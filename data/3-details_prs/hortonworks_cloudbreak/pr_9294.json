{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTEwNTY1NDUw", "number": 9294, "title": "CB-9109 Freeipa launch crippled by missing storage account", "bodyText": "With rebase another small refactoring was necessary:\nazureUtils.getImageNameFromConnectionString(image) was moved into CustomVMImageNameProvider and into AzureImageInfo.\n=====\nOn azure, during freeipa launch, a 1) storage account is created, 2) the corresponding vhd image file is copied into the storage account, and 3) an finally azure managed image is created from the vhd file.\nIf an image already exists, then the whole process should be bypassed. However, if the storage account is deleted but the image exists an error is produced.\nIn this commit the bug is fixed by refactoring.\nSee detailed description in the commit message.", "createdAt": "2020-10-27T08:20:22Z", "url": "https://github.com/hortonworks/cloudbreak/pull/9294", "merged": true, "mergeCommit": {"oid": "f911740327126835c6262e65bc15513765d8a815"}, "closed": true, "closedAt": "2020-11-18T06:35:43Z", "author": {"login": "gergopapi2"}, "timelineItems": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdWtQtggBqjM5Mjc0NzQ4MTY=", "endCursor": "Y3Vyc29yOnYyOpPPAAABddgAUcgBqjQwMDc1MTA3NzM=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "abc58ad126bcf6c7d11814889bcc03c3858f93f5", "author": {"user": {"login": "gergopapi2", "name": "Gergely Papp"}}, "url": "https://github.com/hortonworks/cloudbreak/commit/abc58ad126bcf6c7d11814889bcc03c3858f93f5", "committedDate": "2020-10-27T08:19:05Z", "message": "CB-9109 Freeipa launch crippled by missing storage account\n\nOn azure, during freeipa launch, a 1) storage account is created, 2) the corresponding vhd image file is copied into the storage account, and 3) an finally azure managed image is created from the vhd file.\n\nIf an image already exists, then the whole process should be bypassed. However, if the storage account is deleted but the image exists an error is produced.\n\nIn this commit the bug is fixed by refactoring."}, "afterCommit": {"oid": "e5946d60d2767dd422ab629acc7b5ca586702a51", "author": {"user": {"login": "gergopapi2", "name": "Gergely Papp"}}, "url": "https://github.com/hortonworks/cloudbreak/commit/e5946d60d2767dd422ab629acc7b5ca586702a51", "committedDate": "2020-10-27T18:26:33Z", "message": "CB-9109 Freeipa launch crippled by missing storage account\n\nOn azure, during freeipa launch, a 1) storage account is created, 2) the corresponding vhd image file is copied into the storage account, and 3) an finally azure managed image is created from the vhd file.\n\nIf an image already exists, then the whole process should be bypassed. However, if the storage account is deleted but the image exists an error is produced.\n\nIn this commit the bug is fixed by refactoring."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "e5946d60d2767dd422ab629acc7b5ca586702a51", "author": {"user": {"login": "gergopapi2", "name": "Gergely Papp"}}, "url": "https://github.com/hortonworks/cloudbreak/commit/e5946d60d2767dd422ab629acc7b5ca586702a51", "committedDate": "2020-10-27T18:26:33Z", "message": "CB-9109 Freeipa launch crippled by missing storage account\n\nOn azure, during freeipa launch, a 1) storage account is created, 2) the corresponding vhd image file is copied into the storage account, and 3) an finally azure managed image is created from the vhd file.\n\nIf an image already exists, then the whole process should be bypassed. However, if the storage account is deleted but the image exists an error is produced.\n\nIn this commit the bug is fixed by refactoring."}, "afterCommit": {"oid": "64f657e88470b9298b2c96357a0c03de93bb60ae", "author": {"user": {"login": "gergopapi2", "name": "Gergely Papp"}}, "url": "https://github.com/hortonworks/cloudbreak/commit/64f657e88470b9298b2c96357a0c03de93bb60ae", "committedDate": "2020-10-27T21:25:33Z", "message": "CB-9109 Freeipa launch crippled by missing storage account\n\nOn azure, during freeipa launch, a 1) storage account is created, 2) the corresponding vhd image file is copied into the storage account, and 3) an finally azure managed image is created from the vhd file.\n\nIf an image already exists, then the whole process should be bypassed. However, if the storage account is deleted but the image exists an error is produced.\n\nBeyond the bugfix some refactoring:\n * AzureImageService: methods refactored along single responsibility theorem\n * Functionality to derive image region, name, id was factored into a separate class"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "64f657e88470b9298b2c96357a0c03de93bb60ae", "author": {"user": {"login": "gergopapi2", "name": "Gergely Papp"}}, "url": "https://github.com/hortonworks/cloudbreak/commit/64f657e88470b9298b2c96357a0c03de93bb60ae", "committedDate": "2020-10-27T21:25:33Z", "message": "CB-9109 Freeipa launch crippled by missing storage account\n\nOn azure, during freeipa launch, a 1) storage account is created, 2) the corresponding vhd image file is copied into the storage account, and 3) an finally azure managed image is created from the vhd file.\n\nIf an image already exists, then the whole process should be bypassed. However, if the storage account is deleted but the image exists an error is produced.\n\nBeyond the bugfix some refactoring:\n * AzureImageService: methods refactored along single responsibility theorem\n * Functionality to derive image region, name, id was factored into a separate class"}, "afterCommit": {"oid": "3a6cbe15acdf4086a7a83c6c41980f8d4ad2da4b", "author": {"user": {"login": "gergopapi2", "name": "Gergely Papp"}}, "url": "https://github.com/hortonworks/cloudbreak/commit/3a6cbe15acdf4086a7a83c6c41980f8d4ad2da4b", "committedDate": "2020-10-28T07:17:01Z", "message": "CB-9109 Freeipa launch crippled by missing storage account\n\nOn azure, during freeipa launch, a 1) storage account is created, 2) the corresponding vhd image file is copied into the storage account, 3) and finally an azure managed image is created from the vhd file. If an image already exists, then the whole process should be bypassed. However, an error is produced, if the image exists but the storage account is deleted.\n\nBeyond the bugfix some refactoring that helped to fix the bug easier:\n * AzureImageService: methods refactored along single responsibility theorem\n * Functionality to derive image region, name, id was factored into a separate class"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTI2OTc5NjEx", "url": "https://github.com/hortonworks/cloudbreak/pull/9294#pullrequestreview-526979611", "createdAt": "2020-11-10T08:53:45Z", "commit": {"oid": "3a6cbe15acdf4086a7a83c6c41980f8d4ad2da4b"}, "state": "COMMENTED", "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMFQwODo1Mzo0NlrOHwSGxw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMFQwOTo0ODozNlrOHwUVvw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDM5MDM0Mw==", "bodyText": "Why haven't you extended AzureImage? It has multiple common fields, seems like it has the same purpose.", "url": "https://github.com/hortonworks/cloudbreak/pull/9294#discussion_r520390343", "createdAt": "2020-11-10T08:53:46Z", "author": {"login": "pdarvasi"}, "path": "cloud-azure/src/main/java/com/sequenceiq/cloudbreak/cloud/azure/image/AzureImageDetails.java", "diffHunk": "@@ -0,0 +1,35 @@\n+package com.sequenceiq.cloudbreak.cloud.azure.image;\n+\n+public class AzureImageDetails {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3a6cbe15acdf4086a7a83c6c41980f8d4ad2da4b"}, "originalPosition": 3}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDQyMTA3NQ==", "bodyText": "I'd still prefer isRequested as it check for current status \"REQUESTED\"", "url": "https://github.com/hortonworks/cloudbreak/pull/9294#discussion_r520421075", "createdAt": "2020-11-10T09:39:54Z", "author": {"login": "pdarvasi"}, "path": "cloud-azure/src/main/java/com/sequenceiq/cloudbreak/cloud/azure/image/AzureImageService.java", "diffHunk": "@@ -135,7 +106,7 @@ public CloudResource buildCloudResource(String name, String id, CommonStatus sta\n                 .build();\n     }\n \n-    private boolean isRequested(String imageId) {\n-        return resourcePersistenceRetriever.notifyRetrieve(imageId, CommonStatus.REQUESTED, ResourceType.AZURE_MANAGED_IMAGE).isPresent();\n+    private boolean wasCreateRequested(AzureImageDetails azureImageDetails) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3a6cbe15acdf4086a7a83c6c41980f8d4ad2da4b"}, "originalPosition": 149}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDQyNjI3Mg==", "bodyText": "Generally, I don't like the image --> customImage renames, as it is an Azure Java SDK only term, the object type is \"type\": \"Microsoft.Compute/images\" and in Portal, it is called \"Image\" in Azure Portal, too.\nFurthermore, the custom image term in Cloudbreak is used for a completely different concept. Pls. undo the renames.\nIt would be best to rename all occurrences, regardless of this PR.", "url": "https://github.com/hortonworks/cloudbreak/pull/9294#discussion_r520426272", "createdAt": "2020-11-10T09:47:31Z", "author": {"login": "pdarvasi"}, "path": "cloud-azure/src/main/java/com/sequenceiq/cloudbreak/cloud/azure/image/AzureImageService.java", "diffHunk": "@@ -36,96 +33,70 @@\n     @Inject\n     private PersistenceNotifier persistenceNotifier;\n \n-    @Inject\n-    private AzureResourceIdProviderService azureResourceIdProviderService;\n-\n     @Inject\n     private AzureManagedImageCreationPoller azureManagedImageCreationPoller;\n \n     @Inject\n     private AzureManagedImageService azureManagedImageService;\n \n-    @Inject\n-    private CustomVMImageNameProvider customVMImageNameProvider;\n-\n-    public AzureImage getCustomImageId(String resourceGroup, String fromVhdUri, AuthenticatedContext ac, boolean createIfNotFound, AzureClient client) {\n-        String region = getRegion(ac);\n-        String imageName = getImageName(region, fromVhdUri);\n-        String imageId = getImageId(resourceGroup, client, imageName);\n-        AzureManagedImageCreationCheckerContext checkerContext = new AzureManagedImageCreationCheckerContext(client, resourceGroup, imageName);\n-\n-        if (getCustomImage(resourceGroup, client, imageName).isPresent() || isRequested(imageId)) {\n-            LOGGER.debug(\"Custom image found in '{}' resource group with name '{}'\", resourceGroup, imageName);\n-            azureManagedImageCreationPoller.startPolling(ac, checkerContext);\n-            return new AzureImage(imageId, imageName, true);\n-        } else {\n-            LOGGER.debug(\"Custom image NOT found in '{}' resource group with name '{}', creating it now: {}\", resourceGroup, imageName, createIfNotFound);\n-            if (createIfNotFound) {\n-                saveImage(ac, imageName, imageId);\n-                Optional<VirtualMachineCustomImage> customImage;\n-                try {\n-                    customImage = Optional.of(client.createCustomImage(imageName, resourceGroup, fromVhdUri, region));\n-                } catch (CloudException e) {\n-                    customImage = handleImageCreationException(resourceGroup, ac, client, imageName, imageId, checkerContext, e);\n-                }\n-                return customImage\n-                        .map(image -> createNewAzureImageAndNotify(ac, image))\n-                        .orElseThrow(() -> new CloudConnectorException(\"Failed to create custom image.\"));\n-            } else {\n-                return null;\n-            }\n+    public Optional<AzureImage> findCustomImage(AzureImageDetails azureImageDetails, AzureClient client, AuthenticatedContext ac) {\n+        if (findCustomImage(azureImageDetails, client).isEmpty() && !wasCreateRequested(azureImageDetails)) {\n+            return Optional.empty();\n         }\n+\n+        LOGGER.debug(\"Custom image found in '{}' resource group with name '{}'\", azureImageDetails.getResourceGroup(), azureImageDetails.getImageName());\n+        azureManagedImageCreationPoller.startPolling(ac, new AzureManagedImageCreationCheckerContext(azureImageDetails, client));\n+        return Optional.of(new AzureImage(azureImageDetails.getImageId(), azureImageDetails.getImageName(), true));\n     }\n \n-    private AzureImage createNewAzureImageAndNotify(AuthenticatedContext ac, VirtualMachineCustomImage customImage) {\n-        updateImageStatus(ac, customImage.name(), customImage.id(), CommonStatus.CREATED);\n+    public AzureImage createCustomImage(AzureImageDetails azureImageDetails, String fromVhdUri, AzureClient client, AuthenticatedContext ac) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3a6cbe15acdf4086a7a83c6c41980f8d4ad2da4b"}, "originalPosition": 66}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDQyNjg5NA==", "bodyText": "same: pls. rename the rename", "url": "https://github.com/hortonworks/cloudbreak/pull/9294#discussion_r520426894", "createdAt": "2020-11-10T09:48:30Z", "author": {"login": "pdarvasi"}, "path": "cloud-azure/src/main/java/com/sequenceiq/cloudbreak/cloud/azure/image/AzureImageService.java", "diffHunk": "@@ -36,96 +33,70 @@\n     @Inject\n     private PersistenceNotifier persistenceNotifier;\n \n-    @Inject\n-    private AzureResourceIdProviderService azureResourceIdProviderService;\n-\n     @Inject\n     private AzureManagedImageCreationPoller azureManagedImageCreationPoller;\n \n     @Inject\n     private AzureManagedImageService azureManagedImageService;\n \n-    @Inject\n-    private CustomVMImageNameProvider customVMImageNameProvider;\n-\n-    public AzureImage getCustomImageId(String resourceGroup, String fromVhdUri, AuthenticatedContext ac, boolean createIfNotFound, AzureClient client) {\n-        String region = getRegion(ac);\n-        String imageName = getImageName(region, fromVhdUri);\n-        String imageId = getImageId(resourceGroup, client, imageName);\n-        AzureManagedImageCreationCheckerContext checkerContext = new AzureManagedImageCreationCheckerContext(client, resourceGroup, imageName);\n-\n-        if (getCustomImage(resourceGroup, client, imageName).isPresent() || isRequested(imageId)) {\n-            LOGGER.debug(\"Custom image found in '{}' resource group with name '{}'\", resourceGroup, imageName);\n-            azureManagedImageCreationPoller.startPolling(ac, checkerContext);\n-            return new AzureImage(imageId, imageName, true);\n-        } else {\n-            LOGGER.debug(\"Custom image NOT found in '{}' resource group with name '{}', creating it now: {}\", resourceGroup, imageName, createIfNotFound);\n-            if (createIfNotFound) {\n-                saveImage(ac, imageName, imageId);\n-                Optional<VirtualMachineCustomImage> customImage;\n-                try {\n-                    customImage = Optional.of(client.createCustomImage(imageName, resourceGroup, fromVhdUri, region));\n-                } catch (CloudException e) {\n-                    customImage = handleImageCreationException(resourceGroup, ac, client, imageName, imageId, checkerContext, e);\n-                }\n-                return customImage\n-                        .map(image -> createNewAzureImageAndNotify(ac, image))\n-                        .orElseThrow(() -> new CloudConnectorException(\"Failed to create custom image.\"));\n-            } else {\n-                return null;\n-            }\n+    public Optional<AzureImage> findCustomImage(AzureImageDetails azureImageDetails, AzureClient client, AuthenticatedContext ac) {\n+        if (findCustomImage(azureImageDetails, client).isEmpty() && !wasCreateRequested(azureImageDetails)) {\n+            return Optional.empty();\n         }\n+\n+        LOGGER.debug(\"Custom image found in '{}' resource group with name '{}'\", azureImageDetails.getResourceGroup(), azureImageDetails.getImageName());\n+        azureManagedImageCreationPoller.startPolling(ac, new AzureManagedImageCreationCheckerContext(azureImageDetails, client));\n+        return Optional.of(new AzureImage(azureImageDetails.getImageId(), azureImageDetails.getImageName(), true));\n     }\n \n-    private AzureImage createNewAzureImageAndNotify(AuthenticatedContext ac, VirtualMachineCustomImage customImage) {\n-        updateImageStatus(ac, customImage.name(), customImage.id(), CommonStatus.CREATED);\n+    public AzureImage createCustomImage(AzureImageDetails azureImageDetails, String fromVhdUri, AzureClient client, AuthenticatedContext ac) {\n+        saveCustomImage(ac, azureImageDetails.getImageName(), azureImageDetails.getImageId());\n+        Optional<VirtualMachineCustomImage> customImage;\n+        AzureManagedImageCreationCheckerContext checkerContext = new AzureManagedImageCreationCheckerContext(azureImageDetails, client);\n+        try {\n+            customImage = Optional.of(\n+                    client.createCustomImage(azureImageDetails.getImageName(), azureImageDetails.getResourceGroup(), fromVhdUri, azureImageDetails.getRegion()));\n+        } catch (CloudException e) {\n+            customImage = handleCustomImageCreationException(azureImageDetails, ac, client, checkerContext, e);\n+        }\n+        return customImage\n+                .map(image -> createCustomImageAndNotify(ac, image))\n+                .orElseThrow(() -> new CloudConnectorException(\"Failed to create custom image.\"));\n+    }\n+\n+    private AzureImage createCustomImageAndNotify(AuthenticatedContext ac, VirtualMachineCustomImage customImage) {\n+        updateCustomImageStatus(ac, customImage.name(), customImage.id(), CommonStatus.CREATED);\n         return new AzureImage(customImage.id(), customImage.name(), true);\n     }\n \n-    private Optional<VirtualMachineCustomImage> handleImageCreationException(String resourceGroup, AuthenticatedContext ac, AzureClient client,\n-            String imageName, String imageId, AzureManagedImageCreationCheckerContext checkerContext, CloudException e) {\n+    private Optional<VirtualMachineCustomImage> handleCustomImageCreationException(AzureImageDetails azureImageDetails, AuthenticatedContext ac,\n+            AzureClient client, AzureManagedImageCreationCheckerContext checkerContext, CloudException e) {\n         Optional<VirtualMachineCustomImage> customImage;\n         azureManagedImageCreationPoller.startPolling(ac, checkerContext);\n-        customImage = getCustomImage(resourceGroup, client, imageName);\n+        customImage = findCustomImage(azureImageDetails, client);\n         if (customImage.isEmpty()) {\n             LOGGER.error(\"Failed to create custom image.\", e);\n-            updateImageStatus(ac, imageName, imageId, CommonStatus.FAILED);\n+            updateCustomImageStatus(ac, azureImageDetails.getImageName(), azureImageDetails.getImageId(), CommonStatus.FAILED);\n             throw new CloudConnectorException(e);\n         }\n         return customImage;\n     }\n \n-    private Optional<VirtualMachineCustomImage> getCustomImage(String resourceGroup, AzureClient client, String imageName) {\n-        return azureManagedImageService.findVirtualMachineCustomImage(resourceGroup, imageName, client);\n-    }\n-\n-    private String getImageName(String region, String fromVhdUri) {\n-        return customVMImageNameProvider.get(region, fromVhdUri);\n+    private Optional<VirtualMachineCustomImage> findCustomImage(AzureImageDetails azureImageDetails, AzureClient client) {\n+        return azureManagedImageService.findVirtualMachineCustomImage(azureImageDetails, client);\n     }\n \n-    private void saveImage(AuthenticatedContext ac, String imageName, String imageId) {\n+    private void saveCustomImage(AuthenticatedContext ac, String imageName, String imageId) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3a6cbe15acdf4086a7a83c6c41980f8d4ad2da4b"}, "originalPosition": 114}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDQyNjk0Mw==", "bodyText": "same: pls. rename the rename", "url": "https://github.com/hortonworks/cloudbreak/pull/9294#discussion_r520426943", "createdAt": "2020-11-10T09:48:36Z", "author": {"login": "pdarvasi"}, "path": "cloud-azure/src/main/java/com/sequenceiq/cloudbreak/cloud/azure/image/AzureImageService.java", "diffHunk": "@@ -36,96 +33,70 @@\n     @Inject\n     private PersistenceNotifier persistenceNotifier;\n \n-    @Inject\n-    private AzureResourceIdProviderService azureResourceIdProviderService;\n-\n     @Inject\n     private AzureManagedImageCreationPoller azureManagedImageCreationPoller;\n \n     @Inject\n     private AzureManagedImageService azureManagedImageService;\n \n-    @Inject\n-    private CustomVMImageNameProvider customVMImageNameProvider;\n-\n-    public AzureImage getCustomImageId(String resourceGroup, String fromVhdUri, AuthenticatedContext ac, boolean createIfNotFound, AzureClient client) {\n-        String region = getRegion(ac);\n-        String imageName = getImageName(region, fromVhdUri);\n-        String imageId = getImageId(resourceGroup, client, imageName);\n-        AzureManagedImageCreationCheckerContext checkerContext = new AzureManagedImageCreationCheckerContext(client, resourceGroup, imageName);\n-\n-        if (getCustomImage(resourceGroup, client, imageName).isPresent() || isRequested(imageId)) {\n-            LOGGER.debug(\"Custom image found in '{}' resource group with name '{}'\", resourceGroup, imageName);\n-            azureManagedImageCreationPoller.startPolling(ac, checkerContext);\n-            return new AzureImage(imageId, imageName, true);\n-        } else {\n-            LOGGER.debug(\"Custom image NOT found in '{}' resource group with name '{}', creating it now: {}\", resourceGroup, imageName, createIfNotFound);\n-            if (createIfNotFound) {\n-                saveImage(ac, imageName, imageId);\n-                Optional<VirtualMachineCustomImage> customImage;\n-                try {\n-                    customImage = Optional.of(client.createCustomImage(imageName, resourceGroup, fromVhdUri, region));\n-                } catch (CloudException e) {\n-                    customImage = handleImageCreationException(resourceGroup, ac, client, imageName, imageId, checkerContext, e);\n-                }\n-                return customImage\n-                        .map(image -> createNewAzureImageAndNotify(ac, image))\n-                        .orElseThrow(() -> new CloudConnectorException(\"Failed to create custom image.\"));\n-            } else {\n-                return null;\n-            }\n+    public Optional<AzureImage> findCustomImage(AzureImageDetails azureImageDetails, AzureClient client, AuthenticatedContext ac) {\n+        if (findCustomImage(azureImageDetails, client).isEmpty() && !wasCreateRequested(azureImageDetails)) {\n+            return Optional.empty();\n         }\n+\n+        LOGGER.debug(\"Custom image found in '{}' resource group with name '{}'\", azureImageDetails.getResourceGroup(), azureImageDetails.getImageName());\n+        azureManagedImageCreationPoller.startPolling(ac, new AzureManagedImageCreationCheckerContext(azureImageDetails, client));\n+        return Optional.of(new AzureImage(azureImageDetails.getImageId(), azureImageDetails.getImageName(), true));\n     }\n \n-    private AzureImage createNewAzureImageAndNotify(AuthenticatedContext ac, VirtualMachineCustomImage customImage) {\n-        updateImageStatus(ac, customImage.name(), customImage.id(), CommonStatus.CREATED);\n+    public AzureImage createCustomImage(AzureImageDetails azureImageDetails, String fromVhdUri, AzureClient client, AuthenticatedContext ac) {\n+        saveCustomImage(ac, azureImageDetails.getImageName(), azureImageDetails.getImageId());\n+        Optional<VirtualMachineCustomImage> customImage;\n+        AzureManagedImageCreationCheckerContext checkerContext = new AzureManagedImageCreationCheckerContext(azureImageDetails, client);\n+        try {\n+            customImage = Optional.of(\n+                    client.createCustomImage(azureImageDetails.getImageName(), azureImageDetails.getResourceGroup(), fromVhdUri, azureImageDetails.getRegion()));\n+        } catch (CloudException e) {\n+            customImage = handleCustomImageCreationException(azureImageDetails, ac, client, checkerContext, e);\n+        }\n+        return customImage\n+                .map(image -> createCustomImageAndNotify(ac, image))\n+                .orElseThrow(() -> new CloudConnectorException(\"Failed to create custom image.\"));\n+    }\n+\n+    private AzureImage createCustomImageAndNotify(AuthenticatedContext ac, VirtualMachineCustomImage customImage) {\n+        updateCustomImageStatus(ac, customImage.name(), customImage.id(), CommonStatus.CREATED);\n         return new AzureImage(customImage.id(), customImage.name(), true);\n     }\n \n-    private Optional<VirtualMachineCustomImage> handleImageCreationException(String resourceGroup, AuthenticatedContext ac, AzureClient client,\n-            String imageName, String imageId, AzureManagedImageCreationCheckerContext checkerContext, CloudException e) {\n+    private Optional<VirtualMachineCustomImage> handleCustomImageCreationException(AzureImageDetails azureImageDetails, AuthenticatedContext ac,\n+            AzureClient client, AzureManagedImageCreationCheckerContext checkerContext, CloudException e) {\n         Optional<VirtualMachineCustomImage> customImage;\n         azureManagedImageCreationPoller.startPolling(ac, checkerContext);\n-        customImage = getCustomImage(resourceGroup, client, imageName);\n+        customImage = findCustomImage(azureImageDetails, client);\n         if (customImage.isEmpty()) {\n             LOGGER.error(\"Failed to create custom image.\", e);\n-            updateImageStatus(ac, imageName, imageId, CommonStatus.FAILED);\n+            updateCustomImageStatus(ac, azureImageDetails.getImageName(), azureImageDetails.getImageId(), CommonStatus.FAILED);\n             throw new CloudConnectorException(e);\n         }\n         return customImage;\n     }\n \n-    private Optional<VirtualMachineCustomImage> getCustomImage(String resourceGroup, AzureClient client, String imageName) {\n-        return azureManagedImageService.findVirtualMachineCustomImage(resourceGroup, imageName, client);\n-    }\n-\n-    private String getImageName(String region, String fromVhdUri) {\n-        return customVMImageNameProvider.get(region, fromVhdUri);\n+    private Optional<VirtualMachineCustomImage> findCustomImage(AzureImageDetails azureImageDetails, AzureClient client) {\n+        return azureManagedImageService.findVirtualMachineCustomImage(azureImageDetails, client);\n     }\n \n-    private void saveImage(AuthenticatedContext ac, String imageName, String imageId) {\n+    private void saveCustomImage(AuthenticatedContext ac, String imageName, String imageId) {\n         LOGGER.debug(\"Persisting image with REQUESTED status: {}\", imageId);\n         persistenceNotifier.notifyAllocation(buildCloudResource(imageName, imageId, CommonStatus.REQUESTED), ac.getCloudContext());\n     }\n \n-    private void updateImageStatus(AuthenticatedContext ac, String imageName, String imageId, CommonStatus commonStatus) {\n-        LOGGER.debug(\"Updating image status to {}: {}\", commonStatus.toString(), imageId);\n+    private void updateCustomImageStatus(AuthenticatedContext ac, String imageName, String imageId, CommonStatus commonStatus) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3a6cbe15acdf4086a7a83c6c41980f8d4ad2da4b"}, "originalPosition": 121}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "3a6cbe15acdf4086a7a83c6c41980f8d4ad2da4b", "author": {"user": {"login": "gergopapi2", "name": "Gergely Papp"}}, "url": "https://github.com/hortonworks/cloudbreak/commit/3a6cbe15acdf4086a7a83c6c41980f8d4ad2da4b", "committedDate": "2020-10-28T07:17:01Z", "message": "CB-9109 Freeipa launch crippled by missing storage account\n\nOn azure, during freeipa launch, a 1) storage account is created, 2) the corresponding vhd image file is copied into the storage account, 3) and finally an azure managed image is created from the vhd file. If an image already exists, then the whole process should be bypassed. However, an error is produced, if the image exists but the storage account is deleted.\n\nBeyond the bugfix some refactoring that helped to fix the bug easier:\n * AzureImageService: methods refactored along single responsibility theorem\n * Functionality to derive image region, name, id was factored into a separate class"}, "afterCommit": {"oid": "a17775ddb155fd268caded09f35a807c89e4c311", "author": {"user": {"login": "gergopapi2", "name": "Gergely Papp"}}, "url": "https://github.com/hortonworks/cloudbreak/commit/a17775ddb155fd268caded09f35a807c89e4c311", "committedDate": "2020-11-10T11:37:18Z", "message": "CB-9109 Freeipa launch crippled by missing storage account\n\nOn azure, during freeipa launch, a 1) storage account is created, 2) the corresponding vhd image file is copied into the storage account, 3) and finally an azure managed image is created from the vhd file. If an image already exists, then the whole process should be bypassed. However, an error is produced, if the image exists but the storage account is deleted.\n\nBeyond the bugfix some refactoring that helped to fix the bug easier:\n * AzureImageService: methods refactored along single responsibility theorem\n * Functionality to derive image region, name, id was factored into a separate class"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "151b59310d37f3e18f5d0db0c0f2b82d4c16498a", "author": {"user": {"login": "gergopapi2", "name": "Gergely Papp"}}, "url": "https://github.com/hortonworks/cloudbreak/commit/151b59310d37f3e18f5d0db0c0f2b82d4c16498a", "committedDate": "2020-11-17T20:57:17Z", "message": "CB-9109 Freeipa launch crippled by missing storage account\n\nOn azure, during freeipa launch, a 1) storage account is created, 2) the corresponding vhd image file is copied into the storage account, 3) and finally an azure managed image is created from the vhd file. If an image already exists, then the whole process should be bypassed. However, an error is produced, if the image exists but the storage account is deleted.\n\nBeyond the bugfix some refactoring that helped to fix the bug easier:\n * AzureImageService: methods refactored along single responsibility theorem\n * Functionality to derive image region, name, id was factored into a separate class"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "a17775ddb155fd268caded09f35a807c89e4c311", "author": {"user": {"login": "gergopapi2", "name": "Gergely Papp"}}, "url": "https://github.com/hortonworks/cloudbreak/commit/a17775ddb155fd268caded09f35a807c89e4c311", "committedDate": "2020-11-10T11:37:18Z", "message": "CB-9109 Freeipa launch crippled by missing storage account\n\nOn azure, during freeipa launch, a 1) storage account is created, 2) the corresponding vhd image file is copied into the storage account, 3) and finally an azure managed image is created from the vhd file. If an image already exists, then the whole process should be bypassed. However, an error is produced, if the image exists but the storage account is deleted.\n\nBeyond the bugfix some refactoring that helped to fix the bug easier:\n * AzureImageService: methods refactored along single responsibility theorem\n * Functionality to derive image region, name, id was factored into a separate class"}, "afterCommit": {"oid": "151b59310d37f3e18f5d0db0c0f2b82d4c16498a", "author": {"user": {"login": "gergopapi2", "name": "Gergely Papp"}}, "url": "https://github.com/hortonworks/cloudbreak/commit/151b59310d37f3e18f5d0db0c0f2b82d4c16498a", "committedDate": "2020-11-17T20:57:17Z", "message": "CB-9109 Freeipa launch crippled by missing storage account\n\nOn azure, during freeipa launch, a 1) storage account is created, 2) the corresponding vhd image file is copied into the storage account, 3) and finally an azure managed image is created from the vhd file. If an image already exists, then the whole process should be bypassed. However, an error is produced, if the image exists but the storage account is deleted.\n\nBeyond the bugfix some refactoring that helped to fix the bug easier:\n * AzureImageService: methods refactored along single responsibility theorem\n * Functionality to derive image region, name, id was factored into a separate class"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2069, "cost": 1, "resetAt": "2021-11-01T14:51:55Z"}}}