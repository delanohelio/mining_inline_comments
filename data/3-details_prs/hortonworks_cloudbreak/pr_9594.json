{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTMzODIxMTcw", "number": 9594, "title": "CB-10066 New API methods to add and delete DNS A and CNAME records", "bodyText": "@ianbuss Please check if this API fits your use-case\n@jamisonbennett could you check this? I'm interested in if I'm missing something or you would do differently", "createdAt": "2020-12-07T17:11:13Z", "url": "https://github.com/hortonworks/cloudbreak/pull/9594", "merged": true, "mergeCommit": {"oid": "2152e92dfe62a074c3f476787e5b478695216c36"}, "closed": true, "closedAt": "2020-12-16T17:10:33Z", "author": {"login": "lacikaaa"}, "timelineItems": {"totalCount": 13, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdj5UNjgBqjQwODA5MDc5NDQ=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdmvbxnAFqTU1MzcxMzE1Mg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "967fb9f1cec4676044de04c3726eeba01208d123", "author": {"user": {"login": "lacikaaa", "name": "Mihaly Laszlo Molnar"}}, "url": "https://github.com/hortonworks/cloudbreak/commit/967fb9f1cec4676044de04c3726eeba01208d123", "committedDate": "2020-12-07T17:06:18Z", "message": "CB-10066 New API methods to add and delete DNS A and CNAME records"}, "afterCommit": {"oid": "9d17732e8482011fabf73437127efddd444f1e44", "author": {"user": {"login": "lacikaaa", "name": "Mihaly Laszlo Molnar"}}, "url": "https://github.com/hortonworks/cloudbreak/commit/9d17732e8482011fabf73437127efddd444f1e44", "committedDate": "2020-12-07T17:50:35Z", "message": "CB-10066 New API methods to add and delete DNS A and CNAME records"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ3MTE3ODE0", "url": "https://github.com/hortonworks/cloudbreak/pull/9594#pullrequestreview-547117814", "createdAt": "2020-12-08T11:11:56Z", "commit": {"oid": "9d17732e8482011fabf73437127efddd444f1e44"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOFQxMToxMTo1NlrOIBUPxQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOFQxMToxMTo1NlrOIBUPxQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODI1MTIwNQ==", "bodyText": "Typo: recorc -> record.", "url": "https://github.com/hortonworks/cloudbreak/pull/9594#discussion_r538251205", "createdAt": "2020-12-08T11:11:56Z", "author": {"login": "lajosrodek"}, "path": "freeipa-api/src/main/java/com/sequenceiq/freeipa/api/v1/dns/doc/DnsModelDescription.java", "diffHunk": "@@ -0,0 +1,15 @@\n+package com.sequenceiq.freeipa.api.v1.dns.doc;\n+\n+public final class DnsModelDescription {\n+    public static final String DNS_RECORD = \"DNS record name without the domain. eg. 'ipaserver' from 'ipaserver.clouder.site'\";\n+\n+    public static final String DNS_ZONE = \"It's the domain. Like if your FQDN is ipaserver.clouder.site, it's 'cloudera.site'. \"\n+            + \"'168.192.in-addr.arpa' for a reverse record like '5.1.168.192.in-addr.arpa'\";\n+\n+    public static final String CNAME_TARGET_FQDN = \"The fully qualified domain name of the host the CNAME should point to.\";\n+\n+    public static final String CREATE_REVERSE = \"Tries to create a reverse point for the recorc (PTR). Only if reverse zone already exists\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9d17732e8482011fabf73437127efddd444f1e44"}, "originalPosition": 11}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ3MjEwODI0", "url": "https://github.com/hortonworks/cloudbreak/pull/9594#pullrequestreview-547210824", "createdAt": "2020-12-08T13:00:59Z", "commit": {"oid": "9d17732e8482011fabf73437127efddd444f1e44"}, "state": "COMMENTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOFQxMzowMDo1OVrOIBZtnQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOFQxMzowNDo1MlrOIBZ8Ww==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODM0MDc2NQ==", "bodyText": "Are the zones expected to have a trailing \".\"? Technically this is what an FQDN means but I think this should be called out if it is required since its a common misconception.", "url": "https://github.com/hortonworks/cloudbreak/pull/9594#discussion_r538340765", "createdAt": "2020-12-08T13:00:59Z", "author": {"login": "jamisonbennett"}, "path": "freeipa-api/src/main/java/com/sequenceiq/freeipa/api/v1/dns/doc/DnsModelDescription.java", "diffHunk": "@@ -0,0 +1,15 @@\n+package com.sequenceiq.freeipa.api.v1.dns.doc;\n+\n+public final class DnsModelDescription {\n+    public static final String DNS_RECORD = \"DNS record name without the domain. eg. 'ipaserver' from 'ipaserver.clouder.site'\";\n+\n+    public static final String DNS_ZONE = \"It's the domain. Like if your FQDN is ipaserver.clouder.site, it's 'cloudera.site'. \"\n+            + \"'168.192.in-addr.arpa' for a reverse record like '5.1.168.192.in-addr.arpa'\";\n+\n+    public static final String CNAME_TARGET_FQDN = \"The fully qualified domain name of the host the CNAME should point to.\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9d17732e8482011fabf73437127efddd444f1e44"}, "originalPosition": 9}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODM0MjMzOA==", "bodyText": "Should we also add an API to query the a/cname records?", "url": "https://github.com/hortonworks/cloudbreak/pull/9594#discussion_r538342338", "createdAt": "2020-12-08T13:02:35Z", "author": {"login": "jamisonbennett"}, "path": "freeipa-api/src/main/java/com/sequenceiq/freeipa/api/v1/dns/DnsV1Endpoint.java", "diffHunk": "@@ -75,4 +77,34 @@ void deleteDnsZoneBySubnetId(@QueryParam(\"environment\") @NotEmpty String environ\n     @ApiOperation(value = DnsOperationDescriptions.DELETE_DNS_RECORD_BY_FQDN, produces = MediaType.APPLICATION_JSON, notes = FreeIpaNotes.FREEIPA_NOTES,\n             nickname = \"deleteDnsRecordByFqdnV1\")\n     void deleteDnsRecordsByFqdn(@QueryParam(\"environment\") @NotEmpty String environmentCrn, @QueryParam(\"fqdn\") @NotEmpty List<String> fqdns);\n+\n+    @POST\n+    @Path(\"record/a\")\n+    @Produces(MediaType.APPLICATION_JSON)\n+    @ApiOperation(value = DnsOperationDescriptions.ADD_DNS_A_RECORD_BY_FQDN, produces = MediaType.APPLICATION_JSON, notes = FreeIpaNotes.FREEIPA_NOTES,\n+            nickname = \"addDnsARecordV1\")\n+    void addDnsARecord(@Valid AddDnsARecordRequest request);\n+\n+    @DELETE\n+    @Path(\"record/a\")\n+    @Produces(MediaType.APPLICATION_JSON)\n+    @ApiOperation(value = DnsOperationDescriptions.DELETE_DNS_A_RECORD, produces = MediaType.APPLICATION_JSON, notes = FreeIpaNotes.FREEIPA_NOTES,\n+            nickname = \"deleteDnsARecordV1\")\n+    void deleteDnsARecord(@QueryParam(\"environment\") @NotEmpty String environmentCrn, @QueryParam(\"dnsZone\") @NotEmpty String dnsZone,\n+            @QueryParam(\"record\") @NotEmpty String record);\n+\n+    @POST\n+    @Path(\"record/cname\")\n+    @Produces(MediaType.APPLICATION_JSON)\n+    @ApiOperation(value = DnsOperationDescriptions.ADD_DNS_A_RECORD_BY_FQDN, produces = MediaType.APPLICATION_JSON, notes = FreeIpaNotes.FREEIPA_NOTES,\n+            nickname = \"addDnsCnameRecordV1\")\n+    void addDnsCnameRecord(@Valid AddDnsCnameRecordRequest request);\n+\n+    @DELETE\n+    @Path(\"record/cname\")\n+    @Produces(MediaType.APPLICATION_JSON)\n+    @ApiOperation(value = DnsOperationDescriptions.DELETE_DNS_CNAME_RECORD, produces = MediaType.APPLICATION_JSON, notes = FreeIpaNotes.FREEIPA_NOTES,\n+            nickname = \"deleteDnsCnameRecordV1\")\n+    void deleteDnsCnameRecord(@QueryParam(\"environment\") @NotEmpty String environmentCrn, @QueryParam(\"dnsZone\") @NotEmpty String dnsZone,\n+            @QueryParam(\"record\") @NotEmpty String record);\n }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9d17732e8482011fabf73437127efddd444f1e44"}, "originalPosition": 43}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODM0NDUzOQ==", "bodyText": "It looks like this commit just adds the API and not the implementation. Is that intended?", "url": "https://github.com/hortonworks/cloudbreak/pull/9594#discussion_r538344539", "createdAt": "2020-12-08T13:04:52Z", "author": {"login": "jamisonbennett"}, "path": "freeipa/src/main/java/com/sequenceiq/freeipa/controller/DnsV1Controller.java", "diffHunk": "@@ -126,4 +128,44 @@ public void deleteDnsRecordsByFqdn(@ResourceCrn @NotEmpty String environmentCrn,\n             throw new FreeIpaClientExceptionWrapper(e);\n         }\n     }\n+\n+    @Override\n+    @CheckPermissionByRequestProperty(path = \"environmentCrn\", type = CRN, action = EDIT_ENVIRONMENT)\n+    @Retryable(value = RetryableFreeIpaClientException.class,\n+            maxAttemptsExpression = RetryableFreeIpaClientException.MAX_RETRIES_EXPRESSION,\n+            backoff = @Backoff(delayExpression = RetryableFreeIpaClientException.DELAY_EXPRESSION,\n+                    multiplierExpression = RetryableFreeIpaClientException.MULTIPLIER_EXPRESSION))\n+    public void addDnsARecord(@RequestObject @Valid AddDnsARecordRequest request) {\n+\n+    }\n+\n+    @Override\n+    @CheckPermissionByResourceCrn(action = EDIT_ENVIRONMENT)\n+    @Retryable(value = RetryableFreeIpaClientException.class,\n+            maxAttemptsExpression = RetryableFreeIpaClientException.MAX_RETRIES_EXPRESSION,\n+            backoff = @Backoff(delayExpression = RetryableFreeIpaClientException.DELAY_EXPRESSION,\n+                    multiplierExpression = RetryableFreeIpaClientException.MULTIPLIER_EXPRESSION))\n+    public void deleteDnsARecord(@ResourceCrn @NotEmpty String environmentCrn, @NotEmpty String dnsZone, @NotEmpty String record) {\n+\n+    }\n+\n+    @Override\n+    @CheckPermissionByRequestProperty(path = \"environmentCrn\", type = CRN, action = EDIT_ENVIRONMENT)\n+    @Retryable(value = RetryableFreeIpaClientException.class,\n+            maxAttemptsExpression = RetryableFreeIpaClientException.MAX_RETRIES_EXPRESSION,\n+            backoff = @Backoff(delayExpression = RetryableFreeIpaClientException.DELAY_EXPRESSION,\n+                    multiplierExpression = RetryableFreeIpaClientException.MULTIPLIER_EXPRESSION))\n+    public void addDnsCnameRecord(@RequestObject @Valid AddDnsCnameRecordRequest request) {\n+\n+    }\n+\n+    @Override\n+    @CheckPermissionByResourceCrn(action = EDIT_ENVIRONMENT)\n+    @Retryable(value = RetryableFreeIpaClientException.class,\n+            maxAttemptsExpression = RetryableFreeIpaClientException.MAX_RETRIES_EXPRESSION,\n+            backoff = @Backoff(delayExpression = RetryableFreeIpaClientException.DELAY_EXPRESSION,\n+                    multiplierExpression = RetryableFreeIpaClientException.MULTIPLIER_EXPRESSION))\n+    public void deleteDnsCnameRecord(@ResourceCrn @NotEmpty String environmentCrn, @NotEmpty String dnsZone, @NotEmpty String record) {\n+\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9d17732e8482011fabf73437127efddd444f1e44"}, "originalPosition": 52}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "9d17732e8482011fabf73437127efddd444f1e44", "author": {"user": {"login": "lacikaaa", "name": "Mihaly Laszlo Molnar"}}, "url": "https://github.com/hortonworks/cloudbreak/commit/9d17732e8482011fabf73437127efddd444f1e44", "committedDate": "2020-12-07T17:50:35Z", "message": "CB-10066 New API methods to add and delete DNS A and CNAME records"}, "afterCommit": {"oid": "3f09f0fd0ede68ae26878d8db29491580ae42d22", "author": {"user": {"login": "lacikaaa", "name": "Mihaly Laszlo Molnar"}}, "url": "https://github.com/hortonworks/cloudbreak/commit/3f09f0fd0ede68ae26878d8db29491580ae42d22", "committedDate": "2020-12-08T16:19:52Z", "message": "CB-10066 New API methods to add and delete DNS A and CNAME records"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "3f09f0fd0ede68ae26878d8db29491580ae42d22", "author": {"user": {"login": "lacikaaa", "name": "Mihaly Laszlo Molnar"}}, "url": "https://github.com/hortonworks/cloudbreak/commit/3f09f0fd0ede68ae26878d8db29491580ae42d22", "committedDate": "2020-12-08T16:19:52Z", "message": "CB-10066 New API methods to add and delete DNS A and CNAME records"}, "afterCommit": {"oid": "80b24a6c8f85f0c8343c355c76eda004eb30b549", "author": {"user": {"login": "lacikaaa", "name": "Mihaly Laszlo Molnar"}}, "url": "https://github.com/hortonworks/cloudbreak/commit/80b24a6c8f85f0c8343c355c76eda004eb30b549", "committedDate": "2020-12-09T15:09:31Z", "message": "CB-10066 New API methods to add and delete DNS A and CNAME records"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ4Mjg3ODUx", "url": "https://github.com/hortonworks/cloudbreak/pull/9594#pullrequestreview-548287851", "createdAt": "2020-12-09T15:15:26Z", "commit": {"oid": "3f09f0fd0ede68ae26878d8db29491580ae42d22"}, "state": "COMMENTED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "80b24a6c8f85f0c8343c355c76eda004eb30b549", "author": {"user": {"login": "lacikaaa", "name": "Mihaly Laszlo Molnar"}}, "url": "https://github.com/hortonworks/cloudbreak/commit/80b24a6c8f85f0c8343c355c76eda004eb30b549", "committedDate": "2020-12-09T15:09:31Z", "message": "CB-10066 New API methods to add and delete DNS A and CNAME records"}, "afterCommit": {"oid": "de61d8ff7b2c0a2c38e6e19bdf78d2f4f3078227", "author": {"user": {"login": "lacikaaa", "name": "Mihaly Laszlo Molnar"}}, "url": "https://github.com/hortonworks/cloudbreak/commit/de61d8ff7b2c0a2c38e6e19bdf78d2f4f3078227", "committedDate": "2020-12-14T12:30:18Z", "message": "CB-10066 New API methods to add and delete DNS A and CNAME records\n\nWith the new endpoints other services will be able to create A and\nCNAME records in FreeIPA or delete existing ones. If DNS zone is not\ndefined, the default will be used, which is the environment domain.\nIf a record already exists with the same value then the request\nconsidered successful.\nIf the record exists but has a different value, an error will be\nthrown.\nAlso if the zone is defined but not exists, an error would be thrown.\nWhen deleting a record which not exists is considered a successful\noperation."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTUyNTM2Njg1", "url": "https://github.com/hortonworks/cloudbreak/pull/9594#pullrequestreview-552536685", "createdAt": "2020-12-15T14:49:51Z", "commit": {"oid": "de61d8ff7b2c0a2c38e6e19bdf78d2f4f3078227"}, "state": "COMMENTED", "comments": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNVQxNDo0OTo1MVrOIGPNPQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNVQxNjozNDowOVrOIGUiGA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzQxMTUxNw==", "bodyText": "nit: conatin -> contain", "url": "https://github.com/hortonworks/cloudbreak/pull/9594#discussion_r543411517", "createdAt": "2020-12-15T14:49:51Z", "author": {"login": "jamisonbennett"}, "path": "freeipa-api/src/main/java/com/sequenceiq/freeipa/api/v1/dns/model/AddDnsCnameRecordRequest.java", "diffHunk": "@@ -0,0 +1,85 @@\n+package com.sequenceiq.freeipa.api.v1.dns.model;\n+\n+import static com.sequenceiq.freeipa.api.v1.dns.model.DnsRecordRegexpPatterns.DNS_CNAME_MSG;\n+import static com.sequenceiq.freeipa.api.v1.dns.model.DnsRecordRegexpPatterns.DNS_CNAME_PATTERN;\n+import static com.sequenceiq.freeipa.api.v1.dns.model.DnsRecordRegexpPatterns.DNS_ZONE_MSG;\n+import static com.sequenceiq.freeipa.api.v1.dns.model.DnsRecordRegexpPatterns.DNS_ZONE_PATTERN;\n+\n+import javax.validation.constraints.NotEmpty;\n+import javax.validation.constraints.NotNull;\n+import javax.validation.constraints.Pattern;\n+\n+import com.fasterxml.jackson.annotation.JsonIgnoreProperties;\n+import com.fasterxml.jackson.annotation.JsonInclude;\n+import com.sequenceiq.freeipa.api.v1.dns.doc.DnsModelDescription;\n+import com.sequenceiq.service.api.doc.ModelDescriptions;\n+\n+import io.swagger.annotations.ApiModel;\n+import io.swagger.annotations.ApiModelProperty;\n+\n+@ApiModel(\"AddDnsCnameRecordV1Request\")\n+@JsonIgnoreProperties(ignoreUnknown = true)\n+@JsonInclude(JsonInclude.Include.NON_NULL)\n+public class AddDnsCnameRecordRequest {\n+\n+    @NotNull\n+    @ApiModelProperty(value = ModelDescriptions.ENVIRONMENT_CRN, required = true)\n+    private String environmentCrn;\n+\n+    @NotEmpty\n+    @ApiModelProperty(value = DnsModelDescription.CNAME, required = true)\n+    @Pattern(regexp = DNS_CNAME_PATTERN, message = DNS_CNAME_MSG)\n+    private String cname;\n+\n+    @ApiModelProperty(DnsModelDescription.DNS_ZONE)\n+    @Pattern(regexp = DNS_ZONE_PATTERN, message = DNS_ZONE_MSG)\n+    private String dnsZone;\n+\n+    @NotEmpty\n+    @ApiModelProperty(value = DnsModelDescription.CNAME_TARGET_FQDN, required = true)\n+    @Pattern(regexp = \"^[a-zA-Z0-9]+[a-zA-Z0-9-\\\\.]*[a-zA-Z0-9]+$\",\n+            message = \"Target FQDN must be valid. Might start with '*.' and can conatin alphanumeric characters, dash and dot.\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "de61d8ff7b2c0a2c38e6e19bdf78d2f4f3078227"}, "originalPosition": 41}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzQxMjEwOQ==", "bodyText": "nit: conatin -> contain", "url": "https://github.com/hortonworks/cloudbreak/pull/9594#discussion_r543412109", "createdAt": "2020-12-15T14:50:33Z", "author": {"login": "jamisonbennett"}, "path": "freeipa-api/src/main/java/com/sequenceiq/freeipa/api/v1/dns/model/DnsRecordRegexpPatterns.java", "diffHunk": "@@ -0,0 +1,19 @@\n+package com.sequenceiq.freeipa.api.v1.dns.model;\n+\n+public final class DnsRecordRegexpPatterns {\n+\n+    public static final String DNS_ZONE_PATTERN = \"^[a-zA-Z0-9-\\\\.]+$\";\n+\n+    public static final String DNS_ZONE_MSG = \"DNS zone must be valid. It can conatin alphanumeric characters, dash and dot.\";\n+\n+    public static final String DNS_CNAME_PATTERN = \"^(\\\\*\\\\.)?[a-zA-Z0-9]+[a-zA-Z0-9-\\\\.]*[a-zA-Z0-9]+$\";\n+\n+    public static final String DNS_CNAME_MSG = \"CNAME must be valid. Might start with '*.' and can conatin alphanumeric characters, dash and dot.\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "de61d8ff7b2c0a2c38e6e19bdf78d2f4f3078227"}, "originalPosition": 11}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzQxMjI4Mg==", "bodyText": "nit: conatin -> contain", "url": "https://github.com/hortonworks/cloudbreak/pull/9594#discussion_r543412282", "createdAt": "2020-12-15T14:50:47Z", "author": {"login": "jamisonbennett"}, "path": "freeipa-api/src/main/java/com/sequenceiq/freeipa/api/v1/dns/model/DnsRecordRegexpPatterns.java", "diffHunk": "@@ -0,0 +1,19 @@\n+package com.sequenceiq.freeipa.api.v1.dns.model;\n+\n+public final class DnsRecordRegexpPatterns {\n+\n+    public static final String DNS_ZONE_PATTERN = \"^[a-zA-Z0-9-\\\\.]+$\";\n+\n+    public static final String DNS_ZONE_MSG = \"DNS zone must be valid. It can conatin alphanumeric characters, dash and dot.\";\n+\n+    public static final String DNS_CNAME_PATTERN = \"^(\\\\*\\\\.)?[a-zA-Z0-9]+[a-zA-Z0-9-\\\\.]*[a-zA-Z0-9]+$\";\n+\n+    public static final String DNS_CNAME_MSG = \"CNAME must be valid. Might start with '*.' and can conatin alphanumeric characters, dash and dot.\";\n+\n+    public static final String DNS_HOSTNAME_PATTERN = \"^[a-zA-Z0-9]+[a-zA-Z0-9-\\\\.]*[a-zA-Z0-9]+$\";\n+\n+    public static final String DNS_HOSTNAME_MSG = \"Hostname must be valid. Can conatin alphanumeric characters, dash and dot.\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "de61d8ff7b2c0a2c38e6e19bdf78d2f4f3078227"}, "originalPosition": 15}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzQxMjUwNw==", "bodyText": "nit: conatin -> contain", "url": "https://github.com/hortonworks/cloudbreak/pull/9594#discussion_r543412507", "createdAt": "2020-12-15T14:51:02Z", "author": {"login": "jamisonbennett"}, "path": "freeipa-api/src/main/java/com/sequenceiq/freeipa/api/v1/dns/model/DnsRecordRegexpPatterns.java", "diffHunk": "@@ -0,0 +1,19 @@\n+package com.sequenceiq.freeipa.api.v1.dns.model;\n+\n+public final class DnsRecordRegexpPatterns {\n+\n+    public static final String DNS_ZONE_PATTERN = \"^[a-zA-Z0-9-\\\\.]+$\";\n+\n+    public static final String DNS_ZONE_MSG = \"DNS zone must be valid. It can conatin alphanumeric characters, dash and dot.\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "de61d8ff7b2c0a2c38e6e19bdf78d2f4f3078227"}, "originalPosition": 7}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzQ5NjQwNA==", "bodyText": "I think you might want the following regex: \"^[a-zA-Z0-9]+[a-zA-Z0-9.-]*[a-zA-Z0-9.]+$\"\n\n\nThe dash after the 9 is invalid. Put it at the front/end of the bracketed section so that it doesn't form a range.\n\n\nAssuming the \"-\" is removed, this regex allows \"\\\" in FQDNs:\n\n\necho www\\\\google.com | egrep \"^[a-zA-Z0-9]+[a-zA-Z0-9\\\\.]*[a-zA-Z0-9]+$\"\n\n\nnit: This regex technically doesn't allow a trailing \".\" and that technically is required to be a part of an FQDN (but it is very rare that that is actually used).", "url": "https://github.com/hortonworks/cloudbreak/pull/9594#discussion_r543496404", "createdAt": "2020-12-15T16:31:11Z", "author": {"login": "jamisonbennett"}, "path": "freeipa-api/src/main/java/com/sequenceiq/freeipa/api/v1/dns/model/AddDnsCnameRecordRequest.java", "diffHunk": "@@ -0,0 +1,85 @@\n+package com.sequenceiq.freeipa.api.v1.dns.model;\n+\n+import static com.sequenceiq.freeipa.api.v1.dns.model.DnsRecordRegexpPatterns.DNS_CNAME_MSG;\n+import static com.sequenceiq.freeipa.api.v1.dns.model.DnsRecordRegexpPatterns.DNS_CNAME_PATTERN;\n+import static com.sequenceiq.freeipa.api.v1.dns.model.DnsRecordRegexpPatterns.DNS_ZONE_MSG;\n+import static com.sequenceiq.freeipa.api.v1.dns.model.DnsRecordRegexpPatterns.DNS_ZONE_PATTERN;\n+\n+import javax.validation.constraints.NotEmpty;\n+import javax.validation.constraints.NotNull;\n+import javax.validation.constraints.Pattern;\n+\n+import com.fasterxml.jackson.annotation.JsonIgnoreProperties;\n+import com.fasterxml.jackson.annotation.JsonInclude;\n+import com.sequenceiq.freeipa.api.v1.dns.doc.DnsModelDescription;\n+import com.sequenceiq.service.api.doc.ModelDescriptions;\n+\n+import io.swagger.annotations.ApiModel;\n+import io.swagger.annotations.ApiModelProperty;\n+\n+@ApiModel(\"AddDnsCnameRecordV1Request\")\n+@JsonIgnoreProperties(ignoreUnknown = true)\n+@JsonInclude(JsonInclude.Include.NON_NULL)\n+public class AddDnsCnameRecordRequest {\n+\n+    @NotNull\n+    @ApiModelProperty(value = ModelDescriptions.ENVIRONMENT_CRN, required = true)\n+    private String environmentCrn;\n+\n+    @NotEmpty\n+    @ApiModelProperty(value = DnsModelDescription.CNAME, required = true)\n+    @Pattern(regexp = DNS_CNAME_PATTERN, message = DNS_CNAME_MSG)\n+    private String cname;\n+\n+    @ApiModelProperty(DnsModelDescription.DNS_ZONE)\n+    @Pattern(regexp = DNS_ZONE_PATTERN, message = DNS_ZONE_MSG)\n+    private String dnsZone;\n+\n+    @NotEmpty\n+    @ApiModelProperty(value = DnsModelDescription.CNAME_TARGET_FQDN, required = true)\n+    @Pattern(regexp = \"^[a-zA-Z0-9]+[a-zA-Z0-9-\\\\.]*[a-zA-Z0-9]+$\",", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "de61d8ff7b2c0a2c38e6e19bdf78d2f4f3078227"}, "originalPosition": 40}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzQ5ODA5Mw==", "bodyText": "I think this might be the same rules as above: \"^[a-zA-Z0-9]+[a-zA-Z0-9.-]*[a-zA-Z0-9.]+$\"", "url": "https://github.com/hortonworks/cloudbreak/pull/9594#discussion_r543498093", "createdAt": "2020-12-15T16:33:16Z", "author": {"login": "jamisonbennett"}, "path": "freeipa-api/src/main/java/com/sequenceiq/freeipa/api/v1/dns/model/DnsRecordRegexpPatterns.java", "diffHunk": "@@ -0,0 +1,19 @@\n+package com.sequenceiq.freeipa.api.v1.dns.model;\n+\n+public final class DnsRecordRegexpPatterns {\n+\n+    public static final String DNS_ZONE_PATTERN = \"^[a-zA-Z0-9-\\\\.]+$\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "de61d8ff7b2c0a2c38e6e19bdf78d2f4f3078227"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzQ5ODc3Ng==", "bodyText": "Same as above: \"^[a-zA-Z0-9]+[a-zA-Z0-9.-]*[a-zA-Z0-9.]+$\"", "url": "https://github.com/hortonworks/cloudbreak/pull/9594#discussion_r543498776", "createdAt": "2020-12-15T16:34:09Z", "author": {"login": "jamisonbennett"}, "path": "freeipa-api/src/main/java/com/sequenceiq/freeipa/api/v1/dns/model/DnsRecordRegexpPatterns.java", "diffHunk": "@@ -0,0 +1,19 @@\n+package com.sequenceiq.freeipa.api.v1.dns.model;\n+\n+public final class DnsRecordRegexpPatterns {\n+\n+    public static final String DNS_ZONE_PATTERN = \"^[a-zA-Z0-9-\\\\.]+$\";\n+\n+    public static final String DNS_ZONE_MSG = \"DNS zone must be valid. It can conatin alphanumeric characters, dash and dot.\";\n+\n+    public static final String DNS_CNAME_PATTERN = \"^(\\\\*\\\\.)?[a-zA-Z0-9]+[a-zA-Z0-9-\\\\.]*[a-zA-Z0-9]+$\";\n+\n+    public static final String DNS_CNAME_MSG = \"CNAME must be valid. Might start with '*.' and can conatin alphanumeric characters, dash and dot.\";\n+\n+    public static final String DNS_HOSTNAME_PATTERN = \"^[a-zA-Z0-9]+[a-zA-Z0-9-\\\\.]*[a-zA-Z0-9]+$\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "de61d8ff7b2c0a2c38e6e19bdf78d2f4f3078227"}, "originalPosition": 13}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTUyODQ0OTgw", "url": "https://github.com/hortonworks/cloudbreak/pull/9594#pullrequestreview-552844980", "createdAt": "2020-12-15T20:32:53Z", "commit": {"oid": "de61d8ff7b2c0a2c38e6e19bdf78d2f4f3078227"}, "state": "COMMENTED", "comments": {"totalCount": 10, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNVQyMDozMjo1NFrOIGexfw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNVQyMTowNjowNlrOIGf9RA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzY2NjU1OQ==", "bodyText": "ADD_DNS_A_RECORD_BY_FQDN -> ADD_DNS_CNAME_RECORD_BY_FQDN", "url": "https://github.com/hortonworks/cloudbreak/pull/9594#discussion_r543666559", "createdAt": "2020-12-15T20:32:54Z", "author": {"login": "pdarvasi"}, "path": "freeipa-api/src/main/java/com/sequenceiq/freeipa/api/v1/dns/DnsV1Endpoint.java", "diffHunk": "@@ -75,4 +85,36 @@ void deleteDnsZoneBySubnetId(@QueryParam(\"environment\") @NotEmpty String environ\n     @ApiOperation(value = DnsOperationDescriptions.DELETE_DNS_RECORD_BY_FQDN, produces = MediaType.APPLICATION_JSON, notes = FreeIpaNotes.FREEIPA_NOTES,\n             nickname = \"deleteDnsRecordByFqdnV1\")\n     void deleteDnsRecordsByFqdn(@QueryParam(\"environment\") @NotEmpty String environmentCrn, @QueryParam(\"fqdn\") @NotEmpty List<String> fqdns);\n+\n+    @POST\n+    @Path(\"record/a\")\n+    @Produces(MediaType.APPLICATION_JSON)\n+    @ApiOperation(value = DnsOperationDescriptions.ADD_DNS_A_RECORD_BY_FQDN, produces = MediaType.APPLICATION_JSON, notes = FreeIpaNotes.FREEIPA_NOTES,\n+            nickname = \"addDnsARecordV1\")\n+    void addDnsARecord(@Valid @NotNull AddDnsARecordRequest request);\n+\n+    @DELETE\n+    @Path(\"record/a\")\n+    @Produces(MediaType.APPLICATION_JSON)\n+    @ApiOperation(value = DnsOperationDescriptions.DELETE_DNS_A_RECORD, produces = MediaType.APPLICATION_JSON, notes = FreeIpaNotes.FREEIPA_NOTES,\n+            nickname = \"deleteDnsARecordV1\")\n+    void deleteDnsARecord(@QueryParam(\"environment\") @NotEmpty String environmentCrn,\n+            @QueryParam(\"dnsZone\") @Pattern(regexp = DNS_ZONE_PATTERN, message = DNS_ZONE_MSG) String dnsZone,\n+            @QueryParam(\"hostname\") @NotEmpty @Pattern(regexp = DNS_HOSTNAME_PATTERN, message = DNS_HOSTNAME_MSG) String hostname);\n+\n+    @POST\n+    @Path(\"record/cname\")\n+    @Produces(MediaType.APPLICATION_JSON)\n+    @ApiOperation(value = DnsOperationDescriptions.ADD_DNS_A_RECORD_BY_FQDN, produces = MediaType.APPLICATION_JSON, notes = FreeIpaNotes.FREEIPA_NOTES,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "de61d8ff7b2c0a2c38e6e19bdf78d2f4f3078227"}, "originalPosition": 52}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzY3MDE1OQ==", "bodyText": "like -> eg. to match the other descriptions format.\nclouder -> cloudera", "url": "https://github.com/hortonworks/cloudbreak/pull/9594#discussion_r543670159", "createdAt": "2020-12-15T20:39:14Z", "author": {"login": "pdarvasi"}, "path": "freeipa-api/src/main/java/com/sequenceiq/freeipa/api/v1/dns/doc/DnsModelDescription.java", "diffHunk": "@@ -0,0 +1,19 @@\n+package com.sequenceiq.freeipa.api.v1.dns.doc;\n+\n+public final class DnsModelDescription {\n+    public static final String CNAME = \"DNS name without the domain. eg. 'ipaserver' from 'ipaserver.clouder.site'\";\n+\n+    public static final String HOSTNAME = \"Hostname name without the domain. eg. 'ipaserver' from 'ipaserver.clouder.site'\";\n+\n+    public static final String IP = \"The IP address of the host the A record should point to. Only IPv4\";\n+\n+    public static final String DNS_ZONE = \"It's the domain. Like if your FQDN is ipaserver.clouder.site, it's 'cloudera.site'. \"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "de61d8ff7b2c0a2c38e6e19bdf78d2f4f3078227"}, "originalPosition": 10}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzY3MTE0Mg==", "bodyText": "Reverse pointer created -> Reverse pointer is created", "url": "https://github.com/hortonworks/cloudbreak/pull/9594#discussion_r543671142", "createdAt": "2020-12-15T20:40:52Z", "author": {"login": "pdarvasi"}, "path": "freeipa-api/src/main/java/com/sequenceiq/freeipa/api/v1/dns/doc/DnsOperationDescriptions.java", "diffHunk": "@@ -7,6 +7,12 @@\n     public static final String DELETE_DNS_ZONE_BY_SUBNET = \"Deletes reverse DNS Zone entry by subnet CIDR\";\n     public static final String DELETE_DNS_ZONE_BY_SUBNET_ID = \"Deletes reverse DNS Zone entry by subnet ID\";\n     public static final String DELETE_DNS_RECORD_BY_FQDN = \"Deletes all related A and PTR DNS record\";\n+    public static final String ADD_DNS_A_RECORD_BY_FQDN = \"Creates a DNS A record with the value in the defined zone if zone exists. If zone not specified \"\n+            + \"default zone will be used. Reverse pointer created if requested and reverse zone exists.\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "de61d8ff7b2c0a2c38e6e19bdf78d2f4f3078227"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzY3ODc0NA==", "bodyText": "question: why do you get the client 4 times here?", "url": "https://github.com/hortonworks/cloudbreak/pull/9594#discussion_r543678744", "createdAt": "2020-12-15T20:53:57Z", "author": {"login": "pdarvasi"}, "path": "freeipa/src/main/java/com/sequenceiq/freeipa/service/freeipa/dns/DnsRecordService.java", "diffHunk": "@@ -35,16 +48,18 @@\n     @Inject\n     private StackService stackService;\n \n-    public void deleteDnsRecordByFqdn(String environmentCrn, String accountId,  List<String> fqdns) throws FreeIpaClientException {\n-        Stack stack = stackService.getByEnvironmentCrnAndAccountId(environmentCrn, accountId);\n-        MDCBuilder.buildMdcContext(stack);\n-        FreeIpa freeIpa = freeIpaService.findByStack(stack);\n-        FreeIpaClient freeIpaClient = freeIpaClientFactory.getFreeIpaClientForStack(stack);\n-        for (DnsZone dnsZone : freeIpaClient.findAllDnsZone()) {\n+    @Retryable(value = RetryableFreeIpaClientException.class,\n+            maxAttemptsExpression = RetryableFreeIpaClientException.MAX_RETRIES_EXPRESSION,\n+            backoff = @Backoff(delayExpression = RetryableFreeIpaClientException.DELAY_EXPRESSION,\n+                    multiplierExpression = RetryableFreeIpaClientException.MULTIPLIER_EXPRESSION))\n+    @Measure(DnsRecordService.class)\n+    public void deleteDnsRecordByFqdn(String environmentCrn, String accountId, List<String> fqdns) throws FreeIpaClientException {\n+        FreeIpaAndClient freeIpaAndClient = createFreeIpaAndClient(environmentCrn, accountId);\n+        for (DnsZone dnsZone : freeIpaAndClient.getClient().findAllDnsZone()) {\n             LOGGER.debug(\"Looking for records in zone [{}]\", dnsZone.getIdnsname());\n-            Set<DnsRecord> allDnsRecordsInZone = freeIpaClient.findAllDnsRecordInZone(dnsZone.getIdnsname());\n-            deleteRegularRecords(freeIpaClient, dnsZone, allDnsRecordsInZone, fqdns, freeIpa.getDomain());\n-            deleteSrvRecords(freeIpaClient, dnsZone, allDnsRecordsInZone, fqdns);\n+            Set<DnsRecord> allDnsRecordsInZone = freeIpaAndClient.getClient().findAllDnsRecordInZone(dnsZone.getIdnsname());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "de61d8ff7b2c0a2c38e6e19bdf78d2f4f3078227"}, "originalPosition": 54}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzY4MTkzMw==", "bodyText": "don't you want to log srvRecords here, too?", "url": "https://github.com/hortonworks/cloudbreak/pull/9594#discussion_r543681933", "createdAt": "2020-12-15T20:59:08Z", "author": {"login": "pdarvasi"}, "path": "freeipa/src/main/java/com/sequenceiq/freeipa/service/freeipa/dns/DnsRecordService.java", "diffHunk": "@@ -55,23 +70,142 @@ private void deleteRegularRecords(FreeIpaClient freeIpaClient, DnsZone dnsZone,\n                 .collect(Collectors.toSet());\n         for (DnsRecord dnsRecord : recordsToDelete) {\n             LOGGER.info(\"Delete DNS record [{}] in zone [{}]\", dnsRecord, dnsZone);\n-            freeIpaClient.deleteDnsRecord(dnsRecord.getIdnsname(), dnsZone.getIdnsname());\n+            ignoreNotFoundException(() -> freeIpaClient.deleteDnsRecord(dnsRecord.getIdnsname(), dnsZone.getIdnsname()),\n+                    \"DNS record [{}] not found in zone [{}]\", dnsRecord, dnsZone);\n         }\n     }\n \n     private void deleteSrvRecords(FreeIpaClient freeIpaClient, DnsZone dnsZone, Set<DnsRecord> allDnsRecordsInZone, List<String> fqdns)\n             throws FreeIpaClientException {\n         Set<DnsRecord> srvRecordsToDelete = allDnsRecordsInZone.stream()\n-                .filter(record -> fqdns.stream().anyMatch(fqdn -> record.isHostRelatedSrvRecord(fqdn)))\n+                .filter(record -> fqdns.stream().anyMatch(record::isHostRelatedSrvRecord))\n                 .collect(Collectors.toSet());\n         for (DnsRecord dnsRecord : srvRecordsToDelete) {\n             for (String fqdn : fqdns) {\n                 List<String> srvRecords = dnsRecord.getHostRelatedSrvRecords(fqdn);\n                 if (!srvRecords.isEmpty()) {\n                     LOGGER.info(\"Delete DNS SRV record [{}] for [{}] in zone [{}]\", dnsRecord.getIdnsname(), fqdn, dnsZone);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "de61d8ff7b2c0a2c38e6e19bdf78d2f4f3078227"}, "originalPosition": 80}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzY4MzU1MQ==", "bodyText": "a log line would be nice here", "url": "https://github.com/hortonworks/cloudbreak/pull/9594#discussion_r543683551", "createdAt": "2020-12-15T21:01:56Z", "author": {"login": "pdarvasi"}, "path": "freeipa/src/main/java/com/sequenceiq/freeipa/service/freeipa/dns/DnsRecordService.java", "diffHunk": "@@ -55,23 +70,142 @@ private void deleteRegularRecords(FreeIpaClient freeIpaClient, DnsZone dnsZone,\n                 .collect(Collectors.toSet());\n         for (DnsRecord dnsRecord : recordsToDelete) {\n             LOGGER.info(\"Delete DNS record [{}] in zone [{}]\", dnsRecord, dnsZone);\n-            freeIpaClient.deleteDnsRecord(dnsRecord.getIdnsname(), dnsZone.getIdnsname());\n+            ignoreNotFoundException(() -> freeIpaClient.deleteDnsRecord(dnsRecord.getIdnsname(), dnsZone.getIdnsname()),\n+                    \"DNS record [{}] not found in zone [{}]\", dnsRecord, dnsZone);\n         }\n     }\n \n     private void deleteSrvRecords(FreeIpaClient freeIpaClient, DnsZone dnsZone, Set<DnsRecord> allDnsRecordsInZone, List<String> fqdns)\n             throws FreeIpaClientException {\n         Set<DnsRecord> srvRecordsToDelete = allDnsRecordsInZone.stream()\n-                .filter(record -> fqdns.stream().anyMatch(fqdn -> record.isHostRelatedSrvRecord(fqdn)))\n+                .filter(record -> fqdns.stream().anyMatch(record::isHostRelatedSrvRecord))\n                 .collect(Collectors.toSet());\n         for (DnsRecord dnsRecord : srvRecordsToDelete) {\n             for (String fqdn : fqdns) {\n                 List<String> srvRecords = dnsRecord.getHostRelatedSrvRecords(fqdn);\n                 if (!srvRecords.isEmpty()) {\n                     LOGGER.info(\"Delete DNS SRV record [{}] for [{}] in zone [{}]\", dnsRecord.getIdnsname(), fqdn, dnsZone);\n-                    freeIpaClient.deleteDnsSrvRecord(dnsRecord.getIdnsname(), dnsZone.getIdnsname(), srvRecords);\n+                    ignoreNotFoundException(() -> freeIpaClient.deleteDnsSrvRecord(dnsRecord.getIdnsname(), dnsZone.getIdnsname(), srvRecords),\n+                            \"DNS SRV record [{}] for [{}] not found in zone [{}]\", dnsRecord.getIdnsname(), fqdn, dnsZone);\n                 }\n             }\n         }\n     }\n+\n+    private FreeIpaAndClient createFreeIpaAndClient(String environmentCrn, String accountId) throws FreeIpaClientException {\n+        Stack stack = stackService.getByEnvironmentCrnAndAccountId(environmentCrn, accountId);\n+        MDCBuilder.buildMdcContext(stack);\n+        FreeIpa freeIpa = freeIpaService.findByStack(stack);\n+        FreeIpaClient freeIpaClient = freeIpaClientFactory.getFreeIpaClientForStack(stack);\n+        return new FreeIpaAndClient(freeIpa, freeIpaClient);\n+    }\n+\n+    @Retryable(value = RetryableFreeIpaClientException.class,\n+            maxAttemptsExpression = RetryableFreeIpaClientException.MAX_RETRIES_EXPRESSION,\n+            backoff = @Backoff(delayExpression = RetryableFreeIpaClientException.DELAY_EXPRESSION,\n+                    multiplierExpression = RetryableFreeIpaClientException.MULTIPLIER_EXPRESSION))\n+    @Measure(DnsRecordService.class)\n+    public void addDnsARecord(String accountId, @Valid AddDnsARecordRequest request) throws FreeIpaClientException {\n+        FreeIpaAndClient freeIpaAndClient = createFreeIpaAndClient(request.getEnvironmentCrn(), accountId);\n+        LOGGER.info(\"Processing AddDnsARecordRequest: {}\", request);\n+        String zone = calculateZone(request.getDnsZone(), freeIpaAndClient);\n+        Optional<DnsRecord> dnsRecord = ignoreNotFoundExceptionWithValue(() -> freeIpaAndClient.getClient().showDnsRecord(zone, request.getHostname()), null);\n+        if (dnsRecord.isEmpty()) {\n+            createDnsARecord(freeIpaAndClient.getClient(), zone, request.getHostname(), request.getIp(), request.isCreateReverse());\n+        } else {\n+            validateExistingARecordMatchesRequested(request.getIp(), dnsRecord.get());\n+        }\n+    }\n+\n+    private String calculateZone(String zoneFromRequest, FreeIpaAndClient freeIpaAndClient) throws FreeIpaClientException {\n+        Optional<String> optionalZone = Optional.ofNullable(zoneFromRequest);\n+        String zone = optionalZone.orElse(freeIpaAndClient.getFreeIpa().getDomain());\n+        boolean providedZoneDifferentThanDefault = !freeIpaAndClient.getFreeIpa().getDomain().equals(StringUtils.removeEnd(zone, \".\"));\n+        if (optionalZone.isPresent() && providedZoneDifferentThanDefault) {\n+            validateZoneExists(optionalZone.get(), freeIpaAndClient.getClient());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "de61d8ff7b2c0a2c38e6e19bdf78d2f4f3078227"}, "originalPosition": 119}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzY4NTAyNw==", "bodyText": "1 string would be enough instead of 2", "url": "https://github.com/hortonworks/cloudbreak/pull/9594#discussion_r543685027", "createdAt": "2020-12-15T21:04:29Z", "author": {"login": "pdarvasi"}, "path": "freeipa/src/main/java/com/sequenceiq/freeipa/service/freeipa/dns/DnsRecordService.java", "diffHunk": "@@ -55,23 +70,142 @@ private void deleteRegularRecords(FreeIpaClient freeIpaClient, DnsZone dnsZone,\n                 .collect(Collectors.toSet());\n         for (DnsRecord dnsRecord : recordsToDelete) {\n             LOGGER.info(\"Delete DNS record [{}] in zone [{}]\", dnsRecord, dnsZone);\n-            freeIpaClient.deleteDnsRecord(dnsRecord.getIdnsname(), dnsZone.getIdnsname());\n+            ignoreNotFoundException(() -> freeIpaClient.deleteDnsRecord(dnsRecord.getIdnsname(), dnsZone.getIdnsname()),\n+                    \"DNS record [{}] not found in zone [{}]\", dnsRecord, dnsZone);\n         }\n     }\n \n     private void deleteSrvRecords(FreeIpaClient freeIpaClient, DnsZone dnsZone, Set<DnsRecord> allDnsRecordsInZone, List<String> fqdns)\n             throws FreeIpaClientException {\n         Set<DnsRecord> srvRecordsToDelete = allDnsRecordsInZone.stream()\n-                .filter(record -> fqdns.stream().anyMatch(fqdn -> record.isHostRelatedSrvRecord(fqdn)))\n+                .filter(record -> fqdns.stream().anyMatch(record::isHostRelatedSrvRecord))\n                 .collect(Collectors.toSet());\n         for (DnsRecord dnsRecord : srvRecordsToDelete) {\n             for (String fqdn : fqdns) {\n                 List<String> srvRecords = dnsRecord.getHostRelatedSrvRecords(fqdn);\n                 if (!srvRecords.isEmpty()) {\n                     LOGGER.info(\"Delete DNS SRV record [{}] for [{}] in zone [{}]\", dnsRecord.getIdnsname(), fqdn, dnsZone);\n-                    freeIpaClient.deleteDnsSrvRecord(dnsRecord.getIdnsname(), dnsZone.getIdnsname(), srvRecords);\n+                    ignoreNotFoundException(() -> freeIpaClient.deleteDnsSrvRecord(dnsRecord.getIdnsname(), dnsZone.getIdnsname(), srvRecords),\n+                            \"DNS SRV record [{}] for [{}] not found in zone [{}]\", dnsRecord.getIdnsname(), fqdn, dnsZone);\n                 }\n             }\n         }\n     }\n+\n+    private FreeIpaAndClient createFreeIpaAndClient(String environmentCrn, String accountId) throws FreeIpaClientException {\n+        Stack stack = stackService.getByEnvironmentCrnAndAccountId(environmentCrn, accountId);\n+        MDCBuilder.buildMdcContext(stack);\n+        FreeIpa freeIpa = freeIpaService.findByStack(stack);\n+        FreeIpaClient freeIpaClient = freeIpaClientFactory.getFreeIpaClientForStack(stack);\n+        return new FreeIpaAndClient(freeIpa, freeIpaClient);\n+    }\n+\n+    @Retryable(value = RetryableFreeIpaClientException.class,\n+            maxAttemptsExpression = RetryableFreeIpaClientException.MAX_RETRIES_EXPRESSION,\n+            backoff = @Backoff(delayExpression = RetryableFreeIpaClientException.DELAY_EXPRESSION,\n+                    multiplierExpression = RetryableFreeIpaClientException.MULTIPLIER_EXPRESSION))\n+    @Measure(DnsRecordService.class)\n+    public void addDnsARecord(String accountId, @Valid AddDnsARecordRequest request) throws FreeIpaClientException {\n+        FreeIpaAndClient freeIpaAndClient = createFreeIpaAndClient(request.getEnvironmentCrn(), accountId);\n+        LOGGER.info(\"Processing AddDnsARecordRequest: {}\", request);\n+        String zone = calculateZone(request.getDnsZone(), freeIpaAndClient);\n+        Optional<DnsRecord> dnsRecord = ignoreNotFoundExceptionWithValue(() -> freeIpaAndClient.getClient().showDnsRecord(zone, request.getHostname()), null);\n+        if (dnsRecord.isEmpty()) {\n+            createDnsARecord(freeIpaAndClient.getClient(), zone, request.getHostname(), request.getIp(), request.isCreateReverse());\n+        } else {\n+            validateExistingARecordMatchesRequested(request.getIp(), dnsRecord.get());\n+        }\n+    }\n+\n+    private String calculateZone(String zoneFromRequest, FreeIpaAndClient freeIpaAndClient) throws FreeIpaClientException {\n+        Optional<String> optionalZone = Optional.ofNullable(zoneFromRequest);\n+        String zone = optionalZone.orElse(freeIpaAndClient.getFreeIpa().getDomain());\n+        boolean providedZoneDifferentThanDefault = !freeIpaAndClient.getFreeIpa().getDomain().equals(StringUtils.removeEnd(zone, \".\"));\n+        if (optionalZone.isPresent() && providedZoneDifferentThanDefault) {\n+            validateZoneExists(optionalZone.get(), freeIpaAndClient.getClient());\n+        }\n+        return zone;\n+    }\n+\n+    private void validateZoneExists(String zone, FreeIpaClient client) throws FreeIpaClientException {\n+        Set<DnsZone> allDnsZone = client.findAllDnsZone();\n+        String zoneInFreeIpaFormat = StringUtils.appendIfMissing(zone, \".\");\n+        boolean zoneMissing = allDnsZone.stream()\n+                .map(DnsZone::getIdnsname)\n+                .noneMatch(zoneFromIpa -> zoneFromIpa.equals(zoneInFreeIpaFormat));\n+        if (zoneMissing) {\n+            String msg = String.format(\"Zone [%s] doesn't exists\", zone);\n+            LOGGER.info(msg);\n+            throw new BadRequestException(msg);\n+        }\n+    }\n+\n+    private void validateExistingARecordMatchesRequested(String ip, DnsRecord record) {\n+        LOGGER.debug(\"Validating already existing record: {}\", record);\n+        if (!record.isARecord()) {\n+            LOGGER.info(\"Record already exists and it's not an A record\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "de61d8ff7b2c0a2c38e6e19bdf78d2f4f3078227"}, "originalPosition": 140}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzY4NTA3OA==", "bodyText": "1 string would be enough instead of 2", "url": "https://github.com/hortonworks/cloudbreak/pull/9594#discussion_r543685078", "createdAt": "2020-12-15T21:04:35Z", "author": {"login": "pdarvasi"}, "path": "freeipa/src/main/java/com/sequenceiq/freeipa/service/freeipa/dns/DnsRecordService.java", "diffHunk": "@@ -55,23 +70,142 @@ private void deleteRegularRecords(FreeIpaClient freeIpaClient, DnsZone dnsZone,\n                 .collect(Collectors.toSet());\n         for (DnsRecord dnsRecord : recordsToDelete) {\n             LOGGER.info(\"Delete DNS record [{}] in zone [{}]\", dnsRecord, dnsZone);\n-            freeIpaClient.deleteDnsRecord(dnsRecord.getIdnsname(), dnsZone.getIdnsname());\n+            ignoreNotFoundException(() -> freeIpaClient.deleteDnsRecord(dnsRecord.getIdnsname(), dnsZone.getIdnsname()),\n+                    \"DNS record [{}] not found in zone [{}]\", dnsRecord, dnsZone);\n         }\n     }\n \n     private void deleteSrvRecords(FreeIpaClient freeIpaClient, DnsZone dnsZone, Set<DnsRecord> allDnsRecordsInZone, List<String> fqdns)\n             throws FreeIpaClientException {\n         Set<DnsRecord> srvRecordsToDelete = allDnsRecordsInZone.stream()\n-                .filter(record -> fqdns.stream().anyMatch(fqdn -> record.isHostRelatedSrvRecord(fqdn)))\n+                .filter(record -> fqdns.stream().anyMatch(record::isHostRelatedSrvRecord))\n                 .collect(Collectors.toSet());\n         for (DnsRecord dnsRecord : srvRecordsToDelete) {\n             for (String fqdn : fqdns) {\n                 List<String> srvRecords = dnsRecord.getHostRelatedSrvRecords(fqdn);\n                 if (!srvRecords.isEmpty()) {\n                     LOGGER.info(\"Delete DNS SRV record [{}] for [{}] in zone [{}]\", dnsRecord.getIdnsname(), fqdn, dnsZone);\n-                    freeIpaClient.deleteDnsSrvRecord(dnsRecord.getIdnsname(), dnsZone.getIdnsname(), srvRecords);\n+                    ignoreNotFoundException(() -> freeIpaClient.deleteDnsSrvRecord(dnsRecord.getIdnsname(), dnsZone.getIdnsname(), srvRecords),\n+                            \"DNS SRV record [{}] for [{}] not found in zone [{}]\", dnsRecord.getIdnsname(), fqdn, dnsZone);\n                 }\n             }\n         }\n     }\n+\n+    private FreeIpaAndClient createFreeIpaAndClient(String environmentCrn, String accountId) throws FreeIpaClientException {\n+        Stack stack = stackService.getByEnvironmentCrnAndAccountId(environmentCrn, accountId);\n+        MDCBuilder.buildMdcContext(stack);\n+        FreeIpa freeIpa = freeIpaService.findByStack(stack);\n+        FreeIpaClient freeIpaClient = freeIpaClientFactory.getFreeIpaClientForStack(stack);\n+        return new FreeIpaAndClient(freeIpa, freeIpaClient);\n+    }\n+\n+    @Retryable(value = RetryableFreeIpaClientException.class,\n+            maxAttemptsExpression = RetryableFreeIpaClientException.MAX_RETRIES_EXPRESSION,\n+            backoff = @Backoff(delayExpression = RetryableFreeIpaClientException.DELAY_EXPRESSION,\n+                    multiplierExpression = RetryableFreeIpaClientException.MULTIPLIER_EXPRESSION))\n+    @Measure(DnsRecordService.class)\n+    public void addDnsARecord(String accountId, @Valid AddDnsARecordRequest request) throws FreeIpaClientException {\n+        FreeIpaAndClient freeIpaAndClient = createFreeIpaAndClient(request.getEnvironmentCrn(), accountId);\n+        LOGGER.info(\"Processing AddDnsARecordRequest: {}\", request);\n+        String zone = calculateZone(request.getDnsZone(), freeIpaAndClient);\n+        Optional<DnsRecord> dnsRecord = ignoreNotFoundExceptionWithValue(() -> freeIpaAndClient.getClient().showDnsRecord(zone, request.getHostname()), null);\n+        if (dnsRecord.isEmpty()) {\n+            createDnsARecord(freeIpaAndClient.getClient(), zone, request.getHostname(), request.getIp(), request.isCreateReverse());\n+        } else {\n+            validateExistingARecordMatchesRequested(request.getIp(), dnsRecord.get());\n+        }\n+    }\n+\n+    private String calculateZone(String zoneFromRequest, FreeIpaAndClient freeIpaAndClient) throws FreeIpaClientException {\n+        Optional<String> optionalZone = Optional.ofNullable(zoneFromRequest);\n+        String zone = optionalZone.orElse(freeIpaAndClient.getFreeIpa().getDomain());\n+        boolean providedZoneDifferentThanDefault = !freeIpaAndClient.getFreeIpa().getDomain().equals(StringUtils.removeEnd(zone, \".\"));\n+        if (optionalZone.isPresent() && providedZoneDifferentThanDefault) {\n+            validateZoneExists(optionalZone.get(), freeIpaAndClient.getClient());\n+        }\n+        return zone;\n+    }\n+\n+    private void validateZoneExists(String zone, FreeIpaClient client) throws FreeIpaClientException {\n+        Set<DnsZone> allDnsZone = client.findAllDnsZone();\n+        String zoneInFreeIpaFormat = StringUtils.appendIfMissing(zone, \".\");\n+        boolean zoneMissing = allDnsZone.stream()\n+                .map(DnsZone::getIdnsname)\n+                .noneMatch(zoneFromIpa -> zoneFromIpa.equals(zoneInFreeIpaFormat));\n+        if (zoneMissing) {\n+            String msg = String.format(\"Zone [%s] doesn't exists\", zone);\n+            LOGGER.info(msg);\n+            throw new BadRequestException(msg);\n+        }\n+    }\n+\n+    private void validateExistingARecordMatchesRequested(String ip, DnsRecord record) {\n+        LOGGER.debug(\"Validating already existing record: {}\", record);\n+        if (!record.isARecord()) {\n+            LOGGER.info(\"Record already exists and it's not an A record\");\n+            throw new DnsRecordConflictException(\"Record already exists and it's not an A record\");\n+        } else if (!record.getArecord().contains(ip)) {\n+            LOGGER.info(\"Record already exists and the IP doesn't match\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "de61d8ff7b2c0a2c38e6e19bdf78d2f4f3078227"}, "originalPosition": 143}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzY4NTg2OA==", "bodyText": "1 string would be enough instead of 2", "url": "https://github.com/hortonworks/cloudbreak/pull/9594#discussion_r543685868", "createdAt": "2020-12-15T21:06:00Z", "author": {"login": "pdarvasi"}, "path": "freeipa/src/main/java/com/sequenceiq/freeipa/service/freeipa/dns/DnsRecordService.java", "diffHunk": "@@ -55,23 +70,142 @@ private void deleteRegularRecords(FreeIpaClient freeIpaClient, DnsZone dnsZone,\n                 .collect(Collectors.toSet());\n         for (DnsRecord dnsRecord : recordsToDelete) {\n             LOGGER.info(\"Delete DNS record [{}] in zone [{}]\", dnsRecord, dnsZone);\n-            freeIpaClient.deleteDnsRecord(dnsRecord.getIdnsname(), dnsZone.getIdnsname());\n+            ignoreNotFoundException(() -> freeIpaClient.deleteDnsRecord(dnsRecord.getIdnsname(), dnsZone.getIdnsname()),\n+                    \"DNS record [{}] not found in zone [{}]\", dnsRecord, dnsZone);\n         }\n     }\n \n     private void deleteSrvRecords(FreeIpaClient freeIpaClient, DnsZone dnsZone, Set<DnsRecord> allDnsRecordsInZone, List<String> fqdns)\n             throws FreeIpaClientException {\n         Set<DnsRecord> srvRecordsToDelete = allDnsRecordsInZone.stream()\n-                .filter(record -> fqdns.stream().anyMatch(fqdn -> record.isHostRelatedSrvRecord(fqdn)))\n+                .filter(record -> fqdns.stream().anyMatch(record::isHostRelatedSrvRecord))\n                 .collect(Collectors.toSet());\n         for (DnsRecord dnsRecord : srvRecordsToDelete) {\n             for (String fqdn : fqdns) {\n                 List<String> srvRecords = dnsRecord.getHostRelatedSrvRecords(fqdn);\n                 if (!srvRecords.isEmpty()) {\n                     LOGGER.info(\"Delete DNS SRV record [{}] for [{}] in zone [{}]\", dnsRecord.getIdnsname(), fqdn, dnsZone);\n-                    freeIpaClient.deleteDnsSrvRecord(dnsRecord.getIdnsname(), dnsZone.getIdnsname(), srvRecords);\n+                    ignoreNotFoundException(() -> freeIpaClient.deleteDnsSrvRecord(dnsRecord.getIdnsname(), dnsZone.getIdnsname(), srvRecords),\n+                            \"DNS SRV record [{}] for [{}] not found in zone [{}]\", dnsRecord.getIdnsname(), fqdn, dnsZone);\n                 }\n             }\n         }\n     }\n+\n+    private FreeIpaAndClient createFreeIpaAndClient(String environmentCrn, String accountId) throws FreeIpaClientException {\n+        Stack stack = stackService.getByEnvironmentCrnAndAccountId(environmentCrn, accountId);\n+        MDCBuilder.buildMdcContext(stack);\n+        FreeIpa freeIpa = freeIpaService.findByStack(stack);\n+        FreeIpaClient freeIpaClient = freeIpaClientFactory.getFreeIpaClientForStack(stack);\n+        return new FreeIpaAndClient(freeIpa, freeIpaClient);\n+    }\n+\n+    @Retryable(value = RetryableFreeIpaClientException.class,\n+            maxAttemptsExpression = RetryableFreeIpaClientException.MAX_RETRIES_EXPRESSION,\n+            backoff = @Backoff(delayExpression = RetryableFreeIpaClientException.DELAY_EXPRESSION,\n+                    multiplierExpression = RetryableFreeIpaClientException.MULTIPLIER_EXPRESSION))\n+    @Measure(DnsRecordService.class)\n+    public void addDnsARecord(String accountId, @Valid AddDnsARecordRequest request) throws FreeIpaClientException {\n+        FreeIpaAndClient freeIpaAndClient = createFreeIpaAndClient(request.getEnvironmentCrn(), accountId);\n+        LOGGER.info(\"Processing AddDnsARecordRequest: {}\", request);\n+        String zone = calculateZone(request.getDnsZone(), freeIpaAndClient);\n+        Optional<DnsRecord> dnsRecord = ignoreNotFoundExceptionWithValue(() -> freeIpaAndClient.getClient().showDnsRecord(zone, request.getHostname()), null);\n+        if (dnsRecord.isEmpty()) {\n+            createDnsARecord(freeIpaAndClient.getClient(), zone, request.getHostname(), request.getIp(), request.isCreateReverse());\n+        } else {\n+            validateExistingARecordMatchesRequested(request.getIp(), dnsRecord.get());\n+        }\n+    }\n+\n+    private String calculateZone(String zoneFromRequest, FreeIpaAndClient freeIpaAndClient) throws FreeIpaClientException {\n+        Optional<String> optionalZone = Optional.ofNullable(zoneFromRequest);\n+        String zone = optionalZone.orElse(freeIpaAndClient.getFreeIpa().getDomain());\n+        boolean providedZoneDifferentThanDefault = !freeIpaAndClient.getFreeIpa().getDomain().equals(StringUtils.removeEnd(zone, \".\"));\n+        if (optionalZone.isPresent() && providedZoneDifferentThanDefault) {\n+            validateZoneExists(optionalZone.get(), freeIpaAndClient.getClient());\n+        }\n+        return zone;\n+    }\n+\n+    private void validateZoneExists(String zone, FreeIpaClient client) throws FreeIpaClientException {\n+        Set<DnsZone> allDnsZone = client.findAllDnsZone();\n+        String zoneInFreeIpaFormat = StringUtils.appendIfMissing(zone, \".\");\n+        boolean zoneMissing = allDnsZone.stream()\n+                .map(DnsZone::getIdnsname)\n+                .noneMatch(zoneFromIpa -> zoneFromIpa.equals(zoneInFreeIpaFormat));\n+        if (zoneMissing) {\n+            String msg = String.format(\"Zone [%s] doesn't exists\", zone);\n+            LOGGER.info(msg);\n+            throw new BadRequestException(msg);\n+        }\n+    }\n+\n+    private void validateExistingARecordMatchesRequested(String ip, DnsRecord record) {\n+        LOGGER.debug(\"Validating already existing record: {}\", record);\n+        if (!record.isARecord()) {\n+            LOGGER.info(\"Record already exists and it's not an A record\");\n+            throw new DnsRecordConflictException(\"Record already exists and it's not an A record\");\n+        } else if (!record.getArecord().contains(ip)) {\n+            LOGGER.info(\"Record already exists and the IP doesn't match\");\n+            throw new DnsRecordConflictException(\"Record already exists and the IP doesn't match\");\n+        } else {\n+            LOGGER.info(\"A record already exists and matches with requested. Nothing to do\");\n+        }\n+    }\n+\n+    private void createDnsARecord(FreeIpaClient client, String zone, String hostname, String ip, boolean createReverse) throws FreeIpaClientException {\n+        LOGGER.info(\"Creating A record in zone [{}] with hostname [{}] with IP [{}]. Create reverse set to [{}]\",\n+                zone, hostname, ip, createReverse);\n+        DnsRecord record = client.addDnsARecord(zone, hostname, ip, createReverse);\n+        LOGGER.info(\"A record [{}] pointing to [{}] is created successfully. Created record: {}\", hostname, ip, record);\n+    }\n+\n+    @Retryable(value = RetryableFreeIpaClientException.class,\n+            maxAttemptsExpression = RetryableFreeIpaClientException.MAX_RETRIES_EXPRESSION,\n+            backoff = @Backoff(delayExpression = RetryableFreeIpaClientException.DELAY_EXPRESSION,\n+                    multiplierExpression = RetryableFreeIpaClientException.MULTIPLIER_EXPRESSION))\n+    @Measure(DnsRecordService.class)\n+    public void addDnsCnameRecord(String accountId, AddDnsCnameRecordRequest request) throws FreeIpaClientException {\n+        FreeIpaAndClient freeIpaAndClient = createFreeIpaAndClient(request.getEnvironmentCrn(), accountId);\n+        String zone = calculateZone(request.getDnsZone(), freeIpaAndClient);\n+        Optional<DnsRecord> dnsRecord = ignoreNotFoundExceptionWithValue(() -> freeIpaAndClient.getClient().showDnsRecord(zone, request.getCname()), null);\n+        if (dnsRecord.isEmpty()) {\n+            createDnsCnameRecord(freeIpaAndClient.getClient(), zone, request.getCname(), request.getTargetFqdn());\n+        } else {\n+            validateExistingCnameRecordMatches(dnsRecord.get(), request.getTargetFqdn());\n+        }\n+    }\n+\n+    private void validateExistingCnameRecordMatches(DnsRecord record, String targetFqdn) {\n+        LOGGER.debug(\"Validating already existing record: {}\", record);\n+        if (!record.isCnameRecord()) {\n+            LOGGER.info(\"Record already exists and it's not a CNAME record\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "de61d8ff7b2c0a2c38e6e19bdf78d2f4f3078227"}, "originalPosition": 176}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzY4NTk1Ng==", "bodyText": "1 string would be enough instead of 2", "url": "https://github.com/hortonworks/cloudbreak/pull/9594#discussion_r543685956", "createdAt": "2020-12-15T21:06:06Z", "author": {"login": "pdarvasi"}, "path": "freeipa/src/main/java/com/sequenceiq/freeipa/service/freeipa/dns/DnsRecordService.java", "diffHunk": "@@ -55,23 +70,142 @@ private void deleteRegularRecords(FreeIpaClient freeIpaClient, DnsZone dnsZone,\n                 .collect(Collectors.toSet());\n         for (DnsRecord dnsRecord : recordsToDelete) {\n             LOGGER.info(\"Delete DNS record [{}] in zone [{}]\", dnsRecord, dnsZone);\n-            freeIpaClient.deleteDnsRecord(dnsRecord.getIdnsname(), dnsZone.getIdnsname());\n+            ignoreNotFoundException(() -> freeIpaClient.deleteDnsRecord(dnsRecord.getIdnsname(), dnsZone.getIdnsname()),\n+                    \"DNS record [{}] not found in zone [{}]\", dnsRecord, dnsZone);\n         }\n     }\n \n     private void deleteSrvRecords(FreeIpaClient freeIpaClient, DnsZone dnsZone, Set<DnsRecord> allDnsRecordsInZone, List<String> fqdns)\n             throws FreeIpaClientException {\n         Set<DnsRecord> srvRecordsToDelete = allDnsRecordsInZone.stream()\n-                .filter(record -> fqdns.stream().anyMatch(fqdn -> record.isHostRelatedSrvRecord(fqdn)))\n+                .filter(record -> fqdns.stream().anyMatch(record::isHostRelatedSrvRecord))\n                 .collect(Collectors.toSet());\n         for (DnsRecord dnsRecord : srvRecordsToDelete) {\n             for (String fqdn : fqdns) {\n                 List<String> srvRecords = dnsRecord.getHostRelatedSrvRecords(fqdn);\n                 if (!srvRecords.isEmpty()) {\n                     LOGGER.info(\"Delete DNS SRV record [{}] for [{}] in zone [{}]\", dnsRecord.getIdnsname(), fqdn, dnsZone);\n-                    freeIpaClient.deleteDnsSrvRecord(dnsRecord.getIdnsname(), dnsZone.getIdnsname(), srvRecords);\n+                    ignoreNotFoundException(() -> freeIpaClient.deleteDnsSrvRecord(dnsRecord.getIdnsname(), dnsZone.getIdnsname(), srvRecords),\n+                            \"DNS SRV record [{}] for [{}] not found in zone [{}]\", dnsRecord.getIdnsname(), fqdn, dnsZone);\n                 }\n             }\n         }\n     }\n+\n+    private FreeIpaAndClient createFreeIpaAndClient(String environmentCrn, String accountId) throws FreeIpaClientException {\n+        Stack stack = stackService.getByEnvironmentCrnAndAccountId(environmentCrn, accountId);\n+        MDCBuilder.buildMdcContext(stack);\n+        FreeIpa freeIpa = freeIpaService.findByStack(stack);\n+        FreeIpaClient freeIpaClient = freeIpaClientFactory.getFreeIpaClientForStack(stack);\n+        return new FreeIpaAndClient(freeIpa, freeIpaClient);\n+    }\n+\n+    @Retryable(value = RetryableFreeIpaClientException.class,\n+            maxAttemptsExpression = RetryableFreeIpaClientException.MAX_RETRIES_EXPRESSION,\n+            backoff = @Backoff(delayExpression = RetryableFreeIpaClientException.DELAY_EXPRESSION,\n+                    multiplierExpression = RetryableFreeIpaClientException.MULTIPLIER_EXPRESSION))\n+    @Measure(DnsRecordService.class)\n+    public void addDnsARecord(String accountId, @Valid AddDnsARecordRequest request) throws FreeIpaClientException {\n+        FreeIpaAndClient freeIpaAndClient = createFreeIpaAndClient(request.getEnvironmentCrn(), accountId);\n+        LOGGER.info(\"Processing AddDnsARecordRequest: {}\", request);\n+        String zone = calculateZone(request.getDnsZone(), freeIpaAndClient);\n+        Optional<DnsRecord> dnsRecord = ignoreNotFoundExceptionWithValue(() -> freeIpaAndClient.getClient().showDnsRecord(zone, request.getHostname()), null);\n+        if (dnsRecord.isEmpty()) {\n+            createDnsARecord(freeIpaAndClient.getClient(), zone, request.getHostname(), request.getIp(), request.isCreateReverse());\n+        } else {\n+            validateExistingARecordMatchesRequested(request.getIp(), dnsRecord.get());\n+        }\n+    }\n+\n+    private String calculateZone(String zoneFromRequest, FreeIpaAndClient freeIpaAndClient) throws FreeIpaClientException {\n+        Optional<String> optionalZone = Optional.ofNullable(zoneFromRequest);\n+        String zone = optionalZone.orElse(freeIpaAndClient.getFreeIpa().getDomain());\n+        boolean providedZoneDifferentThanDefault = !freeIpaAndClient.getFreeIpa().getDomain().equals(StringUtils.removeEnd(zone, \".\"));\n+        if (optionalZone.isPresent() && providedZoneDifferentThanDefault) {\n+            validateZoneExists(optionalZone.get(), freeIpaAndClient.getClient());\n+        }\n+        return zone;\n+    }\n+\n+    private void validateZoneExists(String zone, FreeIpaClient client) throws FreeIpaClientException {\n+        Set<DnsZone> allDnsZone = client.findAllDnsZone();\n+        String zoneInFreeIpaFormat = StringUtils.appendIfMissing(zone, \".\");\n+        boolean zoneMissing = allDnsZone.stream()\n+                .map(DnsZone::getIdnsname)\n+                .noneMatch(zoneFromIpa -> zoneFromIpa.equals(zoneInFreeIpaFormat));\n+        if (zoneMissing) {\n+            String msg = String.format(\"Zone [%s] doesn't exists\", zone);\n+            LOGGER.info(msg);\n+            throw new BadRequestException(msg);\n+        }\n+    }\n+\n+    private void validateExistingARecordMatchesRequested(String ip, DnsRecord record) {\n+        LOGGER.debug(\"Validating already existing record: {}\", record);\n+        if (!record.isARecord()) {\n+            LOGGER.info(\"Record already exists and it's not an A record\");\n+            throw new DnsRecordConflictException(\"Record already exists and it's not an A record\");\n+        } else if (!record.getArecord().contains(ip)) {\n+            LOGGER.info(\"Record already exists and the IP doesn't match\");\n+            throw new DnsRecordConflictException(\"Record already exists and the IP doesn't match\");\n+        } else {\n+            LOGGER.info(\"A record already exists and matches with requested. Nothing to do\");\n+        }\n+    }\n+\n+    private void createDnsARecord(FreeIpaClient client, String zone, String hostname, String ip, boolean createReverse) throws FreeIpaClientException {\n+        LOGGER.info(\"Creating A record in zone [{}] with hostname [{}] with IP [{}]. Create reverse set to [{}]\",\n+                zone, hostname, ip, createReverse);\n+        DnsRecord record = client.addDnsARecord(zone, hostname, ip, createReverse);\n+        LOGGER.info(\"A record [{}] pointing to [{}] is created successfully. Created record: {}\", hostname, ip, record);\n+    }\n+\n+    @Retryable(value = RetryableFreeIpaClientException.class,\n+            maxAttemptsExpression = RetryableFreeIpaClientException.MAX_RETRIES_EXPRESSION,\n+            backoff = @Backoff(delayExpression = RetryableFreeIpaClientException.DELAY_EXPRESSION,\n+                    multiplierExpression = RetryableFreeIpaClientException.MULTIPLIER_EXPRESSION))\n+    @Measure(DnsRecordService.class)\n+    public void addDnsCnameRecord(String accountId, AddDnsCnameRecordRequest request) throws FreeIpaClientException {\n+        FreeIpaAndClient freeIpaAndClient = createFreeIpaAndClient(request.getEnvironmentCrn(), accountId);\n+        String zone = calculateZone(request.getDnsZone(), freeIpaAndClient);\n+        Optional<DnsRecord> dnsRecord = ignoreNotFoundExceptionWithValue(() -> freeIpaAndClient.getClient().showDnsRecord(zone, request.getCname()), null);\n+        if (dnsRecord.isEmpty()) {\n+            createDnsCnameRecord(freeIpaAndClient.getClient(), zone, request.getCname(), request.getTargetFqdn());\n+        } else {\n+            validateExistingCnameRecordMatches(dnsRecord.get(), request.getTargetFqdn());\n+        }\n+    }\n+\n+    private void validateExistingCnameRecordMatches(DnsRecord record, String targetFqdn) {\n+        LOGGER.debug(\"Validating already existing record: {}\", record);\n+        if (!record.isCnameRecord()) {\n+            LOGGER.info(\"Record already exists and it's not a CNAME record\");\n+            throw new DnsRecordConflictException(\"Record already exists and it's not a CNAME record\");\n+        } else if (!record.getCnamerecord().contains(targetFqdn)) {\n+            LOGGER.info(\"Record already exists and the target doesn't match\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "de61d8ff7b2c0a2c38e6e19bdf78d2f4f3078227"}, "originalPosition": 179}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "de61d8ff7b2c0a2c38e6e19bdf78d2f4f3078227", "author": {"user": {"login": "lacikaaa", "name": "Mihaly Laszlo Molnar"}}, "url": "https://github.com/hortonworks/cloudbreak/commit/de61d8ff7b2c0a2c38e6e19bdf78d2f4f3078227", "committedDate": "2020-12-14T12:30:18Z", "message": "CB-10066 New API methods to add and delete DNS A and CNAME records\n\nWith the new endpoints other services will be able to create A and\nCNAME records in FreeIPA or delete existing ones. If DNS zone is not\ndefined, the default will be used, which is the environment domain.\nIf a record already exists with the same value then the request\nconsidered successful.\nIf the record exists but has a different value, an error will be\nthrown.\nAlso if the zone is defined but not exists, an error would be thrown.\nWhen deleting a record which not exists is considered a successful\noperation."}, "afterCommit": {"oid": "83984e54ad75fcca64d25eacbc4f90c311cc9f0f", "author": {"user": {"login": "lacikaaa", "name": "Mihaly Laszlo Molnar"}}, "url": "https://github.com/hortonworks/cloudbreak/commit/83984e54ad75fcca64d25eacbc4f90c311cc9f0f", "committedDate": "2020-12-16T11:59:16Z", "message": "CB-10066 New API methods to add and delete DNS A and CNAME records\n\nWith the new endpoints other services will be able to create A and\nCNAME records in FreeIPA or delete existing ones. If DNS zone is not\ndefined, the default will be used, which is the environment domain.\nIf a record already exists with the same value then the request\nconsidered successful.\nIf the record exists but has a different value, an error will be\nthrown.\nAlso if the zone is defined but not exists, an error would be thrown.\nWhen deleting a record which not exists is considered a successful\noperation."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8759b6cd3759bf8b99db1876f98fa5a2ce86b5e0", "author": {"user": {"login": "lacikaaa", "name": "Mihaly Laszlo Molnar"}}, "url": "https://github.com/hortonworks/cloudbreak/commit/8759b6cd3759bf8b99db1876f98fa5a2ce86b5e0", "committedDate": "2020-12-16T13:15:59Z", "message": "CB-10066 New API methods to add and delete DNS A and CNAME records\n\nWith the new endpoints other services will be able to create A and\nCNAME records in FreeIPA or delete existing ones. If DNS zone is not\ndefined, the default will be used, which is the environment domain.\nIf a record already exists with the same value then the request\nconsidered successful.\nIf the record exists but has a different value, an error will be\nthrown.\nAlso if the zone is defined but not exists, an error would be thrown.\nWhen deleting a record which not exists is considered a successful\noperation."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "83984e54ad75fcca64d25eacbc4f90c311cc9f0f", "author": {"user": {"login": "lacikaaa", "name": "Mihaly Laszlo Molnar"}}, "url": "https://github.com/hortonworks/cloudbreak/commit/83984e54ad75fcca64d25eacbc4f90c311cc9f0f", "committedDate": "2020-12-16T11:59:16Z", "message": "CB-10066 New API methods to add and delete DNS A and CNAME records\n\nWith the new endpoints other services will be able to create A and\nCNAME records in FreeIPA or delete existing ones. If DNS zone is not\ndefined, the default will be used, which is the environment domain.\nIf a record already exists with the same value then the request\nconsidered successful.\nIf the record exists but has a different value, an error will be\nthrown.\nAlso if the zone is defined but not exists, an error would be thrown.\nWhen deleting a record which not exists is considered a successful\noperation."}, "afterCommit": {"oid": "8759b6cd3759bf8b99db1876f98fa5a2ce86b5e0", "author": {"user": {"login": "lacikaaa", "name": "Mihaly Laszlo Molnar"}}, "url": "https://github.com/hortonworks/cloudbreak/commit/8759b6cd3759bf8b99db1876f98fa5a2ce86b5e0", "committedDate": "2020-12-16T13:15:59Z", "message": "CB-10066 New API methods to add and delete DNS A and CNAME records\n\nWith the new endpoints other services will be able to create A and\nCNAME records in FreeIPA or delete existing ones. If DNS zone is not\ndefined, the default will be used, which is the environment domain.\nIf a record already exists with the same value then the request\nconsidered successful.\nIf the record exists but has a different value, an error will be\nthrown.\nAlso if the zone is defined but not exists, an error would be thrown.\nWhen deleting a record which not exists is considered a successful\noperation."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTUzNzEzMTUy", "url": "https://github.com/hortonworks/cloudbreak/pull/9594#pullrequestreview-553713152", "createdAt": "2020-12-16T14:02:14Z", "commit": {"oid": "8759b6cd3759bf8b99db1876f98fa5a2ce86b5e0"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1950, "cost": 1, "resetAt": "2021-11-01T14:51:55Z"}}}