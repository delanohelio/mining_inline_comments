{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTEwNTY1NDUw", "number": 9294, "reviewThreads": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMFQwODo1Mzo0NlrOE3H0ew==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMFQwOTo0ODozNlrOE3JP7A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI2MjM1MjU5OnYy", "diffSide": "RIGHT", "path": "cloud-azure/src/main/java/com/sequenceiq/cloudbreak/cloud/azure/image/AzureImageDetails.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMFQwODo1Mzo0NlrOHwSGxw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMFQxMTowNjozNVrOHwXfGQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDM5MDM0Mw==", "bodyText": "Why haven't you extended AzureImage? It has multiple common fields, seems like it has the same purpose.", "url": "https://github.com/hortonworks/cloudbreak/pull/9294#discussion_r520390343", "createdAt": "2020-11-10T08:53:46Z", "author": {"login": "pdarvasi"}, "path": "cloud-azure/src/main/java/com/sequenceiq/cloudbreak/cloud/azure/image/AzureImageDetails.java", "diffHunk": "@@ -0,0 +1,35 @@\n+package com.sequenceiq.cloudbreak.cloud.azure.image;\n+\n+public class AzureImageDetails {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3a6cbe15acdf4086a7a83c6c41980f8d4ad2da4b"}, "originalPosition": 3}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDQ2MTQ4OA==", "bodyText": "While it's true they have common fields but there are some not in common, as well. They also serve slightly different purposes.\nI view it as:\ninput: AzureImageDetails. Grouping all the needed input parameters into one class\noutput: AzureImage. Tells, for example, if an image exists.\nI would keep it.", "url": "https://github.com/hortonworks/cloudbreak/pull/9294#discussion_r520461488", "createdAt": "2020-11-10T10:40:17Z", "author": {"login": "gergopapi2"}, "path": "cloud-azure/src/main/java/com/sequenceiq/cloudbreak/cloud/azure/image/AzureImageDetails.java", "diffHunk": "@@ -0,0 +1,35 @@\n+package com.sequenceiq.cloudbreak.cloud.azure.image;\n+\n+public class AzureImageDetails {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDM5MDM0Mw=="}, "originalCommit": {"oid": "3a6cbe15acdf4086a7a83c6c41980f8d4ad2da4b"}, "originalPosition": 3}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDQ3ODQ4OQ==", "bodyText": "I renamed it to AzureImageInfo in hope to give it a better name.", "url": "https://github.com/hortonworks/cloudbreak/pull/9294#discussion_r520478489", "createdAt": "2020-11-10T11:06:35Z", "author": {"login": "gergopapi2"}, "path": "cloud-azure/src/main/java/com/sequenceiq/cloudbreak/cloud/azure/image/AzureImageDetails.java", "diffHunk": "@@ -0,0 +1,35 @@\n+package com.sequenceiq.cloudbreak.cloud.azure.image;\n+\n+public class AzureImageDetails {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDM5MDM0Mw=="}, "originalCommit": {"oid": "3a6cbe15acdf4086a7a83c6c41980f8d4ad2da4b"}, "originalPosition": 3}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI2MjU0OTAxOnYy", "diffSide": "RIGHT", "path": "cloud-azure/src/main/java/com/sequenceiq/cloudbreak/cloud/azure/image/AzureImageService.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMFQwOTozOTo1NFrOHwT-0w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMFQwOTozOTo1NFrOHwT-0w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDQyMTA3NQ==", "bodyText": "I'd still prefer isRequested as it check for current status \"REQUESTED\"", "url": "https://github.com/hortonworks/cloudbreak/pull/9294#discussion_r520421075", "createdAt": "2020-11-10T09:39:54Z", "author": {"login": "pdarvasi"}, "path": "cloud-azure/src/main/java/com/sequenceiq/cloudbreak/cloud/azure/image/AzureImageService.java", "diffHunk": "@@ -135,7 +106,7 @@ public CloudResource buildCloudResource(String name, String id, CommonStatus sta\n                 .build();\n     }\n \n-    private boolean isRequested(String imageId) {\n-        return resourcePersistenceRetriever.notifyRetrieve(imageId, CommonStatus.REQUESTED, ResourceType.AZURE_MANAGED_IMAGE).isPresent();\n+    private boolean wasCreateRequested(AzureImageDetails azureImageDetails) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3a6cbe15acdf4086a7a83c6c41980f8d4ad2da4b"}, "originalPosition": 149}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI2MjU4MjUwOnYy", "diffSide": "RIGHT", "path": "cloud-azure/src/main/java/com/sequenceiq/cloudbreak/cloud/azure/image/AzureImageService.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMFQwOTo0NzozMVrOHwUTIA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMFQxMDo1MzoyNFrOHwW9hw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDQyNjI3Mg==", "bodyText": "Generally, I don't like the image --> customImage renames, as it is an Azure Java SDK only term, the object type is \"type\": \"Microsoft.Compute/images\" and in Portal, it is called \"Image\" in Azure Portal, too.\nFurthermore, the custom image term in Cloudbreak is used for a completely different concept. Pls. undo the renames.\nIt would be best to rename all occurrences, regardless of this PR.", "url": "https://github.com/hortonworks/cloudbreak/pull/9294#discussion_r520426272", "createdAt": "2020-11-10T09:47:31Z", "author": {"login": "pdarvasi"}, "path": "cloud-azure/src/main/java/com/sequenceiq/cloudbreak/cloud/azure/image/AzureImageService.java", "diffHunk": "@@ -36,96 +33,70 @@\n     @Inject\n     private PersistenceNotifier persistenceNotifier;\n \n-    @Inject\n-    private AzureResourceIdProviderService azureResourceIdProviderService;\n-\n     @Inject\n     private AzureManagedImageCreationPoller azureManagedImageCreationPoller;\n \n     @Inject\n     private AzureManagedImageService azureManagedImageService;\n \n-    @Inject\n-    private CustomVMImageNameProvider customVMImageNameProvider;\n-\n-    public AzureImage getCustomImageId(String resourceGroup, String fromVhdUri, AuthenticatedContext ac, boolean createIfNotFound, AzureClient client) {\n-        String region = getRegion(ac);\n-        String imageName = getImageName(region, fromVhdUri);\n-        String imageId = getImageId(resourceGroup, client, imageName);\n-        AzureManagedImageCreationCheckerContext checkerContext = new AzureManagedImageCreationCheckerContext(client, resourceGroup, imageName);\n-\n-        if (getCustomImage(resourceGroup, client, imageName).isPresent() || isRequested(imageId)) {\n-            LOGGER.debug(\"Custom image found in '{}' resource group with name '{}'\", resourceGroup, imageName);\n-            azureManagedImageCreationPoller.startPolling(ac, checkerContext);\n-            return new AzureImage(imageId, imageName, true);\n-        } else {\n-            LOGGER.debug(\"Custom image NOT found in '{}' resource group with name '{}', creating it now: {}\", resourceGroup, imageName, createIfNotFound);\n-            if (createIfNotFound) {\n-                saveImage(ac, imageName, imageId);\n-                Optional<VirtualMachineCustomImage> customImage;\n-                try {\n-                    customImage = Optional.of(client.createCustomImage(imageName, resourceGroup, fromVhdUri, region));\n-                } catch (CloudException e) {\n-                    customImage = handleImageCreationException(resourceGroup, ac, client, imageName, imageId, checkerContext, e);\n-                }\n-                return customImage\n-                        .map(image -> createNewAzureImageAndNotify(ac, image))\n-                        .orElseThrow(() -> new CloudConnectorException(\"Failed to create custom image.\"));\n-            } else {\n-                return null;\n-            }\n+    public Optional<AzureImage> findCustomImage(AzureImageDetails azureImageDetails, AzureClient client, AuthenticatedContext ac) {\n+        if (findCustomImage(azureImageDetails, client).isEmpty() && !wasCreateRequested(azureImageDetails)) {\n+            return Optional.empty();\n         }\n+\n+        LOGGER.debug(\"Custom image found in '{}' resource group with name '{}'\", azureImageDetails.getResourceGroup(), azureImageDetails.getImageName());\n+        azureManagedImageCreationPoller.startPolling(ac, new AzureManagedImageCreationCheckerContext(azureImageDetails, client));\n+        return Optional.of(new AzureImage(azureImageDetails.getImageId(), azureImageDetails.getImageName(), true));\n     }\n \n-    private AzureImage createNewAzureImageAndNotify(AuthenticatedContext ac, VirtualMachineCustomImage customImage) {\n-        updateImageStatus(ac, customImage.name(), customImage.id(), CommonStatus.CREATED);\n+    public AzureImage createCustomImage(AzureImageDetails azureImageDetails, String fromVhdUri, AzureClient client, AuthenticatedContext ac) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3a6cbe15acdf4086a7a83c6c41980f8d4ad2da4b"}, "originalPosition": 66}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDQ2OTg5NQ==", "bodyText": "You mean in AzureClient as well? Doing it.", "url": "https://github.com/hortonworks/cloudbreak/pull/9294#discussion_r520469895", "createdAt": "2020-11-10T10:53:24Z", "author": {"login": "gergopapi2"}, "path": "cloud-azure/src/main/java/com/sequenceiq/cloudbreak/cloud/azure/image/AzureImageService.java", "diffHunk": "@@ -36,96 +33,70 @@\n     @Inject\n     private PersistenceNotifier persistenceNotifier;\n \n-    @Inject\n-    private AzureResourceIdProviderService azureResourceIdProviderService;\n-\n     @Inject\n     private AzureManagedImageCreationPoller azureManagedImageCreationPoller;\n \n     @Inject\n     private AzureManagedImageService azureManagedImageService;\n \n-    @Inject\n-    private CustomVMImageNameProvider customVMImageNameProvider;\n-\n-    public AzureImage getCustomImageId(String resourceGroup, String fromVhdUri, AuthenticatedContext ac, boolean createIfNotFound, AzureClient client) {\n-        String region = getRegion(ac);\n-        String imageName = getImageName(region, fromVhdUri);\n-        String imageId = getImageId(resourceGroup, client, imageName);\n-        AzureManagedImageCreationCheckerContext checkerContext = new AzureManagedImageCreationCheckerContext(client, resourceGroup, imageName);\n-\n-        if (getCustomImage(resourceGroup, client, imageName).isPresent() || isRequested(imageId)) {\n-            LOGGER.debug(\"Custom image found in '{}' resource group with name '{}'\", resourceGroup, imageName);\n-            azureManagedImageCreationPoller.startPolling(ac, checkerContext);\n-            return new AzureImage(imageId, imageName, true);\n-        } else {\n-            LOGGER.debug(\"Custom image NOT found in '{}' resource group with name '{}', creating it now: {}\", resourceGroup, imageName, createIfNotFound);\n-            if (createIfNotFound) {\n-                saveImage(ac, imageName, imageId);\n-                Optional<VirtualMachineCustomImage> customImage;\n-                try {\n-                    customImage = Optional.of(client.createCustomImage(imageName, resourceGroup, fromVhdUri, region));\n-                } catch (CloudException e) {\n-                    customImage = handleImageCreationException(resourceGroup, ac, client, imageName, imageId, checkerContext, e);\n-                }\n-                return customImage\n-                        .map(image -> createNewAzureImageAndNotify(ac, image))\n-                        .orElseThrow(() -> new CloudConnectorException(\"Failed to create custom image.\"));\n-            } else {\n-                return null;\n-            }\n+    public Optional<AzureImage> findCustomImage(AzureImageDetails azureImageDetails, AzureClient client, AuthenticatedContext ac) {\n+        if (findCustomImage(azureImageDetails, client).isEmpty() && !wasCreateRequested(azureImageDetails)) {\n+            return Optional.empty();\n         }\n+\n+        LOGGER.debug(\"Custom image found in '{}' resource group with name '{}'\", azureImageDetails.getResourceGroup(), azureImageDetails.getImageName());\n+        azureManagedImageCreationPoller.startPolling(ac, new AzureManagedImageCreationCheckerContext(azureImageDetails, client));\n+        return Optional.of(new AzureImage(azureImageDetails.getImageId(), azureImageDetails.getImageName(), true));\n     }\n \n-    private AzureImage createNewAzureImageAndNotify(AuthenticatedContext ac, VirtualMachineCustomImage customImage) {\n-        updateImageStatus(ac, customImage.name(), customImage.id(), CommonStatus.CREATED);\n+    public AzureImage createCustomImage(AzureImageDetails azureImageDetails, String fromVhdUri, AzureClient client, AuthenticatedContext ac) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDQyNjI3Mg=="}, "originalCommit": {"oid": "3a6cbe15acdf4086a7a83c6c41980f8d4ad2da4b"}, "originalPosition": 66}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI2MjU4NjMzOnYy", "diffSide": "RIGHT", "path": "cloud-azure/src/main/java/com/sequenceiq/cloudbreak/cloud/azure/image/AzureImageService.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMFQwOTo0ODozMFrOHwUVjg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMFQwOTo0ODozMFrOHwUVjg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDQyNjg5NA==", "bodyText": "same: pls. rename the rename", "url": "https://github.com/hortonworks/cloudbreak/pull/9294#discussion_r520426894", "createdAt": "2020-11-10T09:48:30Z", "author": {"login": "pdarvasi"}, "path": "cloud-azure/src/main/java/com/sequenceiq/cloudbreak/cloud/azure/image/AzureImageService.java", "diffHunk": "@@ -36,96 +33,70 @@\n     @Inject\n     private PersistenceNotifier persistenceNotifier;\n \n-    @Inject\n-    private AzureResourceIdProviderService azureResourceIdProviderService;\n-\n     @Inject\n     private AzureManagedImageCreationPoller azureManagedImageCreationPoller;\n \n     @Inject\n     private AzureManagedImageService azureManagedImageService;\n \n-    @Inject\n-    private CustomVMImageNameProvider customVMImageNameProvider;\n-\n-    public AzureImage getCustomImageId(String resourceGroup, String fromVhdUri, AuthenticatedContext ac, boolean createIfNotFound, AzureClient client) {\n-        String region = getRegion(ac);\n-        String imageName = getImageName(region, fromVhdUri);\n-        String imageId = getImageId(resourceGroup, client, imageName);\n-        AzureManagedImageCreationCheckerContext checkerContext = new AzureManagedImageCreationCheckerContext(client, resourceGroup, imageName);\n-\n-        if (getCustomImage(resourceGroup, client, imageName).isPresent() || isRequested(imageId)) {\n-            LOGGER.debug(\"Custom image found in '{}' resource group with name '{}'\", resourceGroup, imageName);\n-            azureManagedImageCreationPoller.startPolling(ac, checkerContext);\n-            return new AzureImage(imageId, imageName, true);\n-        } else {\n-            LOGGER.debug(\"Custom image NOT found in '{}' resource group with name '{}', creating it now: {}\", resourceGroup, imageName, createIfNotFound);\n-            if (createIfNotFound) {\n-                saveImage(ac, imageName, imageId);\n-                Optional<VirtualMachineCustomImage> customImage;\n-                try {\n-                    customImage = Optional.of(client.createCustomImage(imageName, resourceGroup, fromVhdUri, region));\n-                } catch (CloudException e) {\n-                    customImage = handleImageCreationException(resourceGroup, ac, client, imageName, imageId, checkerContext, e);\n-                }\n-                return customImage\n-                        .map(image -> createNewAzureImageAndNotify(ac, image))\n-                        .orElseThrow(() -> new CloudConnectorException(\"Failed to create custom image.\"));\n-            } else {\n-                return null;\n-            }\n+    public Optional<AzureImage> findCustomImage(AzureImageDetails azureImageDetails, AzureClient client, AuthenticatedContext ac) {\n+        if (findCustomImage(azureImageDetails, client).isEmpty() && !wasCreateRequested(azureImageDetails)) {\n+            return Optional.empty();\n         }\n+\n+        LOGGER.debug(\"Custom image found in '{}' resource group with name '{}'\", azureImageDetails.getResourceGroup(), azureImageDetails.getImageName());\n+        azureManagedImageCreationPoller.startPolling(ac, new AzureManagedImageCreationCheckerContext(azureImageDetails, client));\n+        return Optional.of(new AzureImage(azureImageDetails.getImageId(), azureImageDetails.getImageName(), true));\n     }\n \n-    private AzureImage createNewAzureImageAndNotify(AuthenticatedContext ac, VirtualMachineCustomImage customImage) {\n-        updateImageStatus(ac, customImage.name(), customImage.id(), CommonStatus.CREATED);\n+    public AzureImage createCustomImage(AzureImageDetails azureImageDetails, String fromVhdUri, AzureClient client, AuthenticatedContext ac) {\n+        saveCustomImage(ac, azureImageDetails.getImageName(), azureImageDetails.getImageId());\n+        Optional<VirtualMachineCustomImage> customImage;\n+        AzureManagedImageCreationCheckerContext checkerContext = new AzureManagedImageCreationCheckerContext(azureImageDetails, client);\n+        try {\n+            customImage = Optional.of(\n+                    client.createCustomImage(azureImageDetails.getImageName(), azureImageDetails.getResourceGroup(), fromVhdUri, azureImageDetails.getRegion()));\n+        } catch (CloudException e) {\n+            customImage = handleCustomImageCreationException(azureImageDetails, ac, client, checkerContext, e);\n+        }\n+        return customImage\n+                .map(image -> createCustomImageAndNotify(ac, image))\n+                .orElseThrow(() -> new CloudConnectorException(\"Failed to create custom image.\"));\n+    }\n+\n+    private AzureImage createCustomImageAndNotify(AuthenticatedContext ac, VirtualMachineCustomImage customImage) {\n+        updateCustomImageStatus(ac, customImage.name(), customImage.id(), CommonStatus.CREATED);\n         return new AzureImage(customImage.id(), customImage.name(), true);\n     }\n \n-    private Optional<VirtualMachineCustomImage> handleImageCreationException(String resourceGroup, AuthenticatedContext ac, AzureClient client,\n-            String imageName, String imageId, AzureManagedImageCreationCheckerContext checkerContext, CloudException e) {\n+    private Optional<VirtualMachineCustomImage> handleCustomImageCreationException(AzureImageDetails azureImageDetails, AuthenticatedContext ac,\n+            AzureClient client, AzureManagedImageCreationCheckerContext checkerContext, CloudException e) {\n         Optional<VirtualMachineCustomImage> customImage;\n         azureManagedImageCreationPoller.startPolling(ac, checkerContext);\n-        customImage = getCustomImage(resourceGroup, client, imageName);\n+        customImage = findCustomImage(azureImageDetails, client);\n         if (customImage.isEmpty()) {\n             LOGGER.error(\"Failed to create custom image.\", e);\n-            updateImageStatus(ac, imageName, imageId, CommonStatus.FAILED);\n+            updateCustomImageStatus(ac, azureImageDetails.getImageName(), azureImageDetails.getImageId(), CommonStatus.FAILED);\n             throw new CloudConnectorException(e);\n         }\n         return customImage;\n     }\n \n-    private Optional<VirtualMachineCustomImage> getCustomImage(String resourceGroup, AzureClient client, String imageName) {\n-        return azureManagedImageService.findVirtualMachineCustomImage(resourceGroup, imageName, client);\n-    }\n-\n-    private String getImageName(String region, String fromVhdUri) {\n-        return customVMImageNameProvider.get(region, fromVhdUri);\n+    private Optional<VirtualMachineCustomImage> findCustomImage(AzureImageDetails azureImageDetails, AzureClient client) {\n+        return azureManagedImageService.findVirtualMachineCustomImage(azureImageDetails, client);\n     }\n \n-    private void saveImage(AuthenticatedContext ac, String imageName, String imageId) {\n+    private void saveCustomImage(AuthenticatedContext ac, String imageName, String imageId) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3a6cbe15acdf4086a7a83c6c41980f8d4ad2da4b"}, "originalPosition": 114}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI2MjU4NjY4OnYy", "diffSide": "RIGHT", "path": "cloud-azure/src/main/java/com/sequenceiq/cloudbreak/cloud/azure/image/AzureImageService.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMFQwOTo0ODozNlrOHwUVvw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMFQwOTo0ODozNlrOHwUVvw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDQyNjk0Mw==", "bodyText": "same: pls. rename the rename", "url": "https://github.com/hortonworks/cloudbreak/pull/9294#discussion_r520426943", "createdAt": "2020-11-10T09:48:36Z", "author": {"login": "pdarvasi"}, "path": "cloud-azure/src/main/java/com/sequenceiq/cloudbreak/cloud/azure/image/AzureImageService.java", "diffHunk": "@@ -36,96 +33,70 @@\n     @Inject\n     private PersistenceNotifier persistenceNotifier;\n \n-    @Inject\n-    private AzureResourceIdProviderService azureResourceIdProviderService;\n-\n     @Inject\n     private AzureManagedImageCreationPoller azureManagedImageCreationPoller;\n \n     @Inject\n     private AzureManagedImageService azureManagedImageService;\n \n-    @Inject\n-    private CustomVMImageNameProvider customVMImageNameProvider;\n-\n-    public AzureImage getCustomImageId(String resourceGroup, String fromVhdUri, AuthenticatedContext ac, boolean createIfNotFound, AzureClient client) {\n-        String region = getRegion(ac);\n-        String imageName = getImageName(region, fromVhdUri);\n-        String imageId = getImageId(resourceGroup, client, imageName);\n-        AzureManagedImageCreationCheckerContext checkerContext = new AzureManagedImageCreationCheckerContext(client, resourceGroup, imageName);\n-\n-        if (getCustomImage(resourceGroup, client, imageName).isPresent() || isRequested(imageId)) {\n-            LOGGER.debug(\"Custom image found in '{}' resource group with name '{}'\", resourceGroup, imageName);\n-            azureManagedImageCreationPoller.startPolling(ac, checkerContext);\n-            return new AzureImage(imageId, imageName, true);\n-        } else {\n-            LOGGER.debug(\"Custom image NOT found in '{}' resource group with name '{}', creating it now: {}\", resourceGroup, imageName, createIfNotFound);\n-            if (createIfNotFound) {\n-                saveImage(ac, imageName, imageId);\n-                Optional<VirtualMachineCustomImage> customImage;\n-                try {\n-                    customImage = Optional.of(client.createCustomImage(imageName, resourceGroup, fromVhdUri, region));\n-                } catch (CloudException e) {\n-                    customImage = handleImageCreationException(resourceGroup, ac, client, imageName, imageId, checkerContext, e);\n-                }\n-                return customImage\n-                        .map(image -> createNewAzureImageAndNotify(ac, image))\n-                        .orElseThrow(() -> new CloudConnectorException(\"Failed to create custom image.\"));\n-            } else {\n-                return null;\n-            }\n+    public Optional<AzureImage> findCustomImage(AzureImageDetails azureImageDetails, AzureClient client, AuthenticatedContext ac) {\n+        if (findCustomImage(azureImageDetails, client).isEmpty() && !wasCreateRequested(azureImageDetails)) {\n+            return Optional.empty();\n         }\n+\n+        LOGGER.debug(\"Custom image found in '{}' resource group with name '{}'\", azureImageDetails.getResourceGroup(), azureImageDetails.getImageName());\n+        azureManagedImageCreationPoller.startPolling(ac, new AzureManagedImageCreationCheckerContext(azureImageDetails, client));\n+        return Optional.of(new AzureImage(azureImageDetails.getImageId(), azureImageDetails.getImageName(), true));\n     }\n \n-    private AzureImage createNewAzureImageAndNotify(AuthenticatedContext ac, VirtualMachineCustomImage customImage) {\n-        updateImageStatus(ac, customImage.name(), customImage.id(), CommonStatus.CREATED);\n+    public AzureImage createCustomImage(AzureImageDetails azureImageDetails, String fromVhdUri, AzureClient client, AuthenticatedContext ac) {\n+        saveCustomImage(ac, azureImageDetails.getImageName(), azureImageDetails.getImageId());\n+        Optional<VirtualMachineCustomImage> customImage;\n+        AzureManagedImageCreationCheckerContext checkerContext = new AzureManagedImageCreationCheckerContext(azureImageDetails, client);\n+        try {\n+            customImage = Optional.of(\n+                    client.createCustomImage(azureImageDetails.getImageName(), azureImageDetails.getResourceGroup(), fromVhdUri, azureImageDetails.getRegion()));\n+        } catch (CloudException e) {\n+            customImage = handleCustomImageCreationException(azureImageDetails, ac, client, checkerContext, e);\n+        }\n+        return customImage\n+                .map(image -> createCustomImageAndNotify(ac, image))\n+                .orElseThrow(() -> new CloudConnectorException(\"Failed to create custom image.\"));\n+    }\n+\n+    private AzureImage createCustomImageAndNotify(AuthenticatedContext ac, VirtualMachineCustomImage customImage) {\n+        updateCustomImageStatus(ac, customImage.name(), customImage.id(), CommonStatus.CREATED);\n         return new AzureImage(customImage.id(), customImage.name(), true);\n     }\n \n-    private Optional<VirtualMachineCustomImage> handleImageCreationException(String resourceGroup, AuthenticatedContext ac, AzureClient client,\n-            String imageName, String imageId, AzureManagedImageCreationCheckerContext checkerContext, CloudException e) {\n+    private Optional<VirtualMachineCustomImage> handleCustomImageCreationException(AzureImageDetails azureImageDetails, AuthenticatedContext ac,\n+            AzureClient client, AzureManagedImageCreationCheckerContext checkerContext, CloudException e) {\n         Optional<VirtualMachineCustomImage> customImage;\n         azureManagedImageCreationPoller.startPolling(ac, checkerContext);\n-        customImage = getCustomImage(resourceGroup, client, imageName);\n+        customImage = findCustomImage(azureImageDetails, client);\n         if (customImage.isEmpty()) {\n             LOGGER.error(\"Failed to create custom image.\", e);\n-            updateImageStatus(ac, imageName, imageId, CommonStatus.FAILED);\n+            updateCustomImageStatus(ac, azureImageDetails.getImageName(), azureImageDetails.getImageId(), CommonStatus.FAILED);\n             throw new CloudConnectorException(e);\n         }\n         return customImage;\n     }\n \n-    private Optional<VirtualMachineCustomImage> getCustomImage(String resourceGroup, AzureClient client, String imageName) {\n-        return azureManagedImageService.findVirtualMachineCustomImage(resourceGroup, imageName, client);\n-    }\n-\n-    private String getImageName(String region, String fromVhdUri) {\n-        return customVMImageNameProvider.get(region, fromVhdUri);\n+    private Optional<VirtualMachineCustomImage> findCustomImage(AzureImageDetails azureImageDetails, AzureClient client) {\n+        return azureManagedImageService.findVirtualMachineCustomImage(azureImageDetails, client);\n     }\n \n-    private void saveImage(AuthenticatedContext ac, String imageName, String imageId) {\n+    private void saveCustomImage(AuthenticatedContext ac, String imageName, String imageId) {\n         LOGGER.debug(\"Persisting image with REQUESTED status: {}\", imageId);\n         persistenceNotifier.notifyAllocation(buildCloudResource(imageName, imageId, CommonStatus.REQUESTED), ac.getCloudContext());\n     }\n \n-    private void updateImageStatus(AuthenticatedContext ac, String imageName, String imageId, CommonStatus commonStatus) {\n-        LOGGER.debug(\"Updating image status to {}: {}\", commonStatus.toString(), imageId);\n+    private void updateCustomImageStatus(AuthenticatedContext ac, String imageName, String imageId, CommonStatus commonStatus) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3a6cbe15acdf4086a7a83c6c41980f8d4ad2da4b"}, "originalPosition": 121}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2054, "cost": 1, "resetAt": "2021-11-12T20:44:06Z"}}}