{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDczNzg1NzIw", "number": 8865, "title": "CB-7040 Upgrade salt states during Datalake upgrade", "bodyText": "Salt upgrade has been added in 2 places:\n\nbefore starting the runtime upgrade the states pushed down to the GW\nnodes and a highstate is called. This is a separate flow which is\nadded to the upgrade flowchain as first step. Also the component table\nis updated with the new states\nas replacing the instances is implemented using full repair, this\ncommit adds a step to upgradeOs calls where it replaces the salt\nstates stored in ClusterComponent table. In this case we don't\ninitiate a highstate as the new GW node will come up with the new\nstates during the upgrade/repair. If the upgrade/repair flow cannot be\ninitiated the ClusterComponent is rolled back to previous version as\nit is a versioned entity\n\nAs a result we don't check if salt version is matching in the future.\nNotable refactors:\n\nClusterRepairService#validateRepair had a big, ugly transaction.\nThis has been removed and where it was necessary separate repository\ncalls have been introduced\nthere were some hand written checks for running flows which has been\neliminated as flow engine won't accept new flows if there is one\nalready running\n\nSee detailed description in the commit message.", "createdAt": "2020-08-26T09:43:46Z", "url": "https://github.com/hortonworks/cloudbreak/pull/8865", "merged": true, "mergeCommit": {"oid": "7bce164504130c4b1fb56526f0e64c1d8df7299a"}, "closed": true, "closedAt": "2020-08-27T13:19:14Z", "author": {"login": "lacikaaa"}, "timelineItems": {"totalCount": 12, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdCp6imAFqTQ3NTM4NzcxMQ==", "endCursor": "Y3Vyc29yOnYyOpPPAAABdC-cPvgBqjM2OTkxMTEwOTk=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDc1Mzg3NzEx", "url": "https://github.com/hortonworks/cloudbreak/pull/8865#pullrequestreview-475387711", "createdAt": "2020-08-26T11:15:08Z", "commit": {"oid": "4029a34609c2af10224c32c7c35556fe62c880ce"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDc1Mzk5NDQ2", "url": "https://github.com/hortonworks/cloudbreak/pull/8865#pullrequestreview-475399446", "createdAt": "2020-08-26T11:33:02Z", "commit": {"oid": "4029a34609c2af10224c32c7c35556fe62c880ce"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNlQxMTozMzowM1rOHHH5EQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNlQxMTozMzowM1rOHHH5EQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzIzMTM3Nw==", "bodyText": "Why is this commented out?", "url": "https://github.com/hortonworks/cloudbreak/pull/8865#discussion_r477231377", "createdAt": "2020-08-26T11:33:03Z", "author": {"login": "keyki"}, "path": "core/src/main/java/com/sequenceiq/cloudbreak/reactor/api/event/cluster/upgrade/ClusterUpgradeRequest.java", "diffHunk": "@@ -7,9 +7,4 @@\n     public ClusterUpgradeRequest(Long stackId) {\n         super(stackId);\n     }\n-\n-//    @Override", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4029a34609c2af10224c32c7c35556fe62c880ce"}, "originalPosition": 5}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "4029a34609c2af10224c32c7c35556fe62c880ce", "author": {"user": {"login": "lacikaaa", "name": "Mihaly Laszlo Molnar"}}, "url": "https://github.com/hortonworks/cloudbreak/commit/4029a34609c2af10224c32c7c35556fe62c880ce", "committedDate": "2020-08-26T09:22:52Z", "message": "CB-7040 Upgrade salt states during Datalake upgrade\n\nSalt upgrade has been added in 2 places:\n- before starting the runtime upgrade the states pushed down to the GW\nnodes and a highstate is called. This is a separate flow which is\nadded to the upgrade flowchain as first step. Also the component table\nis updated with the new states\n- as replacing the instances is implemented using full repair, this\ncommit adds a step to `upgradeOs` calls where it replaces the salt\nstates stored in `ClusterComponent` table. In this case we don't\ninitiate a highstate as the new GW node will come up with the new\nstates during the upgrade/repair. If the upgrade/repair flow cannot be\ninitiated the `ClusterComponent` is rolled back to previous version as\nit is a versioned entity\n\nAs a result we don't check if salt version is matching in the future.\n\nNotable refactors:\n- `ClusterRepairService#validateRepair` had a big, ugly transaction.\nThis has been removed and where it was necessary separate repository\ncalls have been introduced\n- there were some hand written checks for running flows which has been\neliminated as flow engine won't accept new flows if there is one\nalready running"}, "afterCommit": {"oid": "498f97a1e6b1b499d2374fbe70e7a201452684a7", "author": {"user": {"login": "lacikaaa", "name": "Mihaly Laszlo Molnar"}}, "url": "https://github.com/hortonworks/cloudbreak/commit/498f97a1e6b1b499d2374fbe70e7a201452684a7", "committedDate": "2020-08-26T13:05:01Z", "message": "CB-7040 Upgrade salt states during Datalake upgrade\n\nSalt upgrade has been added in 2 places:\n- before starting the runtime upgrade the states pushed down to the GW\nnodes and a highstate is called. This is a separate flow which is\nadded to the upgrade flowchain as first step. Also the component table\nis updated with the new states\n- as replacing the instances is implemented using full repair, this\ncommit adds a step to `upgradeOs` calls where it replaces the salt\nstates stored in `ClusterComponent` table. In this case we don't\ninitiate a highstate as the new GW node will come up with the new\nstates during the upgrade/repair. If the upgrade/repair flow cannot be\ninitiated the `ClusterComponent` is rolled back to previous version as\nit is a versioned entity\n\nAs a result we don't check if salt version is matching in the future.\n\nNotable refactors:\n- `ClusterRepairService#validateRepair` had a big, ugly transaction.\nThis has been removed and where it was necessary separate repository\ncalls have been introduced\n- there were some hand written checks for running flows which has been\neliminated as flow engine won't accept new flows if there is one\nalready running"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDc1NDc3MTQy", "url": "https://github.com/hortonworks/cloudbreak/pull/8865#pullrequestreview-475477142", "createdAt": "2020-08-26T13:17:36Z", "commit": {"oid": "498f97a1e6b1b499d2374fbe70e7a201452684a7"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNlQxMzoxNzozNlrOHHLmWg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNlQxMzoxNzozNlrOHHLmWg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzI5MjEyMg==", "bodyText": "Can you please rename it to getSupportedOperatingSystems?", "url": "https://github.com/hortonworks/cloudbreak/pull/8865#discussion_r477292122", "createdAt": "2020-08-26T13:17:36Z", "author": {"login": "foldik"}, "path": "core/src/main/java/com/sequenceiq/cloudbreak/service/image/ImageService.java", "diffHunk": "@@ -208,7 +155,8 @@ private StatedImage checkIfBasePermitted(StatedImage image, boolean baseImageEna\n         return image;\n     }\n \n-    private Set<String> getSupportedOperationSystems(Long workspaceId, ImageSettingsV4Request imageSettings, String clusterVersion, String platform) throws Exception {\n+    private Set<String> getSupportedOperationSystems(Long workspaceId, ImageSettingsV4Request imageSettings, String clusterVersion, String platform)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "498f97a1e6b1b499d2374fbe70e7a201452684a7"}, "originalPosition": 91}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "498f97a1e6b1b499d2374fbe70e7a201452684a7", "author": {"user": {"login": "lacikaaa", "name": "Mihaly Laszlo Molnar"}}, "url": "https://github.com/hortonworks/cloudbreak/commit/498f97a1e6b1b499d2374fbe70e7a201452684a7", "committedDate": "2020-08-26T13:05:01Z", "message": "CB-7040 Upgrade salt states during Datalake upgrade\n\nSalt upgrade has been added in 2 places:\n- before starting the runtime upgrade the states pushed down to the GW\nnodes and a highstate is called. This is a separate flow which is\nadded to the upgrade flowchain as first step. Also the component table\nis updated with the new states\n- as replacing the instances is implemented using full repair, this\ncommit adds a step to `upgradeOs` calls where it replaces the salt\nstates stored in `ClusterComponent` table. In this case we don't\ninitiate a highstate as the new GW node will come up with the new\nstates during the upgrade/repair. If the upgrade/repair flow cannot be\ninitiated the `ClusterComponent` is rolled back to previous version as\nit is a versioned entity\n\nAs a result we don't check if salt version is matching in the future.\n\nNotable refactors:\n- `ClusterRepairService#validateRepair` had a big, ugly transaction.\nThis has been removed and where it was necessary separate repository\ncalls have been introduced\n- there were some hand written checks for running flows which has been\neliminated as flow engine won't accept new flows if there is one\nalready running"}, "afterCommit": {"oid": "700cf1a8d9d679fe472dcd5cf715b3a1ed1ced17", "author": {"user": {"login": "lacikaaa", "name": "Mihaly Laszlo Molnar"}}, "url": "https://github.com/hortonworks/cloudbreak/commit/700cf1a8d9d679fe472dcd5cf715b3a1ed1ced17", "committedDate": "2020-08-26T13:29:45Z", "message": "CB-7040 Upgrade salt states during Datalake upgrade\n\nSalt upgrade has been added in 2 places:\n- before starting the runtime upgrade the states pushed down to the GW\nnodes and a highstate is called. This is a separate flow which is\nadded to the upgrade flowchain as first step. Also the component table\nis updated with the new states\n- as replacing the instances is implemented using full repair, this\ncommit adds a step to `upgradeOs` calls where it replaces the salt\nstates stored in `ClusterComponent` table. In this case we don't\ninitiate a highstate as the new GW node will come up with the new\nstates during the upgrade/repair. If the upgrade/repair flow cannot be\ninitiated the `ClusterComponent` is rolled back to previous version as\nit is a versioned entity\n\nAs a result we don't check if salt version is matching in the future.\n\nNotable refactors:\n- `ClusterRepairService#validateRepair` had a big, ugly transaction.\nThis has been removed and where it was necessary separate repository\ncalls have been introduced\n- there were some hand written checks for running flows which has been\neliminated as flow engine won't accept new flows if there is one\nalready running"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "700cf1a8d9d679fe472dcd5cf715b3a1ed1ced17", "author": {"user": {"login": "lacikaaa", "name": "Mihaly Laszlo Molnar"}}, "url": "https://github.com/hortonworks/cloudbreak/commit/700cf1a8d9d679fe472dcd5cf715b3a1ed1ced17", "committedDate": "2020-08-26T13:29:45Z", "message": "CB-7040 Upgrade salt states during Datalake upgrade\n\nSalt upgrade has been added in 2 places:\n- before starting the runtime upgrade the states pushed down to the GW\nnodes and a highstate is called. This is a separate flow which is\nadded to the upgrade flowchain as first step. Also the component table\nis updated with the new states\n- as replacing the instances is implemented using full repair, this\ncommit adds a step to `upgradeOs` calls where it replaces the salt\nstates stored in `ClusterComponent` table. In this case we don't\ninitiate a highstate as the new GW node will come up with the new\nstates during the upgrade/repair. If the upgrade/repair flow cannot be\ninitiated the `ClusterComponent` is rolled back to previous version as\nit is a versioned entity\n\nAs a result we don't check if salt version is matching in the future.\n\nNotable refactors:\n- `ClusterRepairService#validateRepair` had a big, ugly transaction.\nThis has been removed and where it was necessary separate repository\ncalls have been introduced\n- there were some hand written checks for running flows which has been\neliminated as flow engine won't accept new flows if there is one\nalready running"}, "afterCommit": {"oid": "1533efdfc97bd9b41803ab6f2a8ff9428b2408db", "author": {"user": {"login": "lacikaaa", "name": "Mihaly Laszlo Molnar"}}, "url": "https://github.com/hortonworks/cloudbreak/commit/1533efdfc97bd9b41803ab6f2a8ff9428b2408db", "committedDate": "2020-08-26T14:49:46Z", "message": "CB-7040 Upgrade salt states during Datalake upgrade\n\nSalt upgrade has been added in 2 places:\n- before starting the runtime upgrade the states pushed down to the GW\nnodes and a highstate is called. This is a separate flow which is\nadded to the upgrade flowchain as first step. Also the component table\nis updated with the new states\n- as replacing the instances is implemented using full repair, this\ncommit adds a step to `upgradeOs` calls where it replaces the salt\nstates stored in `ClusterComponent` table. In this case we don't\ninitiate a highstate as the new GW node will come up with the new\nstates during the upgrade/repair. If the upgrade/repair flow cannot be\ninitiated the `ClusterComponent` is rolled back to previous version as\nit is a versioned entity\n\nAs a result we don't check if salt version is matching in the future.\n\nNotable refactors:\n- `ClusterRepairService#validateRepair` had a big, ugly transaction.\nThis has been removed and where it was necessary separate repository\ncalls have been introduced\n- there were some hand written checks for running flows which has been\neliminated as flow engine won't accept new flows if there is one\nalready running"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "1533efdfc97bd9b41803ab6f2a8ff9428b2408db", "author": {"user": {"login": "lacikaaa", "name": "Mihaly Laszlo Molnar"}}, "url": "https://github.com/hortonworks/cloudbreak/commit/1533efdfc97bd9b41803ab6f2a8ff9428b2408db", "committedDate": "2020-08-26T14:49:46Z", "message": "CB-7040 Upgrade salt states during Datalake upgrade\n\nSalt upgrade has been added in 2 places:\n- before starting the runtime upgrade the states pushed down to the GW\nnodes and a highstate is called. This is a separate flow which is\nadded to the upgrade flowchain as first step. Also the component table\nis updated with the new states\n- as replacing the instances is implemented using full repair, this\ncommit adds a step to `upgradeOs` calls where it replaces the salt\nstates stored in `ClusterComponent` table. In this case we don't\ninitiate a highstate as the new GW node will come up with the new\nstates during the upgrade/repair. If the upgrade/repair flow cannot be\ninitiated the `ClusterComponent` is rolled back to previous version as\nit is a versioned entity\n\nAs a result we don't check if salt version is matching in the future.\n\nNotable refactors:\n- `ClusterRepairService#validateRepair` had a big, ugly transaction.\nThis has been removed and where it was necessary separate repository\ncalls have been introduced\n- there were some hand written checks for running flows which has been\neliminated as flow engine won't accept new flows if there is one\nalready running"}, "afterCommit": {"oid": "7d2fca79de60b80078f150e56558936e3653577f", "author": {"user": {"login": "lacikaaa", "name": "Mihaly Laszlo Molnar"}}, "url": "https://github.com/hortonworks/cloudbreak/commit/7d2fca79de60b80078f150e56558936e3653577f", "committedDate": "2020-08-26T20:28:29Z", "message": "CB-7040 Upgrade salt states during Datalake upgrade\n\nSalt upgrade has been added in 2 places:\n- before starting the runtime upgrade the states pushed down to the GW\nnodes and a highstate is called. This is a separate flow which is\nadded to the upgrade flowchain as first step. Also the component table\nis updated with the new states\n- as replacing the instances is implemented using full repair, this\ncommit adds a step to `upgradeOs` calls where it replaces the salt\nstates stored in `ClusterComponent` table. In this case we don't\ninitiate a highstate as the new GW node will come up with the new\nstates during the upgrade/repair. If the upgrade/repair flow cannot be\ninitiated the `ClusterComponent` is rolled back to previous version as\nit is a versioned entity\n\nAs a result we don't check if salt version is matching in the future.\n\nNotable refactors:\n- `ClusterRepairService#validateRepair` had a big, ugly transaction.\nThis has been removed and where it was necessary separate repository\ncalls have been introduced\n- there were some hand written checks for running flows which has been\neliminated as flow engine won't accept new flows if there is one\nalready running"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "7d2fca79de60b80078f150e56558936e3653577f", "author": {"user": {"login": "lacikaaa", "name": "Mihaly Laszlo Molnar"}}, "url": "https://github.com/hortonworks/cloudbreak/commit/7d2fca79de60b80078f150e56558936e3653577f", "committedDate": "2020-08-26T20:28:29Z", "message": "CB-7040 Upgrade salt states during Datalake upgrade\n\nSalt upgrade has been added in 2 places:\n- before starting the runtime upgrade the states pushed down to the GW\nnodes and a highstate is called. This is a separate flow which is\nadded to the upgrade flowchain as first step. Also the component table\nis updated with the new states\n- as replacing the instances is implemented using full repair, this\ncommit adds a step to `upgradeOs` calls where it replaces the salt\nstates stored in `ClusterComponent` table. In this case we don't\ninitiate a highstate as the new GW node will come up with the new\nstates during the upgrade/repair. If the upgrade/repair flow cannot be\ninitiated the `ClusterComponent` is rolled back to previous version as\nit is a versioned entity\n\nAs a result we don't check if salt version is matching in the future.\n\nNotable refactors:\n- `ClusterRepairService#validateRepair` had a big, ugly transaction.\nThis has been removed and where it was necessary separate repository\ncalls have been introduced\n- there were some hand written checks for running flows which has been\neliminated as flow engine won't accept new flows if there is one\nalready running"}, "afterCommit": {"oid": "b99163bcc04c9e4f6848b2e4ecbbd53ee99cbda9", "author": {"user": {"login": "lacikaaa", "name": "Mihaly Laszlo Molnar"}}, "url": "https://github.com/hortonworks/cloudbreak/commit/b99163bcc04c9e4f6848b2e4ecbbd53ee99cbda9", "committedDate": "2020-08-26T20:33:41Z", "message": "CB-7040 Upgrade salt states during Datalake upgrade\n\nSalt upgrade has been added in 2 places:\n- before starting the runtime upgrade the states pushed down to the GW\nnodes and a highstate is called. This is a separate flow which is\nadded to the upgrade flowchain as first step. Also the component table\nis updated with the new states\n- as replacing the instances is implemented using full repair, this\ncommit adds a step to `upgradeOs` calls where it replaces the salt\nstates stored in `ClusterComponent` table. In this case we don't\ninitiate a highstate as the new GW node will come up with the new\nstates during the upgrade/repair. If the upgrade/repair flow cannot be\ninitiated the `ClusterComponent` is rolled back to previous version as\nit is a versioned entity\n\nAs a result we don't check if salt version is matching in the future.\n\nNotable refactors:\n- `ClusterRepairService#validateRepair` had a big, ugly transaction.\nThis has been removed and where it was necessary separate repository\ncalls have been introduced\n- there were some hand written checks for running flows which has been\neliminated as flow engine won't accept new flows if there is one\nalready running"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "b99163bcc04c9e4f6848b2e4ecbbd53ee99cbda9", "author": {"user": {"login": "lacikaaa", "name": "Mihaly Laszlo Molnar"}}, "url": "https://github.com/hortonworks/cloudbreak/commit/b99163bcc04c9e4f6848b2e4ecbbd53ee99cbda9", "committedDate": "2020-08-26T20:33:41Z", "message": "CB-7040 Upgrade salt states during Datalake upgrade\n\nSalt upgrade has been added in 2 places:\n- before starting the runtime upgrade the states pushed down to the GW\nnodes and a highstate is called. This is a separate flow which is\nadded to the upgrade flowchain as first step. Also the component table\nis updated with the new states\n- as replacing the instances is implemented using full repair, this\ncommit adds a step to `upgradeOs` calls where it replaces the salt\nstates stored in `ClusterComponent` table. In this case we don't\ninitiate a highstate as the new GW node will come up with the new\nstates during the upgrade/repair. If the upgrade/repair flow cannot be\ninitiated the `ClusterComponent` is rolled back to previous version as\nit is a versioned entity\n\nAs a result we don't check if salt version is matching in the future.\n\nNotable refactors:\n- `ClusterRepairService#validateRepair` had a big, ugly transaction.\nThis has been removed and where it was necessary separate repository\ncalls have been introduced\n- there were some hand written checks for running flows which has been\neliminated as flow engine won't accept new flows if there is one\nalready running"}, "afterCommit": {"oid": "6b7272cc8c5454cfb03b11c477f92d8b59f115c1", "author": {"user": {"login": "lacikaaa", "name": "Mihaly Laszlo Molnar"}}, "url": "https://github.com/hortonworks/cloudbreak/commit/6b7272cc8c5454cfb03b11c477f92d8b59f115c1", "committedDate": "2020-08-27T06:44:50Z", "message": "CB-7040 Upgrade salt states during Datalake upgrade\n\nSalt upgrade has been added in 2 places:\n- before starting the runtime upgrade the states pushed down to the GW\nnodes and a highstate is called. This is a separate flow which is\nadded to the upgrade flowchain as first step. Also the component table\nis updated with the new states\n- as replacing the instances is implemented using full repair, this\ncommit adds a step to `upgradeOs` calls where it replaces the salt\nstates stored in `ClusterComponent` table. In this case we don't\ninitiate a highstate as the new GW node will come up with the new\nstates during the upgrade/repair. If the upgrade/repair flow cannot be\ninitiated the `ClusterComponent` is rolled back to previous version as\nit is a versioned entity\n\nAs a result we don't check if salt version is matching in the future.\n\nNotable refactors:\n- `ClusterRepairService#validateRepair` had a big, ugly transaction.\nThis has been removed and where it was necessary separate repository\ncalls have been introduced\n- there were some hand written checks for running flows which has been\neliminated as flow engine won't accept new flows if there is one\nalready running"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "6b7272cc8c5454cfb03b11c477f92d8b59f115c1", "author": {"user": {"login": "lacikaaa", "name": "Mihaly Laszlo Molnar"}}, "url": "https://github.com/hortonworks/cloudbreak/commit/6b7272cc8c5454cfb03b11c477f92d8b59f115c1", "committedDate": "2020-08-27T06:44:50Z", "message": "CB-7040 Upgrade salt states during Datalake upgrade\n\nSalt upgrade has been added in 2 places:\n- before starting the runtime upgrade the states pushed down to the GW\nnodes and a highstate is called. This is a separate flow which is\nadded to the upgrade flowchain as first step. Also the component table\nis updated with the new states\n- as replacing the instances is implemented using full repair, this\ncommit adds a step to `upgradeOs` calls where it replaces the salt\nstates stored in `ClusterComponent` table. In this case we don't\ninitiate a highstate as the new GW node will come up with the new\nstates during the upgrade/repair. If the upgrade/repair flow cannot be\ninitiated the `ClusterComponent` is rolled back to previous version as\nit is a versioned entity\n\nAs a result we don't check if salt version is matching in the future.\n\nNotable refactors:\n- `ClusterRepairService#validateRepair` had a big, ugly transaction.\nThis has been removed and where it was necessary separate repository\ncalls have been introduced\n- there were some hand written checks for running flows which has been\neliminated as flow engine won't accept new flows if there is one\nalready running"}, "afterCommit": {"oid": "a2606ef0fd9ca94372562c374b86b0a6539ce63e", "author": {"user": {"login": "lacikaaa", "name": "Mihaly Laszlo Molnar"}}, "url": "https://github.com/hortonworks/cloudbreak/commit/a2606ef0fd9ca94372562c374b86b0a6539ce63e", "committedDate": "2020-08-27T07:22:17Z", "message": "CB-7040 Upgrade salt states during Datalake upgrade\n\nSalt upgrade has been added in 2 places:\n- before starting the runtime upgrade the states pushed down to the GW\nnodes and a highstate is called. This is a separate flow which is\nadded to the upgrade flowchain as first step. Also the component table\nis updated with the new states\n- as replacing the instances is implemented using full repair, this\ncommit adds a step to `upgradeOs` calls where it replaces the salt\nstates stored in `ClusterComponent` table. In this case we don't\ninitiate a highstate as the new GW node will come up with the new\nstates during the upgrade/repair. If the upgrade/repair flow cannot be\ninitiated the `ClusterComponent` is rolled back to previous version as\nit is a versioned entity\n\nAs a result we don't check if salt version is matching in the future.\n\nNotable refactors:\n- `ClusterRepairService#validateRepair` had a big, ugly transaction.\nThis has been removed and where it was necessary separate repository\ncalls have been introduced\n- there were some hand written checks for running flows which has been\neliminated as flow engine won't accept new flows if there is one\nalready running"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ccf08f00af354317cb877359d9dd8ebb5ba72eef", "author": {"user": {"login": "lacikaaa", "name": "Mihaly Laszlo Molnar"}}, "url": "https://github.com/hortonworks/cloudbreak/commit/ccf08f00af354317cb877359d9dd8ebb5ba72eef", "committedDate": "2020-08-27T11:09:36Z", "message": "CB-7040 Upgrade salt states during Datalake upgrade\n\nSalt upgrade has been added in 2 places:\n- before starting the runtime upgrade the states pushed down to the GW\nnodes and a highstate is called. This is a separate flow which is\nadded to the upgrade flowchain as first step. Also the component table\nis updated with the new states\n- as replacing the instances is implemented using full repair, this\ncommit adds a step to `upgradeOs` calls where it replaces the salt\nstates stored in `ClusterComponent` table. In this case we don't\ninitiate a highstate as the new GW node will come up with the new\nstates during the upgrade/repair. If the upgrade/repair flow cannot be\ninitiated the `ClusterComponent` is rolled back to previous version as\nit is a versioned entity\n\nAs a result we don't check if salt version is matching in the future.\n\nNotable refactors:\n- `ClusterRepairService#validateRepair` had a big, ugly transaction.\nThis has been removed and where it was necessary separate repository\ncalls have been introduced\n- there were some hand written checks for running flows which has been\neliminated as flow engine won't accept new flows if there is one\nalready running"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "a2606ef0fd9ca94372562c374b86b0a6539ce63e", "author": {"user": {"login": "lacikaaa", "name": "Mihaly Laszlo Molnar"}}, "url": "https://github.com/hortonworks/cloudbreak/commit/a2606ef0fd9ca94372562c374b86b0a6539ce63e", "committedDate": "2020-08-27T07:22:17Z", "message": "CB-7040 Upgrade salt states during Datalake upgrade\n\nSalt upgrade has been added in 2 places:\n- before starting the runtime upgrade the states pushed down to the GW\nnodes and a highstate is called. This is a separate flow which is\nadded to the upgrade flowchain as first step. Also the component table\nis updated with the new states\n- as replacing the instances is implemented using full repair, this\ncommit adds a step to `upgradeOs` calls where it replaces the salt\nstates stored in `ClusterComponent` table. In this case we don't\ninitiate a highstate as the new GW node will come up with the new\nstates during the upgrade/repair. If the upgrade/repair flow cannot be\ninitiated the `ClusterComponent` is rolled back to previous version as\nit is a versioned entity\n\nAs a result we don't check if salt version is matching in the future.\n\nNotable refactors:\n- `ClusterRepairService#validateRepair` had a big, ugly transaction.\nThis has been removed and where it was necessary separate repository\ncalls have been introduced\n- there were some hand written checks for running flows which has been\neliminated as flow engine won't accept new flows if there is one\nalready running"}, "afterCommit": {"oid": "ccf08f00af354317cb877359d9dd8ebb5ba72eef", "author": {"user": {"login": "lacikaaa", "name": "Mihaly Laszlo Molnar"}}, "url": "https://github.com/hortonworks/cloudbreak/commit/ccf08f00af354317cb877359d9dd8ebb5ba72eef", "committedDate": "2020-08-27T11:09:36Z", "message": "CB-7040 Upgrade salt states during Datalake upgrade\n\nSalt upgrade has been added in 2 places:\n- before starting the runtime upgrade the states pushed down to the GW\nnodes and a highstate is called. This is a separate flow which is\nadded to the upgrade flowchain as first step. Also the component table\nis updated with the new states\n- as replacing the instances is implemented using full repair, this\ncommit adds a step to `upgradeOs` calls where it replaces the salt\nstates stored in `ClusterComponent` table. In this case we don't\ninitiate a highstate as the new GW node will come up with the new\nstates during the upgrade/repair. If the upgrade/repair flow cannot be\ninitiated the `ClusterComponent` is rolled back to previous version as\nit is a versioned entity\n\nAs a result we don't check if salt version is matching in the future.\n\nNotable refactors:\n- `ClusterRepairService#validateRepair` had a big, ugly transaction.\nThis has been removed and where it was necessary separate repository\ncalls have been introduced\n- there were some hand written checks for running flows which has been\neliminated as flow engine won't accept new flows if there is one\nalready running"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2365, "cost": 1, "resetAt": "2021-11-01T14:51:55Z"}}}