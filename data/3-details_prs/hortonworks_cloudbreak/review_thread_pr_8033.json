{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDE3MjQ4OTAw", "number": 8033, "reviewThreads": {"totalCount": 11, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMFQwNjowNTozN1rOD-EeyA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMlQwNzo0Njo0M1rOEBocCw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY2NDExNzIwOnYy", "diffSide": "RIGHT", "path": "integration-test/src/main/java/com/sequenceiq/it/cloudbreak/util/wait/service/database/DatabaseAwait.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMFQwNjowNTozN1rOGX8dLg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMFQxMTozMDoxOVrOGYHMhQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzc2MDk0Mg==", "bodyText": "Why are we refreshing with null?", "url": "https://github.com/hortonworks/cloudbreak/pull/8033#discussion_r427760942", "createdAt": "2020-05-20T06:05:37Z", "author": {"login": "lnardai"}, "path": "integration-test/src/main/java/com/sequenceiq/it/cloudbreak/util/wait/service/database/DatabaseAwait.java", "diffHunk": "@@ -0,0 +1,72 @@\n+package com.sequenceiq.it.cloudbreak.util.wait.service.database;\n+\n+import static com.sequenceiq.redbeams.api.model.common.Status.DELETE_COMPLETED;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.stereotype.Component;\n+\n+import com.sequenceiq.it.cloudbreak.RedbeamsClient;\n+import com.sequenceiq.it.cloudbreak.context.RunningParameter;\n+import com.sequenceiq.it.cloudbreak.context.TestContext;\n+import com.sequenceiq.it.cloudbreak.dto.database.RedbeamsDatabaseServerTestDto;\n+import com.sequenceiq.it.cloudbreak.log.Log;\n+import com.sequenceiq.it.cloudbreak.util.ResponseUtil;\n+import com.sequenceiq.it.cloudbreak.util.wait.service.Await;\n+import com.sequenceiq.it.cloudbreak.util.wait.service.ExceptionChecker;\n+import com.sequenceiq.it.cloudbreak.util.wait.service.Result;\n+import com.sequenceiq.it.cloudbreak.util.wait.service.WaitResult;\n+import com.sequenceiq.redbeams.api.model.common.Status;\n+\n+@Component\n+public class DatabaseAwait extends Await<RedbeamsDatabaseServerTestDto, Status> {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(DatabaseAwait.class);\n+\n+    @Override\n+    public RedbeamsDatabaseServerTestDto await(RedbeamsDatabaseServerTestDto entity, Status desiredStatus, TestContext testContext,\n+            RunningParameter runningParameter, long pollingInterval, int maxRetry) {\n+        try {\n+            if (entity == null) {\n+                throw new RuntimeException(\"Database key has been provided but no result in resource map!\");\n+            }\n+            Log.await(LOGGER, String.format(\"%s for %s\", entity.getResponse().getName(), desiredStatus));\n+            RedbeamsClient client = testContext.getMicroserviceClient(RedbeamsClient.class, testContext.getWho(runningParameter)\n+                    .getAccessKey());\n+            String crn = entity.getResponse().getResourceCrn();\n+            switch (desiredStatus) {\n+                case AVAILABLE:\n+                case STOPPED:\n+                    waitForDatabaseStatus(new DatabaseOperationChecker<>(), client, crn, testContext, desiredStatus,\n+                            pollingInterval, maxRetry);\n+                    break;\n+                case DELETE_COMPLETED:\n+                    waitForDatabaseStatus(new DatabaseTerminationChecker<>(), client, crn, testContext, desiredStatus,\n+                            pollingInterval, maxRetry);\n+                    break;\n+                default:\n+                    LOGGER.warn(\"Wait checker is not implemented yet for the desired database state '{}' \", desiredStatus);\n+                    break;\n+            }\n+            if (!desiredStatus.equals(DELETE_COMPLETED)) {\n+                entity.refresh(testContext, null);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2fa44c1e3d7c9d8d494f2c0d53953b129062cc57"}, "originalPosition": 52}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzkzNjkwMQ==", "bodyText": "Here is the CloudbreakClient should be passed.\nawaitEntity.refresh(getTestContext(), (CloudbreakClient) null);}\nHowever that is not defined in RedbeamsDatabaseServerTestDto await.\nAnyway we can remove this from Redbeams Await, because of Redbeams is\n\n\"not refreshable resource\"\n\nindeed", "url": "https://github.com/hortonworks/cloudbreak/pull/8033#discussion_r427936901", "createdAt": "2020-05-20T11:30:19Z", "author": {"login": "aszegedi"}, "path": "integration-test/src/main/java/com/sequenceiq/it/cloudbreak/util/wait/service/database/DatabaseAwait.java", "diffHunk": "@@ -0,0 +1,72 @@\n+package com.sequenceiq.it.cloudbreak.util.wait.service.database;\n+\n+import static com.sequenceiq.redbeams.api.model.common.Status.DELETE_COMPLETED;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.stereotype.Component;\n+\n+import com.sequenceiq.it.cloudbreak.RedbeamsClient;\n+import com.sequenceiq.it.cloudbreak.context.RunningParameter;\n+import com.sequenceiq.it.cloudbreak.context.TestContext;\n+import com.sequenceiq.it.cloudbreak.dto.database.RedbeamsDatabaseServerTestDto;\n+import com.sequenceiq.it.cloudbreak.log.Log;\n+import com.sequenceiq.it.cloudbreak.util.ResponseUtil;\n+import com.sequenceiq.it.cloudbreak.util.wait.service.Await;\n+import com.sequenceiq.it.cloudbreak.util.wait.service.ExceptionChecker;\n+import com.sequenceiq.it.cloudbreak.util.wait.service.Result;\n+import com.sequenceiq.it.cloudbreak.util.wait.service.WaitResult;\n+import com.sequenceiq.redbeams.api.model.common.Status;\n+\n+@Component\n+public class DatabaseAwait extends Await<RedbeamsDatabaseServerTestDto, Status> {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(DatabaseAwait.class);\n+\n+    @Override\n+    public RedbeamsDatabaseServerTestDto await(RedbeamsDatabaseServerTestDto entity, Status desiredStatus, TestContext testContext,\n+            RunningParameter runningParameter, long pollingInterval, int maxRetry) {\n+        try {\n+            if (entity == null) {\n+                throw new RuntimeException(\"Database key has been provided but no result in resource map!\");\n+            }\n+            Log.await(LOGGER, String.format(\"%s for %s\", entity.getResponse().getName(), desiredStatus));\n+            RedbeamsClient client = testContext.getMicroserviceClient(RedbeamsClient.class, testContext.getWho(runningParameter)\n+                    .getAccessKey());\n+            String crn = entity.getResponse().getResourceCrn();\n+            switch (desiredStatus) {\n+                case AVAILABLE:\n+                case STOPPED:\n+                    waitForDatabaseStatus(new DatabaseOperationChecker<>(), client, crn, testContext, desiredStatus,\n+                            pollingInterval, maxRetry);\n+                    break;\n+                case DELETE_COMPLETED:\n+                    waitForDatabaseStatus(new DatabaseTerminationChecker<>(), client, crn, testContext, desiredStatus,\n+                            pollingInterval, maxRetry);\n+                    break;\n+                default:\n+                    LOGGER.warn(\"Wait checker is not implemented yet for the desired database state '{}' \", desiredStatus);\n+                    break;\n+            }\n+            if (!desiredStatus.equals(DELETE_COMPLETED)) {\n+                entity.refresh(testContext, null);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzc2MDk0Mg=="}, "originalCommit": {"oid": "2fa44c1e3d7c9d8d494f2c0d53953b129062cc57"}, "originalPosition": 52}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY5MjU5NjEzOnYy", "diffSide": "RIGHT", "path": "integration-test/src/main/java/com/sequenceiq/it/cloudbreak/util/wait/service/cloudbreak/CloudbreakWaitObject.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOVQwNzozMzozN1rOGcR3wA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOVQwNzozMzozN1rOGcR3wA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjMwNjExMg==", "bodyText": "I think the below alternative is more efficient.\n        Set<Status> failedStatuses = Set.of(UPDATE_FAILED, CREATE_FAILED, ENABLE_SECURITY_FAILED, DELETE_FAILED, START_FAILED, STOP_FAILED,\n                EXTERNAL_DATABASE_CREATION_FAILED, EXTERNAL_DATABASE_DELETION_FAILED);\n        return !Sets.intersection(failedStatuses, Set.copyOf(distroxStatuses.values())).isEmpty();", "url": "https://github.com/hortonworks/cloudbreak/pull/8033#discussion_r432306112", "createdAt": "2020-05-29T07:33:37Z", "author": {"login": "foldik"}, "path": "integration-test/src/main/java/com/sequenceiq/it/cloudbreak/util/wait/service/cloudbreak/CloudbreakWaitObject.java", "diffHunk": "@@ -0,0 +1,64 @@\n+package com.sequenceiq.it.cloudbreak.util.wait.service.cloudbreak;\n+\n+import static com.sequenceiq.cloudbreak.api.endpoint.v4.common.Status.CREATE_FAILED;\n+import static com.sequenceiq.cloudbreak.api.endpoint.v4.common.Status.DELETE_FAILED;\n+import static com.sequenceiq.cloudbreak.api.endpoint.v4.common.Status.ENABLE_SECURITY_FAILED;\n+import static com.sequenceiq.cloudbreak.api.endpoint.v4.common.Status.EXTERNAL_DATABASE_CREATION_FAILED;\n+import static com.sequenceiq.cloudbreak.api.endpoint.v4.common.Status.EXTERNAL_DATABASE_DELETION_FAILED;\n+import static com.sequenceiq.cloudbreak.api.endpoint.v4.common.Status.START_FAILED;\n+import static com.sequenceiq.cloudbreak.api.endpoint.v4.common.Status.STOP_FAILED;\n+import static com.sequenceiq.cloudbreak.api.endpoint.v4.common.Status.UPDATE_FAILED;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.apache.commons.collections.CollectionUtils;\n+\n+import com.sequenceiq.cloudbreak.api.endpoint.v4.common.Status;\n+import com.sequenceiq.cloudbreak.api.endpoint.v4.stacks.StackV4Endpoint;\n+import com.sequenceiq.distrox.api.v1.distrox.endpoint.DistroXV1Endpoint;\n+import com.sequenceiq.it.cloudbreak.CloudbreakClient;\n+\n+public class CloudbreakWaitObject {\n+\n+    private final CloudbreakClient client;\n+\n+    private final String name;\n+\n+    private final Map<String, Status> desiredStatuses;\n+\n+    public CloudbreakWaitObject(CloudbreakClient client, String name, Map<String, Status> desiredStatuses) {\n+        this.client = client;\n+        this.name = name;\n+        this.desiredStatuses = desiredStatuses;\n+    }\n+\n+    public DistroXV1Endpoint getDistroxEndpoint() {\n+        return client.getCloudbreakClient().distroXV1Endpoint();\n+    }\n+\n+    public StackV4Endpoint getStackEndpoint() {\n+        return client.getCloudbreakClient().stackV4Endpoint();\n+    }\n+\n+    public Long getWorkspaceId() {\n+        return client.getWorkspaceId();\n+    }\n+\n+    public String getName() {\n+        return name;\n+    }\n+\n+    public Map<String, Status> getDesiredStatuses() {\n+        return desiredStatuses;\n+    }\n+\n+    public boolean isFailed(Map<String, Status> distroxStatuses) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c4492a300357bb0068805091911643075df7dfcf"}, "originalPosition": 57}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY5MjYwNTk2OnYy", "diffSide": "RIGHT", "path": "integration-test/src/main/java/com/sequenceiq/it/cloudbreak/util/wait/service/database/DatabaseOperationChecker.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOVQwNzozNzowNVrOGcR93g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOVQwNzozNzowNVrOGcR93g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjMwNzY3OA==", "bodyText": "Why call it twice? I guess the compiler will optimize it anyway but still strange a bit. I saw it earlier as well in other files. Can you please introduce a message variable?", "url": "https://github.com/hortonworks/cloudbreak/pull/8033#discussion_r432307678", "createdAt": "2020-05-29T07:37:05Z", "author": {"login": "foldik"}, "path": "integration-test/src/main/java/com/sequenceiq/it/cloudbreak/util/wait/service/database/DatabaseOperationChecker.java", "diffHunk": "@@ -0,0 +1,135 @@\n+package com.sequenceiq.it.cloudbreak.util.wait.service.database;\n+\n+import static com.sequenceiq.redbeams.api.model.common.Status.CREATE_FAILED;\n+import static com.sequenceiq.redbeams.api.model.common.Status.DELETE_COMPLETED;\n+import static com.sequenceiq.redbeams.api.model.common.Status.DELETE_IN_PROGRESS;\n+import static com.sequenceiq.redbeams.api.model.common.Status.DELETE_REQUESTED;\n+import static com.sequenceiq.redbeams.api.model.common.Status.PRE_DELETE_IN_PROGRESS;\n+\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Map;\n+\n+import javax.ws.rs.ProcessingException;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.sequenceiq.it.cloudbreak.exception.TestFailException;\n+import com.sequenceiq.it.cloudbreak.util.wait.service.ExceptionChecker;\n+import com.sequenceiq.redbeams.api.endpoint.v4.databaseserver.responses.DatabaseServerV4Response;\n+import com.sequenceiq.redbeams.api.model.common.Status;\n+\n+public class DatabaseOperationChecker<T extends DatabaseWaitObject> extends ExceptionChecker<T> {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(DatabaseOperationChecker.class);\n+\n+    @Override\n+    public boolean checkStatus(T waitObject) {\n+        String crn = waitObject.getCrn();\n+        Status desiredStatus = waitObject.getDesiredStatus();\n+        try {\n+            DatabaseServerV4Response database = waitObject.getEndpoint().getByCrn(crn);\n+            if (database == null) {\n+                throw new TestFailException(String.format(\"'%s' database was not found.\", crn));\n+            }\n+            String name = database.getName();\n+            Status status = database.getStatus();\n+            LOGGER.info(\"Waiting for the '{}' state of '{}' '{}' database. Actual state is: '{}'\", desiredStatus, name, crn, status);\n+            if (isDeletionInProgress(status) || status == DELETE_COMPLETED) {\n+                LOGGER.error(\"Database '{}' '{}' has been getting terminated (status:'{}'), waiting is cancelled.\", name, crn, status);\n+                throw new TestFailException(String.format(\"Database '%s' '%s' has been getting terminated (status:'%s'), waiting is cancelled.\", name, crn,\n+                        status));\n+            }\n+            if (waitObject.isFailed(status)) {\n+                LOGGER.error(\"Database '{}' '{}' is in failed state (status:'{}'), waiting is cancelled.\", name, crn, status);\n+                throw new TestFailException(String.format(\"Database '%s' '%s' is in failed state. Status: '%s' statusReason: '%s'\",\n+                        name, crn, status, database.getStatusReason()));\n+            }\n+            if (desiredStatus.equals(status)) {\n+                return true;\n+            }\n+        } catch (Exception e) {\n+            StringBuilder builder = new StringBuilder(\"Database has been failed. Also failed to get database status: \")\n+                    .append(System.lineSeparator())\n+                    .append(e.getMessage())\n+                    .append(System.lineSeparator())\n+                    .append(e);\n+            LOGGER.error(builder.toString());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c4492a300357bb0068805091911643075df7dfcf"}, "originalPosition": 58}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY5MjYxMjIxOnYy", "diffSide": "RIGHT", "path": "integration-test/src/main/java/com/sequenceiq/it/cloudbreak/util/wait/service/database/DatabaseOperationChecker.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOVQwNzozOToxM1rOGcSBvg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOVQwNzozOToxM1rOGcSBvg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjMwODY3MA==", "bodyText": "For pure logging please use the LOGGER.error(\"message {} {}\", arg1,, arg2) format. I saw it other places as well. Please avoid manual string concatenation when possible.", "url": "https://github.com/hortonworks/cloudbreak/pull/8033#discussion_r432308670", "createdAt": "2020-05-29T07:39:13Z", "author": {"login": "foldik"}, "path": "integration-test/src/main/java/com/sequenceiq/it/cloudbreak/util/wait/service/database/DatabaseOperationChecker.java", "diffHunk": "@@ -0,0 +1,135 @@\n+package com.sequenceiq.it.cloudbreak.util.wait.service.database;\n+\n+import static com.sequenceiq.redbeams.api.model.common.Status.CREATE_FAILED;\n+import static com.sequenceiq.redbeams.api.model.common.Status.DELETE_COMPLETED;\n+import static com.sequenceiq.redbeams.api.model.common.Status.DELETE_IN_PROGRESS;\n+import static com.sequenceiq.redbeams.api.model.common.Status.DELETE_REQUESTED;\n+import static com.sequenceiq.redbeams.api.model.common.Status.PRE_DELETE_IN_PROGRESS;\n+\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Map;\n+\n+import javax.ws.rs.ProcessingException;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.sequenceiq.it.cloudbreak.exception.TestFailException;\n+import com.sequenceiq.it.cloudbreak.util.wait.service.ExceptionChecker;\n+import com.sequenceiq.redbeams.api.endpoint.v4.databaseserver.responses.DatabaseServerV4Response;\n+import com.sequenceiq.redbeams.api.model.common.Status;\n+\n+public class DatabaseOperationChecker<T extends DatabaseWaitObject> extends ExceptionChecker<T> {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(DatabaseOperationChecker.class);\n+\n+    @Override\n+    public boolean checkStatus(T waitObject) {\n+        String crn = waitObject.getCrn();\n+        Status desiredStatus = waitObject.getDesiredStatus();\n+        try {\n+            DatabaseServerV4Response database = waitObject.getEndpoint().getByCrn(crn);\n+            if (database == null) {\n+                throw new TestFailException(String.format(\"'%s' database was not found.\", crn));\n+            }\n+            String name = database.getName();\n+            Status status = database.getStatus();\n+            LOGGER.info(\"Waiting for the '{}' state of '{}' '{}' database. Actual state is: '{}'\", desiredStatus, name, crn, status);\n+            if (isDeletionInProgress(status) || status == DELETE_COMPLETED) {\n+                LOGGER.error(\"Database '{}' '{}' has been getting terminated (status:'{}'), waiting is cancelled.\", name, crn, status);\n+                throw new TestFailException(String.format(\"Database '%s' '%s' has been getting terminated (status:'%s'), waiting is cancelled.\", name, crn,\n+                        status));\n+            }\n+            if (waitObject.isFailed(status)) {\n+                LOGGER.error(\"Database '{}' '{}' is in failed state (status:'{}'), waiting is cancelled.\", name, crn, status);\n+                throw new TestFailException(String.format(\"Database '%s' '%s' is in failed state. Status: '%s' statusReason: '%s'\",\n+                        name, crn, status, database.getStatusReason()));\n+            }\n+            if (desiredStatus.equals(status)) {\n+                return true;\n+            }\n+        } catch (Exception e) {\n+            StringBuilder builder = new StringBuilder(\"Database has been failed. Also failed to get database status: \")\n+                    .append(System.lineSeparator())\n+                    .append(e.getMessage())\n+                    .append(System.lineSeparator())\n+                    .append(e);\n+            LOGGER.error(builder.toString());\n+            throw new TestFailException(builder.toString());\n+        }\n+        return false;\n+    }\n+\n+    @Override\n+    public void handleTimeout(T waitObject) {\n+        String crn = waitObject.getCrn();\n+        try {\n+            DatabaseServerV4Response database = waitObject.getEndpoint().getByCrn(crn);\n+            if (database == null) {\n+                throw new TestFailException(String.format(\"'%s' database was not found.\", crn));\n+            }\n+            String name = database.getName();\n+            Status status = database.getStatus();\n+            throw new TestFailException(String.format(\"Wait operation timed out, database '%s' '%s' has been failed. Database status: '%s' \"\n+                    + \"statusReason: '%s'\", name, crn, status, database.getStatusReason()));\n+        } catch (Exception e) {\n+            StringBuilder builder = new StringBuilder(\"Wait operation timed out, database has been failed. Also failed to get database status: \")\n+                    .append(System.lineSeparator())\n+                    .append(e.getMessage())\n+                    .append(System.lineSeparator())\n+                    .append(e);\n+            LOGGER.error(builder.toString());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c4492a300357bb0068805091911643075df7dfcf"}, "originalPosition": 82}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY5MjYxODY4OnYy", "diffSide": "RIGHT", "path": "integration-test/src/main/java/com/sequenceiq/it/cloudbreak/util/wait/service/database/DatabaseWaitObject.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOVQwNzo0MToxNFrOGcSFwg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOVQwNzo0MToxNFrOGcSFwg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjMwOTY5OA==", "bodyText": "Please use a Set instead.", "url": "https://github.com/hortonworks/cloudbreak/pull/8033#discussion_r432309698", "createdAt": "2020-05-29T07:41:14Z", "author": {"login": "foldik"}, "path": "integration-test/src/main/java/com/sequenceiq/it/cloudbreak/util/wait/service/database/DatabaseWaitObject.java", "diffHunk": "@@ -0,0 +1,47 @@\n+package com.sequenceiq.it.cloudbreak.util.wait.service.database;\n+\n+import static com.sequenceiq.redbeams.api.model.common.Status.CREATE_FAILED;\n+import static com.sequenceiq.redbeams.api.model.common.Status.DELETE_FAILED;\n+import static com.sequenceiq.redbeams.api.model.common.Status.ENABLE_SECURITY_FAILED;\n+import static com.sequenceiq.redbeams.api.model.common.Status.START_FAILED;\n+import static com.sequenceiq.redbeams.api.model.common.Status.STOP_FAILED;\n+import static com.sequenceiq.redbeams.api.model.common.Status.UPDATE_FAILED;\n+\n+import java.util.Collection;\n+import java.util.List;\n+\n+import com.sequenceiq.it.cloudbreak.RedbeamsClient;\n+import com.sequenceiq.redbeams.api.endpoint.v4.databaseserver.DatabaseServerV4Endpoint;\n+import com.sequenceiq.redbeams.api.model.common.Status;\n+\n+public class DatabaseWaitObject {\n+\n+    private final RedbeamsClient client;\n+\n+    private final String crn;\n+\n+    private final Status desiredStatus;\n+\n+    public DatabaseWaitObject(RedbeamsClient client, String crn, Status desiredStatus) {\n+        this.client = client;\n+        this.crn = crn;\n+        this.desiredStatus = desiredStatus;\n+    }\n+\n+    public DatabaseServerV4Endpoint getEndpoint() {\n+        return client.getEndpoints().databaseServerV4Endpoint();\n+    }\n+\n+    public String getCrn() {\n+        return crn;\n+    }\n+\n+    public Status getDesiredStatus() {\n+        return desiredStatus;\n+    }\n+\n+    public boolean isFailed(Status databaseStatus) {\n+        Collection<Status> failedStatuses = List.of(UPDATE_FAILED, CREATE_FAILED, ENABLE_SECURITY_FAILED, DELETE_FAILED, START_FAILED, STOP_FAILED);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c4492a300357bb0068805091911643075df7dfcf"}, "originalPosition": 44}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY5MjYyMjQ5OnYy", "diffSide": "RIGHT", "path": "integration-test/src/main/java/com/sequenceiq/it/cloudbreak/util/wait/service/datalake/DatalakeWaitObject.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOVQwNzo0MjoyMlrOGcSIEA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOVQwNzo0MjoyMlrOGcSIEA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjMxMDI4OA==", "bodyText": "Please use a Set.", "url": "https://github.com/hortonworks/cloudbreak/pull/8033#discussion_r432310288", "createdAt": "2020-05-29T07:42:22Z", "author": {"login": "foldik"}, "path": "integration-test/src/main/java/com/sequenceiq/it/cloudbreak/util/wait/service/datalake/DatalakeWaitObject.java", "diffHunk": "@@ -0,0 +1,50 @@\n+package com.sequenceiq.it.cloudbreak.util.wait.service.datalake;\n+\n+import static com.sequenceiq.sdx.api.model.SdxClusterStatusResponse.DATALAKE_UPGRADE_FAILED;\n+import static com.sequenceiq.sdx.api.model.SdxClusterStatusResponse.DELETE_FAILED;\n+import static com.sequenceiq.sdx.api.model.SdxClusterStatusResponse.PROVISIONING_FAILED;\n+import static com.sequenceiq.sdx.api.model.SdxClusterStatusResponse.REPAIR_FAILED;\n+import static com.sequenceiq.sdx.api.model.SdxClusterStatusResponse.START_FAILED;\n+import static com.sequenceiq.sdx.api.model.SdxClusterStatusResponse.STOP_FAILED;\n+import static com.sequenceiq.sdx.api.model.SdxClusterStatusResponse.SYNC_FAILED;\n+import static com.sequenceiq.sdx.api.model.SdxClusterStatusResponse.UPGRADE_FAILED;\n+\n+import java.util.Collection;\n+import java.util.List;\n+\n+import com.sequenceiq.it.cloudbreak.SdxClient;\n+import com.sequenceiq.sdx.api.endpoint.SdxEndpoint;\n+import com.sequenceiq.sdx.api.model.SdxClusterStatusResponse;\n+\n+public class DatalakeWaitObject {\n+\n+    private final SdxClient client;\n+\n+    private final String name;\n+\n+    private final SdxClusterStatusResponse desiredStatus;\n+\n+    public DatalakeWaitObject(SdxClient client, String name, SdxClusterStatusResponse desiredStatus) {\n+        this.client = client;\n+        this.name = name;\n+        this.desiredStatus = desiredStatus;\n+    }\n+\n+    public SdxEndpoint getEndpoint() {\n+        return client.getSdxClient().sdxEndpoint();\n+    }\n+\n+    public String getName() {\n+        return name;\n+    }\n+\n+    public SdxClusterStatusResponse getDesiredStatus() {\n+        return desiredStatus;\n+    }\n+\n+    public boolean isFailed(SdxClusterStatusResponse datalakeStatus) {\n+        Collection<SdxClusterStatusResponse> failedStatuses = List.of(PROVISIONING_FAILED, REPAIR_FAILED, UPGRADE_FAILED, DATALAKE_UPGRADE_FAILED,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c4492a300357bb0068805091911643075df7dfcf"}, "originalPosition": 46}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY5MjYyNjAzOnYy", "diffSide": "RIGHT", "path": "integration-test/src/main/java/com/sequenceiq/it/cloudbreak/util/wait/service/environment/EnvironmentOperationChecker.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOVQwNzo0MzoxNlrOGcSKLQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOVQwNzo0MzoxNlrOGcSKLQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjMxMDgyOQ==", "bodyText": "Please use a set.", "url": "https://github.com/hortonworks/cloudbreak/pull/8033#discussion_r432310829", "createdAt": "2020-05-29T07:43:16Z", "author": {"login": "foldik"}, "path": "integration-test/src/main/java/com/sequenceiq/it/cloudbreak/util/wait/service/environment/EnvironmentOperationChecker.java", "diffHunk": "@@ -112,24 +113,29 @@ public boolean exitWaiting(T waitObject) {\n             }\n             return status.isFailed();\n         } catch (ProcessingException clientException) {\n-            StringBuilder builder = new StringBuilder(\"Exit waiting! Failed to get environment due to API client exception: \")\n-                    .append(System.lineSeparator())\n-                    .append(clientException.getMessage())\n-                    .append(System.lineSeparator())\n-                    .append(clientException);\n-            LOGGER.error(builder.toString());\n+            String builder = \"Exit waiting! Failed to get environment due to API client exception: \" +\n+                    System.lineSeparator() +\n+                    clientException.getMessage() +\n+                    System.lineSeparator() +\n+                    clientException;\n+            LOGGER.error(builder);\n         } catch (Exception e) {\n-            StringBuilder builder = new StringBuilder(\"Exit waiting! Failed to get environment, because of: \")\n-                    .append(System.lineSeparator())\n-                    .append(e.getMessage())\n-                    .append(System.lineSeparator())\n-                    .append(e);\n-            LOGGER.error(builder.toString());\n+            String builder = \"Exit waiting! Failed to get environment, because of: \" +\n+                    System.lineSeparator() +\n+                    e.getMessage() +\n+                    System.lineSeparator() +\n+                    e;\n+            LOGGER.error(builder);\n             return true;\n         }\n         return false;\n     }\n \n+    @Override\n+    public Map<String, String> getStatuses(T waitObject) {\n+        return Map.of(\"status\", waitObject.getEndpoint().getByCrn(waitObject.getCrn()).getEnvironmentStatus().name());\n+    }\n+\n     private boolean isDeletionInProgress(EnvironmentStatus environmentStatus) {\n         Collection<EnvironmentStatus> deleteInProgressStatuses = List.of(DELETE_INITIATED, NETWORK_DELETE_IN_PROGRESS, RDBMS_DELETE_IN_PROGRESS,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c4492a300357bb0068805091911643075df7dfcf"}, "originalPosition": 48}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcwMTI4OTY3OnYy", "diffSide": "RIGHT", "path": "integration-test/src/main/java/com/sequenceiq/it/cloudbreak/util/wait/service/WaitService.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMlQwNjo0Nzo1MVrOGdkNeQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMlQwNjo0Nzo1MVrOGdkNeQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzY1NTE2MQ==", "bodyText": "I would rename t to WaitObject or something similar", "url": "https://github.com/hortonworks/cloudbreak/pull/8033#discussion_r433655161", "createdAt": "2020-06-02T06:47:51Z", "author": {"login": "gergopapi2"}, "path": "integration-test/src/main/java/com/sequenceiq/it/cloudbreak/util/wait/service/WaitService.java", "diffHunk": "@@ -1,27 +1,33 @@\n package com.sequenceiq.it.cloudbreak.util.wait.service;\n \n+import java.util.Map;\n+\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n import org.springframework.stereotype.Component;\n \n+import com.sequenceiq.it.cloudbreak.context.TestContext;\n+\n @Component\n public class WaitService<T> {\n     private static final Logger LOGGER = LoggerFactory.getLogger(WaitService.class);\n \n-    public Result<WaitResult, Exception> waitWithTimeout(StatusChecker<T> statusChecker, T t, long interval, int maxAttempts, int maxFailure) {\n-        return waitWithTimeout(statusChecker, t, interval, new TimeoutChecker(maxAttempts), maxFailure);\n+    public Result<WaitResult, Exception> waitWithTimeout(StatusChecker<T> statusChecker, T t, TestContext testContext, long interval, int maxAttempts,\n+            int maxFailure) {\n+        return waitWithTimeout(statusChecker, t, testContext, interval, new TimeoutChecker(maxAttempts), maxFailure);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7a477a27dc7441d01edc5effc0a1b890f0b27b55"}, "originalPosition": 19}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcwMTMxMTY3OnYy", "diffSide": "RIGHT", "path": "integration-test/src/main/java/com/sequenceiq/it/cloudbreak/testcase/mock/clouderamanager/CMUpscaleWithHttp500ResponsesTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMlQwNjo1NTo0MVrOGdka4Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMlQwNjo1NTo0MVrOGdka4Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzY1ODU5Mw==", "bodyText": "In general I would use type Duration for a time duration, that has also a unit included. This might mean passing a type Duration and at the sleep step using Duration.toMillis() method.\nIf that is too big of a change, I would 1) extract this to a constant with name including the unit, and 2) rename the variables interval to intervalMillis.", "url": "https://github.com/hortonworks/cloudbreak/pull/8033#discussion_r433658593", "createdAt": "2020-06-02T06:55:41Z", "author": {"login": "gergopapi2"}, "path": "integration-test/src/main/java/com/sequenceiq/it/cloudbreak/testcase/mock/clouderamanager/CMUpscaleWithHttp500ResponsesTest.java", "diffHunk": "@@ -131,7 +131,7 @@ public void testUpscale(MockedTestContext testContext) {\n                 .when(stackTestClient.createV4())\n                 .await(STACK_AVAILABLE)\n                 .when(StackScalePostAction.valid().withDesiredCount(desiredWorkerCount).withForced(Boolean.FALSE))\n-                .await(StackTestDto.class, STACK_AVAILABLE)\n+                .await(StackTestDto.class, STACK_AVAILABLE, 3000)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7a477a27dc7441d01edc5effc0a1b890f0b27b55"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcwMTM0MDQ3OnYy", "diffSide": "RIGHT", "path": "integration-test/src/main/java/com/sequenceiq/it/cloudbreak/util/wait/service/database/DatabaseAwait.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMlQwNzowNjowMFrOGdkskg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMlQwNzowNjowMFrOGdkskg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzY2MzEyMg==", "bodyText": "I would rename Database* to Redbeams*, to avoid confusion with the existing Database endpoints on cloudbreak.\nOr, if you want to keep the database name, then I would rename it to DatabaseServer*, to avoid confusion with Database endpoints on redbeams.", "url": "https://github.com/hortonworks/cloudbreak/pull/8033#discussion_r433663122", "createdAt": "2020-06-02T07:06:00Z", "author": {"login": "gergopapi2"}, "path": "integration-test/src/main/java/com/sequenceiq/it/cloudbreak/util/wait/service/database/DatabaseAwait.java", "diffHunk": "@@ -0,0 +1,67 @@\n+package com.sequenceiq.it.cloudbreak.util.wait.service.database;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.stereotype.Component;\n+\n+import com.sequenceiq.it.cloudbreak.RedbeamsClient;\n+import com.sequenceiq.it.cloudbreak.context.RunningParameter;\n+import com.sequenceiq.it.cloudbreak.context.TestContext;\n+import com.sequenceiq.it.cloudbreak.dto.database.RedbeamsDatabaseServerTestDto;\n+import com.sequenceiq.it.cloudbreak.log.Log;\n+import com.sequenceiq.it.cloudbreak.util.ResponseUtil;\n+import com.sequenceiq.it.cloudbreak.util.wait.service.Await;\n+import com.sequenceiq.it.cloudbreak.util.wait.service.ExceptionChecker;\n+import com.sequenceiq.it.cloudbreak.util.wait.service.Result;\n+import com.sequenceiq.it.cloudbreak.util.wait.service.WaitResult;\n+import com.sequenceiq.redbeams.api.model.common.Status;\n+\n+@Component\n+public class DatabaseAwait extends Await<RedbeamsDatabaseServerTestDto, Status> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7a477a27dc7441d01edc5effc0a1b890f0b27b55"}, "originalPosition": 20}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcwMTQ2NTcxOnYy", "diffSide": "RIGHT", "path": "integration-test/src/main/java/com/sequenceiq/it/cloudbreak/util/wait/service/database/DatabaseAwait.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMlQwNzo0Njo0M1rOGdl7sQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMlQwNzo0Njo0M1rOGdl7sQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzY4MzM3Nw==", "bodyText": "I put this question here but relates to all Await implementations: if waiting for a given status is not implemented but a test developer wants to wait for it in his test, how will he be notified?\n@aszegedi, you suggested in personal communications, that switch-case could be converted to plain if-else, distinguishing between delete and non-delete operations, could make sense.", "url": "https://github.com/hortonworks/cloudbreak/pull/8033#discussion_r433683377", "createdAt": "2020-06-02T07:46:43Z", "author": {"login": "gergopapi2"}, "path": "integration-test/src/main/java/com/sequenceiq/it/cloudbreak/util/wait/service/database/DatabaseAwait.java", "diffHunk": "@@ -0,0 +1,67 @@\n+package com.sequenceiq.it.cloudbreak.util.wait.service.database;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.stereotype.Component;\n+\n+import com.sequenceiq.it.cloudbreak.RedbeamsClient;\n+import com.sequenceiq.it.cloudbreak.context.RunningParameter;\n+import com.sequenceiq.it.cloudbreak.context.TestContext;\n+import com.sequenceiq.it.cloudbreak.dto.database.RedbeamsDatabaseServerTestDto;\n+import com.sequenceiq.it.cloudbreak.log.Log;\n+import com.sequenceiq.it.cloudbreak.util.ResponseUtil;\n+import com.sequenceiq.it.cloudbreak.util.wait.service.Await;\n+import com.sequenceiq.it.cloudbreak.util.wait.service.ExceptionChecker;\n+import com.sequenceiq.it.cloudbreak.util.wait.service.Result;\n+import com.sequenceiq.it.cloudbreak.util.wait.service.WaitResult;\n+import com.sequenceiq.redbeams.api.model.common.Status;\n+\n+@Component\n+public class DatabaseAwait extends Await<RedbeamsDatabaseServerTestDto, Status> {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(DatabaseAwait.class);\n+\n+    @Override\n+    public RedbeamsDatabaseServerTestDto await(RedbeamsDatabaseServerTestDto entity, Status desiredStatus, TestContext testContext,\n+            RunningParameter runningParameter, long pollingInterval, int maxRetry) {\n+        try {\n+            if (entity == null) {\n+                throw new RuntimeException(\"Database key has been provided but no result in resource map!\");\n+            }\n+            Log.await(LOGGER, String.format(\"%s for %s\", entity.getResponse().getName(), desiredStatus));\n+            RedbeamsClient client = testContext.getMicroserviceClient(RedbeamsClient.class, testContext.getWho(runningParameter)\n+                    .getAccessKey());\n+            String crn = entity.getResponse().getResourceCrn();\n+            switch (desiredStatus) {\n+                case AVAILABLE:\n+                case STOPPED:\n+                    waitForDatabaseStatus(new DatabaseOperationChecker<>(), client, crn, testContext, desiredStatus,\n+                            pollingInterval, maxRetry);\n+                    break;\n+                case DELETE_COMPLETED:\n+                    waitForDatabaseStatus(new DatabaseTerminationChecker<>(), client, crn, testContext, desiredStatus,\n+                            pollingInterval, maxRetry);\n+                    break;\n+                default:\n+                    LOGGER.warn(\"Wait checker is not implemented yet for the desired database state '{}' \", desiredStatus);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7a477a27dc7441d01edc5effc0a1b890f0b27b55"}, "originalPosition": 46}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2455, "cost": 1, "resetAt": "2021-11-12T20:44:06Z"}}}