{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTIzNTY5MzY4", "number": 9475, "reviewThreads": {"totalCount": 58, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOVQxMTowNzo1NlrOE6_XDg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wM1QwODowNDo0NlrOFACaVA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMwMjkwOTU4OnYy", "diffSide": "RIGHT", "path": "cloud-reactor/src/main/java/com/sequenceiq/cloudbreak/cloud/handler/CollectLoadBalancerMetadataHandler.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOVQxMTowNzo1NlrOH2X8VA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOVQxMTowNzo1NlrOH2X8VA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjc3NzQyOA==", "bodyText": "Nit: remove unnecessary space after metadata().", "url": "https://github.com/hortonworks/cloudbreak/pull/9475#discussion_r526777428", "createdAt": "2020-11-19T11:07:56Z", "author": {"login": "lajosrodek"}, "path": "cloud-reactor/src/main/java/com/sequenceiq/cloudbreak/cloud/handler/CollectLoadBalancerMetadataHandler.java", "diffHunk": "@@ -0,0 +1,59 @@\n+package com.sequenceiq.cloudbreak.cloud.handler;\n+\n+import java.util.List;\n+\n+import javax.inject.Inject;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.stereotype.Component;\n+\n+import com.sequenceiq.cloudbreak.cloud.CloudConnector;\n+import com.sequenceiq.cloudbreak.cloud.context.AuthenticatedContext;\n+import com.sequenceiq.cloudbreak.cloud.event.loadbalancer.CollectLoadBalancerMetadataRequest;\n+import com.sequenceiq.cloudbreak.cloud.event.loadbalancer.CollectLoadBalancerMetadataResult;\n+import com.sequenceiq.cloudbreak.cloud.init.CloudPlatformConnectors;\n+import com.sequenceiq.cloudbreak.cloud.model.CloudLoadBalancerMetadata;\n+\n+import reactor.bus.Event;\n+import reactor.bus.EventBus;\n+\n+@Component\n+public class CollectLoadBalancerMetadataHandler implements CloudPlatformEventHandler<CollectLoadBalancerMetadataRequest> {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(CollectLoadBalancerMetadataHandler.class);\n+\n+    @Inject\n+    private CloudPlatformConnectors cloudPlatformConnectors;\n+\n+    @Inject\n+    private EventBus eventBus;\n+\n+    @Override\n+    public Class<CollectLoadBalancerMetadataRequest> type() {\n+        return CollectLoadBalancerMetadataRequest.class;\n+    }\n+\n+    @Override\n+    public void accept(Event<CollectLoadBalancerMetadataRequest> collectLBMetadataRequestEvent) {\n+        LOGGER.debug(\"Received event: {}\", collectLBMetadataRequestEvent);\n+        CollectLoadBalancerMetadataRequest request = collectLBMetadataRequestEvent.getData();\n+        try {\n+            CloudConnector<Object> connector = cloudPlatformConnectors.get(request.getCloudContext().getPlatformVariant());\n+            AuthenticatedContext ac = connector.authentication().authenticate(request.getCloudContext(), request.getCloudCredential());\n+\n+            List<CloudLoadBalancerMetadata> loadBalancerStatuses = connector.metadata() .collectLoadBalancer(ac, request.getGatewayGroupNames());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "de55a4bb1b4971dd8f935faf64cd1e01685b9bb1"}, "originalPosition": 45}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMwNTMyMjU4OnYy", "diffSide": "RIGHT", "path": "core-model/src/main/java/com/sequenceiq/cloudbreak/domain/stack/Stack.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOVQyMDowMToyN1rOH2vcbw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOVQyMTo0NToyMFrOH2zHXg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzE2MjQ3OQ==", "bodyText": "Could do a instanceGroups.stream().filter(group -> InstanceGroupType.Gateway.equals(group.getInstanceGroupType).findAny().orElse(null);", "url": "https://github.com/hortonworks/cloudbreak/pull/9475#discussion_r527162479", "createdAt": "2020-11-19T20:01:27Z", "author": {"login": "frozenwizard"}, "path": "core-model/src/main/java/com/sequenceiq/cloudbreak/domain/stack/Stack.java", "diffHunk": "@@ -574,6 +579,15 @@ public InstanceMetaData getPrimaryGatewayInstance() {\n         return metaData.orElse(null);\n     }\n \n+    public InstanceGroup getGatewayGroup() {\n+        for (InstanceGroup instanceGroup : instanceGroups) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5e43c56ce52d7d662196ebae07c6db60206b53a9"}, "originalPosition": 24}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzIyMjYyMg==", "bodyText": "This method was from a pretty early implementation, and I realized it's no longer being called, so it'll be removed in the most recent commit.", "url": "https://github.com/hortonworks/cloudbreak/pull/9475#discussion_r527222622", "createdAt": "2020-11-19T21:45:20Z", "author": {"login": "hreeve-cloudera"}, "path": "core-model/src/main/java/com/sequenceiq/cloudbreak/domain/stack/Stack.java", "diffHunk": "@@ -574,6 +579,15 @@ public InstanceMetaData getPrimaryGatewayInstance() {\n         return metaData.orElse(null);\n     }\n \n+    public InstanceGroup getGatewayGroup() {\n+        for (InstanceGroup instanceGroup : instanceGroups) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzE2MjQ3OQ=="}, "originalCommit": {"oid": "5e43c56ce52d7d662196ebae07c6db60206b53a9"}, "originalPosition": 24}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMwNTMyOTU2OnYy", "diffSide": "RIGHT", "path": "core-model/src/main/java/com/sequenceiq/cloudbreak/domain/stack/instance/InstanceGroup.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOVQyMDowMzozMlrOH2vg1w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOVQyMjowNDozMFrOH2zvYQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzE2MzYwNw==", "bodyText": "probably want to do a fetch type of lazy", "url": "https://github.com/hortonworks/cloudbreak/pull/9475#discussion_r527163607", "createdAt": "2020-11-19T20:03:32Z", "author": {"login": "frozenwizard"}, "path": "core-model/src/main/java/com/sequenceiq/cloudbreak/domain/stack/instance/InstanceGroup.java", "diffHunk": "@@ -70,6 +73,9 @@\n \n     private int initialNodeCount;\n \n+    @ManyToMany(mappedBy = \"instanceGroups\", fetch = FetchType.EAGER)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5e43c56ce52d7d662196ebae07c6db60206b53a9"}, "originalPosition": 24}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzIzMjg2NQ==", "bodyText": "T'was I who was lazy. I'll change this and add a manual fetch instead.", "url": "https://github.com/hortonworks/cloudbreak/pull/9475#discussion_r527232865", "createdAt": "2020-11-19T22:04:30Z", "author": {"login": "hreeve-cloudera"}, "path": "core-model/src/main/java/com/sequenceiq/cloudbreak/domain/stack/instance/InstanceGroup.java", "diffHunk": "@@ -70,6 +73,9 @@\n \n     private int initialNodeCount;\n \n+    @ManyToMany(mappedBy = \"instanceGroups\", fetch = FetchType.EAGER)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzE2MzYwNw=="}, "originalCommit": {"oid": "5e43c56ce52d7d662196ebae07c6db60206b53a9"}, "originalPosition": 24}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMwNTMzNTcwOnYy", "diffSide": "RIGHT", "path": "core-model/src/main/java/com/sequenceiq/cloudbreak/domain/stack/instance/InstanceGroup.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOVQyMDowNToxOFrOH2vkvQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOVQyMDowNToxOFrOH2vkvQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzE2NDYwNQ==", "bodyText": "could we just initialize targetgroups = new HashSet<>() at the top of the file?", "url": "https://github.com/hortonworks/cloudbreak/pull/9475#discussion_r527164605", "createdAt": "2020-11-19T20:05:18Z", "author": {"login": "frozenwizard"}, "path": "core-model/src/main/java/com/sequenceiq/cloudbreak/domain/stack/instance/InstanceGroup.java", "diffHunk": "@@ -208,6 +214,21 @@ public void setCloudIdentityType(CloudIdentityType cloudIdentityType) {\n         attributes = new Json(attributeMap);\n     }\n \n+    public Set<TargetGroup> getTargetGroups() {\n+        return targetGroups;\n+    }\n+\n+    public void setTargetGroups(Set<TargetGroup> targetGroups) {\n+        this.targetGroups = targetGroups;\n+    }\n+\n+    public void addTargetGroup(TargetGroup targetGroup) {\n+        if (targetGroups == null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5e43c56ce52d7d662196ebae07c6db60206b53a9"}, "originalPosition": 43}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMwNTM0MDM4OnYy", "diffSide": "RIGHT", "path": "core-model/src/main/java/com/sequenceiq/cloudbreak/domain/stack/loadbalancer/LoadBalancer.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOVQyMDowNjo1M1rOH2vnzw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOVQyMjowOTozNFrOH2z5sA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzE2NTM5MQ==", "bodyText": "Do we need to make this a abstract class and subtype a awsloadbalancer from it so we can later support azure's loadbalancing?", "url": "https://github.com/hortonworks/cloudbreak/pull/9475#discussion_r527165391", "createdAt": "2020-11-19T20:06:53Z", "author": {"login": "frozenwizard"}, "path": "core-model/src/main/java/com/sequenceiq/cloudbreak/domain/stack/loadbalancer/LoadBalancer.java", "diffHunk": "@@ -0,0 +1,111 @@\n+package com.sequenceiq.cloudbreak.domain.stack.loadbalancer;\n+\n+import java.util.HashSet;\n+import java.util.Set;\n+\n+import javax.persistence.CascadeType;\n+import javax.persistence.Entity;\n+import javax.persistence.GeneratedValue;\n+import javax.persistence.GenerationType;\n+import javax.persistence.Id;\n+import javax.persistence.ManyToOne;\n+import javax.persistence.OneToMany;\n+import javax.persistence.SequenceGenerator;\n+\n+import com.sequenceiq.cloudbreak.domain.ProvisionEntity;\n+import com.sequenceiq.cloudbreak.domain.stack.Stack;\n+\n+@Entity\n+public class LoadBalancer implements ProvisionEntity  {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5e43c56ce52d7d662196ebae07c6db60206b53a9"}, "originalPosition": 19}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzIzNTUwNA==", "bodyText": "This is a database entity, so I don't think we should mess with it. It's also in a different module and serves a different purpose (used in an internal stack model vs. the cloud based model) than AwsLoadBalancer. I get what you're saying about having an abstract class we can implement for both cloud platforms. But the AwsLoadBalancer was explicitly modeled to mimic the relationship between load balancers, listeners, and target groups in AWS. Since I don't yet know what the Azure model will look like, I'd rather wait until we have more information about that to see what makes sense to abstract out.", "url": "https://github.com/hortonworks/cloudbreak/pull/9475#discussion_r527235504", "createdAt": "2020-11-19T22:09:34Z", "author": {"login": "hreeve-cloudera"}, "path": "core-model/src/main/java/com/sequenceiq/cloudbreak/domain/stack/loadbalancer/LoadBalancer.java", "diffHunk": "@@ -0,0 +1,111 @@\n+package com.sequenceiq.cloudbreak.domain.stack.loadbalancer;\n+\n+import java.util.HashSet;\n+import java.util.Set;\n+\n+import javax.persistence.CascadeType;\n+import javax.persistence.Entity;\n+import javax.persistence.GeneratedValue;\n+import javax.persistence.GenerationType;\n+import javax.persistence.Id;\n+import javax.persistence.ManyToOne;\n+import javax.persistence.OneToMany;\n+import javax.persistence.SequenceGenerator;\n+\n+import com.sequenceiq.cloudbreak.domain.ProvisionEntity;\n+import com.sequenceiq.cloudbreak.domain.stack.Stack;\n+\n+@Entity\n+public class LoadBalancer implements ProvisionEntity  {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzE2NTM5MQ=="}, "originalCommit": {"oid": "5e43c56ce52d7d662196ebae07c6db60206b53a9"}, "originalPosition": 19}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMwNTM1MTc3OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/com/sequenceiq/cloudbreak/converter/v4/stacks/StackV4RequestToStackConverter.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOVQyMDoxMDoyNFrOH2vvBg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOVQyMjoxMTozN1rOH2z9xg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzE2NzIzOA==", "bodyText": "Is there a jira for this one or is it a later commit in this pr?", "url": "https://github.com/hortonworks/cloudbreak/pull/9475#discussion_r527167238", "createdAt": "2020-11-19T20:10:24Z", "author": {"login": "frozenwizard"}, "path": "core/src/main/java/com/sequenceiq/cloudbreak/converter/v4/stacks/StackV4RequestToStackConverter.java", "diffHunk": "@@ -335,6 +344,40 @@ private void validateStackAuthentication(StackV4Request source) {\n         return convertedSet;\n     }\n \n+    private Set<LoadBalancer> createLoadBalancers(StackV4Request source, Stack stack) {\n+        Set<LoadBalancer> loadBalancers = new HashSet<>();\n+        Set<TargetGroup> targetGroups = new HashSet<>();\n+        // TODO expand this to data hubs\n+        if (StackType.DATALAKE.equals(source.getType())) {\n+            LOGGER.info(\"Setting up load balancers for stack {}\", source.getName());\n+            Set<String> knoxGatewayGroupNames = loadBalancerConfigService.getKnoxGatewayGroups(stack);\n+            Set<InstanceGroup> knoxGatewayGroups = stack.getInstanceGroups().stream()\n+                .filter(ig -> knoxGatewayGroupNames.contains(ig.getGroupName()))\n+                .collect(Collectors.toSet());\n+            if (!knoxGatewayGroups.isEmpty()) {\n+                LOGGER.info(\"Knox gateway instance found; enabling Knox load balancer configuration.\");\n+                TargetGroup targetGroup = new TargetGroup();\n+                targetGroup.setType(TargetGroupType.KNOX.name());\n+                targetGroup.setInstanceGroups(knoxGatewayGroups);\n+                targetGroups.add(targetGroup);\n+                knoxGatewayGroups.forEach(ig -> ig.addTargetGroup(targetGroup));\n+            }\n+            // TODO create target group for CM instances", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f2bf0c1f201d9b486f2da3f6f2f3cef16ad9c26d"}, "originalPosition": 63}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzIzNjU1MA==", "bodyText": "Yes, Bryce is working on figuring out the configuration for CM target groups in CB-9368. I'll put that JIRA in the comment.", "url": "https://github.com/hortonworks/cloudbreak/pull/9475#discussion_r527236550", "createdAt": "2020-11-19T22:11:37Z", "author": {"login": "hreeve-cloudera"}, "path": "core/src/main/java/com/sequenceiq/cloudbreak/converter/v4/stacks/StackV4RequestToStackConverter.java", "diffHunk": "@@ -335,6 +344,40 @@ private void validateStackAuthentication(StackV4Request source) {\n         return convertedSet;\n     }\n \n+    private Set<LoadBalancer> createLoadBalancers(StackV4Request source, Stack stack) {\n+        Set<LoadBalancer> loadBalancers = new HashSet<>();\n+        Set<TargetGroup> targetGroups = new HashSet<>();\n+        // TODO expand this to data hubs\n+        if (StackType.DATALAKE.equals(source.getType())) {\n+            LOGGER.info(\"Setting up load balancers for stack {}\", source.getName());\n+            Set<String> knoxGatewayGroupNames = loadBalancerConfigService.getKnoxGatewayGroups(stack);\n+            Set<InstanceGroup> knoxGatewayGroups = stack.getInstanceGroups().stream()\n+                .filter(ig -> knoxGatewayGroupNames.contains(ig.getGroupName()))\n+                .collect(Collectors.toSet());\n+            if (!knoxGatewayGroups.isEmpty()) {\n+                LOGGER.info(\"Knox gateway instance found; enabling Knox load balancer configuration.\");\n+                TargetGroup targetGroup = new TargetGroup();\n+                targetGroup.setType(TargetGroupType.KNOX.name());\n+                targetGroup.setInstanceGroups(knoxGatewayGroups);\n+                targetGroups.add(targetGroup);\n+                knoxGatewayGroups.forEach(ig -> ig.addTargetGroup(targetGroup));\n+            }\n+            // TODO create target group for CM instances", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzE2NzIzOA=="}, "originalCommit": {"oid": "f2bf0c1f201d9b486f2da3f6f2f3cef16ad9c26d"}, "originalPosition": 63}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMwNTM1NDUzOnYy", "diffSide": "RIGHT", "path": "core/src/main/java/com/sequenceiq/cloudbreak/converter/v4/stacks/StackV4RequestToStackConverter.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOVQyMDoxMToxMlrOH2vwww==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOVQyMjoxMjowN1rOH2z-kw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzE2NzY4Mw==", "bodyText": "Assuming later commit has this in there?", "url": "https://github.com/hortonworks/cloudbreak/pull/9475#discussion_r527167683", "createdAt": "2020-11-19T20:11:12Z", "author": {"login": "frozenwizard"}, "path": "core/src/main/java/com/sequenceiq/cloudbreak/converter/v4/stacks/StackV4RequestToStackConverter.java", "diffHunk": "@@ -335,6 +344,40 @@ private void validateStackAuthentication(StackV4Request source) {\n         return convertedSet;\n     }\n \n+    private Set<LoadBalancer> createLoadBalancers(StackV4Request source, Stack stack) {\n+        Set<LoadBalancer> loadBalancers = new HashSet<>();\n+        Set<TargetGroup> targetGroups = new HashSet<>();\n+        // TODO expand this to data hubs\n+        if (StackType.DATALAKE.equals(source.getType())) {\n+            LOGGER.info(\"Setting up load balancers for stack {}\", source.getName());\n+            Set<String> knoxGatewayGroupNames = loadBalancerConfigService.getKnoxGatewayGroups(stack);\n+            Set<InstanceGroup> knoxGatewayGroups = stack.getInstanceGroups().stream()\n+                .filter(ig -> knoxGatewayGroupNames.contains(ig.getGroupName()))\n+                .collect(Collectors.toSet());\n+            if (!knoxGatewayGroups.isEmpty()) {\n+                LOGGER.info(\"Knox gateway instance found; enabling Knox load balancer configuration.\");\n+                TargetGroup targetGroup = new TargetGroup();\n+                targetGroup.setType(TargetGroupType.KNOX.name());\n+                targetGroup.setInstanceGroups(knoxGatewayGroups);\n+                targetGroups.add(targetGroup);\n+                knoxGatewayGroups.forEach(ig -> ig.addTargetGroup(targetGroup));\n+            }\n+            // TODO create target group for CM instances\n+        }\n+\n+        if (!targetGroups.isEmpty()) {\n+            LoadBalancer loadBalancer = new LoadBalancer();\n+            loadBalancer.setStack(stack);\n+            // TODO actually figure out the type we need here", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f2bf0c1f201d9b486f2da3f6f2f3cef16ad9c26d"}, "originalPosition": 69}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzIzNjc1NQ==", "bodyText": "This is going to be more work than I originally anticipated, so I opened CB-9900 about it. I'll update the comment.", "url": "https://github.com/hortonworks/cloudbreak/pull/9475#discussion_r527236755", "createdAt": "2020-11-19T22:12:07Z", "author": {"login": "hreeve-cloudera"}, "path": "core/src/main/java/com/sequenceiq/cloudbreak/converter/v4/stacks/StackV4RequestToStackConverter.java", "diffHunk": "@@ -335,6 +344,40 @@ private void validateStackAuthentication(StackV4Request source) {\n         return convertedSet;\n     }\n \n+    private Set<LoadBalancer> createLoadBalancers(StackV4Request source, Stack stack) {\n+        Set<LoadBalancer> loadBalancers = new HashSet<>();\n+        Set<TargetGroup> targetGroups = new HashSet<>();\n+        // TODO expand this to data hubs\n+        if (StackType.DATALAKE.equals(source.getType())) {\n+            LOGGER.info(\"Setting up load balancers for stack {}\", source.getName());\n+            Set<String> knoxGatewayGroupNames = loadBalancerConfigService.getKnoxGatewayGroups(stack);\n+            Set<InstanceGroup> knoxGatewayGroups = stack.getInstanceGroups().stream()\n+                .filter(ig -> knoxGatewayGroupNames.contains(ig.getGroupName()))\n+                .collect(Collectors.toSet());\n+            if (!knoxGatewayGroups.isEmpty()) {\n+                LOGGER.info(\"Knox gateway instance found; enabling Knox load balancer configuration.\");\n+                TargetGroup targetGroup = new TargetGroup();\n+                targetGroup.setType(TargetGroupType.KNOX.name());\n+                targetGroup.setInstanceGroups(knoxGatewayGroups);\n+                targetGroups.add(targetGroup);\n+                knoxGatewayGroups.forEach(ig -> ig.addTargetGroup(targetGroup));\n+            }\n+            // TODO create target group for CM instances\n+        }\n+\n+        if (!targetGroups.isEmpty()) {\n+            LoadBalancer loadBalancer = new LoadBalancer();\n+            loadBalancer.setStack(stack);\n+            // TODO actually figure out the type we need here", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzE2NzY4Mw=="}, "originalCommit": {"oid": "f2bf0c1f201d9b486f2da3f6f2f3cef16ad9c26d"}, "originalPosition": 69}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMwNTM2NTAyOnYy", "diffSide": "RIGHT", "path": "core/src/main/java/com/sequenceiq/cloudbreak/converter/v4/stacks/StackV4RequestToStackConverter.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOVQyMDoxNDoxMlrOH2v3Nw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOVQyMjowOTo1NlrOH2z6gQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzE2OTMzNQ==", "bodyText": "Should this be in an entitlement?", "url": "https://github.com/hortonworks/cloudbreak/pull/9475#discussion_r527169335", "createdAt": "2020-11-19T20:14:12Z", "author": {"login": "frozenwizard"}, "path": "core/src/main/java/com/sequenceiq/cloudbreak/converter/v4/stacks/StackV4RequestToStackConverter.java", "diffHunk": "@@ -335,6 +344,40 @@ private void validateStackAuthentication(StackV4Request source) {\n         return convertedSet;\n     }\n \n+    private Set<LoadBalancer> createLoadBalancers(StackV4Request source, Stack stack) {\n+        Set<LoadBalancer> loadBalancers = new HashSet<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f2bf0c1f201d9b486f2da3f6f2f3cef16ad9c26d"}, "originalPosition": 46}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzIzNTcxMw==", "bodyText": "Yep, the entitlement's coming in the next commit.", "url": "https://github.com/hortonworks/cloudbreak/pull/9475#discussion_r527235713", "createdAt": "2020-11-19T22:09:56Z", "author": {"login": "hreeve-cloudera"}, "path": "core/src/main/java/com/sequenceiq/cloudbreak/converter/v4/stacks/StackV4RequestToStackConverter.java", "diffHunk": "@@ -335,6 +344,40 @@ private void validateStackAuthentication(StackV4Request source) {\n         return convertedSet;\n     }\n \n+    private Set<LoadBalancer> createLoadBalancers(StackV4Request source, Stack stack) {\n+        Set<LoadBalancer> loadBalancers = new HashSet<>();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzE2OTMzNQ=="}, "originalCommit": {"oid": "f2bf0c1f201d9b486f2da3f6f2f3cef16ad9c26d"}, "originalPosition": 46}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMwNTQxOTQ0OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/com/sequenceiq/cloudbreak/service/LoadBalancerConfigService.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOVQyMDoyOToyN1rOH2wYTA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOVQyMjoxMzozOFrOH20BYg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzE3NzgwNA==", "bodyText": "What happens if cluster is null?", "url": "https://github.com/hortonworks/cloudbreak/pull/9475#discussion_r527177804", "createdAt": "2020-11-19T20:29:27Z", "author": {"login": "frozenwizard"}, "path": "core/src/main/java/com/sequenceiq/cloudbreak/service/LoadBalancerConfigService.java", "diffHunk": "@@ -0,0 +1,80 @@\n+package com.sequenceiq.cloudbreak.service;\n+\n+import com.sequenceiq.cloudbreak.domain.stack.loadbalancer.TargetGroup;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.stereotype.Service;\n+\n+import com.sequenceiq.cloudbreak.cmtemplate.CmTemplateProcessor;\n+import com.sequenceiq.cloudbreak.cmtemplate.configproviders.knox.KnoxRoles;\n+import com.sequenceiq.cloudbreak.domain.stack.Stack;\n+import com.sequenceiq.cloudbreak.domain.stack.cluster.Cluster;\n+import com.sequenceiq.cloudbreak.domain.stack.instance.InstanceGroup;\n+import com.sequenceiq.cloudbreak.template.model.ServiceComponent;\n+import com.sequenceiq.common.api.type.InstanceGroupType;\n+import com.sequenceiq.common.api.type.LoadBalancerType;\n+\n+@Service\n+public class LoadBalancerConfigService {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(LoadBalancerConfigService.class);\n+\n+    private static final String ENDPOINT_SUFFIX = \"gateway\";\n+\n+    private static final String PUBLIC_SUFFIX = \"external\";\n+\n+    private static final Set<Integer> DEFAULT_KNOX_PORTS = Set.of(443);\n+\n+    public Set<String> getKnoxGatewayGroups(Stack stack) {\n+        LOGGER.info(\"Fetching list of instance groups with Knox gateway installed\");\n+        Set<String> groupNames = new HashSet<>();\n+        Cluster cluster = stack.getCluster();\n+        if (cluster != null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f2bf0c1f201d9b486f2da3f6f2f3cef16ad9c26d"}, "originalPosition": 40}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzIzNzQ3NA==", "bodyText": "Then we don't have a way to check the cluster blueprint, so we don't do anything here and hit the next if that triggers if groupNames is still empty.", "url": "https://github.com/hortonworks/cloudbreak/pull/9475#discussion_r527237474", "createdAt": "2020-11-19T22:13:38Z", "author": {"login": "hreeve-cloudera"}, "path": "core/src/main/java/com/sequenceiq/cloudbreak/service/LoadBalancerConfigService.java", "diffHunk": "@@ -0,0 +1,80 @@\n+package com.sequenceiq.cloudbreak.service;\n+\n+import com.sequenceiq.cloudbreak.domain.stack.loadbalancer.TargetGroup;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.stereotype.Service;\n+\n+import com.sequenceiq.cloudbreak.cmtemplate.CmTemplateProcessor;\n+import com.sequenceiq.cloudbreak.cmtemplate.configproviders.knox.KnoxRoles;\n+import com.sequenceiq.cloudbreak.domain.stack.Stack;\n+import com.sequenceiq.cloudbreak.domain.stack.cluster.Cluster;\n+import com.sequenceiq.cloudbreak.domain.stack.instance.InstanceGroup;\n+import com.sequenceiq.cloudbreak.template.model.ServiceComponent;\n+import com.sequenceiq.common.api.type.InstanceGroupType;\n+import com.sequenceiq.common.api.type.LoadBalancerType;\n+\n+@Service\n+public class LoadBalancerConfigService {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(LoadBalancerConfigService.class);\n+\n+    private static final String ENDPOINT_SUFFIX = \"gateway\";\n+\n+    private static final String PUBLIC_SUFFIX = \"external\";\n+\n+    private static final Set<Integer> DEFAULT_KNOX_PORTS = Set.of(443);\n+\n+    public Set<String> getKnoxGatewayGroups(Stack stack) {\n+        LOGGER.info(\"Fetching list of instance groups with Knox gateway installed\");\n+        Set<String> groupNames = new HashSet<>();\n+        Cluster cluster = stack.getCluster();\n+        if (cluster != null) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzE3NzgwNA=="}, "originalCommit": {"oid": "f2bf0c1f201d9b486f2da3f6f2f3cef16ad9c26d"}, "originalPosition": 40}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMwNTQ0NDI4OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/com/sequenceiq/cloudbreak/service/LoadBalancerConfigService.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOVQyMDozNTo0NVrOH2wnIg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOVQyMjoxNzozN1rOH20P8w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzE4MTYwMg==", "bodyText": "More descriptive variable name please.\nAlso i feel like you could just do String s = stack.getname()+\"-\"+ENDPOING_SUFFIX;  and if public +=\"-\"+PUBLIC_SUFFIX.", "url": "https://github.com/hortonworks/cloudbreak/pull/9475#discussion_r527181602", "createdAt": "2020-11-19T20:35:45Z", "author": {"login": "frozenwizard"}, "path": "core/src/main/java/com/sequenceiq/cloudbreak/service/LoadBalancerConfigService.java", "diffHunk": "@@ -0,0 +1,80 @@\n+package com.sequenceiq.cloudbreak.service;\n+\n+import com.sequenceiq.cloudbreak.domain.stack.loadbalancer.TargetGroup;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.stereotype.Service;\n+\n+import com.sequenceiq.cloudbreak.cmtemplate.CmTemplateProcessor;\n+import com.sequenceiq.cloudbreak.cmtemplate.configproviders.knox.KnoxRoles;\n+import com.sequenceiq.cloudbreak.domain.stack.Stack;\n+import com.sequenceiq.cloudbreak.domain.stack.cluster.Cluster;\n+import com.sequenceiq.cloudbreak.domain.stack.instance.InstanceGroup;\n+import com.sequenceiq.cloudbreak.template.model.ServiceComponent;\n+import com.sequenceiq.common.api.type.InstanceGroupType;\n+import com.sequenceiq.common.api.type.LoadBalancerType;\n+\n+@Service\n+public class LoadBalancerConfigService {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(LoadBalancerConfigService.class);\n+\n+    private static final String ENDPOINT_SUFFIX = \"gateway\";\n+\n+    private static final String PUBLIC_SUFFIX = \"external\";\n+\n+    private static final Set<Integer> DEFAULT_KNOX_PORTS = Set.of(443);\n+\n+    public Set<String> getKnoxGatewayGroups(Stack stack) {\n+        LOGGER.info(\"Fetching list of instance groups with Knox gateway installed\");\n+        Set<String> groupNames = new HashSet<>();\n+        Cluster cluster = stack.getCluster();\n+        if (cluster != null) {\n+            CmTemplateProcessor cmTemplateProcessor = new CmTemplateProcessor(cluster.getBlueprint().getBlueprintText());\n+            Map<String, Set<ServiceComponent>> components = cmTemplateProcessor.getServiceComponentsByHostGroup();\n+            LOGGER.info(\"Checking if Knox gateway is explicitly defined\");\n+            groupNames = components.entrySet().stream()\n+                .filter(e -> e.getValue().stream().anyMatch(c -> KnoxRoles.KNOX_GATEWAY.equals(c.getComponent())))\n+                .map(Map.Entry::getKey)\n+                .collect(Collectors.toSet());\n+        }\n+\n+        if (groupNames.isEmpty()) {\n+            LOGGER.info(\"Knox gateway is not explicitly defined; searching for CM gateway hosts\");\n+            groupNames = stack.getInstanceGroups().stream()\n+                .filter(i -> InstanceGroupType.isGateway(i.getInstanceGroupType()))\n+                .map(InstanceGroup::getGroupName)\n+                .collect(Collectors.toSet());\n+        }\n+\n+        if (groupNames.isEmpty()) {\n+            LOGGER.info(\"No Knox gateway instance groups found\");\n+        }\n+        return groupNames;\n+    }\n+\n+    public String generateLoadBalancerEndpoint(Stack stack, LoadBalancerType type) {\n+        List<String> s = Arrays.asList(stack.getName(), ENDPOINT_SUFFIX);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f2bf0c1f201d9b486f2da3f6f2f3cef16ad9c26d"}, "originalPosition": 65}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzI0MTIwMw==", "bodyText": "Intellij fusses at you if you append strings with \"+\", but I've changed it to a StringBuilder.", "url": "https://github.com/hortonworks/cloudbreak/pull/9475#discussion_r527241203", "createdAt": "2020-11-19T22:17:37Z", "author": {"login": "hreeve-cloudera"}, "path": "core/src/main/java/com/sequenceiq/cloudbreak/service/LoadBalancerConfigService.java", "diffHunk": "@@ -0,0 +1,80 @@\n+package com.sequenceiq.cloudbreak.service;\n+\n+import com.sequenceiq.cloudbreak.domain.stack.loadbalancer.TargetGroup;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.stereotype.Service;\n+\n+import com.sequenceiq.cloudbreak.cmtemplate.CmTemplateProcessor;\n+import com.sequenceiq.cloudbreak.cmtemplate.configproviders.knox.KnoxRoles;\n+import com.sequenceiq.cloudbreak.domain.stack.Stack;\n+import com.sequenceiq.cloudbreak.domain.stack.cluster.Cluster;\n+import com.sequenceiq.cloudbreak.domain.stack.instance.InstanceGroup;\n+import com.sequenceiq.cloudbreak.template.model.ServiceComponent;\n+import com.sequenceiq.common.api.type.InstanceGroupType;\n+import com.sequenceiq.common.api.type.LoadBalancerType;\n+\n+@Service\n+public class LoadBalancerConfigService {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(LoadBalancerConfigService.class);\n+\n+    private static final String ENDPOINT_SUFFIX = \"gateway\";\n+\n+    private static final String PUBLIC_SUFFIX = \"external\";\n+\n+    private static final Set<Integer> DEFAULT_KNOX_PORTS = Set.of(443);\n+\n+    public Set<String> getKnoxGatewayGroups(Stack stack) {\n+        LOGGER.info(\"Fetching list of instance groups with Knox gateway installed\");\n+        Set<String> groupNames = new HashSet<>();\n+        Cluster cluster = stack.getCluster();\n+        if (cluster != null) {\n+            CmTemplateProcessor cmTemplateProcessor = new CmTemplateProcessor(cluster.getBlueprint().getBlueprintText());\n+            Map<String, Set<ServiceComponent>> components = cmTemplateProcessor.getServiceComponentsByHostGroup();\n+            LOGGER.info(\"Checking if Knox gateway is explicitly defined\");\n+            groupNames = components.entrySet().stream()\n+                .filter(e -> e.getValue().stream().anyMatch(c -> KnoxRoles.KNOX_GATEWAY.equals(c.getComponent())))\n+                .map(Map.Entry::getKey)\n+                .collect(Collectors.toSet());\n+        }\n+\n+        if (groupNames.isEmpty()) {\n+            LOGGER.info(\"Knox gateway is not explicitly defined; searching for CM gateway hosts\");\n+            groupNames = stack.getInstanceGroups().stream()\n+                .filter(i -> InstanceGroupType.isGateway(i.getInstanceGroupType()))\n+                .map(InstanceGroup::getGroupName)\n+                .collect(Collectors.toSet());\n+        }\n+\n+        if (groupNames.isEmpty()) {\n+            LOGGER.info(\"No Knox gateway instance groups found\");\n+        }\n+        return groupNames;\n+    }\n+\n+    public String generateLoadBalancerEndpoint(Stack stack, LoadBalancerType type) {\n+        List<String> s = Arrays.asList(stack.getName(), ENDPOINT_SUFFIX);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzE4MTYwMg=="}, "originalCommit": {"oid": "f2bf0c1f201d9b486f2da3f6f2f3cef16ad9c26d"}, "originalPosition": 65}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMwNTQ0OTM1OnYy", "diffSide": "RIGHT", "path": "core-model/src/main/java/com/sequenceiq/cloudbreak/domain/stack/loadbalancer/TargetGroup.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOVQyMDozNjo1M1rOH2wqAA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yMFQyMzoyMjowOVrOH3j3zQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzE4MjMzNg==", "bodyText": "question: I see that we're typing ProvisionEntity in lots of places, but I don't see anywhere that it's used to narrow a type or provide for multiple implementations. It looks like it's just an extension of Serializable -- is that the case?", "url": "https://github.com/hortonworks/cloudbreak/pull/9475#discussion_r527182336", "createdAt": "2020-11-19T20:36:53Z", "author": {"login": "brycederriso"}, "path": "core-model/src/main/java/com/sequenceiq/cloudbreak/domain/stack/loadbalancer/TargetGroup.java", "diffHunk": "@@ -0,0 +1,55 @@\n+package com.sequenceiq.cloudbreak.domain.stack.loadbalancer;\n+\n+import com.sequenceiq.cloudbreak.domain.ProvisionEntity;\n+import java.util.Set;\n+\n+import javax.persistence.Entity;\n+import javax.persistence.FetchType;\n+import javax.persistence.GeneratedValue;\n+import javax.persistence.GenerationType;\n+import javax.persistence.Id;\n+import javax.persistence.ManyToMany;\n+import javax.persistence.ManyToOne;\n+import javax.persistence.SequenceGenerator;\n+\n+import com.sequenceiq.cloudbreak.domain.stack.instance.InstanceGroup;\n+\n+@Entity\n+public class TargetGroup implements ProvisionEntity {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5e43c56ce52d7d662196ebae07c6db60206b53a9"}, "originalPosition": 18}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODAyMTQ1Mw==", "bodyText": "Yes. There's some check in the code that makes sure all database entity classes are serializable, and that's done through the ProvisionEntity interface. I don't know if that has something to do with JPA or is a CB requirement, but the build won't work without it.", "url": "https://github.com/hortonworks/cloudbreak/pull/9475#discussion_r528021453", "createdAt": "2020-11-20T23:22:09Z", "author": {"login": "hreeve-cloudera"}, "path": "core-model/src/main/java/com/sequenceiq/cloudbreak/domain/stack/loadbalancer/TargetGroup.java", "diffHunk": "@@ -0,0 +1,55 @@\n+package com.sequenceiq.cloudbreak.domain.stack.loadbalancer;\n+\n+import com.sequenceiq.cloudbreak.domain.ProvisionEntity;\n+import java.util.Set;\n+\n+import javax.persistence.Entity;\n+import javax.persistence.FetchType;\n+import javax.persistence.GeneratedValue;\n+import javax.persistence.GenerationType;\n+import javax.persistence.Id;\n+import javax.persistence.ManyToMany;\n+import javax.persistence.ManyToOne;\n+import javax.persistence.SequenceGenerator;\n+\n+import com.sequenceiq.cloudbreak.domain.stack.instance.InstanceGroup;\n+\n+@Entity\n+public class TargetGroup implements ProvisionEntity {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzE4MjMzNg=="}, "originalCommit": {"oid": "5e43c56ce52d7d662196ebae07c6db60206b53a9"}, "originalPosition": 18}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMwNTQ1MDQ1OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/com/sequenceiq/cloudbreak/service/LoadBalancerConfigService.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOVQyMDozNzowN1rOH2wqkA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOVQyMjoxODozNlrOH20R2Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzE4MjQ4MA==", "bodyText": "CM?", "url": "https://github.com/hortonworks/cloudbreak/pull/9475#discussion_r527182480", "createdAt": "2020-11-19T20:37:07Z", "author": {"login": "frozenwizard"}, "path": "core/src/main/java/com/sequenceiq/cloudbreak/service/LoadBalancerConfigService.java", "diffHunk": "@@ -0,0 +1,80 @@\n+package com.sequenceiq.cloudbreak.service;\n+\n+import com.sequenceiq.cloudbreak.domain.stack.loadbalancer.TargetGroup;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.stereotype.Service;\n+\n+import com.sequenceiq.cloudbreak.cmtemplate.CmTemplateProcessor;\n+import com.sequenceiq.cloudbreak.cmtemplate.configproviders.knox.KnoxRoles;\n+import com.sequenceiq.cloudbreak.domain.stack.Stack;\n+import com.sequenceiq.cloudbreak.domain.stack.cluster.Cluster;\n+import com.sequenceiq.cloudbreak.domain.stack.instance.InstanceGroup;\n+import com.sequenceiq.cloudbreak.template.model.ServiceComponent;\n+import com.sequenceiq.common.api.type.InstanceGroupType;\n+import com.sequenceiq.common.api.type.LoadBalancerType;\n+\n+@Service\n+public class LoadBalancerConfigService {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(LoadBalancerConfigService.class);\n+\n+    private static final String ENDPOINT_SUFFIX = \"gateway\";\n+\n+    private static final String PUBLIC_SUFFIX = \"external\";\n+\n+    private static final Set<Integer> DEFAULT_KNOX_PORTS = Set.of(443);\n+\n+    public Set<String> getKnoxGatewayGroups(Stack stack) {\n+        LOGGER.info(\"Fetching list of instance groups with Knox gateway installed\");\n+        Set<String> groupNames = new HashSet<>();\n+        Cluster cluster = stack.getCluster();\n+        if (cluster != null) {\n+            CmTemplateProcessor cmTemplateProcessor = new CmTemplateProcessor(cluster.getBlueprint().getBlueprintText());\n+            Map<String, Set<ServiceComponent>> components = cmTemplateProcessor.getServiceComponentsByHostGroup();\n+            LOGGER.info(\"Checking if Knox gateway is explicitly defined\");\n+            groupNames = components.entrySet().stream()\n+                .filter(e -> e.getValue().stream().anyMatch(c -> KnoxRoles.KNOX_GATEWAY.equals(c.getComponent())))\n+                .map(Map.Entry::getKey)\n+                .collect(Collectors.toSet());\n+        }\n+\n+        if (groupNames.isEmpty()) {\n+            LOGGER.info(\"Knox gateway is not explicitly defined; searching for CM gateway hosts\");\n+            groupNames = stack.getInstanceGroups().stream()\n+                .filter(i -> InstanceGroupType.isGateway(i.getInstanceGroupType()))\n+                .map(InstanceGroup::getGroupName)\n+                .collect(Collectors.toSet());\n+        }\n+\n+        if (groupNames.isEmpty()) {\n+            LOGGER.info(\"No Knox gateway instance groups found\");\n+        }\n+        return groupNames;\n+    }\n+\n+    public String generateLoadBalancerEndpoint(Stack stack, LoadBalancerType type) {\n+        List<String> s = Arrays.asList(stack.getName(), ENDPOINT_SUFFIX);\n+        if (LoadBalancerType.PUBLIC.equals(type)) {\n+            s.add(PUBLIC_SUFFIX);\n+        }\n+        return String.join(\"-\", s);\n+    }\n+\n+    public Set<Integer> getPortsForTargetGroup(TargetGroup targetGroup) {\n+        switch (targetGroup.getType()) {\n+            case \"KNOX\":", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f2bf0c1f201d9b486f2da3f6f2f3cef16ad9c26d"}, "originalPosition": 74}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzI0MTY4OQ==", "bodyText": "Yep, that's why it's a switch statement, so we can add the CM case when it's ready.", "url": "https://github.com/hortonworks/cloudbreak/pull/9475#discussion_r527241689", "createdAt": "2020-11-19T22:18:36Z", "author": {"login": "hreeve-cloudera"}, "path": "core/src/main/java/com/sequenceiq/cloudbreak/service/LoadBalancerConfigService.java", "diffHunk": "@@ -0,0 +1,80 @@\n+package com.sequenceiq.cloudbreak.service;\n+\n+import com.sequenceiq.cloudbreak.domain.stack.loadbalancer.TargetGroup;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.stereotype.Service;\n+\n+import com.sequenceiq.cloudbreak.cmtemplate.CmTemplateProcessor;\n+import com.sequenceiq.cloudbreak.cmtemplate.configproviders.knox.KnoxRoles;\n+import com.sequenceiq.cloudbreak.domain.stack.Stack;\n+import com.sequenceiq.cloudbreak.domain.stack.cluster.Cluster;\n+import com.sequenceiq.cloudbreak.domain.stack.instance.InstanceGroup;\n+import com.sequenceiq.cloudbreak.template.model.ServiceComponent;\n+import com.sequenceiq.common.api.type.InstanceGroupType;\n+import com.sequenceiq.common.api.type.LoadBalancerType;\n+\n+@Service\n+public class LoadBalancerConfigService {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(LoadBalancerConfigService.class);\n+\n+    private static final String ENDPOINT_SUFFIX = \"gateway\";\n+\n+    private static final String PUBLIC_SUFFIX = \"external\";\n+\n+    private static final Set<Integer> DEFAULT_KNOX_PORTS = Set.of(443);\n+\n+    public Set<String> getKnoxGatewayGroups(Stack stack) {\n+        LOGGER.info(\"Fetching list of instance groups with Knox gateway installed\");\n+        Set<String> groupNames = new HashSet<>();\n+        Cluster cluster = stack.getCluster();\n+        if (cluster != null) {\n+            CmTemplateProcessor cmTemplateProcessor = new CmTemplateProcessor(cluster.getBlueprint().getBlueprintText());\n+            Map<String, Set<ServiceComponent>> components = cmTemplateProcessor.getServiceComponentsByHostGroup();\n+            LOGGER.info(\"Checking if Knox gateway is explicitly defined\");\n+            groupNames = components.entrySet().stream()\n+                .filter(e -> e.getValue().stream().anyMatch(c -> KnoxRoles.KNOX_GATEWAY.equals(c.getComponent())))\n+                .map(Map.Entry::getKey)\n+                .collect(Collectors.toSet());\n+        }\n+\n+        if (groupNames.isEmpty()) {\n+            LOGGER.info(\"Knox gateway is not explicitly defined; searching for CM gateway hosts\");\n+            groupNames = stack.getInstanceGroups().stream()\n+                .filter(i -> InstanceGroupType.isGateway(i.getInstanceGroupType()))\n+                .map(InstanceGroup::getGroupName)\n+                .collect(Collectors.toSet());\n+        }\n+\n+        if (groupNames.isEmpty()) {\n+            LOGGER.info(\"No Knox gateway instance groups found\");\n+        }\n+        return groupNames;\n+    }\n+\n+    public String generateLoadBalancerEndpoint(Stack stack, LoadBalancerType type) {\n+        List<String> s = Arrays.asList(stack.getName(), ENDPOINT_SUFFIX);\n+        if (LoadBalancerType.PUBLIC.equals(type)) {\n+            s.add(PUBLIC_SUFFIX);\n+        }\n+        return String.join(\"-\", s);\n+    }\n+\n+    public Set<Integer> getPortsForTargetGroup(TargetGroup targetGroup) {\n+        switch (targetGroup.getType()) {\n+            case \"KNOX\":", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzE4MjQ4MA=="}, "originalCommit": {"oid": "f2bf0c1f201d9b486f2da3f6f2f3cef16ad9c26d"}, "originalPosition": 74}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMwNTQ2NzA2OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/com/sequenceiq/cloudbreak/service/stack/LoadBalancerService.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOVQyMDo0MjoxN1rOH2w00A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yMFQyMzo0OToyN1rOH3kTqw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzE4NTEwNA==", "bodyText": "suggestion: LoadBalancerPersistenceService maybe? I'm not generally a huge fan of the @Service ...Service pattern of naming.\nI think it's clearer to indicate that this deals with the persistence aspects of Load balancer entities.", "url": "https://github.com/hortonworks/cloudbreak/pull/9475#discussion_r527185104", "createdAt": "2020-11-19T20:42:17Z", "author": {"login": "brycederriso"}, "path": "core/src/main/java/com/sequenceiq/cloudbreak/service/stack/LoadBalancerService.java", "diffHunk": "@@ -0,0 +1,29 @@\n+package com.sequenceiq.cloudbreak.service.stack;\n+\n+import java.util.Set;\n+\n+import javax.inject.Inject;\n+\n+import org.springframework.stereotype.Service;\n+\n+import com.sequenceiq.cloudbreak.domain.stack.loadbalancer.LoadBalancer;\n+import com.sequenceiq.cloudbreak.repository.LoadBalancerRepository;\n+\n+@Service\n+public class LoadBalancerService {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5e43c56ce52d7d662196ebae07c6db60206b53a9"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODAyODU4Nw==", "bodyText": "I'm fine with that. But so you know there a lot of @Service ...Service class names in this part of the code. :)", "url": "https://github.com/hortonworks/cloudbreak/pull/9475#discussion_r528028587", "createdAt": "2020-11-20T23:49:27Z", "author": {"login": "hreeve-cloudera"}, "path": "core/src/main/java/com/sequenceiq/cloudbreak/service/stack/LoadBalancerService.java", "diffHunk": "@@ -0,0 +1,29 @@\n+package com.sequenceiq.cloudbreak.service.stack;\n+\n+import java.util.Set;\n+\n+import javax.inject.Inject;\n+\n+import org.springframework.stereotype.Service;\n+\n+import com.sequenceiq.cloudbreak.domain.stack.loadbalancer.LoadBalancer;\n+import com.sequenceiq.cloudbreak.repository.LoadBalancerRepository;\n+\n+@Service\n+public class LoadBalancerService {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzE4NTEwNA=="}, "originalCommit": {"oid": "5e43c56ce52d7d662196ebae07c6db60206b53a9"}, "originalPosition": 13}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMwNTQ3OTUzOnYy", "diffSide": "RIGHT", "path": "core/src/main/resources/schema/app/20201103154306_CB-9366_Create_load_balancer_metadata_table.sql", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOVQyMDo0NjowMlrOH2w8dg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNFQxMDoyOTowNVrOH45PLw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzE4NzA2Mg==", "bodyText": "question: Do you know what system we use to apply sql migrations?", "url": "https://github.com/hortonworks/cloudbreak/pull/9475#discussion_r527187062", "createdAt": "2020-11-19T20:46:02Z", "author": {"login": "brycederriso"}, "path": "core/src/main/resources/schema/app/20201103154306_CB-9366_Create_load_balancer_metadata_table.sql", "diffHunk": "@@ -0,0 +1,62 @@\n+-- // CB-9366 Create load balancer metadata table\n+-- Migration SQL that makes the change goes here.\n+\n+CREATE SEQUENCE loadbalancer_id_seq START WITH 1\n+  INCREMENT BY 1\n+  NO MINVALUE\n+  NO MAXVALUE\n+  CACHE 1;\n+\n+CREATE TABLE loadbalancer (\n+    id bigint default nextval('loadbalancer_id_seq'::regclass) not null\n+      constraint loadbalancer_pkey\n+        primary key,\n+    dns character varying(255),\n+    hostedzoneid character varying(255),\n+    ip character varying(255),\n+    type character varying(255),\n+    endpoint character varying(255),\n+    stack_id bigint\n+      constraint fk_loadbalancer_stack_id\n+        references stack\n+);\n+\n+CREATE INDEX loadbalancer_stack_id on loadbalancer (stack_id);\n+\n+CREATE SEQUENCE targetgroup_id_seq START WITH 1\n+  INCREMENT BY 1\n+  NO MINVALUE\n+  NO MAXVALUE\n+  CACHE 1;\n+\n+CREATE TABLE targetgroup (\n+    id bigint default nextval('targetgroup_id_seq'::regclass) not null\n+      constraint targetgroup_pkey\n+        primary key,\n+    type character varying(255),\n+    loadbalancer_id bigint\n+      constraint fk_targetgroup_loadbalancer_id\n+          references loadbalancer\n+);\n+\n+CREATE TABLE targetgroup_instancegroup (\n+    targetgroups_id bigint NOT NULL,\n+    instancegroups_id bigint NOT NULL\n+);\n+\n+ALTER TABLE ONLY targetgroup_instancegroup ADD CONSTRAINT targetgroup_instancegroup_pkey PRIMARY KEY (targetgroups_id, instancegroups_id);\n+ALTER TABLE ONLY targetgroup_instancegroup ADD CONSTRAINT fk_targetgroup_instancegroup_targetgroup_id FOREIGN KEY (targetgroups_id) REFERENCES targetgroup(id);\n+ALTER TABLE ONLY targetgroup_instancegroup ADD CONSTRAINT fk_targetgroup_instancegroup_instancegroup_id FOREIGN KEY (instancegroups_id) REFERENCES instancegroup(id);\n+\n+-- //@UNDO", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5e43c56ce52d7d662196ebae07c6db60206b53a9"}, "originalPosition": 51}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODAyODU2NQ==", "bodyText": "I don't. I suspect there's a way to add these constraints to the original table creation, but I'm not good enough at SQL to know exactly what that should look like, so I just copied the only other ManyToMany relationship example in the code base.", "url": "https://github.com/hortonworks/cloudbreak/pull/9475#discussion_r528028565", "createdAt": "2020-11-20T23:49:22Z", "author": {"login": "hreeve-cloudera"}, "path": "core/src/main/resources/schema/app/20201103154306_CB-9366_Create_load_balancer_metadata_table.sql", "diffHunk": "@@ -0,0 +1,62 @@\n+-- // CB-9366 Create load balancer metadata table\n+-- Migration SQL that makes the change goes here.\n+\n+CREATE SEQUENCE loadbalancer_id_seq START WITH 1\n+  INCREMENT BY 1\n+  NO MINVALUE\n+  NO MAXVALUE\n+  CACHE 1;\n+\n+CREATE TABLE loadbalancer (\n+    id bigint default nextval('loadbalancer_id_seq'::regclass) not null\n+      constraint loadbalancer_pkey\n+        primary key,\n+    dns character varying(255),\n+    hostedzoneid character varying(255),\n+    ip character varying(255),\n+    type character varying(255),\n+    endpoint character varying(255),\n+    stack_id bigint\n+      constraint fk_loadbalancer_stack_id\n+        references stack\n+);\n+\n+CREATE INDEX loadbalancer_stack_id on loadbalancer (stack_id);\n+\n+CREATE SEQUENCE targetgroup_id_seq START WITH 1\n+  INCREMENT BY 1\n+  NO MINVALUE\n+  NO MAXVALUE\n+  CACHE 1;\n+\n+CREATE TABLE targetgroup (\n+    id bigint default nextval('targetgroup_id_seq'::regclass) not null\n+      constraint targetgroup_pkey\n+        primary key,\n+    type character varying(255),\n+    loadbalancer_id bigint\n+      constraint fk_targetgroup_loadbalancer_id\n+          references loadbalancer\n+);\n+\n+CREATE TABLE targetgroup_instancegroup (\n+    targetgroups_id bigint NOT NULL,\n+    instancegroups_id bigint NOT NULL\n+);\n+\n+ALTER TABLE ONLY targetgroup_instancegroup ADD CONSTRAINT targetgroup_instancegroup_pkey PRIMARY KEY (targetgroups_id, instancegroups_id);\n+ALTER TABLE ONLY targetgroup_instancegroup ADD CONSTRAINT fk_targetgroup_instancegroup_targetgroup_id FOREIGN KEY (targetgroups_id) REFERENCES targetgroup(id);\n+ALTER TABLE ONLY targetgroup_instancegroup ADD CONSTRAINT fk_targetgroup_instancegroup_instancegroup_id FOREIGN KEY (instancegroups_id) REFERENCES instancegroup(id);\n+\n+-- //@UNDO", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzE4NzA2Mg=="}, "originalCommit": {"oid": "5e43c56ce52d7d662196ebae07c6db60206b53a9"}, "originalPosition": 51}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTQyMDA3OQ==", "bodyText": "Some background materials:\n\nhttps://github.com/hortonworks/cloudbreak#database-development\nhttps://cloudera.atlassian.net/wiki/spaces/ENG/pages/931037185/TRAINING+-+Database", "url": "https://github.com/hortonworks/cloudbreak/pull/9475#discussion_r529420079", "createdAt": "2020-11-24T10:29:05Z", "author": {"login": "lajosrodek"}, "path": "core/src/main/resources/schema/app/20201103154306_CB-9366_Create_load_balancer_metadata_table.sql", "diffHunk": "@@ -0,0 +1,62 @@\n+-- // CB-9366 Create load balancer metadata table\n+-- Migration SQL that makes the change goes here.\n+\n+CREATE SEQUENCE loadbalancer_id_seq START WITH 1\n+  INCREMENT BY 1\n+  NO MINVALUE\n+  NO MAXVALUE\n+  CACHE 1;\n+\n+CREATE TABLE loadbalancer (\n+    id bigint default nextval('loadbalancer_id_seq'::regclass) not null\n+      constraint loadbalancer_pkey\n+        primary key,\n+    dns character varying(255),\n+    hostedzoneid character varying(255),\n+    ip character varying(255),\n+    type character varying(255),\n+    endpoint character varying(255),\n+    stack_id bigint\n+      constraint fk_loadbalancer_stack_id\n+        references stack\n+);\n+\n+CREATE INDEX loadbalancer_stack_id on loadbalancer (stack_id);\n+\n+CREATE SEQUENCE targetgroup_id_seq START WITH 1\n+  INCREMENT BY 1\n+  NO MINVALUE\n+  NO MAXVALUE\n+  CACHE 1;\n+\n+CREATE TABLE targetgroup (\n+    id bigint default nextval('targetgroup_id_seq'::regclass) not null\n+      constraint targetgroup_pkey\n+        primary key,\n+    type character varying(255),\n+    loadbalancer_id bigint\n+      constraint fk_targetgroup_loadbalancer_id\n+          references loadbalancer\n+);\n+\n+CREATE TABLE targetgroup_instancegroup (\n+    targetgroups_id bigint NOT NULL,\n+    instancegroups_id bigint NOT NULL\n+);\n+\n+ALTER TABLE ONLY targetgroup_instancegroup ADD CONSTRAINT targetgroup_instancegroup_pkey PRIMARY KEY (targetgroups_id, instancegroups_id);\n+ALTER TABLE ONLY targetgroup_instancegroup ADD CONSTRAINT fk_targetgroup_instancegroup_targetgroup_id FOREIGN KEY (targetgroups_id) REFERENCES targetgroup(id);\n+ALTER TABLE ONLY targetgroup_instancegroup ADD CONSTRAINT fk_targetgroup_instancegroup_instancegroup_id FOREIGN KEY (instancegroups_id) REFERENCES instancegroup(id);\n+\n+-- //@UNDO", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzE4NzA2Mg=="}, "originalCommit": {"oid": "5e43c56ce52d7d662196ebae07c6db60206b53a9"}, "originalPosition": 51}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMwNTQ4NDgxOnYy", "diffSide": "RIGHT", "path": "cloud-aws/src/main/java/com/sequenceiq/cloudbreak/cloud/aws/CloudFormationTemplateBuilder.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOVQyMDo0NzoxN1rOH2w_eQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOVQyMDo0NzoxN1rOH2w_eQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzE4NzgzMw==", "bodyText": "Could do a Optional.ofNullable(context.loadBalncers).orElse(new ArrayList());", "url": "https://github.com/hortonworks/cloudbreak/pull/9475#discussion_r527187833", "createdAt": "2020-11-19T20:47:17Z", "author": {"login": "frozenwizard"}, "path": "cloud-aws/src/main/java/com/sequenceiq/cloudbreak/cloud/aws/CloudFormationTemplateBuilder.java", "diffHunk": "@@ -91,6 +92,7 @@ public String build(ModelContext context) {\n         model.put(\"outboundInternetTraffic\", context.outboundInternetTraffic);\n         model.put(\"vpcCidrs\", context.vpcCidrs);\n         model.put(\"prefixListIds\", context.prefixListIds);\n+        model.put(\"loadBalancers\", context.loadBalancers == null ? new ArrayList<>() : context.loadBalancers);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2ed3b72c53f6bf1676d0a131295045c8dd203b4f"}, "originalPosition": 12}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMwNTQ5ODgyOnYy", "diffSide": "RIGHT", "path": "cloud-aws/src/main/java/com/sequenceiq/cloudbreak/cloud/aws/connector/resource/AwsLaunchService.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOVQyMDo1MToxMFrOH2xHlQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOVQyMDo1MToxMFrOH2xHlQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzE4OTkwOQ==", "bodyText": "there's a findFirst() you can use instead.", "url": "https://github.com/hortonworks/cloudbreak/pull/9475#discussion_r527189909", "createdAt": "2020-11-19T20:51:10Z", "author": {"login": "frozenwizard"}, "path": "cloud-aws/src/main/java/com/sequenceiq/cloudbreak/cloud/aws/connector/resource/AwsLaunchService.java", "diffHunk": "@@ -171,9 +164,128 @@\n \n         awsCloudWatchService.addCloudWatchAlarmsForSystemFailures(instances, stack, regionName, credentialView);\n \n+        updateCloudformationWithLoadBalancer(ac, stack, resourceNotifier, modelContext, instances);\n+\n         return awsResourceConnector.check(ac, instances);\n     }\n \n+    private ModelContext buildDefaultModelContext(AuthenticatedContext ac, CloudStack stack, PersistenceNotifier resourceNotifier) {\n+        AwsCredentialView credentialView = new AwsCredentialView(ac.getCloudCredential());\n+        String regionName = ac.getCloudContext().getLocation().getRegion().value();\n+        AmazonEC2Client amazonEC2Client = awsClient.createAccess(credentialView, regionName);\n+        Network network = stack.getNetwork();\n+        AwsNetworkView awsNetworkView = new AwsNetworkView(network);\n+        boolean mapPublicIpOnLaunch = awsNetworkService.isMapPublicOnLaunch(awsNetworkView, amazonEC2Client);\n+\n+        boolean existingVPC = awsNetworkView.isExistingVPC();\n+        boolean existingSubnet = awsNetworkView.isExistingSubnet();\n+\n+        String cidr = network.getSubnet().getCidr();\n+        String subnet = isNoCIDRProvided(existingVPC, existingSubnet, cidr) ? awsNetworkService.findNonOverLappingCIDR(ac, stack) : cidr;\n+        AwsInstanceProfileView awsInstanceProfileView = new AwsInstanceProfileView(stack);\n+        ModelContext modelContext = new ModelContext()\n+            .withAuthenticatedContext(ac)\n+            .withStack(stack)\n+            .withExistingVpc(existingVPC)\n+            .withExistingIGW(awsNetworkView.isExistingIGW())\n+            .withExistingSubnetCidr(existingSubnet ? awsNetworkService.getExistingSubnetCidr(ac, stack) : null)\n+            .withExistinVpcCidr(awsNetworkService.getVpcCidrs(ac, stack))\n+            .withExistingSubnetIds(existingSubnet ? awsNetworkView.getSubnetList() : null)\n+            .mapPublicIpOnLaunch(mapPublicIpOnLaunch)\n+            .withEnableInstanceProfile(awsInstanceProfileView.isInstanceProfileAvailable())\n+            .withInstanceProfileAvailable(awsInstanceProfileView.isInstanceProfileAvailable())\n+            .withTemplate(stack.getTemplate())\n+            .withDefaultSubnet(subnet)\n+            .withOutboundInternetTraffic(network.getOutboundInternetTraffic())\n+            .withVpcCidrs(network.getNetworkCidrs())\n+            .withPrefixListIds(getPrefixListIds(amazonEC2Client, regionName, network.getOutboundInternetTraffic()))\n+            .withEncryptedAMIByGroupName(encryptedImageCopyService.createEncryptedImages(ac, stack, resourceNotifier));\n+\n+        return modelContext;\n+    }\n+\n+    private void updateCloudformationWithLoadBalancer(AuthenticatedContext ac, CloudStack stack, PersistenceNotifier resourceNotifier,\n+            ModelContext modelContext, List<CloudResource> instances) {\n+\n+        if (stack.getLoadBalancers().isPresent() && !stack.getLoadBalancers().get().isEmpty()) {\n+            if (modelContext == null) {\n+                modelContext = buildDefaultModelContext(ac, stack, resourceNotifier);\n+            }\n+\n+            List<AwsLoadBalancer> awsLoadBalancers = new ArrayList<>();\n+            List<CloudLoadBalancer> cloudLoadBalancers = stack.getLoadBalancers().get();\n+            for (CloudLoadBalancer cloudLoadBalancer : cloudLoadBalancers) {\n+                awsLoadBalancers.add(convert(cloudLoadBalancer, stack, instances));\n+            }\n+\n+            modelContext.withLoadBalancers(awsLoadBalancers);\n+            ListStackResourcesResult result = updateCloudFormationStack(ac, stack, modelContext);\n+\n+            for (AwsLoadBalancer loadBalancer : awsLoadBalancers) {\n+                for (AwsListener listener : loadBalancer.getListeners()) {\n+                    for (AwsTargetGroup targetGroup : listener.getTargetGroups()) {\n+                        StackResourceSummary targetGroupSummary = result.getStackResourceSummaries().stream()\n+                            .filter(stackResourceSummary -> targetGroup.getName().equals(stackResourceSummary.getLogicalResourceId()))\n+                            .collect(Collectors.toList())\n+                            .get(0);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2ed3b72c53f6bf1676d0a131295045c8dd203b4f"}, "originalPosition": 139}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMwNTQ5OTExOnYy", "diffSide": "RIGHT", "path": "cloud-aws/src/main/java/com/sequenceiq/cloudbreak/cloud/aws/connector/resource/AwsLaunchService.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOVQyMDo1MToxNlrOH2xHxQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOVQyMDo1MToxNlrOH2xHxQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzE4OTk1Nw==", "bodyText": "findFirst()", "url": "https://github.com/hortonworks/cloudbreak/pull/9475#discussion_r527189957", "createdAt": "2020-11-19T20:51:16Z", "author": {"login": "frozenwizard"}, "path": "cloud-aws/src/main/java/com/sequenceiq/cloudbreak/cloud/aws/connector/resource/AwsLaunchService.java", "diffHunk": "@@ -171,9 +164,128 @@\n \n         awsCloudWatchService.addCloudWatchAlarmsForSystemFailures(instances, stack, regionName, credentialView);\n \n+        updateCloudformationWithLoadBalancer(ac, stack, resourceNotifier, modelContext, instances);\n+\n         return awsResourceConnector.check(ac, instances);\n     }\n \n+    private ModelContext buildDefaultModelContext(AuthenticatedContext ac, CloudStack stack, PersistenceNotifier resourceNotifier) {\n+        AwsCredentialView credentialView = new AwsCredentialView(ac.getCloudCredential());\n+        String regionName = ac.getCloudContext().getLocation().getRegion().value();\n+        AmazonEC2Client amazonEC2Client = awsClient.createAccess(credentialView, regionName);\n+        Network network = stack.getNetwork();\n+        AwsNetworkView awsNetworkView = new AwsNetworkView(network);\n+        boolean mapPublicIpOnLaunch = awsNetworkService.isMapPublicOnLaunch(awsNetworkView, amazonEC2Client);\n+\n+        boolean existingVPC = awsNetworkView.isExistingVPC();\n+        boolean existingSubnet = awsNetworkView.isExistingSubnet();\n+\n+        String cidr = network.getSubnet().getCidr();\n+        String subnet = isNoCIDRProvided(existingVPC, existingSubnet, cidr) ? awsNetworkService.findNonOverLappingCIDR(ac, stack) : cidr;\n+        AwsInstanceProfileView awsInstanceProfileView = new AwsInstanceProfileView(stack);\n+        ModelContext modelContext = new ModelContext()\n+            .withAuthenticatedContext(ac)\n+            .withStack(stack)\n+            .withExistingVpc(existingVPC)\n+            .withExistingIGW(awsNetworkView.isExistingIGW())\n+            .withExistingSubnetCidr(existingSubnet ? awsNetworkService.getExistingSubnetCidr(ac, stack) : null)\n+            .withExistinVpcCidr(awsNetworkService.getVpcCidrs(ac, stack))\n+            .withExistingSubnetIds(existingSubnet ? awsNetworkView.getSubnetList() : null)\n+            .mapPublicIpOnLaunch(mapPublicIpOnLaunch)\n+            .withEnableInstanceProfile(awsInstanceProfileView.isInstanceProfileAvailable())\n+            .withInstanceProfileAvailable(awsInstanceProfileView.isInstanceProfileAvailable())\n+            .withTemplate(stack.getTemplate())\n+            .withDefaultSubnet(subnet)\n+            .withOutboundInternetTraffic(network.getOutboundInternetTraffic())\n+            .withVpcCidrs(network.getNetworkCidrs())\n+            .withPrefixListIds(getPrefixListIds(amazonEC2Client, regionName, network.getOutboundInternetTraffic()))\n+            .withEncryptedAMIByGroupName(encryptedImageCopyService.createEncryptedImages(ac, stack, resourceNotifier));\n+\n+        return modelContext;\n+    }\n+\n+    private void updateCloudformationWithLoadBalancer(AuthenticatedContext ac, CloudStack stack, PersistenceNotifier resourceNotifier,\n+            ModelContext modelContext, List<CloudResource> instances) {\n+\n+        if (stack.getLoadBalancers().isPresent() && !stack.getLoadBalancers().get().isEmpty()) {\n+            if (modelContext == null) {\n+                modelContext = buildDefaultModelContext(ac, stack, resourceNotifier);\n+            }\n+\n+            List<AwsLoadBalancer> awsLoadBalancers = new ArrayList<>();\n+            List<CloudLoadBalancer> cloudLoadBalancers = stack.getLoadBalancers().get();\n+            for (CloudLoadBalancer cloudLoadBalancer : cloudLoadBalancers) {\n+                awsLoadBalancers.add(convert(cloudLoadBalancer, stack, instances));\n+            }\n+\n+            modelContext.withLoadBalancers(awsLoadBalancers);\n+            ListStackResourcesResult result = updateCloudFormationStack(ac, stack, modelContext);\n+\n+            for (AwsLoadBalancer loadBalancer : awsLoadBalancers) {\n+                for (AwsListener listener : loadBalancer.getListeners()) {\n+                    for (AwsTargetGroup targetGroup : listener.getTargetGroups()) {\n+                        StackResourceSummary targetGroupSummary = result.getStackResourceSummaries().stream()\n+                            .filter(stackResourceSummary -> targetGroup.getName().equals(stackResourceSummary.getLogicalResourceId()))\n+                            .collect(Collectors.toList())\n+                            .get(0);\n+                        targetGroup.setArn(targetGroupSummary.getPhysicalResourceId());\n+                    }\n+                }\n+                StackResourceSummary loadBalancerSummary = result.getStackResourceSummaries().stream()\n+                    .filter(stackResourceSummary -> loadBalancer.getName().equals(stackResourceSummary.getLogicalResourceId()))", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2ed3b72c53f6bf1676d0a131295045c8dd203b4f"}, "originalPosition": 144}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMwNTUwODYyOnYy", "diffSide": "RIGHT", "path": "cloud-aws/src/main/java/com/sequenceiq/cloudbreak/cloud/aws/loadbalancer/AwsTargetGroup.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOVQyMDo1NDowN1rOH2xNuA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOVQyMjoyNToyN1rOH20fRw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzE5MTQ4MA==", "bodyText": "huh?  capatilize into lower case?", "url": "https://github.com/hortonworks/cloudbreak/pull/9475#discussion_r527191480", "createdAt": "2020-11-19T20:54:07Z", "author": {"login": "frozenwizard"}, "path": "cloud-aws/src/main/java/com/sequenceiq/cloudbreak/cloud/aws/loadbalancer/AwsTargetGroup.java", "diffHunk": "@@ -0,0 +1,56 @@\n+package com.sequenceiq.cloudbreak.cloud.aws.loadbalancer;\n+\n+import java.util.List;\n+\n+import org.apache.commons.lang3.StringUtils;\n+\n+public class AwsTargetGroup {\n+\n+    private static final String TARGET_GROUP_NAME_PREFIX = \"TargetGroupPort\";\n+\n+    private final int port;\n+\n+    private final String name;\n+\n+    private final int order;\n+\n+    private final List<String> instanceIds;\n+\n+    private String arn;\n+\n+    public AwsTargetGroup(int port, AwsLoadBalancerScheme scheme, int order, List<String> instanceIds) {\n+        this.port = port;\n+        this.order = order;\n+        this.instanceIds = instanceIds;\n+        name = getTargetGroupName(port, scheme);\n+    }\n+\n+    public int getPort() {\n+        return port;\n+    }\n+\n+    public String getArn() {\n+        return arn;\n+    }\n+\n+    public void setArn(String arn) {\n+        this.arn = arn;\n+    }\n+\n+    public String getName() {\n+        return name;\n+    }\n+\n+    public int getOrder() {\n+        return order;\n+    }\n+\n+    public List<String> getInstanceIds() {\n+        return instanceIds;\n+    }\n+\n+    private static String getTargetGroupName(int port, AwsLoadBalancerScheme scheme) {\n+        return TARGET_GROUP_NAME_PREFIX + port +\n+            StringUtils.capitalize(scheme.name().toLowerCase());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2ed3b72c53f6bf1676d0a131295045c8dd203b4f"}, "originalPosition": 54}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzI0NTEyNw==", "bodyText": "Technically lowercase into capitalize, so PRIVATE becomes Private. I couldn't find a more elegant way to do it. There's no real reason to be this nitpicky about the capitalization, I just think it looks better to have LoadBalancerPrivate instead of LoadBalancerprivate or LoadBalancerPRIVATE.", "url": "https://github.com/hortonworks/cloudbreak/pull/9475#discussion_r527245127", "createdAt": "2020-11-19T22:25:27Z", "author": {"login": "hreeve-cloudera"}, "path": "cloud-aws/src/main/java/com/sequenceiq/cloudbreak/cloud/aws/loadbalancer/AwsTargetGroup.java", "diffHunk": "@@ -0,0 +1,56 @@\n+package com.sequenceiq.cloudbreak.cloud.aws.loadbalancer;\n+\n+import java.util.List;\n+\n+import org.apache.commons.lang3.StringUtils;\n+\n+public class AwsTargetGroup {\n+\n+    private static final String TARGET_GROUP_NAME_PREFIX = \"TargetGroupPort\";\n+\n+    private final int port;\n+\n+    private final String name;\n+\n+    private final int order;\n+\n+    private final List<String> instanceIds;\n+\n+    private String arn;\n+\n+    public AwsTargetGroup(int port, AwsLoadBalancerScheme scheme, int order, List<String> instanceIds) {\n+        this.port = port;\n+        this.order = order;\n+        this.instanceIds = instanceIds;\n+        name = getTargetGroupName(port, scheme);\n+    }\n+\n+    public int getPort() {\n+        return port;\n+    }\n+\n+    public String getArn() {\n+        return arn;\n+    }\n+\n+    public void setArn(String arn) {\n+        this.arn = arn;\n+    }\n+\n+    public String getName() {\n+        return name;\n+    }\n+\n+    public int getOrder() {\n+        return order;\n+    }\n+\n+    public List<String> getInstanceIds() {\n+        return instanceIds;\n+    }\n+\n+    private static String getTargetGroupName(int port, AwsLoadBalancerScheme scheme) {\n+        return TARGET_GROUP_NAME_PREFIX + port +\n+            StringUtils.capitalize(scheme.name().toLowerCase());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzE5MTQ4MA=="}, "originalCommit": {"oid": "2ed3b72c53f6bf1676d0a131295045c8dd203b4f"}, "originalPosition": 54}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMwNTUxNjU2OnYy", "diffSide": "RIGHT", "path": "cloud-aws/src/main/java/com/sequenceiq/cloudbreak/cloud/aws/AwsMetadataCollector.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOVQyMDo1NjoxN1rOH2xShA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOVQyMjoxOTo1OVrOH20UlA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzE5MjcwOA==", "bodyText": "jira?", "url": "https://github.com/hortonworks/cloudbreak/pull/9475#discussion_r527192708", "createdAt": "2020-11-19T20:56:17Z", "author": {"login": "frozenwizard"}, "path": "cloud-aws/src/main/java/com/sequenceiq/cloudbreak/cloud/aws/AwsMetadataCollector.java", "diffHunk": "@@ -171,4 +176,30 @@ private void addKnownInstance(CloudInstance cloudInstance, Multimap<String, Inst\n                 .flatMap(reservation -> reservation.getInstances().stream())\n                 .collect(Collectors.toList());\n     }\n+\n+    @Override\n+    public List<CloudLoadBalancerMetadata> collectLoadBalancer(AuthenticatedContext ac, List<String> gatewayGroupNames) {\n+        LOGGER.debug(\"Collect AWS load balanacer metadata, for cluster {}\", ac.getCloudContext().getName());\n+\n+        String region = ac.getCloudContext().getLocation().getRegion().value();\n+\n+        List<CloudLoadBalancerMetadata> cloudLoadBalancerMetadata = new ArrayList<>();\n+        try {\n+            for (String groupName : gatewayGroupNames) {\n+                String loadBalancerName = AwsLoadBalancer.getLoadBalancerName(AwsLoadBalancerScheme.PRIVATE);\n+                LoadBalancer loadBalancer = cloudFormationStackUtil.getLoadBalancerByLogicalId(ac, loadBalancerName, region);\n+                cloudLoadBalancerMetadata.add(new CloudLoadBalancerMetadata(\n+                    groupName,\n+                    LoadBalancerType.PRIVATE,\n+                    loadBalancer.getDNSName(),\n+                    loadBalancer.getCanonicalHostedZoneId(),\n+                    null\n+                ));\n+                // TODO public endpoints", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "de55a4bb1b4971dd8f935faf64cd1e01685b9bb1"}, "originalPosition": 51}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzI0MjM4OA==", "bodyText": "Old comment. Deleted it and changed LoadBalancerType.PRIVATE to LoadBalancerType.valueOf(type), which should handle either case.", "url": "https://github.com/hortonworks/cloudbreak/pull/9475#discussion_r527242388", "createdAt": "2020-11-19T22:19:59Z", "author": {"login": "hreeve-cloudera"}, "path": "cloud-aws/src/main/java/com/sequenceiq/cloudbreak/cloud/aws/AwsMetadataCollector.java", "diffHunk": "@@ -171,4 +176,30 @@ private void addKnownInstance(CloudInstance cloudInstance, Multimap<String, Inst\n                 .flatMap(reservation -> reservation.getInstances().stream())\n                 .collect(Collectors.toList());\n     }\n+\n+    @Override\n+    public List<CloudLoadBalancerMetadata> collectLoadBalancer(AuthenticatedContext ac, List<String> gatewayGroupNames) {\n+        LOGGER.debug(\"Collect AWS load balanacer metadata, for cluster {}\", ac.getCloudContext().getName());\n+\n+        String region = ac.getCloudContext().getLocation().getRegion().value();\n+\n+        List<CloudLoadBalancerMetadata> cloudLoadBalancerMetadata = new ArrayList<>();\n+        try {\n+            for (String groupName : gatewayGroupNames) {\n+                String loadBalancerName = AwsLoadBalancer.getLoadBalancerName(AwsLoadBalancerScheme.PRIVATE);\n+                LoadBalancer loadBalancer = cloudFormationStackUtil.getLoadBalancerByLogicalId(ac, loadBalancerName, region);\n+                cloudLoadBalancerMetadata.add(new CloudLoadBalancerMetadata(\n+                    groupName,\n+                    LoadBalancerType.PRIVATE,\n+                    loadBalancer.getDNSName(),\n+                    loadBalancer.getCanonicalHostedZoneId(),\n+                    null\n+                ));\n+                // TODO public endpoints", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzE5MjcwOA=="}, "originalCommit": {"oid": "de55a4bb1b4971dd8f935faf64cd1e01685b9bb1"}, "originalPosition": 51}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMwNTU2MTQ4OnYy", "diffSide": "RIGHT", "path": "cloud-api/src/main/java/com/sequenceiq/cloudbreak/cloud/model/CloudStack.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOVQyMTowODo1NlrOH2xtsQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yMFQyMzo0NDo1MlrOH3kPgw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzE5OTY2NQ==", "bodyText": "suggestion: Consider using an empty List here instead of null.\nI'd prefer the semantics of an empty List<CloudLoadBalancer> over Optional<List<CloudLoadBalancer> as well.\nI'd only expect that to throw a wrench in maybe serialization? Are there other reasons you chose Optional over an empty list?", "url": "https://github.com/hortonworks/cloudbreak/pull/9475#discussion_r527199665", "createdAt": "2020-11-19T21:08:56Z", "author": {"login": "brycederriso"}, "path": "cloud-api/src/main/java/com/sequenceiq/cloudbreak/cloud/model/CloudStack.java", "diffHunk": "@@ -33,8 +33,16 @@\n \n     private final Optional<SpiFileSystem> fileSystem;\n \n+    private final Optional<List<CloudLoadBalancer>> loadBalancers;\n+\n     public CloudStack(Collection<Group> groups, Network network, Image image, Map<String, String> parameters, Map<String, String> tags, String template,\n             InstanceAuthentication instanceAuthentication, String loginUserName, String publicKey, SpiFileSystem fileSystem) {\n+        this(groups, network, image, parameters, tags, template, instanceAuthentication, loginUserName, publicKey, fileSystem, null);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f2bf0c1f201d9b486f2da3f6f2f3cef16ad9c26d"}, "originalPosition": 8}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODAyNzUyMw==", "bodyText": "Serialization should be fine. I've been working on these changes for about a month, and I think the optional choice was made here when I thought there would only be a single load balancer, and I just never updated it when I changed that to a list. But that makes sense, and I'll change it to empty list.", "url": "https://github.com/hortonworks/cloudbreak/pull/9475#discussion_r528027523", "createdAt": "2020-11-20T23:44:52Z", "author": {"login": "hreeve-cloudera"}, "path": "cloud-api/src/main/java/com/sequenceiq/cloudbreak/cloud/model/CloudStack.java", "diffHunk": "@@ -33,8 +33,16 @@\n \n     private final Optional<SpiFileSystem> fileSystem;\n \n+    private final Optional<List<CloudLoadBalancer>> loadBalancers;\n+\n     public CloudStack(Collection<Group> groups, Network network, Image image, Map<String, String> parameters, Map<String, String> tags, String template,\n             InstanceAuthentication instanceAuthentication, String loginUserName, String publicKey, SpiFileSystem fileSystem) {\n+        this(groups, network, image, parameters, tags, template, instanceAuthentication, loginUserName, publicKey, fileSystem, null);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzE5OTY2NQ=="}, "originalCommit": {"oid": "f2bf0c1f201d9b486f2da3f6f2f3cef16ad9c26d"}, "originalPosition": 8}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMwNTU2NTQxOnYy", "diffSide": "RIGHT", "path": "common-model/src/main/java/com/sequenceiq/common/api/type/LoadBalancerType.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOVQyMTowOTo1MVrOH2xv7g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOVQyMTowOTo1MVrOH2xv7g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzIwMDIzOA==", "bodyText": "praise: Thank you for not making these just String constants!\nLove me some enums.", "url": "https://github.com/hortonworks/cloudbreak/pull/9475#discussion_r527200238", "createdAt": "2020-11-19T21:09:51Z", "author": {"login": "brycederriso"}, "path": "common-model/src/main/java/com/sequenceiq/common/api/type/LoadBalancerType.java", "diffHunk": "@@ -0,0 +1,6 @@\n+package com.sequenceiq.common.api.type;\n+\n+public enum LoadBalancerType {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f2bf0c1f201d9b486f2da3f6f2f3cef16ad9c26d"}, "originalPosition": 3}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMxMDY4NzI4OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/com/sequenceiq/cloudbreak/converter/v4/stacks/StackV4RequestToStackConverter.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yMFQyMjoyMzoxMVrOH3iuNg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yMFQyMzo0NDozN1rOH3kPPw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODAwMjYxNA==", "bodyText": "question: The body of this if is adding knox TargetGroups to the targetGroups set if the stack we're working with is a Datalake?\nIf possible, I think it would be clearer to move the knoxGatewayGroups out of the if block and do an else:\n    private Set<LoadBalancer> createLoadBalancers(StackV4Request source, Stack stack) {\n        Set<LoadBalancer> loadBalancers = new HashSet<>();\n        Set<TargetGroup> targetGroups = new HashSet<>();\n        // TODO expand this to data hubs\n\n        Set<String> knoxGatewayGroupNames = loadBalancerConfigService.getKnoxGatewayGroups(stack);\n        Set<InstanceGroup> knoxGatewayGroups = stack.getInstanceGroups().stream()\n                .filter(ig -> knoxGatewayGroupNames.contains(ig.getGroupName()))\n                .collect(Collectors.toSet());\n\n        if (StackType.DATALAKE.equals(source.getType()) && !knoxGatewayGroups.isEmpty()) {\n            LOGGER.info(\"Setting up load balancers for stack {}\", source.getName());\n            LOGGER.info(\"Knox gateway instance found; enabling Knox load balancer configuration.\");\n            TargetGroup targetGroup = new TargetGroup();\n            targetGroup.setType(TargetGroupType.KNOX.name());\n            targetGroup.setInstanceGroups(knoxGatewayGroups);\n            targetGroups.add(targetGroup);\n            // TODO create target group for CM instances\n        } else {\n            LoadBalancer loadBalancer = new LoadBalancer();\n            loadBalancer.setStack(stack);\n            // TODO actually figure out the type we need here\n            loadBalancer.setType(LoadBalancerType.PRIVATE.name());\n            loadBalancer.setTargetGroups(targetGroups);\n            targetGroups.forEach(tg -> tg.setLoadBalancer(loadBalancer));\n            loadBalancers.add(loadBalancer);\n        }\n\n        return loadBalancers;\n    }", "url": "https://github.com/hortonworks/cloudbreak/pull/9475#discussion_r528002614", "createdAt": "2020-11-20T22:23:11Z", "author": {"login": "brycederriso"}, "path": "core/src/main/java/com/sequenceiq/cloudbreak/converter/v4/stacks/StackV4RequestToStackConverter.java", "diffHunk": "@@ -335,6 +344,40 @@ private void validateStackAuthentication(StackV4Request source) {\n         return convertedSet;\n     }\n \n+    private Set<LoadBalancer> createLoadBalancers(StackV4Request source, Stack stack) {\n+        Set<LoadBalancer> loadBalancers = new HashSet<>();\n+        Set<TargetGroup> targetGroups = new HashSet<>();\n+        // TODO expand this to data hubs\n+        if (StackType.DATALAKE.equals(source.getType())) {\n+            LOGGER.info(\"Setting up load balancers for stack {}\", source.getName());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f2bf0c1f201d9b486f2da3f6f2f3cef16ad9c26d"}, "originalPosition": 50}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODAyNzQ1NQ==", "bodyText": "My intention was to limit the stack types that could have load balancers at all to only data lakes. If it's any other kind of stack we shouldn't add anything to the target groups at all. So having an else at all is anathema to that. It's a gatekeeping if.\nThe way target groups work is they're just a type of traffic and the instance groups that traffic is forwarded to. In the else you're creating target groups, but not setting either of those properties. Which is basically saying to the load balancer, \"I want you to forward traffic, but I'm not going to tell you what traffic to forward or where it's going.\" Which is making me realize I should really mark those fields as non-null so we know they need to be set.\nWith that in mind, do you have any suggestions on how to clarify it?", "url": "https://github.com/hortonworks/cloudbreak/pull/9475#discussion_r528027455", "createdAt": "2020-11-20T23:44:37Z", "author": {"login": "hreeve-cloudera"}, "path": "core/src/main/java/com/sequenceiq/cloudbreak/converter/v4/stacks/StackV4RequestToStackConverter.java", "diffHunk": "@@ -335,6 +344,40 @@ private void validateStackAuthentication(StackV4Request source) {\n         return convertedSet;\n     }\n \n+    private Set<LoadBalancer> createLoadBalancers(StackV4Request source, Stack stack) {\n+        Set<LoadBalancer> loadBalancers = new HashSet<>();\n+        Set<TargetGroup> targetGroups = new HashSet<>();\n+        // TODO expand this to data hubs\n+        if (StackType.DATALAKE.equals(source.getType())) {\n+            LOGGER.info(\"Setting up load balancers for stack {}\", source.getName());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODAwMjYxNA=="}, "originalCommit": {"oid": "f2bf0c1f201d9b486f2da3f6f2f3cef16ad9c26d"}, "originalPosition": 50}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMxMDc2Njg2OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/com/sequenceiq/cloudbreak/service/LoadBalancerConfigService.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yMFQyMjo1ODo1OFrOH3jdDg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yMFQyMzo0NDoyMVrOH3kPCA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODAxNDYwNg==", "bodyText": "suggestion: I'd generally prefer not to double nest streams like this, but I'm not sure it's avoidable here.\nYou could extract a function hostGroupContainsKnoxGateway that contains the e -> e.getValue().stream().anyMatch(c -> KnoxRoles.KNOX_GATEWAY.equals(c.getComponent())) portion and then do:\n            groupNames = components.entrySet().stream()\n                .filter(hostGroupContainsKnoxGateway)\n                .map(Map.Entry::getKey)\n                .collect(Collectors.toSet());\nBut, barring that, consider expanding the lambda function parameters e and c into what they they actually represent -- entry and serviceComponent I think.", "url": "https://github.com/hortonworks/cloudbreak/pull/9475#discussion_r528014606", "createdAt": "2020-11-20T22:58:58Z", "author": {"login": "brycederriso"}, "path": "core/src/main/java/com/sequenceiq/cloudbreak/service/LoadBalancerConfigService.java", "diffHunk": "@@ -0,0 +1,80 @@\n+package com.sequenceiq.cloudbreak.service;\n+\n+import com.sequenceiq.cloudbreak.domain.stack.loadbalancer.TargetGroup;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.stereotype.Service;\n+\n+import com.sequenceiq.cloudbreak.cmtemplate.CmTemplateProcessor;\n+import com.sequenceiq.cloudbreak.cmtemplate.configproviders.knox.KnoxRoles;\n+import com.sequenceiq.cloudbreak.domain.stack.Stack;\n+import com.sequenceiq.cloudbreak.domain.stack.cluster.Cluster;\n+import com.sequenceiq.cloudbreak.domain.stack.instance.InstanceGroup;\n+import com.sequenceiq.cloudbreak.template.model.ServiceComponent;\n+import com.sequenceiq.common.api.type.InstanceGroupType;\n+import com.sequenceiq.common.api.type.LoadBalancerType;\n+\n+@Service\n+public class LoadBalancerConfigService {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(LoadBalancerConfigService.class);\n+\n+    private static final String ENDPOINT_SUFFIX = \"gateway\";\n+\n+    private static final String PUBLIC_SUFFIX = \"external\";\n+\n+    private static final Set<Integer> DEFAULT_KNOX_PORTS = Set.of(443);\n+\n+    public Set<String> getKnoxGatewayGroups(Stack stack) {\n+        LOGGER.info(\"Fetching list of instance groups with Knox gateway installed\");\n+        Set<String> groupNames = new HashSet<>();\n+        Cluster cluster = stack.getCluster();\n+        if (cluster != null) {\n+            CmTemplateProcessor cmTemplateProcessor = new CmTemplateProcessor(cluster.getBlueprint().getBlueprintText());\n+            Map<String, Set<ServiceComponent>> components = cmTemplateProcessor.getServiceComponentsByHostGroup();\n+            LOGGER.info(\"Checking if Knox gateway is explicitly defined\");\n+            groupNames = components.entrySet().stream()\n+                .filter(e -> e.getValue().stream().anyMatch(c -> KnoxRoles.KNOX_GATEWAY.equals(c.getComponent())))", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f2bf0c1f201d9b486f2da3f6f2f3cef16ad9c26d"}, "originalPosition": 45}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODAyNzQwMA==", "bodyText": "I can do a separate function to make it more readable.", "url": "https://github.com/hortonworks/cloudbreak/pull/9475#discussion_r528027400", "createdAt": "2020-11-20T23:44:21Z", "author": {"login": "hreeve-cloudera"}, "path": "core/src/main/java/com/sequenceiq/cloudbreak/service/LoadBalancerConfigService.java", "diffHunk": "@@ -0,0 +1,80 @@\n+package com.sequenceiq.cloudbreak.service;\n+\n+import com.sequenceiq.cloudbreak.domain.stack.loadbalancer.TargetGroup;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.stereotype.Service;\n+\n+import com.sequenceiq.cloudbreak.cmtemplate.CmTemplateProcessor;\n+import com.sequenceiq.cloudbreak.cmtemplate.configproviders.knox.KnoxRoles;\n+import com.sequenceiq.cloudbreak.domain.stack.Stack;\n+import com.sequenceiq.cloudbreak.domain.stack.cluster.Cluster;\n+import com.sequenceiq.cloudbreak.domain.stack.instance.InstanceGroup;\n+import com.sequenceiq.cloudbreak.template.model.ServiceComponent;\n+import com.sequenceiq.common.api.type.InstanceGroupType;\n+import com.sequenceiq.common.api.type.LoadBalancerType;\n+\n+@Service\n+public class LoadBalancerConfigService {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(LoadBalancerConfigService.class);\n+\n+    private static final String ENDPOINT_SUFFIX = \"gateway\";\n+\n+    private static final String PUBLIC_SUFFIX = \"external\";\n+\n+    private static final Set<Integer> DEFAULT_KNOX_PORTS = Set.of(443);\n+\n+    public Set<String> getKnoxGatewayGroups(Stack stack) {\n+        LOGGER.info(\"Fetching list of instance groups with Knox gateway installed\");\n+        Set<String> groupNames = new HashSet<>();\n+        Cluster cluster = stack.getCluster();\n+        if (cluster != null) {\n+            CmTemplateProcessor cmTemplateProcessor = new CmTemplateProcessor(cluster.getBlueprint().getBlueprintText());\n+            Map<String, Set<ServiceComponent>> components = cmTemplateProcessor.getServiceComponentsByHostGroup();\n+            LOGGER.info(\"Checking if Knox gateway is explicitly defined\");\n+            groupNames = components.entrySet().stream()\n+                .filter(e -> e.getValue().stream().anyMatch(c -> KnoxRoles.KNOX_GATEWAY.equals(c.getComponent())))", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODAxNDYwNg=="}, "originalCommit": {"oid": "f2bf0c1f201d9b486f2da3f6f2f3cef16ad9c26d"}, "originalPosition": 45}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMxODk0NzE2OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/com/sequenceiq/cloudbreak/service/stack/flow/MetadataSetupService.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNFQwNDo1OTo1MVrOH4sCHw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNFQwNDo1OTo1MVrOH4sCHw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTIwMzc0Mw==", "bodyText": "do you want to also rename the variable name to match the remaining refactoring.", "url": "https://github.com/hortonworks/cloudbreak/pull/9475#discussion_r529203743", "createdAt": "2020-11-24T04:59:51Z", "author": {"login": "enis"}, "path": "core/src/main/java/com/sequenceiq/cloudbreak/service/stack/flow/MetadataSetupService.java", "diffHunk": "@@ -54,7 +54,7 @@\n     private InstanceMetaDataService instanceMetaDataService;\n \n     @Inject\n-    private LoadBalancerService loadBalancerMetadataService;\n+    private LoadBalancerPersistenceService loadBalancerMetadataService;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e19d80b459db1f5f36788bd56bc824be5253f860"}, "originalPosition": 14}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMyMzk0NDA1OnYy", "diffSide": "RIGHT", "path": "auth-connector/src/main/java/com/sequenceiq/cloudbreak/auth/altus/model/Entitlement.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNFQyMzoyOToyM1rOH5c25g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNFQyMzoyOToyM1rOH5c25g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDAwMzY4Ng==", "bodyText": "Just linking https://github.infra.cloudera.com/thunderhead/thunderhead/pull/2780 for other reviewers.", "url": "https://github.com/hortonworks/cloudbreak/pull/9475#discussion_r530003686", "createdAt": "2020-11-24T23:29:23Z", "author": {"login": "enis"}, "path": "auth-connector/src/main/java/com/sequenceiq/cloudbreak/auth/altus/model/Entitlement.java", "diffHunk": "@@ -33,5 +33,6 @@\n     DATAHUB_AZURE_AUTOSCALING,\n     CDP_CB_DATABASE_WIRE_ENCRYPTION,\n     CDP_ENABLE_DISTROX_INSTANCE_TYPES,\n-    CDP_SHOW_CLI;\n+    CDP_SHOW_CLI,\n+    CDP_DL_LOAD_BALANCER;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e19d80b459db1f5f36788bd56bc824be5253f860"}, "originalPosition": 6}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMyMzk3MTQ3OnYy", "diffSide": "RIGHT", "path": "cloud-api/src/main/java/com/sequenceiq/cloudbreak/cloud/model/CloudLoadBalancerMetadata.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNFQyMzozNDoxNVrOH5dI3g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0zMFQxNToyNDo0NVrOH8AIkQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDAwODI4Ng==", "bodyText": "AWS load balancers bind to 1 ip per subnet for better cross-AZ availability. I think you should make this a List instead.", "url": "https://github.com/hortonworks/cloudbreak/pull/9475#discussion_r530008286", "createdAt": "2020-11-24T23:34:15Z", "author": {"login": "enis"}, "path": "cloud-api/src/main/java/com/sequenceiq/cloudbreak/cloud/model/CloudLoadBalancerMetadata.java", "diffHunk": "@@ -0,0 +1,37 @@\n+package com.sequenceiq.cloudbreak.cloud.model;\n+\n+import com.sequenceiq.common.api.type.LoadBalancerType;\n+\n+public class CloudLoadBalancerMetadata {\n+\n+    private final LoadBalancerType type;\n+\n+    private final String cloudDns;\n+\n+    private final String hostedZoneId;\n+\n+    private final String ip;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e19d80b459db1f5f36788bd56bc824be5253f860"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjY3ODgwMQ==", "bodyText": "The ip field isn't used for AWS load balancers at all. We instead use the dns and hostedZoneId. I put this here because my understanding is that Azure LBs use IPs, so we'll need an ip field eventually. But if it needs to be a list we'll update it when the Azure work is being done.", "url": "https://github.com/hortonworks/cloudbreak/pull/9475#discussion_r532678801", "createdAt": "2020-11-30T15:24:45Z", "author": {"login": "hreeve-cloudera"}, "path": "cloud-api/src/main/java/com/sequenceiq/cloudbreak/cloud/model/CloudLoadBalancerMetadata.java", "diffHunk": "@@ -0,0 +1,37 @@\n+package com.sequenceiq.cloudbreak.cloud.model;\n+\n+import com.sequenceiq.common.api.type.LoadBalancerType;\n+\n+public class CloudLoadBalancerMetadata {\n+\n+    private final LoadBalancerType type;\n+\n+    private final String cloudDns;\n+\n+    private final String hostedZoneId;\n+\n+    private final String ip;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDAwODI4Ng=="}, "originalCommit": {"oid": "e19d80b459db1f5f36788bd56bc824be5253f860"}, "originalPosition": 13}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMyMzk5Mzg0OnYy", "diffSide": "RIGHT", "path": "cloud-aws/src/main/java/com/sequenceiq/cloudbreak/cloud/aws/AwsClient.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNFQyMzozODowN1rOH5dXVA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNFQyMzozODowN1rOH5dXVA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDAxMTk4OA==", "bodyText": "I do not see these two methods being used.", "url": "https://github.com/hortonworks/cloudbreak/pull/9475#discussion_r530011988", "createdAt": "2020-11-24T23:38:07Z", "author": {"login": "enis"}, "path": "cloud-aws/src/main/java/com/sequenceiq/cloudbreak/cloud/aws/AwsClient.java", "diffHunk": "@@ -170,6 +172,23 @@ public AmazonCloudFormationRetryClient createCloudFormationRetryClient(AmazonClo\n         return new AmazonCloudFormationRetryClient(amazonCloudFormationClient, retry);\n     }\n \n+    public AmazonElasticLoadBalancingClient createElasticLoadBalancingClient(AwsCredentialView awsCredential, String regionName) {\n+        AmazonElasticLoadBalancingClient client = isRoleAssumeRequired(awsCredential) ?\n+            new AmazonElasticLoadBalancingClient(createAwsSessionCredentialProvider(awsCredential), getDefaultClientConfiguration()) :\n+            new AmazonElasticLoadBalancingClient(createAwsCredentials(awsCredential), getDefaultClientConfiguration());\n+        client.setRegion(RegionUtils.getRegion(regionName));\n+        client.addRequestHandler(new AwsTracingRequestHandler(tracer));\n+        return client;\n+    }\n+\n+    public AmazonElbV2RetryClient createElbV2RetryClient(AwsCredentialView awsCredential, String regionName) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e19d80b459db1f5f36788bd56bc824be5253f860"}, "originalPosition": 29}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMyMzk5NDQ1OnYy", "diffSide": "RIGHT", "path": "cloud-aws/src/main/java/com/sequenceiq/cloudbreak/cloud/aws/AwsClient.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNFQyMzozODoxM1rOH5dXrA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNFQyMzozODoxM1rOH5dXrA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDAxMjA3Ng==", "bodyText": "same here.", "url": "https://github.com/hortonworks/cloudbreak/pull/9475#discussion_r530012076", "createdAt": "2020-11-24T23:38:13Z", "author": {"login": "enis"}, "path": "cloud-aws/src/main/java/com/sequenceiq/cloudbreak/cloud/aws/AwsClient.java", "diffHunk": "@@ -170,6 +172,23 @@ public AmazonCloudFormationRetryClient createCloudFormationRetryClient(AmazonClo\n         return new AmazonCloudFormationRetryClient(amazonCloudFormationClient, retry);\n     }\n \n+    public AmazonElasticLoadBalancingClient createElasticLoadBalancingClient(AwsCredentialView awsCredential, String regionName) {\n+        AmazonElasticLoadBalancingClient client = isRoleAssumeRequired(awsCredential) ?\n+            new AmazonElasticLoadBalancingClient(createAwsSessionCredentialProvider(awsCredential), getDefaultClientConfiguration()) :\n+            new AmazonElasticLoadBalancingClient(createAwsCredentials(awsCredential), getDefaultClientConfiguration());\n+        client.setRegion(RegionUtils.getRegion(regionName));\n+        client.addRequestHandler(new AwsTracingRequestHandler(tracer));\n+        return client;\n+    }\n+\n+    public AmazonElbV2RetryClient createElbV2RetryClient(AwsCredentialView awsCredential, String regionName) {\n+        return new AmazonElbV2RetryClient(createElasticLoadBalancingClient(awsCredential, regionName), retry);\n+    }\n+\n+    public AmazonElbV2RetryClient createElbV2RetryClient(AmazonElasticLoadBalancingClient amazonElasticLoadBalancingClient) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e19d80b459db1f5f36788bd56bc824be5253f860"}, "originalPosition": 33}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMyNDAxOTEwOnYy", "diffSide": "RIGHT", "path": "common-model/src/main/java/com/sequenceiq/common/api/type/LoadBalancerType.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNFQyMzo0NDoxN1rOH5dnRg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0zMFQxNToyODozMlrOH8AUlg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDAxNjA3MA==", "bodyText": "AWS and Azure calls these \"Internal\" load balancers rather than public / private. In AWS, they are called \"internet-facing\".\nLoadBalancerType in AWS is a selection between \"ELB\", \"NLB\", or \"ALB\" versus the internal vs internet-facing is called \"load balancer scheme\". See https://docs.aws.amazon.com/elasticloadbalancing/latest/userguide/how-elastic-load-balancing-works.html.\nWe do not necessarily need to follow the same naming, but just a sugestion if we want to be consistent with the cloud providers.", "url": "https://github.com/hortonworks/cloudbreak/pull/9475#discussion_r530016070", "createdAt": "2020-11-24T23:44:17Z", "author": {"login": "enis"}, "path": "common-model/src/main/java/com/sequenceiq/common/api/type/LoadBalancerType.java", "diffHunk": "@@ -0,0 +1,6 @@\n+package com.sequenceiq.common.api.type;\n+\n+public enum LoadBalancerType {\n+    PUBLIC,\n+    PRIVATE", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e19d80b459db1f5f36788bd56bc824be5253f860"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjY4MTg3OA==", "bodyText": "The purpose of this module is to provide a cloud provider agnostic modeling of the cloud resources. So I don't feel any particular need to follow the cloud provide convention super closely. Especially since I only know the AWS convention, so following that might just mean we're contradicting the Azure convention.\nI am considering changing these to INTERNAL and EXTERNAL, but I'm going to think about that and make the change later if necessary.", "url": "https://github.com/hortonworks/cloudbreak/pull/9475#discussion_r532681878", "createdAt": "2020-11-30T15:28:32Z", "author": {"login": "hreeve-cloudera"}, "path": "common-model/src/main/java/com/sequenceiq/common/api/type/LoadBalancerType.java", "diffHunk": "@@ -0,0 +1,6 @@\n+package com.sequenceiq.common.api.type;\n+\n+public enum LoadBalancerType {\n+    PUBLIC,\n+    PRIVATE", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDAxNjA3MA=="}, "originalCommit": {"oid": "e19d80b459db1f5f36788bd56bc824be5253f860"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMyNDAyMzE1OnYy", "diffSide": "RIGHT", "path": "cloud-aws/src/main/java/com/sequenceiq/cloudbreak/cloud/aws/AwsMetadataCollector.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNFQyMzo0NTo0NVrOH5dpeg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNFQyMzo0NTo0NVrOH5dpeg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDAxNjYzNA==", "bodyText": "nit: typo in balanacer", "url": "https://github.com/hortonworks/cloudbreak/pull/9475#discussion_r530016634", "createdAt": "2020-11-24T23:45:45Z", "author": {"login": "enis"}, "path": "cloud-aws/src/main/java/com/sequenceiq/cloudbreak/cloud/aws/AwsMetadataCollector.java", "diffHunk": "@@ -171,4 +176,28 @@ private void addKnownInstance(CloudInstance cloudInstance, Multimap<String, Inst\n                 .flatMap(reservation -> reservation.getInstances().stream())\n                 .collect(Collectors.toList());\n     }\n+\n+    @Override\n+    public List<CloudLoadBalancerMetadata> collectLoadBalancer(AuthenticatedContext ac, List<String> loadBalancerTypes) {\n+        LOGGER.debug(\"Collect AWS load balanacer metadata, for cluster {}\", ac.getCloudContext().getName());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e19d80b459db1f5f36788bd56bc824be5253f860"}, "originalPosition": 35}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMyNDAyODI4OnYy", "diffSide": "RIGHT", "path": "cloud-aws/src/main/java/com/sequenceiq/cloudbreak/cloud/aws/AwsMetadataCollector.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNFQyMzo0ODowNlrOH5dsbw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0zMFQxNTozMDowNFrOH8AZUw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDAxNzM5MQ==", "bodyText": "we do not have access to the ip at this point?", "url": "https://github.com/hortonworks/cloudbreak/pull/9475#discussion_r530017391", "createdAt": "2020-11-24T23:48:06Z", "author": {"login": "enis"}, "path": "cloud-aws/src/main/java/com/sequenceiq/cloudbreak/cloud/aws/AwsMetadataCollector.java", "diffHunk": "@@ -171,4 +176,28 @@ private void addKnownInstance(CloudInstance cloudInstance, Multimap<String, Inst\n                 .flatMap(reservation -> reservation.getInstances().stream())\n                 .collect(Collectors.toList());\n     }\n+\n+    @Override\n+    public List<CloudLoadBalancerMetadata> collectLoadBalancer(AuthenticatedContext ac, List<String> loadBalancerTypes) {\n+        LOGGER.debug(\"Collect AWS load balanacer metadata, for cluster {}\", ac.getCloudContext().getName());\n+\n+        String region = ac.getCloudContext().getLocation().getRegion().value();\n+\n+        List<CloudLoadBalancerMetadata> cloudLoadBalancerMetadata = new ArrayList<>();\n+        try {\n+            for (String type : loadBalancerTypes) {\n+                String loadBalancerName = AwsLoadBalancer.getLoadBalancerName(AwsLoadBalancerScheme.valueOf(type));\n+                LoadBalancer loadBalancer = cloudFormationStackUtil.getLoadBalancerByLogicalId(ac, loadBalancerName, region);\n+                cloudLoadBalancerMetadata.add(new CloudLoadBalancerMetadata(\n+                    LoadBalancerType.valueOf(type),\n+                    loadBalancer.getDNSName(),\n+                    loadBalancer.getCanonicalHostedZoneId(),\n+                    null", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e19d80b459db1f5f36788bd56bc824be5253f860"}, "originalPosition": 48}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjY4MzA5MQ==", "bodyText": "No. For AWS load balancers we use the cloud DNS name and hostedZoneId, not the IP address.", "url": "https://github.com/hortonworks/cloudbreak/pull/9475#discussion_r532683091", "createdAt": "2020-11-30T15:30:04Z", "author": {"login": "hreeve-cloudera"}, "path": "cloud-aws/src/main/java/com/sequenceiq/cloudbreak/cloud/aws/AwsMetadataCollector.java", "diffHunk": "@@ -171,4 +176,28 @@ private void addKnownInstance(CloudInstance cloudInstance, Multimap<String, Inst\n                 .flatMap(reservation -> reservation.getInstances().stream())\n                 .collect(Collectors.toList());\n     }\n+\n+    @Override\n+    public List<CloudLoadBalancerMetadata> collectLoadBalancer(AuthenticatedContext ac, List<String> loadBalancerTypes) {\n+        LOGGER.debug(\"Collect AWS load balanacer metadata, for cluster {}\", ac.getCloudContext().getName());\n+\n+        String region = ac.getCloudContext().getLocation().getRegion().value();\n+\n+        List<CloudLoadBalancerMetadata> cloudLoadBalancerMetadata = new ArrayList<>();\n+        try {\n+            for (String type : loadBalancerTypes) {\n+                String loadBalancerName = AwsLoadBalancer.getLoadBalancerName(AwsLoadBalancerScheme.valueOf(type));\n+                LoadBalancer loadBalancer = cloudFormationStackUtil.getLoadBalancerByLogicalId(ac, loadBalancerName, region);\n+                cloudLoadBalancerMetadata.add(new CloudLoadBalancerMetadata(\n+                    LoadBalancerType.valueOf(type),\n+                    loadBalancer.getDNSName(),\n+                    loadBalancer.getCanonicalHostedZoneId(),\n+                    null", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDAxNzM5MQ=="}, "originalCommit": {"oid": "e19d80b459db1f5f36788bd56bc824be5253f860"}, "originalPosition": 48}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMyNDA0NTczOnYy", "diffSide": "RIGHT", "path": "cloud-aws/src/main/java/com/sequenceiq/cloudbreak/cloud/aws/AwsStackRequestHelper.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNFQyMzo1NTo1NlrOH5d2gA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNFQyMzo1NTo1NlrOH5d2gA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDAxOTk2OA==", "bodyText": "Do you want to rename subnet to newSubnetCidr to match the one in getStackParameters. I am assuming that this is the CIDR for the subnet.", "url": "https://github.com/hortonworks/cloudbreak/pull/9475#discussion_r530019968", "createdAt": "2020-11-24T23:55:56Z", "author": {"login": "enis"}, "path": "cloud-aws/src/main/java/com/sequenceiq/cloudbreak/cloud/aws/AwsStackRequestHelper.java", "diffHunk": "@@ -86,6 +87,20 @@ public DeleteStackRequest createDeleteStackRequest(String cFStackName) {\n                 .withStackName(cFStackName);\n     }\n \n+    public UpdateStackRequest createUpdateStackRequest(AuthenticatedContext ac, CloudStack stack, String cFStackName, String subnet, String cfTemplate) {\n+        return new UpdateStackRequest()\n+            .withStackName(cFStackName)\n+            .withTemplateBody(cfTemplate)\n+            .withTags(awsTaggingService.prepareCloudformationTags(ac, stack.getTags()))\n+            .withCapabilities(CAPABILITY_IAM)\n+            .withParameters(getStackParameters(ac, stack, cFStackName, subnet));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e19d80b459db1f5f36788bd56bc824be5253f860"}, "originalPosition": 18}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMyNDA0NzMwOnYy", "diffSide": "RIGHT", "path": "cloud-aws/src/main/java/com/sequenceiq/cloudbreak/cloud/aws/AwsStackRequestHelper.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNFQyMzo1Njo0OFrOH5d3dg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0zMFQxOTowOToxMVrOH8JktQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDAyMDIxNA==", "bodyText": "This overloads the function defined above. I suggest moving it to be just below that, and changing that function definition to call this with subnet = null", "url": "https://github.com/hortonworks/cloudbreak/pull/9475#discussion_r530020214", "createdAt": "2020-11-24T23:56:48Z", "author": {"login": "enis"}, "path": "cloud-aws/src/main/java/com/sequenceiq/cloudbreak/cloud/aws/AwsStackRequestHelper.java", "diffHunk": "@@ -86,6 +87,20 @@ public DeleteStackRequest createDeleteStackRequest(String cFStackName) {\n                 .withStackName(cFStackName);\n     }\n \n+    public UpdateStackRequest createUpdateStackRequest(AuthenticatedContext ac, CloudStack stack, String cFStackName, String subnet, String cfTemplate) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e19d80b459db1f5f36788bd56bc824be5253f860"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjgzMzQ2MQ==", "bodyText": "I took a closer look and realized we didn't need two different methods, so I've removed this one and am using the other createUpdateStackRequest method.", "url": "https://github.com/hortonworks/cloudbreak/pull/9475#discussion_r532833461", "createdAt": "2020-11-30T19:09:11Z", "author": {"login": "hreeve-cloudera"}, "path": "cloud-aws/src/main/java/com/sequenceiq/cloudbreak/cloud/aws/AwsStackRequestHelper.java", "diffHunk": "@@ -86,6 +87,20 @@ public DeleteStackRequest createDeleteStackRequest(String cFStackName) {\n                 .withStackName(cFStackName);\n     }\n \n+    public UpdateStackRequest createUpdateStackRequest(AuthenticatedContext ac, CloudStack stack, String cFStackName, String subnet, String cfTemplate) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDAyMDIxNA=="}, "originalCommit": {"oid": "e19d80b459db1f5f36788bd56bc824be5253f860"}, "originalPosition": 12}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMyNDA1NTQ4OnYy", "diffSide": "RIGHT", "path": "cloud-aws/src/main/java/com/sequenceiq/cloudbreak/cloud/aws/client/AmazonElbV2RetryClient.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNVQwMDowMDozN1rOH5d8Vg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0zMFQxNTozNToxOVrOH8ApJw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDAyMTQ2Mg==", "bodyText": "should be named describeLoadBalancers()", "url": "https://github.com/hortonworks/cloudbreak/pull/9475#discussion_r530021462", "createdAt": "2020-11-25T00:00:37Z", "author": {"login": "enis"}, "path": "cloud-aws/src/main/java/com/sequenceiq/cloudbreak/cloud/aws/client/AmazonElbV2RetryClient.java", "diffHunk": "@@ -0,0 +1,28 @@\n+package com.sequenceiq.cloudbreak.cloud.aws.client;\n+\n+import com.amazonaws.services.elasticloadbalancingv2.AmazonElasticLoadBalancingClient;\n+import com.amazonaws.services.elasticloadbalancingv2.model.DescribeLoadBalancersRequest;\n+import com.amazonaws.services.elasticloadbalancingv2.model.DescribeLoadBalancersResult;\n+import com.amazonaws.services.elasticloadbalancingv2.model.DescribeTargetGroupsRequest;\n+import com.amazonaws.services.elasticloadbalancingv2.model.DescribeTargetGroupsResult;\n+import com.sequenceiq.cloudbreak.service.Retry;\n+\n+public class AmazonElbV2RetryClient extends AmazonRetryClient {\n+\n+    private final AmazonElasticLoadBalancingClient client;\n+\n+    private final Retry retry;\n+\n+    public AmazonElbV2RetryClient(AmazonElasticLoadBalancingClient client, Retry retry) {\n+        this.client = client;\n+        this.retry = retry;\n+    }\n+\n+    public DescribeLoadBalancersResult describeLoadBalancer(DescribeLoadBalancersRequest request) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e19d80b459db1f5f36788bd56bc824be5253f860"}, "originalPosition": 21}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjY4NzE0Mw==", "bodyText": "Looking at this class made me realize I'm not actually using it anymore, so I'm deleting it.", "url": "https://github.com/hortonworks/cloudbreak/pull/9475#discussion_r532687143", "createdAt": "2020-11-30T15:35:19Z", "author": {"login": "hreeve-cloudera"}, "path": "cloud-aws/src/main/java/com/sequenceiq/cloudbreak/cloud/aws/client/AmazonElbV2RetryClient.java", "diffHunk": "@@ -0,0 +1,28 @@\n+package com.sequenceiq.cloudbreak.cloud.aws.client;\n+\n+import com.amazonaws.services.elasticloadbalancingv2.AmazonElasticLoadBalancingClient;\n+import com.amazonaws.services.elasticloadbalancingv2.model.DescribeLoadBalancersRequest;\n+import com.amazonaws.services.elasticloadbalancingv2.model.DescribeLoadBalancersResult;\n+import com.amazonaws.services.elasticloadbalancingv2.model.DescribeTargetGroupsRequest;\n+import com.amazonaws.services.elasticloadbalancingv2.model.DescribeTargetGroupsResult;\n+import com.sequenceiq.cloudbreak.service.Retry;\n+\n+public class AmazonElbV2RetryClient extends AmazonRetryClient {\n+\n+    private final AmazonElasticLoadBalancingClient client;\n+\n+    private final Retry retry;\n+\n+    public AmazonElbV2RetryClient(AmazonElasticLoadBalancingClient client, Retry retry) {\n+        this.client = client;\n+        this.retry = retry;\n+    }\n+\n+    public DescribeLoadBalancersResult describeLoadBalancer(DescribeLoadBalancersRequest request) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDAyMTQ2Mg=="}, "originalCommit": {"oid": "e19d80b459db1f5f36788bd56bc824be5253f860"}, "originalPosition": 21}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMyNDA1NjA4OnYy", "diffSide": "RIGHT", "path": "cloud-aws/src/main/java/com/sequenceiq/cloudbreak/cloud/aws/client/AmazonElbV2RetryClient.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNVQwMDowMDo1OVrOH5d8sg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNVQwMDowMDo1OVrOH5d8sg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDAyMTU1NA==", "bodyText": "Should be named describeTargetGroups()", "url": "https://github.com/hortonworks/cloudbreak/pull/9475#discussion_r530021554", "createdAt": "2020-11-25T00:00:59Z", "author": {"login": "enis"}, "path": "cloud-aws/src/main/java/com/sequenceiq/cloudbreak/cloud/aws/client/AmazonElbV2RetryClient.java", "diffHunk": "@@ -0,0 +1,28 @@\n+package com.sequenceiq.cloudbreak.cloud.aws.client;\n+\n+import com.amazonaws.services.elasticloadbalancingv2.AmazonElasticLoadBalancingClient;\n+import com.amazonaws.services.elasticloadbalancingv2.model.DescribeLoadBalancersRequest;\n+import com.amazonaws.services.elasticloadbalancingv2.model.DescribeLoadBalancersResult;\n+import com.amazonaws.services.elasticloadbalancingv2.model.DescribeTargetGroupsRequest;\n+import com.amazonaws.services.elasticloadbalancingv2.model.DescribeTargetGroupsResult;\n+import com.sequenceiq.cloudbreak.service.Retry;\n+\n+public class AmazonElbV2RetryClient extends AmazonRetryClient {\n+\n+    private final AmazonElasticLoadBalancingClient client;\n+\n+    private final Retry retry;\n+\n+    public AmazonElbV2RetryClient(AmazonElasticLoadBalancingClient client, Retry retry) {\n+        this.client = client;\n+        this.retry = retry;\n+    }\n+\n+    public DescribeLoadBalancersResult describeLoadBalancer(DescribeLoadBalancersRequest request) {\n+        return retry.testWith2SecDelayMax15Times(() -> mapThrottlingError(() -> client.describeLoadBalancers(request)));\n+    }\n+\n+    public DescribeTargetGroupsResult describeLoadBalancer(DescribeTargetGroupsRequest request) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e19d80b459db1f5f36788bd56bc824be5253f860"}, "originalPosition": 25}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMyNDA5MjAyOnYy", "diffSide": "RIGHT", "path": "cloud-aws/src/main/java/com/sequenceiq/cloudbreak/cloud/aws/connector/resource/AwsLaunchService.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNVQwMDoxNzoxMVrOH5eRcw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNVQwMDoxNzoxMVrOH5eRcw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDAyNjg2Nw==", "bodyText": "some of these exist already in the scope  in the above call to this function. Maybe you can look at sending these to the function rather than recreating.", "url": "https://github.com/hortonworks/cloudbreak/pull/9475#discussion_r530026867", "createdAt": "2020-11-25T00:17:11Z", "author": {"login": "enis"}, "path": "cloud-aws/src/main/java/com/sequenceiq/cloudbreak/cloud/aws/connector/resource/AwsLaunchService.java", "diffHunk": "@@ -171,9 +165,132 @@\n \n         awsCloudWatchService.addCloudWatchAlarmsForSystemFailures(instances, stack, regionName, credentialView);\n \n+        updateCloudformationWithLoadBalancer(ac, stack, resourceNotifier, modelContext, instances);\n+\n         return awsResourceConnector.check(ac, instances);\n     }\n \n+    private ModelContext buildDefaultModelContext(AuthenticatedContext ac, CloudStack stack, PersistenceNotifier resourceNotifier) {\n+        AwsCredentialView credentialView = new AwsCredentialView(ac.getCloudCredential());\n+        String regionName = ac.getCloudContext().getLocation().getRegion().value();\n+        AmazonEC2Client amazonEC2Client = awsClient.createAccess(credentialView, regionName);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e19d80b459db1f5f36788bd56bc824be5253f860"}, "originalPosition": 87}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMyNDA5MzYzOnYy", "diffSide": "RIGHT", "path": "cloud-aws/src/main/java/com/sequenceiq/cloudbreak/cloud/aws/connector/resource/AwsLaunchService.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNVQwMDoxNzo1NlrOH5eSag==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNVQwMDoxNzo1NlrOH5eSag==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDAyNzExNA==", "bodyText": "nit: rename to updateCloudformationWithLoadBalancers()?", "url": "https://github.com/hortonworks/cloudbreak/pull/9475#discussion_r530027114", "createdAt": "2020-11-25T00:17:56Z", "author": {"login": "enis"}, "path": "cloud-aws/src/main/java/com/sequenceiq/cloudbreak/cloud/aws/connector/resource/AwsLaunchService.java", "diffHunk": "@@ -171,9 +165,132 @@\n \n         awsCloudWatchService.addCloudWatchAlarmsForSystemFailures(instances, stack, regionName, credentialView);\n \n+        updateCloudformationWithLoadBalancer(ac, stack, resourceNotifier, modelContext, instances);\n+\n         return awsResourceConnector.check(ac, instances);\n     }\n \n+    private ModelContext buildDefaultModelContext(AuthenticatedContext ac, CloudStack stack, PersistenceNotifier resourceNotifier) {\n+        AwsCredentialView credentialView = new AwsCredentialView(ac.getCloudCredential());\n+        String regionName = ac.getCloudContext().getLocation().getRegion().value();\n+        AmazonEC2Client amazonEC2Client = awsClient.createAccess(credentialView, regionName);\n+        Network network = stack.getNetwork();\n+        AwsNetworkView awsNetworkView = new AwsNetworkView(network);\n+        boolean mapPublicIpOnLaunch = awsNetworkService.isMapPublicOnLaunch(awsNetworkView, amazonEC2Client);\n+\n+        boolean existingVPC = awsNetworkView.isExistingVPC();\n+        boolean existingSubnet = awsNetworkView.isExistingSubnet();\n+\n+        String cidr = network.getSubnet().getCidr();\n+        String subnet = isNoCIDRProvided(existingVPC, existingSubnet, cidr) ? awsNetworkService.findNonOverLappingCIDR(ac, stack) : cidr;\n+        AwsInstanceProfileView awsInstanceProfileView = new AwsInstanceProfileView(stack);\n+        ModelContext modelContext = new ModelContext()\n+            .withAuthenticatedContext(ac)\n+            .withStack(stack)\n+            .withExistingVpc(existingVPC)\n+            .withExistingIGW(awsNetworkView.isExistingIGW())\n+            .withExistingSubnetCidr(existingSubnet ? awsNetworkService.getExistingSubnetCidr(ac, stack) : null)\n+            .withExistinVpcCidr(awsNetworkService.getVpcCidrs(ac, stack))\n+            .withExistingSubnetIds(existingSubnet ? awsNetworkView.getSubnetList() : null)\n+            .mapPublicIpOnLaunch(mapPublicIpOnLaunch)\n+            .withEnableInstanceProfile(awsInstanceProfileView.isInstanceProfileAvailable())\n+            .withInstanceProfileAvailable(awsInstanceProfileView.isInstanceProfileAvailable())\n+            .withTemplate(stack.getTemplate())\n+            .withDefaultSubnet(subnet)\n+            .withOutboundInternetTraffic(network.getOutboundInternetTraffic())\n+            .withVpcCidrs(network.getNetworkCidrs())\n+            .withPrefixListIds(getPrefixListIds(amazonEC2Client, regionName, network.getOutboundInternetTraffic()))\n+            .withEncryptedAMIByGroupName(encryptedImageCopyService.createEncryptedImages(ac, stack, resourceNotifier));\n+\n+        return modelContext;\n+    }\n+\n+    private void updateCloudformationWithLoadBalancer(AuthenticatedContext ac, CloudStack stack, PersistenceNotifier resourceNotifier,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e19d80b459db1f5f36788bd56bc824be5253f860"}, "originalPosition": 119}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMyNDExMDk4OnYy", "diffSide": "RIGHT", "path": "cloud-aws/src/main/java/com/sequenceiq/cloudbreak/cloud/aws/connector/resource/AwsLaunchService.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNVQwMDoyNToyMFrOH5eb4g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0zMFQxNTo0MzoxN1rOH8BA1A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDAyOTUzOA==", "bodyText": "Is this logic mimicing an existing behaviour? maybe you can make a comment here about what CIDR we chose and how.", "url": "https://github.com/hortonworks/cloudbreak/pull/9475#discussion_r530029538", "createdAt": "2020-11-25T00:25:20Z", "author": {"login": "enis"}, "path": "cloud-aws/src/main/java/com/sequenceiq/cloudbreak/cloud/aws/connector/resource/AwsLaunchService.java", "diffHunk": "@@ -171,9 +165,132 @@\n \n         awsCloudWatchService.addCloudWatchAlarmsForSystemFailures(instances, stack, regionName, credentialView);\n \n+        updateCloudformationWithLoadBalancer(ac, stack, resourceNotifier, modelContext, instances);\n+\n         return awsResourceConnector.check(ac, instances);\n     }\n \n+    private ModelContext buildDefaultModelContext(AuthenticatedContext ac, CloudStack stack, PersistenceNotifier resourceNotifier) {\n+        AwsCredentialView credentialView = new AwsCredentialView(ac.getCloudCredential());\n+        String regionName = ac.getCloudContext().getLocation().getRegion().value();\n+        AmazonEC2Client amazonEC2Client = awsClient.createAccess(credentialView, regionName);\n+        Network network = stack.getNetwork();\n+        AwsNetworkView awsNetworkView = new AwsNetworkView(network);\n+        boolean mapPublicIpOnLaunch = awsNetworkService.isMapPublicOnLaunch(awsNetworkView, amazonEC2Client);\n+\n+        boolean existingVPC = awsNetworkView.isExistingVPC();\n+        boolean existingSubnet = awsNetworkView.isExistingSubnet();\n+\n+        String cidr = network.getSubnet().getCidr();\n+        String subnet = isNoCIDRProvided(existingVPC, existingSubnet, cidr) ? awsNetworkService.findNonOverLappingCIDR(ac, stack) : cidr;\n+        AwsInstanceProfileView awsInstanceProfileView = new AwsInstanceProfileView(stack);\n+        ModelContext modelContext = new ModelContext()\n+            .withAuthenticatedContext(ac)\n+            .withStack(stack)\n+            .withExistingVpc(existingVPC)\n+            .withExistingIGW(awsNetworkView.isExistingIGW())\n+            .withExistingSubnetCidr(existingSubnet ? awsNetworkService.getExistingSubnetCidr(ac, stack) : null)\n+            .withExistinVpcCidr(awsNetworkService.getVpcCidrs(ac, stack))\n+            .withExistingSubnetIds(existingSubnet ? awsNetworkView.getSubnetList() : null)\n+            .mapPublicIpOnLaunch(mapPublicIpOnLaunch)\n+            .withEnableInstanceProfile(awsInstanceProfileView.isInstanceProfileAvailable())\n+            .withInstanceProfileAvailable(awsInstanceProfileView.isInstanceProfileAvailable())\n+            .withTemplate(stack.getTemplate())\n+            .withDefaultSubnet(subnet)\n+            .withOutboundInternetTraffic(network.getOutboundInternetTraffic())\n+            .withVpcCidrs(network.getNetworkCidrs())\n+            .withPrefixListIds(getPrefixListIds(amazonEC2Client, regionName, network.getOutboundInternetTraffic()))\n+            .withEncryptedAMIByGroupName(encryptedImageCopyService.createEncryptedImages(ac, stack, resourceNotifier));\n+\n+        return modelContext;\n+    }\n+\n+    private void updateCloudformationWithLoadBalancer(AuthenticatedContext ac, CloudStack stack, PersistenceNotifier resourceNotifier,\n+            ModelContext modelContext, List<CloudResource> instances) {\n+\n+        List<CloudLoadBalancer> cloudLoadBalancers = stack.getLoadBalancers();\n+        if (!cloudLoadBalancers.isEmpty()) {\n+            if (modelContext == null) {\n+                modelContext = buildDefaultModelContext(ac, stack, resourceNotifier);\n+            }\n+\n+            List<AwsLoadBalancer> awsLoadBalancers = new ArrayList<>();\n+            for (CloudLoadBalancer cloudLoadBalancer : cloudLoadBalancers) {\n+                awsLoadBalancers.add(convert(cloudLoadBalancer, stack, instances));\n+            }\n+\n+            modelContext.withLoadBalancers(awsLoadBalancers);\n+            ListStackResourcesResult result = updateCloudFormationStack(ac, stack, modelContext);\n+\n+            for (AwsLoadBalancer loadBalancer : awsLoadBalancers) {\n+                for (AwsListener listener : loadBalancer.getListeners()) {\n+                    for (AwsTargetGroup targetGroup : listener.getTargetGroups()) {\n+                        Optional<StackResourceSummary> targetGroupSummary = result.getStackResourceSummaries().stream()\n+                            .filter(stackResourceSummary -> targetGroup.getName().equals(stackResourceSummary.getLogicalResourceId()))\n+                            .findFirst();\n+                        if (targetGroupSummary.isEmpty()) {\n+                            throw new CloudConnectorException(\"Could not create load balancer listeners: target group not found.\");\n+                        }\n+                        targetGroup.setArn(targetGroupSummary.get().getPhysicalResourceId());\n+                    }\n+                }\n+                Optional<StackResourceSummary> loadBalancerSummary = result.getStackResourceSummaries().stream()\n+                    .filter(stackResourceSummary -> loadBalancer.getName().equals(stackResourceSummary.getLogicalResourceId()))\n+                    .findFirst();\n+                if (loadBalancerSummary.isEmpty()) {\n+                    throw new CloudConnectorException(\"Could not create load balancer listeners: load balancer not found.\");\n+                }\n+                loadBalancer.setArn(loadBalancerSummary.get().getPhysicalResourceId());\n+                loadBalancer.canCreateListeners();\n+            }\n+\n+            updateCloudFormationStack(ac, stack, modelContext);\n+        }\n+    }\n+\n+    private AwsLoadBalancer convert(CloudLoadBalancer cloudLoadBalancer, CloudStack stack, List<CloudResource> instances) {\n+        int order = 1;\n+        List<AwsListener> awsListeners = new ArrayList<>();\n+        AwsLoadBalancerScheme scheme = AwsLoadBalancerScheme.valueOf(cloudLoadBalancer.getType().name());\n+        for (Map.Entry<Integer, Set<Group>> entry : cloudLoadBalancer.getPortToTargetGroupMapping().entrySet()) {\n+            List<CloudResource> lbTargetInstances = instances.stream()\n+                .filter(instance -> entry.getValue().stream().anyMatch(tg -> tg.getName().equals(instance.getGroup())))\n+                .collect(Collectors.toList());\n+            List<String> instanceIds = lbTargetInstances.stream().map(CloudResource::getInstanceId).collect(Collectors.toList());\n+\n+            AwsTargetGroup targetGroup = new AwsTargetGroup(entry.getKey(), scheme, order++, instanceIds);\n+            awsListeners.add(new AwsListener(entry.getKey(), Collections.singletonList(targetGroup), scheme));\n+        }\n+        return new AwsLoadBalancer(scheme, awsListeners);\n+    }\n+\n+    private ListStackResourcesResult updateCloudFormationStack(AuthenticatedContext ac, CloudStack stack, ModelContext modelContext) {\n+        String cFStackName = cfStackUtil.getCfStackName(ac);\n+        AwsCredentialView credentialView = new AwsCredentialView(ac.getCloudCredential());\n+        String regionName = ac.getCloudContext().getLocation().getRegion().value();\n+        AmazonCloudFormationRetryClient cfRetryClient = awsClient.createCloudFormationRetryClient(credentialView, regionName);\n+        Network network = stack.getNetwork();\n+        AwsNetworkView awsNetworkView = new AwsNetworkView(network);\n+        boolean existingVPC = awsNetworkView.isExistingVPC();\n+        boolean existingSubnet = awsNetworkView.isExistingSubnet();\n+        String cidr = network.getSubnet().getCidr();\n+        String subnet = isNoCIDRProvided(existingVPC, existingSubnet, cidr) ? awsNetworkService.findNonOverLappingCIDR(ac, stack) : cidr;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e19d80b459db1f5f36788bd56bc824be5253f860"}, "originalPosition": 188}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjY5MzIwNA==", "bodyText": "This is the logic that already existed, just moved to a new method. Since I didn't wrote it myself I'm not exactly sure how the logic of it works.", "url": "https://github.com/hortonworks/cloudbreak/pull/9475#discussion_r532693204", "createdAt": "2020-11-30T15:43:17Z", "author": {"login": "hreeve-cloudera"}, "path": "cloud-aws/src/main/java/com/sequenceiq/cloudbreak/cloud/aws/connector/resource/AwsLaunchService.java", "diffHunk": "@@ -171,9 +165,132 @@\n \n         awsCloudWatchService.addCloudWatchAlarmsForSystemFailures(instances, stack, regionName, credentialView);\n \n+        updateCloudformationWithLoadBalancer(ac, stack, resourceNotifier, modelContext, instances);\n+\n         return awsResourceConnector.check(ac, instances);\n     }\n \n+    private ModelContext buildDefaultModelContext(AuthenticatedContext ac, CloudStack stack, PersistenceNotifier resourceNotifier) {\n+        AwsCredentialView credentialView = new AwsCredentialView(ac.getCloudCredential());\n+        String regionName = ac.getCloudContext().getLocation().getRegion().value();\n+        AmazonEC2Client amazonEC2Client = awsClient.createAccess(credentialView, regionName);\n+        Network network = stack.getNetwork();\n+        AwsNetworkView awsNetworkView = new AwsNetworkView(network);\n+        boolean mapPublicIpOnLaunch = awsNetworkService.isMapPublicOnLaunch(awsNetworkView, amazonEC2Client);\n+\n+        boolean existingVPC = awsNetworkView.isExistingVPC();\n+        boolean existingSubnet = awsNetworkView.isExistingSubnet();\n+\n+        String cidr = network.getSubnet().getCidr();\n+        String subnet = isNoCIDRProvided(existingVPC, existingSubnet, cidr) ? awsNetworkService.findNonOverLappingCIDR(ac, stack) : cidr;\n+        AwsInstanceProfileView awsInstanceProfileView = new AwsInstanceProfileView(stack);\n+        ModelContext modelContext = new ModelContext()\n+            .withAuthenticatedContext(ac)\n+            .withStack(stack)\n+            .withExistingVpc(existingVPC)\n+            .withExistingIGW(awsNetworkView.isExistingIGW())\n+            .withExistingSubnetCidr(existingSubnet ? awsNetworkService.getExistingSubnetCidr(ac, stack) : null)\n+            .withExistinVpcCidr(awsNetworkService.getVpcCidrs(ac, stack))\n+            .withExistingSubnetIds(existingSubnet ? awsNetworkView.getSubnetList() : null)\n+            .mapPublicIpOnLaunch(mapPublicIpOnLaunch)\n+            .withEnableInstanceProfile(awsInstanceProfileView.isInstanceProfileAvailable())\n+            .withInstanceProfileAvailable(awsInstanceProfileView.isInstanceProfileAvailable())\n+            .withTemplate(stack.getTemplate())\n+            .withDefaultSubnet(subnet)\n+            .withOutboundInternetTraffic(network.getOutboundInternetTraffic())\n+            .withVpcCidrs(network.getNetworkCidrs())\n+            .withPrefixListIds(getPrefixListIds(amazonEC2Client, regionName, network.getOutboundInternetTraffic()))\n+            .withEncryptedAMIByGroupName(encryptedImageCopyService.createEncryptedImages(ac, stack, resourceNotifier));\n+\n+        return modelContext;\n+    }\n+\n+    private void updateCloudformationWithLoadBalancer(AuthenticatedContext ac, CloudStack stack, PersistenceNotifier resourceNotifier,\n+            ModelContext modelContext, List<CloudResource> instances) {\n+\n+        List<CloudLoadBalancer> cloudLoadBalancers = stack.getLoadBalancers();\n+        if (!cloudLoadBalancers.isEmpty()) {\n+            if (modelContext == null) {\n+                modelContext = buildDefaultModelContext(ac, stack, resourceNotifier);\n+            }\n+\n+            List<AwsLoadBalancer> awsLoadBalancers = new ArrayList<>();\n+            for (CloudLoadBalancer cloudLoadBalancer : cloudLoadBalancers) {\n+                awsLoadBalancers.add(convert(cloudLoadBalancer, stack, instances));\n+            }\n+\n+            modelContext.withLoadBalancers(awsLoadBalancers);\n+            ListStackResourcesResult result = updateCloudFormationStack(ac, stack, modelContext);\n+\n+            for (AwsLoadBalancer loadBalancer : awsLoadBalancers) {\n+                for (AwsListener listener : loadBalancer.getListeners()) {\n+                    for (AwsTargetGroup targetGroup : listener.getTargetGroups()) {\n+                        Optional<StackResourceSummary> targetGroupSummary = result.getStackResourceSummaries().stream()\n+                            .filter(stackResourceSummary -> targetGroup.getName().equals(stackResourceSummary.getLogicalResourceId()))\n+                            .findFirst();\n+                        if (targetGroupSummary.isEmpty()) {\n+                            throw new CloudConnectorException(\"Could not create load balancer listeners: target group not found.\");\n+                        }\n+                        targetGroup.setArn(targetGroupSummary.get().getPhysicalResourceId());\n+                    }\n+                }\n+                Optional<StackResourceSummary> loadBalancerSummary = result.getStackResourceSummaries().stream()\n+                    .filter(stackResourceSummary -> loadBalancer.getName().equals(stackResourceSummary.getLogicalResourceId()))\n+                    .findFirst();\n+                if (loadBalancerSummary.isEmpty()) {\n+                    throw new CloudConnectorException(\"Could not create load balancer listeners: load balancer not found.\");\n+                }\n+                loadBalancer.setArn(loadBalancerSummary.get().getPhysicalResourceId());\n+                loadBalancer.canCreateListeners();\n+            }\n+\n+            updateCloudFormationStack(ac, stack, modelContext);\n+        }\n+    }\n+\n+    private AwsLoadBalancer convert(CloudLoadBalancer cloudLoadBalancer, CloudStack stack, List<CloudResource> instances) {\n+        int order = 1;\n+        List<AwsListener> awsListeners = new ArrayList<>();\n+        AwsLoadBalancerScheme scheme = AwsLoadBalancerScheme.valueOf(cloudLoadBalancer.getType().name());\n+        for (Map.Entry<Integer, Set<Group>> entry : cloudLoadBalancer.getPortToTargetGroupMapping().entrySet()) {\n+            List<CloudResource> lbTargetInstances = instances.stream()\n+                .filter(instance -> entry.getValue().stream().anyMatch(tg -> tg.getName().equals(instance.getGroup())))\n+                .collect(Collectors.toList());\n+            List<String> instanceIds = lbTargetInstances.stream().map(CloudResource::getInstanceId).collect(Collectors.toList());\n+\n+            AwsTargetGroup targetGroup = new AwsTargetGroup(entry.getKey(), scheme, order++, instanceIds);\n+            awsListeners.add(new AwsListener(entry.getKey(), Collections.singletonList(targetGroup), scheme));\n+        }\n+        return new AwsLoadBalancer(scheme, awsListeners);\n+    }\n+\n+    private ListStackResourcesResult updateCloudFormationStack(AuthenticatedContext ac, CloudStack stack, ModelContext modelContext) {\n+        String cFStackName = cfStackUtil.getCfStackName(ac);\n+        AwsCredentialView credentialView = new AwsCredentialView(ac.getCloudCredential());\n+        String regionName = ac.getCloudContext().getLocation().getRegion().value();\n+        AmazonCloudFormationRetryClient cfRetryClient = awsClient.createCloudFormationRetryClient(credentialView, regionName);\n+        Network network = stack.getNetwork();\n+        AwsNetworkView awsNetworkView = new AwsNetworkView(network);\n+        boolean existingVPC = awsNetworkView.isExistingVPC();\n+        boolean existingSubnet = awsNetworkView.isExistingSubnet();\n+        String cidr = network.getSubnet().getCidr();\n+        String subnet = isNoCIDRProvided(existingVPC, existingSubnet, cidr) ? awsNetworkService.findNonOverLappingCIDR(ac, stack) : cidr;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDAyOTUzOA=="}, "originalCommit": {"oid": "e19d80b459db1f5f36788bd56bc824be5253f860"}, "originalPosition": 188}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMyNDExNzg4OnYy", "diffSide": "RIGHT", "path": "cloud-aws/src/main/java/com/sequenceiq/cloudbreak/cloud/aws/connector/resource/AwsTerminateService.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNVQwMDoyNzoyOFrOH5efVQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wM1QxNjozMzozNlrOH-llJw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDAzMDQyMQ==", "bodyText": "isStackDeleted is also using waiters and retry / polling logic. Are we using double layer of retry intentionally?", "url": "https://github.com/hortonworks/cloudbreak/pull/9475#discussion_r530030421", "createdAt": "2020-11-25T00:27:28Z", "author": {"login": "enis"}, "path": "cloud-aws/src/main/java/com/sequenceiq/cloudbreak/cloud/aws/connector/resource/AwsTerminateService.java", "diffHunk": "@@ -112,12 +112,9 @@ private void waitAndDeleteCloudformationStack(AuthenticatedContext ac, CloudStac\n         resumeAutoScalingPolicies(ac, stack);\n         LOGGER.debug(\"Delete cloudformation stack from resources\");\n         DeleteStackRequest deleteStackRequest = new DeleteStackRequest().withStackName(cFStackName);\n-        cfRetryClient.deleteStack(deleteStackRequest);\n-        Waiter<DescribeStacksRequest> stackDeleteCompleteWaiter = amazonCloudFormationClient.waiters().stackDeleteComplete();\n         try {\n-            WaiterParameters<DescribeStacksRequest> describeStacksRequestWaiterParameters = new WaiterParameters<>(describeStacksRequest)\n-                    .withPollingStrategy(getBackoffCancellablePollingStrategy(null));\n-            stackDeleteCompleteWaiter.run(describeStacksRequestWaiterParameters);\n+            retryService.testWith2SecDelayMax5Times(() -> isStackDeleted(cfRetryClient, amazonCloudFormationClient,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e19d80b459db1f5f36788bd56bc824be5253f860"}, "originalPosition": 10}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjY5NjYxNw==", "bodyText": "It was intentional, yes. There are two things being retried. The cfRetryClient.deleteStack method is retrying the initiation of the request; if the initial request is rejected or fails immediately, it will retry up to 15 time to initiate it again. However, once it's successfully initiated, that retry is complete and there's nothing left to do. The purpose of the isStackDeleted method is to check the final state of the deletion, and allow us to retry if the final state is a failure. So one retry checks initialization state, and one checks the final state.", "url": "https://github.com/hortonworks/cloudbreak/pull/9475#discussion_r532696617", "createdAt": "2020-11-30T15:47:41Z", "author": {"login": "hreeve-cloudera"}, "path": "cloud-aws/src/main/java/com/sequenceiq/cloudbreak/cloud/aws/connector/resource/AwsTerminateService.java", "diffHunk": "@@ -112,12 +112,9 @@ private void waitAndDeleteCloudformationStack(AuthenticatedContext ac, CloudStac\n         resumeAutoScalingPolicies(ac, stack);\n         LOGGER.debug(\"Delete cloudformation stack from resources\");\n         DeleteStackRequest deleteStackRequest = new DeleteStackRequest().withStackName(cFStackName);\n-        cfRetryClient.deleteStack(deleteStackRequest);\n-        Waiter<DescribeStacksRequest> stackDeleteCompleteWaiter = amazonCloudFormationClient.waiters().stackDeleteComplete();\n         try {\n-            WaiterParameters<DescribeStacksRequest> describeStacksRequestWaiterParameters = new WaiterParameters<>(describeStacksRequest)\n-                    .withPollingStrategy(getBackoffCancellablePollingStrategy(null));\n-            stackDeleteCompleteWaiter.run(describeStacksRequestWaiterParameters);\n+            retryService.testWith2SecDelayMax5Times(() -> isStackDeleted(cfRetryClient, amazonCloudFormationClient,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDAzMDQyMQ=="}, "originalCommit": {"oid": "e19d80b459db1f5f36788bd56bc824be5253f860"}, "originalPosition": 10}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTM4OTQ3OQ==", "bodyText": "Talked this out with Tamas and added additional logging messages to make the logic of this section more cler.", "url": "https://github.com/hortonworks/cloudbreak/pull/9475#discussion_r535389479", "createdAt": "2020-12-03T16:33:36Z", "author": {"login": "hreeve-cloudera"}, "path": "cloud-aws/src/main/java/com/sequenceiq/cloudbreak/cloud/aws/connector/resource/AwsTerminateService.java", "diffHunk": "@@ -112,12 +112,9 @@ private void waitAndDeleteCloudformationStack(AuthenticatedContext ac, CloudStac\n         resumeAutoScalingPolicies(ac, stack);\n         LOGGER.debug(\"Delete cloudformation stack from resources\");\n         DeleteStackRequest deleteStackRequest = new DeleteStackRequest().withStackName(cFStackName);\n-        cfRetryClient.deleteStack(deleteStackRequest);\n-        Waiter<DescribeStacksRequest> stackDeleteCompleteWaiter = amazonCloudFormationClient.waiters().stackDeleteComplete();\n         try {\n-            WaiterParameters<DescribeStacksRequest> describeStacksRequestWaiterParameters = new WaiterParameters<>(describeStacksRequest)\n-                    .withPollingStrategy(getBackoffCancellablePollingStrategy(null));\n-            stackDeleteCompleteWaiter.run(describeStacksRequestWaiterParameters);\n+            retryService.testWith2SecDelayMax5Times(() -> isStackDeleted(cfRetryClient, amazonCloudFormationClient,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDAzMDQyMQ=="}, "originalCommit": {"oid": "e19d80b459db1f5f36788bd56bc824be5253f860"}, "originalPosition": 10}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMyNDEyMTMxOnYy", "diffSide": "RIGHT", "path": "cloud-aws/src/main/java/com/sequenceiq/cloudbreak/cloud/aws/loadbalancer/AwsListener.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNVQwMDoyODo1N1rOH5ehKA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNVQwMDoyODo1N1rOH5ehKA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDAzMDg4OA==", "bodyText": "great.", "url": "https://github.com/hortonworks/cloudbreak/pull/9475#discussion_r530030888", "createdAt": "2020-11-25T00:28:57Z", "author": {"login": "enis"}, "path": "cloud-aws/src/main/java/com/sequenceiq/cloudbreak/cloud/aws/loadbalancer/AwsListener.java", "diffHunk": "@@ -0,0 +1,43 @@\n+package com.sequenceiq.cloudbreak.cloud.aws.loadbalancer;\n+\n+import java.util.List;\n+\n+import org.apache.commons.lang3.StringUtils;\n+\n+public class AwsListener {\n+\n+    private static final String LISTENER_NAME_PREFIX = \"ListenerPort\";\n+\n+    private final int port;\n+\n+    private final List<AwsTargetGroup> targetGroups;\n+\n+    private final String name;\n+\n+    public AwsListener(int port, List<AwsTargetGroup> targetGroups, AwsLoadBalancerScheme scheme) {\n+        this.port = port;\n+        this.targetGroups = targetGroups;\n+        this.name = getListenerName(port, scheme);\n+    }\n+\n+    public int getPort() {\n+        return port;\n+    }\n+\n+    public List<AwsTargetGroup> getTargetGroups() {\n+        return targetGroups;\n+    }\n+\n+    public boolean areTargetGroupArnsSet() {\n+        return targetGroups.stream().noneMatch(t -> t.getArn() == null || t.getArn().isEmpty());\n+    }\n+\n+    public String getName() {\n+        return name;\n+    }\n+\n+    private static String getListenerName(int port, AwsLoadBalancerScheme scheme) {\n+        return LISTENER_NAME_PREFIX + port +", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e19d80b459db1f5f36788bd56bc824be5253f860"}, "originalPosition": 40}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMyNDEyMjk1OnYy", "diffSide": "RIGHT", "path": "cloud-aws/src/main/java/com/sequenceiq/cloudbreak/cloud/aws/loadbalancer/AwsLoadBalancer.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNVQwMDoyOTozNVrOH5eiBQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0zMFQxNTo1Mzo0NFrOH8BgOA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDAzMTEwOQ==", "bodyText": "nit: shouldCreateListeners()", "url": "https://github.com/hortonworks/cloudbreak/pull/9475#discussion_r530031109", "createdAt": "2020-11-25T00:29:35Z", "author": {"login": "enis"}, "path": "cloud-aws/src/main/java/com/sequenceiq/cloudbreak/cloud/aws/loadbalancer/AwsLoadBalancer.java", "diffHunk": "@@ -0,0 +1,73 @@\n+package com.sequenceiq.cloudbreak.cloud.aws.loadbalancer;\n+\n+import java.util.List;\n+\n+import org.apache.commons.lang3.StringUtils;\n+\n+public class AwsLoadBalancer {\n+\n+    private static final String LOAD_BALANCER_NAME_PREFIX = \"LoadBalancer\";\n+\n+    private final AwsLoadBalancerScheme scheme;\n+\n+    private final String awsScheme;\n+\n+    private final List<AwsListener> listeners;\n+\n+    private final String name;\n+\n+    private String arn;\n+\n+    private boolean createListeners;\n+\n+    public AwsLoadBalancer(AwsLoadBalancerScheme scheme, List<AwsListener> listeners) {\n+        this.scheme = scheme;\n+        this.awsScheme = scheme.awsScheme();\n+        this.listeners = listeners;\n+        this.name = getLoadBalancerName(scheme);\n+        this.createListeners = false;\n+    }\n+\n+    public AwsLoadBalancerScheme getScheme() {\n+        return scheme;\n+    }\n+\n+    public List<AwsListener> getListeners() {\n+        return listeners;\n+    }\n+\n+    public String getName() {\n+        return name;\n+    }\n+\n+    public String getArn() {\n+        return arn;\n+    }\n+\n+    public void setArn(String arn) {\n+        this.arn = arn;\n+    }\n+\n+    public String getAwsScheme() {\n+        return awsScheme;\n+    }\n+\n+    public boolean isCreateListeners() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e19d80b459db1f5f36788bd56bc824be5253f860"}, "originalPosition": 55}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjcwMTI0MA==", "bodyText": "I can't actually change this getter name, because the template files fetch the class members using standardized getter names. If you use anything else, it can't fetch the value properly and the template won't be filled out.\nHowever, I did change it from createListeners to listenerConfigSet, so the method name sounds nicer.", "url": "https://github.com/hortonworks/cloudbreak/pull/9475#discussion_r532701240", "createdAt": "2020-11-30T15:53:44Z", "author": {"login": "hreeve-cloudera"}, "path": "cloud-aws/src/main/java/com/sequenceiq/cloudbreak/cloud/aws/loadbalancer/AwsLoadBalancer.java", "diffHunk": "@@ -0,0 +1,73 @@\n+package com.sequenceiq.cloudbreak.cloud.aws.loadbalancer;\n+\n+import java.util.List;\n+\n+import org.apache.commons.lang3.StringUtils;\n+\n+public class AwsLoadBalancer {\n+\n+    private static final String LOAD_BALANCER_NAME_PREFIX = \"LoadBalancer\";\n+\n+    private final AwsLoadBalancerScheme scheme;\n+\n+    private final String awsScheme;\n+\n+    private final List<AwsListener> listeners;\n+\n+    private final String name;\n+\n+    private String arn;\n+\n+    private boolean createListeners;\n+\n+    public AwsLoadBalancer(AwsLoadBalancerScheme scheme, List<AwsListener> listeners) {\n+        this.scheme = scheme;\n+        this.awsScheme = scheme.awsScheme();\n+        this.listeners = listeners;\n+        this.name = getLoadBalancerName(scheme);\n+        this.createListeners = false;\n+    }\n+\n+    public AwsLoadBalancerScheme getScheme() {\n+        return scheme;\n+    }\n+\n+    public List<AwsListener> getListeners() {\n+        return listeners;\n+    }\n+\n+    public String getName() {\n+        return name;\n+    }\n+\n+    public String getArn() {\n+        return arn;\n+    }\n+\n+    public void setArn(String arn) {\n+        this.arn = arn;\n+    }\n+\n+    public String getAwsScheme() {\n+        return awsScheme;\n+    }\n+\n+    public boolean isCreateListeners() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDAzMTEwOQ=="}, "originalCommit": {"oid": "e19d80b459db1f5f36788bd56bc824be5253f860"}, "originalPosition": 55}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMyNDEyNDg5OnYy", "diffSide": "RIGHT", "path": "cloud-aws/src/main/java/com/sequenceiq/cloudbreak/cloud/aws/loadbalancer/AwsLoadBalancer.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNVQwMDozMDoyMlrOH5ejBA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0zMFQxNTo1NTozNFrOH8BmDg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDAzMTM2NA==", "bodyText": "This does not seem to be used.", "url": "https://github.com/hortonworks/cloudbreak/pull/9475#discussion_r530031364", "createdAt": "2020-11-25T00:30:22Z", "author": {"login": "enis"}, "path": "cloud-aws/src/main/java/com/sequenceiq/cloudbreak/cloud/aws/loadbalancer/AwsLoadBalancer.java", "diffHunk": "@@ -0,0 +1,73 @@\n+package com.sequenceiq.cloudbreak.cloud.aws.loadbalancer;\n+\n+import java.util.List;\n+\n+import org.apache.commons.lang3.StringUtils;\n+\n+public class AwsLoadBalancer {\n+\n+    private static final String LOAD_BALANCER_NAME_PREFIX = \"LoadBalancer\";\n+\n+    private final AwsLoadBalancerScheme scheme;\n+\n+    private final String awsScheme;\n+\n+    private final List<AwsListener> listeners;\n+\n+    private final String name;\n+\n+    private String arn;\n+\n+    private boolean createListeners;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e19d80b459db1f5f36788bd56bc824be5253f860"}, "originalPosition": 21}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjcwMjczNA==", "bodyText": "It's used by the template files. See https://github.com/hortonworks/cloudbreak/pull/9475/files#diff-5b1a3ad86915b768282779a97322c280afd84febb377b395e1d274fbdebef237R288", "url": "https://github.com/hortonworks/cloudbreak/pull/9475#discussion_r532702734", "createdAt": "2020-11-30T15:55:34Z", "author": {"login": "hreeve-cloudera"}, "path": "cloud-aws/src/main/java/com/sequenceiq/cloudbreak/cloud/aws/loadbalancer/AwsLoadBalancer.java", "diffHunk": "@@ -0,0 +1,73 @@\n+package com.sequenceiq.cloudbreak.cloud.aws.loadbalancer;\n+\n+import java.util.List;\n+\n+import org.apache.commons.lang3.StringUtils;\n+\n+public class AwsLoadBalancer {\n+\n+    private static final String LOAD_BALANCER_NAME_PREFIX = \"LoadBalancer\";\n+\n+    private final AwsLoadBalancerScheme scheme;\n+\n+    private final String awsScheme;\n+\n+    private final List<AwsListener> listeners;\n+\n+    private final String name;\n+\n+    private String arn;\n+\n+    private boolean createListeners;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDAzMTM2NA=="}, "originalCommit": {"oid": "e19d80b459db1f5f36788bd56bc824be5253f860"}, "originalPosition": 21}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMyNDEyNjU0OnYy", "diffSide": "RIGHT", "path": "cloud-aws/src/main/java/com/sequenceiq/cloudbreak/cloud/aws/loadbalancer/AwsLoadBalancerScheme.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNVQwMDozMTowM1rOH5ej6Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0zMFQxNTo1NzoxNlrOH8BrLg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDAzMTU5Mw==", "bodyText": "I think this should match AWS's terminology.\nINTERNET_FACING(\"internet-facing\")\nINTERNAL(\"internal\")", "url": "https://github.com/hortonworks/cloudbreak/pull/9475#discussion_r530031593", "createdAt": "2020-11-25T00:31:03Z", "author": {"login": "enis"}, "path": "cloud-aws/src/main/java/com/sequenceiq/cloudbreak/cloud/aws/loadbalancer/AwsLoadBalancerScheme.java", "diffHunk": "@@ -0,0 +1,16 @@\n+package com.sequenceiq.cloudbreak.cloud.aws.loadbalancer;\n+\n+public enum AwsLoadBalancerScheme {\n+    PUBLIC(\"internet-facing\"),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e19d80b459db1f5f36788bd56bc824be5253f860"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjcwNDA0Ng==", "bodyText": "The purpose of using PUBLIC/PRIVATE here is so we can convert between the LoadBalalncerType class and this class. You can see this use in AwsLaunchService:\nAwsLoadBalancerScheme scheme = AwsLoadBalancerScheme.valueOf(cloudLoadBalancer.getType().name());", "url": "https://github.com/hortonworks/cloudbreak/pull/9475#discussion_r532704046", "createdAt": "2020-11-30T15:57:16Z", "author": {"login": "hreeve-cloudera"}, "path": "cloud-aws/src/main/java/com/sequenceiq/cloudbreak/cloud/aws/loadbalancer/AwsLoadBalancerScheme.java", "diffHunk": "@@ -0,0 +1,16 @@\n+package com.sequenceiq.cloudbreak.cloud.aws.loadbalancer;\n+\n+public enum AwsLoadBalancerScheme {\n+    PUBLIC(\"internet-facing\"),", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDAzMTU5Mw=="}, "originalCommit": {"oid": "e19d80b459db1f5f36788bd56bc824be5253f860"}, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMyNDEzNjI3OnYy", "diffSide": "RIGHT", "path": "cloud-aws/src/main/resources/templates/aws-cf-stack.ftl", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNVQwMDozNToxNFrOH5epTw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0zMFQxNTo1OTozMlrOH8ByRQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDAzMjk3NQ==", "bodyText": "Which subnet is this? We may need some logic here (as you note in your email thread) about selectiing public or private subnets as well as having more than 1 subnet (for cross-AZ availability). Can be done as follow ups.", "url": "https://github.com/hortonworks/cloudbreak/pull/9475#discussion_r530032975", "createdAt": "2020-11-25T00:35:14Z", "author": {"login": "enis"}, "path": "cloud-aws/src/main/resources/templates/aws-cf-stack.ftl", "diffHunk": "@@ -273,6 +273,64 @@\n     },\n     </#if>\n \n+    <#list loadBalancers as loadBalancer>\n+    \"${loadBalancer.name}\" : {\n+      \"Type\" : \"AWS::ElasticLoadBalancingV2::LoadBalancer\",\n+      \"Properties\" : {\n+        \"IpAddressType\" : \"ipv4\",\n+        \"Scheme\" : \"${loadBalancer.awsScheme}\",\n+        \"Subnets\" : [ { \"Ref\" : \"SubnetId\" } ],", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e19d80b459db1f5f36788bd56bc824be5253f860"}, "originalPosition": 10}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjcwNTg2MQ==", "bodyText": "At the moment it's using the same subnet as is being used for the EC2 instances. I've already opened CB-9900 to expand this to use public subnets when necessary. When I dug into it it looked like a fairly sizable change, so I didn't want to add it to this PR.", "url": "https://github.com/hortonworks/cloudbreak/pull/9475#discussion_r532705861", "createdAt": "2020-11-30T15:59:32Z", "author": {"login": "hreeve-cloudera"}, "path": "cloud-aws/src/main/resources/templates/aws-cf-stack.ftl", "diffHunk": "@@ -273,6 +273,64 @@\n     },\n     </#if>\n \n+    <#list loadBalancers as loadBalancer>\n+    \"${loadBalancer.name}\" : {\n+      \"Type\" : \"AWS::ElasticLoadBalancingV2::LoadBalancer\",\n+      \"Properties\" : {\n+        \"IpAddressType\" : \"ipv4\",\n+        \"Scheme\" : \"${loadBalancer.awsScheme}\",\n+        \"Subnets\" : [ { \"Ref\" : \"SubnetId\" } ],", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDAzMjk3NQ=="}, "originalCommit": {"oid": "e19d80b459db1f5f36788bd56bc824be5253f860"}, "originalPosition": 10}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMyNDEzOTc3OnYy", "diffSide": "RIGHT", "path": "cloud-aws/src/main/resources/templates/aws-cf-stack.ftl", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNVQwMDozNjo0M1rOH5erLw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0zMFQxNjowMDowOVrOH8B0EA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDAzMzQ1NQ==", "bodyText": "I think hard coding it here makes sense for now, but maybe also have the LB type in the database table so that in the future we can add ALB, ELB if needed.", "url": "https://github.com/hortonworks/cloudbreak/pull/9475#discussion_r530033455", "createdAt": "2020-11-25T00:36:43Z", "author": {"login": "enis"}, "path": "cloud-aws/src/main/resources/templates/aws-cf-stack.ftl", "diffHunk": "@@ -273,6 +273,64 @@\n     },\n     </#if>\n \n+    <#list loadBalancers as loadBalancer>\n+    \"${loadBalancer.name}\" : {\n+      \"Type\" : \"AWS::ElasticLoadBalancingV2::LoadBalancer\",\n+      \"Properties\" : {\n+        \"IpAddressType\" : \"ipv4\",\n+        \"Scheme\" : \"${loadBalancer.awsScheme}\",\n+        \"Subnets\" : [ { \"Ref\" : \"SubnetId\" } ],\n+        \"Type\" : \"network\"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e19d80b459db1f5f36788bd56bc824be5253f860"}, "originalPosition": 11}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjcwNjMyMA==", "bodyText": "We can certainly add that as it becomes needed. I just didn't want to complicate it anymore than it already was at this point.", "url": "https://github.com/hortonworks/cloudbreak/pull/9475#discussion_r532706320", "createdAt": "2020-11-30T16:00:09Z", "author": {"login": "hreeve-cloudera"}, "path": "cloud-aws/src/main/resources/templates/aws-cf-stack.ftl", "diffHunk": "@@ -273,6 +273,64 @@\n     },\n     </#if>\n \n+    <#list loadBalancers as loadBalancer>\n+    \"${loadBalancer.name}\" : {\n+      \"Type\" : \"AWS::ElasticLoadBalancingV2::LoadBalancer\",\n+      \"Properties\" : {\n+        \"IpAddressType\" : \"ipv4\",\n+        \"Scheme\" : \"${loadBalancer.awsScheme}\",\n+        \"Subnets\" : [ { \"Ref\" : \"SubnetId\" } ],\n+        \"Type\" : \"network\"", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDAzMzQ1NQ=="}, "originalCommit": {"oid": "e19d80b459db1f5f36788bd56bc824be5253f860"}, "originalPosition": 11}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMyNDE4OTUxOnYy", "diffSide": "RIGHT", "path": "core/src/main/resources/schema/app/20201103154306_CB-9366_Create_load_balancer_metadata_table.sql", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNVQwMTowMDowMVrOH5fHrg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wM1QwNzo1Mzo1NVrOH-EmpA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDA0MDc1MA==", "bodyText": "it makes sense to double check whether everthing here fits 255 chars.", "url": "https://github.com/hortonworks/cloudbreak/pull/9475#discussion_r530040750", "createdAt": "2020-11-25T01:00:01Z", "author": {"login": "enis"}, "path": "core/src/main/resources/schema/app/20201103154306_CB-9366_Create_load_balancer_metadata_table.sql", "diffHunk": "@@ -0,0 +1,62 @@\n+-- // CB-9366 Create load balancer metadata table\n+-- Migration SQL that makes the change goes here.\n+\n+CREATE SEQUENCE loadbalancer_id_seq START WITH 1\n+  INCREMENT BY 1\n+  NO MINVALUE\n+  NO MAXVALUE\n+  CACHE 1;\n+\n+CREATE TABLE loadbalancer (\n+    id bigint default nextval('loadbalancer_id_seq'::regclass) not null\n+      constraint loadbalancer_pkey\n+        primary key,\n+    dns character varying(255),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e19d80b459db1f5f36788bd56bc824be5253f860"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDg0OTE4OA==", "bodyText": "Regarding RFC-1035 it should be enough.\n\nTo simplify implementations, the total length of a domain name (i.e.,\nlabel octets and label length octets) is restricted to 255 octets or\nless.", "url": "https://github.com/hortonworks/cloudbreak/pull/9475#discussion_r534849188", "createdAt": "2020-12-03T07:53:55Z", "author": {"login": "biharitomi"}, "path": "core/src/main/resources/schema/app/20201103154306_CB-9366_Create_load_balancer_metadata_table.sql", "diffHunk": "@@ -0,0 +1,62 @@\n+-- // CB-9366 Create load balancer metadata table\n+-- Migration SQL that makes the change goes here.\n+\n+CREATE SEQUENCE loadbalancer_id_seq START WITH 1\n+  INCREMENT BY 1\n+  NO MINVALUE\n+  NO MAXVALUE\n+  CACHE 1;\n+\n+CREATE TABLE loadbalancer (\n+    id bigint default nextval('loadbalancer_id_seq'::regclass) not null\n+      constraint loadbalancer_pkey\n+        primary key,\n+    dns character varying(255),", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDA0MDc1MA=="}, "originalCommit": {"oid": "e19d80b459db1f5f36788bd56bc824be5253f860"}, "originalPosition": 14}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMyNDE5MTE5OnYy", "diffSide": "RIGHT", "path": "core/src/main/resources/schema/app/20201103154306_CB-9366_Create_load_balancer_metadata_table.sql", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNVQwMTowMDo1M1rOH5fIvw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0zMFQxNjowMDo1NVrOH8B2Lg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDA0MTAyMw==", "bodyText": "as per above, this may need to be a list of ips (but a short list), so may even be ip_1, ip_2, ip_3.", "url": "https://github.com/hortonworks/cloudbreak/pull/9475#discussion_r530041023", "createdAt": "2020-11-25T01:00:53Z", "author": {"login": "enis"}, "path": "core/src/main/resources/schema/app/20201103154306_CB-9366_Create_load_balancer_metadata_table.sql", "diffHunk": "@@ -0,0 +1,62 @@\n+-- // CB-9366 Create load balancer metadata table\n+-- Migration SQL that makes the change goes here.\n+\n+CREATE SEQUENCE loadbalancer_id_seq START WITH 1\n+  INCREMENT BY 1\n+  NO MINVALUE\n+  NO MAXVALUE\n+  CACHE 1;\n+\n+CREATE TABLE loadbalancer (\n+    id bigint default nextval('loadbalancer_id_seq'::regclass) not null\n+      constraint loadbalancer_pkey\n+        primary key,\n+    dns character varying(255),\n+    hostedzoneid character varying(255),\n+    ip character varying(255),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e19d80b459db1f5f36788bd56bc824be5253f860"}, "originalPosition": 16}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjcwNjg2Mg==", "bodyText": "See my previous comment about the ip addresses. If we need this to be a list when Azure is incorporated, I'll make a new SQL file to update the table.", "url": "https://github.com/hortonworks/cloudbreak/pull/9475#discussion_r532706862", "createdAt": "2020-11-30T16:00:55Z", "author": {"login": "hreeve-cloudera"}, "path": "core/src/main/resources/schema/app/20201103154306_CB-9366_Create_load_balancer_metadata_table.sql", "diffHunk": "@@ -0,0 +1,62 @@\n+-- // CB-9366 Create load balancer metadata table\n+-- Migration SQL that makes the change goes here.\n+\n+CREATE SEQUENCE loadbalancer_id_seq START WITH 1\n+  INCREMENT BY 1\n+  NO MINVALUE\n+  NO MAXVALUE\n+  CACHE 1;\n+\n+CREATE TABLE loadbalancer (\n+    id bigint default nextval('loadbalancer_id_seq'::regclass) not null\n+      constraint loadbalancer_pkey\n+        primary key,\n+    dns character varying(255),\n+    hostedzoneid character varying(255),\n+    ip character varying(255),", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDA0MTAyMw=="}, "originalCommit": {"oid": "e19d80b459db1f5f36788bd56bc824be5253f860"}, "originalPosition": 16}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMyNDIwMDU5OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/com/sequenceiq/cloudbreak/service/LoadBalancerConfigService.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNVQwMTowNTo1MVrOH5fOeg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNVQwMTowNTo1MVrOH5fOeg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDA0MjQ5MA==", "bodyText": "maybe debug level?", "url": "https://github.com/hortonworks/cloudbreak/pull/9475#discussion_r530042490", "createdAt": "2020-11-25T01:05:51Z", "author": {"login": "enis"}, "path": "core/src/main/java/com/sequenceiq/cloudbreak/service/LoadBalancerConfigService.java", "diffHunk": "@@ -0,0 +1,86 @@\n+package com.sequenceiq.cloudbreak.service;\n+\n+import com.sequenceiq.cloudbreak.domain.stack.loadbalancer.TargetGroup;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.stereotype.Service;\n+\n+import com.sequenceiq.cloudbreak.cmtemplate.CmTemplateProcessor;\n+import com.sequenceiq.cloudbreak.cmtemplate.configproviders.knox.KnoxRoles;\n+import com.sequenceiq.cloudbreak.domain.stack.Stack;\n+import com.sequenceiq.cloudbreak.domain.stack.cluster.Cluster;\n+import com.sequenceiq.cloudbreak.domain.stack.instance.InstanceGroup;\n+import com.sequenceiq.cloudbreak.template.model.ServiceComponent;\n+import com.sequenceiq.common.api.type.InstanceGroupType;\n+import com.sequenceiq.common.api.type.LoadBalancerType;\n+\n+@Service\n+public class LoadBalancerConfigService {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(LoadBalancerConfigService.class);\n+\n+    private static final String ENDPOINT_SUFFIX = \"gateway\";\n+\n+    private static final String PUBLIC_SUFFIX = \"external\";\n+\n+    private static final Set<Integer> DEFAULT_KNOX_PORTS = Set.of(443);\n+\n+    public Set<String> getKnoxGatewayGroups(Stack stack) {\n+        LOGGER.info(\"Fetching list of instance groups with Knox gateway installed\");\n+        Set<String> groupNames = new HashSet<>();\n+        Cluster cluster = stack.getCluster();\n+        if (cluster != null) {\n+            CmTemplateProcessor cmTemplateProcessor = new CmTemplateProcessor(cluster.getBlueprint().getBlueprintText());\n+            Map<String, Set<ServiceComponent>> componentByHostGroup = cmTemplateProcessor.getServiceComponentsByHostGroup();\n+            LOGGER.info(\"Checking if Knox gateway is explicitly defined\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e19d80b459db1f5f36788bd56bc824be5253f860"}, "originalPosition": 41}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMyNDIwMzkwOnYy", "diffSide": "RIGHT", "path": "core/src/main/java/com/sequenceiq/cloudbreak/service/LoadBalancerConfigService.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNVQwMTowNzozM1rOH5fQZg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0zMFQxNjowMjozMVrOH8B68w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDA0Mjk4Mg==", "bodyText": "I think the convention we should use is to follow AWS terminology. internet-facing load balancers do not have an \"external\" suffix, but internal load balancers have and \"-internal\" suffix.", "url": "https://github.com/hortonworks/cloudbreak/pull/9475#discussion_r530042982", "createdAt": "2020-11-25T01:07:33Z", "author": {"login": "enis"}, "path": "core/src/main/java/com/sequenceiq/cloudbreak/service/LoadBalancerConfigService.java", "diffHunk": "@@ -0,0 +1,86 @@\n+package com.sequenceiq.cloudbreak.service;\n+\n+import com.sequenceiq.cloudbreak.domain.stack.loadbalancer.TargetGroup;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.stereotype.Service;\n+\n+import com.sequenceiq.cloudbreak.cmtemplate.CmTemplateProcessor;\n+import com.sequenceiq.cloudbreak.cmtemplate.configproviders.knox.KnoxRoles;\n+import com.sequenceiq.cloudbreak.domain.stack.Stack;\n+import com.sequenceiq.cloudbreak.domain.stack.cluster.Cluster;\n+import com.sequenceiq.cloudbreak.domain.stack.instance.InstanceGroup;\n+import com.sequenceiq.cloudbreak.template.model.ServiceComponent;\n+import com.sequenceiq.common.api.type.InstanceGroupType;\n+import com.sequenceiq.common.api.type.LoadBalancerType;\n+\n+@Service\n+public class LoadBalancerConfigService {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(LoadBalancerConfigService.class);\n+\n+    private static final String ENDPOINT_SUFFIX = \"gateway\";\n+\n+    private static final String PUBLIC_SUFFIX = \"external\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e19d80b459db1f5f36788bd56bc824be5253f860"}, "originalPosition": 30}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjcwODA4Mw==", "bodyText": "I'm going to copy this comment to CB-9900. External subnets aren't going to be incorporated until that's done, so we can look at the naming then.", "url": "https://github.com/hortonworks/cloudbreak/pull/9475#discussion_r532708083", "createdAt": "2020-11-30T16:02:31Z", "author": {"login": "hreeve-cloudera"}, "path": "core/src/main/java/com/sequenceiq/cloudbreak/service/LoadBalancerConfigService.java", "diffHunk": "@@ -0,0 +1,86 @@\n+package com.sequenceiq.cloudbreak.service;\n+\n+import com.sequenceiq.cloudbreak.domain.stack.loadbalancer.TargetGroup;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.stereotype.Service;\n+\n+import com.sequenceiq.cloudbreak.cmtemplate.CmTemplateProcessor;\n+import com.sequenceiq.cloudbreak.cmtemplate.configproviders.knox.KnoxRoles;\n+import com.sequenceiq.cloudbreak.domain.stack.Stack;\n+import com.sequenceiq.cloudbreak.domain.stack.cluster.Cluster;\n+import com.sequenceiq.cloudbreak.domain.stack.instance.InstanceGroup;\n+import com.sequenceiq.cloudbreak.template.model.ServiceComponent;\n+import com.sequenceiq.common.api.type.InstanceGroupType;\n+import com.sequenceiq.common.api.type.LoadBalancerType;\n+\n+@Service\n+public class LoadBalancerConfigService {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(LoadBalancerConfigService.class);\n+\n+    private static final String ENDPOINT_SUFFIX = \"gateway\";\n+\n+    private static final String PUBLIC_SUFFIX = \"external\";", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDA0Mjk4Mg=="}, "originalCommit": {"oid": "e19d80b459db1f5f36788bd56bc824be5253f860"}, "originalPosition": 30}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMyNDIwNTEyOnYy", "diffSide": "RIGHT", "path": "core/src/main/java/com/sequenceiq/cloudbreak/service/LoadBalancerConfigService.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNVQwMTowODoxNlrOH5fRJw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0zMFQxNjowNDo0OFrOH8CBsQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDA0MzE3NQ==", "bodyText": "is this the full stack name, or just the shortened one?", "url": "https://github.com/hortonworks/cloudbreak/pull/9475#discussion_r530043175", "createdAt": "2020-11-25T01:08:16Z", "author": {"login": "enis"}, "path": "core/src/main/java/com/sequenceiq/cloudbreak/service/LoadBalancerConfigService.java", "diffHunk": "@@ -0,0 +1,86 @@\n+package com.sequenceiq.cloudbreak.service;\n+\n+import com.sequenceiq.cloudbreak.domain.stack.loadbalancer.TargetGroup;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.stereotype.Service;\n+\n+import com.sequenceiq.cloudbreak.cmtemplate.CmTemplateProcessor;\n+import com.sequenceiq.cloudbreak.cmtemplate.configproviders.knox.KnoxRoles;\n+import com.sequenceiq.cloudbreak.domain.stack.Stack;\n+import com.sequenceiq.cloudbreak.domain.stack.cluster.Cluster;\n+import com.sequenceiq.cloudbreak.domain.stack.instance.InstanceGroup;\n+import com.sequenceiq.cloudbreak.template.model.ServiceComponent;\n+import com.sequenceiq.common.api.type.InstanceGroupType;\n+import com.sequenceiq.common.api.type.LoadBalancerType;\n+\n+@Service\n+public class LoadBalancerConfigService {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(LoadBalancerConfigService.class);\n+\n+    private static final String ENDPOINT_SUFFIX = \"gateway\";\n+\n+    private static final String PUBLIC_SUFFIX = \"external\";\n+\n+    private static final Set<Integer> DEFAULT_KNOX_PORTS = Set.of(443);\n+\n+    public Set<String> getKnoxGatewayGroups(Stack stack) {\n+        LOGGER.info(\"Fetching list of instance groups with Knox gateway installed\");\n+        Set<String> groupNames = new HashSet<>();\n+        Cluster cluster = stack.getCluster();\n+        if (cluster != null) {\n+            CmTemplateProcessor cmTemplateProcessor = new CmTemplateProcessor(cluster.getBlueprint().getBlueprintText());\n+            Map<String, Set<ServiceComponent>> componentByHostGroup = cmTemplateProcessor.getServiceComponentsByHostGroup();\n+            LOGGER.info(\"Checking if Knox gateway is explicitly defined\");\n+            groupNames = componentByHostGroup.entrySet().stream()\n+                .filter(entry -> isKnoxGatewayDefinedInServices(entry.getValue()))\n+                .map(Map.Entry::getKey)\n+                .collect(Collectors.toSet());\n+        }\n+\n+        if (groupNames.isEmpty()) {\n+            LOGGER.info(\"Knox gateway is not explicitly defined; searching for CM gateway hosts\");\n+            groupNames = stack.getInstanceGroups().stream()\n+                .filter(i -> InstanceGroupType.isGateway(i.getInstanceGroupType()))\n+                .map(InstanceGroup::getGroupName)\n+                .collect(Collectors.toSet());\n+        }\n+\n+        if (groupNames.isEmpty()) {\n+            LOGGER.info(\"No Knox gateway instance groups found\");\n+        }\n+        return groupNames;\n+    }\n+\n+    private boolean isKnoxGatewayDefinedInServices(Set<ServiceComponent> serviceComponents) {\n+        return serviceComponents.stream()\n+            .anyMatch(serviceComponent -> KnoxRoles.KNOX_GATEWAY.equals(serviceComponent.getComponent()));\n+    }\n+\n+    public String generateLoadBalancerEndpoint(Stack stack, LoadBalancerType type) {\n+        StringBuilder name = new StringBuilder()\n+            .append(stack.getName())", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e19d80b459db1f5f36788bd56bc824be5253f860"}, "originalPosition": 69}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjcwOTgwOQ==", "bodyText": "The shortened one. So if I name my datalake hreeve-cloudbreak-dl, that would be the stack name here, and the endpoint would be hreeve-cloudbreak-dl-gateway.", "url": "https://github.com/hortonworks/cloudbreak/pull/9475#discussion_r532709809", "createdAt": "2020-11-30T16:04:48Z", "author": {"login": "hreeve-cloudera"}, "path": "core/src/main/java/com/sequenceiq/cloudbreak/service/LoadBalancerConfigService.java", "diffHunk": "@@ -0,0 +1,86 @@\n+package com.sequenceiq.cloudbreak.service;\n+\n+import com.sequenceiq.cloudbreak.domain.stack.loadbalancer.TargetGroup;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.stereotype.Service;\n+\n+import com.sequenceiq.cloudbreak.cmtemplate.CmTemplateProcessor;\n+import com.sequenceiq.cloudbreak.cmtemplate.configproviders.knox.KnoxRoles;\n+import com.sequenceiq.cloudbreak.domain.stack.Stack;\n+import com.sequenceiq.cloudbreak.domain.stack.cluster.Cluster;\n+import com.sequenceiq.cloudbreak.domain.stack.instance.InstanceGroup;\n+import com.sequenceiq.cloudbreak.template.model.ServiceComponent;\n+import com.sequenceiq.common.api.type.InstanceGroupType;\n+import com.sequenceiq.common.api.type.LoadBalancerType;\n+\n+@Service\n+public class LoadBalancerConfigService {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(LoadBalancerConfigService.class);\n+\n+    private static final String ENDPOINT_SUFFIX = \"gateway\";\n+\n+    private static final String PUBLIC_SUFFIX = \"external\";\n+\n+    private static final Set<Integer> DEFAULT_KNOX_PORTS = Set.of(443);\n+\n+    public Set<String> getKnoxGatewayGroups(Stack stack) {\n+        LOGGER.info(\"Fetching list of instance groups with Knox gateway installed\");\n+        Set<String> groupNames = new HashSet<>();\n+        Cluster cluster = stack.getCluster();\n+        if (cluster != null) {\n+            CmTemplateProcessor cmTemplateProcessor = new CmTemplateProcessor(cluster.getBlueprint().getBlueprintText());\n+            Map<String, Set<ServiceComponent>> componentByHostGroup = cmTemplateProcessor.getServiceComponentsByHostGroup();\n+            LOGGER.info(\"Checking if Knox gateway is explicitly defined\");\n+            groupNames = componentByHostGroup.entrySet().stream()\n+                .filter(entry -> isKnoxGatewayDefinedInServices(entry.getValue()))\n+                .map(Map.Entry::getKey)\n+                .collect(Collectors.toSet());\n+        }\n+\n+        if (groupNames.isEmpty()) {\n+            LOGGER.info(\"Knox gateway is not explicitly defined; searching for CM gateway hosts\");\n+            groupNames = stack.getInstanceGroups().stream()\n+                .filter(i -> InstanceGroupType.isGateway(i.getInstanceGroupType()))\n+                .map(InstanceGroup::getGroupName)\n+                .collect(Collectors.toSet());\n+        }\n+\n+        if (groupNames.isEmpty()) {\n+            LOGGER.info(\"No Knox gateway instance groups found\");\n+        }\n+        return groupNames;\n+    }\n+\n+    private boolean isKnoxGatewayDefinedInServices(Set<ServiceComponent> serviceComponents) {\n+        return serviceComponents.stream()\n+            .anyMatch(serviceComponent -> KnoxRoles.KNOX_GATEWAY.equals(serviceComponent.getComponent()));\n+    }\n+\n+    public String generateLoadBalancerEndpoint(Stack stack, LoadBalancerType type) {\n+        StringBuilder name = new StringBuilder()\n+            .append(stack.getName())", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDA0MzE3NQ=="}, "originalCommit": {"oid": "e19d80b459db1f5f36788bd56bc824be5253f860"}, "originalPosition": 69}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM1MjIyOTAzOnYy", "diffSide": "RIGHT", "path": "mock-thunderhead/src/main/resources/application.yml", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMlQxNjowODo0OVrOH9id3w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMlQxNjowODo0OVrOH9id3w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDI4OTg4Nw==", "bodyText": "Can we make this functionality disabled by default?\nAs most of the devs don't have a running PEM locally or connected to one of the MOW ones.", "url": "https://github.com/hortonworks/cloudbreak/pull/9475#discussion_r534289887", "createdAt": "2020-12-02T16:08:49Z", "author": {"login": "biharitomi"}, "path": "mock-thunderhead/src/main/resources/application.yml", "diffHunk": "@@ -33,3 +33,4 @@ auth:\n     differentdatahubversionthandatalake.enabled: true\n     database.wire.encryption.enable: true\n     datahub.runtime.upgrade.enable: true\n+    datalake.loadbalancer.enable: true", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "38ef8055c8d7bdf17068665196206f3622b9a3bd"}, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM1MzU0MDE1OnYy", "diffSide": "RIGHT", "path": "core-model/src/main/java/com/sequenceiq/cloudbreak/domain/stack/Stack.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMlQyMTozMzozNVrOH9vB0A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wM1QxNjozNjowMVrOH-lsjA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDQ5NTY5Ng==", "bodyText": "This method should not be created as getGatewayInstanceMetadata or getPrimaryGatewayInstance could be used to do the same and I checked in IDEA it hasn't even used anywhere on this branch.", "url": "https://github.com/hortonworks/cloudbreak/pull/9475#discussion_r534495696", "createdAt": "2020-12-02T21:33:35Z", "author": {"login": "biharitomi"}, "path": "core-model/src/main/java/com/sequenceiq/cloudbreak/domain/stack/Stack.java", "diffHunk": "@@ -574,6 +579,15 @@ public InstanceMetaData getPrimaryGatewayInstance() {\n         return metaData.orElse(null);\n     }\n \n+    public InstanceGroup getGatewayGroup() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "91252020ce85e0bf097c4fcba5073697e46aa7e7"}, "originalPosition": 23}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTM5MTM3Mg==", "bodyText": "This method has been deleted. Thanks for the catch!", "url": "https://github.com/hortonworks/cloudbreak/pull/9475#discussion_r535391372", "createdAt": "2020-12-03T16:36:01Z", "author": {"login": "hreeve-cloudera"}, "path": "core-model/src/main/java/com/sequenceiq/cloudbreak/domain/stack/Stack.java", "diffHunk": "@@ -574,6 +579,15 @@ public InstanceMetaData getPrimaryGatewayInstance() {\n         return metaData.orElse(null);\n     }\n \n+    public InstanceGroup getGatewayGroup() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDQ5NTY5Ng=="}, "originalCommit": {"oid": "91252020ce85e0bf097c4fcba5073697e46aa7e7"}, "originalPosition": 23}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM1MzU3NTU5OnYy", "diffSide": "RIGHT", "path": "core-model/src/main/java/com/sequenceiq/cloudbreak/domain/stack/loadbalancer/TargetGroup.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMlQyMTo0Mzo0OVrOH9vXKQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wM1QxODowMToyMVrOH-p2Jw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDUwMTE2MQ==", "bodyText": "The TargetGroupType enum could be used here and the values of the field would be more straightforward. CB has an enum converter logic which handles the conversion from enum to string and vice versa.\nAn example could be: com.sequenceiq.environment.parameters.dao.converter.CredentialTypeConverter", "url": "https://github.com/hortonworks/cloudbreak/pull/9475#discussion_r534501161", "createdAt": "2020-12-02T21:43:49Z", "author": {"login": "biharitomi"}, "path": "core-model/src/main/java/com/sequenceiq/cloudbreak/domain/stack/loadbalancer/TargetGroup.java", "diffHunk": "@@ -0,0 +1,59 @@\n+package com.sequenceiq.cloudbreak.domain.stack.loadbalancer;\n+\n+import com.sequenceiq.cloudbreak.domain.ProvisionEntity;\n+import java.util.Set;\n+\n+import javax.persistence.Entity;\n+import javax.persistence.FetchType;\n+import javax.persistence.GeneratedValue;\n+import javax.persistence.GenerationType;\n+import javax.persistence.Id;\n+import javax.persistence.ManyToMany;\n+import javax.persistence.ManyToOne;\n+import javax.persistence.SequenceGenerator;\n+\n+import com.sequenceiq.cloudbreak.domain.stack.instance.InstanceGroup;\n+\n+@Entity\n+public class TargetGroup implements ProvisionEntity {\n+    @Id\n+    @GeneratedValue(strategy = GenerationType.AUTO, generator = \"targetgroup_generator\")\n+    @SequenceGenerator(name = \"targetgroup_generator\", sequenceName = \"targetgroup_id_seq\", allocationSize = 1)\n+    private Long id;\n+\n+    private String type;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "91252020ce85e0bf097c4fcba5073697e46aa7e7"}, "originalPosition": 24}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTQ1OTM2Nw==", "bodyText": "Done", "url": "https://github.com/hortonworks/cloudbreak/pull/9475#discussion_r535459367", "createdAt": "2020-12-03T18:01:21Z", "author": {"login": "hreeve-cloudera"}, "path": "core-model/src/main/java/com/sequenceiq/cloudbreak/domain/stack/loadbalancer/TargetGroup.java", "diffHunk": "@@ -0,0 +1,59 @@\n+package com.sequenceiq.cloudbreak.domain.stack.loadbalancer;\n+\n+import com.sequenceiq.cloudbreak.domain.ProvisionEntity;\n+import java.util.Set;\n+\n+import javax.persistence.Entity;\n+import javax.persistence.FetchType;\n+import javax.persistence.GeneratedValue;\n+import javax.persistence.GenerationType;\n+import javax.persistence.Id;\n+import javax.persistence.ManyToMany;\n+import javax.persistence.ManyToOne;\n+import javax.persistence.SequenceGenerator;\n+\n+import com.sequenceiq.cloudbreak.domain.stack.instance.InstanceGroup;\n+\n+@Entity\n+public class TargetGroup implements ProvisionEntity {\n+    @Id\n+    @GeneratedValue(strategy = GenerationType.AUTO, generator = \"targetgroup_generator\")\n+    @SequenceGenerator(name = \"targetgroup_generator\", sequenceName = \"targetgroup_id_seq\", allocationSize = 1)\n+    private Long id;\n+\n+    private String type;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDUwMTE2MQ=="}, "originalCommit": {"oid": "91252020ce85e0bf097c4fcba5073697e46aa7e7"}, "originalPosition": 24}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM1MzU3OTAxOnYy", "diffSide": "RIGHT", "path": "core-model/src/main/java/com/sequenceiq/cloudbreak/domain/stack/loadbalancer/LoadBalancer.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMlQyMTo0NDo0NVrOH9vZSA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wM1QxODowMToxM1rOH-p13w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDUwMTcwNA==", "bodyText": "The LoadBalancerType enum could be used here and the values of the field would be more straightforward. CB has an enum converter logic which handles the conversion from enum to string and vice versa.\nAn example could be: com.sequenceiq.environment.parameters.dao.converter.CredentialTypeConverter", "url": "https://github.com/hortonworks/cloudbreak/pull/9475#discussion_r534501704", "createdAt": "2020-12-02T21:44:45Z", "author": {"login": "biharitomi"}, "path": "core-model/src/main/java/com/sequenceiq/cloudbreak/domain/stack/loadbalancer/LoadBalancer.java", "diffHunk": "@@ -0,0 +1,111 @@\n+package com.sequenceiq.cloudbreak.domain.stack.loadbalancer;\n+\n+import java.util.HashSet;\n+import java.util.Set;\n+\n+import javax.persistence.CascadeType;\n+import javax.persistence.Entity;\n+import javax.persistence.GeneratedValue;\n+import javax.persistence.GenerationType;\n+import javax.persistence.Id;\n+import javax.persistence.ManyToOne;\n+import javax.persistence.OneToMany;\n+import javax.persistence.SequenceGenerator;\n+\n+import com.sequenceiq.cloudbreak.domain.ProvisionEntity;\n+import com.sequenceiq.cloudbreak.domain.stack.Stack;\n+\n+@Entity\n+public class LoadBalancer implements ProvisionEntity  {\n+    @Id\n+    @GeneratedValue(strategy = GenerationType.AUTO, generator = \"loadbalancer_generator\")\n+    @SequenceGenerator(name = \"loadbalancer_generator\", sequenceName = \"loadbalancer_id_seq\", allocationSize = 1)\n+    private Long id;\n+\n+    @ManyToOne\n+    private Stack stack;\n+\n+    private String dns;\n+\n+    private String hostedZoneId;\n+\n+    private String ip;\n+\n+    private String type;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "91252020ce85e0bf097c4fcba5073697e46aa7e7"}, "originalPosition": 34}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTQ1OTI5NQ==", "bodyText": "Done", "url": "https://github.com/hortonworks/cloudbreak/pull/9475#discussion_r535459295", "createdAt": "2020-12-03T18:01:13Z", "author": {"login": "hreeve-cloudera"}, "path": "core-model/src/main/java/com/sequenceiq/cloudbreak/domain/stack/loadbalancer/LoadBalancer.java", "diffHunk": "@@ -0,0 +1,111 @@\n+package com.sequenceiq.cloudbreak.domain.stack.loadbalancer;\n+\n+import java.util.HashSet;\n+import java.util.Set;\n+\n+import javax.persistence.CascadeType;\n+import javax.persistence.Entity;\n+import javax.persistence.GeneratedValue;\n+import javax.persistence.GenerationType;\n+import javax.persistence.Id;\n+import javax.persistence.ManyToOne;\n+import javax.persistence.OneToMany;\n+import javax.persistence.SequenceGenerator;\n+\n+import com.sequenceiq.cloudbreak.domain.ProvisionEntity;\n+import com.sequenceiq.cloudbreak.domain.stack.Stack;\n+\n+@Entity\n+public class LoadBalancer implements ProvisionEntity  {\n+    @Id\n+    @GeneratedValue(strategy = GenerationType.AUTO, generator = \"loadbalancer_generator\")\n+    @SequenceGenerator(name = \"loadbalancer_generator\", sequenceName = \"loadbalancer_id_seq\", allocationSize = 1)\n+    private Long id;\n+\n+    @ManyToOne\n+    private Stack stack;\n+\n+    private String dns;\n+\n+    private String hostedZoneId;\n+\n+    private String ip;\n+\n+    private String type;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDUwMTcwNA=="}, "originalCommit": {"oid": "91252020ce85e0bf097c4fcba5073697e46aa7e7"}, "originalPosition": 34}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM1MzYyODczOnYy", "diffSide": "RIGHT", "path": "core/src/main/java/com/sequenceiq/cloudbreak/service/LoadBalancerConfigService.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMlQyMTo1ODozMVrOH9v25g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wM1QxODowMTowNFrOH-p1jw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDUwOTI4Ng==", "bodyText": "Instead of this call and the next lambda filter the com.sequenceiq.cloudbreak.cmtemplate.CmTemplateProcessor#getHostGroupsWithComponent method could be used.", "url": "https://github.com/hortonworks/cloudbreak/pull/9475#discussion_r534509286", "createdAt": "2020-12-02T21:58:31Z", "author": {"login": "biharitomi"}, "path": "core/src/main/java/com/sequenceiq/cloudbreak/service/LoadBalancerConfigService.java", "diffHunk": "@@ -0,0 +1,86 @@\n+package com.sequenceiq.cloudbreak.service;\n+\n+import com.sequenceiq.cloudbreak.domain.stack.loadbalancer.TargetGroup;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.stereotype.Service;\n+\n+import com.sequenceiq.cloudbreak.cmtemplate.CmTemplateProcessor;\n+import com.sequenceiq.cloudbreak.cmtemplate.configproviders.knox.KnoxRoles;\n+import com.sequenceiq.cloudbreak.domain.stack.Stack;\n+import com.sequenceiq.cloudbreak.domain.stack.cluster.Cluster;\n+import com.sequenceiq.cloudbreak.domain.stack.instance.InstanceGroup;\n+import com.sequenceiq.cloudbreak.template.model.ServiceComponent;\n+import com.sequenceiq.common.api.type.InstanceGroupType;\n+import com.sequenceiq.common.api.type.LoadBalancerType;\n+\n+@Service\n+public class LoadBalancerConfigService {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(LoadBalancerConfigService.class);\n+\n+    private static final String ENDPOINT_SUFFIX = \"gateway\";\n+\n+    private static final String PUBLIC_SUFFIX = \"external\";\n+\n+    private static final Set<Integer> DEFAULT_KNOX_PORTS = Set.of(443);\n+\n+    public Set<String> getKnoxGatewayGroups(Stack stack) {\n+        LOGGER.info(\"Fetching list of instance groups with Knox gateway installed\");\n+        Set<String> groupNames = new HashSet<>();\n+        Cluster cluster = stack.getCluster();\n+        if (cluster != null) {\n+            CmTemplateProcessor cmTemplateProcessor = new CmTemplateProcessor(cluster.getBlueprint().getBlueprintText());\n+            Map<String, Set<ServiceComponent>> componentByHostGroup = cmTemplateProcessor.getServiceComponentsByHostGroup();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "91252020ce85e0bf097c4fcba5073697e46aa7e7"}, "originalPosition": 40}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTQ1OTIxNQ==", "bodyText": "Well that's much easier. :)", "url": "https://github.com/hortonworks/cloudbreak/pull/9475#discussion_r535459215", "createdAt": "2020-12-03T18:01:04Z", "author": {"login": "hreeve-cloudera"}, "path": "core/src/main/java/com/sequenceiq/cloudbreak/service/LoadBalancerConfigService.java", "diffHunk": "@@ -0,0 +1,86 @@\n+package com.sequenceiq.cloudbreak.service;\n+\n+import com.sequenceiq.cloudbreak.domain.stack.loadbalancer.TargetGroup;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.stereotype.Service;\n+\n+import com.sequenceiq.cloudbreak.cmtemplate.CmTemplateProcessor;\n+import com.sequenceiq.cloudbreak.cmtemplate.configproviders.knox.KnoxRoles;\n+import com.sequenceiq.cloudbreak.domain.stack.Stack;\n+import com.sequenceiq.cloudbreak.domain.stack.cluster.Cluster;\n+import com.sequenceiq.cloudbreak.domain.stack.instance.InstanceGroup;\n+import com.sequenceiq.cloudbreak.template.model.ServiceComponent;\n+import com.sequenceiq.common.api.type.InstanceGroupType;\n+import com.sequenceiq.common.api.type.LoadBalancerType;\n+\n+@Service\n+public class LoadBalancerConfigService {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(LoadBalancerConfigService.class);\n+\n+    private static final String ENDPOINT_SUFFIX = \"gateway\";\n+\n+    private static final String PUBLIC_SUFFIX = \"external\";\n+\n+    private static final Set<Integer> DEFAULT_KNOX_PORTS = Set.of(443);\n+\n+    public Set<String> getKnoxGatewayGroups(Stack stack) {\n+        LOGGER.info(\"Fetching list of instance groups with Knox gateway installed\");\n+        Set<String> groupNames = new HashSet<>();\n+        Cluster cluster = stack.getCluster();\n+        if (cluster != null) {\n+            CmTemplateProcessor cmTemplateProcessor = new CmTemplateProcessor(cluster.getBlueprint().getBlueprintText());\n+            Map<String, Set<ServiceComponent>> componentByHostGroup = cmTemplateProcessor.getServiceComponentsByHostGroup();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDUwOTI4Ng=="}, "originalCommit": {"oid": "91252020ce85e0bf097c4fcba5073697e46aa7e7"}, "originalPosition": 40}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM1MzYzOTQ5OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/com/sequenceiq/cloudbreak/service/publicendpoint/GatewayPublicEndpointManagementService.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMlQyMjowMToxM1rOH9v9ZA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wM1QxODowMDo1NVrOH-p1Kg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDUxMDk0OA==", "bodyText": "Using if-else instead of if-continue?", "url": "https://github.com/hortonworks/cloudbreak/pull/9475#discussion_r534510948", "createdAt": "2020-12-02T22:01:13Z", "author": {"login": "biharitomi"}, "path": "core/src/main/java/com/sequenceiq/cloudbreak/service/publicendpoint/GatewayPublicEndpointManagementService.java", "diffHunk": "@@ -92,6 +101,41 @@ public String updateDnsEntry(Stack stack, String gatewayIp) {\n         return null;\n     }\n \n+    public void updateDnsEntryForLoadBalancers(Stack stack) {\n+        Set<LoadBalancer> loadBalancers = loadBalancerPersistenceService.findByStackId(stack.getId());\n+        if (loadBalancers.isEmpty()) {\n+            LOGGER.info(\"No load balancers in stack {}\", stack.getId());\n+            return;\n+        }\n+\n+        LOGGER.info(\"Update load balancer DNS entries\");\n+        String userCrn = ThreadBasedUserCrnProvider.getUserCrn();\n+        String accountId = ThreadBasedUserCrnProvider.getAccountId();\n+        DetailedEnvironmentResponse environment = environmentClientService.getByCrn(stack.getEnvironmentCrn());\n+\n+        for (LoadBalancer loadBalancer : loadBalancers) {\n+            Optional<String> endpoint = Optional.ofNullable(loadBalancer.getEndpoint());\n+            if (endpoint.isEmpty()) {\n+                LOGGER.error(\"No endpoint set for load balancer. Can't register domain.\");\n+                continue;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "91252020ce85e0bf097c4fcba5073697e46aa7e7"}, "originalPosition": 63}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTQ1OTExNA==", "bodyText": "Done", "url": "https://github.com/hortonworks/cloudbreak/pull/9475#discussion_r535459114", "createdAt": "2020-12-03T18:00:55Z", "author": {"login": "hreeve-cloudera"}, "path": "core/src/main/java/com/sequenceiq/cloudbreak/service/publicendpoint/GatewayPublicEndpointManagementService.java", "diffHunk": "@@ -92,6 +101,41 @@ public String updateDnsEntry(Stack stack, String gatewayIp) {\n         return null;\n     }\n \n+    public void updateDnsEntryForLoadBalancers(Stack stack) {\n+        Set<LoadBalancer> loadBalancers = loadBalancerPersistenceService.findByStackId(stack.getId());\n+        if (loadBalancers.isEmpty()) {\n+            LOGGER.info(\"No load balancers in stack {}\", stack.getId());\n+            return;\n+        }\n+\n+        LOGGER.info(\"Update load balancer DNS entries\");\n+        String userCrn = ThreadBasedUserCrnProvider.getUserCrn();\n+        String accountId = ThreadBasedUserCrnProvider.getAccountId();\n+        DetailedEnvironmentResponse environment = environmentClientService.getByCrn(stack.getEnvironmentCrn());\n+\n+        for (LoadBalancer loadBalancer : loadBalancers) {\n+            Optional<String> endpoint = Optional.ofNullable(loadBalancer.getEndpoint());\n+            if (endpoint.isEmpty()) {\n+                LOGGER.error(\"No endpoint set for load balancer. Can't register domain.\");\n+                continue;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDUxMDk0OA=="}, "originalCommit": {"oid": "91252020ce85e0bf097c4fcba5073697e46aa7e7"}, "originalPosition": 63}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM1MzY0ODM0OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/com/sequenceiq/cloudbreak/service/publicendpoint/dns/BaseDnsEntryService.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMlQyMjowNDowMVrOH9wC7Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMlQyMjowNDowMVrOH9wC7Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDUxMjM2NQ==", "bodyText": "No, https://github.com/hortonworks/cloudbreak/pull/9475/files#diff-7d0c14c28466a6ed89a04d3cc0a6c5973f30325dab017a4093173af0145e77dbR35 will do the job.", "url": "https://github.com/hortonworks/cloudbreak/pull/9475#discussion_r534512365", "createdAt": "2020-12-02T22:04:01Z", "author": {"login": "biharitomi"}, "path": "core/src/main/java/com/sequenceiq/cloudbreak/service/publicendpoint/dns/BaseDnsEntryService.java", "diffHunk": "@@ -101,6 +101,7 @@\n         String accountId = ThreadBasedUserCrnProvider.getAccountId();\n         DetailedEnvironmentResponse environment = environmentClientService.getByCrn(environmentCrn);\n \n+        // TODO do we need to deregister the load balancer DNS here as well?", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "91252020ce85e0bf097c4fcba5073697e46aa7e7"}, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM1NTgzODI4OnYy", "diffSide": "RIGHT", "path": "core/src/main/resources/schema/app/20201103154306_CB-9366_Create_load_balancer_metadata_table.sql", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wM1QwODowNDo0NlrOH-Fvug==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wM1QxODowMDo0NVrOH-p0uw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDg2Nzg5OA==", "bodyText": "Just would like to add some notes about the unwritten convention that is mostly used by our team in case of SQL scripts, this SQL script is fine for me.\nYou could save the time of sequence creator SQLs with using name convention and bigserial as type of id. In this case the DROP TABLE should also cleanup the sequence too. For example:\n\ncredential table\ncredential id sequence name\n\nOn the other hand we prefer SQL statements with IF EXISTS or IF NOT EXISTS conditions in place where it is applicable, that makes the SQL scripts more bullet proof.", "url": "https://github.com/hortonworks/cloudbreak/pull/9475#discussion_r534867898", "createdAt": "2020-12-03T08:04:46Z", "author": {"login": "biharitomi"}, "path": "core/src/main/resources/schema/app/20201103154306_CB-9366_Create_load_balancer_metadata_table.sql", "diffHunk": "@@ -0,0 +1,62 @@\n+-- // CB-9366 Create load balancer metadata table\n+-- Migration SQL that makes the change goes here.\n+\n+CREATE SEQUENCE loadbalancer_id_seq START WITH 1", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "91252020ce85e0bf097c4fcba5073697e46aa7e7"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTQ1OTAwMw==", "bodyText": "I've revamped the SQL script using your example, and added IF EXISTS or IF NOT EXISTS checks to everything. Let me know if it looks okay.", "url": "https://github.com/hortonworks/cloudbreak/pull/9475#discussion_r535459003", "createdAt": "2020-12-03T18:00:45Z", "author": {"login": "hreeve-cloudera"}, "path": "core/src/main/resources/schema/app/20201103154306_CB-9366_Create_load_balancer_metadata_table.sql", "diffHunk": "@@ -0,0 +1,62 @@\n+-- // CB-9366 Create load balancer metadata table\n+-- Migration SQL that makes the change goes here.\n+\n+CREATE SEQUENCE loadbalancer_id_seq START WITH 1", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDg2Nzg5OA=="}, "originalCommit": {"oid": "91252020ce85e0bf097c4fcba5073697e46aa7e7"}, "originalPosition": 4}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3490, "cost": 1, "resetAt": "2021-11-12T20:44:06Z"}}}