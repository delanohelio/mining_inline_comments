{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDI3MjY5Mzc1", "number": 8200, "title": "CB-6637 Internal API for Salt upgrade testing", "bodyText": "CLI: hortonworks/cb-cli#747", "createdAt": "2020-06-03T15:11:53Z", "url": "https://github.com/hortonworks/cloudbreak/pull/8200", "merged": true, "mergeCommit": {"oid": "22d71b5f84a6ac981c4b34871550b6258c51f3b3"}, "closed": true, "closedAt": "2020-06-05T18:25:56Z", "author": {"login": "lacikaaa"}, "timelineItems": {"totalCount": 11, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcoO4teAFqTQyNTEyNDAwNg==", "endCursor": "Y3Vyc29yOnYyOpPPAAABcoT2nLABqjM0MTE3MDQxMzA=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI1MTI0MDA2", "url": "https://github.com/hortonworks/cloudbreak/pull/8200#pullrequestreview-425124006", "createdAt": "2020-06-05T09:03:40Z", "commit": {"oid": "0b841b27b9ef62246c17d217b595605cfc92f35f"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQwOTowMzo0MFrOGfmaTQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQwOTowMzo0MFrOGfmaTQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTc4ODM2NQ==", "bodyText": "the component creation is duplicated for save and update", "url": "https://github.com/hortonworks/cloudbreak/pull/8200#discussion_r435788365", "createdAt": "2020-06-05T09:03:40Z", "author": {"login": "keyki"}, "path": "core/src/main/java/com/sequenceiq/cloudbreak/core/bootstrap/service/ClusterBootstrapper.java", "diffHunk": "@@ -106,21 +103,117 @@\n \n     public void bootstrapMachines(Long stackId) throws CloudbreakException {\n         Stack stack = stackService.getByIdWithListsInTransaction(stackId);\n-        String stackOrchestratorType = stack.getOrchestrator().getType();\n-        OrchestratorType orchestratorType = orchestratorTypeResolver.resolveType(stackOrchestratorType);\n+        bootstrapOnHost(stack);\n+    }\n \n-        if (orchestratorType.hostOrchestrator()) {\n-            bootstrapOnHost(stack);\n-        } else if (orchestratorType.containerOrchestrator()) {\n-            LOGGER.debug(\"Skipping bootstrap of the machines because the stack's orchestrator type is '{}'.\", stackOrchestratorType);\n-        } else {\n-            LOGGER.error(\"Orchestrator not found: {}\", stackOrchestratorType);\n-            throw new CloudbreakException(\"HostOrchestrator not found: \" + stackOrchestratorType);\n-        }\n+    public void reBootstrapMachines(Long stackId) throws CloudbreakException {\n+        Stack stack = stackService.getByIdWithListsInTransaction(stackId);\n+        LOGGER.info(\"ReBootstrapMachines for stack [{}] [{}]\", stack.getName(), stack.getResourceCrn());\n+        reBootstrapOnHost(stack);\n     }\n \n     @SuppressFBWarnings(\"REC_CATCH_EXCEPTION\")\n     public void bootstrapOnHost(Stack stack) throws CloudbreakException {\n+        Set<Node> nodes = collectNodesForBootstrap(stack);\n+        try {\n+            List<GatewayConfig> allGatewayConfig = collectAndCheckGateways(stack);\n+\n+            saveSaltComponent(stack);\n+\n+            BootstrapParams params = createBootstrapParams(stack);\n+            hostOrchestrator.bootstrap(allGatewayConfig, nodes, params, clusterDeletionBasedModel(stack.getId(), null));\n+\n+            InstanceMetaData primaryGateway = stack.getPrimaryGatewayInstance();\n+            saveOrchestrator(stack, primaryGateway);\n+            checkIfAllNodesAvailable(stack, nodes, primaryGateway);\n+        } catch (Exception e) {\n+            throw new CloudbreakException(e);\n+        }\n+    }\n+\n+    public void reBootstrapOnHost(Stack stack) throws CloudbreakException {\n+        Set<Node> nodes = collectNodesForBootstrap(stack);\n+        try {\n+            List<GatewayConfig> allGatewayConfig = collectAndCheckGateways(stack);\n+\n+            updateSaltComponent(stack);\n+\n+            BootstrapParams params = createBootstrapParams(stack);\n+            hostOrchestrator.bootstrap(allGatewayConfig, nodes, params, clusterDeletionBasedModel(stack.getId(), null));\n+\n+            InstanceMetaData primaryGateway = stack.getPrimaryGatewayInstance();\n+            checkIfAllNodesAvailable(stack, nodes, primaryGateway);\n+        } catch (Exception e) {\n+            throw new CloudbreakException(e);\n+        }\n+    }\n+\n+    private void checkIfAllNodesAvailable(Stack stack, Set<Node> nodes, InstanceMetaData primaryGateway) throws CloudbreakOrchestratorFailedException {\n+        GatewayConfig gatewayConfig = gatewayConfigService.getGatewayConfig(stack, primaryGateway, isKnoxEnabled(stack));\n+        PollingResult allNodesAvailabilityPolling = hostClusterAvailabilityPollingService.pollWithTimeoutSingleFailure(\n+                hostClusterAvailabilityCheckerTask, new HostOrchestratorClusterContext(stack, hostOrchestrator, gatewayConfig, nodes),\n+                POLL_INTERVAL, MAX_POLLING_ATTEMPTS);\n+        validatePollingResultForCancellation(allNodesAvailabilityPolling, \"Polling of all nodes availability was cancelled.\");\n+        if (TIMEOUT.equals(allNodesAvailabilityPolling)) {\n+            clusterBootstrapperErrorHandler.terminateFailedNodes(hostOrchestrator, null, stack, gatewayConfig, nodes);\n+        }\n+    }\n+\n+    private void saveSaltComponent(Stack stack) throws IOException {\n+        ClusterComponent saltComponent = clusterComponentProvider.getComponent(stack.getCluster().getId(), ComponentType.SALT_STATE);\n+        if (saltComponent == null) {\n+            byte[] stateConfigZip = hostOrchestrator.getStateConfigZip();\n+            saltComponent = new ClusterComponent(ComponentType.SALT_STATE,\n+                    new Json(singletonMap(ComponentType.SALT_STATE.name(), Base64.encodeBase64String(stateConfigZip))), stack.getCluster());\n+            clusterComponentProvider.store(saltComponent);\n+        }\n+    }\n+\n+    private void updateSaltComponent(Stack stack) throws IOException {\n+        ClusterComponent saltComponent = clusterComponentProvider.getComponent(stack.getCluster().getId(), ComponentType.SALT_STATE);\n+        byte[] stateConfigZip = hostOrchestrator.getStateConfigZip();\n+        if (saltComponent == null) {\n+            saltComponent = new ClusterComponent(ComponentType.SALT_STATE,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0b841b27b9ef62246c17d217b595605cfc92f35f"}, "originalPosition": 130}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI1MTI1NzEw", "url": "https://github.com/hortonworks/cloudbreak/pull/8200#pullrequestreview-425125710", "createdAt": "2020-06-05T09:06:12Z", "commit": {"oid": "0b841b27b9ef62246c17d217b595605cfc92f35f"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQwOTowNjoxMlrOGfmfpg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQwOTowNjoxMlrOGfmfpg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTc4OTczNA==", "bodyText": "bootstrap and reBootstrap are almost the same except for the save and update. Can this be refactored  to a common method?", "url": "https://github.com/hortonworks/cloudbreak/pull/8200#discussion_r435789734", "createdAt": "2020-06-05T09:06:12Z", "author": {"login": "keyki"}, "path": "core/src/main/java/com/sequenceiq/cloudbreak/core/bootstrap/service/ClusterBootstrapper.java", "diffHunk": "@@ -106,21 +103,117 @@\n \n     public void bootstrapMachines(Long stackId) throws CloudbreakException {\n         Stack stack = stackService.getByIdWithListsInTransaction(stackId);\n-        String stackOrchestratorType = stack.getOrchestrator().getType();\n-        OrchestratorType orchestratorType = orchestratorTypeResolver.resolveType(stackOrchestratorType);\n+        bootstrapOnHost(stack);\n+    }\n \n-        if (orchestratorType.hostOrchestrator()) {\n-            bootstrapOnHost(stack);\n-        } else if (orchestratorType.containerOrchestrator()) {\n-            LOGGER.debug(\"Skipping bootstrap of the machines because the stack's orchestrator type is '{}'.\", stackOrchestratorType);\n-        } else {\n-            LOGGER.error(\"Orchestrator not found: {}\", stackOrchestratorType);\n-            throw new CloudbreakException(\"HostOrchestrator not found: \" + stackOrchestratorType);\n-        }\n+    public void reBootstrapMachines(Long stackId) throws CloudbreakException {\n+        Stack stack = stackService.getByIdWithListsInTransaction(stackId);\n+        LOGGER.info(\"ReBootstrapMachines for stack [{}] [{}]\", stack.getName(), stack.getResourceCrn());\n+        reBootstrapOnHost(stack);\n     }\n \n     @SuppressFBWarnings(\"REC_CATCH_EXCEPTION\")\n     public void bootstrapOnHost(Stack stack) throws CloudbreakException {\n+        Set<Node> nodes = collectNodesForBootstrap(stack);\n+        try {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0b841b27b9ef62246c17d217b595605cfc92f35f"}, "originalPosition": 72}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI1MTM0MDQ3", "url": "https://github.com/hortonworks/cloudbreak/pull/8200#pullrequestreview-425134047", "createdAt": "2020-06-05T09:18:02Z", "commit": {"oid": "0b841b27b9ef62246c17d217b595605cfc92f35f"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQwOToxODowM1rOGfm5JQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQwOToxODowM1rOGfm5JQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTc5NjI2MQ==", "bodyText": "Can you add Deprecated or some comment/doc to explain why it is still there? Otherwise, someone might delete it as it's not doing anything.", "url": "https://github.com/hortonworks/cloudbreak/pull/8200#discussion_r435796261", "createdAt": "2020-06-05T09:18:03Z", "author": {"login": "keyki"}, "path": "core/src/main/java/com/sequenceiq/cloudbreak/reactor/handler/orchestration/ClusterTerminationHandler.java", "diffHunk": "@@ -35,8 +31,7 @@ public void accept(Event<ClusterTerminationRequest> event) {\n         ClusterTerminationRequest request = event.getData();\n         ClusterTerminationResult result;\n         try {\n-            Boolean allowed = clusterTerminationService.deleteClusterComponents(request.getClusterId());\n-            result = new ClusterTerminationResult(request, allowed);\n+            result = new ClusterTerminationResult(request, Boolean.TRUE);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0b841b27b9ef62246c17d217b595605cfc92f35f"}, "originalPosition": 29}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI1MTQxMDE1", "url": "https://github.com/hortonworks/cloudbreak/pull/8200#pullrequestreview-425141015", "createdAt": "2020-06-05T09:27:40Z", "commit": {"oid": "0b841b27b9ef62246c17d217b595605cfc92f35f"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQwOToyNzo0MFrOGfnOPQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQwOToyNzo0MFrOGfnOPQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTgwMTY2MQ==", "bodyText": "SaltUpdateEvent not needed", "url": "https://github.com/hortonworks/cloudbreak/pull/8200#discussion_r435801661", "createdAt": "2020-06-05T09:27:40Z", "author": {"login": "keyki"}, "path": "core/src/main/java/com/sequenceiq/cloudbreak/core/flow2/cluster/salt/update/SaltUpdateFlowConfig.java", "diffHunk": "@@ -0,0 +1,75 @@\n+package com.sequenceiq.cloudbreak.core.flow2.cluster.salt.update;\n+\n+import static com.sequenceiq.cloudbreak.core.flow2.cluster.salt.update.SaltUpdateEvent.BOOTSTRAP_MACHINES_FAILED_EVENT;\n+import static com.sequenceiq.cloudbreak.core.flow2.cluster.salt.update.SaltUpdateEvent.BOOTSTRAP_MACHINES_FINISHED_EVENT;\n+import static com.sequenceiq.cloudbreak.core.flow2.cluster.salt.update.SaltUpdateEvent.CONFIGURE_KEYTABS_FAILED_EVENT;\n+import static com.sequenceiq.cloudbreak.core.flow2.cluster.salt.update.SaltUpdateEvent.CONFIGURE_KEYTABS_FINISHED_EVENT;\n+import static com.sequenceiq.cloudbreak.core.flow2.cluster.salt.update.SaltUpdateEvent.SALT_UPDATE_EVENT;\n+import static com.sequenceiq.cloudbreak.core.flow2.cluster.salt.update.SaltUpdateEvent.SALT_UPDATE_FAILED_EVENT;\n+import static com.sequenceiq.cloudbreak.core.flow2.cluster.salt.update.SaltUpdateEvent.SALT_UPDATE_FAILURE_HANDLED_EVENT;\n+import static com.sequenceiq.cloudbreak.core.flow2.cluster.salt.update.SaltUpdateEvent.SALT_UPDATE_FINISHED_EVENT;\n+import static com.sequenceiq.cloudbreak.core.flow2.cluster.salt.update.SaltUpdateEvent.START_AMBARI_SERVICES_FAILED_EVENT;\n+import static com.sequenceiq.cloudbreak.core.flow2.cluster.salt.update.SaltUpdateEvent.START_AMBARI_SERVICES_FINISHED_EVENT;\n+import static com.sequenceiq.cloudbreak.core.flow2.cluster.salt.update.SaltUpdateEvent.UPLOAD_RECIPES_FAILED_EVENT;\n+import static com.sequenceiq.cloudbreak.core.flow2.cluster.salt.update.SaltUpdateEvent.UPLOAD_RECIPES_FINISHED_EVENT;\n+import static com.sequenceiq.cloudbreak.core.flow2.cluster.salt.update.SaltUpdateState.RECONFIGURE_KEYTABS_FOR_SU_STATE;\n+import static com.sequenceiq.cloudbreak.core.flow2.cluster.salt.update.SaltUpdateState.FINAL_STATE;\n+import static com.sequenceiq.cloudbreak.core.flow2.cluster.salt.update.SaltUpdateState.INIT_STATE;\n+import static com.sequenceiq.cloudbreak.core.flow2.cluster.salt.update.SaltUpdateState.RUN_HIGHSTATE_STATE;\n+import static com.sequenceiq.cloudbreak.core.flow2.cluster.salt.update.SaltUpdateState.SALT_UPDATE_FAILED_STATE;\n+import static com.sequenceiq.cloudbreak.core.flow2.cluster.salt.update.SaltUpdateState.SALT_UPDATE_FINISHED_STATE;\n+import static com.sequenceiq.cloudbreak.core.flow2.cluster.salt.update.SaltUpdateState.UPDATE_SALT_STATE_FILES_STATE;\n+import static com.sequenceiq.cloudbreak.core.flow2.cluster.salt.update.SaltUpdateState.UPLOAD_RECIPES_FOR_SU_STATE;\n+\n+import java.util.List;\n+\n+import org.springframework.stereotype.Component;\n+\n+import com.sequenceiq.flow.core.config.AbstractFlowConfiguration;\n+import com.sequenceiq.flow.core.config.AbstractFlowConfiguration.Transition.Builder;\n+\n+@Component\n+public class SaltUpdateFlowConfig extends AbstractFlowConfiguration<SaltUpdateState, SaltUpdateEvent> {\n+\n+    private static final List<Transition<SaltUpdateState, SaltUpdateEvent>> TRANSITIONS =\n+            new Builder<SaltUpdateState, SaltUpdateEvent>().defaultFailureEvent(SALT_UPDATE_FAILED_EVENT)\n+            .from(INIT_STATE).to(UPDATE_SALT_STATE_FILES_STATE).event(SALT_UPDATE_EVENT).defaultFailureEvent()\n+            .from(UPDATE_SALT_STATE_FILES_STATE).to(UPLOAD_RECIPES_FOR_SU_STATE).event(BOOTSTRAP_MACHINES_FINISHED_EVENT)\n+                    .failureEvent(BOOTSTRAP_MACHINES_FAILED_EVENT)\n+            .from(UPLOAD_RECIPES_FOR_SU_STATE).to(RECONFIGURE_KEYTABS_FOR_SU_STATE).event(UPLOAD_RECIPES_FINISHED_EVENT)\n+                    .failureEvent(UPLOAD_RECIPES_FAILED_EVENT)\n+            .from(RECONFIGURE_KEYTABS_FOR_SU_STATE).to(RUN_HIGHSTATE_STATE).event(CONFIGURE_KEYTABS_FINISHED_EVENT).failureEvent(CONFIGURE_KEYTABS_FAILED_EVENT)\n+            .from(RUN_HIGHSTATE_STATE).to(SALT_UPDATE_FINISHED_STATE).event(START_AMBARI_SERVICES_FINISHED_EVENT)\n+                    .failureEvent(START_AMBARI_SERVICES_FAILED_EVENT)\n+            .from(SALT_UPDATE_FINISHED_STATE).to(FINAL_STATE).event(SALT_UPDATE_FINISHED_EVENT).noFailureEvent()\n+            .build();\n+\n+    public SaltUpdateFlowConfig() {\n+        super(SaltUpdateState.class, SaltUpdateEvent.class);\n+    }\n+\n+    @Override\n+    protected List<Transition<SaltUpdateState, SaltUpdateEvent>> getTransitions() {\n+        return TRANSITIONS;\n+    }\n+\n+    @Override\n+    protected FlowEdgeConfig<SaltUpdateState, SaltUpdateEvent> getEdgeConfig() {\n+        return new FlowEdgeConfig<>(INIT_STATE, FINAL_STATE, SALT_UPDATE_FAILED_STATE, SALT_UPDATE_FAILURE_HANDLED_EVENT);\n+    }\n+\n+    @Override\n+    public SaltUpdateEvent[] getEvents() {\n+        return SaltUpdateEvent.values();\n+    }\n+\n+    @Override\n+    public SaltUpdateEvent[] getInitEvents() {\n+        return new SaltUpdateEvent[]{SaltUpdateEvent.SALT_UPDATE_EVENT};", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0b841b27b9ef62246c17d217b595605cfc92f35f"}, "originalPosition": 68}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI1MTQyNjk1", "url": "https://github.com/hortonworks/cloudbreak/pull/8200#pullrequestreview-425142695", "createdAt": "2020-06-05T09:30:06Z", "commit": {"oid": "0b841b27b9ef62246c17d217b595605cfc92f35f"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQwOTozMDowNlrOGfnTNg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQwOTozMDowNlrOGfnTNg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTgwMjkzNA==", "bodyText": "Duplication from ClusterCreationService", "url": "https://github.com/hortonworks/cloudbreak/pull/8200#discussion_r435802934", "createdAt": "2020-06-05T09:30:06Z", "author": {"login": "keyki"}, "path": "core/src/main/java/com/sequenceiq/cloudbreak/core/flow2/cluster/salt/update/SaltUpdateService.java", "diffHunk": "@@ -0,0 +1,85 @@\n+package com.sequenceiq.cloudbreak.core.flow2.cluster.salt.update;\n+\n+import static com.sequenceiq.cloudbreak.api.endpoint.v4.common.Status.AVAILABLE;\n+import static com.sequenceiq.cloudbreak.api.endpoint.v4.common.Status.CREATE_FAILED;\n+import static com.sequenceiq.cloudbreak.api.endpoint.v4.common.Status.UPDATE_IN_PROGRESS;\n+import static com.sequenceiq.cloudbreak.event.ResourceEvent.CLUSTER_BUILT;\n+import static com.sequenceiq.cloudbreak.event.ResourceEvent.CLUSTER_CREATE_FAILED;\n+import static com.sequenceiq.cloudbreak.event.ResourceEvent.CLUSTER_RUN_SERVICES;\n+import static com.sequenceiq.cloudbreak.event.ResourceEvent.STACK_INFRASTRUCTURE_BOOTSTRAP;\n+\n+import javax.inject.Inject;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.stereotype.Component;\n+\n+import com.sequenceiq.cloudbreak.api.endpoint.v4.common.DetailedStackStatus;\n+import com.sequenceiq.cloudbreak.common.service.TransactionService;\n+import com.sequenceiq.cloudbreak.common.service.TransactionService.TransactionExecutionException;\n+import com.sequenceiq.cloudbreak.common.service.TransactionService.TransactionRuntimeExecutionException;\n+import com.sequenceiq.cloudbreak.core.flow2.stack.CloudbreakFlowMessageService;\n+import com.sequenceiq.cloudbreak.domain.stack.Stack;\n+import com.sequenceiq.cloudbreak.domain.view.StackView;\n+import com.sequenceiq.cloudbreak.service.CloudbreakException;\n+import com.sequenceiq.cloudbreak.service.StackUpdater;\n+import com.sequenceiq.cloudbreak.service.cluster.ClusterService;\n+\n+@Component\n+public class SaltUpdateService {\n+    private static final Logger LOGGER = LoggerFactory.getLogger(SaltUpdateService.class);\n+\n+    @Inject\n+    private StackUpdater stackUpdater;\n+\n+    @Inject\n+    private CloudbreakFlowMessageService flowMessageService;\n+\n+    @Inject\n+    private ClusterService clusterService;\n+\n+    @Inject\n+    private TransactionService transactionService;\n+\n+    public void bootstrappingMachines(Stack stack) {\n+        stackUpdater.updateStackStatus(stack.getId(), DetailedStackStatus.BOOTSTRAPPING_MACHINES);\n+        flowMessageService.fireEventAndLog(stack.getId(), UPDATE_IN_PROGRESS.name(), STACK_INFRASTRUCTURE_BOOTSTRAP);\n+    }\n+\n+    public void startingClusterServices(StackView stack) {\n+        stackUpdater.updateStackStatus(stack.getId(), DetailedStackStatus.STARTING_CLUSTER_MANAGER_SERVICES, \"Running cluster services.\");\n+        flowMessageService.fireEventAndLog(stack.getId(), UPDATE_IN_PROGRESS.name(), CLUSTER_RUN_SERVICES);\n+    }\n+\n+    public void clusterInstallationFinished(StackView stackView) {\n+        try {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0b841b27b9ef62246c17d217b595605cfc92f35f"}, "originalPosition": 55}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI1MTQyOTM2", "url": "https://github.com/hortonworks/cloudbreak/pull/8200#pullrequestreview-425142936", "createdAt": "2020-06-05T09:30:29Z", "commit": {"oid": "0b841b27b9ef62246c17d217b595605cfc92f35f"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQwOTozMDoyOVrOGfnUAw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQwOTozMDoyOVrOGfnUAw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTgwMzEzOQ==", "bodyText": "Duplication from ClusterCreationService", "url": "https://github.com/hortonworks/cloudbreak/pull/8200#discussion_r435803139", "createdAt": "2020-06-05T09:30:29Z", "author": {"login": "keyki"}, "path": "core/src/main/java/com/sequenceiq/cloudbreak/core/flow2/cluster/salt/update/SaltUpdateService.java", "diffHunk": "@@ -0,0 +1,85 @@\n+package com.sequenceiq.cloudbreak.core.flow2.cluster.salt.update;\n+\n+import static com.sequenceiq.cloudbreak.api.endpoint.v4.common.Status.AVAILABLE;\n+import static com.sequenceiq.cloudbreak.api.endpoint.v4.common.Status.CREATE_FAILED;\n+import static com.sequenceiq.cloudbreak.api.endpoint.v4.common.Status.UPDATE_IN_PROGRESS;\n+import static com.sequenceiq.cloudbreak.event.ResourceEvent.CLUSTER_BUILT;\n+import static com.sequenceiq.cloudbreak.event.ResourceEvent.CLUSTER_CREATE_FAILED;\n+import static com.sequenceiq.cloudbreak.event.ResourceEvent.CLUSTER_RUN_SERVICES;\n+import static com.sequenceiq.cloudbreak.event.ResourceEvent.STACK_INFRASTRUCTURE_BOOTSTRAP;\n+\n+import javax.inject.Inject;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.stereotype.Component;\n+\n+import com.sequenceiq.cloudbreak.api.endpoint.v4.common.DetailedStackStatus;\n+import com.sequenceiq.cloudbreak.common.service.TransactionService;\n+import com.sequenceiq.cloudbreak.common.service.TransactionService.TransactionExecutionException;\n+import com.sequenceiq.cloudbreak.common.service.TransactionService.TransactionRuntimeExecutionException;\n+import com.sequenceiq.cloudbreak.core.flow2.stack.CloudbreakFlowMessageService;\n+import com.sequenceiq.cloudbreak.domain.stack.Stack;\n+import com.sequenceiq.cloudbreak.domain.view.StackView;\n+import com.sequenceiq.cloudbreak.service.CloudbreakException;\n+import com.sequenceiq.cloudbreak.service.StackUpdater;\n+import com.sequenceiq.cloudbreak.service.cluster.ClusterService;\n+\n+@Component\n+public class SaltUpdateService {\n+    private static final Logger LOGGER = LoggerFactory.getLogger(SaltUpdateService.class);\n+\n+    @Inject\n+    private StackUpdater stackUpdater;\n+\n+    @Inject\n+    private CloudbreakFlowMessageService flowMessageService;\n+\n+    @Inject\n+    private ClusterService clusterService;\n+\n+    @Inject\n+    private TransactionService transactionService;\n+\n+    public void bootstrappingMachines(Stack stack) {\n+        stackUpdater.updateStackStatus(stack.getId(), DetailedStackStatus.BOOTSTRAPPING_MACHINES);\n+        flowMessageService.fireEventAndLog(stack.getId(), UPDATE_IN_PROGRESS.name(), STACK_INFRASTRUCTURE_BOOTSTRAP);\n+    }\n+\n+    public void startingClusterServices(StackView stack) {\n+        stackUpdater.updateStackStatus(stack.getId(), DetailedStackStatus.STARTING_CLUSTER_MANAGER_SERVICES, \"Running cluster services.\");\n+        flowMessageService.fireEventAndLog(stack.getId(), UPDATE_IN_PROGRESS.name(), CLUSTER_RUN_SERVICES);\n+    }\n+\n+    public void clusterInstallationFinished(StackView stackView) {\n+        try {\n+            transactionService.required(() -> {\n+                clusterService.updateClusterStatusByStackId(stackView.getId(), AVAILABLE);\n+                stackUpdater.updateStackStatus(stackView.getId(), DetailedStackStatus.AVAILABLE, \"Cluster creation finished.\");\n+                flowMessageService.fireEventAndLog(stackView.getId(), AVAILABLE.name(), CLUSTER_BUILT);\n+            });\n+        } catch (TransactionExecutionException e) {\n+            throw new TransactionRuntimeExecutionException(e);\n+        }\n+    }\n+\n+    public void handleClusterCreationFailure(StackView stackView, Exception exception) {\n+        if (stackView.getClusterView() != null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0b841b27b9ef62246c17d217b595605cfc92f35f"}, "originalPosition": 67}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI1MTQzNjA2", "url": "https://github.com/hortonworks/cloudbreak/pull/8200#pullrequestreview-425143606", "createdAt": "2020-06-05T09:31:26Z", "commit": {"oid": "0b841b27b9ef62246c17d217b595605cfc92f35f"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQwOTozMToyNlrOGfnWNA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQwOTozMToyNlrOGfnWNA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTgwMzcwMA==", "bodyText": "Same duplication.", "url": "https://github.com/hortonworks/cloudbreak/pull/8200#discussion_r435803700", "createdAt": "2020-06-05T09:31:26Z", "author": {"login": "keyki"}, "path": "core/src/main/java/com/sequenceiq/cloudbreak/core/flow2/cluster/salt/update/SaltUpdateService.java", "diffHunk": "@@ -0,0 +1,85 @@\n+package com.sequenceiq.cloudbreak.core.flow2.cluster.salt.update;\n+\n+import static com.sequenceiq.cloudbreak.api.endpoint.v4.common.Status.AVAILABLE;\n+import static com.sequenceiq.cloudbreak.api.endpoint.v4.common.Status.CREATE_FAILED;\n+import static com.sequenceiq.cloudbreak.api.endpoint.v4.common.Status.UPDATE_IN_PROGRESS;\n+import static com.sequenceiq.cloudbreak.event.ResourceEvent.CLUSTER_BUILT;\n+import static com.sequenceiq.cloudbreak.event.ResourceEvent.CLUSTER_CREATE_FAILED;\n+import static com.sequenceiq.cloudbreak.event.ResourceEvent.CLUSTER_RUN_SERVICES;\n+import static com.sequenceiq.cloudbreak.event.ResourceEvent.STACK_INFRASTRUCTURE_BOOTSTRAP;\n+\n+import javax.inject.Inject;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.stereotype.Component;\n+\n+import com.sequenceiq.cloudbreak.api.endpoint.v4.common.DetailedStackStatus;\n+import com.sequenceiq.cloudbreak.common.service.TransactionService;\n+import com.sequenceiq.cloudbreak.common.service.TransactionService.TransactionExecutionException;\n+import com.sequenceiq.cloudbreak.common.service.TransactionService.TransactionRuntimeExecutionException;\n+import com.sequenceiq.cloudbreak.core.flow2.stack.CloudbreakFlowMessageService;\n+import com.sequenceiq.cloudbreak.domain.stack.Stack;\n+import com.sequenceiq.cloudbreak.domain.view.StackView;\n+import com.sequenceiq.cloudbreak.service.CloudbreakException;\n+import com.sequenceiq.cloudbreak.service.StackUpdater;\n+import com.sequenceiq.cloudbreak.service.cluster.ClusterService;\n+\n+@Component\n+public class SaltUpdateService {\n+    private static final Logger LOGGER = LoggerFactory.getLogger(SaltUpdateService.class);\n+\n+    @Inject\n+    private StackUpdater stackUpdater;\n+\n+    @Inject\n+    private CloudbreakFlowMessageService flowMessageService;\n+\n+    @Inject\n+    private ClusterService clusterService;\n+\n+    @Inject\n+    private TransactionService transactionService;\n+\n+    public void bootstrappingMachines(Stack stack) {\n+        stackUpdater.updateStackStatus(stack.getId(), DetailedStackStatus.BOOTSTRAPPING_MACHINES);\n+        flowMessageService.fireEventAndLog(stack.getId(), UPDATE_IN_PROGRESS.name(), STACK_INFRASTRUCTURE_BOOTSTRAP);\n+    }\n+\n+    public void startingClusterServices(StackView stack) {\n+        stackUpdater.updateStackStatus(stack.getId(), DetailedStackStatus.STARTING_CLUSTER_MANAGER_SERVICES, \"Running cluster services.\");\n+        flowMessageService.fireEventAndLog(stack.getId(), UPDATE_IN_PROGRESS.name(), CLUSTER_RUN_SERVICES);\n+    }\n+\n+    public void clusterInstallationFinished(StackView stackView) {\n+        try {\n+            transactionService.required(() -> {\n+                clusterService.updateClusterStatusByStackId(stackView.getId(), AVAILABLE);\n+                stackUpdater.updateStackStatus(stackView.getId(), DetailedStackStatus.AVAILABLE, \"Cluster creation finished.\");\n+                flowMessageService.fireEventAndLog(stackView.getId(), AVAILABLE.name(), CLUSTER_BUILT);\n+            });\n+        } catch (TransactionExecutionException e) {\n+            throw new TransactionRuntimeExecutionException(e);\n+        }\n+    }\n+\n+    public void handleClusterCreationFailure(StackView stackView, Exception exception) {\n+        if (stackView.getClusterView() != null) {\n+            String errorMessage = getErrorMessageFromException(exception);\n+            clusterService.updateClusterStatusByStackId(stackView.getId(), CREATE_FAILED, errorMessage);\n+            stackUpdater.updateStackStatus(stackView.getId(), DetailedStackStatus.AVAILABLE);\n+            flowMessageService.fireEventAndLog(stackView.getId(), CREATE_FAILED.name(), CLUSTER_CREATE_FAILED, errorMessage);\n+        } else {\n+            LOGGER.info(\"Cluster was null. Flow action was not required.\");\n+        }\n+    }\n+\n+    private String getErrorMessageFromException(Exception exception) {\n+        if (exception instanceof TransactionRuntimeExecutionException && exception.getCause() != null && exception.getCause().getCause() != null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0b841b27b9ef62246c17d217b595605cfc92f35f"}, "originalPosition": 78}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI1MTY3OTI1", "url": "https://github.com/hortonworks/cloudbreak/pull/8200#pullrequestreview-425167925", "createdAt": "2020-06-05T10:05:58Z", "commit": {"oid": "0b841b27b9ef62246c17d217b595605cfc92f35f"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "0b841b27b9ef62246c17d217b595605cfc92f35f", "author": {"user": {"login": "lacikaaa", "name": "Mihaly Laszlo Molnar"}}, "url": "https://github.com/hortonworks/cloudbreak/commit/0b841b27b9ef62246c17d217b595605cfc92f35f", "committedDate": "2020-06-03T15:11:13Z", "message": "CB-6637 Internal API for Salt upgrade testing"}, "afterCommit": {"oid": "9fbc475871c79efa8d75d34a6afe33a88df8c200", "author": {"user": {"login": "lacikaaa", "name": "Mihaly Laszlo Molnar"}}, "url": "https://github.com/hortonworks/cloudbreak/commit/9fbc475871c79efa8d75d34a6afe33a88df8c200", "committedDate": "2020-06-05T14:04:14Z", "message": "CB-6637 Internal API for Salt upgrade testing"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "eecfac40a3fb2fa13bb4616b3ee2c6d8a09cd5f8", "author": {"user": {"login": "lacikaaa", "name": "Mihaly Laszlo Molnar"}}, "url": "https://github.com/hortonworks/cloudbreak/commit/eecfac40a3fb2fa13bb4616b3ee2c6d8a09cd5f8", "committedDate": "2020-06-05T14:50:33Z", "message": "CB-6637 Internal API for Salt upgrade testing"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "9fbc475871c79efa8d75d34a6afe33a88df8c200", "author": {"user": {"login": "lacikaaa", "name": "Mihaly Laszlo Molnar"}}, "url": "https://github.com/hortonworks/cloudbreak/commit/9fbc475871c79efa8d75d34a6afe33a88df8c200", "committedDate": "2020-06-05T14:04:14Z", "message": "CB-6637 Internal API for Salt upgrade testing"}, "afterCommit": {"oid": "eecfac40a3fb2fa13bb4616b3ee2c6d8a09cd5f8", "author": {"user": {"login": "lacikaaa", "name": "Mihaly Laszlo Molnar"}}, "url": "https://github.com/hortonworks/cloudbreak/commit/eecfac40a3fb2fa13bb4616b3ee2c6d8a09cd5f8", "committedDate": "2020-06-05T14:50:33Z", "message": "CB-6637 Internal API for Salt upgrade testing"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1793, "cost": 1, "resetAt": "2021-11-01T14:51:55Z"}}}