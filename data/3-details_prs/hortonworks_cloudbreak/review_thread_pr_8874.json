{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDc0NjA5NzA5", "number": 8874, "reviewThreads": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QyMjo1NzowOVrOEdanEw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QyMjo1NzowOVrOEdanEw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk5MjgwMTQ3OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/com/sequenceiq/cloudbreak/controller/StackCreatorService.java", "isResolved": false, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QyMjo1NzowOVrOHIj-PQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yOFQxMToyMDowM1rOHI9Fug==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODc0MDAyOQ==", "bodyText": "I don't think this will provide the Knox node(s) (which effectively is the endpoint for all services) with a consistent hostname. e.g. If the number of 'CORE' nodes is dynamic - the 'GATEWAY' instance will get a number which follows the count of all 'CORE' nodes.\nThis needs better understanding of 'CORE' vs 'GATEWAY'. If I'm not mistaken, there can be one GATEWAY hostGroup, and this is the instance on which KNOX is installed (not sure if there can be more than one such node). I could be completely wrong about this though. @cegganesh84 - I think you have a much better understanding of CORE vs GATEWAY and cardinality given the HA templates that you've worked on.\nIf GATEWAY==KNOX node and there can be only 1 gateway hostGroup, explicitly assigning numbers to this hostGroup first probably works.\nAlternately, may need to make this service aware.", "url": "https://github.com/hortonworks/cloudbreak/pull/8874#discussion_r478740029", "createdAt": "2020-08-27T22:57:09Z", "author": {"login": "sidseth"}, "path": "core/src/main/java/com/sequenceiq/cloudbreak/controller/StackCreatorService.java", "diffHunk": "@@ -370,9 +372,13 @@ private void setStackTypeAndValidateDatalake(Stack stack, Blueprint blueprint) {\n         }\n     }\n \n-    private void fillInstanceMetadata(Stack stack) {\n+    void fillInstanceMetadata(Stack stack) {\n         long privateIdNumber = 0;\n-        for (InstanceGroup instanceGroup : stack.getInstanceGroups()) {\n+        //Gateway HostGroups are sorted first to start with privateIdNumber 0.\n+        List<InstanceGroup> sortedInstanceGroups = stack.getInstanceGroups().stream()\n+                .sorted(Comparator.comparing(InstanceGroup::getInstanceGroupType)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4d5af2613ee5563206c415ca04f0f910cfb7b967"}, "originalPosition": 26}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODc0MTQxMw==", "bodyText": "Looking some more, looks like GATEWAY is the first in the sort order, so this works as expected. May still be better to explicitly look at GATEWAY nodes first.\nStill need to get an understanding of where Knox goes, and how many GATEWAY type groups can exist.", "url": "https://github.com/hortonworks/cloudbreak/pull/8874#discussion_r478741413", "createdAt": "2020-08-27T23:01:18Z", "author": {"login": "sidseth"}, "path": "core/src/main/java/com/sequenceiq/cloudbreak/controller/StackCreatorService.java", "diffHunk": "@@ -370,9 +372,13 @@ private void setStackTypeAndValidateDatalake(Stack stack, Blueprint blueprint) {\n         }\n     }\n \n-    private void fillInstanceMetadata(Stack stack) {\n+    void fillInstanceMetadata(Stack stack) {\n         long privateIdNumber = 0;\n-        for (InstanceGroup instanceGroup : stack.getInstanceGroups()) {\n+        //Gateway HostGroups are sorted first to start with privateIdNumber 0.\n+        List<InstanceGroup> sortedInstanceGroups = stack.getInstanceGroups().stream()\n+                .sorted(Comparator.comparing(InstanceGroup::getInstanceGroupType)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODc0MDAyOQ=="}, "originalCommit": {"oid": "4d5af2613ee5563206c415ca04f0f910cfb7b967"}, "originalPosition": 26}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTAzODI4OQ==", "bodyText": "Knox is always deployed to the CM's machine which group always have the GATEWAY as InstanceGroupType. In case of HA clusters where could be multiple gateway instance/host group due to the comparison on group name the private id selection should be consistent - I think", "url": "https://github.com/hortonworks/cloudbreak/pull/8874#discussion_r479038289", "createdAt": "2020-08-28T09:43:56Z", "author": {"login": "biharitomi"}, "path": "core/src/main/java/com/sequenceiq/cloudbreak/controller/StackCreatorService.java", "diffHunk": "@@ -370,9 +372,13 @@ private void setStackTypeAndValidateDatalake(Stack stack, Blueprint blueprint) {\n         }\n     }\n \n-    private void fillInstanceMetadata(Stack stack) {\n+    void fillInstanceMetadata(Stack stack) {\n         long privateIdNumber = 0;\n-        for (InstanceGroup instanceGroup : stack.getInstanceGroups()) {\n+        //Gateway HostGroups are sorted first to start with privateIdNumber 0.\n+        List<InstanceGroup> sortedInstanceGroups = stack.getInstanceGroups().stream()\n+                .sorted(Comparator.comparing(InstanceGroup::getInstanceGroupType)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODc0MDAyOQ=="}, "originalCommit": {"oid": "4d5af2613ee5563206c415ca04f0f910cfb7b967"}, "originalPosition": 26}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTAzOTg5Mg==", "bodyText": "Previously, we had multiple groups with GATEWAY type for Ambari HA. At some point, the same will come to CM HA as well.", "url": "https://github.com/hortonworks/cloudbreak/pull/8874#discussion_r479039892", "createdAt": "2020-08-28T09:45:15Z", "author": {"login": "keyki"}, "path": "core/src/main/java/com/sequenceiq/cloudbreak/controller/StackCreatorService.java", "diffHunk": "@@ -370,9 +372,13 @@ private void setStackTypeAndValidateDatalake(Stack stack, Blueprint blueprint) {\n         }\n     }\n \n-    private void fillInstanceMetadata(Stack stack) {\n+    void fillInstanceMetadata(Stack stack) {\n         long privateIdNumber = 0;\n-        for (InstanceGroup instanceGroup : stack.getInstanceGroups()) {\n+        //Gateway HostGroups are sorted first to start with privateIdNumber 0.\n+        List<InstanceGroup> sortedInstanceGroups = stack.getInstanceGroups().stream()\n+                .sorted(Comparator.comparing(InstanceGroup::getInstanceGroupType)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODc0MDAyOQ=="}, "originalCommit": {"oid": "4d5af2613ee5563206c415ca04f0f910cfb7b967"}, "originalPosition": 26}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTE1MTU0Ng==", "bodyText": "Yes, if multiple GATEWAY host-groups are defined in future (current template validation fails multiple gateway host-groups), the naming convention will still be consistent for the same template due to comparison on InstanceGroupType which is followed by groupName. so nodes will be masterA0, masterB1  if masterA, masterB are gateway hostgroups.\nAlso tested cluster launch by changing gateway hostGroup from \"master\"  to \"worker\"  and then \"worker\" nodes started with worker0.\nCB-6185 concern is basically about different\\random node sequenceId and hence node name for same template and cardinality and that issue would be addressed by this patch .", "url": "https://github.com/hortonworks/cloudbreak/pull/8874#discussion_r479151546", "createdAt": "2020-08-28T11:20:03Z", "author": {"login": "smaniraju"}, "path": "core/src/main/java/com/sequenceiq/cloudbreak/controller/StackCreatorService.java", "diffHunk": "@@ -370,9 +372,13 @@ private void setStackTypeAndValidateDatalake(Stack stack, Blueprint blueprint) {\n         }\n     }\n \n-    private void fillInstanceMetadata(Stack stack) {\n+    void fillInstanceMetadata(Stack stack) {\n         long privateIdNumber = 0;\n-        for (InstanceGroup instanceGroup : stack.getInstanceGroups()) {\n+        //Gateway HostGroups are sorted first to start with privateIdNumber 0.\n+        List<InstanceGroup> sortedInstanceGroups = stack.getInstanceGroups().stream()\n+                .sorted(Comparator.comparing(InstanceGroup::getInstanceGroupType)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODc0MDAyOQ=="}, "originalCommit": {"oid": "4d5af2613ee5563206c415ca04f0f910cfb7b967"}, "originalPosition": 26}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2309, "cost": 1, "resetAt": "2021-11-12T20:44:06Z"}}}