{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTE5MTc1OTcy", "number": 9409, "reviewThreads": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMlQxMzowNDozMlrOE4Jumw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMlQxMzowNDozMlrOE4Jumw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI3MzE1MDk5OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/com/sequenceiq/cloudbreak/controller/validation/stack/StackRuntimeVersionValidator.java", "isResolved": true, "comments": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMlQxMzowNDozMlrOHx525A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMlQxMzo1NjozMVrOHx73hw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjA5MDIxMg==", "bodyText": "two things here. you're catching exceptions that have been thrown earlier by yourself which can be replaced with another flow control approach. maybe it's just me but I usually hate these exception driven development kind of approach \ud83d\ude42 because it is not just unnecessary to invoke any kind of exception but it can be unnecessarily resource-intensive to do so.\non the other hand, you're about to catch an Exception which is \"too wide\" to catch. it catches everything but the catch block doesn't ensure that the original problem/exception won't happen again. surely there are many cases when multiple kinds of exception should be handle in the same way but IMO one should be aware of the original exception not just to be able to handle it properly but to make a more meaningful log entry for that scenario", "url": "https://github.com/hortonworks/cloudbreak/pull/9409#discussion_r522090212", "createdAt": "2020-11-12T13:04:32Z", "author": {"login": "gregito"}, "path": "core/src/main/java/com/sequenceiq/cloudbreak/controller/validation/stack/StackRuntimeVersionValidator.java", "diffHunk": "@@ -32,23 +39,64 @@\n     @Inject\n     private SdxClientService sdxClientService;\n \n+    @Inject\n+    private StackViewService stackViewService;\n+\n+    @Inject\n+    private ClusterComponentConfigProvider clusterComponentConfigProvider;\n+\n     @Inject\n     private EntitlementService entitlementService;\n \n-    public void validate(StackV4Request stackRequest, Image image) {\n-        if (isDifferentDataHubAndDataLakeVersionAllowed()) {\n-            LOGGER.debug(\"The Data Hub version validation has been turned off with entitlement.\");\n-        } else if (StackType.WORKLOAD.equals(stackRequest.getType())) {\n-            LOGGER.debug(\"Validating Data Hub version.\");\n-            findStackVersion(stackRequest, image).ifPresent(stackRuntimeVersion -> {\n-                List<SdxClusterResponse> sdxClusters = sdxClientService.getByEnvironmentCrn(stackRequest.getEnvironmentCrn());\n-                sdxClusters.forEach(sdx -> validateStackVersion(stackRuntimeVersion, sdx.getRuntime()));\n-            });\n+    public void validate(StackV4Request stackRequest, Image image, StackType stackType) {\n+        if (StackType.WORKLOAD.equals(stackType)) {\n+            if (isDifferentDataHubAndDataLakeVersionAllowed()) {\n+                LOGGER.debug(\"The Data Hub version validation has been turned off with entitlement.\");\n+            } else {\n+                LOGGER.debug(\"Validating Data Hub version.\");\n+                findRequestedStackVersion(stackRequest, image).ifPresent(requestedRuntimeVersion -> {\n+                    checkRuntimeVersion(stackRequest.getEnvironmentCrn(), requestedRuntimeVersion);\n+                });\n+            }\n         }\n+    }\n+\n+    private void checkRuntimeVersion(String environmentCrn, String requestedStackVersion) {\n+        try {\n+            Optional<StackView> relatedDatalakeStack = stackViewService.findDatalakeViewByEnvironmentCrn(environmentCrn);\n+            if (relatedDatalakeStack.isPresent() && relatedDatalakeStack.get().isAvailable()) {\n+                List<ClouderaManagerProduct> clouderaManagerProductDetails =\n+                        clusterComponentConfigProvider.getClouderaManagerProductDetails(relatedDatalakeStack.get().getClusterView().getId());\n+                Optional<ClouderaManagerProduct> cdh = clouderaManagerProductDetails.stream()\n+                        .filter(clouderaManagerProduct -> StringUtils.equals(\"CDH\", clouderaManagerProduct.getName())).findFirst();\n+                if (cdh.isPresent() && cdh.get().getVersion() != null) {\n+                    compareRuntimeVersions(requestedStackVersion, StringUtils.substringBefore(cdh.get().getVersion(), \"-\"));\n+                } else {\n+                    throw new NotFoundException(String.format(\"Cannot found CDH details about related datalake stack in CB, name: %s\",\n+                            relatedDatalakeStack.get().getName()));\n+                }\n+            } else {\n+                throw new NotFoundException(String.format(\"Cannot found related dalatake stack in CB for environment CRN %s \" +\n+                        \"or the datalake isn't available yet.\", environmentCrn));\n+            }\n+        } catch (Exception e) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "43e734ba0c3e69934d6464179c4ce28ae7b8c753"}, "originalPosition": 79}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjA5MTQ1Nw==", "bodyText": "as I can remember we had such a checkstyle entry to prevent one to catch Exception. certainly, there are cases where catching Exception is inevitable, but in this case probably not. correct me if I'm wrong \ud83d\ude42", "url": "https://github.com/hortonworks/cloudbreak/pull/9409#discussion_r522091457", "createdAt": "2020-11-12T13:06:40Z", "author": {"login": "gregito"}, "path": "core/src/main/java/com/sequenceiq/cloudbreak/controller/validation/stack/StackRuntimeVersionValidator.java", "diffHunk": "@@ -32,23 +39,64 @@\n     @Inject\n     private SdxClientService sdxClientService;\n \n+    @Inject\n+    private StackViewService stackViewService;\n+\n+    @Inject\n+    private ClusterComponentConfigProvider clusterComponentConfigProvider;\n+\n     @Inject\n     private EntitlementService entitlementService;\n \n-    public void validate(StackV4Request stackRequest, Image image) {\n-        if (isDifferentDataHubAndDataLakeVersionAllowed()) {\n-            LOGGER.debug(\"The Data Hub version validation has been turned off with entitlement.\");\n-        } else if (StackType.WORKLOAD.equals(stackRequest.getType())) {\n-            LOGGER.debug(\"Validating Data Hub version.\");\n-            findStackVersion(stackRequest, image).ifPresent(stackRuntimeVersion -> {\n-                List<SdxClusterResponse> sdxClusters = sdxClientService.getByEnvironmentCrn(stackRequest.getEnvironmentCrn());\n-                sdxClusters.forEach(sdx -> validateStackVersion(stackRuntimeVersion, sdx.getRuntime()));\n-            });\n+    public void validate(StackV4Request stackRequest, Image image, StackType stackType) {\n+        if (StackType.WORKLOAD.equals(stackType)) {\n+            if (isDifferentDataHubAndDataLakeVersionAllowed()) {\n+                LOGGER.debug(\"The Data Hub version validation has been turned off with entitlement.\");\n+            } else {\n+                LOGGER.debug(\"Validating Data Hub version.\");\n+                findRequestedStackVersion(stackRequest, image).ifPresent(requestedRuntimeVersion -> {\n+                    checkRuntimeVersion(stackRequest.getEnvironmentCrn(), requestedRuntimeVersion);\n+                });\n+            }\n         }\n+    }\n+\n+    private void checkRuntimeVersion(String environmentCrn, String requestedStackVersion) {\n+        try {\n+            Optional<StackView> relatedDatalakeStack = stackViewService.findDatalakeViewByEnvironmentCrn(environmentCrn);\n+            if (relatedDatalakeStack.isPresent() && relatedDatalakeStack.get().isAvailable()) {\n+                List<ClouderaManagerProduct> clouderaManagerProductDetails =\n+                        clusterComponentConfigProvider.getClouderaManagerProductDetails(relatedDatalakeStack.get().getClusterView().getId());\n+                Optional<ClouderaManagerProduct> cdh = clouderaManagerProductDetails.stream()\n+                        .filter(clouderaManagerProduct -> StringUtils.equals(\"CDH\", clouderaManagerProduct.getName())).findFirst();\n+                if (cdh.isPresent() && cdh.get().getVersion() != null) {\n+                    compareRuntimeVersions(requestedStackVersion, StringUtils.substringBefore(cdh.get().getVersion(), \"-\"));\n+                } else {\n+                    throw new NotFoundException(String.format(\"Cannot found CDH details about related datalake stack in CB, name: %s\",\n+                            relatedDatalakeStack.get().getName()));\n+                }\n+            } else {\n+                throw new NotFoundException(String.format(\"Cannot found related dalatake stack in CB for environment CRN %s \" +\n+                        \"or the datalake isn't available yet.\", environmentCrn));\n+            }\n+        } catch (Exception e) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjA5MDIxMg=="}, "originalCommit": {"oid": "43e734ba0c3e69934d6464179c4ce28ae7b8c753"}, "originalPosition": 79}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjA5NjQ0OA==", "bodyText": "ok, i can change the try block logic do not throw those exceptions, thats fine.\nregarding too wide catch, the original issue is not happening because of the code in the try block, its completely new logic to spare the unnecessary call in sdx service. i do not want different error handling here, only one thing: checking dl in cb, if any error, then fall back to existing logic (calling sdx service). i see no point for various complex error handling for a singe version validator", "url": "https://github.com/hortonworks/cloudbreak/pull/9409#discussion_r522096448", "createdAt": "2020-11-12T13:15:05Z", "author": {"login": "horadla23"}, "path": "core/src/main/java/com/sequenceiq/cloudbreak/controller/validation/stack/StackRuntimeVersionValidator.java", "diffHunk": "@@ -32,23 +39,64 @@\n     @Inject\n     private SdxClientService sdxClientService;\n \n+    @Inject\n+    private StackViewService stackViewService;\n+\n+    @Inject\n+    private ClusterComponentConfigProvider clusterComponentConfigProvider;\n+\n     @Inject\n     private EntitlementService entitlementService;\n \n-    public void validate(StackV4Request stackRequest, Image image) {\n-        if (isDifferentDataHubAndDataLakeVersionAllowed()) {\n-            LOGGER.debug(\"The Data Hub version validation has been turned off with entitlement.\");\n-        } else if (StackType.WORKLOAD.equals(stackRequest.getType())) {\n-            LOGGER.debug(\"Validating Data Hub version.\");\n-            findStackVersion(stackRequest, image).ifPresent(stackRuntimeVersion -> {\n-                List<SdxClusterResponse> sdxClusters = sdxClientService.getByEnvironmentCrn(stackRequest.getEnvironmentCrn());\n-                sdxClusters.forEach(sdx -> validateStackVersion(stackRuntimeVersion, sdx.getRuntime()));\n-            });\n+    public void validate(StackV4Request stackRequest, Image image, StackType stackType) {\n+        if (StackType.WORKLOAD.equals(stackType)) {\n+            if (isDifferentDataHubAndDataLakeVersionAllowed()) {\n+                LOGGER.debug(\"The Data Hub version validation has been turned off with entitlement.\");\n+            } else {\n+                LOGGER.debug(\"Validating Data Hub version.\");\n+                findRequestedStackVersion(stackRequest, image).ifPresent(requestedRuntimeVersion -> {\n+                    checkRuntimeVersion(stackRequest.getEnvironmentCrn(), requestedRuntimeVersion);\n+                });\n+            }\n         }\n+    }\n+\n+    private void checkRuntimeVersion(String environmentCrn, String requestedStackVersion) {\n+        try {\n+            Optional<StackView> relatedDatalakeStack = stackViewService.findDatalakeViewByEnvironmentCrn(environmentCrn);\n+            if (relatedDatalakeStack.isPresent() && relatedDatalakeStack.get().isAvailable()) {\n+                List<ClouderaManagerProduct> clouderaManagerProductDetails =\n+                        clusterComponentConfigProvider.getClouderaManagerProductDetails(relatedDatalakeStack.get().getClusterView().getId());\n+                Optional<ClouderaManagerProduct> cdh = clouderaManagerProductDetails.stream()\n+                        .filter(clouderaManagerProduct -> StringUtils.equals(\"CDH\", clouderaManagerProduct.getName())).findFirst();\n+                if (cdh.isPresent() && cdh.get().getVersion() != null) {\n+                    compareRuntimeVersions(requestedStackVersion, StringUtils.substringBefore(cdh.get().getVersion(), \"-\"));\n+                } else {\n+                    throw new NotFoundException(String.format(\"Cannot found CDH details about related datalake stack in CB, name: %s\",\n+                            relatedDatalakeStack.get().getName()));\n+                }\n+            } else {\n+                throw new NotFoundException(String.format(\"Cannot found related dalatake stack in CB for environment CRN %s \" +\n+                        \"or the datalake isn't available yet.\", environmentCrn));\n+            }\n+        } catch (Exception e) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjA5MDIxMg=="}, "originalCommit": {"oid": "43e734ba0c3e69934d6464179c4ce28ae7b8c753"}, "originalPosition": 79}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjEwNDg0MQ==", "bodyText": "doesn't ensure that the original problem/exception won't happen again\n\nmost of the cases how can we ensure if:\n\ndatalake is not available, then it will next time\ndatalake is no present, then it will next time\nCDH version is not present, then it will next time\n\nI think there is no way to do it, these are user errors, we can handle these with one way: log it and fall back to sdx call\nor what would you do in these cases?\nwhat different error handling should be here also?\nin general speaking I agree with you, but I cannot see what more we can do here, please give me specific advises, if you have it regarding this case", "url": "https://github.com/hortonworks/cloudbreak/pull/9409#discussion_r522104841", "createdAt": "2020-11-12T13:28:46Z", "author": {"login": "horadla23"}, "path": "core/src/main/java/com/sequenceiq/cloudbreak/controller/validation/stack/StackRuntimeVersionValidator.java", "diffHunk": "@@ -32,23 +39,64 @@\n     @Inject\n     private SdxClientService sdxClientService;\n \n+    @Inject\n+    private StackViewService stackViewService;\n+\n+    @Inject\n+    private ClusterComponentConfigProvider clusterComponentConfigProvider;\n+\n     @Inject\n     private EntitlementService entitlementService;\n \n-    public void validate(StackV4Request stackRequest, Image image) {\n-        if (isDifferentDataHubAndDataLakeVersionAllowed()) {\n-            LOGGER.debug(\"The Data Hub version validation has been turned off with entitlement.\");\n-        } else if (StackType.WORKLOAD.equals(stackRequest.getType())) {\n-            LOGGER.debug(\"Validating Data Hub version.\");\n-            findStackVersion(stackRequest, image).ifPresent(stackRuntimeVersion -> {\n-                List<SdxClusterResponse> sdxClusters = sdxClientService.getByEnvironmentCrn(stackRequest.getEnvironmentCrn());\n-                sdxClusters.forEach(sdx -> validateStackVersion(stackRuntimeVersion, sdx.getRuntime()));\n-            });\n+    public void validate(StackV4Request stackRequest, Image image, StackType stackType) {\n+        if (StackType.WORKLOAD.equals(stackType)) {\n+            if (isDifferentDataHubAndDataLakeVersionAllowed()) {\n+                LOGGER.debug(\"The Data Hub version validation has been turned off with entitlement.\");\n+            } else {\n+                LOGGER.debug(\"Validating Data Hub version.\");\n+                findRequestedStackVersion(stackRequest, image).ifPresent(requestedRuntimeVersion -> {\n+                    checkRuntimeVersion(stackRequest.getEnvironmentCrn(), requestedRuntimeVersion);\n+                });\n+            }\n         }\n+    }\n+\n+    private void checkRuntimeVersion(String environmentCrn, String requestedStackVersion) {\n+        try {\n+            Optional<StackView> relatedDatalakeStack = stackViewService.findDatalakeViewByEnvironmentCrn(environmentCrn);\n+            if (relatedDatalakeStack.isPresent() && relatedDatalakeStack.get().isAvailable()) {\n+                List<ClouderaManagerProduct> clouderaManagerProductDetails =\n+                        clusterComponentConfigProvider.getClouderaManagerProductDetails(relatedDatalakeStack.get().getClusterView().getId());\n+                Optional<ClouderaManagerProduct> cdh = clouderaManagerProductDetails.stream()\n+                        .filter(clouderaManagerProduct -> StringUtils.equals(\"CDH\", clouderaManagerProduct.getName())).findFirst();\n+                if (cdh.isPresent() && cdh.get().getVersion() != null) {\n+                    compareRuntimeVersions(requestedStackVersion, StringUtils.substringBefore(cdh.get().getVersion(), \"-\"));\n+                } else {\n+                    throw new NotFoundException(String.format(\"Cannot found CDH details about related datalake stack in CB, name: %s\",\n+                            relatedDatalakeStack.get().getName()));\n+                }\n+            } else {\n+                throw new NotFoundException(String.format(\"Cannot found related dalatake stack in CB for environment CRN %s \" +\n+                        \"or the datalake isn't available yet.\", environmentCrn));\n+            }\n+        } catch (Exception e) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjA5MDIxMg=="}, "originalCommit": {"oid": "43e734ba0c3e69934d6464179c4ce28ae7b8c753"}, "originalPosition": 79}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjEwNzc1MA==", "bodyText": "thanks!\nyeah, I'm thinking the same way. a single version validator shouldn't contain such complex error handling as that one. just the necessary but without sacrificing the foreseeing of the chances of malfunctions.", "url": "https://github.com/hortonworks/cloudbreak/pull/9409#discussion_r522107750", "createdAt": "2020-11-12T13:33:26Z", "author": {"login": "gregito"}, "path": "core/src/main/java/com/sequenceiq/cloudbreak/controller/validation/stack/StackRuntimeVersionValidator.java", "diffHunk": "@@ -32,23 +39,64 @@\n     @Inject\n     private SdxClientService sdxClientService;\n \n+    @Inject\n+    private StackViewService stackViewService;\n+\n+    @Inject\n+    private ClusterComponentConfigProvider clusterComponentConfigProvider;\n+\n     @Inject\n     private EntitlementService entitlementService;\n \n-    public void validate(StackV4Request stackRequest, Image image) {\n-        if (isDifferentDataHubAndDataLakeVersionAllowed()) {\n-            LOGGER.debug(\"The Data Hub version validation has been turned off with entitlement.\");\n-        } else if (StackType.WORKLOAD.equals(stackRequest.getType())) {\n-            LOGGER.debug(\"Validating Data Hub version.\");\n-            findStackVersion(stackRequest, image).ifPresent(stackRuntimeVersion -> {\n-                List<SdxClusterResponse> sdxClusters = sdxClientService.getByEnvironmentCrn(stackRequest.getEnvironmentCrn());\n-                sdxClusters.forEach(sdx -> validateStackVersion(stackRuntimeVersion, sdx.getRuntime()));\n-            });\n+    public void validate(StackV4Request stackRequest, Image image, StackType stackType) {\n+        if (StackType.WORKLOAD.equals(stackType)) {\n+            if (isDifferentDataHubAndDataLakeVersionAllowed()) {\n+                LOGGER.debug(\"The Data Hub version validation has been turned off with entitlement.\");\n+            } else {\n+                LOGGER.debug(\"Validating Data Hub version.\");\n+                findRequestedStackVersion(stackRequest, image).ifPresent(requestedRuntimeVersion -> {\n+                    checkRuntimeVersion(stackRequest.getEnvironmentCrn(), requestedRuntimeVersion);\n+                });\n+            }\n         }\n+    }\n+\n+    private void checkRuntimeVersion(String environmentCrn, String requestedStackVersion) {\n+        try {\n+            Optional<StackView> relatedDatalakeStack = stackViewService.findDatalakeViewByEnvironmentCrn(environmentCrn);\n+            if (relatedDatalakeStack.isPresent() && relatedDatalakeStack.get().isAvailable()) {\n+                List<ClouderaManagerProduct> clouderaManagerProductDetails =\n+                        clusterComponentConfigProvider.getClouderaManagerProductDetails(relatedDatalakeStack.get().getClusterView().getId());\n+                Optional<ClouderaManagerProduct> cdh = clouderaManagerProductDetails.stream()\n+                        .filter(clouderaManagerProduct -> StringUtils.equals(\"CDH\", clouderaManagerProduct.getName())).findFirst();\n+                if (cdh.isPresent() && cdh.get().getVersion() != null) {\n+                    compareRuntimeVersions(requestedStackVersion, StringUtils.substringBefore(cdh.get().getVersion(), \"-\"));\n+                } else {\n+                    throw new NotFoundException(String.format(\"Cannot found CDH details about related datalake stack in CB, name: %s\",\n+                            relatedDatalakeStack.get().getName()));\n+                }\n+            } else {\n+                throw new NotFoundException(String.format(\"Cannot found related dalatake stack in CB for environment CRN %s \" +\n+                        \"or the datalake isn't available yet.\", environmentCrn));\n+            }\n+        } catch (Exception e) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjA5MDIxMg=="}, "originalCommit": {"oid": "43e734ba0c3e69934d6464179c4ce28ae7b8c753"}, "originalPosition": 79}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjEyMjk0NA==", "bodyText": "i would keep that exception catch, there is no checkstyle rule against it. here i do no trust logic of clusterComponentConfigProvider  enough to leave that catch :)", "url": "https://github.com/hortonworks/cloudbreak/pull/9409#discussion_r522122944", "createdAt": "2020-11-12T13:56:13Z", "author": {"login": "horadla23"}, "path": "core/src/main/java/com/sequenceiq/cloudbreak/controller/validation/stack/StackRuntimeVersionValidator.java", "diffHunk": "@@ -32,23 +39,64 @@\n     @Inject\n     private SdxClientService sdxClientService;\n \n+    @Inject\n+    private StackViewService stackViewService;\n+\n+    @Inject\n+    private ClusterComponentConfigProvider clusterComponentConfigProvider;\n+\n     @Inject\n     private EntitlementService entitlementService;\n \n-    public void validate(StackV4Request stackRequest, Image image) {\n-        if (isDifferentDataHubAndDataLakeVersionAllowed()) {\n-            LOGGER.debug(\"The Data Hub version validation has been turned off with entitlement.\");\n-        } else if (StackType.WORKLOAD.equals(stackRequest.getType())) {\n-            LOGGER.debug(\"Validating Data Hub version.\");\n-            findStackVersion(stackRequest, image).ifPresent(stackRuntimeVersion -> {\n-                List<SdxClusterResponse> sdxClusters = sdxClientService.getByEnvironmentCrn(stackRequest.getEnvironmentCrn());\n-                sdxClusters.forEach(sdx -> validateStackVersion(stackRuntimeVersion, sdx.getRuntime()));\n-            });\n+    public void validate(StackV4Request stackRequest, Image image, StackType stackType) {\n+        if (StackType.WORKLOAD.equals(stackType)) {\n+            if (isDifferentDataHubAndDataLakeVersionAllowed()) {\n+                LOGGER.debug(\"The Data Hub version validation has been turned off with entitlement.\");\n+            } else {\n+                LOGGER.debug(\"Validating Data Hub version.\");\n+                findRequestedStackVersion(stackRequest, image).ifPresent(requestedRuntimeVersion -> {\n+                    checkRuntimeVersion(stackRequest.getEnvironmentCrn(), requestedRuntimeVersion);\n+                });\n+            }\n         }\n+    }\n+\n+    private void checkRuntimeVersion(String environmentCrn, String requestedStackVersion) {\n+        try {\n+            Optional<StackView> relatedDatalakeStack = stackViewService.findDatalakeViewByEnvironmentCrn(environmentCrn);\n+            if (relatedDatalakeStack.isPresent() && relatedDatalakeStack.get().isAvailable()) {\n+                List<ClouderaManagerProduct> clouderaManagerProductDetails =\n+                        clusterComponentConfigProvider.getClouderaManagerProductDetails(relatedDatalakeStack.get().getClusterView().getId());\n+                Optional<ClouderaManagerProduct> cdh = clouderaManagerProductDetails.stream()\n+                        .filter(clouderaManagerProduct -> StringUtils.equals(\"CDH\", clouderaManagerProduct.getName())).findFirst();\n+                if (cdh.isPresent() && cdh.get().getVersion() != null) {\n+                    compareRuntimeVersions(requestedStackVersion, StringUtils.substringBefore(cdh.get().getVersion(), \"-\"));\n+                } else {\n+                    throw new NotFoundException(String.format(\"Cannot found CDH details about related datalake stack in CB, name: %s\",\n+                            relatedDatalakeStack.get().getName()));\n+                }\n+            } else {\n+                throw new NotFoundException(String.format(\"Cannot found related dalatake stack in CB for environment CRN %s \" +\n+                        \"or the datalake isn't available yet.\", environmentCrn));\n+            }\n+        } catch (Exception e) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjA5MDIxMg=="}, "originalCommit": {"oid": "43e734ba0c3e69934d6464179c4ce28ae7b8c753"}, "originalPosition": 79}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjEyMzE0Mw==", "bodyText": "i also removed unnecessary throws", "url": "https://github.com/hortonworks/cloudbreak/pull/9409#discussion_r522123143", "createdAt": "2020-11-12T13:56:31Z", "author": {"login": "horadla23"}, "path": "core/src/main/java/com/sequenceiq/cloudbreak/controller/validation/stack/StackRuntimeVersionValidator.java", "diffHunk": "@@ -32,23 +39,64 @@\n     @Inject\n     private SdxClientService sdxClientService;\n \n+    @Inject\n+    private StackViewService stackViewService;\n+\n+    @Inject\n+    private ClusterComponentConfigProvider clusterComponentConfigProvider;\n+\n     @Inject\n     private EntitlementService entitlementService;\n \n-    public void validate(StackV4Request stackRequest, Image image) {\n-        if (isDifferentDataHubAndDataLakeVersionAllowed()) {\n-            LOGGER.debug(\"The Data Hub version validation has been turned off with entitlement.\");\n-        } else if (StackType.WORKLOAD.equals(stackRequest.getType())) {\n-            LOGGER.debug(\"Validating Data Hub version.\");\n-            findStackVersion(stackRequest, image).ifPresent(stackRuntimeVersion -> {\n-                List<SdxClusterResponse> sdxClusters = sdxClientService.getByEnvironmentCrn(stackRequest.getEnvironmentCrn());\n-                sdxClusters.forEach(sdx -> validateStackVersion(stackRuntimeVersion, sdx.getRuntime()));\n-            });\n+    public void validate(StackV4Request stackRequest, Image image, StackType stackType) {\n+        if (StackType.WORKLOAD.equals(stackType)) {\n+            if (isDifferentDataHubAndDataLakeVersionAllowed()) {\n+                LOGGER.debug(\"The Data Hub version validation has been turned off with entitlement.\");\n+            } else {\n+                LOGGER.debug(\"Validating Data Hub version.\");\n+                findRequestedStackVersion(stackRequest, image).ifPresent(requestedRuntimeVersion -> {\n+                    checkRuntimeVersion(stackRequest.getEnvironmentCrn(), requestedRuntimeVersion);\n+                });\n+            }\n         }\n+    }\n+\n+    private void checkRuntimeVersion(String environmentCrn, String requestedStackVersion) {\n+        try {\n+            Optional<StackView> relatedDatalakeStack = stackViewService.findDatalakeViewByEnvironmentCrn(environmentCrn);\n+            if (relatedDatalakeStack.isPresent() && relatedDatalakeStack.get().isAvailable()) {\n+                List<ClouderaManagerProduct> clouderaManagerProductDetails =\n+                        clusterComponentConfigProvider.getClouderaManagerProductDetails(relatedDatalakeStack.get().getClusterView().getId());\n+                Optional<ClouderaManagerProduct> cdh = clouderaManagerProductDetails.stream()\n+                        .filter(clouderaManagerProduct -> StringUtils.equals(\"CDH\", clouderaManagerProduct.getName())).findFirst();\n+                if (cdh.isPresent() && cdh.get().getVersion() != null) {\n+                    compareRuntimeVersions(requestedStackVersion, StringUtils.substringBefore(cdh.get().getVersion(), \"-\"));\n+                } else {\n+                    throw new NotFoundException(String.format(\"Cannot found CDH details about related datalake stack in CB, name: %s\",\n+                            relatedDatalakeStack.get().getName()));\n+                }\n+            } else {\n+                throw new NotFoundException(String.format(\"Cannot found related dalatake stack in CB for environment CRN %s \" +\n+                        \"or the datalake isn't available yet.\", environmentCrn));\n+            }\n+        } catch (Exception e) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjA5MDIxMg=="}, "originalCommit": {"oid": "43e734ba0c3e69934d6464179c4ce28ae7b8c753"}, "originalPosition": 79}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3576, "cost": 1, "resetAt": "2021-11-12T20:44:06Z"}}}