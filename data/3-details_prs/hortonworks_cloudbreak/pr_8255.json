{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDMyNTUzMjcx", "number": 8255, "title": "CB-7082 - Use multiple implementations instead of instanceOf", "bodyText": "CB-7082 - Use multiple implementations instead of instanceOf", "createdAt": "2020-06-10T15:59:33Z", "url": "https://github.com/hortonworks/cloudbreak/pull/8255", "merged": true, "mergeCommit": {"oid": "9b0668c7a1ae65fe67256727cd3004f19662205c"}, "closed": true, "closedAt": "2020-06-24T17:54:33Z", "author": {"login": "gregito"}, "timelineItems": {"totalCount": 23, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcqKKEagBqjM0MzMxMTI2MTk=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcuaq-MABqjM0Nzc3MDMwNzc=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "2a58ef77fffba7152e47c7dda6f6e19294e88a35", "author": {"user": {"login": "gregito", "name": "M\u00e9sz\u00e1ros Gergely"}}, "url": "https://github.com/hortonworks/cloudbreak/commit/2a58ef77fffba7152e47c7dda6f6e19294e88a35", "committedDate": "2020-06-10T12:36:00Z", "message": "CB-7082 - Use multiple implementations instead of instanceOf"}, "afterCommit": {"oid": "dc2bac5c66993a862f101bf9bd08791392c3bbbf", "author": {"user": {"login": "gregito", "name": "M\u00e9sz\u00e1ros Gergely"}}, "url": "https://github.com/hortonworks/cloudbreak/commit/dc2bac5c66993a862f101bf9bd08791392c3bbbf", "committedDate": "2020-06-11T08:40:46Z", "message": "CB-7082 - Use multiple implementations instead of instanceOf"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI4ODQwNjE0", "url": "https://github.com/hortonworks/cloudbreak/pull/8255#pullrequestreview-428840614", "createdAt": "2020-06-11T12:00:38Z", "commit": {"oid": "dc2bac5c66993a862f101bf9bd08791392c3bbbf"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 20, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMVQxMjowMDozOFrOGiaGdA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMVQxMzozODoyOVrOGidipw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODczMjQwNA==", "bodyText": "is there a specific need for LinkedHashMap? (same question for the bean below as well)", "url": "https://github.com/hortonworks/cloudbreak/pull/8255#discussion_r438732404", "createdAt": "2020-06-11T12:00:38Z", "author": {"login": "bergerdenes"}, "path": "audit-connector/src/main/java/com/sequenceiq/cloudbreak/audit/config/AuditConfig.java", "diffHunk": "@@ -26,4 +39,19 @@ public int getPort() {\n     public boolean isConfigured() {\n         return !StringUtil.isNullOrEmpty(endpoint);\n     }\n+\n+    @Bean\n+    public Map<Class, EventDataUtilizer> eventDataUtilizers() {\n+        Map<Class, EventDataUtilizer> result = new LinkedHashMap<>(eventDataUtilizerImplementations.size());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dc2bac5c66993a862f101bf9bd08791392c3bbbf"}, "originalPosition": 39}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODczNDk3Nw==", "bodyText": "Why \"D\" ? :)\nNaming: EventDataConverter (okay, it is not a traditional converter, but still)", "url": "https://github.com/hortonworks/cloudbreak/pull/8255#discussion_r438734977", "createdAt": "2020-06-11T12:06:13Z", "author": {"login": "bergerdenes"}, "path": "audit-connector/src/main/java/com/sequenceiq/cloudbreak/audit/converter/EventDataUtilizer.java", "diffHunk": "@@ -0,0 +1,12 @@\n+package com.sequenceiq.cloudbreak.audit.converter;\n+\n+import com.cloudera.thunderhead.service.audit.AuditProto;\n+import com.sequenceiq.cloudbreak.audit.model.EventData;\n+\n+public interface EventDataUtilizer<D extends EventData> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dc2bac5c66993a862f101bf9bd08791392c3bbbf"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODczNTE3Ng==", "bodyText": "modifyAuditEventBuilderWithEventData  -> convertInBuilder", "url": "https://github.com/hortonworks/cloudbreak/pull/8255#discussion_r438735176", "createdAt": "2020-06-11T12:06:38Z", "author": {"login": "bergerdenes"}, "path": "audit-connector/src/main/java/com/sequenceiq/cloudbreak/audit/converter/EventDataUtilizer.java", "diffHunk": "@@ -0,0 +1,12 @@\n+package com.sequenceiq.cloudbreak.audit.converter;\n+\n+import com.cloudera.thunderhead.service.audit.AuditProto;\n+import com.sequenceiq.cloudbreak.audit.model.EventData;\n+\n+public interface EventDataUtilizer<D extends EventData> {\n+\n+    void modifyAuditEventBuilderWithEventData(AuditProto.AuditEvent.Builder auditEventBuilder, D source);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dc2bac5c66993a862f101bf9bd08791392c3bbbf"}, "originalPosition": 8}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODc2NzUyNw==", "bodyText": "after renaming the template class, the field name would be like eventDataConverters", "url": "https://github.com/hortonworks/cloudbreak/pull/8255#discussion_r438767527", "createdAt": "2020-06-11T13:07:45Z", "author": {"login": "bergerdenes"}, "path": "audit-connector/src/main/java/com/sequenceiq/cloudbreak/audit/config/AuditConfig.java", "diffHunk": "@@ -15,6 +22,12 @@\n     @Value(\"${altus.audit.port:8989}\")\n     private int port;\n \n+    @Inject\n+    private List<EventDataUtilizer> eventDataUtilizerImplementations;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dc2bac5c66993a862f101bf9bd08791392c3bbbf"}, "originalPosition": 24}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODc2NzY4Ng==", "bodyText": "after renaming the template class, the field name would be like resultEventDataConverters", "url": "https://github.com/hortonworks/cloudbreak/pull/8255#discussion_r438767686", "createdAt": "2020-06-11T13:08:00Z", "author": {"login": "bergerdenes"}, "path": "audit-connector/src/main/java/com/sequenceiq/cloudbreak/audit/config/AuditConfig.java", "diffHunk": "@@ -15,6 +22,12 @@\n     @Value(\"${altus.audit.port:8989}\")\n     private int port;\n \n+    @Inject\n+    private List<EventDataUtilizer> eventDataUtilizerImplementations;\n+\n+    @Inject\n+    private List<AuditEventDataUtilizer> auditEventDataUtilizerImplementations;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dc2bac5c66993a862f101bf9bd08791392c3bbbf"}, "originalPosition": 27}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODc2NzkxNA==", "bodyText": "utilizer -> converter", "url": "https://github.com/hortonworks/cloudbreak/pull/8255#discussion_r438767914", "createdAt": "2020-06-11T13:08:26Z", "author": {"login": "bergerdenes"}, "path": "audit-connector/src/main/java/com/sequenceiq/cloudbreak/audit/config/AuditConfig.java", "diffHunk": "@@ -26,4 +39,19 @@ public int getPort() {\n     public boolean isConfigured() {\n         return !StringUtil.isNullOrEmpty(endpoint);\n     }\n+\n+    @Bean\n+    public Map<Class, EventDataUtilizer> eventDataUtilizers() {\n+        Map<Class, EventDataUtilizer> result = new LinkedHashMap<>(eventDataUtilizerImplementations.size());\n+        eventDataUtilizerImplementations.forEach(utilizer -> result.put(utilizer.getType(), utilizer));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dc2bac5c66993a862f101bf9bd08791392c3bbbf"}, "originalPosition": 40}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODc3MDg3MA==", "bodyText": "why \"D\"?\nNaming: ResultEventDataConverter (okay, it is not a traditional converter, but still)", "url": "https://github.com/hortonworks/cloudbreak/pull/8255#discussion_r438770870", "createdAt": "2020-06-11T13:13:12Z", "author": {"login": "bergerdenes"}, "path": "audit-connector/src/main/java/com/sequenceiq/cloudbreak/audit/converter/AuditEventDataUtilizer.java", "diffHunk": "@@ -0,0 +1,12 @@\n+package com.sequenceiq.cloudbreak.audit.converter;\n+\n+import com.cloudera.thunderhead.service.audit.AuditProto;\n+import com.sequenceiq.cloudbreak.audit.model.ResultEventData;\n+\n+public interface AuditEventDataUtilizer<D extends ResultEventData> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dc2bac5c66993a862f101bf9bd08791392c3bbbf"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODc3MTA2Mg==", "bodyText": "modifyAuditEventBuilderWithEventData -> convertInBuilder\nauditEventBuilder -> attemptAuditEventResultBuilder (too long, I know. or just builder)", "url": "https://github.com/hortonworks/cloudbreak/pull/8255#discussion_r438771062", "createdAt": "2020-06-11T13:13:29Z", "author": {"login": "bergerdenes"}, "path": "audit-connector/src/main/java/com/sequenceiq/cloudbreak/audit/converter/AuditEventDataUtilizer.java", "diffHunk": "@@ -0,0 +1,12 @@\n+package com.sequenceiq.cloudbreak.audit.converter;\n+\n+import com.cloudera.thunderhead.service.audit.AuditProto;\n+import com.sequenceiq.cloudbreak.audit.model.ResultEventData;\n+\n+public interface AuditEventDataUtilizer<D extends ResultEventData> {\n+\n+    void modifyAuditEventBuilderWithEventData(AuditProto.AttemptAuditEventResult.Builder auditEventBuilder, D source);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dc2bac5c66993a862f101bf9bd08791392c3bbbf"}, "originalPosition": 8}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODc3NDI5MQ==", "bodyText": "Is this logging needed? If you insist on this logging, please move it to the Bean definition method in the Configuration class.", "url": "https://github.com/hortonworks/cloudbreak/pull/8255#discussion_r438774291", "createdAt": "2020-06-11T13:18:52Z", "author": {"login": "bergerdenes"}, "path": "audit-connector/src/main/java/com/sequenceiq/cloudbreak/audit/converter/AuditEventToGrpcAuditEventConverter.java", "diffHunk": "@@ -1,25 +1,49 @@\n package com.sequenceiq.cloudbreak.audit.converter;\n \n-import static com.sequenceiq.cloudbreak.util.ConditionBasedEvaluatorUtil.doIfTrue;\n-import static com.sequenceiq.cloudbreak.util.UuidUtil.uuidSupplier;\n-\n-import java.util.Optional;\n-\n-import org.apache.commons.lang3.StringUtils;\n-import org.springframework.stereotype.Component;\n-\n import com.cloudera.thunderhead.service.audit.AuditProto;\n import com.sequenceiq.cloudbreak.audit.model.ActorBase;\n import com.sequenceiq.cloudbreak.audit.model.ActorCrn;\n import com.sequenceiq.cloudbreak.audit.model.ActorService;\n-import com.sequenceiq.cloudbreak.audit.model.ApiRequestData;\n import com.sequenceiq.cloudbreak.audit.model.AuditEvent;\n import com.sequenceiq.cloudbreak.audit.model.EventData;\n-import com.sequenceiq.cloudbreak.audit.model.ServiceEventData;\n+import com.sequenceiq.cloudbreak.util.NullUtil;\n+import org.apache.commons.collections.MapUtils;\n+import org.apache.commons.lang3.StringUtils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.stereotype.Component;\n+\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+\n+import static com.sequenceiq.cloudbreak.util.ConditionBasedEvaluatorUtil.doIfTrue;\n+import static com.sequenceiq.cloudbreak.util.UuidUtil.uuidSupplier;\n \n @Component\n public class AuditEventToGrpcAuditEventConverter {\n \n+    private static final Logger LOGGER = LoggerFactory.getLogger(AuditEventToGrpcAuditEventConverter.class);\n+\n+    private final Map<Class, EventDataUtilizer> eventDataUtilizer;\n+\n+    public AuditEventToGrpcAuditEventConverter(Map<Class, EventDataUtilizer> eventDataUtilizer) {\n+        if (MapUtils.isNotEmpty(eventDataUtilizer)) {\n+            List<String> utilizers = new LinkedList<>();\n+            eventDataUtilizer.forEach((type, utilizer) -> utilizers.add(String.format(\"[%s :: %s]\",\n+                    NullUtil.getIfNotNull(type, t -> t.getSimpleName()),\n+                    NullUtil.getIfNotNull(utilizer, u -> u.getClass().getSimpleName()))));\n+            String utilizerListMessage = String.join(\",\", utilizers);\n+            LOGGER.debug(\"The \" + AuditEventToGrpcAuditEventConverter.class.getSimpleName() + \" has got the following \"\n+                    + EventDataUtilizer.class.getSimpleName() + \" implementations: {}\", utilizerListMessage);\n+        } else {\n+            LOGGER.debug(\"The \" + AuditEventToGrpcAuditEventConverter.class.getSimpleName() + \" has not got any \"\n+                    + EventDataUtilizer.class.getSimpleName() + \" implementation!\");\n+        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dc2bac5c66993a862f101bf9bd08791392c3bbbf"}, "originalPosition": 53}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODc3NTE1OA==", "bodyText": "you could completely go functional and throw out the utilizers list. just map the k:v to output and use Collectors.joining", "url": "https://github.com/hortonworks/cloudbreak/pull/8255#discussion_r438775158", "createdAt": "2020-06-11T13:20:21Z", "author": {"login": "bergerdenes"}, "path": "audit-connector/src/main/java/com/sequenceiq/cloudbreak/audit/converter/AuditEventToGrpcAuditEventConverter.java", "diffHunk": "@@ -1,25 +1,49 @@\n package com.sequenceiq.cloudbreak.audit.converter;\n \n-import static com.sequenceiq.cloudbreak.util.ConditionBasedEvaluatorUtil.doIfTrue;\n-import static com.sequenceiq.cloudbreak.util.UuidUtil.uuidSupplier;\n-\n-import java.util.Optional;\n-\n-import org.apache.commons.lang3.StringUtils;\n-import org.springframework.stereotype.Component;\n-\n import com.cloudera.thunderhead.service.audit.AuditProto;\n import com.sequenceiq.cloudbreak.audit.model.ActorBase;\n import com.sequenceiq.cloudbreak.audit.model.ActorCrn;\n import com.sequenceiq.cloudbreak.audit.model.ActorService;\n-import com.sequenceiq.cloudbreak.audit.model.ApiRequestData;\n import com.sequenceiq.cloudbreak.audit.model.AuditEvent;\n import com.sequenceiq.cloudbreak.audit.model.EventData;\n-import com.sequenceiq.cloudbreak.audit.model.ServiceEventData;\n+import com.sequenceiq.cloudbreak.util.NullUtil;\n+import org.apache.commons.collections.MapUtils;\n+import org.apache.commons.lang3.StringUtils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.stereotype.Component;\n+\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+\n+import static com.sequenceiq.cloudbreak.util.ConditionBasedEvaluatorUtil.doIfTrue;\n+import static com.sequenceiq.cloudbreak.util.UuidUtil.uuidSupplier;\n \n @Component\n public class AuditEventToGrpcAuditEventConverter {\n \n+    private static final Logger LOGGER = LoggerFactory.getLogger(AuditEventToGrpcAuditEventConverter.class);\n+\n+    private final Map<Class, EventDataUtilizer> eventDataUtilizer;\n+\n+    public AuditEventToGrpcAuditEventConverter(Map<Class, EventDataUtilizer> eventDataUtilizer) {\n+        if (MapUtils.isNotEmpty(eventDataUtilizer)) {\n+            List<String> utilizers = new LinkedList<>();\n+            eventDataUtilizer.forEach((type, utilizer) -> utilizers.add(String.format(\"[%s :: %s]\",\n+                    NullUtil.getIfNotNull(type, t -> t.getSimpleName()),\n+                    NullUtil.getIfNotNull(utilizer, u -> u.getClass().getSimpleName()))));\n+            String utilizerListMessage = String.join(\",\", utilizers);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dc2bac5c66993a862f101bf9bd08791392c3bbbf"}, "originalPosition": 47}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODc3NTQwNg==", "bodyText": "Is this logging needed? If you insist on this logging, please move it to the Bean definition method in the Configuration class.", "url": "https://github.com/hortonworks/cloudbreak/pull/8255#discussion_r438775406", "createdAt": "2020-06-11T13:20:46Z", "author": {"login": "bergerdenes"}, "path": "audit-connector/src/main/java/com/sequenceiq/cloudbreak/audit/converter/AttemptAuditEventResultToGrpcAttemptAuditEventResultConverter.java", "diffHunk": "@@ -1,22 +1,47 @@\n package com.sequenceiq.cloudbreak.audit.converter;\n \n-import static com.sequenceiq.cloudbreak.util.ConditionBasedEvaluatorUtil.doIfTrue;\n-\n-import org.apache.commons.lang3.StringUtils;\n-import org.springframework.stereotype.Component;\n-\n import com.cloudera.thunderhead.service.audit.AuditProto;\n import com.sequenceiq.cloudbreak.audit.model.AttemptAuditEventResult;\n-import com.sequenceiq.cloudbreak.audit.model.ResultApiRequestData;\n import com.sequenceiq.cloudbreak.audit.model.ResultEventData;\n-import com.sequenceiq.cloudbreak.audit.model.ResultServiceEventData;\n+import com.sequenceiq.cloudbreak.util.NullUtil;\n+import org.apache.commons.collections.MapUtils;\n+import org.apache.commons.lang3.StringUtils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.stereotype.Component;\n+\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static com.sequenceiq.cloudbreak.util.ConditionBasedEvaluatorUtil.doIfTrue;\n \n @Component\n public class AttemptAuditEventResultToGrpcAttemptAuditEventResultConverter {\n \n+    private static final Logger LOGGER = LoggerFactory.getLogger(AttemptAuditEventResultToGrpcAttemptAuditEventResultConverter.class);\n+\n+    private final Map<Class, AuditEventDataUtilizer> auditEventDataUtilizers;\n+\n+    public AttemptAuditEventResultToGrpcAttemptAuditEventResultConverter(Map<Class, AuditEventDataUtilizer> auditEventDataUtilizers) {\n+        if (MapUtils.isNotEmpty(auditEventDataUtilizers)) {\n+            List<String> utilizers = new LinkedList<>();\n+            auditEventDataUtilizers.forEach((type, utilizer) -> utilizers.add(String.format(\"[%s :: %s]\",\n+                    NullUtil.getIfNotNull(type, t -> t.getSimpleName()),\n+                    NullUtil.getIfNotNull(utilizer, u -> u.getClass().getSimpleName()))));\n+            String utilizerListMessage = String.join(\",\", utilizers);\n+            LOGGER.debug(\"The \" + AttemptAuditEventResultToGrpcAttemptAuditEventResultConverter.class.getSimpleName() + \" has got the following \"\n+                    + AuditEventDataUtilizer.class.getSimpleName() + \" implementations: {}\", utilizerListMessage);\n+        } else {\n+            LOGGER.debug(\"The \" + AttemptAuditEventResultToGrpcAttemptAuditEventResultConverter.class.getSimpleName() + \" has not got any \"\n+                    + AuditEventDataUtilizer.class.getSimpleName() + \" implementation!\");\n+        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dc2bac5c66993a862f101bf9bd08791392c3bbbf"}, "originalPosition": 45}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODc4MTM2OA==", "bodyText": "please rename consistently with interface name", "url": "https://github.com/hortonworks/cloudbreak/pull/8255#discussion_r438781368", "createdAt": "2020-06-11T13:30:17Z", "author": {"login": "bergerdenes"}, "path": "audit-connector/src/main/java/com/sequenceiq/cloudbreak/audit/converter/ResultApiRequestDataUtilizer.java", "diffHunk": "@@ -0,0 +1,26 @@\n+package com.sequenceiq.cloudbreak.audit.converter;\n+\n+import com.cloudera.thunderhead.service.audit.AuditProto;\n+import com.sequenceiq.cloudbreak.audit.model.ResultApiRequestData;\n+import org.apache.commons.lang3.StringUtils;\n+import org.springframework.stereotype.Component;\n+\n+import static com.sequenceiq.cloudbreak.util.ConditionBasedEvaluatorUtil.doIfTrue;\n+\n+@Component\n+public class ResultApiRequestDataUtilizer implements AuditEventDataUtilizer<ResultApiRequestData> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dc2bac5c66993a862f101bf9bd08791392c3bbbf"}, "originalPosition": 11}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODc4MTQ2Mg==", "bodyText": "please rename consistently with interface name", "url": "https://github.com/hortonworks/cloudbreak/pull/8255#discussion_r438781462", "createdAt": "2020-06-11T13:30:26Z", "author": {"login": "bergerdenes"}, "path": "audit-connector/src/main/java/com/sequenceiq/cloudbreak/audit/converter/ResultServiceEventDataUtilizer.java", "diffHunk": "@@ -0,0 +1,27 @@\n+package com.sequenceiq.cloudbreak.audit.converter;\n+\n+import com.cloudera.thunderhead.service.audit.AuditProto;\n+import com.sequenceiq.cloudbreak.audit.model.ResultServiceEventData;\n+import org.apache.commons.lang3.StringUtils;\n+import org.springframework.stereotype.Component;\n+\n+import static com.sequenceiq.cloudbreak.util.ConditionBasedEvaluatorUtil.doIfTrue;\n+\n+@Component\n+public class ResultServiceEventDataUtilizer implements AuditEventDataUtilizer<ResultServiceEventData> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dc2bac5c66993a862f101bf9bd08791392c3bbbf"}, "originalPosition": 11}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODc4MTgxMw==", "bodyText": "please rename consistently with base class", "url": "https://github.com/hortonworks/cloudbreak/pull/8255#discussion_r438781813", "createdAt": "2020-06-11T13:30:58Z", "author": {"login": "bergerdenes"}, "path": "audit-connector/src/main/java/com/sequenceiq/cloudbreak/audit/converter/ServiceEventDataUtilizer.java", "diffHunk": "@@ -0,0 +1,26 @@\n+package com.sequenceiq.cloudbreak.audit.converter;\n+\n+import com.cloudera.thunderhead.service.audit.AuditProto;\n+import com.sequenceiq.cloudbreak.audit.model.ServiceEventData;\n+import org.apache.commons.lang3.StringUtils;\n+import org.springframework.stereotype.Component;\n+\n+import static com.sequenceiq.cloudbreak.util.ConditionBasedEvaluatorUtil.doIfTrue;\n+\n+@Component\n+public class ServiceEventDataUtilizer implements EventDataUtilizer<ServiceEventData> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dc2bac5c66993a862f101bf9bd08791392c3bbbf"}, "originalPosition": 11}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODc4MzAzOQ==", "bodyText": "times(0) -> never() (although its just cosmetics)", "url": "https://github.com/hortonworks/cloudbreak/pull/8255#discussion_r438783039", "createdAt": "2020-06-11T13:32:24Z", "author": {"login": "bergerdenes"}, "path": "audit-connector/src/test/java/com/sequenceiq/cloudbreak/audit/converter/AttemptAuditEventResultToGrpcAttemptAuditEventResultConverterTest.java", "diffHunk": "@@ -49,7 +63,18 @@ void testPreventPossibleNullValuesServiceApiRequestResult() {\n                 .withResourceCrns(CRNS)\n                 .build();\n         AttemptAuditEventResult source = makeMinimalAttemptAuditEventResult(resultServiceEventData);\n+        underTest = new AttemptAuditEventResultToGrpcAttemptAuditEventResultConverter(createMockUtilizer(ResultServiceEventData.class));\n+\n         underTest.convert(source);\n+        verify(mockAuditEventDataUtilizer, times(1)).modifyAuditEventBuilderWithEventData(any(), any());\n+    }\n+\n+    @Test\n+    void testWhenResultEventDataIsNullThenNoUtilizerCallHappens() {\n+        AttemptAuditEventResult source = makeMinimalAttemptAuditEventResult(null);\n+\n+        underTest.convert(source);\n+        verify(mockAuditEventDataUtilizer, times(0)).modifyAuditEventBuilderWithEventData(any(), any());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dc2bac5c66993a862f101bf9bd08791392c3bbbf"}, "originalPosition": 63}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODc4NDM3Mw==", "bodyText": "I prefer declarative @Mock but it's up to your taste.", "url": "https://github.com/hortonworks/cloudbreak/pull/8255#discussion_r438784373", "createdAt": "2020-06-11T13:33:47Z", "author": {"login": "bergerdenes"}, "path": "audit-connector/src/test/java/com/sequenceiq/cloudbreak/audit/converter/AttemptAuditEventResultToGrpcAttemptAuditEventResultConverterTest.java", "diffHunk": "@@ -35,7 +41,15 @@\n \n     private static final String RESPONSE_PARAMETERS = \"responseParameters\";\n \n-    private final AttemptAuditEventResultToGrpcAttemptAuditEventResultConverter underTest = new AttemptAuditEventResultToGrpcAttemptAuditEventResultConverter();\n+    private AttemptAuditEventResultToGrpcAttemptAuditEventResultConverter underTest;\n+\n+    private AuditEventDataUtilizer mockAuditEventDataUtilizer;\n+\n+    @BeforeEach\n+    void setUp() {\n+        underTest = new AttemptAuditEventResultToGrpcAttemptAuditEventResultConverter(new LinkedHashMap<>());\n+        mockAuditEventDataUtilizer = mock(AuditEventDataUtilizer.class);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dc2bac5c66993a862f101bf9bd08791392c3bbbf"}, "originalPosition": 43}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODc4Nzc4OQ==", "bodyText": "I miss these tests in for the recently refactored converter classes", "url": "https://github.com/hortonworks/cloudbreak/pull/8255#discussion_r438787789", "createdAt": "2020-06-11T13:37:22Z", "author": {"login": "bergerdenes"}, "path": "audit-connector/src/test/java/com/sequenceiq/cloudbreak/audit/converter/AuditEventToGrpcAuditEventConverterTest.java", "diffHunk": "@@ -115,13 +139,20 @@ void convertWithApiRequestData() {\n                 .build();\n         AuditEvent source = makeAuditEvent(actor, eventData);\n \n+        underTest = new AuditEventToGrpcAuditEventConverter(createMockUtilizer(ApiRequestData.class));\n+\n         AuditProto.AuditEvent target = underTest.convert(source);\n         assertGeneric(target);\n-        assertThat(target.getEventTypeCase()).isEqualTo(AuditProto.AuditEvent.EventTypeCase.APIREQUESTDATA);\n-        assertThat(target.getApiRequestData().getApiVersion()).isEqualTo(API_VERSION);\n-        assertThat(target.getApiRequestData().getMutating()).isEqualTo(MUTATING);\n-        assertThat(target.getApiRequestData().getRequestParameters()).isEqualTo(REQUEST_PARAMETERS);\n-        assertThat(target.getApiRequestData().getUserAgent()).isEqualTo(USER_AGENT);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dc2bac5c66993a862f101bf9bd08791392c3bbbf"}, "originalPosition": 99}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODc4ODIzNg==", "bodyText": "miss these tests in for the recently refactored converter classes", "url": "https://github.com/hortonworks/cloudbreak/pull/8255#discussion_r438788236", "createdAt": "2020-06-11T13:37:53Z", "author": {"login": "bergerdenes"}, "path": "audit-connector/src/test/java/com/sequenceiq/cloudbreak/audit/converter/AuditEventToGrpcAuditEventConverterTest.java", "diffHunk": "@@ -97,11 +121,11 @@ void convertWithServiceEventData() {\n                 .build();\n         AuditEvent source = makeAuditEvent(actor, eventData);\n \n+        underTest = new AuditEventToGrpcAuditEventConverter(createMockUtilizer(ServiceEventData.class));\n+\n         AuditProto.AuditEvent target = underTest.convert(source);\n         assertGeneric(target);\n-        assertThat(target.getEventTypeCase()).isEqualTo(AuditProto.AuditEvent.EventTypeCase.SERVICEEVENTDATA);\n-        assertThat(target.getServiceEventData().getDetailsVersion()).isEqualTo(SERVICE_EVENT_VERSION);\n-        assertThat(target.getServiceEventData().getEventDetails()).isEqualTo(SERVICE_EVENT_DETAILS);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dc2bac5c66993a862f101bf9bd08791392c3bbbf"}, "originalPosition": 82}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODc4ODUwNw==", "bodyText": "I miss these tests in for the recently refactored converter classes", "url": "https://github.com/hortonworks/cloudbreak/pull/8255#discussion_r438788507", "createdAt": "2020-06-11T13:38:09Z", "author": {"login": "bergerdenes"}, "path": "audit-connector/src/test/java/com/sequenceiq/cloudbreak/audit/converter/AttemptAuditEventResultToGrpcAttemptAuditEventResultConverterTest.java", "diffHunk": "@@ -68,22 +93,22 @@ void convertWithResultServiceEventData() {\n                 .withResultDetails(RESULT_DETAILS)\n                 .build();\n         AttemptAuditEventResult source = makeAttemptAuditEventResult(rsed);\n+        underTest = new AttemptAuditEventResultToGrpcAttemptAuditEventResultConverter(createMockUtilizer(ResultServiceEventData.class));\n \n         AuditProto.AttemptAuditEventResult target = underTest.convert(source);\n         assertGeneric(target);\n-        assertThat(target.getEventTypeCase()).isEqualTo(AuditProto.AttemptAuditEventResult.EventTypeCase.RESULTSERVICEEVENTDATA);\n-        assertThat(target.getResultServiceEventData().getResourceCrnList()).hasSameElementsAs(CRNS);\n-        assertThat(target.getResultServiceEventData().getResultDetails()).isEqualTo(RESULT_DETAILS);\n+        verify(mockAuditEventDataUtilizer, times(1)).modifyAuditEventBuilderWithEventData(any(), any());\n     }\n \n     @Test\n     void convertWithResultApiRequestData() {\n         ResultApiRequestData rsed = ResultApiRequestData.builder().withResponseParameters(RESPONSE_PARAMETERS).build();\n         AttemptAuditEventResult source = makeAttemptAuditEventResult(rsed);\n+        underTest = new AttemptAuditEventResultToGrpcAttemptAuditEventResultConverter(createMockUtilizer(ResultApiRequestData.class));\n \n         AuditProto.AttemptAuditEventResult target = underTest.convert(source);\n         assertGeneric(target);\n-        assertThat(target.getEventTypeCase()).isEqualTo(AuditProto.AttemptAuditEventResult.EventTypeCase.RESULTAPIREQUESTDATA);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dc2bac5c66993a862f101bf9bd08791392c3bbbf"}, "originalPosition": 89}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODc4ODc3NQ==", "bodyText": "I miss these tests in for the recently refactored converter classes", "url": "https://github.com/hortonworks/cloudbreak/pull/8255#discussion_r438788775", "createdAt": "2020-06-11T13:38:29Z", "author": {"login": "bergerdenes"}, "path": "audit-connector/src/test/java/com/sequenceiq/cloudbreak/audit/converter/AttemptAuditEventResultToGrpcAttemptAuditEventResultConverterTest.java", "diffHunk": "@@ -68,22 +93,22 @@ void convertWithResultServiceEventData() {\n                 .withResultDetails(RESULT_DETAILS)\n                 .build();\n         AttemptAuditEventResult source = makeAttemptAuditEventResult(rsed);\n+        underTest = new AttemptAuditEventResultToGrpcAttemptAuditEventResultConverter(createMockUtilizer(ResultServiceEventData.class));\n \n         AuditProto.AttemptAuditEventResult target = underTest.convert(source);\n         assertGeneric(target);\n-        assertThat(target.getEventTypeCase()).isEqualTo(AuditProto.AttemptAuditEventResult.EventTypeCase.RESULTSERVICEEVENTDATA);\n-        assertThat(target.getResultServiceEventData().getResourceCrnList()).hasSameElementsAs(CRNS);\n-        assertThat(target.getResultServiceEventData().getResultDetails()).isEqualTo(RESULT_DETAILS);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dc2bac5c66993a862f101bf9bd08791392c3bbbf"}, "originalPosition": 77}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "dc2bac5c66993a862f101bf9bd08791392c3bbbf", "author": {"user": {"login": "gregito", "name": "M\u00e9sz\u00e1ros Gergely"}}, "url": "https://github.com/hortonworks/cloudbreak/commit/dc2bac5c66993a862f101bf9bd08791392c3bbbf", "committedDate": "2020-06-11T08:40:46Z", "message": "CB-7082 - Use multiple implementations instead of instanceOf"}, "afterCommit": {"oid": "dda634562b104cbe877c4200a824a4182f8fe30a", "author": {"user": {"login": "gregito", "name": "M\u00e9sz\u00e1ros Gergely"}}, "url": "https://github.com/hortonworks/cloudbreak/commit/dda634562b104cbe877c4200a824a4182f8fe30a", "committedDate": "2020-06-11T14:54:50Z", "message": "CB-7082 - Use multiple implementations instead of instanceOf"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "dda634562b104cbe877c4200a824a4182f8fe30a", "author": {"user": {"login": "gregito", "name": "M\u00e9sz\u00e1ros Gergely"}}, "url": "https://github.com/hortonworks/cloudbreak/commit/dda634562b104cbe877c4200a824a4182f8fe30a", "committedDate": "2020-06-11T14:54:50Z", "message": "CB-7082 - Use multiple implementations instead of instanceOf"}, "afterCommit": {"oid": "0f57740c47c2189f980b63c4087dae4a65370188", "author": {"user": {"login": "gregito", "name": "M\u00e9sz\u00e1ros Gergely"}}, "url": "https://github.com/hortonworks/cloudbreak/commit/0f57740c47c2189f980b63c4087dae4a65370188", "committedDate": "2020-06-12T07:18:55Z", "message": "CB-7082 - Use multiple implementations instead of instanceOf"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMwNjI5OTI3", "url": "https://github.com/hortonworks/cloudbreak/pull/8255#pullrequestreview-430629927", "createdAt": "2020-06-15T13:13:31Z", "commit": {"oid": "0f57740c47c2189f980b63c4087dae4a65370188"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 11, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNVQxMzoxMzozMVrOGjxkrw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNVQxMzo0MDowN1rOGjynQQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDE2NTU1MQ==", "bodyText": "auditEventBuilderUpdaters", "url": "https://github.com/hortonworks/cloudbreak/pull/8255#discussion_r440165551", "createdAt": "2020-06-15T13:13:31Z", "author": {"login": "bergerdenes"}, "path": "audit-connector/src/main/java/com/sequenceiq/cloudbreak/audit/config/AuditConfig.java", "diffHunk": "@@ -1,20 +1,40 @@\n package com.sequenceiq.cloudbreak.audit.config;\n \n \n+import com.sequenceiq.cloudbreak.audit.converter.AttemptAuditEventResultBuilderUpdater;\n+import com.sequenceiq.cloudbreak.audit.converter.AuditEventBuilderUpdater;\n+import com.sequenceiq.cloudbreak.util.NullUtil;\n+import io.netty.util.internal.StringUtil;\n+import org.apache.commons.collections.MapUtils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n import org.springframework.beans.factory.annotation.Value;\n+import org.springframework.context.annotation.Bean;\n import org.springframework.context.annotation.Configuration;\n \n-import io.netty.util.internal.StringUtil;\n+import javax.inject.Inject;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n \n @Configuration\n public class AuditConfig {\n \n+    private static final Logger LOGGER = LoggerFactory.getLogger(AuditConfig.class);\n+\n     @Value(\"${altus.audit.host:}\")\n     private String endpoint;\n \n     @Value(\"${altus.audit.port:8989}\")\n     private int port;\n \n+    @Inject\n+    private List<AuditEventBuilderUpdater> auditEventBuilderUpdaterImplementations;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0f57740c47c2189f980b63c4087dae4a65370188"}, "originalPosition": 34}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDE2NTgwNg==", "bodyText": "attemptAuditEventResultBuilderUpdaters\nstill long enough", "url": "https://github.com/hortonworks/cloudbreak/pull/8255#discussion_r440165806", "createdAt": "2020-06-15T13:13:58Z", "author": {"login": "bergerdenes"}, "path": "audit-connector/src/main/java/com/sequenceiq/cloudbreak/audit/config/AuditConfig.java", "diffHunk": "@@ -1,20 +1,40 @@\n package com.sequenceiq.cloudbreak.audit.config;\n \n \n+import com.sequenceiq.cloudbreak.audit.converter.AttemptAuditEventResultBuilderUpdater;\n+import com.sequenceiq.cloudbreak.audit.converter.AuditEventBuilderUpdater;\n+import com.sequenceiq.cloudbreak.util.NullUtil;\n+import io.netty.util.internal.StringUtil;\n+import org.apache.commons.collections.MapUtils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n import org.springframework.beans.factory.annotation.Value;\n+import org.springframework.context.annotation.Bean;\n import org.springframework.context.annotation.Configuration;\n \n-import io.netty.util.internal.StringUtil;\n+import javax.inject.Inject;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n \n @Configuration\n public class AuditConfig {\n \n+    private static final Logger LOGGER = LoggerFactory.getLogger(AuditConfig.class);\n+\n     @Value(\"${altus.audit.host:}\")\n     private String endpoint;\n \n     @Value(\"${altus.audit.port:8989}\")\n     private int port;\n \n+    @Inject\n+    private List<AuditEventBuilderUpdater> auditEventBuilderUpdaterImplementations;\n+\n+    @Inject\n+    private List<AttemptAuditEventResultBuilderUpdater> attemptAuditEventResultBuilderUpdaterImplementations;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0f57740c47c2189f980b63c4087dae4a65370188"}, "originalPosition": 37}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDE2NjM5MA==", "bodyText": "Collectors.joining(\",\")", "url": "https://github.com/hortonworks/cloudbreak/pull/8255#discussion_r440166390", "createdAt": "2020-06-15T13:14:57Z", "author": {"login": "bergerdenes"}, "path": "audit-connector/src/main/java/com/sequenceiq/cloudbreak/audit/config/AuditConfig.java", "diffHunk": "@@ -26,4 +46,44 @@ public int getPort() {\n     public boolean isConfigured() {\n         return !StringUtil.isNullOrEmpty(endpoint);\n     }\n+\n+    @Bean\n+    public Map<Class, AuditEventBuilderUpdater> eventDataUtilizers() {\n+        Map<Class, AuditEventBuilderUpdater> result = new LinkedHashMap<>(auditEventBuilderUpdaterImplementations.size());\n+        auditEventBuilderUpdaterImplementations.forEach(utilizer -> result.put(utilizer.getType(), utilizer));\n+        if (MapUtils.isNotEmpty(result)) {\n+            List<String> eventDataUtilizers = result.entrySet().stream().map(classAuditEventDataUtilizerEntry -> {\n+                return String.format(\"[%s :: %s]\",\n+                        NullUtil.getIfNotNull(classAuditEventDataUtilizerEntry.getKey(), t -> t.getSimpleName()),\n+                        NullUtil.getIfNotNull(classAuditEventDataUtilizerEntry.getValue(), u -> u.getClass().getSimpleName()));\n+            }).collect(Collectors.toList());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0f57740c47c2189f980b63c4087dae4a65370188"}, "originalPosition": 56}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDE2Njg5OQ==", "bodyText": "return is not needed, neither the {}", "url": "https://github.com/hortonworks/cloudbreak/pull/8255#discussion_r440166899", "createdAt": "2020-06-15T13:15:42Z", "author": {"login": "bergerdenes"}, "path": "audit-connector/src/main/java/com/sequenceiq/cloudbreak/audit/config/AuditConfig.java", "diffHunk": "@@ -26,4 +46,44 @@ public int getPort() {\n     public boolean isConfigured() {\n         return !StringUtil.isNullOrEmpty(endpoint);\n     }\n+\n+    @Bean\n+    public Map<Class, AuditEventBuilderUpdater> eventDataUtilizers() {\n+        Map<Class, AuditEventBuilderUpdater> result = new LinkedHashMap<>(auditEventBuilderUpdaterImplementations.size());\n+        auditEventBuilderUpdaterImplementations.forEach(utilizer -> result.put(utilizer.getType(), utilizer));\n+        if (MapUtils.isNotEmpty(result)) {\n+            List<String> eventDataUtilizers = result.entrySet().stream().map(classAuditEventDataUtilizerEntry -> {\n+                return String.format(\"[%s :: %s]\",\n+                        NullUtil.getIfNotNull(classAuditEventDataUtilizerEntry.getKey(), t -> t.getSimpleName()),\n+                        NullUtil.getIfNotNull(classAuditEventDataUtilizerEntry.getValue(), u -> u.getClass().getSimpleName()));\n+            }).collect(Collectors.toList());\n+            String utilizerListMessage = String.join(\",\", eventDataUtilizers);\n+            LOGGER.debug(\"The \" + AuditEventBuilderUpdater.class.getSimpleName() + \" has the following implementations: {}\", utilizerListMessage);\n+        } else {\n+            LOGGER.debug(\"The \" + AuditEventBuilderUpdater.class.getSimpleName() + \" has no any implementation!\");\n+        }\n+        return result;\n+    }\n+\n+    @Bean\n+    public Map<Class, AttemptAuditEventResultBuilderUpdater> auditEventDataUtilizers() {\n+        Map<Class, AttemptAuditEventResultBuilderUpdater> result = new LinkedHashMap<>(attemptAuditEventResultBuilderUpdaterImplementations.size());\n+        attemptAuditEventResultBuilderUpdaterImplementations.forEach(utilizer -> result.put(utilizer.getType(), utilizer));\n+        if (MapUtils.isNotEmpty(result)) {\n+            List<String> auditEventDataUtilizers = result.entrySet().stream().map(classAuditEventDataUtilizerEntry -> {\n+                return String.format(\"[%s :: %s]\",", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0f57740c47c2189f980b63c4087dae4a65370188"}, "originalPosition": 71}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDE2NzI4MQ==", "bodyText": "Collectors.joining", "url": "https://github.com/hortonworks/cloudbreak/pull/8255#discussion_r440167281", "createdAt": "2020-06-15T13:16:19Z", "author": {"login": "bergerdenes"}, "path": "audit-connector/src/main/java/com/sequenceiq/cloudbreak/audit/config/AuditConfig.java", "diffHunk": "@@ -26,4 +46,44 @@ public int getPort() {\n     public boolean isConfigured() {\n         return !StringUtil.isNullOrEmpty(endpoint);\n     }\n+\n+    @Bean\n+    public Map<Class, AuditEventBuilderUpdater> eventDataUtilizers() {\n+        Map<Class, AuditEventBuilderUpdater> result = new LinkedHashMap<>(auditEventBuilderUpdaterImplementations.size());\n+        auditEventBuilderUpdaterImplementations.forEach(utilizer -> result.put(utilizer.getType(), utilizer));\n+        if (MapUtils.isNotEmpty(result)) {\n+            List<String> eventDataUtilizers = result.entrySet().stream().map(classAuditEventDataUtilizerEntry -> {\n+                return String.format(\"[%s :: %s]\",\n+                        NullUtil.getIfNotNull(classAuditEventDataUtilizerEntry.getKey(), t -> t.getSimpleName()),\n+                        NullUtil.getIfNotNull(classAuditEventDataUtilizerEntry.getValue(), u -> u.getClass().getSimpleName()));\n+            }).collect(Collectors.toList());\n+            String utilizerListMessage = String.join(\",\", eventDataUtilizers);\n+            LOGGER.debug(\"The \" + AuditEventBuilderUpdater.class.getSimpleName() + \" has the following implementations: {}\", utilizerListMessage);\n+        } else {\n+            LOGGER.debug(\"The \" + AuditEventBuilderUpdater.class.getSimpleName() + \" has no any implementation!\");\n+        }\n+        return result;\n+    }\n+\n+    @Bean\n+    public Map<Class, AttemptAuditEventResultBuilderUpdater> auditEventDataUtilizers() {\n+        Map<Class, AttemptAuditEventResultBuilderUpdater> result = new LinkedHashMap<>(attemptAuditEventResultBuilderUpdaterImplementations.size());\n+        attemptAuditEventResultBuilderUpdaterImplementations.forEach(utilizer -> result.put(utilizer.getType(), utilizer));\n+        if (MapUtils.isNotEmpty(result)) {\n+            List<String> auditEventDataUtilizers = result.entrySet().stream().map(classAuditEventDataUtilizerEntry -> {\n+                return String.format(\"[%s :: %s]\",\n+                        NullUtil.getIfNotNull(classAuditEventDataUtilizerEntry.getKey(), t -> t.getSimpleName()),\n+                        NullUtil.getIfNotNull(classAuditEventDataUtilizerEntry.getValue(), u -> u.getClass().getSimpleName()));\n+            }).collect(Collectors.toList());\n+            result.forEach((type, utilizer) -> auditEventDataUtilizers.add(String.format(\"[%s :: %s]\",\n+                    NullUtil.getIfNotNull(type, t -> t.getSimpleName()),\n+                    NullUtil.getIfNotNull(utilizer, u -> u.getClass().getSimpleName()))));\n+            String utilizerListMessage = String.join(\",\", auditEventDataUtilizers);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0f57740c47c2189f980b63c4087dae4a65370188"}, "originalPosition": 78}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDE2ODIzOQ==", "bodyText": "it is not \"utilizer\" anymore", "url": "https://github.com/hortonworks/cloudbreak/pull/8255#discussion_r440168239", "createdAt": "2020-06-15T13:17:47Z", "author": {"login": "bergerdenes"}, "path": "audit-connector/src/main/java/com/sequenceiq/cloudbreak/audit/converter/AttemptAuditEventResultToGrpcAttemptAuditEventResultConverter.java", "diffHunk": "@@ -1,22 +1,31 @@\n package com.sequenceiq.cloudbreak.audit.converter;\n \n-import static com.sequenceiq.cloudbreak.util.ConditionBasedEvaluatorUtil.doIfTrue;\n-\n-import org.apache.commons.lang3.StringUtils;\n-import org.springframework.stereotype.Component;\n-\n import com.cloudera.thunderhead.service.audit.AuditProto;\n import com.sequenceiq.cloudbreak.audit.model.AttemptAuditEventResult;\n-import com.sequenceiq.cloudbreak.audit.model.ResultApiRequestData;\n import com.sequenceiq.cloudbreak.audit.model.ResultEventData;\n-import com.sequenceiq.cloudbreak.audit.model.ResultServiceEventData;\n+import org.apache.commons.lang3.StringUtils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.stereotype.Component;\n+\n+import java.util.Map;\n+\n+import static com.sequenceiq.cloudbreak.util.ConditionBasedEvaluatorUtil.doIfTrue;\n \n @Component\n public class AttemptAuditEventResultToGrpcAttemptAuditEventResultConverter {\n \n+    private static final Logger LOGGER = LoggerFactory.getLogger(AttemptAuditEventResultToGrpcAttemptAuditEventResultConverter.class);\n+\n+    private final Map<Class, AttemptAuditEventResultBuilderUpdater> auditEventDataUtilizers;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0f57740c47c2189f980b63c4087dae4a65370188"}, "originalPosition": 27}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDE2ODY2Nw==", "bodyText": "\"WithEventData\" could be omitted\nmoreover, update would be adequate", "url": "https://github.com/hortonworks/cloudbreak/pull/8255#discussion_r440168667", "createdAt": "2020-06-15T13:18:28Z", "author": {"login": "bergerdenes"}, "path": "audit-connector/src/main/java/com/sequenceiq/cloudbreak/audit/converter/AuditEventBuilderUpdater.java", "diffHunk": "@@ -0,0 +1,12 @@\n+package com.sequenceiq.cloudbreak.audit.converter;\n+\n+import com.cloudera.thunderhead.service.audit.AuditProto;\n+import com.sequenceiq.cloudbreak.audit.model.EventData;\n+\n+public interface AuditEventBuilderUpdater<T extends EventData> {\n+\n+    void updateAuditEventBuilderWithEventData(AuditProto.AuditEvent.Builder auditEventBuilder, T source);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0f57740c47c2189f980b63c4087dae4a65370188"}, "originalPosition": 8}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDE2ODc5Nw==", "bodyText": "not \"utilizer\" anymore", "url": "https://github.com/hortonworks/cloudbreak/pull/8255#discussion_r440168797", "createdAt": "2020-06-15T13:18:40Z", "author": {"login": "bergerdenes"}, "path": "audit-connector/src/main/java/com/sequenceiq/cloudbreak/audit/converter/AuditEventToGrpcAuditEventConverter.java", "diffHunk": "@@ -1,25 +1,33 @@\n package com.sequenceiq.cloudbreak.audit.converter;\n \n-import static com.sequenceiq.cloudbreak.util.ConditionBasedEvaluatorUtil.doIfTrue;\n-import static com.sequenceiq.cloudbreak.util.UuidUtil.uuidSupplier;\n-\n-import java.util.Optional;\n-\n-import org.apache.commons.lang3.StringUtils;\n-import org.springframework.stereotype.Component;\n-\n import com.cloudera.thunderhead.service.audit.AuditProto;\n import com.sequenceiq.cloudbreak.audit.model.ActorBase;\n import com.sequenceiq.cloudbreak.audit.model.ActorCrn;\n import com.sequenceiq.cloudbreak.audit.model.ActorService;\n-import com.sequenceiq.cloudbreak.audit.model.ApiRequestData;\n import com.sequenceiq.cloudbreak.audit.model.AuditEvent;\n import com.sequenceiq.cloudbreak.audit.model.EventData;\n-import com.sequenceiq.cloudbreak.audit.model.ServiceEventData;\n+import org.apache.commons.lang3.StringUtils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.stereotype.Component;\n+\n+import java.util.Map;\n+import java.util.Optional;\n+\n+import static com.sequenceiq.cloudbreak.util.ConditionBasedEvaluatorUtil.doIfTrue;\n+import static com.sequenceiq.cloudbreak.util.UuidUtil.uuidSupplier;\n \n @Component\n public class AuditEventToGrpcAuditEventConverter {\n \n+    private static final Logger LOGGER = LoggerFactory.getLogger(AuditEventToGrpcAuditEventConverter.class);\n+\n+    private final Map<Class, AuditEventBuilderUpdater> eventDataUtilizer;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0f57740c47c2189f980b63c4087dae4a65370188"}, "originalPosition": 35}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDE3NDU5NA==", "bodyText": "update would be adequate", "url": "https://github.com/hortonworks/cloudbreak/pull/8255#discussion_r440174594", "createdAt": "2020-06-15T13:28:01Z", "author": {"login": "bergerdenes"}, "path": "audit-connector/src/main/java/com/sequenceiq/cloudbreak/audit/converter/AttemptAuditEventResultBuilderUpdater.java", "diffHunk": "@@ -0,0 +1,12 @@\n+package com.sequenceiq.cloudbreak.audit.converter;\n+\n+import com.cloudera.thunderhead.service.audit.AuditProto;\n+import com.sequenceiq.cloudbreak.audit.model.ResultEventData;\n+\n+public interface AttemptAuditEventResultBuilderUpdater<T extends ResultEventData> {\n+\n+    void updateAttemptAuditEventResultBuilderWithEventData(AuditProto.AttemptAuditEventResult.Builder builder, T source);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0f57740c47c2189f980b63c4087dae4a65370188"}, "originalPosition": 8}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDE4MjA5Ng==", "bodyText": "ResultApiRequestResultBuilderUpdaterAttempt is a way overcomplicated name.\nI would have still stuck to naming the interface to reflect the converter nature: AttemptAuditEventResultConverter\nand then name this class like ResultApiRequestConverter\nThoughts?", "url": "https://github.com/hortonworks/cloudbreak/pull/8255#discussion_r440182096", "createdAt": "2020-06-15T13:39:29Z", "author": {"login": "bergerdenes"}, "path": "audit-connector/src/main/java/com/sequenceiq/cloudbreak/audit/converter/ResultApiRequestResultBuilderUpdaterAttempt.java", "diffHunk": "@@ -0,0 +1,26 @@\n+package com.sequenceiq.cloudbreak.audit.converter;\n+\n+import com.cloudera.thunderhead.service.audit.AuditProto;\n+import com.sequenceiq.cloudbreak.audit.model.ResultApiRequestData;\n+import org.apache.commons.lang3.StringUtils;\n+import org.springframework.stereotype.Component;\n+\n+import static com.sequenceiq.cloudbreak.util.ConditionBasedEvaluatorUtil.doIfTrue;\n+\n+@Component\n+public class ResultApiRequestResultBuilderUpdaterAttempt implements AttemptAuditEventResultBuilderUpdater<ResultApiRequestData> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0f57740c47c2189f980b63c4087dae4a65370188"}, "originalPosition": 11}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDE4MjU5Mw==", "bodyText": "same as above. this name is way too compex", "url": "https://github.com/hortonworks/cloudbreak/pull/8255#discussion_r440182593", "createdAt": "2020-06-15T13:40:07Z", "author": {"login": "bergerdenes"}, "path": "audit-connector/src/main/java/com/sequenceiq/cloudbreak/audit/converter/ResultServiceEventResultBuilderUpdaterAttempt.java", "diffHunk": "@@ -0,0 +1,27 @@\n+package com.sequenceiq.cloudbreak.audit.converter;\n+\n+import com.cloudera.thunderhead.service.audit.AuditProto;\n+import com.sequenceiq.cloudbreak.audit.model.ResultServiceEventData;\n+import org.apache.commons.lang3.StringUtils;\n+import org.springframework.stereotype.Component;\n+\n+import static com.sequenceiq.cloudbreak.util.ConditionBasedEvaluatorUtil.doIfTrue;\n+\n+@Component\n+public class ResultServiceEventResultBuilderUpdaterAttempt implements AttemptAuditEventResultBuilderUpdater<ResultServiceEventData> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0f57740c47c2189f980b63c4087dae4a65370188"}, "originalPosition": 11}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "0f57740c47c2189f980b63c4087dae4a65370188", "author": {"user": {"login": "gregito", "name": "M\u00e9sz\u00e1ros Gergely"}}, "url": "https://github.com/hortonworks/cloudbreak/commit/0f57740c47c2189f980b63c4087dae4a65370188", "committedDate": "2020-06-12T07:18:55Z", "message": "CB-7082 - Use multiple implementations instead of instanceOf"}, "afterCommit": {"oid": "8f96166859b53cb860f65c9416df911da68d8916", "author": {"user": {"login": "gregito", "name": "M\u00e9sz\u00e1ros Gergely"}}, "url": "https://github.com/hortonworks/cloudbreak/commit/8f96166859b53cb860f65c9416df911da68d8916", "committedDate": "2020-06-15T15:09:43Z", "message": "CB-7082 - Use multiple implementations instead of instanceOf"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "8f96166859b53cb860f65c9416df911da68d8916", "author": {"user": {"login": "gregito", "name": "M\u00e9sz\u00e1ros Gergely"}}, "url": "https://github.com/hortonworks/cloudbreak/commit/8f96166859b53cb860f65c9416df911da68d8916", "committedDate": "2020-06-15T15:09:43Z", "message": "CB-7082 - Use multiple implementations instead of instanceOf"}, "afterCommit": {"oid": "864f2277527a0b13dc29ff29cbb7c6b32de82d75", "author": {"user": {"login": "gregito", "name": "M\u00e9sz\u00e1ros Gergely"}}, "url": "https://github.com/hortonworks/cloudbreak/commit/864f2277527a0b13dc29ff29cbb7c6b32de82d75", "committedDate": "2020-06-15T21:33:48Z", "message": "CB-7082 - Use multiple implementations instead of instanceOf"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "864f2277527a0b13dc29ff29cbb7c6b32de82d75", "author": {"user": {"login": "gregito", "name": "M\u00e9sz\u00e1ros Gergely"}}, "url": "https://github.com/hortonworks/cloudbreak/commit/864f2277527a0b13dc29ff29cbb7c6b32de82d75", "committedDate": "2020-06-15T21:33:48Z", "message": "CB-7082 - Use multiple implementations instead of instanceOf"}, "afterCommit": {"oid": "646a2b0546dc0ef0f70f536880242fc7d49ade3e", "author": {"user": {"login": "gregito", "name": "M\u00e9sz\u00e1ros Gergely"}}, "url": "https://github.com/hortonworks/cloudbreak/commit/646a2b0546dc0ef0f70f536880242fc7d49ade3e", "committedDate": "2020-06-16T04:51:51Z", "message": "CB-7082 - Use multiple implementations instead of instanceOf"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "646a2b0546dc0ef0f70f536880242fc7d49ade3e", "author": {"user": {"login": "gregito", "name": "M\u00e9sz\u00e1ros Gergely"}}, "url": "https://github.com/hortonworks/cloudbreak/commit/646a2b0546dc0ef0f70f536880242fc7d49ade3e", "committedDate": "2020-06-16T04:51:51Z", "message": "CB-7082 - Use multiple implementations instead of instanceOf"}, "afterCommit": {"oid": "f5384bb5baff17a1b0fab926162ac689e6a0e4b9", "author": {"user": {"login": "gregito", "name": "M\u00e9sz\u00e1ros Gergely"}}, "url": "https://github.com/hortonworks/cloudbreak/commit/f5384bb5baff17a1b0fab926162ac689e6a0e4b9", "committedDate": "2020-06-16T05:11:02Z", "message": "CB-7082 - Use multiple implementations instead of instanceOf"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "f5384bb5baff17a1b0fab926162ac689e6a0e4b9", "author": {"user": {"login": "gregito", "name": "M\u00e9sz\u00e1ros Gergely"}}, "url": "https://github.com/hortonworks/cloudbreak/commit/f5384bb5baff17a1b0fab926162ac689e6a0e4b9", "committedDate": "2020-06-16T05:11:02Z", "message": "CB-7082 - Use multiple implementations instead of instanceOf"}, "afterCommit": {"oid": "af5bfc4286864634e9d039edee46aa838719db75", "author": {"user": {"login": "gregito", "name": "M\u00e9sz\u00e1ros Gergely"}}, "url": "https://github.com/hortonworks/cloudbreak/commit/af5bfc4286864634e9d039edee46aa838719db75", "committedDate": "2020-06-16T05:39:03Z", "message": "CB-7082 - Use multiple implementations instead of instanceOf"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "af5bfc4286864634e9d039edee46aa838719db75", "author": {"user": {"login": "gregito", "name": "M\u00e9sz\u00e1ros Gergely"}}, "url": "https://github.com/hortonworks/cloudbreak/commit/af5bfc4286864634e9d039edee46aa838719db75", "committedDate": "2020-06-16T05:39:03Z", "message": "CB-7082 - Use multiple implementations instead of instanceOf"}, "afterCommit": {"oid": "eec1e40ba435f621d02548b72c14cc9cb40e3679", "author": {"user": {"login": "gregito", "name": "M\u00e9sz\u00e1ros Gergely"}}, "url": "https://github.com/hortonworks/cloudbreak/commit/eec1e40ba435f621d02548b72c14cc9cb40e3679", "committedDate": "2020-06-16T05:44:44Z", "message": "CB-7082 - Use multiple implementations instead of instanceOf"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "eec1e40ba435f621d02548b72c14cc9cb40e3679", "author": {"user": {"login": "gregito", "name": "M\u00e9sz\u00e1ros Gergely"}}, "url": "https://github.com/hortonworks/cloudbreak/commit/eec1e40ba435f621d02548b72c14cc9cb40e3679", "committedDate": "2020-06-16T05:44:44Z", "message": "CB-7082 - Use multiple implementations instead of instanceOf"}, "afterCommit": {"oid": "e03b9634216f10311ed6f1cf62b1d81468b95508", "author": {"user": {"login": "gregito", "name": "M\u00e9sz\u00e1ros Gergely"}}, "url": "https://github.com/hortonworks/cloudbreak/commit/e03b9634216f10311ed6f1cf62b1d81468b95508", "committedDate": "2020-06-16T05:54:02Z", "message": "CB-7082 - Use multiple implementations instead of instanceOf"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "e03b9634216f10311ed6f1cf62b1d81468b95508", "author": {"user": {"login": "gregito", "name": "M\u00e9sz\u00e1ros Gergely"}}, "url": "https://github.com/hortonworks/cloudbreak/commit/e03b9634216f10311ed6f1cf62b1d81468b95508", "committedDate": "2020-06-16T05:54:02Z", "message": "CB-7082 - Use multiple implementations instead of instanceOf"}, "afterCommit": {"oid": "dc440cd706536c3b143c641e39fe2350f2518311", "author": {"user": {"login": "gregito", "name": "M\u00e9sz\u00e1ros Gergely"}}, "url": "https://github.com/hortonworks/cloudbreak/commit/dc440cd706536c3b143c641e39fe2350f2518311", "committedDate": "2020-06-16T06:18:01Z", "message": "CB-7082 - Use multiple implementations instead of instanceOf"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMyNjkxMzg2", "url": "https://github.com/hortonworks/cloudbreak/pull/8255#pullrequestreview-432691386", "createdAt": "2020-06-17T19:01:49Z", "commit": {"oid": "dc440cd706536c3b143c641e39fe2350f2518311"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xN1QxOTowMTo0OVrOGlTc7w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xN1QxOTowMzoyOFrOGlTgbA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTc2OTE5OQ==", "bodyText": "what is the reason behind this? besides, it is not consistent with the other converter class", "url": "https://github.com/hortonworks/cloudbreak/pull/8255#discussion_r441769199", "createdAt": "2020-06-17T19:01:49Z", "author": {"login": "bergerdenes"}, "path": "audit-connector/src/main/java/com/sequenceiq/cloudbreak/audit/converter/AttemptAuditEventResultToGrpcAttemptAuditEventResultConverter.java", "diffHunk": "@@ -1,51 +1,46 @@\n package com.sequenceiq.cloudbreak.audit.converter;\n \n-import static com.sequenceiq.cloudbreak.util.ConditionBasedEvaluatorUtil.doIfTrue;\n-\n-import org.apache.commons.lang3.StringUtils;\n-import org.springframework.stereotype.Component;\n-\n import com.cloudera.thunderhead.service.audit.AuditProto;\n+import com.sequenceiq.cloudbreak.audit.converter.builder.AttemptAuditEventResultBuilderProvider;\n import com.sequenceiq.cloudbreak.audit.model.AttemptAuditEventResult;\n-import com.sequenceiq.cloudbreak.audit.model.ResultApiRequestData;\n import com.sequenceiq.cloudbreak.audit.model.ResultEventData;\n-import com.sequenceiq.cloudbreak.audit.model.ResultServiceEventData;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.stereotype.Component;\n+\n+import java.util.Map;\n \n @Component\n public class AttemptAuditEventResultToGrpcAttemptAuditEventResultConverter {\n \n-    public AuditProto.AttemptAuditEventResult convert(AttemptAuditEventResult source) {\n-        AuditProto.AttemptAuditEventResult.Builder attemptAuditEventResultBuilder = prepareBuilderForCreateAuditEvent(source);\n-        updatResultEventData(attemptAuditEventResultBuilder, source.getResultEventData());\n-        return attemptAuditEventResultBuilder.build();\n+    private static final Logger LOGGER = LoggerFactory.getLogger(AttemptAuditEventResultToGrpcAttemptAuditEventResultConverter.class);\n+\n+    private final Map<Class, AttemptAuditEventResultBuilderUpdater> builderUpdater;\n+\n+    private final AttemptAuditEventResultBuilderProvider builderProvider;\n+\n+    public AttemptAuditEventResultToGrpcAttemptAuditEventResultConverter(Map<Class, AttemptAuditEventResultBuilderUpdater> builderUpdater,\n+                    AttemptAuditEventResultBuilderProvider builderProvider) {\n+        this.builderUpdater = builderUpdater;\n+        this.builderProvider = builderProvider;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dc440cd706536c3b143c641e39fe2350f2518311"}, "originalPosition": 36}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTc2OTMwMA==", "bodyText": "should be plural", "url": "https://github.com/hortonworks/cloudbreak/pull/8255#discussion_r441769300", "createdAt": "2020-06-17T19:02:00Z", "author": {"login": "bergerdenes"}, "path": "audit-connector/src/main/java/com/sequenceiq/cloudbreak/audit/converter/AttemptAuditEventResultToGrpcAttemptAuditEventResultConverter.java", "diffHunk": "@@ -1,51 +1,46 @@\n package com.sequenceiq.cloudbreak.audit.converter;\n \n-import static com.sequenceiq.cloudbreak.util.ConditionBasedEvaluatorUtil.doIfTrue;\n-\n-import org.apache.commons.lang3.StringUtils;\n-import org.springframework.stereotype.Component;\n-\n import com.cloudera.thunderhead.service.audit.AuditProto;\n+import com.sequenceiq.cloudbreak.audit.converter.builder.AttemptAuditEventResultBuilderProvider;\n import com.sequenceiq.cloudbreak.audit.model.AttemptAuditEventResult;\n-import com.sequenceiq.cloudbreak.audit.model.ResultApiRequestData;\n import com.sequenceiq.cloudbreak.audit.model.ResultEventData;\n-import com.sequenceiq.cloudbreak.audit.model.ResultServiceEventData;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.stereotype.Component;\n+\n+import java.util.Map;\n \n @Component\n public class AttemptAuditEventResultToGrpcAttemptAuditEventResultConverter {\n \n-    public AuditProto.AttemptAuditEventResult convert(AttemptAuditEventResult source) {\n-        AuditProto.AttemptAuditEventResult.Builder attemptAuditEventResultBuilder = prepareBuilderForCreateAuditEvent(source);\n-        updatResultEventData(attemptAuditEventResultBuilder, source.getResultEventData());\n-        return attemptAuditEventResultBuilder.build();\n+    private static final Logger LOGGER = LoggerFactory.getLogger(AttemptAuditEventResultToGrpcAttemptAuditEventResultConverter.class);\n+\n+    private final Map<Class, AttemptAuditEventResultBuilderUpdater> builderUpdater;\n+\n+    private final AttemptAuditEventResultBuilderProvider builderProvider;\n+\n+    public AttemptAuditEventResultToGrpcAttemptAuditEventResultConverter(Map<Class, AttemptAuditEventResultBuilderUpdater> builderUpdater,\n+                    AttemptAuditEventResultBuilderProvider builderProvider) {\n+        this.builderUpdater = builderUpdater;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dc440cd706536c3b143c641e39fe2350f2518311"}, "originalPosition": 35}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTc3MDA5Mg==", "bodyText": "should be plural", "url": "https://github.com/hortonworks/cloudbreak/pull/8255#discussion_r441770092", "createdAt": "2020-06-17T19:03:28Z", "author": {"login": "bergerdenes"}, "path": "audit-connector/src/main/java/com/sequenceiq/cloudbreak/audit/converter/AuditEventToGrpcAuditEventConverter.java", "diffHunk": "@@ -1,25 +1,33 @@\n package com.sequenceiq.cloudbreak.audit.converter;\n \n-import static com.sequenceiq.cloudbreak.util.ConditionBasedEvaluatorUtil.doIfTrue;\n-import static com.sequenceiq.cloudbreak.util.UuidUtil.uuidSupplier;\n-\n-import java.util.Optional;\n-\n-import org.apache.commons.lang3.StringUtils;\n-import org.springframework.stereotype.Component;\n-\n import com.cloudera.thunderhead.service.audit.AuditProto;\n import com.sequenceiq.cloudbreak.audit.model.ActorBase;\n import com.sequenceiq.cloudbreak.audit.model.ActorCrn;\n import com.sequenceiq.cloudbreak.audit.model.ActorService;\n-import com.sequenceiq.cloudbreak.audit.model.ApiRequestData;\n import com.sequenceiq.cloudbreak.audit.model.AuditEvent;\n import com.sequenceiq.cloudbreak.audit.model.EventData;\n-import com.sequenceiq.cloudbreak.audit.model.ServiceEventData;\n+import org.apache.commons.lang3.StringUtils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.stereotype.Component;\n+\n+import java.util.Map;\n+import java.util.Optional;\n+\n+import static com.sequenceiq.cloudbreak.util.ConditionBasedEvaluatorUtil.doIfTrue;\n+import static com.sequenceiq.cloudbreak.util.UuidUtil.uuidSupplier;\n \n @Component\n public class AuditEventToGrpcAuditEventConverter {\n \n+    private static final Logger LOGGER = LoggerFactory.getLogger(AuditEventToGrpcAuditEventConverter.class);\n+\n+    private final Map<Class, AuditEventBuilderUpdater> builderUpdater;\n+\n+    public AuditEventToGrpcAuditEventConverter(Map<Class, AuditEventBuilderUpdater> builderUpdater) {\n+        this.builderUpdater = builderUpdater;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dc440cd706536c3b143c641e39fe2350f2518311"}, "originalPosition": 38}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "dc440cd706536c3b143c641e39fe2350f2518311", "author": {"user": {"login": "gregito", "name": "M\u00e9sz\u00e1ros Gergely"}}, "url": "https://github.com/hortonworks/cloudbreak/commit/dc440cd706536c3b143c641e39fe2350f2518311", "committedDate": "2020-06-16T06:18:01Z", "message": "CB-7082 - Use multiple implementations instead of instanceOf"}, "afterCommit": {"oid": "f0eab1eb6d978c501d2de951b5c1ff36f7c11a8b", "author": {"user": {"login": "gregito", "name": "M\u00e9sz\u00e1ros Gergely"}}, "url": "https://github.com/hortonworks/cloudbreak/commit/f0eab1eb6d978c501d2de951b5c1ff36f7c11a8b", "committedDate": "2020-06-17T22:54:43Z", "message": "CB-7082 - Use multiple implementations instead of instanceOf"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "f0eab1eb6d978c501d2de951b5c1ff36f7c11a8b", "author": {"user": {"login": "gregito", "name": "M\u00e9sz\u00e1ros Gergely"}}, "url": "https://github.com/hortonworks/cloudbreak/commit/f0eab1eb6d978c501d2de951b5c1ff36f7c11a8b", "committedDate": "2020-06-17T22:54:43Z", "message": "CB-7082 - Use multiple implementations instead of instanceOf"}, "afterCommit": {"oid": "e71902e2d69431fe1112ac448787b988da8f8f83", "author": {"user": {"login": "gregito", "name": "M\u00e9sz\u00e1ros Gergely"}}, "url": "https://github.com/hortonworks/cloudbreak/commit/e71902e2d69431fe1112ac448787b988da8f8f83", "committedDate": "2020-06-18T17:46:20Z", "message": "CB-7082 - Use multiple implementations instead of instanceOf"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "e71902e2d69431fe1112ac448787b988da8f8f83", "author": {"user": {"login": "gregito", "name": "M\u00e9sz\u00e1ros Gergely"}}, "url": "https://github.com/hortonworks/cloudbreak/commit/e71902e2d69431fe1112ac448787b988da8f8f83", "committedDate": "2020-06-18T17:46:20Z", "message": "CB-7082 - Use multiple implementations instead of instanceOf"}, "afterCommit": {"oid": "a25557bbd45adbdffac4af1daf828119981c6b09", "author": {"user": {"login": "gregito", "name": "M\u00e9sz\u00e1ros Gergely"}}, "url": "https://github.com/hortonworks/cloudbreak/commit/a25557bbd45adbdffac4af1daf828119981c6b09", "committedDate": "2020-06-19T20:38:57Z", "message": "CB-7082 - Use multiple implementations instead of instanceOf"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM0OTgyNzM2", "url": "https://github.com/hortonworks/cloudbreak/pull/8255#pullrequestreview-434982736", "createdAt": "2020-06-22T14:32:35Z", "commit": {"oid": "a25557bbd45adbdffac4af1daf828119981c6b09"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yMlQxNDozMjozNVrOGnDYHQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yMlQxNDozNTo0MFrOGnDhjQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzYwMjk3Mw==", "bodyText": "not needed", "url": "https://github.com/hortonworks/cloudbreak/pull/8255#discussion_r443602973", "createdAt": "2020-06-22T14:32:35Z", "author": {"login": "bergerdenes"}, "path": "audit-connector/src/test/java/com/sequenceiq/cloudbreak/audit/converter/ServiceEventDataBuildUpdaterTest.java", "diffHunk": "@@ -0,0 +1,112 @@\n+package com.sequenceiq.cloudbreak.audit.converter;\n+\n+import com.cloudera.thunderhead.service.audit.AuditProto;\n+import com.sequenceiq.cloudbreak.audit.converter.builder.ServiceEventDataBuilderProvider;\n+import com.sequenceiq.cloudbreak.audit.model.ServiceEventData;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.mockito.Mock;\n+import org.mockito.MockitoAnnotations;\n+\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.Mockito.never;\n+import static org.mockito.Mockito.times;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+\n+class ServiceEventDataBuildUpdaterTest {\n+\n+    @Mock\n+    private ServiceEventDataBuilderProvider mockBuilderProvider;\n+\n+    @Mock\n+    private AuditProto.ServiceEventData.Builder mockServiceEventDataBuilder;\n+\n+    @Mock\n+    private AuditProto.ServiceEventData mockAuditProtoServiceEventData;\n+\n+    @Mock\n+    private AuditProto.AuditEvent.Builder mockAuditEventBuilder;\n+\n+    @Mock\n+    private ServiceEventData mockServiceEventData;\n+\n+    private ServiceEventDataBuildUpdater underTest;\n+\n+    @BeforeEach\n+    void setUp() {\n+        MockitoAnnotations.initMocks(this);\n+        when(mockBuilderProvider.getNewServiceEventDataBuilder()).thenReturn(mockServiceEventDataBuilder);\n+        when(mockServiceEventDataBuilder.build()).thenReturn(mockAuditProtoServiceEventData);\n+\n+        underTest = new ServiceEventDataBuildUpdater(mockBuilderProvider);\n+    }\n+\n+    @AfterEach\n+    void checkAfter() {\n+        verify(mockServiceEventDataBuilder, times(1)).build();\n+        verify(mockServiceEventData, times(1)).getVersion();\n+        verify(mockServiceEventData, times(1)).getEventDetails();\n+        verify(mockBuilderProvider, times(1)).getNewServiceEventDataBuilder();\n+    }\n+\n+    @Test\n+    void testUpdateWhenVersionIsNull() {\n+        when(mockServiceEventData.getVersion()).thenReturn(null);\n+\n+        underTest.update(mockAuditEventBuilder, mockServiceEventData);\n+\n+        verify(mockServiceEventDataBuilder, never()).setDetailsVersion(any());\n+    }\n+\n+    @Test\n+    void testUpdateWhenVersionIsEmpty() {\n+        when(mockServiceEventData.getVersion()).thenReturn(\"\");\n+\n+        underTest.update(mockAuditEventBuilder, mockServiceEventData);\n+\n+        verify(mockServiceEventDataBuilder, never()).setDetailsVersion(any());\n+    }\n+\n+    @Test\n+    void testUpdateWhenVersionIsNotNull() {\n+        String version = \"someVersion\";\n+        when(mockServiceEventData.getVersion()).thenReturn(version);\n+\n+        underTest.update(mockAuditEventBuilder, mockServiceEventData);\n+\n+        verify(mockServiceEventDataBuilder, times(1)).setDetailsVersion(any());\n+        verify(mockServiceEventDataBuilder, times(1)).setDetailsVersion(version);\n+    }\n+\n+    @Test\n+    void testUpdateWhenEventDetailIsNull() {\n+        when(mockServiceEventData.getEventDetails()).thenReturn(null);\n+\n+        underTest.update(mockAuditEventBuilder, mockServiceEventData);\n+\n+        verify(mockServiceEventDataBuilder, never()).setEventDetails(any());\n+    }\n+\n+    @Test\n+    void testUpdateWhenEventDetailIsEmpty() {\n+        when(mockServiceEventData.getEventDetails()).thenReturn(\"\");\n+\n+        underTest.update(mockAuditEventBuilder, mockServiceEventData);\n+\n+        verify(mockServiceEventDataBuilder, never()).setEventDetails(any());\n+    }\n+\n+    @Test\n+    void testUpdateWhenEventDetailIsNotNull() {\n+        String details = \"someDetail\";\n+        when(mockServiceEventData.getEventDetails()).thenReturn(details);\n+\n+        underTest.update(mockAuditEventBuilder, mockServiceEventData);\n+\n+        verify(mockServiceEventDataBuilder, times(1)).setEventDetails(any());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a25557bbd45adbdffac4af1daf828119981c6b09"}, "originalPosition": 108}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzYwMzE1MQ==", "bodyText": "\"SomeData\"", "url": "https://github.com/hortonworks/cloudbreak/pull/8255#discussion_r443603151", "createdAt": "2020-06-22T14:32:50Z", "author": {"login": "bergerdenes"}, "path": "audit-connector/src/test/java/com/sequenceiq/cloudbreak/audit/converter/ResultServiceEventDataBuildUpdaterTest.java", "diffHunk": "@@ -0,0 +1,77 @@\n+package com.sequenceiq.cloudbreak.audit.converter;\n+\n+import com.cloudera.thunderhead.service.audit.AuditProto;\n+import com.sequenceiq.cloudbreak.audit.converter.builder.ResultServiceEventDataBuilderProvider;\n+import com.sequenceiq.cloudbreak.audit.model.ResultServiceEventData;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.mockito.Mock;\n+import org.mockito.MockitoAnnotations;\n+\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.Mockito.never;\n+import static org.mockito.Mockito.times;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+\n+class ResultServiceEventDataBuildUpdaterTest {\n+\n+    @Mock\n+    private ResultServiceEventDataBuilderProvider mockBuilderProvider;\n+\n+    @Mock\n+    private AuditProto.ResultServiceEventData.Builder mockResultServiceEventDataBuilder;\n+\n+    @Mock\n+    private AuditProto.AttemptAuditEventResult.Builder mockAttemptAuditEventResult;\n+\n+    @Mock\n+    private ResultServiceEventData mockResultServiceEventData;\n+\n+    private ResultServiceEventDataBuildUpdater underTest;\n+\n+    @BeforeEach\n+    void setUp() {\n+        MockitoAnnotations.initMocks(this);\n+        when(mockBuilderProvider.getNewResultServiceEventDataBuilder()).thenReturn(mockResultServiceEventDataBuilder);\n+        when(mockResultServiceEventDataBuilder.addAllResourceCrn(any())).thenReturn(mockResultServiceEventDataBuilder);\n+\n+        underTest = new ResultServiceEventDataBuildUpdater(mockBuilderProvider);\n+    }\n+\n+    @AfterEach\n+    void checkAfter() {\n+        verify(mockResultServiceEventDataBuilder, times(1)).build();\n+        verify(mockResultServiceEventData, times(1)).getResultDetails();\n+        verify(mockResultServiceEventDataBuilder, times(1)).addAllResourceCrn(any());\n+    }\n+\n+    @Test\n+    void testUpdateWhenResultDetailIsEmpty() {\n+        when(mockResultServiceEventData.getResultDetails()).thenReturn(\"\");\n+\n+        underTest.update(mockAttemptAuditEventResult, mockResultServiceEventData);\n+\n+        verify(mockResultServiceEventDataBuilder, never()).setResultDetails(any());\n+    }\n+\n+    @Test\n+    void testUpdateWhenResultDetailIsNull() {\n+        when(mockResultServiceEventData.getResultDetails()).thenReturn(null);\n+\n+        underTest.update(mockAttemptAuditEventResult, mockResultServiceEventData);\n+\n+        verify(mockResultServiceEventDataBuilder, never()).setResultDetails(any());\n+    }\n+\n+    @Test\n+    void testUpdateWhenResultDetailIsNotEmpty() {\n+        when(mockResultServiceEventData.getResultDetails()).thenReturn(\"SomeData\");\n+\n+        underTest.update(mockAttemptAuditEventResult, mockResultServiceEventData);\n+\n+        verify(mockResultServiceEventDataBuilder, times(1)).setResultDetails(any());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a25557bbd45adbdffac4af1daf828119981c6b09"}, "originalPosition": 74}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzYwMzM4NA==", "bodyText": "\"someValue\"", "url": "https://github.com/hortonworks/cloudbreak/pull/8255#discussion_r443603384", "createdAt": "2020-06-22T14:33:08Z", "author": {"login": "bergerdenes"}, "path": "audit-connector/src/test/java/com/sequenceiq/cloudbreak/audit/converter/ResultApiRequestDataBuildUpdaterTest.java", "diffHunk": "@@ -0,0 +1,83 @@\n+package com.sequenceiq.cloudbreak.audit.converter;\n+\n+import com.cloudera.thunderhead.service.audit.AuditProto;\n+import com.sequenceiq.cloudbreak.audit.converter.builder.ResultApiRequestDataBuilderProvider;\n+import com.sequenceiq.cloudbreak.audit.model.ResultApiRequestData;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.mockito.Mock;\n+import org.mockito.MockitoAnnotations;\n+\n+import static org.mockito.ArgumentMatchers.anyString;\n+import static org.mockito.Mockito.never;\n+import static org.mockito.Mockito.times;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+\n+class ResultApiRequestDataBuildUpdaterTest {\n+\n+    @Mock\n+    private AuditProto.ResultApiRequestData.Builder mockResultApiRequestDataBuilder;\n+\n+    @Mock\n+    private ResultApiRequestDataBuilderProvider builderProvider;\n+\n+    @Mock\n+    private AuditProto.ResultApiRequestData mockResultApiRequestData;\n+\n+    @Mock\n+    private AuditProto.AttemptAuditEventResult.Builder mockAttemptAuditEventResultBuilder;\n+\n+    @Mock\n+    private ResultApiRequestData resultEventData;\n+\n+    @Mock\n+    private ResultApiRequestDataBuildUpdater underTest;\n+\n+    @BeforeEach\n+    void setUp() {\n+        MockitoAnnotations.initMocks(this);\n+\n+        when(builderProvider.getNewResultApiRequestDataBuilder()).thenReturn(mockResultApiRequestDataBuilder);\n+        when(mockResultApiRequestDataBuilder.build()).thenReturn(mockResultApiRequestData);\n+\n+        underTest = new ResultApiRequestDataBuildUpdater(builderProvider);\n+    }\n+\n+    @AfterEach\n+    void checkAfter() {\n+        verify(builderProvider, times(1)).getNewResultApiRequestDataBuilder();\n+        verify(mockResultApiRequestDataBuilder, times(1)).build();\n+        verify(resultEventData, times(1)).getResponseParameters();\n+        verify(mockAttemptAuditEventResultBuilder, times(1)).setResultApiRequestData(mockResultApiRequestData);\n+    }\n+\n+    @Test\n+    void testUpdateWhenResponseParametersAreEmpty() {\n+        when(resultEventData.getResponseParameters()).thenReturn(\"\");\n+\n+        underTest.update(mockAttemptAuditEventResultBuilder, resultEventData);\n+\n+        verify(mockResultApiRequestDataBuilder, never()).setResponseParameters(anyString());\n+    }\n+\n+    @Test\n+    void testUpdateWhenResponseParameterIsNull() {\n+        when(resultEventData.getResponseParameters()).thenReturn(null);\n+\n+        underTest.update(mockAttemptAuditEventResultBuilder, resultEventData);\n+\n+        verify(mockResultApiRequestDataBuilder, never()).setResponseParameters(anyString());\n+    }\n+\n+    @Test\n+    void testUpdateWhenResponseParametersAreNotEmpty() {\n+        when(resultEventData.getResponseParameters()).thenReturn(\"someValue\");\n+\n+        underTest.update(mockAttemptAuditEventResultBuilder, resultEventData);\n+\n+        verify(mockResultApiRequestDataBuilder, times(1)).setResponseParameters(anyString());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a25557bbd45adbdffac4af1daf828119981c6b09"}, "originalPosition": 80}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzYwNDIyMg==", "bodyText": "not needed. same for all other properties", "url": "https://github.com/hortonworks/cloudbreak/pull/8255#discussion_r443604222", "createdAt": "2020-06-22T14:34:11Z", "author": {"login": "bergerdenes"}, "path": "audit-connector/src/test/java/com/sequenceiq/cloudbreak/audit/converter/AuditEventToGrpcAuditEventConverterTest.java", "diffHunk": "@@ -147,13 +201,26 @@ void convertUnknownActorThrows() {\n         assertThatThrownBy(() -> underTest.convert(source)).isInstanceOf(IllegalArgumentException.class);\n     }\n \n-    private void assertGeneric(AuditProto.AuditEvent target) {\n-        assertThat(target.getId()).isEqualTo(UUID_ID);\n-        assertThat(target.getAccountId()).isEqualTo(ACCOUNT_ID);\n-        assertThat(target.getRequestId()).isEqualTo(REQUEST_ID);\n-        assertThat(target.getEventName()).isEqualTo(EVENT_NAME);\n-        assertThat(target.getEventSource()).isEqualTo(EVENT_SOURCE);\n-        assertThat(target.getSourceIPAddress()).isEqualTo(SOURCE_IP);\n+    private void assertGeneric() {\n+        verify(mockAuditEventBuilder, times(1)).setId(any());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a25557bbd45adbdffac4af1daf828119981c6b09"}, "originalPosition": 187}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzYwNTEwNQ==", "bodyText": "not needed", "url": "https://github.com/hortonworks/cloudbreak/pull/8255#discussion_r443605105", "createdAt": "2020-06-22T14:35:19Z", "author": {"login": "bergerdenes"}, "path": "audit-connector/src/test/java/com/sequenceiq/cloudbreak/audit/converter/ApiRequestDataBuildUpdaterTest.java", "diffHunk": "@@ -0,0 +1,145 @@\n+package com.sequenceiq.cloudbreak.audit.converter;\n+\n+import com.cloudera.thunderhead.service.audit.AuditProto;\n+import com.sequenceiq.cloudbreak.audit.converter.builder.ApiRequestDataBuilderProvider;\n+import com.sequenceiq.cloudbreak.audit.model.ApiRequestData;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.mockito.Mock;\n+import org.mockito.MockitoAnnotations;\n+\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.ArgumentMatchers.anyBoolean;\n+import static org.mockito.Mockito.never;\n+import static org.mockito.Mockito.times;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+\n+class ApiRequestDataBuildUpdaterTest {\n+\n+    @Mock\n+    private ApiRequestDataBuilderProvider mockBuilderProvider;\n+\n+    @Mock\n+    private AuditProto.ApiRequestData.Builder mockApiRequestDataBuilder;\n+\n+    @Mock\n+    private ApiRequestData mockApiRequestData;\n+\n+    @Mock\n+    private AuditProto.AuditEvent.Builder mockAuditEventBuilder;\n+\n+    @Mock\n+    private AuditProto.ApiRequestData mockApiRequestDataBuilderResult;\n+\n+    private ApiRequestDataBuildUpdater underTest;\n+\n+    @BeforeEach\n+    void setUp() {\n+        MockitoAnnotations.initMocks(this);\n+        when(mockBuilderProvider.getNewApiRequestDataBuilder()).thenReturn(mockApiRequestDataBuilder);\n+        when(mockApiRequestDataBuilder.setMutating(anyBoolean())).thenReturn(mockApiRequestDataBuilder);\n+        when(mockApiRequestDataBuilder.build()).thenReturn(mockApiRequestDataBuilderResult);\n+\n+        underTest = new ApiRequestDataBuildUpdater(mockBuilderProvider);\n+    }\n+\n+    @AfterEach\n+    void checkAfter() {\n+        verify(mockApiRequestDataBuilder, times(1)).setMutating(anyBoolean());\n+        verify(mockApiRequestData, times(1)).getApiVersion();\n+        verify(mockApiRequestData, times(1)).getRequestParameters();\n+        verify(mockApiRequestData, times(1)).getUserAgent();\n+        verify(mockAuditEventBuilder, times(1)).setApiRequestData(any(AuditProto.ApiRequestData.class));\n+        verify(mockAuditEventBuilder, times(1)).setApiRequestData(mockApiRequestDataBuilderResult);\n+    }\n+\n+    @Test\n+    void testUpdateWhenApiVersionIsNull() {\n+        when(mockApiRequestData.getApiVersion()).thenReturn(null);\n+\n+        underTest.update(mockAuditEventBuilder, mockApiRequestData);\n+\n+        verify(mockApiRequestDataBuilder, never()).setApiVersion(any());\n+    }\n+\n+    @Test\n+    void testUpdateWhenApiVersionIsEmpty() {\n+        when(mockApiRequestData.getApiVersion()).thenReturn(\"\");\n+\n+        underTest.update(mockAuditEventBuilder, mockApiRequestData);\n+\n+        verify(mockApiRequestDataBuilder, never()).setApiVersion(any());\n+    }\n+\n+    @Test\n+    void testUpdateWhenApiVersionIsNotEmpty() {\n+        String apiVersionValue = \"someApiVersion\";\n+        when(mockApiRequestData.getApiVersion()).thenReturn(apiVersionValue);\n+\n+        underTest.update(mockAuditEventBuilder, mockApiRequestData);\n+\n+        verify(mockApiRequestDataBuilder, times(1)).setApiVersion(any());\n+        verify(mockApiRequestDataBuilder, times(1)).setApiVersion(apiVersionValue);\n+    }\n+\n+    @Test\n+    void testUpdateWhenRequestParameterIsNull() {\n+        when(mockApiRequestData.getRequestParameters()).thenReturn(null);\n+\n+        underTest.update(mockAuditEventBuilder, mockApiRequestData);\n+\n+        verify(mockApiRequestDataBuilder, never()).setRequestParameters(any());\n+    }\n+\n+    @Test\n+    void testUpdateWhenRequestParameterIsEmpty() {\n+        when(mockApiRequestData.getRequestParameters()).thenReturn(\"\");\n+\n+        underTest.update(mockAuditEventBuilder, mockApiRequestData);\n+\n+        verify(mockApiRequestDataBuilder, never()).setRequestParameters(any());\n+    }\n+\n+    @Test\n+    void testUpdateWhenRequestParameterIsNotEmpty() {\n+        String requestParams = \"someRequestParamValue\";\n+        when(mockApiRequestData.getRequestParameters()).thenReturn(requestParams);\n+\n+        underTest.update(mockAuditEventBuilder, mockApiRequestData);\n+\n+        verify(mockApiRequestDataBuilder, times(1)).setRequestParameters(any());\n+        verify(mockApiRequestDataBuilder, times(1)).setRequestParameters(requestParams);\n+    }\n+\n+    @Test\n+    void testUpdateWhenUserAgentIsNull() {\n+        when(mockApiRequestData.getUserAgent()).thenReturn(null);\n+\n+        underTest.update(mockAuditEventBuilder, mockApiRequestData);\n+\n+        verify(mockApiRequestDataBuilder, never()).setUserAgent(any());\n+    }\n+\n+    @Test\n+    void testUpdateWhenUserAgentIsEmpty() {\n+        when(mockApiRequestData.getUserAgent()).thenReturn(\"\");\n+\n+        underTest.update(mockAuditEventBuilder, mockApiRequestData);\n+\n+        verify(mockApiRequestDataBuilder, never()).setUserAgent(any());\n+    }\n+\n+    @Test\n+    void testUpdateWhenUserAgentIsNotEmpty() {\n+        String userAgentValue = \"someUserAgentValue\";\n+        when(mockApiRequestData.getUserAgent()).thenReturn(userAgentValue);\n+\n+        underTest.update(mockAuditEventBuilder, mockApiRequestData);\n+\n+        verify(mockApiRequestDataBuilder, times(1)).setUserAgent(any());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a25557bbd45adbdffac4af1daf828119981c6b09"}, "originalPosition": 141}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzYwNTIyOA==", "bodyText": "not needed", "url": "https://github.com/hortonworks/cloudbreak/pull/8255#discussion_r443605228", "createdAt": "2020-06-22T14:35:28Z", "author": {"login": "bergerdenes"}, "path": "audit-connector/src/test/java/com/sequenceiq/cloudbreak/audit/converter/ApiRequestDataBuildUpdaterTest.java", "diffHunk": "@@ -0,0 +1,145 @@\n+package com.sequenceiq.cloudbreak.audit.converter;\n+\n+import com.cloudera.thunderhead.service.audit.AuditProto;\n+import com.sequenceiq.cloudbreak.audit.converter.builder.ApiRequestDataBuilderProvider;\n+import com.sequenceiq.cloudbreak.audit.model.ApiRequestData;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.mockito.Mock;\n+import org.mockito.MockitoAnnotations;\n+\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.ArgumentMatchers.anyBoolean;\n+import static org.mockito.Mockito.never;\n+import static org.mockito.Mockito.times;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+\n+class ApiRequestDataBuildUpdaterTest {\n+\n+    @Mock\n+    private ApiRequestDataBuilderProvider mockBuilderProvider;\n+\n+    @Mock\n+    private AuditProto.ApiRequestData.Builder mockApiRequestDataBuilder;\n+\n+    @Mock\n+    private ApiRequestData mockApiRequestData;\n+\n+    @Mock\n+    private AuditProto.AuditEvent.Builder mockAuditEventBuilder;\n+\n+    @Mock\n+    private AuditProto.ApiRequestData mockApiRequestDataBuilderResult;\n+\n+    private ApiRequestDataBuildUpdater underTest;\n+\n+    @BeforeEach\n+    void setUp() {\n+        MockitoAnnotations.initMocks(this);\n+        when(mockBuilderProvider.getNewApiRequestDataBuilder()).thenReturn(mockApiRequestDataBuilder);\n+        when(mockApiRequestDataBuilder.setMutating(anyBoolean())).thenReturn(mockApiRequestDataBuilder);\n+        when(mockApiRequestDataBuilder.build()).thenReturn(mockApiRequestDataBuilderResult);\n+\n+        underTest = new ApiRequestDataBuildUpdater(mockBuilderProvider);\n+    }\n+\n+    @AfterEach\n+    void checkAfter() {\n+        verify(mockApiRequestDataBuilder, times(1)).setMutating(anyBoolean());\n+        verify(mockApiRequestData, times(1)).getApiVersion();\n+        verify(mockApiRequestData, times(1)).getRequestParameters();\n+        verify(mockApiRequestData, times(1)).getUserAgent();\n+        verify(mockAuditEventBuilder, times(1)).setApiRequestData(any(AuditProto.ApiRequestData.class));\n+        verify(mockAuditEventBuilder, times(1)).setApiRequestData(mockApiRequestDataBuilderResult);\n+    }\n+\n+    @Test\n+    void testUpdateWhenApiVersionIsNull() {\n+        when(mockApiRequestData.getApiVersion()).thenReturn(null);\n+\n+        underTest.update(mockAuditEventBuilder, mockApiRequestData);\n+\n+        verify(mockApiRequestDataBuilder, never()).setApiVersion(any());\n+    }\n+\n+    @Test\n+    void testUpdateWhenApiVersionIsEmpty() {\n+        when(mockApiRequestData.getApiVersion()).thenReturn(\"\");\n+\n+        underTest.update(mockAuditEventBuilder, mockApiRequestData);\n+\n+        verify(mockApiRequestDataBuilder, never()).setApiVersion(any());\n+    }\n+\n+    @Test\n+    void testUpdateWhenApiVersionIsNotEmpty() {\n+        String apiVersionValue = \"someApiVersion\";\n+        when(mockApiRequestData.getApiVersion()).thenReturn(apiVersionValue);\n+\n+        underTest.update(mockAuditEventBuilder, mockApiRequestData);\n+\n+        verify(mockApiRequestDataBuilder, times(1)).setApiVersion(any());\n+        verify(mockApiRequestDataBuilder, times(1)).setApiVersion(apiVersionValue);\n+    }\n+\n+    @Test\n+    void testUpdateWhenRequestParameterIsNull() {\n+        when(mockApiRequestData.getRequestParameters()).thenReturn(null);\n+\n+        underTest.update(mockAuditEventBuilder, mockApiRequestData);\n+\n+        verify(mockApiRequestDataBuilder, never()).setRequestParameters(any());\n+    }\n+\n+    @Test\n+    void testUpdateWhenRequestParameterIsEmpty() {\n+        when(mockApiRequestData.getRequestParameters()).thenReturn(\"\");\n+\n+        underTest.update(mockAuditEventBuilder, mockApiRequestData);\n+\n+        verify(mockApiRequestDataBuilder, never()).setRequestParameters(any());\n+    }\n+\n+    @Test\n+    void testUpdateWhenRequestParameterIsNotEmpty() {\n+        String requestParams = \"someRequestParamValue\";\n+        when(mockApiRequestData.getRequestParameters()).thenReturn(requestParams);\n+\n+        underTest.update(mockAuditEventBuilder, mockApiRequestData);\n+\n+        verify(mockApiRequestDataBuilder, times(1)).setRequestParameters(any());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a25557bbd45adbdffac4af1daf828119981c6b09"}, "originalPosition": 112}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzYwNTM4OQ==", "bodyText": "not needed", "url": "https://github.com/hortonworks/cloudbreak/pull/8255#discussion_r443605389", "createdAt": "2020-06-22T14:35:40Z", "author": {"login": "bergerdenes"}, "path": "audit-connector/src/test/java/com/sequenceiq/cloudbreak/audit/converter/ApiRequestDataBuildUpdaterTest.java", "diffHunk": "@@ -0,0 +1,145 @@\n+package com.sequenceiq.cloudbreak.audit.converter;\n+\n+import com.cloudera.thunderhead.service.audit.AuditProto;\n+import com.sequenceiq.cloudbreak.audit.converter.builder.ApiRequestDataBuilderProvider;\n+import com.sequenceiq.cloudbreak.audit.model.ApiRequestData;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.mockito.Mock;\n+import org.mockito.MockitoAnnotations;\n+\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.ArgumentMatchers.anyBoolean;\n+import static org.mockito.Mockito.never;\n+import static org.mockito.Mockito.times;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+\n+class ApiRequestDataBuildUpdaterTest {\n+\n+    @Mock\n+    private ApiRequestDataBuilderProvider mockBuilderProvider;\n+\n+    @Mock\n+    private AuditProto.ApiRequestData.Builder mockApiRequestDataBuilder;\n+\n+    @Mock\n+    private ApiRequestData mockApiRequestData;\n+\n+    @Mock\n+    private AuditProto.AuditEvent.Builder mockAuditEventBuilder;\n+\n+    @Mock\n+    private AuditProto.ApiRequestData mockApiRequestDataBuilderResult;\n+\n+    private ApiRequestDataBuildUpdater underTest;\n+\n+    @BeforeEach\n+    void setUp() {\n+        MockitoAnnotations.initMocks(this);\n+        when(mockBuilderProvider.getNewApiRequestDataBuilder()).thenReturn(mockApiRequestDataBuilder);\n+        when(mockApiRequestDataBuilder.setMutating(anyBoolean())).thenReturn(mockApiRequestDataBuilder);\n+        when(mockApiRequestDataBuilder.build()).thenReturn(mockApiRequestDataBuilderResult);\n+\n+        underTest = new ApiRequestDataBuildUpdater(mockBuilderProvider);\n+    }\n+\n+    @AfterEach\n+    void checkAfter() {\n+        verify(mockApiRequestDataBuilder, times(1)).setMutating(anyBoolean());\n+        verify(mockApiRequestData, times(1)).getApiVersion();\n+        verify(mockApiRequestData, times(1)).getRequestParameters();\n+        verify(mockApiRequestData, times(1)).getUserAgent();\n+        verify(mockAuditEventBuilder, times(1)).setApiRequestData(any(AuditProto.ApiRequestData.class));\n+        verify(mockAuditEventBuilder, times(1)).setApiRequestData(mockApiRequestDataBuilderResult);\n+    }\n+\n+    @Test\n+    void testUpdateWhenApiVersionIsNull() {\n+        when(mockApiRequestData.getApiVersion()).thenReturn(null);\n+\n+        underTest.update(mockAuditEventBuilder, mockApiRequestData);\n+\n+        verify(mockApiRequestDataBuilder, never()).setApiVersion(any());\n+    }\n+\n+    @Test\n+    void testUpdateWhenApiVersionIsEmpty() {\n+        when(mockApiRequestData.getApiVersion()).thenReturn(\"\");\n+\n+        underTest.update(mockAuditEventBuilder, mockApiRequestData);\n+\n+        verify(mockApiRequestDataBuilder, never()).setApiVersion(any());\n+    }\n+\n+    @Test\n+    void testUpdateWhenApiVersionIsNotEmpty() {\n+        String apiVersionValue = \"someApiVersion\";\n+        when(mockApiRequestData.getApiVersion()).thenReturn(apiVersionValue);\n+\n+        underTest.update(mockAuditEventBuilder, mockApiRequestData);\n+\n+        verify(mockApiRequestDataBuilder, times(1)).setApiVersion(any());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a25557bbd45adbdffac4af1daf828119981c6b09"}, "originalPosition": 83}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "a25557bbd45adbdffac4af1daf828119981c6b09", "author": {"user": {"login": "gregito", "name": "M\u00e9sz\u00e1ros Gergely"}}, "url": "https://github.com/hortonworks/cloudbreak/commit/a25557bbd45adbdffac4af1daf828119981c6b09", "committedDate": "2020-06-19T20:38:57Z", "message": "CB-7082 - Use multiple implementations instead of instanceOf"}, "afterCommit": {"oid": "7201f95649449d3d1dc732b288767cb6abb5ad93", "author": {"user": {"login": "gregito", "name": "M\u00e9sz\u00e1ros Gergely"}}, "url": "https://github.com/hortonworks/cloudbreak/commit/7201f95649449d3d1dc732b288767cb6abb5ad93", "committedDate": "2020-06-23T11:30:26Z", "message": "CB-7082 - Use multiple implementations instead of instanceOf"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "7201f95649449d3d1dc732b288767cb6abb5ad93", "author": {"user": {"login": "gregito", "name": "M\u00e9sz\u00e1ros Gergely"}}, "url": "https://github.com/hortonworks/cloudbreak/commit/7201f95649449d3d1dc732b288767cb6abb5ad93", "committedDate": "2020-06-23T11:30:26Z", "message": "CB-7082 - Use multiple implementations instead of instanceOf"}, "afterCommit": {"oid": "b970faa2727a001cf8d605a543b7e65672336550", "author": {"user": {"login": "gregito", "name": "M\u00e9sz\u00e1ros Gergely"}}, "url": "https://github.com/hortonworks/cloudbreak/commit/b970faa2727a001cf8d605a543b7e65672336550", "committedDate": "2020-06-23T11:33:02Z", "message": "CB-7082 - Use multiple implementations instead of instanceOf"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM2MDQyMTMw", "url": "https://github.com/hortonworks/cloudbreak/pull/8255#pullrequestreview-436042130", "createdAt": "2020-06-23T18:20:50Z", "commit": {"oid": "b970faa2727a001cf8d605a543b7e65672336550"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c38ce25dd3dd8eee58b7f3b9a6faced6e4230f6f", "author": {"user": {"login": "gregito", "name": "M\u00e9sz\u00e1ros Gergely"}}, "url": "https://github.com/hortonworks/cloudbreak/commit/c38ce25dd3dd8eee58b7f3b9a6faced6e4230f6f", "committedDate": "2020-06-24T14:10:47Z", "message": "CB-7082 - Use multiple implementations instead of instanceOf"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "b970faa2727a001cf8d605a543b7e65672336550", "author": {"user": {"login": "gregito", "name": "M\u00e9sz\u00e1ros Gergely"}}, "url": "https://github.com/hortonworks/cloudbreak/commit/b970faa2727a001cf8d605a543b7e65672336550", "committedDate": "2020-06-23T11:33:02Z", "message": "CB-7082 - Use multiple implementations instead of instanceOf"}, "afterCommit": {"oid": "c38ce25dd3dd8eee58b7f3b9a6faced6e4230f6f", "author": {"user": {"login": "gregito", "name": "M\u00e9sz\u00e1ros Gergely"}}, "url": "https://github.com/hortonworks/cloudbreak/commit/c38ce25dd3dd8eee58b7f3b9a6faced6e4230f6f", "committedDate": "2020-06-24T14:10:47Z", "message": "CB-7082 - Use multiple implementations instead of instanceOf"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1681, "cost": 1, "resetAt": "2021-11-01T14:51:55Z"}}}