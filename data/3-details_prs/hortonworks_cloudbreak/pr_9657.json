{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTQwNzIxNTI5", "number": 9657, "title": "CB-9926: Add retries to the legacy health check's ping", "bodyText": "Add retries to the legacy health check's ping.\nSee detailed description in the commit message.", "createdAt": "2020-12-15T21:10:04Z", "url": "https://github.com/hortonworks/cloudbreak/pull/9657", "merged": true, "mergeCommit": {"oid": "b6561de50d7fa8a12261c06cb5e275b8b1e77c17"}, "closed": true, "closedAt": "2021-01-05T17:26:16Z", "author": {"login": "jamisonbennett"}, "timelineItems": {"totalCount": 10, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdmmKorABqjQxMTc2MjI1NDc=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdtNY3OgH2gAyNTQwNzIxNTI5OmM0OTQ5NDEzOTAyOTc1YjNhMDVlODU3ZjhmZTBhZmMwMjU1NGE2MmQ=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "7c8fe28f9be8b86a3671fb5f95dd30f5dfc02050", "author": {"user": {"login": "jamisonbennett", "name": "Jamison Bennett"}}, "url": "https://github.com/hortonworks/cloudbreak/commit/7c8fe28f9be8b86a3671fb5f95dd30f5dfc02050", "committedDate": "2020-12-15T21:09:05Z", "message": "CB-9926: Add retries to the legacy health check's ping\n\nAdd retries to the legacy health check's ping."}, "afterCommit": {"oid": "67415cf6033ff1f022130ba513deda35890ab058", "author": {"user": {"login": "jamisonbennett", "name": "Jamison Bennett"}}, "url": "https://github.com/hortonworks/cloudbreak/commit/67415cf6033ff1f022130ba513deda35890ab058", "committedDate": "2020-12-16T03:08:28Z", "message": "CB-9926: Add retries to the legacy health check's ping\n\nAdd retries to the legacy health check's ping."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "67415cf6033ff1f022130ba513deda35890ab058", "author": {"user": {"login": "jamisonbennett", "name": "Jamison Bennett"}}, "url": "https://github.com/hortonworks/cloudbreak/commit/67415cf6033ff1f022130ba513deda35890ab058", "committedDate": "2020-12-16T03:08:28Z", "message": "CB-9926: Add retries to the legacy health check's ping\n\nAdd retries to the legacy health check's ping."}, "afterCommit": {"oid": "94d1a817196a3c01fde99b3c6aba778a723a7bb9", "author": {"user": {"login": "jamisonbennett", "name": "Jamison Bennett"}}, "url": "https://github.com/hortonworks/cloudbreak/commit/94d1a817196a3c01fde99b3c6aba778a723a7bb9", "committedDate": "2020-12-16T22:41:02Z", "message": "CB-10403: Fix legacy FreeIPA health check to use the result flag\n\nFix legacy FreeIPA health check to use the result flag in all cases."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTYxMjI2MTIy", "url": "https://github.com/hortonworks/cloudbreak/pull/9657#pullrequestreview-561226122", "createdAt": "2021-01-04T17:59:34Z", "commit": {"oid": "94d1a817196a3c01fde99b3c6aba778a723a7bb9"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNFQxNzo1OTozNFrOIN7Xow==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNFQxNzo1OTozNFrOIN7Xow==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTQ3NTEwNw==", "bodyText": "found variable is not necessary.  use  (!nodeMatcher.find()) should be good enough.", "url": "https://github.com/hortonworks/cloudbreak/pull/9657#discussion_r551475107", "createdAt": "2021-01-04T17:59:34Z", "author": {"login": "christmasferret"}, "path": "freeipa/src/main/java/com/sequenceiq/freeipa/service/stack/FreeIpaInstanceHealthDetailsService.java", "diffHunk": "@@ -0,0 +1,161 @@\n+package com.sequenceiq.freeipa.service.stack;\n+\n+import java.util.Objects;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+\n+import javax.inject.Inject;\n+import javax.ws.rs.core.Response;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.retry.annotation.Retryable;\n+import org.springframework.stereotype.Service;\n+\n+import com.sequenceiq.freeipa.api.v1.freeipa.stack.model.common.instance.InstanceStatus;\n+import com.sequenceiq.freeipa.api.v1.freeipa.stack.model.health.NodeHealthDetails;\n+import com.sequenceiq.freeipa.client.FreeIpaClient;\n+import com.sequenceiq.freeipa.client.FreeIpaClientException;\n+import com.sequenceiq.freeipa.client.FreeIpaHealthCheckClient;\n+import com.sequenceiq.freeipa.client.FreeIpaHealthCheckClientFactory;\n+import com.sequenceiq.freeipa.client.RetryableFreeIpaClientException;\n+import com.sequenceiq.freeipa.client.healthcheckmodel.CheckResult;\n+import com.sequenceiq.freeipa.client.model.RPCMessage;\n+import com.sequenceiq.freeipa.client.model.RPCResponse;\n+import com.sequenceiq.freeipa.entity.InstanceMetaData;\n+import com.sequenceiq.freeipa.entity.Stack;\n+import com.sequenceiq.freeipa.service.freeipa.FreeIpaClientFactory;\n+import com.sequenceiq.freeipa.util.HealthCheckAvailabilityChecker;\n+\n+@Service\n+public class FreeIpaInstanceHealthDetailsService {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(FreeIpaInstanceHealthDetailsService.class);\n+\n+    private static final String EXTERNAL_COMMAND_OUTPUT = \"ExternalCommandOutput\";\n+\n+    private static final String STATUS_OK = \"OK\";\n+\n+    private static final int STATUS_GROUP = 2;\n+\n+    private static final String MESSAGE_UNAVAILABLE = \"Message Unavailable\";\n+\n+    private static final Pattern RESULT_PATTERN = Pattern.compile(\"(ecure port|: TCP) \\\\([0-9]*\\\\): (.*)\");\n+\n+    private static final Pattern NEW_NODE_PATTERN = Pattern.compile(\"Check connection from master to remote replica '(.[^\\']*)\");\n+\n+    @Inject\n+    private FreeIpaClientFactory freeIpaClientFactory;\n+\n+    @Inject\n+    private HealthCheckAvailabilityChecker healthCheckAvailabilityChecker;\n+\n+    @Inject\n+    private FreeIpaHealthCheckClientFactory freeIpaHealthCheckClientFactory;\n+\n+    @Retryable(RetryableFreeIpaClientException.class)\n+    public NodeHealthDetails getInstanceHealthDetails(Stack stack, InstanceMetaData instance) throws FreeIpaClientException {\n+        if (healthCheckAvailabilityChecker.isCdpFreeIpaHeathAgentAvailable(stack)) {\n+            RPCResponse<CheckResult> rpcResponse = freeIpaHealthCheck(stack, instance);\n+            return parseMessages(rpcResponse, instance);\n+        } else {\n+            RPCResponse<Boolean> rpcResponse = legacyFreeIpaHealthCheck(stack, instance);\n+            return legacyParseMessages(rpcResponse, instance);\n+        }\n+    }\n+\n+    @Retryable(RetryableFreeIpaClientException.class)\n+    public RPCResponse<Boolean> checkFreeIpaHealth(Stack stack, InstanceMetaData instance) throws FreeIpaClientException {\n+        RPCResponse<Boolean> result;\n+        if (healthCheckAvailabilityChecker.isCdpFreeIpaHeathAgentAvailable(stack)) {\n+            result = toBooleanRpcResponse(freeIpaHealthCheck(stack, instance));\n+        } else {\n+            result = legacyFreeIpaHealthCheck(stack, instance);\n+        }\n+        return result;\n+    }\n+\n+    private RPCResponse<CheckResult> freeIpaHealthCheck(Stack stack, InstanceMetaData instance) throws FreeIpaClientException {\n+        try (FreeIpaHealthCheckClient client = freeIpaHealthCheckClientFactory.getClient(stack, instance)) {\n+            return client.nodeHealth();\n+        } catch (FreeIpaClientException e) {\n+            throw new RetryableFreeIpaClientException(\"Error during healthcheck\", e);\n+        } catch (Exception e) {\n+            LOGGER.error(\"FreeIPA health check failed\", e);\n+            throw new RetryableFreeIpaClientException(\"FreeIPA health check failed\", e);\n+        }\n+    }\n+\n+    private RPCResponse<Boolean> legacyFreeIpaHealthCheck(Stack stack, InstanceMetaData instance) throws FreeIpaClientException {\n+        FreeIpaClient freeIpaClient = freeIpaClientFactory.getFreeIpaClientForStackForLegacyHealthCheck(stack, instance.getDiscoveryFQDN());\n+        return freeIpaClient.serverConnCheck(freeIpaClient.getHostname(), instance.getDiscoveryFQDN());\n+    }\n+\n+    private RPCResponse<Boolean> toBooleanRpcResponse(RPCResponse<CheckResult> nodeHealth) {\n+        RPCResponse<Boolean> response = new RPCResponse<>();\n+        response.setSummary(nodeHealth.getSummary());\n+        response.setResult(isHealthCheckPassing(nodeHealth));\n+        response.setCount(nodeHealth.getCount());\n+        response.setTruncated(nodeHealth.getTruncated());\n+        response.setMessages(nodeHealth.getMessages());\n+        response.setCompleted(nodeHealth.getCompleted());\n+        response.setFailed(nodeHealth.getFailed());\n+        response.setValue(nodeHealth.getValue());\n+        return response;\n+    }\n+\n+    private NodeHealthDetails parseMessages(RPCResponse<CheckResult> rpcResponse, InstanceMetaData instanceMetaData) {\n+        NodeHealthDetails nodeResponse = new NodeHealthDetails();\n+        nodeResponse.setName(instanceMetaData.getDiscoveryFQDN());\n+        nodeResponse.setInstanceId(instanceMetaData.getInstanceId());\n+        if (isHealthCheckPassing(rpcResponse)) {\n+            nodeResponse.setStatus(InstanceStatus.CREATED);\n+        } else {\n+            nodeResponse.setStatus(InstanceStatus.UNHEALTHY);\n+            nodeResponse.setIssues(rpcResponse.getMessages().stream().map(RPCMessage::getMessage).collect(Collectors.toList()));\n+        }\n+        return nodeResponse;\n+    }\n+\n+    private NodeHealthDetails legacyParseMessages(RPCResponse<Boolean> rpcResponse, InstanceMetaData instanceMetaData) {\n+        String precedingMessage = MESSAGE_UNAVAILABLE;\n+        NodeHealthDetails nodeResponse = new NodeHealthDetails();\n+        nodeResponse.setStatus(rpcResponse.getResult() ? InstanceStatus.CREATED : InstanceStatus.UNHEALTHY);\n+        nodeResponse.setName(instanceMetaData.getDiscoveryFQDN());\n+        nodeResponse.setInstanceId(instanceMetaData.getInstanceId());\n+        boolean found = false;\n+        for (RPCMessage message : rpcResponse.getMessages()) {\n+            Matcher nodeMatcher = NEW_NODE_PATTERN.matcher(message.getMessage());\n+            if (nodeMatcher.find()) {\n+                found = true;\n+            }\n+            if (!found) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "94d1a817196a3c01fde99b3c6aba778a723a7bb9"}, "originalPosition": 133}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTYxMjI3Mjg2", "url": "https://github.com/hortonworks/cloudbreak/pull/9657#pullrequestreview-561227286", "createdAt": "2021-01-04T18:01:13Z", "commit": {"oid": "94d1a817196a3c01fde99b3c6aba778a723a7bb9"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNFQxODowMToxM1rOIN7bBg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNFQxODowMToxM1rOIN7bBg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTQ3NTk3NA==", "bodyText": "precedingMessage = message.getMessage(); will have no effect here as mutating string will not change the string in nodeResponse above. Could append the message before addIssue()", "url": "https://github.com/hortonworks/cloudbreak/pull/9657#discussion_r551475974", "createdAt": "2021-01-04T18:01:13Z", "author": {"login": "christmasferret"}, "path": "freeipa/src/main/java/com/sequenceiq/freeipa/service/stack/FreeIpaInstanceHealthDetailsService.java", "diffHunk": "@@ -0,0 +1,161 @@\n+package com.sequenceiq.freeipa.service.stack;\n+\n+import java.util.Objects;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+\n+import javax.inject.Inject;\n+import javax.ws.rs.core.Response;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.retry.annotation.Retryable;\n+import org.springframework.stereotype.Service;\n+\n+import com.sequenceiq.freeipa.api.v1.freeipa.stack.model.common.instance.InstanceStatus;\n+import com.sequenceiq.freeipa.api.v1.freeipa.stack.model.health.NodeHealthDetails;\n+import com.sequenceiq.freeipa.client.FreeIpaClient;\n+import com.sequenceiq.freeipa.client.FreeIpaClientException;\n+import com.sequenceiq.freeipa.client.FreeIpaHealthCheckClient;\n+import com.sequenceiq.freeipa.client.FreeIpaHealthCheckClientFactory;\n+import com.sequenceiq.freeipa.client.RetryableFreeIpaClientException;\n+import com.sequenceiq.freeipa.client.healthcheckmodel.CheckResult;\n+import com.sequenceiq.freeipa.client.model.RPCMessage;\n+import com.sequenceiq.freeipa.client.model.RPCResponse;\n+import com.sequenceiq.freeipa.entity.InstanceMetaData;\n+import com.sequenceiq.freeipa.entity.Stack;\n+import com.sequenceiq.freeipa.service.freeipa.FreeIpaClientFactory;\n+import com.sequenceiq.freeipa.util.HealthCheckAvailabilityChecker;\n+\n+@Service\n+public class FreeIpaInstanceHealthDetailsService {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(FreeIpaInstanceHealthDetailsService.class);\n+\n+    private static final String EXTERNAL_COMMAND_OUTPUT = \"ExternalCommandOutput\";\n+\n+    private static final String STATUS_OK = \"OK\";\n+\n+    private static final int STATUS_GROUP = 2;\n+\n+    private static final String MESSAGE_UNAVAILABLE = \"Message Unavailable\";\n+\n+    private static final Pattern RESULT_PATTERN = Pattern.compile(\"(ecure port|: TCP) \\\\([0-9]*\\\\): (.*)\");\n+\n+    private static final Pattern NEW_NODE_PATTERN = Pattern.compile(\"Check connection from master to remote replica '(.[^\\']*)\");\n+\n+    @Inject\n+    private FreeIpaClientFactory freeIpaClientFactory;\n+\n+    @Inject\n+    private HealthCheckAvailabilityChecker healthCheckAvailabilityChecker;\n+\n+    @Inject\n+    private FreeIpaHealthCheckClientFactory freeIpaHealthCheckClientFactory;\n+\n+    @Retryable(RetryableFreeIpaClientException.class)\n+    public NodeHealthDetails getInstanceHealthDetails(Stack stack, InstanceMetaData instance) throws FreeIpaClientException {\n+        if (healthCheckAvailabilityChecker.isCdpFreeIpaHeathAgentAvailable(stack)) {\n+            RPCResponse<CheckResult> rpcResponse = freeIpaHealthCheck(stack, instance);\n+            return parseMessages(rpcResponse, instance);\n+        } else {\n+            RPCResponse<Boolean> rpcResponse = legacyFreeIpaHealthCheck(stack, instance);\n+            return legacyParseMessages(rpcResponse, instance);\n+        }\n+    }\n+\n+    @Retryable(RetryableFreeIpaClientException.class)\n+    public RPCResponse<Boolean> checkFreeIpaHealth(Stack stack, InstanceMetaData instance) throws FreeIpaClientException {\n+        RPCResponse<Boolean> result;\n+        if (healthCheckAvailabilityChecker.isCdpFreeIpaHeathAgentAvailable(stack)) {\n+            result = toBooleanRpcResponse(freeIpaHealthCheck(stack, instance));\n+        } else {\n+            result = legacyFreeIpaHealthCheck(stack, instance);\n+        }\n+        return result;\n+    }\n+\n+    private RPCResponse<CheckResult> freeIpaHealthCheck(Stack stack, InstanceMetaData instance) throws FreeIpaClientException {\n+        try (FreeIpaHealthCheckClient client = freeIpaHealthCheckClientFactory.getClient(stack, instance)) {\n+            return client.nodeHealth();\n+        } catch (FreeIpaClientException e) {\n+            throw new RetryableFreeIpaClientException(\"Error during healthcheck\", e);\n+        } catch (Exception e) {\n+            LOGGER.error(\"FreeIPA health check failed\", e);\n+            throw new RetryableFreeIpaClientException(\"FreeIPA health check failed\", e);\n+        }\n+    }\n+\n+    private RPCResponse<Boolean> legacyFreeIpaHealthCheck(Stack stack, InstanceMetaData instance) throws FreeIpaClientException {\n+        FreeIpaClient freeIpaClient = freeIpaClientFactory.getFreeIpaClientForStackForLegacyHealthCheck(stack, instance.getDiscoveryFQDN());\n+        return freeIpaClient.serverConnCheck(freeIpaClient.getHostname(), instance.getDiscoveryFQDN());\n+    }\n+\n+    private RPCResponse<Boolean> toBooleanRpcResponse(RPCResponse<CheckResult> nodeHealth) {\n+        RPCResponse<Boolean> response = new RPCResponse<>();\n+        response.setSummary(nodeHealth.getSummary());\n+        response.setResult(isHealthCheckPassing(nodeHealth));\n+        response.setCount(nodeHealth.getCount());\n+        response.setTruncated(nodeHealth.getTruncated());\n+        response.setMessages(nodeHealth.getMessages());\n+        response.setCompleted(nodeHealth.getCompleted());\n+        response.setFailed(nodeHealth.getFailed());\n+        response.setValue(nodeHealth.getValue());\n+        return response;\n+    }\n+\n+    private NodeHealthDetails parseMessages(RPCResponse<CheckResult> rpcResponse, InstanceMetaData instanceMetaData) {\n+        NodeHealthDetails nodeResponse = new NodeHealthDetails();\n+        nodeResponse.setName(instanceMetaData.getDiscoveryFQDN());\n+        nodeResponse.setInstanceId(instanceMetaData.getInstanceId());\n+        if (isHealthCheckPassing(rpcResponse)) {\n+            nodeResponse.setStatus(InstanceStatus.CREATED);\n+        } else {\n+            nodeResponse.setStatus(InstanceStatus.UNHEALTHY);\n+            nodeResponse.setIssues(rpcResponse.getMessages().stream().map(RPCMessage::getMessage).collect(Collectors.toList()));\n+        }\n+        return nodeResponse;\n+    }\n+\n+    private NodeHealthDetails legacyParseMessages(RPCResponse<Boolean> rpcResponse, InstanceMetaData instanceMetaData) {\n+        String precedingMessage = MESSAGE_UNAVAILABLE;\n+        NodeHealthDetails nodeResponse = new NodeHealthDetails();\n+        nodeResponse.setStatus(rpcResponse.getResult() ? InstanceStatus.CREATED : InstanceStatus.UNHEALTHY);\n+        nodeResponse.setName(instanceMetaData.getDiscoveryFQDN());\n+        nodeResponse.setInstanceId(instanceMetaData.getInstanceId());\n+        boolean found = false;\n+        for (RPCMessage message : rpcResponse.getMessages()) {\n+            Matcher nodeMatcher = NEW_NODE_PATTERN.matcher(message.getMessage());\n+            if (nodeMatcher.find()) {\n+                found = true;\n+            }\n+            if (!found) {\n+                LOGGER.info(\"No node for message: {}\" + message.getMessage());\n+            } else {\n+                // When parsing the messages, if there's an error, the error\n+                // appears in the preceding message.\n+                if (EXTERNAL_COMMAND_OUTPUT.equals(message.getName())) {\n+                    Matcher matcher = RESULT_PATTERN.matcher(message.getMessage());\n+                    if (matcher.find()) {\n+                        if (!STATUS_OK.equals(matcher.group(STATUS_GROUP))) {\n+                            nodeResponse.addIssue(precedingMessage);\n+                        }\n+                    }\n+                    precedingMessage = message.getMessage();\n+                }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "94d1a817196a3c01fde99b3c6aba778a723a7bb9"}, "originalPosition": 146}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "94d1a817196a3c01fde99b3c6aba778a723a7bb9", "author": {"user": {"login": "jamisonbennett", "name": "Jamison Bennett"}}, "url": "https://github.com/hortonworks/cloudbreak/commit/94d1a817196a3c01fde99b3c6aba778a723a7bb9", "committedDate": "2020-12-16T22:41:02Z", "message": "CB-10403: Fix legacy FreeIPA health check to use the result flag\n\nFix legacy FreeIPA health check to use the result flag in all cases."}, "afterCommit": {"oid": "8146ced3b0ef6a1c0c0e8092e44dd50107b61175", "author": {"user": {"login": "jamisonbennett", "name": "Jamison Bennett"}}, "url": "https://github.com/hortonworks/cloudbreak/commit/8146ced3b0ef6a1c0c0e8092e44dd50107b61175", "committedDate": "2021-01-04T22:11:47Z", "message": "CB-10455: Fix logic which treated unreahcable FreeIPA as reachable\n\nFixed incorrect logic which treated FreeIPA is being reachable when it\nwas unreachable and cluster proxy was used. In this case cluster proxy\nreturns 502 which was incorrectly treated as a successful connection.\n\nAlthough it would become unreachable for other reasons (e.g. the 3\nminute health check), the health API would report incorrect results\nfor up to 3 minutes. There were also misleading logs which stated\nFreeIPA was reachable.\n\nThis was manually tested with a local cloudbreak cluster."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTYxNDAwMTc3", "url": "https://github.com/hortonworks/cloudbreak/pull/9657#pullrequestreview-561400177", "createdAt": "2021-01-04T22:44:18Z", "commit": {"oid": "8146ced3b0ef6a1c0c0e8092e44dd50107b61175"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNFQyMjo0NDoxOFrOIODyfQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNFQyMjo0NDoxOFrOIODyfQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTYxMzA1Mw==", "bodyText": "It is strange that the catch clause after this is LOGGER.debug. Might be LOGGER.error()\ncatch (Exception e) {\nString msg = \"Ping failed\";\nLOGGER.debug(msg, e);", "url": "https://github.com/hortonworks/cloudbreak/pull/9657#discussion_r551613053", "createdAt": "2021-01-04T22:44:18Z", "author": {"login": "christmasferret"}, "path": "freeipa/src/main/java/com/sequenceiq/freeipa/client/FreeIpaClientBuilder.java", "diffHunk": "@@ -169,7 +166,7 @@ public FreeIpaClient build(boolean withPing) throws URISyntaxException, IOExcept\n                 additionalHeaders.forEach(request::addHeader);\n                 additionalHeadersStickySessionFirstRpc.forEach(request::addHeader);\n                 try (CloseableHttpResponse response = client.execute(request)) {\n-                    if (UNAVIALLBE_PING_HTTP_RESPONSES.contains(response.getStatusLine().getStatusCode())) {\n+                    if (isUnreachableHttpStatus(response.getStatusLine().getStatusCode())) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8146ced3b0ef6a1c0c0e8092e44dd50107b61175"}, "originalPosition": 22}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "8146ced3b0ef6a1c0c0e8092e44dd50107b61175", "author": {"user": {"login": "jamisonbennett", "name": "Jamison Bennett"}}, "url": "https://github.com/hortonworks/cloudbreak/commit/8146ced3b0ef6a1c0c0e8092e44dd50107b61175", "committedDate": "2021-01-04T22:11:47Z", "message": "CB-10455: Fix logic which treated unreahcable FreeIPA as reachable\n\nFixed incorrect logic which treated FreeIPA is being reachable when it\nwas unreachable and cluster proxy was used. In this case cluster proxy\nreturns 502 which was incorrectly treated as a successful connection.\n\nAlthough it would become unreachable for other reasons (e.g. the 3\nminute health check), the health API would report incorrect results\nfor up to 3 minutes. There were also misleading logs which stated\nFreeIPA was reachable.\n\nThis was manually tested with a local cloudbreak cluster."}, "afterCommit": {"oid": "af76d4b533099401209ecd3ed66373c009397715", "author": {"user": {"login": "jamisonbennett", "name": "Jamison Bennett"}}, "url": "https://github.com/hortonworks/cloudbreak/commit/af76d4b533099401209ecd3ed66373c009397715", "committedDate": "2021-01-05T01:42:01Z", "message": "CB-9926: Add retries to the legacy health check's ping\n\nAdd retries to the legacy health check's ping.\n\nRefactor the health checks to allow it to be retry on each instance of\nFreeIPA."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTYxNzAyOTYx", "url": "https://github.com/hortonworks/cloudbreak/pull/9657#pullrequestreview-561702961", "createdAt": "2021-01-05T11:09:11Z", "commit": {"oid": "af76d4b533099401209ecd3ed66373c009397715"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "af76d4b533099401209ecd3ed66373c009397715", "author": {"user": {"login": "jamisonbennett", "name": "Jamison Bennett"}}, "url": "https://github.com/hortonworks/cloudbreak/commit/af76d4b533099401209ecd3ed66373c009397715", "committedDate": "2021-01-05T01:42:01Z", "message": "CB-9926: Add retries to the legacy health check's ping\n\nAdd retries to the legacy health check's ping.\n\nRefactor the health checks to allow it to be retry on each instance of\nFreeIPA."}, "afterCommit": {"oid": "3957e5f0e3a7ec997aa10a4c5741f1a67361269e", "author": {"user": {"login": "lturcsanyi", "name": "Laszlo Turcsanyi"}}, "url": "https://github.com/hortonworks/cloudbreak/commit/3957e5f0e3a7ec997aa10a4c5741f1a67361269e", "committedDate": "2021-01-05T13:15:50Z", "message": "CB-10311 Remove asm dependencies"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c4949413902975b3a05e857f8fe0afc02554a62d", "author": {"user": {"login": "jamisonbennett", "name": "Jamison Bennett"}}, "url": "https://github.com/hortonworks/cloudbreak/commit/c4949413902975b3a05e857f8fe0afc02554a62d", "committedDate": "2021-01-05T16:19:45Z", "message": "CB-9926: Add retries to the legacy health check's ping\n\nAdd retries to the legacy health check's ping.\n\nRefactor the health checks to allow it to be retry on each instance of\nFreeIPA."}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1889, "cost": 1, "resetAt": "2021-11-01T14:51:55Z"}}}