{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDI4Mzc1NTIy", "number": 8220, "title": "CB-7336: Add upscaling FreeIPA for recovery of non-CRL master nodes", "bodyText": "When a non-CRL master fails, the recovery should perform a downscale\nfollowed by an upscale.\nThe upscale process includes:\n\nAdding the new cloud instances\nValidating the cloud instances\nRetrieving the metadata for the new instances\nSaving the metadata for the new instances\nSetting up TLS\nBootstrapping salt on the new instances\nCollecting the new hostnames using salt\nSaving the new hostnames in the database\nInstalling FreeIPA and replicating from an existing node\nUpdating cluster proxy registration\nPost installation steps for FreeIPA to update the replication\ntopology\n\nRepair was tested with the added tests and it was also tested manually\nby repairing a 2 node FreeIPA cluster. The primary gateway was the CA\nmaster & CRL master and that node was kept.\nCloses #CB-7336", "createdAt": "2020-06-05T10:51:08Z", "url": "https://github.com/hortonworks/cloudbreak/pull/8220", "merged": true, "mergeCommit": {"oid": "26e1dca7d4ef58799aa94069f51a361280bd63e2"}, "closed": true, "closedAt": "2020-06-15T16:48:06Z", "author": {"login": "jamisonbennett"}, "timelineItems": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcphje2AFqTQyNjk1Mzg3MA==", "endCursor": "Y3Vyc29yOnYyOpPPAAABcrjUH6gFqTQzMDgwOTQ5OA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI2OTUzODcw", "url": "https://github.com/hortonworks/cloudbreak/pull/8220#pullrequestreview-426953870", "createdAt": "2020-06-09T09:22:35Z", "commit": {"oid": "693db1151dfb450ab9c365ba675720c20200a5d9"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOVQwOToyMjozNVrOGhApSw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOVQwOToyMjozNVrOGhApSw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzI2Njc2Mw==", "bodyText": "it's a bit odd and confusing for me. So with repair endpoint/request will we be able to scale the size of the FreeIPA cluster? Is it really a repair functionality? also the naming, instanceCountByGroup a bit odd, as we don't really specify any group in the request", "url": "https://github.com/hortonworks/cloudbreak/pull/8220#discussion_r437266763", "createdAt": "2020-06-09T09:22:35Z", "author": {"login": "lacikaaa"}, "path": "freeipa-api/src/main/java/com/sequenceiq/freeipa/api/v1/freeipa/stack/model/repair/RepairInstancesRequest.java", "diffHunk": "@@ -25,6 +25,9 @@\n     @ApiModelProperty(ModelDescriptions.INSTANCE_ID)\n     private List<String> instanceIds;\n \n+    @ApiModelProperty(ModelDescriptions.FREEIPA_INSTANCE_COUNT_BY_GROUP)\n+    private Integer instanceCountByGroup;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "693db1151dfb450ab9c365ba675720c20200a5d9"}, "originalPosition": 5}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI2OTY1NzY1", "url": "https://github.com/hortonworks/cloudbreak/pull/8220#pullrequestreview-426965765", "createdAt": "2020-06-09T09:36:49Z", "commit": {"oid": "693db1151dfb450ab9c365ba675720c20200a5d9"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 10, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOVQwOTozNjo1MFrOGhBRvQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOVQxMjozNTo0OFrOGhHanA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzI3NzExNw==", "bodyText": "so I see you reused this in AbstractUpscaleActions, but I think it's not best way to go. I would either duplicate this method, or introduce an AbstractScaleActions (or similar) class to have the common part instead of making these into public static", "url": "https://github.com/hortonworks/cloudbreak/pull/8220#discussion_r437277117", "createdAt": "2020-06-09T09:36:50Z", "author": {"login": "lacikaaa"}, "path": "freeipa/src/main/java/com/sequenceiq/freeipa/flow/freeipa/downscale/action/AbstractDownscaleAction.java", "diffHunk": "@@ -107,10 +109,18 @@ protected void setHosts(Map<Object, Object> variables, List<String> hosts) {\n         variables.put(HOSTS, hosts);\n     }\n \n-    protected List<String> getHosts(Map<Object, Object> variables) {\n+    public static List<String> getHosts(Map<Object, Object> variables) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "693db1151dfb450ab9c365ba675720c20200a5d9"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzI3OTIxOA==", "bodyText": "so I don't understand this. Why do we set it to DOWNSCALE_IN_PROGRESS when it's finished?", "url": "https://github.com/hortonworks/cloudbreak/pull/8220#discussion_r437279218", "createdAt": "2020-06-09T09:40:14Z", "author": {"login": "lacikaaa"}, "path": "freeipa/src/main/java/com/sequenceiq/freeipa/flow/freeipa/downscale/action/FreeIpaDownscaleActions.java", "diffHunk": "@@ -238,8 +239,12 @@ protected void doExecute(StackContext context, StackEvent payload, Map<Object, O\n                 Stack stack = context.getStack();\n                 SuccessDetails successDetails = new SuccessDetails(stack.getEnvironmentCrn());\n                 successDetails.getAdditionalDetails().put(\"Hosts\", getHosts(variables));\n-                stackUpdater.updateStackStatus(stack.getId(), DetailedStackStatus.DOWNSCALE_COMPLETED, \"Downscale complete\");\n-                operationService.completeOperation(stack.getAccountId(), getOperationId(variables), List.of(successDetails), Collections.emptyList());\n+                if (isRepair(variables)) {\n+                    stackUpdater.updateStackStatus(stack.getId(), DetailedStackStatus.DOWNSCALE_IN_PROGRESS, \"Downscale complete\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "693db1151dfb450ab9c365ba675720c20200a5d9"}, "originalPosition": 15}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzM0MTE2Mw==", "bodyText": "is it called DOWNSCALE_HOSTS on purpose?", "url": "https://github.com/hortonworks/cloudbreak/pull/8220#discussion_r437341163", "createdAt": "2020-06-09T11:37:37Z", "author": {"login": "lacikaaa"}, "path": "freeipa/src/main/java/com/sequenceiq/freeipa/flow/freeipa/upscale/action/AbstractUpscaleAction.java", "diffHunk": "@@ -0,0 +1,129 @@\n+package com.sequenceiq.freeipa.flow.freeipa.upscale.action;\n+\n+import static com.sequenceiq.cloudbreak.cloud.model.Location.location;\n+import static com.sequenceiq.cloudbreak.cloud.model.Region.region;\n+\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+\n+import javax.inject.Inject;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.statemachine.StateContext;\n+\n+import com.sequenceiq.cloudbreak.cloud.context.CloudContext;\n+import com.sequenceiq.cloudbreak.cloud.model.CloudCredential;\n+import com.sequenceiq.cloudbreak.cloud.model.CloudStack;\n+import com.sequenceiq.cloudbreak.cloud.model.Location;\n+import com.sequenceiq.cloudbreak.common.event.Payload;\n+import com.sequenceiq.cloudbreak.logger.MDCBuilder;\n+import com.sequenceiq.flow.core.FlowParameters;\n+import com.sequenceiq.freeipa.converter.cloud.CredentialToCloudCredentialConverter;\n+import com.sequenceiq.freeipa.converter.cloud.StackToCloudStackConverter;\n+import com.sequenceiq.freeipa.entity.InstanceMetaData;\n+import com.sequenceiq.freeipa.entity.Stack;\n+import com.sequenceiq.freeipa.flow.freeipa.upscale.UpscaleFlowEvent;\n+import com.sequenceiq.freeipa.flow.freeipa.upscale.UpscaleState;\n+import com.sequenceiq.freeipa.flow.stack.AbstractStackAction;\n+import com.sequenceiq.freeipa.flow.stack.StackContext;\n+import com.sequenceiq.freeipa.flow.stack.StackFailureEvent;\n+import com.sequenceiq.freeipa.service.CredentialService;\n+import com.sequenceiq.freeipa.service.stack.StackService;\n+\n+public abstract class AbstractUpscaleAction<P extends Payload> extends AbstractStackAction<UpscaleState, UpscaleFlowEvent, StackContext, P> {\n+\n+    protected static final String REPAIR = \"REPAIR\";\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(AbstractUpscaleAction.class);\n+\n+    private static final String INSTANCE_IDS = \"INSTANCE_IDS\";\n+\n+    private static final String OPERATION_ID = \"OPERATION_ID\";\n+\n+    private static final String INSTANCE_COUNT_BY_GROUP = \"INSTANCE_COUNT_BY_GROUP\";\n+\n+    private static final String HOSTS = \"DOWNSCALE_HOSTS\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "693db1151dfb450ab9c365ba675720c20200a5d9"}, "originalPosition": 48}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzM0NzEzNw==", "bodyText": "it would be a bit more compact with streams:\nOptional<Long> max = instanceGroups.stream()\n                        .flatMap(ig -> ig.getAllInstanceMetaData().stream())\n                        .filter(im -> im.getPrivateId() != null)\n                        .max(Comparator.comparing(InstanceMetaData::getPrivateId))\n                        .map(InstanceMetaData::getPrivateId);", "url": "https://github.com/hortonworks/cloudbreak/pull/8220#discussion_r437347137", "createdAt": "2020-06-09T11:49:18Z", "author": {"login": "lacikaaa"}, "path": "freeipa/src/main/java/com/sequenceiq/freeipa/flow/freeipa/upscale/action/FreeIpaUpscaleActions.java", "diffHunk": "@@ -0,0 +1,482 @@\n+package com.sequenceiq.freeipa.flow.freeipa.upscale.action;\n+\n+import static com.sequenceiq.freeipa.flow.freeipa.upscale.UpscaleFlowEvent.FAIL_HANDLED_EVENT;\n+import static com.sequenceiq.freeipa.flow.freeipa.upscale.UpscaleFlowEvent.UPSCALE_FINISHED_EVENT;\n+import static com.sequenceiq.freeipa.flow.freeipa.upscale.UpscaleFlowEvent.UPSCALE_RECORD_HOSTNAMES_FINISHED_EVENT;\n+import static com.sequenceiq.freeipa.flow.freeipa.upscale.UpscaleFlowEvent.UPSCALE_SAVE_METADATA_FINISHED_EVENT;\n+import static com.sequenceiq.freeipa.flow.freeipa.upscale.UpscaleFlowEvent.UPSCALE_STARTING_FINISHED_EVENT;\n+import static com.sequenceiq.freeipa.flow.freeipa.upscale.UpscaleFlowEvent.UPSCALE_VALIDATE_INSTANCES_FAILED_EVENT;\n+import static com.sequenceiq.freeipa.flow.freeipa.upscale.UpscaleFlowEvent.UPSCALE_VALIDATE_INSTANCES_FINISHED_EVENT;\n+import static java.lang.String.format;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import javax.inject.Inject;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.context.annotation.Bean;\n+import org.springframework.context.annotation.Configuration;\n+import org.springframework.statemachine.action.Action;\n+\n+import com.sequenceiq.cloudbreak.cloud.event.instance.CollectMetadataRequest;\n+import com.sequenceiq.cloudbreak.cloud.event.instance.CollectMetadataResult;\n+import com.sequenceiq.cloudbreak.cloud.event.resource.UpscaleStackRequest;\n+import com.sequenceiq.cloudbreak.cloud.event.resource.UpscaleStackResult;\n+import com.sequenceiq.cloudbreak.cloud.model.CloudInstance;\n+import com.sequenceiq.cloudbreak.cloud.model.CloudResource;\n+import com.sequenceiq.cloudbreak.cloud.model.CloudResourceStatus;\n+import com.sequenceiq.cloudbreak.cloud.model.CloudStack;\n+import com.sequenceiq.cloudbreak.cloud.model.CloudVmInstanceStatus;\n+import com.sequenceiq.cloudbreak.cloud.model.CloudVmMetaDataStatus;\n+import com.sequenceiq.cloudbreak.cloud.model.InstanceStatus;\n+import com.sequenceiq.cloudbreak.cloud.model.ResourceStatus;\n+import com.sequenceiq.cloudbreak.cloud.transform.ResourceLists;\n+import com.sequenceiq.cloudbreak.service.OperationException;\n+import com.sequenceiq.common.api.type.CommonResourceType;\n+import com.sequenceiq.flow.core.PayloadConverter;\n+import com.sequenceiq.freeipa.api.v1.freeipa.stack.model.common.DetailedStackStatus;\n+import com.sequenceiq.freeipa.api.v1.freeipa.user.model.FailureDetails;\n+import com.sequenceiq.freeipa.api.v1.freeipa.user.model.SuccessDetails;\n+import com.sequenceiq.freeipa.converter.cloud.ResourceToCloudResourceConverter;\n+import com.sequenceiq.freeipa.converter.cloud.StackToCloudStackConverter;\n+import com.sequenceiq.freeipa.entity.InstanceGroup;\n+import com.sequenceiq.freeipa.entity.InstanceMetaData;\n+import com.sequenceiq.freeipa.entity.Resource;\n+import com.sequenceiq.freeipa.entity.Stack;\n+import com.sequenceiq.freeipa.flow.freeipa.downscale.action.AbstractDownscaleAction;\n+import com.sequenceiq.freeipa.flow.freeipa.provision.event.bootstrap.BootstrapMachinesRequest;\n+import com.sequenceiq.freeipa.flow.freeipa.provision.event.bootstrap.BootstrapMachinesSuccess;\n+import com.sequenceiq.freeipa.flow.freeipa.provision.event.clusterproxy.ClusterProxyUpdateRegistrationRequest;\n+import com.sequenceiq.freeipa.flow.freeipa.provision.event.clusterproxy.ClusterProxyUpdateRegistrationSuccess;\n+import com.sequenceiq.freeipa.flow.freeipa.provision.event.hostmetadatasetup.HostMetadataSetupRequest;\n+import com.sequenceiq.freeipa.flow.freeipa.provision.event.hostmetadatasetup.HostMetadataSetupSuccess;\n+import com.sequenceiq.freeipa.flow.freeipa.provision.event.postinstall.PostInstallFreeIpaRequest;\n+import com.sequenceiq.freeipa.flow.freeipa.provision.event.postinstall.PostInstallFreeIpaSuccess;\n+import com.sequenceiq.freeipa.flow.freeipa.provision.event.services.InstallFreeIpaServicesRequest;\n+import com.sequenceiq.freeipa.flow.freeipa.provision.event.services.InstallFreeIpaServicesSuccess;\n+import com.sequenceiq.freeipa.flow.freeipa.upscale.UpscaleFlowEvent;\n+import com.sequenceiq.freeipa.flow.freeipa.upscale.event.UpscaleEvent;\n+import com.sequenceiq.freeipa.flow.freeipa.upscale.event.UpscaleFailureEvent;\n+import com.sequenceiq.freeipa.flow.freeipa.upscale.failure.BootstrapMachinesFailedToUpscaleFailureEventConverter;\n+import com.sequenceiq.freeipa.flow.freeipa.upscale.failure.ClusterProxyUpdateRegistrationFailedToUpscaleFailureEventConverter;\n+import com.sequenceiq.freeipa.flow.freeipa.upscale.failure.CollectMetadataResultToUpscaleFailureEventConverter;\n+import com.sequenceiq.freeipa.flow.freeipa.upscale.failure.HostMetadataSetupFailedToUpscaleFailureEventConverter;\n+import com.sequenceiq.freeipa.flow.freeipa.upscale.failure.InstallFreeIpaServicesFailedToUpscaleFailureEventConverter;\n+import com.sequenceiq.freeipa.flow.freeipa.upscale.failure.PostInstallFreeIpaFailedToUpscaleFailureEventConverter;\n+import com.sequenceiq.freeipa.flow.freeipa.upscale.failure.UpscaleStackResultToUpscaleFailureEventConverter;\n+import com.sequenceiq.freeipa.flow.stack.StackContext;\n+import com.sequenceiq.freeipa.flow.stack.StackEvent;\n+import com.sequenceiq.freeipa.service.TlsSetupService;\n+import com.sequenceiq.freeipa.service.operation.OperationService;\n+import com.sequenceiq.freeipa.service.resource.ResourceService;\n+import com.sequenceiq.freeipa.service.stack.StackUpdater;\n+import com.sequenceiq.freeipa.service.stack.instance.InstanceMetaDataService;\n+import com.sequenceiq.freeipa.service.stack.instance.MetadataSetupService;\n+\n+@Configuration\n+public class FreeIpaUpscaleActions {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(FreeIpaUpscaleActions.class);\n+\n+    @Inject\n+    private ResourceService resourceService;\n+\n+    @Inject\n+    private InstanceMetaDataService instanceMetaDataService;\n+\n+    @Inject\n+    private StackToCloudStackConverter cloudStackConverter;\n+\n+    @Inject\n+    private ResourceToCloudResourceConverter resourceConverter;\n+\n+    @Inject\n+    private MetadataSetupService metadataSetupService;\n+\n+    @Inject\n+    private TlsSetupService tlsSetupService;\n+\n+    @Inject\n+    private StackUpdater stackUpdater;\n+\n+    @Bean(name = \"UPSCALE_STARTING_STATE\")\n+    public Action<?, ?> startingAction() {\n+        return new AbstractUpscaleAction<>(UpscaleEvent.class) {\n+            @Override\n+            protected void doExecute(StackContext context, UpscaleEvent payload, Map<Object, Object> variables) {\n+                Stack stack = context.getStack();\n+                String operationId = payload.getOperationId();\n+                setOperationId(variables, operationId);\n+                setInstanceCountByGroup(variables, payload.getInstanceCountByGroup());\n+                setRepair(variables, payload.isRepair());\n+                LOGGER.info(\"Starting upscale of stack {}\", stack.getId());\n+                stackUpdater.updateStackStatus(stack.getId(), DetailedStackStatus.UPSCALE_IN_PROGRESS, \"Starting upscale\");\n+                sendEvent(context, UPSCALE_STARTING_FINISHED_EVENT.selector(), new StackEvent(stack.getId()));\n+            }\n+        };\n+    }\n+\n+    @Bean(name = \"UPSCALE_ADD_INSTANCES_STATE\")\n+    public Action<?, ?> addInstancesAction() {\n+        return new AbstractUpscaleAction<>(StackEvent.class) {\n+            @Override\n+            protected void doExecute(StackContext context, StackEvent payload, Map<Object, Object> variables) {\n+                Stack stack = context.getStack();\n+                stackUpdater.updateStackStatus(stack.getId(), DetailedStackStatus.UPSCALE_IN_PROGRESS, \"Adding instances\");\n+\n+                List<CloudInstance> newInstances = buildNewInstances(context.getStack(), getInstanceCountByGroup(variables));\n+                if (newInstances.isEmpty()) {\n+                    List<CloudResourceStatus> list = resourceService.getAllAsCloudResourceStatus(payload.getResourceId());\n+                    UpscaleStackRequest<UpscaleStackResult> request = new UpscaleStackRequest<>(\n+                            context.getCloudContext(), context.getCloudCredential(), context.getCloudStack(), ResourceLists.transform(list));\n+                    UpscaleStackResult result = new UpscaleStackResult(request.getResourceId(), ResourceStatus.CREATED, list);\n+                    sendEvent(context, result.selector(), result);\n+                } else {\n+                    Stack updatedStack = instanceMetaDataService.saveInstanceAndGetUpdatedStack(context.getStack(), newInstances);\n+                    List<CloudResource> cloudResources = resourceService.findAllByStackId(stack.getId()).stream()\n+                            .map(resource -> resourceConverter.convert(resource))\n+                            .collect(Collectors.toList());\n+                    CloudStack updatedCloudStack = cloudStackConverter.convert(updatedStack);\n+                    UpscaleStackRequest request = new UpscaleStackRequest<UpscaleStackResult>(\n+                            context.getCloudContext(), context.getCloudCredential(), updatedCloudStack, cloudResources);\n+                    sendEvent(context, request.selector(), request);\n+                }\n+            }\n+\n+            private List<CloudInstance> buildNewInstances(Stack stack, int instanceCountByGroup) {\n+                long privateId = getFirstValidPrivateId(stack.getInstanceGroups());\n+                List<CloudInstance> newInstances = new ArrayList<>();\n+                for (InstanceGroup instanceGroup : stack.getInstanceGroups()) {\n+                    int remainingInstances = instanceCountByGroup - instanceGroup.getNotDeletedInstanceMetaDataSet().size();\n+                    for (long i = 0; i < remainingInstances; ++i) {\n+                        newInstances.add(cloudStackConverter.buildInstance(stack, null, instanceGroup,\n+                                stack.getStackAuthentication(), privateId++, InstanceStatus.CREATE_REQUESTED));\n+                    }\n+                }\n+                return newInstances;\n+            }\n+\n+            private Long getFirstValidPrivateId(Set<InstanceGroup> instanceGroups) {\n+                LOGGER.debug(\"Get first valid PrivateId of instanceGroups\");\n+                long highest = 0;\n+                for (InstanceGroup instanceGroup : instanceGroups) {\n+                    LOGGER.debug(\"Checking of instanceGroup: {}\", instanceGroup.getGroupName());\n+                    for (InstanceMetaData metaData : instanceGroup.getAllInstanceMetaData()) {\n+                        Long privateId = metaData.getPrivateId();\n+                        LOGGER.debug(\"InstanceMetaData metaData: privateId: {}, instanceId: {}, status: {}\",\n+                                privateId, metaData.getInstanceId(), metaData.getInstanceStatus());\n+                        if (privateId == null) {\n+                            continue;\n+                        }\n+                        if (privateId > highest) {\n+                            highest = privateId;\n+                        }\n+                    }\n+                }\n+                LOGGER.debug(\"Highest privateId: {}\", highest);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "693db1151dfb450ab9c365ba675720c20200a5d9"}, "originalPosition": 185}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzM1OTA5NA==", "bodyText": "should be: UpscaleStackRequest<UpscaleStackResult> request = new UpscaleStackRequest<>(", "url": "https://github.com/hortonworks/cloudbreak/pull/8220#discussion_r437359094", "createdAt": "2020-06-09T12:11:42Z", "author": {"login": "lacikaaa"}, "path": "freeipa/src/main/java/com/sequenceiq/freeipa/flow/freeipa/upscale/action/FreeIpaUpscaleActions.java", "diffHunk": "@@ -0,0 +1,482 @@\n+package com.sequenceiq.freeipa.flow.freeipa.upscale.action;\n+\n+import static com.sequenceiq.freeipa.flow.freeipa.upscale.UpscaleFlowEvent.FAIL_HANDLED_EVENT;\n+import static com.sequenceiq.freeipa.flow.freeipa.upscale.UpscaleFlowEvent.UPSCALE_FINISHED_EVENT;\n+import static com.sequenceiq.freeipa.flow.freeipa.upscale.UpscaleFlowEvent.UPSCALE_RECORD_HOSTNAMES_FINISHED_EVENT;\n+import static com.sequenceiq.freeipa.flow.freeipa.upscale.UpscaleFlowEvent.UPSCALE_SAVE_METADATA_FINISHED_EVENT;\n+import static com.sequenceiq.freeipa.flow.freeipa.upscale.UpscaleFlowEvent.UPSCALE_STARTING_FINISHED_EVENT;\n+import static com.sequenceiq.freeipa.flow.freeipa.upscale.UpscaleFlowEvent.UPSCALE_VALIDATE_INSTANCES_FAILED_EVENT;\n+import static com.sequenceiq.freeipa.flow.freeipa.upscale.UpscaleFlowEvent.UPSCALE_VALIDATE_INSTANCES_FINISHED_EVENT;\n+import static java.lang.String.format;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import javax.inject.Inject;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.context.annotation.Bean;\n+import org.springframework.context.annotation.Configuration;\n+import org.springframework.statemachine.action.Action;\n+\n+import com.sequenceiq.cloudbreak.cloud.event.instance.CollectMetadataRequest;\n+import com.sequenceiq.cloudbreak.cloud.event.instance.CollectMetadataResult;\n+import com.sequenceiq.cloudbreak.cloud.event.resource.UpscaleStackRequest;\n+import com.sequenceiq.cloudbreak.cloud.event.resource.UpscaleStackResult;\n+import com.sequenceiq.cloudbreak.cloud.model.CloudInstance;\n+import com.sequenceiq.cloudbreak.cloud.model.CloudResource;\n+import com.sequenceiq.cloudbreak.cloud.model.CloudResourceStatus;\n+import com.sequenceiq.cloudbreak.cloud.model.CloudStack;\n+import com.sequenceiq.cloudbreak.cloud.model.CloudVmInstanceStatus;\n+import com.sequenceiq.cloudbreak.cloud.model.CloudVmMetaDataStatus;\n+import com.sequenceiq.cloudbreak.cloud.model.InstanceStatus;\n+import com.sequenceiq.cloudbreak.cloud.model.ResourceStatus;\n+import com.sequenceiq.cloudbreak.cloud.transform.ResourceLists;\n+import com.sequenceiq.cloudbreak.service.OperationException;\n+import com.sequenceiq.common.api.type.CommonResourceType;\n+import com.sequenceiq.flow.core.PayloadConverter;\n+import com.sequenceiq.freeipa.api.v1.freeipa.stack.model.common.DetailedStackStatus;\n+import com.sequenceiq.freeipa.api.v1.freeipa.user.model.FailureDetails;\n+import com.sequenceiq.freeipa.api.v1.freeipa.user.model.SuccessDetails;\n+import com.sequenceiq.freeipa.converter.cloud.ResourceToCloudResourceConverter;\n+import com.sequenceiq.freeipa.converter.cloud.StackToCloudStackConverter;\n+import com.sequenceiq.freeipa.entity.InstanceGroup;\n+import com.sequenceiq.freeipa.entity.InstanceMetaData;\n+import com.sequenceiq.freeipa.entity.Resource;\n+import com.sequenceiq.freeipa.entity.Stack;\n+import com.sequenceiq.freeipa.flow.freeipa.downscale.action.AbstractDownscaleAction;\n+import com.sequenceiq.freeipa.flow.freeipa.provision.event.bootstrap.BootstrapMachinesRequest;\n+import com.sequenceiq.freeipa.flow.freeipa.provision.event.bootstrap.BootstrapMachinesSuccess;\n+import com.sequenceiq.freeipa.flow.freeipa.provision.event.clusterproxy.ClusterProxyUpdateRegistrationRequest;\n+import com.sequenceiq.freeipa.flow.freeipa.provision.event.clusterproxy.ClusterProxyUpdateRegistrationSuccess;\n+import com.sequenceiq.freeipa.flow.freeipa.provision.event.hostmetadatasetup.HostMetadataSetupRequest;\n+import com.sequenceiq.freeipa.flow.freeipa.provision.event.hostmetadatasetup.HostMetadataSetupSuccess;\n+import com.sequenceiq.freeipa.flow.freeipa.provision.event.postinstall.PostInstallFreeIpaRequest;\n+import com.sequenceiq.freeipa.flow.freeipa.provision.event.postinstall.PostInstallFreeIpaSuccess;\n+import com.sequenceiq.freeipa.flow.freeipa.provision.event.services.InstallFreeIpaServicesRequest;\n+import com.sequenceiq.freeipa.flow.freeipa.provision.event.services.InstallFreeIpaServicesSuccess;\n+import com.sequenceiq.freeipa.flow.freeipa.upscale.UpscaleFlowEvent;\n+import com.sequenceiq.freeipa.flow.freeipa.upscale.event.UpscaleEvent;\n+import com.sequenceiq.freeipa.flow.freeipa.upscale.event.UpscaleFailureEvent;\n+import com.sequenceiq.freeipa.flow.freeipa.upscale.failure.BootstrapMachinesFailedToUpscaleFailureEventConverter;\n+import com.sequenceiq.freeipa.flow.freeipa.upscale.failure.ClusterProxyUpdateRegistrationFailedToUpscaleFailureEventConverter;\n+import com.sequenceiq.freeipa.flow.freeipa.upscale.failure.CollectMetadataResultToUpscaleFailureEventConverter;\n+import com.sequenceiq.freeipa.flow.freeipa.upscale.failure.HostMetadataSetupFailedToUpscaleFailureEventConverter;\n+import com.sequenceiq.freeipa.flow.freeipa.upscale.failure.InstallFreeIpaServicesFailedToUpscaleFailureEventConverter;\n+import com.sequenceiq.freeipa.flow.freeipa.upscale.failure.PostInstallFreeIpaFailedToUpscaleFailureEventConverter;\n+import com.sequenceiq.freeipa.flow.freeipa.upscale.failure.UpscaleStackResultToUpscaleFailureEventConverter;\n+import com.sequenceiq.freeipa.flow.stack.StackContext;\n+import com.sequenceiq.freeipa.flow.stack.StackEvent;\n+import com.sequenceiq.freeipa.service.TlsSetupService;\n+import com.sequenceiq.freeipa.service.operation.OperationService;\n+import com.sequenceiq.freeipa.service.resource.ResourceService;\n+import com.sequenceiq.freeipa.service.stack.StackUpdater;\n+import com.sequenceiq.freeipa.service.stack.instance.InstanceMetaDataService;\n+import com.sequenceiq.freeipa.service.stack.instance.MetadataSetupService;\n+\n+@Configuration\n+public class FreeIpaUpscaleActions {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(FreeIpaUpscaleActions.class);\n+\n+    @Inject\n+    private ResourceService resourceService;\n+\n+    @Inject\n+    private InstanceMetaDataService instanceMetaDataService;\n+\n+    @Inject\n+    private StackToCloudStackConverter cloudStackConverter;\n+\n+    @Inject\n+    private ResourceToCloudResourceConverter resourceConverter;\n+\n+    @Inject\n+    private MetadataSetupService metadataSetupService;\n+\n+    @Inject\n+    private TlsSetupService tlsSetupService;\n+\n+    @Inject\n+    private StackUpdater stackUpdater;\n+\n+    @Bean(name = \"UPSCALE_STARTING_STATE\")\n+    public Action<?, ?> startingAction() {\n+        return new AbstractUpscaleAction<>(UpscaleEvent.class) {\n+            @Override\n+            protected void doExecute(StackContext context, UpscaleEvent payload, Map<Object, Object> variables) {\n+                Stack stack = context.getStack();\n+                String operationId = payload.getOperationId();\n+                setOperationId(variables, operationId);\n+                setInstanceCountByGroup(variables, payload.getInstanceCountByGroup());\n+                setRepair(variables, payload.isRepair());\n+                LOGGER.info(\"Starting upscale of stack {}\", stack.getId());\n+                stackUpdater.updateStackStatus(stack.getId(), DetailedStackStatus.UPSCALE_IN_PROGRESS, \"Starting upscale\");\n+                sendEvent(context, UPSCALE_STARTING_FINISHED_EVENT.selector(), new StackEvent(stack.getId()));\n+            }\n+        };\n+    }\n+\n+    @Bean(name = \"UPSCALE_ADD_INSTANCES_STATE\")\n+    public Action<?, ?> addInstancesAction() {\n+        return new AbstractUpscaleAction<>(StackEvent.class) {\n+            @Override\n+            protected void doExecute(StackContext context, StackEvent payload, Map<Object, Object> variables) {\n+                Stack stack = context.getStack();\n+                stackUpdater.updateStackStatus(stack.getId(), DetailedStackStatus.UPSCALE_IN_PROGRESS, \"Adding instances\");\n+\n+                List<CloudInstance> newInstances = buildNewInstances(context.getStack(), getInstanceCountByGroup(variables));\n+                if (newInstances.isEmpty()) {\n+                    List<CloudResourceStatus> list = resourceService.getAllAsCloudResourceStatus(payload.getResourceId());\n+                    UpscaleStackRequest<UpscaleStackResult> request = new UpscaleStackRequest<>(\n+                            context.getCloudContext(), context.getCloudCredential(), context.getCloudStack(), ResourceLists.transform(list));\n+                    UpscaleStackResult result = new UpscaleStackResult(request.getResourceId(), ResourceStatus.CREATED, list);\n+                    sendEvent(context, result.selector(), result);\n+                } else {\n+                    Stack updatedStack = instanceMetaDataService.saveInstanceAndGetUpdatedStack(context.getStack(), newInstances);\n+                    List<CloudResource> cloudResources = resourceService.findAllByStackId(stack.getId()).stream()\n+                            .map(resource -> resourceConverter.convert(resource))\n+                            .collect(Collectors.toList());\n+                    CloudStack updatedCloudStack = cloudStackConverter.convert(updatedStack);\n+                    UpscaleStackRequest request = new UpscaleStackRequest<UpscaleStackResult>(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "693db1151dfb450ab9c365ba675720c20200a5d9"}, "originalPosition": 149}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzM2MTE4OQ==", "bodyText": "could you refactor the if-else branches to methods?", "url": "https://github.com/hortonworks/cloudbreak/pull/8220#discussion_r437361189", "createdAt": "2020-06-09T12:15:24Z", "author": {"login": "lacikaaa"}, "path": "freeipa/src/main/java/com/sequenceiq/freeipa/flow/freeipa/upscale/action/FreeIpaUpscaleActions.java", "diffHunk": "@@ -0,0 +1,482 @@\n+package com.sequenceiq.freeipa.flow.freeipa.upscale.action;\n+\n+import static com.sequenceiq.freeipa.flow.freeipa.upscale.UpscaleFlowEvent.FAIL_HANDLED_EVENT;\n+import static com.sequenceiq.freeipa.flow.freeipa.upscale.UpscaleFlowEvent.UPSCALE_FINISHED_EVENT;\n+import static com.sequenceiq.freeipa.flow.freeipa.upscale.UpscaleFlowEvent.UPSCALE_RECORD_HOSTNAMES_FINISHED_EVENT;\n+import static com.sequenceiq.freeipa.flow.freeipa.upscale.UpscaleFlowEvent.UPSCALE_SAVE_METADATA_FINISHED_EVENT;\n+import static com.sequenceiq.freeipa.flow.freeipa.upscale.UpscaleFlowEvent.UPSCALE_STARTING_FINISHED_EVENT;\n+import static com.sequenceiq.freeipa.flow.freeipa.upscale.UpscaleFlowEvent.UPSCALE_VALIDATE_INSTANCES_FAILED_EVENT;\n+import static com.sequenceiq.freeipa.flow.freeipa.upscale.UpscaleFlowEvent.UPSCALE_VALIDATE_INSTANCES_FINISHED_EVENT;\n+import static java.lang.String.format;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import javax.inject.Inject;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.context.annotation.Bean;\n+import org.springframework.context.annotation.Configuration;\n+import org.springframework.statemachine.action.Action;\n+\n+import com.sequenceiq.cloudbreak.cloud.event.instance.CollectMetadataRequest;\n+import com.sequenceiq.cloudbreak.cloud.event.instance.CollectMetadataResult;\n+import com.sequenceiq.cloudbreak.cloud.event.resource.UpscaleStackRequest;\n+import com.sequenceiq.cloudbreak.cloud.event.resource.UpscaleStackResult;\n+import com.sequenceiq.cloudbreak.cloud.model.CloudInstance;\n+import com.sequenceiq.cloudbreak.cloud.model.CloudResource;\n+import com.sequenceiq.cloudbreak.cloud.model.CloudResourceStatus;\n+import com.sequenceiq.cloudbreak.cloud.model.CloudStack;\n+import com.sequenceiq.cloudbreak.cloud.model.CloudVmInstanceStatus;\n+import com.sequenceiq.cloudbreak.cloud.model.CloudVmMetaDataStatus;\n+import com.sequenceiq.cloudbreak.cloud.model.InstanceStatus;\n+import com.sequenceiq.cloudbreak.cloud.model.ResourceStatus;\n+import com.sequenceiq.cloudbreak.cloud.transform.ResourceLists;\n+import com.sequenceiq.cloudbreak.service.OperationException;\n+import com.sequenceiq.common.api.type.CommonResourceType;\n+import com.sequenceiq.flow.core.PayloadConverter;\n+import com.sequenceiq.freeipa.api.v1.freeipa.stack.model.common.DetailedStackStatus;\n+import com.sequenceiq.freeipa.api.v1.freeipa.user.model.FailureDetails;\n+import com.sequenceiq.freeipa.api.v1.freeipa.user.model.SuccessDetails;\n+import com.sequenceiq.freeipa.converter.cloud.ResourceToCloudResourceConverter;\n+import com.sequenceiq.freeipa.converter.cloud.StackToCloudStackConverter;\n+import com.sequenceiq.freeipa.entity.InstanceGroup;\n+import com.sequenceiq.freeipa.entity.InstanceMetaData;\n+import com.sequenceiq.freeipa.entity.Resource;\n+import com.sequenceiq.freeipa.entity.Stack;\n+import com.sequenceiq.freeipa.flow.freeipa.downscale.action.AbstractDownscaleAction;\n+import com.sequenceiq.freeipa.flow.freeipa.provision.event.bootstrap.BootstrapMachinesRequest;\n+import com.sequenceiq.freeipa.flow.freeipa.provision.event.bootstrap.BootstrapMachinesSuccess;\n+import com.sequenceiq.freeipa.flow.freeipa.provision.event.clusterproxy.ClusterProxyUpdateRegistrationRequest;\n+import com.sequenceiq.freeipa.flow.freeipa.provision.event.clusterproxy.ClusterProxyUpdateRegistrationSuccess;\n+import com.sequenceiq.freeipa.flow.freeipa.provision.event.hostmetadatasetup.HostMetadataSetupRequest;\n+import com.sequenceiq.freeipa.flow.freeipa.provision.event.hostmetadatasetup.HostMetadataSetupSuccess;\n+import com.sequenceiq.freeipa.flow.freeipa.provision.event.postinstall.PostInstallFreeIpaRequest;\n+import com.sequenceiq.freeipa.flow.freeipa.provision.event.postinstall.PostInstallFreeIpaSuccess;\n+import com.sequenceiq.freeipa.flow.freeipa.provision.event.services.InstallFreeIpaServicesRequest;\n+import com.sequenceiq.freeipa.flow.freeipa.provision.event.services.InstallFreeIpaServicesSuccess;\n+import com.sequenceiq.freeipa.flow.freeipa.upscale.UpscaleFlowEvent;\n+import com.sequenceiq.freeipa.flow.freeipa.upscale.event.UpscaleEvent;\n+import com.sequenceiq.freeipa.flow.freeipa.upscale.event.UpscaleFailureEvent;\n+import com.sequenceiq.freeipa.flow.freeipa.upscale.failure.BootstrapMachinesFailedToUpscaleFailureEventConverter;\n+import com.sequenceiq.freeipa.flow.freeipa.upscale.failure.ClusterProxyUpdateRegistrationFailedToUpscaleFailureEventConverter;\n+import com.sequenceiq.freeipa.flow.freeipa.upscale.failure.CollectMetadataResultToUpscaleFailureEventConverter;\n+import com.sequenceiq.freeipa.flow.freeipa.upscale.failure.HostMetadataSetupFailedToUpscaleFailureEventConverter;\n+import com.sequenceiq.freeipa.flow.freeipa.upscale.failure.InstallFreeIpaServicesFailedToUpscaleFailureEventConverter;\n+import com.sequenceiq.freeipa.flow.freeipa.upscale.failure.PostInstallFreeIpaFailedToUpscaleFailureEventConverter;\n+import com.sequenceiq.freeipa.flow.freeipa.upscale.failure.UpscaleStackResultToUpscaleFailureEventConverter;\n+import com.sequenceiq.freeipa.flow.stack.StackContext;\n+import com.sequenceiq.freeipa.flow.stack.StackEvent;\n+import com.sequenceiq.freeipa.service.TlsSetupService;\n+import com.sequenceiq.freeipa.service.operation.OperationService;\n+import com.sequenceiq.freeipa.service.resource.ResourceService;\n+import com.sequenceiq.freeipa.service.stack.StackUpdater;\n+import com.sequenceiq.freeipa.service.stack.instance.InstanceMetaDataService;\n+import com.sequenceiq.freeipa.service.stack.instance.MetadataSetupService;\n+\n+@Configuration\n+public class FreeIpaUpscaleActions {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(FreeIpaUpscaleActions.class);\n+\n+    @Inject\n+    private ResourceService resourceService;\n+\n+    @Inject\n+    private InstanceMetaDataService instanceMetaDataService;\n+\n+    @Inject\n+    private StackToCloudStackConverter cloudStackConverter;\n+\n+    @Inject\n+    private ResourceToCloudResourceConverter resourceConverter;\n+\n+    @Inject\n+    private MetadataSetupService metadataSetupService;\n+\n+    @Inject\n+    private TlsSetupService tlsSetupService;\n+\n+    @Inject\n+    private StackUpdater stackUpdater;\n+\n+    @Bean(name = \"UPSCALE_STARTING_STATE\")\n+    public Action<?, ?> startingAction() {\n+        return new AbstractUpscaleAction<>(UpscaleEvent.class) {\n+            @Override\n+            protected void doExecute(StackContext context, UpscaleEvent payload, Map<Object, Object> variables) {\n+                Stack stack = context.getStack();\n+                String operationId = payload.getOperationId();\n+                setOperationId(variables, operationId);\n+                setInstanceCountByGroup(variables, payload.getInstanceCountByGroup());\n+                setRepair(variables, payload.isRepair());\n+                LOGGER.info(\"Starting upscale of stack {}\", stack.getId());\n+                stackUpdater.updateStackStatus(stack.getId(), DetailedStackStatus.UPSCALE_IN_PROGRESS, \"Starting upscale\");\n+                sendEvent(context, UPSCALE_STARTING_FINISHED_EVENT.selector(), new StackEvent(stack.getId()));\n+            }\n+        };\n+    }\n+\n+    @Bean(name = \"UPSCALE_ADD_INSTANCES_STATE\")\n+    public Action<?, ?> addInstancesAction() {\n+        return new AbstractUpscaleAction<>(StackEvent.class) {\n+            @Override\n+            protected void doExecute(StackContext context, StackEvent payload, Map<Object, Object> variables) {\n+                Stack stack = context.getStack();\n+                stackUpdater.updateStackStatus(stack.getId(), DetailedStackStatus.UPSCALE_IN_PROGRESS, \"Adding instances\");\n+\n+                List<CloudInstance> newInstances = buildNewInstances(context.getStack(), getInstanceCountByGroup(variables));\n+                if (newInstances.isEmpty()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "693db1151dfb450ab9c365ba675720c20200a5d9"}, "originalPosition": 137}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzM2NDg2NA==", "bodyText": "nit: you could use stack instead of context.getStack()", "url": "https://github.com/hortonworks/cloudbreak/pull/8220#discussion_r437364864", "createdAt": "2020-06-09T12:20:56Z", "author": {"login": "lacikaaa"}, "path": "freeipa/src/main/java/com/sequenceiq/freeipa/flow/freeipa/upscale/action/FreeIpaUpscaleActions.java", "diffHunk": "@@ -0,0 +1,482 @@\n+package com.sequenceiq.freeipa.flow.freeipa.upscale.action;\n+\n+import static com.sequenceiq.freeipa.flow.freeipa.upscale.UpscaleFlowEvent.FAIL_HANDLED_EVENT;\n+import static com.sequenceiq.freeipa.flow.freeipa.upscale.UpscaleFlowEvent.UPSCALE_FINISHED_EVENT;\n+import static com.sequenceiq.freeipa.flow.freeipa.upscale.UpscaleFlowEvent.UPSCALE_RECORD_HOSTNAMES_FINISHED_EVENT;\n+import static com.sequenceiq.freeipa.flow.freeipa.upscale.UpscaleFlowEvent.UPSCALE_SAVE_METADATA_FINISHED_EVENT;\n+import static com.sequenceiq.freeipa.flow.freeipa.upscale.UpscaleFlowEvent.UPSCALE_STARTING_FINISHED_EVENT;\n+import static com.sequenceiq.freeipa.flow.freeipa.upscale.UpscaleFlowEvent.UPSCALE_VALIDATE_INSTANCES_FAILED_EVENT;\n+import static com.sequenceiq.freeipa.flow.freeipa.upscale.UpscaleFlowEvent.UPSCALE_VALIDATE_INSTANCES_FINISHED_EVENT;\n+import static java.lang.String.format;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import javax.inject.Inject;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.context.annotation.Bean;\n+import org.springframework.context.annotation.Configuration;\n+import org.springframework.statemachine.action.Action;\n+\n+import com.sequenceiq.cloudbreak.cloud.event.instance.CollectMetadataRequest;\n+import com.sequenceiq.cloudbreak.cloud.event.instance.CollectMetadataResult;\n+import com.sequenceiq.cloudbreak.cloud.event.resource.UpscaleStackRequest;\n+import com.sequenceiq.cloudbreak.cloud.event.resource.UpscaleStackResult;\n+import com.sequenceiq.cloudbreak.cloud.model.CloudInstance;\n+import com.sequenceiq.cloudbreak.cloud.model.CloudResource;\n+import com.sequenceiq.cloudbreak.cloud.model.CloudResourceStatus;\n+import com.sequenceiq.cloudbreak.cloud.model.CloudStack;\n+import com.sequenceiq.cloudbreak.cloud.model.CloudVmInstanceStatus;\n+import com.sequenceiq.cloudbreak.cloud.model.CloudVmMetaDataStatus;\n+import com.sequenceiq.cloudbreak.cloud.model.InstanceStatus;\n+import com.sequenceiq.cloudbreak.cloud.model.ResourceStatus;\n+import com.sequenceiq.cloudbreak.cloud.transform.ResourceLists;\n+import com.sequenceiq.cloudbreak.service.OperationException;\n+import com.sequenceiq.common.api.type.CommonResourceType;\n+import com.sequenceiq.flow.core.PayloadConverter;\n+import com.sequenceiq.freeipa.api.v1.freeipa.stack.model.common.DetailedStackStatus;\n+import com.sequenceiq.freeipa.api.v1.freeipa.user.model.FailureDetails;\n+import com.sequenceiq.freeipa.api.v1.freeipa.user.model.SuccessDetails;\n+import com.sequenceiq.freeipa.converter.cloud.ResourceToCloudResourceConverter;\n+import com.sequenceiq.freeipa.converter.cloud.StackToCloudStackConverter;\n+import com.sequenceiq.freeipa.entity.InstanceGroup;\n+import com.sequenceiq.freeipa.entity.InstanceMetaData;\n+import com.sequenceiq.freeipa.entity.Resource;\n+import com.sequenceiq.freeipa.entity.Stack;\n+import com.sequenceiq.freeipa.flow.freeipa.downscale.action.AbstractDownscaleAction;\n+import com.sequenceiq.freeipa.flow.freeipa.provision.event.bootstrap.BootstrapMachinesRequest;\n+import com.sequenceiq.freeipa.flow.freeipa.provision.event.bootstrap.BootstrapMachinesSuccess;\n+import com.sequenceiq.freeipa.flow.freeipa.provision.event.clusterproxy.ClusterProxyUpdateRegistrationRequest;\n+import com.sequenceiq.freeipa.flow.freeipa.provision.event.clusterproxy.ClusterProxyUpdateRegistrationSuccess;\n+import com.sequenceiq.freeipa.flow.freeipa.provision.event.hostmetadatasetup.HostMetadataSetupRequest;\n+import com.sequenceiq.freeipa.flow.freeipa.provision.event.hostmetadatasetup.HostMetadataSetupSuccess;\n+import com.sequenceiq.freeipa.flow.freeipa.provision.event.postinstall.PostInstallFreeIpaRequest;\n+import com.sequenceiq.freeipa.flow.freeipa.provision.event.postinstall.PostInstallFreeIpaSuccess;\n+import com.sequenceiq.freeipa.flow.freeipa.provision.event.services.InstallFreeIpaServicesRequest;\n+import com.sequenceiq.freeipa.flow.freeipa.provision.event.services.InstallFreeIpaServicesSuccess;\n+import com.sequenceiq.freeipa.flow.freeipa.upscale.UpscaleFlowEvent;\n+import com.sequenceiq.freeipa.flow.freeipa.upscale.event.UpscaleEvent;\n+import com.sequenceiq.freeipa.flow.freeipa.upscale.event.UpscaleFailureEvent;\n+import com.sequenceiq.freeipa.flow.freeipa.upscale.failure.BootstrapMachinesFailedToUpscaleFailureEventConverter;\n+import com.sequenceiq.freeipa.flow.freeipa.upscale.failure.ClusterProxyUpdateRegistrationFailedToUpscaleFailureEventConverter;\n+import com.sequenceiq.freeipa.flow.freeipa.upscale.failure.CollectMetadataResultToUpscaleFailureEventConverter;\n+import com.sequenceiq.freeipa.flow.freeipa.upscale.failure.HostMetadataSetupFailedToUpscaleFailureEventConverter;\n+import com.sequenceiq.freeipa.flow.freeipa.upscale.failure.InstallFreeIpaServicesFailedToUpscaleFailureEventConverter;\n+import com.sequenceiq.freeipa.flow.freeipa.upscale.failure.PostInstallFreeIpaFailedToUpscaleFailureEventConverter;\n+import com.sequenceiq.freeipa.flow.freeipa.upscale.failure.UpscaleStackResultToUpscaleFailureEventConverter;\n+import com.sequenceiq.freeipa.flow.stack.StackContext;\n+import com.sequenceiq.freeipa.flow.stack.StackEvent;\n+import com.sequenceiq.freeipa.service.TlsSetupService;\n+import com.sequenceiq.freeipa.service.operation.OperationService;\n+import com.sequenceiq.freeipa.service.resource.ResourceService;\n+import com.sequenceiq.freeipa.service.stack.StackUpdater;\n+import com.sequenceiq.freeipa.service.stack.instance.InstanceMetaDataService;\n+import com.sequenceiq.freeipa.service.stack.instance.MetadataSetupService;\n+\n+@Configuration\n+public class FreeIpaUpscaleActions {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(FreeIpaUpscaleActions.class);\n+\n+    @Inject\n+    private ResourceService resourceService;\n+\n+    @Inject\n+    private InstanceMetaDataService instanceMetaDataService;\n+\n+    @Inject\n+    private StackToCloudStackConverter cloudStackConverter;\n+\n+    @Inject\n+    private ResourceToCloudResourceConverter resourceConverter;\n+\n+    @Inject\n+    private MetadataSetupService metadataSetupService;\n+\n+    @Inject\n+    private TlsSetupService tlsSetupService;\n+\n+    @Inject\n+    private StackUpdater stackUpdater;\n+\n+    @Bean(name = \"UPSCALE_STARTING_STATE\")\n+    public Action<?, ?> startingAction() {\n+        return new AbstractUpscaleAction<>(UpscaleEvent.class) {\n+            @Override\n+            protected void doExecute(StackContext context, UpscaleEvent payload, Map<Object, Object> variables) {\n+                Stack stack = context.getStack();\n+                String operationId = payload.getOperationId();\n+                setOperationId(variables, operationId);\n+                setInstanceCountByGroup(variables, payload.getInstanceCountByGroup());\n+                setRepair(variables, payload.isRepair());\n+                LOGGER.info(\"Starting upscale of stack {}\", stack.getId());\n+                stackUpdater.updateStackStatus(stack.getId(), DetailedStackStatus.UPSCALE_IN_PROGRESS, \"Starting upscale\");\n+                sendEvent(context, UPSCALE_STARTING_FINISHED_EVENT.selector(), new StackEvent(stack.getId()));\n+            }\n+        };\n+    }\n+\n+    @Bean(name = \"UPSCALE_ADD_INSTANCES_STATE\")\n+    public Action<?, ?> addInstancesAction() {\n+        return new AbstractUpscaleAction<>(StackEvent.class) {\n+            @Override\n+            protected void doExecute(StackContext context, StackEvent payload, Map<Object, Object> variables) {\n+                Stack stack = context.getStack();\n+                stackUpdater.updateStackStatus(stack.getId(), DetailedStackStatus.UPSCALE_IN_PROGRESS, \"Adding instances\");\n+\n+                List<CloudInstance> newInstances = buildNewInstances(context.getStack(), getInstanceCountByGroup(variables));\n+                if (newInstances.isEmpty()) {\n+                    List<CloudResourceStatus> list = resourceService.getAllAsCloudResourceStatus(payload.getResourceId());\n+                    UpscaleStackRequest<UpscaleStackResult> request = new UpscaleStackRequest<>(\n+                            context.getCloudContext(), context.getCloudCredential(), context.getCloudStack(), ResourceLists.transform(list));\n+                    UpscaleStackResult result = new UpscaleStackResult(request.getResourceId(), ResourceStatus.CREATED, list);\n+                    sendEvent(context, result.selector(), result);\n+                } else {\n+                    Stack updatedStack = instanceMetaDataService.saveInstanceAndGetUpdatedStack(context.getStack(), newInstances);\n+                    List<CloudResource> cloudResources = resourceService.findAllByStackId(stack.getId()).stream()\n+                            .map(resource -> resourceConverter.convert(resource))\n+                            .collect(Collectors.toList());\n+                    CloudStack updatedCloudStack = cloudStackConverter.convert(updatedStack);\n+                    UpscaleStackRequest request = new UpscaleStackRequest<UpscaleStackResult>(\n+                            context.getCloudContext(), context.getCloudCredential(), updatedCloudStack, cloudResources);\n+                    sendEvent(context, request.selector(), request);\n+                }\n+            }\n+\n+            private List<CloudInstance> buildNewInstances(Stack stack, int instanceCountByGroup) {\n+                long privateId = getFirstValidPrivateId(stack.getInstanceGroups());\n+                List<CloudInstance> newInstances = new ArrayList<>();\n+                for (InstanceGroup instanceGroup : stack.getInstanceGroups()) {\n+                    int remainingInstances = instanceCountByGroup - instanceGroup.getNotDeletedInstanceMetaDataSet().size();\n+                    for (long i = 0; i < remainingInstances; ++i) {\n+                        newInstances.add(cloudStackConverter.buildInstance(stack, null, instanceGroup,\n+                                stack.getStackAuthentication(), privateId++, InstanceStatus.CREATE_REQUESTED));\n+                    }\n+                }\n+                return newInstances;\n+            }\n+\n+            private Long getFirstValidPrivateId(Set<InstanceGroup> instanceGroups) {\n+                LOGGER.debug(\"Get first valid PrivateId of instanceGroups\");\n+                long highest = 0;\n+                for (InstanceGroup instanceGroup : instanceGroups) {\n+                    LOGGER.debug(\"Checking of instanceGroup: {}\", instanceGroup.getGroupName());\n+                    for (InstanceMetaData metaData : instanceGroup.getAllInstanceMetaData()) {\n+                        Long privateId = metaData.getPrivateId();\n+                        LOGGER.debug(\"InstanceMetaData metaData: privateId: {}, instanceId: {}, status: {}\",\n+                                privateId, metaData.getInstanceId(), metaData.getInstanceStatus());\n+                        if (privateId == null) {\n+                            continue;\n+                        }\n+                        if (privateId > highest) {\n+                            highest = privateId;\n+                        }\n+                    }\n+                }\n+                LOGGER.debug(\"Highest privateId: {}\", highest);\n+                return highest == 0 ? 0 : highest + 1;\n+            }\n+\n+        };\n+    }\n+\n+    @Bean(name = \"UPSCALE_VALIDATE_INSTANCES_STATE\")\n+    public Action<?, ?> validateInstancesAction() {\n+        return new AbstractUpscaleAction<>(UpscaleStackResult.class) {\n+            @Override\n+            protected void doExecute(StackContext context, UpscaleStackResult payload, Map<Object, Object> variables) {\n+                Stack stack = context.getStack();\n+                stackUpdater.updateStackStatus(stack.getId(), DetailedStackStatus.UPSCALE_IN_PROGRESS, \"Validating new instances\");\n+                try {\n+                    finishAddInstances(context, payload);\n+                    sendEvent(context, UPSCALE_VALIDATE_INSTANCES_FINISHED_EVENT.selector(), new StackEvent(stack.getId()));\n+                } catch (Exception e) {\n+                    sendEvent(context, UPSCALE_VALIDATE_INSTANCES_FAILED_EVENT.selector(),\n+                            new UpscaleFailureEvent(stack.getId(), \"Validating new instances\", Set.of(), Map.of(), e));\n+                }\n+            }\n+\n+            private void finishAddInstances(StackContext context, UpscaleStackResult payload) {\n+                LOGGER.debug(\"Upscale stack result: {}\", payload);\n+                List<CloudResourceStatus> results = payload.getResults();\n+                validateResourceResults(context, payload.getErrorDetails(), results);\n+                Set<Resource> resourceSet = transformResults(results, context.getStack());\n+                if (resourceSet.isEmpty()) {\n+                    metadataSetupService.cleanupRequestedInstances(context.getStack());\n+                    throw new OperationException(\"Failed to upscale the cluster since all create request failed. Resource set is empty\");\n+                }\n+                LOGGER.debug(\"Adding new instances to the stack is DONE\");\n+            }\n+\n+            private void validateResourceResults(StackContext context, Exception exception, List<CloudResourceStatus> results) {\n+                if (exception != null) {\n+                    LOGGER.info(format(\"Failed to upscale stack: %s\", context.getCloudContext()), exception);\n+                    throw new OperationException(exception);\n+                }\n+                List<CloudResourceStatus> templates = results.stream().filter(result -> CommonResourceType.TEMPLATE == result.getCloudResource().getType()\n+                        .getCommonResourceType()).collect(Collectors.toList());\n+                if (!templates.isEmpty() && (templates.get(0).isFailed() || templates.get(0).isDeleted())) {\n+                    throw new OperationException(format(\"Failed to upscale the stack for %s due to: %s\",\n+                            context.getCloudContext(), templates.get(0).getStatusReason()));\n+                }\n+            }\n+\n+            private Set<Resource> transformResults(Iterable<CloudResourceStatus> cloudResourceStatuses, Stack stack) {\n+                Set<Resource> retSet = new HashSet<>();\n+                for (CloudResourceStatus cloudResourceStatus : cloudResourceStatuses) {\n+                    if (!cloudResourceStatus.isFailed()) {\n+                        CloudResource cloudResource = cloudResourceStatus.getCloudResource();\n+                        Resource resource = new Resource(\n+                                cloudResource.getType(), cloudResource.getName(), cloudResource.getReference(), cloudResource.getStatus(), stack, null);\n+                        retSet.add(resource);\n+                    }\n+                }\n+                return retSet;\n+            }\n+        };\n+    }\n+\n+    @Bean(name = \"UPSCALE_EXTEND_METADATA_STATE\")\n+    public Action<?, ?> extendMetadataAction() {\n+        return new AbstractUpscaleAction<>(StackEvent.class) {\n+\n+            private final Set<InstanceStatus> unusedInstanceStatuses = Set.of(InstanceStatus.CREATE_REQUESTED, InstanceStatus.CREATED);\n+\n+            @Override\n+            protected void doExecute(StackContext context, StackEvent payload, Map<Object, Object> variables) {\n+                Stack stack = context.getStack();\n+                stackUpdater.updateStackStatus(stack.getId(), DetailedStackStatus.UPSCALE_IN_PROGRESS, \"Extending metadata\");\n+\n+                List<CloudInstance> allKnownInstances = cloudStackConverter.buildInstances(context.getStack());\n+                List<Resource> resources = resourceService.findAllByStackId(context.getStack().getId());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "693db1151dfb450ab9c365ba675720c20200a5d9"}, "originalPosition": 260}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzM3NDc3Nw==", "bodyText": "could you refactor this? like move the rest of the method to a separate one, and put that call in the if.", "url": "https://github.com/hortonworks/cloudbreak/pull/8220#discussion_r437374777", "createdAt": "2020-06-09T12:31:56Z", "author": {"login": "lacikaaa"}, "path": "freeipa/src/main/java/com/sequenceiq/freeipa/service/freeipa/flow/FreeIpaPostInstallService.java", "diffHunk": "@@ -65,11 +65,14 @@\n     @Inject\n     private FreeIpaService freeIpaService;\n \n-    public void postInstallFreeIpa(Long stackId) throws Exception {\n-        LOGGER.debug(\"Performing post-install configuration for stack {}\", stackId);\n+    public void postInstallFreeIpa(Long stackId, boolean fullPostInstall) throws Exception {\n+        LOGGER.debug(\"Performing post-install configuration for stack {}. {}.\", stackId, fullPostInstall ? \"Full post install\" : \"Partial post install\");\n         Stack stack = stackService.getStackById(stackId);\n         FreeIpaClient freeIpaClient = freeIpaClientFactory.getFreeIpaClientForStack(stack);\n         freeIpaTopologyService.updateReplicationTopology(stackId, freeIpaClient);\n+        if (!fullPostInstall) {\n+            return;\n+        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "693db1151dfb450ab9c365ba675720c20200a5d9"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzM3NzUwNg==", "bodyText": "this might worth to be refactored into it's own method", "url": "https://github.com/hortonworks/cloudbreak/pull/8220#discussion_r437377506", "createdAt": "2020-06-09T12:35:28Z", "author": {"login": "lacikaaa"}, "path": "freeipa/src/main/java/com/sequenceiq/freeipa/service/stack/RepairInstancesService.java", "diffHunk": "@@ -65,6 +70,49 @@\n     @Inject\n     private OperationToOperationStatusConverter operationToOperationStatusConverter;\n \n+    @Inject\n+    private EntitlementService entitlementService;\n+\n+    @Value(\"${freeipa.max.instances}\")\n+    private int maxInstances;\n+\n+    private void validate(String accountId, Stack stack, Set<InstanceMetaData> remainingInstances, Collection<InstanceMetaData> instancesToRepair,\n+            Integer instanceCountByGroup) {\n+        if (!entitlementService.freeIpaHaEnabled(INTERNAL_ACTOR_CRN, accountId)) {\n+            throw new BadRequestException(\"The FreeIPA HA capability is disabled.\");\n+        }\n+        if (null == instanceCountByGroup) {\n+            throw new BadRequestException(\"Instance count by group is required.\");\n+        }\n+        int requestedNumberOfNodes = instanceCountByGroup * stack.getInstanceGroups().size();\n+        if (instancesToRepair.isEmpty()) {\n+            throw new NotFoundException(\"No unhealthy instances to repair.  Maybe use the force option.\");\n+        }\n+        if (remainingInstances.isEmpty()) {\n+            throw new BadRequestException(\"At least one instance must remain running during a repair.\");\n+        }\n+        if (requestedNumberOfNodes <= 1) {\n+            throw new BadRequestException(\"After repairing FreeIPA there must be at least 2 instances of FreeIPA\");\n+        }\n+        if (requestedNumberOfNodes > maxInstances) {\n+            throw new BadRequestException(String.format(\"After repairing FreeIPA there must be at most %d instances.\", maxInstances));\n+        }\n+        Set<String> remainingInstanceIds = remainingInstances.stream()\n+                .map(InstanceMetaData::getInstanceId)\n+                .collect(Collectors.toSet());\n+        long numInstanceGroupsWithTooMandNodes = stack.getInstanceGroups().stream()\n+                .map(instanceGroup ->\n+                    instanceGroup.getInstanceMetaData().stream()\n+                            .map(InstanceMetaData::getInstanceId)\n+                            .filter(instanceId -> remainingInstanceIds.contains(instanceId))\n+                            .count())\n+                .filter(count -> count > instanceCountByGroup)\n+                .count();\n+        if (numInstanceGroupsWithTooMandNodes > 0) {\n+            throw new BadRequestException(\"The instance count by group cannot be reduced during a repair.\");\n+        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "693db1151dfb450ab9c365ba675720c20200a5d9"}, "originalPosition": 87}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzM3NzY5Mg==", "bodyText": "typo: Mand -> Many", "url": "https://github.com/hortonworks/cloudbreak/pull/8220#discussion_r437377692", "createdAt": "2020-06-09T12:35:48Z", "author": {"login": "lacikaaa"}, "path": "freeipa/src/main/java/com/sequenceiq/freeipa/service/stack/RepairInstancesService.java", "diffHunk": "@@ -65,6 +70,49 @@\n     @Inject\n     private OperationToOperationStatusConverter operationToOperationStatusConverter;\n \n+    @Inject\n+    private EntitlementService entitlementService;\n+\n+    @Value(\"${freeipa.max.instances}\")\n+    private int maxInstances;\n+\n+    private void validate(String accountId, Stack stack, Set<InstanceMetaData> remainingInstances, Collection<InstanceMetaData> instancesToRepair,\n+            Integer instanceCountByGroup) {\n+        if (!entitlementService.freeIpaHaEnabled(INTERNAL_ACTOR_CRN, accountId)) {\n+            throw new BadRequestException(\"The FreeIPA HA capability is disabled.\");\n+        }\n+        if (null == instanceCountByGroup) {\n+            throw new BadRequestException(\"Instance count by group is required.\");\n+        }\n+        int requestedNumberOfNodes = instanceCountByGroup * stack.getInstanceGroups().size();\n+        if (instancesToRepair.isEmpty()) {\n+            throw new NotFoundException(\"No unhealthy instances to repair.  Maybe use the force option.\");\n+        }\n+        if (remainingInstances.isEmpty()) {\n+            throw new BadRequestException(\"At least one instance must remain running during a repair.\");\n+        }\n+        if (requestedNumberOfNodes <= 1) {\n+            throw new BadRequestException(\"After repairing FreeIPA there must be at least 2 instances of FreeIPA\");\n+        }\n+        if (requestedNumberOfNodes > maxInstances) {\n+            throw new BadRequestException(String.format(\"After repairing FreeIPA there must be at most %d instances.\", maxInstances));\n+        }\n+        Set<String> remainingInstanceIds = remainingInstances.stream()\n+                .map(InstanceMetaData::getInstanceId)\n+                .collect(Collectors.toSet());\n+        long numInstanceGroupsWithTooMandNodes = stack.getInstanceGroups().stream()\n+                .map(instanceGroup ->\n+                    instanceGroup.getInstanceMetaData().stream()\n+                            .map(InstanceMetaData::getInstanceId)\n+                            .filter(instanceId -> remainingInstanceIds.contains(instanceId))\n+                            .count())\n+                .filter(count -> count > instanceCountByGroup)\n+                .count();\n+        if (numInstanceGroupsWithTooMandNodes > 0) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "693db1151dfb450ab9c365ba675720c20200a5d9"}, "originalPosition": 85}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "693db1151dfb450ab9c365ba675720c20200a5d9", "author": {"user": {"login": "jamisonbennett", "name": "Jamison Bennett"}}, "url": "https://github.com/hortonworks/cloudbreak/commit/693db1151dfb450ab9c365ba675720c20200a5d9", "committedDate": "2020-06-05T10:49:02Z", "message": "CB-7336: Add upscaling FreeIPA for recovery of non-CRL master nodes\n\nWhen a non-CRL master fails, the recovery should perform a downscale\nfollowed by an upscale.\nThe upscale process includes:\n  * Adding the new cloud instances\n  * Validating the cloud instances\n  * Retrieving the metadata for the new instances\n  * Saving the metadata for the new instances\n  * Setting up TLS\n  * Bootstrapping salt on the new instances\n  * Collecting the new hostnames using salt\n  * Saving the new hostnames in the database\n  * Installing FreeIPA and replicating from an existing node\n  * Updating cluster proxy registration\n  * Post installation steps for FreeIPA to update the replication\n    topology\n\nRepair was tested with the added tests and it was also tested manually\nby repairing a 2 node FreeIPA cluster. The primary gateway was the CA\nmaster & CRL master and that node was kept."}, "afterCommit": {"oid": "5ad1816a0508b559927e3c1178960fa4ed1cf513", "author": {"user": {"login": "jamisonbennett", "name": "Jamison Bennett"}}, "url": "https://github.com/hortonworks/cloudbreak/commit/5ad1816a0508b559927e3c1178960fa4ed1cf513", "committedDate": "2020-06-10T22:16:43Z", "message": "CB-7336: Add upscaling FreeIPA for recovery of non-CRL master nodes\n\nWhen a non-CRL master fails, the recovery should perform a downscale\nfollowed by an upscale.\nThe upscale process includes:\n  * Adding the new cloud instances\n  * Validating the cloud instances\n  * Retrieving the metadata for the new instances\n  * Saving the metadata for the new instances\n  * Setting up TLS\n  * Bootstrapping salt on the new instances\n  * Collecting the new hostnames using salt\n  * Saving the new hostnames in the database\n  * Installing FreeIPA and replicating from an existing node\n  * Updating cluster proxy registration\n  * Post installation steps for FreeIPA to update the replication\n    topology\n\nRepair was tested with the added tests and it was also tested manually\nby repairing a 2 node FreeIPA cluster. The primary gateway was the CA\nmaster & CRL master and that node was kept."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI5NzUwNjk5", "url": "https://github.com/hortonworks/cloudbreak/pull/8220#pullrequestreview-429750699", "createdAt": "2020-06-12T13:43:21Z", "commit": {"oid": "5ad1816a0508b559927e3c1178960fa4ed1cf513"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMlQxMzo0MzoyMVrOGjEb_A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMlQxMzo0ODoyM1rOGjEnpA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTQyNjA0NA==", "bodyText": "so this will produce invalid output. if we have highest ID 0 then we will return 0 as first valid id. this should be an Optional<Long> and the return look like:\nreturn highest.isPresent() ? highest.get() + 1 : 0;\n\nalso we might have a test for this method to be sure we don't break it in the future", "url": "https://github.com/hortonworks/cloudbreak/pull/8220#discussion_r439426044", "createdAt": "2020-06-12T13:43:21Z", "author": {"login": "lacikaaa"}, "path": "core/src/main/java/com/sequenceiq/cloudbreak/core/flow2/stack/upscale/StackUpscaleService.java", "diffHunk": "@@ -206,21 +206,12 @@ private void validateResourceResults(StackScalingFlowContext context, Exception\n \n     private Long getFirstValidPrivateId(List<InstanceGroup> instanceGroups) {\n         LOGGER.debug(\"Get first valid PrivateId of instanceGroups\");\n-        long highest = 0;\n-        for (InstanceGroup instanceGroup : instanceGroups) {\n-            LOGGER.debug(\"Checking of instanceGroup: {}\", instanceGroup.getGroupName());\n-            for (InstanceMetaData metaData : instanceGroup.getAllInstanceMetaData()) {\n-                Long privateId = metaData.getPrivateId();\n-                LOGGER.debug(\"InstanceMetaData metaData: privateId: {}, instanceGroupName: {}, instanceId: {}, status: {}\",\n-                        privateId, metaData.getInstanceGroupName(), metaData.getInstanceId(), metaData.getInstanceStatus());\n-                if (privateId == null) {\n-                    continue;\n-                }\n-                if (privateId > highest) {\n-                    highest = privateId;\n-                }\n-            }\n-        }\n+        long highest = instanceGroups.stream()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5ad1816a0508b559927e3c1178960fa4ed1cf513"}, "originalPosition": 19}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTQyOTAyOA==", "bodyText": "this seems to me to be a duplicate. we might move this method to a separate class. it would make testing easier", "url": "https://github.com/hortonworks/cloudbreak/pull/8220#discussion_r439429028", "createdAt": "2020-06-12T13:48:23Z", "author": {"login": "lacikaaa"}, "path": "freeipa/src/main/java/com/sequenceiq/freeipa/flow/freeipa/upscale/action/FreeIpaUpscaleActions.java", "diffHunk": "@@ -0,0 +1,507 @@\n+package com.sequenceiq.freeipa.flow.freeipa.upscale.action;\n+\n+import static com.sequenceiq.freeipa.flow.freeipa.upscale.UpscaleFlowEvent.FAIL_HANDLED_EVENT;\n+import static com.sequenceiq.freeipa.flow.freeipa.upscale.UpscaleFlowEvent.UPSCALE_FINISHED_EVENT;\n+import static com.sequenceiq.freeipa.flow.freeipa.upscale.UpscaleFlowEvent.UPSCALE_RECORD_HOSTNAMES_FINISHED_EVENT;\n+import static com.sequenceiq.freeipa.flow.freeipa.upscale.UpscaleFlowEvent.UPSCALE_SAVE_METADATA_FINISHED_EVENT;\n+import static com.sequenceiq.freeipa.flow.freeipa.upscale.UpscaleFlowEvent.UPSCALE_STARTING_FINISHED_EVENT;\n+import static com.sequenceiq.freeipa.flow.freeipa.upscale.UpscaleFlowEvent.UPSCALE_UPDATE_METADATA_FINISHED_EVENT;\n+import static com.sequenceiq.freeipa.flow.freeipa.upscale.UpscaleFlowEvent.UPSCALE_VALIDATE_INSTANCES_FAILED_EVENT;\n+import static com.sequenceiq.freeipa.flow.freeipa.upscale.UpscaleFlowEvent.UPSCALE_VALIDATE_INSTANCES_FINISHED_EVENT;\n+import static java.lang.String.format;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import javax.inject.Inject;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.context.annotation.Bean;\n+import org.springframework.context.annotation.Configuration;\n+import org.springframework.statemachine.action.Action;\n+\n+import com.sequenceiq.cloudbreak.cloud.event.instance.CollectMetadataRequest;\n+import com.sequenceiq.cloudbreak.cloud.event.instance.CollectMetadataResult;\n+import com.sequenceiq.cloudbreak.cloud.event.resource.UpscaleStackRequest;\n+import com.sequenceiq.cloudbreak.cloud.event.resource.UpscaleStackResult;\n+import com.sequenceiq.cloudbreak.cloud.model.CloudInstance;\n+import com.sequenceiq.cloudbreak.cloud.model.CloudResource;\n+import com.sequenceiq.cloudbreak.cloud.model.CloudResourceStatus;\n+import com.sequenceiq.cloudbreak.cloud.model.CloudStack;\n+import com.sequenceiq.cloudbreak.cloud.model.CloudVmInstanceStatus;\n+import com.sequenceiq.cloudbreak.cloud.model.CloudVmMetaDataStatus;\n+import com.sequenceiq.cloudbreak.cloud.model.InstanceStatus;\n+import com.sequenceiq.cloudbreak.cloud.model.ResourceStatus;\n+import com.sequenceiq.cloudbreak.cloud.transform.ResourceLists;\n+import com.sequenceiq.cloudbreak.service.OperationException;\n+import com.sequenceiq.common.api.type.CommonResourceType;\n+import com.sequenceiq.flow.core.PayloadConverter;\n+import com.sequenceiq.freeipa.api.v1.freeipa.stack.model.common.DetailedStackStatus;\n+import com.sequenceiq.freeipa.api.v1.freeipa.user.model.FailureDetails;\n+import com.sequenceiq.freeipa.api.v1.freeipa.user.model.SuccessDetails;\n+import com.sequenceiq.freeipa.converter.cloud.ResourceToCloudResourceConverter;\n+import com.sequenceiq.freeipa.converter.cloud.StackToCloudStackConverter;\n+import com.sequenceiq.freeipa.entity.InstanceGroup;\n+import com.sequenceiq.freeipa.entity.InstanceMetaData;\n+import com.sequenceiq.freeipa.entity.Resource;\n+import com.sequenceiq.freeipa.entity.Stack;\n+import com.sequenceiq.freeipa.flow.freeipa.provision.event.bootstrap.BootstrapMachinesRequest;\n+import com.sequenceiq.freeipa.flow.freeipa.provision.event.bootstrap.BootstrapMachinesSuccess;\n+import com.sequenceiq.freeipa.flow.freeipa.provision.event.clusterproxy.ClusterProxyUpdateRegistrationRequest;\n+import com.sequenceiq.freeipa.flow.freeipa.provision.event.clusterproxy.ClusterProxyUpdateRegistrationSuccess;\n+import com.sequenceiq.freeipa.flow.freeipa.provision.event.hostmetadatasetup.HostMetadataSetupRequest;\n+import com.sequenceiq.freeipa.flow.freeipa.provision.event.hostmetadatasetup.HostMetadataSetupSuccess;\n+import com.sequenceiq.freeipa.flow.freeipa.provision.event.postinstall.PostInstallFreeIpaRequest;\n+import com.sequenceiq.freeipa.flow.freeipa.provision.event.postinstall.PostInstallFreeIpaSuccess;\n+import com.sequenceiq.freeipa.flow.freeipa.provision.event.services.InstallFreeIpaServicesRequest;\n+import com.sequenceiq.freeipa.flow.freeipa.provision.event.services.InstallFreeIpaServicesSuccess;\n+import com.sequenceiq.freeipa.flow.freeipa.upscale.UpscaleFlowEvent;\n+import com.sequenceiq.freeipa.flow.freeipa.upscale.event.UpscaleEvent;\n+import com.sequenceiq.freeipa.flow.freeipa.upscale.event.UpscaleFailureEvent;\n+import com.sequenceiq.freeipa.flow.freeipa.upscale.failure.BootstrapMachinesFailedToUpscaleFailureEventConverter;\n+import com.sequenceiq.freeipa.flow.freeipa.upscale.failure.ClusterProxyUpdateRegistrationFailedToUpscaleFailureEventConverter;\n+import com.sequenceiq.freeipa.flow.freeipa.upscale.failure.CollectMetadataResultToUpscaleFailureEventConverter;\n+import com.sequenceiq.freeipa.flow.freeipa.upscale.failure.HostMetadataSetupFailedToUpscaleFailureEventConverter;\n+import com.sequenceiq.freeipa.flow.freeipa.upscale.failure.InstallFreeIpaServicesFailedToUpscaleFailureEventConverter;\n+import com.sequenceiq.freeipa.flow.freeipa.upscale.failure.PostInstallFreeIpaFailedToUpscaleFailureEventConverter;\n+import com.sequenceiq.freeipa.flow.freeipa.upscale.failure.UpscaleStackResultToUpscaleFailureEventConverter;\n+import com.sequenceiq.freeipa.flow.stack.StackContext;\n+import com.sequenceiq.freeipa.flow.stack.StackEvent;\n+import com.sequenceiq.freeipa.service.TlsSetupService;\n+import com.sequenceiq.freeipa.service.operation.OperationService;\n+import com.sequenceiq.freeipa.service.resource.ResourceService;\n+import com.sequenceiq.freeipa.service.stack.StackUpdater;\n+import com.sequenceiq.freeipa.service.stack.instance.InstanceGroupService;\n+import com.sequenceiq.freeipa.service.stack.instance.InstanceMetaDataService;\n+import com.sequenceiq.freeipa.service.stack.instance.MetadataSetupService;\n+\n+@Configuration\n+public class FreeIpaUpscaleActions {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(FreeIpaUpscaleActions.class);\n+\n+    @Inject\n+    private ResourceService resourceService;\n+\n+    @Inject\n+    private InstanceMetaDataService instanceMetaDataService;\n+\n+    @Inject\n+    private StackToCloudStackConverter cloudStackConverter;\n+\n+    @Inject\n+    private ResourceToCloudResourceConverter resourceConverter;\n+\n+    @Inject\n+    private MetadataSetupService metadataSetupService;\n+\n+    @Inject\n+    private TlsSetupService tlsSetupService;\n+\n+    @Inject\n+    private StackUpdater stackUpdater;\n+\n+    @Inject\n+    private InstanceGroupService instanceGroupService;\n+\n+    @Bean(name = \"UPSCALE_STARTING_STATE\")\n+    public Action<?, ?> startingAction() {\n+        return new AbstractUpscaleAction<>(UpscaleEvent.class) {\n+            @Override\n+            protected void doExecute(StackContext context, UpscaleEvent payload, Map<Object, Object> variables) {\n+                Stack stack = context.getStack();\n+                String operationId = payload.getOperationId();\n+                setOperationId(variables, operationId);\n+                setInstanceCountByGroup(variables, payload.getInstanceCountByGroup());\n+                setRepair(variables, payload.isRepair());\n+                LOGGER.info(\"Starting upscale of stack {}\", stack.getId());\n+                stackUpdater.updateStackStatus(stack.getId(), DetailedStackStatus.UPSCALE_IN_PROGRESS, \"Starting upscale\");\n+                sendEvent(context, UPSCALE_STARTING_FINISHED_EVENT.selector(), new StackEvent(stack.getId()));\n+            }\n+        };\n+    }\n+\n+    @Bean(name = \"UPSCALE_ADD_INSTANCES_STATE\")\n+    public Action<?, ?> addInstancesAction() {\n+        return new AbstractUpscaleAction<>(StackEvent.class) {\n+            @Override\n+            protected void doExecute(StackContext context, StackEvent payload, Map<Object, Object> variables) {\n+                Stack stack = context.getStack();\n+                stackUpdater.updateStackStatus(stack.getId(), DetailedStackStatus.UPSCALE_IN_PROGRESS, \"Adding instances\");\n+\n+                List<CloudInstance> newInstances = buildNewInstances(context.getStack(), getInstanceCountByGroup(variables));\n+                if (newInstances.isEmpty()) {\n+                    skipAddingNewInstances(context, stack);\n+                } else {\n+                    addNewInstances(context, stack, newInstances);\n+                }\n+            }\n+\n+            private void skipAddingNewInstances(StackContext context, Stack stack) {\n+                List<CloudResourceStatus> list = resourceService.getAllAsCloudResourceStatus(stack.getId());\n+                UpscaleStackRequest<UpscaleStackResult> request = new UpscaleStackRequest<>(\n+                        context.getCloudContext(), context.getCloudCredential(), context.getCloudStack(), ResourceLists.transform(list));\n+                UpscaleStackResult result = new UpscaleStackResult(request.getResourceId(), ResourceStatus.CREATED, list);\n+                sendEvent(context, result.selector(), result);\n+            }\n+\n+            private void addNewInstances(StackContext context, Stack stack, List<CloudInstance> newInstances) {\n+                Stack updatedStack = instanceMetaDataService.saveInstanceAndGetUpdatedStack(stack, newInstances);\n+                List<CloudResource> cloudResources = resourceService.findAllByStackId(stack.getId()).stream()\n+                        .map(resource -> resourceConverter.convert(resource))\n+                        .collect(Collectors.toList());\n+                CloudStack updatedCloudStack = cloudStackConverter.convert(updatedStack);\n+                UpscaleStackRequest<UpscaleStackResult> request = new UpscaleStackRequest<>(\n+                        context.getCloudContext(), context.getCloudCredential(), updatedCloudStack, cloudResources);\n+                sendEvent(context, request.selector(), request);\n+            }\n+\n+            private List<CloudInstance> buildNewInstances(Stack stack, int instanceCountByGroup) {\n+                long privateId = getFirstValidPrivateId(stack.getInstanceGroups());\n+                List<CloudInstance> newInstances = new ArrayList<>();\n+                for (InstanceGroup instanceGroup : stack.getInstanceGroups()) {\n+                    int remainingInstances = instanceCountByGroup - instanceGroup.getNotDeletedInstanceMetaDataSet().size();\n+                    for (long i = 0; i < remainingInstances; ++i) {\n+                        newInstances.add(cloudStackConverter.buildInstance(stack, null, instanceGroup,\n+                                stack.getStackAuthentication(), privateId++, InstanceStatus.CREATE_REQUESTED));\n+                    }\n+                }\n+                return newInstances;\n+            }\n+\n+            private Long getFirstValidPrivateId(Set<InstanceGroup> instanceGroups) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5ad1816a0508b559927e3c1178960fa4ed1cf513"}, "originalPosition": 180}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c7a071b8ecf462190a9553cf42d38f152bf411dd", "author": {"user": {"login": "jamisonbennett", "name": "Jamison Bennett"}}, "url": "https://github.com/hortonworks/cloudbreak/commit/c7a071b8ecf462190a9553cf42d38f152bf411dd", "committedDate": "2020-06-12T19:04:05Z", "message": "CB-7336: Add upscaling FreeIPA for recovery of non-CRL master nodes\n\nWhen a non-CRL master fails, the recovery should perform a downscale\nfollowed by an upscale.\nThe upscale process includes:\n  * Adding the new cloud instances\n  * Validating the cloud instances\n  * Retrieving the metadata for the new instances\n  * Saving the metadata for the new instances\n  * Setting up TLS\n  * Bootstrapping salt on the new instances\n  * Collecting the new hostnames using salt\n  * Saving the new hostnames in the database\n  * Installing FreeIPA and replicating from an existing node\n  * Updating cluster proxy registration\n  * Post installation steps for FreeIPA to update the replication\n    topology\n\nRepair was tested with the added tests and it was also tested manually\nby repairing a 2 node FreeIPA cluster. The primary gateway was the CA\nmaster & CRL master and that node was kept."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "5ad1816a0508b559927e3c1178960fa4ed1cf513", "author": {"user": {"login": "jamisonbennett", "name": "Jamison Bennett"}}, "url": "https://github.com/hortonworks/cloudbreak/commit/5ad1816a0508b559927e3c1178960fa4ed1cf513", "committedDate": "2020-06-10T22:16:43Z", "message": "CB-7336: Add upscaling FreeIPA for recovery of non-CRL master nodes\n\nWhen a non-CRL master fails, the recovery should perform a downscale\nfollowed by an upscale.\nThe upscale process includes:\n  * Adding the new cloud instances\n  * Validating the cloud instances\n  * Retrieving the metadata for the new instances\n  * Saving the metadata for the new instances\n  * Setting up TLS\n  * Bootstrapping salt on the new instances\n  * Collecting the new hostnames using salt\n  * Saving the new hostnames in the database\n  * Installing FreeIPA and replicating from an existing node\n  * Updating cluster proxy registration\n  * Post installation steps for FreeIPA to update the replication\n    topology\n\nRepair was tested with the added tests and it was also tested manually\nby repairing a 2 node FreeIPA cluster. The primary gateway was the CA\nmaster & CRL master and that node was kept."}, "afterCommit": {"oid": "c7a071b8ecf462190a9553cf42d38f152bf411dd", "author": {"user": {"login": "jamisonbennett", "name": "Jamison Bennett"}}, "url": "https://github.com/hortonworks/cloudbreak/commit/c7a071b8ecf462190a9553cf42d38f152bf411dd", "committedDate": "2020-06-12T19:04:05Z", "message": "CB-7336: Add upscaling FreeIPA for recovery of non-CRL master nodes\n\nWhen a non-CRL master fails, the recovery should perform a downscale\nfollowed by an upscale.\nThe upscale process includes:\n  * Adding the new cloud instances\n  * Validating the cloud instances\n  * Retrieving the metadata for the new instances\n  * Saving the metadata for the new instances\n  * Setting up TLS\n  * Bootstrapping salt on the new instances\n  * Collecting the new hostnames using salt\n  * Saving the new hostnames in the database\n  * Installing FreeIPA and replicating from an existing node\n  * Updating cluster proxy registration\n  * Post installation steps for FreeIPA to update the replication\n    topology\n\nRepair was tested with the added tests and it was also tested manually\nby repairing a 2 node FreeIPA cluster. The primary gateway was the CA\nmaster & CRL master and that node was kept."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMwODA5NDk4", "url": "https://github.com/hortonworks/cloudbreak/pull/8220#pullrequestreview-430809498", "createdAt": "2020-06-15T16:33:29Z", "commit": {"oid": "c7a071b8ecf462190a9553cf42d38f152bf411dd"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1806, "cost": 1, "resetAt": "2021-11-01T14:51:55Z"}}}