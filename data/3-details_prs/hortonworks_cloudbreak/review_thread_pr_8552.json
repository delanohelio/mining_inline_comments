{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDQ4OTgxNzY5", "number": 8552, "reviewThreads": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNVQxMDoxNDozMlrOEOnqtQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNVQxMDoxNDozMlrOEOnqtQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgzNzY1NDI5OnYy", "diffSide": "RIGHT", "path": "environment/src/main/java/com/sequenceiq/environment/credential/v1/AuditCredentialV1Controller.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNVQxMDoxNDozMlrOGx3mdA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNVQxMDoxNDozMlrOGx3mdA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDk0NDM3Mg==", "bodyText": "this should be authorized against the existing credential resource, not on account level\nto do that:\n\nadd @CheckPermissionByResourceObject to the method\nadd @ResourceObject to the credentialrequest parameter (it is there as i see)\nadd @ResourceObjectField(action = AuthorizationResourceAction.EDIT_CREDENTIAL, variableType = AuthorizationVariableType.NAME) to the name field of the CredentialRequest class (I think this is done too since it is the same class as used in other crednetial controller)\n\nso I think the method annotation should be changed only", "url": "https://github.com/hortonworks/cloudbreak/pull/8552#discussion_r454944372", "createdAt": "2020-07-15T10:14:32Z", "author": {"login": "horadla23"}, "path": "environment/src/main/java/com/sequenceiq/environment/credential/v1/AuditCredentialV1Controller.java", "diffHunk": "@@ -0,0 +1,106 @@\n+package com.sequenceiq.environment.credential.v1;\n+\n+import static com.sequenceiq.common.model.CredentialType.AUDIT;\n+import static com.sequenceiq.common.model.CredentialType.onlyAudit;\n+\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import javax.validation.Valid;\n+\n+import org.springframework.stereotype.Controller;\n+\n+import com.sequenceiq.authorization.annotation.AuthorizationResource;\n+import com.sequenceiq.authorization.annotation.CheckPermissionByAccount;\n+import com.sequenceiq.authorization.annotation.CheckPermissionByResourceCrn;\n+import com.sequenceiq.authorization.annotation.FilterListBasedOnPermissions;\n+import com.sequenceiq.authorization.annotation.ResourceCrn;\n+import com.sequenceiq.authorization.annotation.ResourceObject;\n+import com.sequenceiq.authorization.resource.AuthorizationResourceAction;\n+import com.sequenceiq.cloudbreak.auth.ThreadBasedUserCrnProvider;\n+import com.sequenceiq.cloudbreak.auth.security.internal.InternalReady;\n+import com.sequenceiq.cloudbreak.auth.security.internal.TenantAwareParam;\n+import com.sequenceiq.cloudbreak.cloud.response.CredentialPrerequisitesResponse;\n+import com.sequenceiq.cloudbreak.event.ResourceEvent;\n+import com.sequenceiq.cloudbreak.exception.BadRequestException;\n+import com.sequenceiq.common.model.CredentialType;\n+import com.sequenceiq.environment.api.v1.credential.endpoint.AuditCredentialEndpoint;\n+import com.sequenceiq.environment.api.v1.credential.model.request.CredentialRequest;\n+import com.sequenceiq.environment.api.v1.credential.model.response.CredentialResponse;\n+import com.sequenceiq.environment.api.v1.credential.model.response.CredentialResponses;\n+import com.sequenceiq.environment.credential.domain.Credential;\n+import com.sequenceiq.environment.credential.service.CredentialService;\n+import com.sequenceiq.environment.credential.v1.converter.CredentialToCredentialV1ResponseConverter;\n+import com.sequenceiq.notification.NotificationController;\n+\n+@Controller\n+@InternalReady\n+@AuthorizationResource\n+public class AuditCredentialV1Controller extends NotificationController implements AuditCredentialEndpoint {\n+\n+    private final CredentialService credentialService;\n+\n+    private final CredentialToCredentialV1ResponseConverter credentialConverter;\n+\n+    public AuditCredentialV1Controller(\n+            CredentialService credentialService,\n+            CredentialToCredentialV1ResponseConverter credentialConverter) {\n+        this.credentialService = credentialService;\n+        this.credentialConverter = credentialConverter;\n+    }\n+\n+    @Override\n+    @FilterListBasedOnPermissions(action = AuthorizationResourceAction.DESCRIBE_CREDENTIAL)\n+    public CredentialResponses list() {\n+        String accountId = ThreadBasedUserCrnProvider.getAccountId();\n+        return new CredentialResponses(\n+                credentialService.listAvailablesByAccountId(accountId, onlyAudit())\n+                        .stream()\n+                        .map(credentialConverter::convert)\n+                        .collect(Collectors.toSet()));\n+    }\n+\n+    @Override\n+    @CheckPermissionByResourceCrn(action = AuthorizationResourceAction.DESCRIBE_CREDENTIAL)\n+    public CredentialResponse getByResourceCrn(@TenantAwareParam @ResourceCrn String credentialCrn) {\n+        String accountId = ThreadBasedUserCrnProvider.getAccountId();\n+        return credentialConverter.convert(credentialService.getByCrnForAccountId(credentialCrn, accountId, onlyAudit()));\n+    }\n+\n+    @Override\n+    @CheckPermissionByAccount(action = AuthorizationResourceAction.CREATE_CREDENTIAL)\n+    public CredentialResponse post(@Valid CredentialRequest request) {\n+        String accountId = ThreadBasedUserCrnProvider.getAccountId();\n+        String creator = ThreadBasedUserCrnProvider.getUserCrn();\n+        Credential credential = credentialConverter.convert(request);\n+        credential.setType(AUDIT);\n+        notify(ResourceEvent.CREDENTIAL_CREATED);\n+        Set<Credential> auditCredentialsByPlatfom = credentialService\n+                .listAvailablesByAccountId(accountId, onlyAudit())\n+                .stream()\n+                .filter(c -> c.getCloudPlatform().equals(credential.getCloudPlatform()))\n+                .collect(Collectors.toSet());\n+        if (auditCredentialsByPlatfom.isEmpty()) {\n+            return credentialConverter.convert(credentialService.create(credential, accountId, creator, onlyAudit()));\n+        } else {\n+            throw new BadRequestException(String.format(\"Audit credential already exist for %s cloud.\", credential.getCloudPlatform()));\n+        }\n+    }\n+\n+    @Override\n+    @CheckPermissionByAccount(action = AuthorizationResourceAction.CREATE_CREDENTIAL)\n+    public CredentialResponse put(@ResourceObject @Valid CredentialRequest credentialRequest) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cacef9135d4f7cd3f7ee89044d055015e36ab8a6"}, "originalPosition": 92}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3041, "cost": 1, "resetAt": "2021-11-12T20:44:06Z"}}}