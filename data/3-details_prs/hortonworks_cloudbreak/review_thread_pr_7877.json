{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDA3NTc1OTg1", "number": 7877, "reviewThreads": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yM1QwNzoxODoxMVrOD1Ic7g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yM1QwOToxODozNFrOD1Lw4Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU3MDM5NTk4OnYy", "diffSide": "RIGHT", "path": "freeipa/src/main/java/com/sequenceiq/freeipa/client/FreeIpaClientBuilder.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yM1QwNzoxODoxMVrOGKaWBw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yM1QxMjo1ODoxNVrOGKn9QQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzU3MDU2Nw==", "bodyText": "you don't have to call the close() here, try will take care of it", "url": "https://github.com/hortonworks/cloudbreak/pull/7877#discussion_r413570567", "createdAt": "2020-04-23T07:18:11Z", "author": {"login": "lacikaaa"}, "path": "freeipa/src/main/java/com/sequenceiq/freeipa/client/FreeIpaClientBuilder.java", "diffHunk": "@@ -138,7 +138,9 @@ public FreeIpaClient build(boolean withPing) throws URISyntaxException, IOExcept\n                     .build()) {\n                 URI target = getIpaUrl(clientConfig.getApiAddress(), port, basePath, \"/session/login_password\").toURI();\n                 LOGGER.debug(\"Ping at target: {}\", target);\n-                client.execute(new HttpHead(target));\n+                HttpHead request = new HttpHead(target);\n+                additionalHeaders.forEach(request::addHeader);\n+                client.execute(request).close();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "26398f7379d5a37355376f427fa7d427d1db4e22"}, "originalPosition": 7}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzc5MzYwMQ==", "bodyText": "I think both the CloseableHttpResponse and the CloseableHttpClient should be closed.\nhttps://hc.apache.org/httpcomponents-client-ga/tutorial/html/fundamentals.html shows the following:\nCloseableHttpResponse response = httpclient.execute(httpget);\ntry {\n    <...>\n} finally {\n    response.close();\n}\n\nAlso FreeIpaClientBuilder::connect() does a close on both the CloseableHttpResponse and the CloseableHttpClient.", "url": "https://github.com/hortonworks/cloudbreak/pull/7877#discussion_r413793601", "createdAt": "2020-04-23T12:58:15Z", "author": {"login": "jamisonbennett"}, "path": "freeipa/src/main/java/com/sequenceiq/freeipa/client/FreeIpaClientBuilder.java", "diffHunk": "@@ -138,7 +138,9 @@ public FreeIpaClient build(boolean withPing) throws URISyntaxException, IOExcept\n                     .build()) {\n                 URI target = getIpaUrl(clientConfig.getApiAddress(), port, basePath, \"/session/login_password\").toURI();\n                 LOGGER.debug(\"Ping at target: {}\", target);\n-                client.execute(new HttpHead(target));\n+                HttpHead request = new HttpHead(target);\n+                additionalHeaders.forEach(request::addHeader);\n+                client.execute(request).close();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzU3MDU2Nw=="}, "originalCommit": {"oid": "26398f7379d5a37355376f427fa7d427d1db4e22"}, "originalPosition": 7}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU3MDQ2ODA5OnYy", "diffSide": "RIGHT", "path": "freeipa/src/main/java/com/sequenceiq/freeipa/flow/freeipa/provision/action/FreeIpaProvisionActions.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yM1QwNzozNjoxNlrOGKbApQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yM1QxMzowNToxMVrOGKoQIA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzU4MTQ3Nw==", "bodyText": "we could use StackEvent here so both the old and new event would match", "url": "https://github.com/hortonworks/cloudbreak/pull/7877#discussion_r413581477", "createdAt": "2020-04-23T07:36:16Z", "author": {"login": "lacikaaa"}, "path": "freeipa/src/main/java/com/sequenceiq/freeipa/flow/freeipa/provision/action/FreeIpaProvisionActions.java", "diffHunk": "@@ -90,12 +92,29 @@ protected Selectable createRequest(StackContext context) {\n         };\n     }\n \n+    @Bean(name = \"CLUSTERPROXY_UPDATE_REGISTRATION_STATE\")\n+    public Action<?, ?> updateClusterProxyRegistrationAction() {\n+        return new AbstractStackProvisionAction<>(InstallFreeIpaServicesSuccess.class) {\n+            @Override\n+            protected void doExecute(StackContext context, InstallFreeIpaServicesSuccess payload, Map<Object, Object> variables) throws Exception {\n+                stackUpdater.updateStackStatus(context.getStack().getId(), DetailedStackStatus.UPDATE_CLUSTER_PROXY_REGISTRATION,\n+                        \"Updating cluster proxy registration.\");\n+                sendEvent(context);\n+            }\n+\n+            @Override\n+            protected Selectable createRequest(StackContext context) {\n+                return new ClusterProxyUpdateRegistrationRequest(context.getStack().getId());\n+            }\n+        };\n+    }\n+\n     @Bean(name = \"FREEIPA_POST_INSTALL_STATE\")\n     public Action<?, ?> postInstallFreeIpa() {\n-        return new AbstractStackProvisionAction<>(InstallFreeIpaServicesSuccess.class) {\n+        return new AbstractStackProvisionAction<>(ClusterProxyUpdateRegistrationSuccess.class) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "26398f7379d5a37355376f427fa7d427d1db4e22"}, "originalPosition": 33}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzc5ODQzMg==", "bodyText": "The StackEvent is still used during the original bootstrapping for the StackProvisionFlowConfig. The ClusterProxyUpdateRegistrationSuccess is for the new step in the FreeIpaProvisionFlowConfig. The StackProvisionFlowConfig events remain unchanged. Does. it still make sense to have a StackEvent here? If so I will make the change.", "url": "https://github.com/hortonworks/cloudbreak/pull/7877#discussion_r413798432", "createdAt": "2020-04-23T13:05:11Z", "author": {"login": "jamisonbennett"}, "path": "freeipa/src/main/java/com/sequenceiq/freeipa/flow/freeipa/provision/action/FreeIpaProvisionActions.java", "diffHunk": "@@ -90,12 +92,29 @@ protected Selectable createRequest(StackContext context) {\n         };\n     }\n \n+    @Bean(name = \"CLUSTERPROXY_UPDATE_REGISTRATION_STATE\")\n+    public Action<?, ?> updateClusterProxyRegistrationAction() {\n+        return new AbstractStackProvisionAction<>(InstallFreeIpaServicesSuccess.class) {\n+            @Override\n+            protected void doExecute(StackContext context, InstallFreeIpaServicesSuccess payload, Map<Object, Object> variables) throws Exception {\n+                stackUpdater.updateStackStatus(context.getStack().getId(), DetailedStackStatus.UPDATE_CLUSTER_PROXY_REGISTRATION,\n+                        \"Updating cluster proxy registration.\");\n+                sendEvent(context);\n+            }\n+\n+            @Override\n+            protected Selectable createRequest(StackContext context) {\n+                return new ClusterProxyUpdateRegistrationRequest(context.getStack().getId());\n+            }\n+        };\n+    }\n+\n     @Bean(name = \"FREEIPA_POST_INSTALL_STATE\")\n     public Action<?, ?> postInstallFreeIpa() {\n-        return new AbstractStackProvisionAction<>(InstallFreeIpaServicesSuccess.class) {\n+        return new AbstractStackProvisionAction<>(ClusterProxyUpdateRegistrationSuccess.class) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzU4MTQ3Nw=="}, "originalCommit": {"oid": "26398f7379d5a37355376f427fa7d427d1db4e22"}, "originalPosition": 33}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU3MDU3MDcyOnYy", "diffSide": "RIGHT", "path": "freeipa/src/main/java/com/sequenceiq/freeipa/service/freeipa/FreeIpaClientFactory.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yM1QwNzo1ODo1MVrOGKb9Nw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yM1QwNzo1ODo1MVrOGKb9Nw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzU5Njk4Mw==", "bodyText": "nit: create a comparator class for this", "url": "https://github.com/hortonworks/cloudbreak/pull/7877#discussion_r413596983", "createdAt": "2020-04-23T07:58:51Z", "author": {"login": "lacikaaa"}, "path": "freeipa/src/main/java/com/sequenceiq/freeipa/service/freeipa/FreeIpaClientFactory.java", "diffHunk": "@@ -138,38 +139,52 @@ private boolean canTryAnotherInstance(boolean lastInstance, IOException e) {\n         return !lastInstance;\n     }\n \n-    private List<InstanceMetaData> getAllInstances(Stack stack) {\n-        return stack.getInstanceGroups().stream().flatMap(instanceGroup ->\n-                instanceGroup.getInstanceMetaData().stream()).collect(Collectors.toList());\n+    private List<InstanceMetaData> getPriorityOrderedFreeIpaInstances(Stack stack) {\n+        return instanceMetaDataRepository.findNotTerminatedForStack(stack.getId()).stream()\n+                .filter(InstanceMetaData::isAvailable)\n+                .sorted((l, r) -> {\n+                    if (l.getInstanceMetadataType() == InstanceMetadataType.GATEWAY_PRIMARY) {\n+                        return -1;\n+                    }\n+                    if (r.getInstanceMetadataType() == InstanceMetadataType.GATEWAY_PRIMARY) {\n+                        return 1;\n+                    }\n+                    return Comparator.comparing(InstanceMetaData::getDiscoveryFQDN).compare(l, r);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "26398f7379d5a37355376f427fa7d427d1db4e22"}, "originalPosition": 114}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU3MDcwMjM5OnYy", "diffSide": "RIGHT", "path": "freeipa/src/main/java/com/sequenceiq/freeipa/service/freeipa/FreeIpaClientFactory.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yM1QwODoyODowOVrOGKdMWQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yM1QwODoyODowOVrOGKdMWQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzYxNzI0MQ==", "bodyText": "don't include repository anywhere else than the related service", "url": "https://github.com/hortonworks/cloudbreak/pull/7877#discussion_r413617241", "createdAt": "2020-04-23T08:28:09Z", "author": {"login": "lacikaaa"}, "path": "freeipa/src/main/java/com/sequenceiq/freeipa/service/freeipa/FreeIpaClientFactory.java", "diffHunk": "@@ -61,6 +63,9 @@\n     @Inject\n     private TlsSecurityService tlsSecurityService;\n \n+    @Inject\n+    private InstanceMetaDataRepository instanceMetaDataRepository;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "26398f7379d5a37355376f427fa7d427d1db4e22"}, "originalPosition": 30}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU3MDc3MjYzOnYy", "diffSide": "RIGHT", "path": "freeipa/src/main/java/com/sequenceiq/freeipa/service/stack/ClusterProxyService.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yM1QwODo0Mjo0NVrOGKd2AQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yM1QwODo0Mjo0NVrOGKd2AQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzYyNzkwNQ==", "bodyText": "don't use repository here", "url": "https://github.com/hortonworks/cloudbreak/pull/7877#discussion_r413627905", "createdAt": "2020-04-23T08:42:45Z", "author": {"login": "lacikaaa"}, "path": "freeipa/src/main/java/com/sequenceiq/freeipa/service/stack/ClusterProxyService.java", "diffHunk": "@@ -70,15 +74,25 @@\n     @Inject\n     private SecurityConfigService securityConfigService;\n \n+    @Inject\n+    private InstanceMetaDataRepository instanceMetaDataRepository;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "26398f7379d5a37355376f427fa7d427d1db4e22"}, "originalPosition": 44}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU3MDgyNzg2OnYy", "diffSide": "RIGHT", "path": "freeipa/src/main/java/com/sequenceiq/freeipa/service/stack/ClusterProxyService.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yM1QwODo1NDoyN1rOGKeXAw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yM1QxMzo0NzoxNFrOGKo5tQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzYzNjM1NQ==", "bodyText": "is it ok to add this ServiceConfig on bootstrap and again when we are adding the other ones? It looks like to me we double add it, and I don't know if it cause any issue on CP side", "url": "https://github.com/hortonworks/cloudbreak/pull/7877#discussion_r413636355", "createdAt": "2020-04-23T08:54:27Z", "author": {"login": "lacikaaa"}, "path": "freeipa/src/main/java/com/sequenceiq/freeipa/service/stack/ClusterProxyService.java", "diffHunk": "@@ -88,17 +102,27 @@\n         LOGGER.debug(\"Registering freeipa with cluster-proxy: Environment CRN = [{}], Stack CRN = [{}]\", stack.getEnvironmentCrn(), stack.getResourceCrn());\n \n         GatewayConfig primaryGatewayConfig = gatewayConfigService.getPrimaryGatewayConfig(stack);\n-        HttpClientConfig httpClientConfig = tlsSecurityService.buildTLSClientConfigForPrimaryGateway(\n-                stack, primaryGatewayConfig.getGatewayUrl());\n+        List<GatewayConfig> gatewayConfigs = gatewayConfigService.getNotTerminatedGatewayConfigs(stack);\n         ClientCertificate clientCertificate = clientCertificates(stack);\n \n-        ClusterServiceConfig serviceConfig = createServiceConfig(stack, httpClientConfig, clientCertificate);\n+        boolean usePrivateIpToTls = stack.getSecurityConfig().isUsePrivateIpToTls();\n+        List<GatewayConfig> tunnelGatewayConfigs;\n+        List<ClusterServiceConfig> serviceConfigs = new LinkedList<>();\n+        serviceConfigs.add(createServiceConfig(stack, FREEIPA_SERVICE_NAME, primaryGatewayConfig, clientCertificate, usePrivateIpToTls));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "26398f7379d5a37355376f427fa7d427d1db4e22"}, "originalPosition": 82}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzgwOTA3Nw==", "bodyText": "Yes, I confirmed this with the cluster proxy team. The registration is a \"force\" registration and it overwrites the old config.", "url": "https://github.com/hortonworks/cloudbreak/pull/7877#discussion_r413809077", "createdAt": "2020-04-23T13:47:14Z", "author": {"login": "jamisonbennett"}, "path": "freeipa/src/main/java/com/sequenceiq/freeipa/service/stack/ClusterProxyService.java", "diffHunk": "@@ -88,17 +102,27 @@\n         LOGGER.debug(\"Registering freeipa with cluster-proxy: Environment CRN = [{}], Stack CRN = [{}]\", stack.getEnvironmentCrn(), stack.getResourceCrn());\n \n         GatewayConfig primaryGatewayConfig = gatewayConfigService.getPrimaryGatewayConfig(stack);\n-        HttpClientConfig httpClientConfig = tlsSecurityService.buildTLSClientConfigForPrimaryGateway(\n-                stack, primaryGatewayConfig.getGatewayUrl());\n+        List<GatewayConfig> gatewayConfigs = gatewayConfigService.getNotTerminatedGatewayConfigs(stack);\n         ClientCertificate clientCertificate = clientCertificates(stack);\n \n-        ClusterServiceConfig serviceConfig = createServiceConfig(stack, httpClientConfig, clientCertificate);\n+        boolean usePrivateIpToTls = stack.getSecurityConfig().isUsePrivateIpToTls();\n+        List<GatewayConfig> tunnelGatewayConfigs;\n+        List<ClusterServiceConfig> serviceConfigs = new LinkedList<>();\n+        serviceConfigs.add(createServiceConfig(stack, FREEIPA_SERVICE_NAME, primaryGatewayConfig, clientCertificate, usePrivateIpToTls));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzYzNjM1NQ=="}, "originalCommit": {"oid": "26398f7379d5a37355376f427fa7d427d1db4e22"}, "originalPosition": 82}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU3MDg4ODM5OnYy", "diffSide": "RIGHT", "path": "freeipa/src/main/java/com/sequenceiq/freeipa/service/stack/ClusterProxyService.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yM1QwOTowNzoxMlrOGKe6lg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yM1QxNjoxMToxM1rOGKwVJQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzY0NTQ2Mg==", "bodyText": "protocol should come from GatewayConfig as it is used when we are building apiAddress", "url": "https://github.com/hortonworks/cloudbreak/pull/7877#discussion_r413645462", "createdAt": "2020-04-23T09:07:12Z", "author": {"login": "lacikaaa"}, "path": "freeipa/src/main/java/com/sequenceiq/freeipa/service/stack/ClusterProxyService.java", "diffHunk": "@@ -183,4 +227,12 @@ private ClientCertificate clientCertificates(Stack stack) {\n         return clientCertificate;\n     }\n \n+    private String getEndpointForRegistration(Stack stack, GatewayConfig gatewayConfig, boolean usePrivateIpToTls) {\n+        String ipAddresss = gatewayConfig.getPublicAddress();\n+        if (usePrivateIpToTls) {\n+            ipAddresss = gatewayConfig.getPrivateAddress();\n+        }\n+        return String.format(\"https://%s:%d\", ipAddresss, stack.getGatewayport());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "26398f7379d5a37355376f427fa7d427d1db4e22"}, "originalPosition": 168}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzkzMDc4OQ==", "bodyText": "The gateway config is updated to use the protocol of cluster proxy. This needs to be the NGINX endpoint protocol not the protocol of cluster proxy. When registering an endpoint in cluster proxy the needs to be the final NGINX endpoint. I will rename the method to make this a little more clear.", "url": "https://github.com/hortonworks/cloudbreak/pull/7877#discussion_r413930789", "createdAt": "2020-04-23T16:11:13Z", "author": {"login": "jamisonbennett"}, "path": "freeipa/src/main/java/com/sequenceiq/freeipa/service/stack/ClusterProxyService.java", "diffHunk": "@@ -183,4 +227,12 @@ private ClientCertificate clientCertificates(Stack stack) {\n         return clientCertificate;\n     }\n \n+    private String getEndpointForRegistration(Stack stack, GatewayConfig gatewayConfig, boolean usePrivateIpToTls) {\n+        String ipAddresss = gatewayConfig.getPublicAddress();\n+        if (usePrivateIpToTls) {\n+            ipAddresss = gatewayConfig.getPrivateAddress();\n+        }\n+        return String.format(\"https://%s:%d\", ipAddresss, stack.getGatewayport());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzY0NTQ2Mg=="}, "originalCommit": {"oid": "26398f7379d5a37355376f427fa7d427d1db4e22"}, "originalPosition": 168}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU3MDkzODU3OnYy", "diffSide": "RIGHT", "path": "freeipa/src/main/java/com/sequenceiq/freeipa/sync/FreeipaChecker.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yM1QwOToxODozNFrOGKfZhA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yM1QxNjo0OTowMlrOGKyDrg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzY1MzM4MA==", "bodyText": "is this still a valid option? can we receive such exceptions?", "url": "https://github.com/hortonworks/cloudbreak/pull/7877#discussion_r413653380", "createdAt": "2020-04-23T09:18:34Z", "author": {"login": "lacikaaa"}, "path": "freeipa/src/main/java/com/sequenceiq/freeipa/sync/FreeipaChecker.java", "diffHunk": "@@ -31,28 +34,38 @@\n     @Inject\n     private FreeIpaClientFactory freeIpaClientFactory;\n \n-    private RPCResponse<Boolean> checkStatus(Stack stack, Set<InstanceMetaData> checkableInstances) throws Exception {\n+    @Inject\n+    private InstanceMetaDataService instanceMetaDataService;\n+\n+    private List<RPCResponse<Boolean>> checkStatus(Stack stack, Set<InstanceMetaData> checkableInstances) throws Exception {\n         return checkedMeasure(() -> {\n-            FreeIpaClient freeIpaClient = checkedMeasure(() -> freeIpaClientFactory.getFreeIpaClientForStackWithPing(stack), LOGGER,\n-                    \":::Auto sync::: freeipa client is created in {}ms\");\n-            String hostname = getPrimaryHostname(checkableInstances);\n-            return checkedMeasure(() -> freeIpaClient.serverConnCheck(freeIpaClient.getHostname(), hostname), LOGGER,\n-                    \":::Auto sync::: freeipa server_conncheck ran in {}ms\");\n+            List<RPCResponse<Boolean>> statuses = new LinkedList<>();\n+            for (InstanceMetaData instanceMetaData : checkableInstances) {\n+                String hostname = instanceMetaData.getDiscoveryFQDN();\n+                FreeIpaClient freeIpaClient = checkedMeasure(() ->\n+                                freeIpaClientFactory.getFreeIpaClientForStackWithPing(stack, hostname), LOGGER,\n+                        \":::Auto sync::: freeipa client is created in {}ms\");\n+                statuses.add(checkedMeasure(() -> freeIpaClient.serverConnCheck(freeIpaClient.getHostname(), hostname), LOGGER,\n+                        \":::Auto sync::: freeipa server_conncheck ran in {}ms\"));\n+            }\n+            return statuses;\n         }, LOGGER, \":::Auto sync::: freeipa server status is checked in {}ms\");\n     }\n \n     public SyncResult getStatus(Stack stack, Set<InstanceMetaData> checkableInstances) {\n         try {\n-            RPCResponse<Boolean> response = checkStatus(stack, checkableInstances);\n+            Set<InstanceMetaData> notTermiatedStackInstances = instanceMetaDataService.findNotTerminatedForStack(stack.getId());\n+            List<RPCResponse<Boolean>> responses = checkStatus(stack, checkableInstances);\n             DetailedStackStatus status;\n             String postFix = \"\";\n-            if (response.getResult()) {\n+            Boolean result = !responses.isEmpty() && responses.stream().allMatch(RPCResponse::getResult);\n+            if (result && responses.size() == notTermiatedStackInstances.size()) {\n                 status = DetailedStackStatus.PROVISIONED;\n             } else {\n                 status = DetailedStackStatus.UNHEALTHY;\n                 postFix = \"Freeipa is unhealthy, \";\n             }\n-            return new SyncResult(postFix + getMessage(response), status, response.getResult());\n+            return new SyncResult(postFix + getMessages(responses), status, result);\n         } catch (HttpHostConnectException | ConnectTimeoutException e) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "26398f7379d5a37355376f427fa7d427d1db4e22"}, "originalPosition": 62}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzk1OTA4Ng==", "bodyText": "I noticed this yesterday too. You are correct, it is impossible to receive these exceptions. I am in the process of fixing this in CB-6745. I would prefer to fix this in a separate pull request since this wasn't affected by this pull request and this PR is pretty large already.", "url": "https://github.com/hortonworks/cloudbreak/pull/7877#discussion_r413959086", "createdAt": "2020-04-23T16:49:02Z", "author": {"login": "jamisonbennett"}, "path": "freeipa/src/main/java/com/sequenceiq/freeipa/sync/FreeipaChecker.java", "diffHunk": "@@ -31,28 +34,38 @@\n     @Inject\n     private FreeIpaClientFactory freeIpaClientFactory;\n \n-    private RPCResponse<Boolean> checkStatus(Stack stack, Set<InstanceMetaData> checkableInstances) throws Exception {\n+    @Inject\n+    private InstanceMetaDataService instanceMetaDataService;\n+\n+    private List<RPCResponse<Boolean>> checkStatus(Stack stack, Set<InstanceMetaData> checkableInstances) throws Exception {\n         return checkedMeasure(() -> {\n-            FreeIpaClient freeIpaClient = checkedMeasure(() -> freeIpaClientFactory.getFreeIpaClientForStackWithPing(stack), LOGGER,\n-                    \":::Auto sync::: freeipa client is created in {}ms\");\n-            String hostname = getPrimaryHostname(checkableInstances);\n-            return checkedMeasure(() -> freeIpaClient.serverConnCheck(freeIpaClient.getHostname(), hostname), LOGGER,\n-                    \":::Auto sync::: freeipa server_conncheck ran in {}ms\");\n+            List<RPCResponse<Boolean>> statuses = new LinkedList<>();\n+            for (InstanceMetaData instanceMetaData : checkableInstances) {\n+                String hostname = instanceMetaData.getDiscoveryFQDN();\n+                FreeIpaClient freeIpaClient = checkedMeasure(() ->\n+                                freeIpaClientFactory.getFreeIpaClientForStackWithPing(stack, hostname), LOGGER,\n+                        \":::Auto sync::: freeipa client is created in {}ms\");\n+                statuses.add(checkedMeasure(() -> freeIpaClient.serverConnCheck(freeIpaClient.getHostname(), hostname), LOGGER,\n+                        \":::Auto sync::: freeipa server_conncheck ran in {}ms\"));\n+            }\n+            return statuses;\n         }, LOGGER, \":::Auto sync::: freeipa server status is checked in {}ms\");\n     }\n \n     public SyncResult getStatus(Stack stack, Set<InstanceMetaData> checkableInstances) {\n         try {\n-            RPCResponse<Boolean> response = checkStatus(stack, checkableInstances);\n+            Set<InstanceMetaData> notTermiatedStackInstances = instanceMetaDataService.findNotTerminatedForStack(stack.getId());\n+            List<RPCResponse<Boolean>> responses = checkStatus(stack, checkableInstances);\n             DetailedStackStatus status;\n             String postFix = \"\";\n-            if (response.getResult()) {\n+            Boolean result = !responses.isEmpty() && responses.stream().allMatch(RPCResponse::getResult);\n+            if (result && responses.size() == notTermiatedStackInstances.size()) {\n                 status = DetailedStackStatus.PROVISIONED;\n             } else {\n                 status = DetailedStackStatus.UNHEALTHY;\n                 postFix = \"Freeipa is unhealthy, \";\n             }\n-            return new SyncResult(postFix + getMessage(response), status, response.getResult());\n+            return new SyncResult(postFix + getMessages(responses), status, result);\n         } catch (HttpHostConnectException | ConnectTimeoutException e) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzY1MzM4MA=="}, "originalCommit": {"oid": "26398f7379d5a37355376f427fa7d427d1db4e22"}, "originalPosition": 62}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2488, "cost": 1, "resetAt": "2021-11-12T20:44:06Z"}}}