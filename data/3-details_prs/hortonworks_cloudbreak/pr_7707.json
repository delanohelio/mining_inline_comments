{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzk3MDE5NzEw", "number": 7707, "title": "CB-6188: upgrade reason message", "bodyText": "", "createdAt": "2020-04-01T14:08:27Z", "url": "https://github.com/hortonworks/cloudbreak/pull/7707", "merged": true, "mergeCommit": {"oid": "74d73a46e6c9dee78b29e8028ec1474bc6ecb45f"}, "closed": true, "closedAt": "2020-04-06T08:08:46Z", "author": {"login": "tiborpopovics"}, "timelineItems": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcTYVDxABqjMxODgxMDI0MTM=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcT91TAAFqTM4NzExNDI0OA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "4278ca4ab62d91d47777688598e52622604ed8d5", "author": {"user": null}, "url": "https://github.com/hortonworks/cloudbreak/commit/4278ca4ab62d91d47777688598e52622604ed8d5", "committedDate": "2020-04-01T13:09:51Z", "message": "CB-6188: upgrade reason message"}, "afterCommit": {"oid": "17162f24600d530de95659591965edaa2efdfa0e", "author": {"user": null}, "url": "https://github.com/hortonworks/cloudbreak/commit/17162f24600d530de95659591965edaa2efdfa0e", "committedDate": "2020-04-01T14:11:05Z", "message": "CB-6188: upgrade reason message"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg2NTM0MDY3", "url": "https://github.com/hortonworks/cloudbreak/pull/7707#pullrequestreview-386534067", "createdAt": "2020-04-02T15:20:56Z", "commit": {"oid": "17162f24600d530de95659591965edaa2efdfa0e"}, "state": "COMMENTED", "comments": {"totalCount": 9, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMlQxNToyMDo1NlrOF_wdqg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMlQxNTozMzoyNlrOF_xCyA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjM5ODYzNA==", "bodyText": "Wouldn't it be better to aggregate all the validation errors here?", "url": "https://github.com/hortonworks/cloudbreak/pull/7707#discussion_r402398634", "createdAt": "2020-04-02T15:20:56Z", "author": {"login": "pdarvasi"}, "path": "core/src/main/java/com/sequenceiq/cloudbreak/service/upgrade/ClusterUpgradeImageFilter.java", "diffHunk": "@@ -52,71 +46,86 @@ Images filter(List<Image> availableImages, Versions supportedVersions, Image cur\n         return versionBasedImageFilter.getCdhImagesForCbVersion(supportedVersions, availableImages);\n     }\n \n-    private List<Image> filterImages(List<Image> availableImages, Image currentImage, String cloudPlatform) {\n-        // I think the whole logic is broken, since we don't allow an upgrade if we shipped a new parcel extension...\n-        return availableImages.stream()\n+    private ImageFilterResult filterImages(List<Image> availableImages, Image currentImage, String cloudPlatform) {\n+        List<Image> images = availableImages.stream()\n+                .filter(filterCurrentImage(currentImage))\n                 .filter(ignoredCmVersion())\n-                .filter(validateCmVersion(currentImage).or(validateStackVersion(currentImage)))\n+                .filter(validateCmAndStackVersion(currentImage))\n                 .filter(validateCloudPlatform(cloudPlatform))\n                 .filter(validateOsVersion(currentImage))\n-                // We don't necessary need CFM and CSP since only SDX upgrade is supported\n-                //.filter(validateCfmVersion(currentImage))\n-                //.filter(validateCspVersion(currentImage))\n                 .filter(validateSaltVersion(currentImage))\n-                .filter(filterCurrentImage(currentImage))\n                 .collect(Collectors.toList());\n-    }\n \n-    private Predicate<Image> validateOsVersion(Image currentImage) {\n-        return image -> isOsVersionsMatch(currentImage, image);\n+        return new ImageFilterResult(new Images(null, null, null, images, null), getReason(images));\n     }\n \n-    private boolean isOsVersionsMatch(Image currentImage, Image newImage) {\n-        return newImage.getOs().equalsIgnoreCase(currentImage.getOs())\n-                && newImage.getOsType().equalsIgnoreCase(currentImage.getOsType());\n+    private Predicate<Image> filterCurrentImage(Image currentImage) {\n+        return image -> {\n+            boolean result = !image.getUuid().equals(currentImage.getUuid());\n+            setReason(result, \"No other image is available.\");\n+            return result;\n+        };\n     }\n \n     private Predicate<Image> ignoredCmVersion() {\n-        // There are some legacy CM versions that do not follow a proper versioning scheme, we must ignore them\n-        return image -> image.getPackageVersions().get(CM_PACKAGE_KEY) != null &&\n-                !image.getPackageVersions().get(CM_PACKAGE_KEY).contains(IGNORED_CM_VERSION);\n+        return image -> {\n+            boolean result = image.getPackageVersions().get(CM_PACKAGE_KEY) != null\n+                    && !image.getPackageVersions().get(CM_PACKAGE_KEY).contains(IGNORED_CM_VERSION);\n+            setReason(result, \"There are no supported Cloudera Manager or CDP version.\");\n+            return result;\n+        };\n     }\n \n-    private Predicate<Image> validateCmVersion(Image currentImage) {\n-        return image -> permitCmAndSatckUpgrade(currentImage, image, CM_PACKAGE_KEY);\n+    private Predicate<Image> validateCmAndStackVersion(Image currentImage) {\n+        return image -> {\n+            boolean result = permitCmAndSatckUpgrade(currentImage, image, CM_PACKAGE_KEY) || permitCmAndSatckUpgrade(currentImage, image, STACK_PACKAGE_KEY);\n+            setReason(result, \"There are no proper Cloudera Manager or CDP version to upgrade.\");\n+            return result;\n+        };\n     }\n \n-    private Predicate<Image> validateStackVersion(Image currentImage) {\n-        return image -> permitCmAndSatckUpgrade(currentImage, image, STACK_PACKAGE_KEY);\n+    private boolean permitCmAndSatckUpgrade(Image currentImage, Image image, String key) {\n+        return upgradePermissionProvider.permitCmAndSatckUpgrade(currentImage.getPackageVersions().get(STACK_PACKAGE_KEY),\n+                image.getPackageVersions().get(key));\n     }\n \n     private Predicate<Image> validateCloudPlatform(String cloudPlatform) {\n-        return image -> image.getImageSetsByProvider().keySet().stream().anyMatch(key -> key.equalsIgnoreCase(cloudPlatform));\n+        return image -> {\n+            boolean result = image.getImageSetsByProvider().keySet().stream().anyMatch(key -> key.equalsIgnoreCase(cloudPlatform));\n+            if (!result) {\n+                reason = String.format(\"There are no image available for %s cloud platform.\", cloudPlatform);\n+            }\n+            return result;\n+        };\n     }\n \n-    private Predicate<Image> validateCfmVersion(Image currentImage) {\n-        return image -> permitExtensionUpgrade(currentImage, image, CFM_PACKAGE_KEY);\n-    }\n-\n-    private Predicate<Image> validateCspVersion(Image currentImage) {\n-        return image -> permitExtensionUpgrade(currentImage, image, CSP_PACKAGE_KEY);\n+    private Predicate<Image> validateOsVersion(Image currentImage) {\n+        return image -> {\n+            boolean result = isOsVersionsMatch(currentImage, image);\n+            setReason(result, \"There are no other image with the same OS version.\");\n+            return result;\n+        };\n     }\n \n-    private boolean permitCmAndSatckUpgrade(Image currentImage, Image image, String key) {\n-        return upgradePermissionProvider.permitCmAndSatckUpgrade(currentImage.getPackageVersions().get(STACK_PACKAGE_KEY),\n-                image.getPackageVersions().get(key));\n+    private boolean isOsVersionsMatch(Image currentImage, Image newImage) {\n+        return newImage.getOs().equalsIgnoreCase(currentImage.getOs()) && newImage.getOsType().equalsIgnoreCase(currentImage.getOsType());\n     }\n \n-    private boolean permitExtensionUpgrade(Image currentImage, Image image, String key) {\n-        return upgradePermissionProvider.permitExtensionUpgrade(currentImage.getPackageVersions().get(STACK_PACKAGE_KEY),\n-                image.getPackageVersions().get(key));\n+    private Predicate<Image> validateSaltVersion(Image currentImage) {\n+        return image -> {\n+            boolean result = image.getPackageVersions().get(SALT_PACKAGE_KEY).equals(currentImage.getPackageVersions().get(SALT_PACKAGE_KEY));\n+            setReason(result, \"There are no other image with the same salt version.\");\n+            return result;\n+        };\n     }\n \n-    private Predicate<Image> validateSaltVersion(Image currentImage) {\n-        return image -> image.getPackageVersions().get(SALT_PACKAGE_KEY).equals(currentImage.getPackageVersions().get(SALT_PACKAGE_KEY));\n+    private String getReason(List<Image> images) {\n+        return images.isEmpty() ? reason : null;\n     }\n \n-    private Predicate<Image> filterCurrentImage(Image currentImage) {\n-        return image -> !image.getUuid().equals(currentImage.getUuid());\n+    private void setReason(boolean result, String reasonText) {\n+        if (!result) {\n+            reason = reasonText;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "17162f24600d530de95659591965edaa2efdfa0e"}, "originalPosition": 146}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjM5OTIzOA==", "bodyText": "Typo: images", "url": "https://github.com/hortonworks/cloudbreak/pull/7707#discussion_r402399238", "createdAt": "2020-04-02T15:21:46Z", "author": {"login": "pdarvasi"}, "path": "core/src/main/java/com/sequenceiq/cloudbreak/service/upgrade/ClusterUpgradeImageFilter.java", "diffHunk": "@@ -52,71 +46,86 @@ Images filter(List<Image> availableImages, Versions supportedVersions, Image cur\n         return versionBasedImageFilter.getCdhImagesForCbVersion(supportedVersions, availableImages);\n     }\n \n-    private List<Image> filterImages(List<Image> availableImages, Image currentImage, String cloudPlatform) {\n-        // I think the whole logic is broken, since we don't allow an upgrade if we shipped a new parcel extension...\n-        return availableImages.stream()\n+    private ImageFilterResult filterImages(List<Image> availableImages, Image currentImage, String cloudPlatform) {\n+        List<Image> images = availableImages.stream()\n+                .filter(filterCurrentImage(currentImage))\n                 .filter(ignoredCmVersion())\n-                .filter(validateCmVersion(currentImage).or(validateStackVersion(currentImage)))\n+                .filter(validateCmAndStackVersion(currentImage))\n                 .filter(validateCloudPlatform(cloudPlatform))\n                 .filter(validateOsVersion(currentImage))\n-                // We don't necessary need CFM and CSP since only SDX upgrade is supported\n-                //.filter(validateCfmVersion(currentImage))\n-                //.filter(validateCspVersion(currentImage))\n                 .filter(validateSaltVersion(currentImage))\n-                .filter(filterCurrentImage(currentImage))\n                 .collect(Collectors.toList());\n-    }\n \n-    private Predicate<Image> validateOsVersion(Image currentImage) {\n-        return image -> isOsVersionsMatch(currentImage, image);\n+        return new ImageFilterResult(new Images(null, null, null, images, null), getReason(images));\n     }\n \n-    private boolean isOsVersionsMatch(Image currentImage, Image newImage) {\n-        return newImage.getOs().equalsIgnoreCase(currentImage.getOs())\n-                && newImage.getOsType().equalsIgnoreCase(currentImage.getOsType());\n+    private Predicate<Image> filterCurrentImage(Image currentImage) {\n+        return image -> {\n+            boolean result = !image.getUuid().equals(currentImage.getUuid());\n+            setReason(result, \"No other image is available.\");\n+            return result;\n+        };\n     }\n \n     private Predicate<Image> ignoredCmVersion() {\n-        // There are some legacy CM versions that do not follow a proper versioning scheme, we must ignore them\n-        return image -> image.getPackageVersions().get(CM_PACKAGE_KEY) != null &&\n-                !image.getPackageVersions().get(CM_PACKAGE_KEY).contains(IGNORED_CM_VERSION);\n+        return image -> {\n+            boolean result = image.getPackageVersions().get(CM_PACKAGE_KEY) != null\n+                    && !image.getPackageVersions().get(CM_PACKAGE_KEY).contains(IGNORED_CM_VERSION);\n+            setReason(result, \"There are no supported Cloudera Manager or CDP version.\");\n+            return result;\n+        };\n     }\n \n-    private Predicate<Image> validateCmVersion(Image currentImage) {\n-        return image -> permitCmAndSatckUpgrade(currentImage, image, CM_PACKAGE_KEY);\n+    private Predicate<Image> validateCmAndStackVersion(Image currentImage) {\n+        return image -> {\n+            boolean result = permitCmAndSatckUpgrade(currentImage, image, CM_PACKAGE_KEY) || permitCmAndSatckUpgrade(currentImage, image, STACK_PACKAGE_KEY);\n+            setReason(result, \"There are no proper Cloudera Manager or CDP version to upgrade.\");\n+            return result;\n+        };\n     }\n \n-    private Predicate<Image> validateStackVersion(Image currentImage) {\n-        return image -> permitCmAndSatckUpgrade(currentImage, image, STACK_PACKAGE_KEY);\n+    private boolean permitCmAndSatckUpgrade(Image currentImage, Image image, String key) {\n+        return upgradePermissionProvider.permitCmAndSatckUpgrade(currentImage.getPackageVersions().get(STACK_PACKAGE_KEY),\n+                image.getPackageVersions().get(key));\n     }\n \n     private Predicate<Image> validateCloudPlatform(String cloudPlatform) {\n-        return image -> image.getImageSetsByProvider().keySet().stream().anyMatch(key -> key.equalsIgnoreCase(cloudPlatform));\n+        return image -> {\n+            boolean result = image.getImageSetsByProvider().keySet().stream().anyMatch(key -> key.equalsIgnoreCase(cloudPlatform));\n+            if (!result) {\n+                reason = String.format(\"There are no image available for %s cloud platform.\", cloudPlatform);\n+            }\n+            return result;\n+        };\n     }\n \n-    private Predicate<Image> validateCfmVersion(Image currentImage) {\n-        return image -> permitExtensionUpgrade(currentImage, image, CFM_PACKAGE_KEY);\n-    }\n-\n-    private Predicate<Image> validateCspVersion(Image currentImage) {\n-        return image -> permitExtensionUpgrade(currentImage, image, CSP_PACKAGE_KEY);\n+    private Predicate<Image> validateOsVersion(Image currentImage) {\n+        return image -> {\n+            boolean result = isOsVersionsMatch(currentImage, image);\n+            setReason(result, \"There are no other image with the same OS version.\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "17162f24600d530de95659591965edaa2efdfa0e"}, "originalPosition": 113}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjM5OTY5Mw==", "bodyText": "Typo: images", "url": "https://github.com/hortonworks/cloudbreak/pull/7707#discussion_r402399693", "createdAt": "2020-04-02T15:22:24Z", "author": {"login": "pdarvasi"}, "path": "core/src/main/java/com/sequenceiq/cloudbreak/service/upgrade/ClusterUpgradeImageFilter.java", "diffHunk": "@@ -52,71 +46,86 @@ Images filter(List<Image> availableImages, Versions supportedVersions, Image cur\n         return versionBasedImageFilter.getCdhImagesForCbVersion(supportedVersions, availableImages);\n     }\n \n-    private List<Image> filterImages(List<Image> availableImages, Image currentImage, String cloudPlatform) {\n-        // I think the whole logic is broken, since we don't allow an upgrade if we shipped a new parcel extension...\n-        return availableImages.stream()\n+    private ImageFilterResult filterImages(List<Image> availableImages, Image currentImage, String cloudPlatform) {\n+        List<Image> images = availableImages.stream()\n+                .filter(filterCurrentImage(currentImage))\n                 .filter(ignoredCmVersion())\n-                .filter(validateCmVersion(currentImage).or(validateStackVersion(currentImage)))\n+                .filter(validateCmAndStackVersion(currentImage))\n                 .filter(validateCloudPlatform(cloudPlatform))\n                 .filter(validateOsVersion(currentImage))\n-                // We don't necessary need CFM and CSP since only SDX upgrade is supported\n-                //.filter(validateCfmVersion(currentImage))\n-                //.filter(validateCspVersion(currentImage))\n                 .filter(validateSaltVersion(currentImage))\n-                .filter(filterCurrentImage(currentImage))\n                 .collect(Collectors.toList());\n-    }\n \n-    private Predicate<Image> validateOsVersion(Image currentImage) {\n-        return image -> isOsVersionsMatch(currentImage, image);\n+        return new ImageFilterResult(new Images(null, null, null, images, null), getReason(images));\n     }\n \n-    private boolean isOsVersionsMatch(Image currentImage, Image newImage) {\n-        return newImage.getOs().equalsIgnoreCase(currentImage.getOs())\n-                && newImage.getOsType().equalsIgnoreCase(currentImage.getOsType());\n+    private Predicate<Image> filterCurrentImage(Image currentImage) {\n+        return image -> {\n+            boolean result = !image.getUuid().equals(currentImage.getUuid());\n+            setReason(result, \"No other image is available.\");\n+            return result;\n+        };\n     }\n \n     private Predicate<Image> ignoredCmVersion() {\n-        // There are some legacy CM versions that do not follow a proper versioning scheme, we must ignore them\n-        return image -> image.getPackageVersions().get(CM_PACKAGE_KEY) != null &&\n-                !image.getPackageVersions().get(CM_PACKAGE_KEY).contains(IGNORED_CM_VERSION);\n+        return image -> {\n+            boolean result = image.getPackageVersions().get(CM_PACKAGE_KEY) != null\n+                    && !image.getPackageVersions().get(CM_PACKAGE_KEY).contains(IGNORED_CM_VERSION);\n+            setReason(result, \"There are no supported Cloudera Manager or CDP version.\");\n+            return result;\n+        };\n     }\n \n-    private Predicate<Image> validateCmVersion(Image currentImage) {\n-        return image -> permitCmAndSatckUpgrade(currentImage, image, CM_PACKAGE_KEY);\n+    private Predicate<Image> validateCmAndStackVersion(Image currentImage) {\n+        return image -> {\n+            boolean result = permitCmAndSatckUpgrade(currentImage, image, CM_PACKAGE_KEY) || permitCmAndSatckUpgrade(currentImage, image, STACK_PACKAGE_KEY);\n+            setReason(result, \"There are no proper Cloudera Manager or CDP version to upgrade.\");\n+            return result;\n+        };\n     }\n \n-    private Predicate<Image> validateStackVersion(Image currentImage) {\n-        return image -> permitCmAndSatckUpgrade(currentImage, image, STACK_PACKAGE_KEY);\n+    private boolean permitCmAndSatckUpgrade(Image currentImage, Image image, String key) {\n+        return upgradePermissionProvider.permitCmAndSatckUpgrade(currentImage.getPackageVersions().get(STACK_PACKAGE_KEY),\n+                image.getPackageVersions().get(key));\n     }\n \n     private Predicate<Image> validateCloudPlatform(String cloudPlatform) {\n-        return image -> image.getImageSetsByProvider().keySet().stream().anyMatch(key -> key.equalsIgnoreCase(cloudPlatform));\n+        return image -> {\n+            boolean result = image.getImageSetsByProvider().keySet().stream().anyMatch(key -> key.equalsIgnoreCase(cloudPlatform));\n+            if (!result) {\n+                reason = String.format(\"There are no image available for %s cloud platform.\", cloudPlatform);\n+            }\n+            return result;\n+        };\n     }\n \n-    private Predicate<Image> validateCfmVersion(Image currentImage) {\n-        return image -> permitExtensionUpgrade(currentImage, image, CFM_PACKAGE_KEY);\n-    }\n-\n-    private Predicate<Image> validateCspVersion(Image currentImage) {\n-        return image -> permitExtensionUpgrade(currentImage, image, CSP_PACKAGE_KEY);\n+    private Predicate<Image> validateOsVersion(Image currentImage) {\n+        return image -> {\n+            boolean result = isOsVersionsMatch(currentImage, image);\n+            setReason(result, \"There are no other image with the same OS version.\");\n+            return result;\n+        };\n     }\n \n-    private boolean permitCmAndSatckUpgrade(Image currentImage, Image image, String key) {\n-        return upgradePermissionProvider.permitCmAndSatckUpgrade(currentImage.getPackageVersions().get(STACK_PACKAGE_KEY),\n-                image.getPackageVersions().get(key));\n+    private boolean isOsVersionsMatch(Image currentImage, Image newImage) {\n+        return newImage.getOs().equalsIgnoreCase(currentImage.getOs()) && newImage.getOsType().equalsIgnoreCase(currentImage.getOsType());\n     }\n \n-    private boolean permitExtensionUpgrade(Image currentImage, Image image, String key) {\n-        return upgradePermissionProvider.permitExtensionUpgrade(currentImage.getPackageVersions().get(STACK_PACKAGE_KEY),\n-                image.getPackageVersions().get(key));\n+    private Predicate<Image> validateSaltVersion(Image currentImage) {\n+        return image -> {\n+            boolean result = image.getPackageVersions().get(SALT_PACKAGE_KEY).equals(currentImage.getPackageVersions().get(SALT_PACKAGE_KEY));\n+            setReason(result, \"There are no other image with the same salt version.\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "17162f24600d530de95659591965edaa2efdfa0e"}, "originalPosition": 131}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjQwMDY4MQ==", "bodyText": "This message can be a little misleading, maybe there is other image but the input image id was incorrect?", "url": "https://github.com/hortonworks/cloudbreak/pull/7707#discussion_r402400681", "createdAt": "2020-04-02T15:23:41Z", "author": {"login": "pdarvasi"}, "path": "core/src/main/java/com/sequenceiq/cloudbreak/service/upgrade/ClusterUpgradeImageFilter.java", "diffHunk": "@@ -52,71 +46,86 @@ Images filter(List<Image> availableImages, Versions supportedVersions, Image cur\n         return versionBasedImageFilter.getCdhImagesForCbVersion(supportedVersions, availableImages);\n     }\n \n-    private List<Image> filterImages(List<Image> availableImages, Image currentImage, String cloudPlatform) {\n-        // I think the whole logic is broken, since we don't allow an upgrade if we shipped a new parcel extension...\n-        return availableImages.stream()\n+    private ImageFilterResult filterImages(List<Image> availableImages, Image currentImage, String cloudPlatform) {\n+        List<Image> images = availableImages.stream()\n+                .filter(filterCurrentImage(currentImage))\n                 .filter(ignoredCmVersion())\n-                .filter(validateCmVersion(currentImage).or(validateStackVersion(currentImage)))\n+                .filter(validateCmAndStackVersion(currentImage))\n                 .filter(validateCloudPlatform(cloudPlatform))\n                 .filter(validateOsVersion(currentImage))\n-                // We don't necessary need CFM and CSP since only SDX upgrade is supported\n-                //.filter(validateCfmVersion(currentImage))\n-                //.filter(validateCspVersion(currentImage))\n                 .filter(validateSaltVersion(currentImage))\n-                .filter(filterCurrentImage(currentImage))\n                 .collect(Collectors.toList());\n-    }\n \n-    private Predicate<Image> validateOsVersion(Image currentImage) {\n-        return image -> isOsVersionsMatch(currentImage, image);\n+        return new ImageFilterResult(new Images(null, null, null, images, null), getReason(images));\n     }\n \n-    private boolean isOsVersionsMatch(Image currentImage, Image newImage) {\n-        return newImage.getOs().equalsIgnoreCase(currentImage.getOs())\n-                && newImage.getOsType().equalsIgnoreCase(currentImage.getOsType());\n+    private Predicate<Image> filterCurrentImage(Image currentImage) {\n+        return image -> {\n+            boolean result = !image.getUuid().equals(currentImage.getUuid());\n+            setReason(result, \"No other image is available.\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "17162f24600d530de95659591965edaa2efdfa0e"}, "originalPosition": 59}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjQwMjYzMw==", "bodyText": "Pls expand image.getPackageVersions().get(CM_PACKAGE_KEY) as a variable and add it to that reason also", "url": "https://github.com/hortonworks/cloudbreak/pull/7707#discussion_r402402633", "createdAt": "2020-04-02T15:26:05Z", "author": {"login": "pdarvasi"}, "path": "core/src/main/java/com/sequenceiq/cloudbreak/service/upgrade/ClusterUpgradeImageFilter.java", "diffHunk": "@@ -52,71 +46,86 @@ Images filter(List<Image> availableImages, Versions supportedVersions, Image cur\n         return versionBasedImageFilter.getCdhImagesForCbVersion(supportedVersions, availableImages);\n     }\n \n-    private List<Image> filterImages(List<Image> availableImages, Image currentImage, String cloudPlatform) {\n-        // I think the whole logic is broken, since we don't allow an upgrade if we shipped a new parcel extension...\n-        return availableImages.stream()\n+    private ImageFilterResult filterImages(List<Image> availableImages, Image currentImage, String cloudPlatform) {\n+        List<Image> images = availableImages.stream()\n+                .filter(filterCurrentImage(currentImage))\n                 .filter(ignoredCmVersion())\n-                .filter(validateCmVersion(currentImage).or(validateStackVersion(currentImage)))\n+                .filter(validateCmAndStackVersion(currentImage))\n                 .filter(validateCloudPlatform(cloudPlatform))\n                 .filter(validateOsVersion(currentImage))\n-                // We don't necessary need CFM and CSP since only SDX upgrade is supported\n-                //.filter(validateCfmVersion(currentImage))\n-                //.filter(validateCspVersion(currentImage))\n                 .filter(validateSaltVersion(currentImage))\n-                .filter(filterCurrentImage(currentImage))\n                 .collect(Collectors.toList());\n-    }\n \n-    private Predicate<Image> validateOsVersion(Image currentImage) {\n-        return image -> isOsVersionsMatch(currentImage, image);\n+        return new ImageFilterResult(new Images(null, null, null, images, null), getReason(images));\n     }\n \n-    private boolean isOsVersionsMatch(Image currentImage, Image newImage) {\n-        return newImage.getOs().equalsIgnoreCase(currentImage.getOs())\n-                && newImage.getOsType().equalsIgnoreCase(currentImage.getOsType());\n+    private Predicate<Image> filterCurrentImage(Image currentImage) {\n+        return image -> {\n+            boolean result = !image.getUuid().equals(currentImage.getUuid());\n+            setReason(result, \"No other image is available.\");\n+            return result;\n+        };\n     }\n \n     private Predicate<Image> ignoredCmVersion() {\n-        // There are some legacy CM versions that do not follow a proper versioning scheme, we must ignore them\n-        return image -> image.getPackageVersions().get(CM_PACKAGE_KEY) != null &&\n-                !image.getPackageVersions().get(CM_PACKAGE_KEY).contains(IGNORED_CM_VERSION);\n+        return image -> {\n+            boolean result = image.getPackageVersions().get(CM_PACKAGE_KEY) != null\n+                    && !image.getPackageVersions().get(CM_PACKAGE_KEY).contains(IGNORED_CM_VERSION);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "17162f24600d530de95659591965edaa2efdfa0e"}, "originalPosition": 70}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjQwNDI2NQ==", "bodyText": "pls use StringUtils.isNotEmpty()", "url": "https://github.com/hortonworks/cloudbreak/pull/7707#discussion_r402404265", "createdAt": "2020-04-02T15:28:16Z", "author": {"login": "pdarvasi"}, "path": "core/src/main/java/com/sequenceiq/cloudbreak/service/upgrade/ClusterUpgradeImageFilter.java", "diffHunk": "@@ -52,71 +46,86 @@ Images filter(List<Image> availableImages, Versions supportedVersions, Image cur\n         return versionBasedImageFilter.getCdhImagesForCbVersion(supportedVersions, availableImages);\n     }\n \n-    private List<Image> filterImages(List<Image> availableImages, Image currentImage, String cloudPlatform) {\n-        // I think the whole logic is broken, since we don't allow an upgrade if we shipped a new parcel extension...\n-        return availableImages.stream()\n+    private ImageFilterResult filterImages(List<Image> availableImages, Image currentImage, String cloudPlatform) {\n+        List<Image> images = availableImages.stream()\n+                .filter(filterCurrentImage(currentImage))\n                 .filter(ignoredCmVersion())\n-                .filter(validateCmVersion(currentImage).or(validateStackVersion(currentImage)))\n+                .filter(validateCmAndStackVersion(currentImage))\n                 .filter(validateCloudPlatform(cloudPlatform))\n                 .filter(validateOsVersion(currentImage))\n-                // We don't necessary need CFM and CSP since only SDX upgrade is supported\n-                //.filter(validateCfmVersion(currentImage))\n-                //.filter(validateCspVersion(currentImage))\n                 .filter(validateSaltVersion(currentImage))\n-                .filter(filterCurrentImage(currentImage))\n                 .collect(Collectors.toList());\n-    }\n \n-    private Predicate<Image> validateOsVersion(Image currentImage) {\n-        return image -> isOsVersionsMatch(currentImage, image);\n+        return new ImageFilterResult(new Images(null, null, null, images, null), getReason(images));\n     }\n \n-    private boolean isOsVersionsMatch(Image currentImage, Image newImage) {\n-        return newImage.getOs().equalsIgnoreCase(currentImage.getOs())\n-                && newImage.getOsType().equalsIgnoreCase(currentImage.getOsType());\n+    private Predicate<Image> filterCurrentImage(Image currentImage) {\n+        return image -> {\n+            boolean result = !image.getUuid().equals(currentImage.getUuid());\n+            setReason(result, \"No other image is available.\");\n+            return result;\n+        };\n     }\n \n     private Predicate<Image> ignoredCmVersion() {\n-        // There are some legacy CM versions that do not follow a proper versioning scheme, we must ignore them\n-        return image -> image.getPackageVersions().get(CM_PACKAGE_KEY) != null &&\n-                !image.getPackageVersions().get(CM_PACKAGE_KEY).contains(IGNORED_CM_VERSION);\n+        return image -> {\n+            boolean result = image.getPackageVersions().get(CM_PACKAGE_KEY) != null", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "17162f24600d530de95659591965edaa2efdfa0e"}, "originalPosition": 69}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjQwNTQzNg==", "bodyText": "I would separate this 2 use-cases with 2 different setReasons(), aggregated.", "url": "https://github.com/hortonworks/cloudbreak/pull/7707#discussion_r402405436", "createdAt": "2020-04-02T15:29:43Z", "author": {"login": "pdarvasi"}, "path": "core/src/main/java/com/sequenceiq/cloudbreak/service/upgrade/ClusterUpgradeImageFilter.java", "diffHunk": "@@ -52,71 +46,86 @@ Images filter(List<Image> availableImages, Versions supportedVersions, Image cur\n         return versionBasedImageFilter.getCdhImagesForCbVersion(supportedVersions, availableImages);\n     }\n \n-    private List<Image> filterImages(List<Image> availableImages, Image currentImage, String cloudPlatform) {\n-        // I think the whole logic is broken, since we don't allow an upgrade if we shipped a new parcel extension...\n-        return availableImages.stream()\n+    private ImageFilterResult filterImages(List<Image> availableImages, Image currentImage, String cloudPlatform) {\n+        List<Image> images = availableImages.stream()\n+                .filter(filterCurrentImage(currentImage))\n                 .filter(ignoredCmVersion())\n-                .filter(validateCmVersion(currentImage).or(validateStackVersion(currentImage)))\n+                .filter(validateCmAndStackVersion(currentImage))\n                 .filter(validateCloudPlatform(cloudPlatform))\n                 .filter(validateOsVersion(currentImage))\n-                // We don't necessary need CFM and CSP since only SDX upgrade is supported\n-                //.filter(validateCfmVersion(currentImage))\n-                //.filter(validateCspVersion(currentImage))\n                 .filter(validateSaltVersion(currentImage))\n-                .filter(filterCurrentImage(currentImage))\n                 .collect(Collectors.toList());\n-    }\n \n-    private Predicate<Image> validateOsVersion(Image currentImage) {\n-        return image -> isOsVersionsMatch(currentImage, image);\n+        return new ImageFilterResult(new Images(null, null, null, images, null), getReason(images));\n     }\n \n-    private boolean isOsVersionsMatch(Image currentImage, Image newImage) {\n-        return newImage.getOs().equalsIgnoreCase(currentImage.getOs())\n-                && newImage.getOsType().equalsIgnoreCase(currentImage.getOsType());\n+    private Predicate<Image> filterCurrentImage(Image currentImage) {\n+        return image -> {\n+            boolean result = !image.getUuid().equals(currentImage.getUuid());\n+            setReason(result, \"No other image is available.\");\n+            return result;\n+        };\n     }\n \n     private Predicate<Image> ignoredCmVersion() {\n-        // There are some legacy CM versions that do not follow a proper versioning scheme, we must ignore them\n-        return image -> image.getPackageVersions().get(CM_PACKAGE_KEY) != null &&\n-                !image.getPackageVersions().get(CM_PACKAGE_KEY).contains(IGNORED_CM_VERSION);\n+        return image -> {\n+            boolean result = image.getPackageVersions().get(CM_PACKAGE_KEY) != null\n+                    && !image.getPackageVersions().get(CM_PACKAGE_KEY).contains(IGNORED_CM_VERSION);\n+            setReason(result, \"There are no supported Cloudera Manager or CDP version.\");\n+            return result;\n+        };\n     }\n \n-    private Predicate<Image> validateCmVersion(Image currentImage) {\n-        return image -> permitCmAndSatckUpgrade(currentImage, image, CM_PACKAGE_KEY);\n+    private Predicate<Image> validateCmAndStackVersion(Image currentImage) {\n+        return image -> {\n+            boolean result = permitCmAndSatckUpgrade(currentImage, image, CM_PACKAGE_KEY) || permitCmAndSatckUpgrade(currentImage, image, STACK_PACKAGE_KEY);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "17162f24600d530de95659591965edaa2efdfa0e"}, "originalPosition": 80}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjQwNTg2NQ==", "bodyText": "Typo: are --> is", "url": "https://github.com/hortonworks/cloudbreak/pull/7707#discussion_r402405865", "createdAt": "2020-04-02T15:30:12Z", "author": {"login": "pdarvasi"}, "path": "core/src/main/java/com/sequenceiq/cloudbreak/service/upgrade/ClusterUpgradeImageFilter.java", "diffHunk": "@@ -52,71 +46,86 @@ Images filter(List<Image> availableImages, Versions supportedVersions, Image cur\n         return versionBasedImageFilter.getCdhImagesForCbVersion(supportedVersions, availableImages);\n     }\n \n-    private List<Image> filterImages(List<Image> availableImages, Image currentImage, String cloudPlatform) {\n-        // I think the whole logic is broken, since we don't allow an upgrade if we shipped a new parcel extension...\n-        return availableImages.stream()\n+    private ImageFilterResult filterImages(List<Image> availableImages, Image currentImage, String cloudPlatform) {\n+        List<Image> images = availableImages.stream()\n+                .filter(filterCurrentImage(currentImage))\n                 .filter(ignoredCmVersion())\n-                .filter(validateCmVersion(currentImage).or(validateStackVersion(currentImage)))\n+                .filter(validateCmAndStackVersion(currentImage))\n                 .filter(validateCloudPlatform(cloudPlatform))\n                 .filter(validateOsVersion(currentImage))\n-                // We don't necessary need CFM and CSP since only SDX upgrade is supported\n-                //.filter(validateCfmVersion(currentImage))\n-                //.filter(validateCspVersion(currentImage))\n                 .filter(validateSaltVersion(currentImage))\n-                .filter(filterCurrentImage(currentImage))\n                 .collect(Collectors.toList());\n-    }\n \n-    private Predicate<Image> validateOsVersion(Image currentImage) {\n-        return image -> isOsVersionsMatch(currentImage, image);\n+        return new ImageFilterResult(new Images(null, null, null, images, null), getReason(images));\n     }\n \n-    private boolean isOsVersionsMatch(Image currentImage, Image newImage) {\n-        return newImage.getOs().equalsIgnoreCase(currentImage.getOs())\n-                && newImage.getOsType().equalsIgnoreCase(currentImage.getOsType());\n+    private Predicate<Image> filterCurrentImage(Image currentImage) {\n+        return image -> {\n+            boolean result = !image.getUuid().equals(currentImage.getUuid());\n+            setReason(result, \"No other image is available.\");\n+            return result;\n+        };\n     }\n \n     private Predicate<Image> ignoredCmVersion() {\n-        // There are some legacy CM versions that do not follow a proper versioning scheme, we must ignore them\n-        return image -> image.getPackageVersions().get(CM_PACKAGE_KEY) != null &&\n-                !image.getPackageVersions().get(CM_PACKAGE_KEY).contains(IGNORED_CM_VERSION);\n+        return image -> {\n+            boolean result = image.getPackageVersions().get(CM_PACKAGE_KEY) != null\n+                    && !image.getPackageVersions().get(CM_PACKAGE_KEY).contains(IGNORED_CM_VERSION);\n+            setReason(result, \"There are no supported Cloudera Manager or CDP version.\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "17162f24600d530de95659591965edaa2efdfa0e"}, "originalPosition": 71}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjQwODEzNg==", "bodyText": "Typo: image--> images", "url": "https://github.com/hortonworks/cloudbreak/pull/7707#discussion_r402408136", "createdAt": "2020-04-02T15:33:26Z", "author": {"login": "pdarvasi"}, "path": "core/src/main/java/com/sequenceiq/cloudbreak/service/upgrade/ClusterUpgradeImageFilter.java", "diffHunk": "@@ -52,71 +46,86 @@ Images filter(List<Image> availableImages, Versions supportedVersions, Image cur\n         return versionBasedImageFilter.getCdhImagesForCbVersion(supportedVersions, availableImages);\n     }\n \n-    private List<Image> filterImages(List<Image> availableImages, Image currentImage, String cloudPlatform) {\n-        // I think the whole logic is broken, since we don't allow an upgrade if we shipped a new parcel extension...\n-        return availableImages.stream()\n+    private ImageFilterResult filterImages(List<Image> availableImages, Image currentImage, String cloudPlatform) {\n+        List<Image> images = availableImages.stream()\n+                .filter(filterCurrentImage(currentImage))\n                 .filter(ignoredCmVersion())\n-                .filter(validateCmVersion(currentImage).or(validateStackVersion(currentImage)))\n+                .filter(validateCmAndStackVersion(currentImage))\n                 .filter(validateCloudPlatform(cloudPlatform))\n                 .filter(validateOsVersion(currentImage))\n-                // We don't necessary need CFM and CSP since only SDX upgrade is supported\n-                //.filter(validateCfmVersion(currentImage))\n-                //.filter(validateCspVersion(currentImage))\n                 .filter(validateSaltVersion(currentImage))\n-                .filter(filterCurrentImage(currentImage))\n                 .collect(Collectors.toList());\n-    }\n \n-    private Predicate<Image> validateOsVersion(Image currentImage) {\n-        return image -> isOsVersionsMatch(currentImage, image);\n+        return new ImageFilterResult(new Images(null, null, null, images, null), getReason(images));\n     }\n \n-    private boolean isOsVersionsMatch(Image currentImage, Image newImage) {\n-        return newImage.getOs().equalsIgnoreCase(currentImage.getOs())\n-                && newImage.getOsType().equalsIgnoreCase(currentImage.getOsType());\n+    private Predicate<Image> filterCurrentImage(Image currentImage) {\n+        return image -> {\n+            boolean result = !image.getUuid().equals(currentImage.getUuid());\n+            setReason(result, \"No other image is available.\");\n+            return result;\n+        };\n     }\n \n     private Predicate<Image> ignoredCmVersion() {\n-        // There are some legacy CM versions that do not follow a proper versioning scheme, we must ignore them\n-        return image -> image.getPackageVersions().get(CM_PACKAGE_KEY) != null &&\n-                !image.getPackageVersions().get(CM_PACKAGE_KEY).contains(IGNORED_CM_VERSION);\n+        return image -> {\n+            boolean result = image.getPackageVersions().get(CM_PACKAGE_KEY) != null\n+                    && !image.getPackageVersions().get(CM_PACKAGE_KEY).contains(IGNORED_CM_VERSION);\n+            setReason(result, \"There are no supported Cloudera Manager or CDP version.\");\n+            return result;\n+        };\n     }\n \n-    private Predicate<Image> validateCmVersion(Image currentImage) {\n-        return image -> permitCmAndSatckUpgrade(currentImage, image, CM_PACKAGE_KEY);\n+    private Predicate<Image> validateCmAndStackVersion(Image currentImage) {\n+        return image -> {\n+            boolean result = permitCmAndSatckUpgrade(currentImage, image, CM_PACKAGE_KEY) || permitCmAndSatckUpgrade(currentImage, image, STACK_PACKAGE_KEY);\n+            setReason(result, \"There are no proper Cloudera Manager or CDP version to upgrade.\");\n+            return result;\n+        };\n     }\n \n-    private Predicate<Image> validateStackVersion(Image currentImage) {\n-        return image -> permitCmAndSatckUpgrade(currentImage, image, STACK_PACKAGE_KEY);\n+    private boolean permitCmAndSatckUpgrade(Image currentImage, Image image, String key) {\n+        return upgradePermissionProvider.permitCmAndSatckUpgrade(currentImage.getPackageVersions().get(STACK_PACKAGE_KEY),\n+                image.getPackageVersions().get(key));\n     }\n \n     private Predicate<Image> validateCloudPlatform(String cloudPlatform) {\n-        return image -> image.getImageSetsByProvider().keySet().stream().anyMatch(key -> key.equalsIgnoreCase(cloudPlatform));\n+        return image -> {\n+            boolean result = image.getImageSetsByProvider().keySet().stream().anyMatch(key -> key.equalsIgnoreCase(cloudPlatform));\n+            if (!result) {\n+                reason = String.format(\"There are no image available for %s cloud platform.\", cloudPlatform);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "17162f24600d530de95659591965edaa2efdfa0e"}, "originalPosition": 98}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "17162f24600d530de95659591965edaa2efdfa0e", "author": {"user": null}, "url": "https://github.com/hortonworks/cloudbreak/commit/17162f24600d530de95659591965edaa2efdfa0e", "committedDate": "2020-04-01T14:11:05Z", "message": "CB-6188: upgrade reason message"}, "afterCommit": {"oid": "f034a1ce1c502856995ade32d86959846e266d97", "author": {"user": null}, "url": "https://github.com/hortonworks/cloudbreak/commit/f034a1ce1c502856995ade32d86959846e266d97", "committedDate": "2020-04-03T09:02:30Z", "message": "CB-6188: upgrade reason message"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "f034a1ce1c502856995ade32d86959846e266d97", "author": {"user": null}, "url": "https://github.com/hortonworks/cloudbreak/commit/f034a1ce1c502856995ade32d86959846e266d97", "committedDate": "2020-04-03T09:02:30Z", "message": "CB-6188: upgrade reason message"}, "afterCommit": {"oid": "0e94a3a08938d9eb27f16d55a29dbfb3454f5fa1", "author": {"user": null}, "url": "https://github.com/hortonworks/cloudbreak/commit/0e94a3a08938d9eb27f16d55a29dbfb3454f5fa1", "committedDate": "2020-04-03T09:25:47Z", "message": "CB-6188: upgrade reason message"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7130f8d25270457989da669bc4f33b05c73ed068", "author": {"user": null}, "url": "https://github.com/hortonworks/cloudbreak/commit/7130f8d25270457989da669bc4f33b05c73ed068", "committedDate": "2020-04-03T09:39:35Z", "message": "CB-6188: upgrade reason message"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "0e94a3a08938d9eb27f16d55a29dbfb3454f5fa1", "author": {"user": null}, "url": "https://github.com/hortonworks/cloudbreak/commit/0e94a3a08938d9eb27f16d55a29dbfb3454f5fa1", "committedDate": "2020-04-03T09:25:47Z", "message": "CB-6188: upgrade reason message"}, "afterCommit": {"oid": "7130f8d25270457989da669bc4f33b05c73ed068", "author": {"user": null}, "url": "https://github.com/hortonworks/cloudbreak/commit/7130f8d25270457989da669bc4f33b05c73ed068", "committedDate": "2020-04-03T09:39:35Z", "message": "CB-6188: upgrade reason message"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg3MTE0MjQ4", "url": "https://github.com/hortonworks/cloudbreak/pull/7707#pullrequestreview-387114248", "createdAt": "2020-04-03T09:53:04Z", "commit": {"oid": "7130f8d25270457989da669bc4f33b05c73ed068"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2400, "cost": 1, "resetAt": "2021-11-01T14:51:55Z"}}}