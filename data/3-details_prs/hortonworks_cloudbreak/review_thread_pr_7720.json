{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzk3NTE4MDI0", "number": 7720, "reviewThreads": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMlQyMToyODoxN1rODuIDTw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMlQyMToyOTo1M1rODuIFFA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ5NjkzMDA3OnYy", "diffSide": "RIGHT", "path": "autoscale/src/main/java/com/sequenceiq/periscope/controller/AlertController.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMlQyMToyODoxN1rOF_9KGw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wM1QxMjoyNzowMFrOGATQAA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjYwNjYxOQ==", "bodyText": "Do we need to check for the existence of the hostGroup in the cluster?", "url": "https://github.com/hortonworks/cloudbreak/pull/7720#discussion_r402606619", "createdAt": "2020-04-02T21:28:17Z", "author": {"login": "sidseth"}, "path": "autoscale/src/main/java/com/sequenceiq/periscope/controller/AlertController.java", "diffHunk": "@@ -229,14 +224,34 @@ private LoadAlertResponse createLoadAlertResponse(LoadAlert loadAlert) {\n         return loadAlertResponseConverter.convert(loadAlert);\n     }\n \n-    private void validateTimeAlert(Long clusterId, Optional<Long> alertId, TimeAlertRequest json) throws ParseException {\n-        validateAlertForUpdate(clusterId, alertId, AlertType.TIME);\n-        dateService.validateTimeZone(json.getTimeZone());\n-        dateService.getCronExpression(json.getCron());\n+    private void validateTimeAlert(Long clusterId, Optional<Long> alertId, TimeAlertRequest json) {\n+        alertId.ifPresent(alert -> validateAlertForUpdate(clusterId, alert, AlertType.TIME));\n+        try {\n+            dateService.validateTimeZone(json.getTimeZone());\n+            dateService.getCronExpression(json.getCron());\n+        } catch (ParseException parseException) {\n+            throw new BadRequestException(parseException.getMessage(), parseException);\n+        }\n     }\n \n-    private void validateLoadAlert(Long clusterId, Optional<Long> alertId, LoadAlertRequest json) throws ParseException {\n-        validateAlertForUpdate(clusterId, alertId, AlertType.LOAD);\n+    private void validateLoadAlert(Long clusterId, Optional<Long> alertId, LoadAlertRequest json) {\n+        Cluster cluster = clusterService.findById(clusterId);\n+        alertId.ifPresentOrElse(\n+                updateAlert -> {\n+                    validateAlertForUpdate(clusterId, updateAlert, AlertType.LOAD);\n+                }, () -> {\n+                    if (!cluster.getTunnel().useClusterProxy()) {\n+                        throw new BadRequestException(String.format(\"Cluster '%s' is not configured with Cluster Proxy Tunnel, \" +\n+                                \"Cluster Tunnel is %s. Load Based Scaling not supported\", cluster.getStackCrn(), cluster.getTunnel()));\n+                    }\n+\n+                    String hostGroup = json.getScalingPolicy().getHostGroup();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "43edbd16cb6d455a671bf51df90576fb488558ff"}, "originalPosition": 110}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjk2ODU3Ng==", "bodyText": "we would also need the hostGroup services validation, which can be added based on our other discussion.", "url": "https://github.com/hortonworks/cloudbreak/pull/7720#discussion_r402968576", "createdAt": "2020-04-03T12:27:00Z", "author": {"login": "smaniraju"}, "path": "autoscale/src/main/java/com/sequenceiq/periscope/controller/AlertController.java", "diffHunk": "@@ -229,14 +224,34 @@ private LoadAlertResponse createLoadAlertResponse(LoadAlert loadAlert) {\n         return loadAlertResponseConverter.convert(loadAlert);\n     }\n \n-    private void validateTimeAlert(Long clusterId, Optional<Long> alertId, TimeAlertRequest json) throws ParseException {\n-        validateAlertForUpdate(clusterId, alertId, AlertType.TIME);\n-        dateService.validateTimeZone(json.getTimeZone());\n-        dateService.getCronExpression(json.getCron());\n+    private void validateTimeAlert(Long clusterId, Optional<Long> alertId, TimeAlertRequest json) {\n+        alertId.ifPresent(alert -> validateAlertForUpdate(clusterId, alert, AlertType.TIME));\n+        try {\n+            dateService.validateTimeZone(json.getTimeZone());\n+            dateService.getCronExpression(json.getCron());\n+        } catch (ParseException parseException) {\n+            throw new BadRequestException(parseException.getMessage(), parseException);\n+        }\n     }\n \n-    private void validateLoadAlert(Long clusterId, Optional<Long> alertId, LoadAlertRequest json) throws ParseException {\n-        validateAlertForUpdate(clusterId, alertId, AlertType.LOAD);\n+    private void validateLoadAlert(Long clusterId, Optional<Long> alertId, LoadAlertRequest json) {\n+        Cluster cluster = clusterService.findById(clusterId);\n+        alertId.ifPresentOrElse(\n+                updateAlert -> {\n+                    validateAlertForUpdate(clusterId, updateAlert, AlertType.LOAD);\n+                }, () -> {\n+                    if (!cluster.getTunnel().useClusterProxy()) {\n+                        throw new BadRequestException(String.format(\"Cluster '%s' is not configured with Cluster Proxy Tunnel, \" +\n+                                \"Cluster Tunnel is %s. Load Based Scaling not supported\", cluster.getStackCrn(), cluster.getTunnel()));\n+                    }\n+\n+                    String hostGroup = json.getScalingPolicy().getHostGroup();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjYwNjYxOQ=="}, "originalCommit": {"oid": "43edbd16cb6d455a671bf51df90576fb488558ff"}, "originalPosition": 110}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ5NjkzMzY1OnYy", "diffSide": "RIGHT", "path": "autoscale/src/main/java/com/sequenceiq/periscope/controller/AlertController.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMlQyMToyOTozMlrOF_9MaQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMlQyMToyOTozMlrOF_9MaQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjYwNzIwOQ==", "bodyText": "This looks good based on the assumption that we're going with w.r.t all clusters using the ClusterProxy. Will have to include this in the documentation eventually.", "url": "https://github.com/hortonworks/cloudbreak/pull/7720#discussion_r402607209", "createdAt": "2020-04-02T21:29:32Z", "author": {"login": "sidseth"}, "path": "autoscale/src/main/java/com/sequenceiq/periscope/controller/AlertController.java", "diffHunk": "@@ -229,14 +224,34 @@ private LoadAlertResponse createLoadAlertResponse(LoadAlert loadAlert) {\n         return loadAlertResponseConverter.convert(loadAlert);\n     }\n \n-    private void validateTimeAlert(Long clusterId, Optional<Long> alertId, TimeAlertRequest json) throws ParseException {\n-        validateAlertForUpdate(clusterId, alertId, AlertType.TIME);\n-        dateService.validateTimeZone(json.getTimeZone());\n-        dateService.getCronExpression(json.getCron());\n+    private void validateTimeAlert(Long clusterId, Optional<Long> alertId, TimeAlertRequest json) {\n+        alertId.ifPresent(alert -> validateAlertForUpdate(clusterId, alert, AlertType.TIME));\n+        try {\n+            dateService.validateTimeZone(json.getTimeZone());\n+            dateService.getCronExpression(json.getCron());\n+        } catch (ParseException parseException) {\n+            throw new BadRequestException(parseException.getMessage(), parseException);\n+        }\n     }\n \n-    private void validateLoadAlert(Long clusterId, Optional<Long> alertId, LoadAlertRequest json) throws ParseException {\n-        validateAlertForUpdate(clusterId, alertId, AlertType.LOAD);\n+    private void validateLoadAlert(Long clusterId, Optional<Long> alertId, LoadAlertRequest json) {\n+        Cluster cluster = clusterService.findById(clusterId);\n+        alertId.ifPresentOrElse(\n+                updateAlert -> {\n+                    validateAlertForUpdate(clusterId, updateAlert, AlertType.LOAD);\n+                }, () -> {\n+                    if (!cluster.getTunnel().useClusterProxy()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "43edbd16cb6d455a671bf51df90576fb488558ff"}, "originalPosition": 105}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ5NjkzNDYwOnYy", "diffSide": "RIGHT", "path": "autoscale/src/main/java/com/sequenceiq/periscope/controller/AlertController.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMlQyMToyOTo1M1rOF_9M_Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wM1QxMjoyMjo1OVrOGATHZw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjYwNzM1Nw==", "bodyText": "Nit: Move into the (alert == null) block.", "url": "https://github.com/hortonworks/cloudbreak/pull/7720#discussion_r402607357", "createdAt": "2020-04-02T21:29:53Z", "author": {"login": "sidseth"}, "path": "autoscale/src/main/java/com/sequenceiq/periscope/controller/AlertController.java", "diffHunk": "@@ -265,30 +280,27 @@ private PrometheusAlertResponse createPrometheusAlertResponse(PrometheusAlert al\n         return prometheusAlertResponseConverter.convert(alarm);\n     }\n \n-    private void validateAlertForUpdate(Long clusterId, Optional<Long> alertIdRequest, AlertType alertType) {\n-        alertIdRequest.ifPresent(alertId -> {\n-            BaseAlert alert;\n-            String clusterCrn = clusterService.findStackCrnById(clusterId);\n-            switch (alertType) {\n-                case LOAD:\n-                    alert = alertService.findLoadAlertByCluster(clusterId, alertId);\n-                    break;\n-                case TIME:\n-                    alert = alertService.findTimeAlertByCluster(clusterId, alertId);\n-                    break;\n-                case METRIC:\n-                    alert = alertService.findMetricAlertByCluster(clusterId, alertId);\n-                    break;\n-                case PROMETHEUS:\n-                    alert = alertService.findPrometheusAlertByCluster(clusterId, alertId);\n-                    break;\n-                default:\n-                    alert = null;\n-\n-            }\n-            if (alert == null) {\n-                throw new NotFoundException(String.format(\"Could not find %s alert with id: '%s', for cluster: '%s'\", alertType, alertId, clusterCrn));\n-            }\n-        });\n+    private void validateAlertForUpdate(Long clusterId, Long alertId, AlertType alertType) {\n+        BaseAlert alert;\n+        String clusterCrn = clusterService.findStackCrnById(clusterId);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "43edbd16cb6d455a671bf51df90576fb488558ff"}, "originalPosition": 151}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjk2NjM3NQ==", "bodyText": "ack", "url": "https://github.com/hortonworks/cloudbreak/pull/7720#discussion_r402966375", "createdAt": "2020-04-03T12:22:59Z", "author": {"login": "smaniraju"}, "path": "autoscale/src/main/java/com/sequenceiq/periscope/controller/AlertController.java", "diffHunk": "@@ -265,30 +280,27 @@ private PrometheusAlertResponse createPrometheusAlertResponse(PrometheusAlert al\n         return prometheusAlertResponseConverter.convert(alarm);\n     }\n \n-    private void validateAlertForUpdate(Long clusterId, Optional<Long> alertIdRequest, AlertType alertType) {\n-        alertIdRequest.ifPresent(alertId -> {\n-            BaseAlert alert;\n-            String clusterCrn = clusterService.findStackCrnById(clusterId);\n-            switch (alertType) {\n-                case LOAD:\n-                    alert = alertService.findLoadAlertByCluster(clusterId, alertId);\n-                    break;\n-                case TIME:\n-                    alert = alertService.findTimeAlertByCluster(clusterId, alertId);\n-                    break;\n-                case METRIC:\n-                    alert = alertService.findMetricAlertByCluster(clusterId, alertId);\n-                    break;\n-                case PROMETHEUS:\n-                    alert = alertService.findPrometheusAlertByCluster(clusterId, alertId);\n-                    break;\n-                default:\n-                    alert = null;\n-\n-            }\n-            if (alert == null) {\n-                throw new NotFoundException(String.format(\"Could not find %s alert with id: '%s', for cluster: '%s'\", alertType, alertId, clusterCrn));\n-            }\n-        });\n+    private void validateAlertForUpdate(Long clusterId, Long alertId, AlertType alertType) {\n+        BaseAlert alert;\n+        String clusterCrn = clusterService.findStackCrnById(clusterId);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjYwNzM1Nw=="}, "originalCommit": {"oid": "43edbd16cb6d455a671bf51df90576fb488558ff"}, "originalPosition": 151}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2624, "cost": 1, "resetAt": "2021-11-12T20:44:06Z"}}}