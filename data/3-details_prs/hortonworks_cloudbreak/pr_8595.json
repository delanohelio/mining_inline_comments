{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDUzNDI5ODc1", "number": 8595, "title": "CB-7923 MetricEvaluator should send alerts in batch", "bodyText": "The periscope starts the alerts one by one. If the first alert finishes before then the last alert starts, the last alert will be skipped because the cooldown is calculated from the last activity field. So, we should send the alerts in batch and iterate after the cooldown check.", "createdAt": "2020-07-20T13:05:29Z", "url": "https://github.com/hortonworks/cloudbreak/pull/8595", "merged": true, "mergeCommit": {"oid": "d63d00754909cd36e2c062add676626216b7e236"}, "closed": true, "closedAt": "2020-07-22T09:32:35Z", "author": {"login": "topolyai5"}, "timelineItems": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABc2_tmQgFqTQ1MjE0Mjg3Nw==", "endCursor": "Y3Vyc29yOnYyOpPPAAABc3XiYMgFqTQ1MzE0OTI2MA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDUyMTQyODc3", "url": "https://github.com/hortonworks/cloudbreak/pull/8595#pullrequestreview-452142877", "createdAt": "2020-07-21T05:48:00Z", "commit": {"oid": "f6dc8c71166753b383661cd51cfeddd52704b03d"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMVQwNTo0OTozNVrOG0pDAg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMVQwNTo1MTo0NFrOG0pGFQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Nzg1MTY1MA==", "bodyText": "The log message could be enhanced and contain the name of the alert/scaling action pair for the sake of easier debugging in the future.", "url": "https://github.com/hortonworks/cloudbreak/pull/8595#discussion_r457851650", "createdAt": "2020-07-21T05:49:35Z", "author": {"login": "biharitomi"}, "path": "autoscale/src/main/java/com/sequenceiq/periscope/monitor/handler/ScalingHandler.java", "diffHunk": "@@ -48,30 +50,37 @@\n \n     @Override\n     public void onApplicationEvent(ScalingEvent event) {\n-        BaseAlert alert = event.getAlert();\n-        Cluster cluster = clusterService.findById(alert.getCluster().getId());\n+        Set<BaseAlert> alerts = event.getAlerts();\n+        Long clusterId = alerts.stream().findFirst().map(ma -> ma.getCluster().getId()).orElseThrow();\n+        Cluster cluster = clusterService.findById(clusterId);\n         MDCBuilder.buildMdcContext(cluster);\n-        scale(cluster, alert.getScalingPolicy());\n+        if (isCooldownElapsed(cluster)) {\n+            alerts.forEach(alert -> scale(cluster, alert.getScalingPolicy()));\n+        }\n     }\n \n     private void scale(Cluster cluster, ScalingPolicy policy) {\n+        int totalNodes = Math.toIntExact(cloudbreakClient.autoscaleEndpoint().getHostMetadataCountForAutoscale(cluster.getStackId(), policy.getHostGroup()));\n+        int desiredNodeCount = getDesiredNodeCount(cluster, policy, totalNodes);\n+        if (totalNodes != desiredNodeCount) {\n+            Runnable scalingRequest = (Runnable) applicationContext.getBean(\"ScalingRequest\", cluster, policy, totalNodes, desiredNodeCount);\n+            loggedExecutorService.submit(\"ScalingHandler\", scalingRequest);\n+            rejectedThreadService.remove(cluster.getId());\n+            cluster.setLastScalingActivityCurrent();\n+            clusterService.save(cluster);\n+        } else {\n+            LOGGER.info(\"No scaling activity required\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f6dc8c71166753b383661cd51cfeddd52704b03d"}, "originalPosition": 35}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Nzg1MjQzNw==", "bodyText": "Do we really want to trigger multiple scaling actions at the same time?", "url": "https://github.com/hortonworks/cloudbreak/pull/8595#discussion_r457852437", "createdAt": "2020-07-21T05:51:44Z", "author": {"login": "biharitomi"}, "path": "autoscale/src/main/java/com/sequenceiq/periscope/monitor/handler/ScalingHandler.java", "diffHunk": "@@ -48,30 +50,37 @@\n \n     @Override\n     public void onApplicationEvent(ScalingEvent event) {\n-        BaseAlert alert = event.getAlert();\n-        Cluster cluster = clusterService.findById(alert.getCluster().getId());\n+        Set<BaseAlert> alerts = event.getAlerts();\n+        Long clusterId = alerts.stream().findFirst().map(ma -> ma.getCluster().getId()).orElseThrow();\n+        Cluster cluster = clusterService.findById(clusterId);\n         MDCBuilder.buildMdcContext(cluster);\n-        scale(cluster, alert.getScalingPolicy());\n+        if (isCooldownElapsed(cluster)) {\n+            alerts.forEach(alert -> scale(cluster, alert.getScalingPolicy()));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f6dc8c71166753b383661cd51cfeddd52704b03d"}, "originalPosition": 21}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "fea250e812303c3c340f71f81f216358766b5898", "author": {"user": {"login": "topolyai5", "name": "Gergely Topolyai"}}, "url": "https://github.com/hortonworks/cloudbreak/commit/fea250e812303c3c340f71f81f216358766b5898", "committedDate": "2020-07-21T11:05:26Z", "message": "adf"}, "afterCommit": {"oid": "b96f814f54afc0d9c0dea05ee83f870657fac97b", "author": {"user": {"login": "topolyai5", "name": "Gergely Topolyai"}}, "url": "https://github.com/hortonworks/cloudbreak/commit/b96f814f54afc0d9c0dea05ee83f870657fac97b", "committedDate": "2020-07-21T11:35:55Z", "message": "adf"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "b96f814f54afc0d9c0dea05ee83f870657fac97b", "author": {"user": {"login": "topolyai5", "name": "Gergely Topolyai"}}, "url": "https://github.com/hortonworks/cloudbreak/commit/b96f814f54afc0d9c0dea05ee83f870657fac97b", "committedDate": "2020-07-21T11:35:55Z", "message": "adf"}, "afterCommit": {"oid": "d021e12f25d29c0c88a8b6c5aed497843bbfdb0f", "author": {"user": {"login": "topolyai5", "name": "Gergely Topolyai"}}, "url": "https://github.com/hortonworks/cloudbreak/commit/d021e12f25d29c0c88a8b6c5aed497843bbfdb0f", "committedDate": "2020-07-21T18:45:15Z", "message": "CB-7923 MetricEvaluator should send alerts in batch"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8f56659e03c675a34085dea1c72c020898c0e048", "author": {"user": {"login": "topolyai5", "name": "Gergely Topolyai"}}, "url": "https://github.com/hortonworks/cloudbreak/commit/8f56659e03c675a34085dea1c72c020898c0e048", "committedDate": "2020-07-21T19:52:46Z", "message": "CB-7923 MetricEvaluator should send alerts in batch"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "d021e12f25d29c0c88a8b6c5aed497843bbfdb0f", "author": {"user": {"login": "topolyai5", "name": "Gergely Topolyai"}}, "url": "https://github.com/hortonworks/cloudbreak/commit/d021e12f25d29c0c88a8b6c5aed497843bbfdb0f", "committedDate": "2020-07-21T18:45:15Z", "message": "CB-7923 MetricEvaluator should send alerts in batch"}, "afterCommit": {"oid": "8f56659e03c675a34085dea1c72c020898c0e048", "author": {"user": {"login": "topolyai5", "name": "Gergely Topolyai"}}, "url": "https://github.com/hortonworks/cloudbreak/commit/8f56659e03c675a34085dea1c72c020898c0e048", "committedDate": "2020-07-21T19:52:46Z", "message": "CB-7923 MetricEvaluator should send alerts in batch"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDUzMDEyNTIy", "url": "https://github.com/hortonworks/cloudbreak/pull/8595#pullrequestreview-453012522", "createdAt": "2020-07-22T05:51:19Z", "commit": {"oid": "8f56659e03c675a34085dea1c72c020898c0e048"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDUzMTUwOTQ1", "url": "https://github.com/hortonworks/cloudbreak/pull/8595#pullrequestreview-453150945", "createdAt": "2020-07-22T09:31:02Z", "commit": {"oid": "8f56659e03c675a34085dea1c72c020898c0e048"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDUzMTQ5MjYw", "url": "https://github.com/hortonworks/cloudbreak/pull/8595#pullrequestreview-453149260", "createdAt": "2020-07-22T09:28:50Z", "commit": {"oid": "8f56659e03c675a34085dea1c72c020898c0e048"}, "state": "COMMENTED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMlQwOToyODo1MFrOG1acSQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMlQwOTozNzowOFrOG1avSg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODY2MDkzNw==", "bodyText": "pls add some extra logging to this if clause, too", "url": "https://github.com/hortonworks/cloudbreak/pull/8595#discussion_r458660937", "createdAt": "2020-07-22T09:28:50Z", "author": {"login": "pdarvasi"}, "path": "autoscale/src/main/java/com/sequenceiq/periscope/monitor/ScalingHandlerUtil.java", "diffHunk": "@@ -0,0 +1,106 @@\n+package com.sequenceiq.periscope.monitor;\n+\n+import static java.lang.Math.ceil;\n+\n+import javax.inject.Inject;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.context.ApplicationContext;\n+import org.springframework.stereotype.Component;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.sequenceiq.cloudbreak.client.CloudbreakClient;\n+import com.sequenceiq.cloudbreak.service.Clock;\n+import com.sequenceiq.periscope.domain.BaseAlert;\n+import com.sequenceiq.periscope.domain.Cluster;\n+import com.sequenceiq.periscope.domain.ScalingPolicy;\n+import com.sequenceiq.periscope.monitor.executor.LoggedExecutorService;\n+import com.sequenceiq.periscope.service.ClusterService;\n+import com.sequenceiq.periscope.service.RejectedThreadService;\n+import com.sequenceiq.periscope.utils.ClusterUtils;\n+import com.sequenceiq.periscope.utils.TimeUtil;\n+\n+@Component\n+public class ScalingHandlerUtil {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(ScalingHandlerUtil.class);\n+\n+    @Inject\n+    private ApplicationContext applicationContext;\n+\n+    @Inject\n+    private RejectedThreadService rejectedThreadService;\n+\n+    @Inject\n+    private CloudbreakClient cloudbreakClient;\n+\n+    @Inject\n+    private ClusterService clusterService;\n+\n+    @Inject\n+    private LoggedExecutorService loggedExecutorService;\n+\n+    @Inject\n+    private Clock clock;\n+\n+    public void scaleIfNeed(Cluster cluster, BaseAlert alert) {\n+        ScalingPolicy policy = alert.getScalingPolicy();\n+        int totalNodes = Math.toIntExact(cloudbreakClient.autoscaleEndpoint().getHostMetadataCountForAutoscale(cluster.getStackId(), policy.getHostGroup()));\n+        int desiredNodeCount = getDesiredNodeCount(cluster, policy, totalNodes);\n+        if (totalNodes != desiredNodeCount) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8f56659e03c675a34085dea1c72c020898c0e048"}, "originalPosition": 51}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODY2MTAzMg==", "bodyText": "pls add some extra logging to this if clause, too", "url": "https://github.com/hortonworks/cloudbreak/pull/8595#discussion_r458661032", "createdAt": "2020-07-22T09:29:00Z", "author": {"login": "pdarvasi"}, "path": "autoscale/src/main/java/com/sequenceiq/periscope/monitor/ScalingHandlerUtil.java", "diffHunk": "@@ -0,0 +1,106 @@\n+package com.sequenceiq.periscope.monitor;\n+\n+import static java.lang.Math.ceil;\n+\n+import javax.inject.Inject;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.context.ApplicationContext;\n+import org.springframework.stereotype.Component;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.sequenceiq.cloudbreak.client.CloudbreakClient;\n+import com.sequenceiq.cloudbreak.service.Clock;\n+import com.sequenceiq.periscope.domain.BaseAlert;\n+import com.sequenceiq.periscope.domain.Cluster;\n+import com.sequenceiq.periscope.domain.ScalingPolicy;\n+import com.sequenceiq.periscope.monitor.executor.LoggedExecutorService;\n+import com.sequenceiq.periscope.service.ClusterService;\n+import com.sequenceiq.periscope.service.RejectedThreadService;\n+import com.sequenceiq.periscope.utils.ClusterUtils;\n+import com.sequenceiq.periscope.utils.TimeUtil;\n+\n+@Component\n+public class ScalingHandlerUtil {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(ScalingHandlerUtil.class);\n+\n+    @Inject\n+    private ApplicationContext applicationContext;\n+\n+    @Inject\n+    private RejectedThreadService rejectedThreadService;\n+\n+    @Inject\n+    private CloudbreakClient cloudbreakClient;\n+\n+    @Inject\n+    private ClusterService clusterService;\n+\n+    @Inject\n+    private LoggedExecutorService loggedExecutorService;\n+\n+    @Inject\n+    private Clock clock;\n+\n+    public void scaleIfNeed(Cluster cluster, BaseAlert alert) {\n+        ScalingPolicy policy = alert.getScalingPolicy();\n+        int totalNodes = Math.toIntExact(cloudbreakClient.autoscaleEndpoint().getHostMetadataCountForAutoscale(cluster.getStackId(), policy.getHostGroup()));\n+        int desiredNodeCount = getDesiredNodeCount(cluster, policy, totalNodes);\n+        if (totalNodes != desiredNodeCount) {\n+            cluster.setLastScalingActivityCurrent();\n+            clusterService.save(cluster);\n+            scale(cluster, policy);\n+        } else {\n+            LOGGER.info(\"No scaling activity required for '{}' policy\", policy.getName());\n+        }\n+    }\n+\n+    private void scale(Cluster cluster, ScalingPolicy policy) {\n+        int totalNodes = Math.toIntExact(cloudbreakClient.autoscaleEndpoint().getHostMetadataCountForAutoscale(cluster.getStackId(), policy.getHostGroup()));\n+        int desiredNodeCount = getDesiredNodeCount(cluster, policy, totalNodes);\n+        Runnable scalingRequest = (Runnable) applicationContext.getBean(\"ScalingRequest\", cluster, policy, totalNodes, desiredNodeCount);\n+        loggedExecutorService.submit(\"ScalingHandler\", scalingRequest);\n+        rejectedThreadService.remove(cluster.getId());\n+    }\n+\n+    public boolean isCooldownElapsed(Cluster cluster) {\n+        long remainingTime = getRemainingCooldownTime(cluster);\n+        if (remainingTime <= 0) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8f56659e03c675a34085dea1c72c020898c0e048"}, "originalPosition": 70}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODY2MjIzMQ==", "bodyText": "pls add some extra logging to this including minSize, maxSize and calculated desiredNodeCount", "url": "https://github.com/hortonworks/cloudbreak/pull/8595#discussion_r458662231", "createdAt": "2020-07-22T09:31:07Z", "author": {"login": "pdarvasi"}, "path": "autoscale/src/main/java/com/sequenceiq/periscope/monitor/ScalingHandlerUtil.java", "diffHunk": "@@ -0,0 +1,106 @@\n+package com.sequenceiq.periscope.monitor;\n+\n+import static java.lang.Math.ceil;\n+\n+import javax.inject.Inject;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.context.ApplicationContext;\n+import org.springframework.stereotype.Component;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.sequenceiq.cloudbreak.client.CloudbreakClient;\n+import com.sequenceiq.cloudbreak.service.Clock;\n+import com.sequenceiq.periscope.domain.BaseAlert;\n+import com.sequenceiq.periscope.domain.Cluster;\n+import com.sequenceiq.periscope.domain.ScalingPolicy;\n+import com.sequenceiq.periscope.monitor.executor.LoggedExecutorService;\n+import com.sequenceiq.periscope.service.ClusterService;\n+import com.sequenceiq.periscope.service.RejectedThreadService;\n+import com.sequenceiq.periscope.utils.ClusterUtils;\n+import com.sequenceiq.periscope.utils.TimeUtil;\n+\n+@Component\n+public class ScalingHandlerUtil {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(ScalingHandlerUtil.class);\n+\n+    @Inject\n+    private ApplicationContext applicationContext;\n+\n+    @Inject\n+    private RejectedThreadService rejectedThreadService;\n+\n+    @Inject\n+    private CloudbreakClient cloudbreakClient;\n+\n+    @Inject\n+    private ClusterService clusterService;\n+\n+    @Inject\n+    private LoggedExecutorService loggedExecutorService;\n+\n+    @Inject\n+    private Clock clock;\n+\n+    public void scaleIfNeed(Cluster cluster, BaseAlert alert) {\n+        ScalingPolicy policy = alert.getScalingPolicy();\n+        int totalNodes = Math.toIntExact(cloudbreakClient.autoscaleEndpoint().getHostMetadataCountForAutoscale(cluster.getStackId(), policy.getHostGroup()));\n+        int desiredNodeCount = getDesiredNodeCount(cluster, policy, totalNodes);\n+        if (totalNodes != desiredNodeCount) {\n+            cluster.setLastScalingActivityCurrent();\n+            clusterService.save(cluster);\n+            scale(cluster, policy);\n+        } else {\n+            LOGGER.info(\"No scaling activity required for '{}' policy\", policy.getName());\n+        }\n+    }\n+\n+    private void scale(Cluster cluster, ScalingPolicy policy) {\n+        int totalNodes = Math.toIntExact(cloudbreakClient.autoscaleEndpoint().getHostMetadataCountForAutoscale(cluster.getStackId(), policy.getHostGroup()));\n+        int desiredNodeCount = getDesiredNodeCount(cluster, policy, totalNodes);\n+        Runnable scalingRequest = (Runnable) applicationContext.getBean(\"ScalingRequest\", cluster, policy, totalNodes, desiredNodeCount);\n+        loggedExecutorService.submit(\"ScalingHandler\", scalingRequest);\n+        rejectedThreadService.remove(cluster.getId());\n+    }\n+\n+    public boolean isCooldownElapsed(Cluster cluster) {\n+        long remainingTime = getRemainingCooldownTime(cluster);\n+        if (remainingTime <= 0) {\n+            return true;\n+        }\n+        LOGGER.info(\"Cluster cannot be scaled for {} min(s)\",\n+                ClusterUtils.TIME_FORMAT.format((double) remainingTime / TimeUtil.MIN_IN_MS));\n+        return false;\n+    }\n+\n+    private long getRemainingCooldownTime(Cluster cluster) {\n+        long coolDown = cluster.getCoolDown();\n+        long lastScalingActivity = cluster.getLastScalingActivity();\n+        return lastScalingActivity == 0L ? 0L : (coolDown * TimeUtil.MIN_IN_MS) - (clock.getCurrentTime() - lastScalingActivity);\n+    }\n+\n+    @VisibleForTesting\n+    protected int getDesiredNodeCount(Cluster cluster, ScalingPolicy policy, int totalNodes) {\n+        int scalingAdjustment = policy.getScalingAdjustment();\n+        int desiredNodeCount;\n+        switch (policy.getAdjustmentType()) {\n+            case NODE_COUNT:\n+                desiredNodeCount = totalNodes + scalingAdjustment;\n+                break;\n+            case PERCENTAGE:\n+                desiredNodeCount = totalNodes\n+                        + (int) (ceil(totalNodes * ((double) scalingAdjustment / ClusterUtils.MAX_CAPACITY)));\n+                break;\n+            case EXACT:\n+                desiredNodeCount = policy.getScalingAdjustment();\n+                break;\n+            default:\n+                desiredNodeCount = totalNodes;\n+        }\n+        int minSize = cluster.getMinSize();\n+        int maxSize = cluster.getMaxSize();\n+        return desiredNodeCount < minSize ? minSize : Math.min(desiredNodeCount, maxSize);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8f56659e03c675a34085dea1c72c020898c0e048"}, "originalPosition": 104}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODY2NTgwMg==", "bodyText": "Are you sure this won't cause any race conditions? I mean two or more possible subsequent \"true\" answers for isCooldownElapsed..", "url": "https://github.com/hortonworks/cloudbreak/pull/8595#discussion_r458665802", "createdAt": "2020-07-22T09:37:08Z", "author": {"login": "pdarvasi"}, "path": "autoscale/src/main/java/com/sequenceiq/periscope/monitor/handler/ScalingHandler.java", "diffHunk": "@@ -1,105 +1,38 @@\n package com.sequenceiq.periscope.monitor.handler;\n \n-import static java.lang.Math.ceil;\n+import java.util.List;\n \n import javax.inject.Inject;\n \n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-import org.springframework.context.ApplicationContext;\n import org.springframework.context.ApplicationListener;\n import org.springframework.stereotype.Component;\n \n-import com.sequenceiq.cloudbreak.client.CloudbreakClient;\n-import com.sequenceiq.periscope.aspects.AmbariRequestLogging;\n import com.sequenceiq.periscope.domain.BaseAlert;\n import com.sequenceiq.periscope.domain.Cluster;\n-import com.sequenceiq.periscope.domain.ScalingPolicy;\n import com.sequenceiq.periscope.log.MDCBuilder;\n+import com.sequenceiq.periscope.monitor.ScalingHandlerUtil;\n import com.sequenceiq.periscope.monitor.event.ScalingEvent;\n-import com.sequenceiq.periscope.monitor.executor.LoggedExecutorService;\n import com.sequenceiq.periscope.service.ClusterService;\n-import com.sequenceiq.periscope.service.RejectedThreadService;\n-import com.sequenceiq.periscope.utils.ClusterUtils;\n-import com.sequenceiq.periscope.utils.TimeUtil;\n \n @Component\n public class ScalingHandler implements ApplicationListener<ScalingEvent> {\n \n-    private static final Logger LOGGER = LoggerFactory.getLogger(ScalingHandler.class);\n-\n-    @Inject\n-    private LoggedExecutorService loggedExecutorService;\n-\n     @Inject\n     private ClusterService clusterService;\n \n     @Inject\n-    private ApplicationContext applicationContext;\n-\n-    @Inject\n-    private RejectedThreadService rejectedThreadService;\n-\n-    @Inject\n-    private AmbariRequestLogging ambariRequestLogging;\n-\n-    @Inject\n-    private CloudbreakClient cloudbreakClient;\n+    private ScalingHandlerUtil scalingHandlerUtil;\n \n     @Override\n     public void onApplicationEvent(ScalingEvent event) {\n-        BaseAlert alert = event.getAlert();\n-        Cluster cluster = clusterService.findById(alert.getCluster().getId());\n+        List<BaseAlert> alerts = event.getAlerts();\n+        Long clusterId = alerts.stream().findFirst().map(ma -> ma.getCluster().getId()).orElseThrow();\n+        Cluster cluster = clusterService.findById(clusterId);\n         MDCBuilder.buildMdcContext(cluster);\n-        scale(cluster, alert.getScalingPolicy());\n-    }\n-\n-    private void scale(Cluster cluster, ScalingPolicy policy) {\n-        long remainingTime = getRemainingCooldownTime(cluster);\n-        if (remainingTime <= 0) {\n-            int totalNodes = Math.toIntExact(cloudbreakClient.autoscaleEndpoint().getHostMetadataCountForAutoscale(cluster.getStackId(), policy.getHostGroup()));\n-            int desiredNodeCount = getDesiredNodeCount(cluster, policy, totalNodes);\n-            if (totalNodes != desiredNodeCount) {\n-                Runnable scalingRequest = (Runnable) applicationContext.getBean(\"ScalingRequest\", cluster, policy, totalNodes, desiredNodeCount);\n-                loggedExecutorService.submit(\"ScalingHandler\", scalingRequest);\n-                rejectedThreadService.remove(cluster.getId());\n-                cluster.setLastScalingActivityCurrent();\n-                clusterService.save(cluster);\n-            } else {\n-                LOGGER.info(\"No scaling activity required\");\n+        alerts.forEach(alert -> {\n+            if (scalingHandlerUtil.isCooldownElapsed(cluster)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8f56659e03c675a34085dea1c72c020898c0e048"}, "originalPosition": 77}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2603, "cost": 1, "resetAt": "2021-11-01T14:51:55Z"}}}