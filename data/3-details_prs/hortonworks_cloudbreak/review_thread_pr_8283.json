{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDM0NjM2NDA3", "number": 8283, "reviewThreads": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNVQxNjoxMTowNVrOEFmnNw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNVQxNjoxNjo0M1rOEFmwjA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc0MzEwOTY3OnYy", "diffSide": "RIGHT", "path": "authorization-common/src/test/java/com/sequenceiq/authorization/EnforceAuthorizationLogicsUtil.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNVQxNjoxMTowNVrOGj5FeQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNVQxNjoyNDo0OFrOGj5nEg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDI4ODYzMw==", "bodyText": "is it possible to replace these with stream methods?", "url": "https://github.com/hortonworks/cloudbreak/pull/8283#discussion_r440288633", "createdAt": "2020-06-15T16:11:05Z", "author": {"login": "horadla23"}, "path": "authorization-common/src/test/java/com/sequenceiq/authorization/EnforceAuthorizationLogicsUtil.java", "diffHunk": "@@ -62,18 +124,239 @@ public static void testIfControllerClassHasAuthorizationAnnotation() {\n         Set<String> controllersWithoutAnnotation = Sets.difference(controllersClasses, Sets.union(authorizationResourceClasses, disabledAuthorizationClasses));\n \n         assertTrue(\"These controllers are missing @AuthorizationResource annotation: \" + Joiner.on(\",\").join(controllersWithoutAnnotation),\n-                controllersWithoutAnnotation.size() == 0);\n+                controllersWithoutAnnotation.isEmpty());\n     }\n \n     public static void testIfControllerMethodsHaveProperAuthorizationAnnotation() {\n         Set<Class<?>> authorizationResourceClasses = REFLECTIONS.getTypesAnnotatedWith(AuthorizationResource.class);\n-        Set<String> methodsWithoutAnnotation = Sets.newHashSet();\n-        authorizationResourceClasses.stream().forEach(authzClass -> Arrays.stream(authzClass.getDeclaredMethods())\n-            .filter(method -> Modifier.isPublic(method.getModifiers()) && !AuthorizationAnnotationUtils.getPossibleMethodAnnotations().stream()\n-                    .filter(annotation -> method.isAnnotationPresent(annotation)).findAny().isPresent())\n-            .forEach(method -> methodsWithoutAnnotation.add(authzClass.getSimpleName() + \"#\" + method.getName())));\n-\n-        assertTrue(\"These controller methods are missing any authorization related annotation: \"\n-                        + Joiner.on(\",\").join(methodsWithoutAnnotation), methodsWithoutAnnotation.size() == 0);\n+        List<String> validationErrors = authorizationResourceClasses\n+                .stream()\n+                .map(Class::getDeclaredMethods)\n+                .flatMap(Arrays::stream)\n+                .filter(method -> Modifier.isPublic(method.getModifiers()))\n+                .map(EnforceAuthorizationLogicsUtil::validateMethod)\n+                .flatMap(Collection::stream)\n+                .collect(toList());\n+        assertTrue(Joiner.on(System.lineSeparator()).join(validationErrors), validationErrors.isEmpty());\n+    }\n+\n+    private static List<String> validateMethod(Method method) {\n+        List<Class<? extends Annotation>> annotations = AuthorizationAnnotationUtils\n+                .getPossibleMethodAnnotations()\n+                .stream()\n+                .filter(method::isAnnotationPresent)\n+                .collect(toList());\n+        if (annotations.isEmpty()) {\n+            return List.of(invalid(method, \"Missing aithz annotation.\"));\n+        } else {\n+            return annotations\n+                    .stream()\n+                    .map(annotation -> METHOD_VALIDATORS.getOrDefault(annotation, unknownAnnotation(annotation)).apply(method))\n+                    .filter(Optional::isPresent)\n+                    .map(Optional::get)\n+                    .map(Object::toString)\n+                    .collect(toList());\n+        }\n+    }\n+\n+    private static String invalid(Method method, String reason) {\n+        return methodToString(method) + \": \" + reason;\n+    }\n+\n+    private static Function<Method, Optional<String>> noRestriction() {\n+        return method -> Optional.empty();\n+    }\n+\n+    private static Function<Method, Optional<String>> unknownAnnotation(Class<? extends Annotation> annotation) {\n+        return method -> Optional.of(invalid(method, \"No validation rule specified for \" + annotation));\n+    }\n+\n+    private static String methodToString(Method method) {\n+        return method.getDeclaringClass().getSimpleName() + '#' + method.getName();\n+    }\n+\n+    private static Function<Method, Optional<String>> hasParamWhere(Class<? extends Annotation> annotation,\n+            Function<Pair<Method, Class<?>>, Optional<String>> typeValidator) {\n+        return method -> {\n+            List<Optional<String>> validations = new ArrayList<>();\n+            for (Parameter parameter : method.getParameters()) {\n+                if (parameter.isAnnotationPresent(annotation)) {\n+                    validations.add(typeValidator.apply(Pair.of(method, parameter.getType())));\n+                }\n+            }\n+            String errorMessageCommon = \" method param with @\" + annotation.getSimpleName() + \" annotation\";\n+            if (validations.isEmpty()) {\n+                return Optional.of(invalid(method, \"Misssing\" + errorMessageCommon));\n+            } else if (validations.size() > 1) {\n+                return Optional.of(invalid(method, \"Multiple\" + errorMessageCommon));\n+            } else {\n+                return validations.get(0);\n+            }\n+        };\n+    }\n+\n+    private static Function<Method, Optional<String>> stringParam(Class<? extends Annotation> annotation) {\n+        return hasParam(annotation, String.class);\n+    }\n+\n+    private static Function<Method, Optional<String>> hasParam(Class<? extends Annotation> annotation, Class<?> type) {\n+        return method -> {\n+            int count = 0;\n+            for (Parameter parameter : method.getParameters()) {\n+                if (parameter.isAnnotationPresent(annotation) && type.equals(parameter.getType())) {\n+                    count++;\n+                }\n+            }\n+            String errorMessageCommon = \" method parameter with @\" + annotation.getSimpleName() + \" annotation and type \" + type.getSimpleName();\n+            if (count == 0) {\n+                return Optional.of(invalid(method, \"Misssing\" + errorMessageCommon));\n+            } else if (count > 1) {\n+                return Optional.of(invalid(method, \"Multiple\" + errorMessageCommon));\n+            } else {\n+                return Optional.empty();\n+            }\n+        };\n+    }\n+\n+    private static Function<Method, Optional<String>> noParamsWith(Class<? extends Annotation>... annotations) {\n+        return method -> {\n+            for (Parameter parameter : method.getParameters()) {\n+                for (Class<? extends Annotation> annotation : annotations) {\n+                    if (parameter.isAnnotationPresent(annotation)) {\n+                        Optional.of(invalid(method, '@' + annotation.getSimpleName() + \" annotation is not allowed here\"));\n+                    }\n+                }\n+            }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6ad0d8b96f5be7152950c53c4bd806c4e6fa78fc"}, "originalPosition": 218}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDI5NzIzNA==", "bodyText": "yes", "url": "https://github.com/hortonworks/cloudbreak/pull/8283#discussion_r440297234", "createdAt": "2020-06-15T16:24:48Z", "author": {"login": "foldik"}, "path": "authorization-common/src/test/java/com/sequenceiq/authorization/EnforceAuthorizationLogicsUtil.java", "diffHunk": "@@ -62,18 +124,239 @@ public static void testIfControllerClassHasAuthorizationAnnotation() {\n         Set<String> controllersWithoutAnnotation = Sets.difference(controllersClasses, Sets.union(authorizationResourceClasses, disabledAuthorizationClasses));\n \n         assertTrue(\"These controllers are missing @AuthorizationResource annotation: \" + Joiner.on(\",\").join(controllersWithoutAnnotation),\n-                controllersWithoutAnnotation.size() == 0);\n+                controllersWithoutAnnotation.isEmpty());\n     }\n \n     public static void testIfControllerMethodsHaveProperAuthorizationAnnotation() {\n         Set<Class<?>> authorizationResourceClasses = REFLECTIONS.getTypesAnnotatedWith(AuthorizationResource.class);\n-        Set<String> methodsWithoutAnnotation = Sets.newHashSet();\n-        authorizationResourceClasses.stream().forEach(authzClass -> Arrays.stream(authzClass.getDeclaredMethods())\n-            .filter(method -> Modifier.isPublic(method.getModifiers()) && !AuthorizationAnnotationUtils.getPossibleMethodAnnotations().stream()\n-                    .filter(annotation -> method.isAnnotationPresent(annotation)).findAny().isPresent())\n-            .forEach(method -> methodsWithoutAnnotation.add(authzClass.getSimpleName() + \"#\" + method.getName())));\n-\n-        assertTrue(\"These controller methods are missing any authorization related annotation: \"\n-                        + Joiner.on(\",\").join(methodsWithoutAnnotation), methodsWithoutAnnotation.size() == 0);\n+        List<String> validationErrors = authorizationResourceClasses\n+                .stream()\n+                .map(Class::getDeclaredMethods)\n+                .flatMap(Arrays::stream)\n+                .filter(method -> Modifier.isPublic(method.getModifiers()))\n+                .map(EnforceAuthorizationLogicsUtil::validateMethod)\n+                .flatMap(Collection::stream)\n+                .collect(toList());\n+        assertTrue(Joiner.on(System.lineSeparator()).join(validationErrors), validationErrors.isEmpty());\n+    }\n+\n+    private static List<String> validateMethod(Method method) {\n+        List<Class<? extends Annotation>> annotations = AuthorizationAnnotationUtils\n+                .getPossibleMethodAnnotations()\n+                .stream()\n+                .filter(method::isAnnotationPresent)\n+                .collect(toList());\n+        if (annotations.isEmpty()) {\n+            return List.of(invalid(method, \"Missing aithz annotation.\"));\n+        } else {\n+            return annotations\n+                    .stream()\n+                    .map(annotation -> METHOD_VALIDATORS.getOrDefault(annotation, unknownAnnotation(annotation)).apply(method))\n+                    .filter(Optional::isPresent)\n+                    .map(Optional::get)\n+                    .map(Object::toString)\n+                    .collect(toList());\n+        }\n+    }\n+\n+    private static String invalid(Method method, String reason) {\n+        return methodToString(method) + \": \" + reason;\n+    }\n+\n+    private static Function<Method, Optional<String>> noRestriction() {\n+        return method -> Optional.empty();\n+    }\n+\n+    private static Function<Method, Optional<String>> unknownAnnotation(Class<? extends Annotation> annotation) {\n+        return method -> Optional.of(invalid(method, \"No validation rule specified for \" + annotation));\n+    }\n+\n+    private static String methodToString(Method method) {\n+        return method.getDeclaringClass().getSimpleName() + '#' + method.getName();\n+    }\n+\n+    private static Function<Method, Optional<String>> hasParamWhere(Class<? extends Annotation> annotation,\n+            Function<Pair<Method, Class<?>>, Optional<String>> typeValidator) {\n+        return method -> {\n+            List<Optional<String>> validations = new ArrayList<>();\n+            for (Parameter parameter : method.getParameters()) {\n+                if (parameter.isAnnotationPresent(annotation)) {\n+                    validations.add(typeValidator.apply(Pair.of(method, parameter.getType())));\n+                }\n+            }\n+            String errorMessageCommon = \" method param with @\" + annotation.getSimpleName() + \" annotation\";\n+            if (validations.isEmpty()) {\n+                return Optional.of(invalid(method, \"Misssing\" + errorMessageCommon));\n+            } else if (validations.size() > 1) {\n+                return Optional.of(invalid(method, \"Multiple\" + errorMessageCommon));\n+            } else {\n+                return validations.get(0);\n+            }\n+        };\n+    }\n+\n+    private static Function<Method, Optional<String>> stringParam(Class<? extends Annotation> annotation) {\n+        return hasParam(annotation, String.class);\n+    }\n+\n+    private static Function<Method, Optional<String>> hasParam(Class<? extends Annotation> annotation, Class<?> type) {\n+        return method -> {\n+            int count = 0;\n+            for (Parameter parameter : method.getParameters()) {\n+                if (parameter.isAnnotationPresent(annotation) && type.equals(parameter.getType())) {\n+                    count++;\n+                }\n+            }\n+            String errorMessageCommon = \" method parameter with @\" + annotation.getSimpleName() + \" annotation and type \" + type.getSimpleName();\n+            if (count == 0) {\n+                return Optional.of(invalid(method, \"Misssing\" + errorMessageCommon));\n+            } else if (count > 1) {\n+                return Optional.of(invalid(method, \"Multiple\" + errorMessageCommon));\n+            } else {\n+                return Optional.empty();\n+            }\n+        };\n+    }\n+\n+    private static Function<Method, Optional<String>> noParamsWith(Class<? extends Annotation>... annotations) {\n+        return method -> {\n+            for (Parameter parameter : method.getParameters()) {\n+                for (Class<? extends Annotation> annotation : annotations) {\n+                    if (parameter.isAnnotationPresent(annotation)) {\n+                        Optional.of(invalid(method, '@' + annotation.getSimpleName() + \" annotation is not allowed here\"));\n+                    }\n+                }\n+            }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDI4ODYzMw=="}, "originalCommit": {"oid": "6ad0d8b96f5be7152950c53c4bd806c4e6fa78fc"}, "originalPosition": 218}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc0MzExMDY3OnYy", "diffSide": "RIGHT", "path": "authorization-common/src/test/java/com/sequenceiq/authorization/EnforceAuthorizationLogicsUtil.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNVQxNjoxMToxOFrOGj5GHA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNVQxNjoyNDo1NFrOGj5nTg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDI4ODc5Ng==", "bodyText": "same here", "url": "https://github.com/hortonworks/cloudbreak/pull/8283#discussion_r440288796", "createdAt": "2020-06-15T16:11:18Z", "author": {"login": "horadla23"}, "path": "authorization-common/src/test/java/com/sequenceiq/authorization/EnforceAuthorizationLogicsUtil.java", "diffHunk": "@@ -62,18 +124,239 @@ public static void testIfControllerClassHasAuthorizationAnnotation() {\n         Set<String> controllersWithoutAnnotation = Sets.difference(controllersClasses, Sets.union(authorizationResourceClasses, disabledAuthorizationClasses));\n \n         assertTrue(\"These controllers are missing @AuthorizationResource annotation: \" + Joiner.on(\",\").join(controllersWithoutAnnotation),\n-                controllersWithoutAnnotation.size() == 0);\n+                controllersWithoutAnnotation.isEmpty());\n     }\n \n     public static void testIfControllerMethodsHaveProperAuthorizationAnnotation() {\n         Set<Class<?>> authorizationResourceClasses = REFLECTIONS.getTypesAnnotatedWith(AuthorizationResource.class);\n-        Set<String> methodsWithoutAnnotation = Sets.newHashSet();\n-        authorizationResourceClasses.stream().forEach(authzClass -> Arrays.stream(authzClass.getDeclaredMethods())\n-            .filter(method -> Modifier.isPublic(method.getModifiers()) && !AuthorizationAnnotationUtils.getPossibleMethodAnnotations().stream()\n-                    .filter(annotation -> method.isAnnotationPresent(annotation)).findAny().isPresent())\n-            .forEach(method -> methodsWithoutAnnotation.add(authzClass.getSimpleName() + \"#\" + method.getName())));\n-\n-        assertTrue(\"These controller methods are missing any authorization related annotation: \"\n-                        + Joiner.on(\",\").join(methodsWithoutAnnotation), methodsWithoutAnnotation.size() == 0);\n+        List<String> validationErrors = authorizationResourceClasses\n+                .stream()\n+                .map(Class::getDeclaredMethods)\n+                .flatMap(Arrays::stream)\n+                .filter(method -> Modifier.isPublic(method.getModifiers()))\n+                .map(EnforceAuthorizationLogicsUtil::validateMethod)\n+                .flatMap(Collection::stream)\n+                .collect(toList());\n+        assertTrue(Joiner.on(System.lineSeparator()).join(validationErrors), validationErrors.isEmpty());\n+    }\n+\n+    private static List<String> validateMethod(Method method) {\n+        List<Class<? extends Annotation>> annotations = AuthorizationAnnotationUtils\n+                .getPossibleMethodAnnotations()\n+                .stream()\n+                .filter(method::isAnnotationPresent)\n+                .collect(toList());\n+        if (annotations.isEmpty()) {\n+            return List.of(invalid(method, \"Missing aithz annotation.\"));\n+        } else {\n+            return annotations\n+                    .stream()\n+                    .map(annotation -> METHOD_VALIDATORS.getOrDefault(annotation, unknownAnnotation(annotation)).apply(method))\n+                    .filter(Optional::isPresent)\n+                    .map(Optional::get)\n+                    .map(Object::toString)\n+                    .collect(toList());\n+        }\n+    }\n+\n+    private static String invalid(Method method, String reason) {\n+        return methodToString(method) + \": \" + reason;\n+    }\n+\n+    private static Function<Method, Optional<String>> noRestriction() {\n+        return method -> Optional.empty();\n+    }\n+\n+    private static Function<Method, Optional<String>> unknownAnnotation(Class<? extends Annotation> annotation) {\n+        return method -> Optional.of(invalid(method, \"No validation rule specified for \" + annotation));\n+    }\n+\n+    private static String methodToString(Method method) {\n+        return method.getDeclaringClass().getSimpleName() + '#' + method.getName();\n+    }\n+\n+    private static Function<Method, Optional<String>> hasParamWhere(Class<? extends Annotation> annotation,\n+            Function<Pair<Method, Class<?>>, Optional<String>> typeValidator) {\n+        return method -> {\n+            List<Optional<String>> validations = new ArrayList<>();\n+            for (Parameter parameter : method.getParameters()) {\n+                if (parameter.isAnnotationPresent(annotation)) {\n+                    validations.add(typeValidator.apply(Pair.of(method, parameter.getType())));\n+                }\n+            }\n+            String errorMessageCommon = \" method param with @\" + annotation.getSimpleName() + \" annotation\";\n+            if (validations.isEmpty()) {\n+                return Optional.of(invalid(method, \"Misssing\" + errorMessageCommon));\n+            } else if (validations.size() > 1) {\n+                return Optional.of(invalid(method, \"Multiple\" + errorMessageCommon));\n+            } else {\n+                return validations.get(0);\n+            }\n+        };\n+    }\n+\n+    private static Function<Method, Optional<String>> stringParam(Class<? extends Annotation> annotation) {\n+        return hasParam(annotation, String.class);\n+    }\n+\n+    private static Function<Method, Optional<String>> hasParam(Class<? extends Annotation> annotation, Class<?> type) {\n+        return method -> {\n+            int count = 0;\n+            for (Parameter parameter : method.getParameters()) {\n+                if (parameter.isAnnotationPresent(annotation) && type.equals(parameter.getType())) {\n+                    count++;\n+                }\n+            }\n+            String errorMessageCommon = \" method parameter with @\" + annotation.getSimpleName() + \" annotation and type \" + type.getSimpleName();\n+            if (count == 0) {\n+                return Optional.of(invalid(method, \"Misssing\" + errorMessageCommon));\n+            } else if (count > 1) {\n+                return Optional.of(invalid(method, \"Multiple\" + errorMessageCommon));\n+            } else {\n+                return Optional.empty();\n+            }\n+        };\n+    }\n+\n+    private static Function<Method, Optional<String>> noParamsWith(Class<? extends Annotation>... annotations) {\n+        return method -> {\n+            for (Parameter parameter : method.getParameters()) {\n+                for (Class<? extends Annotation> annotation : annotations) {\n+                    if (parameter.isAnnotationPresent(annotation)) {\n+                        Optional.of(invalid(method, '@' + annotation.getSimpleName() + \" annotation is not allowed here\"));\n+                    }\n+                }\n+            }\n+            return Optional.empty();\n+        };\n+    }\n+\n+    private static Function<Method, Optional<String>> anyCollectionFrom(Class<? extends Annotation> annotation, Generic... genericTypes) {\n+        return method -> {\n+            int count = 0;\n+            for (Parameter parameter : method.getParameters()) {\n+                if (parameter.isAnnotationPresent(annotation)) {\n+                    for (Generic generic : genericTypes) {\n+                        if (generic.wrapperType.isAssignableFrom(parameter.getType())) {\n+                            Type[] actualTypeArguments = ((ParameterizedType) parameter.getParameterizedType()).getActualTypeArguments();\n+                            if (actualTypeArguments.length == 1 && actualTypeArguments[0].equals(generic.genericType)) {\n+                                count++;\n+                            }\n+                        }\n+                    }\n+                }\n+            }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6ad0d8b96f5be7152950c53c4bd806c4e6fa78fc"}, "originalPosition": 237}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDI5NzI5NA==", "bodyText": "yes", "url": "https://github.com/hortonworks/cloudbreak/pull/8283#discussion_r440297294", "createdAt": "2020-06-15T16:24:54Z", "author": {"login": "foldik"}, "path": "authorization-common/src/test/java/com/sequenceiq/authorization/EnforceAuthorizationLogicsUtil.java", "diffHunk": "@@ -62,18 +124,239 @@ public static void testIfControllerClassHasAuthorizationAnnotation() {\n         Set<String> controllersWithoutAnnotation = Sets.difference(controllersClasses, Sets.union(authorizationResourceClasses, disabledAuthorizationClasses));\n \n         assertTrue(\"These controllers are missing @AuthorizationResource annotation: \" + Joiner.on(\",\").join(controllersWithoutAnnotation),\n-                controllersWithoutAnnotation.size() == 0);\n+                controllersWithoutAnnotation.isEmpty());\n     }\n \n     public static void testIfControllerMethodsHaveProperAuthorizationAnnotation() {\n         Set<Class<?>> authorizationResourceClasses = REFLECTIONS.getTypesAnnotatedWith(AuthorizationResource.class);\n-        Set<String> methodsWithoutAnnotation = Sets.newHashSet();\n-        authorizationResourceClasses.stream().forEach(authzClass -> Arrays.stream(authzClass.getDeclaredMethods())\n-            .filter(method -> Modifier.isPublic(method.getModifiers()) && !AuthorizationAnnotationUtils.getPossibleMethodAnnotations().stream()\n-                    .filter(annotation -> method.isAnnotationPresent(annotation)).findAny().isPresent())\n-            .forEach(method -> methodsWithoutAnnotation.add(authzClass.getSimpleName() + \"#\" + method.getName())));\n-\n-        assertTrue(\"These controller methods are missing any authorization related annotation: \"\n-                        + Joiner.on(\",\").join(methodsWithoutAnnotation), methodsWithoutAnnotation.size() == 0);\n+        List<String> validationErrors = authorizationResourceClasses\n+                .stream()\n+                .map(Class::getDeclaredMethods)\n+                .flatMap(Arrays::stream)\n+                .filter(method -> Modifier.isPublic(method.getModifiers()))\n+                .map(EnforceAuthorizationLogicsUtil::validateMethod)\n+                .flatMap(Collection::stream)\n+                .collect(toList());\n+        assertTrue(Joiner.on(System.lineSeparator()).join(validationErrors), validationErrors.isEmpty());\n+    }\n+\n+    private static List<String> validateMethod(Method method) {\n+        List<Class<? extends Annotation>> annotations = AuthorizationAnnotationUtils\n+                .getPossibleMethodAnnotations()\n+                .stream()\n+                .filter(method::isAnnotationPresent)\n+                .collect(toList());\n+        if (annotations.isEmpty()) {\n+            return List.of(invalid(method, \"Missing aithz annotation.\"));\n+        } else {\n+            return annotations\n+                    .stream()\n+                    .map(annotation -> METHOD_VALIDATORS.getOrDefault(annotation, unknownAnnotation(annotation)).apply(method))\n+                    .filter(Optional::isPresent)\n+                    .map(Optional::get)\n+                    .map(Object::toString)\n+                    .collect(toList());\n+        }\n+    }\n+\n+    private static String invalid(Method method, String reason) {\n+        return methodToString(method) + \": \" + reason;\n+    }\n+\n+    private static Function<Method, Optional<String>> noRestriction() {\n+        return method -> Optional.empty();\n+    }\n+\n+    private static Function<Method, Optional<String>> unknownAnnotation(Class<? extends Annotation> annotation) {\n+        return method -> Optional.of(invalid(method, \"No validation rule specified for \" + annotation));\n+    }\n+\n+    private static String methodToString(Method method) {\n+        return method.getDeclaringClass().getSimpleName() + '#' + method.getName();\n+    }\n+\n+    private static Function<Method, Optional<String>> hasParamWhere(Class<? extends Annotation> annotation,\n+            Function<Pair<Method, Class<?>>, Optional<String>> typeValidator) {\n+        return method -> {\n+            List<Optional<String>> validations = new ArrayList<>();\n+            for (Parameter parameter : method.getParameters()) {\n+                if (parameter.isAnnotationPresent(annotation)) {\n+                    validations.add(typeValidator.apply(Pair.of(method, parameter.getType())));\n+                }\n+            }\n+            String errorMessageCommon = \" method param with @\" + annotation.getSimpleName() + \" annotation\";\n+            if (validations.isEmpty()) {\n+                return Optional.of(invalid(method, \"Misssing\" + errorMessageCommon));\n+            } else if (validations.size() > 1) {\n+                return Optional.of(invalid(method, \"Multiple\" + errorMessageCommon));\n+            } else {\n+                return validations.get(0);\n+            }\n+        };\n+    }\n+\n+    private static Function<Method, Optional<String>> stringParam(Class<? extends Annotation> annotation) {\n+        return hasParam(annotation, String.class);\n+    }\n+\n+    private static Function<Method, Optional<String>> hasParam(Class<? extends Annotation> annotation, Class<?> type) {\n+        return method -> {\n+            int count = 0;\n+            for (Parameter parameter : method.getParameters()) {\n+                if (parameter.isAnnotationPresent(annotation) && type.equals(parameter.getType())) {\n+                    count++;\n+                }\n+            }\n+            String errorMessageCommon = \" method parameter with @\" + annotation.getSimpleName() + \" annotation and type \" + type.getSimpleName();\n+            if (count == 0) {\n+                return Optional.of(invalid(method, \"Misssing\" + errorMessageCommon));\n+            } else if (count > 1) {\n+                return Optional.of(invalid(method, \"Multiple\" + errorMessageCommon));\n+            } else {\n+                return Optional.empty();\n+            }\n+        };\n+    }\n+\n+    private static Function<Method, Optional<String>> noParamsWith(Class<? extends Annotation>... annotations) {\n+        return method -> {\n+            for (Parameter parameter : method.getParameters()) {\n+                for (Class<? extends Annotation> annotation : annotations) {\n+                    if (parameter.isAnnotationPresent(annotation)) {\n+                        Optional.of(invalid(method, '@' + annotation.getSimpleName() + \" annotation is not allowed here\"));\n+                    }\n+                }\n+            }\n+            return Optional.empty();\n+        };\n+    }\n+\n+    private static Function<Method, Optional<String>> anyCollectionFrom(Class<? extends Annotation> annotation, Generic... genericTypes) {\n+        return method -> {\n+            int count = 0;\n+            for (Parameter parameter : method.getParameters()) {\n+                if (parameter.isAnnotationPresent(annotation)) {\n+                    for (Generic generic : genericTypes) {\n+                        if (generic.wrapperType.isAssignableFrom(parameter.getType())) {\n+                            Type[] actualTypeArguments = ((ParameterizedType) parameter.getParameterizedType()).getActualTypeArguments();\n+                            if (actualTypeArguments.length == 1 && actualTypeArguments[0].equals(generic.genericType)) {\n+                                count++;\n+                            }\n+                        }\n+                    }\n+                }\n+            }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDI4ODc5Ng=="}, "originalCommit": {"oid": "6ad0d8b96f5be7152950c53c4bd806c4e6fa78fc"}, "originalPosition": 237}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc0MzEyOTA4OnYy", "diffSide": "RIGHT", "path": "authorization-common/src/test/java/com/sequenceiq/authorization/EnforceAuthorizationLogicsUtil.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNVQxNjoxNTo0NlrOGj5RIw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNVQxNjoyNTowOFrOGj5n1g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDI5MTYxOQ==", "bodyText": "can we extract this into different class with more specific name?", "url": "https://github.com/hortonworks/cloudbreak/pull/8283#discussion_r440291619", "createdAt": "2020-06-15T16:15:46Z", "author": {"login": "horadla23"}, "path": "authorization-common/src/test/java/com/sequenceiq/authorization/EnforceAuthorizationLogicsUtil.java", "diffHunk": "@@ -62,18 +124,239 @@ public static void testIfControllerClassHasAuthorizationAnnotation() {\n         Set<String> controllersWithoutAnnotation = Sets.difference(controllersClasses, Sets.union(authorizationResourceClasses, disabledAuthorizationClasses));\n \n         assertTrue(\"These controllers are missing @AuthorizationResource annotation: \" + Joiner.on(\",\").join(controllersWithoutAnnotation),\n-                controllersWithoutAnnotation.size() == 0);\n+                controllersWithoutAnnotation.isEmpty());\n     }\n \n     public static void testIfControllerMethodsHaveProperAuthorizationAnnotation() {\n         Set<Class<?>> authorizationResourceClasses = REFLECTIONS.getTypesAnnotatedWith(AuthorizationResource.class);\n-        Set<String> methodsWithoutAnnotation = Sets.newHashSet();\n-        authorizationResourceClasses.stream().forEach(authzClass -> Arrays.stream(authzClass.getDeclaredMethods())\n-            .filter(method -> Modifier.isPublic(method.getModifiers()) && !AuthorizationAnnotationUtils.getPossibleMethodAnnotations().stream()\n-                    .filter(annotation -> method.isAnnotationPresent(annotation)).findAny().isPresent())\n-            .forEach(method -> methodsWithoutAnnotation.add(authzClass.getSimpleName() + \"#\" + method.getName())));\n-\n-        assertTrue(\"These controller methods are missing any authorization related annotation: \"\n-                        + Joiner.on(\",\").join(methodsWithoutAnnotation), methodsWithoutAnnotation.size() == 0);\n+        List<String> validationErrors = authorizationResourceClasses\n+                .stream()\n+                .map(Class::getDeclaredMethods)\n+                .flatMap(Arrays::stream)\n+                .filter(method -> Modifier.isPublic(method.getModifiers()))\n+                .map(EnforceAuthorizationLogicsUtil::validateMethod)\n+                .flatMap(Collection::stream)\n+                .collect(toList());\n+        assertTrue(Joiner.on(System.lineSeparator()).join(validationErrors), validationErrors.isEmpty());\n+    }\n+\n+    private static List<String> validateMethod(Method method) {\n+        List<Class<? extends Annotation>> annotations = AuthorizationAnnotationUtils\n+                .getPossibleMethodAnnotations()\n+                .stream()\n+                .filter(method::isAnnotationPresent)\n+                .collect(toList());\n+        if (annotations.isEmpty()) {\n+            return List.of(invalid(method, \"Missing aithz annotation.\"));\n+        } else {\n+            return annotations\n+                    .stream()\n+                    .map(annotation -> METHOD_VALIDATORS.getOrDefault(annotation, unknownAnnotation(annotation)).apply(method))\n+                    .filter(Optional::isPresent)\n+                    .map(Optional::get)\n+                    .map(Object::toString)\n+                    .collect(toList());\n+        }\n+    }\n+\n+    private static String invalid(Method method, String reason) {\n+        return methodToString(method) + \": \" + reason;\n+    }\n+\n+    private static Function<Method, Optional<String>> noRestriction() {\n+        return method -> Optional.empty();\n+    }\n+\n+    private static Function<Method, Optional<String>> unknownAnnotation(Class<? extends Annotation> annotation) {\n+        return method -> Optional.of(invalid(method, \"No validation rule specified for \" + annotation));\n+    }\n+\n+    private static String methodToString(Method method) {\n+        return method.getDeclaringClass().getSimpleName() + '#' + method.getName();\n+    }\n+\n+    private static Function<Method, Optional<String>> hasParamWhere(Class<? extends Annotation> annotation,\n+            Function<Pair<Method, Class<?>>, Optional<String>> typeValidator) {\n+        return method -> {\n+            List<Optional<String>> validations = new ArrayList<>();\n+            for (Parameter parameter : method.getParameters()) {\n+                if (parameter.isAnnotationPresent(annotation)) {\n+                    validations.add(typeValidator.apply(Pair.of(method, parameter.getType())));\n+                }\n+            }\n+            String errorMessageCommon = \" method param with @\" + annotation.getSimpleName() + \" annotation\";\n+            if (validations.isEmpty()) {\n+                return Optional.of(invalid(method, \"Misssing\" + errorMessageCommon));\n+            } else if (validations.size() > 1) {\n+                return Optional.of(invalid(method, \"Multiple\" + errorMessageCommon));\n+            } else {\n+                return validations.get(0);\n+            }\n+        };\n+    }\n+\n+    private static Function<Method, Optional<String>> stringParam(Class<? extends Annotation> annotation) {\n+        return hasParam(annotation, String.class);\n+    }\n+\n+    private static Function<Method, Optional<String>> hasParam(Class<? extends Annotation> annotation, Class<?> type) {\n+        return method -> {\n+            int count = 0;\n+            for (Parameter parameter : method.getParameters()) {\n+                if (parameter.isAnnotationPresent(annotation) && type.equals(parameter.getType())) {\n+                    count++;\n+                }\n+            }\n+            String errorMessageCommon = \" method parameter with @\" + annotation.getSimpleName() + \" annotation and type \" + type.getSimpleName();\n+            if (count == 0) {\n+                return Optional.of(invalid(method, \"Misssing\" + errorMessageCommon));\n+            } else if (count > 1) {\n+                return Optional.of(invalid(method, \"Multiple\" + errorMessageCommon));\n+            } else {\n+                return Optional.empty();\n+            }\n+        };\n+    }\n+\n+    private static Function<Method, Optional<String>> noParamsWith(Class<? extends Annotation>... annotations) {\n+        return method -> {\n+            for (Parameter parameter : method.getParameters()) {\n+                for (Class<? extends Annotation> annotation : annotations) {\n+                    if (parameter.isAnnotationPresent(annotation)) {\n+                        Optional.of(invalid(method, '@' + annotation.getSimpleName() + \" annotation is not allowed here\"));\n+                    }\n+                }\n+            }\n+            return Optional.empty();\n+        };\n+    }\n+\n+    private static Function<Method, Optional<String>> anyCollectionFrom(Class<? extends Annotation> annotation, Generic... genericTypes) {\n+        return method -> {\n+            int count = 0;\n+            for (Parameter parameter : method.getParameters()) {\n+                if (parameter.isAnnotationPresent(annotation)) {\n+                    for (Generic generic : genericTypes) {\n+                        if (generic.wrapperType.isAssignableFrom(parameter.getType())) {\n+                            Type[] actualTypeArguments = ((ParameterizedType) parameter.getParameterizedType()).getActualTypeArguments();\n+                            if (actualTypeArguments.length == 1 && actualTypeArguments[0].equals(generic.genericType)) {\n+                                count++;\n+                            }\n+                        }\n+                    }\n+                }\n+            }\n+            String errorMessageCommon = \" method parameter with @\" + annotation.getSimpleName() + \" annotation and type from \" +\n+                    Arrays.stream(genericTypes)\n+                            .map(Generic::toString)\n+                            .collect(Collectors.joining(\",\", \"[\", \"]\"));\n+            if (count == 0) {\n+                return Optional.of(invalid(method, \"Misssing\" + errorMessageCommon));\n+            } else if (count > 1) {\n+                return Optional.of(invalid(method, \"Multiple\" + errorMessageCommon));\n+            } else {\n+                return Optional.empty();\n+            }\n+        };\n+    }\n+\n+    private static Function<Method, Optional<String>> returnsAnyOf(Generic... genericTypes) {\n+        return method -> {\n+            int count = 0;\n+            for (Generic generic : genericTypes) {\n+                if (generic.wrapperType.isAssignableFrom(method.getReturnType())) {\n+                    Type[] actualTypeArguments;\n+                    if (method.getReturnType().getSuperclass() == null) {\n+                        actualTypeArguments = ((ParameterizedType) method.getGenericReturnType()).getActualTypeArguments();\n+                    } else {\n+                        actualTypeArguments = ((ParameterizedType) method.getReturnType().getGenericSuperclass()).getActualTypeArguments();\n+                    }\n+                    if (actualTypeArguments.length == 1 && generic.genericType.isAssignableFrom((Class<?>) actualTypeArguments[0])) {\n+                        count++;\n+                    }\n+                }\n+            }\n+            String errorMessage = \"Return \" + method.getReturnType().getSimpleName() + \" type is not one of\" +\n+                    Arrays.stream(genericTypes)\n+                            .map(Generic::toString)\n+                            .collect(Collectors.joining(\",\", \"[\", \"]\"));\n+            if (count != 1) {\n+                return Optional.of(invalid(method, errorMessage));\n+            } else {\n+                return Optional.empty();\n+            }\n+        };\n+    }\n+\n+    private static Function<Pair<Method, Class<?>>, Optional<String>> resourceObject() {\n+        return ctx -> {\n+            Method method = ctx.getKey();\n+            Class<?> type = ctx.getValue();\n+            boolean hasValidField = false;\n+            for (Field field : FieldUtils.getFieldsWithAnnotation(type, ResourceObjectField.class)) {\n+                ResourceObjectField annotation = field.getAnnotation(ResourceObjectField.class);\n+                if (Set.of(CRN, NAME).contains(annotation.variableType())) {\n+                    if (String.class.equals(field.getType())) {\n+                        hasValidField = true;\n+                    } else {\n+                        return Optional.of(invalid(method, field.getName()\n+                                + \" @\" + ResourceObjectField.class + \" must be a String in \" + type.getSimpleName()));\n+                    }\n+                } else if (Set.of(CRN_LIST, NAME_LIST).contains(annotation.variableType())) {\n+                    if (isOneOf(field, list(String.class), set(String.class))) {\n+                        hasValidField = true;\n+                    } else {\n+                        return Optional.of(invalid(method, field.getName()\n+                                + \" @\" + ResourceObjectField.class + \" must be a Set<String> or List<String> in \" + type.getSimpleName()));\n+                    }\n+                }\n+            }\n+            if (hasValidField) {\n+                return Optional.empty();\n+            } else {\n+                return Optional.of(invalid(method, \"Missing @\" + ResourceObjectField.class + \" annotaion in \" + type.getSimpleName()));\n+            }\n+        };\n+    }\n+\n+    private static boolean isOneOf(Field field, Generic... genericTypes) {\n+        for (Generic generic : genericTypes) {\n+            if (generic.wrapperType.isAssignableFrom(field.getType())) {\n+                Type[] actualTypeArguments = ((ParameterizedType) field.getGenericType()).getActualTypeArguments();\n+                if (actualTypeArguments.length == 1 && actualTypeArguments[0].equals(generic.genericType)) {\n+                    return true;\n+                }\n+            }\n+        }\n+        return false;\n+    }\n+\n+    public static class Generic {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6ad0d8b96f5be7152950c53c4bd806c4e6fa78fc"}, "originalPosition": 323}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDI5NzQzMA==", "bodyText": "yep", "url": "https://github.com/hortonworks/cloudbreak/pull/8283#discussion_r440297430", "createdAt": "2020-06-15T16:25:08Z", "author": {"login": "foldik"}, "path": "authorization-common/src/test/java/com/sequenceiq/authorization/EnforceAuthorizationLogicsUtil.java", "diffHunk": "@@ -62,18 +124,239 @@ public static void testIfControllerClassHasAuthorizationAnnotation() {\n         Set<String> controllersWithoutAnnotation = Sets.difference(controllersClasses, Sets.union(authorizationResourceClasses, disabledAuthorizationClasses));\n \n         assertTrue(\"These controllers are missing @AuthorizationResource annotation: \" + Joiner.on(\",\").join(controllersWithoutAnnotation),\n-                controllersWithoutAnnotation.size() == 0);\n+                controllersWithoutAnnotation.isEmpty());\n     }\n \n     public static void testIfControllerMethodsHaveProperAuthorizationAnnotation() {\n         Set<Class<?>> authorizationResourceClasses = REFLECTIONS.getTypesAnnotatedWith(AuthorizationResource.class);\n-        Set<String> methodsWithoutAnnotation = Sets.newHashSet();\n-        authorizationResourceClasses.stream().forEach(authzClass -> Arrays.stream(authzClass.getDeclaredMethods())\n-            .filter(method -> Modifier.isPublic(method.getModifiers()) && !AuthorizationAnnotationUtils.getPossibleMethodAnnotations().stream()\n-                    .filter(annotation -> method.isAnnotationPresent(annotation)).findAny().isPresent())\n-            .forEach(method -> methodsWithoutAnnotation.add(authzClass.getSimpleName() + \"#\" + method.getName())));\n-\n-        assertTrue(\"These controller methods are missing any authorization related annotation: \"\n-                        + Joiner.on(\",\").join(methodsWithoutAnnotation), methodsWithoutAnnotation.size() == 0);\n+        List<String> validationErrors = authorizationResourceClasses\n+                .stream()\n+                .map(Class::getDeclaredMethods)\n+                .flatMap(Arrays::stream)\n+                .filter(method -> Modifier.isPublic(method.getModifiers()))\n+                .map(EnforceAuthorizationLogicsUtil::validateMethod)\n+                .flatMap(Collection::stream)\n+                .collect(toList());\n+        assertTrue(Joiner.on(System.lineSeparator()).join(validationErrors), validationErrors.isEmpty());\n+    }\n+\n+    private static List<String> validateMethod(Method method) {\n+        List<Class<? extends Annotation>> annotations = AuthorizationAnnotationUtils\n+                .getPossibleMethodAnnotations()\n+                .stream()\n+                .filter(method::isAnnotationPresent)\n+                .collect(toList());\n+        if (annotations.isEmpty()) {\n+            return List.of(invalid(method, \"Missing aithz annotation.\"));\n+        } else {\n+            return annotations\n+                    .stream()\n+                    .map(annotation -> METHOD_VALIDATORS.getOrDefault(annotation, unknownAnnotation(annotation)).apply(method))\n+                    .filter(Optional::isPresent)\n+                    .map(Optional::get)\n+                    .map(Object::toString)\n+                    .collect(toList());\n+        }\n+    }\n+\n+    private static String invalid(Method method, String reason) {\n+        return methodToString(method) + \": \" + reason;\n+    }\n+\n+    private static Function<Method, Optional<String>> noRestriction() {\n+        return method -> Optional.empty();\n+    }\n+\n+    private static Function<Method, Optional<String>> unknownAnnotation(Class<? extends Annotation> annotation) {\n+        return method -> Optional.of(invalid(method, \"No validation rule specified for \" + annotation));\n+    }\n+\n+    private static String methodToString(Method method) {\n+        return method.getDeclaringClass().getSimpleName() + '#' + method.getName();\n+    }\n+\n+    private static Function<Method, Optional<String>> hasParamWhere(Class<? extends Annotation> annotation,\n+            Function<Pair<Method, Class<?>>, Optional<String>> typeValidator) {\n+        return method -> {\n+            List<Optional<String>> validations = new ArrayList<>();\n+            for (Parameter parameter : method.getParameters()) {\n+                if (parameter.isAnnotationPresent(annotation)) {\n+                    validations.add(typeValidator.apply(Pair.of(method, parameter.getType())));\n+                }\n+            }\n+            String errorMessageCommon = \" method param with @\" + annotation.getSimpleName() + \" annotation\";\n+            if (validations.isEmpty()) {\n+                return Optional.of(invalid(method, \"Misssing\" + errorMessageCommon));\n+            } else if (validations.size() > 1) {\n+                return Optional.of(invalid(method, \"Multiple\" + errorMessageCommon));\n+            } else {\n+                return validations.get(0);\n+            }\n+        };\n+    }\n+\n+    private static Function<Method, Optional<String>> stringParam(Class<? extends Annotation> annotation) {\n+        return hasParam(annotation, String.class);\n+    }\n+\n+    private static Function<Method, Optional<String>> hasParam(Class<? extends Annotation> annotation, Class<?> type) {\n+        return method -> {\n+            int count = 0;\n+            for (Parameter parameter : method.getParameters()) {\n+                if (parameter.isAnnotationPresent(annotation) && type.equals(parameter.getType())) {\n+                    count++;\n+                }\n+            }\n+            String errorMessageCommon = \" method parameter with @\" + annotation.getSimpleName() + \" annotation and type \" + type.getSimpleName();\n+            if (count == 0) {\n+                return Optional.of(invalid(method, \"Misssing\" + errorMessageCommon));\n+            } else if (count > 1) {\n+                return Optional.of(invalid(method, \"Multiple\" + errorMessageCommon));\n+            } else {\n+                return Optional.empty();\n+            }\n+        };\n+    }\n+\n+    private static Function<Method, Optional<String>> noParamsWith(Class<? extends Annotation>... annotations) {\n+        return method -> {\n+            for (Parameter parameter : method.getParameters()) {\n+                for (Class<? extends Annotation> annotation : annotations) {\n+                    if (parameter.isAnnotationPresent(annotation)) {\n+                        Optional.of(invalid(method, '@' + annotation.getSimpleName() + \" annotation is not allowed here\"));\n+                    }\n+                }\n+            }\n+            return Optional.empty();\n+        };\n+    }\n+\n+    private static Function<Method, Optional<String>> anyCollectionFrom(Class<? extends Annotation> annotation, Generic... genericTypes) {\n+        return method -> {\n+            int count = 0;\n+            for (Parameter parameter : method.getParameters()) {\n+                if (parameter.isAnnotationPresent(annotation)) {\n+                    for (Generic generic : genericTypes) {\n+                        if (generic.wrapperType.isAssignableFrom(parameter.getType())) {\n+                            Type[] actualTypeArguments = ((ParameterizedType) parameter.getParameterizedType()).getActualTypeArguments();\n+                            if (actualTypeArguments.length == 1 && actualTypeArguments[0].equals(generic.genericType)) {\n+                                count++;\n+                            }\n+                        }\n+                    }\n+                }\n+            }\n+            String errorMessageCommon = \" method parameter with @\" + annotation.getSimpleName() + \" annotation and type from \" +\n+                    Arrays.stream(genericTypes)\n+                            .map(Generic::toString)\n+                            .collect(Collectors.joining(\",\", \"[\", \"]\"));\n+            if (count == 0) {\n+                return Optional.of(invalid(method, \"Misssing\" + errorMessageCommon));\n+            } else if (count > 1) {\n+                return Optional.of(invalid(method, \"Multiple\" + errorMessageCommon));\n+            } else {\n+                return Optional.empty();\n+            }\n+        };\n+    }\n+\n+    private static Function<Method, Optional<String>> returnsAnyOf(Generic... genericTypes) {\n+        return method -> {\n+            int count = 0;\n+            for (Generic generic : genericTypes) {\n+                if (generic.wrapperType.isAssignableFrom(method.getReturnType())) {\n+                    Type[] actualTypeArguments;\n+                    if (method.getReturnType().getSuperclass() == null) {\n+                        actualTypeArguments = ((ParameterizedType) method.getGenericReturnType()).getActualTypeArguments();\n+                    } else {\n+                        actualTypeArguments = ((ParameterizedType) method.getReturnType().getGenericSuperclass()).getActualTypeArguments();\n+                    }\n+                    if (actualTypeArguments.length == 1 && generic.genericType.isAssignableFrom((Class<?>) actualTypeArguments[0])) {\n+                        count++;\n+                    }\n+                }\n+            }\n+            String errorMessage = \"Return \" + method.getReturnType().getSimpleName() + \" type is not one of\" +\n+                    Arrays.stream(genericTypes)\n+                            .map(Generic::toString)\n+                            .collect(Collectors.joining(\",\", \"[\", \"]\"));\n+            if (count != 1) {\n+                return Optional.of(invalid(method, errorMessage));\n+            } else {\n+                return Optional.empty();\n+            }\n+        };\n+    }\n+\n+    private static Function<Pair<Method, Class<?>>, Optional<String>> resourceObject() {\n+        return ctx -> {\n+            Method method = ctx.getKey();\n+            Class<?> type = ctx.getValue();\n+            boolean hasValidField = false;\n+            for (Field field : FieldUtils.getFieldsWithAnnotation(type, ResourceObjectField.class)) {\n+                ResourceObjectField annotation = field.getAnnotation(ResourceObjectField.class);\n+                if (Set.of(CRN, NAME).contains(annotation.variableType())) {\n+                    if (String.class.equals(field.getType())) {\n+                        hasValidField = true;\n+                    } else {\n+                        return Optional.of(invalid(method, field.getName()\n+                                + \" @\" + ResourceObjectField.class + \" must be a String in \" + type.getSimpleName()));\n+                    }\n+                } else if (Set.of(CRN_LIST, NAME_LIST).contains(annotation.variableType())) {\n+                    if (isOneOf(field, list(String.class), set(String.class))) {\n+                        hasValidField = true;\n+                    } else {\n+                        return Optional.of(invalid(method, field.getName()\n+                                + \" @\" + ResourceObjectField.class + \" must be a Set<String> or List<String> in \" + type.getSimpleName()));\n+                    }\n+                }\n+            }\n+            if (hasValidField) {\n+                return Optional.empty();\n+            } else {\n+                return Optional.of(invalid(method, \"Missing @\" + ResourceObjectField.class + \" annotaion in \" + type.getSimpleName()));\n+            }\n+        };\n+    }\n+\n+    private static boolean isOneOf(Field field, Generic... genericTypes) {\n+        for (Generic generic : genericTypes) {\n+            if (generic.wrapperType.isAssignableFrom(field.getType())) {\n+                Type[] actualTypeArguments = ((ParameterizedType) field.getGenericType()).getActualTypeArguments();\n+                if (actualTypeArguments.length == 1 && actualTypeArguments[0].equals(generic.genericType)) {\n+                    return true;\n+                }\n+            }\n+        }\n+        return false;\n+    }\n+\n+    public static class Generic {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDI5MTYxOQ=="}, "originalCommit": {"oid": "6ad0d8b96f5be7152950c53c4bd806c4e6fa78fc"}, "originalPosition": 323}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc0MzEzMzU2OnYy", "diffSide": "RIGHT", "path": "authorization-common/src/test/java/com/sequenceiq/authorization/EnforceAuthorizationLogicsUtil.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNVQxNjoxNjo0M1rOGj5Tmw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNVQxNjoyNToxNVrOGj5oJQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDI5MjI1MQ==", "bodyText": "as I see this code block appears twice in the class, please extract it", "url": "https://github.com/hortonworks/cloudbreak/pull/8283#discussion_r440292251", "createdAt": "2020-06-15T16:16:43Z", "author": {"login": "horadla23"}, "path": "authorization-common/src/test/java/com/sequenceiq/authorization/EnforceAuthorizationLogicsUtil.java", "diffHunk": "@@ -62,18 +124,239 @@ public static void testIfControllerClassHasAuthorizationAnnotation() {\n         Set<String> controllersWithoutAnnotation = Sets.difference(controllersClasses, Sets.union(authorizationResourceClasses, disabledAuthorizationClasses));\n \n         assertTrue(\"These controllers are missing @AuthorizationResource annotation: \" + Joiner.on(\",\").join(controllersWithoutAnnotation),\n-                controllersWithoutAnnotation.size() == 0);\n+                controllersWithoutAnnotation.isEmpty());\n     }\n \n     public static void testIfControllerMethodsHaveProperAuthorizationAnnotation() {\n         Set<Class<?>> authorizationResourceClasses = REFLECTIONS.getTypesAnnotatedWith(AuthorizationResource.class);\n-        Set<String> methodsWithoutAnnotation = Sets.newHashSet();\n-        authorizationResourceClasses.stream().forEach(authzClass -> Arrays.stream(authzClass.getDeclaredMethods())\n-            .filter(method -> Modifier.isPublic(method.getModifiers()) && !AuthorizationAnnotationUtils.getPossibleMethodAnnotations().stream()\n-                    .filter(annotation -> method.isAnnotationPresent(annotation)).findAny().isPresent())\n-            .forEach(method -> methodsWithoutAnnotation.add(authzClass.getSimpleName() + \"#\" + method.getName())));\n-\n-        assertTrue(\"These controller methods are missing any authorization related annotation: \"\n-                        + Joiner.on(\",\").join(methodsWithoutAnnotation), methodsWithoutAnnotation.size() == 0);\n+        List<String> validationErrors = authorizationResourceClasses\n+                .stream()\n+                .map(Class::getDeclaredMethods)\n+                .flatMap(Arrays::stream)\n+                .filter(method -> Modifier.isPublic(method.getModifiers()))\n+                .map(EnforceAuthorizationLogicsUtil::validateMethod)\n+                .flatMap(Collection::stream)\n+                .collect(toList());\n+        assertTrue(Joiner.on(System.lineSeparator()).join(validationErrors), validationErrors.isEmpty());\n+    }\n+\n+    private static List<String> validateMethod(Method method) {\n+        List<Class<? extends Annotation>> annotations = AuthorizationAnnotationUtils\n+                .getPossibleMethodAnnotations()\n+                .stream()\n+                .filter(method::isAnnotationPresent)\n+                .collect(toList());\n+        if (annotations.isEmpty()) {\n+            return List.of(invalid(method, \"Missing aithz annotation.\"));\n+        } else {\n+            return annotations\n+                    .stream()\n+                    .map(annotation -> METHOD_VALIDATORS.getOrDefault(annotation, unknownAnnotation(annotation)).apply(method))\n+                    .filter(Optional::isPresent)\n+                    .map(Optional::get)\n+                    .map(Object::toString)\n+                    .collect(toList());\n+        }\n+    }\n+\n+    private static String invalid(Method method, String reason) {\n+        return methodToString(method) + \": \" + reason;\n+    }\n+\n+    private static Function<Method, Optional<String>> noRestriction() {\n+        return method -> Optional.empty();\n+    }\n+\n+    private static Function<Method, Optional<String>> unknownAnnotation(Class<? extends Annotation> annotation) {\n+        return method -> Optional.of(invalid(method, \"No validation rule specified for \" + annotation));\n+    }\n+\n+    private static String methodToString(Method method) {\n+        return method.getDeclaringClass().getSimpleName() + '#' + method.getName();\n+    }\n+\n+    private static Function<Method, Optional<String>> hasParamWhere(Class<? extends Annotation> annotation,\n+            Function<Pair<Method, Class<?>>, Optional<String>> typeValidator) {\n+        return method -> {\n+            List<Optional<String>> validations = new ArrayList<>();\n+            for (Parameter parameter : method.getParameters()) {\n+                if (parameter.isAnnotationPresent(annotation)) {\n+                    validations.add(typeValidator.apply(Pair.of(method, parameter.getType())));\n+                }\n+            }\n+            String errorMessageCommon = \" method param with @\" + annotation.getSimpleName() + \" annotation\";\n+            if (validations.isEmpty()) {\n+                return Optional.of(invalid(method, \"Misssing\" + errorMessageCommon));\n+            } else if (validations.size() > 1) {\n+                return Optional.of(invalid(method, \"Multiple\" + errorMessageCommon));\n+            } else {\n+                return validations.get(0);\n+            }\n+        };\n+    }\n+\n+    private static Function<Method, Optional<String>> stringParam(Class<? extends Annotation> annotation) {\n+        return hasParam(annotation, String.class);\n+    }\n+\n+    private static Function<Method, Optional<String>> hasParam(Class<? extends Annotation> annotation, Class<?> type) {\n+        return method -> {\n+            int count = 0;\n+            for (Parameter parameter : method.getParameters()) {\n+                if (parameter.isAnnotationPresent(annotation) && type.equals(parameter.getType())) {\n+                    count++;\n+                }\n+            }\n+            String errorMessageCommon = \" method parameter with @\" + annotation.getSimpleName() + \" annotation and type \" + type.getSimpleName();\n+            if (count == 0) {\n+                return Optional.of(invalid(method, \"Misssing\" + errorMessageCommon));\n+            } else if (count > 1) {\n+                return Optional.of(invalid(method, \"Multiple\" + errorMessageCommon));\n+            } else {\n+                return Optional.empty();\n+            }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6ad0d8b96f5be7152950c53c4bd806c4e6fa78fc"}, "originalPosition": 206}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDI5NzUwOQ==", "bodyText": "ok", "url": "https://github.com/hortonworks/cloudbreak/pull/8283#discussion_r440297509", "createdAt": "2020-06-15T16:25:15Z", "author": {"login": "foldik"}, "path": "authorization-common/src/test/java/com/sequenceiq/authorization/EnforceAuthorizationLogicsUtil.java", "diffHunk": "@@ -62,18 +124,239 @@ public static void testIfControllerClassHasAuthorizationAnnotation() {\n         Set<String> controllersWithoutAnnotation = Sets.difference(controllersClasses, Sets.union(authorizationResourceClasses, disabledAuthorizationClasses));\n \n         assertTrue(\"These controllers are missing @AuthorizationResource annotation: \" + Joiner.on(\",\").join(controllersWithoutAnnotation),\n-                controllersWithoutAnnotation.size() == 0);\n+                controllersWithoutAnnotation.isEmpty());\n     }\n \n     public static void testIfControllerMethodsHaveProperAuthorizationAnnotation() {\n         Set<Class<?>> authorizationResourceClasses = REFLECTIONS.getTypesAnnotatedWith(AuthorizationResource.class);\n-        Set<String> methodsWithoutAnnotation = Sets.newHashSet();\n-        authorizationResourceClasses.stream().forEach(authzClass -> Arrays.stream(authzClass.getDeclaredMethods())\n-            .filter(method -> Modifier.isPublic(method.getModifiers()) && !AuthorizationAnnotationUtils.getPossibleMethodAnnotations().stream()\n-                    .filter(annotation -> method.isAnnotationPresent(annotation)).findAny().isPresent())\n-            .forEach(method -> methodsWithoutAnnotation.add(authzClass.getSimpleName() + \"#\" + method.getName())));\n-\n-        assertTrue(\"These controller methods are missing any authorization related annotation: \"\n-                        + Joiner.on(\",\").join(methodsWithoutAnnotation), methodsWithoutAnnotation.size() == 0);\n+        List<String> validationErrors = authorizationResourceClasses\n+                .stream()\n+                .map(Class::getDeclaredMethods)\n+                .flatMap(Arrays::stream)\n+                .filter(method -> Modifier.isPublic(method.getModifiers()))\n+                .map(EnforceAuthorizationLogicsUtil::validateMethod)\n+                .flatMap(Collection::stream)\n+                .collect(toList());\n+        assertTrue(Joiner.on(System.lineSeparator()).join(validationErrors), validationErrors.isEmpty());\n+    }\n+\n+    private static List<String> validateMethod(Method method) {\n+        List<Class<? extends Annotation>> annotations = AuthorizationAnnotationUtils\n+                .getPossibleMethodAnnotations()\n+                .stream()\n+                .filter(method::isAnnotationPresent)\n+                .collect(toList());\n+        if (annotations.isEmpty()) {\n+            return List.of(invalid(method, \"Missing aithz annotation.\"));\n+        } else {\n+            return annotations\n+                    .stream()\n+                    .map(annotation -> METHOD_VALIDATORS.getOrDefault(annotation, unknownAnnotation(annotation)).apply(method))\n+                    .filter(Optional::isPresent)\n+                    .map(Optional::get)\n+                    .map(Object::toString)\n+                    .collect(toList());\n+        }\n+    }\n+\n+    private static String invalid(Method method, String reason) {\n+        return methodToString(method) + \": \" + reason;\n+    }\n+\n+    private static Function<Method, Optional<String>> noRestriction() {\n+        return method -> Optional.empty();\n+    }\n+\n+    private static Function<Method, Optional<String>> unknownAnnotation(Class<? extends Annotation> annotation) {\n+        return method -> Optional.of(invalid(method, \"No validation rule specified for \" + annotation));\n+    }\n+\n+    private static String methodToString(Method method) {\n+        return method.getDeclaringClass().getSimpleName() + '#' + method.getName();\n+    }\n+\n+    private static Function<Method, Optional<String>> hasParamWhere(Class<? extends Annotation> annotation,\n+            Function<Pair<Method, Class<?>>, Optional<String>> typeValidator) {\n+        return method -> {\n+            List<Optional<String>> validations = new ArrayList<>();\n+            for (Parameter parameter : method.getParameters()) {\n+                if (parameter.isAnnotationPresent(annotation)) {\n+                    validations.add(typeValidator.apply(Pair.of(method, parameter.getType())));\n+                }\n+            }\n+            String errorMessageCommon = \" method param with @\" + annotation.getSimpleName() + \" annotation\";\n+            if (validations.isEmpty()) {\n+                return Optional.of(invalid(method, \"Misssing\" + errorMessageCommon));\n+            } else if (validations.size() > 1) {\n+                return Optional.of(invalid(method, \"Multiple\" + errorMessageCommon));\n+            } else {\n+                return validations.get(0);\n+            }\n+        };\n+    }\n+\n+    private static Function<Method, Optional<String>> stringParam(Class<? extends Annotation> annotation) {\n+        return hasParam(annotation, String.class);\n+    }\n+\n+    private static Function<Method, Optional<String>> hasParam(Class<? extends Annotation> annotation, Class<?> type) {\n+        return method -> {\n+            int count = 0;\n+            for (Parameter parameter : method.getParameters()) {\n+                if (parameter.isAnnotationPresent(annotation) && type.equals(parameter.getType())) {\n+                    count++;\n+                }\n+            }\n+            String errorMessageCommon = \" method parameter with @\" + annotation.getSimpleName() + \" annotation and type \" + type.getSimpleName();\n+            if (count == 0) {\n+                return Optional.of(invalid(method, \"Misssing\" + errorMessageCommon));\n+            } else if (count > 1) {\n+                return Optional.of(invalid(method, \"Multiple\" + errorMessageCommon));\n+            } else {\n+                return Optional.empty();\n+            }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDI5MjI1MQ=="}, "originalCommit": {"oid": "6ad0d8b96f5be7152950c53c4bd806c4e6fa78fc"}, "originalPosition": 206}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3213, "cost": 1, "resetAt": "2021-11-12T20:44:06Z"}}}