{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDg2ODcyNTgx", "number": 9010, "title": "CDPCP-2990. User sync uses bulk UMS api ", "bodyText": "The UMS introduced an API that returns the user sync state\nfrom the UMS in one request. This is used to avoid the many\nnetwork roundtrips when the FMS builds the state through\nindividual UMS requests.\nChanges include:\n\nBulk of the changes are to the UmsUsersStateProvider. This has been refactored\nto support using either the bulk api or individual apis for full sync. This\nbehavior is protected by an entitlement.\nUnit tests were added to ensure that both codepaths yield the same results\nusermanagement.proto and ums client classes  updated to include the new API\nmock user management service updated to the changes in the GetRightsRequest\nEventGenerationId code updated to use the shared model instead of the\nindividual fields\nFixed typo in CloudIdentitySyncService methods and tests\n\nNOTE: This commit should be able to merge cleanly with #8988\nIf not, then I'll rebase and de-conflict it", "createdAt": "2020-09-14T20:44:42Z", "url": "https://github.com/hortonworks/cloudbreak/pull/9010", "merged": true, "mergeCommit": {"oid": "d5691e633d933cba4d1d9cd0bbfe23bf3044aa1d"}, "closed": true, "closedAt": "2020-09-23T07:32:36Z", "author": {"login": "handavid"}, "timelineItems": {"totalCount": 15, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdI7HrggFqTQ4ODIwMjc4Mg==", "endCursor": "Y3Vyc29yOnYyOpPPAAABdLngOhAFqTQ5NDM1NDczOQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDg4MjAyNzgy", "url": "https://github.com/hortonworks/cloudbreak/pull/9010#pullrequestreview-488202782", "createdAt": "2020-09-14T22:37:38Z", "commit": {"oid": "2099a2d2e3fd0f709bc491ac167110d297567c84"}, "state": "APPROVED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNFQyMjozNzozOFrOHRp3rQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNFQyMjo0MDozN1rOHRqAww==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODI3MzgzNw==", "bodyText": "This doc string isn't correct.", "url": "https://github.com/hortonworks/cloudbreak/pull/9010#discussion_r488273837", "createdAt": "2020-09-14T22:37:38Z", "author": {"login": "aarman-cloudera"}, "path": "auth-connector/src/main/java/com/sequenceiq/cloudbreak/auth/altus/GrpcUmsClient.java", "diffHunk": "@@ -779,6 +781,24 @@ public GetEventGenerationIdsResponse getEventGenerationIds(String actorCrn, Stri\n         }\n     }\n \n+    /**\n+     * Retrieves user sync state model from UMS.\n+     *\n+     * @param accountId        the account Id\n+     * @param requestId        an optional request Id\n+     * @param rightsChecksList list of mapping from resources to lists of rights to check. Lists are used to\n+     *                         preserve order.\n+     * @return the user associated with this user CRN", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2099a2d2e3fd0f709bc491ac167110d297567c84"}, "originalPosition": 36}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODI3NDUyMg==", "bodyText": "List<Pair<String, List<String>>> is a bit hard to read, maybe turn this into\nList<RightsCheck> (adding a new RightsCheck class)?", "url": "https://github.com/hortonworks/cloudbreak/pull/9010#discussion_r488274522", "createdAt": "2020-09-14T22:38:32Z", "author": {"login": "aarman-cloudera"}, "path": "auth-connector/src/main/java/com/sequenceiq/cloudbreak/auth/altus/UmsClient.java", "diffHunk": "@@ -783,4 +787,29 @@ public String getIdentityProviderMetadataXml(String requestId, String accountId)\n         }\n         return assignee.build();\n     }\n+\n+    /**\n+     * Retrieves user sync state model from the UMS.\n+     *\n+     * @param requestId          the request ID for the request\n+     * @param accountId          the account ID\n+     * @param rightsChecksList   list of mapping from resources to lists of rights to check. Lists are used to\n+     *                           preserve order.\n+     * @return the user sync state model\n+     */\n+    public GetUserSyncStateModelResponse getUserSyncStateModel(\n+            String requestId, String accountId, List<Pair<String, List<String>>> rightsChecksList) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2099a2d2e3fd0f709bc491ac167110d297567c84"}, "originalPosition": 40}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODI3NjE2Mw==", "bodyText": "nit: Any reason getUmsUsersStateMapBulk and getUmsUsersStateMap needs to\nreturn a Builder instead of the built UmsUserState?", "url": "https://github.com/hortonworks/cloudbreak/pull/9010#discussion_r488276163", "createdAt": "2020-09-14T22:40:37Z", "author": {"login": "aarman-cloudera"}, "path": "freeipa/src/main/java/com/sequenceiq/freeipa/service/freeipa/user/UmsUsersStateProvider.java", "diffHunk": "@@ -54,92 +77,232 @@\n     @Inject\n     private UmsRightProvider umsRightProvider;\n \n-    public Map<String, UmsUsersState> getEnvToUmsUsersStateMap(String accountId, String actorCrn, Set<String> environmentCrns,\n-        Set<String> userCrns, Set<String> machineUserCrns, Optional<String> requestIdOptional) {\n+    @Inject\n+    private EntitlementService entitlementService;\n+\n+    public Map<String, UmsUsersState> getEnvToUmsUsersStateMap(\n+            String accountId, String actorCrn, Collection<String> environmentCrns,\n+            Set<String> userCrns, Set<String> machineUserCrns, Optional<String> requestIdOptional) {\n         try {\n             LOGGER.debug(\"Getting UMS state for environments {} with requestId {}\", environmentCrns, requestIdOptional);\n \n-            Map<String, UmsUsersState> envUsersStateMap = new HashMap<>();\n-\n             boolean fullSync = userCrns.isEmpty() && machineUserCrns.isEmpty();\n \n-            List<User> users = getUsers(actorCrn, accountId, requestIdOptional, fullSync, userCrns);\n-\n-            List<MachineUser> machineUsers = getMachineUsers(actorCrn, accountId, requestIdOptional, fullSync, machineUserCrns);\n-\n-            Map<String, FmsGroup> crnToFmsGroup = grpcUmsClient.listGroups(actorCrn, accountId, List.of(), requestIdOptional).stream()\n-                    .collect(Collectors.toMap(Group::getCrn, this::umsGroupToGroup));\n-\n-            Map<WorkloadAdministrationGroup, FmsGroup> wags = grpcUmsClient.listWorkloadAdministrationGroups(INTERNAL_ACTOR_CRN, accountId, requestIdOptional)\n-                    .stream()\n-                    .collect(Collectors.toMap(wag -> wag, wag -> nameToGroup(wag.getWorkloadAdministrationGroupName())));\n-            environmentCrns.forEach(environmentCrn -> {\n-                UmsUsersState.Builder umsUsersStateBuilder = new UmsUsersState.Builder()\n-                        .setWorkloadAdministrationGroups(wags.values());\n-\n-                UsersState.Builder usersStateBuilder = new UsersState.Builder();\n-                Set<String> wagNamesForOtherEnvironments = new HashSet<>();\n-\n-                crnToFmsGroup.values().forEach(usersStateBuilder::addGroup);\n-\n-                // Only add workload admin groups that belong to this environment.\n-                // At the same time, build a set of workload admin groups that are\n-                // associated with other environments so we can filter these out in\n-                // the per-user group listing in handleUser.\n-                wags.entrySet().forEach(wagEntry -> {\n-                    WorkloadAdministrationGroup wag = wagEntry.getKey();\n-                    String groupName = wag.getWorkloadAdministrationGroupName();\n-                    if (wag.getResource().equalsIgnoreCase(environmentCrn)) {\n-                        usersStateBuilder.addGroup(wagEntry.getValue());\n-                    } else {\n-                        Crn resourceCrn = getCrn(wag);\n-                        if (resourceCrn != null && resourceCrn.getService() == Crn.Service.ENVIRONMENTS\n-                                && resourceCrn.getResourceType() == ResourceType.ENVIRONMENT) {\n-                            wagNamesForOtherEnvironments.add(groupName);\n-                        }\n-                    }\n-                });\n+            Map<String, UmsUsersState.Builder> envUsersStateMap;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2099a2d2e3fd0f709bc491ac167110d297567c84"}, "originalPosition": 116}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDg5MDUxODA5", "url": "https://github.com/hortonworks/cloudbreak/pull/9010#pullrequestreview-489051809", "createdAt": "2020-09-15T20:37:46Z", "commit": {"oid": "2099a2d2e3fd0f709bc491ac167110d297567c84"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDg5MDYwOTU3", "url": "https://github.com/hortonworks/cloudbreak/pull/9010#pullrequestreview-489060957", "createdAt": "2020-09-15T20:51:45Z", "commit": {"oid": "2099a2d2e3fd0f709bc491ac167110d297567c84"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "fd3a411b774f2e0a46642227c7bb04294ccbd69b", "author": {"user": {"login": "handavid", "name": "David Han"}}, "url": "https://github.com/hortonworks/cloudbreak/commit/fd3a411b774f2e0a46642227c7bb04294ccbd69b", "committedDate": "2020-09-15T22:46:07Z", "message": "address asif's comments"}, "afterCommit": {"oid": "73d6dc30ed172b314b02349317c6ab811980703c", "author": {"user": {"login": "handavid", "name": "David Han"}}, "url": "https://github.com/hortonworks/cloudbreak/commit/73d6dc30ed172b314b02349317c6ab811980703c", "committedDate": "2020-09-17T22:24:16Z", "message": "CDPCP-2990. User sync uses bulk UMS api\n\nThe UMS introduced an API that returns the user sync state\nfrom the UMS in one request. This is used to avoid the many\nnetwork roundtrips when the FMS builds the state through\nindividual UMS requests.\n\nChanges include:\n- Bulk of the changes are to the UmsUsersStateProvider. This has been refactored\n  to support using either the bulk api or individual apis for full sync. This\n  behavior is protected by an entitlement.\n- Unit tests were added to ensure that both codepaths yield the same results\n- usermanagement.proto and ums client classes  updated to include the new API\n- mock user management service updated to the changes in the GetRightsRequest\n- EventGenerationId code updated to use the shared model instead of the\n  individual fields\n- Fixed typo in CloudIdentitySyncService methods and tests"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDkxNDM5MTg2", "url": "https://github.com/hortonworks/cloudbreak/pull/9010#pullrequestreview-491439186", "createdAt": "2020-09-18T12:57:28Z", "commit": {"oid": "73d6dc30ed172b314b02349317c6ab811980703c"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xOFQxMjo1NzoyOVrOHUMAuQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xOFQxNTowOTo1OFrOHURM_w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDkzMDM2MQ==", "bodyText": "please remove static", "url": "https://github.com/hortonworks/cloudbreak/pull/9010#discussion_r490930361", "createdAt": "2020-09-18T12:57:29Z", "author": {"login": "lacikaaa"}, "path": "freeipa/src/main/java/com/sequenceiq/freeipa/service/freeipa/user/EnvironmentAccessChecker.java", "diffHunk": "@@ -74,4 +67,18 @@ public EnvironmentAccessRights hasAccess(String memberCrn, Optional<String> requ\n \n         }\n     }\n+\n+    @VisibleForTesting\n+    static List<RightCheck> createRightCheck(UmsRightProvider umsRightProvider, String environmentCrn) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "73d6dc30ed172b314b02349317c6ab811980703c"}, "originalPosition": 32}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDkzNjAyOA==", "bodyText": "please refactor this class:\n\ninstead of static use @Component annotation and @Inject where you use it\nslice into 3 separate class for: FmsUser, FmsGroup and WorkloadCredential so each would have it's own responsibility", "url": "https://github.com/hortonworks/cloudbreak/pull/9010#discussion_r490936028", "createdAt": "2020-09-18T13:07:12Z", "author": {"login": "lacikaaa"}, "path": "freeipa/src/main/java/com/sequenceiq/freeipa/service/freeipa/user/model/Conversions.java", "diffHunk": "@@ -0,0 +1,85 @@\n+package com.sequenceiq.freeipa.service.freeipa.user.model;\n+\n+import com.cloudera.thunderhead.service.usermanagement.UserManagementProto;\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Strings;\n+\n+import java.time.Instant;\n+import java.util.Optional;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+\n+public class Conversions {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "73d6dc30ed172b314b02349317c6ab811980703c"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDkzNjYwNg==", "bodyText": "this could be replaced with StringUtils.defaultIfBlank(final T str, final T defaultStr) from apache commons lang3", "url": "https://github.com/hortonworks/cloudbreak/pull/9010#discussion_r490936606", "createdAt": "2020-09-18T13:08:12Z", "author": {"login": "lacikaaa"}, "path": "freeipa/src/main/java/com/sequenceiq/freeipa/service/freeipa/user/model/Conversions.java", "diffHunk": "@@ -0,0 +1,85 @@\n+package com.sequenceiq.freeipa.service.freeipa.user.model;\n+\n+import com.cloudera.thunderhead.service.usermanagement.UserManagementProto;\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Strings;\n+\n+import java.time.Instant;\n+import java.util.Optional;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+\n+public class Conversions {\n+\n+    @VisibleForTesting\n+    static final String NONE_STRING = \"None\";\n+\n+    private Conversions() {\n+    }\n+\n+    public static FmsUser toFmsUser(UserManagementProto.User umsUser) {\n+        return createFmsUser(umsUser.getWorkloadUsername(),\n+                umsUser.getFirstName(),\n+                umsUser.getLastName());\n+    }\n+\n+    public static FmsUser toFmsUser(UserManagementProto.MachineUser umsMachineUser) {\n+        // Machine users don't have a first and last name.\n+        // Store the machine user name and id instead.\n+        return createFmsUser(umsMachineUser.getWorkloadUsername(),\n+                umsMachineUser.getMachineUserName(),\n+                umsMachineUser.getMachineUserId());\n+    }\n+\n+    public static FmsUser toFmsUser(\n+            UserManagementProto.UserSyncActorDetails actorDetails) {\n+        return createFmsUser(actorDetails.getWorkloadUsername(),\n+                actorDetails.getFirstName(),\n+                actorDetails.getLastName());\n+    }\n+\n+    private static FmsUser createFmsUser(String workloadUsername, String firstName, String lastName) {\n+        checkArgument(!Strings.isNullOrEmpty(workloadUsername));\n+        FmsUser fmsUser = new FmsUser();\n+        fmsUser.withName(workloadUsername);\n+        fmsUser.withFirstName(orDefault(firstName, NONE_STRING));\n+        fmsUser.withLastName(orDefault(lastName, NONE_STRING));\n+        return fmsUser;\n+    }\n+\n+    public static FmsGroup umsGroupToGroup(UserManagementProto.Group umsGroup) {\n+        return nameToGroup(umsGroup.getGroupName());\n+    }\n+\n+    public static FmsGroup nameToGroup(String name) {\n+        checkArgument(!Strings.isNullOrEmpty(name));\n+        FmsGroup fmsGroup = new FmsGroup();\n+        fmsGroup.withName(name);\n+        return fmsGroup;\n+    }\n+\n+    private static String orDefault(String value, String other) {\n+        return (value == null || value.isBlank()) ? other : value;\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "73d6dc30ed172b314b02349317c6ab811980703c"}, "originalPosition": 63}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDk0MzE4Mw==", "bodyText": "why not stream environmentCrnList and collect the result into a map in the end?", "url": "https://github.com/hortonworks/cloudbreak/pull/9010#discussion_r490943183", "createdAt": "2020-09-18T13:19:10Z", "author": {"login": "lacikaaa"}, "path": "freeipa/src/main/java/com/sequenceiq/freeipa/service/freeipa/user/UmsUsersStateProvider.java", "diffHunk": "@@ -54,92 +77,233 @@\n     @Inject\n     private UmsRightProvider umsRightProvider;\n \n-    public Map<String, UmsUsersState> getEnvToUmsUsersStateMap(String accountId, String actorCrn, Set<String> environmentCrns,\n-        Set<String> userCrns, Set<String> machineUserCrns, Optional<String> requestIdOptional) {\n+    @Inject\n+    private EntitlementService entitlementService;\n+\n+    public Map<String, UmsUsersState> getEnvToUmsUsersStateMap(\n+            String accountId, String actorCrn, Collection<String> environmentCrns,\n+            Set<String> userCrns, Set<String> machineUserCrns, Optional<String> requestIdOptional) {\n         try {\n             LOGGER.debug(\"Getting UMS state for environments {} with requestId {}\", environmentCrns, requestIdOptional);\n \n-            Map<String, UmsUsersState> envUsersStateMap = new HashMap<>();\n-\n             boolean fullSync = userCrns.isEmpty() && machineUserCrns.isEmpty();\n \n-            List<User> users = getUsers(actorCrn, accountId, requestIdOptional, fullSync, userCrns);\n-\n-            List<MachineUser> machineUsers = getMachineUsers(actorCrn, accountId, requestIdOptional, fullSync, machineUserCrns);\n-\n-            Map<String, FmsGroup> crnToFmsGroup = grpcUmsClient.listGroups(actorCrn, accountId, List.of(), requestIdOptional).stream()\n-                    .collect(Collectors.toMap(Group::getCrn, this::umsGroupToGroup));\n-\n-            Map<WorkloadAdministrationGroup, FmsGroup> wags = grpcUmsClient.listWorkloadAdministrationGroups(INTERNAL_ACTOR_CRN, accountId, requestIdOptional)\n-                    .stream()\n-                    .collect(Collectors.toMap(wag -> wag, wag -> nameToGroup(wag.getWorkloadAdministrationGroupName())));\n-            environmentCrns.forEach(environmentCrn -> {\n-                UmsUsersState.Builder umsUsersStateBuilder = new UmsUsersState.Builder()\n-                        .setWorkloadAdministrationGroups(wags.values());\n-\n-                UsersState.Builder usersStateBuilder = new UsersState.Builder();\n-                Set<String> wagNamesForOtherEnvironments = new HashSet<>();\n-\n-                crnToFmsGroup.values().forEach(usersStateBuilder::addGroup);\n-\n-                // Only add workload admin groups that belong to this environment.\n-                // At the same time, build a set of workload admin groups that are\n-                // associated with other environments so we can filter these out in\n-                // the per-user group listing in handleUser.\n-                wags.entrySet().forEach(wagEntry -> {\n-                    WorkloadAdministrationGroup wag = wagEntry.getKey();\n-                    String groupName = wag.getWorkloadAdministrationGroupName();\n-                    if (wag.getResource().equalsIgnoreCase(environmentCrn)) {\n-                        usersStateBuilder.addGroup(wagEntry.getValue());\n-                    } else {\n-                        Crn resourceCrn = getCrn(wag);\n-                        if (resourceCrn != null && resourceCrn.getService() == Crn.Service.ENVIRONMENTS\n-                                && resourceCrn.getResourceType() == ResourceType.ENVIRONMENT) {\n-                            wagNamesForOtherEnvironments.add(groupName);\n-                        }\n-                    }\n-                });\n+            Map<String, UmsUsersState> envUsersStateMap;\n+            if (fullSync && entitlementService.umsUserSyncModelGenerationEnabled(INTERNAL_ACTOR_CRN, accountId)) {\n+                envUsersStateMap = getUmsUsersStateMapBulk(accountId, environmentCrns, requestIdOptional);\n+            } else {\n+                envUsersStateMap = getUmsUsersStateMap(\n+                        accountId, actorCrn,\n+                        environmentCrns, userCrns, machineUserCrns,\n+                        requestIdOptional, fullSync);\n+            }\n \n-                // Add internal usersync group for each environment\n-                usersStateBuilder.addGroup(nameToGroup(UserSyncConstants.CDP_USERSYNC_INTERNAL_GROUP));\n+            return envUsersStateMap;\n+        } catch (RuntimeException e) {\n+            throw new UmsOperationException(String.format(\"Error during UMS operation: '%s'\", e.getLocalizedMessage()), e);\n+        }\n+    }\n \n-                EnvironmentAccessChecker environmentAccessChecker = createEnvironmentAccessChecker(environmentCrn);\n+    @VisibleForTesting\n+    Map<String, UmsUsersState> getUmsUsersStateMapBulk(\n+            String accountId, Collection<String> environmentCrns, Optional<String> requestIdOptional) {\n+\n+        List<String> environmentCrnList = List.copyOf(environmentCrns);\n+        GetUserSyncStateModelResponse userSyncStateModel = grpcUmsClient.getUserSyncStateModel(\n+                INTERNAL_ACTOR_CRN,\n+                accountId,\n+                generateRightsChecksForEnvironments(environmentCrnList),\n+                requestIdOptional);\n+\n+        Map<String, FmsGroup> groups = convertGroupsToFmsGroups(userSyncStateModel.getGroupList());\n+        Map<WorkloadAdministrationGroup, FmsGroup> wags =\n+                convertWagsToFmsGroups(userSyncStateModel.getWorkloadAdministrationGroupList());\n+        List<String> requestedWorkloadUsernames = userSyncStateModel.getActorList().stream()\n+                .map(UserManagementProto.UserSyncActor::getActorDetails)\n+                .map(UserManagementProto.UserSyncActorDetails::getWorkloadUsername)\n+                .collect(Collectors.toList());\n+\n+        Map<String, UmsUsersState> umsUsersStateMap = Maps.newHashMap();\n+        IntStream.range(0, environmentCrnList.size())\n+                .forEach(environmentIndex -> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "73d6dc30ed172b314b02349317c6ab811980703c"}, "originalPosition": 156}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDk4NDg1NA==", "bodyText": "could you break this up into smaller ones? maybe move them to a separate class", "url": "https://github.com/hortonworks/cloudbreak/pull/9010#discussion_r490984854", "createdAt": "2020-09-18T14:22:22Z", "author": {"login": "lacikaaa"}, "path": "freeipa/src/main/java/com/sequenceiq/freeipa/service/freeipa/user/UmsUsersStateProvider.java", "diffHunk": "@@ -54,92 +77,233 @@\n     @Inject\n     private UmsRightProvider umsRightProvider;\n \n-    public Map<String, UmsUsersState> getEnvToUmsUsersStateMap(String accountId, String actorCrn, Set<String> environmentCrns,\n-        Set<String> userCrns, Set<String> machineUserCrns, Optional<String> requestIdOptional) {\n+    @Inject\n+    private EntitlementService entitlementService;\n+\n+    public Map<String, UmsUsersState> getEnvToUmsUsersStateMap(\n+            String accountId, String actorCrn, Collection<String> environmentCrns,\n+            Set<String> userCrns, Set<String> machineUserCrns, Optional<String> requestIdOptional) {\n         try {\n             LOGGER.debug(\"Getting UMS state for environments {} with requestId {}\", environmentCrns, requestIdOptional);\n \n-            Map<String, UmsUsersState> envUsersStateMap = new HashMap<>();\n-\n             boolean fullSync = userCrns.isEmpty() && machineUserCrns.isEmpty();\n \n-            List<User> users = getUsers(actorCrn, accountId, requestIdOptional, fullSync, userCrns);\n-\n-            List<MachineUser> machineUsers = getMachineUsers(actorCrn, accountId, requestIdOptional, fullSync, machineUserCrns);\n-\n-            Map<String, FmsGroup> crnToFmsGroup = grpcUmsClient.listGroups(actorCrn, accountId, List.of(), requestIdOptional).stream()\n-                    .collect(Collectors.toMap(Group::getCrn, this::umsGroupToGroup));\n-\n-            Map<WorkloadAdministrationGroup, FmsGroup> wags = grpcUmsClient.listWorkloadAdministrationGroups(INTERNAL_ACTOR_CRN, accountId, requestIdOptional)\n-                    .stream()\n-                    .collect(Collectors.toMap(wag -> wag, wag -> nameToGroup(wag.getWorkloadAdministrationGroupName())));\n-            environmentCrns.forEach(environmentCrn -> {\n-                UmsUsersState.Builder umsUsersStateBuilder = new UmsUsersState.Builder()\n-                        .setWorkloadAdministrationGroups(wags.values());\n-\n-                UsersState.Builder usersStateBuilder = new UsersState.Builder();\n-                Set<String> wagNamesForOtherEnvironments = new HashSet<>();\n-\n-                crnToFmsGroup.values().forEach(usersStateBuilder::addGroup);\n-\n-                // Only add workload admin groups that belong to this environment.\n-                // At the same time, build a set of workload admin groups that are\n-                // associated with other environments so we can filter these out in\n-                // the per-user group listing in handleUser.\n-                wags.entrySet().forEach(wagEntry -> {\n-                    WorkloadAdministrationGroup wag = wagEntry.getKey();\n-                    String groupName = wag.getWorkloadAdministrationGroupName();\n-                    if (wag.getResource().equalsIgnoreCase(environmentCrn)) {\n-                        usersStateBuilder.addGroup(wagEntry.getValue());\n-                    } else {\n-                        Crn resourceCrn = getCrn(wag);\n-                        if (resourceCrn != null && resourceCrn.getService() == Crn.Service.ENVIRONMENTS\n-                                && resourceCrn.getResourceType() == ResourceType.ENVIRONMENT) {\n-                            wagNamesForOtherEnvironments.add(groupName);\n-                        }\n-                    }\n-                });\n+            Map<String, UmsUsersState> envUsersStateMap;\n+            if (fullSync && entitlementService.umsUserSyncModelGenerationEnabled(INTERNAL_ACTOR_CRN, accountId)) {\n+                envUsersStateMap = getUmsUsersStateMapBulk(accountId, environmentCrns, requestIdOptional);\n+            } else {\n+                envUsersStateMap = getUmsUsersStateMap(\n+                        accountId, actorCrn,\n+                        environmentCrns, userCrns, machineUserCrns,\n+                        requestIdOptional, fullSync);\n+            }\n \n-                // Add internal usersync group for each environment\n-                usersStateBuilder.addGroup(nameToGroup(UserSyncConstants.CDP_USERSYNC_INTERNAL_GROUP));\n+            return envUsersStateMap;\n+        } catch (RuntimeException e) {\n+            throw new UmsOperationException(String.format(\"Error during UMS operation: '%s'\", e.getLocalizedMessage()), e);\n+        }\n+    }\n \n-                EnvironmentAccessChecker environmentAccessChecker = createEnvironmentAccessChecker(environmentCrn);\n+    @VisibleForTesting\n+    Map<String, UmsUsersState> getUmsUsersStateMapBulk(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "73d6dc30ed172b314b02349317c6ab811980703c"}, "originalPosition": 136}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTAxNTQyMw==", "bodyText": "I have to say this class is getting more and more complex, the methods are getting more complex and bigger. It's pretty hard to understand and review it actually. I would like to kindly ask you to refactor this before/while putting these new bulk sync logic into it.\neg this actorHandler might be a separate class as it has a try-catch, which invokes a method with 10 parameters, 3 of them are lambdas", "url": "https://github.com/hortonworks/cloudbreak/pull/9010#discussion_r491015423", "createdAt": "2020-09-18T15:09:58Z", "author": {"login": "lacikaaa"}, "path": "freeipa/src/main/java/com/sequenceiq/freeipa/service/freeipa/user/UmsUsersStateProvider.java", "diffHunk": "@@ -54,92 +77,233 @@\n     @Inject\n     private UmsRightProvider umsRightProvider;\n \n-    public Map<String, UmsUsersState> getEnvToUmsUsersStateMap(String accountId, String actorCrn, Set<String> environmentCrns,\n-        Set<String> userCrns, Set<String> machineUserCrns, Optional<String> requestIdOptional) {\n+    @Inject\n+    private EntitlementService entitlementService;\n+\n+    public Map<String, UmsUsersState> getEnvToUmsUsersStateMap(\n+            String accountId, String actorCrn, Collection<String> environmentCrns,\n+            Set<String> userCrns, Set<String> machineUserCrns, Optional<String> requestIdOptional) {\n         try {\n             LOGGER.debug(\"Getting UMS state for environments {} with requestId {}\", environmentCrns, requestIdOptional);\n \n-            Map<String, UmsUsersState> envUsersStateMap = new HashMap<>();\n-\n             boolean fullSync = userCrns.isEmpty() && machineUserCrns.isEmpty();\n \n-            List<User> users = getUsers(actorCrn, accountId, requestIdOptional, fullSync, userCrns);\n-\n-            List<MachineUser> machineUsers = getMachineUsers(actorCrn, accountId, requestIdOptional, fullSync, machineUserCrns);\n-\n-            Map<String, FmsGroup> crnToFmsGroup = grpcUmsClient.listGroups(actorCrn, accountId, List.of(), requestIdOptional).stream()\n-                    .collect(Collectors.toMap(Group::getCrn, this::umsGroupToGroup));\n-\n-            Map<WorkloadAdministrationGroup, FmsGroup> wags = grpcUmsClient.listWorkloadAdministrationGroups(INTERNAL_ACTOR_CRN, accountId, requestIdOptional)\n-                    .stream()\n-                    .collect(Collectors.toMap(wag -> wag, wag -> nameToGroup(wag.getWorkloadAdministrationGroupName())));\n-            environmentCrns.forEach(environmentCrn -> {\n-                UmsUsersState.Builder umsUsersStateBuilder = new UmsUsersState.Builder()\n-                        .setWorkloadAdministrationGroups(wags.values());\n-\n-                UsersState.Builder usersStateBuilder = new UsersState.Builder();\n-                Set<String> wagNamesForOtherEnvironments = new HashSet<>();\n-\n-                crnToFmsGroup.values().forEach(usersStateBuilder::addGroup);\n-\n-                // Only add workload admin groups that belong to this environment.\n-                // At the same time, build a set of workload admin groups that are\n-                // associated with other environments so we can filter these out in\n-                // the per-user group listing in handleUser.\n-                wags.entrySet().forEach(wagEntry -> {\n-                    WorkloadAdministrationGroup wag = wagEntry.getKey();\n-                    String groupName = wag.getWorkloadAdministrationGroupName();\n-                    if (wag.getResource().equalsIgnoreCase(environmentCrn)) {\n-                        usersStateBuilder.addGroup(wagEntry.getValue());\n-                    } else {\n-                        Crn resourceCrn = getCrn(wag);\n-                        if (resourceCrn != null && resourceCrn.getService() == Crn.Service.ENVIRONMENTS\n-                                && resourceCrn.getResourceType() == ResourceType.ENVIRONMENT) {\n-                            wagNamesForOtherEnvironments.add(groupName);\n-                        }\n-                    }\n-                });\n+            Map<String, UmsUsersState> envUsersStateMap;\n+            if (fullSync && entitlementService.umsUserSyncModelGenerationEnabled(INTERNAL_ACTOR_CRN, accountId)) {\n+                envUsersStateMap = getUmsUsersStateMapBulk(accountId, environmentCrns, requestIdOptional);\n+            } else {\n+                envUsersStateMap = getUmsUsersStateMap(\n+                        accountId, actorCrn,\n+                        environmentCrns, userCrns, machineUserCrns,\n+                        requestIdOptional, fullSync);\n+            }\n \n-                // Add internal usersync group for each environment\n-                usersStateBuilder.addGroup(nameToGroup(UserSyncConstants.CDP_USERSYNC_INTERNAL_GROUP));\n+            return envUsersStateMap;\n+        } catch (RuntimeException e) {\n+            throw new UmsOperationException(String.format(\"Error during UMS operation: '%s'\", e.getLocalizedMessage()), e);\n+        }\n+    }\n \n-                EnvironmentAccessChecker environmentAccessChecker = createEnvironmentAccessChecker(environmentCrn);\n+    @VisibleForTesting\n+    Map<String, UmsUsersState> getUmsUsersStateMapBulk(\n+            String accountId, Collection<String> environmentCrns, Optional<String> requestIdOptional) {\n+\n+        List<String> environmentCrnList = List.copyOf(environmentCrns);\n+        GetUserSyncStateModelResponse userSyncStateModel = grpcUmsClient.getUserSyncStateModel(\n+                INTERNAL_ACTOR_CRN,\n+                accountId,\n+                generateRightsChecksForEnvironments(environmentCrnList),\n+                requestIdOptional);\n+\n+        Map<String, FmsGroup> groups = convertGroupsToFmsGroups(userSyncStateModel.getGroupList());\n+        Map<WorkloadAdministrationGroup, FmsGroup> wags =\n+                convertWagsToFmsGroups(userSyncStateModel.getWorkloadAdministrationGroupList());\n+        List<String> requestedWorkloadUsernames = userSyncStateModel.getActorList().stream()\n+                .map(UserManagementProto.UserSyncActor::getActorDetails)\n+                .map(UserManagementProto.UserSyncActorDetails::getWorkloadUsername)\n+                .collect(Collectors.toList());\n+\n+        Map<String, UmsUsersState> umsUsersStateMap = Maps.newHashMap();\n+        IntStream.range(0, environmentCrnList.size())\n+                .forEach(environmentIndex -> {\n+                    String environmentCrn = environmentCrnList.get(environmentIndex);\n+                    UmsUsersState.Builder umsUsersStateBuilder = UmsUsersState.newBuilder()\n+                            .setWorkloadAdministrationGroups(wags.values());\n+                    UsersState.Builder usersStateBuilder = UsersState.newBuilder();\n+                    addRequestedWorkloadUsernames(umsUsersStateBuilder, requestedWorkloadUsernames);\n+                    addGroupsToUsersStateBuilder(usersStateBuilder, groups.values());\n+                    Set<String> wagNamesForOtherEnvironments =\n+                            addWagsToUsersStateBuilder(usersStateBuilder, wags, environmentCrn);\n+                    addActorsToUmsUsersStateBuilder(\n+                            umsUsersStateBuilder,\n+                            usersStateBuilder,\n+                            environmentIndex,\n+                            userSyncStateModel,\n+                            groups,\n+                            wagNamesForOtherEnvironments);\n+                    addServicePrinciplesCloudIdentities(\n+                            accountId, environmentCrn, umsUsersStateBuilder, requestIdOptional);\n+                    umsUsersStateBuilder.setUsersState(usersStateBuilder.build());\n+                    umsUsersStateMap.put(environmentCrn, umsUsersStateBuilder.build());\n+                });\n+        return umsUsersStateMap;\n+    }\n \n-                users.forEach(u -> {\n-                    FmsUser fmsUser = umsUserToUser(u);\n-                    // add workload username for each user. This will be helpful in getting users from IPA.\n-                    umsUsersStateBuilder.addRequestedWorkloadUsers(fmsUser);\n+    @VisibleForTesting\n+    Map<String, UmsUsersState> getUmsUsersStateMap(\n+            String accountId, String actorCrn, Collection<String> environmentCrns,\n+            Set<String> userCrns, Set<String> machineUserCrns, Optional<String> requestIdOptional,\n+            boolean fullSync) {\n+        List<User> users = getUsers(actorCrn, accountId, requestIdOptional, fullSync, userCrns);\n+        List<MachineUser> machineUsers = getMachineUsers(actorCrn, accountId, requestIdOptional, fullSync, machineUserCrns);\n+\n+        Map<String, FmsGroup> crnToFmsGroup = convertGroupsToFmsGroups(\n+                grpcUmsClient.listAllGroups(INTERNAL_ACTOR_CRN, accountId, requestIdOptional));\n+        Map<WorkloadAdministrationGroup, FmsGroup> wags = convertWagsToFmsGroups(\n+                grpcUmsClient.listWorkloadAdministrationGroups(INTERNAL_ACTOR_CRN, accountId, requestIdOptional));\n+        List<String> requestedWorkloadUsernames = Streams.concat(\n+                users.stream().map(User::getWorkloadUsername),\n+                machineUsers.stream().map(MachineUser::getWorkloadUsername))\n+                .collect(Collectors.toList());\n+\n+        Map<String, UmsUsersState> umsUsersStateMap = new HashMap<>();\n+        environmentCrns.forEach(environmentCrn -> {\n+            UmsUsersState.Builder umsUsersStateBuilder = new UmsUsersState.Builder()\n+                    .setWorkloadAdministrationGroups(wags.values());\n+            UsersState.Builder usersStateBuilder = new UsersState.Builder();\n+            addRequestedWorkloadUsernames(umsUsersStateBuilder, requestedWorkloadUsernames);\n+            addGroupsToUsersStateBuilder(usersStateBuilder, crnToFmsGroup.values());\n+            Set<String> wagNamesForOtherEnvironments =\n+                    addWagsToUsersStateBuilder(usersStateBuilder, wags, environmentCrn);\n+\n+            EnvironmentAccessChecker environmentAccessChecker = createEnvironmentAccessChecker(environmentCrn);\n+            TriConsumer<String, FmsUser, List<CloudIdentity>> actorHandler =", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "73d6dc30ed172b314b02349317c6ab811980703c"}, "originalPosition": 212}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "73d6dc30ed172b314b02349317c6ab811980703c", "author": {"user": {"login": "handavid", "name": "David Han"}}, "url": "https://github.com/hortonworks/cloudbreak/commit/73d6dc30ed172b314b02349317c6ab811980703c", "committedDate": "2020-09-17T22:24:16Z", "message": "CDPCP-2990. User sync uses bulk UMS api\n\nThe UMS introduced an API that returns the user sync state\nfrom the UMS in one request. This is used to avoid the many\nnetwork roundtrips when the FMS builds the state through\nindividual UMS requests.\n\nChanges include:\n- Bulk of the changes are to the UmsUsersStateProvider. This has been refactored\n  to support using either the bulk api or individual apis for full sync. This\n  behavior is protected by an entitlement.\n- Unit tests were added to ensure that both codepaths yield the same results\n- usermanagement.proto and ums client classes  updated to include the new API\n- mock user management service updated to the changes in the GetRightsRequest\n- EventGenerationId code updated to use the shared model instead of the\n  individual fields\n- Fixed typo in CloudIdentitySyncService methods and tests"}, "afterCommit": {"oid": "c69be1a0dfc5f764318a0d2250bfbe145b4162c9", "author": {"user": {"login": "handavid", "name": "David Han"}}, "url": "https://github.com/hortonworks/cloudbreak/commit/c69be1a0dfc5f764318a0d2250bfbe145b4162c9", "committedDate": "2020-09-21T15:32:59Z", "message": "refactored ums users state provider into smaller pieces"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "c69be1a0dfc5f764318a0d2250bfbe145b4162c9", "author": {"user": {"login": "handavid", "name": "David Han"}}, "url": "https://github.com/hortonworks/cloudbreak/commit/c69be1a0dfc5f764318a0d2250bfbe145b4162c9", "committedDate": "2020-09-21T15:32:59Z", "message": "refactored ums users state provider into smaller pieces"}, "afterCommit": {"oid": "4dff6ce4c28f7723eb8f4e50e4fcede872847d06", "author": {"user": {"login": "handavid", "name": "David Han"}}, "url": "https://github.com/hortonworks/cloudbreak/commit/4dff6ce4c28f7723eb8f4e50e4fcede872847d06", "committedDate": "2020-09-21T16:13:07Z", "message": "refactored ums users state provider into smaller pieces"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "4dff6ce4c28f7723eb8f4e50e4fcede872847d06", "author": {"user": {"login": "handavid", "name": "David Han"}}, "url": "https://github.com/hortonworks/cloudbreak/commit/4dff6ce4c28f7723eb8f4e50e4fcede872847d06", "committedDate": "2020-09-21T16:13:07Z", "message": "refactored ums users state provider into smaller pieces"}, "afterCommit": {"oid": "0927c027c9a1887a66f65822e2ea1c20c82a461d", "author": {"user": {"login": "handavid", "name": "David Han"}}, "url": "https://github.com/hortonworks/cloudbreak/commit/0927c027c9a1887a66f65822e2ea1c20c82a461d", "committedDate": "2020-09-22T05:51:02Z", "message": "CDPCP-2990. User sync uses bulk UMS api\n\nThe UMS introduced an API that returns the user sync state\nfrom the UMS in one request. This is used to avoid the many\nnetwork roundtrips when the FMS builds the state through\nindividual UMS requests.\n\nChanges include:\n- Bulk of the changes are to the UmsUsersStateProvider. This has been refactored\n  to support using either the bulk api or individual apis for full sync. This\n  behavior is protected by an entitlement. The class has also been divided into\n  smaller, more focused classes.\n- Unit tests were added to ensure that both codepaths yield the same results\n- usermanagement.proto and ums client classes  updated to include the new API\n- mock user management service updated to the changes in the GetRightsRequest\n- EventGenerationId code updated to use the shared model instead of the\n  individual fields\n- Fixed typo in CloudIdentitySyncService methods and tests"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDkzNTU5Nzk3", "url": "https://github.com/hortonworks/cloudbreak/pull/9010#pullrequestreview-493559797", "createdAt": "2020-09-22T15:03:10Z", "commit": {"oid": "0927c027c9a1887a66f65822e2ea1c20c82a461d"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMlQxNTowMzoxMFrOHV-qoQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMlQxNTowMzoxMFrOHV-qoQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjgwODg2NQ==", "bodyText": "so there is a EnvironmentRightChecksFactory, and I'm a bit confused at first blink which is which and why.", "url": "https://github.com/hortonworks/cloudbreak/pull/9010#discussion_r492808865", "createdAt": "2020-09-22T15:03:10Z", "author": {"login": "lacikaaa"}, "path": "freeipa/src/main/java/com/sequenceiq/freeipa/service/freeipa/user/ums/EnvironmentsRightsChecksFactory.java", "diffHunk": "@@ -0,0 +1,20 @@\n+package com.sequenceiq.freeipa.service.freeipa.user.ums;\n+\n+import com.cloudera.thunderhead.service.usermanagement.UserManagementProto;\n+import com.sequenceiq.freeipa.service.freeipa.user.UserSyncConstants;\n+import org.springframework.stereotype.Component;\n+\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+@Component\n+public class EnvironmentsRightsChecksFactory {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0927c027c9a1887a66f65822e2ea1c20c82a461d"}, "originalPosition": 11}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDkzNTc2NTkx", "url": "https://github.com/hortonworks/cloudbreak/pull/9010#pullrequestreview-493576591", "createdAt": "2020-09-22T15:17:52Z", "commit": {"oid": "0927c027c9a1887a66f65822e2ea1c20c82a461d"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMlQxNToxNzo1MlrOHV_d2Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMlQxNToxNzo1MlrOHV_d2Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjgyMTk3Nw==", "bodyText": "I don't think you need inject on constructor", "url": "https://github.com/hortonworks/cloudbreak/pull/9010#discussion_r492821977", "createdAt": "2020-09-22T15:17:52Z", "author": {"login": "lacikaaa"}, "path": "freeipa/src/main/java/com/sequenceiq/freeipa/service/freeipa/user/ums/BulkUmsUsersStateProvider.java", "diffHunk": "@@ -0,0 +1,137 @@\n+package com.sequenceiq.freeipa.service.freeipa.user.ums;\n+\n+import com.cloudera.thunderhead.service.usermanagement.UserManagementProto;\n+import com.google.common.collect.Maps;\n+import com.sequenceiq.cloudbreak.auth.altus.GrpcUmsClient;\n+import com.sequenceiq.freeipa.service.freeipa.user.conversion.FmsGroupConverter;\n+import com.sequenceiq.freeipa.service.freeipa.user.conversion.FmsUserConverter;\n+import com.sequenceiq.freeipa.service.freeipa.user.conversion.WorkloadCredentialConverter;\n+import com.sequenceiq.freeipa.service.freeipa.user.model.EnvironmentAccessRights;\n+import com.sequenceiq.freeipa.service.freeipa.user.model.FmsGroup;\n+import com.sequenceiq.freeipa.service.freeipa.user.model.UmsUsersState;\n+import com.sequenceiq.freeipa.service.freeipa.user.model.UsersState;\n+import com.sequenceiq.freeipa.service.freeipa.user.model.WorkloadCredential;\n+import org.springframework.stereotype.Component;\n+\n+import javax.inject.Inject;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.function.Supplier;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+\n+import static com.sequenceiq.cloudbreak.auth.ThreadBasedUserCrnProvider.INTERNAL_ACTOR_CRN;\n+\n+@Component\n+public class BulkUmsUsersStateProvider extends BaseUmsUsersStateProvider {\n+    @Inject\n+    private GrpcUmsClient grpcUmsClient;\n+\n+    @Inject\n+    private EnvironmentsRightsChecksFactory environmentsRightsChecksFactory;\n+\n+    @Inject\n+    private FmsUserConverter fmsUserConverter;\n+\n+    @Inject\n+    private WorkloadCredentialConverter workloadCredentialConverter;\n+\n+    @Inject", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0927c027c9a1887a66f65822e2ea1c20c82a461d"}, "originalPosition": 42}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDkzNTc3NDQz", "url": "https://github.com/hortonworks/cloudbreak/pull/9010#pullrequestreview-493577443", "createdAt": "2020-09-22T15:18:44Z", "commit": {"oid": "0927c027c9a1887a66f65822e2ea1c20c82a461d"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMlQxNToxODo0NFrOHV_gWA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMlQxNToxODo0NFrOHV_gWA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjgyMjYxNg==", "bodyText": "same here", "url": "https://github.com/hortonworks/cloudbreak/pull/9010#discussion_r492822616", "createdAt": "2020-09-22T15:18:44Z", "author": {"login": "lacikaaa"}, "path": "freeipa/src/main/java/com/sequenceiq/freeipa/service/freeipa/user/ums/DefaultUmsUsersStateProvider.java", "diffHunk": "@@ -0,0 +1,175 @@\n+package com.sequenceiq.freeipa.service.freeipa.user.ums;\n+\n+import com.cloudera.thunderhead.service.usermanagement.UserManagementProto;\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.collect.Streams;\n+import com.sequenceiq.cloudbreak.auth.altus.GrpcUmsClient;\n+import com.sequenceiq.freeipa.service.freeipa.user.conversion.FmsGroupConverter;\n+import com.sequenceiq.freeipa.service.freeipa.user.conversion.FmsUserConverter;\n+import com.sequenceiq.freeipa.service.freeipa.user.model.FmsGroup;\n+import com.sequenceiq.freeipa.service.freeipa.user.model.FmsUser;\n+import com.sequenceiq.freeipa.service.freeipa.user.model.UmsUsersState;\n+import com.sequenceiq.freeipa.service.freeipa.user.model.UsersState;\n+import com.sequenceiq.freeipa.service.freeipa.user.model.WorkloadCredential;\n+import io.grpc.Status;\n+import io.grpc.StatusRuntimeException;\n+import org.apache.logging.log4j.util.TriConsumer;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.stereotype.Component;\n+\n+import javax.inject.Inject;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.function.Supplier;\n+import java.util.stream.Collectors;\n+\n+import static com.sequenceiq.cloudbreak.auth.ThreadBasedUserCrnProvider.INTERNAL_ACTOR_CRN;\n+import static java.util.Objects.requireNonNull;\n+\n+@Component\n+public class DefaultUmsUsersStateProvider extends BaseUmsUsersStateProvider {\n+    @VisibleForTesting\n+    static final boolean INCLUDE_INTERNAL_MACHINE_USERS = true;\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(DefaultUmsUsersStateProvider.class);\n+\n+    @Inject\n+    private GrpcUmsClient grpcUmsClient;\n+\n+    @Inject\n+    private EnvironmentAccessCheckerFactory environmentAccessCheckerFactory;\n+\n+    @Inject\n+    private UmsCredentialProvider umsCredentialProvider;\n+\n+    @Inject\n+    private FmsUserConverter fmsUserConverter;\n+\n+    @Inject", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0927c027c9a1887a66f65822e2ea1c20c82a461d"}, "originalPosition": 53}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDkzNTc4OTIw", "url": "https://github.com/hortonworks/cloudbreak/pull/9010#pullrequestreview-493578920", "createdAt": "2020-09-22T15:20:15Z", "commit": {"oid": "0927c027c9a1887a66f65822e2ea1c20c82a461d"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMlQxNToyMDoxNVrOHV_lCw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMlQxNToyMDoxNVrOHV_lCw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjgyMzgxOQ==", "bodyText": "it's a bit strange to depend on something from a logging library which is not log related", "url": "https://github.com/hortonworks/cloudbreak/pull/9010#discussion_r492823819", "createdAt": "2020-09-22T15:20:15Z", "author": {"login": "lacikaaa"}, "path": "freeipa/src/main/java/com/sequenceiq/freeipa/service/freeipa/user/ums/DefaultUmsUsersStateProvider.java", "diffHunk": "@@ -0,0 +1,175 @@\n+package com.sequenceiq.freeipa.service.freeipa.user.ums;\n+\n+import com.cloudera.thunderhead.service.usermanagement.UserManagementProto;\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.collect.Streams;\n+import com.sequenceiq.cloudbreak.auth.altus.GrpcUmsClient;\n+import com.sequenceiq.freeipa.service.freeipa.user.conversion.FmsGroupConverter;\n+import com.sequenceiq.freeipa.service.freeipa.user.conversion.FmsUserConverter;\n+import com.sequenceiq.freeipa.service.freeipa.user.model.FmsGroup;\n+import com.sequenceiq.freeipa.service.freeipa.user.model.FmsUser;\n+import com.sequenceiq.freeipa.service.freeipa.user.model.UmsUsersState;\n+import com.sequenceiq.freeipa.service.freeipa.user.model.UsersState;\n+import com.sequenceiq.freeipa.service.freeipa.user.model.WorkloadCredential;\n+import io.grpc.Status;\n+import io.grpc.StatusRuntimeException;\n+import org.apache.logging.log4j.util.TriConsumer;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.stereotype.Component;\n+\n+import javax.inject.Inject;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.function.Supplier;\n+import java.util.stream.Collectors;\n+\n+import static com.sequenceiq.cloudbreak.auth.ThreadBasedUserCrnProvider.INTERNAL_ACTOR_CRN;\n+import static java.util.Objects.requireNonNull;\n+\n+@Component\n+public class DefaultUmsUsersStateProvider extends BaseUmsUsersStateProvider {\n+    @VisibleForTesting\n+    static final boolean INCLUDE_INTERNAL_MACHINE_USERS = true;\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(DefaultUmsUsersStateProvider.class);\n+\n+    @Inject\n+    private GrpcUmsClient grpcUmsClient;\n+\n+    @Inject\n+    private EnvironmentAccessCheckerFactory environmentAccessCheckerFactory;\n+\n+    @Inject\n+    private UmsCredentialProvider umsCredentialProvider;\n+\n+    @Inject\n+    private FmsUserConverter fmsUserConverter;\n+\n+    @Inject\n+    public DefaultUmsUsersStateProvider(FmsGroupConverter fmsGroupConverter) {\n+        super(fmsGroupConverter);\n+    }\n+\n+    public Map<String, UmsUsersState> get(\n+            String accountId, String actorCrn,\n+            Collection<String> environmentCrns, Set<String> userCrns, Set<String> machineUserCrns,\n+            Optional<String> requestIdOptional, boolean fullSync) {\n+        List<UserManagementProto.User> users = getUsers(actorCrn, accountId, requestIdOptional, fullSync, userCrns);\n+        List<UserManagementProto.MachineUser> machineUsers =\n+                getMachineUsers(actorCrn, accountId, requestIdOptional, fullSync, machineUserCrns);\n+\n+        Map<String, FmsGroup> crnToFmsGroup = convertGroupsToFmsGroups(\n+                grpcUmsClient.listAllGroups(INTERNAL_ACTOR_CRN, accountId, requestIdOptional));\n+        Map<UserManagementProto.WorkloadAdministrationGroup, FmsGroup> wags = convertWagsToFmsGroups(\n+                grpcUmsClient.listWorkloadAdministrationGroups(INTERNAL_ACTOR_CRN, accountId, requestIdOptional));\n+        List<String> requestedWorkloadUsernames = Streams.concat(\n+                users.stream().map(UserManagementProto.User::getWorkloadUsername),\n+                machineUsers.stream().map(UserManagementProto.MachineUser::getWorkloadUsername))\n+                .collect(Collectors.toList());\n+\n+        Map<String, UmsUsersState> umsUsersStateMap = new HashMap<>();\n+        environmentCrns.forEach(environmentCrn -> {\n+            UmsUsersState.Builder umsUsersStateBuilder = new UmsUsersState.Builder()\n+                    .setWorkloadAdministrationGroups(wags.values());\n+            UsersState.Builder usersStateBuilder = new UsersState.Builder();\n+\n+            addRequestedWorkloadUsernames(umsUsersStateBuilder, requestedWorkloadUsernames);\n+            addGroupsToUsersStateBuilder(usersStateBuilder, crnToFmsGroup.values());\n+            Set<String> wagNamesForOtherEnvironments =\n+                    addWagsToUsersStateBuilder(usersStateBuilder, wags, environmentCrn);\n+\n+            ActorHandler actorHandler = ActorHandler.newBuilder()\n+                    .withFmsGroupConverter(getFmsGroupConverter())\n+                    .withUmsUsersStateBuilder(umsUsersStateBuilder)\n+                    .withUsersStateBuilder(usersStateBuilder)\n+                    .withCrnToFmsGroup(crnToFmsGroup)\n+                    .withWagNamesForOtherEnvironments(wagNamesForOtherEnvironments)\n+                    .build();\n+            EnvironmentAccessChecker environmentAccessChecker = createEnvironmentAccessChecker(environmentCrn);\n+            TriConsumer<String, FmsUser, List<UserManagementProto.CloudIdentity>> actorConsumer =\n+                    createActorConsumer(accountId, environmentAccessChecker, actorHandler, requestIdOptional);\n+            users.forEach(u -> actorConsumer.accept(u.getCrn(), fmsUserConverter.toFmsUser(u), u.getCloudIdentitiesList()));\n+            machineUsers.forEach(mu -> actorConsumer.accept(mu.getCrn(), fmsUserConverter.toFmsUser(mu), mu.getCloudIdentitiesList()));\n+\n+            addServicePrincipalsCloudIdentities(\n+                    umsUsersStateBuilder,\n+                    grpcUmsClient.listServicePrincipalCloudIdentities(\n+                            INTERNAL_ACTOR_CRN, accountId, environmentCrn, requestIdOptional));\n+\n+            umsUsersStateBuilder.setUsersState(usersStateBuilder.build());\n+            umsUsersStateMap.put(environmentCrn, umsUsersStateBuilder.build());\n+        });\n+        return umsUsersStateMap;\n+    }\n+\n+    private TriConsumer<String, FmsUser, List<UserManagementProto.CloudIdentity>> createActorConsumer(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0927c027c9a1887a66f65822e2ea1c20c82a461d"}, "originalPosition": 110}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ec901f5240fce7cf22f5b20421fab4616dee6a69", "author": {"user": {"login": "handavid", "name": "David Han"}}, "url": "https://github.com/hortonworks/cloudbreak/commit/ec901f5240fce7cf22f5b20421fab4616dee6a69", "committedDate": "2020-09-22T17:02:58Z", "message": "CDPCP-2990. User sync uses bulk UMS api\n\nThe UMS introduced an API that returns the user sync state\nfrom the UMS in one request. This is used to avoid the many\nnetwork roundtrips when the FMS builds the state through\nindividual UMS requests.\n\nChanges include:\n- Bulk of the changes are to the UmsUsersStateProvider. This has been refactored\n  to support using either the bulk api or individual apis for full sync. This\n  behavior is protected by an entitlement. The class has also been divided into\n  smaller, more focused classes.\n- Unit tests were added to ensure that both codepaths yield the same results\n- usermanagement.proto and ums client classes  updated to include the new API\n- mock user management service updated to the changes in the GetRightsRequest\n- EventGenerationId code updated to use the shared model instead of the\n  individual fields\n- Fixed typo in CloudIdentitySyncService methods and tests"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "0927c027c9a1887a66f65822e2ea1c20c82a461d", "author": {"user": {"login": "handavid", "name": "David Han"}}, "url": "https://github.com/hortonworks/cloudbreak/commit/0927c027c9a1887a66f65822e2ea1c20c82a461d", "committedDate": "2020-09-22T05:51:02Z", "message": "CDPCP-2990. User sync uses bulk UMS api\n\nThe UMS introduced an API that returns the user sync state\nfrom the UMS in one request. This is used to avoid the many\nnetwork roundtrips when the FMS builds the state through\nindividual UMS requests.\n\nChanges include:\n- Bulk of the changes are to the UmsUsersStateProvider. This has been refactored\n  to support using either the bulk api or individual apis for full sync. This\n  behavior is protected by an entitlement. The class has also been divided into\n  smaller, more focused classes.\n- Unit tests were added to ensure that both codepaths yield the same results\n- usermanagement.proto and ums client classes  updated to include the new API\n- mock user management service updated to the changes in the GetRightsRequest\n- EventGenerationId code updated to use the shared model instead of the\n  individual fields\n- Fixed typo in CloudIdentitySyncService methods and tests"}, "afterCommit": {"oid": "ec901f5240fce7cf22f5b20421fab4616dee6a69", "author": {"user": {"login": "handavid", "name": "David Han"}}, "url": "https://github.com/hortonworks/cloudbreak/commit/ec901f5240fce7cf22f5b20421fab4616dee6a69", "committedDate": "2020-09-22T17:02:58Z", "message": "CDPCP-2990. User sync uses bulk UMS api\n\nThe UMS introduced an API that returns the user sync state\nfrom the UMS in one request. This is used to avoid the many\nnetwork roundtrips when the FMS builds the state through\nindividual UMS requests.\n\nChanges include:\n- Bulk of the changes are to the UmsUsersStateProvider. This has been refactored\n  to support using either the bulk api or individual apis for full sync. This\n  behavior is protected by an entitlement. The class has also been divided into\n  smaller, more focused classes.\n- Unit tests were added to ensure that both codepaths yield the same results\n- usermanagement.proto and ums client classes  updated to include the new API\n- mock user management service updated to the changes in the GetRightsRequest\n- EventGenerationId code updated to use the shared model instead of the\n  individual fields\n- Fixed typo in CloudIdentitySyncService methods and tests"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDk0MzU0NzM5", "url": "https://github.com/hortonworks/cloudbreak/pull/9010#pullrequestreview-494354739", "createdAt": "2020-09-23T07:31:54Z", "commit": {"oid": "ec901f5240fce7cf22f5b20421fab4616dee6a69"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2323, "cost": 1, "resetAt": "2021-11-01T14:51:55Z"}}}