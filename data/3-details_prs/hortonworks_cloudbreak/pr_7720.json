{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzk3NTE4MDI0", "number": 7720, "title": "CB-5734 Additional Validations for DistroX Autoscale API", "bodyText": "CB-5734 Additional Validations\n\nLoad Based Scaling Enabled only for clusters with cluster-proxy tunnel.\nAdditional Validation for invalid crn or name.", "createdAt": "2020-04-02T11:26:06Z", "url": "https://github.com/hortonworks/cloudbreak/pull/7720", "merged": true, "mergeCommit": {"oid": "0b3d9bc035029dacdf8fd0f72564c7c60eb00181"}, "closed": true, "closedAt": "2020-04-06T08:14:11Z", "author": {"login": "smaniraju"}, "timelineItems": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcTzXtfAFqTM4Njc4OTgzMg==", "endCursor": "Y3Vyc29yOnYyOpPPAAABcUAEFrABqjMxOTYxODc4NjM=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg2Nzg5ODMy", "url": "https://github.com/hortonworks/cloudbreak/pull/7720#pullrequestreview-386789832", "createdAt": "2020-04-02T21:28:17Z", "commit": {"oid": "43edbd16cb6d455a671bf51df90576fb488558ff"}, "state": "APPROVED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMlQyMToyODoxN1rOF_9KGw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMlQyMToyOTo1M1rOF_9M_Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjYwNjYxOQ==", "bodyText": "Do we need to check for the existence of the hostGroup in the cluster?", "url": "https://github.com/hortonworks/cloudbreak/pull/7720#discussion_r402606619", "createdAt": "2020-04-02T21:28:17Z", "author": {"login": "sidseth"}, "path": "autoscale/src/main/java/com/sequenceiq/periscope/controller/AlertController.java", "diffHunk": "@@ -229,14 +224,34 @@ private LoadAlertResponse createLoadAlertResponse(LoadAlert loadAlert) {\n         return loadAlertResponseConverter.convert(loadAlert);\n     }\n \n-    private void validateTimeAlert(Long clusterId, Optional<Long> alertId, TimeAlertRequest json) throws ParseException {\n-        validateAlertForUpdate(clusterId, alertId, AlertType.TIME);\n-        dateService.validateTimeZone(json.getTimeZone());\n-        dateService.getCronExpression(json.getCron());\n+    private void validateTimeAlert(Long clusterId, Optional<Long> alertId, TimeAlertRequest json) {\n+        alertId.ifPresent(alert -> validateAlertForUpdate(clusterId, alert, AlertType.TIME));\n+        try {\n+            dateService.validateTimeZone(json.getTimeZone());\n+            dateService.getCronExpression(json.getCron());\n+        } catch (ParseException parseException) {\n+            throw new BadRequestException(parseException.getMessage(), parseException);\n+        }\n     }\n \n-    private void validateLoadAlert(Long clusterId, Optional<Long> alertId, LoadAlertRequest json) throws ParseException {\n-        validateAlertForUpdate(clusterId, alertId, AlertType.LOAD);\n+    private void validateLoadAlert(Long clusterId, Optional<Long> alertId, LoadAlertRequest json) {\n+        Cluster cluster = clusterService.findById(clusterId);\n+        alertId.ifPresentOrElse(\n+                updateAlert -> {\n+                    validateAlertForUpdate(clusterId, updateAlert, AlertType.LOAD);\n+                }, () -> {\n+                    if (!cluster.getTunnel().useClusterProxy()) {\n+                        throw new BadRequestException(String.format(\"Cluster '%s' is not configured with Cluster Proxy Tunnel, \" +\n+                                \"Cluster Tunnel is %s. Load Based Scaling not supported\", cluster.getStackCrn(), cluster.getTunnel()));\n+                    }\n+\n+                    String hostGroup = json.getScalingPolicy().getHostGroup();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "43edbd16cb6d455a671bf51df90576fb488558ff"}, "originalPosition": 110}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjYwNzIwOQ==", "bodyText": "This looks good based on the assumption that we're going with w.r.t all clusters using the ClusterProxy. Will have to include this in the documentation eventually.", "url": "https://github.com/hortonworks/cloudbreak/pull/7720#discussion_r402607209", "createdAt": "2020-04-02T21:29:32Z", "author": {"login": "sidseth"}, "path": "autoscale/src/main/java/com/sequenceiq/periscope/controller/AlertController.java", "diffHunk": "@@ -229,14 +224,34 @@ private LoadAlertResponse createLoadAlertResponse(LoadAlert loadAlert) {\n         return loadAlertResponseConverter.convert(loadAlert);\n     }\n \n-    private void validateTimeAlert(Long clusterId, Optional<Long> alertId, TimeAlertRequest json) throws ParseException {\n-        validateAlertForUpdate(clusterId, alertId, AlertType.TIME);\n-        dateService.validateTimeZone(json.getTimeZone());\n-        dateService.getCronExpression(json.getCron());\n+    private void validateTimeAlert(Long clusterId, Optional<Long> alertId, TimeAlertRequest json) {\n+        alertId.ifPresent(alert -> validateAlertForUpdate(clusterId, alert, AlertType.TIME));\n+        try {\n+            dateService.validateTimeZone(json.getTimeZone());\n+            dateService.getCronExpression(json.getCron());\n+        } catch (ParseException parseException) {\n+            throw new BadRequestException(parseException.getMessage(), parseException);\n+        }\n     }\n \n-    private void validateLoadAlert(Long clusterId, Optional<Long> alertId, LoadAlertRequest json) throws ParseException {\n-        validateAlertForUpdate(clusterId, alertId, AlertType.LOAD);\n+    private void validateLoadAlert(Long clusterId, Optional<Long> alertId, LoadAlertRequest json) {\n+        Cluster cluster = clusterService.findById(clusterId);\n+        alertId.ifPresentOrElse(\n+                updateAlert -> {\n+                    validateAlertForUpdate(clusterId, updateAlert, AlertType.LOAD);\n+                }, () -> {\n+                    if (!cluster.getTunnel().useClusterProxy()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "43edbd16cb6d455a671bf51df90576fb488558ff"}, "originalPosition": 105}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjYwNzM1Nw==", "bodyText": "Nit: Move into the (alert == null) block.", "url": "https://github.com/hortonworks/cloudbreak/pull/7720#discussion_r402607357", "createdAt": "2020-04-02T21:29:53Z", "author": {"login": "sidseth"}, "path": "autoscale/src/main/java/com/sequenceiq/periscope/controller/AlertController.java", "diffHunk": "@@ -265,30 +280,27 @@ private PrometheusAlertResponse createPrometheusAlertResponse(PrometheusAlert al\n         return prometheusAlertResponseConverter.convert(alarm);\n     }\n \n-    private void validateAlertForUpdate(Long clusterId, Optional<Long> alertIdRequest, AlertType alertType) {\n-        alertIdRequest.ifPresent(alertId -> {\n-            BaseAlert alert;\n-            String clusterCrn = clusterService.findStackCrnById(clusterId);\n-            switch (alertType) {\n-                case LOAD:\n-                    alert = alertService.findLoadAlertByCluster(clusterId, alertId);\n-                    break;\n-                case TIME:\n-                    alert = alertService.findTimeAlertByCluster(clusterId, alertId);\n-                    break;\n-                case METRIC:\n-                    alert = alertService.findMetricAlertByCluster(clusterId, alertId);\n-                    break;\n-                case PROMETHEUS:\n-                    alert = alertService.findPrometheusAlertByCluster(clusterId, alertId);\n-                    break;\n-                default:\n-                    alert = null;\n-\n-            }\n-            if (alert == null) {\n-                throw new NotFoundException(String.format(\"Could not find %s alert with id: '%s', for cluster: '%s'\", alertType, alertId, clusterCrn));\n-            }\n-        });\n+    private void validateAlertForUpdate(Long clusterId, Long alertId, AlertType alertType) {\n+        BaseAlert alert;\n+        String clusterCrn = clusterService.findStackCrnById(clusterId);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "43edbd16cb6d455a671bf51df90576fb488558ff"}, "originalPosition": 151}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "aa84a242393ead16f0609abe74a28e5fa7cdd619", "author": {"user": {"login": "smaniraju", "name": null}}, "url": "https://github.com/hortonworks/cloudbreak/commit/aa84a242393ead16f0609abe74a28e5fa7cdd619", "committedDate": "2020-04-03T12:27:53Z", "message": "CB-5734 Additional Validations"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "43edbd16cb6d455a671bf51df90576fb488558ff", "author": {"user": {"login": "smaniraju", "name": null}}, "url": "https://github.com/hortonworks/cloudbreak/commit/43edbd16cb6d455a671bf51df90576fb488558ff", "committedDate": "2020-04-02T11:20:47Z", "message": "CB-5734 Additional Validations"}, "afterCommit": {"oid": "aa84a242393ead16f0609abe74a28e5fa7cdd619", "author": {"user": {"login": "smaniraju", "name": null}}, "url": "https://github.com/hortonworks/cloudbreak/commit/aa84a242393ead16f0609abe74a28e5fa7cdd619", "committedDate": "2020-04-03T12:27:53Z", "message": "CB-5734 Additional Validations"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2408, "cost": 1, "resetAt": "2021-11-01T14:51:55Z"}}}