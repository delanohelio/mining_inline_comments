{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTQwNzIxNTI5", "number": 9657, "reviewThreads": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNFQxNzo1OTozNFrOFK_cKg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNFQyMjo0NDoxOFrOFLE6RQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ3MDY5NDgyOnYy", "diffSide": "RIGHT", "path": "freeipa/src/main/java/com/sequenceiq/freeipa/service/stack/FreeIpaInstanceHealthDetailsService.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNFQxNzo1OTozNFrOIN7Xow==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNFQxODo1NjoxN1rOIN9GvA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTQ3NTEwNw==", "bodyText": "found variable is not necessary.  use  (!nodeMatcher.find()) should be good enough.", "url": "https://github.com/hortonworks/cloudbreak/pull/9657#discussion_r551475107", "createdAt": "2021-01-04T17:59:34Z", "author": {"login": "christmasferret"}, "path": "freeipa/src/main/java/com/sequenceiq/freeipa/service/stack/FreeIpaInstanceHealthDetailsService.java", "diffHunk": "@@ -0,0 +1,161 @@\n+package com.sequenceiq.freeipa.service.stack;\n+\n+import java.util.Objects;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+\n+import javax.inject.Inject;\n+import javax.ws.rs.core.Response;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.retry.annotation.Retryable;\n+import org.springframework.stereotype.Service;\n+\n+import com.sequenceiq.freeipa.api.v1.freeipa.stack.model.common.instance.InstanceStatus;\n+import com.sequenceiq.freeipa.api.v1.freeipa.stack.model.health.NodeHealthDetails;\n+import com.sequenceiq.freeipa.client.FreeIpaClient;\n+import com.sequenceiq.freeipa.client.FreeIpaClientException;\n+import com.sequenceiq.freeipa.client.FreeIpaHealthCheckClient;\n+import com.sequenceiq.freeipa.client.FreeIpaHealthCheckClientFactory;\n+import com.sequenceiq.freeipa.client.RetryableFreeIpaClientException;\n+import com.sequenceiq.freeipa.client.healthcheckmodel.CheckResult;\n+import com.sequenceiq.freeipa.client.model.RPCMessage;\n+import com.sequenceiq.freeipa.client.model.RPCResponse;\n+import com.sequenceiq.freeipa.entity.InstanceMetaData;\n+import com.sequenceiq.freeipa.entity.Stack;\n+import com.sequenceiq.freeipa.service.freeipa.FreeIpaClientFactory;\n+import com.sequenceiq.freeipa.util.HealthCheckAvailabilityChecker;\n+\n+@Service\n+public class FreeIpaInstanceHealthDetailsService {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(FreeIpaInstanceHealthDetailsService.class);\n+\n+    private static final String EXTERNAL_COMMAND_OUTPUT = \"ExternalCommandOutput\";\n+\n+    private static final String STATUS_OK = \"OK\";\n+\n+    private static final int STATUS_GROUP = 2;\n+\n+    private static final String MESSAGE_UNAVAILABLE = \"Message Unavailable\";\n+\n+    private static final Pattern RESULT_PATTERN = Pattern.compile(\"(ecure port|: TCP) \\\\([0-9]*\\\\): (.*)\");\n+\n+    private static final Pattern NEW_NODE_PATTERN = Pattern.compile(\"Check connection from master to remote replica '(.[^\\']*)\");\n+\n+    @Inject\n+    private FreeIpaClientFactory freeIpaClientFactory;\n+\n+    @Inject\n+    private HealthCheckAvailabilityChecker healthCheckAvailabilityChecker;\n+\n+    @Inject\n+    private FreeIpaHealthCheckClientFactory freeIpaHealthCheckClientFactory;\n+\n+    @Retryable(RetryableFreeIpaClientException.class)\n+    public NodeHealthDetails getInstanceHealthDetails(Stack stack, InstanceMetaData instance) throws FreeIpaClientException {\n+        if (healthCheckAvailabilityChecker.isCdpFreeIpaHeathAgentAvailable(stack)) {\n+            RPCResponse<CheckResult> rpcResponse = freeIpaHealthCheck(stack, instance);\n+            return parseMessages(rpcResponse, instance);\n+        } else {\n+            RPCResponse<Boolean> rpcResponse = legacyFreeIpaHealthCheck(stack, instance);\n+            return legacyParseMessages(rpcResponse, instance);\n+        }\n+    }\n+\n+    @Retryable(RetryableFreeIpaClientException.class)\n+    public RPCResponse<Boolean> checkFreeIpaHealth(Stack stack, InstanceMetaData instance) throws FreeIpaClientException {\n+        RPCResponse<Boolean> result;\n+        if (healthCheckAvailabilityChecker.isCdpFreeIpaHeathAgentAvailable(stack)) {\n+            result = toBooleanRpcResponse(freeIpaHealthCheck(stack, instance));\n+        } else {\n+            result = legacyFreeIpaHealthCheck(stack, instance);\n+        }\n+        return result;\n+    }\n+\n+    private RPCResponse<CheckResult> freeIpaHealthCheck(Stack stack, InstanceMetaData instance) throws FreeIpaClientException {\n+        try (FreeIpaHealthCheckClient client = freeIpaHealthCheckClientFactory.getClient(stack, instance)) {\n+            return client.nodeHealth();\n+        } catch (FreeIpaClientException e) {\n+            throw new RetryableFreeIpaClientException(\"Error during healthcheck\", e);\n+        } catch (Exception e) {\n+            LOGGER.error(\"FreeIPA health check failed\", e);\n+            throw new RetryableFreeIpaClientException(\"FreeIPA health check failed\", e);\n+        }\n+    }\n+\n+    private RPCResponse<Boolean> legacyFreeIpaHealthCheck(Stack stack, InstanceMetaData instance) throws FreeIpaClientException {\n+        FreeIpaClient freeIpaClient = freeIpaClientFactory.getFreeIpaClientForStackForLegacyHealthCheck(stack, instance.getDiscoveryFQDN());\n+        return freeIpaClient.serverConnCheck(freeIpaClient.getHostname(), instance.getDiscoveryFQDN());\n+    }\n+\n+    private RPCResponse<Boolean> toBooleanRpcResponse(RPCResponse<CheckResult> nodeHealth) {\n+        RPCResponse<Boolean> response = new RPCResponse<>();\n+        response.setSummary(nodeHealth.getSummary());\n+        response.setResult(isHealthCheckPassing(nodeHealth));\n+        response.setCount(nodeHealth.getCount());\n+        response.setTruncated(nodeHealth.getTruncated());\n+        response.setMessages(nodeHealth.getMessages());\n+        response.setCompleted(nodeHealth.getCompleted());\n+        response.setFailed(nodeHealth.getFailed());\n+        response.setValue(nodeHealth.getValue());\n+        return response;\n+    }\n+\n+    private NodeHealthDetails parseMessages(RPCResponse<CheckResult> rpcResponse, InstanceMetaData instanceMetaData) {\n+        NodeHealthDetails nodeResponse = new NodeHealthDetails();\n+        nodeResponse.setName(instanceMetaData.getDiscoveryFQDN());\n+        nodeResponse.setInstanceId(instanceMetaData.getInstanceId());\n+        if (isHealthCheckPassing(rpcResponse)) {\n+            nodeResponse.setStatus(InstanceStatus.CREATED);\n+        } else {\n+            nodeResponse.setStatus(InstanceStatus.UNHEALTHY);\n+            nodeResponse.setIssues(rpcResponse.getMessages().stream().map(RPCMessage::getMessage).collect(Collectors.toList()));\n+        }\n+        return nodeResponse;\n+    }\n+\n+    private NodeHealthDetails legacyParseMessages(RPCResponse<Boolean> rpcResponse, InstanceMetaData instanceMetaData) {\n+        String precedingMessage = MESSAGE_UNAVAILABLE;\n+        NodeHealthDetails nodeResponse = new NodeHealthDetails();\n+        nodeResponse.setStatus(rpcResponse.getResult() ? InstanceStatus.CREATED : InstanceStatus.UNHEALTHY);\n+        nodeResponse.setName(instanceMetaData.getDiscoveryFQDN());\n+        nodeResponse.setInstanceId(instanceMetaData.getInstanceId());\n+        boolean found = false;\n+        for (RPCMessage message : rpcResponse.getMessages()) {\n+            Matcher nodeMatcher = NEW_NODE_PATTERN.matcher(message.getMessage());\n+            if (nodeMatcher.find()) {\n+                found = true;\n+            }\n+            if (!found) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "94d1a817196a3c01fde99b3c6aba778a723a7bb9"}, "originalPosition": 133}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTUwMzU0OA==", "bodyText": "found tracks the state over multiple messages. The match should only occur on the first line of multiline output. If it doesn't appear in the first line as expected then the messages are logged.", "url": "https://github.com/hortonworks/cloudbreak/pull/9657#discussion_r551503548", "createdAt": "2021-01-04T18:56:17Z", "author": {"login": "jamisonbennett"}, "path": "freeipa/src/main/java/com/sequenceiq/freeipa/service/stack/FreeIpaInstanceHealthDetailsService.java", "diffHunk": "@@ -0,0 +1,161 @@\n+package com.sequenceiq.freeipa.service.stack;\n+\n+import java.util.Objects;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+\n+import javax.inject.Inject;\n+import javax.ws.rs.core.Response;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.retry.annotation.Retryable;\n+import org.springframework.stereotype.Service;\n+\n+import com.sequenceiq.freeipa.api.v1.freeipa.stack.model.common.instance.InstanceStatus;\n+import com.sequenceiq.freeipa.api.v1.freeipa.stack.model.health.NodeHealthDetails;\n+import com.sequenceiq.freeipa.client.FreeIpaClient;\n+import com.sequenceiq.freeipa.client.FreeIpaClientException;\n+import com.sequenceiq.freeipa.client.FreeIpaHealthCheckClient;\n+import com.sequenceiq.freeipa.client.FreeIpaHealthCheckClientFactory;\n+import com.sequenceiq.freeipa.client.RetryableFreeIpaClientException;\n+import com.sequenceiq.freeipa.client.healthcheckmodel.CheckResult;\n+import com.sequenceiq.freeipa.client.model.RPCMessage;\n+import com.sequenceiq.freeipa.client.model.RPCResponse;\n+import com.sequenceiq.freeipa.entity.InstanceMetaData;\n+import com.sequenceiq.freeipa.entity.Stack;\n+import com.sequenceiq.freeipa.service.freeipa.FreeIpaClientFactory;\n+import com.sequenceiq.freeipa.util.HealthCheckAvailabilityChecker;\n+\n+@Service\n+public class FreeIpaInstanceHealthDetailsService {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(FreeIpaInstanceHealthDetailsService.class);\n+\n+    private static final String EXTERNAL_COMMAND_OUTPUT = \"ExternalCommandOutput\";\n+\n+    private static final String STATUS_OK = \"OK\";\n+\n+    private static final int STATUS_GROUP = 2;\n+\n+    private static final String MESSAGE_UNAVAILABLE = \"Message Unavailable\";\n+\n+    private static final Pattern RESULT_PATTERN = Pattern.compile(\"(ecure port|: TCP) \\\\([0-9]*\\\\): (.*)\");\n+\n+    private static final Pattern NEW_NODE_PATTERN = Pattern.compile(\"Check connection from master to remote replica '(.[^\\']*)\");\n+\n+    @Inject\n+    private FreeIpaClientFactory freeIpaClientFactory;\n+\n+    @Inject\n+    private HealthCheckAvailabilityChecker healthCheckAvailabilityChecker;\n+\n+    @Inject\n+    private FreeIpaHealthCheckClientFactory freeIpaHealthCheckClientFactory;\n+\n+    @Retryable(RetryableFreeIpaClientException.class)\n+    public NodeHealthDetails getInstanceHealthDetails(Stack stack, InstanceMetaData instance) throws FreeIpaClientException {\n+        if (healthCheckAvailabilityChecker.isCdpFreeIpaHeathAgentAvailable(stack)) {\n+            RPCResponse<CheckResult> rpcResponse = freeIpaHealthCheck(stack, instance);\n+            return parseMessages(rpcResponse, instance);\n+        } else {\n+            RPCResponse<Boolean> rpcResponse = legacyFreeIpaHealthCheck(stack, instance);\n+            return legacyParseMessages(rpcResponse, instance);\n+        }\n+    }\n+\n+    @Retryable(RetryableFreeIpaClientException.class)\n+    public RPCResponse<Boolean> checkFreeIpaHealth(Stack stack, InstanceMetaData instance) throws FreeIpaClientException {\n+        RPCResponse<Boolean> result;\n+        if (healthCheckAvailabilityChecker.isCdpFreeIpaHeathAgentAvailable(stack)) {\n+            result = toBooleanRpcResponse(freeIpaHealthCheck(stack, instance));\n+        } else {\n+            result = legacyFreeIpaHealthCheck(stack, instance);\n+        }\n+        return result;\n+    }\n+\n+    private RPCResponse<CheckResult> freeIpaHealthCheck(Stack stack, InstanceMetaData instance) throws FreeIpaClientException {\n+        try (FreeIpaHealthCheckClient client = freeIpaHealthCheckClientFactory.getClient(stack, instance)) {\n+            return client.nodeHealth();\n+        } catch (FreeIpaClientException e) {\n+            throw new RetryableFreeIpaClientException(\"Error during healthcheck\", e);\n+        } catch (Exception e) {\n+            LOGGER.error(\"FreeIPA health check failed\", e);\n+            throw new RetryableFreeIpaClientException(\"FreeIPA health check failed\", e);\n+        }\n+    }\n+\n+    private RPCResponse<Boolean> legacyFreeIpaHealthCheck(Stack stack, InstanceMetaData instance) throws FreeIpaClientException {\n+        FreeIpaClient freeIpaClient = freeIpaClientFactory.getFreeIpaClientForStackForLegacyHealthCheck(stack, instance.getDiscoveryFQDN());\n+        return freeIpaClient.serverConnCheck(freeIpaClient.getHostname(), instance.getDiscoveryFQDN());\n+    }\n+\n+    private RPCResponse<Boolean> toBooleanRpcResponse(RPCResponse<CheckResult> nodeHealth) {\n+        RPCResponse<Boolean> response = new RPCResponse<>();\n+        response.setSummary(nodeHealth.getSummary());\n+        response.setResult(isHealthCheckPassing(nodeHealth));\n+        response.setCount(nodeHealth.getCount());\n+        response.setTruncated(nodeHealth.getTruncated());\n+        response.setMessages(nodeHealth.getMessages());\n+        response.setCompleted(nodeHealth.getCompleted());\n+        response.setFailed(nodeHealth.getFailed());\n+        response.setValue(nodeHealth.getValue());\n+        return response;\n+    }\n+\n+    private NodeHealthDetails parseMessages(RPCResponse<CheckResult> rpcResponse, InstanceMetaData instanceMetaData) {\n+        NodeHealthDetails nodeResponse = new NodeHealthDetails();\n+        nodeResponse.setName(instanceMetaData.getDiscoveryFQDN());\n+        nodeResponse.setInstanceId(instanceMetaData.getInstanceId());\n+        if (isHealthCheckPassing(rpcResponse)) {\n+            nodeResponse.setStatus(InstanceStatus.CREATED);\n+        } else {\n+            nodeResponse.setStatus(InstanceStatus.UNHEALTHY);\n+            nodeResponse.setIssues(rpcResponse.getMessages().stream().map(RPCMessage::getMessage).collect(Collectors.toList()));\n+        }\n+        return nodeResponse;\n+    }\n+\n+    private NodeHealthDetails legacyParseMessages(RPCResponse<Boolean> rpcResponse, InstanceMetaData instanceMetaData) {\n+        String precedingMessage = MESSAGE_UNAVAILABLE;\n+        NodeHealthDetails nodeResponse = new NodeHealthDetails();\n+        nodeResponse.setStatus(rpcResponse.getResult() ? InstanceStatus.CREATED : InstanceStatus.UNHEALTHY);\n+        nodeResponse.setName(instanceMetaData.getDiscoveryFQDN());\n+        nodeResponse.setInstanceId(instanceMetaData.getInstanceId());\n+        boolean found = false;\n+        for (RPCMessage message : rpcResponse.getMessages()) {\n+            Matcher nodeMatcher = NEW_NODE_PATTERN.matcher(message.getMessage());\n+            if (nodeMatcher.find()) {\n+                found = true;\n+            }\n+            if (!found) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTQ3NTEwNw=="}, "originalCommit": {"oid": "94d1a817196a3c01fde99b3c6aba778a723a7bb9"}, "originalPosition": 133}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ3MDY5OTg0OnYy", "diffSide": "RIGHT", "path": "freeipa/src/main/java/com/sequenceiq/freeipa/service/stack/FreeIpaInstanceHealthDetailsService.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNFQxODowMToxM1rOIN7bBg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNFQxODo1ODo0N1rOIN9MEg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTQ3NTk3NA==", "bodyText": "precedingMessage = message.getMessage(); will have no effect here as mutating string will not change the string in nodeResponse above. Could append the message before addIssue()", "url": "https://github.com/hortonworks/cloudbreak/pull/9657#discussion_r551475974", "createdAt": "2021-01-04T18:01:13Z", "author": {"login": "christmasferret"}, "path": "freeipa/src/main/java/com/sequenceiq/freeipa/service/stack/FreeIpaInstanceHealthDetailsService.java", "diffHunk": "@@ -0,0 +1,161 @@\n+package com.sequenceiq.freeipa.service.stack;\n+\n+import java.util.Objects;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+\n+import javax.inject.Inject;\n+import javax.ws.rs.core.Response;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.retry.annotation.Retryable;\n+import org.springframework.stereotype.Service;\n+\n+import com.sequenceiq.freeipa.api.v1.freeipa.stack.model.common.instance.InstanceStatus;\n+import com.sequenceiq.freeipa.api.v1.freeipa.stack.model.health.NodeHealthDetails;\n+import com.sequenceiq.freeipa.client.FreeIpaClient;\n+import com.sequenceiq.freeipa.client.FreeIpaClientException;\n+import com.sequenceiq.freeipa.client.FreeIpaHealthCheckClient;\n+import com.sequenceiq.freeipa.client.FreeIpaHealthCheckClientFactory;\n+import com.sequenceiq.freeipa.client.RetryableFreeIpaClientException;\n+import com.sequenceiq.freeipa.client.healthcheckmodel.CheckResult;\n+import com.sequenceiq.freeipa.client.model.RPCMessage;\n+import com.sequenceiq.freeipa.client.model.RPCResponse;\n+import com.sequenceiq.freeipa.entity.InstanceMetaData;\n+import com.sequenceiq.freeipa.entity.Stack;\n+import com.sequenceiq.freeipa.service.freeipa.FreeIpaClientFactory;\n+import com.sequenceiq.freeipa.util.HealthCheckAvailabilityChecker;\n+\n+@Service\n+public class FreeIpaInstanceHealthDetailsService {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(FreeIpaInstanceHealthDetailsService.class);\n+\n+    private static final String EXTERNAL_COMMAND_OUTPUT = \"ExternalCommandOutput\";\n+\n+    private static final String STATUS_OK = \"OK\";\n+\n+    private static final int STATUS_GROUP = 2;\n+\n+    private static final String MESSAGE_UNAVAILABLE = \"Message Unavailable\";\n+\n+    private static final Pattern RESULT_PATTERN = Pattern.compile(\"(ecure port|: TCP) \\\\([0-9]*\\\\): (.*)\");\n+\n+    private static final Pattern NEW_NODE_PATTERN = Pattern.compile(\"Check connection from master to remote replica '(.[^\\']*)\");\n+\n+    @Inject\n+    private FreeIpaClientFactory freeIpaClientFactory;\n+\n+    @Inject\n+    private HealthCheckAvailabilityChecker healthCheckAvailabilityChecker;\n+\n+    @Inject\n+    private FreeIpaHealthCheckClientFactory freeIpaHealthCheckClientFactory;\n+\n+    @Retryable(RetryableFreeIpaClientException.class)\n+    public NodeHealthDetails getInstanceHealthDetails(Stack stack, InstanceMetaData instance) throws FreeIpaClientException {\n+        if (healthCheckAvailabilityChecker.isCdpFreeIpaHeathAgentAvailable(stack)) {\n+            RPCResponse<CheckResult> rpcResponse = freeIpaHealthCheck(stack, instance);\n+            return parseMessages(rpcResponse, instance);\n+        } else {\n+            RPCResponse<Boolean> rpcResponse = legacyFreeIpaHealthCheck(stack, instance);\n+            return legacyParseMessages(rpcResponse, instance);\n+        }\n+    }\n+\n+    @Retryable(RetryableFreeIpaClientException.class)\n+    public RPCResponse<Boolean> checkFreeIpaHealth(Stack stack, InstanceMetaData instance) throws FreeIpaClientException {\n+        RPCResponse<Boolean> result;\n+        if (healthCheckAvailabilityChecker.isCdpFreeIpaHeathAgentAvailable(stack)) {\n+            result = toBooleanRpcResponse(freeIpaHealthCheck(stack, instance));\n+        } else {\n+            result = legacyFreeIpaHealthCheck(stack, instance);\n+        }\n+        return result;\n+    }\n+\n+    private RPCResponse<CheckResult> freeIpaHealthCheck(Stack stack, InstanceMetaData instance) throws FreeIpaClientException {\n+        try (FreeIpaHealthCheckClient client = freeIpaHealthCheckClientFactory.getClient(stack, instance)) {\n+            return client.nodeHealth();\n+        } catch (FreeIpaClientException e) {\n+            throw new RetryableFreeIpaClientException(\"Error during healthcheck\", e);\n+        } catch (Exception e) {\n+            LOGGER.error(\"FreeIPA health check failed\", e);\n+            throw new RetryableFreeIpaClientException(\"FreeIPA health check failed\", e);\n+        }\n+    }\n+\n+    private RPCResponse<Boolean> legacyFreeIpaHealthCheck(Stack stack, InstanceMetaData instance) throws FreeIpaClientException {\n+        FreeIpaClient freeIpaClient = freeIpaClientFactory.getFreeIpaClientForStackForLegacyHealthCheck(stack, instance.getDiscoveryFQDN());\n+        return freeIpaClient.serverConnCheck(freeIpaClient.getHostname(), instance.getDiscoveryFQDN());\n+    }\n+\n+    private RPCResponse<Boolean> toBooleanRpcResponse(RPCResponse<CheckResult> nodeHealth) {\n+        RPCResponse<Boolean> response = new RPCResponse<>();\n+        response.setSummary(nodeHealth.getSummary());\n+        response.setResult(isHealthCheckPassing(nodeHealth));\n+        response.setCount(nodeHealth.getCount());\n+        response.setTruncated(nodeHealth.getTruncated());\n+        response.setMessages(nodeHealth.getMessages());\n+        response.setCompleted(nodeHealth.getCompleted());\n+        response.setFailed(nodeHealth.getFailed());\n+        response.setValue(nodeHealth.getValue());\n+        return response;\n+    }\n+\n+    private NodeHealthDetails parseMessages(RPCResponse<CheckResult> rpcResponse, InstanceMetaData instanceMetaData) {\n+        NodeHealthDetails nodeResponse = new NodeHealthDetails();\n+        nodeResponse.setName(instanceMetaData.getDiscoveryFQDN());\n+        nodeResponse.setInstanceId(instanceMetaData.getInstanceId());\n+        if (isHealthCheckPassing(rpcResponse)) {\n+            nodeResponse.setStatus(InstanceStatus.CREATED);\n+        } else {\n+            nodeResponse.setStatus(InstanceStatus.UNHEALTHY);\n+            nodeResponse.setIssues(rpcResponse.getMessages().stream().map(RPCMessage::getMessage).collect(Collectors.toList()));\n+        }\n+        return nodeResponse;\n+    }\n+\n+    private NodeHealthDetails legacyParseMessages(RPCResponse<Boolean> rpcResponse, InstanceMetaData instanceMetaData) {\n+        String precedingMessage = MESSAGE_UNAVAILABLE;\n+        NodeHealthDetails nodeResponse = new NodeHealthDetails();\n+        nodeResponse.setStatus(rpcResponse.getResult() ? InstanceStatus.CREATED : InstanceStatus.UNHEALTHY);\n+        nodeResponse.setName(instanceMetaData.getDiscoveryFQDN());\n+        nodeResponse.setInstanceId(instanceMetaData.getInstanceId());\n+        boolean found = false;\n+        for (RPCMessage message : rpcResponse.getMessages()) {\n+            Matcher nodeMatcher = NEW_NODE_PATTERN.matcher(message.getMessage());\n+            if (nodeMatcher.find()) {\n+                found = true;\n+            }\n+            if (!found) {\n+                LOGGER.info(\"No node for message: {}\" + message.getMessage());\n+            } else {\n+                // When parsing the messages, if there's an error, the error\n+                // appears in the preceding message.\n+                if (EXTERNAL_COMMAND_OUTPUT.equals(message.getName())) {\n+                    Matcher matcher = RESULT_PATTERN.matcher(message.getMessage());\n+                    if (matcher.find()) {\n+                        if (!STATUS_OK.equals(matcher.group(STATUS_GROUP))) {\n+                            nodeResponse.addIssue(precedingMessage);\n+                        }\n+                    }\n+                    precedingMessage = message.getMessage();\n+                }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "94d1a817196a3c01fde99b3c6aba778a723a7bb9"}, "originalPosition": 146}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTUwNDkxNA==", "bodyText": "// When parsing the messages, if there's an error, the error\n// appears in the preceding message.\n\nAssigning precedingMessage will have an effect in the case that there is an error match as it will have the actual error message from the prior message.", "url": "https://github.com/hortonworks/cloudbreak/pull/9657#discussion_r551504914", "createdAt": "2021-01-04T18:58:47Z", "author": {"login": "jamisonbennett"}, "path": "freeipa/src/main/java/com/sequenceiq/freeipa/service/stack/FreeIpaInstanceHealthDetailsService.java", "diffHunk": "@@ -0,0 +1,161 @@\n+package com.sequenceiq.freeipa.service.stack;\n+\n+import java.util.Objects;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+\n+import javax.inject.Inject;\n+import javax.ws.rs.core.Response;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.retry.annotation.Retryable;\n+import org.springframework.stereotype.Service;\n+\n+import com.sequenceiq.freeipa.api.v1.freeipa.stack.model.common.instance.InstanceStatus;\n+import com.sequenceiq.freeipa.api.v1.freeipa.stack.model.health.NodeHealthDetails;\n+import com.sequenceiq.freeipa.client.FreeIpaClient;\n+import com.sequenceiq.freeipa.client.FreeIpaClientException;\n+import com.sequenceiq.freeipa.client.FreeIpaHealthCheckClient;\n+import com.sequenceiq.freeipa.client.FreeIpaHealthCheckClientFactory;\n+import com.sequenceiq.freeipa.client.RetryableFreeIpaClientException;\n+import com.sequenceiq.freeipa.client.healthcheckmodel.CheckResult;\n+import com.sequenceiq.freeipa.client.model.RPCMessage;\n+import com.sequenceiq.freeipa.client.model.RPCResponse;\n+import com.sequenceiq.freeipa.entity.InstanceMetaData;\n+import com.sequenceiq.freeipa.entity.Stack;\n+import com.sequenceiq.freeipa.service.freeipa.FreeIpaClientFactory;\n+import com.sequenceiq.freeipa.util.HealthCheckAvailabilityChecker;\n+\n+@Service\n+public class FreeIpaInstanceHealthDetailsService {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(FreeIpaInstanceHealthDetailsService.class);\n+\n+    private static final String EXTERNAL_COMMAND_OUTPUT = \"ExternalCommandOutput\";\n+\n+    private static final String STATUS_OK = \"OK\";\n+\n+    private static final int STATUS_GROUP = 2;\n+\n+    private static final String MESSAGE_UNAVAILABLE = \"Message Unavailable\";\n+\n+    private static final Pattern RESULT_PATTERN = Pattern.compile(\"(ecure port|: TCP) \\\\([0-9]*\\\\): (.*)\");\n+\n+    private static final Pattern NEW_NODE_PATTERN = Pattern.compile(\"Check connection from master to remote replica '(.[^\\']*)\");\n+\n+    @Inject\n+    private FreeIpaClientFactory freeIpaClientFactory;\n+\n+    @Inject\n+    private HealthCheckAvailabilityChecker healthCheckAvailabilityChecker;\n+\n+    @Inject\n+    private FreeIpaHealthCheckClientFactory freeIpaHealthCheckClientFactory;\n+\n+    @Retryable(RetryableFreeIpaClientException.class)\n+    public NodeHealthDetails getInstanceHealthDetails(Stack stack, InstanceMetaData instance) throws FreeIpaClientException {\n+        if (healthCheckAvailabilityChecker.isCdpFreeIpaHeathAgentAvailable(stack)) {\n+            RPCResponse<CheckResult> rpcResponse = freeIpaHealthCheck(stack, instance);\n+            return parseMessages(rpcResponse, instance);\n+        } else {\n+            RPCResponse<Boolean> rpcResponse = legacyFreeIpaHealthCheck(stack, instance);\n+            return legacyParseMessages(rpcResponse, instance);\n+        }\n+    }\n+\n+    @Retryable(RetryableFreeIpaClientException.class)\n+    public RPCResponse<Boolean> checkFreeIpaHealth(Stack stack, InstanceMetaData instance) throws FreeIpaClientException {\n+        RPCResponse<Boolean> result;\n+        if (healthCheckAvailabilityChecker.isCdpFreeIpaHeathAgentAvailable(stack)) {\n+            result = toBooleanRpcResponse(freeIpaHealthCheck(stack, instance));\n+        } else {\n+            result = legacyFreeIpaHealthCheck(stack, instance);\n+        }\n+        return result;\n+    }\n+\n+    private RPCResponse<CheckResult> freeIpaHealthCheck(Stack stack, InstanceMetaData instance) throws FreeIpaClientException {\n+        try (FreeIpaHealthCheckClient client = freeIpaHealthCheckClientFactory.getClient(stack, instance)) {\n+            return client.nodeHealth();\n+        } catch (FreeIpaClientException e) {\n+            throw new RetryableFreeIpaClientException(\"Error during healthcheck\", e);\n+        } catch (Exception e) {\n+            LOGGER.error(\"FreeIPA health check failed\", e);\n+            throw new RetryableFreeIpaClientException(\"FreeIPA health check failed\", e);\n+        }\n+    }\n+\n+    private RPCResponse<Boolean> legacyFreeIpaHealthCheck(Stack stack, InstanceMetaData instance) throws FreeIpaClientException {\n+        FreeIpaClient freeIpaClient = freeIpaClientFactory.getFreeIpaClientForStackForLegacyHealthCheck(stack, instance.getDiscoveryFQDN());\n+        return freeIpaClient.serverConnCheck(freeIpaClient.getHostname(), instance.getDiscoveryFQDN());\n+    }\n+\n+    private RPCResponse<Boolean> toBooleanRpcResponse(RPCResponse<CheckResult> nodeHealth) {\n+        RPCResponse<Boolean> response = new RPCResponse<>();\n+        response.setSummary(nodeHealth.getSummary());\n+        response.setResult(isHealthCheckPassing(nodeHealth));\n+        response.setCount(nodeHealth.getCount());\n+        response.setTruncated(nodeHealth.getTruncated());\n+        response.setMessages(nodeHealth.getMessages());\n+        response.setCompleted(nodeHealth.getCompleted());\n+        response.setFailed(nodeHealth.getFailed());\n+        response.setValue(nodeHealth.getValue());\n+        return response;\n+    }\n+\n+    private NodeHealthDetails parseMessages(RPCResponse<CheckResult> rpcResponse, InstanceMetaData instanceMetaData) {\n+        NodeHealthDetails nodeResponse = new NodeHealthDetails();\n+        nodeResponse.setName(instanceMetaData.getDiscoveryFQDN());\n+        nodeResponse.setInstanceId(instanceMetaData.getInstanceId());\n+        if (isHealthCheckPassing(rpcResponse)) {\n+            nodeResponse.setStatus(InstanceStatus.CREATED);\n+        } else {\n+            nodeResponse.setStatus(InstanceStatus.UNHEALTHY);\n+            nodeResponse.setIssues(rpcResponse.getMessages().stream().map(RPCMessage::getMessage).collect(Collectors.toList()));\n+        }\n+        return nodeResponse;\n+    }\n+\n+    private NodeHealthDetails legacyParseMessages(RPCResponse<Boolean> rpcResponse, InstanceMetaData instanceMetaData) {\n+        String precedingMessage = MESSAGE_UNAVAILABLE;\n+        NodeHealthDetails nodeResponse = new NodeHealthDetails();\n+        nodeResponse.setStatus(rpcResponse.getResult() ? InstanceStatus.CREATED : InstanceStatus.UNHEALTHY);\n+        nodeResponse.setName(instanceMetaData.getDiscoveryFQDN());\n+        nodeResponse.setInstanceId(instanceMetaData.getInstanceId());\n+        boolean found = false;\n+        for (RPCMessage message : rpcResponse.getMessages()) {\n+            Matcher nodeMatcher = NEW_NODE_PATTERN.matcher(message.getMessage());\n+            if (nodeMatcher.find()) {\n+                found = true;\n+            }\n+            if (!found) {\n+                LOGGER.info(\"No node for message: {}\" + message.getMessage());\n+            } else {\n+                // When parsing the messages, if there's an error, the error\n+                // appears in the preceding message.\n+                if (EXTERNAL_COMMAND_OUTPUT.equals(message.getName())) {\n+                    Matcher matcher = RESULT_PATTERN.matcher(message.getMessage());\n+                    if (matcher.find()) {\n+                        if (!STATUS_OK.equals(matcher.group(STATUS_GROUP))) {\n+                            nodeResponse.addIssue(precedingMessage);\n+                        }\n+                    }\n+                    precedingMessage = message.getMessage();\n+                }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTQ3NTk3NA=="}, "originalCommit": {"oid": "94d1a817196a3c01fde99b3c6aba778a723a7bb9"}, "originalPosition": 146}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ3MTU5MTA5OnYy", "diffSide": "RIGHT", "path": "freeipa/src/main/java/com/sequenceiq/freeipa/client/FreeIpaClientBuilder.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNFQyMjo0NDoxOFrOIODyfQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNVQwMTo0NDoyNVrOIOHPVg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTYxMzA1Mw==", "bodyText": "It is strange that the catch clause after this is LOGGER.debug. Might be LOGGER.error()\ncatch (Exception e) {\nString msg = \"Ping failed\";\nLOGGER.debug(msg, e);", "url": "https://github.com/hortonworks/cloudbreak/pull/9657#discussion_r551613053", "createdAt": "2021-01-04T22:44:18Z", "author": {"login": "christmasferret"}, "path": "freeipa/src/main/java/com/sequenceiq/freeipa/client/FreeIpaClientBuilder.java", "diffHunk": "@@ -169,7 +166,7 @@ public FreeIpaClient build(boolean withPing) throws URISyntaxException, IOExcept\n                 additionalHeaders.forEach(request::addHeader);\n                 additionalHeadersStickySessionFirstRpc.forEach(request::addHeader);\n                 try (CloseableHttpResponse response = client.execute(request)) {\n-                    if (UNAVIALLBE_PING_HTTP_RESPONSES.contains(response.getStatusLine().getStatusCode())) {\n+                    if (isUnreachableHttpStatus(response.getStatusLine().getStatusCode())) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8146ced3b0ef6a1c0c0e8092e44dd50107b61175"}, "originalPosition": 22}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTY2OTU5MA==", "bodyText": "I will break this part out into a separate PR.", "url": "https://github.com/hortonworks/cloudbreak/pull/9657#discussion_r551669590", "createdAt": "2021-01-05T01:44:25Z", "author": {"login": "jamisonbennett"}, "path": "freeipa/src/main/java/com/sequenceiq/freeipa/client/FreeIpaClientBuilder.java", "diffHunk": "@@ -169,7 +166,7 @@ public FreeIpaClient build(boolean withPing) throws URISyntaxException, IOExcept\n                 additionalHeaders.forEach(request::addHeader);\n                 additionalHeadersStickySessionFirstRpc.forEach(request::addHeader);\n                 try (CloseableHttpResponse response = client.execute(request)) {\n-                    if (UNAVIALLBE_PING_HTTP_RESPONSES.contains(response.getStatusLine().getStatusCode())) {\n+                    if (isUnreachableHttpStatus(response.getStatusLine().getStatusCode())) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTYxMzA1Mw=="}, "originalCommit": {"oid": "8146ced3b0ef6a1c0c0e8092e44dd50107b61175"}, "originalPosition": 22}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3370, "cost": 1, "resetAt": "2021-11-12T20:44:06Z"}}}