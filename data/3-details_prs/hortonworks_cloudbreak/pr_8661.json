{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDU4MzI3ODU1", "number": 8661, "title": "CB-5742-EnhanceErrorHandling", "bodyText": "Removed user validation for clusterproxy since it is not User Controlled Configuration and duplicate validations.\nUpdate periscope cluster status based on both CB Stack and Cluster Status.", "createdAt": "2020-07-29T09:57:13Z", "url": "https://github.com/hortonworks/cloudbreak/pull/8661", "merged": true, "mergeCommit": {"oid": "133fc601a65bfd15fc6927c8deb8cf87385c3fa5"}, "closed": true, "closedAt": "2020-07-31T05:42:07Z", "author": {"login": "smaniraju"}, "timelineItems": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABc5oDbpgFqTQ1NzM3MzU3NA==", "endCursor": "Y3Vyc29yOnYyOpPPAAABc5zYUOgFqTQ1Nzk1NjQ4MQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU3MzczNTc0", "url": "https://github.com/hortonworks/cloudbreak/pull/8661#pullrequestreview-457373574", "createdAt": "2020-07-29T09:59:42Z", "commit": {"oid": "3ed5462dd97bf35eb6983e0d4a9e9cd30c92ff0a"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOVQwOTo1OTo0MlrOG4xb8Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOVQwOTo1OTo0MlrOG4xb8Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjE4MzQwOQ==", "bodyText": "ClusterProxy is not a user controlled config, hence removed this user facing validation and also clusterProxy is not a cluster level configuration but a deployment level configuration which is required to be enabled. Second  check for clusterProxy is there while polling yarn.\nMultiple load-alerts in a request is already validated in API layer, hence removed duplicate check.", "url": "https://github.com/hortonworks/cloudbreak/pull/8661#discussion_r462183409", "createdAt": "2020-07-29T09:59:42Z", "author": {"login": "smaniraju"}, "path": "autoscale/src/main/java/com/sequenceiq/periscope/controller/AlertController.java", "diffHunk": "@@ -229,16 +228,6 @@ private void validateLoadAlert(Long clusterId, Optional<Long> alertId, LoadAlert\n                 () -> {\n                     validateAccountEntitlement(cluster);\n                     validateSupportedHostGroup(cluster, json.getScalingPolicy().getHostGroup(), AlertType.LOAD);\n-                    String requestHostGroup = json.getScalingPolicy().getHostGroup();\n-                    cluster.getLoadAlerts().stream().map(LoadAlert::getScalingPolicy).map(ScalingPolicy::getHostGroup)\n-                            .filter(hostGroup -> hostGroup.equalsIgnoreCase(requestHostGroup)).findAny()\n-                            .ifPresent(hostGroup -> {\n-                                throw new BadRequestException(messagesService\n-                                        .getMessage(MessageCode.LOAD_CONFIG_ALREADY_DEFINED, List.of(cluster.getStackName(), requestHostGroup)));\n-                            });\n-                    clusterProxyConfigurationService.getClusterProxyUrl()\n-                            .orElseThrow(() ->  new BadRequestException(\n-                                    messagesService.getMessage(MessageCode.CLUSTER_PROXY_NOT_CONFIGURED, List.of(cluster.getStackName()))));\n                 });\n     }\n ", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3ed5462dd97bf35eb6983e0d4a9e9cd30c92ff0a"}, "originalPosition": 24}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU3MzczOTc5", "url": "https://github.com/hortonworks/cloudbreak/pull/8661#pullrequestreview-457373979", "createdAt": "2020-07-29T10:00:15Z", "commit": {"oid": "3ed5462dd97bf35eb6983e0d4a9e9cd30c92ff0a"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOVQxMDowMDoxNVrOG4xdLg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOVQxMDowMDoxNVrOG4xdLg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjE4MzcyNg==", "bodyText": "validation need not be within the transaction.", "url": "https://github.com/hortonworks/cloudbreak/pull/8661#discussion_r462183726", "createdAt": "2020-07-29T10:00:15Z", "author": {"login": "smaniraju"}, "path": "autoscale/src/main/java/com/sequenceiq/periscope/controller/DistroXAutoScaleClusterV1Controller.java", "diffHunk": "@@ -121,11 +121,12 @@ private DistroXAutoscaleClusterResponse createClusterJsonResponse(Cluster cluste\n     private DistroXAutoscaleClusterResponse updateClusterAutoScaleConfig(Long clusterId,\n             DistroXAutoscaleClusterRequest autoscaleClusterRequest) {\n \n+        alertController.validateLoadAlertRequests(clusterId, autoscaleClusterRequest.getLoadAlertRequests());\n+        alertController.validateTimeAlertRequests(clusterId, autoscaleClusterRequest.getTimeAlertRequests());\n+\n         try {\n             transactionService.required(() -> {\n                 clusterService.deleteAlertsForCluster(clusterId);\n-                alertController.validateLoadAlertRequests(clusterId, autoscaleClusterRequest.getLoadAlertRequests());\n-                alertController.validateTimeAlertRequests(clusterId, autoscaleClusterRequest.getTimeAlertRequests());\n                 alertController.createLoadAlerts(clusterId, autoscaleClusterRequest.getLoadAlertRequests());\n                 alertController.createTimeAlerts(clusterId, autoscaleClusterRequest.getTimeAlertRequests());\n                 asClusterCommonService.setAutoscaleState(clusterId, autoscaleClusterRequest.getEnableAutoscaling());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3ed5462dd97bf35eb6983e0d4a9e9cd30c92ff0a"}, "originalPosition": 14}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU3Mzc1NTI0", "url": "https://github.com/hortonworks/cloudbreak/pull/8661#pullrequestreview-457375524", "createdAt": "2020-07-29T10:02:19Z", "commit": {"oid": "3ed5462dd97bf35eb6983e0d4a9e9cd30c92ff0a"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOVQxMDowMjoxOVrOG4xiEQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOVQxMDowMjoxOVrOG4xiEQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjE4NDk3Nw==", "bodyText": "Periscope status should be synced based on both cluster and stack status, since next upscale is supported only when both are in available status. Even though they both are in sync in certain stimulated slow CB scenarios there is small drift between these two status.", "url": "https://github.com/hortonworks/cloudbreak/pull/8661#discussion_r462184977", "createdAt": "2020-07-29T10:02:19Z", "author": {"login": "smaniraju"}, "path": "autoscale/src/main/java/com/sequenceiq/periscope/monitor/handler/ClusterStatusSyncHandler.java", "diffHunk": "@@ -39,19 +40,22 @@ public void onApplicationEvent(ClusterStatusSyncEvent event) {\n         }\n         MDCBuilder.buildMdcContext(cluster);\n \n-        Status cbClusterStatus = Optional.ofNullable(cloudbreakCommunicator\n-                .getStackStatusByCrn(cluster.getStackCrn()).getClusterStatus()).orElse(Status.AMBIGUOUS);\n-        LOGGER.debug(\"Analysing CBCluster Status '{}' for Cluster '{}' \", cbClusterStatus, cluster.getStackCrn());\n+        StackStatusV4Response statusResponse = cloudbreakCommunicator.getStackStatusByCrn(cluster.getStackCrn());\n+        boolean clusterAvailable = Optional.ofNullable(statusResponse.getStatus()).map(Status::isAvailable).orElse(false)\n+                && Optional.ofNullable(statusResponse.getClusterStatus()).map(Status::isAvailable).orElse(false);\n+        LOGGER.debug(\"Analysing CBCluster Status '{}' for Cluster '{}' \", statusResponse, cluster.getStackCrn());\n \n-        if (DELETE_COMPLETED.equals(cbClusterStatus)) {\n+        if (DELETE_COMPLETED.equals(statusResponse.getStatus())) {\n             clusterService.removeById(autoscaleClusterId);\n-            LOGGER.debug(\"Deleted cluster '{}', CB Cluster status '{}'.\", cluster.getStackCrn(), cbClusterStatus);\n-        } else if (cbClusterStatus.isAvailable() && !RUNNING.equals(cluster.getState())) {\n+            LOGGER.info(\"Deleted cluster '{}', CB Stack Status '{}'.\", cluster.getStackCrn(), statusResponse.getStatus());\n+        } else if (clusterAvailable && !RUNNING.equals(cluster.getState())) {\n             clusterService.setState(cluster.getId(), ClusterState.RUNNING);\n-            LOGGER.debug(\"Updated cluster '{}' to running, CB Cluster status '{}'.\", cluster.getStackCrn(), cbClusterStatus);\n-        } else if (!cbClusterStatus.isAvailable() && RUNNING.equals(cluster.getState())) {\n+            LOGGER.info(\"Updated cluster '{}' to Running, CB Stack Status '{}', CB Cluster Status '{}'.\",\n+                    cluster.getStackCrn(), statusResponse.getStatus(), statusResponse.getClusterStatus());\n+        } else if (!clusterAvailable && RUNNING.equals(cluster.getState())) {\n             clusterService.setState(cluster.getId(), ClusterState.SUSPENDED);\n-            LOGGER.debug(\"Suspended cluster '{}', CB Cluster status '{}'\", cluster.getStackCrn(), cbClusterStatus);\n+            LOGGER.info(\"Suspended cluster '{}', CB Stack Status '{}', CB Cluster Status '{}'\",\n+                    cluster.getStackCrn(), statusResponse.getStatus(), statusResponse.getClusterStatus());\n         }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3ed5462dd97bf35eb6983e0d4a9e9cd30c92ff0a"}, "originalPosition": 37}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "3ed5462dd97bf35eb6983e0d4a9e9cd30c92ff0a", "author": {"user": {"login": "smaniraju", "name": null}}, "url": "https://github.com/hortonworks/cloudbreak/commit/3ed5462dd97bf35eb6983e0d4a9e9cd30c92ff0a", "committedDate": "2020-07-29T09:51:21Z", "message": "CB-5742-EnhanceErrorHandling\n\nRemoved non-user facing and duplicate validations.\nUpdate periscope cluster status based on both CB Stack and Cluster Status."}, "afterCommit": {"oid": "421210a2926c9c840caa1c1d168cc9e4c0de1f7e", "author": {"user": {"login": "smaniraju", "name": null}}, "url": "https://github.com/hortonworks/cloudbreak/commit/421210a2926c9c840caa1c1d168cc9e4c0de1f7e", "committedDate": "2020-07-29T10:04:32Z", "message": "CB-5742-EnhanceErrorHandling\n\nRemoved non-user facing and duplicate validations.\nUpdate periscope cluster status based on both CB Stack and Cluster Status."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1813f53b602064baf5528c63db5d787d2b4db272", "author": {"user": {"login": "smaniraju", "name": null}}, "url": "https://github.com/hortonworks/cloudbreak/commit/1813f53b602064baf5528c63db5d787d2b4db272", "committedDate": "2020-07-29T10:13:27Z", "message": "CB-5742-EnhanceErrorHandling\n\nRemoved user validation for clusterproxy since it is not User Controlled Configuration and duplicate validations.\nUpdate periscope cluster status based on both CB Stack and Cluster Status."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "421210a2926c9c840caa1c1d168cc9e4c0de1f7e", "author": {"user": {"login": "smaniraju", "name": null}}, "url": "https://github.com/hortonworks/cloudbreak/commit/421210a2926c9c840caa1c1d168cc9e4c0de1f7e", "committedDate": "2020-07-29T10:04:32Z", "message": "CB-5742-EnhanceErrorHandling\n\nRemoved non-user facing and duplicate validations.\nUpdate periscope cluster status based on both CB Stack and Cluster Status."}, "afterCommit": {"oid": "1813f53b602064baf5528c63db5d787d2b4db272", "author": {"user": {"login": "smaniraju", "name": null}}, "url": "https://github.com/hortonworks/cloudbreak/commit/1813f53b602064baf5528c63db5d787d2b4db272", "committedDate": "2020-07-29T10:13:27Z", "message": "CB-5742-EnhanceErrorHandling\n\nRemoved user validation for clusterproxy since it is not User Controlled Configuration and duplicate validations.\nUpdate periscope cluster status based on both CB Stack and Cluster Status."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU3OTU2NDgx", "url": "https://github.com/hortonworks/cloudbreak/pull/8661#pullrequestreview-457956481", "createdAt": "2020-07-29T23:03:02Z", "commit": {"oid": "1813f53b602064baf5528c63db5d787d2b4db272"}, "state": "APPROVED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOVQyMzowMzowMlrOG5NPRg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOVQyMzowNzoxN1rOG5NUmg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjYzODkxOA==", "bodyText": "Is ClusterProxy always on? (Is there any way to disable it, via the CLI for example?) Cloudbreak still supports DIRECT and CLUSTER_PROXY (Tunnel.java)", "url": "https://github.com/hortonworks/cloudbreak/pull/8661#discussion_r462638918", "createdAt": "2020-07-29T23:03:02Z", "author": {"login": "sidseth"}, "path": "autoscale/src/main/java/com/sequenceiq/periscope/controller/AlertController.java", "diffHunk": "@@ -229,16 +228,6 @@ private void validateLoadAlert(Long clusterId, Optional<Long> alertId, LoadAlert\n                 () -> {\n                     validateAccountEntitlement(cluster);\n                     validateSupportedHostGroup(cluster, json.getScalingPolicy().getHostGroup(), AlertType.LOAD);\n-                    String requestHostGroup = json.getScalingPolicy().getHostGroup();\n-                    cluster.getLoadAlerts().stream().map(LoadAlert::getScalingPolicy).map(ScalingPolicy::getHostGroup)\n-                            .filter(hostGroup -> hostGroup.equalsIgnoreCase(requestHostGroup)).findAny()\n-                            .ifPresent(hostGroup -> {\n-                                throw new BadRequestException(messagesService\n-                                        .getMessage(MessageCode.LOAD_CONFIG_ALREADY_DEFINED, List.of(cluster.getStackName(), requestHostGroup)));\n-                            });\n-                    clusterProxyConfigurationService.getClusterProxyUrl()\n-                            .orElseThrow(() ->  new BadRequestException(\n-                                    messagesService.getMessage(MessageCode.CLUSTER_PROXY_NOT_CONFIGURED, List.of(cluster.getStackName()))));\n                 });\n     }\n ", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjE4MzQwOQ=="}, "originalCommit": {"oid": "3ed5462dd97bf35eb6983e0d4a9e9cd30c92ff0a"}, "originalPosition": 24}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjY0MDI4Mg==", "bodyText": "Thank you. Was going to ask just this question on how they differ.\nWasn't there a change recently where at least downscale worked even if a previous downscale had failed (or node deleted on provider side).\nThat's the series of jiras Amit had opened. cc @cegganesh84", "url": "https://github.com/hortonworks/cloudbreak/pull/8661#discussion_r462640282", "createdAt": "2020-07-29T23:07:17Z", "author": {"login": "sidseth"}, "path": "autoscale/src/main/java/com/sequenceiq/periscope/monitor/handler/ClusterStatusSyncHandler.java", "diffHunk": "@@ -39,19 +40,22 @@ public void onApplicationEvent(ClusterStatusSyncEvent event) {\n         }\n         MDCBuilder.buildMdcContext(cluster);\n \n-        Status cbClusterStatus = Optional.ofNullable(cloudbreakCommunicator\n-                .getStackStatusByCrn(cluster.getStackCrn()).getClusterStatus()).orElse(Status.AMBIGUOUS);\n-        LOGGER.debug(\"Analysing CBCluster Status '{}' for Cluster '{}' \", cbClusterStatus, cluster.getStackCrn());\n+        StackStatusV4Response statusResponse = cloudbreakCommunicator.getStackStatusByCrn(cluster.getStackCrn());\n+        boolean clusterAvailable = Optional.ofNullable(statusResponse.getStatus()).map(Status::isAvailable).orElse(false)\n+                && Optional.ofNullable(statusResponse.getClusterStatus()).map(Status::isAvailable).orElse(false);\n+        LOGGER.debug(\"Analysing CBCluster Status '{}' for Cluster '{}' \", statusResponse, cluster.getStackCrn());\n \n-        if (DELETE_COMPLETED.equals(cbClusterStatus)) {\n+        if (DELETE_COMPLETED.equals(statusResponse.getStatus())) {\n             clusterService.removeById(autoscaleClusterId);\n-            LOGGER.debug(\"Deleted cluster '{}', CB Cluster status '{}'.\", cluster.getStackCrn(), cbClusterStatus);\n-        } else if (cbClusterStatus.isAvailable() && !RUNNING.equals(cluster.getState())) {\n+            LOGGER.info(\"Deleted cluster '{}', CB Stack Status '{}'.\", cluster.getStackCrn(), statusResponse.getStatus());\n+        } else if (clusterAvailable && !RUNNING.equals(cluster.getState())) {\n             clusterService.setState(cluster.getId(), ClusterState.RUNNING);\n-            LOGGER.debug(\"Updated cluster '{}' to running, CB Cluster status '{}'.\", cluster.getStackCrn(), cbClusterStatus);\n-        } else if (!cbClusterStatus.isAvailable() && RUNNING.equals(cluster.getState())) {\n+            LOGGER.info(\"Updated cluster '{}' to Running, CB Stack Status '{}', CB Cluster Status '{}'.\",\n+                    cluster.getStackCrn(), statusResponse.getStatus(), statusResponse.getClusterStatus());\n+        } else if (!clusterAvailable && RUNNING.equals(cluster.getState())) {\n             clusterService.setState(cluster.getId(), ClusterState.SUSPENDED);\n-            LOGGER.debug(\"Suspended cluster '{}', CB Cluster status '{}'\", cluster.getStackCrn(), cbClusterStatus);\n+            LOGGER.info(\"Suspended cluster '{}', CB Stack Status '{}', CB Cluster Status '{}'\",\n+                    cluster.getStackCrn(), statusResponse.getStatus(), statusResponse.getClusterStatus());\n         }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjE4NDk3Nw=="}, "originalCommit": {"oid": "3ed5462dd97bf35eb6983e0d4a9e9cd30c92ff0a"}, "originalPosition": 37}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2515, "cost": 1, "resetAt": "2021-11-01T14:51:55Z"}}}