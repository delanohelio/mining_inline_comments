{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDI2MTQ0NjM1", "number": 8188, "reviewThreads": {"totalCount": 12, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QyMjowMzo1MVrOECVqRw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNFQxNDoxMzo0OVrOEClO6g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcwODg3NDk1OnYy", "diffSide": "RIGHT", "path": "autoscale/src/main/resources/schema/app/20200602071624_DISTX-399_Datahub_Autoscaling_Changes.sql", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QyMjowMzo1MVrOGevLOg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNFQwNzoyNDozM1rOGe5Dmw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDg4MzM4Ng==", "bodyText": "This should probably be 'text'", "url": "https://github.com/hortonworks/cloudbreak/pull/8188#discussion_r434883386", "createdAt": "2020-06-03T22:03:51Z", "author": {"login": "sidseth"}, "path": "autoscale/src/main/resources/schema/app/20200602071624_DISTX-399_Datahub_Autoscaling_Changes.sql", "diffHunk": "@@ -0,0 +1,39 @@\n+-- // DISTX-399 Datahub Autoscaling Changes\n+-- Migration SQL that makes the change goes here.\n+\n+CREATE TABLE IF NOT EXISTS loadalert (\n+    id bigint NOT NULL,\n+    description character varying(255),\n+    name character varying(255),\n+    load_alert_config character varying(1024),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f681883d1c0c19cfa91ecdd5ef869c12f8a0ebd4"}, "originalPosition": 8}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTA0NTI3NQ==", "bodyText": "ack", "url": "https://github.com/hortonworks/cloudbreak/pull/8188#discussion_r435045275", "createdAt": "2020-06-04T07:24:33Z", "author": {"login": "smaniraju"}, "path": "autoscale/src/main/resources/schema/app/20200602071624_DISTX-399_Datahub_Autoscaling_Changes.sql", "diffHunk": "@@ -0,0 +1,39 @@\n+-- // DISTX-399 Datahub Autoscaling Changes\n+-- Migration SQL that makes the change goes here.\n+\n+CREATE TABLE IF NOT EXISTS loadalert (\n+    id bigint NOT NULL,\n+    description character varying(255),\n+    name character varying(255),\n+    load_alert_config character varying(1024),", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDg4MzM4Ng=="}, "originalCommit": {"oid": "f681883d1c0c19cfa91ecdd5ef869c12f8a0ebd4"}, "originalPosition": 8}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcwODg4MDEwOnYy", "diffSide": "RIGHT", "path": "autoscale/src/test/java/com/sequenceiq/periscope/modul/rejected/RejectedThreadContext.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QyMjowNjowMFrOGevOZQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNFQwODowMTo1OVrOGe6TfQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDg4NDE5Nw==", "bodyText": "May have asked this earlier; is this annotation required?", "url": "https://github.com/hortonworks/cloudbreak/pull/8188#discussion_r434884197", "createdAt": "2020-06-03T22:06:00Z", "author": {"login": "sidseth"}, "path": "autoscale/src/test/java/com/sequenceiq/periscope/modul/rejected/RejectedThreadContext.java", "diffHunk": "@@ -59,6 +60,7 @@\n     @MockBean({Clock.class, ClusterService.class, CloudbreakClientConfiguration.class,\n             MetricUtils.class, InternalCrnBuilder.class, FailedNodeRepository.class})\n     @EnableAsync\n+    @Profile(\"devtest\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f681883d1c0c19cfa91ecdd5ef869c12f8a0ebd4"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTA2NTcyNQ==", "bodyText": "Nested SpringConfig in RejectedThreadContext is basically a TestContext.  Without the profile filter this would result in duplicate  bean definition for periscopeListeningScheduledExecutorService and fails integration endpoint tests which run tests against embedded tomcat and embedded db. Earlier there wasn't any service integration tests hence the missing annotation did not cause any issue.", "url": "https://github.com/hortonworks/cloudbreak/pull/8188#discussion_r435065725", "createdAt": "2020-06-04T08:01:59Z", "author": {"login": "smaniraju"}, "path": "autoscale/src/test/java/com/sequenceiq/periscope/modul/rejected/RejectedThreadContext.java", "diffHunk": "@@ -59,6 +60,7 @@\n     @MockBean({Clock.class, ClusterService.class, CloudbreakClientConfiguration.class,\n             MetricUtils.class, InternalCrnBuilder.class, FailedNodeRepository.class})\n     @EnableAsync\n+    @Profile(\"devtest\")", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDg4NDE5Nw=="}, "originalCommit": {"oid": "f681883d1c0c19cfa91ecdd5ef869c12f8a0ebd4"}, "originalPosition": 12}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcxMDc4MzcyOnYy", "diffSide": "RIGHT", "path": "autoscale-api/src/main/java/com/sequenceiq/periscope/api/endpoint/v1/DistroXAutoScaleClusterV1Endpoint.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNFQxMTozNToyOFrOGfBsKQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQwNzo0NjoyNVrOGfj4Og==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTE4NjcyOQ==", "bodyText": "our url patter is separated by _, please change to autoscale_config and the other URL as well", "url": "https://github.com/hortonworks/cloudbreak/pull/8188#discussion_r435186729", "createdAt": "2020-06-04T11:35:28Z", "author": {"login": "topolyai5"}, "path": "autoscale-api/src/main/java/com/sequenceiq/periscope/api/endpoint/v1/DistroXAutoScaleClusterV1Endpoint.java", "diffHunk": "@@ -0,0 +1,87 @@\n+package com.sequenceiq.periscope.api.endpoint.v1;\n+\n+import static com.sequenceiq.periscope.doc.ApiDescription.CLUSTERS_DESCRIPTION;\n+\n+import java.util.List;\n+\n+import javax.validation.Valid;\n+import javax.ws.rs.Consumes;\n+import javax.ws.rs.DELETE;\n+import javax.ws.rs.GET;\n+import javax.ws.rs.POST;\n+import javax.ws.rs.Path;\n+import javax.ws.rs.PathParam;\n+import javax.ws.rs.Produces;\n+import javax.ws.rs.core.MediaType;\n+\n+import com.sequenceiq.periscope.api.endpoint.validator.ValidDistroXAutoscaleRequest;\n+import com.sequenceiq.periscope.api.model.AutoscaleClusterState;\n+import com.sequenceiq.periscope.api.model.DistroXAutoscaleClusterRequest;\n+import com.sequenceiq.periscope.api.model.DistroXAutoscaleClusterResponse;\n+import com.sequenceiq.periscope.doc.ApiDescription;\n+import com.sequenceiq.periscope.doc.ApiDescription.ClusterOpDescription;\n+import com.sequenceiq.periscope.doc.ApiDescription.DistroXClusterNotes;\n+\n+import io.swagger.annotations.Api;\n+import io.swagger.annotations.ApiOperation;\n+\n+@Path(\"/v1/distrox\")\n+@Consumes(MediaType.APPLICATION_JSON)\n+@Api(value = \"/v1/distrox\", description = CLUSTERS_DESCRIPTION, protocols = \"http,https\", consumes = MediaType.APPLICATION_JSON)\n+public interface DistroXAutoScaleClusterV1Endpoint {\n+\n+    @GET\n+    @Produces(MediaType.APPLICATION_JSON)\n+    @ApiOperation(value = ClusterOpDescription.CLUSTER_GET_ALL, produces = MediaType.APPLICATION_JSON, notes = DistroXClusterNotes.NOTES)\n+    List<DistroXAutoscaleClusterResponse> getClusters();\n+\n+    @GET\n+    @Path(\"crn/{crn}\")\n+    @Produces(MediaType.APPLICATION_JSON)\n+    @ApiOperation(value = ClusterOpDescription.CLUSTER_GET, produces = MediaType.APPLICATION_JSON, notes = DistroXClusterNotes.NOTES)\n+    DistroXAutoscaleClusterResponse getClusterByCrn(@PathParam(\"crn\") String clusterCrn);\n+\n+    @GET\n+    @Path(\"name/{name}\")\n+    @Produces(MediaType.APPLICATION_JSON)\n+    @ApiOperation(value = ClusterOpDescription.CLUSTER_GET, produces = MediaType.APPLICATION_JSON, notes = DistroXClusterNotes.NOTES)\n+    DistroXAutoscaleClusterResponse getClusterByName(@PathParam(\"name\") String clusterName);\n+\n+    @POST\n+    @Path(\"crn/{crn}/autoscaleconfig\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d8ee7e1c27320672da427a3b05c3bc5396700d34"}, "originalPosition": 51}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTc0Njg3NA==", "bodyText": "ok", "url": "https://github.com/hortonworks/cloudbreak/pull/8188#discussion_r435746874", "createdAt": "2020-06-05T07:46:25Z", "author": {"login": "smaniraju"}, "path": "autoscale-api/src/main/java/com/sequenceiq/periscope/api/endpoint/v1/DistroXAutoScaleClusterV1Endpoint.java", "diffHunk": "@@ -0,0 +1,87 @@\n+package com.sequenceiq.periscope.api.endpoint.v1;\n+\n+import static com.sequenceiq.periscope.doc.ApiDescription.CLUSTERS_DESCRIPTION;\n+\n+import java.util.List;\n+\n+import javax.validation.Valid;\n+import javax.ws.rs.Consumes;\n+import javax.ws.rs.DELETE;\n+import javax.ws.rs.GET;\n+import javax.ws.rs.POST;\n+import javax.ws.rs.Path;\n+import javax.ws.rs.PathParam;\n+import javax.ws.rs.Produces;\n+import javax.ws.rs.core.MediaType;\n+\n+import com.sequenceiq.periscope.api.endpoint.validator.ValidDistroXAutoscaleRequest;\n+import com.sequenceiq.periscope.api.model.AutoscaleClusterState;\n+import com.sequenceiq.periscope.api.model.DistroXAutoscaleClusterRequest;\n+import com.sequenceiq.periscope.api.model.DistroXAutoscaleClusterResponse;\n+import com.sequenceiq.periscope.doc.ApiDescription;\n+import com.sequenceiq.periscope.doc.ApiDescription.ClusterOpDescription;\n+import com.sequenceiq.periscope.doc.ApiDescription.DistroXClusterNotes;\n+\n+import io.swagger.annotations.Api;\n+import io.swagger.annotations.ApiOperation;\n+\n+@Path(\"/v1/distrox\")\n+@Consumes(MediaType.APPLICATION_JSON)\n+@Api(value = \"/v1/distrox\", description = CLUSTERS_DESCRIPTION, protocols = \"http,https\", consumes = MediaType.APPLICATION_JSON)\n+public interface DistroXAutoScaleClusterV1Endpoint {\n+\n+    @GET\n+    @Produces(MediaType.APPLICATION_JSON)\n+    @ApiOperation(value = ClusterOpDescription.CLUSTER_GET_ALL, produces = MediaType.APPLICATION_JSON, notes = DistroXClusterNotes.NOTES)\n+    List<DistroXAutoscaleClusterResponse> getClusters();\n+\n+    @GET\n+    @Path(\"crn/{crn}\")\n+    @Produces(MediaType.APPLICATION_JSON)\n+    @ApiOperation(value = ClusterOpDescription.CLUSTER_GET, produces = MediaType.APPLICATION_JSON, notes = DistroXClusterNotes.NOTES)\n+    DistroXAutoscaleClusterResponse getClusterByCrn(@PathParam(\"crn\") String clusterCrn);\n+\n+    @GET\n+    @Path(\"name/{name}\")\n+    @Produces(MediaType.APPLICATION_JSON)\n+    @ApiOperation(value = ClusterOpDescription.CLUSTER_GET, produces = MediaType.APPLICATION_JSON, notes = DistroXClusterNotes.NOTES)\n+    DistroXAutoscaleClusterResponse getClusterByName(@PathParam(\"name\") String clusterName);\n+\n+    @POST\n+    @Path(\"crn/{crn}/autoscaleconfig\")", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTE4NjcyOQ=="}, "originalCommit": {"oid": "d8ee7e1c27320672da427a3b05c3bc5396700d34"}, "originalPosition": 51}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcxMDc4Nzc2OnYy", "diffSide": "RIGHT", "path": "autoscale-api/src/main/java/com/sequenceiq/periscope/api/endpoint/v1/DistroXAutoScaleClusterV1Endpoint.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNFQxMTozNjo0M1rOGfBuug==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQwNzo0NjozNFrOGfj4fA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTE4NzM4Ng==", "bodyText": "separate by _", "url": "https://github.com/hortonworks/cloudbreak/pull/8188#discussion_r435187386", "createdAt": "2020-06-04T11:36:43Z", "author": {"login": "topolyai5"}, "path": "autoscale-api/src/main/java/com/sequenceiq/periscope/api/endpoint/v1/DistroXAutoScaleClusterV1Endpoint.java", "diffHunk": "@@ -0,0 +1,87 @@\n+package com.sequenceiq.periscope.api.endpoint.v1;\n+\n+import static com.sequenceiq.periscope.doc.ApiDescription.CLUSTERS_DESCRIPTION;\n+\n+import java.util.List;\n+\n+import javax.validation.Valid;\n+import javax.ws.rs.Consumes;\n+import javax.ws.rs.DELETE;\n+import javax.ws.rs.GET;\n+import javax.ws.rs.POST;\n+import javax.ws.rs.Path;\n+import javax.ws.rs.PathParam;\n+import javax.ws.rs.Produces;\n+import javax.ws.rs.core.MediaType;\n+\n+import com.sequenceiq.periscope.api.endpoint.validator.ValidDistroXAutoscaleRequest;\n+import com.sequenceiq.periscope.api.model.AutoscaleClusterState;\n+import com.sequenceiq.periscope.api.model.DistroXAutoscaleClusterRequest;\n+import com.sequenceiq.periscope.api.model.DistroXAutoscaleClusterResponse;\n+import com.sequenceiq.periscope.doc.ApiDescription;\n+import com.sequenceiq.periscope.doc.ApiDescription.ClusterOpDescription;\n+import com.sequenceiq.periscope.doc.ApiDescription.DistroXClusterNotes;\n+\n+import io.swagger.annotations.Api;\n+import io.swagger.annotations.ApiOperation;\n+\n+@Path(\"/v1/distrox\")\n+@Consumes(MediaType.APPLICATION_JSON)\n+@Api(value = \"/v1/distrox\", description = CLUSTERS_DESCRIPTION, protocols = \"http,https\", consumes = MediaType.APPLICATION_JSON)\n+public interface DistroXAutoScaleClusterV1Endpoint {\n+\n+    @GET\n+    @Produces(MediaType.APPLICATION_JSON)\n+    @ApiOperation(value = ClusterOpDescription.CLUSTER_GET_ALL, produces = MediaType.APPLICATION_JSON, notes = DistroXClusterNotes.NOTES)\n+    List<DistroXAutoscaleClusterResponse> getClusters();\n+\n+    @GET\n+    @Path(\"crn/{crn}\")\n+    @Produces(MediaType.APPLICATION_JSON)\n+    @ApiOperation(value = ClusterOpDescription.CLUSTER_GET, produces = MediaType.APPLICATION_JSON, notes = DistroXClusterNotes.NOTES)\n+    DistroXAutoscaleClusterResponse getClusterByCrn(@PathParam(\"crn\") String clusterCrn);\n+\n+    @GET\n+    @Path(\"name/{name}\")\n+    @Produces(MediaType.APPLICATION_JSON)\n+    @ApiOperation(value = ClusterOpDescription.CLUSTER_GET, produces = MediaType.APPLICATION_JSON, notes = DistroXClusterNotes.NOTES)\n+    DistroXAutoscaleClusterResponse getClusterByName(@PathParam(\"name\") String clusterName);\n+\n+    @POST\n+    @Path(\"crn/{crn}/autoscaleconfig\")\n+    @Produces(MediaType.APPLICATION_JSON)\n+    @ApiOperation(value = ClusterOpDescription.CLUSTER_UPDATE_AUTOSCALE_CONFIG, produces = MediaType.APPLICATION_JSON, notes = DistroXClusterNotes.NOTES)\n+    DistroXAutoscaleClusterResponse updateAutoscaleConfigByClusterCrn(@PathParam(\"crn\") String clusterCrn,\n+            @ValidDistroXAutoscaleRequest @Valid DistroXAutoscaleClusterRequest autoscaleClusterRequest);\n+\n+    @POST\n+    @Path(\"name/{name}/autoscaleconfig\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d8ee7e1c27320672da427a3b05c3bc5396700d34"}, "originalPosition": 58}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTc0Njk0MA==", "bodyText": "ok", "url": "https://github.com/hortonworks/cloudbreak/pull/8188#discussion_r435746940", "createdAt": "2020-06-05T07:46:34Z", "author": {"login": "smaniraju"}, "path": "autoscale-api/src/main/java/com/sequenceiq/periscope/api/endpoint/v1/DistroXAutoScaleClusterV1Endpoint.java", "diffHunk": "@@ -0,0 +1,87 @@\n+package com.sequenceiq.periscope.api.endpoint.v1;\n+\n+import static com.sequenceiq.periscope.doc.ApiDescription.CLUSTERS_DESCRIPTION;\n+\n+import java.util.List;\n+\n+import javax.validation.Valid;\n+import javax.ws.rs.Consumes;\n+import javax.ws.rs.DELETE;\n+import javax.ws.rs.GET;\n+import javax.ws.rs.POST;\n+import javax.ws.rs.Path;\n+import javax.ws.rs.PathParam;\n+import javax.ws.rs.Produces;\n+import javax.ws.rs.core.MediaType;\n+\n+import com.sequenceiq.periscope.api.endpoint.validator.ValidDistroXAutoscaleRequest;\n+import com.sequenceiq.periscope.api.model.AutoscaleClusterState;\n+import com.sequenceiq.periscope.api.model.DistroXAutoscaleClusterRequest;\n+import com.sequenceiq.periscope.api.model.DistroXAutoscaleClusterResponse;\n+import com.sequenceiq.periscope.doc.ApiDescription;\n+import com.sequenceiq.periscope.doc.ApiDescription.ClusterOpDescription;\n+import com.sequenceiq.periscope.doc.ApiDescription.DistroXClusterNotes;\n+\n+import io.swagger.annotations.Api;\n+import io.swagger.annotations.ApiOperation;\n+\n+@Path(\"/v1/distrox\")\n+@Consumes(MediaType.APPLICATION_JSON)\n+@Api(value = \"/v1/distrox\", description = CLUSTERS_DESCRIPTION, protocols = \"http,https\", consumes = MediaType.APPLICATION_JSON)\n+public interface DistroXAutoScaleClusterV1Endpoint {\n+\n+    @GET\n+    @Produces(MediaType.APPLICATION_JSON)\n+    @ApiOperation(value = ClusterOpDescription.CLUSTER_GET_ALL, produces = MediaType.APPLICATION_JSON, notes = DistroXClusterNotes.NOTES)\n+    List<DistroXAutoscaleClusterResponse> getClusters();\n+\n+    @GET\n+    @Path(\"crn/{crn}\")\n+    @Produces(MediaType.APPLICATION_JSON)\n+    @ApiOperation(value = ClusterOpDescription.CLUSTER_GET, produces = MediaType.APPLICATION_JSON, notes = DistroXClusterNotes.NOTES)\n+    DistroXAutoscaleClusterResponse getClusterByCrn(@PathParam(\"crn\") String clusterCrn);\n+\n+    @GET\n+    @Path(\"name/{name}\")\n+    @Produces(MediaType.APPLICATION_JSON)\n+    @ApiOperation(value = ClusterOpDescription.CLUSTER_GET, produces = MediaType.APPLICATION_JSON, notes = DistroXClusterNotes.NOTES)\n+    DistroXAutoscaleClusterResponse getClusterByName(@PathParam(\"name\") String clusterName);\n+\n+    @POST\n+    @Path(\"crn/{crn}/autoscaleconfig\")\n+    @Produces(MediaType.APPLICATION_JSON)\n+    @ApiOperation(value = ClusterOpDescription.CLUSTER_UPDATE_AUTOSCALE_CONFIG, produces = MediaType.APPLICATION_JSON, notes = DistroXClusterNotes.NOTES)\n+    DistroXAutoscaleClusterResponse updateAutoscaleConfigByClusterCrn(@PathParam(\"crn\") String clusterCrn,\n+            @ValidDistroXAutoscaleRequest @Valid DistroXAutoscaleClusterRequest autoscaleClusterRequest);\n+\n+    @POST\n+    @Path(\"name/{name}/autoscaleconfig\")", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTE4NzM4Ng=="}, "originalCommit": {"oid": "d8ee7e1c27320672da427a3b05c3bc5396700d34"}, "originalPosition": 58}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcxMDgwMzk5OnYy", "diffSide": "RIGHT", "path": "autoscale-api/src/main/java/com/sequenceiq/periscope/api/endpoint/validator/DistroXAutoscaleRequestValidator.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNFQxMTo0MjowMlrOGfB5Hg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQwNzo0ODowMVrOGfj7Hw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTE5MDA0Ng==", "bodyText": "why do you use fully qualified name?", "url": "https://github.com/hortonworks/cloudbreak/pull/8188#discussion_r435190046", "createdAt": "2020-06-04T11:42:02Z", "author": {"login": "topolyai5"}, "path": "autoscale-api/src/main/java/com/sequenceiq/periscope/api/endpoint/validator/DistroXAutoscaleRequestValidator.java", "diffHunk": "@@ -0,0 +1,74 @@\n+package com.sequenceiq.periscope.api.endpoint.validator;\n+\n+import java.util.HashSet;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import javax.validation.ConstraintValidator;\n+import javax.validation.ConstraintValidatorContext;\n+\n+import com.sequenceiq.periscope.api.model.AdjustmentType;\n+import com.sequenceiq.periscope.api.model.DistroXAutoscaleClusterRequest;\n+\n+public class DistroXAutoscaleRequestValidator\n+        implements ConstraintValidator<ValidDistroXAutoscaleRequest, DistroXAutoscaleClusterRequest> {\n+\n+    @Override\n+    public boolean isValid(DistroXAutoscaleClusterRequest request, ConstraintValidatorContext context) {\n+\n+        if (!request.getLoadAlertRequests().isEmpty() &&\n+                !request.getTimeAlertRequests().isEmpty()) {\n+            String message = String.format(\"Cluster can be configured with only one type of autoscaling policies.\");\n+            com.sequenceiq.cloudbreak.validation.ValidatorUtil.addConstraintViolation(context, message, \"autoscalingPolicy\")\n+                    .disableDefaultConstraintViolation();\n+            return false;\n+        }\n+\n+        if (!request.getLoadAlertRequests().isEmpty()) {\n+            return isValidLoadAlertRequests(request, context);\n+        }\n+\n+        return true;\n+    }\n+\n+    private Boolean isValidLoadAlertRequests(DistroXAutoscaleClusterRequest request, ConstraintValidatorContext context) {\n+        Set<String> distinctLoadBasedHostGroups = new HashSet<>();\n+        Set<AdjustmentType> distinctLoadBasedAdjustmentTypes = new HashSet<>();\n+\n+        if (request.getLoadAlertRequests().size() > 1) {\n+            String message = String.format(\"LoadBased autoscaling currently supports a single HostGroup in a Cluster.\");\n+            com.sequenceiq.cloudbreak.validation.ValidatorUtil.addConstraintViolation(context, message, \"loadAlertRequests\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d8ee7e1c27320672da427a3b05c3bc5396700d34"}, "originalPosition": 40}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTc0NzYxNQ==", "bodyText": "fixed", "url": "https://github.com/hortonworks/cloudbreak/pull/8188#discussion_r435747615", "createdAt": "2020-06-05T07:48:01Z", "author": {"login": "smaniraju"}, "path": "autoscale-api/src/main/java/com/sequenceiq/periscope/api/endpoint/validator/DistroXAutoscaleRequestValidator.java", "diffHunk": "@@ -0,0 +1,74 @@\n+package com.sequenceiq.periscope.api.endpoint.validator;\n+\n+import java.util.HashSet;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import javax.validation.ConstraintValidator;\n+import javax.validation.ConstraintValidatorContext;\n+\n+import com.sequenceiq.periscope.api.model.AdjustmentType;\n+import com.sequenceiq.periscope.api.model.DistroXAutoscaleClusterRequest;\n+\n+public class DistroXAutoscaleRequestValidator\n+        implements ConstraintValidator<ValidDistroXAutoscaleRequest, DistroXAutoscaleClusterRequest> {\n+\n+    @Override\n+    public boolean isValid(DistroXAutoscaleClusterRequest request, ConstraintValidatorContext context) {\n+\n+        if (!request.getLoadAlertRequests().isEmpty() &&\n+                !request.getTimeAlertRequests().isEmpty()) {\n+            String message = String.format(\"Cluster can be configured with only one type of autoscaling policies.\");\n+            com.sequenceiq.cloudbreak.validation.ValidatorUtil.addConstraintViolation(context, message, \"autoscalingPolicy\")\n+                    .disableDefaultConstraintViolation();\n+            return false;\n+        }\n+\n+        if (!request.getLoadAlertRequests().isEmpty()) {\n+            return isValidLoadAlertRequests(request, context);\n+        }\n+\n+        return true;\n+    }\n+\n+    private Boolean isValidLoadAlertRequests(DistroXAutoscaleClusterRequest request, ConstraintValidatorContext context) {\n+        Set<String> distinctLoadBasedHostGroups = new HashSet<>();\n+        Set<AdjustmentType> distinctLoadBasedAdjustmentTypes = new HashSet<>();\n+\n+        if (request.getLoadAlertRequests().size() > 1) {\n+            String message = String.format(\"LoadBased autoscaling currently supports a single HostGroup in a Cluster.\");\n+            com.sequenceiq.cloudbreak.validation.ValidatorUtil.addConstraintViolation(context, message, \"loadAlertRequests\")", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTE5MDA0Ng=="}, "originalCommit": {"oid": "d8ee7e1c27320672da427a3b05c3bc5396700d34"}, "originalPosition": 40}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcxMDgwODU4OnYy", "diffSide": "RIGHT", "path": "autoscale-api/src/main/java/com/sequenceiq/periscope/api/endpoint/validator/DistroXAutoscaleRequestValidator.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNFQxMTo0MzoyNVrOGfB76g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQwNzo0ODoxNlrOGfj7pg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTE5MDc2Mg==", "bodyText": "you can do this in the same map", "url": "https://github.com/hortonworks/cloudbreak/pull/8188#discussion_r435190762", "createdAt": "2020-06-04T11:43:25Z", "author": {"login": "topolyai5"}, "path": "autoscale-api/src/main/java/com/sequenceiq/periscope/api/endpoint/validator/DistroXAutoscaleRequestValidator.java", "diffHunk": "@@ -0,0 +1,74 @@\n+package com.sequenceiq.periscope.api.endpoint.validator;\n+\n+import java.util.HashSet;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import javax.validation.ConstraintValidator;\n+import javax.validation.ConstraintValidatorContext;\n+\n+import com.sequenceiq.periscope.api.model.AdjustmentType;\n+import com.sequenceiq.periscope.api.model.DistroXAutoscaleClusterRequest;\n+\n+public class DistroXAutoscaleRequestValidator\n+        implements ConstraintValidator<ValidDistroXAutoscaleRequest, DistroXAutoscaleClusterRequest> {\n+\n+    @Override\n+    public boolean isValid(DistroXAutoscaleClusterRequest request, ConstraintValidatorContext context) {\n+\n+        if (!request.getLoadAlertRequests().isEmpty() &&\n+                !request.getTimeAlertRequests().isEmpty()) {\n+            String message = String.format(\"Cluster can be configured with only one type of autoscaling policies.\");\n+            com.sequenceiq.cloudbreak.validation.ValidatorUtil.addConstraintViolation(context, message, \"autoscalingPolicy\")\n+                    .disableDefaultConstraintViolation();\n+            return false;\n+        }\n+\n+        if (!request.getLoadAlertRequests().isEmpty()) {\n+            return isValidLoadAlertRequests(request, context);\n+        }\n+\n+        return true;\n+    }\n+\n+    private Boolean isValidLoadAlertRequests(DistroXAutoscaleClusterRequest request, ConstraintValidatorContext context) {\n+        Set<String> distinctLoadBasedHostGroups = new HashSet<>();\n+        Set<AdjustmentType> distinctLoadBasedAdjustmentTypes = new HashSet<>();\n+\n+        if (request.getLoadAlertRequests().size() > 1) {\n+            String message = String.format(\"LoadBased autoscaling currently supports a single HostGroup in a Cluster.\");\n+            com.sequenceiq.cloudbreak.validation.ValidatorUtil.addConstraintViolation(context, message, \"loadAlertRequests\")\n+                    .disableDefaultConstraintViolation();\n+            return false;\n+        }\n+\n+        Set<String> duplicateHostGroups =\n+                request.getLoadAlertRequests().stream()\n+                        .map(loadAlertRequest -> loadAlertRequest.getScalingPolicy())\n+                        .map(scalingPolicyRequest -> {\n+                            distinctLoadBasedAdjustmentTypes.add(scalingPolicyRequest.getAdjustmentType());\n+                            return scalingPolicyRequest;\n+                        })\n+                        .map(scalingPolicyRequest -> scalingPolicyRequest.getHostGroup())", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d8ee7e1c27320672da427a3b05c3bc5396700d34"}, "originalPosition": 52}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTc0Nzc1MA==", "bodyText": "ok", "url": "https://github.com/hortonworks/cloudbreak/pull/8188#discussion_r435747750", "createdAt": "2020-06-05T07:48:16Z", "author": {"login": "smaniraju"}, "path": "autoscale-api/src/main/java/com/sequenceiq/periscope/api/endpoint/validator/DistroXAutoscaleRequestValidator.java", "diffHunk": "@@ -0,0 +1,74 @@\n+package com.sequenceiq.periscope.api.endpoint.validator;\n+\n+import java.util.HashSet;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import javax.validation.ConstraintValidator;\n+import javax.validation.ConstraintValidatorContext;\n+\n+import com.sequenceiq.periscope.api.model.AdjustmentType;\n+import com.sequenceiq.periscope.api.model.DistroXAutoscaleClusterRequest;\n+\n+public class DistroXAutoscaleRequestValidator\n+        implements ConstraintValidator<ValidDistroXAutoscaleRequest, DistroXAutoscaleClusterRequest> {\n+\n+    @Override\n+    public boolean isValid(DistroXAutoscaleClusterRequest request, ConstraintValidatorContext context) {\n+\n+        if (!request.getLoadAlertRequests().isEmpty() &&\n+                !request.getTimeAlertRequests().isEmpty()) {\n+            String message = String.format(\"Cluster can be configured with only one type of autoscaling policies.\");\n+            com.sequenceiq.cloudbreak.validation.ValidatorUtil.addConstraintViolation(context, message, \"autoscalingPolicy\")\n+                    .disableDefaultConstraintViolation();\n+            return false;\n+        }\n+\n+        if (!request.getLoadAlertRequests().isEmpty()) {\n+            return isValidLoadAlertRequests(request, context);\n+        }\n+\n+        return true;\n+    }\n+\n+    private Boolean isValidLoadAlertRequests(DistroXAutoscaleClusterRequest request, ConstraintValidatorContext context) {\n+        Set<String> distinctLoadBasedHostGroups = new HashSet<>();\n+        Set<AdjustmentType> distinctLoadBasedAdjustmentTypes = new HashSet<>();\n+\n+        if (request.getLoadAlertRequests().size() > 1) {\n+            String message = String.format(\"LoadBased autoscaling currently supports a single HostGroup in a Cluster.\");\n+            com.sequenceiq.cloudbreak.validation.ValidatorUtil.addConstraintViolation(context, message, \"loadAlertRequests\")\n+                    .disableDefaultConstraintViolation();\n+            return false;\n+        }\n+\n+        Set<String> duplicateHostGroups =\n+                request.getLoadAlertRequests().stream()\n+                        .map(loadAlertRequest -> loadAlertRequest.getScalingPolicy())\n+                        .map(scalingPolicyRequest -> {\n+                            distinctLoadBasedAdjustmentTypes.add(scalingPolicyRequest.getAdjustmentType());\n+                            return scalingPolicyRequest;\n+                        })\n+                        .map(scalingPolicyRequest -> scalingPolicyRequest.getHostGroup())", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTE5MDc2Mg=="}, "originalCommit": {"oid": "d8ee7e1c27320672da427a3b05c3bc5396700d34"}, "originalPosition": 52}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcxMTM0MTk5OnYy", "diffSide": "RIGHT", "path": "autoscale/build.gradle", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNFQxMzo1NToyOFrOGfHMTA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQwODo1ODo0NVrOGfmO5w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTI3Njg3Ng==", "bodyText": "where do you use h2? Are our schema SQL running on h2?", "url": "https://github.com/hortonworks/cloudbreak/pull/8188#discussion_r435276876", "createdAt": "2020-06-04T13:55:28Z", "author": {"login": "topolyai5"}, "path": "autoscale/build.gradle", "diffHunk": "@@ -164,6 +164,7 @@ dependencies {\n     testCompile group: 'org.powermock',             name: 'powermock-api-mockito2'\n     testCompile group: 'org.ow2.asm',               name: 'asm'\n     testCompile group: 'com.openpojo',              name: 'openpojo'\n+    testCompile group: \"com.h2database\",            name: \"h2\",     version: h2databaseVersion", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d8ee7e1c27320672da427a3b05c3bc5396700d34"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTc0ODY3Ng==", "bodyText": "h2 is used for running DistroXAutoScaleClusterV1EndpointTest service endpoint integration tests against embedded tomcat and database.", "url": "https://github.com/hortonworks/cloudbreak/pull/8188#discussion_r435748676", "createdAt": "2020-06-05T07:49:41Z", "author": {"login": "smaniraju"}, "path": "autoscale/build.gradle", "diffHunk": "@@ -164,6 +164,7 @@ dependencies {\n     testCompile group: 'org.powermock',             name: 'powermock-api-mockito2'\n     testCompile group: 'org.ow2.asm',               name: 'asm'\n     testCompile group: 'com.openpojo',              name: 'openpojo'\n+    testCompile group: \"com.h2database\",            name: \"h2\",     version: h2databaseVersion", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTI3Njg3Ng=="}, "originalCommit": {"oid": "d8ee7e1c27320672da427a3b05c3bc5396700d34"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTc4MzU5NA==", "bodyText": "is this integration test run as a unit test or the integration test of PR?", "url": "https://github.com/hortonworks/cloudbreak/pull/8188#discussion_r435783594", "createdAt": "2020-06-05T08:55:27Z", "author": {"login": "topolyai5"}, "path": "autoscale/build.gradle", "diffHunk": "@@ -164,6 +164,7 @@ dependencies {\n     testCompile group: 'org.powermock',             name: 'powermock-api-mockito2'\n     testCompile group: 'org.ow2.asm',               name: 'asm'\n     testCompile group: 'com.openpojo',              name: 'openpojo'\n+    testCompile group: \"com.h2database\",            name: \"h2\",     version: h2databaseVersion", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTI3Njg3Ng=="}, "originalCommit": {"oid": "d8ee7e1c27320672da427a3b05c3bc5396700d34"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTc4NTQ0Nw==", "bodyText": "Unit test similar to EnvironmentServiceIntegrationTest.", "url": "https://github.com/hortonworks/cloudbreak/pull/8188#discussion_r435785447", "createdAt": "2020-06-05T08:58:45Z", "author": {"login": "smaniraju"}, "path": "autoscale/build.gradle", "diffHunk": "@@ -164,6 +164,7 @@ dependencies {\n     testCompile group: 'org.powermock',             name: 'powermock-api-mockito2'\n     testCompile group: 'org.ow2.asm',               name: 'asm'\n     testCompile group: 'com.openpojo',              name: 'openpojo'\n+    testCompile group: \"com.h2database\",            name: \"h2\",     version: h2databaseVersion", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTI3Njg3Ng=="}, "originalCommit": {"oid": "d8ee7e1c27320672da427a3b05c3bc5396700d34"}, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcxMTM2OTQ2OnYy", "diffSide": "RIGHT", "path": "autoscale/src/main/java/com/sequenceiq/periscope/converter/db/StackTypeAttributeConverter.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNFQxNDowMTozNFrOGfHeVQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQwNzo0OTo1MFrOGfj_qw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTI4MTQ5Mw==", "bodyText": "You can use the DefaultEnumConverter", "url": "https://github.com/hortonworks/cloudbreak/pull/8188#discussion_r435281493", "createdAt": "2020-06-04T14:01:34Z", "author": {"login": "topolyai5"}, "path": "autoscale/src/main/java/com/sequenceiq/periscope/converter/db/StackTypeAttributeConverter.java", "diffHunk": "@@ -0,0 +1,27 @@\n+package com.sequenceiq.periscope.converter.db;\n+\n+import javax.persistence.AttributeConverter;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.sequenceiq.cloudbreak.api.endpoint.v4.common.StackType;\n+\n+public class StackTypeAttributeConverter implements AttributeConverter<StackType, String> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d8ee7e1c27320672da427a3b05c3bc5396700d34"}, "originalPosition": 10}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTc0ODc3OQ==", "bodyText": "ok", "url": "https://github.com/hortonworks/cloudbreak/pull/8188#discussion_r435748779", "createdAt": "2020-06-05T07:49:50Z", "author": {"login": "smaniraju"}, "path": "autoscale/src/main/java/com/sequenceiq/periscope/converter/db/StackTypeAttributeConverter.java", "diffHunk": "@@ -0,0 +1,27 @@\n+package com.sequenceiq.periscope.converter.db;\n+\n+import javax.persistence.AttributeConverter;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.sequenceiq.cloudbreak.api.endpoint.v4.common.StackType;\n+\n+public class StackTypeAttributeConverter implements AttributeConverter<StackType, String> {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTI4MTQ5Mw=="}, "originalCommit": {"oid": "d8ee7e1c27320672da427a3b05c3bc5396700d34"}, "originalPosition": 10}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcxMTM4NjIzOnYy", "diffSide": "RIGHT", "path": "autoscale/src/main/java/com/sequenceiq/periscope/monitor/evaluator/load/YarnLoadEvaluator.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNFQxNDowNTowNlrOGfHpTw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQwNzo1MDowM1rOGfkAFQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTI4NDMwMw==", "bodyText": "why not null?", "url": "https://github.com/hortonworks/cloudbreak/pull/8188#discussion_r435284303", "createdAt": "2020-06-04T14:05:06Z", "author": {"login": "topolyai5"}, "path": "autoscale/src/main/java/com/sequenceiq/periscope/monitor/evaluator/load/YarnLoadEvaluator.java", "diffHunk": "@@ -0,0 +1,172 @@\n+package com.sequenceiq.periscope.monitor.evaluator.load;\n+\n+import static com.sequenceiq.periscope.monitor.evaluator.ScalingConstants.DEFAULT_MAX_SCALE_UP_STEP_SIZE;\n+\n+import java.util.Comparator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+\n+import javax.annotation.Nonnull;\n+import javax.inject.Inject;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.context.annotation.Scope;\n+import org.springframework.stereotype.Component;\n+\n+import com.sequenceiq.cloudbreak.api.endpoint.v4.stacks.response.StackV4Response;\n+import com.sequenceiq.cloudbreak.logger.MDCBuilder;\n+import com.sequenceiq.periscope.domain.Cluster;\n+import com.sequenceiq.periscope.domain.LoadAlert;\n+import com.sequenceiq.periscope.domain.LoadAlertConfiguration;\n+import com.sequenceiq.periscope.model.yarn.YarnScalingServiceV1Response;\n+import com.sequenceiq.periscope.model.yarn.YarnScalingServiceV1Response.DecommissionCandidate;\n+import com.sequenceiq.periscope.model.yarn.YarnScalingServiceV1Response.NewNodeManagerCandidates;\n+import com.sequenceiq.periscope.monitor.client.YarnMetricsClient;\n+import com.sequenceiq.periscope.monitor.context.ClusterIdEvaluatorContext;\n+import com.sequenceiq.periscope.monitor.context.EvaluatorContext;\n+import com.sequenceiq.periscope.monitor.evaluator.EvaluatorExecutor;\n+import com.sequenceiq.periscope.monitor.evaluator.EventPublisher;\n+import com.sequenceiq.periscope.monitor.event.ScalingEvent;\n+import com.sequenceiq.periscope.monitor.event.UpdateFailedEvent;\n+import com.sequenceiq.periscope.monitor.handler.CloudbreakCommunicator;\n+import com.sequenceiq.periscope.repository.LoadAlertRepository;\n+import com.sequenceiq.periscope.service.ClusterService;\n+import com.sequenceiq.periscope.utils.StackResponseUtils;\n+\n+@Component(\"YarnLoadEvaluator\")\n+@Scope(\"prototype\")\n+public class YarnLoadEvaluator extends EvaluatorExecutor {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(YarnLoadEvaluator.class);\n+\n+    private static final String EVALUATOR_NAME = YarnLoadEvaluator.class.getName();\n+\n+    @Inject\n+    private ClusterService clusterService;\n+\n+    @Inject\n+    private LoadAlertRepository alertRepository;\n+\n+    @Inject\n+    private EventPublisher eventPublisher;\n+\n+    @Inject\n+    private YarnMetricsClient yarnMetricsClient;\n+\n+    @Inject\n+    private StackResponseUtils stackResponseUtils;\n+\n+    @Inject\n+    private CloudbreakCommunicator cloudbreakCommunicator;\n+\n+    private long clusterId;\n+\n+    private Cluster cluster;\n+\n+    private LoadAlert loadAlert;\n+\n+    private LoadAlertConfiguration loadAlertConfiguration;\n+\n+    private String policyHostGroup;\n+\n+    @Nonnull\n+    @Override\n+    public EvaluatorContext getContext() {\n+        return new ClusterIdEvaluatorContext(clusterId);\n+    }\n+\n+    @Override\n+    public void setContext(EvaluatorContext context) {\n+        clusterId = (long) context.getData();\n+    }\n+\n+    @Override\n+    public String getName() {\n+        return EVALUATOR_NAME;\n+    }\n+\n+    @Override\n+    protected void execute() {\n+        long start = System.currentTimeMillis();\n+        String stackCrn = \"NotInitialized\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d8ee7e1c27320672da427a3b05c3bc5396700d34"}, "originalPosition": 96}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTc0ODg4NQ==", "bodyText": "ok", "url": "https://github.com/hortonworks/cloudbreak/pull/8188#discussion_r435748885", "createdAt": "2020-06-05T07:50:03Z", "author": {"login": "smaniraju"}, "path": "autoscale/src/main/java/com/sequenceiq/periscope/monitor/evaluator/load/YarnLoadEvaluator.java", "diffHunk": "@@ -0,0 +1,172 @@\n+package com.sequenceiq.periscope.monitor.evaluator.load;\n+\n+import static com.sequenceiq.periscope.monitor.evaluator.ScalingConstants.DEFAULT_MAX_SCALE_UP_STEP_SIZE;\n+\n+import java.util.Comparator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+\n+import javax.annotation.Nonnull;\n+import javax.inject.Inject;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.context.annotation.Scope;\n+import org.springframework.stereotype.Component;\n+\n+import com.sequenceiq.cloudbreak.api.endpoint.v4.stacks.response.StackV4Response;\n+import com.sequenceiq.cloudbreak.logger.MDCBuilder;\n+import com.sequenceiq.periscope.domain.Cluster;\n+import com.sequenceiq.periscope.domain.LoadAlert;\n+import com.sequenceiq.periscope.domain.LoadAlertConfiguration;\n+import com.sequenceiq.periscope.model.yarn.YarnScalingServiceV1Response;\n+import com.sequenceiq.periscope.model.yarn.YarnScalingServiceV1Response.DecommissionCandidate;\n+import com.sequenceiq.periscope.model.yarn.YarnScalingServiceV1Response.NewNodeManagerCandidates;\n+import com.sequenceiq.periscope.monitor.client.YarnMetricsClient;\n+import com.sequenceiq.periscope.monitor.context.ClusterIdEvaluatorContext;\n+import com.sequenceiq.periscope.monitor.context.EvaluatorContext;\n+import com.sequenceiq.periscope.monitor.evaluator.EvaluatorExecutor;\n+import com.sequenceiq.periscope.monitor.evaluator.EventPublisher;\n+import com.sequenceiq.periscope.monitor.event.ScalingEvent;\n+import com.sequenceiq.periscope.monitor.event.UpdateFailedEvent;\n+import com.sequenceiq.periscope.monitor.handler.CloudbreakCommunicator;\n+import com.sequenceiq.periscope.repository.LoadAlertRepository;\n+import com.sequenceiq.periscope.service.ClusterService;\n+import com.sequenceiq.periscope.utils.StackResponseUtils;\n+\n+@Component(\"YarnLoadEvaluator\")\n+@Scope(\"prototype\")\n+public class YarnLoadEvaluator extends EvaluatorExecutor {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(YarnLoadEvaluator.class);\n+\n+    private static final String EVALUATOR_NAME = YarnLoadEvaluator.class.getName();\n+\n+    @Inject\n+    private ClusterService clusterService;\n+\n+    @Inject\n+    private LoadAlertRepository alertRepository;\n+\n+    @Inject\n+    private EventPublisher eventPublisher;\n+\n+    @Inject\n+    private YarnMetricsClient yarnMetricsClient;\n+\n+    @Inject\n+    private StackResponseUtils stackResponseUtils;\n+\n+    @Inject\n+    private CloudbreakCommunicator cloudbreakCommunicator;\n+\n+    private long clusterId;\n+\n+    private Cluster cluster;\n+\n+    private LoadAlert loadAlert;\n+\n+    private LoadAlertConfiguration loadAlertConfiguration;\n+\n+    private String policyHostGroup;\n+\n+    @Nonnull\n+    @Override\n+    public EvaluatorContext getContext() {\n+        return new ClusterIdEvaluatorContext(clusterId);\n+    }\n+\n+    @Override\n+    public void setContext(EvaluatorContext context) {\n+        clusterId = (long) context.getData();\n+    }\n+\n+    @Override\n+    public String getName() {\n+        return EVALUATOR_NAME;\n+    }\n+\n+    @Override\n+    protected void execute() {\n+        long start = System.currentTimeMillis();\n+        String stackCrn = \"NotInitialized\";", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTI4NDMwMw=="}, "originalCommit": {"oid": "d8ee7e1c27320672da427a3b05c3bc5396700d34"}, "originalPosition": 96}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcxMTM5NDg2OnYy", "diffSide": "RIGHT", "path": "autoscale/src/main/java/com/sequenceiq/periscope/monitor/evaluator/load/YarnLoadEvaluator.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNFQxNDowNjo1MlrOGfHuzQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQwNzo1MDoyOFrOGfkA8A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTI4NTcwOQ==", "bodyText": "can you break up smaller functions?", "url": "https://github.com/hortonworks/cloudbreak/pull/8188#discussion_r435285709", "createdAt": "2020-06-04T14:06:52Z", "author": {"login": "topolyai5"}, "path": "autoscale/src/main/java/com/sequenceiq/periscope/monitor/evaluator/load/YarnLoadEvaluator.java", "diffHunk": "@@ -0,0 +1,172 @@\n+package com.sequenceiq.periscope.monitor.evaluator.load;\n+\n+import static com.sequenceiq.periscope.monitor.evaluator.ScalingConstants.DEFAULT_MAX_SCALE_UP_STEP_SIZE;\n+\n+import java.util.Comparator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+\n+import javax.annotation.Nonnull;\n+import javax.inject.Inject;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.context.annotation.Scope;\n+import org.springframework.stereotype.Component;\n+\n+import com.sequenceiq.cloudbreak.api.endpoint.v4.stacks.response.StackV4Response;\n+import com.sequenceiq.cloudbreak.logger.MDCBuilder;\n+import com.sequenceiq.periscope.domain.Cluster;\n+import com.sequenceiq.periscope.domain.LoadAlert;\n+import com.sequenceiq.periscope.domain.LoadAlertConfiguration;\n+import com.sequenceiq.periscope.model.yarn.YarnScalingServiceV1Response;\n+import com.sequenceiq.periscope.model.yarn.YarnScalingServiceV1Response.DecommissionCandidate;\n+import com.sequenceiq.periscope.model.yarn.YarnScalingServiceV1Response.NewNodeManagerCandidates;\n+import com.sequenceiq.periscope.monitor.client.YarnMetricsClient;\n+import com.sequenceiq.periscope.monitor.context.ClusterIdEvaluatorContext;\n+import com.sequenceiq.periscope.monitor.context.EvaluatorContext;\n+import com.sequenceiq.periscope.monitor.evaluator.EvaluatorExecutor;\n+import com.sequenceiq.periscope.monitor.evaluator.EventPublisher;\n+import com.sequenceiq.periscope.monitor.event.ScalingEvent;\n+import com.sequenceiq.periscope.monitor.event.UpdateFailedEvent;\n+import com.sequenceiq.periscope.monitor.handler.CloudbreakCommunicator;\n+import com.sequenceiq.periscope.repository.LoadAlertRepository;\n+import com.sequenceiq.periscope.service.ClusterService;\n+import com.sequenceiq.periscope.utils.StackResponseUtils;\n+\n+@Component(\"YarnLoadEvaluator\")\n+@Scope(\"prototype\")\n+public class YarnLoadEvaluator extends EvaluatorExecutor {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(YarnLoadEvaluator.class);\n+\n+    private static final String EVALUATOR_NAME = YarnLoadEvaluator.class.getName();\n+\n+    @Inject\n+    private ClusterService clusterService;\n+\n+    @Inject\n+    private LoadAlertRepository alertRepository;\n+\n+    @Inject\n+    private EventPublisher eventPublisher;\n+\n+    @Inject\n+    private YarnMetricsClient yarnMetricsClient;\n+\n+    @Inject\n+    private StackResponseUtils stackResponseUtils;\n+\n+    @Inject\n+    private CloudbreakCommunicator cloudbreakCommunicator;\n+\n+    private long clusterId;\n+\n+    private Cluster cluster;\n+\n+    private LoadAlert loadAlert;\n+\n+    private LoadAlertConfiguration loadAlertConfiguration;\n+\n+    private String policyHostGroup;\n+\n+    @Nonnull\n+    @Override\n+    public EvaluatorContext getContext() {\n+        return new ClusterIdEvaluatorContext(clusterId);\n+    }\n+\n+    @Override\n+    public void setContext(EvaluatorContext context) {\n+        clusterId = (long) context.getData();\n+    }\n+\n+    @Override\n+    public String getName() {\n+        return EVALUATOR_NAME;\n+    }\n+\n+    @Override\n+    protected void execute() {\n+        long start = System.currentTimeMillis();\n+        String stackCrn = \"NotInitialized\";\n+        try {\n+            MDCBuilder.buildMdcContext(cluster);\n+            cluster = clusterService.findById(clusterId);\n+            stackCrn = cluster.getStackCrn();\n+            loadAlert = cluster.getLoadAlerts().stream().findFirst().get();\n+            loadAlertConfiguration = loadAlert.getLoadAlertConfiguration();\n+            policyHostGroup = loadAlert.getScalingPolicy().getHostGroup();\n+\n+            if (isCoolDownTimeElapsed(cluster.getStackCrn(), loadAlertConfiguration.getCoolDownMillis(),\n+                    cluster.getLastScalingActivity())) {\n+                pollYarnMetricsAndScaleCluster();\n+            }\n+        } catch (Exception ex) {\n+            LOGGER.info(\"Failed to process load alert for Cluster {}, exception {}\", stackCrn, ex);\n+            eventPublisher.publishEvent(new UpdateFailedEvent(clusterId));\n+        } finally {\n+            LOGGER.debug(\"Finished loadEvaluator for cluster {} in {} ms\", stackCrn, System.currentTimeMillis() - start);\n+        }\n+    }\n+\n+    protected void pollYarnMetricsAndScaleCluster() throws Exception {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d8ee7e1c27320672da427a3b05c3bc5396700d34"}, "originalPosition": 117}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTc0OTEwNA==", "bodyText": "done", "url": "https://github.com/hortonworks/cloudbreak/pull/8188#discussion_r435749104", "createdAt": "2020-06-05T07:50:28Z", "author": {"login": "smaniraju"}, "path": "autoscale/src/main/java/com/sequenceiq/periscope/monitor/evaluator/load/YarnLoadEvaluator.java", "diffHunk": "@@ -0,0 +1,172 @@\n+package com.sequenceiq.periscope.monitor.evaluator.load;\n+\n+import static com.sequenceiq.periscope.monitor.evaluator.ScalingConstants.DEFAULT_MAX_SCALE_UP_STEP_SIZE;\n+\n+import java.util.Comparator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+\n+import javax.annotation.Nonnull;\n+import javax.inject.Inject;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.context.annotation.Scope;\n+import org.springframework.stereotype.Component;\n+\n+import com.sequenceiq.cloudbreak.api.endpoint.v4.stacks.response.StackV4Response;\n+import com.sequenceiq.cloudbreak.logger.MDCBuilder;\n+import com.sequenceiq.periscope.domain.Cluster;\n+import com.sequenceiq.periscope.domain.LoadAlert;\n+import com.sequenceiq.periscope.domain.LoadAlertConfiguration;\n+import com.sequenceiq.periscope.model.yarn.YarnScalingServiceV1Response;\n+import com.sequenceiq.periscope.model.yarn.YarnScalingServiceV1Response.DecommissionCandidate;\n+import com.sequenceiq.periscope.model.yarn.YarnScalingServiceV1Response.NewNodeManagerCandidates;\n+import com.sequenceiq.periscope.monitor.client.YarnMetricsClient;\n+import com.sequenceiq.periscope.monitor.context.ClusterIdEvaluatorContext;\n+import com.sequenceiq.periscope.monitor.context.EvaluatorContext;\n+import com.sequenceiq.periscope.monitor.evaluator.EvaluatorExecutor;\n+import com.sequenceiq.periscope.monitor.evaluator.EventPublisher;\n+import com.sequenceiq.periscope.monitor.event.ScalingEvent;\n+import com.sequenceiq.periscope.monitor.event.UpdateFailedEvent;\n+import com.sequenceiq.periscope.monitor.handler.CloudbreakCommunicator;\n+import com.sequenceiq.periscope.repository.LoadAlertRepository;\n+import com.sequenceiq.periscope.service.ClusterService;\n+import com.sequenceiq.periscope.utils.StackResponseUtils;\n+\n+@Component(\"YarnLoadEvaluator\")\n+@Scope(\"prototype\")\n+public class YarnLoadEvaluator extends EvaluatorExecutor {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(YarnLoadEvaluator.class);\n+\n+    private static final String EVALUATOR_NAME = YarnLoadEvaluator.class.getName();\n+\n+    @Inject\n+    private ClusterService clusterService;\n+\n+    @Inject\n+    private LoadAlertRepository alertRepository;\n+\n+    @Inject\n+    private EventPublisher eventPublisher;\n+\n+    @Inject\n+    private YarnMetricsClient yarnMetricsClient;\n+\n+    @Inject\n+    private StackResponseUtils stackResponseUtils;\n+\n+    @Inject\n+    private CloudbreakCommunicator cloudbreakCommunicator;\n+\n+    private long clusterId;\n+\n+    private Cluster cluster;\n+\n+    private LoadAlert loadAlert;\n+\n+    private LoadAlertConfiguration loadAlertConfiguration;\n+\n+    private String policyHostGroup;\n+\n+    @Nonnull\n+    @Override\n+    public EvaluatorContext getContext() {\n+        return new ClusterIdEvaluatorContext(clusterId);\n+    }\n+\n+    @Override\n+    public void setContext(EvaluatorContext context) {\n+        clusterId = (long) context.getData();\n+    }\n+\n+    @Override\n+    public String getName() {\n+        return EVALUATOR_NAME;\n+    }\n+\n+    @Override\n+    protected void execute() {\n+        long start = System.currentTimeMillis();\n+        String stackCrn = \"NotInitialized\";\n+        try {\n+            MDCBuilder.buildMdcContext(cluster);\n+            cluster = clusterService.findById(clusterId);\n+            stackCrn = cluster.getStackCrn();\n+            loadAlert = cluster.getLoadAlerts().stream().findFirst().get();\n+            loadAlertConfiguration = loadAlert.getLoadAlertConfiguration();\n+            policyHostGroup = loadAlert.getScalingPolicy().getHostGroup();\n+\n+            if (isCoolDownTimeElapsed(cluster.getStackCrn(), loadAlertConfiguration.getCoolDownMillis(),\n+                    cluster.getLastScalingActivity())) {\n+                pollYarnMetricsAndScaleCluster();\n+            }\n+        } catch (Exception ex) {\n+            LOGGER.info(\"Failed to process load alert for Cluster {}, exception {}\", stackCrn, ex);\n+            eventPublisher.publishEvent(new UpdateFailedEvent(clusterId));\n+        } finally {\n+            LOGGER.debug(\"Finished loadEvaluator for cluster {} in {} ms\", stackCrn, System.currentTimeMillis() - start);\n+        }\n+    }\n+\n+    protected void pollYarnMetricsAndScaleCluster() throws Exception {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTI4NTcwOQ=="}, "originalCommit": {"oid": "d8ee7e1c27320672da427a3b05c3bc5396700d34"}, "originalPosition": 117}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcxMTQxMjk1OnYy", "diffSide": "RIGHT", "path": "autoscale/src/main/java/com/sequenceiq/periscope/monitor/handler/UpdateFailedHandler.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNFQxNDoxMDo1MVrOGfH6XQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQwNzo1MzozMlrOGfkGwQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTI4ODY2OQ==", "bodyText": "can you create a list with the suspended statuses and check whether contains or not?", "url": "https://github.com/hortonworks/cloudbreak/pull/8188#discussion_r435288669", "createdAt": "2020-06-04T14:10:51Z", "author": {"login": "topolyai5"}, "path": "autoscale/src/main/java/com/sequenceiq/periscope/monitor/handler/UpdateFailedHandler.java", "diffHunk": "@@ -43,57 +41,53 @@\n     @Inject\n     private CloudbreakCommunicator cloudbreakCommunicator;\n \n-    @Inject\n-    private FailedNodeRepository failedNodeRepository;\n-\n     private final Map<Long, Integer> updateFailures = new ConcurrentHashMap<>();\n \n     @Override\n     public void onApplicationEvent(UpdateFailedEvent event) {\n         long autoscaleClusterId = event.getClusterId();\n-        LOGGER.debug(\"Cluster {} failed\", autoscaleClusterId);\n         Cluster cluster = clusterService.findById(autoscaleClusterId);\n         if (cluster == null) {\n             return;\n         }\n         MDCBuilder.buildMdcContext(cluster);\n+        LOGGER.debug(\"Analysing Cluster Status '{}' \", cluster.getStackCrn());\n         StackV4Response stackResponse = getStackById(cluster.getStackCrn());\n-        if (stackResponse == null) {\n-            LOGGER.debug(\"Suspending cluster {}\", autoscaleClusterId);\n+        String stackStatus = getStackStatus(stackResponse);\n+        if (stackResponse == null || stackStatus.startsWith(STOPPED_STATUSES_PREFIX)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d8ee7e1c27320672da427a3b05c3bc5396700d34"}, "originalPosition": 56}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTc1MDU5Mw==", "bodyText": "Agree, replaced functionality to use inbuilt Status::isAvailable and also abstracted CBCluster state sync functionality out of UpdateFailedHandler since there was overlap functionality here in tracking failures and syncing cluster status. Also split the unit-tests to separate cluster sync and update failure tracking.", "url": "https://github.com/hortonworks/cloudbreak/pull/8188#discussion_r435750593", "createdAt": "2020-06-05T07:53:32Z", "author": {"login": "smaniraju"}, "path": "autoscale/src/main/java/com/sequenceiq/periscope/monitor/handler/UpdateFailedHandler.java", "diffHunk": "@@ -43,57 +41,53 @@\n     @Inject\n     private CloudbreakCommunicator cloudbreakCommunicator;\n \n-    @Inject\n-    private FailedNodeRepository failedNodeRepository;\n-\n     private final Map<Long, Integer> updateFailures = new ConcurrentHashMap<>();\n \n     @Override\n     public void onApplicationEvent(UpdateFailedEvent event) {\n         long autoscaleClusterId = event.getClusterId();\n-        LOGGER.debug(\"Cluster {} failed\", autoscaleClusterId);\n         Cluster cluster = clusterService.findById(autoscaleClusterId);\n         if (cluster == null) {\n             return;\n         }\n         MDCBuilder.buildMdcContext(cluster);\n+        LOGGER.debug(\"Analysing Cluster Status '{}' \", cluster.getStackCrn());\n         StackV4Response stackResponse = getStackById(cluster.getStackCrn());\n-        if (stackResponse == null) {\n-            LOGGER.debug(\"Suspending cluster {}\", autoscaleClusterId);\n+        String stackStatus = getStackStatus(stackResponse);\n+        if (stackResponse == null || stackStatus.startsWith(STOPPED_STATUSES_PREFIX)) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTI4ODY2OQ=="}, "originalCommit": {"oid": "d8ee7e1c27320672da427a3b05c3bc5396700d34"}, "originalPosition": 56}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcxMTQyNjM0OnYy", "diffSide": "RIGHT", "path": "autoscale/src/main/java/com/sequenceiq/periscope/repository/ClusterPertainRepository.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNFQxNDoxMzo0OVrOGfIC8A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQwNzo1NDo0OFrOGfkJTA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTI5MDg2NA==", "bodyText": "It much better: ClusterPertain findByUserCrn(String userCrn) and should be work", "url": "https://github.com/hortonworks/cloudbreak/pull/8188#discussion_r435290864", "createdAt": "2020-06-04T14:13:49Z", "author": {"login": "topolyai5"}, "path": "autoscale/src/main/java/com/sequenceiq/periscope/repository/ClusterPertainRepository.java", "diffHunk": "@@ -0,0 +1,20 @@\n+package com.sequenceiq.periscope.repository;\n+\n+import java.util.List;\n+\n+import org.springframework.data.domain.PageRequest;\n+import org.springframework.data.domain.Pageable;\n+import org.springframework.data.repository.CrudRepository;\n+import org.springframework.data.repository.query.Param;\n+\n+import com.sequenceiq.cloudbreak.workspace.repository.EntityType;\n+import com.sequenceiq.periscope.domain.ClusterPertain;\n+\n+@EntityType(entityClass = ClusterPertain.class)\n+public interface ClusterPertainRepository extends CrudRepository<ClusterPertain, Long> {\n+    List<ClusterPertain> findByUserCrn(@Param(\"userCrn\") String userCrn, Pageable page);\n+\n+    default List<ClusterPertain> findByUserCrn(String userCrn) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d8ee7e1c27320672da427a3b05c3bc5396700d34"}, "originalPosition": 17}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTc1MTI0NA==", "bodyText": "agree updated existing cluster->clusterpertain mapping to support ManyToOne and api to ClusterPertain findByUserCrn(String userCrn)", "url": "https://github.com/hortonworks/cloudbreak/pull/8188#discussion_r435751244", "createdAt": "2020-06-05T07:54:48Z", "author": {"login": "smaniraju"}, "path": "autoscale/src/main/java/com/sequenceiq/periscope/repository/ClusterPertainRepository.java", "diffHunk": "@@ -0,0 +1,20 @@\n+package com.sequenceiq.periscope.repository;\n+\n+import java.util.List;\n+\n+import org.springframework.data.domain.PageRequest;\n+import org.springframework.data.domain.Pageable;\n+import org.springframework.data.repository.CrudRepository;\n+import org.springframework.data.repository.query.Param;\n+\n+import com.sequenceiq.cloudbreak.workspace.repository.EntityType;\n+import com.sequenceiq.periscope.domain.ClusterPertain;\n+\n+@EntityType(entityClass = ClusterPertain.class)\n+public interface ClusterPertainRepository extends CrudRepository<ClusterPertain, Long> {\n+    List<ClusterPertain> findByUserCrn(@Param(\"userCrn\") String userCrn, Pageable page);\n+\n+    default List<ClusterPertain> findByUserCrn(String userCrn) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTI5MDg2NA=="}, "originalCommit": {"oid": "d8ee7e1c27320672da427a3b05c3bc5396700d34"}, "originalPosition": 17}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3264, "cost": 1, "resetAt": "2021-11-12T20:44:06Z"}}}