{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDkxNDEwNTYw", "number": 9065, "reviewThreads": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yM1QwNzo0ODoxOFrOEmahkQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yM1QwOToxMzowOVrOEmdiig==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA4NzE1OTIxOnYy", "diffSide": "RIGHT", "path": "freeipa/src/main/java/com/sequenceiq/freeipa/sync/FreeipaChecker.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yM1QwNzo0ODoxOFrOHWax4g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yM1QwNzo0ODoxOFrOHWax4g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzI2OTQ3NA==", "bodyText": "this became unused", "url": "https://github.com/hortonworks/cloudbreak/pull/9065#discussion_r493269474", "createdAt": "2020-09-23T07:48:18Z", "author": {"login": "lacikaaa"}, "path": "freeipa/src/main/java/com/sequenceiq/freeipa/sync/FreeipaChecker.java", "diffHunk": "@@ -35,41 +34,60 @@\n     @Inject\n     private InstanceMetaDataService instanceMetaDataService;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d9329dd6b6e248cf8cd321d47bd13f60bde32e3c"}, "originalPosition": 24}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA4NzE5NzgyOnYy", "diffSide": "RIGHT", "path": "freeipa/src/main/java/com/sequenceiq/freeipa/sync/FreeipaChecker.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yM1QwNzo1NjowMlrOHWbJ5w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yM1QyMjo1MjoyMlrOHXDngg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzI3NTYyMw==", "bodyText": "what's the purpose of this result? the name and the thing it's a boolean makes me confused. Also I don't see any usage of SyncResult#getResult so we might drop it", "url": "https://github.com/hortonworks/cloudbreak/pull/9065#discussion_r493275623", "createdAt": "2020-09-23T07:56:02Z", "author": {"login": "lacikaaa"}, "path": "freeipa/src/main/java/com/sequenceiq/freeipa/sync/FreeipaChecker.java", "diffHunk": "@@ -35,41 +34,60 @@\n     @Inject\n     private InstanceMetaDataService instanceMetaDataService;\n \n-    private List<RPCResponse<Boolean>> checkStatus(Stack stack, Set<InstanceMetaData> checkableInstances) throws Exception {\n+    private Pair<List<DetailedStackStatus>, String> checkStatus(Stack stack, Set<InstanceMetaData> checkableInstances) throws Exception {\n         return checkedMeasure(() -> {\n-            List<RPCResponse<Boolean>> statuses = new LinkedList<>();\n+            List<DetailedStackStatus> statuses = new LinkedList<>();\n+            List<RPCResponse<Boolean>> responses = new LinkedList<>();\n             for (InstanceMetaData instanceMetaData : checkableInstances) {\n                 String hostname = instanceMetaData.getDiscoveryFQDN();\n-                FreeIpaClient freeIpaClient = checkedMeasure(() -> freeIpaClientFactory.getFreeIpaClientForStackWithPing(stack, hostname), LOGGER,\n-                        \":::Auto sync::: freeipa client is created in {}ms\");\n-                statuses.add(checkedMeasure(() -> freeIpaClient.serverConnCheck(freeIpaClient.getHostname(), hostname), LOGGER,\n-                        \":::Auto sync::: freeipa server_conncheck ran in {}ms\"));\n+                try {\n+                    FreeIpaClient freeIpaClient = checkedMeasure(() -> freeIpaClientFactory.getFreeIpaClientForStackWithPing(stack, hostname), LOGGER,\n+                            \":::Auto sync::: freeipa client is created in {}ms\");\n+                    RPCResponse<Boolean> response = checkedMeasure(() -> freeIpaClient.serverConnCheck(freeIpaClient.getHostname(), hostname), LOGGER,\n+                            \":::Auto sync::: freeipa server_conncheck ran in {}ms\");\n+                    responses.add(response);\n+                    if (response.getResult()) {\n+                        statuses.add(DetailedStackStatus.AVAILABLE);\n+                    } else {\n+                        statuses.add(DetailedStackStatus.UNHEALTHY);\n+                    }\n+                } catch (Exception e) {\n+                    LOGGER.info(\"FreeIpaClientException occurred during status fetch: \" + e.getMessage(), e);\n+                    statuses.add(DetailedStackStatus.UNREACHABLE);\n+                }\n             }\n-            return statuses;\n+            String message = getMessages(responses);\n+            return Pair.of(statuses, message);\n         }, LOGGER, \":::Auto sync::: freeipa server status is checked in {}ms\");\n     }\n \n     public SyncResult getStatus(Stack stack, Set<InstanceMetaData> checkableInstances) {\n         try {\n-            Set<InstanceMetaData> notTermiatedStackInstances = instanceMetaDataService.findNotTerminatedForStack(stack.getId());\n-            List<RPCResponse<Boolean>> responses = checkStatus(stack, checkableInstances);\n+            // Exclude terminated but include deleted\n+            Set<InstanceMetaData> notTermiatedStackInstances = stack.getAllInstanceMetaDataList().stream()\n+                    .filter(Predicate.not(InstanceMetaData::isTerminated))\n+                    .collect(Collectors.toSet());\n+            Pair<List<DetailedStackStatus>, String> statusCheckPair = checkStatus(stack, checkableInstances);\n+            List<DetailedStackStatus> responses = statusCheckPair.getFirst();\n             DetailedStackStatus status;\n             String postFix = \"\";\n-            Boolean result = !responses.isEmpty() && responses.stream().allMatch(RPCResponse::getResult);\n-            if (result && responses.size() == notTermiatedStackInstances.size()) {\n-                status = DetailedStackStatus.PROVISIONED;\n+            Boolean result = false;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d9329dd6b6e248cf8cd321d47bd13f60bde32e3c"}, "originalPosition": 75}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzkzODU2Mg==", "bodyText": "I didn't notice that the result isn't even ever read. So I got rid of it and that helped clean up more of the logic.\nThanks.", "url": "https://github.com/hortonworks/cloudbreak/pull/9065#discussion_r493938562", "createdAt": "2020-09-23T22:52:22Z", "author": {"login": "jamisonbennett"}, "path": "freeipa/src/main/java/com/sequenceiq/freeipa/sync/FreeipaChecker.java", "diffHunk": "@@ -35,41 +34,60 @@\n     @Inject\n     private InstanceMetaDataService instanceMetaDataService;\n \n-    private List<RPCResponse<Boolean>> checkStatus(Stack stack, Set<InstanceMetaData> checkableInstances) throws Exception {\n+    private Pair<List<DetailedStackStatus>, String> checkStatus(Stack stack, Set<InstanceMetaData> checkableInstances) throws Exception {\n         return checkedMeasure(() -> {\n-            List<RPCResponse<Boolean>> statuses = new LinkedList<>();\n+            List<DetailedStackStatus> statuses = new LinkedList<>();\n+            List<RPCResponse<Boolean>> responses = new LinkedList<>();\n             for (InstanceMetaData instanceMetaData : checkableInstances) {\n                 String hostname = instanceMetaData.getDiscoveryFQDN();\n-                FreeIpaClient freeIpaClient = checkedMeasure(() -> freeIpaClientFactory.getFreeIpaClientForStackWithPing(stack, hostname), LOGGER,\n-                        \":::Auto sync::: freeipa client is created in {}ms\");\n-                statuses.add(checkedMeasure(() -> freeIpaClient.serverConnCheck(freeIpaClient.getHostname(), hostname), LOGGER,\n-                        \":::Auto sync::: freeipa server_conncheck ran in {}ms\"));\n+                try {\n+                    FreeIpaClient freeIpaClient = checkedMeasure(() -> freeIpaClientFactory.getFreeIpaClientForStackWithPing(stack, hostname), LOGGER,\n+                            \":::Auto sync::: freeipa client is created in {}ms\");\n+                    RPCResponse<Boolean> response = checkedMeasure(() -> freeIpaClient.serverConnCheck(freeIpaClient.getHostname(), hostname), LOGGER,\n+                            \":::Auto sync::: freeipa server_conncheck ran in {}ms\");\n+                    responses.add(response);\n+                    if (response.getResult()) {\n+                        statuses.add(DetailedStackStatus.AVAILABLE);\n+                    } else {\n+                        statuses.add(DetailedStackStatus.UNHEALTHY);\n+                    }\n+                } catch (Exception e) {\n+                    LOGGER.info(\"FreeIpaClientException occurred during status fetch: \" + e.getMessage(), e);\n+                    statuses.add(DetailedStackStatus.UNREACHABLE);\n+                }\n             }\n-            return statuses;\n+            String message = getMessages(responses);\n+            return Pair.of(statuses, message);\n         }, LOGGER, \":::Auto sync::: freeipa server status is checked in {}ms\");\n     }\n \n     public SyncResult getStatus(Stack stack, Set<InstanceMetaData> checkableInstances) {\n         try {\n-            Set<InstanceMetaData> notTermiatedStackInstances = instanceMetaDataService.findNotTerminatedForStack(stack.getId());\n-            List<RPCResponse<Boolean>> responses = checkStatus(stack, checkableInstances);\n+            // Exclude terminated but include deleted\n+            Set<InstanceMetaData> notTermiatedStackInstances = stack.getAllInstanceMetaDataList().stream()\n+                    .filter(Predicate.not(InstanceMetaData::isTerminated))\n+                    .collect(Collectors.toSet());\n+            Pair<List<DetailedStackStatus>, String> statusCheckPair = checkStatus(stack, checkableInstances);\n+            List<DetailedStackStatus> responses = statusCheckPair.getFirst();\n             DetailedStackStatus status;\n             String postFix = \"\";\n-            Boolean result = !responses.isEmpty() && responses.stream().allMatch(RPCResponse::getResult);\n-            if (result && responses.size() == notTermiatedStackInstances.size()) {\n-                status = DetailedStackStatus.PROVISIONED;\n+            Boolean result = false;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzI3NTYyMw=="}, "originalCommit": {"oid": "d9329dd6b6e248cf8cd321d47bd13f60bde32e3c"}, "originalPosition": 75}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA4NzIxMDEyOnYy", "diffSide": "RIGHT", "path": "freeipa/src/main/java/com/sequenceiq/freeipa/sync/FreeipaChecker.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yM1QwNzo1Nzo1NlrOHWbRgA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yM1QwNzo1Nzo1NlrOHWbRgA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzI3NzU2OA==", "bodyText": "could you refactor this condition. at least I think the stream on should be moved to a method/variable called something like isAllStatusTheSame if I guess well it's purpose", "url": "https://github.com/hortonworks/cloudbreak/pull/9065#discussion_r493277568", "createdAt": "2020-09-23T07:57:56Z", "author": {"login": "lacikaaa"}, "path": "freeipa/src/main/java/com/sequenceiq/freeipa/sync/FreeipaChecker.java", "diffHunk": "@@ -35,41 +34,60 @@\n     @Inject\n     private InstanceMetaDataService instanceMetaDataService;\n \n-    private List<RPCResponse<Boolean>> checkStatus(Stack stack, Set<InstanceMetaData> checkableInstances) throws Exception {\n+    private Pair<List<DetailedStackStatus>, String> checkStatus(Stack stack, Set<InstanceMetaData> checkableInstances) throws Exception {\n         return checkedMeasure(() -> {\n-            List<RPCResponse<Boolean>> statuses = new LinkedList<>();\n+            List<DetailedStackStatus> statuses = new LinkedList<>();\n+            List<RPCResponse<Boolean>> responses = new LinkedList<>();\n             for (InstanceMetaData instanceMetaData : checkableInstances) {\n                 String hostname = instanceMetaData.getDiscoveryFQDN();\n-                FreeIpaClient freeIpaClient = checkedMeasure(() -> freeIpaClientFactory.getFreeIpaClientForStackWithPing(stack, hostname), LOGGER,\n-                        \":::Auto sync::: freeipa client is created in {}ms\");\n-                statuses.add(checkedMeasure(() -> freeIpaClient.serverConnCheck(freeIpaClient.getHostname(), hostname), LOGGER,\n-                        \":::Auto sync::: freeipa server_conncheck ran in {}ms\"));\n+                try {\n+                    FreeIpaClient freeIpaClient = checkedMeasure(() -> freeIpaClientFactory.getFreeIpaClientForStackWithPing(stack, hostname), LOGGER,\n+                            \":::Auto sync::: freeipa client is created in {}ms\");\n+                    RPCResponse<Boolean> response = checkedMeasure(() -> freeIpaClient.serverConnCheck(freeIpaClient.getHostname(), hostname), LOGGER,\n+                            \":::Auto sync::: freeipa server_conncheck ran in {}ms\");\n+                    responses.add(response);\n+                    if (response.getResult()) {\n+                        statuses.add(DetailedStackStatus.AVAILABLE);\n+                    } else {\n+                        statuses.add(DetailedStackStatus.UNHEALTHY);\n+                    }\n+                } catch (Exception e) {\n+                    LOGGER.info(\"FreeIpaClientException occurred during status fetch: \" + e.getMessage(), e);\n+                    statuses.add(DetailedStackStatus.UNREACHABLE);\n+                }\n             }\n-            return statuses;\n+            String message = getMessages(responses);\n+            return Pair.of(statuses, message);\n         }, LOGGER, \":::Auto sync::: freeipa server status is checked in {}ms\");\n     }\n \n     public SyncResult getStatus(Stack stack, Set<InstanceMetaData> checkableInstances) {\n         try {\n-            Set<InstanceMetaData> notTermiatedStackInstances = instanceMetaDataService.findNotTerminatedForStack(stack.getId());\n-            List<RPCResponse<Boolean>> responses = checkStatus(stack, checkableInstances);\n+            // Exclude terminated but include deleted\n+            Set<InstanceMetaData> notTermiatedStackInstances = stack.getAllInstanceMetaDataList().stream()\n+                    .filter(Predicate.not(InstanceMetaData::isTerminated))\n+                    .collect(Collectors.toSet());\n+            Pair<List<DetailedStackStatus>, String> statusCheckPair = checkStatus(stack, checkableInstances);\n+            List<DetailedStackStatus> responses = statusCheckPair.getFirst();\n             DetailedStackStatus status;\n             String postFix = \"\";\n-            Boolean result = !responses.isEmpty() && responses.stream().allMatch(RPCResponse::getResult);\n-            if (result && responses.size() == notTermiatedStackInstances.size()) {\n-                status = DetailedStackStatus.PROVISIONED;\n+            Boolean result = false;\n+            if (responses.isEmpty()) {\n+                status = DetailedStackStatus.UNREACHABLE;\n+                postFix = \"Freeipa is unreachable, \";\n             } else {\n-                status = DetailedStackStatus.UNHEALTHY;\n-                postFix = \"Freeipa is unhealthy, \";\n+                DetailedStackStatus first = responses.get(0);\n+                if (responses.stream().allMatch(Predicate.isEqual(first)) && responses.size() == notTermiatedStackInstances.size()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d9329dd6b6e248cf8cd321d47bd13f60bde32e3c"}, "originalPosition": 83}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA4NzIzMjIxOnYy", "diffSide": "RIGHT", "path": "freeipa/src/main/java/com/sequenceiq/freeipa/sync/StackStatusCheckerJob.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yM1QwODowMTozN1rOHWbf7A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yM1QwODowMTozN1rOHWbf7A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzI4MTI2MA==", "bodyText": "InstanceMetaDataService is not used anymore, please remove", "url": "https://github.com/hortonworks/cloudbreak/pull/9065#discussion_r493281260", "createdAt": "2020-09-23T08:01:37Z", "author": {"login": "lacikaaa"}, "path": "freeipa/src/main/java/com/sequenceiq/freeipa/sync/StackStatusCheckerJob.java", "diffHunk": "@@ -88,8 +88,12 @@ private void syncAStack(Stack stack) {\n         try {\n             checkedMeasure(() -> {\n                 ThreadBasedUserCrnProvider.doAsInternalActor(() -> {\n-                    Set<InstanceMetaData> notTerminatedForStack = instanceMetaDataService.findNotTerminatedForStack(stack.getId());\n-                    Set<InstanceMetaData> checkableInstances = notTerminatedForStack.stream().filter(i -> !i.isDeletedOnProvider())\n+                    // Exclude terminated but include deleted", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d9329dd6b6e248cf8cd321d47bd13f60bde32e3c"}, "originalPosition": 15}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA4NzY1MzIyOnYy", "diffSide": "RIGHT", "path": "freeipa/src/test/java/com/sequenceiq/freeipa/sync/StackStatusTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yM1QwOToxMzowOVrOHWfv_A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yM1QwOToxMzowOVrOHWfv_A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzM1MDkwOA==", "bodyText": "I guess this should be INSTANCE_2. Same applies to someStoppped.\nHowever the test is green, so this case should be investigated.", "url": "https://github.com/hortonworks/cloudbreak/pull/9065#discussion_r493350908", "createdAt": "2020-09-23T09:13:09Z", "author": {"login": "Bajzathd"}, "path": "freeipa/src/test/java/com/sequenceiq/freeipa/sync/StackStatusTest.java", "diffHunk": "@@ -152,6 +174,82 @@ void deleted() throws JobExecutionException {\n         verify(stackUpdater).updateStackStatus(eq(stack), eq(DetailedStackStatus.DELETED_ON_PROVIDER_SIDE), any());\n     }\n \n+    @Test\n+    @DisplayName(\n+            \"GIVEN an available stack \" +\n+                    \"WHEN FreeIpa instance is stopped \" +\n+                    \"THEN stack status should change\"\n+    )\n+    void stoppped() throws Exception {\n+        setUp(1);\n+        setUpFreeIpaAvailabilityResponse(false);\n+        when(stackInstanceProviderChecker.checkStatus(stack, notTerminatedInstances)).thenReturn(List.of(\n+                createCloudVmInstanceStatus(INSTANCE_1, com.sequenceiq.cloudbreak.cloud.model.InstanceStatus.STOPPED)\n+        ));\n+\n+        underTest.executeInternal(jobExecutionContext);\n+\n+        verify(stackUpdater).updateStackStatus(eq(stack), eq(DetailedStackStatus.STOPPED), any());\n+    }\n+\n+    @Test\n+    @DisplayName(\n+            \"GIVEN an available stack \" +\n+                    \"WHEN All FreeIpa instance are stopped \" +\n+                    \"THEN stack status should change\"\n+    )\n+    void allStoppped() throws Exception {\n+        setUp(2);\n+        setUpFreeIpaAvailabilityResponse(false);\n+        when(stackInstanceProviderChecker.checkStatus(stack, notTerminatedInstances)).thenReturn(List.of(\n+                createCloudVmInstanceStatus(INSTANCE_1, com.sequenceiq.cloudbreak.cloud.model.InstanceStatus.STOPPED),\n+                createCloudVmInstanceStatus(INSTANCE_1, com.sequenceiq.cloudbreak.cloud.model.InstanceStatus.STOPPED)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d9329dd6b6e248cf8cd321d47bd13f60bde32e3c"}, "originalPosition": 138}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2200, "cost": 1, "resetAt": "2021-11-12T20:44:06Z"}}}