{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDc4NTcwODM2", "number": 8918, "reviewThreads": {"totalCount": 15, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wM1QyMTozOToxNVrOEgKjxw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wNFQxMzo1NDowNlrOEgZEwQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAyMTYyODg3OnYy", "diffSide": "RIGHT", "path": "cloud-api/src/main/java/com/sequenceiq/cloudbreak/cloud/DefaultNetworkConnector.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wM1QyMTozOToxNVrOHM4XDg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wM1QyMTozOToxNVrOHM4XDg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzI2ODM2Ng==", "bodyText": "Not pressing, but something we have to look out for. GCP subnets span across all the AZs in that region, and the user can not control it. So giving a subnet is enough in GCP.", "url": "https://github.com/hortonworks/cloudbreak/pull/8918#discussion_r483268366", "createdAt": "2020-09-03T21:39:15Z", "author": {"login": "cegganesh84"}, "path": "cloud-api/src/main/java/com/sequenceiq/cloudbreak/cloud/DefaultNetworkConnector.java", "diffHunk": "@@ -17,14 +17,14 @@\n import com.sequenceiq.cloudbreak.cloud.model.SubnetSelectionParameters;\n import com.sequenceiq.cloudbreak.cloud.model.SubnetSelectionResult;\n \n-public abstract class DefaultNetworkConnector implements NetworkConnector {\n+public interface DefaultNetworkConnector extends NetworkConnector {\n \n-    private static final Logger LOGGER = LoggerFactory.getLogger(DefaultNetworkConnector.class);\n+    Logger LOGGER = LoggerFactory.getLogger(DefaultNetworkConnector.class);\n \n-    private static final String NOT_ENOUGH_AZ = \"Acceptable subnets are in %d different AZs, but subnets in %d different AZs required.\";\n+    String NOT_ENOUGH_AZ = \"Acceptable subnets are in %d different AZs, but subnets in %d different AZs required.\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b25ea7e13e0f9bab1103c27aafd7ba1538e59c7b"}, "originalPosition": 11}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAyMTY1MTg3OnYy", "diffSide": "RIGHT", "path": "environment/src/main/java/com/sequenceiq/environment/environment/service/EnvironmentCreationService.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wM1QyMTo0Nzo0MFrOHM4kjA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wNFQwNjoyNjowNFrOHNBK1A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzI3MTgyMA==", "bodyText": "I have changed the error message to  \"Provisioning in \" + creationDto.getCloudPlatform() + \" is not enabled for this account.\" locally.", "url": "https://github.com/hortonworks/cloudbreak/pull/8918#discussion_r483271820", "createdAt": "2020-09-03T21:47:40Z", "author": {"login": "cegganesh84"}, "path": "environment/src/main/java/com/sequenceiq/environment/environment/service/EnvironmentCreationService.java", "diffHunk": "@@ -136,6 +137,7 @@ private void validateCreation(EnvironmentCreationDto creationDto, Environment en\n     }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b25ea7e13e0f9bab1103c27aafd7ba1538e59c7b"}, "originalPosition": 9}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzQxMjY5Mg==", "bodyText": "\ud83d\udc4d", "url": "https://github.com/hortonworks/cloudbreak/pull/8918#discussion_r483412692", "createdAt": "2020-09-04T06:26:04Z", "author": {"login": "doktoric"}, "path": "environment/src/main/java/com/sequenceiq/environment/environment/service/EnvironmentCreationService.java", "diffHunk": "@@ -136,6 +137,7 @@ private void validateCreation(EnvironmentCreationDto creationDto, Environment en\n     }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzI3MTgyMA=="}, "originalCommit": {"oid": "b25ea7e13e0f9bab1103c27aafd7ba1538e59c7b"}, "originalPosition": 9}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAyMTY2MTI3OnYy", "diffSide": "RIGHT", "path": "environment/src/main/resources/application.yml", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wM1QyMTo1MToyNlrOHM4qRQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wNFQwNjo1MToxM1rOHNBwxg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzI3MzI4NQ==", "bodyText": "I had a doubt here, will UI start showing GCP credential creation if we enable this here? If so do we need UI change for the entitlement check before making this change?", "url": "https://github.com/hortonworks/cloudbreak/pull/8918#discussion_r483273285", "createdAt": "2020-09-03T21:51:26Z", "author": {"login": "cegganesh84"}, "path": "environment/src/main/resources/application.yml", "diffHunk": "@@ -74,8 +74,8 @@ environment:\n   freeipa:\n     url: http://localhost:8090\n     contextPath: /freeipa\n-    supportedPlatforms: AWS,AZURE\n     synchronizeOnStart: true\n+    supportedPlatforms: AWS,AZURE,GCP", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b25ea7e13e0f9bab1103c27aafd7ba1538e59c7b"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzQyMjQwNg==", "bodyText": "hortonworks/hortonworks-cloud#2347", "url": "https://github.com/hortonworks/cloudbreak/pull/8918#discussion_r483422406", "createdAt": "2020-09-04T06:51:13Z", "author": {"login": "doktoric"}, "path": "environment/src/main/resources/application.yml", "diffHunk": "@@ -74,8 +74,8 @@ environment:\n   freeipa:\n     url: http://localhost:8090\n     contextPath: /freeipa\n-    supportedPlatforms: AWS,AZURE\n     synchronizeOnStart: true\n+    supportedPlatforms: AWS,AZURE,GCP", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzI3MzI4NQ=="}, "originalCommit": {"oid": "b25ea7e13e0f9bab1103c27aafd7ba1538e59c7b"}, "originalPosition": 6}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAyMTY3NDI0OnYy", "diffSide": "LEFT", "path": "freeipa/src/main/resources/freeipa-salt/salt/freeipa/scripts/freeipa_install.sh", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wM1QyMTo1NjozMVrOHM4yAw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wM1QyMjowMToxMFrOHM45Bw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzI3NTI2Nw==", "bodyText": "Adding @jamisonbennett to the loop.\nd45bd41 commit changed the auto forwarders to link-local IP address as a forwarder which fails with the following in GCP ->\n\"ipa-server-install: error: option --forwarder: invalid IP address 169.254.169.254: cannot use link-local IP address 169.254.169.254\"\nMore info https://unix.stackexchange.com/questions/222346/ipa-server-configuration-cannot-use-ip-network-address", "url": "https://github.com/hortonworks/cloudbreak/pull/8918#discussion_r483275267", "createdAt": "2020-09-03T21:56:31Z", "author": {"login": "cegganesh84"}, "path": "freeipa/src/main/resources/freeipa-salt/salt/freeipa/scripts/freeipa_install.sh", "diffHunk": "@@ -26,8 +21,8 @@ ipa-server-install \\\n           --allow-zone-overlap \\\n           --ssh-trust-dns \\\n           --mkhomedir \\\n-          --ip-address \"$IPADDR\" \\\n-          $FORWARDERS \\", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b25ea7e13e0f9bab1103c27aafd7ba1538e59c7b"}, "originalPosition": 17}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzI3NzA2Mw==", "bodyText": "I was relying on one line from the commit message \"Use the same logic for the master too eventhough it didn't matter.\n\"", "url": "https://github.com/hortonworks/cloudbreak/pull/8918#discussion_r483277063", "createdAt": "2020-09-03T22:01:10Z", "author": {"login": "cegganesh84"}, "path": "freeipa/src/main/resources/freeipa-salt/salt/freeipa/scripts/freeipa_install.sh", "diffHunk": "@@ -26,8 +21,8 @@ ipa-server-install \\\n           --allow-zone-overlap \\\n           --ssh-trust-dns \\\n           --mkhomedir \\\n-          --ip-address \"$IPADDR\" \\\n-          $FORWARDERS \\", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzI3NTI2Nw=="}, "originalCommit": {"oid": "b25ea7e13e0f9bab1103c27aafd7ba1538e59c7b"}, "originalPosition": 17}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAyMzc1OTI1OnYy", "diffSide": "RIGHT", "path": "cloud-gcp/src/main/java/com/sequenceiq/cloudbreak/cloud/gcp/GcpNetworkConnector.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wNFQxMjo0NDo1NlrOHNMHPw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wNFQxMjo0NDo1NlrOHNMHPw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzU5MTk5OQ==", "bodyText": "creation -> deletion", "url": "https://github.com/hortonworks/cloudbreak/pull/8918#discussion_r483591999", "createdAt": "2020-09-04T12:44:56Z", "author": {"login": "jamisonbennett"}, "path": "cloud-gcp/src/main/java/com/sequenceiq/cloudbreak/cloud/gcp/GcpNetworkConnector.java", "diffHunk": "@@ -0,0 +1,293 @@\n+package com.sequenceiq.cloudbreak.cloud.gcp;\n+\n+import static com.sequenceiq.cloudbreak.cloud.model.Location.location;\n+import static com.sequenceiq.cloudbreak.cloud.model.Region.region;\n+import static com.sequenceiq.common.api.type.ResourceType.GCP_NETWORK;\n+import static com.sequenceiq.common.api.type.ResourceType.GCP_SUBNET;\n+\n+import java.io.IOException;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import javax.inject.Inject;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.beans.factory.annotation.Value;\n+import org.springframework.stereotype.Component;\n+\n+import com.google.api.client.googleapis.json.GoogleJsonResponseException;\n+import com.google.api.services.compute.Compute;\n+import com.sequenceiq.cloudbreak.cloud.DefaultNetworkConnector;\n+import com.sequenceiq.cloudbreak.cloud.NetworkConnector;\n+import com.sequenceiq.cloudbreak.cloud.context.AuthenticatedContext;\n+import com.sequenceiq.cloudbreak.cloud.context.CloudContext;\n+import com.sequenceiq.cloudbreak.cloud.gcp.context.GcpContext;\n+import com.sequenceiq.cloudbreak.cloud.gcp.context.GcpContextBuilder;\n+import com.sequenceiq.cloudbreak.cloud.gcp.network.GcpNetworkResourceBuilder;\n+import com.sequenceiq.cloudbreak.cloud.gcp.network.GcpSubnetResourceBuilder;\n+import com.sequenceiq.cloudbreak.cloud.gcp.service.GcpSubnetSelectorService;\n+import com.sequenceiq.cloudbreak.cloud.gcp.util.GcpStackUtil;\n+import com.sequenceiq.cloudbreak.cloud.model.CloudCredential;\n+import com.sequenceiq.cloudbreak.cloud.model.CloudResource;\n+import com.sequenceiq.cloudbreak.cloud.model.CloudResourceStatus;\n+import com.sequenceiq.cloudbreak.cloud.model.CloudSubnet;\n+import com.sequenceiq.cloudbreak.cloud.model.Network;\n+import com.sequenceiq.cloudbreak.cloud.model.Platform;\n+import com.sequenceiq.cloudbreak.cloud.model.Subnet;\n+import com.sequenceiq.cloudbreak.cloud.model.SubnetSelectionParameters;\n+import com.sequenceiq.cloudbreak.cloud.model.SubnetSelectionResult;\n+import com.sequenceiq.cloudbreak.cloud.model.Variant;\n+import com.sequenceiq.cloudbreak.cloud.model.network.CreatedCloudNetwork;\n+import com.sequenceiq.cloudbreak.cloud.model.network.CreatedSubnet;\n+import com.sequenceiq.cloudbreak.cloud.model.network.NetworkCreationRequest;\n+import com.sequenceiq.cloudbreak.cloud.model.network.NetworkDeletionRequest;\n+import com.sequenceiq.cloudbreak.cloud.network.NetworkCidr;\n+import com.sequenceiq.cloudbreak.cloud.scheduler.SyncPollingScheduler;\n+import com.sequenceiq.cloudbreak.cloud.task.PollTask;\n+import com.sequenceiq.cloudbreak.cloud.template.task.ResourcePollTaskFactory;\n+import com.sequenceiq.cloudbreak.common.mappable.CloudPlatform;\n+import com.sequenceiq.common.api.type.ResourceType;\n+\n+@Component\n+public class GcpNetworkConnector extends AbstractGcpResourceBuilder implements NetworkConnector, DefaultNetworkConnector {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(GcpNetworkConnector.class);\n+\n+    @Value(\"${cb.gcp.subnet.ha.different.az.min:1}\")\n+    private int minSubnetCountInDifferentAz;\n+\n+    @Value(\"${cb.gcp.subnet.ha.different.az.max:3}\")\n+    private int maxSubnetCountInDifferentAz;\n+\n+    @Inject\n+    private GcpCloudSubnetProvider gcpCloudSubnetProvider;\n+\n+    @Inject\n+    private GcpNetworkResourceBuilder gcpNetworkResourceBuilder;\n+\n+    @Inject\n+    private GcpSubnetResourceBuilder gcpSubnetResourceBuilder;\n+\n+    @Inject\n+    private GcpContextBuilder contextBuilders;\n+\n+    @Inject\n+    private SyncPollingScheduler<List<CloudResourceStatus>> syncPollingScheduler;\n+\n+    @Inject\n+    private ResourcePollTaskFactory statusCheckFactory;\n+\n+    @Inject\n+    private GcpSubnetSelectorService gcpSubnetSelectorService;\n+\n+    @Override\n+    public CreatedCloudNetwork createNetworkWithSubnets(NetworkCreationRequest networkCreationRequest) {\n+        CloudContext cloudContext = getCloudContext(networkCreationRequest);\n+        AuthenticatedContext auth = new AuthenticatedContext(cloudContext, networkCreationRequest.getCloudCredential());\n+        Network network = buildNetworkForCreation(networkCreationRequest);\n+        GcpContext context = contextBuilders.contextInit(cloudContext, auth, network, null, true);\n+\n+        try {\n+            CloudResource networkResource = createNetwork(context, auth, network);\n+            List<CreatedSubnet> subnetList = getCloudSubNets(networkCreationRequest);\n+            for (CreatedSubnet createdSubnet : subnetList) {\n+                createSubnet(context, auth, buildSubnetForCreation(networkCreationRequest, createdSubnet.getCidr()), createdSubnet);\n+            }\n+            return new CreatedCloudNetwork(networkCreationRequest.getEnvName(), networkResource.getName(), getCreatedSubnets(subnetList));\n+        } catch (GoogleJsonResponseException e) {\n+            throw new GcpResourceException(checkException(e), GCP_NETWORK, networkCreationRequest.getEnvName());\n+        } catch (IOException e) {\n+            throw new GcpResourceException(\"Network creation failed due to IO exception\", GCP_NETWORK, networkCreationRequest.getEnvName());\n+        }\n+    }\n+\n+    @Override\n+    public void deleteNetworkWithSubnets(NetworkDeletionRequest networkDeletionRequest) {\n+        CloudContext cloudContext = getCloudContext(networkDeletionRequest);\n+        AuthenticatedContext auth = new AuthenticatedContext(cloudContext, networkDeletionRequest.getCloudCredential());\n+        Network network = buildNetworkForDeletion(networkDeletionRequest);\n+        GcpContext context = contextBuilders.contextInit(cloudContext, auth, network, null, true);\n+\n+        try {\n+            for (String subnetId : networkDeletionRequest.getSubnetIds()) {\n+                deleteSubnet(context, auth, network, subnetId);\n+            }\n+            deleteNetwork(context, auth, network, networkDeletionRequest.getNetworkId());\n+        } catch (GoogleJsonResponseException e) {\n+            exceptionHandler(e, networkDeletionRequest.getStackName(), GCP_NETWORK);\n+        } catch (IOException e) {\n+            throw new GcpResourceException(\"Network deletion failed due to IO exception\", GCP_NETWORK, networkDeletionRequest.getStackName());\n+        }\n+    }\n+\n+    @Override\n+    public NetworkCidr getNetworkCidr(Network network, CloudCredential credential) {\n+        String subnetId = network.getStringParameter(GcpStackUtil.SUBNET_ID);\n+        String region = network.getStringParameter(GcpStackUtil.REGION);\n+        LOGGER.debug(\"Getting network cidrs for subnet {} in region {}\", subnetId, region);\n+        Compute compute = GcpStackUtil.buildCompute(credential);\n+        String projectId = GcpStackUtil.getProjectId(credential);\n+        try {\n+            String ipCidrRange = compute.subnetworks().get(projectId, region, subnetId).execute().getIpCidrRange();\n+            return new NetworkCidr(ipCidrRange, Collections.singletonList(ipCidrRange));\n+        } catch (IOException e) {\n+            throw new GcpResourceException(\"Describe subnets failed due to IO exception\", GCP_NETWORK, subnetId);\n+        }\n+    }\n+\n+    @Override\n+    public SubnetSelectionResult filterSubnets(Collection<CloudSubnet> subnetMetas, SubnetSelectionParameters subnetSelectionParameters) {\n+        return gcpSubnetSelectorService.select(subnetMetas, subnetSelectionParameters);\n+    }\n+\n+    @Override\n+    public int subnetCountInDifferentAzMin() {\n+        return minSubnetCountInDifferentAz;\n+    }\n+\n+    @Override\n+    public int subnetCountInDifferentAzMax() {\n+        return maxSubnetCountInDifferentAz;\n+    }\n+\n+    private CloudContext getCloudContext(NetworkCreationRequest networkRequest) {\n+        return new CloudContext(\n+                networkRequest.getEnvId(),\n+                networkRequest.getEnvName(),\n+                CloudPlatform.GCP.name(),\n+                CloudPlatform.GCP.name(),\n+                location(networkRequest.getRegion()),\n+                networkRequest.getCreatorCrn(),\n+                networkRequest.getAccountId());\n+    }\n+\n+    private CloudContext getCloudContext(NetworkDeletionRequest networkRequest) {\n+        return new CloudContext(\n+                networkRequest.getEnvId(),\n+                networkRequest.getEnvName(),\n+                CloudPlatform.GCP.name(),\n+                CloudPlatform.GCP.name(),\n+                location(region(networkRequest.getRegion())),\n+                networkRequest.getUserId(),\n+                networkRequest.getAccountId());\n+    }\n+\n+    private Network buildNetworkForCreation(NetworkCreationRequest networkRequest) {\n+        Subnet subnet = new Subnet(networkRequest.getNetworkCidr());\n+        Map<String, Object> params = new HashMap<>();\n+        params.put(GcpStackUtil.NETWORK_IP_RANGE, networkRequest.getNetworkCidr());\n+        return new Network(subnet, params);\n+    }\n+\n+    private Network buildNetworkForDeletion(NetworkDeletionRequest networkRequest) {\n+        return new Network(null);\n+    }\n+\n+    private Network buildSubnetForCreation(NetworkCreationRequest networkRequest, String cidr) {\n+        Network network = buildNetworkForCreation(networkRequest);\n+        Subnet subnet = new Subnet(cidr);\n+        network = new Network(subnet, network.getParameters());\n+        return network;\n+    }\n+\n+    private CloudResource createSubnet(GcpContext context, AuthenticatedContext auth, Network network, CreatedSubnet subnet) {\n+        CloudResource cloudResource = gcpSubnetResourceBuilder.create(context, auth, network);\n+        try {\n+            cloudResource = gcpSubnetResourceBuilder.build(context, auth, network, null, cloudResource);\n+            PollTask<List<CloudResourceStatus>> task = statusCheckFactory.newPollResourceTask(gcpSubnetResourceBuilder,\n+                    auth, Collections.singletonList(cloudResource), context, true);\n+            subnet.setSubnetId(cloudResource.getName());\n+            syncPollingScheduler.schedule(task);\n+        } catch (Exception e) {\n+            LOGGER.debug(\"Skipping resource creation: {}\", e.getMessage());\n+        }\n+        return cloudResource;\n+    }\n+\n+    private CloudResource createNetwork(GcpContext context, AuthenticatedContext auth, Network network) {\n+        CloudResource cloudResource = gcpNetworkResourceBuilder.create(context, auth, network);\n+        try {\n+            cloudResource = gcpNetworkResourceBuilder.build(context, auth, network, null, cloudResource);\n+            PollTask<List<CloudResourceStatus>> task = statusCheckFactory.newPollResourceTask(gcpNetworkResourceBuilder,\n+                    auth, Collections.singletonList(cloudResource), context, true);\n+            syncPollingScheduler.schedule(task);\n+        } catch (Exception e) {\n+            LOGGER.debug(\"Skipping resource creation: {}\", e.getMessage());\n+        }\n+        return cloudResource;\n+    }\n+\n+    private void deleteNetwork(GcpContext context, AuthenticatedContext auth, Network network, String networkId) throws IOException {\n+        CloudResource networkResource = createNamedResource(GCP_NETWORK, networkId);\n+        try {\n+            CloudResource deletedResource = gcpNetworkResourceBuilder.delete(context, auth, networkResource, network);\n+            if (deletedResource != null) {\n+                PollTask<List<CloudResourceStatus>> task = statusCheckFactory.newPollResourceTask(\n+                        gcpSubnetResourceBuilder, auth, Collections.singletonList(deletedResource), context, true);\n+                syncPollingScheduler.schedule(task);\n+            }\n+        } catch (Exception e) {\n+            LOGGER.debug(\"Skipping resource creation: {}\", e.getMessage());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7d71a0504ea930a18fdbed61035ac88137d56213"}, "originalPosition": 237}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAyMzc2MjM3OnYy", "diffSide": "RIGHT", "path": "cloud-gcp/src/main/java/com/sequenceiq/cloudbreak/cloud/gcp/GcpNetworkConnector.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wNFQxMjo0NTo1OVrOHNMJEw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wNFQxMjo0NTo1OVrOHNMJEw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzU5MjQ2Nw==", "bodyText": "creation -> deletion", "url": "https://github.com/hortonworks/cloudbreak/pull/8918#discussion_r483592467", "createdAt": "2020-09-04T12:45:59Z", "author": {"login": "jamisonbennett"}, "path": "cloud-gcp/src/main/java/com/sequenceiq/cloudbreak/cloud/gcp/GcpNetworkConnector.java", "diffHunk": "@@ -0,0 +1,293 @@\n+package com.sequenceiq.cloudbreak.cloud.gcp;\n+\n+import static com.sequenceiq.cloudbreak.cloud.model.Location.location;\n+import static com.sequenceiq.cloudbreak.cloud.model.Region.region;\n+import static com.sequenceiq.common.api.type.ResourceType.GCP_NETWORK;\n+import static com.sequenceiq.common.api.type.ResourceType.GCP_SUBNET;\n+\n+import java.io.IOException;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import javax.inject.Inject;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.beans.factory.annotation.Value;\n+import org.springframework.stereotype.Component;\n+\n+import com.google.api.client.googleapis.json.GoogleJsonResponseException;\n+import com.google.api.services.compute.Compute;\n+import com.sequenceiq.cloudbreak.cloud.DefaultNetworkConnector;\n+import com.sequenceiq.cloudbreak.cloud.NetworkConnector;\n+import com.sequenceiq.cloudbreak.cloud.context.AuthenticatedContext;\n+import com.sequenceiq.cloudbreak.cloud.context.CloudContext;\n+import com.sequenceiq.cloudbreak.cloud.gcp.context.GcpContext;\n+import com.sequenceiq.cloudbreak.cloud.gcp.context.GcpContextBuilder;\n+import com.sequenceiq.cloudbreak.cloud.gcp.network.GcpNetworkResourceBuilder;\n+import com.sequenceiq.cloudbreak.cloud.gcp.network.GcpSubnetResourceBuilder;\n+import com.sequenceiq.cloudbreak.cloud.gcp.service.GcpSubnetSelectorService;\n+import com.sequenceiq.cloudbreak.cloud.gcp.util.GcpStackUtil;\n+import com.sequenceiq.cloudbreak.cloud.model.CloudCredential;\n+import com.sequenceiq.cloudbreak.cloud.model.CloudResource;\n+import com.sequenceiq.cloudbreak.cloud.model.CloudResourceStatus;\n+import com.sequenceiq.cloudbreak.cloud.model.CloudSubnet;\n+import com.sequenceiq.cloudbreak.cloud.model.Network;\n+import com.sequenceiq.cloudbreak.cloud.model.Platform;\n+import com.sequenceiq.cloudbreak.cloud.model.Subnet;\n+import com.sequenceiq.cloudbreak.cloud.model.SubnetSelectionParameters;\n+import com.sequenceiq.cloudbreak.cloud.model.SubnetSelectionResult;\n+import com.sequenceiq.cloudbreak.cloud.model.Variant;\n+import com.sequenceiq.cloudbreak.cloud.model.network.CreatedCloudNetwork;\n+import com.sequenceiq.cloudbreak.cloud.model.network.CreatedSubnet;\n+import com.sequenceiq.cloudbreak.cloud.model.network.NetworkCreationRequest;\n+import com.sequenceiq.cloudbreak.cloud.model.network.NetworkDeletionRequest;\n+import com.sequenceiq.cloudbreak.cloud.network.NetworkCidr;\n+import com.sequenceiq.cloudbreak.cloud.scheduler.SyncPollingScheduler;\n+import com.sequenceiq.cloudbreak.cloud.task.PollTask;\n+import com.sequenceiq.cloudbreak.cloud.template.task.ResourcePollTaskFactory;\n+import com.sequenceiq.cloudbreak.common.mappable.CloudPlatform;\n+import com.sequenceiq.common.api.type.ResourceType;\n+\n+@Component\n+public class GcpNetworkConnector extends AbstractGcpResourceBuilder implements NetworkConnector, DefaultNetworkConnector {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(GcpNetworkConnector.class);\n+\n+    @Value(\"${cb.gcp.subnet.ha.different.az.min:1}\")\n+    private int minSubnetCountInDifferentAz;\n+\n+    @Value(\"${cb.gcp.subnet.ha.different.az.max:3}\")\n+    private int maxSubnetCountInDifferentAz;\n+\n+    @Inject\n+    private GcpCloudSubnetProvider gcpCloudSubnetProvider;\n+\n+    @Inject\n+    private GcpNetworkResourceBuilder gcpNetworkResourceBuilder;\n+\n+    @Inject\n+    private GcpSubnetResourceBuilder gcpSubnetResourceBuilder;\n+\n+    @Inject\n+    private GcpContextBuilder contextBuilders;\n+\n+    @Inject\n+    private SyncPollingScheduler<List<CloudResourceStatus>> syncPollingScheduler;\n+\n+    @Inject\n+    private ResourcePollTaskFactory statusCheckFactory;\n+\n+    @Inject\n+    private GcpSubnetSelectorService gcpSubnetSelectorService;\n+\n+    @Override\n+    public CreatedCloudNetwork createNetworkWithSubnets(NetworkCreationRequest networkCreationRequest) {\n+        CloudContext cloudContext = getCloudContext(networkCreationRequest);\n+        AuthenticatedContext auth = new AuthenticatedContext(cloudContext, networkCreationRequest.getCloudCredential());\n+        Network network = buildNetworkForCreation(networkCreationRequest);\n+        GcpContext context = contextBuilders.contextInit(cloudContext, auth, network, null, true);\n+\n+        try {\n+            CloudResource networkResource = createNetwork(context, auth, network);\n+            List<CreatedSubnet> subnetList = getCloudSubNets(networkCreationRequest);\n+            for (CreatedSubnet createdSubnet : subnetList) {\n+                createSubnet(context, auth, buildSubnetForCreation(networkCreationRequest, createdSubnet.getCidr()), createdSubnet);\n+            }\n+            return new CreatedCloudNetwork(networkCreationRequest.getEnvName(), networkResource.getName(), getCreatedSubnets(subnetList));\n+        } catch (GoogleJsonResponseException e) {\n+            throw new GcpResourceException(checkException(e), GCP_NETWORK, networkCreationRequest.getEnvName());\n+        } catch (IOException e) {\n+            throw new GcpResourceException(\"Network creation failed due to IO exception\", GCP_NETWORK, networkCreationRequest.getEnvName());\n+        }\n+    }\n+\n+    @Override\n+    public void deleteNetworkWithSubnets(NetworkDeletionRequest networkDeletionRequest) {\n+        CloudContext cloudContext = getCloudContext(networkDeletionRequest);\n+        AuthenticatedContext auth = new AuthenticatedContext(cloudContext, networkDeletionRequest.getCloudCredential());\n+        Network network = buildNetworkForDeletion(networkDeletionRequest);\n+        GcpContext context = contextBuilders.contextInit(cloudContext, auth, network, null, true);\n+\n+        try {\n+            for (String subnetId : networkDeletionRequest.getSubnetIds()) {\n+                deleteSubnet(context, auth, network, subnetId);\n+            }\n+            deleteNetwork(context, auth, network, networkDeletionRequest.getNetworkId());\n+        } catch (GoogleJsonResponseException e) {\n+            exceptionHandler(e, networkDeletionRequest.getStackName(), GCP_NETWORK);\n+        } catch (IOException e) {\n+            throw new GcpResourceException(\"Network deletion failed due to IO exception\", GCP_NETWORK, networkDeletionRequest.getStackName());\n+        }\n+    }\n+\n+    @Override\n+    public NetworkCidr getNetworkCidr(Network network, CloudCredential credential) {\n+        String subnetId = network.getStringParameter(GcpStackUtil.SUBNET_ID);\n+        String region = network.getStringParameter(GcpStackUtil.REGION);\n+        LOGGER.debug(\"Getting network cidrs for subnet {} in region {}\", subnetId, region);\n+        Compute compute = GcpStackUtil.buildCompute(credential);\n+        String projectId = GcpStackUtil.getProjectId(credential);\n+        try {\n+            String ipCidrRange = compute.subnetworks().get(projectId, region, subnetId).execute().getIpCidrRange();\n+            return new NetworkCidr(ipCidrRange, Collections.singletonList(ipCidrRange));\n+        } catch (IOException e) {\n+            throw new GcpResourceException(\"Describe subnets failed due to IO exception\", GCP_NETWORK, subnetId);\n+        }\n+    }\n+\n+    @Override\n+    public SubnetSelectionResult filterSubnets(Collection<CloudSubnet> subnetMetas, SubnetSelectionParameters subnetSelectionParameters) {\n+        return gcpSubnetSelectorService.select(subnetMetas, subnetSelectionParameters);\n+    }\n+\n+    @Override\n+    public int subnetCountInDifferentAzMin() {\n+        return minSubnetCountInDifferentAz;\n+    }\n+\n+    @Override\n+    public int subnetCountInDifferentAzMax() {\n+        return maxSubnetCountInDifferentAz;\n+    }\n+\n+    private CloudContext getCloudContext(NetworkCreationRequest networkRequest) {\n+        return new CloudContext(\n+                networkRequest.getEnvId(),\n+                networkRequest.getEnvName(),\n+                CloudPlatform.GCP.name(),\n+                CloudPlatform.GCP.name(),\n+                location(networkRequest.getRegion()),\n+                networkRequest.getCreatorCrn(),\n+                networkRequest.getAccountId());\n+    }\n+\n+    private CloudContext getCloudContext(NetworkDeletionRequest networkRequest) {\n+        return new CloudContext(\n+                networkRequest.getEnvId(),\n+                networkRequest.getEnvName(),\n+                CloudPlatform.GCP.name(),\n+                CloudPlatform.GCP.name(),\n+                location(region(networkRequest.getRegion())),\n+                networkRequest.getUserId(),\n+                networkRequest.getAccountId());\n+    }\n+\n+    private Network buildNetworkForCreation(NetworkCreationRequest networkRequest) {\n+        Subnet subnet = new Subnet(networkRequest.getNetworkCidr());\n+        Map<String, Object> params = new HashMap<>();\n+        params.put(GcpStackUtil.NETWORK_IP_RANGE, networkRequest.getNetworkCidr());\n+        return new Network(subnet, params);\n+    }\n+\n+    private Network buildNetworkForDeletion(NetworkDeletionRequest networkRequest) {\n+        return new Network(null);\n+    }\n+\n+    private Network buildSubnetForCreation(NetworkCreationRequest networkRequest, String cidr) {\n+        Network network = buildNetworkForCreation(networkRequest);\n+        Subnet subnet = new Subnet(cidr);\n+        network = new Network(subnet, network.getParameters());\n+        return network;\n+    }\n+\n+    private CloudResource createSubnet(GcpContext context, AuthenticatedContext auth, Network network, CreatedSubnet subnet) {\n+        CloudResource cloudResource = gcpSubnetResourceBuilder.create(context, auth, network);\n+        try {\n+            cloudResource = gcpSubnetResourceBuilder.build(context, auth, network, null, cloudResource);\n+            PollTask<List<CloudResourceStatus>> task = statusCheckFactory.newPollResourceTask(gcpSubnetResourceBuilder,\n+                    auth, Collections.singletonList(cloudResource), context, true);\n+            subnet.setSubnetId(cloudResource.getName());\n+            syncPollingScheduler.schedule(task);\n+        } catch (Exception e) {\n+            LOGGER.debug(\"Skipping resource creation: {}\", e.getMessage());\n+        }\n+        return cloudResource;\n+    }\n+\n+    private CloudResource createNetwork(GcpContext context, AuthenticatedContext auth, Network network) {\n+        CloudResource cloudResource = gcpNetworkResourceBuilder.create(context, auth, network);\n+        try {\n+            cloudResource = gcpNetworkResourceBuilder.build(context, auth, network, null, cloudResource);\n+            PollTask<List<CloudResourceStatus>> task = statusCheckFactory.newPollResourceTask(gcpNetworkResourceBuilder,\n+                    auth, Collections.singletonList(cloudResource), context, true);\n+            syncPollingScheduler.schedule(task);\n+        } catch (Exception e) {\n+            LOGGER.debug(\"Skipping resource creation: {}\", e.getMessage());\n+        }\n+        return cloudResource;\n+    }\n+\n+    private void deleteNetwork(GcpContext context, AuthenticatedContext auth, Network network, String networkId) throws IOException {\n+        CloudResource networkResource = createNamedResource(GCP_NETWORK, networkId);\n+        try {\n+            CloudResource deletedResource = gcpNetworkResourceBuilder.delete(context, auth, networkResource, network);\n+            if (deletedResource != null) {\n+                PollTask<List<CloudResourceStatus>> task = statusCheckFactory.newPollResourceTask(\n+                        gcpSubnetResourceBuilder, auth, Collections.singletonList(deletedResource), context, true);\n+                syncPollingScheduler.schedule(task);\n+            }\n+        } catch (Exception e) {\n+            LOGGER.debug(\"Skipping resource creation: {}\", e.getMessage());\n+        }\n+    }\n+\n+    private void deleteSubnet(GcpContext context, AuthenticatedContext auth, Network network, String subnetId) throws IOException {\n+        CloudResource subnetResource = createNamedResource(GCP_SUBNET, subnetId);\n+        try {\n+            CloudResource deletedResource = gcpSubnetResourceBuilder.delete(context, auth, subnetResource, network);\n+            if (deletedResource != null) {\n+                PollTask<List<CloudResourceStatus>> task = statusCheckFactory.newPollResourceTask(\n+                        gcpSubnetResourceBuilder, auth, Collections.singletonList(deletedResource), context, true);\n+                syncPollingScheduler.schedule(task);\n+            }\n+        } catch (Exception e) {\n+            LOGGER.debug(\"Skipping resource creation: {}\", e.getMessage());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7d71a0504ea930a18fdbed61035ac88137d56213"}, "originalPosition": 251}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAyMzc3MDAyOnYy", "diffSide": "RIGHT", "path": "cloud-gcp/src/main/java/com/sequenceiq/cloudbreak/cloud/gcp/GcpNetworkConnector.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wNFQxMjo0ODoyNlrOHNMNpQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOVQxOTowOTowN1rOHPV5PA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzU5MzYzNw==", "bodyText": "For createSubnet(), createNetwork(), deleteNetwork(), and deleteSubnet() is it really a good idea to ignore exceptions. I would think this would lead to the environment not being setup fully and it would lead to lots of strange behavior later on. And I would think these would be at least a warning level log message.", "url": "https://github.com/hortonworks/cloudbreak/pull/8918#discussion_r483593637", "createdAt": "2020-09-04T12:48:26Z", "author": {"login": "jamisonbennett"}, "path": "cloud-gcp/src/main/java/com/sequenceiq/cloudbreak/cloud/gcp/GcpNetworkConnector.java", "diffHunk": "@@ -0,0 +1,293 @@\n+package com.sequenceiq.cloudbreak.cloud.gcp;\n+\n+import static com.sequenceiq.cloudbreak.cloud.model.Location.location;\n+import static com.sequenceiq.cloudbreak.cloud.model.Region.region;\n+import static com.sequenceiq.common.api.type.ResourceType.GCP_NETWORK;\n+import static com.sequenceiq.common.api.type.ResourceType.GCP_SUBNET;\n+\n+import java.io.IOException;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import javax.inject.Inject;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.beans.factory.annotation.Value;\n+import org.springframework.stereotype.Component;\n+\n+import com.google.api.client.googleapis.json.GoogleJsonResponseException;\n+import com.google.api.services.compute.Compute;\n+import com.sequenceiq.cloudbreak.cloud.DefaultNetworkConnector;\n+import com.sequenceiq.cloudbreak.cloud.NetworkConnector;\n+import com.sequenceiq.cloudbreak.cloud.context.AuthenticatedContext;\n+import com.sequenceiq.cloudbreak.cloud.context.CloudContext;\n+import com.sequenceiq.cloudbreak.cloud.gcp.context.GcpContext;\n+import com.sequenceiq.cloudbreak.cloud.gcp.context.GcpContextBuilder;\n+import com.sequenceiq.cloudbreak.cloud.gcp.network.GcpNetworkResourceBuilder;\n+import com.sequenceiq.cloudbreak.cloud.gcp.network.GcpSubnetResourceBuilder;\n+import com.sequenceiq.cloudbreak.cloud.gcp.service.GcpSubnetSelectorService;\n+import com.sequenceiq.cloudbreak.cloud.gcp.util.GcpStackUtil;\n+import com.sequenceiq.cloudbreak.cloud.model.CloudCredential;\n+import com.sequenceiq.cloudbreak.cloud.model.CloudResource;\n+import com.sequenceiq.cloudbreak.cloud.model.CloudResourceStatus;\n+import com.sequenceiq.cloudbreak.cloud.model.CloudSubnet;\n+import com.sequenceiq.cloudbreak.cloud.model.Network;\n+import com.sequenceiq.cloudbreak.cloud.model.Platform;\n+import com.sequenceiq.cloudbreak.cloud.model.Subnet;\n+import com.sequenceiq.cloudbreak.cloud.model.SubnetSelectionParameters;\n+import com.sequenceiq.cloudbreak.cloud.model.SubnetSelectionResult;\n+import com.sequenceiq.cloudbreak.cloud.model.Variant;\n+import com.sequenceiq.cloudbreak.cloud.model.network.CreatedCloudNetwork;\n+import com.sequenceiq.cloudbreak.cloud.model.network.CreatedSubnet;\n+import com.sequenceiq.cloudbreak.cloud.model.network.NetworkCreationRequest;\n+import com.sequenceiq.cloudbreak.cloud.model.network.NetworkDeletionRequest;\n+import com.sequenceiq.cloudbreak.cloud.network.NetworkCidr;\n+import com.sequenceiq.cloudbreak.cloud.scheduler.SyncPollingScheduler;\n+import com.sequenceiq.cloudbreak.cloud.task.PollTask;\n+import com.sequenceiq.cloudbreak.cloud.template.task.ResourcePollTaskFactory;\n+import com.sequenceiq.cloudbreak.common.mappable.CloudPlatform;\n+import com.sequenceiq.common.api.type.ResourceType;\n+\n+@Component\n+public class GcpNetworkConnector extends AbstractGcpResourceBuilder implements NetworkConnector, DefaultNetworkConnector {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(GcpNetworkConnector.class);\n+\n+    @Value(\"${cb.gcp.subnet.ha.different.az.min:1}\")\n+    private int minSubnetCountInDifferentAz;\n+\n+    @Value(\"${cb.gcp.subnet.ha.different.az.max:3}\")\n+    private int maxSubnetCountInDifferentAz;\n+\n+    @Inject\n+    private GcpCloudSubnetProvider gcpCloudSubnetProvider;\n+\n+    @Inject\n+    private GcpNetworkResourceBuilder gcpNetworkResourceBuilder;\n+\n+    @Inject\n+    private GcpSubnetResourceBuilder gcpSubnetResourceBuilder;\n+\n+    @Inject\n+    private GcpContextBuilder contextBuilders;\n+\n+    @Inject\n+    private SyncPollingScheduler<List<CloudResourceStatus>> syncPollingScheduler;\n+\n+    @Inject\n+    private ResourcePollTaskFactory statusCheckFactory;\n+\n+    @Inject\n+    private GcpSubnetSelectorService gcpSubnetSelectorService;\n+\n+    @Override\n+    public CreatedCloudNetwork createNetworkWithSubnets(NetworkCreationRequest networkCreationRequest) {\n+        CloudContext cloudContext = getCloudContext(networkCreationRequest);\n+        AuthenticatedContext auth = new AuthenticatedContext(cloudContext, networkCreationRequest.getCloudCredential());\n+        Network network = buildNetworkForCreation(networkCreationRequest);\n+        GcpContext context = contextBuilders.contextInit(cloudContext, auth, network, null, true);\n+\n+        try {\n+            CloudResource networkResource = createNetwork(context, auth, network);\n+            List<CreatedSubnet> subnetList = getCloudSubNets(networkCreationRequest);\n+            for (CreatedSubnet createdSubnet : subnetList) {\n+                createSubnet(context, auth, buildSubnetForCreation(networkCreationRequest, createdSubnet.getCidr()), createdSubnet);\n+            }\n+            return new CreatedCloudNetwork(networkCreationRequest.getEnvName(), networkResource.getName(), getCreatedSubnets(subnetList));\n+        } catch (GoogleJsonResponseException e) {\n+            throw new GcpResourceException(checkException(e), GCP_NETWORK, networkCreationRequest.getEnvName());\n+        } catch (IOException e) {\n+            throw new GcpResourceException(\"Network creation failed due to IO exception\", GCP_NETWORK, networkCreationRequest.getEnvName());\n+        }\n+    }\n+\n+    @Override\n+    public void deleteNetworkWithSubnets(NetworkDeletionRequest networkDeletionRequest) {\n+        CloudContext cloudContext = getCloudContext(networkDeletionRequest);\n+        AuthenticatedContext auth = new AuthenticatedContext(cloudContext, networkDeletionRequest.getCloudCredential());\n+        Network network = buildNetworkForDeletion(networkDeletionRequest);\n+        GcpContext context = contextBuilders.contextInit(cloudContext, auth, network, null, true);\n+\n+        try {\n+            for (String subnetId : networkDeletionRequest.getSubnetIds()) {\n+                deleteSubnet(context, auth, network, subnetId);\n+            }\n+            deleteNetwork(context, auth, network, networkDeletionRequest.getNetworkId());\n+        } catch (GoogleJsonResponseException e) {\n+            exceptionHandler(e, networkDeletionRequest.getStackName(), GCP_NETWORK);\n+        } catch (IOException e) {\n+            throw new GcpResourceException(\"Network deletion failed due to IO exception\", GCP_NETWORK, networkDeletionRequest.getStackName());\n+        }\n+    }\n+\n+    @Override\n+    public NetworkCidr getNetworkCidr(Network network, CloudCredential credential) {\n+        String subnetId = network.getStringParameter(GcpStackUtil.SUBNET_ID);\n+        String region = network.getStringParameter(GcpStackUtil.REGION);\n+        LOGGER.debug(\"Getting network cidrs for subnet {} in region {}\", subnetId, region);\n+        Compute compute = GcpStackUtil.buildCompute(credential);\n+        String projectId = GcpStackUtil.getProjectId(credential);\n+        try {\n+            String ipCidrRange = compute.subnetworks().get(projectId, region, subnetId).execute().getIpCidrRange();\n+            return new NetworkCidr(ipCidrRange, Collections.singletonList(ipCidrRange));\n+        } catch (IOException e) {\n+            throw new GcpResourceException(\"Describe subnets failed due to IO exception\", GCP_NETWORK, subnetId);\n+        }\n+    }\n+\n+    @Override\n+    public SubnetSelectionResult filterSubnets(Collection<CloudSubnet> subnetMetas, SubnetSelectionParameters subnetSelectionParameters) {\n+        return gcpSubnetSelectorService.select(subnetMetas, subnetSelectionParameters);\n+    }\n+\n+    @Override\n+    public int subnetCountInDifferentAzMin() {\n+        return minSubnetCountInDifferentAz;\n+    }\n+\n+    @Override\n+    public int subnetCountInDifferentAzMax() {\n+        return maxSubnetCountInDifferentAz;\n+    }\n+\n+    private CloudContext getCloudContext(NetworkCreationRequest networkRequest) {\n+        return new CloudContext(\n+                networkRequest.getEnvId(),\n+                networkRequest.getEnvName(),\n+                CloudPlatform.GCP.name(),\n+                CloudPlatform.GCP.name(),\n+                location(networkRequest.getRegion()),\n+                networkRequest.getCreatorCrn(),\n+                networkRequest.getAccountId());\n+    }\n+\n+    private CloudContext getCloudContext(NetworkDeletionRequest networkRequest) {\n+        return new CloudContext(\n+                networkRequest.getEnvId(),\n+                networkRequest.getEnvName(),\n+                CloudPlatform.GCP.name(),\n+                CloudPlatform.GCP.name(),\n+                location(region(networkRequest.getRegion())),\n+                networkRequest.getUserId(),\n+                networkRequest.getAccountId());\n+    }\n+\n+    private Network buildNetworkForCreation(NetworkCreationRequest networkRequest) {\n+        Subnet subnet = new Subnet(networkRequest.getNetworkCidr());\n+        Map<String, Object> params = new HashMap<>();\n+        params.put(GcpStackUtil.NETWORK_IP_RANGE, networkRequest.getNetworkCidr());\n+        return new Network(subnet, params);\n+    }\n+\n+    private Network buildNetworkForDeletion(NetworkDeletionRequest networkRequest) {\n+        return new Network(null);\n+    }\n+\n+    private Network buildSubnetForCreation(NetworkCreationRequest networkRequest, String cidr) {\n+        Network network = buildNetworkForCreation(networkRequest);\n+        Subnet subnet = new Subnet(cidr);\n+        network = new Network(subnet, network.getParameters());\n+        return network;\n+    }\n+\n+    private CloudResource createSubnet(GcpContext context, AuthenticatedContext auth, Network network, CreatedSubnet subnet) {\n+        CloudResource cloudResource = gcpSubnetResourceBuilder.create(context, auth, network);\n+        try {\n+            cloudResource = gcpSubnetResourceBuilder.build(context, auth, network, null, cloudResource);\n+            PollTask<List<CloudResourceStatus>> task = statusCheckFactory.newPollResourceTask(gcpSubnetResourceBuilder,\n+                    auth, Collections.singletonList(cloudResource), context, true);\n+            subnet.setSubnetId(cloudResource.getName());\n+            syncPollingScheduler.schedule(task);\n+        } catch (Exception e) {\n+            LOGGER.debug(\"Skipping resource creation: {}\", e.getMessage());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7d71a0504ea930a18fdbed61035ac88137d56213"}, "originalPosition": 209}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTg0OTQwNA==", "bodyText": "this part will be disabled as a first drop", "url": "https://github.com/hortonworks/cloudbreak/pull/8918#discussion_r485849404", "createdAt": "2020-09-09T19:09:07Z", "author": {"login": "doktoric"}, "path": "cloud-gcp/src/main/java/com/sequenceiq/cloudbreak/cloud/gcp/GcpNetworkConnector.java", "diffHunk": "@@ -0,0 +1,293 @@\n+package com.sequenceiq.cloudbreak.cloud.gcp;\n+\n+import static com.sequenceiq.cloudbreak.cloud.model.Location.location;\n+import static com.sequenceiq.cloudbreak.cloud.model.Region.region;\n+import static com.sequenceiq.common.api.type.ResourceType.GCP_NETWORK;\n+import static com.sequenceiq.common.api.type.ResourceType.GCP_SUBNET;\n+\n+import java.io.IOException;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import javax.inject.Inject;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.beans.factory.annotation.Value;\n+import org.springframework.stereotype.Component;\n+\n+import com.google.api.client.googleapis.json.GoogleJsonResponseException;\n+import com.google.api.services.compute.Compute;\n+import com.sequenceiq.cloudbreak.cloud.DefaultNetworkConnector;\n+import com.sequenceiq.cloudbreak.cloud.NetworkConnector;\n+import com.sequenceiq.cloudbreak.cloud.context.AuthenticatedContext;\n+import com.sequenceiq.cloudbreak.cloud.context.CloudContext;\n+import com.sequenceiq.cloudbreak.cloud.gcp.context.GcpContext;\n+import com.sequenceiq.cloudbreak.cloud.gcp.context.GcpContextBuilder;\n+import com.sequenceiq.cloudbreak.cloud.gcp.network.GcpNetworkResourceBuilder;\n+import com.sequenceiq.cloudbreak.cloud.gcp.network.GcpSubnetResourceBuilder;\n+import com.sequenceiq.cloudbreak.cloud.gcp.service.GcpSubnetSelectorService;\n+import com.sequenceiq.cloudbreak.cloud.gcp.util.GcpStackUtil;\n+import com.sequenceiq.cloudbreak.cloud.model.CloudCredential;\n+import com.sequenceiq.cloudbreak.cloud.model.CloudResource;\n+import com.sequenceiq.cloudbreak.cloud.model.CloudResourceStatus;\n+import com.sequenceiq.cloudbreak.cloud.model.CloudSubnet;\n+import com.sequenceiq.cloudbreak.cloud.model.Network;\n+import com.sequenceiq.cloudbreak.cloud.model.Platform;\n+import com.sequenceiq.cloudbreak.cloud.model.Subnet;\n+import com.sequenceiq.cloudbreak.cloud.model.SubnetSelectionParameters;\n+import com.sequenceiq.cloudbreak.cloud.model.SubnetSelectionResult;\n+import com.sequenceiq.cloudbreak.cloud.model.Variant;\n+import com.sequenceiq.cloudbreak.cloud.model.network.CreatedCloudNetwork;\n+import com.sequenceiq.cloudbreak.cloud.model.network.CreatedSubnet;\n+import com.sequenceiq.cloudbreak.cloud.model.network.NetworkCreationRequest;\n+import com.sequenceiq.cloudbreak.cloud.model.network.NetworkDeletionRequest;\n+import com.sequenceiq.cloudbreak.cloud.network.NetworkCidr;\n+import com.sequenceiq.cloudbreak.cloud.scheduler.SyncPollingScheduler;\n+import com.sequenceiq.cloudbreak.cloud.task.PollTask;\n+import com.sequenceiq.cloudbreak.cloud.template.task.ResourcePollTaskFactory;\n+import com.sequenceiq.cloudbreak.common.mappable.CloudPlatform;\n+import com.sequenceiq.common.api.type.ResourceType;\n+\n+@Component\n+public class GcpNetworkConnector extends AbstractGcpResourceBuilder implements NetworkConnector, DefaultNetworkConnector {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(GcpNetworkConnector.class);\n+\n+    @Value(\"${cb.gcp.subnet.ha.different.az.min:1}\")\n+    private int minSubnetCountInDifferentAz;\n+\n+    @Value(\"${cb.gcp.subnet.ha.different.az.max:3}\")\n+    private int maxSubnetCountInDifferentAz;\n+\n+    @Inject\n+    private GcpCloudSubnetProvider gcpCloudSubnetProvider;\n+\n+    @Inject\n+    private GcpNetworkResourceBuilder gcpNetworkResourceBuilder;\n+\n+    @Inject\n+    private GcpSubnetResourceBuilder gcpSubnetResourceBuilder;\n+\n+    @Inject\n+    private GcpContextBuilder contextBuilders;\n+\n+    @Inject\n+    private SyncPollingScheduler<List<CloudResourceStatus>> syncPollingScheduler;\n+\n+    @Inject\n+    private ResourcePollTaskFactory statusCheckFactory;\n+\n+    @Inject\n+    private GcpSubnetSelectorService gcpSubnetSelectorService;\n+\n+    @Override\n+    public CreatedCloudNetwork createNetworkWithSubnets(NetworkCreationRequest networkCreationRequest) {\n+        CloudContext cloudContext = getCloudContext(networkCreationRequest);\n+        AuthenticatedContext auth = new AuthenticatedContext(cloudContext, networkCreationRequest.getCloudCredential());\n+        Network network = buildNetworkForCreation(networkCreationRequest);\n+        GcpContext context = contextBuilders.contextInit(cloudContext, auth, network, null, true);\n+\n+        try {\n+            CloudResource networkResource = createNetwork(context, auth, network);\n+            List<CreatedSubnet> subnetList = getCloudSubNets(networkCreationRequest);\n+            for (CreatedSubnet createdSubnet : subnetList) {\n+                createSubnet(context, auth, buildSubnetForCreation(networkCreationRequest, createdSubnet.getCidr()), createdSubnet);\n+            }\n+            return new CreatedCloudNetwork(networkCreationRequest.getEnvName(), networkResource.getName(), getCreatedSubnets(subnetList));\n+        } catch (GoogleJsonResponseException e) {\n+            throw new GcpResourceException(checkException(e), GCP_NETWORK, networkCreationRequest.getEnvName());\n+        } catch (IOException e) {\n+            throw new GcpResourceException(\"Network creation failed due to IO exception\", GCP_NETWORK, networkCreationRequest.getEnvName());\n+        }\n+    }\n+\n+    @Override\n+    public void deleteNetworkWithSubnets(NetworkDeletionRequest networkDeletionRequest) {\n+        CloudContext cloudContext = getCloudContext(networkDeletionRequest);\n+        AuthenticatedContext auth = new AuthenticatedContext(cloudContext, networkDeletionRequest.getCloudCredential());\n+        Network network = buildNetworkForDeletion(networkDeletionRequest);\n+        GcpContext context = contextBuilders.contextInit(cloudContext, auth, network, null, true);\n+\n+        try {\n+            for (String subnetId : networkDeletionRequest.getSubnetIds()) {\n+                deleteSubnet(context, auth, network, subnetId);\n+            }\n+            deleteNetwork(context, auth, network, networkDeletionRequest.getNetworkId());\n+        } catch (GoogleJsonResponseException e) {\n+            exceptionHandler(e, networkDeletionRequest.getStackName(), GCP_NETWORK);\n+        } catch (IOException e) {\n+            throw new GcpResourceException(\"Network deletion failed due to IO exception\", GCP_NETWORK, networkDeletionRequest.getStackName());\n+        }\n+    }\n+\n+    @Override\n+    public NetworkCidr getNetworkCidr(Network network, CloudCredential credential) {\n+        String subnetId = network.getStringParameter(GcpStackUtil.SUBNET_ID);\n+        String region = network.getStringParameter(GcpStackUtil.REGION);\n+        LOGGER.debug(\"Getting network cidrs for subnet {} in region {}\", subnetId, region);\n+        Compute compute = GcpStackUtil.buildCompute(credential);\n+        String projectId = GcpStackUtil.getProjectId(credential);\n+        try {\n+            String ipCidrRange = compute.subnetworks().get(projectId, region, subnetId).execute().getIpCidrRange();\n+            return new NetworkCidr(ipCidrRange, Collections.singletonList(ipCidrRange));\n+        } catch (IOException e) {\n+            throw new GcpResourceException(\"Describe subnets failed due to IO exception\", GCP_NETWORK, subnetId);\n+        }\n+    }\n+\n+    @Override\n+    public SubnetSelectionResult filterSubnets(Collection<CloudSubnet> subnetMetas, SubnetSelectionParameters subnetSelectionParameters) {\n+        return gcpSubnetSelectorService.select(subnetMetas, subnetSelectionParameters);\n+    }\n+\n+    @Override\n+    public int subnetCountInDifferentAzMin() {\n+        return minSubnetCountInDifferentAz;\n+    }\n+\n+    @Override\n+    public int subnetCountInDifferentAzMax() {\n+        return maxSubnetCountInDifferentAz;\n+    }\n+\n+    private CloudContext getCloudContext(NetworkCreationRequest networkRequest) {\n+        return new CloudContext(\n+                networkRequest.getEnvId(),\n+                networkRequest.getEnvName(),\n+                CloudPlatform.GCP.name(),\n+                CloudPlatform.GCP.name(),\n+                location(networkRequest.getRegion()),\n+                networkRequest.getCreatorCrn(),\n+                networkRequest.getAccountId());\n+    }\n+\n+    private CloudContext getCloudContext(NetworkDeletionRequest networkRequest) {\n+        return new CloudContext(\n+                networkRequest.getEnvId(),\n+                networkRequest.getEnvName(),\n+                CloudPlatform.GCP.name(),\n+                CloudPlatform.GCP.name(),\n+                location(region(networkRequest.getRegion())),\n+                networkRequest.getUserId(),\n+                networkRequest.getAccountId());\n+    }\n+\n+    private Network buildNetworkForCreation(NetworkCreationRequest networkRequest) {\n+        Subnet subnet = new Subnet(networkRequest.getNetworkCidr());\n+        Map<String, Object> params = new HashMap<>();\n+        params.put(GcpStackUtil.NETWORK_IP_RANGE, networkRequest.getNetworkCidr());\n+        return new Network(subnet, params);\n+    }\n+\n+    private Network buildNetworkForDeletion(NetworkDeletionRequest networkRequest) {\n+        return new Network(null);\n+    }\n+\n+    private Network buildSubnetForCreation(NetworkCreationRequest networkRequest, String cidr) {\n+        Network network = buildNetworkForCreation(networkRequest);\n+        Subnet subnet = new Subnet(cidr);\n+        network = new Network(subnet, network.getParameters());\n+        return network;\n+    }\n+\n+    private CloudResource createSubnet(GcpContext context, AuthenticatedContext auth, Network network, CreatedSubnet subnet) {\n+        CloudResource cloudResource = gcpSubnetResourceBuilder.create(context, auth, network);\n+        try {\n+            cloudResource = gcpSubnetResourceBuilder.build(context, auth, network, null, cloudResource);\n+            PollTask<List<CloudResourceStatus>> task = statusCheckFactory.newPollResourceTask(gcpSubnetResourceBuilder,\n+                    auth, Collections.singletonList(cloudResource), context, true);\n+            subnet.setSubnetId(cloudResource.getName());\n+            syncPollingScheduler.schedule(task);\n+        } catch (Exception e) {\n+            LOGGER.debug(\"Skipping resource creation: {}\", e.getMessage());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzU5MzYzNw=="}, "originalCommit": {"oid": "7d71a0504ea930a18fdbed61035ac88137d56213"}, "originalPosition": 209}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAyMzc3NTA1OnYy", "diffSide": "RIGHT", "path": "cloud-gcp/src/main/java/com/sequenceiq/cloudbreak/cloud/gcp/GcpObjectStorageConnector.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wNFQxMjo1MDowMlrOHNMQrg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wNFQxNzoyMTo1NFrOHNWN9Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzU5NDQxNA==", "bodyText": "Can a JIRA be targetted for this and write TODO(CB-XXXX)? That way this isn't forgotten.", "url": "https://github.com/hortonworks/cloudbreak/pull/8918#discussion_r483594414", "createdAt": "2020-09-04T12:50:02Z", "author": {"login": "jamisonbennett"}, "path": "cloud-gcp/src/main/java/com/sequenceiq/cloudbreak/cloud/gcp/GcpObjectStorageConnector.java", "diffHunk": "@@ -0,0 +1,65 @@\n+package com.sequenceiq.cloudbreak.cloud.gcp;\n+\n+import com.google.api.services.storage.Storage;\n+import com.google.api.services.storage.model.StorageObject;\n+import com.sequenceiq.cloudbreak.cloud.ObjectStorageConnector;\n+import com.sequenceiq.cloudbreak.cloud.gcp.util.GcpStackUtil;\n+import com.sequenceiq.cloudbreak.cloud.model.Platform;\n+import com.sequenceiq.cloudbreak.cloud.model.Variant;\n+import com.sequenceiq.cloudbreak.cloud.model.base.ResponseStatus;\n+import com.sequenceiq.cloudbreak.cloud.model.objectstorage.ObjectStorageMetadataRequest;\n+import com.sequenceiq.cloudbreak.cloud.model.objectstorage.ObjectStorageMetadataResponse;\n+import com.sequenceiq.cloudbreak.cloud.model.objectstorage.ObjectStorageValidateRequest;\n+import com.sequenceiq.cloudbreak.cloud.model.objectstorage.ObjectStorageValidateResponse;\n+import com.sequenceiq.common.api.cloudstorage.StorageLocationBase;\n+import org.springframework.stereotype.Service;\n+\n+@Service\n+public class GcpObjectStorageConnector implements ObjectStorageConnector {\n+\n+    @Override\n+    public ObjectStorageMetadataResponse getObjectStorageMetadata(ObjectStorageMetadataRequest request) {\n+        Storage storage = GcpStackUtil.buildStorage(request.getCredential(), request.getCredential().getName());\n+        try {\n+            StorageObject storageObject = storage.objects().get(GcpStackUtil.getBucketName(request.getObjectStoragePath()),\n+                    GcpStackUtil.getPath(request.getObjectStoragePath())).execute();\n+            return ObjectStorageMetadataResponse.builder()\n+                    .withStatus(ResponseStatus.OK)\n+                    .build();\n+        } catch (Exception e) {\n+            return ObjectStorageMetadataResponse.builder()\n+                    .withStatus(ResponseStatus.RESOURCE_NOT_FOUND)\n+                    .build();\n+        }\n+    }\n+\n+    @Override\n+    public ObjectStorageValidateResponse validateObjectStorage(ObjectStorageValidateRequest request) {\n+        // TODO: The following check is naive, beefup", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7d71a0504ea930a18fdbed61035ac88137d56213"}, "originalPosition": 38}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mzc1NzU1Nw==", "bodyText": "Thanks https://jira.cloudera.com/browse/CB-8678", "url": "https://github.com/hortonworks/cloudbreak/pull/8918#discussion_r483757557", "createdAt": "2020-09-04T17:21:54Z", "author": {"login": "cegganesh84"}, "path": "cloud-gcp/src/main/java/com/sequenceiq/cloudbreak/cloud/gcp/GcpObjectStorageConnector.java", "diffHunk": "@@ -0,0 +1,65 @@\n+package com.sequenceiq.cloudbreak.cloud.gcp;\n+\n+import com.google.api.services.storage.Storage;\n+import com.google.api.services.storage.model.StorageObject;\n+import com.sequenceiq.cloudbreak.cloud.ObjectStorageConnector;\n+import com.sequenceiq.cloudbreak.cloud.gcp.util.GcpStackUtil;\n+import com.sequenceiq.cloudbreak.cloud.model.Platform;\n+import com.sequenceiq.cloudbreak.cloud.model.Variant;\n+import com.sequenceiq.cloudbreak.cloud.model.base.ResponseStatus;\n+import com.sequenceiq.cloudbreak.cloud.model.objectstorage.ObjectStorageMetadataRequest;\n+import com.sequenceiq.cloudbreak.cloud.model.objectstorage.ObjectStorageMetadataResponse;\n+import com.sequenceiq.cloudbreak.cloud.model.objectstorage.ObjectStorageValidateRequest;\n+import com.sequenceiq.cloudbreak.cloud.model.objectstorage.ObjectStorageValidateResponse;\n+import com.sequenceiq.common.api.cloudstorage.StorageLocationBase;\n+import org.springframework.stereotype.Service;\n+\n+@Service\n+public class GcpObjectStorageConnector implements ObjectStorageConnector {\n+\n+    @Override\n+    public ObjectStorageMetadataResponse getObjectStorageMetadata(ObjectStorageMetadataRequest request) {\n+        Storage storage = GcpStackUtil.buildStorage(request.getCredential(), request.getCredential().getName());\n+        try {\n+            StorageObject storageObject = storage.objects().get(GcpStackUtil.getBucketName(request.getObjectStoragePath()),\n+                    GcpStackUtil.getPath(request.getObjectStoragePath())).execute();\n+            return ObjectStorageMetadataResponse.builder()\n+                    .withStatus(ResponseStatus.OK)\n+                    .build();\n+        } catch (Exception e) {\n+            return ObjectStorageMetadataResponse.builder()\n+                    .withStatus(ResponseStatus.RESOURCE_NOT_FOUND)\n+                    .build();\n+        }\n+    }\n+\n+    @Override\n+    public ObjectStorageValidateResponse validateObjectStorage(ObjectStorageValidateRequest request) {\n+        // TODO: The following check is naive, beefup", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzU5NDQxNA=="}, "originalCommit": {"oid": "7d71a0504ea930a18fdbed61035ac88137d56213"}, "originalPosition": 38}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAyMzc4NjU5OnYy", "diffSide": "RIGHT", "path": "cloud-gcp/src/main/java/com/sequenceiq/cloudbreak/cloud/gcp/GcpPlatformResources.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wNFQxMjo1MzozMlrOHNMXig==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wNFQxMjo1MzozMlrOHNMXig==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzU5NjE3MA==", "bodyText": "String zone = compute.regions().get(projectId, region.value()).execute().getZones().stream()\n.findFirst()\n.map(zone -> zone.substring(zone.lastIndexOf('/') + 1))\n.orElse(null);", "url": "https://github.com/hortonworks/cloudbreak/pull/8918#discussion_r483596170", "createdAt": "2020-09-04T12:53:32Z", "author": {"login": "jamisonbennett"}, "path": "cloud-gcp/src/main/java/com/sequenceiq/cloudbreak/cloud/gcp/GcpPlatformResources.java", "diffHunk": "@@ -126,9 +128,27 @@ public CloudNetworks networks(CloudCredential cloudCredential, Region region, Ma\n         String projectId = GcpStackUtil.getProjectId(cloudCredential);\n         Map<String, Set<CloudNetwork>> result = new HashMap<>();\n \n+        String networkId = null;\n+        String subnetId = null;\n+        if (filters != null) {\n+            networkId = filters.getOrDefault(\"networkId\", null);\n+            subnetId = filters.getOrDefault(\"subnetId\", null);\n+        }\n+\n+        LOGGER.debug(\"Get subnets with filter values, networkId : {}, subnetId : {}\", networkId, subnetId);\n         Set<CloudNetwork> cloudNetworks = new HashSet<>();\n-        NetworkList networkList = compute.networks().list(projectId).execute();\n-        List<Subnetwork> subnetworkList = compute.subnetworks().list(projectId, region.value()).execute().getItems();\n+        NetworkList networkList = StringUtils.isEmpty(networkId) ?\n+                compute.networks().list(projectId).execute() :\n+                new NetworkList().setItems(Collections.singletonList(compute.networks().get(projectId, networkId).execute()));\n+        SubnetworkList subnetworkList = StringUtils.isEmpty(subnetId) ?\n+                compute.subnetworks().list(projectId, region.value()).execute() :\n+                new SubnetworkList().setItems(Collections.singletonList(compute.subnetworks().get(projectId, region.value(), subnetId).execute()));\n+        // GCP VPCs are global. Subnets have a global scope in region. So picking the first availability zone in the region for subnet.\n+        String zone = compute.regions().get(projectId, region.value()).execute().getZones().stream().findFirst().orElse(null);\n+        if (zone != null) {\n+            zone = zone.substring(zone.lastIndexOf('/') + 1);\n+        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7d71a0504ea930a18fdbed61035ac88137d56213"}, "originalPosition": 41}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAyMzgwMTY0OnYy", "diffSide": "RIGHT", "path": "cloud-gcp/src/main/java/com/sequenceiq/cloudbreak/cloud/gcp/service/GcpSubnetSelectorService.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wNFQxMjo1Nzo0N1rOHNMgig==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMFQxNToyMzoxN1rOHP5aBQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzU5ODQ3NA==", "bodyText": "Since this is not sorted, it may produce different results every time its run.", "url": "https://github.com/hortonworks/cloudbreak/pull/8918#discussion_r483598474", "createdAt": "2020-09-04T12:57:47Z", "author": {"login": "jamisonbennett"}, "path": "cloud-gcp/src/main/java/com/sequenceiq/cloudbreak/cloud/gcp/service/GcpSubnetSelectorService.java", "diffHunk": "@@ -0,0 +1,41 @@\n+package com.sequenceiq.cloudbreak.cloud.gcp.service;\n+\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Optional;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.stereotype.Service;\n+\n+import com.sequenceiq.cloudbreak.cloud.model.CloudSubnet;\n+import com.sequenceiq.cloudbreak.cloud.model.SubnetSelectionParameters;\n+import com.sequenceiq.cloudbreak.cloud.model.SubnetSelectionResult;\n+\n+@Service\n+public class GcpSubnetSelectorService {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(GcpSubnetSelectorService.class);\n+\n+    public SubnetSelectionResult select(Collection<CloudSubnet> subnetMetas, SubnetSelectionParameters subnetSelectionParameters) {\n+        Optional<String> errorMessage = quickValidate(subnetMetas, subnetSelectionParameters);\n+        if (errorMessage.isPresent()) {\n+            LOGGER.debug(\"{}\", errorMessage.get());\n+            return new SubnetSelectionResult(errorMessage.get());\n+        }\n+        // GCP VPCs are global and different subnets can be in different geographies. So for safety just choosing the first subnet.\n+        CloudSubnet first = subnetMetas.stream().findFirst().get();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7d71a0504ea930a18fdbed61035ac88137d56213"}, "originalPosition": 27}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjQzMTIzNw==", "bodyText": "yep and it is not a problem.", "url": "https://github.com/hortonworks/cloudbreak/pull/8918#discussion_r486431237", "createdAt": "2020-09-10T15:23:17Z", "author": {"login": "doktoric"}, "path": "cloud-gcp/src/main/java/com/sequenceiq/cloudbreak/cloud/gcp/service/GcpSubnetSelectorService.java", "diffHunk": "@@ -0,0 +1,41 @@\n+package com.sequenceiq.cloudbreak.cloud.gcp.service;\n+\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Optional;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.stereotype.Service;\n+\n+import com.sequenceiq.cloudbreak.cloud.model.CloudSubnet;\n+import com.sequenceiq.cloudbreak.cloud.model.SubnetSelectionParameters;\n+import com.sequenceiq.cloudbreak.cloud.model.SubnetSelectionResult;\n+\n+@Service\n+public class GcpSubnetSelectorService {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(GcpSubnetSelectorService.class);\n+\n+    public SubnetSelectionResult select(Collection<CloudSubnet> subnetMetas, SubnetSelectionParameters subnetSelectionParameters) {\n+        Optional<String> errorMessage = quickValidate(subnetMetas, subnetSelectionParameters);\n+        if (errorMessage.isPresent()) {\n+            LOGGER.debug(\"{}\", errorMessage.get());\n+            return new SubnetSelectionResult(errorMessage.get());\n+        }\n+        // GCP VPCs are global and different subnets can be in different geographies. So for safety just choosing the first subnet.\n+        CloudSubnet first = subnetMetas.stream().findFirst().get();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzU5ODQ3NA=="}, "originalCommit": {"oid": "7d71a0504ea930a18fdbed61035ac88137d56213"}, "originalPosition": 27}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAyMzg3ODA0OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/com/sequenceiq/cloudbreak/service/template/ClusterTemplateCloudPlatformValidator.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wNFQxMzoxOTo1OFrOHNNPcw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wNFQxMzoxOTo1OFrOHNNPcw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzYxMDQ4Mw==", "bodyText": "I would prefer if this was named isCloudEntitlementEnabeldForTheAccount().", "url": "https://github.com/hortonworks/cloudbreak/pull/8918#discussion_r483610483", "createdAt": "2020-09-04T13:19:58Z", "author": {"login": "jamisonbennett"}, "path": "core/src/main/java/com/sequenceiq/cloudbreak/service/template/ClusterTemplateCloudPlatformValidator.java", "diffHunk": "@@ -24,8 +25,21 @@ public ClusterTemplateCloudPlatformValidator(@Value(\"${cb.enabledplatforms:}\") S\n     }\n \n     public boolean isClusterTemplateCloudPlatformValid(String cloudPlatform, String accountId) {\n-        return (enabledPlatforms.contains(cloudPlatform) || CollectionUtils.isEmpty(enabledPlatforms))\n-                && (!AZURE.name().equalsIgnoreCase(cloudPlatform) || entitlementService.azureEnabled(INTERNAL_ACTOR_CRN, accountId));\n+        return isPlatformEnabled(cloudPlatform)\n+                && (notACloudPlatformWhichIsEntitlementSpecific(cloudPlatform) || isAzureOrGCPEntitlementEnabledForTheAccount(cloudPlatform, accountId));\n+    }\n+\n+    public boolean isPlatformEnabled(String cloudPlatform) {\n+        return enabledPlatforms.contains(cloudPlatform) || CollectionUtils.isEmpty(enabledPlatforms);\n+    }\n+\n+    private boolean notACloudPlatformWhichIsEntitlementSpecific(String cloudPlatform) {\n+        return !AZURE.name().equalsIgnoreCase(cloudPlatform) && !GCP.name().equalsIgnoreCase(cloudPlatform);\n+    }\n+\n+    private boolean isAzureOrGCPEntitlementEnabledForTheAccount(String cloudPlatform, String accountId) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7d71a0504ea930a18fdbed61035ac88137d56213"}, "originalPosition": 26}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAyMzg5NjMxOnYy", "diffSide": "RIGHT", "path": "core/src/main/java/com/sequenceiq/cloudbreak/service/template/ClusterTemplateCloudPlatformValidator.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wNFQxMzoyNDo0M1rOHNNaQQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNVQxOToxMDoyN1rOHSQWsg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzYxMzI0OQ==", "bodyText": "nit: I find the naming with a \"not\" a little confusing.", "url": "https://github.com/hortonworks/cloudbreak/pull/8918#discussion_r483613249", "createdAt": "2020-09-04T13:24:43Z", "author": {"login": "jamisonbennett"}, "path": "core/src/main/java/com/sequenceiq/cloudbreak/service/template/ClusterTemplateCloudPlatformValidator.java", "diffHunk": "@@ -24,8 +25,21 @@ public ClusterTemplateCloudPlatformValidator(@Value(\"${cb.enabledplatforms:}\") S\n     }\n \n     public boolean isClusterTemplateCloudPlatformValid(String cloudPlatform, String accountId) {\n-        return (enabledPlatforms.contains(cloudPlatform) || CollectionUtils.isEmpty(enabledPlatforms))\n-                && (!AZURE.name().equalsIgnoreCase(cloudPlatform) || entitlementService.azureEnabled(INTERNAL_ACTOR_CRN, accountId));\n+        return isPlatformEnabled(cloudPlatform)\n+                && (notACloudPlatformWhichIsEntitlementSpecific(cloudPlatform) || isAzureOrGCPEntitlementEnabledForTheAccount(cloudPlatform, accountId));\n+    }\n+\n+    public boolean isPlatformEnabled(String cloudPlatform) {\n+        return enabledPlatforms.contains(cloudPlatform) || CollectionUtils.isEmpty(enabledPlatforms);\n+    }\n+\n+    private boolean notACloudPlatformWhichIsEntitlementSpecific(String cloudPlatform) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7d71a0504ea930a18fdbed61035ac88137d56213"}, "originalPosition": 22}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjQzMTQ4MA==", "bodyText": "what do you suggest here ?", "url": "https://github.com/hortonworks/cloudbreak/pull/8918#discussion_r486431480", "createdAt": "2020-09-10T15:23:36Z", "author": {"login": "doktoric"}, "path": "core/src/main/java/com/sequenceiq/cloudbreak/service/template/ClusterTemplateCloudPlatformValidator.java", "diffHunk": "@@ -24,8 +25,21 @@ public ClusterTemplateCloudPlatformValidator(@Value(\"${cb.enabledplatforms:}\") S\n     }\n \n     public boolean isClusterTemplateCloudPlatformValid(String cloudPlatform, String accountId) {\n-        return (enabledPlatforms.contains(cloudPlatform) || CollectionUtils.isEmpty(enabledPlatforms))\n-                && (!AZURE.name().equalsIgnoreCase(cloudPlatform) || entitlementService.azureEnabled(INTERNAL_ACTOR_CRN, accountId));\n+        return isPlatformEnabled(cloudPlatform)\n+                && (notACloudPlatformWhichIsEntitlementSpecific(cloudPlatform) || isAzureOrGCPEntitlementEnabledForTheAccount(cloudPlatform, accountId));\n+    }\n+\n+    public boolean isPlatformEnabled(String cloudPlatform) {\n+        return enabledPlatforms.contains(cloudPlatform) || CollectionUtils.isEmpty(enabledPlatforms);\n+    }\n+\n+    private boolean notACloudPlatformWhichIsEntitlementSpecific(String cloudPlatform) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzYxMzI0OQ=="}, "originalCommit": {"oid": "7d71a0504ea930a18fdbed61035ac88137d56213"}, "originalPosition": 22}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODkwNDM3MA==", "bodyText": "nit: I would probably word it isCloudEntitlementRequiredPlatform() and then change the above logic to isCloudEntitlementRequiredPlatform(cloudPlatform) && isCloudEntitlementEnabeledForTheAccount(cloudPlatform, accountId)", "url": "https://github.com/hortonworks/cloudbreak/pull/8918#discussion_r488904370", "createdAt": "2020-09-15T19:10:27Z", "author": {"login": "jamisonbennett"}, "path": "core/src/main/java/com/sequenceiq/cloudbreak/service/template/ClusterTemplateCloudPlatformValidator.java", "diffHunk": "@@ -24,8 +25,21 @@ public ClusterTemplateCloudPlatformValidator(@Value(\"${cb.enabledplatforms:}\") S\n     }\n \n     public boolean isClusterTemplateCloudPlatformValid(String cloudPlatform, String accountId) {\n-        return (enabledPlatforms.contains(cloudPlatform) || CollectionUtils.isEmpty(enabledPlatforms))\n-                && (!AZURE.name().equalsIgnoreCase(cloudPlatform) || entitlementService.azureEnabled(INTERNAL_ACTOR_CRN, accountId));\n+        return isPlatformEnabled(cloudPlatform)\n+                && (notACloudPlatformWhichIsEntitlementSpecific(cloudPlatform) || isAzureOrGCPEntitlementEnabledForTheAccount(cloudPlatform, accountId));\n+    }\n+\n+    public boolean isPlatformEnabled(String cloudPlatform) {\n+        return enabledPlatforms.contains(cloudPlatform) || CollectionUtils.isEmpty(enabledPlatforms);\n+    }\n+\n+    private boolean notACloudPlatformWhichIsEntitlementSpecific(String cloudPlatform) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzYxMzI0OQ=="}, "originalCommit": {"oid": "7d71a0504ea930a18fdbed61035ac88137d56213"}, "originalPosition": 22}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAyMzkyODI1OnYy", "diffSide": "RIGHT", "path": "cloud-gcp/src/main/java/com/sequenceiq/cloudbreak/cloud/gcp/util/GcpStackUtil.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wNFQxMzozMzoxNFrOHNNtLQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wNFQxMzozMzoxNFrOHNNtLQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzYxODA5Mw==", "bodyText": "nit: how about using a named constant for the bucket index and avoiding the magic number?", "url": "https://github.com/hortonworks/cloudbreak/pull/8918#discussion_r483618093", "createdAt": "2020-09-04T13:33:14Z", "author": {"login": "jamisonbennett"}, "path": "cloud-gcp/src/main/java/com/sequenceiq/cloudbreak/cloud/gcp/util/GcpStackUtil.java", "diffHunk": "@@ -241,6 +256,26 @@ public static String getTarName(String image) {\n         }\n     }\n \n+    public static String getBucketName(String objectStorageLocation) {\n+        String[] parts = createParts(objectStorageLocation);\n+        if (!StringUtils.isEmpty(objectStorageLocation) && parts.length > 1) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7d71a0504ea930a18fdbed61035ac88137d56213"}, "originalPosition": 70}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAyMzk2NTYzOnYy", "diffSide": "RIGHT", "path": "environment/src/main/java/com/sequenceiq/environment/environment/validation/network/gcp/GcpEnvironmentNetworkValidator.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wNFQxMzo0MzoxNFrOHNOD3Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wNFQxMzo0MzoxNFrOHNOD3Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzYyMzkwMQ==", "bodyText": "nit: Can this message be improved to state that one of them is null, how about \"Either EnvironmentDto or NetworkDto is null. Neither them can be null.\"", "url": "https://github.com/hortonworks/cloudbreak/pull/8918#discussion_r483623901", "createdAt": "2020-09-04T13:43:14Z", "author": {"login": "jamisonbennett"}, "path": "environment/src/main/java/com/sequenceiq/environment/environment/validation/network/gcp/GcpEnvironmentNetworkValidator.java", "diffHunk": "@@ -0,0 +1,119 @@\n+package com.sequenceiq.environment.environment.validation.network.gcp;\n+\n+import static com.sequenceiq.cloudbreak.common.mappable.CloudPlatform.GCP;\n+\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+\n+import org.apache.commons.collections.MapUtils;\n+import org.apache.commons.collections4.CollectionUtils;\n+import org.apache.commons.lang3.StringUtils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.stereotype.Component;\n+\n+import com.sequenceiq.cloudbreak.cloud.model.CloudSubnet;\n+import com.sequenceiq.cloudbreak.common.mappable.CloudPlatform;\n+import com.sequenceiq.cloudbreak.validation.ValidationResult;\n+import com.sequenceiq.environment.environment.dto.EnvironmentDto;\n+import com.sequenceiq.environment.environment.validation.network.EnvironmentNetworkValidator;\n+import com.sequenceiq.environment.network.CloudNetworkService;\n+import com.sequenceiq.environment.network.dto.GcpParams;\n+import com.sequenceiq.environment.network.dto.NetworkDto;\n+\n+@Component\n+public class GcpEnvironmentNetworkValidator implements EnvironmentNetworkValidator {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(GcpEnvironmentNetworkValidator.class);\n+\n+    private final CloudNetworkService cloudNetworkService;\n+\n+    public GcpEnvironmentNetworkValidator(CloudNetworkService cloudNetworkService) {\n+        this.cloudNetworkService = cloudNetworkService;\n+    }\n+\n+    @Override\n+    public void validateDuringFlow(EnvironmentDto environmentDto, NetworkDto networkDto, ValidationResult.ValidationResultBuilder resultBuilder) {\n+        if (environmentDto == null || networkDto == null) {\n+            LOGGER.warn(\"EnvironmentDto or NetworkDto. Neither them can be null!\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7d71a0504ea930a18fdbed61035ac88137d56213"}, "originalPosition": 38}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAyNDAwNzA1OnYy", "diffSide": "RIGHT", "path": "freeipa/src/main/resources/freeipa-salt/salt/freeipa/scripts/freeipa_install.sh", "isResolved": true, "comments": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wNFQxMzo1NDowNlrOHNOcqw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNVQxOTo0OTo0NVrOHSSG2Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzYzMDI1MQ==", "bodyText": "It appears that this wasn't tested with FreeIPA HA. As freeipa_replica_install.sh has the same thing but doesn't appear to be changed in the PR.\nI think the primary install might be OK without auto forwarder since I think it was probably changed for consistency with the replica install. If the replica install is also configured to use --auto-forwarders this will reintroduce CB-8329 and it will be rather hard to detect that the cluster is no longer actually HA.\nWe used to have --auto-forwarders but if you create a 2 node freeipa HA cluster and then kill/stop the first one which is installed. The second instance will no longer be able to resolve external DNS (e.g. try resolving foo.com from it). While this appears to \"work\" it really sets the forwarder of the replica to be another instance of FreeIPA, so the entire freeipa cluster depends on a single instance of FreeIPA for external DNS resolution. Also, if you do a few repairs eventually you end up with no way to route external DNS.\nI think this needs to be validated to ensure we don't reintroduce CB-8329 under an HA scenario.\nBased on the reason this change was made, we might need a new way to detect the upstream DNS forwarders for GCP.", "url": "https://github.com/hortonworks/cloudbreak/pull/8918#discussion_r483630251", "createdAt": "2020-09-04T13:54:06Z", "author": {"login": "jamisonbennett"}, "path": "freeipa/src/main/resources/freeipa-salt/salt/freeipa/scripts/freeipa_install.sh", "diffHunk": "@@ -26,8 +21,8 @@ ipa-server-install \\\n           --allow-zone-overlap \\\n           --ssh-trust-dns \\\n           --mkhomedir \\\n-          --ip-address \"$IPADDR\" \\\n-          $FORWARDERS \\\n+          --ip-address $IPADDR \\\n+          --auto-forwarders \\", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7d71a0504ea930a18fdbed61035ac88137d56213"}, "originalPosition": 19}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mzc1MjU5Mw==", "bodyText": "@jamisonbennett correct, FreeIPA HA is not in tech-preview scope, even it is not in GA scope. Probably will file a Jira for GCP FreeIPA HA. My understanding is that FreeIPA HA is still under entitlement CDP_FREEIPA_HA.", "url": "https://github.com/hortonworks/cloudbreak/pull/8918#discussion_r483752593", "createdAt": "2020-09-04T17:10:18Z", "author": {"login": "cegganesh84"}, "path": "freeipa/src/main/resources/freeipa-salt/salt/freeipa/scripts/freeipa_install.sh", "diffHunk": "@@ -26,8 +21,8 @@ ipa-server-install \\\n           --allow-zone-overlap \\\n           --ssh-trust-dns \\\n           --mkhomedir \\\n-          --ip-address \"$IPADDR\" \\\n-          $FORWARDERS \\\n+          --ip-address $IPADDR \\\n+          --auto-forwarders \\", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzYzMDI1MQ=="}, "originalCommit": {"oid": "7d71a0504ea930a18fdbed61035ac88137d56213"}, "originalPosition": 19}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mzc1NTc1Mw==", "bodyText": "https://jira.cloudera.com/browse/CB-8677", "url": "https://github.com/hortonworks/cloudbreak/pull/8918#discussion_r483755753", "createdAt": "2020-09-04T17:17:44Z", "author": {"login": "cegganesh84"}, "path": "freeipa/src/main/resources/freeipa-salt/salt/freeipa/scripts/freeipa_install.sh", "diffHunk": "@@ -26,8 +21,8 @@ ipa-server-install \\\n           --allow-zone-overlap \\\n           --ssh-trust-dns \\\n           --mkhomedir \\\n-          --ip-address \"$IPADDR\" \\\n-          $FORWARDERS \\\n+          --ip-address $IPADDR \\\n+          --auto-forwarders \\", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzYzMDI1MQ=="}, "originalCommit": {"oid": "7d71a0504ea930a18fdbed61035ac88137d56213"}, "originalPosition": 19}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODkwNTMwMQ==", "bodyText": "The problem is this is going into common code in the master branch and it will break FreeIPA HA for Azure & AWS.", "url": "https://github.com/hortonworks/cloudbreak/pull/8918#discussion_r488905301", "createdAt": "2020-09-15T19:12:17Z", "author": {"login": "jamisonbennett"}, "path": "freeipa/src/main/resources/freeipa-salt/salt/freeipa/scripts/freeipa_install.sh", "diffHunk": "@@ -26,8 +21,8 @@ ipa-server-install \\\n           --allow-zone-overlap \\\n           --ssh-trust-dns \\\n           --mkhomedir \\\n-          --ip-address \"$IPADDR\" \\\n-          $FORWARDERS \\\n+          --ip-address $IPADDR \\\n+          --auto-forwarders \\", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzYzMDI1MQ=="}, "originalCommit": {"oid": "7d71a0504ea930a18fdbed61035ac88137d56213"}, "originalPosition": 19}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODkwNzk0Ng==", "bodyText": "Can you put this in a platform if block in the template?", "url": "https://github.com/hortonworks/cloudbreak/pull/8918#discussion_r488907946", "createdAt": "2020-09-15T19:17:20Z", "author": {"login": "jamisonbennett"}, "path": "freeipa/src/main/resources/freeipa-salt/salt/freeipa/scripts/freeipa_install.sh", "diffHunk": "@@ -26,8 +21,8 @@ ipa-server-install \\\n           --allow-zone-overlap \\\n           --ssh-trust-dns \\\n           --mkhomedir \\\n-          --ip-address \"$IPADDR\" \\\n-          $FORWARDERS \\\n+          --ip-address $IPADDR \\\n+          --auto-forwarders \\", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzYzMDI1MQ=="}, "originalCommit": {"oid": "7d71a0504ea930a18fdbed61035ac88137d56213"}, "originalPosition": 19}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODkzMjE1NQ==", "bodyText": "My original comment says the forwarder change was not necessary on the primary but was just done for consistency. So this will not break anything.", "url": "https://github.com/hortonworks/cloudbreak/pull/8918#discussion_r488932155", "createdAt": "2020-09-15T19:48:22Z", "author": {"login": "jamisonbennett"}, "path": "freeipa/src/main/resources/freeipa-salt/salt/freeipa/scripts/freeipa_install.sh", "diffHunk": "@@ -26,8 +21,8 @@ ipa-server-install \\\n           --allow-zone-overlap \\\n           --ssh-trust-dns \\\n           --mkhomedir \\\n-          --ip-address \"$IPADDR\" \\\n-          $FORWARDERS \\\n+          --ip-address $IPADDR \\\n+          --auto-forwarders \\", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzYzMDI1MQ=="}, "originalCommit": {"oid": "7d71a0504ea930a18fdbed61035ac88137d56213"}, "originalPosition": 19}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODkzMzA4MQ==", "bodyText": "Had an offline chat. This does not break FreeIPA HA for Azure & AWS. The original description (of Jamison) says the forwarder change was not necessary on the primary but was just done for consistency. Any followups on this can be done as part of CB-8677", "url": "https://github.com/hortonworks/cloudbreak/pull/8918#discussion_r488933081", "createdAt": "2020-09-15T19:49:45Z", "author": {"login": "cegganesh84"}, "path": "freeipa/src/main/resources/freeipa-salt/salt/freeipa/scripts/freeipa_install.sh", "diffHunk": "@@ -26,8 +21,8 @@ ipa-server-install \\\n           --allow-zone-overlap \\\n           --ssh-trust-dns \\\n           --mkhomedir \\\n-          --ip-address \"$IPADDR\" \\\n-          $FORWARDERS \\\n+          --ip-address $IPADDR \\\n+          --auto-forwarders \\", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzYzMDI1MQ=="}, "originalCommit": {"oid": "7d71a0504ea930a18fdbed61035ac88137d56213"}, "originalPosition": 19}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2337, "cost": 1, "resetAt": "2021-11-12T20:44:06Z"}}}