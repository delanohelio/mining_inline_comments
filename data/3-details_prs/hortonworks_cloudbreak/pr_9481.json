{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTI0MTg0MzAw", "number": 9481, "title": "CB-9639 Introduce the upgrade API to DistroX", "bodyText": "includes a new endpoint for DistroX upgrade\ndepends on the same code az datalake/sdx upgrade\ndatalake service side flow has been replaced with flowchain\nVM replacement not supported ATM", "createdAt": "2020-11-19T19:36:15Z", "url": "https://github.com/hortonworks/cloudbreak/pull/9481", "merged": true, "mergeCommit": {"oid": "16cfedd441f0aa22be9c1ee702c2406226d02922"}, "closed": true, "closedAt": "2020-11-25T13:36:38Z", "author": {"login": "lacikaaa"}, "timelineItems": {"totalCount": 9, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdfTmGdABqjQwMjcyMDAyMzQ=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdf89fEgBqjQwMzc2OTkwNzQ=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "afedfd1d8a0547aba33bf78a14c5f69732a1340b", "author": {"user": {"login": "lacikaaa", "name": "Mihaly Laszlo Molnar"}}, "url": "https://github.com/hortonworks/cloudbreak/commit/afedfd1d8a0547aba33bf78a14c5f69732a1340b", "committedDate": "2020-11-19T19:33:23Z", "message": "CB-9639 Introduce the upgrade API to DistroX\n\n- includes a new endpoint for DistroX upgrade\n- depends on the same code az datalake/sdx upgrade\n- datalake service side flow has been replaced with flowchain\n- VM replacement not supported ATM"}, "afterCommit": {"oid": "c0149f8eeb59033a226fa978dbb756522b7f3460", "author": {"user": {"login": "lacikaaa", "name": "Mihaly Laszlo Molnar"}}, "url": "https://github.com/hortonworks/cloudbreak/commit/c0149f8eeb59033a226fa978dbb756522b7f3460", "committedDate": "2020-11-23T11:38:13Z", "message": "CB-9639 Introduce the upgrade API to DistroX\n\n- includes a new endpoint for DistroX upgrade\n- depends on the same code az datalake/sdx upgrade\n- datalake service side flow has been replaced with flowchain\n- VM replacement not supported ATM"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "c0149f8eeb59033a226fa978dbb756522b7f3460", "author": {"user": {"login": "lacikaaa", "name": "Mihaly Laszlo Molnar"}}, "url": "https://github.com/hortonworks/cloudbreak/commit/c0149f8eeb59033a226fa978dbb756522b7f3460", "committedDate": "2020-11-23T11:38:13Z", "message": "CB-9639 Introduce the upgrade API to DistroX\n\n- includes a new endpoint for DistroX upgrade\n- depends on the same code az datalake/sdx upgrade\n- datalake service side flow has been replaced with flowchain\n- VM replacement not supported ATM"}, "afterCommit": {"oid": "4635be966b2108f2d4f524ba88d67e36e94d5973", "author": {"user": {"login": "lacikaaa", "name": "Mihaly Laszlo Molnar"}}, "url": "https://github.com/hortonworks/cloudbreak/commit/4635be966b2108f2d4f524ba88d67e36e94d5973", "committedDate": "2020-11-23T13:10:10Z", "message": "CB-9639 Introduce the upgrade API to DistroX\n\n- includes a new endpoint for DistroX upgrade\n- depends on the same code az datalake/sdx upgrade\n- datalake service side flow has been replaced with flowchain\n- VM replacement not supported ATM"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTM2NDc3NTc0", "url": "https://github.com/hortonworks/cloudbreak/pull/9481#pullrequestreview-536477574", "createdAt": "2020-11-23T13:36:56Z", "commit": {"oid": "4635be966b2108f2d4f524ba88d67e36e94d5973"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yM1QxMzozNjo1NlrOH4NwIA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yM1QxMzozNjo1NlrOH4NwIA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODcwNzYxNg==", "bodyText": "We're checking if the attached Data Hubs are stopped or not so the method name is misleading. Similar we should rename checkForNotAttachedClusters as well.", "url": "https://github.com/hortonworks/cloudbreak/pull/9481#discussion_r528707616", "createdAt": "2020-11-23T13:36:56Z", "author": {"login": "keyki"}, "path": "core/src/main/java/com/sequenceiq/distrox/v1/distrox/StackOperations.java", "diffHunk": "@@ -237,22 +237,21 @@ public FlowIdentifier updatePillarConfiguration(@NotNull NameOrCrn nameOrCrn, Lo\n     }\n \n     public UpgradeV4Response checkForClusterUpgrade(@NotNull NameOrCrn nameOrCrn, Long workspaceId, UpgradeV4Request request) {\n-        if (nameOrCrn.hasName()) {\n-            String stackName = nameOrCrn.getName();\n-            boolean osUpgrade = upgradeService.isOsUpgrade(request);\n-            UpgradeV4Response upgradeResponse = clusterUpgradeAvailabilityService.checkForUpgradesByName(workspaceId, stackName,\n-                    osUpgrade);\n-            if (CollectionUtils.isNotEmpty(upgradeResponse.getUpgradeCandidates())) {\n-                clusterUpgradeAvailabilityService.filterUpgradeOptions(upgradeResponse, request);\n-            }\n-            Stack stack = getStackByName(stackName);\n-            MDCBuilder.buildMdcContext(stack);\n+        Stack stack = stackService.getByNameOrCrnInWorkspace(nameOrCrn, workspaceId);\n+        MDCBuilder.buildMdcContext(stack);\n+        boolean osUpgrade = upgradeService.isOsUpgrade(request);\n+        UpgradeV4Response upgradeResponse = clusterUpgradeAvailabilityService.checkForUpgradesByName(stack, osUpgrade, request.getReplaceVms());\n+        if (CollectionUtils.isNotEmpty(upgradeResponse.getUpgradeCandidates())) {\n+            clusterUpgradeAvailabilityService.filterUpgradeOptions(upgradeResponse, request);\n+        }\n+        validateDatalakeHasNoDatahub(workspaceId, stack, upgradeResponse);\n+        return upgradeResponse;\n+    }\n+\n+    private void validateDatalakeHasNoDatahub(Long workspaceId, Stack stack, UpgradeV4Response upgradeResponse) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4635be966b2108f2d4f524ba88d67e36e94d5973"}, "originalPosition": 25}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTM2NTI4MzU2", "url": "https://github.com/hortonworks/cloudbreak/pull/9481#pullrequestreview-536528356", "createdAt": "2020-11-23T14:34:43Z", "commit": {"oid": "4635be966b2108f2d4f524ba88d67e36e94d5973"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yM1QxNDozNDo0M1rOH4QGFA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yM1QxNDozNDo0M1rOH4QGFA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODc0NjAwNA==", "bodyText": "What does this todo mean?", "url": "https://github.com/hortonworks/cloudbreak/pull/9481#discussion_r528746004", "createdAt": "2020-11-23T14:34:43Z", "author": {"login": "keyki"}, "path": "core/src/main/java/com/sequenceiq/distrox/v1/distrox/service/upgrade/DistroxUpgradeService.java", "diffHunk": "@@ -0,0 +1,126 @@\n+package com.sequenceiq.distrox.v1.distrox.service.upgrade;\n+\n+import static com.sequenceiq.cloudbreak.auth.ThreadBasedUserCrnProvider.INTERNAL_ACTOR_CRN;\n+\n+import java.util.List;\n+\n+import javax.inject.Inject;\n+\n+import org.apache.commons.collections.CollectionUtils;\n+import org.apache.commons.lang3.StringUtils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.beans.factory.annotation.Value;\n+import org.springframework.stereotype.Service;\n+\n+import com.cloudera.thunderhead.service.usermanagement.UserManagementProto.Account;\n+import com.sequenceiq.cloudbreak.api.endpoint.v4.dto.NameOrCrn;\n+import com.sequenceiq.cloudbreak.api.endpoint.v4.stacks.request.StackImageChangeV4Request;\n+import com.sequenceiq.cloudbreak.api.endpoint.v4.stacks.request.tags.upgrade.UpgradeV4Request;\n+import com.sequenceiq.cloudbreak.api.endpoint.v4.stacks.response.image.ImageInfoV4Response;\n+import com.sequenceiq.cloudbreak.api.endpoint.v4.stacks.response.upgrade.UpgradeV4Response;\n+import com.sequenceiq.cloudbreak.auth.CMLicenseParser;\n+import com.sequenceiq.cloudbreak.auth.JsonCMLicense;\n+import com.sequenceiq.cloudbreak.auth.PaywallAccessChecker;\n+import com.sequenceiq.cloudbreak.auth.altus.Crn;\n+import com.sequenceiq.cloudbreak.auth.altus.EntitlementService;\n+import com.sequenceiq.cloudbreak.auth.altus.GrpcUmsClient;\n+import com.sequenceiq.cloudbreak.core.flow2.service.ReactorFlowManager;\n+import com.sequenceiq.cloudbreak.exception.BadRequestException;\n+import com.sequenceiq.cloudbreak.logger.MDCUtils;\n+import com.sequenceiq.cloudbreak.service.StackCommonService;\n+import com.sequenceiq.cloudbreak.service.image.ImageChangeDto;\n+import com.sequenceiq.cloudbreak.service.stack.StackService;\n+import com.sequenceiq.flow.api.model.FlowIdentifier;\n+\n+@Service\n+public class DistroxUpgradeService {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(DistroxUpgradeService.class);\n+\n+    @Value(\"${cb.paywall.url}\")\n+    private String paywallUrl;\n+\n+    @Inject\n+    private DistroxUpgradeAvailabilityService upgradeAvailabilityService;\n+\n+    @Inject\n+    private EntitlementService entitlementService;\n+\n+    @Inject\n+    private GrpcUmsClient umsClient;\n+\n+    @Inject\n+    private PaywallAccessChecker paywallAccessChecker;\n+\n+    @Inject\n+    private DistroxUpgradeImageSelector imageSelector;\n+\n+    @Inject\n+    private StackCommonService stackCommonService;\n+\n+    @Inject\n+    private ReactorFlowManager reactorFlowManager;\n+\n+    @Inject\n+    private StackService stackService;\n+\n+    @Inject\n+    private CMLicenseParser cmLicenseParser;\n+\n+    public UpgradeV4Response triggerUpgrade(NameOrCrn cluster, Long workspaceId, String userCrn, UpgradeV4Request request) {\n+        UpgradeV4Response upgradeV4Response = upgradeAvailabilityService.checkForUpgrade(cluster, workspaceId, request, userCrn);\n+        validateUpgradeCandidates(cluster, upgradeV4Response);\n+        verifyPaywallAccess(userCrn, request);\n+        return initUpgrade(request, upgradeV4Response.getUpgradeCandidates(), cluster, workspaceId);\n+    }\n+\n+    private UpgradeV4Response initUpgrade(UpgradeV4Request request, List<ImageInfoV4Response> upgradeCandidates, NameOrCrn cluster, Long workspaceId) {\n+        ImageInfoV4Response image = imageSelector.determineImageId(request, upgradeCandidates);\n+        ImageChangeDto imageChangeDto = createImageChangeDto(cluster, workspaceId, image);\n+        Long stackId = stackService.getIdByNameOrCrnInWorkspace(cluster, workspaceId);\n+        FlowIdentifier flowIdentifier = reactorFlowManager.triggerDistroxUpgrade(stackId, imageChangeDto, false);\n+        // TODO: reason nice solution", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4635be966b2108f2d4f524ba88d67e36e94d5973"}, "originalPosition": 83}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "4635be966b2108f2d4f524ba88d67e36e94d5973", "author": {"user": {"login": "lacikaaa", "name": "Mihaly Laszlo Molnar"}}, "url": "https://github.com/hortonworks/cloudbreak/commit/4635be966b2108f2d4f524ba88d67e36e94d5973", "committedDate": "2020-11-23T13:10:10Z", "message": "CB-9639 Introduce the upgrade API to DistroX\n\n- includes a new endpoint for DistroX upgrade\n- depends on the same code az datalake/sdx upgrade\n- datalake service side flow has been replaced with flowchain\n- VM replacement not supported ATM"}, "afterCommit": {"oid": "1fdd32b0338f74edd4466735f5756550fed4b0fe", "author": {"user": {"login": "lacikaaa", "name": "Mihaly Laszlo Molnar"}}, "url": "https://github.com/hortonworks/cloudbreak/commit/1fdd32b0338f74edd4466735f5756550fed4b0fe", "committedDate": "2020-11-23T15:19:23Z", "message": "CB-9639 Introduce the upgrade API to DistroX\n\n- includes a new endpoint for DistroX upgrade\n- depends on the same code az datalake/sdx upgrade\n- datalake service side flow has been replaced with flowchain\n- VM replacement not supported ATM"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "1fdd32b0338f74edd4466735f5756550fed4b0fe", "author": {"user": {"login": "lacikaaa", "name": "Mihaly Laszlo Molnar"}}, "url": "https://github.com/hortonworks/cloudbreak/commit/1fdd32b0338f74edd4466735f5756550fed4b0fe", "committedDate": "2020-11-23T15:19:23Z", "message": "CB-9639 Introduce the upgrade API to DistroX\n\n- includes a new endpoint for DistroX upgrade\n- depends on the same code az datalake/sdx upgrade\n- datalake service side flow has been replaced with flowchain\n- VM replacement not supported ATM"}, "afterCommit": {"oid": "06a8142dc207f0571f510a9198346510b3ae2e0d", "author": {"user": {"login": "lacikaaa", "name": "Mihaly Laszlo Molnar"}}, "url": "https://github.com/hortonworks/cloudbreak/commit/06a8142dc207f0571f510a9198346510b3ae2e0d", "committedDate": "2020-11-24T14:23:34Z", "message": "CB-9639 Introduce the upgrade API to DistroX\n\n- includes a new endpoint for DistroX upgrade\n- depends on the same code az datalake/sdx upgrade\n- datalake service side flow has been replaced with flowchain\n- VM replacement not supported ATM"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTM2NzA1OTY3", "url": "https://github.com/hortonworks/cloudbreak/pull/9481#pullrequestreview-536705967", "createdAt": "2020-11-23T17:41:45Z", "commit": {"oid": "1fdd32b0338f74edd4466735f5756550fed4b0fe"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 20, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yM1QxNzo0MTo0NVrOH4Yh8Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNFQxNTo1Njo0NFrOH5I2KQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODg4NDIwOQ==", "bodyText": "this could be used in com.sequenceiq.cloudbreak.service.upgrade.ClusterUpgradeAvailabilityService#filterUpgradeOptions", "url": "https://github.com/hortonworks/cloudbreak/pull/9481#discussion_r528884209", "createdAt": "2020-11-23T17:41:45Z", "author": {"login": "pdarvasi"}, "path": "core-api/src/main/java/com/sequenceiq/cloudbreak/api/endpoint/v4/stacks/response/image/ImageInfoV4Response.java", "diffHunk": "@@ -126,6 +127,10 @@ public int compareTo(ImageInfoV4Response o) {\n         return ret;\n     }\n \n+    public static Comparator<ImageInfoV4Response> creationBasedComparator() {\n+        return Comparator.comparingLong(ImageInfoV4Response::getCreated);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1fdd32b0338f74edd4466735f5756550fed4b0fe"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTQ0OTgxNA==", "bodyText": "DatalakeClusterUpgradeTriggerEvent should be renamed as it is general now", "url": "https://github.com/hortonworks/cloudbreak/pull/9481#discussion_r529449814", "createdAt": "2020-11-24T10:53:56Z", "author": {"login": "pdarvasi"}, "path": "core/src/main/java/com/sequenceiq/cloudbreak/core/flow2/chain/UpgradeDistroxFlowEventChainFactory.java", "diffHunk": "@@ -0,0 +1,43 @@\n+package com.sequenceiq.cloudbreak.core.flow2.chain;\n+\n+import static com.sequenceiq.cloudbreak.core.flow2.cluster.datalake.upgrade.ClusterUpgradeEvent.CLUSTER_UPGRADE_INIT_EVENT;\n+\n+import java.util.Queue;\n+import java.util.concurrent.ConcurrentLinkedQueue;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.stereotype.Component;\n+\n+import com.sequenceiq.cloudbreak.common.event.Selectable;\n+import com.sequenceiq.cloudbreak.core.flow2.cluster.salt.update.SaltUpdateEvent;\n+import com.sequenceiq.cloudbreak.core.flow2.event.DatalakeClusterUpgradeTriggerEvent;\n+import com.sequenceiq.cloudbreak.core.flow2.event.DistroxUpgradeTriggerEvent;\n+import com.sequenceiq.cloudbreak.core.flow2.event.StackImageUpdateTriggerEvent;\n+import com.sequenceiq.cloudbreak.reactor.api.event.StackEvent;\n+import com.sequenceiq.flow.core.chain.FlowEventChainFactory;\n+\n+@Component\n+public class UpgradeDistroxFlowEventChainFactory implements FlowEventChainFactory<DistroxUpgradeTriggerEvent> {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(UpgradeDistroxFlowEventChainFactory.class);\n+\n+    @Override\n+    public String initEvent() {\n+        return FlowChainTriggers.DISTROX_CLUSTER_UPGRADE_CHAIN_TRIGGER_EVENT;\n+    }\n+\n+    @Override\n+    public Queue<Selectable> createFlowTriggerEventQueue(DistroxUpgradeTriggerEvent event) {\n+        Queue<Selectable> chain = new ConcurrentLinkedQueue<>();\n+        chain.add(new StackEvent(SaltUpdateEvent.SALT_UPDATE_EVENT.event(), event.getResourceId(), event.accepted()));\n+        chain.add(new DatalakeClusterUpgradeTriggerEvent(CLUSTER_UPGRADE_INIT_EVENT.event(), event.getResourceId(), event.accepted(),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1fdd32b0338f74edd4466735f5756550fed4b0fe"}, "originalPosition": 34}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTQ1NDIxMg==", "bodyText": "this is not used as per now", "url": "https://github.com/hortonworks/cloudbreak/pull/9481#discussion_r529454212", "createdAt": "2020-11-24T10:57:37Z", "author": {"login": "pdarvasi"}, "path": "core/src/main/java/com/sequenceiq/cloudbreak/core/flow2/event/DistroxUpgradeTriggerEvent.java", "diffHunk": "@@ -0,0 +1,34 @@\n+package com.sequenceiq.cloudbreak.core.flow2.event;\n+\n+import com.sequenceiq.cloudbreak.common.event.AcceptResult;\n+import com.sequenceiq.cloudbreak.reactor.api.event.StackEvent;\n+import com.sequenceiq.cloudbreak.service.image.ImageChangeDto;\n+\n+import reactor.rx.Promise;\n+\n+public class DistroxUpgradeTriggerEvent extends StackEvent {\n+\n+    private final ImageChangeDto imageChangeDto;\n+\n+    private final boolean replaceVms;\n+\n+    public DistroxUpgradeTriggerEvent(String selector, Long stackId, ImageChangeDto imageChangeDto, boolean replaceVms) {\n+        super(selector, stackId);\n+        this.imageChangeDto = imageChangeDto;\n+        this.replaceVms = replaceVms;\n+    }\n+\n+    public DistroxUpgradeTriggerEvent(String event, Long resourceId, Promise<AcceptResult> accepted, ImageChangeDto imageChangeDto, boolean replaceVms) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1fdd32b0338f74edd4466735f5756550fed4b0fe"}, "originalPosition": 21}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTQ3MjQ5MQ==", "bodyText": "minor: it would be good to unify the naming as this is called both imageChange and imageUpdate, the latter is more common", "url": "https://github.com/hortonworks/cloudbreak/pull/9481#discussion_r529472491", "createdAt": "2020-11-24T11:25:27Z", "author": {"login": "pdarvasi"}, "path": "core/src/main/java/com/sequenceiq/cloudbreak/core/flow2/event/DistroxUpgradeTriggerEvent.java", "diffHunk": "@@ -0,0 +1,34 @@\n+package com.sequenceiq.cloudbreak.core.flow2.event;\n+\n+import com.sequenceiq.cloudbreak.common.event.AcceptResult;\n+import com.sequenceiq.cloudbreak.reactor.api.event.StackEvent;\n+import com.sequenceiq.cloudbreak.service.image.ImageChangeDto;\n+\n+import reactor.rx.Promise;\n+\n+public class DistroxUpgradeTriggerEvent extends StackEvent {\n+\n+    private final ImageChangeDto imageChangeDto;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1fdd32b0338f74edd4466735f5756550fed4b0fe"}, "originalPosition": 11}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTQ3OTIxMw==", "bodyText": "latter 2 could be replaced with one Boolean.TRUE.equals()", "url": "https://github.com/hortonworks/cloudbreak/pull/9481#discussion_r529479213", "createdAt": "2020-11-24T11:37:02Z", "author": {"login": "pdarvasi"}, "path": "core/src/main/java/com/sequenceiq/cloudbreak/service/upgrade/ClusterUpgradeAvailabilityService.java", "diffHunk": "@@ -81,24 +77,29 @@\n     @Inject\n     private ClusterComponentConfigProvider clusterComponentConfigProvider;\n \n-    public UpgradeV4Response checkForUpgradesByName(Long workspaceId, String stackName, boolean lockComponents) {\n-        Stack stack = stackService.getByNameInWorkspace(stackName, workspaceId);\n+    public UpgradeV4Response checkForUpgradesByName(Stack stack, boolean lockComponents, Boolean replaceVms) {\n         UpgradeV4Response upgradeOptions = checkForUpgrades(stack, lockComponents);\n         if (StringUtils.isEmpty(upgradeOptions.getReason())) {\n-            Result<Map<HostGroupName, Set<InstanceMetaData>>, RepairValidation> validationResult = clusterRepairService.repairWithDryRun(stack.getId());\n             if (!stack.getStatus().isAvailable()) {\n                 upgradeOptions.setReason(String.format(\"Cannot upgrade cluster because it is in %s state.\", stack.getStatus()));\n                 LOGGER.warn(upgradeOptions.getReason());\n-            } else if (validationResult.isError()) {\n-                upgradeOptions.setReason(String.join(\",\", validationResult.getError().getValidationErrors()));\n-                LOGGER.warn(String.format(\"Cannot upgrade cluster because: %s\", upgradeOptions.getReason()));\n+            } else if (shouldValidateForRepair(lockComponents, replaceVms)) {\n+                LOGGER.debug(\"Validate for repair\");\n+                Result<Map<HostGroupName, Set<InstanceMetaData>>, RepairValidation> validationResult = clusterRepairService.repairWithDryRun(stack.getId());\n+                if (validationResult.isError()) {\n+                    upgradeOptions.setReason(String.join(\",\", validationResult.getError().getValidationErrors()));\n+                    LOGGER.warn(String.format(\"Cannot upgrade cluster because: %s\", upgradeOptions.getReason()));\n+                }\n             }\n         }\n         return upgradeOptions;\n     }\n \n-    public UpgradeV4Response checkForNotAttachedClusters(StackViewV4Responses stackViewV4Responses, UpgradeV4Response upgradeOptions) {\n+    private boolean shouldValidateForRepair(boolean lockComponents, Boolean replaceVms) {\n+        return lockComponents || replaceVms == null || replaceVms;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1fdd32b0338f74edd4466735f5756550fed4b0fe"}, "originalPosition": 48}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTYwNzkxNA==", "bodyText": "typo: selectLastestImageByRuntime", "url": "https://github.com/hortonworks/cloudbreak/pull/9481#discussion_r529607914", "createdAt": "2020-11-24T14:56:27Z", "author": {"login": "pdarvasi"}, "path": "core/src/main/java/com/sequenceiq/distrox/v1/distrox/service/upgrade/DistroxUpgradeImageSelector.java", "diffHunk": "@@ -0,0 +1,88 @@\n+package com.sequenceiq.distrox.v1.distrox.service.upgrade;\n+\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+\n+import org.apache.commons.lang3.StringUtils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.stereotype.Component;\n+\n+import com.sequenceiq.cloudbreak.api.endpoint.v4.stacks.request.tags.upgrade.UpgradeV4Request;\n+import com.sequenceiq.cloudbreak.api.endpoint.v4.stacks.response.image.ImageComponentVersions;\n+import com.sequenceiq.cloudbreak.api.endpoint.v4.stacks.response.image.ImageInfoV4Response;\n+import com.sequenceiq.cloudbreak.exception.BadRequestException;\n+\n+@Component\n+public class DistroxUpgradeImageSelector {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(DistroxUpgradeImageSelector.class);\n+\n+    public ImageInfoV4Response determineImageId(UpgradeV4Request request, List<ImageInfoV4Response> upgradeCandidates) {\n+        Optional<ImageInfoV4Response> image = Optional.empty();\n+        if (Objects.isNull(request) || request.isEmpty() || Boolean.TRUE.equals(request.getLockComponents())) {\n+            image = selectLatestImageFromCandidates(upgradeCandidates);\n+        } else if (StringUtils.isNotEmpty(request.getImageId())) {\n+            image = selectRequestedImage(request, upgradeCandidates);\n+        } else if (StringUtils.isNotEmpty(request.getRuntime())) {\n+            image = selectLastestImageByRuntime(upgradeCandidates, request.getRuntime());\n+        }\n+        return image.orElseThrow(() -> new BadRequestException(String.format(\"Invalid upgrade request, please validate the contents: %s\", request)));\n+    }\n+\n+    private Optional<ImageInfoV4Response> selectLastestImageByRuntime(List<ImageInfoV4Response> upgradeCandidates, String runtime) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "06a8142dc207f0571f510a9198346510b3ae2e0d"}, "originalPosition": 35}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTYxMzgxOQ==", "bodyText": "this should be instead:         Optional imageInfoV4Response = imagesWithMatchingRuntime.stream().max(ImageInfoV4Response.creationBasedComparator());", "url": "https://github.com/hortonworks/cloudbreak/pull/9481#discussion_r529613819", "createdAt": "2020-11-24T15:04:00Z", "author": {"login": "pdarvasi"}, "path": "core/src/main/java/com/sequenceiq/distrox/v1/distrox/service/upgrade/DistroxUpgradeImageSelector.java", "diffHunk": "@@ -0,0 +1,88 @@\n+package com.sequenceiq.distrox.v1.distrox.service.upgrade;\n+\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+\n+import org.apache.commons.lang3.StringUtils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.stereotype.Component;\n+\n+import com.sequenceiq.cloudbreak.api.endpoint.v4.stacks.request.tags.upgrade.UpgradeV4Request;\n+import com.sequenceiq.cloudbreak.api.endpoint.v4.stacks.response.image.ImageComponentVersions;\n+import com.sequenceiq.cloudbreak.api.endpoint.v4.stacks.response.image.ImageInfoV4Response;\n+import com.sequenceiq.cloudbreak.exception.BadRequestException;\n+\n+@Component\n+public class DistroxUpgradeImageSelector {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(DistroxUpgradeImageSelector.class);\n+\n+    public ImageInfoV4Response determineImageId(UpgradeV4Request request, List<ImageInfoV4Response> upgradeCandidates) {\n+        Optional<ImageInfoV4Response> image = Optional.empty();\n+        if (Objects.isNull(request) || request.isEmpty() || Boolean.TRUE.equals(request.getLockComponents())) {\n+            image = selectLatestImageFromCandidates(upgradeCandidates);\n+        } else if (StringUtils.isNotEmpty(request.getImageId())) {\n+            image = selectRequestedImage(request, upgradeCandidates);\n+        } else if (StringUtils.isNotEmpty(request.getRuntime())) {\n+            image = selectLastestImageByRuntime(upgradeCandidates, request.getRuntime());\n+        }\n+        return image.orElseThrow(() -> new BadRequestException(String.format(\"Invalid upgrade request, please validate the contents: %s\", request)));\n+    }\n+\n+    private Optional<ImageInfoV4Response> selectLastestImageByRuntime(List<ImageInfoV4Response> upgradeCandidates, String runtime) {\n+        List<ImageInfoV4Response> imagesWithMatchingRuntime = upgradeCandidates.stream().filter(\n+                imageInfoV4Response -> runtime.equals(imageInfoV4Response.getComponentVersions().getCdp())).collect(Collectors.toList());\n+        validateThereIsMatchingRuntime(upgradeCandidates, imagesWithMatchingRuntime, runtime);\n+        ImageInfoV4Response imageInfoV4Response = imagesWithMatchingRuntime.stream().max(ImageInfoV4Response.creationBasedComparator()).orElseThrow();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "06a8142dc207f0571f510a9198346510b3ae2e0d"}, "originalPosition": 39}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTYxNTEzMw==", "bodyText": "typo + 2 lines can be unified in 1 line", "url": "https://github.com/hortonworks/cloudbreak/pull/9481#discussion_r529615133", "createdAt": "2020-11-24T15:05:41Z", "author": {"login": "pdarvasi"}, "path": "core/src/main/java/com/sequenceiq/distrox/v1/distrox/service/upgrade/DistroxUpgradeImageSelector.java", "diffHunk": "@@ -0,0 +1,88 @@\n+package com.sequenceiq.distrox.v1.distrox.service.upgrade;\n+\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+\n+import org.apache.commons.lang3.StringUtils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.stereotype.Component;\n+\n+import com.sequenceiq.cloudbreak.api.endpoint.v4.stacks.request.tags.upgrade.UpgradeV4Request;\n+import com.sequenceiq.cloudbreak.api.endpoint.v4.stacks.response.image.ImageComponentVersions;\n+import com.sequenceiq.cloudbreak.api.endpoint.v4.stacks.response.image.ImageInfoV4Response;\n+import com.sequenceiq.cloudbreak.exception.BadRequestException;\n+\n+@Component\n+public class DistroxUpgradeImageSelector {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(DistroxUpgradeImageSelector.class);\n+\n+    public ImageInfoV4Response determineImageId(UpgradeV4Request request, List<ImageInfoV4Response> upgradeCandidates) {\n+        Optional<ImageInfoV4Response> image = Optional.empty();\n+        if (Objects.isNull(request) || request.isEmpty() || Boolean.TRUE.equals(request.getLockComponents())) {\n+            image = selectLatestImageFromCandidates(upgradeCandidates);\n+        } else if (StringUtils.isNotEmpty(request.getImageId())) {\n+            image = selectRequestedImage(request, upgradeCandidates);\n+        } else if (StringUtils.isNotEmpty(request.getRuntime())) {\n+            image = selectLastestImageByRuntime(upgradeCandidates, request.getRuntime());\n+        }\n+        return image.orElseThrow(() -> new BadRequestException(String.format(\"Invalid upgrade request, please validate the contents: %s\", request)));\n+    }\n+\n+    private Optional<ImageInfoV4Response> selectLastestImageByRuntime(List<ImageInfoV4Response> upgradeCandidates, String runtime) {\n+        List<ImageInfoV4Response> imagesWithMatchingRuntime = upgradeCandidates.stream().filter(\n+                imageInfoV4Response -> runtime.equals(imageInfoV4Response.getComponentVersions().getCdp())).collect(Collectors.toList());\n+        validateThereIsMatchingRuntime(upgradeCandidates, imagesWithMatchingRuntime, runtime);\n+        ImageInfoV4Response imageInfoV4Response = imagesWithMatchingRuntime.stream().max(ImageInfoV4Response.creationBasedComparator()).orElseThrow();\n+        LOGGER.debug(\"Chosen image {} for {} runtime specified in the request\", imageInfoV4Response, runtime);\n+        return Optional.of(imageInfoV4Response);\n+    }\n+\n+    private void validateThereIsMatchingRuntime(List<ImageInfoV4Response> upgradeCandidates, List<ImageInfoV4Response> imagesWithMatchingRuntime,\n+            String runtime) {\n+        boolean hasNoCompatbileImageWithRuntime = imagesWithMatchingRuntime.isEmpty();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "06a8142dc207f0571f510a9198346510b3ae2e0d"}, "originalPosition": 46}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTYxNzI2NA==", "bodyText": "requestedImage.isEmpty() should be the 2nd parameter", "url": "https://github.com/hortonworks/cloudbreak/pull/9481#discussion_r529617264", "createdAt": "2020-11-24T15:08:23Z", "author": {"login": "pdarvasi"}, "path": "core/src/main/java/com/sequenceiq/distrox/v1/distrox/service/upgrade/DistroxUpgradeImageSelector.java", "diffHunk": "@@ -0,0 +1,88 @@\n+package com.sequenceiq.distrox.v1.distrox.service.upgrade;\n+\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+\n+import org.apache.commons.lang3.StringUtils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.stereotype.Component;\n+\n+import com.sequenceiq.cloudbreak.api.endpoint.v4.stacks.request.tags.upgrade.UpgradeV4Request;\n+import com.sequenceiq.cloudbreak.api.endpoint.v4.stacks.response.image.ImageComponentVersions;\n+import com.sequenceiq.cloudbreak.api.endpoint.v4.stacks.response.image.ImageInfoV4Response;\n+import com.sequenceiq.cloudbreak.exception.BadRequestException;\n+\n+@Component\n+public class DistroxUpgradeImageSelector {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(DistroxUpgradeImageSelector.class);\n+\n+    public ImageInfoV4Response determineImageId(UpgradeV4Request request, List<ImageInfoV4Response> upgradeCandidates) {\n+        Optional<ImageInfoV4Response> image = Optional.empty();\n+        if (Objects.isNull(request) || request.isEmpty() || Boolean.TRUE.equals(request.getLockComponents())) {\n+            image = selectLatestImageFromCandidates(upgradeCandidates);\n+        } else if (StringUtils.isNotEmpty(request.getImageId())) {\n+            image = selectRequestedImage(request, upgradeCandidates);\n+        } else if (StringUtils.isNotEmpty(request.getRuntime())) {\n+            image = selectLastestImageByRuntime(upgradeCandidates, request.getRuntime());\n+        }\n+        return image.orElseThrow(() -> new BadRequestException(String.format(\"Invalid upgrade request, please validate the contents: %s\", request)));\n+    }\n+\n+    private Optional<ImageInfoV4Response> selectLastestImageByRuntime(List<ImageInfoV4Response> upgradeCandidates, String runtime) {\n+        List<ImageInfoV4Response> imagesWithMatchingRuntime = upgradeCandidates.stream().filter(\n+                imageInfoV4Response -> runtime.equals(imageInfoV4Response.getComponentVersions().getCdp())).collect(Collectors.toList());\n+        validateThereIsMatchingRuntime(upgradeCandidates, imagesWithMatchingRuntime, runtime);\n+        ImageInfoV4Response imageInfoV4Response = imagesWithMatchingRuntime.stream().max(ImageInfoV4Response.creationBasedComparator()).orElseThrow();\n+        LOGGER.debug(\"Chosen image {} for {} runtime specified in the request\", imageInfoV4Response, runtime);\n+        return Optional.of(imageInfoV4Response);\n+    }\n+\n+    private void validateThereIsMatchingRuntime(List<ImageInfoV4Response> upgradeCandidates, List<ImageInfoV4Response> imagesWithMatchingRuntime,\n+            String runtime) {\n+        boolean hasNoCompatbileImageWithRuntime = imagesWithMatchingRuntime.isEmpty();\n+        if (hasNoCompatbileImageWithRuntime) {\n+            String availableRuntimes = collectAvailableRuntimes(upgradeCandidates);\n+            if (StringUtils.isEmpty(availableRuntimes)) {\n+                throw new BadRequestException(String.format(\"There is no image eligible for the cluster upgrade with runtime: %s.\", runtime));\n+            } else {\n+                throw new BadRequestException(String.format(\"There is no image eligible for the cluster upgrade with runtime: %s. \"\n+                        + \"Please choose a runtime from the following: %s\", runtime, availableRuntimes));\n+            }\n+        }\n+    }\n+\n+    private String collectAvailableRuntimes(List<ImageInfoV4Response> upgradeCandidates) {\n+        return upgradeCandidates.stream()\n+                .map(ImageInfoV4Response::getComponentVersions)\n+                .map(ImageComponentVersions::getCdp)\n+                .distinct()\n+                .collect(Collectors.joining(\",\"));\n+    }\n+\n+    private Optional<ImageInfoV4Response> selectRequestedImage(UpgradeV4Request request, List<ImageInfoV4Response> upgradeCandidates) {\n+        Optional<ImageInfoV4Response> requestedImage = upgradeCandidates.stream()\n+                .filter(candidate -> request.getImageId().equals(candidate.getImageId()))\n+                .findFirst();\n+        validateImageIsPresent(upgradeCandidates, requestedImage);\n+        LOGGER.debug(\"Chosen image {} as it was specified in the request\", requestedImage);\n+        return requestedImage;\n+    }\n+\n+    private Optional<ImageInfoV4Response> selectLatestImageFromCandidates(List<ImageInfoV4Response> upgradeCandidates) {\n+        ImageInfoV4Response imageInfoV4Response = upgradeCandidates.stream().max(ImageInfoV4Response.creationBasedComparator()).orElseThrow();\n+        LOGGER.debug(\"Choosing latest image {} as either upgrade request is empty or lockComponents is true\", imageInfoV4Response);\n+        return Optional.of(imageInfoV4Response);\n+    }\n+\n+    private void validateImageIsPresent(List<ImageInfoV4Response> upgradeCandidates, Optional<ImageInfoV4Response> requestedImage) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "06a8142dc207f0571f510a9198346510b3ae2e0d"}, "originalPosition": 81}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTYxODI3Mg==", "bodyText": "orElseThrow() could be omitted here, too", "url": "https://github.com/hortonworks/cloudbreak/pull/9481#discussion_r529618272", "createdAt": "2020-11-24T15:09:37Z", "author": {"login": "pdarvasi"}, "path": "core/src/main/java/com/sequenceiq/distrox/v1/distrox/service/upgrade/DistroxUpgradeImageSelector.java", "diffHunk": "@@ -0,0 +1,88 @@\n+package com.sequenceiq.distrox.v1.distrox.service.upgrade;\n+\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+\n+import org.apache.commons.lang3.StringUtils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.stereotype.Component;\n+\n+import com.sequenceiq.cloudbreak.api.endpoint.v4.stacks.request.tags.upgrade.UpgradeV4Request;\n+import com.sequenceiq.cloudbreak.api.endpoint.v4.stacks.response.image.ImageComponentVersions;\n+import com.sequenceiq.cloudbreak.api.endpoint.v4.stacks.response.image.ImageInfoV4Response;\n+import com.sequenceiq.cloudbreak.exception.BadRequestException;\n+\n+@Component\n+public class DistroxUpgradeImageSelector {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(DistroxUpgradeImageSelector.class);\n+\n+    public ImageInfoV4Response determineImageId(UpgradeV4Request request, List<ImageInfoV4Response> upgradeCandidates) {\n+        Optional<ImageInfoV4Response> image = Optional.empty();\n+        if (Objects.isNull(request) || request.isEmpty() || Boolean.TRUE.equals(request.getLockComponents())) {\n+            image = selectLatestImageFromCandidates(upgradeCandidates);\n+        } else if (StringUtils.isNotEmpty(request.getImageId())) {\n+            image = selectRequestedImage(request, upgradeCandidates);\n+        } else if (StringUtils.isNotEmpty(request.getRuntime())) {\n+            image = selectLastestImageByRuntime(upgradeCandidates, request.getRuntime());\n+        }\n+        return image.orElseThrow(() -> new BadRequestException(String.format(\"Invalid upgrade request, please validate the contents: %s\", request)));\n+    }\n+\n+    private Optional<ImageInfoV4Response> selectLastestImageByRuntime(List<ImageInfoV4Response> upgradeCandidates, String runtime) {\n+        List<ImageInfoV4Response> imagesWithMatchingRuntime = upgradeCandidates.stream().filter(\n+                imageInfoV4Response -> runtime.equals(imageInfoV4Response.getComponentVersions().getCdp())).collect(Collectors.toList());\n+        validateThereIsMatchingRuntime(upgradeCandidates, imagesWithMatchingRuntime, runtime);\n+        ImageInfoV4Response imageInfoV4Response = imagesWithMatchingRuntime.stream().max(ImageInfoV4Response.creationBasedComparator()).orElseThrow();\n+        LOGGER.debug(\"Chosen image {} for {} runtime specified in the request\", imageInfoV4Response, runtime);\n+        return Optional.of(imageInfoV4Response);\n+    }\n+\n+    private void validateThereIsMatchingRuntime(List<ImageInfoV4Response> upgradeCandidates, List<ImageInfoV4Response> imagesWithMatchingRuntime,\n+            String runtime) {\n+        boolean hasNoCompatbileImageWithRuntime = imagesWithMatchingRuntime.isEmpty();\n+        if (hasNoCompatbileImageWithRuntime) {\n+            String availableRuntimes = collectAvailableRuntimes(upgradeCandidates);\n+            if (StringUtils.isEmpty(availableRuntimes)) {\n+                throw new BadRequestException(String.format(\"There is no image eligible for the cluster upgrade with runtime: %s.\", runtime));\n+            } else {\n+                throw new BadRequestException(String.format(\"There is no image eligible for the cluster upgrade with runtime: %s. \"\n+                        + \"Please choose a runtime from the following: %s\", runtime, availableRuntimes));\n+            }\n+        }\n+    }\n+\n+    private String collectAvailableRuntimes(List<ImageInfoV4Response> upgradeCandidates) {\n+        return upgradeCandidates.stream()\n+                .map(ImageInfoV4Response::getComponentVersions)\n+                .map(ImageComponentVersions::getCdp)\n+                .distinct()\n+                .collect(Collectors.joining(\",\"));\n+    }\n+\n+    private Optional<ImageInfoV4Response> selectRequestedImage(UpgradeV4Request request, List<ImageInfoV4Response> upgradeCandidates) {\n+        Optional<ImageInfoV4Response> requestedImage = upgradeCandidates.stream()\n+                .filter(candidate -> request.getImageId().equals(candidate.getImageId()))\n+                .findFirst();\n+        validateImageIsPresent(upgradeCandidates, requestedImage);\n+        LOGGER.debug(\"Chosen image {} as it was specified in the request\", requestedImage);\n+        return requestedImage;\n+    }\n+\n+    private Optional<ImageInfoV4Response> selectLatestImageFromCandidates(List<ImageInfoV4Response> upgradeCandidates) {\n+        ImageInfoV4Response imageInfoV4Response = upgradeCandidates.stream().max(ImageInfoV4Response.creationBasedComparator()).orElseThrow();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "06a8142dc207f0571f510a9198346510b3ae2e0d"}, "originalPosition": 76}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTY0NzE3Mg==", "bodyText": "minor: these 2 could be final", "url": "https://github.com/hortonworks/cloudbreak/pull/9481#discussion_r529647172", "createdAt": "2020-11-24T15:36:42Z", "author": {"login": "pdarvasi"}, "path": "core/src/test/java/com/sequenceiq/cloudbreak/core/flow2/chain/UpgradeDistroxFlowEventChainFactoryTest.java", "diffHunk": "@@ -0,0 +1,69 @@\n+package com.sequenceiq.cloudbreak.core.flow2.chain;\n+\n+import static com.sequenceiq.cloudbreak.core.flow2.chain.FlowChainTriggers.STACK_IMAGE_UPDATE_TRIGGER_EVENT;\n+import static com.sequenceiq.cloudbreak.core.flow2.cluster.datalake.upgrade.ClusterUpgradeEvent.CLUSTER_UPGRADE_INIT_EVENT;\n+import static com.sequenceiq.cloudbreak.core.flow2.cluster.salt.update.SaltUpdateEvent.SALT_UPDATE_EVENT;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+import java.util.Queue;\n+\n+import org.junit.jupiter.api.Test;\n+\n+import com.sequenceiq.cloudbreak.common.event.Selectable;\n+import com.sequenceiq.cloudbreak.core.flow2.event.DatalakeClusterUpgradeTriggerEvent;\n+import com.sequenceiq.cloudbreak.core.flow2.event.DistroxUpgradeTriggerEvent;\n+import com.sequenceiq.cloudbreak.core.flow2.event.StackImageUpdateTriggerEvent;\n+import com.sequenceiq.cloudbreak.reactor.api.event.StackEvent;\n+import com.sequenceiq.cloudbreak.service.image.ImageChangeDto;\n+\n+class UpgradeDistroxFlowEventChainFactoryTest {\n+\n+    private static final long STACK_ID = 1L;\n+\n+    private UpgradeDistroxFlowEventChainFactory underTest = new UpgradeDistroxFlowEventChainFactory();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "06a8142dc207f0571f510a9198346510b3ae2e0d"}, "originalPosition": 24}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTY0OTc5Ng==", "bodyText": "minor: this could be final", "url": "https://github.com/hortonworks/cloudbreak/pull/9481#discussion_r529649796", "createdAt": "2020-11-24T15:38:34Z", "author": {"login": "pdarvasi"}, "path": "core/src/test/java/com/sequenceiq/cloudbreak/service/StackCommonServiceTest.java", "diffHunk": "@@ -0,0 +1,89 @@\n+package com.sequenceiq.cloudbreak.service;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertNull;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.Mockito.when;\n+\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+import org.mockito.InjectMocks;\n+import org.mockito.Mock;\n+import org.mockito.junit.jupiter.MockitoExtension;\n+\n+import com.sequenceiq.cloudbreak.api.endpoint.v4.dto.NameOrCrn;\n+import com.sequenceiq.cloudbreak.api.endpoint.v4.stacks.request.StackImageChangeV4Request;\n+import com.sequenceiq.cloudbreak.domain.ImageCatalog;\n+import com.sequenceiq.cloudbreak.service.image.ImageCatalogService;\n+import com.sequenceiq.cloudbreak.service.image.ImageChangeDto;\n+import com.sequenceiq.cloudbreak.service.stack.StackService;\n+import com.sequenceiq.cloudbreak.service.stack.flow.StackOperationService;\n+import com.sequenceiq.flow.api.model.FlowIdentifier;\n+import com.sequenceiq.flow.api.model.FlowType;\n+\n+@ExtendWith(MockitoExtension.class)\n+class StackCommonServiceTest {\n+\n+    private static final long WORKSPACE_ID = 1L;\n+\n+    private static final long STACK_ID = 2L;\n+\n+    @Mock\n+    private ImageCatalogService imageCatalogService;\n+\n+    @Mock\n+    private StackService stackService;\n+\n+    @Mock\n+    private StackOperationService stackOperationService;\n+\n+    @InjectMocks\n+    private StackCommonService underTest;\n+\n+    private NameOrCrn stackName  = NameOrCrn.ofName(\"stackName\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "06a8142dc207f0571f510a9198346510b3ae2e0d"}, "originalPosition": 43}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTY1MDE0MQ==", "bodyText": "typo: catolog", "url": "https://github.com/hortonworks/cloudbreak/pull/9481#discussion_r529650141", "createdAt": "2020-11-24T15:38:47Z", "author": {"login": "pdarvasi"}, "path": "core/src/test/java/com/sequenceiq/cloudbreak/service/StackCommonServiceTest.java", "diffHunk": "@@ -0,0 +1,89 @@\n+package com.sequenceiq.cloudbreak.service;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertNull;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.Mockito.when;\n+\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+import org.mockito.InjectMocks;\n+import org.mockito.Mock;\n+import org.mockito.junit.jupiter.MockitoExtension;\n+\n+import com.sequenceiq.cloudbreak.api.endpoint.v4.dto.NameOrCrn;\n+import com.sequenceiq.cloudbreak.api.endpoint.v4.stacks.request.StackImageChangeV4Request;\n+import com.sequenceiq.cloudbreak.domain.ImageCatalog;\n+import com.sequenceiq.cloudbreak.service.image.ImageCatalogService;\n+import com.sequenceiq.cloudbreak.service.image.ImageChangeDto;\n+import com.sequenceiq.cloudbreak.service.stack.StackService;\n+import com.sequenceiq.cloudbreak.service.stack.flow.StackOperationService;\n+import com.sequenceiq.flow.api.model.FlowIdentifier;\n+import com.sequenceiq.flow.api.model.FlowType;\n+\n+@ExtendWith(MockitoExtension.class)\n+class StackCommonServiceTest {\n+\n+    private static final long WORKSPACE_ID = 1L;\n+\n+    private static final long STACK_ID = 2L;\n+\n+    @Mock\n+    private ImageCatalogService imageCatalogService;\n+\n+    @Mock\n+    private StackService stackService;\n+\n+    @Mock\n+    private StackOperationService stackOperationService;\n+\n+    @InjectMocks\n+    private StackCommonService underTest;\n+\n+    private NameOrCrn stackName  = NameOrCrn.ofName(\"stackName\");\n+\n+    @Test\n+    public void testCreateImageChangeDtoWithCatalog() {\n+        StackImageChangeV4Request stackImageChangeRequest = new StackImageChangeV4Request();\n+        stackImageChangeRequest.setImageCatalogName(\"catalog\");\n+        stackImageChangeRequest.setImageId(\"imageId\");\n+        ImageCatalog catalog = new ImageCatalog();\n+        catalog.setName(stackImageChangeRequest.getImageCatalogName());\n+        catalog.setImageCatalogUrl(\"catologUrl\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "06a8142dc207f0571f510a9198346510b3ae2e0d"}, "originalPosition": 52}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTY1NDg4NA==", "bodyText": "this could be final", "url": "https://github.com/hortonworks/cloudbreak/pull/9481#discussion_r529654884", "createdAt": "2020-11-24T15:42:02Z", "author": {"login": "pdarvasi"}, "path": "core/src/test/java/com/sequenceiq/distrox/v1/distrox/converter/UpgradeConverterTest.java", "diffHunk": "@@ -0,0 +1,73 @@\n+package com.sequenceiq.distrox.v1.distrox.converter;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+\n+import java.util.List;\n+\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.EnumSource;\n+\n+import com.sequenceiq.cloudbreak.api.endpoint.v4.stacks.request.tags.upgrade.UpgradeV4Request;\n+import com.sequenceiq.cloudbreak.api.endpoint.v4.stacks.response.image.ImageInfoV4Response;\n+import com.sequenceiq.cloudbreak.api.endpoint.v4.stacks.response.upgrade.UpgradeV4Response;\n+import com.sequenceiq.common.model.UpgradeShowAvailableImages;\n+import com.sequenceiq.distrox.api.v1.distrox.model.upgrade.DistroxUpgradeReplaceVms;\n+import com.sequenceiq.distrox.api.v1.distrox.model.upgrade.DistroxUpgradeShowAvailableImages;\n+import com.sequenceiq.distrox.api.v1.distrox.model.upgrade.DistroxUpgradeV1Request;\n+import com.sequenceiq.distrox.api.v1.distrox.model.upgrade.DistroxUpgradeV1Response;\n+import com.sequenceiq.flow.api.model.FlowIdentifier;\n+import com.sequenceiq.flow.api.model.FlowType;\n+\n+class UpgradeConverterTest {\n+\n+    private UpgradeConverter underTest = new UpgradeConverter();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "06a8142dc207f0571f510a9198346510b3ae2e0d"}, "originalPosition": 24}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTY1ODIwOQ==", "bodyText": "this could be local variable in method", "url": "https://github.com/hortonworks/cloudbreak/pull/9481#discussion_r529658209", "createdAt": "2020-11-24T15:44:21Z", "author": {"login": "pdarvasi"}, "path": "core/src/test/java/com/sequenceiq/distrox/v1/distrox/service/upgrade/ComponentLockerTest.java", "diffHunk": "@@ -0,0 +1,99 @@\n+package com.sequenceiq.distrox.v1.distrox.service.upgrade;\n+\n+import static com.sequenceiq.distrox.api.v1.distrox.model.upgrade.DistroxUpgradeShowAvailableImages.LATEST_ONLY;\n+import static com.sequenceiq.distrox.api.v1.distrox.model.upgrade.DistroxUpgradeShowAvailableImages.SHOW;\n+import static java.lang.Boolean.FALSE;\n+import static java.lang.Boolean.TRUE;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.mockito.Mockito.when;\n+\n+import org.junit.jupiter.api.extension.ExtendWith;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.MethodSource;\n+import org.mockito.InjectMocks;\n+import org.mockito.Mock;\n+import org.mockito.junit.jupiter.MockitoExtension;\n+import org.mockito.junit.jupiter.MockitoSettings;\n+import org.mockito.quality.Strictness;\n+\n+import com.sequenceiq.distrox.api.v1.distrox.model.upgrade.DistroxUpgradeShowAvailableImages;\n+import com.sequenceiq.distrox.api.v1.distrox.model.upgrade.DistroxUpgradeV1Request;\n+\n+@ExtendWith(MockitoExtension.class)\n+class ComponentLockerTest {\n+\n+    private static final String USER_CRN = \"userCrn\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "06a8142dc207f0571f510a9198346510b3ae2e0d"}, "originalPosition": 25}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTY2MTY1NA==", "bodyText": ":D", "url": "https://github.com/hortonworks/cloudbreak/pull/9481#discussion_r529661654", "createdAt": "2020-11-24T15:46:47Z", "author": {"login": "pdarvasi"}, "path": "core/src/test/java/com/sequenceiq/distrox/v1/distrox/service/upgrade/DistroxUpgradeAvailabilityServiceTest.java", "diffHunk": "@@ -0,0 +1,145 @@\n+package com.sequenceiq.distrox.v1.distrox.service.upgrade;\n+\n+import static com.sequenceiq.cloudbreak.auth.ThreadBasedUserCrnProvider.INTERNAL_ACTOR_CRN;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.mockito.Mockito.lenient;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+\n+import java.util.List;\n+\n+import org.junit.jupiter.api.Assertions;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+import org.mockito.InjectMocks;\n+import org.mockito.Mock;\n+import org.mockito.junit.jupiter.MockitoExtension;\n+\n+import com.sequenceiq.cloudbreak.api.endpoint.v4.dto.NameOrCrn;\n+import com.sequenceiq.cloudbreak.api.endpoint.v4.stacks.request.tags.upgrade.UpgradeV4Request;\n+import com.sequenceiq.cloudbreak.api.endpoint.v4.stacks.response.image.ImageComponentVersions;\n+import com.sequenceiq.cloudbreak.api.endpoint.v4.stacks.response.image.ImageInfoV4Response;\n+import com.sequenceiq.cloudbreak.api.endpoint.v4.stacks.response.upgrade.UpgradeV4Response;\n+import com.sequenceiq.cloudbreak.auth.altus.EntitlementService;\n+import com.sequenceiq.cloudbreak.exception.BadRequestException;\n+import com.sequenceiq.common.model.UpgradeShowAvailableImages;\n+import com.sequenceiq.distrox.v1.distrox.StackOperations;\n+\n+@ExtendWith(MockitoExtension.class)\n+class DistroxUpgradeAvailabilityServiceTest {\n+\n+    private static final String USER_CRN = \"crn:cdp:iam:us-west-1:9d74eee4-1cad-45d7-b645-7ccf9edbb73d:user:f3b8ed82-e712-4f89-bda7-be07183720d3\";\n+\n+    private static final NameOrCrn CLUSTER = NameOrCrn.ofName(\"asdf\");\n+\n+    private static final Long WORKSPACE_ID = 1L;\n+\n+    @Mock\n+    private EntitlementService entitlementService;\n+\n+    @Mock\n+    private StackOperations stackOperations;\n+\n+    @InjectMocks\n+    private DistroxUpgradeAvailabilityService underTest;\n+\n+    @BeforeEach\n+    public void init() {\n+        lenient().when(entitlementService.datahubRuntimeUpgradeEnabled(INTERNAL_ACTOR_CRN, \"9d74eee4-1cad-45d7-b645-7ccf9edbb73d\")).thenReturn(Boolean.TRUE);\n+    }\n+\n+    @Test\n+    public void testCrnParseException() {\n+        Assertions.assertThrows(BadRequestException.class, () -> underTest.isRuntimeUpgradeEnabled(\"asdf\"));\n+    }\n+\n+    @Test\n+    public void testNullPointerException() {\n+        Assertions.assertThrows(BadRequestException.class, () -> underTest.isRuntimeUpgradeEnabled(null));\n+    }\n+\n+    @Test\n+    public void testEntitlementServiceCalled() {\n+        boolean result = underTest.isRuntimeUpgradeEnabled(USER_CRN);\n+\n+        assertTrue(result);\n+        verify(entitlementService).datahubRuntimeUpgradeEnabled(INTERNAL_ACTOR_CRN, \"9d74eee4-1cad-45d7-b645-7ccf9edbb73d\");\n+    }\n+\n+    @Test\n+    public void testVerifyRuntimeUpgradeEntitlement() {\n+        when(entitlementService.datahubRuntimeUpgradeEnabled(INTERNAL_ACTOR_CRN, \"9d74eee4-1cad-45d7-b645-7ccf9edbb73d\")).thenReturn(Boolean.FALSE);\n+        UpgradeV4Request request = new UpgradeV4Request();\n+\n+        assertThrows(BadRequestException.class, () -> underTest.checkForUpgrade(CLUSTER, WORKSPACE_ID, request, USER_CRN),\n+                \"Runtime upgrade feature is not enabled\");\n+    }\n+\n+    @Test\n+    public void testReturnAllCandidates() {\n+        UpgradeV4Request request = new UpgradeV4Request();\n+        UpgradeV4Response response = new UpgradeV4Response();\n+        response.setUpgradeCandidates(List.of(mock(ImageInfoV4Response.class), mock(ImageInfoV4Response.class)));\n+        when(stackOperations.checkForClusterUpgrade(CLUSTER, WORKSPACE_ID, request)).thenReturn(response);\n+\n+        UpgradeV4Response result = underTest.checkForUpgrade(CLUSTER, WORKSPACE_ID, request, USER_CRN);\n+\n+        assertEquals(response.getUpgradeCandidates(), result.getUpgradeCandidates());\n+    }\n+\n+    @Test\n+    public void testReturnLatestOnlyForDryRun() {\n+        UpgradeV4Request request = new UpgradeV4Request();\n+        request.setDryRun(Boolean.TRUE);\n+        UpgradeV4Response response = new UpgradeV4Response();\n+        ImageInfoV4Response image1 = new ImageInfoV4Response();\n+        image1.setCreated(1L);\n+        ImageInfoV4Response image2 = new ImageInfoV4Response();\n+        image2.setCreated(8L);\n+        ImageInfoV4Response image3 = new ImageInfoV4Response();\n+        image3.setCreated(5L);\n+        response.setUpgradeCandidates(List.of(image1, image2, image3));\n+        when(stackOperations.checkForClusterUpgrade(CLUSTER, WORKSPACE_ID, request)).thenReturn(response);\n+\n+        UpgradeV4Response result = underTest.checkForUpgrade(CLUSTER, WORKSPACE_ID, request, USER_CRN);\n+\n+        assertEquals(1, result.getUpgradeCandidates().size());\n+        assertEquals(8L, result.getUpgradeCandidates().get(0).getCreated());\n+    }\n+\n+    @Test\n+    public void testLatestByRuntime() {\n+        UpgradeV4Request request = new UpgradeV4Request();\n+        request.setShowAvailableImages(UpgradeShowAvailableImages.LATEST_ONLY);\n+        UpgradeV4Response response = new UpgradeV4Response();\n+        ImageInfoV4Response image1 = createImageResponse(2L, \"A\");\n+        ImageInfoV4Response image2 = createImageResponse(8L, \"A\");\n+        ImageInfoV4Response image3 = createImageResponse(6L, \"A\");\n+        ImageInfoV4Response image4 = createImageResponse(1L, \"B\");\n+        ImageInfoV4Response image5 = createImageResponse(4L, \"B\");\n+        ImageInfoV4Response image6 = createImageResponse(3L, \"B\");\n+        ImageInfoV4Response image7 = createImageResponse(9L, \"C\");\n+        ImageInfoV4Response image8 = createImageResponse(8L, \"C\");\n+        ImageInfoV4Response image9 = createImageResponse(6L, \"C\");\n+        response.setUpgradeCandidates(List.of(image1, image2, image3, image4, image5, image6, image7, image8, image9));\n+        when(stackOperations.checkForClusterUpgrade(CLUSTER, WORKSPACE_ID, request)).thenReturn(response);\n+\n+        UpgradeV4Response result = underTest.checkForUpgrade(CLUSTER, WORKSPACE_ID, request, USER_CRN);\n+\n+        assertEquals(3, result.getUpgradeCandidates().size());\n+        assertTrue(result.getUpgradeCandidates().stream().anyMatch(img -> img.getCreated() == 8L && \"A\".equals(img.getComponentVersions().getCdp())));\n+        assertTrue(result.getUpgradeCandidates().stream().anyMatch(img -> img.getCreated() == 4L && \"B\".equals(img.getComponentVersions().getCdp())));\n+        assertTrue(result.getUpgradeCandidates().stream().anyMatch(img -> img.getCreated() == 9L && \"C\".equals(img.getComponentVersions().getCdp())));\n+    }\n+\n+    private ImageInfoV4Response createImageResponse(long creation, String cdp) {\n+        ImageInfoV4Response image = new ImageInfoV4Response();\n+        image.setCreated(creation);\n+        image.setComponentVersions(new ImageComponentVersions(\"dontcare\", \"dontcare\", cdp, \"dontcare\", \"dontcare\", \"dontcare\"));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "06a8142dc207f0571f510a9198346510b3ae2e0d"}, "originalPosition": 142}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTY2MzEyMQ==", "bodyText": "this could be final", "url": "https://github.com/hortonworks/cloudbreak/pull/9481#discussion_r529663121", "createdAt": "2020-11-24T15:47:53Z", "author": {"login": "pdarvasi"}, "path": "core/src/test/java/com/sequenceiq/distrox/v1/distrox/service/upgrade/DistroxUpgradeImageSelectorTest.java", "diffHunk": "@@ -0,0 +1,122 @@\n+package com.sequenceiq.distrox.v1.distrox.service.upgrade;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.when;\n+\n+import java.util.List;\n+\n+import org.junit.jupiter.api.Test;\n+\n+import com.sequenceiq.cloudbreak.api.endpoint.v4.stacks.request.tags.upgrade.UpgradeV4Request;\n+import com.sequenceiq.cloudbreak.api.endpoint.v4.stacks.response.image.ImageComponentVersions;\n+import com.sequenceiq.cloudbreak.api.endpoint.v4.stacks.response.image.ImageInfoV4Response;\n+import com.sequenceiq.cloudbreak.exception.BadRequestException;\n+\n+class DistroxUpgradeImageSelectorTest {\n+\n+    private DistroxUpgradeImageSelector underTest = new DistroxUpgradeImageSelector();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "06a8142dc207f0571f510a9198346510b3ae2e0d"}, "originalPosition": 19}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTY2NTI4MA==", "bodyText": "what about don't care? \ud83d\ude38", "url": "https://github.com/hortonworks/cloudbreak/pull/9481#discussion_r529665280", "createdAt": "2020-11-24T15:49:28Z", "author": {"login": "pdarvasi"}, "path": "core/src/test/java/com/sequenceiq/distrox/v1/distrox/service/upgrade/DistroxUpgradeImageSelectorTest.java", "diffHunk": "@@ -0,0 +1,122 @@\n+package com.sequenceiq.distrox.v1.distrox.service.upgrade;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.when;\n+\n+import java.util.List;\n+\n+import org.junit.jupiter.api.Test;\n+\n+import com.sequenceiq.cloudbreak.api.endpoint.v4.stacks.request.tags.upgrade.UpgradeV4Request;\n+import com.sequenceiq.cloudbreak.api.endpoint.v4.stacks.response.image.ImageComponentVersions;\n+import com.sequenceiq.cloudbreak.api.endpoint.v4.stacks.response.image.ImageInfoV4Response;\n+import com.sequenceiq.cloudbreak.exception.BadRequestException;\n+\n+class DistroxUpgradeImageSelectorTest {\n+\n+    private DistroxUpgradeImageSelector underTest = new DistroxUpgradeImageSelector();\n+\n+    @Test\n+    public void testLatestImageFromCandidatesWhenRequestNull() {\n+        List<ImageInfoV4Response> candidates =\n+                List.of(createImageResponse(\"A\", 1L, \"5\"), createImageResponse(\"B\", 6L, \"3\"), createImageResponse(\"C\", 3L, \"1\"));\n+\n+        ImageInfoV4Response result = underTest.determineImageId(null, candidates);\n+\n+        assertEquals(\"B\", result.getImageId());\n+        assertEquals(\"3\", result.getComponentVersions().getCdp());\n+        assertEquals(6L, result.getCreated());\n+    }\n+\n+    @Test\n+    public void testLatestImageFromCandidatesWhenRequestIsEmpty() {\n+        List<ImageInfoV4Response> candidates =\n+                List.of(createImageResponse(\"A\", 1L, \"5\"), createImageResponse(\"B\", 6L, \"3\"), createImageResponse(\"C\", 3L, \"1\"));\n+        UpgradeV4Request request = mock(UpgradeV4Request.class);\n+        when(request.isEmpty()).thenReturn(Boolean.TRUE);\n+\n+        ImageInfoV4Response result = underTest.determineImageId(request, candidates);\n+\n+        assertEquals(\"B\", result.getImageId());\n+        assertEquals(\"3\", result.getComponentVersions().getCdp());\n+        assertEquals(6L, result.getCreated());\n+    }\n+\n+    @Test\n+    public void testLatestImageFromCandidatesWhenLockComponentsIsTrue() {\n+        List<ImageInfoV4Response> candidates =\n+                List.of(createImageResponse(\"A\", 1L, \"5\"), createImageResponse(\"B\", 6L, \"3\"), createImageResponse(\"C\", 3L, \"1\"));\n+        UpgradeV4Request request = mock(UpgradeV4Request.class);\n+        when(request.getLockComponents()).thenReturn(Boolean.TRUE);\n+\n+        ImageInfoV4Response result = underTest.determineImageId(request, candidates);\n+\n+        assertEquals(\"B\", result.getImageId());\n+        assertEquals(\"3\", result.getComponentVersions().getCdp());\n+        assertEquals(6L, result.getCreated());\n+    }\n+\n+    @Test\n+    public void testSelectedImageByIdFound() {\n+        List<ImageInfoV4Response> candidates =\n+                List.of(createImageResponse(\"A\", 1L, \"5\"), createImageResponse(\"B\", 6L, \"3\"), createImageResponse(\"C\", 3L, \"1\"));\n+        UpgradeV4Request request = new UpgradeV4Request();\n+        request.setImageId(\"C\");\n+\n+        ImageInfoV4Response result = underTest.determineImageId(request, candidates);\n+\n+        assertEquals(\"C\", result.getImageId());\n+        assertEquals(\"1\", result.getComponentVersions().getCdp());\n+        assertEquals(3L, result.getCreated());\n+    }\n+\n+    @Test\n+    public void testSelectedImageByIdNotInCandidates() {\n+        List<ImageInfoV4Response> candidates =\n+                List.of(createImageResponse(\"A\", 1L, \"5\"), createImageResponse(\"B\", 6L, \"3\"), createImageResponse(\"C\", 3L, \"1\"));\n+        UpgradeV4Request request = new UpgradeV4Request();\n+        request.setImageId(\"D\");\n+\n+        assertThrows(BadRequestException.class, () -> underTest.determineImageId(request, candidates));\n+    }\n+\n+    @Test\n+    public void testSelectedImageByRuntimeFound() {\n+        List<ImageInfoV4Response> candidates =\n+                List.of(createImageResponse(\"A\", 1L, \"5\"),\n+                        createImageResponse(\"B\", 6L, \"3\"),\n+                        createImageResponse(\"C\", 3L, \"1\"),\n+                        createImageResponse(\"D\", 8L, \"3\"));\n+        UpgradeV4Request request = new UpgradeV4Request();\n+        request.setRuntime(\"3\");\n+\n+        ImageInfoV4Response result = underTest.determineImageId(request, candidates);\n+\n+        assertEquals(\"D\", result.getImageId());\n+        assertEquals(\"3\", result.getComponentVersions().getCdp());\n+        assertEquals(8L, result.getCreated());\n+    }\n+\n+    @Test\n+    public void testSelectedImageByRuntimeNotFound() {\n+        List<ImageInfoV4Response> candidates =\n+                List.of(createImageResponse(\"A\", 1L, \"5\"),\n+                        createImageResponse(\"B\", 6L, \"3\"),\n+                        createImageResponse(\"C\", 3L, \"1\"),\n+                        createImageResponse(\"D\", 8L, \"3\"));\n+        UpgradeV4Request request = new UpgradeV4Request();\n+        request.setRuntime(\"8\");\n+\n+        assertThrows(BadRequestException.class, () -> underTest.determineImageId(request, candidates));\n+    }\n+\n+    private ImageInfoV4Response createImageResponse(String id, long creation, String cdp) {\n+        ImageInfoV4Response image = new ImageInfoV4Response();\n+        image.setImageId(id);\n+        image.setCreated(creation);\n+        image.setComponentVersions(new ImageComponentVersions(\"a\", \"b\", cdp, \"d\", \"g\", \"a\"));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "06a8142dc207f0571f510a9198346510b3ae2e0d"}, "originalPosition": 119}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTY2NjI5NQ==", "bodyText": "typo: reasion", "url": "https://github.com/hortonworks/cloudbreak/pull/9481#discussion_r529666295", "createdAt": "2020-11-24T15:50:07Z", "author": {"login": "pdarvasi"}, "path": "core/src/test/java/com/sequenceiq/distrox/v1/distrox/service/upgrade/DistroxUpgradeServiceTest.java", "diffHunk": "@@ -0,0 +1,174 @@\n+package com.sequenceiq.distrox.v1.distrox.service.upgrade;\n+\n+import static com.sequenceiq.cloudbreak.auth.ThreadBasedUserCrnProvider.INTERNAL_ACTOR_CRN;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.ArgumentMatchers.eq;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.verifyNoInteractions;\n+import static org.mockito.Mockito.when;\n+\n+import java.util.List;\n+import java.util.Optional;\n+\n+import org.junit.jupiter.api.Assertions;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+import org.mockito.ArgumentCaptor;\n+import org.mockito.InjectMocks;\n+import org.mockito.Mock;\n+import org.mockito.junit.jupiter.MockitoExtension;\n+\n+import com.cloudera.thunderhead.service.usermanagement.UserManagementProto;\n+import com.sequenceiq.cloudbreak.api.endpoint.v4.dto.NameOrCrn;\n+import com.sequenceiq.cloudbreak.api.endpoint.v4.stacks.request.StackImageChangeV4Request;\n+import com.sequenceiq.cloudbreak.api.endpoint.v4.stacks.request.tags.upgrade.UpgradeV4Request;\n+import com.sequenceiq.cloudbreak.api.endpoint.v4.stacks.response.image.ImageInfoV4Response;\n+import com.sequenceiq.cloudbreak.api.endpoint.v4.stacks.response.upgrade.UpgradeV4Response;\n+import com.sequenceiq.cloudbreak.auth.CMLicenseParser;\n+import com.sequenceiq.cloudbreak.auth.JsonCMLicense;\n+import com.sequenceiq.cloudbreak.auth.PaywallAccessChecker;\n+import com.sequenceiq.cloudbreak.auth.altus.EntitlementService;\n+import com.sequenceiq.cloudbreak.auth.altus.GrpcUmsClient;\n+import com.sequenceiq.cloudbreak.core.flow2.service.ReactorFlowManager;\n+import com.sequenceiq.cloudbreak.exception.BadRequestException;\n+import com.sequenceiq.cloudbreak.service.StackCommonService;\n+import com.sequenceiq.cloudbreak.service.image.ImageChangeDto;\n+import com.sequenceiq.cloudbreak.service.stack.StackService;\n+import com.sequenceiq.flow.api.model.FlowIdentifier;\n+import com.sequenceiq.flow.api.model.FlowType;\n+\n+@ExtendWith(MockitoExtension.class)\n+class DistroxUpgradeServiceTest {\n+\n+    private static final String USER_CRN = \"crn:cdp:iam:us-west-1:9d74eee4-1cad-45d7-b645-7ccf9edbb73d:user:f3b8ed82-e712-4f89-bda7-be07183720d3\";\n+\n+    private static final NameOrCrn CLUSTER = NameOrCrn.ofName(\"cluster\");\n+\n+    private static final Long WS_ID = 1L;\n+\n+    private static final Long STACK_ID = 3L;\n+\n+    @Mock\n+    private DistroxUpgradeAvailabilityService upgradeAvailabilityService;\n+\n+    @Mock\n+    private EntitlementService entitlementService;\n+\n+    @Mock\n+    private GrpcUmsClient umsClient;\n+\n+    @Mock\n+    private PaywallAccessChecker paywallAccessChecker;\n+\n+    @Mock\n+    private DistroxUpgradeImageSelector imageSelector;\n+\n+    @Mock\n+    private StackCommonService stackCommonService;\n+\n+    @Mock\n+    private ReactorFlowManager reactorFlowManager;\n+\n+    @Mock\n+    private StackService stackService;\n+\n+    @Mock\n+    private CMLicenseParser cmLicenseParser;\n+\n+    @InjectMocks\n+    private DistroxUpgradeService underTest;\n+\n+    @Test\n+    public void testUpgradeResponseHasReason() {\n+        UpgradeV4Request request = new UpgradeV4Request();\n+        when(upgradeAvailabilityService.checkForUpgrade(CLUSTER, WS_ID, request, USER_CRN)).thenReturn(new UpgradeV4Response(\"reasion\", null));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "06a8142dc207f0571f510a9198346510b3ae2e0d"}, "originalPosition": 87}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTY3NTgxNw==", "bodyText": "minor: extra line", "url": "https://github.com/hortonworks/cloudbreak/pull/9481#discussion_r529675817", "createdAt": "2020-11-24T15:56:44Z", "author": {"login": "pdarvasi"}, "path": "mock-thunderhead/src/test/java/com/sequenceiq/thunderhead/grpc/service/auth/MockUserManagementServiceTest.java", "diffHunk": "@@ -200,6 +200,10 @@ void getAccountTestIncludesFixedEntitlements() {\n                 {\"runtimeUpgradeEnabled false\", \"runtimeUpgradeEnabled\", false, \"CDP_RUNTIME_UPGRADE\", false},\n                 {\"runtimeUpgradeEnabled true\", \"runtimeUpgradeEnabled\", true, \"CDP_RUNTIME_UPGRADE\", true},\n \n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "06a8142dc207f0571f510a9198346510b3ae2e0d"}, "originalPosition": 4}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5a777dddec5f60a0c0838887a6731d2e601a24ca", "author": {"user": {"login": "lacikaaa", "name": "Mihaly Laszlo Molnar"}}, "url": "https://github.com/hortonworks/cloudbreak/commit/5a777dddec5f60a0c0838887a6731d2e601a24ca", "committedDate": "2020-11-25T11:50:00Z", "message": "CB-9639 Introduce the upgrade API to DistroX\n\n- includes a new endpoint for DistroX upgrade\n- depends on the same code az datalake/sdx upgrade\n- datalake service side flow has been replaced with flowchain\n- VM replacement not supported ATM"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "06a8142dc207f0571f510a9198346510b3ae2e0d", "author": {"user": {"login": "lacikaaa", "name": "Mihaly Laszlo Molnar"}}, "url": "https://github.com/hortonworks/cloudbreak/commit/06a8142dc207f0571f510a9198346510b3ae2e0d", "committedDate": "2020-11-24T14:23:34Z", "message": "CB-9639 Introduce the upgrade API to DistroX\n\n- includes a new endpoint for DistroX upgrade\n- depends on the same code az datalake/sdx upgrade\n- datalake service side flow has been replaced with flowchain\n- VM replacement not supported ATM"}, "afterCommit": {"oid": "5a777dddec5f60a0c0838887a6731d2e601a24ca", "author": {"user": {"login": "lacikaaa", "name": "Mihaly Laszlo Molnar"}}, "url": "https://github.com/hortonworks/cloudbreak/commit/5a777dddec5f60a0c0838887a6731d2e601a24ca", "committedDate": "2020-11-25T11:50:00Z", "message": "CB-9639 Introduce the upgrade API to DistroX\n\n- includes a new endpoint for DistroX upgrade\n- depends on the same code az datalake/sdx upgrade\n- datalake service side flow has been replaced with flowchain\n- VM replacement not supported ATM"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2022, "cost": 1, "resetAt": "2021-11-01T14:51:55Z"}}}