{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzk3MDE5NzEw", "number": 7707, "reviewThreads": {"totalCount": 9, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMlQxNToyMDo1NlrODuAO8A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMlQxNTozMzoyNlrODuAlgg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ5NTY0OTEyOnYy", "diffSide": "RIGHT", "path": "core/src/main/java/com/sequenceiq/cloudbreak/service/upgrade/ClusterUpgradeImageFilter.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMlQxNToyMDo1NlrOF_wdqg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wM1QwODozMDoyMlrOGAK6ZA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjM5ODYzNA==", "bodyText": "Wouldn't it be better to aggregate all the validation errors here?", "url": "https://github.com/hortonworks/cloudbreak/pull/7707#discussion_r402398634", "createdAt": "2020-04-02T15:20:56Z", "author": {"login": "pdarvasi"}, "path": "core/src/main/java/com/sequenceiq/cloudbreak/service/upgrade/ClusterUpgradeImageFilter.java", "diffHunk": "@@ -52,71 +46,86 @@ Images filter(List<Image> availableImages, Versions supportedVersions, Image cur\n         return versionBasedImageFilter.getCdhImagesForCbVersion(supportedVersions, availableImages);\n     }\n \n-    private List<Image> filterImages(List<Image> availableImages, Image currentImage, String cloudPlatform) {\n-        // I think the whole logic is broken, since we don't allow an upgrade if we shipped a new parcel extension...\n-        return availableImages.stream()\n+    private ImageFilterResult filterImages(List<Image> availableImages, Image currentImage, String cloudPlatform) {\n+        List<Image> images = availableImages.stream()\n+                .filter(filterCurrentImage(currentImage))\n                 .filter(ignoredCmVersion())\n-                .filter(validateCmVersion(currentImage).or(validateStackVersion(currentImage)))\n+                .filter(validateCmAndStackVersion(currentImage))\n                 .filter(validateCloudPlatform(cloudPlatform))\n                 .filter(validateOsVersion(currentImage))\n-                // We don't necessary need CFM and CSP since only SDX upgrade is supported\n-                //.filter(validateCfmVersion(currentImage))\n-                //.filter(validateCspVersion(currentImage))\n                 .filter(validateSaltVersion(currentImage))\n-                .filter(filterCurrentImage(currentImage))\n                 .collect(Collectors.toList());\n-    }\n \n-    private Predicate<Image> validateOsVersion(Image currentImage) {\n-        return image -> isOsVersionsMatch(currentImage, image);\n+        return new ImageFilterResult(new Images(null, null, null, images, null), getReason(images));\n     }\n \n-    private boolean isOsVersionsMatch(Image currentImage, Image newImage) {\n-        return newImage.getOs().equalsIgnoreCase(currentImage.getOs())\n-                && newImage.getOsType().equalsIgnoreCase(currentImage.getOsType());\n+    private Predicate<Image> filterCurrentImage(Image currentImage) {\n+        return image -> {\n+            boolean result = !image.getUuid().equals(currentImage.getUuid());\n+            setReason(result, \"No other image is available.\");\n+            return result;\n+        };\n     }\n \n     private Predicate<Image> ignoredCmVersion() {\n-        // There are some legacy CM versions that do not follow a proper versioning scheme, we must ignore them\n-        return image -> image.getPackageVersions().get(CM_PACKAGE_KEY) != null &&\n-                !image.getPackageVersions().get(CM_PACKAGE_KEY).contains(IGNORED_CM_VERSION);\n+        return image -> {\n+            boolean result = image.getPackageVersions().get(CM_PACKAGE_KEY) != null\n+                    && !image.getPackageVersions().get(CM_PACKAGE_KEY).contains(IGNORED_CM_VERSION);\n+            setReason(result, \"There are no supported Cloudera Manager or CDP version.\");\n+            return result;\n+        };\n     }\n \n-    private Predicate<Image> validateCmVersion(Image currentImage) {\n-        return image -> permitCmAndSatckUpgrade(currentImage, image, CM_PACKAGE_KEY);\n+    private Predicate<Image> validateCmAndStackVersion(Image currentImage) {\n+        return image -> {\n+            boolean result = permitCmAndSatckUpgrade(currentImage, image, CM_PACKAGE_KEY) || permitCmAndSatckUpgrade(currentImage, image, STACK_PACKAGE_KEY);\n+            setReason(result, \"There are no proper Cloudera Manager or CDP version to upgrade.\");\n+            return result;\n+        };\n     }\n \n-    private Predicate<Image> validateStackVersion(Image currentImage) {\n-        return image -> permitCmAndSatckUpgrade(currentImage, image, STACK_PACKAGE_KEY);\n+    private boolean permitCmAndSatckUpgrade(Image currentImage, Image image, String key) {\n+        return upgradePermissionProvider.permitCmAndSatckUpgrade(currentImage.getPackageVersions().get(STACK_PACKAGE_KEY),\n+                image.getPackageVersions().get(key));\n     }\n \n     private Predicate<Image> validateCloudPlatform(String cloudPlatform) {\n-        return image -> image.getImageSetsByProvider().keySet().stream().anyMatch(key -> key.equalsIgnoreCase(cloudPlatform));\n+        return image -> {\n+            boolean result = image.getImageSetsByProvider().keySet().stream().anyMatch(key -> key.equalsIgnoreCase(cloudPlatform));\n+            if (!result) {\n+                reason = String.format(\"There are no image available for %s cloud platform.\", cloudPlatform);\n+            }\n+            return result;\n+        };\n     }\n \n-    private Predicate<Image> validateCfmVersion(Image currentImage) {\n-        return image -> permitExtensionUpgrade(currentImage, image, CFM_PACKAGE_KEY);\n-    }\n-\n-    private Predicate<Image> validateCspVersion(Image currentImage) {\n-        return image -> permitExtensionUpgrade(currentImage, image, CSP_PACKAGE_KEY);\n+    private Predicate<Image> validateOsVersion(Image currentImage) {\n+        return image -> {\n+            boolean result = isOsVersionsMatch(currentImage, image);\n+            setReason(result, \"There are no other image with the same OS version.\");\n+            return result;\n+        };\n     }\n \n-    private boolean permitCmAndSatckUpgrade(Image currentImage, Image image, String key) {\n-        return upgradePermissionProvider.permitCmAndSatckUpgrade(currentImage.getPackageVersions().get(STACK_PACKAGE_KEY),\n-                image.getPackageVersions().get(key));\n+    private boolean isOsVersionsMatch(Image currentImage, Image newImage) {\n+        return newImage.getOs().equalsIgnoreCase(currentImage.getOs()) && newImage.getOsType().equalsIgnoreCase(currentImage.getOsType());\n     }\n \n-    private boolean permitExtensionUpgrade(Image currentImage, Image image, String key) {\n-        return upgradePermissionProvider.permitExtensionUpgrade(currentImage.getPackageVersions().get(STACK_PACKAGE_KEY),\n-                image.getPackageVersions().get(key));\n+    private Predicate<Image> validateSaltVersion(Image currentImage) {\n+        return image -> {\n+            boolean result = image.getPackageVersions().get(SALT_PACKAGE_KEY).equals(currentImage.getPackageVersions().get(SALT_PACKAGE_KEY));\n+            setReason(result, \"There are no other image with the same salt version.\");\n+            return result;\n+        };\n     }\n \n-    private Predicate<Image> validateSaltVersion(Image currentImage) {\n-        return image -> image.getPackageVersions().get(SALT_PACKAGE_KEY).equals(currentImage.getPackageVersions().get(SALT_PACKAGE_KEY));\n+    private String getReason(List<Image> images) {\n+        return images.isEmpty() ? reason : null;\n     }\n \n-    private Predicate<Image> filterCurrentImage(Image currentImage) {\n-        return image -> !image.getUuid().equals(currentImage.getUuid());\n+    private void setReason(boolean result, String reasonText) {\n+        if (!result) {\n+            reason = reasonText;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "17162f24600d530de95659591965edaa2efdfa0e"}, "originalPosition": 146}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjc4Mjg4MQ==", "bodyText": "You mean we should collect all the validation errors and return them?", "url": "https://github.com/hortonworks/cloudbreak/pull/7707#discussion_r402782881", "createdAt": "2020-04-03T07:21:19Z", "author": {"login": "tiborpopovics"}, "path": "core/src/main/java/com/sequenceiq/cloudbreak/service/upgrade/ClusterUpgradeImageFilter.java", "diffHunk": "@@ -52,71 +46,86 @@ Images filter(List<Image> availableImages, Versions supportedVersions, Image cur\n         return versionBasedImageFilter.getCdhImagesForCbVersion(supportedVersions, availableImages);\n     }\n \n-    private List<Image> filterImages(List<Image> availableImages, Image currentImage, String cloudPlatform) {\n-        // I think the whole logic is broken, since we don't allow an upgrade if we shipped a new parcel extension...\n-        return availableImages.stream()\n+    private ImageFilterResult filterImages(List<Image> availableImages, Image currentImage, String cloudPlatform) {\n+        List<Image> images = availableImages.stream()\n+                .filter(filterCurrentImage(currentImage))\n                 .filter(ignoredCmVersion())\n-                .filter(validateCmVersion(currentImage).or(validateStackVersion(currentImage)))\n+                .filter(validateCmAndStackVersion(currentImage))\n                 .filter(validateCloudPlatform(cloudPlatform))\n                 .filter(validateOsVersion(currentImage))\n-                // We don't necessary need CFM and CSP since only SDX upgrade is supported\n-                //.filter(validateCfmVersion(currentImage))\n-                //.filter(validateCspVersion(currentImage))\n                 .filter(validateSaltVersion(currentImage))\n-                .filter(filterCurrentImage(currentImage))\n                 .collect(Collectors.toList());\n-    }\n \n-    private Predicate<Image> validateOsVersion(Image currentImage) {\n-        return image -> isOsVersionsMatch(currentImage, image);\n+        return new ImageFilterResult(new Images(null, null, null, images, null), getReason(images));\n     }\n \n-    private boolean isOsVersionsMatch(Image currentImage, Image newImage) {\n-        return newImage.getOs().equalsIgnoreCase(currentImage.getOs())\n-                && newImage.getOsType().equalsIgnoreCase(currentImage.getOsType());\n+    private Predicate<Image> filterCurrentImage(Image currentImage) {\n+        return image -> {\n+            boolean result = !image.getUuid().equals(currentImage.getUuid());\n+            setReason(result, \"No other image is available.\");\n+            return result;\n+        };\n     }\n \n     private Predicate<Image> ignoredCmVersion() {\n-        // There are some legacy CM versions that do not follow a proper versioning scheme, we must ignore them\n-        return image -> image.getPackageVersions().get(CM_PACKAGE_KEY) != null &&\n-                !image.getPackageVersions().get(CM_PACKAGE_KEY).contains(IGNORED_CM_VERSION);\n+        return image -> {\n+            boolean result = image.getPackageVersions().get(CM_PACKAGE_KEY) != null\n+                    && !image.getPackageVersions().get(CM_PACKAGE_KEY).contains(IGNORED_CM_VERSION);\n+            setReason(result, \"There are no supported Cloudera Manager or CDP version.\");\n+            return result;\n+        };\n     }\n \n-    private Predicate<Image> validateCmVersion(Image currentImage) {\n-        return image -> permitCmAndSatckUpgrade(currentImage, image, CM_PACKAGE_KEY);\n+    private Predicate<Image> validateCmAndStackVersion(Image currentImage) {\n+        return image -> {\n+            boolean result = permitCmAndSatckUpgrade(currentImage, image, CM_PACKAGE_KEY) || permitCmAndSatckUpgrade(currentImage, image, STACK_PACKAGE_KEY);\n+            setReason(result, \"There are no proper Cloudera Manager or CDP version to upgrade.\");\n+            return result;\n+        };\n     }\n \n-    private Predicate<Image> validateStackVersion(Image currentImage) {\n-        return image -> permitCmAndSatckUpgrade(currentImage, image, STACK_PACKAGE_KEY);\n+    private boolean permitCmAndSatckUpgrade(Image currentImage, Image image, String key) {\n+        return upgradePermissionProvider.permitCmAndSatckUpgrade(currentImage.getPackageVersions().get(STACK_PACKAGE_KEY),\n+                image.getPackageVersions().get(key));\n     }\n \n     private Predicate<Image> validateCloudPlatform(String cloudPlatform) {\n-        return image -> image.getImageSetsByProvider().keySet().stream().anyMatch(key -> key.equalsIgnoreCase(cloudPlatform));\n+        return image -> {\n+            boolean result = image.getImageSetsByProvider().keySet().stream().anyMatch(key -> key.equalsIgnoreCase(cloudPlatform));\n+            if (!result) {\n+                reason = String.format(\"There are no image available for %s cloud platform.\", cloudPlatform);\n+            }\n+            return result;\n+        };\n     }\n \n-    private Predicate<Image> validateCfmVersion(Image currentImage) {\n-        return image -> permitExtensionUpgrade(currentImage, image, CFM_PACKAGE_KEY);\n-    }\n-\n-    private Predicate<Image> validateCspVersion(Image currentImage) {\n-        return image -> permitExtensionUpgrade(currentImage, image, CSP_PACKAGE_KEY);\n+    private Predicate<Image> validateOsVersion(Image currentImage) {\n+        return image -> {\n+            boolean result = isOsVersionsMatch(currentImage, image);\n+            setReason(result, \"There are no other image with the same OS version.\");\n+            return result;\n+        };\n     }\n \n-    private boolean permitCmAndSatckUpgrade(Image currentImage, Image image, String key) {\n-        return upgradePermissionProvider.permitCmAndSatckUpgrade(currentImage.getPackageVersions().get(STACK_PACKAGE_KEY),\n-                image.getPackageVersions().get(key));\n+    private boolean isOsVersionsMatch(Image currentImage, Image newImage) {\n+        return newImage.getOs().equalsIgnoreCase(currentImage.getOs()) && newImage.getOsType().equalsIgnoreCase(currentImage.getOsType());\n     }\n \n-    private boolean permitExtensionUpgrade(Image currentImage, Image image, String key) {\n-        return upgradePermissionProvider.permitExtensionUpgrade(currentImage.getPackageVersions().get(STACK_PACKAGE_KEY),\n-                image.getPackageVersions().get(key));\n+    private Predicate<Image> validateSaltVersion(Image currentImage) {\n+        return image -> {\n+            boolean result = image.getPackageVersions().get(SALT_PACKAGE_KEY).equals(currentImage.getPackageVersions().get(SALT_PACKAGE_KEY));\n+            setReason(result, \"There are no other image with the same salt version.\");\n+            return result;\n+        };\n     }\n \n-    private Predicate<Image> validateSaltVersion(Image currentImage) {\n-        return image -> image.getPackageVersions().get(SALT_PACKAGE_KEY).equals(currentImage.getPackageVersions().get(SALT_PACKAGE_KEY));\n+    private String getReason(List<Image> images) {\n+        return images.isEmpty() ? reason : null;\n     }\n \n-    private Predicate<Image> filterCurrentImage(Image currentImage) {\n-        return image -> !image.getUuid().equals(currentImage.getUuid());\n+    private void setReason(boolean result, String reasonText) {\n+        if (!result) {\n+            reason = reasonText;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjM5ODYzNA=="}, "originalCommit": {"oid": "17162f24600d530de95659591965edaa2efdfa0e"}, "originalPosition": 146}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjc4NDgwMA==", "bodyText": "Yes", "url": "https://github.com/hortonworks/cloudbreak/pull/7707#discussion_r402784800", "createdAt": "2020-04-03T07:25:03Z", "author": {"login": "pdarvasi"}, "path": "core/src/main/java/com/sequenceiq/cloudbreak/service/upgrade/ClusterUpgradeImageFilter.java", "diffHunk": "@@ -52,71 +46,86 @@ Images filter(List<Image> availableImages, Versions supportedVersions, Image cur\n         return versionBasedImageFilter.getCdhImagesForCbVersion(supportedVersions, availableImages);\n     }\n \n-    private List<Image> filterImages(List<Image> availableImages, Image currentImage, String cloudPlatform) {\n-        // I think the whole logic is broken, since we don't allow an upgrade if we shipped a new parcel extension...\n-        return availableImages.stream()\n+    private ImageFilterResult filterImages(List<Image> availableImages, Image currentImage, String cloudPlatform) {\n+        List<Image> images = availableImages.stream()\n+                .filter(filterCurrentImage(currentImage))\n                 .filter(ignoredCmVersion())\n-                .filter(validateCmVersion(currentImage).or(validateStackVersion(currentImage)))\n+                .filter(validateCmAndStackVersion(currentImage))\n                 .filter(validateCloudPlatform(cloudPlatform))\n                 .filter(validateOsVersion(currentImage))\n-                // We don't necessary need CFM and CSP since only SDX upgrade is supported\n-                //.filter(validateCfmVersion(currentImage))\n-                //.filter(validateCspVersion(currentImage))\n                 .filter(validateSaltVersion(currentImage))\n-                .filter(filterCurrentImage(currentImage))\n                 .collect(Collectors.toList());\n-    }\n \n-    private Predicate<Image> validateOsVersion(Image currentImage) {\n-        return image -> isOsVersionsMatch(currentImage, image);\n+        return new ImageFilterResult(new Images(null, null, null, images, null), getReason(images));\n     }\n \n-    private boolean isOsVersionsMatch(Image currentImage, Image newImage) {\n-        return newImage.getOs().equalsIgnoreCase(currentImage.getOs())\n-                && newImage.getOsType().equalsIgnoreCase(currentImage.getOsType());\n+    private Predicate<Image> filterCurrentImage(Image currentImage) {\n+        return image -> {\n+            boolean result = !image.getUuid().equals(currentImage.getUuid());\n+            setReason(result, \"No other image is available.\");\n+            return result;\n+        };\n     }\n \n     private Predicate<Image> ignoredCmVersion() {\n-        // There are some legacy CM versions that do not follow a proper versioning scheme, we must ignore them\n-        return image -> image.getPackageVersions().get(CM_PACKAGE_KEY) != null &&\n-                !image.getPackageVersions().get(CM_PACKAGE_KEY).contains(IGNORED_CM_VERSION);\n+        return image -> {\n+            boolean result = image.getPackageVersions().get(CM_PACKAGE_KEY) != null\n+                    && !image.getPackageVersions().get(CM_PACKAGE_KEY).contains(IGNORED_CM_VERSION);\n+            setReason(result, \"There are no supported Cloudera Manager or CDP version.\");\n+            return result;\n+        };\n     }\n \n-    private Predicate<Image> validateCmVersion(Image currentImage) {\n-        return image -> permitCmAndSatckUpgrade(currentImage, image, CM_PACKAGE_KEY);\n+    private Predicate<Image> validateCmAndStackVersion(Image currentImage) {\n+        return image -> {\n+            boolean result = permitCmAndSatckUpgrade(currentImage, image, CM_PACKAGE_KEY) || permitCmAndSatckUpgrade(currentImage, image, STACK_PACKAGE_KEY);\n+            setReason(result, \"There are no proper Cloudera Manager or CDP version to upgrade.\");\n+            return result;\n+        };\n     }\n \n-    private Predicate<Image> validateStackVersion(Image currentImage) {\n-        return image -> permitCmAndSatckUpgrade(currentImage, image, STACK_PACKAGE_KEY);\n+    private boolean permitCmAndSatckUpgrade(Image currentImage, Image image, String key) {\n+        return upgradePermissionProvider.permitCmAndSatckUpgrade(currentImage.getPackageVersions().get(STACK_PACKAGE_KEY),\n+                image.getPackageVersions().get(key));\n     }\n \n     private Predicate<Image> validateCloudPlatform(String cloudPlatform) {\n-        return image -> image.getImageSetsByProvider().keySet().stream().anyMatch(key -> key.equalsIgnoreCase(cloudPlatform));\n+        return image -> {\n+            boolean result = image.getImageSetsByProvider().keySet().stream().anyMatch(key -> key.equalsIgnoreCase(cloudPlatform));\n+            if (!result) {\n+                reason = String.format(\"There are no image available for %s cloud platform.\", cloudPlatform);\n+            }\n+            return result;\n+        };\n     }\n \n-    private Predicate<Image> validateCfmVersion(Image currentImage) {\n-        return image -> permitExtensionUpgrade(currentImage, image, CFM_PACKAGE_KEY);\n-    }\n-\n-    private Predicate<Image> validateCspVersion(Image currentImage) {\n-        return image -> permitExtensionUpgrade(currentImage, image, CSP_PACKAGE_KEY);\n+    private Predicate<Image> validateOsVersion(Image currentImage) {\n+        return image -> {\n+            boolean result = isOsVersionsMatch(currentImage, image);\n+            setReason(result, \"There are no other image with the same OS version.\");\n+            return result;\n+        };\n     }\n \n-    private boolean permitCmAndSatckUpgrade(Image currentImage, Image image, String key) {\n-        return upgradePermissionProvider.permitCmAndSatckUpgrade(currentImage.getPackageVersions().get(STACK_PACKAGE_KEY),\n-                image.getPackageVersions().get(key));\n+    private boolean isOsVersionsMatch(Image currentImage, Image newImage) {\n+        return newImage.getOs().equalsIgnoreCase(currentImage.getOs()) && newImage.getOsType().equalsIgnoreCase(currentImage.getOsType());\n     }\n \n-    private boolean permitExtensionUpgrade(Image currentImage, Image image, String key) {\n-        return upgradePermissionProvider.permitExtensionUpgrade(currentImage.getPackageVersions().get(STACK_PACKAGE_KEY),\n-                image.getPackageVersions().get(key));\n+    private Predicate<Image> validateSaltVersion(Image currentImage) {\n+        return image -> {\n+            boolean result = image.getPackageVersions().get(SALT_PACKAGE_KEY).equals(currentImage.getPackageVersions().get(SALT_PACKAGE_KEY));\n+            setReason(result, \"There are no other image with the same salt version.\");\n+            return result;\n+        };\n     }\n \n-    private Predicate<Image> validateSaltVersion(Image currentImage) {\n-        return image -> image.getPackageVersions().get(SALT_PACKAGE_KEY).equals(currentImage.getPackageVersions().get(SALT_PACKAGE_KEY));\n+    private String getReason(List<Image> images) {\n+        return images.isEmpty() ? reason : null;\n     }\n \n-    private Predicate<Image> filterCurrentImage(Image currentImage) {\n-        return image -> !image.getUuid().equals(currentImage.getUuid());\n+    private void setReason(boolean result, String reasonText) {\n+        if (!result) {\n+            reason = reasonText;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjM5ODYzNA=="}, "originalCommit": {"oid": "17162f24600d530de95659591965edaa2efdfa0e"}, "originalPosition": 146}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjgzMTk3Mg==", "bodyText": "We discussed in other channel.", "url": "https://github.com/hortonworks/cloudbreak/pull/7707#discussion_r402831972", "createdAt": "2020-04-03T08:30:22Z", "author": {"login": "tiborpopovics"}, "path": "core/src/main/java/com/sequenceiq/cloudbreak/service/upgrade/ClusterUpgradeImageFilter.java", "diffHunk": "@@ -52,71 +46,86 @@ Images filter(List<Image> availableImages, Versions supportedVersions, Image cur\n         return versionBasedImageFilter.getCdhImagesForCbVersion(supportedVersions, availableImages);\n     }\n \n-    private List<Image> filterImages(List<Image> availableImages, Image currentImage, String cloudPlatform) {\n-        // I think the whole logic is broken, since we don't allow an upgrade if we shipped a new parcel extension...\n-        return availableImages.stream()\n+    private ImageFilterResult filterImages(List<Image> availableImages, Image currentImage, String cloudPlatform) {\n+        List<Image> images = availableImages.stream()\n+                .filter(filterCurrentImage(currentImage))\n                 .filter(ignoredCmVersion())\n-                .filter(validateCmVersion(currentImage).or(validateStackVersion(currentImage)))\n+                .filter(validateCmAndStackVersion(currentImage))\n                 .filter(validateCloudPlatform(cloudPlatform))\n                 .filter(validateOsVersion(currentImage))\n-                // We don't necessary need CFM and CSP since only SDX upgrade is supported\n-                //.filter(validateCfmVersion(currentImage))\n-                //.filter(validateCspVersion(currentImage))\n                 .filter(validateSaltVersion(currentImage))\n-                .filter(filterCurrentImage(currentImage))\n                 .collect(Collectors.toList());\n-    }\n \n-    private Predicate<Image> validateOsVersion(Image currentImage) {\n-        return image -> isOsVersionsMatch(currentImage, image);\n+        return new ImageFilterResult(new Images(null, null, null, images, null), getReason(images));\n     }\n \n-    private boolean isOsVersionsMatch(Image currentImage, Image newImage) {\n-        return newImage.getOs().equalsIgnoreCase(currentImage.getOs())\n-                && newImage.getOsType().equalsIgnoreCase(currentImage.getOsType());\n+    private Predicate<Image> filterCurrentImage(Image currentImage) {\n+        return image -> {\n+            boolean result = !image.getUuid().equals(currentImage.getUuid());\n+            setReason(result, \"No other image is available.\");\n+            return result;\n+        };\n     }\n \n     private Predicate<Image> ignoredCmVersion() {\n-        // There are some legacy CM versions that do not follow a proper versioning scheme, we must ignore them\n-        return image -> image.getPackageVersions().get(CM_PACKAGE_KEY) != null &&\n-                !image.getPackageVersions().get(CM_PACKAGE_KEY).contains(IGNORED_CM_VERSION);\n+        return image -> {\n+            boolean result = image.getPackageVersions().get(CM_PACKAGE_KEY) != null\n+                    && !image.getPackageVersions().get(CM_PACKAGE_KEY).contains(IGNORED_CM_VERSION);\n+            setReason(result, \"There are no supported Cloudera Manager or CDP version.\");\n+            return result;\n+        };\n     }\n \n-    private Predicate<Image> validateCmVersion(Image currentImage) {\n-        return image -> permitCmAndSatckUpgrade(currentImage, image, CM_PACKAGE_KEY);\n+    private Predicate<Image> validateCmAndStackVersion(Image currentImage) {\n+        return image -> {\n+            boolean result = permitCmAndSatckUpgrade(currentImage, image, CM_PACKAGE_KEY) || permitCmAndSatckUpgrade(currentImage, image, STACK_PACKAGE_KEY);\n+            setReason(result, \"There are no proper Cloudera Manager or CDP version to upgrade.\");\n+            return result;\n+        };\n     }\n \n-    private Predicate<Image> validateStackVersion(Image currentImage) {\n-        return image -> permitCmAndSatckUpgrade(currentImage, image, STACK_PACKAGE_KEY);\n+    private boolean permitCmAndSatckUpgrade(Image currentImage, Image image, String key) {\n+        return upgradePermissionProvider.permitCmAndSatckUpgrade(currentImage.getPackageVersions().get(STACK_PACKAGE_KEY),\n+                image.getPackageVersions().get(key));\n     }\n \n     private Predicate<Image> validateCloudPlatform(String cloudPlatform) {\n-        return image -> image.getImageSetsByProvider().keySet().stream().anyMatch(key -> key.equalsIgnoreCase(cloudPlatform));\n+        return image -> {\n+            boolean result = image.getImageSetsByProvider().keySet().stream().anyMatch(key -> key.equalsIgnoreCase(cloudPlatform));\n+            if (!result) {\n+                reason = String.format(\"There are no image available for %s cloud platform.\", cloudPlatform);\n+            }\n+            return result;\n+        };\n     }\n \n-    private Predicate<Image> validateCfmVersion(Image currentImage) {\n-        return image -> permitExtensionUpgrade(currentImage, image, CFM_PACKAGE_KEY);\n-    }\n-\n-    private Predicate<Image> validateCspVersion(Image currentImage) {\n-        return image -> permitExtensionUpgrade(currentImage, image, CSP_PACKAGE_KEY);\n+    private Predicate<Image> validateOsVersion(Image currentImage) {\n+        return image -> {\n+            boolean result = isOsVersionsMatch(currentImage, image);\n+            setReason(result, \"There are no other image with the same OS version.\");\n+            return result;\n+        };\n     }\n \n-    private boolean permitCmAndSatckUpgrade(Image currentImage, Image image, String key) {\n-        return upgradePermissionProvider.permitCmAndSatckUpgrade(currentImage.getPackageVersions().get(STACK_PACKAGE_KEY),\n-                image.getPackageVersions().get(key));\n+    private boolean isOsVersionsMatch(Image currentImage, Image newImage) {\n+        return newImage.getOs().equalsIgnoreCase(currentImage.getOs()) && newImage.getOsType().equalsIgnoreCase(currentImage.getOsType());\n     }\n \n-    private boolean permitExtensionUpgrade(Image currentImage, Image image, String key) {\n-        return upgradePermissionProvider.permitExtensionUpgrade(currentImage.getPackageVersions().get(STACK_PACKAGE_KEY),\n-                image.getPackageVersions().get(key));\n+    private Predicate<Image> validateSaltVersion(Image currentImage) {\n+        return image -> {\n+            boolean result = image.getPackageVersions().get(SALT_PACKAGE_KEY).equals(currentImage.getPackageVersions().get(SALT_PACKAGE_KEY));\n+            setReason(result, \"There are no other image with the same salt version.\");\n+            return result;\n+        };\n     }\n \n-    private Predicate<Image> validateSaltVersion(Image currentImage) {\n-        return image -> image.getPackageVersions().get(SALT_PACKAGE_KEY).equals(currentImage.getPackageVersions().get(SALT_PACKAGE_KEY));\n+    private String getReason(List<Image> images) {\n+        return images.isEmpty() ? reason : null;\n     }\n \n-    private Predicate<Image> filterCurrentImage(Image currentImage) {\n-        return image -> !image.getUuid().equals(currentImage.getUuid());\n+    private void setReason(boolean result, String reasonText) {\n+        if (!result) {\n+            reason = reasonText;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjM5ODYzNA=="}, "originalCommit": {"oid": "17162f24600d530de95659591965edaa2efdfa0e"}, "originalPosition": 146}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ5NTY1MjY3OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/com/sequenceiq/cloudbreak/service/upgrade/ClusterUpgradeImageFilter.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMlQxNToyMTo0NlrOF_wgBg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMlQxNToyMTo0NlrOF_wgBg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjM5OTIzOA==", "bodyText": "Typo: images", "url": "https://github.com/hortonworks/cloudbreak/pull/7707#discussion_r402399238", "createdAt": "2020-04-02T15:21:46Z", "author": {"login": "pdarvasi"}, "path": "core/src/main/java/com/sequenceiq/cloudbreak/service/upgrade/ClusterUpgradeImageFilter.java", "diffHunk": "@@ -52,71 +46,86 @@ Images filter(List<Image> availableImages, Versions supportedVersions, Image cur\n         return versionBasedImageFilter.getCdhImagesForCbVersion(supportedVersions, availableImages);\n     }\n \n-    private List<Image> filterImages(List<Image> availableImages, Image currentImage, String cloudPlatform) {\n-        // I think the whole logic is broken, since we don't allow an upgrade if we shipped a new parcel extension...\n-        return availableImages.stream()\n+    private ImageFilterResult filterImages(List<Image> availableImages, Image currentImage, String cloudPlatform) {\n+        List<Image> images = availableImages.stream()\n+                .filter(filterCurrentImage(currentImage))\n                 .filter(ignoredCmVersion())\n-                .filter(validateCmVersion(currentImage).or(validateStackVersion(currentImage)))\n+                .filter(validateCmAndStackVersion(currentImage))\n                 .filter(validateCloudPlatform(cloudPlatform))\n                 .filter(validateOsVersion(currentImage))\n-                // We don't necessary need CFM and CSP since only SDX upgrade is supported\n-                //.filter(validateCfmVersion(currentImage))\n-                //.filter(validateCspVersion(currentImage))\n                 .filter(validateSaltVersion(currentImage))\n-                .filter(filterCurrentImage(currentImage))\n                 .collect(Collectors.toList());\n-    }\n \n-    private Predicate<Image> validateOsVersion(Image currentImage) {\n-        return image -> isOsVersionsMatch(currentImage, image);\n+        return new ImageFilterResult(new Images(null, null, null, images, null), getReason(images));\n     }\n \n-    private boolean isOsVersionsMatch(Image currentImage, Image newImage) {\n-        return newImage.getOs().equalsIgnoreCase(currentImage.getOs())\n-                && newImage.getOsType().equalsIgnoreCase(currentImage.getOsType());\n+    private Predicate<Image> filterCurrentImage(Image currentImage) {\n+        return image -> {\n+            boolean result = !image.getUuid().equals(currentImage.getUuid());\n+            setReason(result, \"No other image is available.\");\n+            return result;\n+        };\n     }\n \n     private Predicate<Image> ignoredCmVersion() {\n-        // There are some legacy CM versions that do not follow a proper versioning scheme, we must ignore them\n-        return image -> image.getPackageVersions().get(CM_PACKAGE_KEY) != null &&\n-                !image.getPackageVersions().get(CM_PACKAGE_KEY).contains(IGNORED_CM_VERSION);\n+        return image -> {\n+            boolean result = image.getPackageVersions().get(CM_PACKAGE_KEY) != null\n+                    && !image.getPackageVersions().get(CM_PACKAGE_KEY).contains(IGNORED_CM_VERSION);\n+            setReason(result, \"There are no supported Cloudera Manager or CDP version.\");\n+            return result;\n+        };\n     }\n \n-    private Predicate<Image> validateCmVersion(Image currentImage) {\n-        return image -> permitCmAndSatckUpgrade(currentImage, image, CM_PACKAGE_KEY);\n+    private Predicate<Image> validateCmAndStackVersion(Image currentImage) {\n+        return image -> {\n+            boolean result = permitCmAndSatckUpgrade(currentImage, image, CM_PACKAGE_KEY) || permitCmAndSatckUpgrade(currentImage, image, STACK_PACKAGE_KEY);\n+            setReason(result, \"There are no proper Cloudera Manager or CDP version to upgrade.\");\n+            return result;\n+        };\n     }\n \n-    private Predicate<Image> validateStackVersion(Image currentImage) {\n-        return image -> permitCmAndSatckUpgrade(currentImage, image, STACK_PACKAGE_KEY);\n+    private boolean permitCmAndSatckUpgrade(Image currentImage, Image image, String key) {\n+        return upgradePermissionProvider.permitCmAndSatckUpgrade(currentImage.getPackageVersions().get(STACK_PACKAGE_KEY),\n+                image.getPackageVersions().get(key));\n     }\n \n     private Predicate<Image> validateCloudPlatform(String cloudPlatform) {\n-        return image -> image.getImageSetsByProvider().keySet().stream().anyMatch(key -> key.equalsIgnoreCase(cloudPlatform));\n+        return image -> {\n+            boolean result = image.getImageSetsByProvider().keySet().stream().anyMatch(key -> key.equalsIgnoreCase(cloudPlatform));\n+            if (!result) {\n+                reason = String.format(\"There are no image available for %s cloud platform.\", cloudPlatform);\n+            }\n+            return result;\n+        };\n     }\n \n-    private Predicate<Image> validateCfmVersion(Image currentImage) {\n-        return image -> permitExtensionUpgrade(currentImage, image, CFM_PACKAGE_KEY);\n-    }\n-\n-    private Predicate<Image> validateCspVersion(Image currentImage) {\n-        return image -> permitExtensionUpgrade(currentImage, image, CSP_PACKAGE_KEY);\n+    private Predicate<Image> validateOsVersion(Image currentImage) {\n+        return image -> {\n+            boolean result = isOsVersionsMatch(currentImage, image);\n+            setReason(result, \"There are no other image with the same OS version.\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "17162f24600d530de95659591965edaa2efdfa0e"}, "originalPosition": 113}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ5NTY1NTUxOnYy", "diffSide": "RIGHT", "path": "core/src/main/java/com/sequenceiq/cloudbreak/service/upgrade/ClusterUpgradeImageFilter.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMlQxNToyMjoyNFrOF_whzQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMlQxNToyMjoyNFrOF_whzQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjM5OTY5Mw==", "bodyText": "Typo: images", "url": "https://github.com/hortonworks/cloudbreak/pull/7707#discussion_r402399693", "createdAt": "2020-04-02T15:22:24Z", "author": {"login": "pdarvasi"}, "path": "core/src/main/java/com/sequenceiq/cloudbreak/service/upgrade/ClusterUpgradeImageFilter.java", "diffHunk": "@@ -52,71 +46,86 @@ Images filter(List<Image> availableImages, Versions supportedVersions, Image cur\n         return versionBasedImageFilter.getCdhImagesForCbVersion(supportedVersions, availableImages);\n     }\n \n-    private List<Image> filterImages(List<Image> availableImages, Image currentImage, String cloudPlatform) {\n-        // I think the whole logic is broken, since we don't allow an upgrade if we shipped a new parcel extension...\n-        return availableImages.stream()\n+    private ImageFilterResult filterImages(List<Image> availableImages, Image currentImage, String cloudPlatform) {\n+        List<Image> images = availableImages.stream()\n+                .filter(filterCurrentImage(currentImage))\n                 .filter(ignoredCmVersion())\n-                .filter(validateCmVersion(currentImage).or(validateStackVersion(currentImage)))\n+                .filter(validateCmAndStackVersion(currentImage))\n                 .filter(validateCloudPlatform(cloudPlatform))\n                 .filter(validateOsVersion(currentImage))\n-                // We don't necessary need CFM and CSP since only SDX upgrade is supported\n-                //.filter(validateCfmVersion(currentImage))\n-                //.filter(validateCspVersion(currentImage))\n                 .filter(validateSaltVersion(currentImage))\n-                .filter(filterCurrentImage(currentImage))\n                 .collect(Collectors.toList());\n-    }\n \n-    private Predicate<Image> validateOsVersion(Image currentImage) {\n-        return image -> isOsVersionsMatch(currentImage, image);\n+        return new ImageFilterResult(new Images(null, null, null, images, null), getReason(images));\n     }\n \n-    private boolean isOsVersionsMatch(Image currentImage, Image newImage) {\n-        return newImage.getOs().equalsIgnoreCase(currentImage.getOs())\n-                && newImage.getOsType().equalsIgnoreCase(currentImage.getOsType());\n+    private Predicate<Image> filterCurrentImage(Image currentImage) {\n+        return image -> {\n+            boolean result = !image.getUuid().equals(currentImage.getUuid());\n+            setReason(result, \"No other image is available.\");\n+            return result;\n+        };\n     }\n \n     private Predicate<Image> ignoredCmVersion() {\n-        // There are some legacy CM versions that do not follow a proper versioning scheme, we must ignore them\n-        return image -> image.getPackageVersions().get(CM_PACKAGE_KEY) != null &&\n-                !image.getPackageVersions().get(CM_PACKAGE_KEY).contains(IGNORED_CM_VERSION);\n+        return image -> {\n+            boolean result = image.getPackageVersions().get(CM_PACKAGE_KEY) != null\n+                    && !image.getPackageVersions().get(CM_PACKAGE_KEY).contains(IGNORED_CM_VERSION);\n+            setReason(result, \"There are no supported Cloudera Manager or CDP version.\");\n+            return result;\n+        };\n     }\n \n-    private Predicate<Image> validateCmVersion(Image currentImage) {\n-        return image -> permitCmAndSatckUpgrade(currentImage, image, CM_PACKAGE_KEY);\n+    private Predicate<Image> validateCmAndStackVersion(Image currentImage) {\n+        return image -> {\n+            boolean result = permitCmAndSatckUpgrade(currentImage, image, CM_PACKAGE_KEY) || permitCmAndSatckUpgrade(currentImage, image, STACK_PACKAGE_KEY);\n+            setReason(result, \"There are no proper Cloudera Manager or CDP version to upgrade.\");\n+            return result;\n+        };\n     }\n \n-    private Predicate<Image> validateStackVersion(Image currentImage) {\n-        return image -> permitCmAndSatckUpgrade(currentImage, image, STACK_PACKAGE_KEY);\n+    private boolean permitCmAndSatckUpgrade(Image currentImage, Image image, String key) {\n+        return upgradePermissionProvider.permitCmAndSatckUpgrade(currentImage.getPackageVersions().get(STACK_PACKAGE_KEY),\n+                image.getPackageVersions().get(key));\n     }\n \n     private Predicate<Image> validateCloudPlatform(String cloudPlatform) {\n-        return image -> image.getImageSetsByProvider().keySet().stream().anyMatch(key -> key.equalsIgnoreCase(cloudPlatform));\n+        return image -> {\n+            boolean result = image.getImageSetsByProvider().keySet().stream().anyMatch(key -> key.equalsIgnoreCase(cloudPlatform));\n+            if (!result) {\n+                reason = String.format(\"There are no image available for %s cloud platform.\", cloudPlatform);\n+            }\n+            return result;\n+        };\n     }\n \n-    private Predicate<Image> validateCfmVersion(Image currentImage) {\n-        return image -> permitExtensionUpgrade(currentImage, image, CFM_PACKAGE_KEY);\n-    }\n-\n-    private Predicate<Image> validateCspVersion(Image currentImage) {\n-        return image -> permitExtensionUpgrade(currentImage, image, CSP_PACKAGE_KEY);\n+    private Predicate<Image> validateOsVersion(Image currentImage) {\n+        return image -> {\n+            boolean result = isOsVersionsMatch(currentImage, image);\n+            setReason(result, \"There are no other image with the same OS version.\");\n+            return result;\n+        };\n     }\n \n-    private boolean permitCmAndSatckUpgrade(Image currentImage, Image image, String key) {\n-        return upgradePermissionProvider.permitCmAndSatckUpgrade(currentImage.getPackageVersions().get(STACK_PACKAGE_KEY),\n-                image.getPackageVersions().get(key));\n+    private boolean isOsVersionsMatch(Image currentImage, Image newImage) {\n+        return newImage.getOs().equalsIgnoreCase(currentImage.getOs()) && newImage.getOsType().equalsIgnoreCase(currentImage.getOsType());\n     }\n \n-    private boolean permitExtensionUpgrade(Image currentImage, Image image, String key) {\n-        return upgradePermissionProvider.permitExtensionUpgrade(currentImage.getPackageVersions().get(STACK_PACKAGE_KEY),\n-                image.getPackageVersions().get(key));\n+    private Predicate<Image> validateSaltVersion(Image currentImage) {\n+        return image -> {\n+            boolean result = image.getPackageVersions().get(SALT_PACKAGE_KEY).equals(currentImage.getPackageVersions().get(SALT_PACKAGE_KEY));\n+            setReason(result, \"There are no other image with the same salt version.\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "17162f24600d530de95659591965edaa2efdfa0e"}, "originalPosition": 131}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ5NTY2MTQ0OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/com/sequenceiq/cloudbreak/service/upgrade/ClusterUpgradeImageFilter.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMlQxNToyMzo0MVrOF_wlqQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wM1QwNzoyNDozM1rOGAIBOQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjQwMDY4MQ==", "bodyText": "This message can be a little misleading, maybe there is other image but the input image id was incorrect?", "url": "https://github.com/hortonworks/cloudbreak/pull/7707#discussion_r402400681", "createdAt": "2020-04-02T15:23:41Z", "author": {"login": "pdarvasi"}, "path": "core/src/main/java/com/sequenceiq/cloudbreak/service/upgrade/ClusterUpgradeImageFilter.java", "diffHunk": "@@ -52,71 +46,86 @@ Images filter(List<Image> availableImages, Versions supportedVersions, Image cur\n         return versionBasedImageFilter.getCdhImagesForCbVersion(supportedVersions, availableImages);\n     }\n \n-    private List<Image> filterImages(List<Image> availableImages, Image currentImage, String cloudPlatform) {\n-        // I think the whole logic is broken, since we don't allow an upgrade if we shipped a new parcel extension...\n-        return availableImages.stream()\n+    private ImageFilterResult filterImages(List<Image> availableImages, Image currentImage, String cloudPlatform) {\n+        List<Image> images = availableImages.stream()\n+                .filter(filterCurrentImage(currentImage))\n                 .filter(ignoredCmVersion())\n-                .filter(validateCmVersion(currentImage).or(validateStackVersion(currentImage)))\n+                .filter(validateCmAndStackVersion(currentImage))\n                 .filter(validateCloudPlatform(cloudPlatform))\n                 .filter(validateOsVersion(currentImage))\n-                // We don't necessary need CFM and CSP since only SDX upgrade is supported\n-                //.filter(validateCfmVersion(currentImage))\n-                //.filter(validateCspVersion(currentImage))\n                 .filter(validateSaltVersion(currentImage))\n-                .filter(filterCurrentImage(currentImage))\n                 .collect(Collectors.toList());\n-    }\n \n-    private Predicate<Image> validateOsVersion(Image currentImage) {\n-        return image -> isOsVersionsMatch(currentImage, image);\n+        return new ImageFilterResult(new Images(null, null, null, images, null), getReason(images));\n     }\n \n-    private boolean isOsVersionsMatch(Image currentImage, Image newImage) {\n-        return newImage.getOs().equalsIgnoreCase(currentImage.getOs())\n-                && newImage.getOsType().equalsIgnoreCase(currentImage.getOsType());\n+    private Predicate<Image> filterCurrentImage(Image currentImage) {\n+        return image -> {\n+            boolean result = !image.getUuid().equals(currentImage.getUuid());\n+            setReason(result, \"No other image is available.\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "17162f24600d530de95659591965edaa2efdfa0e"}, "originalPosition": 59}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjU2NDM3Mg==", "bodyText": "You're right. What about this? \"Only your current image is available with the same package versions.\"", "url": "https://github.com/hortonworks/cloudbreak/pull/7707#discussion_r402564372", "createdAt": "2020-04-02T19:37:52Z", "author": {"login": "tiborpopovics"}, "path": "core/src/main/java/com/sequenceiq/cloudbreak/service/upgrade/ClusterUpgradeImageFilter.java", "diffHunk": "@@ -52,71 +46,86 @@ Images filter(List<Image> availableImages, Versions supportedVersions, Image cur\n         return versionBasedImageFilter.getCdhImagesForCbVersion(supportedVersions, availableImages);\n     }\n \n-    private List<Image> filterImages(List<Image> availableImages, Image currentImage, String cloudPlatform) {\n-        // I think the whole logic is broken, since we don't allow an upgrade if we shipped a new parcel extension...\n-        return availableImages.stream()\n+    private ImageFilterResult filterImages(List<Image> availableImages, Image currentImage, String cloudPlatform) {\n+        List<Image> images = availableImages.stream()\n+                .filter(filterCurrentImage(currentImage))\n                 .filter(ignoredCmVersion())\n-                .filter(validateCmVersion(currentImage).or(validateStackVersion(currentImage)))\n+                .filter(validateCmAndStackVersion(currentImage))\n                 .filter(validateCloudPlatform(cloudPlatform))\n                 .filter(validateOsVersion(currentImage))\n-                // We don't necessary need CFM and CSP since only SDX upgrade is supported\n-                //.filter(validateCfmVersion(currentImage))\n-                //.filter(validateCspVersion(currentImage))\n                 .filter(validateSaltVersion(currentImage))\n-                .filter(filterCurrentImage(currentImage))\n                 .collect(Collectors.toList());\n-    }\n \n-    private Predicate<Image> validateOsVersion(Image currentImage) {\n-        return image -> isOsVersionsMatch(currentImage, image);\n+        return new ImageFilterResult(new Images(null, null, null, images, null), getReason(images));\n     }\n \n-    private boolean isOsVersionsMatch(Image currentImage, Image newImage) {\n-        return newImage.getOs().equalsIgnoreCase(currentImage.getOs())\n-                && newImage.getOsType().equalsIgnoreCase(currentImage.getOsType());\n+    private Predicate<Image> filterCurrentImage(Image currentImage) {\n+        return image -> {\n+            boolean result = !image.getUuid().equals(currentImage.getUuid());\n+            setReason(result, \"No other image is available.\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjQwMDY4MQ=="}, "originalCommit": {"oid": "17162f24600d530de95659591965edaa2efdfa0e"}, "originalPosition": 59}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjc4NDU2OQ==", "bodyText": "Ok, pls. put in the imageId in the response.", "url": "https://github.com/hortonworks/cloudbreak/pull/7707#discussion_r402784569", "createdAt": "2020-04-03T07:24:33Z", "author": {"login": "pdarvasi"}, "path": "core/src/main/java/com/sequenceiq/cloudbreak/service/upgrade/ClusterUpgradeImageFilter.java", "diffHunk": "@@ -52,71 +46,86 @@ Images filter(List<Image> availableImages, Versions supportedVersions, Image cur\n         return versionBasedImageFilter.getCdhImagesForCbVersion(supportedVersions, availableImages);\n     }\n \n-    private List<Image> filterImages(List<Image> availableImages, Image currentImage, String cloudPlatform) {\n-        // I think the whole logic is broken, since we don't allow an upgrade if we shipped a new parcel extension...\n-        return availableImages.stream()\n+    private ImageFilterResult filterImages(List<Image> availableImages, Image currentImage, String cloudPlatform) {\n+        List<Image> images = availableImages.stream()\n+                .filter(filterCurrentImage(currentImage))\n                 .filter(ignoredCmVersion())\n-                .filter(validateCmVersion(currentImage).or(validateStackVersion(currentImage)))\n+                .filter(validateCmAndStackVersion(currentImage))\n                 .filter(validateCloudPlatform(cloudPlatform))\n                 .filter(validateOsVersion(currentImage))\n-                // We don't necessary need CFM and CSP since only SDX upgrade is supported\n-                //.filter(validateCfmVersion(currentImage))\n-                //.filter(validateCspVersion(currentImage))\n                 .filter(validateSaltVersion(currentImage))\n-                .filter(filterCurrentImage(currentImage))\n                 .collect(Collectors.toList());\n-    }\n \n-    private Predicate<Image> validateOsVersion(Image currentImage) {\n-        return image -> isOsVersionsMatch(currentImage, image);\n+        return new ImageFilterResult(new Images(null, null, null, images, null), getReason(images));\n     }\n \n-    private boolean isOsVersionsMatch(Image currentImage, Image newImage) {\n-        return newImage.getOs().equalsIgnoreCase(currentImage.getOs())\n-                && newImage.getOsType().equalsIgnoreCase(currentImage.getOsType());\n+    private Predicate<Image> filterCurrentImage(Image currentImage) {\n+        return image -> {\n+            boolean result = !image.getUuid().equals(currentImage.getUuid());\n+            setReason(result, \"No other image is available.\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjQwMDY4MQ=="}, "originalCommit": {"oid": "17162f24600d530de95659591965edaa2efdfa0e"}, "originalPosition": 59}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ5NTY3MzQwOnYy", "diffSide": "RIGHT", "path": "core/src/main/java/com/sequenceiq/cloudbreak/service/upgrade/ClusterUpgradeImageFilter.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMlQxNToyNjowNVrOF_wtSQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMlQxNToyNjowNVrOF_wtSQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjQwMjYzMw==", "bodyText": "Pls expand image.getPackageVersions().get(CM_PACKAGE_KEY) as a variable and add it to that reason also", "url": "https://github.com/hortonworks/cloudbreak/pull/7707#discussion_r402402633", "createdAt": "2020-04-02T15:26:05Z", "author": {"login": "pdarvasi"}, "path": "core/src/main/java/com/sequenceiq/cloudbreak/service/upgrade/ClusterUpgradeImageFilter.java", "diffHunk": "@@ -52,71 +46,86 @@ Images filter(List<Image> availableImages, Versions supportedVersions, Image cur\n         return versionBasedImageFilter.getCdhImagesForCbVersion(supportedVersions, availableImages);\n     }\n \n-    private List<Image> filterImages(List<Image> availableImages, Image currentImage, String cloudPlatform) {\n-        // I think the whole logic is broken, since we don't allow an upgrade if we shipped a new parcel extension...\n-        return availableImages.stream()\n+    private ImageFilterResult filterImages(List<Image> availableImages, Image currentImage, String cloudPlatform) {\n+        List<Image> images = availableImages.stream()\n+                .filter(filterCurrentImage(currentImage))\n                 .filter(ignoredCmVersion())\n-                .filter(validateCmVersion(currentImage).or(validateStackVersion(currentImage)))\n+                .filter(validateCmAndStackVersion(currentImage))\n                 .filter(validateCloudPlatform(cloudPlatform))\n                 .filter(validateOsVersion(currentImage))\n-                // We don't necessary need CFM and CSP since only SDX upgrade is supported\n-                //.filter(validateCfmVersion(currentImage))\n-                //.filter(validateCspVersion(currentImage))\n                 .filter(validateSaltVersion(currentImage))\n-                .filter(filterCurrentImage(currentImage))\n                 .collect(Collectors.toList());\n-    }\n \n-    private Predicate<Image> validateOsVersion(Image currentImage) {\n-        return image -> isOsVersionsMatch(currentImage, image);\n+        return new ImageFilterResult(new Images(null, null, null, images, null), getReason(images));\n     }\n \n-    private boolean isOsVersionsMatch(Image currentImage, Image newImage) {\n-        return newImage.getOs().equalsIgnoreCase(currentImage.getOs())\n-                && newImage.getOsType().equalsIgnoreCase(currentImage.getOsType());\n+    private Predicate<Image> filterCurrentImage(Image currentImage) {\n+        return image -> {\n+            boolean result = !image.getUuid().equals(currentImage.getUuid());\n+            setReason(result, \"No other image is available.\");\n+            return result;\n+        };\n     }\n \n     private Predicate<Image> ignoredCmVersion() {\n-        // There are some legacy CM versions that do not follow a proper versioning scheme, we must ignore them\n-        return image -> image.getPackageVersions().get(CM_PACKAGE_KEY) != null &&\n-                !image.getPackageVersions().get(CM_PACKAGE_KEY).contains(IGNORED_CM_VERSION);\n+        return image -> {\n+            boolean result = image.getPackageVersions().get(CM_PACKAGE_KEY) != null\n+                    && !image.getPackageVersions().get(CM_PACKAGE_KEY).contains(IGNORED_CM_VERSION);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "17162f24600d530de95659591965edaa2efdfa0e"}, "originalPosition": 70}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ5NTY4MzI2OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/com/sequenceiq/cloudbreak/service/upgrade/ClusterUpgradeImageFilter.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMlQxNToyODoxNlrOF_wzqQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMlQxNToyODoxNlrOF_wzqQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjQwNDI2NQ==", "bodyText": "pls use StringUtils.isNotEmpty()", "url": "https://github.com/hortonworks/cloudbreak/pull/7707#discussion_r402404265", "createdAt": "2020-04-02T15:28:16Z", "author": {"login": "pdarvasi"}, "path": "core/src/main/java/com/sequenceiq/cloudbreak/service/upgrade/ClusterUpgradeImageFilter.java", "diffHunk": "@@ -52,71 +46,86 @@ Images filter(List<Image> availableImages, Versions supportedVersions, Image cur\n         return versionBasedImageFilter.getCdhImagesForCbVersion(supportedVersions, availableImages);\n     }\n \n-    private List<Image> filterImages(List<Image> availableImages, Image currentImage, String cloudPlatform) {\n-        // I think the whole logic is broken, since we don't allow an upgrade if we shipped a new parcel extension...\n-        return availableImages.stream()\n+    private ImageFilterResult filterImages(List<Image> availableImages, Image currentImage, String cloudPlatform) {\n+        List<Image> images = availableImages.stream()\n+                .filter(filterCurrentImage(currentImage))\n                 .filter(ignoredCmVersion())\n-                .filter(validateCmVersion(currentImage).or(validateStackVersion(currentImage)))\n+                .filter(validateCmAndStackVersion(currentImage))\n                 .filter(validateCloudPlatform(cloudPlatform))\n                 .filter(validateOsVersion(currentImage))\n-                // We don't necessary need CFM and CSP since only SDX upgrade is supported\n-                //.filter(validateCfmVersion(currentImage))\n-                //.filter(validateCspVersion(currentImage))\n                 .filter(validateSaltVersion(currentImage))\n-                .filter(filterCurrentImage(currentImage))\n                 .collect(Collectors.toList());\n-    }\n \n-    private Predicate<Image> validateOsVersion(Image currentImage) {\n-        return image -> isOsVersionsMatch(currentImage, image);\n+        return new ImageFilterResult(new Images(null, null, null, images, null), getReason(images));\n     }\n \n-    private boolean isOsVersionsMatch(Image currentImage, Image newImage) {\n-        return newImage.getOs().equalsIgnoreCase(currentImage.getOs())\n-                && newImage.getOsType().equalsIgnoreCase(currentImage.getOsType());\n+    private Predicate<Image> filterCurrentImage(Image currentImage) {\n+        return image -> {\n+            boolean result = !image.getUuid().equals(currentImage.getUuid());\n+            setReason(result, \"No other image is available.\");\n+            return result;\n+        };\n     }\n \n     private Predicate<Image> ignoredCmVersion() {\n-        // There are some legacy CM versions that do not follow a proper versioning scheme, we must ignore them\n-        return image -> image.getPackageVersions().get(CM_PACKAGE_KEY) != null &&\n-                !image.getPackageVersions().get(CM_PACKAGE_KEY).contains(IGNORED_CM_VERSION);\n+        return image -> {\n+            boolean result = image.getPackageVersions().get(CM_PACKAGE_KEY) != null", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "17162f24600d530de95659591965edaa2efdfa0e"}, "originalPosition": 69}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ5NTY5MDUyOnYy", "diffSide": "RIGHT", "path": "core/src/main/java/com/sequenceiq/cloudbreak/service/upgrade/ClusterUpgradeImageFilter.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMlQxNToyOTo0M1rOF_w4PA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wM1QwNzoyMjo1OVrOGAH-AQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjQwNTQzNg==", "bodyText": "I would separate this 2 use-cases with 2 different setReasons(), aggregated.", "url": "https://github.com/hortonworks/cloudbreak/pull/7707#discussion_r402405436", "createdAt": "2020-04-02T15:29:43Z", "author": {"login": "pdarvasi"}, "path": "core/src/main/java/com/sequenceiq/cloudbreak/service/upgrade/ClusterUpgradeImageFilter.java", "diffHunk": "@@ -52,71 +46,86 @@ Images filter(List<Image> availableImages, Versions supportedVersions, Image cur\n         return versionBasedImageFilter.getCdhImagesForCbVersion(supportedVersions, availableImages);\n     }\n \n-    private List<Image> filterImages(List<Image> availableImages, Image currentImage, String cloudPlatform) {\n-        // I think the whole logic is broken, since we don't allow an upgrade if we shipped a new parcel extension...\n-        return availableImages.stream()\n+    private ImageFilterResult filterImages(List<Image> availableImages, Image currentImage, String cloudPlatform) {\n+        List<Image> images = availableImages.stream()\n+                .filter(filterCurrentImage(currentImage))\n                 .filter(ignoredCmVersion())\n-                .filter(validateCmVersion(currentImage).or(validateStackVersion(currentImage)))\n+                .filter(validateCmAndStackVersion(currentImage))\n                 .filter(validateCloudPlatform(cloudPlatform))\n                 .filter(validateOsVersion(currentImage))\n-                // We don't necessary need CFM and CSP since only SDX upgrade is supported\n-                //.filter(validateCfmVersion(currentImage))\n-                //.filter(validateCspVersion(currentImage))\n                 .filter(validateSaltVersion(currentImage))\n-                .filter(filterCurrentImage(currentImage))\n                 .collect(Collectors.toList());\n-    }\n \n-    private Predicate<Image> validateOsVersion(Image currentImage) {\n-        return image -> isOsVersionsMatch(currentImage, image);\n+        return new ImageFilterResult(new Images(null, null, null, images, null), getReason(images));\n     }\n \n-    private boolean isOsVersionsMatch(Image currentImage, Image newImage) {\n-        return newImage.getOs().equalsIgnoreCase(currentImage.getOs())\n-                && newImage.getOsType().equalsIgnoreCase(currentImage.getOsType());\n+    private Predicate<Image> filterCurrentImage(Image currentImage) {\n+        return image -> {\n+            boolean result = !image.getUuid().equals(currentImage.getUuid());\n+            setReason(result, \"No other image is available.\");\n+            return result;\n+        };\n     }\n \n     private Predicate<Image> ignoredCmVersion() {\n-        // There are some legacy CM versions that do not follow a proper versioning scheme, we must ignore them\n-        return image -> image.getPackageVersions().get(CM_PACKAGE_KEY) != null &&\n-                !image.getPackageVersions().get(CM_PACKAGE_KEY).contains(IGNORED_CM_VERSION);\n+        return image -> {\n+            boolean result = image.getPackageVersions().get(CM_PACKAGE_KEY) != null\n+                    && !image.getPackageVersions().get(CM_PACKAGE_KEY).contains(IGNORED_CM_VERSION);\n+            setReason(result, \"There are no supported Cloudera Manager or CDP version.\");\n+            return result;\n+        };\n     }\n \n-    private Predicate<Image> validateCmVersion(Image currentImage) {\n-        return image -> permitCmAndSatckUpgrade(currentImage, image, CM_PACKAGE_KEY);\n+    private Predicate<Image> validateCmAndStackVersion(Image currentImage) {\n+        return image -> {\n+            boolean result = permitCmAndSatckUpgrade(currentImage, image, CM_PACKAGE_KEY) || permitCmAndSatckUpgrade(currentImage, image, STACK_PACKAGE_KEY);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "17162f24600d530de95659591965edaa2efdfa0e"}, "originalPosition": 80}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjc4MTc4OQ==", "bodyText": "I think it's not necessary because we offer an image if the CM or CDP package versions are higher then the current. So we only need to return the error message if we not found any higher versions.", "url": "https://github.com/hortonworks/cloudbreak/pull/7707#discussion_r402781789", "createdAt": "2020-04-03T07:19:01Z", "author": {"login": "tiborpopovics"}, "path": "core/src/main/java/com/sequenceiq/cloudbreak/service/upgrade/ClusterUpgradeImageFilter.java", "diffHunk": "@@ -52,71 +46,86 @@ Images filter(List<Image> availableImages, Versions supportedVersions, Image cur\n         return versionBasedImageFilter.getCdhImagesForCbVersion(supportedVersions, availableImages);\n     }\n \n-    private List<Image> filterImages(List<Image> availableImages, Image currentImage, String cloudPlatform) {\n-        // I think the whole logic is broken, since we don't allow an upgrade if we shipped a new parcel extension...\n-        return availableImages.stream()\n+    private ImageFilterResult filterImages(List<Image> availableImages, Image currentImage, String cloudPlatform) {\n+        List<Image> images = availableImages.stream()\n+                .filter(filterCurrentImage(currentImage))\n                 .filter(ignoredCmVersion())\n-                .filter(validateCmVersion(currentImage).or(validateStackVersion(currentImage)))\n+                .filter(validateCmAndStackVersion(currentImage))\n                 .filter(validateCloudPlatform(cloudPlatform))\n                 .filter(validateOsVersion(currentImage))\n-                // We don't necessary need CFM and CSP since only SDX upgrade is supported\n-                //.filter(validateCfmVersion(currentImage))\n-                //.filter(validateCspVersion(currentImage))\n                 .filter(validateSaltVersion(currentImage))\n-                .filter(filterCurrentImage(currentImage))\n                 .collect(Collectors.toList());\n-    }\n \n-    private Predicate<Image> validateOsVersion(Image currentImage) {\n-        return image -> isOsVersionsMatch(currentImage, image);\n+        return new ImageFilterResult(new Images(null, null, null, images, null), getReason(images));\n     }\n \n-    private boolean isOsVersionsMatch(Image currentImage, Image newImage) {\n-        return newImage.getOs().equalsIgnoreCase(currentImage.getOs())\n-                && newImage.getOsType().equalsIgnoreCase(currentImage.getOsType());\n+    private Predicate<Image> filterCurrentImage(Image currentImage) {\n+        return image -> {\n+            boolean result = !image.getUuid().equals(currentImage.getUuid());\n+            setReason(result, \"No other image is available.\");\n+            return result;\n+        };\n     }\n \n     private Predicate<Image> ignoredCmVersion() {\n-        // There are some legacy CM versions that do not follow a proper versioning scheme, we must ignore them\n-        return image -> image.getPackageVersions().get(CM_PACKAGE_KEY) != null &&\n-                !image.getPackageVersions().get(CM_PACKAGE_KEY).contains(IGNORED_CM_VERSION);\n+        return image -> {\n+            boolean result = image.getPackageVersions().get(CM_PACKAGE_KEY) != null\n+                    && !image.getPackageVersions().get(CM_PACKAGE_KEY).contains(IGNORED_CM_VERSION);\n+            setReason(result, \"There are no supported Cloudera Manager or CDP version.\");\n+            return result;\n+        };\n     }\n \n-    private Predicate<Image> validateCmVersion(Image currentImage) {\n-        return image -> permitCmAndSatckUpgrade(currentImage, image, CM_PACKAGE_KEY);\n+    private Predicate<Image> validateCmAndStackVersion(Image currentImage) {\n+        return image -> {\n+            boolean result = permitCmAndSatckUpgrade(currentImage, image, CM_PACKAGE_KEY) || permitCmAndSatckUpgrade(currentImage, image, STACK_PACKAGE_KEY);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjQwNTQzNg=="}, "originalCommit": {"oid": "17162f24600d530de95659591965edaa2efdfa0e"}, "originalPosition": 80}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjc4Mzc0NQ==", "bodyText": "Ok!", "url": "https://github.com/hortonworks/cloudbreak/pull/7707#discussion_r402783745", "createdAt": "2020-04-03T07:22:59Z", "author": {"login": "pdarvasi"}, "path": "core/src/main/java/com/sequenceiq/cloudbreak/service/upgrade/ClusterUpgradeImageFilter.java", "diffHunk": "@@ -52,71 +46,86 @@ Images filter(List<Image> availableImages, Versions supportedVersions, Image cur\n         return versionBasedImageFilter.getCdhImagesForCbVersion(supportedVersions, availableImages);\n     }\n \n-    private List<Image> filterImages(List<Image> availableImages, Image currentImage, String cloudPlatform) {\n-        // I think the whole logic is broken, since we don't allow an upgrade if we shipped a new parcel extension...\n-        return availableImages.stream()\n+    private ImageFilterResult filterImages(List<Image> availableImages, Image currentImage, String cloudPlatform) {\n+        List<Image> images = availableImages.stream()\n+                .filter(filterCurrentImage(currentImage))\n                 .filter(ignoredCmVersion())\n-                .filter(validateCmVersion(currentImage).or(validateStackVersion(currentImage)))\n+                .filter(validateCmAndStackVersion(currentImage))\n                 .filter(validateCloudPlatform(cloudPlatform))\n                 .filter(validateOsVersion(currentImage))\n-                // We don't necessary need CFM and CSP since only SDX upgrade is supported\n-                //.filter(validateCfmVersion(currentImage))\n-                //.filter(validateCspVersion(currentImage))\n                 .filter(validateSaltVersion(currentImage))\n-                .filter(filterCurrentImage(currentImage))\n                 .collect(Collectors.toList());\n-    }\n \n-    private Predicate<Image> validateOsVersion(Image currentImage) {\n-        return image -> isOsVersionsMatch(currentImage, image);\n+        return new ImageFilterResult(new Images(null, null, null, images, null), getReason(images));\n     }\n \n-    private boolean isOsVersionsMatch(Image currentImage, Image newImage) {\n-        return newImage.getOs().equalsIgnoreCase(currentImage.getOs())\n-                && newImage.getOsType().equalsIgnoreCase(currentImage.getOsType());\n+    private Predicate<Image> filterCurrentImage(Image currentImage) {\n+        return image -> {\n+            boolean result = !image.getUuid().equals(currentImage.getUuid());\n+            setReason(result, \"No other image is available.\");\n+            return result;\n+        };\n     }\n \n     private Predicate<Image> ignoredCmVersion() {\n-        // There are some legacy CM versions that do not follow a proper versioning scheme, we must ignore them\n-        return image -> image.getPackageVersions().get(CM_PACKAGE_KEY) != null &&\n-                !image.getPackageVersions().get(CM_PACKAGE_KEY).contains(IGNORED_CM_VERSION);\n+        return image -> {\n+            boolean result = image.getPackageVersions().get(CM_PACKAGE_KEY) != null\n+                    && !image.getPackageVersions().get(CM_PACKAGE_KEY).contains(IGNORED_CM_VERSION);\n+            setReason(result, \"There are no supported Cloudera Manager or CDP version.\");\n+            return result;\n+        };\n     }\n \n-    private Predicate<Image> validateCmVersion(Image currentImage) {\n-        return image -> permitCmAndSatckUpgrade(currentImage, image, CM_PACKAGE_KEY);\n+    private Predicate<Image> validateCmAndStackVersion(Image currentImage) {\n+        return image -> {\n+            boolean result = permitCmAndSatckUpgrade(currentImage, image, CM_PACKAGE_KEY) || permitCmAndSatckUpgrade(currentImage, image, STACK_PACKAGE_KEY);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjQwNTQzNg=="}, "originalCommit": {"oid": "17162f24600d530de95659591965edaa2efdfa0e"}, "originalPosition": 80}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ5NTY5MzQ0OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/com/sequenceiq/cloudbreak/service/upgrade/ClusterUpgradeImageFilter.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMlQxNTozMDoxMlrOF_w56Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMlQxNTozMDoxMlrOF_w56Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjQwNTg2NQ==", "bodyText": "Typo: are --> is", "url": "https://github.com/hortonworks/cloudbreak/pull/7707#discussion_r402405865", "createdAt": "2020-04-02T15:30:12Z", "author": {"login": "pdarvasi"}, "path": "core/src/main/java/com/sequenceiq/cloudbreak/service/upgrade/ClusterUpgradeImageFilter.java", "diffHunk": "@@ -52,71 +46,86 @@ Images filter(List<Image> availableImages, Versions supportedVersions, Image cur\n         return versionBasedImageFilter.getCdhImagesForCbVersion(supportedVersions, availableImages);\n     }\n \n-    private List<Image> filterImages(List<Image> availableImages, Image currentImage, String cloudPlatform) {\n-        // I think the whole logic is broken, since we don't allow an upgrade if we shipped a new parcel extension...\n-        return availableImages.stream()\n+    private ImageFilterResult filterImages(List<Image> availableImages, Image currentImage, String cloudPlatform) {\n+        List<Image> images = availableImages.stream()\n+                .filter(filterCurrentImage(currentImage))\n                 .filter(ignoredCmVersion())\n-                .filter(validateCmVersion(currentImage).or(validateStackVersion(currentImage)))\n+                .filter(validateCmAndStackVersion(currentImage))\n                 .filter(validateCloudPlatform(cloudPlatform))\n                 .filter(validateOsVersion(currentImage))\n-                // We don't necessary need CFM and CSP since only SDX upgrade is supported\n-                //.filter(validateCfmVersion(currentImage))\n-                //.filter(validateCspVersion(currentImage))\n                 .filter(validateSaltVersion(currentImage))\n-                .filter(filterCurrentImage(currentImage))\n                 .collect(Collectors.toList());\n-    }\n \n-    private Predicate<Image> validateOsVersion(Image currentImage) {\n-        return image -> isOsVersionsMatch(currentImage, image);\n+        return new ImageFilterResult(new Images(null, null, null, images, null), getReason(images));\n     }\n \n-    private boolean isOsVersionsMatch(Image currentImage, Image newImage) {\n-        return newImage.getOs().equalsIgnoreCase(currentImage.getOs())\n-                && newImage.getOsType().equalsIgnoreCase(currentImage.getOsType());\n+    private Predicate<Image> filterCurrentImage(Image currentImage) {\n+        return image -> {\n+            boolean result = !image.getUuid().equals(currentImage.getUuid());\n+            setReason(result, \"No other image is available.\");\n+            return result;\n+        };\n     }\n \n     private Predicate<Image> ignoredCmVersion() {\n-        // There are some legacy CM versions that do not follow a proper versioning scheme, we must ignore them\n-        return image -> image.getPackageVersions().get(CM_PACKAGE_KEY) != null &&\n-                !image.getPackageVersions().get(CM_PACKAGE_KEY).contains(IGNORED_CM_VERSION);\n+        return image -> {\n+            boolean result = image.getPackageVersions().get(CM_PACKAGE_KEY) != null\n+                    && !image.getPackageVersions().get(CM_PACKAGE_KEY).contains(IGNORED_CM_VERSION);\n+            setReason(result, \"There are no supported Cloudera Manager or CDP version.\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "17162f24600d530de95659591965edaa2efdfa0e"}, "originalPosition": 71}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ5NTcwNjkwOnYy", "diffSide": "RIGHT", "path": "core/src/main/java/com/sequenceiq/cloudbreak/service/upgrade/ClusterUpgradeImageFilter.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMlQxNTozMzoyNlrOF_xCyA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMlQxNTozMzoyNlrOF_xCyA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjQwODEzNg==", "bodyText": "Typo: image--> images", "url": "https://github.com/hortonworks/cloudbreak/pull/7707#discussion_r402408136", "createdAt": "2020-04-02T15:33:26Z", "author": {"login": "pdarvasi"}, "path": "core/src/main/java/com/sequenceiq/cloudbreak/service/upgrade/ClusterUpgradeImageFilter.java", "diffHunk": "@@ -52,71 +46,86 @@ Images filter(List<Image> availableImages, Versions supportedVersions, Image cur\n         return versionBasedImageFilter.getCdhImagesForCbVersion(supportedVersions, availableImages);\n     }\n \n-    private List<Image> filterImages(List<Image> availableImages, Image currentImage, String cloudPlatform) {\n-        // I think the whole logic is broken, since we don't allow an upgrade if we shipped a new parcel extension...\n-        return availableImages.stream()\n+    private ImageFilterResult filterImages(List<Image> availableImages, Image currentImage, String cloudPlatform) {\n+        List<Image> images = availableImages.stream()\n+                .filter(filterCurrentImage(currentImage))\n                 .filter(ignoredCmVersion())\n-                .filter(validateCmVersion(currentImage).or(validateStackVersion(currentImage)))\n+                .filter(validateCmAndStackVersion(currentImage))\n                 .filter(validateCloudPlatform(cloudPlatform))\n                 .filter(validateOsVersion(currentImage))\n-                // We don't necessary need CFM and CSP since only SDX upgrade is supported\n-                //.filter(validateCfmVersion(currentImage))\n-                //.filter(validateCspVersion(currentImage))\n                 .filter(validateSaltVersion(currentImage))\n-                .filter(filterCurrentImage(currentImage))\n                 .collect(Collectors.toList());\n-    }\n \n-    private Predicate<Image> validateOsVersion(Image currentImage) {\n-        return image -> isOsVersionsMatch(currentImage, image);\n+        return new ImageFilterResult(new Images(null, null, null, images, null), getReason(images));\n     }\n \n-    private boolean isOsVersionsMatch(Image currentImage, Image newImage) {\n-        return newImage.getOs().equalsIgnoreCase(currentImage.getOs())\n-                && newImage.getOsType().equalsIgnoreCase(currentImage.getOsType());\n+    private Predicate<Image> filterCurrentImage(Image currentImage) {\n+        return image -> {\n+            boolean result = !image.getUuid().equals(currentImage.getUuid());\n+            setReason(result, \"No other image is available.\");\n+            return result;\n+        };\n     }\n \n     private Predicate<Image> ignoredCmVersion() {\n-        // There are some legacy CM versions that do not follow a proper versioning scheme, we must ignore them\n-        return image -> image.getPackageVersions().get(CM_PACKAGE_KEY) != null &&\n-                !image.getPackageVersions().get(CM_PACKAGE_KEY).contains(IGNORED_CM_VERSION);\n+        return image -> {\n+            boolean result = image.getPackageVersions().get(CM_PACKAGE_KEY) != null\n+                    && !image.getPackageVersions().get(CM_PACKAGE_KEY).contains(IGNORED_CM_VERSION);\n+            setReason(result, \"There are no supported Cloudera Manager or CDP version.\");\n+            return result;\n+        };\n     }\n \n-    private Predicate<Image> validateCmVersion(Image currentImage) {\n-        return image -> permitCmAndSatckUpgrade(currentImage, image, CM_PACKAGE_KEY);\n+    private Predicate<Image> validateCmAndStackVersion(Image currentImage) {\n+        return image -> {\n+            boolean result = permitCmAndSatckUpgrade(currentImage, image, CM_PACKAGE_KEY) || permitCmAndSatckUpgrade(currentImage, image, STACK_PACKAGE_KEY);\n+            setReason(result, \"There are no proper Cloudera Manager or CDP version to upgrade.\");\n+            return result;\n+        };\n     }\n \n-    private Predicate<Image> validateStackVersion(Image currentImage) {\n-        return image -> permitCmAndSatckUpgrade(currentImage, image, STACK_PACKAGE_KEY);\n+    private boolean permitCmAndSatckUpgrade(Image currentImage, Image image, String key) {\n+        return upgradePermissionProvider.permitCmAndSatckUpgrade(currentImage.getPackageVersions().get(STACK_PACKAGE_KEY),\n+                image.getPackageVersions().get(key));\n     }\n \n     private Predicate<Image> validateCloudPlatform(String cloudPlatform) {\n-        return image -> image.getImageSetsByProvider().keySet().stream().anyMatch(key -> key.equalsIgnoreCase(cloudPlatform));\n+        return image -> {\n+            boolean result = image.getImageSetsByProvider().keySet().stream().anyMatch(key -> key.equalsIgnoreCase(cloudPlatform));\n+            if (!result) {\n+                reason = String.format(\"There are no image available for %s cloud platform.\", cloudPlatform);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "17162f24600d530de95659591965edaa2efdfa0e"}, "originalPosition": 98}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2618, "cost": 1, "resetAt": "2021-11-12T20:44:06Z"}}}