{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzgwNTAzMzI3", "number": 7400, "title": "CDPCP-1113 Determine environment access using rights", "bodyText": "This is based on two commits. One for updating the UMS proto and one for updating the FMS.\nCDPCP-1113. Sync users based on accessEnvironment right\n\nUsers are now granted access to an environment based on the\nenvironments/accessEnvironment right instead of the EnvironmentUser,\nEnvironmentAdmin, or PowerUser role.\n\nAdditionally, users are now added to the ipa \"admins\" group if they\nhave the environments/adminFreeIPA right. This right is not granted\nto the EnvironmentAdmin role, so EnvironmentAdmins will be removed\nfrom the \"admins\" group. PowerUsers will still have this right.\n\nAs part of this change, a hasRights method is added to the GrpcUmsClient.\nUmsUsersStateProvider has been modified to use the hasRights method and\ngetWorkloadAdministrationGroups instead of getRights.\n\nCDPCP-1113. Update UMS for retrieving WAGs for a member\n\nThe usermanagementservice.proto has been updated to include a new\nrequest ListWorkloadAdministrationGroupsForMember. This request\nreturns the workload administration groups for the specified member\n(i.e., user or machine user) and must be called by the internal actor.\n\nThe Grpc and MockUserManagementService have been updated to match.", "createdAt": "2020-02-26T20:58:36Z", "url": "https://github.com/hortonworks/cloudbreak/pull/7400", "merged": true, "mergeCommit": {"oid": "5f61877f88444bad3711c2bc75a5a468caba924e"}, "closed": true, "closedAt": "2020-02-28T09:59:52Z", "author": {"login": "handavid"}, "timelineItems": {"totalCount": 11, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcIYrWigFqTM2NTU2MTM2MA==", "endCursor": "Y3Vyc29yOnYyOpPPAAABcI4A79gFqTM2NjcyOTk5Nw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY1NTYxMzYw", "url": "https://github.com/hortonworks/cloudbreak/pull/7400#pullrequestreview-365561360", "createdAt": "2020-02-27T10:17:23Z", "commit": {"oid": "757d41b2063bb45434ab9ee948c59433f7712e88"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yN1QxMDoxNzoyNFrOFvMhNQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yN1QxMDoyMDo1NFrOFvMojg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTAzMjUwMQ==", "bodyText": "could you move this to a method called sth like addEligibleUserToInnternalGroup so we can drop  the comment", "url": "https://github.com/hortonworks/cloudbreak/pull/7400#discussion_r385032501", "createdAt": "2020-02-27T10:17:24Z", "author": {"login": "lacikaaa"}, "path": "freeipa/src/main/java/com/sequenceiq/freeipa/service/freeipa/user/UmsUsersStateProvider.java", "diffHunk": "@@ -129,95 +133,38 @@ private WorkloadCredential getCredentials(String userCrn, Optional<String> reque\n         return new WorkloadCredential(hashedPassword, keys, expirationInstant);\n     }\n \n-    private boolean isEnvironmentUser(String enviromentCrn, GetRightsResponse rightsResponse) {\n-\n-        List<RoleAssignment> rolesAssignedList = rightsResponse.getRoleAssignmentList();\n-        for (RoleAssignment roleAssigned : rolesAssignedList) {\n-            // TODO: should come from IAM Roles and check against Role Object\n-            if (roleAssigned.getRole().getCrn().contains(\"PowerUser\") ||\n-                roleAssigned.getRole().getCrn().contains(\"EnvironmentAdmin\")) {\n-                return true;\n-                // admins are also users\n-            }\n-        }\n-\n-        List<ResourceRoleAssignment> resourceRoleAssignedList = rightsResponse.getResourceRolesAssignmentList();\n-        for (ResourceRoleAssignment resourceRoleAssigned : resourceRoleAssignedList) {\n-            // TODO: should come from IAM Roles and check against Role Object\n-            if (resourceRoleAssigned.getResourceRole().getCrn().contains(\"EnvironmentAdmin\") ||\n-                (resourceRoleAssigned.getResourceRole().getCrn().contains(\"EnvironmentUser\"))) {\n-                return true;\n-            }\n-        }\n-\n-        return false;\n-    }\n-\n-    private boolean isEnvironmentAdmin(String enviromentCrn, GetRightsResponse rightsResponse) {\n-        List<RoleAssignment> rolesAssignedList = rightsResponse.getRoleAssignmentList();\n-        for (RoleAssignment roleAssigned : rolesAssignedList) {\n-            // TODO: should come from IAM Roles and check against Role Object\n-            if (roleAssigned.getRole().getCrn().contains(\"PowerUser\") ||\n-                roleAssigned.getRole().getCrn().contains(\"EnvironmentAdmin\")) {\n-                return true;\n-            }\n-        }\n-\n-        List<ResourceRoleAssignment> resourceRoleAssignedList = rightsResponse.getResourceRolesAssignmentList();\n-        for (ResourceRoleAssignment resourceRoleAssigned : resourceRoleAssignedList) {\n-            // TODO: should come from IAM Roles and check against Role Object\n-            if (resourceRoleAssigned.getResourceRole().getCrn().contains(\"EnvironmentAdmin\")) {\n-                return true;\n-            }\n-        }\n-\n-        return false;\n-    }\n-\n     @SuppressWarnings(\"ParameterNumber\")\n     private void handleUser(UmsUsersState.Builder umsUsersStateBuilder, UsersState.Builder usersStateBuilder, Map<String, FmsGroup> crnToFmsGroup,\n-                            String actorCrn, String memberCrn, FmsUser fmsUser, String environmentCrn, Optional<String> requestId) {\n-        try {\n-            GetRightsResponse rightsResponse = grpcUmsClient.getRightsForUser(actorCrn, memberCrn, environmentCrn, requestId);\n-            if (isEnvironmentUser(environmentCrn, rightsResponse)) {\n-                usersStateBuilder.addUser(fmsUser);\n-                rightsResponse.getGroupCrnList().stream().forEach(gcrn -> {\n-                    FmsGroup group = crnToFmsGroup.get(gcrn);\n-                    // If the group is null, then there has been a group membership change after we started the sync\n-                    // the group and group membership will be updated on the next sync\n-                    if (group != null) {\n-                        usersStateBuilder.addMemberToGroup(group.getName(), fmsUser.getName());\n-                    }\n-                });\n-\n-                // Since this user is eligible, add this user to internal group\n-                usersStateBuilder.addMemberToGroup(UserServiceConstants.CDP_USERSYNC_INTERNAL_GROUP, fmsUser.getName());\n+                            String memberCrn, FmsUser fmsUser, EnvironmentAccessRights environmentAccessRights, Optional<String> requestId) {\n+        if (environmentAccessRights.hasEnvironmentAccessRight()) {\n+            usersStateBuilder.addUser(fmsUser);\n+            String username = fmsUser.getName();\n+            String accountId = Crn.safeFromString(memberCrn).getAccountId();\n+            grpcUmsClient.listGroupsForMember(IAM_INTERNAL_ACTOR_CRN, accountId, memberCrn, requestId).forEach(gcrn -> {\n+                FmsGroup group = crnToFmsGroup.get(gcrn);\n+                // If the group is null, then there has been a group membership change after we started the sync\n+                // the group and group membership will be updated on the next sync\n+                if (group != null) {\n+                    usersStateBuilder.addMemberToGroup(group.getName(), username);\n+                }\n+            });\n \n-                List<String> workloadAdministrationGroupNames = rightsResponse.getWorkloadAdministrationGroupNameList();\n-                LOGGER.debug(\"workloadAdministrationGroupNameList = {}\", workloadAdministrationGroupNames);\n-                workloadAdministrationGroupNames.forEach(groupName -> {\n-                    usersStateBuilder.addGroup(nameToGroup(groupName));\n-                    usersStateBuilder.addMemberToGroup(groupName, fmsUser.getName());\n-                });\n+            // Since this user is eligible, add this user to internal group\n+            usersStateBuilder.addMemberToGroup(UserServiceConstants.CDP_USERSYNC_INTERNAL_GROUP, username);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "757d41b2063bb45434ab9ee948c59433f7712e88"}, "originalPosition": 161}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTAzNDM4Mg==", "bodyText": "I think you can drop this command or move this to a method with a self explaining name", "url": "https://github.com/hortonworks/cloudbreak/pull/7400#discussion_r385034382", "createdAt": "2020-02-27T10:20:54Z", "author": {"login": "lacikaaa"}, "path": "freeipa/src/main/java/com/sequenceiq/freeipa/service/freeipa/user/UmsUsersStateProvider.java", "diffHunk": "@@ -129,95 +133,38 @@ private WorkloadCredential getCredentials(String userCrn, Optional<String> reque\n         return new WorkloadCredential(hashedPassword, keys, expirationInstant);\n     }\n \n-    private boolean isEnvironmentUser(String enviromentCrn, GetRightsResponse rightsResponse) {\n-\n-        List<RoleAssignment> rolesAssignedList = rightsResponse.getRoleAssignmentList();\n-        for (RoleAssignment roleAssigned : rolesAssignedList) {\n-            // TODO: should come from IAM Roles and check against Role Object\n-            if (roleAssigned.getRole().getCrn().contains(\"PowerUser\") ||\n-                roleAssigned.getRole().getCrn().contains(\"EnvironmentAdmin\")) {\n-                return true;\n-                // admins are also users\n-            }\n-        }\n-\n-        List<ResourceRoleAssignment> resourceRoleAssignedList = rightsResponse.getResourceRolesAssignmentList();\n-        for (ResourceRoleAssignment resourceRoleAssigned : resourceRoleAssignedList) {\n-            // TODO: should come from IAM Roles and check against Role Object\n-            if (resourceRoleAssigned.getResourceRole().getCrn().contains(\"EnvironmentAdmin\") ||\n-                (resourceRoleAssigned.getResourceRole().getCrn().contains(\"EnvironmentUser\"))) {\n-                return true;\n-            }\n-        }\n-\n-        return false;\n-    }\n-\n-    private boolean isEnvironmentAdmin(String enviromentCrn, GetRightsResponse rightsResponse) {\n-        List<RoleAssignment> rolesAssignedList = rightsResponse.getRoleAssignmentList();\n-        for (RoleAssignment roleAssigned : rolesAssignedList) {\n-            // TODO: should come from IAM Roles and check against Role Object\n-            if (roleAssigned.getRole().getCrn().contains(\"PowerUser\") ||\n-                roleAssigned.getRole().getCrn().contains(\"EnvironmentAdmin\")) {\n-                return true;\n-            }\n-        }\n-\n-        List<ResourceRoleAssignment> resourceRoleAssignedList = rightsResponse.getResourceRolesAssignmentList();\n-        for (ResourceRoleAssignment resourceRoleAssigned : resourceRoleAssignedList) {\n-            // TODO: should come from IAM Roles and check against Role Object\n-            if (resourceRoleAssigned.getResourceRole().getCrn().contains(\"EnvironmentAdmin\")) {\n-                return true;\n-            }\n-        }\n-\n-        return false;\n-    }\n-\n     @SuppressWarnings(\"ParameterNumber\")\n     private void handleUser(UmsUsersState.Builder umsUsersStateBuilder, UsersState.Builder usersStateBuilder, Map<String, FmsGroup> crnToFmsGroup,\n-                            String actorCrn, String memberCrn, FmsUser fmsUser, String environmentCrn, Optional<String> requestId) {\n-        try {\n-            GetRightsResponse rightsResponse = grpcUmsClient.getRightsForUser(actorCrn, memberCrn, environmentCrn, requestId);\n-            if (isEnvironmentUser(environmentCrn, rightsResponse)) {\n-                usersStateBuilder.addUser(fmsUser);\n-                rightsResponse.getGroupCrnList().stream().forEach(gcrn -> {\n-                    FmsGroup group = crnToFmsGroup.get(gcrn);\n-                    // If the group is null, then there has been a group membership change after we started the sync\n-                    // the group and group membership will be updated on the next sync\n-                    if (group != null) {\n-                        usersStateBuilder.addMemberToGroup(group.getName(), fmsUser.getName());\n-                    }\n-                });\n-\n-                // Since this user is eligible, add this user to internal group\n-                usersStateBuilder.addMemberToGroup(UserServiceConstants.CDP_USERSYNC_INTERNAL_GROUP, fmsUser.getName());\n+                            String memberCrn, FmsUser fmsUser, EnvironmentAccessRights environmentAccessRights, Optional<String> requestId) {\n+        if (environmentAccessRights.hasEnvironmentAccessRight()) {\n+            usersStateBuilder.addUser(fmsUser);\n+            String username = fmsUser.getName();\n+            String accountId = Crn.safeFromString(memberCrn).getAccountId();\n+            grpcUmsClient.listGroupsForMember(IAM_INTERNAL_ACTOR_CRN, accountId, memberCrn, requestId).forEach(gcrn -> {\n+                FmsGroup group = crnToFmsGroup.get(gcrn);\n+                // If the group is null, then there has been a group membership change after we started the sync\n+                // the group and group membership will be updated on the next sync\n+                if (group != null) {\n+                    usersStateBuilder.addMemberToGroup(group.getName(), username);\n+                }\n+            });\n \n-                List<String> workloadAdministrationGroupNames = rightsResponse.getWorkloadAdministrationGroupNameList();\n-                LOGGER.debug(\"workloadAdministrationGroupNameList = {}\", workloadAdministrationGroupNames);\n-                workloadAdministrationGroupNames.forEach(groupName -> {\n-                    usersStateBuilder.addGroup(nameToGroup(groupName));\n-                    usersStateBuilder.addMemberToGroup(groupName, fmsUser.getName());\n-                });\n+            // Since this user is eligible, add this user to internal group\n+            usersStateBuilder.addMemberToGroup(UserServiceConstants.CDP_USERSYNC_INTERNAL_GROUP, username);\n \n-                if (isEnvironmentAdmin(environmentCrn, rightsResponse)) {\n-                    // TODO: introduce a flag for adding admin\n-                    usersStateBuilder.addMemberToGroup(\"admins\", fmsUser.getName());\n-                }\n+            UserManagementProto.ListWorkloadAdministrationGroupsForMemberResponse workloadAdministrationGroups =\n+                    grpcUmsClient.listWorkloadAdministrationGroupsForMember(IAM_INTERNAL_ACTOR_CRN, memberCrn, requestId);\n+            workloadAdministrationGroups.getWorkloadAdministrationGroupNameList().forEach(groupName -> {\n+                usersStateBuilder.addGroup(nameToGroup(groupName));\n+                usersStateBuilder.addMemberToGroup(groupName, username);\n+            });\n \n-                // get credentials\n-                umsUsersStateBuilder.addWorkloadCredentials(fmsUser.getName(), getCredentials(memberCrn, requestId));\n-            }\n-        } catch (StatusRuntimeException e) {\n-            // NOT_FOUND errors indicate that a user/machineUser has been deleted after we have\n-            // retrieved the list of users/machineUsers from the UMS. Treat these users as if\n-            // they do not have the right to access this environment and belong to no groups.\n-            if (e.getStatus().getCode() == Status.Code.NOT_FOUND) {\n-                LOGGER.warn(\"CRN {} not found in UMS. Treating as if CRN has no rights to environment {}: {}\",\n-                        memberCrn, environmentCrn, e.getLocalizedMessage());\n-            } else {\n-                throw e;\n+            if (environmentAccessRights.hasAdminFreeIPARight()) {\n+                usersStateBuilder.addMemberToGroup(ADMIN_FREEIPA_GROUP, username);\n             }\n+\n+            // get credentials", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "757d41b2063bb45434ab9ee948c59433f7712e88"}, "originalPosition": 190}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY1NTY3MTI4", "url": "https://github.com/hortonworks/cloudbreak/pull/7400#pullrequestreview-365567128", "createdAt": "2020-02-27T10:25:52Z", "commit": {"oid": "757d41b2063bb45434ab9ee948c59433f7712e88"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yN1QxMDoyNTo1M1rOFvMzZA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yN1QxMDozMToyMlrOFvM_pQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTAzNzE1Ng==", "bodyText": "I would annotate this class with @Service or @Component and inject it into the proper class or make it static (maybe @Service is better because you can write mockito tests for it), instead of instantiate it every time", "url": "https://github.com/hortonworks/cloudbreak/pull/7400#discussion_r385037156", "createdAt": "2020-02-27T10:25:53Z", "author": {"login": "horadla23"}, "path": "freeipa/src/main/java/com/sequenceiq/freeipa/service/freeipa/user/EnvironmentAccessChecker.java", "diffHunk": "@@ -0,0 +1,82 @@\n+package com.sequenceiq.freeipa.service.freeipa.user;\n+\n+import static java.util.Objects.requireNonNull;\n+\n+import java.util.List;\n+import java.util.Optional;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.cloudera.thunderhead.service.authorization.AuthorizationProto;\n+import com.sequenceiq.authorization.resource.AuthorizationResource;\n+import com.sequenceiq.authorization.resource.ResourceAction;\n+import com.sequenceiq.authorization.resource.RightUtils;\n+import com.sequenceiq.cloudbreak.auth.altus.Crn;\n+import com.sequenceiq.cloudbreak.auth.altus.CrnParseException;\n+import com.sequenceiq.cloudbreak.auth.altus.GrpcUmsClient;\n+import com.sequenceiq.cloudbreak.auth.security.InternalCrnBuilder;\n+import com.sequenceiq.freeipa.service.freeipa.user.model.EnvironmentAccessRights;\n+\n+import io.grpc.Status;\n+import io.grpc.StatusRuntimeException;\n+\n+public class EnvironmentAccessChecker {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "757d41b2063bb45434ab9ee948c59433f7712e88"}, "originalPosition": 24}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTAzOTA0OA==", "bodyText": "Since this is Freeipa service, then I would create internal CRN for freeipa service (or environment because freeipa service is not a public service afaik), not for IAM service", "url": "https://github.com/hortonworks/cloudbreak/pull/7400#discussion_r385039048", "createdAt": "2020-02-27T10:29:13Z", "author": {"login": "horadla23"}, "path": "freeipa/src/main/java/com/sequenceiq/freeipa/service/freeipa/user/EnvironmentAccessChecker.java", "diffHunk": "@@ -0,0 +1,82 @@\n+package com.sequenceiq.freeipa.service.freeipa.user;\n+\n+import static java.util.Objects.requireNonNull;\n+\n+import java.util.List;\n+import java.util.Optional;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.cloudera.thunderhead.service.authorization.AuthorizationProto;\n+import com.sequenceiq.authorization.resource.AuthorizationResource;\n+import com.sequenceiq.authorization.resource.ResourceAction;\n+import com.sequenceiq.authorization.resource.RightUtils;\n+import com.sequenceiq.cloudbreak.auth.altus.Crn;\n+import com.sequenceiq.cloudbreak.auth.altus.CrnParseException;\n+import com.sequenceiq.cloudbreak.auth.altus.GrpcUmsClient;\n+import com.sequenceiq.cloudbreak.auth.security.InternalCrnBuilder;\n+import com.sequenceiq.freeipa.service.freeipa.user.model.EnvironmentAccessRights;\n+\n+import io.grpc.Status;\n+import io.grpc.StatusRuntimeException;\n+\n+public class EnvironmentAccessChecker {\n+    private static final Logger LOGGER = LoggerFactory.getLogger(EnvironmentAccessChecker.class);\n+\n+    private static final String IAM_INTERNAL_ACTOR_CRN = new InternalCrnBuilder(Crn.Service.IAM).getInternalCrnForServiceAsString();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "757d41b2063bb45434ab9ee948c59433f7712e88"}, "originalPosition": 27}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTAzOTU3Mw==", "bodyText": "please check checkRight method and add caching to this method similarly", "url": "https://github.com/hortonworks/cloudbreak/pull/7400#discussion_r385039573", "createdAt": "2020-02-27T10:30:10Z", "author": {"login": "horadla23"}, "path": "auth-connector/src/main/java/com/sequenceiq/cloudbreak/auth/altus/GrpcUmsClient.java", "diffHunk": "@@ -329,6 +348,22 @@ public boolean checkRight(String actorCrn, String userCrn, String right, Optiona\n         return checkRight(actorCrn, userCrn, right, null, requestId);\n     }\n \n+    /**\n+     * Retrieves whether the member has the specified rights.\n+     *\n+     * @param actorCrn the CRN of the actor\n+     * @param memberCrn the CRN of the member\n+     * @param rightChecks the rights to check\n+     * @param requestId an optional request id\n+     * @return a list of booleans indicating whether the member has the specified rights\n+     */\n+    public List<Boolean> hasRights(String actorCrn, String memberCrn, List<AuthorizationProto.RightCheck> rightChecks, Optional<String> requestId) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "757d41b2063bb45434ab9ee948c59433f7712e88"}, "originalPosition": 53}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTA0MDI5Mw==", "bodyText": "we are currently not making call to UMS in case of internal CRN because right now everything allowed witn internalCRN afaik, there is an if (InternalCrnBuilder.isInternalCrn(actorCrn)) in checkRight call for it, I think we should use that here also", "url": "https://github.com/hortonworks/cloudbreak/pull/7400#discussion_r385040293", "createdAt": "2020-02-27T10:31:22Z", "author": {"login": "horadla23"}, "path": "auth-connector/src/main/java/com/sequenceiq/cloudbreak/auth/altus/GrpcUmsClient.java", "diffHunk": "@@ -329,6 +348,22 @@ public boolean checkRight(String actorCrn, String userCrn, String right, Optiona\n         return checkRight(actorCrn, userCrn, right, null, requestId);\n     }\n \n+    /**\n+     * Retrieves whether the member has the specified rights.\n+     *\n+     * @param actorCrn the CRN of the actor\n+     * @param memberCrn the CRN of the member\n+     * @param rightChecks the rights to check\n+     * @param requestId an optional request id\n+     * @return a list of booleans indicating whether the member has the specified rights\n+     */\n+    public List<Boolean> hasRights(String actorCrn, String memberCrn, List<AuthorizationProto.RightCheck> rightChecks, Optional<String> requestId) {\n+        try (ManagedChannelWrapper channelWrapper = makeWrapper()) {\n+            AuthorizationClient client = new AuthorizationClient(channelWrapper.getChannel(), actorCrn);\n+            return client.hasRights(requestId.orElse(UUID.randomUUID().toString()), memberCrn, rightChecks);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "757d41b2063bb45434ab9ee948c59433f7712e88"}, "originalPosition": 56}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "86094cd572d83921733de093049e3fc939cca0e3", "author": {"user": {"login": "handavid", "name": "David Han"}}, "url": "https://github.com/hortonworks/cloudbreak/commit/86094cd572d83921733de093049e3fc939cca0e3", "committedDate": "2020-02-27T18:43:55Z", "message": "CDPCP-1113. Update UMS for retrieving WAGs for a member\n\nThe usermanagementservice.proto has been updated to include a new\nrequest ListWorkloadAdministrationGroupsForMember. This request\nreturns the workload administration groups for the specified member\n(i.e., user or machine user) and must be called by the internal actor.\n\nThe Grpc and MockUserManagementService have been updated to match."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "757d41b2063bb45434ab9ee948c59433f7712e88", "author": {"user": {"login": "handavid", "name": "David Han"}}, "url": "https://github.com/hortonworks/cloudbreak/commit/757d41b2063bb45434ab9ee948c59433f7712e88", "committedDate": "2020-02-26T20:50:34Z", "message": "CDPCP-1113. Sync users based on accessEnvironment right\n\nUsers are now granted access to an environment based on the\nenvironments/accessEnvironment right instead of the EnvironmentUser,\nEnvironmentAdmin, or PowerUser role.\n\nAdditionally, users are now added to the ipa \"admins\" group if they\nhave the environments/adminFreeIPA right. This right is not granted\nto the EnvironmentAdmin role, so EnvironmentAdmins will be removed\nfrom the \"admins\" group. PowerUsers will still have this right.\n\nAs part of this change, a hasRights method is added to the GrpcUmsClient.\nUmsUsersStateProvider has been modified to use the hasRights method and\ngetWorkloadAdministrationGroups instead of getRights."}, "afterCommit": {"oid": "dba5d33ded6214d6983c811ff5aa96b119c09363", "author": {"user": {"login": "handavid", "name": "David Han"}}, "url": "https://github.com/hortonworks/cloudbreak/commit/dba5d33ded6214d6983c811ff5aa96b119c09363", "committedDate": "2020-02-27T22:31:45Z", "message": "fix checkRight to short-circuit call if user is internal\n\nThere are two CRNs passed to the checkRights call. The actorCrn\nis part of the grpc context and indicates who is checking the right.\nThe userCrn is part of the checkRights request and indicates for\nwhom the rights are checked.\n\nInternal users are known to have all rights w/o needing to call the\nAuthorizationService. This commit fixes the short-circuit to check\nwhether the userCrn is an internal CRN instead of checking whether\nthe actorCrn is an internal CRN."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY2MDUwOTY1", "url": "https://github.com/hortonworks/cloudbreak/pull/7400#pullrequestreview-366050965", "createdAt": "2020-02-27T22:39:20Z", "commit": {"oid": "dba5d33ded6214d6983c811ff5aa96b119c09363"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e89d2294a7f6ceca349be2b4231657cb579cf15c", "author": {"user": {"login": "handavid", "name": "David Han"}}, "url": "https://github.com/hortonworks/cloudbreak/commit/e89d2294a7f6ceca349be2b4231657cb579cf15c", "committedDate": "2020-02-28T03:54:19Z", "message": "CDPCP-1113. Sync users based on accessEnvironment right\n\nUsers are now granted access to an environment based on the\nenvironments/accessEnvironment right instead of the EnvironmentUser,\nEnvironmentAdmin, or PowerUser role.\n\nAdditionally, users are now added to the ipa \"admins\" group if they\nhave the environments/adminFreeIPA right. This right is not granted\nto the EnvironmentAdmin role, so EnvironmentAdmins will be removed\nfrom the \"admins\" group. PowerUsers will still have this right.\n\nAs part of this change, a hasRights method is added to the GrpcUmsClient.\nUmsUsersStateProvider has been modified to use the hasRights method and\ngetWorkloadAdministrationGroups instead of getRights."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "cd180ef48452078c772f0d1f9f38279fc8c2347b", "author": {"user": {"login": "handavid", "name": "David Han"}}, "url": "https://github.com/hortonworks/cloudbreak/commit/cd180ef48452078c772f0d1f9f38279fc8c2347b", "committedDate": "2020-02-28T03:54:19Z", "message": "fix checkRight to short-circuit call if user is internal\n\nThere are two CRNs passed to the checkRights call. The actorCrn\nis part of the grpc context and indicates who is checking the right.\nThe userCrn is part of the checkRights request and indicates for\nwhom the rights are checked.\n\nInternal users are known to have all rights w/o needing to call the\nAuthorizationService. This commit fixes the short-circuit to check\nwhether the userCrn is an internal CRN instead of checking whether\nthe actorCrn is an internal CRN."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "dba5d33ded6214d6983c811ff5aa96b119c09363", "author": {"user": {"login": "handavid", "name": "David Han"}}, "url": "https://github.com/hortonworks/cloudbreak/commit/dba5d33ded6214d6983c811ff5aa96b119c09363", "committedDate": "2020-02-27T22:31:45Z", "message": "fix checkRight to short-circuit call if user is internal\n\nThere are two CRNs passed to the checkRights call. The actorCrn\nis part of the grpc context and indicates who is checking the right.\nThe userCrn is part of the checkRights request and indicates for\nwhom the rights are checked.\n\nInternal users are known to have all rights w/o needing to call the\nAuthorizationService. This commit fixes the short-circuit to check\nwhether the userCrn is an internal CRN instead of checking whether\nthe actorCrn is an internal CRN."}, "afterCommit": {"oid": "cd180ef48452078c772f0d1f9f38279fc8c2347b", "author": {"user": {"login": "handavid", "name": "David Han"}}, "url": "https://github.com/hortonworks/cloudbreak/commit/cd180ef48452078c772f0d1f9f38279fc8c2347b", "committedDate": "2020-02-28T03:54:19Z", "message": "fix checkRight to short-circuit call if user is internal\n\nThere are two CRNs passed to the checkRights call. The actorCrn\nis part of the grpc context and indicates who is checking the right.\nThe userCrn is part of the checkRights request and indicates for\nwhom the rights are checked.\n\nInternal users are known to have all rights w/o needing to call the\nAuthorizationService. This commit fixes the short-circuit to check\nwhether the userCrn is an internal CRN instead of checking whether\nthe actorCrn is an internal CRN."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY2MjQ5MTk3", "url": "https://github.com/hortonworks/cloudbreak/pull/7400#pullrequestreview-366249197", "createdAt": "2020-02-28T09:09:29Z", "commit": {"oid": "cd180ef48452078c772f0d1f9f38279fc8c2347b"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY2Mjc5NjE2", "url": "https://github.com/hortonworks/cloudbreak/pull/7400#pullrequestreview-366279616", "createdAt": "2020-02-28T09:59:30Z", "commit": {"oid": "cd180ef48452078c772f0d1f9f38279fc8c2347b"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY2NzI5OTk3", "url": "https://github.com/hortonworks/cloudbreak/pull/7400#pullrequestreview-366729997", "createdAt": "2020-02-28T22:48:00Z", "commit": {"oid": "e89d2294a7f6ceca349be2b4231657cb579cf15c"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yOFQyMjo0ODowMFrOFwE-Rg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yOFQyMjo1MToxNFrOFwFBsg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTk1NzQ0Ng==", "bodyText": "So I prefer not to do the right check here, in the grpc ums client. Let's not optimize this right now. I think that the right way to optimize this is to have distributed policies that have ttl on them. The policy for an internal actor can be \"forever\" so that the clients will never go to the authorization service. But I do not want to copy the authorization checks all over the place.", "url": "https://github.com/hortonworks/cloudbreak/pull/7400#discussion_r385957446", "createdAt": "2020-02-28T22:48:00Z", "author": {"login": "giladwolff"}, "path": "auth-connector/src/main/java/com/sequenceiq/cloudbreak/auth/altus/GrpcUmsClient.java", "diffHunk": "@@ -347,6 +350,33 @@ public boolean checkRight(String actorCrn, String userCrn, String right, Optiona\n         return checkRight(actorCrn, userCrn, right, null, requestId);\n     }\n \n+    /**\n+     * Retrieves whether the member has the specified rights.\n+     *\n+     * @param actorCrn the CRN of the actor\n+     * @param memberCrn the CRN of the member\n+     * @param rightChecks the rights to check\n+     * @param requestId an optional request id\n+     * @return a list of booleans indicating whether the member has the specified rights\n+     */\n+    public List<Boolean> hasRights(String actorCrn, String memberCrn, List<AuthorizationProto.RightCheck> rightChecks, Optional<String> requestId) {\n+        LOGGER.info(\"Checking whether member [] has rights [{}]\",\n+                memberCrn,\n+                rightChecks.stream().map(AuthorizationProto.RightCheck::getRight).collect(Collectors.toList()));\n+        if (InternalCrnBuilder.isInternalCrn(memberCrn)) {\n+            LOGGER.info(\"InternalCrn has all rights\");\n+            Boolean[] values = new Boolean[rightChecks.size()];\n+            Arrays.fill(values, Boolean.TRUE);\n+            return Arrays.asList(values);\n+        }\n+        try (ManagedChannelWrapper channelWrapper = makeWrapper()) {\n+            AuthorizationClient client = new AuthorizationClient(channelWrapper.getChannel(), actorCrn);\n+            List<Boolean> retVal = client.hasRights(requestId.orElse(UUID.randomUUID().toString()), memberCrn, rightChecks);\n+            LOGGER.info(\"member {} has rights {}\", memberCrn, retVal);\n+            return retVal;\n+        }\n+    }\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e89d2294a7f6ceca349be2b4231657cb579cf15c"}, "originalPosition": 50}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTk1ODMyMg==", "bodyText": "So this is fine for now, but maybe add the jira number tracking deletion of users from the FreeIPA here? Or is there an explicit check for the existence of users somewhere else?", "url": "https://github.com/hortonworks/cloudbreak/pull/7400#discussion_r385958322", "createdAt": "2020-02-28T22:51:14Z", "author": {"login": "giladwolff"}, "path": "freeipa/src/main/java/com/sequenceiq/freeipa/service/freeipa/user/EnvironmentAccessChecker.java", "diffHunk": "@@ -0,0 +1,82 @@\n+package com.sequenceiq.freeipa.service.freeipa.user;\n+\n+import static java.util.Objects.requireNonNull;\n+\n+import java.util.List;\n+import java.util.Optional;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.cloudera.thunderhead.service.authorization.AuthorizationProto;\n+import com.sequenceiq.authorization.resource.AuthorizationResource;\n+import com.sequenceiq.authorization.resource.ResourceAction;\n+import com.sequenceiq.authorization.resource.RightUtils;\n+import com.sequenceiq.cloudbreak.auth.altus.Crn;\n+import com.sequenceiq.cloudbreak.auth.altus.CrnParseException;\n+import com.sequenceiq.cloudbreak.auth.altus.GrpcUmsClient;\n+import com.sequenceiq.cloudbreak.auth.security.InternalCrnBuilder;\n+import com.sequenceiq.freeipa.service.freeipa.user.model.EnvironmentAccessRights;\n+\n+import io.grpc.Status;\n+import io.grpc.StatusRuntimeException;\n+\n+public class EnvironmentAccessChecker {\n+    private static final Logger LOGGER = LoggerFactory.getLogger(EnvironmentAccessChecker.class);\n+\n+    private static final String IAM_INTERNAL_ACTOR_CRN = new InternalCrnBuilder(Crn.Service.IAM).getInternalCrnForServiceAsString();\n+\n+    private static final String ACCESS_ENVIRONMENT_RIGHT = RightUtils.getRight(AuthorizationResource.ENVIRONMENT, ResourceAction.ACCESS_ENVIRONMENT);\n+\n+    private static final String ADMIN_FREEIPA_RIGHT = RightUtils.getRight(AuthorizationResource.ENVIRONMENT, ResourceAction.ADMIN_FREEIPA);\n+\n+    private final GrpcUmsClient grpcUmsClient;\n+\n+    private final String environmentCrn;\n+\n+    private final List<AuthorizationProto.RightCheck> rightChecks;\n+\n+    /**\n+     * Creates an EnvironmentAccessChecker instance.\n+     * @param grpcUmsClient a GrpcUmsClient\n+     * @param environmentCrn a environment CRN\n+     * @throws NullPointerException if the environmentCrn is null\n+     * @throws CrnParseException    if the environmentCrn does not match the CRN pattern or cannot be parsed\n+     */\n+    public EnvironmentAccessChecker(GrpcUmsClient grpcUmsClient, String environmentCrn) {\n+        this.grpcUmsClient = requireNonNull(grpcUmsClient, \"grpcUmsClient is null\");\n+        Crn.safeFromString(environmentCrn);\n+        this.environmentCrn = environmentCrn;\n+\n+        this.rightChecks = List.of(\n+                AuthorizationProto.RightCheck.newBuilder()\n+                        .setRight(ACCESS_ENVIRONMENT_RIGHT)\n+                        .setResource(environmentCrn)\n+                        .build(),\n+                AuthorizationProto.RightCheck.newBuilder()\n+                        .setRight(ADMIN_FREEIPA_RIGHT)\n+                        .build());\n+    }\n+\n+    public EnvironmentAccessRights hasAccess(String memberCrn, Optional<String> requestId) {\n+        requireNonNull(memberCrn, \"memberCrn is null\");\n+        requireNonNull(requestId, \"requestId is null\");\n+\n+        try {\n+            List<Boolean> hasRights = grpcUmsClient.hasRights(IAM_INTERNAL_ACTOR_CRN, memberCrn, rightChecks, requestId);\n+            return new EnvironmentAccessRights(hasRights.get(0), hasRights.get(1));\n+        } catch (StatusRuntimeException e) {\n+            // NOT_FOUND errors indicate that a user/machineUser has been deleted after we have\n+            // retrieved the list of users/machineUsers from the UMS. Treat these users as if\n+            // they do not have the right to access this environment and belong to no groups.\n+            if (e.getStatus().getCode() == Status.Code.NOT_FOUND) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e89d2294a7f6ceca349be2b4231657cb579cf15c"}, "originalPosition": 72}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2601, "cost": 1, "resetAt": "2021-11-01T14:51:55Z"}}}