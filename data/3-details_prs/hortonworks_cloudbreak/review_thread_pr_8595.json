{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDUzNDI5ODc1", "number": 8595, "reviewThreads": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMVQwNTo0OTozNVrOEQeQ5g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMlQwOTozNzowOFrOEQ-EXg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg1NzA4NTE4OnYy", "diffSide": "RIGHT", "path": "autoscale/src/main/java/com/sequenceiq/periscope/monitor/handler/ScalingHandler.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMVQwNTo0OTozNVrOG0pDAg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMVQwNTo1ODozMVrOG0pO-A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Nzg1MTY1MA==", "bodyText": "The log message could be enhanced and contain the name of the alert/scaling action pair for the sake of easier debugging in the future.", "url": "https://github.com/hortonworks/cloudbreak/pull/8595#discussion_r457851650", "createdAt": "2020-07-21T05:49:35Z", "author": {"login": "biharitomi"}, "path": "autoscale/src/main/java/com/sequenceiq/periscope/monitor/handler/ScalingHandler.java", "diffHunk": "@@ -48,30 +50,37 @@\n \n     @Override\n     public void onApplicationEvent(ScalingEvent event) {\n-        BaseAlert alert = event.getAlert();\n-        Cluster cluster = clusterService.findById(alert.getCluster().getId());\n+        Set<BaseAlert> alerts = event.getAlerts();\n+        Long clusterId = alerts.stream().findFirst().map(ma -> ma.getCluster().getId()).orElseThrow();\n+        Cluster cluster = clusterService.findById(clusterId);\n         MDCBuilder.buildMdcContext(cluster);\n-        scale(cluster, alert.getScalingPolicy());\n+        if (isCooldownElapsed(cluster)) {\n+            alerts.forEach(alert -> scale(cluster, alert.getScalingPolicy()));\n+        }\n     }\n \n     private void scale(Cluster cluster, ScalingPolicy policy) {\n+        int totalNodes = Math.toIntExact(cloudbreakClient.autoscaleEndpoint().getHostMetadataCountForAutoscale(cluster.getStackId(), policy.getHostGroup()));\n+        int desiredNodeCount = getDesiredNodeCount(cluster, policy, totalNodes);\n+        if (totalNodes != desiredNodeCount) {\n+            Runnable scalingRequest = (Runnable) applicationContext.getBean(\"ScalingRequest\", cluster, policy, totalNodes, desiredNodeCount);\n+            loggedExecutorService.submit(\"ScalingHandler\", scalingRequest);\n+            rejectedThreadService.remove(cluster.getId());\n+            cluster.setLastScalingActivityCurrent();\n+            clusterService.save(cluster);\n+        } else {\n+            LOGGER.info(\"No scaling activity required\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f6dc8c71166753b383661cd51cfeddd52704b03d"}, "originalPosition": 35}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Nzg1NDcxMg==", "bodyText": "this information is available in MDC context. But if it is not enough, I can update the message", "url": "https://github.com/hortonworks/cloudbreak/pull/8595#discussion_r457854712", "createdAt": "2020-07-21T05:58:31Z", "author": {"login": "topolyai5"}, "path": "autoscale/src/main/java/com/sequenceiq/periscope/monitor/handler/ScalingHandler.java", "diffHunk": "@@ -48,30 +50,37 @@\n \n     @Override\n     public void onApplicationEvent(ScalingEvent event) {\n-        BaseAlert alert = event.getAlert();\n-        Cluster cluster = clusterService.findById(alert.getCluster().getId());\n+        Set<BaseAlert> alerts = event.getAlerts();\n+        Long clusterId = alerts.stream().findFirst().map(ma -> ma.getCluster().getId()).orElseThrow();\n+        Cluster cluster = clusterService.findById(clusterId);\n         MDCBuilder.buildMdcContext(cluster);\n-        scale(cluster, alert.getScalingPolicy());\n+        if (isCooldownElapsed(cluster)) {\n+            alerts.forEach(alert -> scale(cluster, alert.getScalingPolicy()));\n+        }\n     }\n \n     private void scale(Cluster cluster, ScalingPolicy policy) {\n+        int totalNodes = Math.toIntExact(cloudbreakClient.autoscaleEndpoint().getHostMetadataCountForAutoscale(cluster.getStackId(), policy.getHostGroup()));\n+        int desiredNodeCount = getDesiredNodeCount(cluster, policy, totalNodes);\n+        if (totalNodes != desiredNodeCount) {\n+            Runnable scalingRequest = (Runnable) applicationContext.getBean(\"ScalingRequest\", cluster, policy, totalNodes, desiredNodeCount);\n+            loggedExecutorService.submit(\"ScalingHandler\", scalingRequest);\n+            rejectedThreadService.remove(cluster.getId());\n+            cluster.setLastScalingActivityCurrent();\n+            clusterService.save(cluster);\n+        } else {\n+            LOGGER.info(\"No scaling activity required\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Nzg1MTY1MA=="}, "originalCommit": {"oid": "f6dc8c71166753b383661cd51cfeddd52704b03d"}, "originalPosition": 35}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg1NzA5MDg3OnYy", "diffSide": "RIGHT", "path": "autoscale/src/main/java/com/sequenceiq/periscope/monitor/handler/ScalingHandler.java", "isResolved": false, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMVQwNTo1MTo0NFrOG0pGFQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMVQwNjoyNToyNVrOG0pzww==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Nzg1MjQzNw==", "bodyText": "Do we really want to trigger multiple scaling actions at the same time?", "url": "https://github.com/hortonworks/cloudbreak/pull/8595#discussion_r457852437", "createdAt": "2020-07-21T05:51:44Z", "author": {"login": "biharitomi"}, "path": "autoscale/src/main/java/com/sequenceiq/periscope/monitor/handler/ScalingHandler.java", "diffHunk": "@@ -48,30 +50,37 @@\n \n     @Override\n     public void onApplicationEvent(ScalingEvent event) {\n-        BaseAlert alert = event.getAlert();\n-        Cluster cluster = clusterService.findById(alert.getCluster().getId());\n+        Set<BaseAlert> alerts = event.getAlerts();\n+        Long clusterId = alerts.stream().findFirst().map(ma -> ma.getCluster().getId()).orElseThrow();\n+        Cluster cluster = clusterService.findById(clusterId);\n         MDCBuilder.buildMdcContext(cluster);\n-        scale(cluster, alert.getScalingPolicy());\n+        if (isCooldownElapsed(cluster)) {\n+            alerts.forEach(alert -> scale(cluster, alert.getScalingPolicy()));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f6dc8c71166753b383661cd51cfeddd52704b03d"}, "originalPosition": 21}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Nzg1NDk2NA==", "bodyText": "Yes, this is the main problem.", "url": "https://github.com/hortonworks/cloudbreak/pull/8595#discussion_r457854964", "createdAt": "2020-07-21T05:59:13Z", "author": {"login": "topolyai5"}, "path": "autoscale/src/main/java/com/sequenceiq/periscope/monitor/handler/ScalingHandler.java", "diffHunk": "@@ -48,30 +50,37 @@\n \n     @Override\n     public void onApplicationEvent(ScalingEvent event) {\n-        BaseAlert alert = event.getAlert();\n-        Cluster cluster = clusterService.findById(alert.getCluster().getId());\n+        Set<BaseAlert> alerts = event.getAlerts();\n+        Long clusterId = alerts.stream().findFirst().map(ma -> ma.getCluster().getId()).orElseThrow();\n+        Cluster cluster = clusterService.findById(clusterId);\n         MDCBuilder.buildMdcContext(cluster);\n-        scale(cluster, alert.getScalingPolicy());\n+        if (isCooldownElapsed(cluster)) {\n+            alerts.forEach(alert -> scale(cluster, alert.getScalingPolicy()));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Nzg1MjQzNw=="}, "originalCommit": {"oid": "f6dc8c71166753b383661cd51cfeddd52704b03d"}, "originalPosition": 21}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Nzg1ODAxMg==", "bodyText": "Hm, I need more investigation. The second request will be denied because the cluster is under operation.", "url": "https://github.com/hortonworks/cloudbreak/pull/8595#discussion_r457858012", "createdAt": "2020-07-21T06:08:13Z", "author": {"login": "topolyai5"}, "path": "autoscale/src/main/java/com/sequenceiq/periscope/monitor/handler/ScalingHandler.java", "diffHunk": "@@ -48,30 +50,37 @@\n \n     @Override\n     public void onApplicationEvent(ScalingEvent event) {\n-        BaseAlert alert = event.getAlert();\n-        Cluster cluster = clusterService.findById(alert.getCluster().getId());\n+        Set<BaseAlert> alerts = event.getAlerts();\n+        Long clusterId = alerts.stream().findFirst().map(ma -> ma.getCluster().getId()).orElseThrow();\n+        Cluster cluster = clusterService.findById(clusterId);\n         MDCBuilder.buildMdcContext(cluster);\n-        scale(cluster, alert.getScalingPolicy());\n+        if (isCooldownElapsed(cluster)) {\n+            alerts.forEach(alert -> scale(cluster, alert.getScalingPolicy()));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Nzg1MjQzNw=="}, "originalCommit": {"oid": "f6dc8c71166753b383661cd51cfeddd52704b03d"}, "originalPosition": 21}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Nzg2NDEzMQ==", "bodyText": "I am not sure about that, triggering multiple scaling on the CB APIs is not so safe. @keyki ?", "url": "https://github.com/hortonworks/cloudbreak/pull/8595#discussion_r457864131", "createdAt": "2020-07-21T06:25:25Z", "author": {"login": "biharitomi"}, "path": "autoscale/src/main/java/com/sequenceiq/periscope/monitor/handler/ScalingHandler.java", "diffHunk": "@@ -48,30 +50,37 @@\n \n     @Override\n     public void onApplicationEvent(ScalingEvent event) {\n-        BaseAlert alert = event.getAlert();\n-        Cluster cluster = clusterService.findById(alert.getCluster().getId());\n+        Set<BaseAlert> alerts = event.getAlerts();\n+        Long clusterId = alerts.stream().findFirst().map(ma -> ma.getCluster().getId()).orElseThrow();\n+        Cluster cluster = clusterService.findById(clusterId);\n         MDCBuilder.buildMdcContext(cluster);\n-        scale(cluster, alert.getScalingPolicy());\n+        if (isCooldownElapsed(cluster)) {\n+            alerts.forEach(alert -> scale(cluster, alert.getScalingPolicy()));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Nzg1MjQzNw=="}, "originalCommit": {"oid": "f6dc8c71166753b383661cd51cfeddd52704b03d"}, "originalPosition": 21}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg2MjI2NDk1OnYy", "diffSide": "RIGHT", "path": "autoscale/src/main/java/com/sequenceiq/periscope/monitor/ScalingHandlerUtil.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMlQwOToyODo1MFrOG1acSQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMlQwOToyODo1MFrOG1acSQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODY2MDkzNw==", "bodyText": "pls add some extra logging to this if clause, too", "url": "https://github.com/hortonworks/cloudbreak/pull/8595#discussion_r458660937", "createdAt": "2020-07-22T09:28:50Z", "author": {"login": "pdarvasi"}, "path": "autoscale/src/main/java/com/sequenceiq/periscope/monitor/ScalingHandlerUtil.java", "diffHunk": "@@ -0,0 +1,106 @@\n+package com.sequenceiq.periscope.monitor;\n+\n+import static java.lang.Math.ceil;\n+\n+import javax.inject.Inject;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.context.ApplicationContext;\n+import org.springframework.stereotype.Component;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.sequenceiq.cloudbreak.client.CloudbreakClient;\n+import com.sequenceiq.cloudbreak.service.Clock;\n+import com.sequenceiq.periscope.domain.BaseAlert;\n+import com.sequenceiq.periscope.domain.Cluster;\n+import com.sequenceiq.periscope.domain.ScalingPolicy;\n+import com.sequenceiq.periscope.monitor.executor.LoggedExecutorService;\n+import com.sequenceiq.periscope.service.ClusterService;\n+import com.sequenceiq.periscope.service.RejectedThreadService;\n+import com.sequenceiq.periscope.utils.ClusterUtils;\n+import com.sequenceiq.periscope.utils.TimeUtil;\n+\n+@Component\n+public class ScalingHandlerUtil {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(ScalingHandlerUtil.class);\n+\n+    @Inject\n+    private ApplicationContext applicationContext;\n+\n+    @Inject\n+    private RejectedThreadService rejectedThreadService;\n+\n+    @Inject\n+    private CloudbreakClient cloudbreakClient;\n+\n+    @Inject\n+    private ClusterService clusterService;\n+\n+    @Inject\n+    private LoggedExecutorService loggedExecutorService;\n+\n+    @Inject\n+    private Clock clock;\n+\n+    public void scaleIfNeed(Cluster cluster, BaseAlert alert) {\n+        ScalingPolicy policy = alert.getScalingPolicy();\n+        int totalNodes = Math.toIntExact(cloudbreakClient.autoscaleEndpoint().getHostMetadataCountForAutoscale(cluster.getStackId(), policy.getHostGroup()));\n+        int desiredNodeCount = getDesiredNodeCount(cluster, policy, totalNodes);\n+        if (totalNodes != desiredNodeCount) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8f56659e03c675a34085dea1c72c020898c0e048"}, "originalPosition": 51}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg2MjI2NTUyOnYy", "diffSide": "RIGHT", "path": "autoscale/src/main/java/com/sequenceiq/periscope/monitor/ScalingHandlerUtil.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMlQwOToyOTowMFrOG1acqA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMlQwOToyOTowMFrOG1acqA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODY2MTAzMg==", "bodyText": "pls add some extra logging to this if clause, too", "url": "https://github.com/hortonworks/cloudbreak/pull/8595#discussion_r458661032", "createdAt": "2020-07-22T09:29:00Z", "author": {"login": "pdarvasi"}, "path": "autoscale/src/main/java/com/sequenceiq/periscope/monitor/ScalingHandlerUtil.java", "diffHunk": "@@ -0,0 +1,106 @@\n+package com.sequenceiq.periscope.monitor;\n+\n+import static java.lang.Math.ceil;\n+\n+import javax.inject.Inject;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.context.ApplicationContext;\n+import org.springframework.stereotype.Component;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.sequenceiq.cloudbreak.client.CloudbreakClient;\n+import com.sequenceiq.cloudbreak.service.Clock;\n+import com.sequenceiq.periscope.domain.BaseAlert;\n+import com.sequenceiq.periscope.domain.Cluster;\n+import com.sequenceiq.periscope.domain.ScalingPolicy;\n+import com.sequenceiq.periscope.monitor.executor.LoggedExecutorService;\n+import com.sequenceiq.periscope.service.ClusterService;\n+import com.sequenceiq.periscope.service.RejectedThreadService;\n+import com.sequenceiq.periscope.utils.ClusterUtils;\n+import com.sequenceiq.periscope.utils.TimeUtil;\n+\n+@Component\n+public class ScalingHandlerUtil {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(ScalingHandlerUtil.class);\n+\n+    @Inject\n+    private ApplicationContext applicationContext;\n+\n+    @Inject\n+    private RejectedThreadService rejectedThreadService;\n+\n+    @Inject\n+    private CloudbreakClient cloudbreakClient;\n+\n+    @Inject\n+    private ClusterService clusterService;\n+\n+    @Inject\n+    private LoggedExecutorService loggedExecutorService;\n+\n+    @Inject\n+    private Clock clock;\n+\n+    public void scaleIfNeed(Cluster cluster, BaseAlert alert) {\n+        ScalingPolicy policy = alert.getScalingPolicy();\n+        int totalNodes = Math.toIntExact(cloudbreakClient.autoscaleEndpoint().getHostMetadataCountForAutoscale(cluster.getStackId(), policy.getHostGroup()));\n+        int desiredNodeCount = getDesiredNodeCount(cluster, policy, totalNodes);\n+        if (totalNodes != desiredNodeCount) {\n+            cluster.setLastScalingActivityCurrent();\n+            clusterService.save(cluster);\n+            scale(cluster, policy);\n+        } else {\n+            LOGGER.info(\"No scaling activity required for '{}' policy\", policy.getName());\n+        }\n+    }\n+\n+    private void scale(Cluster cluster, ScalingPolicy policy) {\n+        int totalNodes = Math.toIntExact(cloudbreakClient.autoscaleEndpoint().getHostMetadataCountForAutoscale(cluster.getStackId(), policy.getHostGroup()));\n+        int desiredNodeCount = getDesiredNodeCount(cluster, policy, totalNodes);\n+        Runnable scalingRequest = (Runnable) applicationContext.getBean(\"ScalingRequest\", cluster, policy, totalNodes, desiredNodeCount);\n+        loggedExecutorService.submit(\"ScalingHandler\", scalingRequest);\n+        rejectedThreadService.remove(cluster.getId());\n+    }\n+\n+    public boolean isCooldownElapsed(Cluster cluster) {\n+        long remainingTime = getRemainingCooldownTime(cluster);\n+        if (remainingTime <= 0) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8f56659e03c675a34085dea1c72c020898c0e048"}, "originalPosition": 70}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg2MjI3MzIwOnYy", "diffSide": "RIGHT", "path": "autoscale/src/main/java/com/sequenceiq/periscope/monitor/ScalingHandlerUtil.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMlQwOTozMTowN1rOG1ahVw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMlQwOTozMTowN1rOG1ahVw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODY2MjIzMQ==", "bodyText": "pls add some extra logging to this including minSize, maxSize and calculated desiredNodeCount", "url": "https://github.com/hortonworks/cloudbreak/pull/8595#discussion_r458662231", "createdAt": "2020-07-22T09:31:07Z", "author": {"login": "pdarvasi"}, "path": "autoscale/src/main/java/com/sequenceiq/periscope/monitor/ScalingHandlerUtil.java", "diffHunk": "@@ -0,0 +1,106 @@\n+package com.sequenceiq.periscope.monitor;\n+\n+import static java.lang.Math.ceil;\n+\n+import javax.inject.Inject;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.context.ApplicationContext;\n+import org.springframework.stereotype.Component;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.sequenceiq.cloudbreak.client.CloudbreakClient;\n+import com.sequenceiq.cloudbreak.service.Clock;\n+import com.sequenceiq.periscope.domain.BaseAlert;\n+import com.sequenceiq.periscope.domain.Cluster;\n+import com.sequenceiq.periscope.domain.ScalingPolicy;\n+import com.sequenceiq.periscope.monitor.executor.LoggedExecutorService;\n+import com.sequenceiq.periscope.service.ClusterService;\n+import com.sequenceiq.periscope.service.RejectedThreadService;\n+import com.sequenceiq.periscope.utils.ClusterUtils;\n+import com.sequenceiq.periscope.utils.TimeUtil;\n+\n+@Component\n+public class ScalingHandlerUtil {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(ScalingHandlerUtil.class);\n+\n+    @Inject\n+    private ApplicationContext applicationContext;\n+\n+    @Inject\n+    private RejectedThreadService rejectedThreadService;\n+\n+    @Inject\n+    private CloudbreakClient cloudbreakClient;\n+\n+    @Inject\n+    private ClusterService clusterService;\n+\n+    @Inject\n+    private LoggedExecutorService loggedExecutorService;\n+\n+    @Inject\n+    private Clock clock;\n+\n+    public void scaleIfNeed(Cluster cluster, BaseAlert alert) {\n+        ScalingPolicy policy = alert.getScalingPolicy();\n+        int totalNodes = Math.toIntExact(cloudbreakClient.autoscaleEndpoint().getHostMetadataCountForAutoscale(cluster.getStackId(), policy.getHostGroup()));\n+        int desiredNodeCount = getDesiredNodeCount(cluster, policy, totalNodes);\n+        if (totalNodes != desiredNodeCount) {\n+            cluster.setLastScalingActivityCurrent();\n+            clusterService.save(cluster);\n+            scale(cluster, policy);\n+        } else {\n+            LOGGER.info(\"No scaling activity required for '{}' policy\", policy.getName());\n+        }\n+    }\n+\n+    private void scale(Cluster cluster, ScalingPolicy policy) {\n+        int totalNodes = Math.toIntExact(cloudbreakClient.autoscaleEndpoint().getHostMetadataCountForAutoscale(cluster.getStackId(), policy.getHostGroup()));\n+        int desiredNodeCount = getDesiredNodeCount(cluster, policy, totalNodes);\n+        Runnable scalingRequest = (Runnable) applicationContext.getBean(\"ScalingRequest\", cluster, policy, totalNodes, desiredNodeCount);\n+        loggedExecutorService.submit(\"ScalingHandler\", scalingRequest);\n+        rejectedThreadService.remove(cluster.getId());\n+    }\n+\n+    public boolean isCooldownElapsed(Cluster cluster) {\n+        long remainingTime = getRemainingCooldownTime(cluster);\n+        if (remainingTime <= 0) {\n+            return true;\n+        }\n+        LOGGER.info(\"Cluster cannot be scaled for {} min(s)\",\n+                ClusterUtils.TIME_FORMAT.format((double) remainingTime / TimeUtil.MIN_IN_MS));\n+        return false;\n+    }\n+\n+    private long getRemainingCooldownTime(Cluster cluster) {\n+        long coolDown = cluster.getCoolDown();\n+        long lastScalingActivity = cluster.getLastScalingActivity();\n+        return lastScalingActivity == 0L ? 0L : (coolDown * TimeUtil.MIN_IN_MS) - (clock.getCurrentTime() - lastScalingActivity);\n+    }\n+\n+    @VisibleForTesting\n+    protected int getDesiredNodeCount(Cluster cluster, ScalingPolicy policy, int totalNodes) {\n+        int scalingAdjustment = policy.getScalingAdjustment();\n+        int desiredNodeCount;\n+        switch (policy.getAdjustmentType()) {\n+            case NODE_COUNT:\n+                desiredNodeCount = totalNodes + scalingAdjustment;\n+                break;\n+            case PERCENTAGE:\n+                desiredNodeCount = totalNodes\n+                        + (int) (ceil(totalNodes * ((double) scalingAdjustment / ClusterUtils.MAX_CAPACITY)));\n+                break;\n+            case EXACT:\n+                desiredNodeCount = policy.getScalingAdjustment();\n+                break;\n+            default:\n+                desiredNodeCount = totalNodes;\n+        }\n+        int minSize = cluster.getMinSize();\n+        int maxSize = cluster.getMaxSize();\n+        return desiredNodeCount < minSize ? minSize : Math.min(desiredNodeCount, maxSize);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8f56659e03c675a34085dea1c72c020898c0e048"}, "originalPosition": 104}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg2MjI5NTk4OnYy", "diffSide": "RIGHT", "path": "autoscale/src/main/java/com/sequenceiq/periscope/monitor/handler/ScalingHandler.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMlQwOTozNzowOFrOG1avSg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMlQwOTozNzowOFrOG1avSg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODY2NTgwMg==", "bodyText": "Are you sure this won't cause any race conditions? I mean two or more possible subsequent \"true\" answers for isCooldownElapsed..", "url": "https://github.com/hortonworks/cloudbreak/pull/8595#discussion_r458665802", "createdAt": "2020-07-22T09:37:08Z", "author": {"login": "pdarvasi"}, "path": "autoscale/src/main/java/com/sequenceiq/periscope/monitor/handler/ScalingHandler.java", "diffHunk": "@@ -1,105 +1,38 @@\n package com.sequenceiq.periscope.monitor.handler;\n \n-import static java.lang.Math.ceil;\n+import java.util.List;\n \n import javax.inject.Inject;\n \n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-import org.springframework.context.ApplicationContext;\n import org.springframework.context.ApplicationListener;\n import org.springframework.stereotype.Component;\n \n-import com.sequenceiq.cloudbreak.client.CloudbreakClient;\n-import com.sequenceiq.periscope.aspects.AmbariRequestLogging;\n import com.sequenceiq.periscope.domain.BaseAlert;\n import com.sequenceiq.periscope.domain.Cluster;\n-import com.sequenceiq.periscope.domain.ScalingPolicy;\n import com.sequenceiq.periscope.log.MDCBuilder;\n+import com.sequenceiq.periscope.monitor.ScalingHandlerUtil;\n import com.sequenceiq.periscope.monitor.event.ScalingEvent;\n-import com.sequenceiq.periscope.monitor.executor.LoggedExecutorService;\n import com.sequenceiq.periscope.service.ClusterService;\n-import com.sequenceiq.periscope.service.RejectedThreadService;\n-import com.sequenceiq.periscope.utils.ClusterUtils;\n-import com.sequenceiq.periscope.utils.TimeUtil;\n \n @Component\n public class ScalingHandler implements ApplicationListener<ScalingEvent> {\n \n-    private static final Logger LOGGER = LoggerFactory.getLogger(ScalingHandler.class);\n-\n-    @Inject\n-    private LoggedExecutorService loggedExecutorService;\n-\n     @Inject\n     private ClusterService clusterService;\n \n     @Inject\n-    private ApplicationContext applicationContext;\n-\n-    @Inject\n-    private RejectedThreadService rejectedThreadService;\n-\n-    @Inject\n-    private AmbariRequestLogging ambariRequestLogging;\n-\n-    @Inject\n-    private CloudbreakClient cloudbreakClient;\n+    private ScalingHandlerUtil scalingHandlerUtil;\n \n     @Override\n     public void onApplicationEvent(ScalingEvent event) {\n-        BaseAlert alert = event.getAlert();\n-        Cluster cluster = clusterService.findById(alert.getCluster().getId());\n+        List<BaseAlert> alerts = event.getAlerts();\n+        Long clusterId = alerts.stream().findFirst().map(ma -> ma.getCluster().getId()).orElseThrow();\n+        Cluster cluster = clusterService.findById(clusterId);\n         MDCBuilder.buildMdcContext(cluster);\n-        scale(cluster, alert.getScalingPolicy());\n-    }\n-\n-    private void scale(Cluster cluster, ScalingPolicy policy) {\n-        long remainingTime = getRemainingCooldownTime(cluster);\n-        if (remainingTime <= 0) {\n-            int totalNodes = Math.toIntExact(cloudbreakClient.autoscaleEndpoint().getHostMetadataCountForAutoscale(cluster.getStackId(), policy.getHostGroup()));\n-            int desiredNodeCount = getDesiredNodeCount(cluster, policy, totalNodes);\n-            if (totalNodes != desiredNodeCount) {\n-                Runnable scalingRequest = (Runnable) applicationContext.getBean(\"ScalingRequest\", cluster, policy, totalNodes, desiredNodeCount);\n-                loggedExecutorService.submit(\"ScalingHandler\", scalingRequest);\n-                rejectedThreadService.remove(cluster.getId());\n-                cluster.setLastScalingActivityCurrent();\n-                clusterService.save(cluster);\n-            } else {\n-                LOGGER.info(\"No scaling activity required\");\n+        alerts.forEach(alert -> {\n+            if (scalingHandlerUtil.isCooldownElapsed(cluster)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8f56659e03c675a34085dea1c72c020898c0e048"}, "originalPosition": 77}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3056, "cost": 1, "resetAt": "2021-11-12T20:44:06Z"}}}