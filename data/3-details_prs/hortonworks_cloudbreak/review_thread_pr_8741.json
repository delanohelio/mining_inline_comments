{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDY0MTUyOTY2", "number": 8741, "reviewThreads": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wN1QwNzo0NzoyOFrOEWHYAg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wN1QwNzo0NzoyOFrOEWHYAg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkxNjI0OTYyOnYy", "diffSide": "RIGHT", "path": "template-manager-cmtemplate/src/main/java/com/sequenceiq/cloudbreak/cmtemplate/servicetype/ServiceTypeResolver.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wN1QwNzo0NzoyOFrOG9QBmQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wN1QwODowMDoxNVrOG9QaZw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Njg3ODg3Mw==", "bodyText": "maybe in case the user could not specify the servicetype then we should check the stack.type. What do you think?", "url": "https://github.com/hortonworks/cloudbreak/pull/8741#discussion_r466878873", "createdAt": "2020-08-07T07:47:28Z", "author": {"login": "doktoric"}, "path": "template-manager-cmtemplate/src/main/java/com/sequenceiq/cloudbreak/cmtemplate/servicetype/ServiceTypeResolver.java", "diffHunk": "@@ -0,0 +1,68 @@\n+package com.sequenceiq.cloudbreak.cmtemplate.servicetype;\n+\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+\n+import org.apache.commons.collections.CollectionUtils;\n+import org.apache.commons.lang3.StringUtils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.stereotype.Component;\n+\n+import com.sequenceiq.cloudbreak.cmtemplate.CmTemplateProcessor;\n+import com.sequenceiq.cloudbreak.exception.BadRequestException;\n+\n+@Component\n+public class ServiceTypeResolver {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(ServiceTypeResolver.class);\n+\n+    private final List<ServiceTypeMatcher> serviceTypeMatchers;\n+\n+    public ServiceTypeResolver(List<ServiceTypeMatcher> serviceTypeMatchers) {\n+        this.serviceTypeMatchers = serviceTypeMatchers;\n+    }\n+\n+    /**\n+     * Run all service type providers, in case of none of them will be applied, the default DATAHUB service type will be used.\n+     * If it will match multiple serviceTypes, that will fall back the default DATAHUB service type.\n+     * If there is a desired service type (provided by an another application) and the result won't be the same that will cause a runtime exception.\n+     * @param cmTemplateProcessor template processor that contains role and configuration data\n+     * @param desiredServiceType desired type service type that is provided by other service\n+     * @return resolved service type for the template\n+     */\n+    public String resolveServiceType(CmTemplateProcessor cmTemplateProcessor, String desiredServiceType) {\n+        Set<ServiceType> serviceTypes = new HashSet<>();\n+        ServiceType result = ServiceType.DATAHUB;\n+        if (StringUtils.isNotBlank(desiredServiceType) && !ServiceType.isValueValid(desiredServiceType)) {\n+            String errorMessage = String.format(\"'%s' is not a valid value for ServiceType enum.\", desiredServiceType);\n+            throw new BadRequestException(errorMessage);\n+        }\n+        if (CollectionUtils.isNotEmpty(serviceTypeMatchers)) {\n+            for (ServiceTypeMatcher serviceTypeMatcher : serviceTypeMatchers) {\n+                if (serviceTypeMatcher.match(cmTemplateProcessor)) {\n+                    serviceTypes.add(serviceTypeMatcher.getServiceType());\n+                }\n+            }\n+        }\n+        serviceTypes.remove(ServiceType.DATAHUB);\n+        if (serviceTypes.size() == 0) {\n+            LOGGER.debug(\"Service type only matched for dummy/default DataHub provider. Default DATAHUB service type will be used.\");\n+        } else if (serviceTypes.size() == 1) {\n+            result = serviceTypes.iterator().next();\n+            LOGGER.debug(\"The following service type will be selected based on the service type providers: {}\", result.value());\n+        } else {\n+            LOGGER.warn(\"You cannot match on multiple service types based on the service type providers. \" +", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ae4e33440085b5b7439d17d0b99e79ac1009d9f3"}, "originalPosition": 56}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Njg4NTIyMw==", "bodyText": "default service type is DATAHUB here, is the same as the stack type (that is not used for DATALAKE). metering v1 event supports only that. better to use that default enum (in case of DATAHUB name will change in the future or something), so i think it should be fine to use the default ServiceType enum instead of the stack type", "url": "https://github.com/hortonworks/cloudbreak/pull/8741#discussion_r466885223", "createdAt": "2020-08-07T08:00:15Z", "author": {"login": "oleewere"}, "path": "template-manager-cmtemplate/src/main/java/com/sequenceiq/cloudbreak/cmtemplate/servicetype/ServiceTypeResolver.java", "diffHunk": "@@ -0,0 +1,68 @@\n+package com.sequenceiq.cloudbreak.cmtemplate.servicetype;\n+\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+\n+import org.apache.commons.collections.CollectionUtils;\n+import org.apache.commons.lang3.StringUtils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.stereotype.Component;\n+\n+import com.sequenceiq.cloudbreak.cmtemplate.CmTemplateProcessor;\n+import com.sequenceiq.cloudbreak.exception.BadRequestException;\n+\n+@Component\n+public class ServiceTypeResolver {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(ServiceTypeResolver.class);\n+\n+    private final List<ServiceTypeMatcher> serviceTypeMatchers;\n+\n+    public ServiceTypeResolver(List<ServiceTypeMatcher> serviceTypeMatchers) {\n+        this.serviceTypeMatchers = serviceTypeMatchers;\n+    }\n+\n+    /**\n+     * Run all service type providers, in case of none of them will be applied, the default DATAHUB service type will be used.\n+     * If it will match multiple serviceTypes, that will fall back the default DATAHUB service type.\n+     * If there is a desired service type (provided by an another application) and the result won't be the same that will cause a runtime exception.\n+     * @param cmTemplateProcessor template processor that contains role and configuration data\n+     * @param desiredServiceType desired type service type that is provided by other service\n+     * @return resolved service type for the template\n+     */\n+    public String resolveServiceType(CmTemplateProcessor cmTemplateProcessor, String desiredServiceType) {\n+        Set<ServiceType> serviceTypes = new HashSet<>();\n+        ServiceType result = ServiceType.DATAHUB;\n+        if (StringUtils.isNotBlank(desiredServiceType) && !ServiceType.isValueValid(desiredServiceType)) {\n+            String errorMessage = String.format(\"'%s' is not a valid value for ServiceType enum.\", desiredServiceType);\n+            throw new BadRequestException(errorMessage);\n+        }\n+        if (CollectionUtils.isNotEmpty(serviceTypeMatchers)) {\n+            for (ServiceTypeMatcher serviceTypeMatcher : serviceTypeMatchers) {\n+                if (serviceTypeMatcher.match(cmTemplateProcessor)) {\n+                    serviceTypes.add(serviceTypeMatcher.getServiceType());\n+                }\n+            }\n+        }\n+        serviceTypes.remove(ServiceType.DATAHUB);\n+        if (serviceTypes.size() == 0) {\n+            LOGGER.debug(\"Service type only matched for dummy/default DataHub provider. Default DATAHUB service type will be used.\");\n+        } else if (serviceTypes.size() == 1) {\n+            result = serviceTypes.iterator().next();\n+            LOGGER.debug(\"The following service type will be selected based on the service type providers: {}\", result.value());\n+        } else {\n+            LOGGER.warn(\"You cannot match on multiple service types based on the service type providers. \" +", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Njg3ODg3Mw=="}, "originalCommit": {"oid": "ae4e33440085b5b7439d17d0b99e79ac1009d9f3"}, "originalPosition": 56}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3031, "cost": 1, "resetAt": "2021-11-12T20:44:06Z"}}}