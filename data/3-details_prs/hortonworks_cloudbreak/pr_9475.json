{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTIzNTY5MzY4", "number": 9475, "title": "CB 9241 Create load balancer for data lake HA", "bodyText": "This PR has been broken into multiple commits so the reviewers can review smaller chunks if desired. It will be squashed before being merged in.\nThis change adds a load balancer to the data lake that sits in front of Knox. It is configured automatically during data lake creation for AWS environments. This covers JIRAs CB-9241, CB-9365, and CB-9366.\nCommit 1: Create database tables and entities for load balancer\nCreates the database tables used to store load balancer and target group information, where a target group is a set of instance groups traffic will be forwarded to by the load balancer, and a type that determines what ports are used for forwarding. Sets up a relationship with the existing Stack and InstanceGroup entities such that:\nStack --OneToMany--> LoadBalancer --OneToMany--> TargetGroup\nTargetGroup <--ManyToMany--> InstanceGroup.\nCreates the services used to query the LoadBalancer and TargetGroup tables.\nCommit 2: Create load balancer from stack request\nWhen a StackV4Request is received, parse it to determine if a load balancer needs to be created. If the Knox gateway service is explicitly or implicitly defined, create a load balancer and target group for a Knox frontend load balancer. Add this load balancer to the Stack object. When the Stack is converted to a CloudStack, convert the Stack load balance to a CloadLoadBalancer. Adds new units tests to test both of these conversions.\nCommit 3: Create load balancer as part of AWS CloudFormation stack\nExpands the AWS Cloudformation templates to allow for the creation of load balancers, target groups, and listeners in the Cloudformation stack. These are created and configured as updates to the CF stack after its initial creation. Also adds a retry to the CF deletion logic if the intial deletion fails. This is to work around a problem with CF not deleting the load balancer assets in the correct order, resulting in failed deletions.\nCommit 4: Collect load balancer DNS metadata\nAdds a new stack creation action that collects and saves the load balancer metadata (for AWS, its DNS and hosted zone id). Currently this is only implemented for AWS.\nCommit 5: Set up DNS for load balancer\nIf a load balancer is created for a stack, registers a DNS entry with the PEM service for its endpoint, and adds the load balancer endpoint to the subject alternate names of the instance's certificate. Similarly deletes the load balancer DNS entry when the stack is deleted.\nCommit 6: Put the load balancer logic behind an entitlement\nAdds CDP_LOAD_BALANCER entitlement and addresses initial review comments.", "createdAt": "2020-11-18T23:14:21Z", "url": "https://github.com/hortonworks/cloudbreak/pull/9475", "merged": true, "mergeCommit": {"oid": "352e5e68b5901a0889fcfa488b3c47fb1df63496"}, "closed": true, "closedAt": "2020-12-03T19:30:41Z", "author": {"login": "hreeve-cloudera"}, "timelineItems": {"totalCount": 17, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdeAwfuAFqTUzNDMxMDAzNw==", "endCursor": "Y3Vyc29yOnYyOpPPAAABdioS6LgFqTU0NDMwODE2Nw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTM0MzEwMDM3", "url": "https://github.com/hortonworks/cloudbreak/pull/9475#pullrequestreview-534310037", "createdAt": "2020-11-19T11:07:56Z", "commit": {"oid": "de55a4bb1b4971dd8f935faf64cd1e01685b9bb1"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOVQxMTowNzo1NlrOH2X8VA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOVQxMTowNzo1NlrOH2X8VA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjc3NzQyOA==", "bodyText": "Nit: remove unnecessary space after metadata().", "url": "https://github.com/hortonworks/cloudbreak/pull/9475#discussion_r526777428", "createdAt": "2020-11-19T11:07:56Z", "author": {"login": "lajosrodek"}, "path": "cloud-reactor/src/main/java/com/sequenceiq/cloudbreak/cloud/handler/CollectLoadBalancerMetadataHandler.java", "diffHunk": "@@ -0,0 +1,59 @@\n+package com.sequenceiq.cloudbreak.cloud.handler;\n+\n+import java.util.List;\n+\n+import javax.inject.Inject;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.stereotype.Component;\n+\n+import com.sequenceiq.cloudbreak.cloud.CloudConnector;\n+import com.sequenceiq.cloudbreak.cloud.context.AuthenticatedContext;\n+import com.sequenceiq.cloudbreak.cloud.event.loadbalancer.CollectLoadBalancerMetadataRequest;\n+import com.sequenceiq.cloudbreak.cloud.event.loadbalancer.CollectLoadBalancerMetadataResult;\n+import com.sequenceiq.cloudbreak.cloud.init.CloudPlatformConnectors;\n+import com.sequenceiq.cloudbreak.cloud.model.CloudLoadBalancerMetadata;\n+\n+import reactor.bus.Event;\n+import reactor.bus.EventBus;\n+\n+@Component\n+public class CollectLoadBalancerMetadataHandler implements CloudPlatformEventHandler<CollectLoadBalancerMetadataRequest> {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(CollectLoadBalancerMetadataHandler.class);\n+\n+    @Inject\n+    private CloudPlatformConnectors cloudPlatformConnectors;\n+\n+    @Inject\n+    private EventBus eventBus;\n+\n+    @Override\n+    public Class<CollectLoadBalancerMetadataRequest> type() {\n+        return CollectLoadBalancerMetadataRequest.class;\n+    }\n+\n+    @Override\n+    public void accept(Event<CollectLoadBalancerMetadataRequest> collectLBMetadataRequestEvent) {\n+        LOGGER.debug(\"Received event: {}\", collectLBMetadataRequestEvent);\n+        CollectLoadBalancerMetadataRequest request = collectLBMetadataRequestEvent.getData();\n+        try {\n+            CloudConnector<Object> connector = cloudPlatformConnectors.get(request.getCloudContext().getPlatformVariant());\n+            AuthenticatedContext ac = connector.authentication().authenticate(request.getCloudContext(), request.getCloudCredential());\n+\n+            List<CloudLoadBalancerMetadata> loadBalancerStatuses = connector.metadata() .collectLoadBalancer(ac, request.getGatewayGroupNames());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "de55a4bb1b4971dd8f935faf64cd1e01685b9bb1"}, "originalPosition": 45}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTM0ODA0MTk1", "url": "https://github.com/hortonworks/cloudbreak/pull/9475#pullrequestreview-534804195", "createdAt": "2020-11-19T20:01:27Z", "commit": {"oid": "5e43c56ce52d7d662196ebae07c6db60206b53a9"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 15, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOVQyMDowMToyN1rOH2vcbw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOVQyMDo1NjoxN1rOH2xShA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzE2MjQ3OQ==", "bodyText": "Could do a instanceGroups.stream().filter(group -> InstanceGroupType.Gateway.equals(group.getInstanceGroupType).findAny().orElse(null);", "url": "https://github.com/hortonworks/cloudbreak/pull/9475#discussion_r527162479", "createdAt": "2020-11-19T20:01:27Z", "author": {"login": "frozenwizard"}, "path": "core-model/src/main/java/com/sequenceiq/cloudbreak/domain/stack/Stack.java", "diffHunk": "@@ -574,6 +579,15 @@ public InstanceMetaData getPrimaryGatewayInstance() {\n         return metaData.orElse(null);\n     }\n \n+    public InstanceGroup getGatewayGroup() {\n+        for (InstanceGroup instanceGroup : instanceGroups) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5e43c56ce52d7d662196ebae07c6db60206b53a9"}, "originalPosition": 24}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzE2MzYwNw==", "bodyText": "probably want to do a fetch type of lazy", "url": "https://github.com/hortonworks/cloudbreak/pull/9475#discussion_r527163607", "createdAt": "2020-11-19T20:03:32Z", "author": {"login": "frozenwizard"}, "path": "core-model/src/main/java/com/sequenceiq/cloudbreak/domain/stack/instance/InstanceGroup.java", "diffHunk": "@@ -70,6 +73,9 @@\n \n     private int initialNodeCount;\n \n+    @ManyToMany(mappedBy = \"instanceGroups\", fetch = FetchType.EAGER)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5e43c56ce52d7d662196ebae07c6db60206b53a9"}, "originalPosition": 24}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzE2NDYwNQ==", "bodyText": "could we just initialize targetgroups = new HashSet<>() at the top of the file?", "url": "https://github.com/hortonworks/cloudbreak/pull/9475#discussion_r527164605", "createdAt": "2020-11-19T20:05:18Z", "author": {"login": "frozenwizard"}, "path": "core-model/src/main/java/com/sequenceiq/cloudbreak/domain/stack/instance/InstanceGroup.java", "diffHunk": "@@ -208,6 +214,21 @@ public void setCloudIdentityType(CloudIdentityType cloudIdentityType) {\n         attributes = new Json(attributeMap);\n     }\n \n+    public Set<TargetGroup> getTargetGroups() {\n+        return targetGroups;\n+    }\n+\n+    public void setTargetGroups(Set<TargetGroup> targetGroups) {\n+        this.targetGroups = targetGroups;\n+    }\n+\n+    public void addTargetGroup(TargetGroup targetGroup) {\n+        if (targetGroups == null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5e43c56ce52d7d662196ebae07c6db60206b53a9"}, "originalPosition": 43}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzE2NTM5MQ==", "bodyText": "Do we need to make this a abstract class and subtype a awsloadbalancer from it so we can later support azure's loadbalancing?", "url": "https://github.com/hortonworks/cloudbreak/pull/9475#discussion_r527165391", "createdAt": "2020-11-19T20:06:53Z", "author": {"login": "frozenwizard"}, "path": "core-model/src/main/java/com/sequenceiq/cloudbreak/domain/stack/loadbalancer/LoadBalancer.java", "diffHunk": "@@ -0,0 +1,111 @@\n+package com.sequenceiq.cloudbreak.domain.stack.loadbalancer;\n+\n+import java.util.HashSet;\n+import java.util.Set;\n+\n+import javax.persistence.CascadeType;\n+import javax.persistence.Entity;\n+import javax.persistence.GeneratedValue;\n+import javax.persistence.GenerationType;\n+import javax.persistence.Id;\n+import javax.persistence.ManyToOne;\n+import javax.persistence.OneToMany;\n+import javax.persistence.SequenceGenerator;\n+\n+import com.sequenceiq.cloudbreak.domain.ProvisionEntity;\n+import com.sequenceiq.cloudbreak.domain.stack.Stack;\n+\n+@Entity\n+public class LoadBalancer implements ProvisionEntity  {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5e43c56ce52d7d662196ebae07c6db60206b53a9"}, "originalPosition": 19}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzE2NzIzOA==", "bodyText": "Is there a jira for this one or is it a later commit in this pr?", "url": "https://github.com/hortonworks/cloudbreak/pull/9475#discussion_r527167238", "createdAt": "2020-11-19T20:10:24Z", "author": {"login": "frozenwizard"}, "path": "core/src/main/java/com/sequenceiq/cloudbreak/converter/v4/stacks/StackV4RequestToStackConverter.java", "diffHunk": "@@ -335,6 +344,40 @@ private void validateStackAuthentication(StackV4Request source) {\n         return convertedSet;\n     }\n \n+    private Set<LoadBalancer> createLoadBalancers(StackV4Request source, Stack stack) {\n+        Set<LoadBalancer> loadBalancers = new HashSet<>();\n+        Set<TargetGroup> targetGroups = new HashSet<>();\n+        // TODO expand this to data hubs\n+        if (StackType.DATALAKE.equals(source.getType())) {\n+            LOGGER.info(\"Setting up load balancers for stack {}\", source.getName());\n+            Set<String> knoxGatewayGroupNames = loadBalancerConfigService.getKnoxGatewayGroups(stack);\n+            Set<InstanceGroup> knoxGatewayGroups = stack.getInstanceGroups().stream()\n+                .filter(ig -> knoxGatewayGroupNames.contains(ig.getGroupName()))\n+                .collect(Collectors.toSet());\n+            if (!knoxGatewayGroups.isEmpty()) {\n+                LOGGER.info(\"Knox gateway instance found; enabling Knox load balancer configuration.\");\n+                TargetGroup targetGroup = new TargetGroup();\n+                targetGroup.setType(TargetGroupType.KNOX.name());\n+                targetGroup.setInstanceGroups(knoxGatewayGroups);\n+                targetGroups.add(targetGroup);\n+                knoxGatewayGroups.forEach(ig -> ig.addTargetGroup(targetGroup));\n+            }\n+            // TODO create target group for CM instances", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f2bf0c1f201d9b486f2da3f6f2f3cef16ad9c26d"}, "originalPosition": 63}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzE2NzY4Mw==", "bodyText": "Assuming later commit has this in there?", "url": "https://github.com/hortonworks/cloudbreak/pull/9475#discussion_r527167683", "createdAt": "2020-11-19T20:11:12Z", "author": {"login": "frozenwizard"}, "path": "core/src/main/java/com/sequenceiq/cloudbreak/converter/v4/stacks/StackV4RequestToStackConverter.java", "diffHunk": "@@ -335,6 +344,40 @@ private void validateStackAuthentication(StackV4Request source) {\n         return convertedSet;\n     }\n \n+    private Set<LoadBalancer> createLoadBalancers(StackV4Request source, Stack stack) {\n+        Set<LoadBalancer> loadBalancers = new HashSet<>();\n+        Set<TargetGroup> targetGroups = new HashSet<>();\n+        // TODO expand this to data hubs\n+        if (StackType.DATALAKE.equals(source.getType())) {\n+            LOGGER.info(\"Setting up load balancers for stack {}\", source.getName());\n+            Set<String> knoxGatewayGroupNames = loadBalancerConfigService.getKnoxGatewayGroups(stack);\n+            Set<InstanceGroup> knoxGatewayGroups = stack.getInstanceGroups().stream()\n+                .filter(ig -> knoxGatewayGroupNames.contains(ig.getGroupName()))\n+                .collect(Collectors.toSet());\n+            if (!knoxGatewayGroups.isEmpty()) {\n+                LOGGER.info(\"Knox gateway instance found; enabling Knox load balancer configuration.\");\n+                TargetGroup targetGroup = new TargetGroup();\n+                targetGroup.setType(TargetGroupType.KNOX.name());\n+                targetGroup.setInstanceGroups(knoxGatewayGroups);\n+                targetGroups.add(targetGroup);\n+                knoxGatewayGroups.forEach(ig -> ig.addTargetGroup(targetGroup));\n+            }\n+            // TODO create target group for CM instances\n+        }\n+\n+        if (!targetGroups.isEmpty()) {\n+            LoadBalancer loadBalancer = new LoadBalancer();\n+            loadBalancer.setStack(stack);\n+            // TODO actually figure out the type we need here", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f2bf0c1f201d9b486f2da3f6f2f3cef16ad9c26d"}, "originalPosition": 69}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzE2OTMzNQ==", "bodyText": "Should this be in an entitlement?", "url": "https://github.com/hortonworks/cloudbreak/pull/9475#discussion_r527169335", "createdAt": "2020-11-19T20:14:12Z", "author": {"login": "frozenwizard"}, "path": "core/src/main/java/com/sequenceiq/cloudbreak/converter/v4/stacks/StackV4RequestToStackConverter.java", "diffHunk": "@@ -335,6 +344,40 @@ private void validateStackAuthentication(StackV4Request source) {\n         return convertedSet;\n     }\n \n+    private Set<LoadBalancer> createLoadBalancers(StackV4Request source, Stack stack) {\n+        Set<LoadBalancer> loadBalancers = new HashSet<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f2bf0c1f201d9b486f2da3f6f2f3cef16ad9c26d"}, "originalPosition": 46}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzE3NzgwNA==", "bodyText": "What happens if cluster is null?", "url": "https://github.com/hortonworks/cloudbreak/pull/9475#discussion_r527177804", "createdAt": "2020-11-19T20:29:27Z", "author": {"login": "frozenwizard"}, "path": "core/src/main/java/com/sequenceiq/cloudbreak/service/LoadBalancerConfigService.java", "diffHunk": "@@ -0,0 +1,80 @@\n+package com.sequenceiq.cloudbreak.service;\n+\n+import com.sequenceiq.cloudbreak.domain.stack.loadbalancer.TargetGroup;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.stereotype.Service;\n+\n+import com.sequenceiq.cloudbreak.cmtemplate.CmTemplateProcessor;\n+import com.sequenceiq.cloudbreak.cmtemplate.configproviders.knox.KnoxRoles;\n+import com.sequenceiq.cloudbreak.domain.stack.Stack;\n+import com.sequenceiq.cloudbreak.domain.stack.cluster.Cluster;\n+import com.sequenceiq.cloudbreak.domain.stack.instance.InstanceGroup;\n+import com.sequenceiq.cloudbreak.template.model.ServiceComponent;\n+import com.sequenceiq.common.api.type.InstanceGroupType;\n+import com.sequenceiq.common.api.type.LoadBalancerType;\n+\n+@Service\n+public class LoadBalancerConfigService {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(LoadBalancerConfigService.class);\n+\n+    private static final String ENDPOINT_SUFFIX = \"gateway\";\n+\n+    private static final String PUBLIC_SUFFIX = \"external\";\n+\n+    private static final Set<Integer> DEFAULT_KNOX_PORTS = Set.of(443);\n+\n+    public Set<String> getKnoxGatewayGroups(Stack stack) {\n+        LOGGER.info(\"Fetching list of instance groups with Knox gateway installed\");\n+        Set<String> groupNames = new HashSet<>();\n+        Cluster cluster = stack.getCluster();\n+        if (cluster != null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f2bf0c1f201d9b486f2da3f6f2f3cef16ad9c26d"}, "originalPosition": 40}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzE4MTYwMg==", "bodyText": "More descriptive variable name please.\nAlso i feel like you could just do String s = stack.getname()+\"-\"+ENDPOING_SUFFIX;  and if public +=\"-\"+PUBLIC_SUFFIX.", "url": "https://github.com/hortonworks/cloudbreak/pull/9475#discussion_r527181602", "createdAt": "2020-11-19T20:35:45Z", "author": {"login": "frozenwizard"}, "path": "core/src/main/java/com/sequenceiq/cloudbreak/service/LoadBalancerConfigService.java", "diffHunk": "@@ -0,0 +1,80 @@\n+package com.sequenceiq.cloudbreak.service;\n+\n+import com.sequenceiq.cloudbreak.domain.stack.loadbalancer.TargetGroup;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.stereotype.Service;\n+\n+import com.sequenceiq.cloudbreak.cmtemplate.CmTemplateProcessor;\n+import com.sequenceiq.cloudbreak.cmtemplate.configproviders.knox.KnoxRoles;\n+import com.sequenceiq.cloudbreak.domain.stack.Stack;\n+import com.sequenceiq.cloudbreak.domain.stack.cluster.Cluster;\n+import com.sequenceiq.cloudbreak.domain.stack.instance.InstanceGroup;\n+import com.sequenceiq.cloudbreak.template.model.ServiceComponent;\n+import com.sequenceiq.common.api.type.InstanceGroupType;\n+import com.sequenceiq.common.api.type.LoadBalancerType;\n+\n+@Service\n+public class LoadBalancerConfigService {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(LoadBalancerConfigService.class);\n+\n+    private static final String ENDPOINT_SUFFIX = \"gateway\";\n+\n+    private static final String PUBLIC_SUFFIX = \"external\";\n+\n+    private static final Set<Integer> DEFAULT_KNOX_PORTS = Set.of(443);\n+\n+    public Set<String> getKnoxGatewayGroups(Stack stack) {\n+        LOGGER.info(\"Fetching list of instance groups with Knox gateway installed\");\n+        Set<String> groupNames = new HashSet<>();\n+        Cluster cluster = stack.getCluster();\n+        if (cluster != null) {\n+            CmTemplateProcessor cmTemplateProcessor = new CmTemplateProcessor(cluster.getBlueprint().getBlueprintText());\n+            Map<String, Set<ServiceComponent>> components = cmTemplateProcessor.getServiceComponentsByHostGroup();\n+            LOGGER.info(\"Checking if Knox gateway is explicitly defined\");\n+            groupNames = components.entrySet().stream()\n+                .filter(e -> e.getValue().stream().anyMatch(c -> KnoxRoles.KNOX_GATEWAY.equals(c.getComponent())))\n+                .map(Map.Entry::getKey)\n+                .collect(Collectors.toSet());\n+        }\n+\n+        if (groupNames.isEmpty()) {\n+            LOGGER.info(\"Knox gateway is not explicitly defined; searching for CM gateway hosts\");\n+            groupNames = stack.getInstanceGroups().stream()\n+                .filter(i -> InstanceGroupType.isGateway(i.getInstanceGroupType()))\n+                .map(InstanceGroup::getGroupName)\n+                .collect(Collectors.toSet());\n+        }\n+\n+        if (groupNames.isEmpty()) {\n+            LOGGER.info(\"No Knox gateway instance groups found\");\n+        }\n+        return groupNames;\n+    }\n+\n+    public String generateLoadBalancerEndpoint(Stack stack, LoadBalancerType type) {\n+        List<String> s = Arrays.asList(stack.getName(), ENDPOINT_SUFFIX);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f2bf0c1f201d9b486f2da3f6f2f3cef16ad9c26d"}, "originalPosition": 65}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzE4MjQ4MA==", "bodyText": "CM?", "url": "https://github.com/hortonworks/cloudbreak/pull/9475#discussion_r527182480", "createdAt": "2020-11-19T20:37:07Z", "author": {"login": "frozenwizard"}, "path": "core/src/main/java/com/sequenceiq/cloudbreak/service/LoadBalancerConfigService.java", "diffHunk": "@@ -0,0 +1,80 @@\n+package com.sequenceiq.cloudbreak.service;\n+\n+import com.sequenceiq.cloudbreak.domain.stack.loadbalancer.TargetGroup;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.stereotype.Service;\n+\n+import com.sequenceiq.cloudbreak.cmtemplate.CmTemplateProcessor;\n+import com.sequenceiq.cloudbreak.cmtemplate.configproviders.knox.KnoxRoles;\n+import com.sequenceiq.cloudbreak.domain.stack.Stack;\n+import com.sequenceiq.cloudbreak.domain.stack.cluster.Cluster;\n+import com.sequenceiq.cloudbreak.domain.stack.instance.InstanceGroup;\n+import com.sequenceiq.cloudbreak.template.model.ServiceComponent;\n+import com.sequenceiq.common.api.type.InstanceGroupType;\n+import com.sequenceiq.common.api.type.LoadBalancerType;\n+\n+@Service\n+public class LoadBalancerConfigService {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(LoadBalancerConfigService.class);\n+\n+    private static final String ENDPOINT_SUFFIX = \"gateway\";\n+\n+    private static final String PUBLIC_SUFFIX = \"external\";\n+\n+    private static final Set<Integer> DEFAULT_KNOX_PORTS = Set.of(443);\n+\n+    public Set<String> getKnoxGatewayGroups(Stack stack) {\n+        LOGGER.info(\"Fetching list of instance groups with Knox gateway installed\");\n+        Set<String> groupNames = new HashSet<>();\n+        Cluster cluster = stack.getCluster();\n+        if (cluster != null) {\n+            CmTemplateProcessor cmTemplateProcessor = new CmTemplateProcessor(cluster.getBlueprint().getBlueprintText());\n+            Map<String, Set<ServiceComponent>> components = cmTemplateProcessor.getServiceComponentsByHostGroup();\n+            LOGGER.info(\"Checking if Knox gateway is explicitly defined\");\n+            groupNames = components.entrySet().stream()\n+                .filter(e -> e.getValue().stream().anyMatch(c -> KnoxRoles.KNOX_GATEWAY.equals(c.getComponent())))\n+                .map(Map.Entry::getKey)\n+                .collect(Collectors.toSet());\n+        }\n+\n+        if (groupNames.isEmpty()) {\n+            LOGGER.info(\"Knox gateway is not explicitly defined; searching for CM gateway hosts\");\n+            groupNames = stack.getInstanceGroups().stream()\n+                .filter(i -> InstanceGroupType.isGateway(i.getInstanceGroupType()))\n+                .map(InstanceGroup::getGroupName)\n+                .collect(Collectors.toSet());\n+        }\n+\n+        if (groupNames.isEmpty()) {\n+            LOGGER.info(\"No Knox gateway instance groups found\");\n+        }\n+        return groupNames;\n+    }\n+\n+    public String generateLoadBalancerEndpoint(Stack stack, LoadBalancerType type) {\n+        List<String> s = Arrays.asList(stack.getName(), ENDPOINT_SUFFIX);\n+        if (LoadBalancerType.PUBLIC.equals(type)) {\n+            s.add(PUBLIC_SUFFIX);\n+        }\n+        return String.join(\"-\", s);\n+    }\n+\n+    public Set<Integer> getPortsForTargetGroup(TargetGroup targetGroup) {\n+        switch (targetGroup.getType()) {\n+            case \"KNOX\":", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f2bf0c1f201d9b486f2da3f6f2f3cef16ad9c26d"}, "originalPosition": 74}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzE4NzgzMw==", "bodyText": "Could do a Optional.ofNullable(context.loadBalncers).orElse(new ArrayList());", "url": "https://github.com/hortonworks/cloudbreak/pull/9475#discussion_r527187833", "createdAt": "2020-11-19T20:47:17Z", "author": {"login": "frozenwizard"}, "path": "cloud-aws/src/main/java/com/sequenceiq/cloudbreak/cloud/aws/CloudFormationTemplateBuilder.java", "diffHunk": "@@ -91,6 +92,7 @@ public String build(ModelContext context) {\n         model.put(\"outboundInternetTraffic\", context.outboundInternetTraffic);\n         model.put(\"vpcCidrs\", context.vpcCidrs);\n         model.put(\"prefixListIds\", context.prefixListIds);\n+        model.put(\"loadBalancers\", context.loadBalancers == null ? new ArrayList<>() : context.loadBalancers);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2ed3b72c53f6bf1676d0a131295045c8dd203b4f"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzE4OTkwOQ==", "bodyText": "there's a findFirst() you can use instead.", "url": "https://github.com/hortonworks/cloudbreak/pull/9475#discussion_r527189909", "createdAt": "2020-11-19T20:51:10Z", "author": {"login": "frozenwizard"}, "path": "cloud-aws/src/main/java/com/sequenceiq/cloudbreak/cloud/aws/connector/resource/AwsLaunchService.java", "diffHunk": "@@ -171,9 +164,128 @@\n \n         awsCloudWatchService.addCloudWatchAlarmsForSystemFailures(instances, stack, regionName, credentialView);\n \n+        updateCloudformationWithLoadBalancer(ac, stack, resourceNotifier, modelContext, instances);\n+\n         return awsResourceConnector.check(ac, instances);\n     }\n \n+    private ModelContext buildDefaultModelContext(AuthenticatedContext ac, CloudStack stack, PersistenceNotifier resourceNotifier) {\n+        AwsCredentialView credentialView = new AwsCredentialView(ac.getCloudCredential());\n+        String regionName = ac.getCloudContext().getLocation().getRegion().value();\n+        AmazonEC2Client amazonEC2Client = awsClient.createAccess(credentialView, regionName);\n+        Network network = stack.getNetwork();\n+        AwsNetworkView awsNetworkView = new AwsNetworkView(network);\n+        boolean mapPublicIpOnLaunch = awsNetworkService.isMapPublicOnLaunch(awsNetworkView, amazonEC2Client);\n+\n+        boolean existingVPC = awsNetworkView.isExistingVPC();\n+        boolean existingSubnet = awsNetworkView.isExistingSubnet();\n+\n+        String cidr = network.getSubnet().getCidr();\n+        String subnet = isNoCIDRProvided(existingVPC, existingSubnet, cidr) ? awsNetworkService.findNonOverLappingCIDR(ac, stack) : cidr;\n+        AwsInstanceProfileView awsInstanceProfileView = new AwsInstanceProfileView(stack);\n+        ModelContext modelContext = new ModelContext()\n+            .withAuthenticatedContext(ac)\n+            .withStack(stack)\n+            .withExistingVpc(existingVPC)\n+            .withExistingIGW(awsNetworkView.isExistingIGW())\n+            .withExistingSubnetCidr(existingSubnet ? awsNetworkService.getExistingSubnetCidr(ac, stack) : null)\n+            .withExistinVpcCidr(awsNetworkService.getVpcCidrs(ac, stack))\n+            .withExistingSubnetIds(existingSubnet ? awsNetworkView.getSubnetList() : null)\n+            .mapPublicIpOnLaunch(mapPublicIpOnLaunch)\n+            .withEnableInstanceProfile(awsInstanceProfileView.isInstanceProfileAvailable())\n+            .withInstanceProfileAvailable(awsInstanceProfileView.isInstanceProfileAvailable())\n+            .withTemplate(stack.getTemplate())\n+            .withDefaultSubnet(subnet)\n+            .withOutboundInternetTraffic(network.getOutboundInternetTraffic())\n+            .withVpcCidrs(network.getNetworkCidrs())\n+            .withPrefixListIds(getPrefixListIds(amazonEC2Client, regionName, network.getOutboundInternetTraffic()))\n+            .withEncryptedAMIByGroupName(encryptedImageCopyService.createEncryptedImages(ac, stack, resourceNotifier));\n+\n+        return modelContext;\n+    }\n+\n+    private void updateCloudformationWithLoadBalancer(AuthenticatedContext ac, CloudStack stack, PersistenceNotifier resourceNotifier,\n+            ModelContext modelContext, List<CloudResource> instances) {\n+\n+        if (stack.getLoadBalancers().isPresent() && !stack.getLoadBalancers().get().isEmpty()) {\n+            if (modelContext == null) {\n+                modelContext = buildDefaultModelContext(ac, stack, resourceNotifier);\n+            }\n+\n+            List<AwsLoadBalancer> awsLoadBalancers = new ArrayList<>();\n+            List<CloudLoadBalancer> cloudLoadBalancers = stack.getLoadBalancers().get();\n+            for (CloudLoadBalancer cloudLoadBalancer : cloudLoadBalancers) {\n+                awsLoadBalancers.add(convert(cloudLoadBalancer, stack, instances));\n+            }\n+\n+            modelContext.withLoadBalancers(awsLoadBalancers);\n+            ListStackResourcesResult result = updateCloudFormationStack(ac, stack, modelContext);\n+\n+            for (AwsLoadBalancer loadBalancer : awsLoadBalancers) {\n+                for (AwsListener listener : loadBalancer.getListeners()) {\n+                    for (AwsTargetGroup targetGroup : listener.getTargetGroups()) {\n+                        StackResourceSummary targetGroupSummary = result.getStackResourceSummaries().stream()\n+                            .filter(stackResourceSummary -> targetGroup.getName().equals(stackResourceSummary.getLogicalResourceId()))\n+                            .collect(Collectors.toList())\n+                            .get(0);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2ed3b72c53f6bf1676d0a131295045c8dd203b4f"}, "originalPosition": 139}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzE4OTk1Nw==", "bodyText": "findFirst()", "url": "https://github.com/hortonworks/cloudbreak/pull/9475#discussion_r527189957", "createdAt": "2020-11-19T20:51:16Z", "author": {"login": "frozenwizard"}, "path": "cloud-aws/src/main/java/com/sequenceiq/cloudbreak/cloud/aws/connector/resource/AwsLaunchService.java", "diffHunk": "@@ -171,9 +164,128 @@\n \n         awsCloudWatchService.addCloudWatchAlarmsForSystemFailures(instances, stack, regionName, credentialView);\n \n+        updateCloudformationWithLoadBalancer(ac, stack, resourceNotifier, modelContext, instances);\n+\n         return awsResourceConnector.check(ac, instances);\n     }\n \n+    private ModelContext buildDefaultModelContext(AuthenticatedContext ac, CloudStack stack, PersistenceNotifier resourceNotifier) {\n+        AwsCredentialView credentialView = new AwsCredentialView(ac.getCloudCredential());\n+        String regionName = ac.getCloudContext().getLocation().getRegion().value();\n+        AmazonEC2Client amazonEC2Client = awsClient.createAccess(credentialView, regionName);\n+        Network network = stack.getNetwork();\n+        AwsNetworkView awsNetworkView = new AwsNetworkView(network);\n+        boolean mapPublicIpOnLaunch = awsNetworkService.isMapPublicOnLaunch(awsNetworkView, amazonEC2Client);\n+\n+        boolean existingVPC = awsNetworkView.isExistingVPC();\n+        boolean existingSubnet = awsNetworkView.isExistingSubnet();\n+\n+        String cidr = network.getSubnet().getCidr();\n+        String subnet = isNoCIDRProvided(existingVPC, existingSubnet, cidr) ? awsNetworkService.findNonOverLappingCIDR(ac, stack) : cidr;\n+        AwsInstanceProfileView awsInstanceProfileView = new AwsInstanceProfileView(stack);\n+        ModelContext modelContext = new ModelContext()\n+            .withAuthenticatedContext(ac)\n+            .withStack(stack)\n+            .withExistingVpc(existingVPC)\n+            .withExistingIGW(awsNetworkView.isExistingIGW())\n+            .withExistingSubnetCidr(existingSubnet ? awsNetworkService.getExistingSubnetCidr(ac, stack) : null)\n+            .withExistinVpcCidr(awsNetworkService.getVpcCidrs(ac, stack))\n+            .withExistingSubnetIds(existingSubnet ? awsNetworkView.getSubnetList() : null)\n+            .mapPublicIpOnLaunch(mapPublicIpOnLaunch)\n+            .withEnableInstanceProfile(awsInstanceProfileView.isInstanceProfileAvailable())\n+            .withInstanceProfileAvailable(awsInstanceProfileView.isInstanceProfileAvailable())\n+            .withTemplate(stack.getTemplate())\n+            .withDefaultSubnet(subnet)\n+            .withOutboundInternetTraffic(network.getOutboundInternetTraffic())\n+            .withVpcCidrs(network.getNetworkCidrs())\n+            .withPrefixListIds(getPrefixListIds(amazonEC2Client, regionName, network.getOutboundInternetTraffic()))\n+            .withEncryptedAMIByGroupName(encryptedImageCopyService.createEncryptedImages(ac, stack, resourceNotifier));\n+\n+        return modelContext;\n+    }\n+\n+    private void updateCloudformationWithLoadBalancer(AuthenticatedContext ac, CloudStack stack, PersistenceNotifier resourceNotifier,\n+            ModelContext modelContext, List<CloudResource> instances) {\n+\n+        if (stack.getLoadBalancers().isPresent() && !stack.getLoadBalancers().get().isEmpty()) {\n+            if (modelContext == null) {\n+                modelContext = buildDefaultModelContext(ac, stack, resourceNotifier);\n+            }\n+\n+            List<AwsLoadBalancer> awsLoadBalancers = new ArrayList<>();\n+            List<CloudLoadBalancer> cloudLoadBalancers = stack.getLoadBalancers().get();\n+            for (CloudLoadBalancer cloudLoadBalancer : cloudLoadBalancers) {\n+                awsLoadBalancers.add(convert(cloudLoadBalancer, stack, instances));\n+            }\n+\n+            modelContext.withLoadBalancers(awsLoadBalancers);\n+            ListStackResourcesResult result = updateCloudFormationStack(ac, stack, modelContext);\n+\n+            for (AwsLoadBalancer loadBalancer : awsLoadBalancers) {\n+                for (AwsListener listener : loadBalancer.getListeners()) {\n+                    for (AwsTargetGroup targetGroup : listener.getTargetGroups()) {\n+                        StackResourceSummary targetGroupSummary = result.getStackResourceSummaries().stream()\n+                            .filter(stackResourceSummary -> targetGroup.getName().equals(stackResourceSummary.getLogicalResourceId()))\n+                            .collect(Collectors.toList())\n+                            .get(0);\n+                        targetGroup.setArn(targetGroupSummary.getPhysicalResourceId());\n+                    }\n+                }\n+                StackResourceSummary loadBalancerSummary = result.getStackResourceSummaries().stream()\n+                    .filter(stackResourceSummary -> loadBalancer.getName().equals(stackResourceSummary.getLogicalResourceId()))", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2ed3b72c53f6bf1676d0a131295045c8dd203b4f"}, "originalPosition": 144}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzE5MTQ4MA==", "bodyText": "huh?  capatilize into lower case?", "url": "https://github.com/hortonworks/cloudbreak/pull/9475#discussion_r527191480", "createdAt": "2020-11-19T20:54:07Z", "author": {"login": "frozenwizard"}, "path": "cloud-aws/src/main/java/com/sequenceiq/cloudbreak/cloud/aws/loadbalancer/AwsTargetGroup.java", "diffHunk": "@@ -0,0 +1,56 @@\n+package com.sequenceiq.cloudbreak.cloud.aws.loadbalancer;\n+\n+import java.util.List;\n+\n+import org.apache.commons.lang3.StringUtils;\n+\n+public class AwsTargetGroup {\n+\n+    private static final String TARGET_GROUP_NAME_PREFIX = \"TargetGroupPort\";\n+\n+    private final int port;\n+\n+    private final String name;\n+\n+    private final int order;\n+\n+    private final List<String> instanceIds;\n+\n+    private String arn;\n+\n+    public AwsTargetGroup(int port, AwsLoadBalancerScheme scheme, int order, List<String> instanceIds) {\n+        this.port = port;\n+        this.order = order;\n+        this.instanceIds = instanceIds;\n+        name = getTargetGroupName(port, scheme);\n+    }\n+\n+    public int getPort() {\n+        return port;\n+    }\n+\n+    public String getArn() {\n+        return arn;\n+    }\n+\n+    public void setArn(String arn) {\n+        this.arn = arn;\n+    }\n+\n+    public String getName() {\n+        return name;\n+    }\n+\n+    public int getOrder() {\n+        return order;\n+    }\n+\n+    public List<String> getInstanceIds() {\n+        return instanceIds;\n+    }\n+\n+    private static String getTargetGroupName(int port, AwsLoadBalancerScheme scheme) {\n+        return TARGET_GROUP_NAME_PREFIX + port +\n+            StringUtils.capitalize(scheme.name().toLowerCase());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2ed3b72c53f6bf1676d0a131295045c8dd203b4f"}, "originalPosition": 54}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzE5MjcwOA==", "bodyText": "jira?", "url": "https://github.com/hortonworks/cloudbreak/pull/9475#discussion_r527192708", "createdAt": "2020-11-19T20:56:17Z", "author": {"login": "frozenwizard"}, "path": "cloud-aws/src/main/java/com/sequenceiq/cloudbreak/cloud/aws/AwsMetadataCollector.java", "diffHunk": "@@ -171,4 +176,30 @@ private void addKnownInstance(CloudInstance cloudInstance, Multimap<String, Inst\n                 .flatMap(reservation -> reservation.getInstances().stream())\n                 .collect(Collectors.toList());\n     }\n+\n+    @Override\n+    public List<CloudLoadBalancerMetadata> collectLoadBalancer(AuthenticatedContext ac, List<String> gatewayGroupNames) {\n+        LOGGER.debug(\"Collect AWS load balanacer metadata, for cluster {}\", ac.getCloudContext().getName());\n+\n+        String region = ac.getCloudContext().getLocation().getRegion().value();\n+\n+        List<CloudLoadBalancerMetadata> cloudLoadBalancerMetadata = new ArrayList<>();\n+        try {\n+            for (String groupName : gatewayGroupNames) {\n+                String loadBalancerName = AwsLoadBalancer.getLoadBalancerName(AwsLoadBalancerScheme.PRIVATE);\n+                LoadBalancer loadBalancer = cloudFormationStackUtil.getLoadBalancerByLogicalId(ac, loadBalancerName, region);\n+                cloudLoadBalancerMetadata.add(new CloudLoadBalancerMetadata(\n+                    groupName,\n+                    LoadBalancerType.PRIVATE,\n+                    loadBalancer.getDNSName(),\n+                    loadBalancer.getCanonicalHostedZoneId(),\n+                    null\n+                ));\n+                // TODO public endpoints", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "de55a4bb1b4971dd8f935faf64cd1e01685b9bb1"}, "originalPosition": 51}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "ad0044050b6e97a13e09cdb1e1a77a5cd29a4048", "author": {"user": {"login": "hreeve-cloudera", "name": null}}, "url": "https://github.com/hortonworks/cloudbreak/commit/ad0044050b6e97a13e09cdb1e1a77a5cd29a4048", "committedDate": "2020-11-19T23:32:24Z", "message": "Puts load balancer creation logic behind new CDP_LOAD_BALANCER entitlement.\nFixes a bug from earlier commit that was hit when trying to do a collected\nload balancer metadata action on a data lake with no load balancer. Initial\nreview changes."}, "afterCommit": {"oid": "6d89db90bbc4014d490a9f57fa21920c583a753c", "author": {"user": {"login": "hreeve-cloudera", "name": null}}, "url": "https://github.com/hortonworks/cloudbreak/commit/6d89db90bbc4014d490a9f57fa21920c583a753c", "committedDate": "2020-11-20T00:16:55Z", "message": "Puts load balancer creation logic behind new CDP_LOAD_BALANCER entitlement.\nFixes a bug from earlier commit that was hit when trying to do a collected\nload balancer metadata action on a data lake with no load balancer. Initial\nreview changes."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "6d89db90bbc4014d490a9f57fa21920c583a753c", "author": {"user": {"login": "hreeve-cloudera", "name": null}}, "url": "https://github.com/hortonworks/cloudbreak/commit/6d89db90bbc4014d490a9f57fa21920c583a753c", "committedDate": "2020-11-20T00:16:55Z", "message": "Puts load balancer creation logic behind new CDP_LOAD_BALANCER entitlement.\nFixes a bug from earlier commit that was hit when trying to do a collected\nload balancer metadata action on a data lake with no load balancer. Initial\nreview changes."}, "afterCommit": {"oid": "9135c5e07472800ad49f077d0c2a90995404f308", "author": {"user": {"login": "hreeve-cloudera", "name": null}}, "url": "https://github.com/hortonworks/cloudbreak/commit/9135c5e07472800ad49f077d0c2a90995404f308", "committedDate": "2020-11-20T16:25:43Z", "message": "Puts load balancer creation logic behind new CDP_LOAD_BALANCER entitlement.\nFixes a bug from earlier commit that was hit when trying to do a collected\nload balancer metadata action on a data lake with no load balancer. Initial\nreview changes."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "9135c5e07472800ad49f077d0c2a90995404f308", "author": {"user": {"login": "hreeve-cloudera", "name": null}}, "url": "https://github.com/hortonworks/cloudbreak/commit/9135c5e07472800ad49f077d0c2a90995404f308", "committedDate": "2020-11-20T16:25:43Z", "message": "Puts load balancer creation logic behind new CDP_LOAD_BALANCER entitlement.\nFixes a bug from earlier commit that was hit when trying to do a collected\nload balancer metadata action on a data lake with no load balancer. Initial\nreview changes."}, "afterCommit": {"oid": "13ceaf192fc8588e41c803e6764c650de33d9d8d", "author": {"user": {"login": "hreeve-cloudera", "name": null}}, "url": "https://github.com/hortonworks/cloudbreak/commit/13ceaf192fc8588e41c803e6764c650de33d9d8d", "committedDate": "2020-11-20T16:59:43Z", "message": "Puts load balancer creation logic behind new CDP_LOAD_BALANCER entitlement.\nFixes a bug from earlier commit that was hit when trying to do a collected\nload balancer metadata action on a data lake with no load balancer. Initial\nreview changes."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTM1NzI4Njkw", "url": "https://github.com/hortonworks/cloudbreak/pull/9475#pullrequestreview-535728690", "createdAt": "2020-11-20T19:45:18Z", "commit": {"oid": "13ceaf192fc8588e41c803e6764c650de33d9d8d"}, "state": "COMMENTED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "13ceaf192fc8588e41c803e6764c650de33d9d8d", "author": {"user": {"login": "hreeve-cloudera", "name": null}}, "url": "https://github.com/hortonworks/cloudbreak/commit/13ceaf192fc8588e41c803e6764c650de33d9d8d", "committedDate": "2020-11-20T16:59:43Z", "message": "Puts load balancer creation logic behind new CDP_LOAD_BALANCER entitlement.\nFixes a bug from earlier commit that was hit when trying to do a collected\nload balancer metadata action on a data lake with no load balancer. Initial\nreview changes."}, "afterCommit": {"oid": "a90cb7616434e79f07beb3b2521875754c0f15b0", "author": {"user": {"login": "hreeve-cloudera", "name": null}}, "url": "https://github.com/hortonworks/cloudbreak/commit/a90cb7616434e79f07beb3b2521875754c0f15b0", "committedDate": "2020-11-20T22:27:54Z", "message": "Puts load balancer creation logic behind new CDP_LOAD_BALANCER entitlement.\nFixes a bug from earlier commit that was hit when trying to do a collected\nload balancer metadata action on a data lake with no load balancer. Initial\nreview changes."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTM0ODMwNjIw", "url": "https://github.com/hortonworks/cloudbreak/pull/9475#pullrequestreview-534830620", "createdAt": "2020-11-19T20:36:53Z", "commit": {"oid": "5e43c56ce52d7d662196ebae07c6db60206b53a9"}, "state": "COMMENTED", "comments": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOVQyMDozNjo1M1rOH2wqAA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yMFQyMjo1ODo1OFrOH3jdDg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzE4MjMzNg==", "bodyText": "question: I see that we're typing ProvisionEntity in lots of places, but I don't see anywhere that it's used to narrow a type or provide for multiple implementations. It looks like it's just an extension of Serializable -- is that the case?", "url": "https://github.com/hortonworks/cloudbreak/pull/9475#discussion_r527182336", "createdAt": "2020-11-19T20:36:53Z", "author": {"login": "brycederriso"}, "path": "core-model/src/main/java/com/sequenceiq/cloudbreak/domain/stack/loadbalancer/TargetGroup.java", "diffHunk": "@@ -0,0 +1,55 @@\n+package com.sequenceiq.cloudbreak.domain.stack.loadbalancer;\n+\n+import com.sequenceiq.cloudbreak.domain.ProvisionEntity;\n+import java.util.Set;\n+\n+import javax.persistence.Entity;\n+import javax.persistence.FetchType;\n+import javax.persistence.GeneratedValue;\n+import javax.persistence.GenerationType;\n+import javax.persistence.Id;\n+import javax.persistence.ManyToMany;\n+import javax.persistence.ManyToOne;\n+import javax.persistence.SequenceGenerator;\n+\n+import com.sequenceiq.cloudbreak.domain.stack.instance.InstanceGroup;\n+\n+@Entity\n+public class TargetGroup implements ProvisionEntity {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5e43c56ce52d7d662196ebae07c6db60206b53a9"}, "originalPosition": 18}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzE4NTEwNA==", "bodyText": "suggestion: LoadBalancerPersistenceService maybe? I'm not generally a huge fan of the @Service ...Service pattern of naming.\nI think it's clearer to indicate that this deals with the persistence aspects of Load balancer entities.", "url": "https://github.com/hortonworks/cloudbreak/pull/9475#discussion_r527185104", "createdAt": "2020-11-19T20:42:17Z", "author": {"login": "brycederriso"}, "path": "core/src/main/java/com/sequenceiq/cloudbreak/service/stack/LoadBalancerService.java", "diffHunk": "@@ -0,0 +1,29 @@\n+package com.sequenceiq.cloudbreak.service.stack;\n+\n+import java.util.Set;\n+\n+import javax.inject.Inject;\n+\n+import org.springframework.stereotype.Service;\n+\n+import com.sequenceiq.cloudbreak.domain.stack.loadbalancer.LoadBalancer;\n+import com.sequenceiq.cloudbreak.repository.LoadBalancerRepository;\n+\n+@Service\n+public class LoadBalancerService {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5e43c56ce52d7d662196ebae07c6db60206b53a9"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzE4NzA2Mg==", "bodyText": "question: Do you know what system we use to apply sql migrations?", "url": "https://github.com/hortonworks/cloudbreak/pull/9475#discussion_r527187062", "createdAt": "2020-11-19T20:46:02Z", "author": {"login": "brycederriso"}, "path": "core/src/main/resources/schema/app/20201103154306_CB-9366_Create_load_balancer_metadata_table.sql", "diffHunk": "@@ -0,0 +1,62 @@\n+-- // CB-9366 Create load balancer metadata table\n+-- Migration SQL that makes the change goes here.\n+\n+CREATE SEQUENCE loadbalancer_id_seq START WITH 1\n+  INCREMENT BY 1\n+  NO MINVALUE\n+  NO MAXVALUE\n+  CACHE 1;\n+\n+CREATE TABLE loadbalancer (\n+    id bigint default nextval('loadbalancer_id_seq'::regclass) not null\n+      constraint loadbalancer_pkey\n+        primary key,\n+    dns character varying(255),\n+    hostedzoneid character varying(255),\n+    ip character varying(255),\n+    type character varying(255),\n+    endpoint character varying(255),\n+    stack_id bigint\n+      constraint fk_loadbalancer_stack_id\n+        references stack\n+);\n+\n+CREATE INDEX loadbalancer_stack_id on loadbalancer (stack_id);\n+\n+CREATE SEQUENCE targetgroup_id_seq START WITH 1\n+  INCREMENT BY 1\n+  NO MINVALUE\n+  NO MAXVALUE\n+  CACHE 1;\n+\n+CREATE TABLE targetgroup (\n+    id bigint default nextval('targetgroup_id_seq'::regclass) not null\n+      constraint targetgroup_pkey\n+        primary key,\n+    type character varying(255),\n+    loadbalancer_id bigint\n+      constraint fk_targetgroup_loadbalancer_id\n+          references loadbalancer\n+);\n+\n+CREATE TABLE targetgroup_instancegroup (\n+    targetgroups_id bigint NOT NULL,\n+    instancegroups_id bigint NOT NULL\n+);\n+\n+ALTER TABLE ONLY targetgroup_instancegroup ADD CONSTRAINT targetgroup_instancegroup_pkey PRIMARY KEY (targetgroups_id, instancegroups_id);\n+ALTER TABLE ONLY targetgroup_instancegroup ADD CONSTRAINT fk_targetgroup_instancegroup_targetgroup_id FOREIGN KEY (targetgroups_id) REFERENCES targetgroup(id);\n+ALTER TABLE ONLY targetgroup_instancegroup ADD CONSTRAINT fk_targetgroup_instancegroup_instancegroup_id FOREIGN KEY (instancegroups_id) REFERENCES instancegroup(id);\n+\n+-- //@UNDO", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5e43c56ce52d7d662196ebae07c6db60206b53a9"}, "originalPosition": 51}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzE5OTY2NQ==", "bodyText": "suggestion: Consider using an empty List here instead of null.\nI'd prefer the semantics of an empty List<CloudLoadBalancer> over Optional<List<CloudLoadBalancer> as well.\nI'd only expect that to throw a wrench in maybe serialization? Are there other reasons you chose Optional over an empty list?", "url": "https://github.com/hortonworks/cloudbreak/pull/9475#discussion_r527199665", "createdAt": "2020-11-19T21:08:56Z", "author": {"login": "brycederriso"}, "path": "cloud-api/src/main/java/com/sequenceiq/cloudbreak/cloud/model/CloudStack.java", "diffHunk": "@@ -33,8 +33,16 @@\n \n     private final Optional<SpiFileSystem> fileSystem;\n \n+    private final Optional<List<CloudLoadBalancer>> loadBalancers;\n+\n     public CloudStack(Collection<Group> groups, Network network, Image image, Map<String, String> parameters, Map<String, String> tags, String template,\n             InstanceAuthentication instanceAuthentication, String loginUserName, String publicKey, SpiFileSystem fileSystem) {\n+        this(groups, network, image, parameters, tags, template, instanceAuthentication, loginUserName, publicKey, fileSystem, null);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f2bf0c1f201d9b486f2da3f6f2f3cef16ad9c26d"}, "originalPosition": 8}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzIwMDIzOA==", "bodyText": "praise: Thank you for not making these just String constants!\nLove me some enums.", "url": "https://github.com/hortonworks/cloudbreak/pull/9475#discussion_r527200238", "createdAt": "2020-11-19T21:09:51Z", "author": {"login": "brycederriso"}, "path": "common-model/src/main/java/com/sequenceiq/common/api/type/LoadBalancerType.java", "diffHunk": "@@ -0,0 +1,6 @@\n+package com.sequenceiq.common.api.type;\n+\n+public enum LoadBalancerType {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f2bf0c1f201d9b486f2da3f6f2f3cef16ad9c26d"}, "originalPosition": 3}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODAwMjYxNA==", "bodyText": "question: The body of this if is adding knox TargetGroups to the targetGroups set if the stack we're working with is a Datalake?\nIf possible, I think it would be clearer to move the knoxGatewayGroups out of the if block and do an else:\n    private Set<LoadBalancer> createLoadBalancers(StackV4Request source, Stack stack) {\n        Set<LoadBalancer> loadBalancers = new HashSet<>();\n        Set<TargetGroup> targetGroups = new HashSet<>();\n        // TODO expand this to data hubs\n\n        Set<String> knoxGatewayGroupNames = loadBalancerConfigService.getKnoxGatewayGroups(stack);\n        Set<InstanceGroup> knoxGatewayGroups = stack.getInstanceGroups().stream()\n                .filter(ig -> knoxGatewayGroupNames.contains(ig.getGroupName()))\n                .collect(Collectors.toSet());\n\n        if (StackType.DATALAKE.equals(source.getType()) && !knoxGatewayGroups.isEmpty()) {\n            LOGGER.info(\"Setting up load balancers for stack {}\", source.getName());\n            LOGGER.info(\"Knox gateway instance found; enabling Knox load balancer configuration.\");\n            TargetGroup targetGroup = new TargetGroup();\n            targetGroup.setType(TargetGroupType.KNOX.name());\n            targetGroup.setInstanceGroups(knoxGatewayGroups);\n            targetGroups.add(targetGroup);\n            // TODO create target group for CM instances\n        } else {\n            LoadBalancer loadBalancer = new LoadBalancer();\n            loadBalancer.setStack(stack);\n            // TODO actually figure out the type we need here\n            loadBalancer.setType(LoadBalancerType.PRIVATE.name());\n            loadBalancer.setTargetGroups(targetGroups);\n            targetGroups.forEach(tg -> tg.setLoadBalancer(loadBalancer));\n            loadBalancers.add(loadBalancer);\n        }\n\n        return loadBalancers;\n    }", "url": "https://github.com/hortonworks/cloudbreak/pull/9475#discussion_r528002614", "createdAt": "2020-11-20T22:23:11Z", "author": {"login": "brycederriso"}, "path": "core/src/main/java/com/sequenceiq/cloudbreak/converter/v4/stacks/StackV4RequestToStackConverter.java", "diffHunk": "@@ -335,6 +344,40 @@ private void validateStackAuthentication(StackV4Request source) {\n         return convertedSet;\n     }\n \n+    private Set<LoadBalancer> createLoadBalancers(StackV4Request source, Stack stack) {\n+        Set<LoadBalancer> loadBalancers = new HashSet<>();\n+        Set<TargetGroup> targetGroups = new HashSet<>();\n+        // TODO expand this to data hubs\n+        if (StackType.DATALAKE.equals(source.getType())) {\n+            LOGGER.info(\"Setting up load balancers for stack {}\", source.getName());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f2bf0c1f201d9b486f2da3f6f2f3cef16ad9c26d"}, "originalPosition": 50}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODAxNDYwNg==", "bodyText": "suggestion: I'd generally prefer not to double nest streams like this, but I'm not sure it's avoidable here.\nYou could extract a function hostGroupContainsKnoxGateway that contains the e -> e.getValue().stream().anyMatch(c -> KnoxRoles.KNOX_GATEWAY.equals(c.getComponent())) portion and then do:\n            groupNames = components.entrySet().stream()\n                .filter(hostGroupContainsKnoxGateway)\n                .map(Map.Entry::getKey)\n                .collect(Collectors.toSet());\nBut, barring that, consider expanding the lambda function parameters e and c into what they they actually represent -- entry and serviceComponent I think.", "url": "https://github.com/hortonworks/cloudbreak/pull/9475#discussion_r528014606", "createdAt": "2020-11-20T22:58:58Z", "author": {"login": "brycederriso"}, "path": "core/src/main/java/com/sequenceiq/cloudbreak/service/LoadBalancerConfigService.java", "diffHunk": "@@ -0,0 +1,80 @@\n+package com.sequenceiq.cloudbreak.service;\n+\n+import com.sequenceiq.cloudbreak.domain.stack.loadbalancer.TargetGroup;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.stereotype.Service;\n+\n+import com.sequenceiq.cloudbreak.cmtemplate.CmTemplateProcessor;\n+import com.sequenceiq.cloudbreak.cmtemplate.configproviders.knox.KnoxRoles;\n+import com.sequenceiq.cloudbreak.domain.stack.Stack;\n+import com.sequenceiq.cloudbreak.domain.stack.cluster.Cluster;\n+import com.sequenceiq.cloudbreak.domain.stack.instance.InstanceGroup;\n+import com.sequenceiq.cloudbreak.template.model.ServiceComponent;\n+import com.sequenceiq.common.api.type.InstanceGroupType;\n+import com.sequenceiq.common.api.type.LoadBalancerType;\n+\n+@Service\n+public class LoadBalancerConfigService {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(LoadBalancerConfigService.class);\n+\n+    private static final String ENDPOINT_SUFFIX = \"gateway\";\n+\n+    private static final String PUBLIC_SUFFIX = \"external\";\n+\n+    private static final Set<Integer> DEFAULT_KNOX_PORTS = Set.of(443);\n+\n+    public Set<String> getKnoxGatewayGroups(Stack stack) {\n+        LOGGER.info(\"Fetching list of instance groups with Knox gateway installed\");\n+        Set<String> groupNames = new HashSet<>();\n+        Cluster cluster = stack.getCluster();\n+        if (cluster != null) {\n+            CmTemplateProcessor cmTemplateProcessor = new CmTemplateProcessor(cluster.getBlueprint().getBlueprintText());\n+            Map<String, Set<ServiceComponent>> components = cmTemplateProcessor.getServiceComponentsByHostGroup();\n+            LOGGER.info(\"Checking if Knox gateway is explicitly defined\");\n+            groupNames = components.entrySet().stream()\n+                .filter(e -> e.getValue().stream().anyMatch(c -> KnoxRoles.KNOX_GATEWAY.equals(c.getComponent())))", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f2bf0c1f201d9b486f2da3f6f2f3cef16ad9c26d"}, "originalPosition": 45}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTM3MDc5MDA4", "url": "https://github.com/hortonworks/cloudbreak/pull/9475#pullrequestreview-537079008", "createdAt": "2020-11-24T04:59:51Z", "commit": {"oid": "e19d80b459db1f5f36788bd56bc824be5253f860"}, "state": "COMMENTED", "comments": {"totalCount": 27, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNFQwNDo1OTo1MVrOH4sCHw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNVQwMTowODoxNlrOH5fRJw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTIwMzc0Mw==", "bodyText": "do you want to also rename the variable name to match the remaining refactoring.", "url": "https://github.com/hortonworks/cloudbreak/pull/9475#discussion_r529203743", "createdAt": "2020-11-24T04:59:51Z", "author": {"login": "enis"}, "path": "core/src/main/java/com/sequenceiq/cloudbreak/service/stack/flow/MetadataSetupService.java", "diffHunk": "@@ -54,7 +54,7 @@\n     private InstanceMetaDataService instanceMetaDataService;\n \n     @Inject\n-    private LoadBalancerService loadBalancerMetadataService;\n+    private LoadBalancerPersistenceService loadBalancerMetadataService;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e19d80b459db1f5f36788bd56bc824be5253f860"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDAwMzY4Ng==", "bodyText": "Just linking https://github.infra.cloudera.com/thunderhead/thunderhead/pull/2780 for other reviewers.", "url": "https://github.com/hortonworks/cloudbreak/pull/9475#discussion_r530003686", "createdAt": "2020-11-24T23:29:23Z", "author": {"login": "enis"}, "path": "auth-connector/src/main/java/com/sequenceiq/cloudbreak/auth/altus/model/Entitlement.java", "diffHunk": "@@ -33,5 +33,6 @@\n     DATAHUB_AZURE_AUTOSCALING,\n     CDP_CB_DATABASE_WIRE_ENCRYPTION,\n     CDP_ENABLE_DISTROX_INSTANCE_TYPES,\n-    CDP_SHOW_CLI;\n+    CDP_SHOW_CLI,\n+    CDP_DL_LOAD_BALANCER;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e19d80b459db1f5f36788bd56bc824be5253f860"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDAwODI4Ng==", "bodyText": "AWS load balancers bind to 1 ip per subnet for better cross-AZ availability. I think you should make this a List instead.", "url": "https://github.com/hortonworks/cloudbreak/pull/9475#discussion_r530008286", "createdAt": "2020-11-24T23:34:15Z", "author": {"login": "enis"}, "path": "cloud-api/src/main/java/com/sequenceiq/cloudbreak/cloud/model/CloudLoadBalancerMetadata.java", "diffHunk": "@@ -0,0 +1,37 @@\n+package com.sequenceiq.cloudbreak.cloud.model;\n+\n+import com.sequenceiq.common.api.type.LoadBalancerType;\n+\n+public class CloudLoadBalancerMetadata {\n+\n+    private final LoadBalancerType type;\n+\n+    private final String cloudDns;\n+\n+    private final String hostedZoneId;\n+\n+    private final String ip;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e19d80b459db1f5f36788bd56bc824be5253f860"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDAxMTk4OA==", "bodyText": "I do not see these two methods being used.", "url": "https://github.com/hortonworks/cloudbreak/pull/9475#discussion_r530011988", "createdAt": "2020-11-24T23:38:07Z", "author": {"login": "enis"}, "path": "cloud-aws/src/main/java/com/sequenceiq/cloudbreak/cloud/aws/AwsClient.java", "diffHunk": "@@ -170,6 +172,23 @@ public AmazonCloudFormationRetryClient createCloudFormationRetryClient(AmazonClo\n         return new AmazonCloudFormationRetryClient(amazonCloudFormationClient, retry);\n     }\n \n+    public AmazonElasticLoadBalancingClient createElasticLoadBalancingClient(AwsCredentialView awsCredential, String regionName) {\n+        AmazonElasticLoadBalancingClient client = isRoleAssumeRequired(awsCredential) ?\n+            new AmazonElasticLoadBalancingClient(createAwsSessionCredentialProvider(awsCredential), getDefaultClientConfiguration()) :\n+            new AmazonElasticLoadBalancingClient(createAwsCredentials(awsCredential), getDefaultClientConfiguration());\n+        client.setRegion(RegionUtils.getRegion(regionName));\n+        client.addRequestHandler(new AwsTracingRequestHandler(tracer));\n+        return client;\n+    }\n+\n+    public AmazonElbV2RetryClient createElbV2RetryClient(AwsCredentialView awsCredential, String regionName) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e19d80b459db1f5f36788bd56bc824be5253f860"}, "originalPosition": 29}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDAxMjA3Ng==", "bodyText": "same here.", "url": "https://github.com/hortonworks/cloudbreak/pull/9475#discussion_r530012076", "createdAt": "2020-11-24T23:38:13Z", "author": {"login": "enis"}, "path": "cloud-aws/src/main/java/com/sequenceiq/cloudbreak/cloud/aws/AwsClient.java", "diffHunk": "@@ -170,6 +172,23 @@ public AmazonCloudFormationRetryClient createCloudFormationRetryClient(AmazonClo\n         return new AmazonCloudFormationRetryClient(amazonCloudFormationClient, retry);\n     }\n \n+    public AmazonElasticLoadBalancingClient createElasticLoadBalancingClient(AwsCredentialView awsCredential, String regionName) {\n+        AmazonElasticLoadBalancingClient client = isRoleAssumeRequired(awsCredential) ?\n+            new AmazonElasticLoadBalancingClient(createAwsSessionCredentialProvider(awsCredential), getDefaultClientConfiguration()) :\n+            new AmazonElasticLoadBalancingClient(createAwsCredentials(awsCredential), getDefaultClientConfiguration());\n+        client.setRegion(RegionUtils.getRegion(regionName));\n+        client.addRequestHandler(new AwsTracingRequestHandler(tracer));\n+        return client;\n+    }\n+\n+    public AmazonElbV2RetryClient createElbV2RetryClient(AwsCredentialView awsCredential, String regionName) {\n+        return new AmazonElbV2RetryClient(createElasticLoadBalancingClient(awsCredential, regionName), retry);\n+    }\n+\n+    public AmazonElbV2RetryClient createElbV2RetryClient(AmazonElasticLoadBalancingClient amazonElasticLoadBalancingClient) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e19d80b459db1f5f36788bd56bc824be5253f860"}, "originalPosition": 33}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDAxNjA3MA==", "bodyText": "AWS and Azure calls these \"Internal\" load balancers rather than public / private. In AWS, they are called \"internet-facing\".\nLoadBalancerType in AWS is a selection between \"ELB\", \"NLB\", or \"ALB\" versus the internal vs internet-facing is called \"load balancer scheme\". See https://docs.aws.amazon.com/elasticloadbalancing/latest/userguide/how-elastic-load-balancing-works.html.\nWe do not necessarily need to follow the same naming, but just a sugestion if we want to be consistent with the cloud providers.", "url": "https://github.com/hortonworks/cloudbreak/pull/9475#discussion_r530016070", "createdAt": "2020-11-24T23:44:17Z", "author": {"login": "enis"}, "path": "common-model/src/main/java/com/sequenceiq/common/api/type/LoadBalancerType.java", "diffHunk": "@@ -0,0 +1,6 @@\n+package com.sequenceiq.common.api.type;\n+\n+public enum LoadBalancerType {\n+    PUBLIC,\n+    PRIVATE", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e19d80b459db1f5f36788bd56bc824be5253f860"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDAxNjYzNA==", "bodyText": "nit: typo in balanacer", "url": "https://github.com/hortonworks/cloudbreak/pull/9475#discussion_r530016634", "createdAt": "2020-11-24T23:45:45Z", "author": {"login": "enis"}, "path": "cloud-aws/src/main/java/com/sequenceiq/cloudbreak/cloud/aws/AwsMetadataCollector.java", "diffHunk": "@@ -171,4 +176,28 @@ private void addKnownInstance(CloudInstance cloudInstance, Multimap<String, Inst\n                 .flatMap(reservation -> reservation.getInstances().stream())\n                 .collect(Collectors.toList());\n     }\n+\n+    @Override\n+    public List<CloudLoadBalancerMetadata> collectLoadBalancer(AuthenticatedContext ac, List<String> loadBalancerTypes) {\n+        LOGGER.debug(\"Collect AWS load balanacer metadata, for cluster {}\", ac.getCloudContext().getName());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e19d80b459db1f5f36788bd56bc824be5253f860"}, "originalPosition": 35}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDAxNzM5MQ==", "bodyText": "we do not have access to the ip at this point?", "url": "https://github.com/hortonworks/cloudbreak/pull/9475#discussion_r530017391", "createdAt": "2020-11-24T23:48:06Z", "author": {"login": "enis"}, "path": "cloud-aws/src/main/java/com/sequenceiq/cloudbreak/cloud/aws/AwsMetadataCollector.java", "diffHunk": "@@ -171,4 +176,28 @@ private void addKnownInstance(CloudInstance cloudInstance, Multimap<String, Inst\n                 .flatMap(reservation -> reservation.getInstances().stream())\n                 .collect(Collectors.toList());\n     }\n+\n+    @Override\n+    public List<CloudLoadBalancerMetadata> collectLoadBalancer(AuthenticatedContext ac, List<String> loadBalancerTypes) {\n+        LOGGER.debug(\"Collect AWS load balanacer metadata, for cluster {}\", ac.getCloudContext().getName());\n+\n+        String region = ac.getCloudContext().getLocation().getRegion().value();\n+\n+        List<CloudLoadBalancerMetadata> cloudLoadBalancerMetadata = new ArrayList<>();\n+        try {\n+            for (String type : loadBalancerTypes) {\n+                String loadBalancerName = AwsLoadBalancer.getLoadBalancerName(AwsLoadBalancerScheme.valueOf(type));\n+                LoadBalancer loadBalancer = cloudFormationStackUtil.getLoadBalancerByLogicalId(ac, loadBalancerName, region);\n+                cloudLoadBalancerMetadata.add(new CloudLoadBalancerMetadata(\n+                    LoadBalancerType.valueOf(type),\n+                    loadBalancer.getDNSName(),\n+                    loadBalancer.getCanonicalHostedZoneId(),\n+                    null", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e19d80b459db1f5f36788bd56bc824be5253f860"}, "originalPosition": 48}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDAxOTk2OA==", "bodyText": "Do you want to rename subnet to newSubnetCidr to match the one in getStackParameters. I am assuming that this is the CIDR for the subnet.", "url": "https://github.com/hortonworks/cloudbreak/pull/9475#discussion_r530019968", "createdAt": "2020-11-24T23:55:56Z", "author": {"login": "enis"}, "path": "cloud-aws/src/main/java/com/sequenceiq/cloudbreak/cloud/aws/AwsStackRequestHelper.java", "diffHunk": "@@ -86,6 +87,20 @@ public DeleteStackRequest createDeleteStackRequest(String cFStackName) {\n                 .withStackName(cFStackName);\n     }\n \n+    public UpdateStackRequest createUpdateStackRequest(AuthenticatedContext ac, CloudStack stack, String cFStackName, String subnet, String cfTemplate) {\n+        return new UpdateStackRequest()\n+            .withStackName(cFStackName)\n+            .withTemplateBody(cfTemplate)\n+            .withTags(awsTaggingService.prepareCloudformationTags(ac, stack.getTags()))\n+            .withCapabilities(CAPABILITY_IAM)\n+            .withParameters(getStackParameters(ac, stack, cFStackName, subnet));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e19d80b459db1f5f36788bd56bc824be5253f860"}, "originalPosition": 18}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDAyMDIxNA==", "bodyText": "This overloads the function defined above. I suggest moving it to be just below that, and changing that function definition to call this with subnet = null", "url": "https://github.com/hortonworks/cloudbreak/pull/9475#discussion_r530020214", "createdAt": "2020-11-24T23:56:48Z", "author": {"login": "enis"}, "path": "cloud-aws/src/main/java/com/sequenceiq/cloudbreak/cloud/aws/AwsStackRequestHelper.java", "diffHunk": "@@ -86,6 +87,20 @@ public DeleteStackRequest createDeleteStackRequest(String cFStackName) {\n                 .withStackName(cFStackName);\n     }\n \n+    public UpdateStackRequest createUpdateStackRequest(AuthenticatedContext ac, CloudStack stack, String cFStackName, String subnet, String cfTemplate) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e19d80b459db1f5f36788bd56bc824be5253f860"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDAyMTQ2Mg==", "bodyText": "should be named describeLoadBalancers()", "url": "https://github.com/hortonworks/cloudbreak/pull/9475#discussion_r530021462", "createdAt": "2020-11-25T00:00:37Z", "author": {"login": "enis"}, "path": "cloud-aws/src/main/java/com/sequenceiq/cloudbreak/cloud/aws/client/AmazonElbV2RetryClient.java", "diffHunk": "@@ -0,0 +1,28 @@\n+package com.sequenceiq.cloudbreak.cloud.aws.client;\n+\n+import com.amazonaws.services.elasticloadbalancingv2.AmazonElasticLoadBalancingClient;\n+import com.amazonaws.services.elasticloadbalancingv2.model.DescribeLoadBalancersRequest;\n+import com.amazonaws.services.elasticloadbalancingv2.model.DescribeLoadBalancersResult;\n+import com.amazonaws.services.elasticloadbalancingv2.model.DescribeTargetGroupsRequest;\n+import com.amazonaws.services.elasticloadbalancingv2.model.DescribeTargetGroupsResult;\n+import com.sequenceiq.cloudbreak.service.Retry;\n+\n+public class AmazonElbV2RetryClient extends AmazonRetryClient {\n+\n+    private final AmazonElasticLoadBalancingClient client;\n+\n+    private final Retry retry;\n+\n+    public AmazonElbV2RetryClient(AmazonElasticLoadBalancingClient client, Retry retry) {\n+        this.client = client;\n+        this.retry = retry;\n+    }\n+\n+    public DescribeLoadBalancersResult describeLoadBalancer(DescribeLoadBalancersRequest request) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e19d80b459db1f5f36788bd56bc824be5253f860"}, "originalPosition": 21}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDAyMTU1NA==", "bodyText": "Should be named describeTargetGroups()", "url": "https://github.com/hortonworks/cloudbreak/pull/9475#discussion_r530021554", "createdAt": "2020-11-25T00:00:59Z", "author": {"login": "enis"}, "path": "cloud-aws/src/main/java/com/sequenceiq/cloudbreak/cloud/aws/client/AmazonElbV2RetryClient.java", "diffHunk": "@@ -0,0 +1,28 @@\n+package com.sequenceiq.cloudbreak.cloud.aws.client;\n+\n+import com.amazonaws.services.elasticloadbalancingv2.AmazonElasticLoadBalancingClient;\n+import com.amazonaws.services.elasticloadbalancingv2.model.DescribeLoadBalancersRequest;\n+import com.amazonaws.services.elasticloadbalancingv2.model.DescribeLoadBalancersResult;\n+import com.amazonaws.services.elasticloadbalancingv2.model.DescribeTargetGroupsRequest;\n+import com.amazonaws.services.elasticloadbalancingv2.model.DescribeTargetGroupsResult;\n+import com.sequenceiq.cloudbreak.service.Retry;\n+\n+public class AmazonElbV2RetryClient extends AmazonRetryClient {\n+\n+    private final AmazonElasticLoadBalancingClient client;\n+\n+    private final Retry retry;\n+\n+    public AmazonElbV2RetryClient(AmazonElasticLoadBalancingClient client, Retry retry) {\n+        this.client = client;\n+        this.retry = retry;\n+    }\n+\n+    public DescribeLoadBalancersResult describeLoadBalancer(DescribeLoadBalancersRequest request) {\n+        return retry.testWith2SecDelayMax15Times(() -> mapThrottlingError(() -> client.describeLoadBalancers(request)));\n+    }\n+\n+    public DescribeTargetGroupsResult describeLoadBalancer(DescribeTargetGroupsRequest request) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e19d80b459db1f5f36788bd56bc824be5253f860"}, "originalPosition": 25}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDAyNjg2Nw==", "bodyText": "some of these exist already in the scope  in the above call to this function. Maybe you can look at sending these to the function rather than recreating.", "url": "https://github.com/hortonworks/cloudbreak/pull/9475#discussion_r530026867", "createdAt": "2020-11-25T00:17:11Z", "author": {"login": "enis"}, "path": "cloud-aws/src/main/java/com/sequenceiq/cloudbreak/cloud/aws/connector/resource/AwsLaunchService.java", "diffHunk": "@@ -171,9 +165,132 @@\n \n         awsCloudWatchService.addCloudWatchAlarmsForSystemFailures(instances, stack, regionName, credentialView);\n \n+        updateCloudformationWithLoadBalancer(ac, stack, resourceNotifier, modelContext, instances);\n+\n         return awsResourceConnector.check(ac, instances);\n     }\n \n+    private ModelContext buildDefaultModelContext(AuthenticatedContext ac, CloudStack stack, PersistenceNotifier resourceNotifier) {\n+        AwsCredentialView credentialView = new AwsCredentialView(ac.getCloudCredential());\n+        String regionName = ac.getCloudContext().getLocation().getRegion().value();\n+        AmazonEC2Client amazonEC2Client = awsClient.createAccess(credentialView, regionName);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e19d80b459db1f5f36788bd56bc824be5253f860"}, "originalPosition": 87}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDAyNzExNA==", "bodyText": "nit: rename to updateCloudformationWithLoadBalancers()?", "url": "https://github.com/hortonworks/cloudbreak/pull/9475#discussion_r530027114", "createdAt": "2020-11-25T00:17:56Z", "author": {"login": "enis"}, "path": "cloud-aws/src/main/java/com/sequenceiq/cloudbreak/cloud/aws/connector/resource/AwsLaunchService.java", "diffHunk": "@@ -171,9 +165,132 @@\n \n         awsCloudWatchService.addCloudWatchAlarmsForSystemFailures(instances, stack, regionName, credentialView);\n \n+        updateCloudformationWithLoadBalancer(ac, stack, resourceNotifier, modelContext, instances);\n+\n         return awsResourceConnector.check(ac, instances);\n     }\n \n+    private ModelContext buildDefaultModelContext(AuthenticatedContext ac, CloudStack stack, PersistenceNotifier resourceNotifier) {\n+        AwsCredentialView credentialView = new AwsCredentialView(ac.getCloudCredential());\n+        String regionName = ac.getCloudContext().getLocation().getRegion().value();\n+        AmazonEC2Client amazonEC2Client = awsClient.createAccess(credentialView, regionName);\n+        Network network = stack.getNetwork();\n+        AwsNetworkView awsNetworkView = new AwsNetworkView(network);\n+        boolean mapPublicIpOnLaunch = awsNetworkService.isMapPublicOnLaunch(awsNetworkView, amazonEC2Client);\n+\n+        boolean existingVPC = awsNetworkView.isExistingVPC();\n+        boolean existingSubnet = awsNetworkView.isExistingSubnet();\n+\n+        String cidr = network.getSubnet().getCidr();\n+        String subnet = isNoCIDRProvided(existingVPC, existingSubnet, cidr) ? awsNetworkService.findNonOverLappingCIDR(ac, stack) : cidr;\n+        AwsInstanceProfileView awsInstanceProfileView = new AwsInstanceProfileView(stack);\n+        ModelContext modelContext = new ModelContext()\n+            .withAuthenticatedContext(ac)\n+            .withStack(stack)\n+            .withExistingVpc(existingVPC)\n+            .withExistingIGW(awsNetworkView.isExistingIGW())\n+            .withExistingSubnetCidr(existingSubnet ? awsNetworkService.getExistingSubnetCidr(ac, stack) : null)\n+            .withExistinVpcCidr(awsNetworkService.getVpcCidrs(ac, stack))\n+            .withExistingSubnetIds(existingSubnet ? awsNetworkView.getSubnetList() : null)\n+            .mapPublicIpOnLaunch(mapPublicIpOnLaunch)\n+            .withEnableInstanceProfile(awsInstanceProfileView.isInstanceProfileAvailable())\n+            .withInstanceProfileAvailable(awsInstanceProfileView.isInstanceProfileAvailable())\n+            .withTemplate(stack.getTemplate())\n+            .withDefaultSubnet(subnet)\n+            .withOutboundInternetTraffic(network.getOutboundInternetTraffic())\n+            .withVpcCidrs(network.getNetworkCidrs())\n+            .withPrefixListIds(getPrefixListIds(amazonEC2Client, regionName, network.getOutboundInternetTraffic()))\n+            .withEncryptedAMIByGroupName(encryptedImageCopyService.createEncryptedImages(ac, stack, resourceNotifier));\n+\n+        return modelContext;\n+    }\n+\n+    private void updateCloudformationWithLoadBalancer(AuthenticatedContext ac, CloudStack stack, PersistenceNotifier resourceNotifier,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e19d80b459db1f5f36788bd56bc824be5253f860"}, "originalPosition": 119}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDAyOTUzOA==", "bodyText": "Is this logic mimicing an existing behaviour? maybe you can make a comment here about what CIDR we chose and how.", "url": "https://github.com/hortonworks/cloudbreak/pull/9475#discussion_r530029538", "createdAt": "2020-11-25T00:25:20Z", "author": {"login": "enis"}, "path": "cloud-aws/src/main/java/com/sequenceiq/cloudbreak/cloud/aws/connector/resource/AwsLaunchService.java", "diffHunk": "@@ -171,9 +165,132 @@\n \n         awsCloudWatchService.addCloudWatchAlarmsForSystemFailures(instances, stack, regionName, credentialView);\n \n+        updateCloudformationWithLoadBalancer(ac, stack, resourceNotifier, modelContext, instances);\n+\n         return awsResourceConnector.check(ac, instances);\n     }\n \n+    private ModelContext buildDefaultModelContext(AuthenticatedContext ac, CloudStack stack, PersistenceNotifier resourceNotifier) {\n+        AwsCredentialView credentialView = new AwsCredentialView(ac.getCloudCredential());\n+        String regionName = ac.getCloudContext().getLocation().getRegion().value();\n+        AmazonEC2Client amazonEC2Client = awsClient.createAccess(credentialView, regionName);\n+        Network network = stack.getNetwork();\n+        AwsNetworkView awsNetworkView = new AwsNetworkView(network);\n+        boolean mapPublicIpOnLaunch = awsNetworkService.isMapPublicOnLaunch(awsNetworkView, amazonEC2Client);\n+\n+        boolean existingVPC = awsNetworkView.isExistingVPC();\n+        boolean existingSubnet = awsNetworkView.isExistingSubnet();\n+\n+        String cidr = network.getSubnet().getCidr();\n+        String subnet = isNoCIDRProvided(existingVPC, existingSubnet, cidr) ? awsNetworkService.findNonOverLappingCIDR(ac, stack) : cidr;\n+        AwsInstanceProfileView awsInstanceProfileView = new AwsInstanceProfileView(stack);\n+        ModelContext modelContext = new ModelContext()\n+            .withAuthenticatedContext(ac)\n+            .withStack(stack)\n+            .withExistingVpc(existingVPC)\n+            .withExistingIGW(awsNetworkView.isExistingIGW())\n+            .withExistingSubnetCidr(existingSubnet ? awsNetworkService.getExistingSubnetCidr(ac, stack) : null)\n+            .withExistinVpcCidr(awsNetworkService.getVpcCidrs(ac, stack))\n+            .withExistingSubnetIds(existingSubnet ? awsNetworkView.getSubnetList() : null)\n+            .mapPublicIpOnLaunch(mapPublicIpOnLaunch)\n+            .withEnableInstanceProfile(awsInstanceProfileView.isInstanceProfileAvailable())\n+            .withInstanceProfileAvailable(awsInstanceProfileView.isInstanceProfileAvailable())\n+            .withTemplate(stack.getTemplate())\n+            .withDefaultSubnet(subnet)\n+            .withOutboundInternetTraffic(network.getOutboundInternetTraffic())\n+            .withVpcCidrs(network.getNetworkCidrs())\n+            .withPrefixListIds(getPrefixListIds(amazonEC2Client, regionName, network.getOutboundInternetTraffic()))\n+            .withEncryptedAMIByGroupName(encryptedImageCopyService.createEncryptedImages(ac, stack, resourceNotifier));\n+\n+        return modelContext;\n+    }\n+\n+    private void updateCloudformationWithLoadBalancer(AuthenticatedContext ac, CloudStack stack, PersistenceNotifier resourceNotifier,\n+            ModelContext modelContext, List<CloudResource> instances) {\n+\n+        List<CloudLoadBalancer> cloudLoadBalancers = stack.getLoadBalancers();\n+        if (!cloudLoadBalancers.isEmpty()) {\n+            if (modelContext == null) {\n+                modelContext = buildDefaultModelContext(ac, stack, resourceNotifier);\n+            }\n+\n+            List<AwsLoadBalancer> awsLoadBalancers = new ArrayList<>();\n+            for (CloudLoadBalancer cloudLoadBalancer : cloudLoadBalancers) {\n+                awsLoadBalancers.add(convert(cloudLoadBalancer, stack, instances));\n+            }\n+\n+            modelContext.withLoadBalancers(awsLoadBalancers);\n+            ListStackResourcesResult result = updateCloudFormationStack(ac, stack, modelContext);\n+\n+            for (AwsLoadBalancer loadBalancer : awsLoadBalancers) {\n+                for (AwsListener listener : loadBalancer.getListeners()) {\n+                    for (AwsTargetGroup targetGroup : listener.getTargetGroups()) {\n+                        Optional<StackResourceSummary> targetGroupSummary = result.getStackResourceSummaries().stream()\n+                            .filter(stackResourceSummary -> targetGroup.getName().equals(stackResourceSummary.getLogicalResourceId()))\n+                            .findFirst();\n+                        if (targetGroupSummary.isEmpty()) {\n+                            throw new CloudConnectorException(\"Could not create load balancer listeners: target group not found.\");\n+                        }\n+                        targetGroup.setArn(targetGroupSummary.get().getPhysicalResourceId());\n+                    }\n+                }\n+                Optional<StackResourceSummary> loadBalancerSummary = result.getStackResourceSummaries().stream()\n+                    .filter(stackResourceSummary -> loadBalancer.getName().equals(stackResourceSummary.getLogicalResourceId()))\n+                    .findFirst();\n+                if (loadBalancerSummary.isEmpty()) {\n+                    throw new CloudConnectorException(\"Could not create load balancer listeners: load balancer not found.\");\n+                }\n+                loadBalancer.setArn(loadBalancerSummary.get().getPhysicalResourceId());\n+                loadBalancer.canCreateListeners();\n+            }\n+\n+            updateCloudFormationStack(ac, stack, modelContext);\n+        }\n+    }\n+\n+    private AwsLoadBalancer convert(CloudLoadBalancer cloudLoadBalancer, CloudStack stack, List<CloudResource> instances) {\n+        int order = 1;\n+        List<AwsListener> awsListeners = new ArrayList<>();\n+        AwsLoadBalancerScheme scheme = AwsLoadBalancerScheme.valueOf(cloudLoadBalancer.getType().name());\n+        for (Map.Entry<Integer, Set<Group>> entry : cloudLoadBalancer.getPortToTargetGroupMapping().entrySet()) {\n+            List<CloudResource> lbTargetInstances = instances.stream()\n+                .filter(instance -> entry.getValue().stream().anyMatch(tg -> tg.getName().equals(instance.getGroup())))\n+                .collect(Collectors.toList());\n+            List<String> instanceIds = lbTargetInstances.stream().map(CloudResource::getInstanceId).collect(Collectors.toList());\n+\n+            AwsTargetGroup targetGroup = new AwsTargetGroup(entry.getKey(), scheme, order++, instanceIds);\n+            awsListeners.add(new AwsListener(entry.getKey(), Collections.singletonList(targetGroup), scheme));\n+        }\n+        return new AwsLoadBalancer(scheme, awsListeners);\n+    }\n+\n+    private ListStackResourcesResult updateCloudFormationStack(AuthenticatedContext ac, CloudStack stack, ModelContext modelContext) {\n+        String cFStackName = cfStackUtil.getCfStackName(ac);\n+        AwsCredentialView credentialView = new AwsCredentialView(ac.getCloudCredential());\n+        String regionName = ac.getCloudContext().getLocation().getRegion().value();\n+        AmazonCloudFormationRetryClient cfRetryClient = awsClient.createCloudFormationRetryClient(credentialView, regionName);\n+        Network network = stack.getNetwork();\n+        AwsNetworkView awsNetworkView = new AwsNetworkView(network);\n+        boolean existingVPC = awsNetworkView.isExistingVPC();\n+        boolean existingSubnet = awsNetworkView.isExistingSubnet();\n+        String cidr = network.getSubnet().getCidr();\n+        String subnet = isNoCIDRProvided(existingVPC, existingSubnet, cidr) ? awsNetworkService.findNonOverLappingCIDR(ac, stack) : cidr;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e19d80b459db1f5f36788bd56bc824be5253f860"}, "originalPosition": 188}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDAzMDQyMQ==", "bodyText": "isStackDeleted is also using waiters and retry / polling logic. Are we using double layer of retry intentionally?", "url": "https://github.com/hortonworks/cloudbreak/pull/9475#discussion_r530030421", "createdAt": "2020-11-25T00:27:28Z", "author": {"login": "enis"}, "path": "cloud-aws/src/main/java/com/sequenceiq/cloudbreak/cloud/aws/connector/resource/AwsTerminateService.java", "diffHunk": "@@ -112,12 +112,9 @@ private void waitAndDeleteCloudformationStack(AuthenticatedContext ac, CloudStac\n         resumeAutoScalingPolicies(ac, stack);\n         LOGGER.debug(\"Delete cloudformation stack from resources\");\n         DeleteStackRequest deleteStackRequest = new DeleteStackRequest().withStackName(cFStackName);\n-        cfRetryClient.deleteStack(deleteStackRequest);\n-        Waiter<DescribeStacksRequest> stackDeleteCompleteWaiter = amazonCloudFormationClient.waiters().stackDeleteComplete();\n         try {\n-            WaiterParameters<DescribeStacksRequest> describeStacksRequestWaiterParameters = new WaiterParameters<>(describeStacksRequest)\n-                    .withPollingStrategy(getBackoffCancellablePollingStrategy(null));\n-            stackDeleteCompleteWaiter.run(describeStacksRequestWaiterParameters);\n+            retryService.testWith2SecDelayMax5Times(() -> isStackDeleted(cfRetryClient, amazonCloudFormationClient,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e19d80b459db1f5f36788bd56bc824be5253f860"}, "originalPosition": 10}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDAzMDg4OA==", "bodyText": "great.", "url": "https://github.com/hortonworks/cloudbreak/pull/9475#discussion_r530030888", "createdAt": "2020-11-25T00:28:57Z", "author": {"login": "enis"}, "path": "cloud-aws/src/main/java/com/sequenceiq/cloudbreak/cloud/aws/loadbalancer/AwsListener.java", "diffHunk": "@@ -0,0 +1,43 @@\n+package com.sequenceiq.cloudbreak.cloud.aws.loadbalancer;\n+\n+import java.util.List;\n+\n+import org.apache.commons.lang3.StringUtils;\n+\n+public class AwsListener {\n+\n+    private static final String LISTENER_NAME_PREFIX = \"ListenerPort\";\n+\n+    private final int port;\n+\n+    private final List<AwsTargetGroup> targetGroups;\n+\n+    private final String name;\n+\n+    public AwsListener(int port, List<AwsTargetGroup> targetGroups, AwsLoadBalancerScheme scheme) {\n+        this.port = port;\n+        this.targetGroups = targetGroups;\n+        this.name = getListenerName(port, scheme);\n+    }\n+\n+    public int getPort() {\n+        return port;\n+    }\n+\n+    public List<AwsTargetGroup> getTargetGroups() {\n+        return targetGroups;\n+    }\n+\n+    public boolean areTargetGroupArnsSet() {\n+        return targetGroups.stream().noneMatch(t -> t.getArn() == null || t.getArn().isEmpty());\n+    }\n+\n+    public String getName() {\n+        return name;\n+    }\n+\n+    private static String getListenerName(int port, AwsLoadBalancerScheme scheme) {\n+        return LISTENER_NAME_PREFIX + port +", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e19d80b459db1f5f36788bd56bc824be5253f860"}, "originalPosition": 40}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDAzMTEwOQ==", "bodyText": "nit: shouldCreateListeners()", "url": "https://github.com/hortonworks/cloudbreak/pull/9475#discussion_r530031109", "createdAt": "2020-11-25T00:29:35Z", "author": {"login": "enis"}, "path": "cloud-aws/src/main/java/com/sequenceiq/cloudbreak/cloud/aws/loadbalancer/AwsLoadBalancer.java", "diffHunk": "@@ -0,0 +1,73 @@\n+package com.sequenceiq.cloudbreak.cloud.aws.loadbalancer;\n+\n+import java.util.List;\n+\n+import org.apache.commons.lang3.StringUtils;\n+\n+public class AwsLoadBalancer {\n+\n+    private static final String LOAD_BALANCER_NAME_PREFIX = \"LoadBalancer\";\n+\n+    private final AwsLoadBalancerScheme scheme;\n+\n+    private final String awsScheme;\n+\n+    private final List<AwsListener> listeners;\n+\n+    private final String name;\n+\n+    private String arn;\n+\n+    private boolean createListeners;\n+\n+    public AwsLoadBalancer(AwsLoadBalancerScheme scheme, List<AwsListener> listeners) {\n+        this.scheme = scheme;\n+        this.awsScheme = scheme.awsScheme();\n+        this.listeners = listeners;\n+        this.name = getLoadBalancerName(scheme);\n+        this.createListeners = false;\n+    }\n+\n+    public AwsLoadBalancerScheme getScheme() {\n+        return scheme;\n+    }\n+\n+    public List<AwsListener> getListeners() {\n+        return listeners;\n+    }\n+\n+    public String getName() {\n+        return name;\n+    }\n+\n+    public String getArn() {\n+        return arn;\n+    }\n+\n+    public void setArn(String arn) {\n+        this.arn = arn;\n+    }\n+\n+    public String getAwsScheme() {\n+        return awsScheme;\n+    }\n+\n+    public boolean isCreateListeners() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e19d80b459db1f5f36788bd56bc824be5253f860"}, "originalPosition": 55}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDAzMTM2NA==", "bodyText": "This does not seem to be used.", "url": "https://github.com/hortonworks/cloudbreak/pull/9475#discussion_r530031364", "createdAt": "2020-11-25T00:30:22Z", "author": {"login": "enis"}, "path": "cloud-aws/src/main/java/com/sequenceiq/cloudbreak/cloud/aws/loadbalancer/AwsLoadBalancer.java", "diffHunk": "@@ -0,0 +1,73 @@\n+package com.sequenceiq.cloudbreak.cloud.aws.loadbalancer;\n+\n+import java.util.List;\n+\n+import org.apache.commons.lang3.StringUtils;\n+\n+public class AwsLoadBalancer {\n+\n+    private static final String LOAD_BALANCER_NAME_PREFIX = \"LoadBalancer\";\n+\n+    private final AwsLoadBalancerScheme scheme;\n+\n+    private final String awsScheme;\n+\n+    private final List<AwsListener> listeners;\n+\n+    private final String name;\n+\n+    private String arn;\n+\n+    private boolean createListeners;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e19d80b459db1f5f36788bd56bc824be5253f860"}, "originalPosition": 21}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDAzMTU5Mw==", "bodyText": "I think this should match AWS's terminology.\nINTERNET_FACING(\"internet-facing\")\nINTERNAL(\"internal\")", "url": "https://github.com/hortonworks/cloudbreak/pull/9475#discussion_r530031593", "createdAt": "2020-11-25T00:31:03Z", "author": {"login": "enis"}, "path": "cloud-aws/src/main/java/com/sequenceiq/cloudbreak/cloud/aws/loadbalancer/AwsLoadBalancerScheme.java", "diffHunk": "@@ -0,0 +1,16 @@\n+package com.sequenceiq.cloudbreak.cloud.aws.loadbalancer;\n+\n+public enum AwsLoadBalancerScheme {\n+    PUBLIC(\"internet-facing\"),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e19d80b459db1f5f36788bd56bc824be5253f860"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDAzMjk3NQ==", "bodyText": "Which subnet is this? We may need some logic here (as you note in your email thread) about selectiing public or private subnets as well as having more than 1 subnet (for cross-AZ availability). Can be done as follow ups.", "url": "https://github.com/hortonworks/cloudbreak/pull/9475#discussion_r530032975", "createdAt": "2020-11-25T00:35:14Z", "author": {"login": "enis"}, "path": "cloud-aws/src/main/resources/templates/aws-cf-stack.ftl", "diffHunk": "@@ -273,6 +273,64 @@\n     },\n     </#if>\n \n+    <#list loadBalancers as loadBalancer>\n+    \"${loadBalancer.name}\" : {\n+      \"Type\" : \"AWS::ElasticLoadBalancingV2::LoadBalancer\",\n+      \"Properties\" : {\n+        \"IpAddressType\" : \"ipv4\",\n+        \"Scheme\" : \"${loadBalancer.awsScheme}\",\n+        \"Subnets\" : [ { \"Ref\" : \"SubnetId\" } ],", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e19d80b459db1f5f36788bd56bc824be5253f860"}, "originalPosition": 10}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDAzMzQ1NQ==", "bodyText": "I think hard coding it here makes sense for now, but maybe also have the LB type in the database table so that in the future we can add ALB, ELB if needed.", "url": "https://github.com/hortonworks/cloudbreak/pull/9475#discussion_r530033455", "createdAt": "2020-11-25T00:36:43Z", "author": {"login": "enis"}, "path": "cloud-aws/src/main/resources/templates/aws-cf-stack.ftl", "diffHunk": "@@ -273,6 +273,64 @@\n     },\n     </#if>\n \n+    <#list loadBalancers as loadBalancer>\n+    \"${loadBalancer.name}\" : {\n+      \"Type\" : \"AWS::ElasticLoadBalancingV2::LoadBalancer\",\n+      \"Properties\" : {\n+        \"IpAddressType\" : \"ipv4\",\n+        \"Scheme\" : \"${loadBalancer.awsScheme}\",\n+        \"Subnets\" : [ { \"Ref\" : \"SubnetId\" } ],\n+        \"Type\" : \"network\"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e19d80b459db1f5f36788bd56bc824be5253f860"}, "originalPosition": 11}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDA0MDc1MA==", "bodyText": "it makes sense to double check whether everthing here fits 255 chars.", "url": "https://github.com/hortonworks/cloudbreak/pull/9475#discussion_r530040750", "createdAt": "2020-11-25T01:00:01Z", "author": {"login": "enis"}, "path": "core/src/main/resources/schema/app/20201103154306_CB-9366_Create_load_balancer_metadata_table.sql", "diffHunk": "@@ -0,0 +1,62 @@\n+-- // CB-9366 Create load balancer metadata table\n+-- Migration SQL that makes the change goes here.\n+\n+CREATE SEQUENCE loadbalancer_id_seq START WITH 1\n+  INCREMENT BY 1\n+  NO MINVALUE\n+  NO MAXVALUE\n+  CACHE 1;\n+\n+CREATE TABLE loadbalancer (\n+    id bigint default nextval('loadbalancer_id_seq'::regclass) not null\n+      constraint loadbalancer_pkey\n+        primary key,\n+    dns character varying(255),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e19d80b459db1f5f36788bd56bc824be5253f860"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDA0MTAyMw==", "bodyText": "as per above, this may need to be a list of ips (but a short list), so may even be ip_1, ip_2, ip_3.", "url": "https://github.com/hortonworks/cloudbreak/pull/9475#discussion_r530041023", "createdAt": "2020-11-25T01:00:53Z", "author": {"login": "enis"}, "path": "core/src/main/resources/schema/app/20201103154306_CB-9366_Create_load_balancer_metadata_table.sql", "diffHunk": "@@ -0,0 +1,62 @@\n+-- // CB-9366 Create load balancer metadata table\n+-- Migration SQL that makes the change goes here.\n+\n+CREATE SEQUENCE loadbalancer_id_seq START WITH 1\n+  INCREMENT BY 1\n+  NO MINVALUE\n+  NO MAXVALUE\n+  CACHE 1;\n+\n+CREATE TABLE loadbalancer (\n+    id bigint default nextval('loadbalancer_id_seq'::regclass) not null\n+      constraint loadbalancer_pkey\n+        primary key,\n+    dns character varying(255),\n+    hostedzoneid character varying(255),\n+    ip character varying(255),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e19d80b459db1f5f36788bd56bc824be5253f860"}, "originalPosition": 16}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDA0MjQ5MA==", "bodyText": "maybe debug level?", "url": "https://github.com/hortonworks/cloudbreak/pull/9475#discussion_r530042490", "createdAt": "2020-11-25T01:05:51Z", "author": {"login": "enis"}, "path": "core/src/main/java/com/sequenceiq/cloudbreak/service/LoadBalancerConfigService.java", "diffHunk": "@@ -0,0 +1,86 @@\n+package com.sequenceiq.cloudbreak.service;\n+\n+import com.sequenceiq.cloudbreak.domain.stack.loadbalancer.TargetGroup;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.stereotype.Service;\n+\n+import com.sequenceiq.cloudbreak.cmtemplate.CmTemplateProcessor;\n+import com.sequenceiq.cloudbreak.cmtemplate.configproviders.knox.KnoxRoles;\n+import com.sequenceiq.cloudbreak.domain.stack.Stack;\n+import com.sequenceiq.cloudbreak.domain.stack.cluster.Cluster;\n+import com.sequenceiq.cloudbreak.domain.stack.instance.InstanceGroup;\n+import com.sequenceiq.cloudbreak.template.model.ServiceComponent;\n+import com.sequenceiq.common.api.type.InstanceGroupType;\n+import com.sequenceiq.common.api.type.LoadBalancerType;\n+\n+@Service\n+public class LoadBalancerConfigService {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(LoadBalancerConfigService.class);\n+\n+    private static final String ENDPOINT_SUFFIX = \"gateway\";\n+\n+    private static final String PUBLIC_SUFFIX = \"external\";\n+\n+    private static final Set<Integer> DEFAULT_KNOX_PORTS = Set.of(443);\n+\n+    public Set<String> getKnoxGatewayGroups(Stack stack) {\n+        LOGGER.info(\"Fetching list of instance groups with Knox gateway installed\");\n+        Set<String> groupNames = new HashSet<>();\n+        Cluster cluster = stack.getCluster();\n+        if (cluster != null) {\n+            CmTemplateProcessor cmTemplateProcessor = new CmTemplateProcessor(cluster.getBlueprint().getBlueprintText());\n+            Map<String, Set<ServiceComponent>> componentByHostGroup = cmTemplateProcessor.getServiceComponentsByHostGroup();\n+            LOGGER.info(\"Checking if Knox gateway is explicitly defined\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e19d80b459db1f5f36788bd56bc824be5253f860"}, "originalPosition": 41}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDA0Mjk4Mg==", "bodyText": "I think the convention we should use is to follow AWS terminology. internet-facing load balancers do not have an \"external\" suffix, but internal load balancers have and \"-internal\" suffix.", "url": "https://github.com/hortonworks/cloudbreak/pull/9475#discussion_r530042982", "createdAt": "2020-11-25T01:07:33Z", "author": {"login": "enis"}, "path": "core/src/main/java/com/sequenceiq/cloudbreak/service/LoadBalancerConfigService.java", "diffHunk": "@@ -0,0 +1,86 @@\n+package com.sequenceiq.cloudbreak.service;\n+\n+import com.sequenceiq.cloudbreak.domain.stack.loadbalancer.TargetGroup;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.stereotype.Service;\n+\n+import com.sequenceiq.cloudbreak.cmtemplate.CmTemplateProcessor;\n+import com.sequenceiq.cloudbreak.cmtemplate.configproviders.knox.KnoxRoles;\n+import com.sequenceiq.cloudbreak.domain.stack.Stack;\n+import com.sequenceiq.cloudbreak.domain.stack.cluster.Cluster;\n+import com.sequenceiq.cloudbreak.domain.stack.instance.InstanceGroup;\n+import com.sequenceiq.cloudbreak.template.model.ServiceComponent;\n+import com.sequenceiq.common.api.type.InstanceGroupType;\n+import com.sequenceiq.common.api.type.LoadBalancerType;\n+\n+@Service\n+public class LoadBalancerConfigService {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(LoadBalancerConfigService.class);\n+\n+    private static final String ENDPOINT_SUFFIX = \"gateway\";\n+\n+    private static final String PUBLIC_SUFFIX = \"external\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e19d80b459db1f5f36788bd56bc824be5253f860"}, "originalPosition": 30}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDA0MzE3NQ==", "bodyText": "is this the full stack name, or just the shortened one?", "url": "https://github.com/hortonworks/cloudbreak/pull/9475#discussion_r530043175", "createdAt": "2020-11-25T01:08:16Z", "author": {"login": "enis"}, "path": "core/src/main/java/com/sequenceiq/cloudbreak/service/LoadBalancerConfigService.java", "diffHunk": "@@ -0,0 +1,86 @@\n+package com.sequenceiq.cloudbreak.service;\n+\n+import com.sequenceiq.cloudbreak.domain.stack.loadbalancer.TargetGroup;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.stereotype.Service;\n+\n+import com.sequenceiq.cloudbreak.cmtemplate.CmTemplateProcessor;\n+import com.sequenceiq.cloudbreak.cmtemplate.configproviders.knox.KnoxRoles;\n+import com.sequenceiq.cloudbreak.domain.stack.Stack;\n+import com.sequenceiq.cloudbreak.domain.stack.cluster.Cluster;\n+import com.sequenceiq.cloudbreak.domain.stack.instance.InstanceGroup;\n+import com.sequenceiq.cloudbreak.template.model.ServiceComponent;\n+import com.sequenceiq.common.api.type.InstanceGroupType;\n+import com.sequenceiq.common.api.type.LoadBalancerType;\n+\n+@Service\n+public class LoadBalancerConfigService {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(LoadBalancerConfigService.class);\n+\n+    private static final String ENDPOINT_SUFFIX = \"gateway\";\n+\n+    private static final String PUBLIC_SUFFIX = \"external\";\n+\n+    private static final Set<Integer> DEFAULT_KNOX_PORTS = Set.of(443);\n+\n+    public Set<String> getKnoxGatewayGroups(Stack stack) {\n+        LOGGER.info(\"Fetching list of instance groups with Knox gateway installed\");\n+        Set<String> groupNames = new HashSet<>();\n+        Cluster cluster = stack.getCluster();\n+        if (cluster != null) {\n+            CmTemplateProcessor cmTemplateProcessor = new CmTemplateProcessor(cluster.getBlueprint().getBlueprintText());\n+            Map<String, Set<ServiceComponent>> componentByHostGroup = cmTemplateProcessor.getServiceComponentsByHostGroup();\n+            LOGGER.info(\"Checking if Knox gateway is explicitly defined\");\n+            groupNames = componentByHostGroup.entrySet().stream()\n+                .filter(entry -> isKnoxGatewayDefinedInServices(entry.getValue()))\n+                .map(Map.Entry::getKey)\n+                .collect(Collectors.toSet());\n+        }\n+\n+        if (groupNames.isEmpty()) {\n+            LOGGER.info(\"Knox gateway is not explicitly defined; searching for CM gateway hosts\");\n+            groupNames = stack.getInstanceGroups().stream()\n+                .filter(i -> InstanceGroupType.isGateway(i.getInstanceGroupType()))\n+                .map(InstanceGroup::getGroupName)\n+                .collect(Collectors.toSet());\n+        }\n+\n+        if (groupNames.isEmpty()) {\n+            LOGGER.info(\"No Knox gateway instance groups found\");\n+        }\n+        return groupNames;\n+    }\n+\n+    private boolean isKnoxGatewayDefinedInServices(Set<ServiceComponent> serviceComponents) {\n+        return serviceComponents.stream()\n+            .anyMatch(serviceComponent -> KnoxRoles.KNOX_GATEWAY.equals(serviceComponent.getComponent()));\n+    }\n+\n+    public String generateLoadBalancerEndpoint(Stack stack, LoadBalancerType type) {\n+        StringBuilder name = new StringBuilder()\n+            .append(stack.getName())", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e19d80b459db1f5f36788bd56bc824be5253f860"}, "originalPosition": 69}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "e19d80b459db1f5f36788bd56bc824be5253f860", "author": {"user": {"login": "hreeve-cloudera", "name": null}}, "url": "https://github.com/hortonworks/cloudbreak/commit/e19d80b459db1f5f36788bd56bc824be5253f860", "committedDate": "2020-11-20T23:52:10Z", "message": "Addressing review comments"}, "afterCommit": {"oid": "d9d43318f7d259946ff4c23f16bb184a1ea58424", "author": {"user": {"login": "hreeve-cloudera", "name": null}}, "url": "https://github.com/hortonworks/cloudbreak/commit/d9d43318f7d259946ff4c23f16bb184a1ea58424", "committedDate": "2020-11-30T19:12:39Z", "message": "Additional review comments and rebase."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "d9d43318f7d259946ff4c23f16bb184a1ea58424", "author": {"user": {"login": "hreeve-cloudera", "name": null}}, "url": "https://github.com/hortonworks/cloudbreak/commit/d9d43318f7d259946ff4c23f16bb184a1ea58424", "committedDate": "2020-11-30T19:12:39Z", "message": "Additional review comments and rebase."}, "afterCommit": {"oid": "38ef8055c8d7bdf17068665196206f3622b9a3bd", "author": {"user": {"login": "hreeve-cloudera", "name": null}}, "url": "https://github.com/hortonworks/cloudbreak/commit/38ef8055c8d7bdf17068665196206f3622b9a3bd", "committedDate": "2020-11-30T20:37:55Z", "message": "Additional review comments and rebase."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQxMjkwNjEz", "url": "https://github.com/hortonworks/cloudbreak/pull/9475#pullrequestreview-541290613", "createdAt": "2020-11-30T21:00:43Z", "commit": {"oid": "38ef8055c8d7bdf17068665196206f3622b9a3bd"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "38ef8055c8d7bdf17068665196206f3622b9a3bd", "author": {"user": {"login": "hreeve-cloudera", "name": null}}, "url": "https://github.com/hortonworks/cloudbreak/commit/38ef8055c8d7bdf17068665196206f3622b9a3bd", "committedDate": "2020-11-30T20:37:55Z", "message": "Additional review comments and rebase."}, "afterCommit": {"oid": "91252020ce85e0bf097c4fcba5073697e46aa7e7", "author": {"user": {"login": "hreeve-cloudera", "name": null}}, "url": "https://github.com/hortonworks/cloudbreak/commit/91252020ce85e0bf097c4fcba5073697e46aa7e7", "committedDate": "2020-12-02T16:35:53Z", "message": "Defaulting mock entitlement to false and rebasing from master."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQyOTk1MDIx", "url": "https://github.com/hortonworks/cloudbreak/pull/9475#pullrequestreview-542995021", "createdAt": "2020-12-02T16:08:49Z", "commit": {"oid": "38ef8055c8d7bdf17068665196206f3622b9a3bd"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 9, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMlQxNjowODo0OVrOH9id3w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wM1QwODowNDo0NlrOH-Fvug==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDI4OTg4Nw==", "bodyText": "Can we make this functionality disabled by default?\nAs most of the devs don't have a running PEM locally or connected to one of the MOW ones.", "url": "https://github.com/hortonworks/cloudbreak/pull/9475#discussion_r534289887", "createdAt": "2020-12-02T16:08:49Z", "author": {"login": "biharitomi"}, "path": "mock-thunderhead/src/main/resources/application.yml", "diffHunk": "@@ -33,3 +33,4 @@ auth:\n     differentdatahubversionthandatalake.enabled: true\n     database.wire.encryption.enable: true\n     datahub.runtime.upgrade.enable: true\n+    datalake.loadbalancer.enable: true", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "38ef8055c8d7bdf17068665196206f3622b9a3bd"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDQ5NTY5Ng==", "bodyText": "This method should not be created as getGatewayInstanceMetadata or getPrimaryGatewayInstance could be used to do the same and I checked in IDEA it hasn't even used anywhere on this branch.", "url": "https://github.com/hortonworks/cloudbreak/pull/9475#discussion_r534495696", "createdAt": "2020-12-02T21:33:35Z", "author": {"login": "biharitomi"}, "path": "core-model/src/main/java/com/sequenceiq/cloudbreak/domain/stack/Stack.java", "diffHunk": "@@ -574,6 +579,15 @@ public InstanceMetaData getPrimaryGatewayInstance() {\n         return metaData.orElse(null);\n     }\n \n+    public InstanceGroup getGatewayGroup() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "91252020ce85e0bf097c4fcba5073697e46aa7e7"}, "originalPosition": 23}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDUwMTE2MQ==", "bodyText": "The TargetGroupType enum could be used here and the values of the field would be more straightforward. CB has an enum converter logic which handles the conversion from enum to string and vice versa.\nAn example could be: com.sequenceiq.environment.parameters.dao.converter.CredentialTypeConverter", "url": "https://github.com/hortonworks/cloudbreak/pull/9475#discussion_r534501161", "createdAt": "2020-12-02T21:43:49Z", "author": {"login": "biharitomi"}, "path": "core-model/src/main/java/com/sequenceiq/cloudbreak/domain/stack/loadbalancer/TargetGroup.java", "diffHunk": "@@ -0,0 +1,59 @@\n+package com.sequenceiq.cloudbreak.domain.stack.loadbalancer;\n+\n+import com.sequenceiq.cloudbreak.domain.ProvisionEntity;\n+import java.util.Set;\n+\n+import javax.persistence.Entity;\n+import javax.persistence.FetchType;\n+import javax.persistence.GeneratedValue;\n+import javax.persistence.GenerationType;\n+import javax.persistence.Id;\n+import javax.persistence.ManyToMany;\n+import javax.persistence.ManyToOne;\n+import javax.persistence.SequenceGenerator;\n+\n+import com.sequenceiq.cloudbreak.domain.stack.instance.InstanceGroup;\n+\n+@Entity\n+public class TargetGroup implements ProvisionEntity {\n+    @Id\n+    @GeneratedValue(strategy = GenerationType.AUTO, generator = \"targetgroup_generator\")\n+    @SequenceGenerator(name = \"targetgroup_generator\", sequenceName = \"targetgroup_id_seq\", allocationSize = 1)\n+    private Long id;\n+\n+    private String type;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "91252020ce85e0bf097c4fcba5073697e46aa7e7"}, "originalPosition": 24}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDUwMTcwNA==", "bodyText": "The LoadBalancerType enum could be used here and the values of the field would be more straightforward. CB has an enum converter logic which handles the conversion from enum to string and vice versa.\nAn example could be: com.sequenceiq.environment.parameters.dao.converter.CredentialTypeConverter", "url": "https://github.com/hortonworks/cloudbreak/pull/9475#discussion_r534501704", "createdAt": "2020-12-02T21:44:45Z", "author": {"login": "biharitomi"}, "path": "core-model/src/main/java/com/sequenceiq/cloudbreak/domain/stack/loadbalancer/LoadBalancer.java", "diffHunk": "@@ -0,0 +1,111 @@\n+package com.sequenceiq.cloudbreak.domain.stack.loadbalancer;\n+\n+import java.util.HashSet;\n+import java.util.Set;\n+\n+import javax.persistence.CascadeType;\n+import javax.persistence.Entity;\n+import javax.persistence.GeneratedValue;\n+import javax.persistence.GenerationType;\n+import javax.persistence.Id;\n+import javax.persistence.ManyToOne;\n+import javax.persistence.OneToMany;\n+import javax.persistence.SequenceGenerator;\n+\n+import com.sequenceiq.cloudbreak.domain.ProvisionEntity;\n+import com.sequenceiq.cloudbreak.domain.stack.Stack;\n+\n+@Entity\n+public class LoadBalancer implements ProvisionEntity  {\n+    @Id\n+    @GeneratedValue(strategy = GenerationType.AUTO, generator = \"loadbalancer_generator\")\n+    @SequenceGenerator(name = \"loadbalancer_generator\", sequenceName = \"loadbalancer_id_seq\", allocationSize = 1)\n+    private Long id;\n+\n+    @ManyToOne\n+    private Stack stack;\n+\n+    private String dns;\n+\n+    private String hostedZoneId;\n+\n+    private String ip;\n+\n+    private String type;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "91252020ce85e0bf097c4fcba5073697e46aa7e7"}, "originalPosition": 34}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDUwOTI4Ng==", "bodyText": "Instead of this call and the next lambda filter the com.sequenceiq.cloudbreak.cmtemplate.CmTemplateProcessor#getHostGroupsWithComponent method could be used.", "url": "https://github.com/hortonworks/cloudbreak/pull/9475#discussion_r534509286", "createdAt": "2020-12-02T21:58:31Z", "author": {"login": "biharitomi"}, "path": "core/src/main/java/com/sequenceiq/cloudbreak/service/LoadBalancerConfigService.java", "diffHunk": "@@ -0,0 +1,86 @@\n+package com.sequenceiq.cloudbreak.service;\n+\n+import com.sequenceiq.cloudbreak.domain.stack.loadbalancer.TargetGroup;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.stereotype.Service;\n+\n+import com.sequenceiq.cloudbreak.cmtemplate.CmTemplateProcessor;\n+import com.sequenceiq.cloudbreak.cmtemplate.configproviders.knox.KnoxRoles;\n+import com.sequenceiq.cloudbreak.domain.stack.Stack;\n+import com.sequenceiq.cloudbreak.domain.stack.cluster.Cluster;\n+import com.sequenceiq.cloudbreak.domain.stack.instance.InstanceGroup;\n+import com.sequenceiq.cloudbreak.template.model.ServiceComponent;\n+import com.sequenceiq.common.api.type.InstanceGroupType;\n+import com.sequenceiq.common.api.type.LoadBalancerType;\n+\n+@Service\n+public class LoadBalancerConfigService {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(LoadBalancerConfigService.class);\n+\n+    private static final String ENDPOINT_SUFFIX = \"gateway\";\n+\n+    private static final String PUBLIC_SUFFIX = \"external\";\n+\n+    private static final Set<Integer> DEFAULT_KNOX_PORTS = Set.of(443);\n+\n+    public Set<String> getKnoxGatewayGroups(Stack stack) {\n+        LOGGER.info(\"Fetching list of instance groups with Knox gateway installed\");\n+        Set<String> groupNames = new HashSet<>();\n+        Cluster cluster = stack.getCluster();\n+        if (cluster != null) {\n+            CmTemplateProcessor cmTemplateProcessor = new CmTemplateProcessor(cluster.getBlueprint().getBlueprintText());\n+            Map<String, Set<ServiceComponent>> componentByHostGroup = cmTemplateProcessor.getServiceComponentsByHostGroup();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "91252020ce85e0bf097c4fcba5073697e46aa7e7"}, "originalPosition": 40}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDUxMDk0OA==", "bodyText": "Using if-else instead of if-continue?", "url": "https://github.com/hortonworks/cloudbreak/pull/9475#discussion_r534510948", "createdAt": "2020-12-02T22:01:13Z", "author": {"login": "biharitomi"}, "path": "core/src/main/java/com/sequenceiq/cloudbreak/service/publicendpoint/GatewayPublicEndpointManagementService.java", "diffHunk": "@@ -92,6 +101,41 @@ public String updateDnsEntry(Stack stack, String gatewayIp) {\n         return null;\n     }\n \n+    public void updateDnsEntryForLoadBalancers(Stack stack) {\n+        Set<LoadBalancer> loadBalancers = loadBalancerPersistenceService.findByStackId(stack.getId());\n+        if (loadBalancers.isEmpty()) {\n+            LOGGER.info(\"No load balancers in stack {}\", stack.getId());\n+            return;\n+        }\n+\n+        LOGGER.info(\"Update load balancer DNS entries\");\n+        String userCrn = ThreadBasedUserCrnProvider.getUserCrn();\n+        String accountId = ThreadBasedUserCrnProvider.getAccountId();\n+        DetailedEnvironmentResponse environment = environmentClientService.getByCrn(stack.getEnvironmentCrn());\n+\n+        for (LoadBalancer loadBalancer : loadBalancers) {\n+            Optional<String> endpoint = Optional.ofNullable(loadBalancer.getEndpoint());\n+            if (endpoint.isEmpty()) {\n+                LOGGER.error(\"No endpoint set for load balancer. Can't register domain.\");\n+                continue;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "91252020ce85e0bf097c4fcba5073697e46aa7e7"}, "originalPosition": 63}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDUxMjM2NQ==", "bodyText": "No, https://github.com/hortonworks/cloudbreak/pull/9475/files#diff-7d0c14c28466a6ed89a04d3cc0a6c5973f30325dab017a4093173af0145e77dbR35 will do the job.", "url": "https://github.com/hortonworks/cloudbreak/pull/9475#discussion_r534512365", "createdAt": "2020-12-02T22:04:01Z", "author": {"login": "biharitomi"}, "path": "core/src/main/java/com/sequenceiq/cloudbreak/service/publicendpoint/dns/BaseDnsEntryService.java", "diffHunk": "@@ -101,6 +101,7 @@\n         String accountId = ThreadBasedUserCrnProvider.getAccountId();\n         DetailedEnvironmentResponse environment = environmentClientService.getByCrn(environmentCrn);\n \n+        // TODO do we need to deregister the load balancer DNS here as well?", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "91252020ce85e0bf097c4fcba5073697e46aa7e7"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDg0OTE4OA==", "bodyText": "Regarding RFC-1035 it should be enough.\n\nTo simplify implementations, the total length of a domain name (i.e.,\nlabel octets and label length octets) is restricted to 255 octets or\nless.", "url": "https://github.com/hortonworks/cloudbreak/pull/9475#discussion_r534849188", "createdAt": "2020-12-03T07:53:55Z", "author": {"login": "biharitomi"}, "path": "core/src/main/resources/schema/app/20201103154306_CB-9366_Create_load_balancer_metadata_table.sql", "diffHunk": "@@ -0,0 +1,62 @@\n+-- // CB-9366 Create load balancer metadata table\n+-- Migration SQL that makes the change goes here.\n+\n+CREATE SEQUENCE loadbalancer_id_seq START WITH 1\n+  INCREMENT BY 1\n+  NO MINVALUE\n+  NO MAXVALUE\n+  CACHE 1;\n+\n+CREATE TABLE loadbalancer (\n+    id bigint default nextval('loadbalancer_id_seq'::regclass) not null\n+      constraint loadbalancer_pkey\n+        primary key,\n+    dns character varying(255),", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDA0MDc1MA=="}, "originalCommit": {"oid": "e19d80b459db1f5f36788bd56bc824be5253f860"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDg2Nzg5OA==", "bodyText": "Just would like to add some notes about the unwritten convention that is mostly used by our team in case of SQL scripts, this SQL script is fine for me.\nYou could save the time of sequence creator SQLs with using name convention and bigserial as type of id. In this case the DROP TABLE should also cleanup the sequence too. For example:\n\ncredential table\ncredential id sequence name\n\nOn the other hand we prefer SQL statements with IF EXISTS or IF NOT EXISTS conditions in place where it is applicable, that makes the SQL scripts more bullet proof.", "url": "https://github.com/hortonworks/cloudbreak/pull/9475#discussion_r534867898", "createdAt": "2020-12-03T08:04:46Z", "author": {"login": "biharitomi"}, "path": "core/src/main/resources/schema/app/20201103154306_CB-9366_Create_load_balancer_metadata_table.sql", "diffHunk": "@@ -0,0 +1,62 @@\n+-- // CB-9366 Create load balancer metadata table\n+-- Migration SQL that makes the change goes here.\n+\n+CREATE SEQUENCE loadbalancer_id_seq START WITH 1", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "91252020ce85e0bf097c4fcba5073697e46aa7e7"}, "originalPosition": 4}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "33c06d91cb3afbb6440f9ed6f05df310b6d8abc6", "author": {"user": {"login": "hreeve-cloudera", "name": null}}, "url": "https://github.com/hortonworks/cloudbreak/commit/33c06d91cb3afbb6440f9ed6f05df310b6d8abc6", "committedDate": "2020-12-03T17:49:16Z", "message": "CB-9241 Create an AWS load balancer in front of Knox on the data lake\n\nThis change adds a load balancer to the data lake that sits in front of Knox.\nIt is configured automatically during data lake creation for AWS environments.\nThis functionality is currently behind the CDP_DATA_LAKE_LOAD_BALANCER\nentitlement.\n\nThe load balancer is modeled in CB by having a series of targetGroups, which\ninclude the type of target (in this commit, only KNOX targets are supported),\nthe port to route data to, and links to the instance groups where the service\nruns. The load balancer will receive traffic on the defined port, and route it\nto the same port on the appropriate instances. The load balancer is created\nautomatically in front of all data lake that have a Knox gateway. If PEM is\nenabled, it is given a DNS entry under the endpoint \"<datalake name>-gateway\".\n\nThis change was tested with unit tests, and by running the Cloudbreak service\nlocally and verifying: 1) the LB is created in AWS, 2) the LB is configured\nwith the appropriate instance information, and 3) accessing the LB endpoint\ncorrectly routes the traffic to Knox."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "91252020ce85e0bf097c4fcba5073697e46aa7e7", "author": {"user": {"login": "hreeve-cloudera", "name": null}}, "url": "https://github.com/hortonworks/cloudbreak/commit/91252020ce85e0bf097c4fcba5073697e46aa7e7", "committedDate": "2020-12-02T16:35:53Z", "message": "Defaulting mock entitlement to false and rebasing from master."}, "afterCommit": {"oid": "33c06d91cb3afbb6440f9ed6f05df310b6d8abc6", "author": {"user": {"login": "hreeve-cloudera", "name": null}}, "url": "https://github.com/hortonworks/cloudbreak/commit/33c06d91cb3afbb6440f9ed6f05df310b6d8abc6", "committedDate": "2020-12-03T17:49:16Z", "message": "CB-9241 Create an AWS load balancer in front of Knox on the data lake\n\nThis change adds a load balancer to the data lake that sits in front of Knox.\nIt is configured automatically during data lake creation for AWS environments.\nThis functionality is currently behind the CDP_DATA_LAKE_LOAD_BALANCER\nentitlement.\n\nThe load balancer is modeled in CB by having a series of targetGroups, which\ninclude the type of target (in this commit, only KNOX targets are supported),\nthe port to route data to, and links to the instance groups where the service\nruns. The load balancer will receive traffic on the defined port, and route it\nto the same port on the appropriate instances. The load balancer is created\nautomatically in front of all data lake that have a Knox gateway. If PEM is\nenabled, it is given a DNS entry under the endpoint \"<datalake name>-gateway\".\n\nThis change was tested with unit tests, and by running the Cloudbreak service\nlocally and verifying: 1) the LB is created in AWS, 2) the LB is configured\nwith the appropriate instance information, and 3) accessing the LB endpoint\ncorrectly routes the traffic to Knox."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ0MzA4MTY3", "url": "https://github.com/hortonworks/cloudbreak/pull/9475#pullrequestreview-544308167", "createdAt": "2020-12-03T19:27:31Z", "commit": {"oid": "33c06d91cb3afbb6440f9ed6f05df310b6d8abc6"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2015, "cost": 1, "resetAt": "2021-11-01T14:51:55Z"}}}