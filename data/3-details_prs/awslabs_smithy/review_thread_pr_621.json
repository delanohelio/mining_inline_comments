{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTEzMzExNzQ1", "number": 621, "reviewThreads": {"totalCount": 18, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0zMFQyMjozNToyNVrOEz-v2w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wM1QwMDowMzo1MlrOE0m0tQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIyOTQwODkxOnYy", "diffSide": "RIGHT", "path": "smithy-jmespath/build.gradle", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0zMFQyMjozNToyNVrOHriMAA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0zMFQyMjozNToyNVrOHriMAA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTQxMDk0NA==", "bodyText": "2020", "url": "https://github.com/awslabs/smithy/pull/621#discussion_r515410944", "createdAt": "2020-10-30T22:35:25Z", "author": {"login": "JordonPhillips"}, "path": "smithy-jmespath/build.gradle", "diffHunk": "@@ -0,0 +1,21 @@\n+/*\n+ * Copyright 2019 Amazon.com, Inc. or its affiliates. All Rights Reserved.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "48677c1f801c71ef5c03b558763d7512f014f2d5"}, "originalPosition": 2}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIzNDQxMjkxOnYy", "diffSide": "RIGHT", "path": "smithy-jmespath/README.md", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMlQxNjo0MDoxOVrOHsMb2Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMlQxNjo0MDoxOVrOHsMb2Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjEwMzEyOQ==", "bodyText": "s/parser/parse", "url": "https://github.com/awslabs/smithy/pull/621#discussion_r516103129", "createdAt": "2020-11-02T16:40:19Z", "author": {"login": "JordonPhillips"}, "path": "smithy-jmespath/README.md", "diffHunk": "@@ -0,0 +1,7 @@\n+# Smithy JMESPath\n+\n+This is an implementation of a [JMESPath](https://jmespath.org/) parser\n+written in Java. It's not intended to be used at runtime and does not include\n+an interpreter. It doesn't implement functions. Its goal is to parser", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "05b0728331d653844be567dbf3fcc9f07d79a8ba"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIzNDY1OTQwOnYy", "diffSide": "RIGHT", "path": "smithy-jmespath/src/main/java/software/amazon/smithy/jmespath/ExpressionVisitor.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMlQxNzozMDo0NVrOHsOv9w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMlQxNzozMDo0NVrOHsOv9w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjE0MTA0Nw==", "bodyText": "Can you add docs here and/or in the expression classes showing an example of the expression and possibly a link to the spec? The naming and layout here isn't 1-1 with the spec so it's a bit difficult to cross-reference. There are some small examples in the parser but people working with the AST aren't gonna be looking there.", "url": "https://github.com/awslabs/smithy/pull/621#discussion_r516141047", "createdAt": "2020-11-02T17:30:45Z", "author": {"login": "JordonPhillips"}, "path": "smithy-jmespath/src/main/java/software/amazon/smithy/jmespath/ExpressionVisitor.java", "diffHunk": "@@ -0,0 +1,79 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package software.amazon.smithy.jmespath;\n+\n+import software.amazon.smithy.jmespath.ast.AndExpression;\n+import software.amazon.smithy.jmespath.ast.ComparisonExpression;\n+import software.amazon.smithy.jmespath.ast.CurrentExpression;\n+import software.amazon.smithy.jmespath.ast.ExpressionReferenceExpression;\n+import software.amazon.smithy.jmespath.ast.FieldExpression;\n+import software.amazon.smithy.jmespath.ast.FilterProjectionExpression;\n+import software.amazon.smithy.jmespath.ast.FlattenExpression;\n+import software.amazon.smithy.jmespath.ast.FunctionExpression;\n+import software.amazon.smithy.jmespath.ast.IndexExpression;\n+import software.amazon.smithy.jmespath.ast.LiteralExpression;\n+import software.amazon.smithy.jmespath.ast.MultiSelectHashExpression;\n+import software.amazon.smithy.jmespath.ast.MultiSelectListExpression;\n+import software.amazon.smithy.jmespath.ast.NotExpression;\n+import software.amazon.smithy.jmespath.ast.ObjectProjectionExpression;\n+import software.amazon.smithy.jmespath.ast.OrExpression;\n+import software.amazon.smithy.jmespath.ast.ProjectionExpression;\n+import software.amazon.smithy.jmespath.ast.SliceExpression;\n+import software.amazon.smithy.jmespath.ast.Subexpression;\n+\n+/**\n+ * Visits each type of AST node.\n+ *\n+ * @param <T> Value returned from the visitor.\n+ */\n+public interface ExpressionVisitor<T> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "05b0728331d653844be567dbf3fcc9f07d79a8ba"}, "originalPosition": 42}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIzNDcxODc3OnYy", "diffSide": "RIGHT", "path": "smithy-jmespath/src/main/java/software/amazon/smithy/jmespath/FunctionDefinition.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMlQxNzo0NjowNFrOHsPUKw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMlQxNzo0NjowNFrOHsPUKw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjE1MDMxNQ==", "bodyText": "This needs docs", "url": "https://github.com/awslabs/smithy/pull/621#discussion_r516150315", "createdAt": "2020-11-02T17:46:04Z", "author": {"login": "JordonPhillips"}, "path": "smithy-jmespath/src/main/java/software/amazon/smithy/jmespath/FunctionDefinition.java", "diffHunk": "@@ -0,0 +1,89 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package software.amazon.smithy.jmespath;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import software.amazon.smithy.jmespath.ast.LiteralExpression;\n+\n+final class FunctionDefinition {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "05b0728331d653844be567dbf3fcc9f07d79a8ba"}, "originalPosition": 22}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIzNDc1NjE4OnYy", "diffSide": "RIGHT", "path": "smithy-jmespath/src/main/java/software/amazon/smithy/jmespath/LinterResult.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMlQxNzo1NTo1NlrOHsPrAQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMlQyMzo0NjoxNFrOHsa1mg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjE1NjE2MQ==", "bodyText": "This is unused", "url": "https://github.com/awslabs/smithy/pull/621#discussion_r516156161", "createdAt": "2020-11-02T17:55:56Z", "author": {"login": "JordonPhillips"}, "path": "smithy-jmespath/src/main/java/software/amazon/smithy/jmespath/LinterResult.java", "diffHunk": "@@ -0,0 +1,54 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package software.amazon.smithy.jmespath;\n+\n+import java.util.Objects;\n+import java.util.Set;\n+\n+public final class LinterResult {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "05b0728331d653844be567dbf3fcc9f07d79a8ba"}, "originalPosition": 21}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjMzOTA5OA==", "bodyText": "It's returned from JmespathExpression#lint", "url": "https://github.com/awslabs/smithy/pull/621#discussion_r516339098", "createdAt": "2020-11-02T23:46:14Z", "author": {"login": "mtdowling"}, "path": "smithy-jmespath/src/main/java/software/amazon/smithy/jmespath/LinterResult.java", "diffHunk": "@@ -0,0 +1,54 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package software.amazon.smithy.jmespath;\n+\n+import java.util.Objects;\n+import java.util.Set;\n+\n+public final class LinterResult {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjE1NjE2MQ=="}, "originalCommit": {"oid": "05b0728331d653844be567dbf3fcc9f07d79a8ba"}, "originalPosition": 21}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIzNTE3OTgwOnYy", "diffSide": "RIGHT", "path": "smithy-jmespath/src/main/java/software/amazon/smithy/jmespath/ast/ComparatorType.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMlQyMDowMjozOVrOHsTvig==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMlQyMDowMjozOVrOHsTvig==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjIyMjg1OA==", "bodyText": "nit: two spaces after enum", "url": "https://github.com/awslabs/smithy/pull/621#discussion_r516222858", "createdAt": "2020-11-02T20:02:39Z", "author": {"login": "kstich"}, "path": "smithy-jmespath/src/main/java/software/amazon/smithy/jmespath/ast/ComparatorType.java", "diffHunk": "@@ -0,0 +1,40 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package software.amazon.smithy.jmespath.ast;\n+\n+/**\n+ * A comparator in a comparison expression.\n+ */\n+public enum  ComparatorType {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "05b0728331d653844be567dbf3fcc9f07d79a8ba"}, "originalPosition": 21}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIzNTIyMTMwOnYy", "diffSide": "RIGHT", "path": "smithy-jmespath/src/main/java/software/amazon/smithy/jmespath/ast/BinaryExpression.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMlQyMDoxNTo1NVrOHsUIlw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wM1QwNjoyMTo0MlrOHshZZg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjIyOTI3MQ==", "bodyText": "Should the equals check and hashCode generation consider the position? This looks like it would apply to everything that extends JmespathExpression.", "url": "https://github.com/awslabs/smithy/pull/621#discussion_r516229271", "createdAt": "2020-11-02T20:15:55Z", "author": {"login": "kstich"}, "path": "smithy-jmespath/src/main/java/software/amazon/smithy/jmespath/ast/BinaryExpression.java", "diffHunk": "@@ -0,0 +1,73 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package software.amazon.smithy.jmespath.ast;\n+\n+import java.util.Objects;\n+import software.amazon.smithy.jmespath.JmespathExpression;\n+\n+/**\n+ * Abstract class representing expressions that have a left and right side.\n+ */\n+public abstract class BinaryExpression extends JmespathExpression {\n+\n+    private final JmespathExpression left;\n+    private final JmespathExpression right;\n+\n+    public BinaryExpression(JmespathExpression left, JmespathExpression right, int line, int column) {\n+        super(line, column);\n+        this.left = left;\n+        this.right = right;\n+    }\n+\n+    /**\n+     * Gets the left side of the expression.\n+     *\n+     * @return Returns the expression on the left.\n+     */\n+    public final JmespathExpression getLeft() {\n+        return left;\n+    }\n+\n+    /**\n+     * Gets the right side of the expression.\n+     *\n+     * @return Returns the expression on the right.\n+     */\n+    public final JmespathExpression getRight() {\n+        return right;\n+    }\n+\n+    @Override\n+    public boolean equals(Object o) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "05b0728331d653844be567dbf3fcc9f07d79a8ba"}, "originalPosition": 54}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjQ0NjU2Ng==", "bodyText": "No, I intentionally left that out since the AST is not a parse tree, but rather more abstract.", "url": "https://github.com/awslabs/smithy/pull/621#discussion_r516446566", "createdAt": "2020-11-03T06:21:42Z", "author": {"login": "mtdowling"}, "path": "smithy-jmespath/src/main/java/software/amazon/smithy/jmespath/ast/BinaryExpression.java", "diffHunk": "@@ -0,0 +1,73 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package software.amazon.smithy.jmespath.ast;\n+\n+import java.util.Objects;\n+import software.amazon.smithy.jmespath.JmespathExpression;\n+\n+/**\n+ * Abstract class representing expressions that have a left and right side.\n+ */\n+public abstract class BinaryExpression extends JmespathExpression {\n+\n+    private final JmespathExpression left;\n+    private final JmespathExpression right;\n+\n+    public BinaryExpression(JmespathExpression left, JmespathExpression right, int line, int column) {\n+        super(line, column);\n+        this.left = left;\n+        this.right = right;\n+    }\n+\n+    /**\n+     * Gets the left side of the expression.\n+     *\n+     * @return Returns the expression on the left.\n+     */\n+    public final JmespathExpression getLeft() {\n+        return left;\n+    }\n+\n+    /**\n+     * Gets the right side of the expression.\n+     *\n+     * @return Returns the expression on the right.\n+     */\n+    public final JmespathExpression getRight() {\n+        return right;\n+    }\n+\n+    @Override\n+    public boolean equals(Object o) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjIyOTI3MQ=="}, "originalCommit": {"oid": "05b0728331d653844be567dbf3fcc9f07d79a8ba"}, "originalPosition": 54}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIzNTIzOTg3OnYy", "diffSide": "RIGHT", "path": "smithy-jmespath/src/main/java/software/amazon/smithy/jmespath/ast/FilterProjectionExpression.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMlQyMDoyMToyNFrOHsUToA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMlQyMDoyMToyNFrOHsUToA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjIzMjA5Ng==", "bodyText": "Missing a class comment.", "url": "https://github.com/awslabs/smithy/pull/621#discussion_r516232096", "createdAt": "2020-11-02T20:21:24Z", "author": {"login": "kstich"}, "path": "smithy-jmespath/src/main/java/software/amazon/smithy/jmespath/ast/FilterProjectionExpression.java", "diffHunk": "@@ -0,0 +1,91 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package software.amazon.smithy.jmespath.ast;\n+\n+import java.util.Objects;\n+import software.amazon.smithy.jmespath.ExpressionVisitor;\n+import software.amazon.smithy.jmespath.JmespathExpression;\n+\n+public final class FilterProjectionExpression extends JmespathExpression {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "05b0728331d653844be567dbf3fcc9f07d79a8ba"}, "originalPosition": 22}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIzNTQ3MDk5OnYy", "diffSide": "RIGHT", "path": "smithy-jmespath/src/main/java/software/amazon/smithy/jmespath/Parser.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMlQyMTozNDo1MFrOHsWeFw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMlQyMzo0NDozMFrOHsaxuA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjI2NzU0Mw==", "bodyText": "There is a difference between a sub expression and a pipe expression. I'm not seeing how this materializes that in the AST", "url": "https://github.com/awslabs/smithy/pull/621#discussion_r516267543", "createdAt": "2020-11-02T21:34:50Z", "author": {"login": "JordonPhillips"}, "path": "smithy-jmespath/src/main/java/software/amazon/smithy/jmespath/Parser.java", "diffHunk": "@@ -0,0 +1,403 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package software.amazon.smithy.jmespath;\n+\n+import java.util.ArrayList;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import software.amazon.smithy.jmespath.ast.AndExpression;\n+import software.amazon.smithy.jmespath.ast.ComparatorType;\n+import software.amazon.smithy.jmespath.ast.ComparisonExpression;\n+import software.amazon.smithy.jmespath.ast.CurrentExpression;\n+import software.amazon.smithy.jmespath.ast.ExpressionReferenceExpression;\n+import software.amazon.smithy.jmespath.ast.FieldExpression;\n+import software.amazon.smithy.jmespath.ast.FilterProjectionExpression;\n+import software.amazon.smithy.jmespath.ast.FlattenExpression;\n+import software.amazon.smithy.jmespath.ast.FunctionExpression;\n+import software.amazon.smithy.jmespath.ast.IndexExpression;\n+import software.amazon.smithy.jmespath.ast.LiteralExpression;\n+import software.amazon.smithy.jmespath.ast.MultiSelectHashExpression;\n+import software.amazon.smithy.jmespath.ast.MultiSelectListExpression;\n+import software.amazon.smithy.jmespath.ast.NotExpression;\n+import software.amazon.smithy.jmespath.ast.ObjectProjectionExpression;\n+import software.amazon.smithy.jmespath.ast.OrExpression;\n+import software.amazon.smithy.jmespath.ast.ProjectionExpression;\n+import software.amazon.smithy.jmespath.ast.SliceExpression;\n+import software.amazon.smithy.jmespath.ast.Subexpression;\n+\n+/**\n+ * A top-down operator precedence parser (aka Pratt parser) for JMESPath.\n+ */\n+final class Parser {\n+\n+    /** The maximum binding power for a token that can stop a projection. */\n+    private static final int PROJECTION_STOP = 10;\n+\n+    /** Tokens that can start an expression. */\n+    private static final TokenType[] NUD_TOKENS = {\n+            TokenType.CURRENT,\n+            TokenType.IDENTIFIER,\n+            TokenType.LITERAL,\n+            TokenType.STAR,\n+            TokenType.LBRACE,\n+            TokenType.LBRACKET,\n+            TokenType.FLATTEN,\n+            TokenType.EXPREF,\n+            TokenType.NOT,\n+            TokenType.FILTER,\n+            TokenType.LPAREN\n+    };\n+\n+    /** Tokens that can follow led tokens. */\n+    private static final TokenType[] LED_TOKENS = {\n+            TokenType.DOT,\n+            TokenType.LBRACKET,\n+            TokenType.OR,\n+            TokenType.AND,\n+            TokenType.PIPE,\n+            TokenType.LPAREN,\n+            TokenType.FLATTEN,\n+            TokenType.FILTER,\n+            TokenType.EQUAL,\n+            TokenType.NOT_EQUAL,\n+            TokenType.GREATER_THAN,\n+            TokenType.GREATER_THAN_EQUAL,\n+            TokenType.LESS_THAN,\n+            TokenType.LESS_THAN_EQUAL\n+    };\n+\n+    private final String expression;\n+    private final TokenIterator iterator;\n+\n+    private Parser(String expression) {\n+        this.expression = expression;\n+        iterator = Lexer.tokenize(expression);\n+    }\n+\n+    static JmespathExpression parse(String expression) {\n+        Parser parser = new Parser(expression);\n+        JmespathExpression result = parser.expression(0);\n+        parser.iterator.expect(TokenType.EOF);\n+        return result;\n+    }\n+\n+    private JmespathExpression expression(int rbp) {\n+        JmespathExpression left = nud();\n+        while (iterator.hasNext() && rbp < iterator.peek().type.lbp) {\n+            left = led(left);\n+        }\n+        return left;\n+    }\n+\n+    private JmespathExpression nud() {\n+        Token token = iterator.expect(NUD_TOKENS);\n+        switch (token.type) {\n+            case CURRENT: // Example: @\n+                return new CurrentExpression(token.line, token.column);\n+            case IDENTIFIER: // Example: foo\n+                // For example, \"foo(\" starts a function expression.\n+                if (iterator.peek().type == TokenType.LPAREN) {\n+                    iterator.expect(TokenType.LPAREN);\n+                    List<JmespathExpression> arguments = parseList(TokenType.RPAREN);\n+                    return new FunctionExpression(token.value.asStringValue(), arguments, token.line, token.column);\n+                } else {\n+                    return new FieldExpression(token.value.asStringValue(), token.line, token.column);\n+                }\n+            case STAR: // Example: *\n+                return parseWildcardObject(new CurrentExpression(token.line, token.column));\n+            case LITERAL: // Example: `true`\n+                return new LiteralExpression(token.value.getValue(), token.line, token.column);\n+            case LBRACKET: // Example: [1]\n+                return parseNudLbracket();\n+            case LBRACE:  // Example: {foo: bar}\n+                return parseNudLbrace();\n+            case FLATTEN: // Example: [].bar\n+                return parseFlatten(new CurrentExpression(token.line, token.column));\n+            case EXPREF:  // Example: sort_by(@, &foo)\n+                JmespathExpression expressionRef = expression(token.type.lbp);\n+                return new ExpressionReferenceExpression(expressionRef, token.line, token.column);\n+            case NOT: // Example: !foo\n+                JmespathExpression notNode = expression(token.type.lbp);\n+                return new NotExpression(notNode, token.line, token.column);\n+            case FILTER: // Example: [?foo == bar]\n+                return parseFilter(new CurrentExpression(token.line, token.column));\n+            case LPAREN: // Example (foo)\n+                JmespathExpression insideParens = expression(0);\n+                iterator.expect(TokenType.RPAREN);\n+                return insideParens;\n+            default:\n+                throw iterator.syntax(\"Invalid nud token: \" + token);\n+        }\n+    }\n+\n+    private JmespathExpression led(JmespathExpression left) {\n+        Token token = iterator.expect(LED_TOKENS);\n+\n+        switch (token.type) {\n+            case DOT:\n+                // For example, \"foo.bar\"\n+                if (iterator.peek().type == TokenType.STAR) {\n+                    // \"Example: foo.*\". This is mostly an optimization of the\n+                    // generated AST to not need a subexpression to contain the\n+                    // projection.\n+                    iterator.expect(TokenType.STAR); // skip the \"*\".\n+                    return parseWildcardObject(left);\n+                } else {\n+                    // \"foo.*\", \"foo.bar\", \"foo.[bar]\", \"foo.length(@)\", etc.\n+                    JmespathExpression dotRhs = parseDotRhs(TokenType.DOT.lbp);\n+                    return new Subexpression(left, dotRhs, token.line, token.column);\n+                }\n+            case FLATTEN: // Example: a[].b\n+                return parseFlatten(left);\n+            case OR: // Example: a || b\n+                return new OrExpression(left, expression(token.type.lbp), token.line, token.column);\n+            case AND: // Example: a && b\n+                return new AndExpression(left, expression(token.type.lbp), token.line, token.column);\n+            case PIPE: // Example: a | b\n+                return new Subexpression(left, expression(token.type.lbp), token.line, token.column);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "05b0728331d653844be567dbf3fcc9f07d79a8ba"}, "originalPosition": 171}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjMzODEwNA==", "bodyText": "This difference is intentionally omitted. The AST is not intended to be a parse tree, so it does take liberties to simplify the representation of an expression.", "url": "https://github.com/awslabs/smithy/pull/621#discussion_r516338104", "createdAt": "2020-11-02T23:44:30Z", "author": {"login": "mtdowling"}, "path": "smithy-jmespath/src/main/java/software/amazon/smithy/jmespath/Parser.java", "diffHunk": "@@ -0,0 +1,403 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package software.amazon.smithy.jmespath;\n+\n+import java.util.ArrayList;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import software.amazon.smithy.jmespath.ast.AndExpression;\n+import software.amazon.smithy.jmespath.ast.ComparatorType;\n+import software.amazon.smithy.jmespath.ast.ComparisonExpression;\n+import software.amazon.smithy.jmespath.ast.CurrentExpression;\n+import software.amazon.smithy.jmespath.ast.ExpressionReferenceExpression;\n+import software.amazon.smithy.jmespath.ast.FieldExpression;\n+import software.amazon.smithy.jmespath.ast.FilterProjectionExpression;\n+import software.amazon.smithy.jmespath.ast.FlattenExpression;\n+import software.amazon.smithy.jmespath.ast.FunctionExpression;\n+import software.amazon.smithy.jmespath.ast.IndexExpression;\n+import software.amazon.smithy.jmespath.ast.LiteralExpression;\n+import software.amazon.smithy.jmespath.ast.MultiSelectHashExpression;\n+import software.amazon.smithy.jmespath.ast.MultiSelectListExpression;\n+import software.amazon.smithy.jmespath.ast.NotExpression;\n+import software.amazon.smithy.jmespath.ast.ObjectProjectionExpression;\n+import software.amazon.smithy.jmespath.ast.OrExpression;\n+import software.amazon.smithy.jmespath.ast.ProjectionExpression;\n+import software.amazon.smithy.jmespath.ast.SliceExpression;\n+import software.amazon.smithy.jmespath.ast.Subexpression;\n+\n+/**\n+ * A top-down operator precedence parser (aka Pratt parser) for JMESPath.\n+ */\n+final class Parser {\n+\n+    /** The maximum binding power for a token that can stop a projection. */\n+    private static final int PROJECTION_STOP = 10;\n+\n+    /** Tokens that can start an expression. */\n+    private static final TokenType[] NUD_TOKENS = {\n+            TokenType.CURRENT,\n+            TokenType.IDENTIFIER,\n+            TokenType.LITERAL,\n+            TokenType.STAR,\n+            TokenType.LBRACE,\n+            TokenType.LBRACKET,\n+            TokenType.FLATTEN,\n+            TokenType.EXPREF,\n+            TokenType.NOT,\n+            TokenType.FILTER,\n+            TokenType.LPAREN\n+    };\n+\n+    /** Tokens that can follow led tokens. */\n+    private static final TokenType[] LED_TOKENS = {\n+            TokenType.DOT,\n+            TokenType.LBRACKET,\n+            TokenType.OR,\n+            TokenType.AND,\n+            TokenType.PIPE,\n+            TokenType.LPAREN,\n+            TokenType.FLATTEN,\n+            TokenType.FILTER,\n+            TokenType.EQUAL,\n+            TokenType.NOT_EQUAL,\n+            TokenType.GREATER_THAN,\n+            TokenType.GREATER_THAN_EQUAL,\n+            TokenType.LESS_THAN,\n+            TokenType.LESS_THAN_EQUAL\n+    };\n+\n+    private final String expression;\n+    private final TokenIterator iterator;\n+\n+    private Parser(String expression) {\n+        this.expression = expression;\n+        iterator = Lexer.tokenize(expression);\n+    }\n+\n+    static JmespathExpression parse(String expression) {\n+        Parser parser = new Parser(expression);\n+        JmespathExpression result = parser.expression(0);\n+        parser.iterator.expect(TokenType.EOF);\n+        return result;\n+    }\n+\n+    private JmespathExpression expression(int rbp) {\n+        JmespathExpression left = nud();\n+        while (iterator.hasNext() && rbp < iterator.peek().type.lbp) {\n+            left = led(left);\n+        }\n+        return left;\n+    }\n+\n+    private JmespathExpression nud() {\n+        Token token = iterator.expect(NUD_TOKENS);\n+        switch (token.type) {\n+            case CURRENT: // Example: @\n+                return new CurrentExpression(token.line, token.column);\n+            case IDENTIFIER: // Example: foo\n+                // For example, \"foo(\" starts a function expression.\n+                if (iterator.peek().type == TokenType.LPAREN) {\n+                    iterator.expect(TokenType.LPAREN);\n+                    List<JmespathExpression> arguments = parseList(TokenType.RPAREN);\n+                    return new FunctionExpression(token.value.asStringValue(), arguments, token.line, token.column);\n+                } else {\n+                    return new FieldExpression(token.value.asStringValue(), token.line, token.column);\n+                }\n+            case STAR: // Example: *\n+                return parseWildcardObject(new CurrentExpression(token.line, token.column));\n+            case LITERAL: // Example: `true`\n+                return new LiteralExpression(token.value.getValue(), token.line, token.column);\n+            case LBRACKET: // Example: [1]\n+                return parseNudLbracket();\n+            case LBRACE:  // Example: {foo: bar}\n+                return parseNudLbrace();\n+            case FLATTEN: // Example: [].bar\n+                return parseFlatten(new CurrentExpression(token.line, token.column));\n+            case EXPREF:  // Example: sort_by(@, &foo)\n+                JmespathExpression expressionRef = expression(token.type.lbp);\n+                return new ExpressionReferenceExpression(expressionRef, token.line, token.column);\n+            case NOT: // Example: !foo\n+                JmespathExpression notNode = expression(token.type.lbp);\n+                return new NotExpression(notNode, token.line, token.column);\n+            case FILTER: // Example: [?foo == bar]\n+                return parseFilter(new CurrentExpression(token.line, token.column));\n+            case LPAREN: // Example (foo)\n+                JmespathExpression insideParens = expression(0);\n+                iterator.expect(TokenType.RPAREN);\n+                return insideParens;\n+            default:\n+                throw iterator.syntax(\"Invalid nud token: \" + token);\n+        }\n+    }\n+\n+    private JmespathExpression led(JmespathExpression left) {\n+        Token token = iterator.expect(LED_TOKENS);\n+\n+        switch (token.type) {\n+            case DOT:\n+                // For example, \"foo.bar\"\n+                if (iterator.peek().type == TokenType.STAR) {\n+                    // \"Example: foo.*\". This is mostly an optimization of the\n+                    // generated AST to not need a subexpression to contain the\n+                    // projection.\n+                    iterator.expect(TokenType.STAR); // skip the \"*\".\n+                    return parseWildcardObject(left);\n+                } else {\n+                    // \"foo.*\", \"foo.bar\", \"foo.[bar]\", \"foo.length(@)\", etc.\n+                    JmespathExpression dotRhs = parseDotRhs(TokenType.DOT.lbp);\n+                    return new Subexpression(left, dotRhs, token.line, token.column);\n+                }\n+            case FLATTEN: // Example: a[].b\n+                return parseFlatten(left);\n+            case OR: // Example: a || b\n+                return new OrExpression(left, expression(token.type.lbp), token.line, token.column);\n+            case AND: // Example: a && b\n+                return new AndExpression(left, expression(token.type.lbp), token.line, token.column);\n+            case PIPE: // Example: a | b\n+                return new Subexpression(left, expression(token.type.lbp), token.line, token.column);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjI2NzU0Mw=="}, "originalCommit": {"oid": "05b0728331d653844be567dbf3fcc9f07d79a8ba"}, "originalPosition": 171}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIzNTQ4MjQwOnYy", "diffSide": "RIGHT", "path": "smithy-jmespath/src/main/java/software/amazon/smithy/jmespath/ast/LiteralExpression.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMlQyMTozODozOFrOHsWk-w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wM1QwNjoyMzoxMVrOHshatQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjI2OTMwNw==", "bodyText": "Should these be expect for alignment with the methods on the Node implementations that throw?", "url": "https://github.com/awslabs/smithy/pull/621#discussion_r516269307", "createdAt": "2020-11-02T21:38:38Z", "author": {"login": "kstich"}, "path": "smithy-jmespath/src/main/java/software/amazon/smithy/jmespath/ast/LiteralExpression.java", "diffHunk": "@@ -0,0 +1,345 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package software.amazon.smithy.jmespath.ast;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.function.Function;\n+import software.amazon.smithy.jmespath.ExpressionVisitor;\n+import software.amazon.smithy.jmespath.JmespathException;\n+import software.amazon.smithy.jmespath.JmespathExpression;\n+import software.amazon.smithy.jmespath.RuntimeType;\n+\n+/**\n+ * Represents a literal value.\n+ */\n+public final class LiteralExpression extends JmespathExpression {\n+\n+    /** Sentinel value to represent ANY. */\n+    public static final LiteralExpression ANY = new LiteralExpression(new Object());\n+\n+    /** Sentinel value to represent any ARRAY. */\n+    public static final LiteralExpression ARRAY = new LiteralExpression(new ArrayList<>());\n+\n+    /** Sentinel value to represent any OBJECT. */\n+    public static final LiteralExpression OBJECT = new LiteralExpression(new HashMap<>());\n+\n+    /** Sentinel value to represent any BOOLEAN. */\n+    public static final LiteralExpression BOOLEAN = new LiteralExpression(false);\n+\n+    /** Sentinel value to represent any STRING. */\n+    public static final LiteralExpression STRING = new LiteralExpression(\"\");\n+\n+    /** Sentinel value to represent any NULL. */\n+    public static final LiteralExpression NUMBER = new LiteralExpression(0);\n+\n+    /** Sentinel value to represent an expression reference. */\n+    public static final LiteralExpression EXPREF = new LiteralExpression((Function<Object, Void>) o -> null);\n+\n+    /** Sentinel value to represent null. */\n+    public static final LiteralExpression NULL = new LiteralExpression(null);\n+\n+    private final Object value;\n+\n+    public LiteralExpression(Object value) {\n+        this(value, 1, 1);\n+    }\n+\n+    public LiteralExpression(Object value, int line, int column) {\n+        super(line, column);\n+\n+        // Unwrapped any wrapping that would mess up type checking.\n+        if (value instanceof LiteralExpression) {\n+            this.value = ((LiteralExpression) value).getValue();\n+        } else {\n+            this.value = value;\n+        }\n+    }\n+\n+    /**\n+     * Creates a LiteralExpression from {@code value}, unwrapping it if necessary.\n+     *\n+     * @param value Value to create the expression from.\n+     * @return Returns the LiteralExpression of the given {@code value}.\n+     */\n+    public static LiteralExpression from(Object value) {\n+        if (value instanceof LiteralExpression) {\n+            return (LiteralExpression) value;\n+        } else {\n+            return new LiteralExpression(value);\n+        }\n+    }\n+\n+    @Override\n+    public <T> T accept(ExpressionVisitor<T> visitor) {\n+        return visitor.visitLiteral(this);\n+    }\n+\n+    /**\n+     * Gets the nullable value contained in the literal value.\n+     *\n+     * @return Returns the contained value.\n+     */\n+    public Object getValue() {\n+        return value;\n+    }\n+\n+    @Override\n+    public boolean equals(Object o) {\n+        if (this == o) {\n+            return true;\n+        } else if (!(o instanceof LiteralExpression)) {\n+            return false;\n+        } else {\n+            return Objects.equals(value, ((LiteralExpression) o).value);\n+        }\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        return Objects.hash(value);\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return \"LiteralExpression{value=\" + value + '}';\n+    }\n+\n+    /**\n+     * Gets the type of the value.\n+     *\n+     * @return Returns the literal expression's runtime type.\n+     */\n+    public RuntimeType getType() {\n+        if (isArrayValue()) {\n+            return RuntimeType.ARRAY;\n+        } else if (isObjectValue()) {\n+            return RuntimeType.OBJECT;\n+        } else if (isStringValue()) {\n+            return RuntimeType.STRING;\n+        } else if (isBooleanValue()) {\n+            return RuntimeType.BOOLEAN;\n+        } else if (isNumberValue()) {\n+            return RuntimeType.NUMBER;\n+        } else if (isNullValue()) {\n+            return RuntimeType.NULL;\n+        } else if (this == EXPREF) {\n+            return RuntimeType.EXPRESSION_REFERENCE;\n+        } else {\n+            return RuntimeType.ANY;\n+        }\n+    }\n+\n+    /**\n+     * Expects the value to be an object and gets a field by\n+     * name. If the field does not exist, then a\n+     * {@link LiteralExpression} with a null value is returned.\n+     *\n+     * @param name Field to get from the expected object.\n+     * @return Returns the object field value.\n+     */\n+    public LiteralExpression getObjectField(String name) {\n+        Map<String, Object> values = asObjectValue();\n+        return values.containsKey(name)\n+               ? new LiteralExpression(values.get(name))\n+               : new LiteralExpression(null);\n+    }\n+\n+    /**\n+     * Expects the value to be an object and checks if it contains\n+     * a field by name.\n+     *\n+     * @param name Field to get from the expected object.\n+     * @return Returns true if the object contains the given key.\n+     */\n+    public boolean hasObjectField(String name) {\n+        return asObjectValue().containsKey(name);\n+    }\n+\n+    /**\n+     * Expects the value to be an array and gets the value at the given\n+     * index. If the index is negative, it is computed to the array\n+     * length minus the index. If the computed index does not exist,\n+     * a {@link LiteralExpression} with a null value is returned.\n+     *\n+     * @param index Index to get from the array.\n+     * @return Returns the array value.\n+     */\n+    public LiteralExpression getArrayIndex(int index) {\n+        List<Object> values = asArrayValue();\n+\n+        if (index < 0) {\n+            index = values.size() + index;\n+        }\n+\n+        return index >= 0 && values.size() > index\n+               ? new LiteralExpression(values.get(index))\n+               : new LiteralExpression(null);\n+    }\n+\n+    /**\n+     * Checks if the value is a string.\n+     *\n+     * @return Returns true if the value is a string.\n+     */\n+    public boolean isStringValue() {\n+        return value instanceof String;\n+    }\n+\n+    /**\n+     * Checks if the value is a number.\n+     *\n+     * @return Returns true if the value is a number.\n+     */\n+    public boolean isNumberValue() {\n+        return value instanceof Number;\n+    }\n+\n+    /**\n+     * Checks if the value is a boolean.\n+     *\n+     * @return Returns true if the value is a boolean.\n+     */\n+    public boolean isBooleanValue() {\n+        return value instanceof Boolean;\n+    }\n+\n+    /**\n+     * Checks if the value is an array.\n+     *\n+     * @return Returns true if the value is an array.\n+     */\n+    public boolean isArrayValue() {\n+        return value instanceof List;\n+    }\n+\n+    /**\n+     * Checks if the value is an object.\n+     *\n+     * @return Returns true if the value is an object.\n+     */\n+    public boolean isObjectValue() {\n+        return value instanceof Map;\n+    }\n+\n+    /**\n+     * Checks if the value is null.\n+     *\n+     * @return Returns true if the value is null.\n+     */\n+    public boolean isNullValue() {\n+        return value == null;\n+    }\n+\n+    /**\n+     * Gets the value as a string.\n+     *\n+     * @return Returns the string value.\n+     * @throws JmespathException if the value is not a string.\n+     */\n+    public String asStringValue() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "05b0728331d653844be567dbf3fcc9f07d79a8ba"}, "originalPosition": 256}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjQ0NjkwMQ==", "bodyText": "Sure, done", "url": "https://github.com/awslabs/smithy/pull/621#discussion_r516446901", "createdAt": "2020-11-03T06:23:11Z", "author": {"login": "mtdowling"}, "path": "smithy-jmespath/src/main/java/software/amazon/smithy/jmespath/ast/LiteralExpression.java", "diffHunk": "@@ -0,0 +1,345 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package software.amazon.smithy.jmespath.ast;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.function.Function;\n+import software.amazon.smithy.jmespath.ExpressionVisitor;\n+import software.amazon.smithy.jmespath.JmespathException;\n+import software.amazon.smithy.jmespath.JmespathExpression;\n+import software.amazon.smithy.jmespath.RuntimeType;\n+\n+/**\n+ * Represents a literal value.\n+ */\n+public final class LiteralExpression extends JmespathExpression {\n+\n+    /** Sentinel value to represent ANY. */\n+    public static final LiteralExpression ANY = new LiteralExpression(new Object());\n+\n+    /** Sentinel value to represent any ARRAY. */\n+    public static final LiteralExpression ARRAY = new LiteralExpression(new ArrayList<>());\n+\n+    /** Sentinel value to represent any OBJECT. */\n+    public static final LiteralExpression OBJECT = new LiteralExpression(new HashMap<>());\n+\n+    /** Sentinel value to represent any BOOLEAN. */\n+    public static final LiteralExpression BOOLEAN = new LiteralExpression(false);\n+\n+    /** Sentinel value to represent any STRING. */\n+    public static final LiteralExpression STRING = new LiteralExpression(\"\");\n+\n+    /** Sentinel value to represent any NULL. */\n+    public static final LiteralExpression NUMBER = new LiteralExpression(0);\n+\n+    /** Sentinel value to represent an expression reference. */\n+    public static final LiteralExpression EXPREF = new LiteralExpression((Function<Object, Void>) o -> null);\n+\n+    /** Sentinel value to represent null. */\n+    public static final LiteralExpression NULL = new LiteralExpression(null);\n+\n+    private final Object value;\n+\n+    public LiteralExpression(Object value) {\n+        this(value, 1, 1);\n+    }\n+\n+    public LiteralExpression(Object value, int line, int column) {\n+        super(line, column);\n+\n+        // Unwrapped any wrapping that would mess up type checking.\n+        if (value instanceof LiteralExpression) {\n+            this.value = ((LiteralExpression) value).getValue();\n+        } else {\n+            this.value = value;\n+        }\n+    }\n+\n+    /**\n+     * Creates a LiteralExpression from {@code value}, unwrapping it if necessary.\n+     *\n+     * @param value Value to create the expression from.\n+     * @return Returns the LiteralExpression of the given {@code value}.\n+     */\n+    public static LiteralExpression from(Object value) {\n+        if (value instanceof LiteralExpression) {\n+            return (LiteralExpression) value;\n+        } else {\n+            return new LiteralExpression(value);\n+        }\n+    }\n+\n+    @Override\n+    public <T> T accept(ExpressionVisitor<T> visitor) {\n+        return visitor.visitLiteral(this);\n+    }\n+\n+    /**\n+     * Gets the nullable value contained in the literal value.\n+     *\n+     * @return Returns the contained value.\n+     */\n+    public Object getValue() {\n+        return value;\n+    }\n+\n+    @Override\n+    public boolean equals(Object o) {\n+        if (this == o) {\n+            return true;\n+        } else if (!(o instanceof LiteralExpression)) {\n+            return false;\n+        } else {\n+            return Objects.equals(value, ((LiteralExpression) o).value);\n+        }\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        return Objects.hash(value);\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return \"LiteralExpression{value=\" + value + '}';\n+    }\n+\n+    /**\n+     * Gets the type of the value.\n+     *\n+     * @return Returns the literal expression's runtime type.\n+     */\n+    public RuntimeType getType() {\n+        if (isArrayValue()) {\n+            return RuntimeType.ARRAY;\n+        } else if (isObjectValue()) {\n+            return RuntimeType.OBJECT;\n+        } else if (isStringValue()) {\n+            return RuntimeType.STRING;\n+        } else if (isBooleanValue()) {\n+            return RuntimeType.BOOLEAN;\n+        } else if (isNumberValue()) {\n+            return RuntimeType.NUMBER;\n+        } else if (isNullValue()) {\n+            return RuntimeType.NULL;\n+        } else if (this == EXPREF) {\n+            return RuntimeType.EXPRESSION_REFERENCE;\n+        } else {\n+            return RuntimeType.ANY;\n+        }\n+    }\n+\n+    /**\n+     * Expects the value to be an object and gets a field by\n+     * name. If the field does not exist, then a\n+     * {@link LiteralExpression} with a null value is returned.\n+     *\n+     * @param name Field to get from the expected object.\n+     * @return Returns the object field value.\n+     */\n+    public LiteralExpression getObjectField(String name) {\n+        Map<String, Object> values = asObjectValue();\n+        return values.containsKey(name)\n+               ? new LiteralExpression(values.get(name))\n+               : new LiteralExpression(null);\n+    }\n+\n+    /**\n+     * Expects the value to be an object and checks if it contains\n+     * a field by name.\n+     *\n+     * @param name Field to get from the expected object.\n+     * @return Returns true if the object contains the given key.\n+     */\n+    public boolean hasObjectField(String name) {\n+        return asObjectValue().containsKey(name);\n+    }\n+\n+    /**\n+     * Expects the value to be an array and gets the value at the given\n+     * index. If the index is negative, it is computed to the array\n+     * length minus the index. If the computed index does not exist,\n+     * a {@link LiteralExpression} with a null value is returned.\n+     *\n+     * @param index Index to get from the array.\n+     * @return Returns the array value.\n+     */\n+    public LiteralExpression getArrayIndex(int index) {\n+        List<Object> values = asArrayValue();\n+\n+        if (index < 0) {\n+            index = values.size() + index;\n+        }\n+\n+        return index >= 0 && values.size() > index\n+               ? new LiteralExpression(values.get(index))\n+               : new LiteralExpression(null);\n+    }\n+\n+    /**\n+     * Checks if the value is a string.\n+     *\n+     * @return Returns true if the value is a string.\n+     */\n+    public boolean isStringValue() {\n+        return value instanceof String;\n+    }\n+\n+    /**\n+     * Checks if the value is a number.\n+     *\n+     * @return Returns true if the value is a number.\n+     */\n+    public boolean isNumberValue() {\n+        return value instanceof Number;\n+    }\n+\n+    /**\n+     * Checks if the value is a boolean.\n+     *\n+     * @return Returns true if the value is a boolean.\n+     */\n+    public boolean isBooleanValue() {\n+        return value instanceof Boolean;\n+    }\n+\n+    /**\n+     * Checks if the value is an array.\n+     *\n+     * @return Returns true if the value is an array.\n+     */\n+    public boolean isArrayValue() {\n+        return value instanceof List;\n+    }\n+\n+    /**\n+     * Checks if the value is an object.\n+     *\n+     * @return Returns true if the value is an object.\n+     */\n+    public boolean isObjectValue() {\n+        return value instanceof Map;\n+    }\n+\n+    /**\n+     * Checks if the value is null.\n+     *\n+     * @return Returns true if the value is null.\n+     */\n+    public boolean isNullValue() {\n+        return value == null;\n+    }\n+\n+    /**\n+     * Gets the value as a string.\n+     *\n+     * @return Returns the string value.\n+     * @throws JmespathException if the value is not a string.\n+     */\n+    public String asStringValue() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjI2OTMwNw=="}, "originalCommit": {"oid": "05b0728331d653844be567dbf3fcc9f07d79a8ba"}, "originalPosition": 256}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIzNTQ5MzEyOnYy", "diffSide": "RIGHT", "path": "smithy-jmespath/src/main/java/software/amazon/smithy/jmespath/ast/MultiSelectHashExpression.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMlQyMTo0MjowNFrOHsWrRw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMlQyMTo0MjowNFrOHsWrRw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjI3MDkxOQ==", "bodyText": "Should be expressions for consistency.", "url": "https://github.com/awslabs/smithy/pull/621#discussion_r516270919", "createdAt": "2020-11-02T21:42:04Z", "author": {"login": "kstich"}, "path": "smithy-jmespath/src/main/java/software/amazon/smithy/jmespath/ast/MultiSelectHashExpression.java", "diffHunk": "@@ -0,0 +1,73 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package software.amazon.smithy.jmespath.ast;\n+\n+import java.util.Map;\n+import java.util.Objects;\n+import software.amazon.smithy.jmespath.ExpressionVisitor;\n+import software.amazon.smithy.jmespath.JmespathExpression;\n+\n+/**\n+ * Creates an object using key-value pairs.\n+ */\n+public final class MultiSelectHashExpression extends JmespathExpression {\n+\n+    private final Map<String, JmespathExpression> expressions;\n+\n+    public MultiSelectHashExpression(Map<String, JmespathExpression> entries) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "05b0728331d653844be567dbf3fcc9f07d79a8ba"}, "originalPosition": 30}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIzNTUxMDk0OnYy", "diffSide": "RIGHT", "path": "smithy-jmespath/src/main/java/software/amazon/smithy/jmespath/ast/NotExpression.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMlQyMTo0NzozNlrOHsW13w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMlQyMTo0NzozNlrOHsW13w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjI3MzYzMQ==", "bodyText": "Should be expression for consistency.", "url": "https://github.com/awslabs/smithy/pull/621#discussion_r516273631", "createdAt": "2020-11-02T21:47:36Z", "author": {"login": "kstich"}, "path": "smithy-jmespath/src/main/java/software/amazon/smithy/jmespath/ast/NotExpression.java", "diffHunk": "@@ -0,0 +1,72 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package software.amazon.smithy.jmespath.ast;\n+\n+import java.util.Objects;\n+import software.amazon.smithy.jmespath.ExpressionVisitor;\n+import software.amazon.smithy.jmespath.JmespathExpression;\n+\n+/**\n+ * Negates an expression based on if the wrapped expression is truthy.\n+ */\n+public final class NotExpression extends JmespathExpression {\n+\n+    private final JmespathExpression expression;\n+\n+    public NotExpression(JmespathExpression wrapped) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "05b0728331d653844be567dbf3fcc9f07d79a8ba"}, "originalPosition": 29}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIzNTUxMjU2OnYy", "diffSide": "RIGHT", "path": "smithy-jmespath/src/main/java/software/amazon/smithy/jmespath/TypeChecker.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMlQyMTo0ODoxMVrOHsW27A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wM1QwNzozODoxNVrOHsiyUA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjI3MzkwMA==", "bodyText": "oh no", "url": "https://github.com/awslabs/smithy/pull/621#discussion_r516273900", "createdAt": "2020-11-02T21:48:11Z", "author": {"login": "JordonPhillips"}, "path": "smithy-jmespath/src/main/java/software/amazon/smithy/jmespath/TypeChecker.java", "diffHunk": "@@ -0,0 +1,482 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package software.amazon.smithy.jmespath;\n+\n+import static software.amazon.smithy.jmespath.FunctionDefinition.isType;\n+import static software.amazon.smithy.jmespath.FunctionDefinition.listOfType;\n+import static software.amazon.smithy.jmespath.FunctionDefinition.oneOf;\n+import static software.amazon.smithy.jmespath.ast.LiteralExpression.ANY;\n+import static software.amazon.smithy.jmespath.ast.LiteralExpression.ARRAY;\n+import static software.amazon.smithy.jmespath.ast.LiteralExpression.BOOLEAN;\n+import static software.amazon.smithy.jmespath.ast.LiteralExpression.EXPREF;\n+import static software.amazon.smithy.jmespath.ast.LiteralExpression.NULL;\n+import static software.amazon.smithy.jmespath.ast.LiteralExpression.NUMBER;\n+import static software.amazon.smithy.jmespath.ast.LiteralExpression.OBJECT;\n+import static software.amazon.smithy.jmespath.ast.LiteralExpression.STRING;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import software.amazon.smithy.jmespath.ast.AndExpression;\n+import software.amazon.smithy.jmespath.ast.ComparatorType;\n+import software.amazon.smithy.jmespath.ast.ComparisonExpression;\n+import software.amazon.smithy.jmespath.ast.CurrentExpression;\n+import software.amazon.smithy.jmespath.ast.ExpressionReferenceExpression;\n+import software.amazon.smithy.jmespath.ast.FieldExpression;\n+import software.amazon.smithy.jmespath.ast.FilterProjectionExpression;\n+import software.amazon.smithy.jmespath.ast.FlattenExpression;\n+import software.amazon.smithy.jmespath.ast.FunctionExpression;\n+import software.amazon.smithy.jmespath.ast.IndexExpression;\n+import software.amazon.smithy.jmespath.ast.LiteralExpression;\n+import software.amazon.smithy.jmespath.ast.MultiSelectHashExpression;\n+import software.amazon.smithy.jmespath.ast.MultiSelectListExpression;\n+import software.amazon.smithy.jmespath.ast.NotExpression;\n+import software.amazon.smithy.jmespath.ast.ObjectProjectionExpression;\n+import software.amazon.smithy.jmespath.ast.OrExpression;\n+import software.amazon.smithy.jmespath.ast.ProjectionExpression;\n+import software.amazon.smithy.jmespath.ast.SliceExpression;\n+import software.amazon.smithy.jmespath.ast.Subexpression;\n+\n+final class TypeChecker implements ExpressionVisitor<LiteralExpression> {\n+\n+    private static final Map<String, FunctionDefinition> FUNCTIONS = new HashMap<>();\n+\n+    static {\n+        FunctionDefinition.ArgValidator isAny = isType(RuntimeType.ANY);\n+        FunctionDefinition.ArgValidator isString = isType(RuntimeType.STRING);\n+        FunctionDefinition.ArgValidator isNumber = isType(RuntimeType.NUMBER);\n+        FunctionDefinition.ArgValidator isArray = isType(RuntimeType.ARRAY);\n+\n+        FUNCTIONS.put(\"abs\", new FunctionDefinition(NUMBER, isNumber));\n+        FUNCTIONS.put(\"avg\", new FunctionDefinition(NUMBER, listOfType(RuntimeType.NUMBER)));\n+        FUNCTIONS.put(\"contains\", new FunctionDefinition(\n+                BOOLEAN, oneOf(RuntimeType.ARRAY, RuntimeType.STRING), isAny));\n+        FUNCTIONS.put(\"ceil\", new FunctionDefinition(NUMBER, isNumber));\n+        FUNCTIONS.put(\"ends_with\", new FunctionDefinition(NUMBER, isString, isString));\n+        FUNCTIONS.put(\"floor\", new FunctionDefinition(NUMBER, isNumber));\n+        FUNCTIONS.put(\"join\", new FunctionDefinition(STRING, isString, listOfType(RuntimeType.STRING)));\n+        FUNCTIONS.put(\"keys\", new FunctionDefinition(ARRAY, isType(RuntimeType.OBJECT)));\n+        FUNCTIONS.put(\"length\", new FunctionDefinition(\n+                NUMBER, oneOf(RuntimeType.STRING, RuntimeType.ARRAY, RuntimeType.OBJECT)));\n+        // TODO: Support expression reference return type validation?\n+        FUNCTIONS.put(\"map\", new FunctionDefinition(ARRAY, isType(RuntimeType.EXPRESSION_REFERENCE), isArray));\n+        // TODO: support array<X|Y>\n+        FUNCTIONS.put(\"max\", new FunctionDefinition(NUMBER, isArray));\n+        FUNCTIONS.put(\"max_by\", new FunctionDefinition(NUMBER, isArray, isType(RuntimeType.EXPRESSION_REFERENCE)));\n+        FUNCTIONS.put(\"merge\", new FunctionDefinition(OBJECT, Collections.emptyList(), isType(RuntimeType.OBJECT)));\n+        FUNCTIONS.put(\"min\", new FunctionDefinition(NUMBER, isArray));\n+        FUNCTIONS.put(\"min_by\", new FunctionDefinition(NUMBER, isArray, isType(RuntimeType.EXPRESSION_REFERENCE)));\n+        FUNCTIONS.put(\"not_null\", new FunctionDefinition(ANY, Collections.singletonList(isAny), isAny));\n+        FUNCTIONS.put(\"reverse\", new FunctionDefinition(ARRAY, oneOf(RuntimeType.ARRAY, RuntimeType.STRING)));\n+        FUNCTIONS.put(\"sort\", new FunctionDefinition(ARRAY, isArray));\n+        FUNCTIONS.put(\"sort_by\", new FunctionDefinition(ARRAY, isArray, isType(RuntimeType.EXPRESSION_REFERENCE)));\n+        FUNCTIONS.put(\"starts_with\", new FunctionDefinition(BOOLEAN, isString, isString));\n+        FUNCTIONS.put(\"sum\", new FunctionDefinition(NUMBER, listOfType(RuntimeType.NUMBER)));\n+        FUNCTIONS.put(\"to_array\", new FunctionDefinition(ARRAY, isAny));\n+        FUNCTIONS.put(\"to_string\", new FunctionDefinition(STRING, isAny));\n+        FUNCTIONS.put(\"to_number\", new FunctionDefinition(NUMBER, isAny));\n+        FUNCTIONS.put(\"type\", new FunctionDefinition(STRING, isAny));\n+        FUNCTIONS.put(\"values\", new FunctionDefinition(ARRAY, isType(RuntimeType.OBJECT)));\n+    }\n+\n+    private final LiteralExpression current;\n+    private final Set<ExpressionProblem> problems;\n+    private LiteralExpression knownFunctionType = ANY;\n+\n+    TypeChecker(LiteralExpression current, Set<ExpressionProblem> problems) {\n+        this.current = current;\n+        this.problems = problems;\n+    }\n+\n+    @Override\n+    public LiteralExpression visitComparison(ComparisonExpression expression) {\n+        LiteralExpression left = expression.getLeft().accept(this);\n+        LiteralExpression right = expression.getRight().accept(this);\n+\n+        // Different types always cause a comparison to not match.\n+        if (left.getType() != right.getType()) {\n+            return BOOLEAN;\n+        }\n+\n+        // I'm so sorry for the following code.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "05b0728331d653844be567dbf3fcc9f07d79a8ba"}, "originalPosition": 118}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjM1MjMxNA==", "bodyText": "Any reason not to break this out in to functions per type? None of the cases on the left.getType() switch have non-terminal states.", "url": "https://github.com/awslabs/smithy/pull/621#discussion_r516352314", "createdAt": "2020-11-03T00:12:16Z", "author": {"login": "kstich"}, "path": "smithy-jmespath/src/main/java/software/amazon/smithy/jmespath/TypeChecker.java", "diffHunk": "@@ -0,0 +1,482 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package software.amazon.smithy.jmespath;\n+\n+import static software.amazon.smithy.jmespath.FunctionDefinition.isType;\n+import static software.amazon.smithy.jmespath.FunctionDefinition.listOfType;\n+import static software.amazon.smithy.jmespath.FunctionDefinition.oneOf;\n+import static software.amazon.smithy.jmespath.ast.LiteralExpression.ANY;\n+import static software.amazon.smithy.jmespath.ast.LiteralExpression.ARRAY;\n+import static software.amazon.smithy.jmespath.ast.LiteralExpression.BOOLEAN;\n+import static software.amazon.smithy.jmespath.ast.LiteralExpression.EXPREF;\n+import static software.amazon.smithy.jmespath.ast.LiteralExpression.NULL;\n+import static software.amazon.smithy.jmespath.ast.LiteralExpression.NUMBER;\n+import static software.amazon.smithy.jmespath.ast.LiteralExpression.OBJECT;\n+import static software.amazon.smithy.jmespath.ast.LiteralExpression.STRING;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import software.amazon.smithy.jmespath.ast.AndExpression;\n+import software.amazon.smithy.jmespath.ast.ComparatorType;\n+import software.amazon.smithy.jmespath.ast.ComparisonExpression;\n+import software.amazon.smithy.jmespath.ast.CurrentExpression;\n+import software.amazon.smithy.jmespath.ast.ExpressionReferenceExpression;\n+import software.amazon.smithy.jmespath.ast.FieldExpression;\n+import software.amazon.smithy.jmespath.ast.FilterProjectionExpression;\n+import software.amazon.smithy.jmespath.ast.FlattenExpression;\n+import software.amazon.smithy.jmespath.ast.FunctionExpression;\n+import software.amazon.smithy.jmespath.ast.IndexExpression;\n+import software.amazon.smithy.jmespath.ast.LiteralExpression;\n+import software.amazon.smithy.jmespath.ast.MultiSelectHashExpression;\n+import software.amazon.smithy.jmespath.ast.MultiSelectListExpression;\n+import software.amazon.smithy.jmespath.ast.NotExpression;\n+import software.amazon.smithy.jmespath.ast.ObjectProjectionExpression;\n+import software.amazon.smithy.jmespath.ast.OrExpression;\n+import software.amazon.smithy.jmespath.ast.ProjectionExpression;\n+import software.amazon.smithy.jmespath.ast.SliceExpression;\n+import software.amazon.smithy.jmespath.ast.Subexpression;\n+\n+final class TypeChecker implements ExpressionVisitor<LiteralExpression> {\n+\n+    private static final Map<String, FunctionDefinition> FUNCTIONS = new HashMap<>();\n+\n+    static {\n+        FunctionDefinition.ArgValidator isAny = isType(RuntimeType.ANY);\n+        FunctionDefinition.ArgValidator isString = isType(RuntimeType.STRING);\n+        FunctionDefinition.ArgValidator isNumber = isType(RuntimeType.NUMBER);\n+        FunctionDefinition.ArgValidator isArray = isType(RuntimeType.ARRAY);\n+\n+        FUNCTIONS.put(\"abs\", new FunctionDefinition(NUMBER, isNumber));\n+        FUNCTIONS.put(\"avg\", new FunctionDefinition(NUMBER, listOfType(RuntimeType.NUMBER)));\n+        FUNCTIONS.put(\"contains\", new FunctionDefinition(\n+                BOOLEAN, oneOf(RuntimeType.ARRAY, RuntimeType.STRING), isAny));\n+        FUNCTIONS.put(\"ceil\", new FunctionDefinition(NUMBER, isNumber));\n+        FUNCTIONS.put(\"ends_with\", new FunctionDefinition(NUMBER, isString, isString));\n+        FUNCTIONS.put(\"floor\", new FunctionDefinition(NUMBER, isNumber));\n+        FUNCTIONS.put(\"join\", new FunctionDefinition(STRING, isString, listOfType(RuntimeType.STRING)));\n+        FUNCTIONS.put(\"keys\", new FunctionDefinition(ARRAY, isType(RuntimeType.OBJECT)));\n+        FUNCTIONS.put(\"length\", new FunctionDefinition(\n+                NUMBER, oneOf(RuntimeType.STRING, RuntimeType.ARRAY, RuntimeType.OBJECT)));\n+        // TODO: Support expression reference return type validation?\n+        FUNCTIONS.put(\"map\", new FunctionDefinition(ARRAY, isType(RuntimeType.EXPRESSION_REFERENCE), isArray));\n+        // TODO: support array<X|Y>\n+        FUNCTIONS.put(\"max\", new FunctionDefinition(NUMBER, isArray));\n+        FUNCTIONS.put(\"max_by\", new FunctionDefinition(NUMBER, isArray, isType(RuntimeType.EXPRESSION_REFERENCE)));\n+        FUNCTIONS.put(\"merge\", new FunctionDefinition(OBJECT, Collections.emptyList(), isType(RuntimeType.OBJECT)));\n+        FUNCTIONS.put(\"min\", new FunctionDefinition(NUMBER, isArray));\n+        FUNCTIONS.put(\"min_by\", new FunctionDefinition(NUMBER, isArray, isType(RuntimeType.EXPRESSION_REFERENCE)));\n+        FUNCTIONS.put(\"not_null\", new FunctionDefinition(ANY, Collections.singletonList(isAny), isAny));\n+        FUNCTIONS.put(\"reverse\", new FunctionDefinition(ARRAY, oneOf(RuntimeType.ARRAY, RuntimeType.STRING)));\n+        FUNCTIONS.put(\"sort\", new FunctionDefinition(ARRAY, isArray));\n+        FUNCTIONS.put(\"sort_by\", new FunctionDefinition(ARRAY, isArray, isType(RuntimeType.EXPRESSION_REFERENCE)));\n+        FUNCTIONS.put(\"starts_with\", new FunctionDefinition(BOOLEAN, isString, isString));\n+        FUNCTIONS.put(\"sum\", new FunctionDefinition(NUMBER, listOfType(RuntimeType.NUMBER)));\n+        FUNCTIONS.put(\"to_array\", new FunctionDefinition(ARRAY, isAny));\n+        FUNCTIONS.put(\"to_string\", new FunctionDefinition(STRING, isAny));\n+        FUNCTIONS.put(\"to_number\", new FunctionDefinition(NUMBER, isAny));\n+        FUNCTIONS.put(\"type\", new FunctionDefinition(STRING, isAny));\n+        FUNCTIONS.put(\"values\", new FunctionDefinition(ARRAY, isType(RuntimeType.OBJECT)));\n+    }\n+\n+    private final LiteralExpression current;\n+    private final Set<ExpressionProblem> problems;\n+    private LiteralExpression knownFunctionType = ANY;\n+\n+    TypeChecker(LiteralExpression current, Set<ExpressionProblem> problems) {\n+        this.current = current;\n+        this.problems = problems;\n+    }\n+\n+    @Override\n+    public LiteralExpression visitComparison(ComparisonExpression expression) {\n+        LiteralExpression left = expression.getLeft().accept(this);\n+        LiteralExpression right = expression.getRight().accept(this);\n+\n+        // Different types always cause a comparison to not match.\n+        if (left.getType() != right.getType()) {\n+            return BOOLEAN;\n+        }\n+\n+        // I'm so sorry for the following code.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjI3MzkwMA=="}, "originalCommit": {"oid": "05b0728331d653844be567dbf3fcc9f07d79a8ba"}, "originalPosition": 118}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjQ2OTMyOA==", "bodyText": "Refactored", "url": "https://github.com/awslabs/smithy/pull/621#discussion_r516469328", "createdAt": "2020-11-03T07:38:15Z", "author": {"login": "mtdowling"}, "path": "smithy-jmespath/src/main/java/software/amazon/smithy/jmespath/TypeChecker.java", "diffHunk": "@@ -0,0 +1,482 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package software.amazon.smithy.jmespath;\n+\n+import static software.amazon.smithy.jmespath.FunctionDefinition.isType;\n+import static software.amazon.smithy.jmespath.FunctionDefinition.listOfType;\n+import static software.amazon.smithy.jmespath.FunctionDefinition.oneOf;\n+import static software.amazon.smithy.jmespath.ast.LiteralExpression.ANY;\n+import static software.amazon.smithy.jmespath.ast.LiteralExpression.ARRAY;\n+import static software.amazon.smithy.jmespath.ast.LiteralExpression.BOOLEAN;\n+import static software.amazon.smithy.jmespath.ast.LiteralExpression.EXPREF;\n+import static software.amazon.smithy.jmespath.ast.LiteralExpression.NULL;\n+import static software.amazon.smithy.jmespath.ast.LiteralExpression.NUMBER;\n+import static software.amazon.smithy.jmespath.ast.LiteralExpression.OBJECT;\n+import static software.amazon.smithy.jmespath.ast.LiteralExpression.STRING;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import software.amazon.smithy.jmespath.ast.AndExpression;\n+import software.amazon.smithy.jmespath.ast.ComparatorType;\n+import software.amazon.smithy.jmespath.ast.ComparisonExpression;\n+import software.amazon.smithy.jmespath.ast.CurrentExpression;\n+import software.amazon.smithy.jmespath.ast.ExpressionReferenceExpression;\n+import software.amazon.smithy.jmespath.ast.FieldExpression;\n+import software.amazon.smithy.jmespath.ast.FilterProjectionExpression;\n+import software.amazon.smithy.jmespath.ast.FlattenExpression;\n+import software.amazon.smithy.jmespath.ast.FunctionExpression;\n+import software.amazon.smithy.jmespath.ast.IndexExpression;\n+import software.amazon.smithy.jmespath.ast.LiteralExpression;\n+import software.amazon.smithy.jmespath.ast.MultiSelectHashExpression;\n+import software.amazon.smithy.jmespath.ast.MultiSelectListExpression;\n+import software.amazon.smithy.jmespath.ast.NotExpression;\n+import software.amazon.smithy.jmespath.ast.ObjectProjectionExpression;\n+import software.amazon.smithy.jmespath.ast.OrExpression;\n+import software.amazon.smithy.jmespath.ast.ProjectionExpression;\n+import software.amazon.smithy.jmespath.ast.SliceExpression;\n+import software.amazon.smithy.jmespath.ast.Subexpression;\n+\n+final class TypeChecker implements ExpressionVisitor<LiteralExpression> {\n+\n+    private static final Map<String, FunctionDefinition> FUNCTIONS = new HashMap<>();\n+\n+    static {\n+        FunctionDefinition.ArgValidator isAny = isType(RuntimeType.ANY);\n+        FunctionDefinition.ArgValidator isString = isType(RuntimeType.STRING);\n+        FunctionDefinition.ArgValidator isNumber = isType(RuntimeType.NUMBER);\n+        FunctionDefinition.ArgValidator isArray = isType(RuntimeType.ARRAY);\n+\n+        FUNCTIONS.put(\"abs\", new FunctionDefinition(NUMBER, isNumber));\n+        FUNCTIONS.put(\"avg\", new FunctionDefinition(NUMBER, listOfType(RuntimeType.NUMBER)));\n+        FUNCTIONS.put(\"contains\", new FunctionDefinition(\n+                BOOLEAN, oneOf(RuntimeType.ARRAY, RuntimeType.STRING), isAny));\n+        FUNCTIONS.put(\"ceil\", new FunctionDefinition(NUMBER, isNumber));\n+        FUNCTIONS.put(\"ends_with\", new FunctionDefinition(NUMBER, isString, isString));\n+        FUNCTIONS.put(\"floor\", new FunctionDefinition(NUMBER, isNumber));\n+        FUNCTIONS.put(\"join\", new FunctionDefinition(STRING, isString, listOfType(RuntimeType.STRING)));\n+        FUNCTIONS.put(\"keys\", new FunctionDefinition(ARRAY, isType(RuntimeType.OBJECT)));\n+        FUNCTIONS.put(\"length\", new FunctionDefinition(\n+                NUMBER, oneOf(RuntimeType.STRING, RuntimeType.ARRAY, RuntimeType.OBJECT)));\n+        // TODO: Support expression reference return type validation?\n+        FUNCTIONS.put(\"map\", new FunctionDefinition(ARRAY, isType(RuntimeType.EXPRESSION_REFERENCE), isArray));\n+        // TODO: support array<X|Y>\n+        FUNCTIONS.put(\"max\", new FunctionDefinition(NUMBER, isArray));\n+        FUNCTIONS.put(\"max_by\", new FunctionDefinition(NUMBER, isArray, isType(RuntimeType.EXPRESSION_REFERENCE)));\n+        FUNCTIONS.put(\"merge\", new FunctionDefinition(OBJECT, Collections.emptyList(), isType(RuntimeType.OBJECT)));\n+        FUNCTIONS.put(\"min\", new FunctionDefinition(NUMBER, isArray));\n+        FUNCTIONS.put(\"min_by\", new FunctionDefinition(NUMBER, isArray, isType(RuntimeType.EXPRESSION_REFERENCE)));\n+        FUNCTIONS.put(\"not_null\", new FunctionDefinition(ANY, Collections.singletonList(isAny), isAny));\n+        FUNCTIONS.put(\"reverse\", new FunctionDefinition(ARRAY, oneOf(RuntimeType.ARRAY, RuntimeType.STRING)));\n+        FUNCTIONS.put(\"sort\", new FunctionDefinition(ARRAY, isArray));\n+        FUNCTIONS.put(\"sort_by\", new FunctionDefinition(ARRAY, isArray, isType(RuntimeType.EXPRESSION_REFERENCE)));\n+        FUNCTIONS.put(\"starts_with\", new FunctionDefinition(BOOLEAN, isString, isString));\n+        FUNCTIONS.put(\"sum\", new FunctionDefinition(NUMBER, listOfType(RuntimeType.NUMBER)));\n+        FUNCTIONS.put(\"to_array\", new FunctionDefinition(ARRAY, isAny));\n+        FUNCTIONS.put(\"to_string\", new FunctionDefinition(STRING, isAny));\n+        FUNCTIONS.put(\"to_number\", new FunctionDefinition(NUMBER, isAny));\n+        FUNCTIONS.put(\"type\", new FunctionDefinition(STRING, isAny));\n+        FUNCTIONS.put(\"values\", new FunctionDefinition(ARRAY, isType(RuntimeType.OBJECT)));\n+    }\n+\n+    private final LiteralExpression current;\n+    private final Set<ExpressionProblem> problems;\n+    private LiteralExpression knownFunctionType = ANY;\n+\n+    TypeChecker(LiteralExpression current, Set<ExpressionProblem> problems) {\n+        this.current = current;\n+        this.problems = problems;\n+    }\n+\n+    @Override\n+    public LiteralExpression visitComparison(ComparisonExpression expression) {\n+        LiteralExpression left = expression.getLeft().accept(this);\n+        LiteralExpression right = expression.getRight().accept(this);\n+\n+        // Different types always cause a comparison to not match.\n+        if (left.getType() != right.getType()) {\n+            return BOOLEAN;\n+        }\n+\n+        // I'm so sorry for the following code.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjI3MzkwMA=="}, "originalCommit": {"oid": "05b0728331d653844be567dbf3fcc9f07d79a8ba"}, "originalPosition": 118}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIzNTYyNjAwOnYy", "diffSide": "RIGHT", "path": "smithy-jmespath/src/main/java/software/amazon/smithy/jmespath/Parser.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMlQyMjoyNDowNVrOHsX7mg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wM1QwNjoyOTo1MlrOHshg9g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjI5MTQ4Mg==", "bodyText": "Doesn't appear in the led() below.", "url": "https://github.com/awslabs/smithy/pull/621#discussion_r516291482", "createdAt": "2020-11-02T22:24:05Z", "author": {"login": "kstich"}, "path": "smithy-jmespath/src/main/java/software/amazon/smithy/jmespath/Parser.java", "diffHunk": "@@ -0,0 +1,403 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package software.amazon.smithy.jmespath;\n+\n+import java.util.ArrayList;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import software.amazon.smithy.jmespath.ast.AndExpression;\n+import software.amazon.smithy.jmespath.ast.ComparatorType;\n+import software.amazon.smithy.jmespath.ast.ComparisonExpression;\n+import software.amazon.smithy.jmespath.ast.CurrentExpression;\n+import software.amazon.smithy.jmespath.ast.ExpressionReferenceExpression;\n+import software.amazon.smithy.jmespath.ast.FieldExpression;\n+import software.amazon.smithy.jmespath.ast.FilterProjectionExpression;\n+import software.amazon.smithy.jmespath.ast.FlattenExpression;\n+import software.amazon.smithy.jmespath.ast.FunctionExpression;\n+import software.amazon.smithy.jmespath.ast.IndexExpression;\n+import software.amazon.smithy.jmespath.ast.LiteralExpression;\n+import software.amazon.smithy.jmespath.ast.MultiSelectHashExpression;\n+import software.amazon.smithy.jmespath.ast.MultiSelectListExpression;\n+import software.amazon.smithy.jmespath.ast.NotExpression;\n+import software.amazon.smithy.jmespath.ast.ObjectProjectionExpression;\n+import software.amazon.smithy.jmespath.ast.OrExpression;\n+import software.amazon.smithy.jmespath.ast.ProjectionExpression;\n+import software.amazon.smithy.jmespath.ast.SliceExpression;\n+import software.amazon.smithy.jmespath.ast.Subexpression;\n+\n+/**\n+ * A top-down operator precedence parser (aka Pratt parser) for JMESPath.\n+ */\n+final class Parser {\n+\n+    /** The maximum binding power for a token that can stop a projection. */\n+    private static final int PROJECTION_STOP = 10;\n+\n+    /** Tokens that can start an expression. */\n+    private static final TokenType[] NUD_TOKENS = {\n+            TokenType.CURRENT,\n+            TokenType.IDENTIFIER,\n+            TokenType.LITERAL,\n+            TokenType.STAR,\n+            TokenType.LBRACE,\n+            TokenType.LBRACKET,\n+            TokenType.FLATTEN,\n+            TokenType.EXPREF,\n+            TokenType.NOT,\n+            TokenType.FILTER,\n+            TokenType.LPAREN\n+    };\n+\n+    /** Tokens that can follow led tokens. */\n+    private static final TokenType[] LED_TOKENS = {\n+            TokenType.DOT,\n+            TokenType.LBRACKET,\n+            TokenType.OR,\n+            TokenType.AND,\n+            TokenType.PIPE,\n+            TokenType.LPAREN,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "05b0728331d653844be567dbf3fcc9f07d79a8ba"}, "originalPosition": 72}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjQ0ODUwMg==", "bodyText": "Added a comment to explain this:\n// While not found in the led() method, a led LPAREN is handled\n// when parsing a nud identifier because it creates a function.", "url": "https://github.com/awslabs/smithy/pull/621#discussion_r516448502", "createdAt": "2020-11-03T06:29:52Z", "author": {"login": "mtdowling"}, "path": "smithy-jmespath/src/main/java/software/amazon/smithy/jmespath/Parser.java", "diffHunk": "@@ -0,0 +1,403 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package software.amazon.smithy.jmespath;\n+\n+import java.util.ArrayList;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import software.amazon.smithy.jmespath.ast.AndExpression;\n+import software.amazon.smithy.jmespath.ast.ComparatorType;\n+import software.amazon.smithy.jmespath.ast.ComparisonExpression;\n+import software.amazon.smithy.jmespath.ast.CurrentExpression;\n+import software.amazon.smithy.jmespath.ast.ExpressionReferenceExpression;\n+import software.amazon.smithy.jmespath.ast.FieldExpression;\n+import software.amazon.smithy.jmespath.ast.FilterProjectionExpression;\n+import software.amazon.smithy.jmespath.ast.FlattenExpression;\n+import software.amazon.smithy.jmespath.ast.FunctionExpression;\n+import software.amazon.smithy.jmespath.ast.IndexExpression;\n+import software.amazon.smithy.jmespath.ast.LiteralExpression;\n+import software.amazon.smithy.jmespath.ast.MultiSelectHashExpression;\n+import software.amazon.smithy.jmespath.ast.MultiSelectListExpression;\n+import software.amazon.smithy.jmespath.ast.NotExpression;\n+import software.amazon.smithy.jmespath.ast.ObjectProjectionExpression;\n+import software.amazon.smithy.jmespath.ast.OrExpression;\n+import software.amazon.smithy.jmespath.ast.ProjectionExpression;\n+import software.amazon.smithy.jmespath.ast.SliceExpression;\n+import software.amazon.smithy.jmespath.ast.Subexpression;\n+\n+/**\n+ * A top-down operator precedence parser (aka Pratt parser) for JMESPath.\n+ */\n+final class Parser {\n+\n+    /** The maximum binding power for a token that can stop a projection. */\n+    private static final int PROJECTION_STOP = 10;\n+\n+    /** Tokens that can start an expression. */\n+    private static final TokenType[] NUD_TOKENS = {\n+            TokenType.CURRENT,\n+            TokenType.IDENTIFIER,\n+            TokenType.LITERAL,\n+            TokenType.STAR,\n+            TokenType.LBRACE,\n+            TokenType.LBRACKET,\n+            TokenType.FLATTEN,\n+            TokenType.EXPREF,\n+            TokenType.NOT,\n+            TokenType.FILTER,\n+            TokenType.LPAREN\n+    };\n+\n+    /** Tokens that can follow led tokens. */\n+    private static final TokenType[] LED_TOKENS = {\n+            TokenType.DOT,\n+            TokenType.LBRACKET,\n+            TokenType.OR,\n+            TokenType.AND,\n+            TokenType.PIPE,\n+            TokenType.LPAREN,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjI5MTQ4Mg=="}, "originalCommit": {"oid": "05b0728331d653844be567dbf3fcc9f07d79a8ba"}, "originalPosition": 72}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIzNTcxMzcxOnYy", "diffSide": "RIGHT", "path": "smithy-jmespath/src/test/java/software/amazon/smithy/jmespath/RunnerTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMlQyMjo0OToyOFrOHsYytg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMlQyMjo0OToyOFrOHsYytg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjMwNTU5MA==", "bodyText": "Should this else be removed?", "url": "https://github.com/awslabs/smithy/pull/621#discussion_r516305590", "createdAt": "2020-11-02T22:49:28Z", "author": {"login": "kstich"}, "path": "smithy-jmespath/src/test/java/software/amazon/smithy/jmespath/RunnerTest.java", "diffHunk": "@@ -0,0 +1,60 @@\n+package software.amazon.smithy.jmespath;\n+\n+import java.io.BufferedReader;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.nio.charset.StandardCharsets;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+import org.junit.jupiter.api.Assertions;\n+import org.junit.jupiter.api.Test;\n+\n+/**\n+ * This test loads invalid and valid files, to ensure that they\n+ * are either able to be parsed or not able to be parsed.\n+ */\n+public class RunnerTest {\n+    @Test\n+    public void validTests() {\n+        for (String line : readFile(getClass().getResourceAsStream(\"valid\"))) {\n+            try {\n+                JmespathExpression expression = JmespathExpression.parse(line);\n+                for (ExpressionProblem problem : expression.lint().getProblems()) {\n+                    if (problem.severity == ExpressionProblem.Severity.ERROR) {\n+                        Assertions.fail(\"Did not expect an ERROR for line: \" + line + \"\\n\" + problem);\n+                    } else {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "05b0728331d653844be567dbf3fcc9f07d79a8ba"}, "originalPosition": 25}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIzNTc1NjQ4OnYy", "diffSide": "RIGHT", "path": "smithy-jmespath/src/test/java/software/amazon/smithy/jmespath/ast/LiteralExpressionTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMlQyMzowMTo1MFrOHsZORQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wM1QwNTo1OToxNFrOHshEOw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjMxMjY0NQ==", "bodyText": "0 being truthy surprised me and I couldn't find it in the spec, can you provide the source?", "url": "https://github.com/awslabs/smithy/pull/621#discussion_r516312645", "createdAt": "2020-11-02T23:01:50Z", "author": {"login": "kstich"}, "path": "smithy-jmespath/src/test/java/software/amazon/smithy/jmespath/ast/LiteralExpressionTest.java", "diffHunk": "@@ -0,0 +1,161 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package software.amazon.smithy.jmespath.ast;\n+\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.equalTo;\n+import static org.hamcrest.Matchers.is;\n+\n+import java.util.Arrays;\n+import java.util.Collections;\n+import org.junit.jupiter.api.Assertions;\n+import org.junit.jupiter.api.Test;\n+import software.amazon.smithy.jmespath.JmespathException;\n+import software.amazon.smithy.jmespath.RuntimeType;\n+\n+public class LiteralExpressionTest {\n+    @Test\n+    public void containsNullValues() {\n+        LiteralExpression node = new LiteralExpression(null);\n+\n+        assertThat(node.isNullValue(), is(true));\n+        assertThat(node.getType(), equalTo(RuntimeType.NULL));\n+    }\n+\n+    @Test\n+    public void throwsWhenNotString() {\n+        LiteralExpression node = new LiteralExpression(10);\n+\n+        Assertions.assertThrows(JmespathException.class, node::asStringValue);\n+    }\n+\n+    @Test\n+    public void getsAsString() {\n+        LiteralExpression node = new LiteralExpression(\"foo\");\n+\n+        node.asStringValue();\n+        assertThat(node.isStringValue(), is(true));\n+        assertThat(node.isNullValue(), is(false)); // not null\n+        assertThat(node.getType(), equalTo(RuntimeType.STRING));\n+    }\n+\n+    @Test\n+    public void throwsWhenNotArray() {\n+        LiteralExpression node = new LiteralExpression(\"hi\");\n+\n+        Assertions.assertThrows(JmespathException.class, node::asArrayValue);\n+    }\n+\n+    @Test\n+    public void getsAsArray() {\n+        LiteralExpression node = new LiteralExpression(Collections.emptyList());\n+\n+        node.asArrayValue();\n+        assertThat(node.isArrayValue(), is(true));\n+        assertThat(node.getType(), equalTo(RuntimeType.ARRAY));\n+    }\n+\n+    @Test\n+    public void getsNegativeArrayIndex() {\n+        LiteralExpression node = new LiteralExpression(Arrays.asList(1, 2, 3));\n+\n+        assertThat(node.getArrayIndex(-1).getValue(), equalTo(3));\n+        assertThat(node.getArrayIndex(-2).getValue(), equalTo(2));\n+        assertThat(node.getArrayIndex(-3).getValue(), equalTo(1));\n+        assertThat(node.getArrayIndex(-4).getValue(), equalTo(null));\n+    }\n+\n+    @Test\n+    public void throwsWhenNotNumber() {\n+        LiteralExpression node = new LiteralExpression(\"hi\");\n+\n+        Assertions.assertThrows(JmespathException.class, node::asNumberValue);\n+    }\n+\n+    @Test\n+    public void getsAsNumber() {\n+        LiteralExpression node = new LiteralExpression(10);\n+\n+        node.asNumberValue();\n+        assertThat(node.isNumberValue(), is(true));\n+        assertThat(node.getType(), equalTo(RuntimeType.NUMBER));\n+    }\n+\n+    @Test\n+    public void throwsWhenNotBoolean() {\n+        LiteralExpression node = new LiteralExpression(\"hi\");\n+\n+        Assertions.assertThrows(JmespathException.class, node::asBooleanValue);\n+    }\n+\n+    @Test\n+    public void getsAsBoolean() {\n+        LiteralExpression node = new LiteralExpression(true);\n+\n+        node.asBooleanValue();\n+        assertThat(node.isBooleanValue(), is(true));\n+        assertThat(node.getType(), equalTo(RuntimeType.BOOLEAN));\n+    }\n+\n+    @Test\n+    public void getsAsBoxedBoolean() {\n+        LiteralExpression node = new LiteralExpression(new Boolean(true));\n+\n+        node.asBooleanValue();\n+        assertThat(node.isBooleanValue(), is(true));\n+    }\n+\n+    @Test\n+    public void throwsWhenNotMap() {\n+        LiteralExpression node = new LiteralExpression(\"hi\");\n+\n+        Assertions.assertThrows(JmespathException.class, node::asObjectValue);\n+    }\n+\n+    @Test\n+    public void getsAsMap() {\n+        LiteralExpression node = new LiteralExpression(Collections.emptyMap());\n+\n+        node.asObjectValue();\n+        assertThat(node.isObjectValue(), is(true));\n+        assertThat(node.getType(), equalTo(RuntimeType.OBJECT));\n+    }\n+\n+    @Test\n+    public void expressionReferenceTypeIsExpref() {\n+        assertThat(LiteralExpression.EXPREF.getType(), equalTo(RuntimeType.EXPRESSION_REFERENCE));\n+    }\n+\n+    @Test\n+    public void anyValueIsAnyType() {\n+        assertThat(LiteralExpression.ANY.getType(), equalTo(RuntimeType.ANY));\n+    }\n+\n+    @Test\n+    public void determinesTruthyValues() {\n+        assertThat(new LiteralExpression(0).isTruthy(), is(true));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "05b0728331d653844be567dbf3fcc9f07d79a8ba"}, "originalPosition": 149}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjQ0MTE0Nw==", "bodyText": "https://jmespath.org/specification.html#or-expressions", "url": "https://github.com/awslabs/smithy/pull/621#discussion_r516441147", "createdAt": "2020-11-03T05:59:14Z", "author": {"login": "mtdowling"}, "path": "smithy-jmespath/src/test/java/software/amazon/smithy/jmespath/ast/LiteralExpressionTest.java", "diffHunk": "@@ -0,0 +1,161 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package software.amazon.smithy.jmespath.ast;\n+\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.equalTo;\n+import static org.hamcrest.Matchers.is;\n+\n+import java.util.Arrays;\n+import java.util.Collections;\n+import org.junit.jupiter.api.Assertions;\n+import org.junit.jupiter.api.Test;\n+import software.amazon.smithy.jmespath.JmespathException;\n+import software.amazon.smithy.jmespath.RuntimeType;\n+\n+public class LiteralExpressionTest {\n+    @Test\n+    public void containsNullValues() {\n+        LiteralExpression node = new LiteralExpression(null);\n+\n+        assertThat(node.isNullValue(), is(true));\n+        assertThat(node.getType(), equalTo(RuntimeType.NULL));\n+    }\n+\n+    @Test\n+    public void throwsWhenNotString() {\n+        LiteralExpression node = new LiteralExpression(10);\n+\n+        Assertions.assertThrows(JmespathException.class, node::asStringValue);\n+    }\n+\n+    @Test\n+    public void getsAsString() {\n+        LiteralExpression node = new LiteralExpression(\"foo\");\n+\n+        node.asStringValue();\n+        assertThat(node.isStringValue(), is(true));\n+        assertThat(node.isNullValue(), is(false)); // not null\n+        assertThat(node.getType(), equalTo(RuntimeType.STRING));\n+    }\n+\n+    @Test\n+    public void throwsWhenNotArray() {\n+        LiteralExpression node = new LiteralExpression(\"hi\");\n+\n+        Assertions.assertThrows(JmespathException.class, node::asArrayValue);\n+    }\n+\n+    @Test\n+    public void getsAsArray() {\n+        LiteralExpression node = new LiteralExpression(Collections.emptyList());\n+\n+        node.asArrayValue();\n+        assertThat(node.isArrayValue(), is(true));\n+        assertThat(node.getType(), equalTo(RuntimeType.ARRAY));\n+    }\n+\n+    @Test\n+    public void getsNegativeArrayIndex() {\n+        LiteralExpression node = new LiteralExpression(Arrays.asList(1, 2, 3));\n+\n+        assertThat(node.getArrayIndex(-1).getValue(), equalTo(3));\n+        assertThat(node.getArrayIndex(-2).getValue(), equalTo(2));\n+        assertThat(node.getArrayIndex(-3).getValue(), equalTo(1));\n+        assertThat(node.getArrayIndex(-4).getValue(), equalTo(null));\n+    }\n+\n+    @Test\n+    public void throwsWhenNotNumber() {\n+        LiteralExpression node = new LiteralExpression(\"hi\");\n+\n+        Assertions.assertThrows(JmespathException.class, node::asNumberValue);\n+    }\n+\n+    @Test\n+    public void getsAsNumber() {\n+        LiteralExpression node = new LiteralExpression(10);\n+\n+        node.asNumberValue();\n+        assertThat(node.isNumberValue(), is(true));\n+        assertThat(node.getType(), equalTo(RuntimeType.NUMBER));\n+    }\n+\n+    @Test\n+    public void throwsWhenNotBoolean() {\n+        LiteralExpression node = new LiteralExpression(\"hi\");\n+\n+        Assertions.assertThrows(JmespathException.class, node::asBooleanValue);\n+    }\n+\n+    @Test\n+    public void getsAsBoolean() {\n+        LiteralExpression node = new LiteralExpression(true);\n+\n+        node.asBooleanValue();\n+        assertThat(node.isBooleanValue(), is(true));\n+        assertThat(node.getType(), equalTo(RuntimeType.BOOLEAN));\n+    }\n+\n+    @Test\n+    public void getsAsBoxedBoolean() {\n+        LiteralExpression node = new LiteralExpression(new Boolean(true));\n+\n+        node.asBooleanValue();\n+        assertThat(node.isBooleanValue(), is(true));\n+    }\n+\n+    @Test\n+    public void throwsWhenNotMap() {\n+        LiteralExpression node = new LiteralExpression(\"hi\");\n+\n+        Assertions.assertThrows(JmespathException.class, node::asObjectValue);\n+    }\n+\n+    @Test\n+    public void getsAsMap() {\n+        LiteralExpression node = new LiteralExpression(Collections.emptyMap());\n+\n+        node.asObjectValue();\n+        assertThat(node.isObjectValue(), is(true));\n+        assertThat(node.getType(), equalTo(RuntimeType.OBJECT));\n+    }\n+\n+    @Test\n+    public void expressionReferenceTypeIsExpref() {\n+        assertThat(LiteralExpression.EXPREF.getType(), equalTo(RuntimeType.EXPRESSION_REFERENCE));\n+    }\n+\n+    @Test\n+    public void anyValueIsAnyType() {\n+        assertThat(LiteralExpression.ANY.getType(), equalTo(RuntimeType.ANY));\n+    }\n+\n+    @Test\n+    public void determinesTruthyValues() {\n+        assertThat(new LiteralExpression(0).isTruthy(), is(true));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjMxMjY0NQ=="}, "originalCommit": {"oid": "05b0728331d653844be567dbf3fcc9f07d79a8ba"}, "originalPosition": 149}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIzNTk2NTUzOnYy", "diffSide": "RIGHT", "path": "smithy-jmespath/src/main/java/software/amazon/smithy/jmespath/TypeChecker.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wM1QwMDowMDozMFrOHsbTwA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wM1QwNzoxMjo0MlrOHsiQuA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjM0NjgxNg==", "bodyText": "This seems like it can be resolved with the tools available in the PR and is relevant for multiple functions in the list.", "url": "https://github.com/awslabs/smithy/pull/621#discussion_r516346816", "createdAt": "2020-11-03T00:00:30Z", "author": {"login": "kstich"}, "path": "smithy-jmespath/src/main/java/software/amazon/smithy/jmespath/TypeChecker.java", "diffHunk": "@@ -0,0 +1,482 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package software.amazon.smithy.jmespath;\n+\n+import static software.amazon.smithy.jmespath.FunctionDefinition.isType;\n+import static software.amazon.smithy.jmespath.FunctionDefinition.listOfType;\n+import static software.amazon.smithy.jmespath.FunctionDefinition.oneOf;\n+import static software.amazon.smithy.jmespath.ast.LiteralExpression.ANY;\n+import static software.amazon.smithy.jmespath.ast.LiteralExpression.ARRAY;\n+import static software.amazon.smithy.jmespath.ast.LiteralExpression.BOOLEAN;\n+import static software.amazon.smithy.jmespath.ast.LiteralExpression.EXPREF;\n+import static software.amazon.smithy.jmespath.ast.LiteralExpression.NULL;\n+import static software.amazon.smithy.jmespath.ast.LiteralExpression.NUMBER;\n+import static software.amazon.smithy.jmespath.ast.LiteralExpression.OBJECT;\n+import static software.amazon.smithy.jmespath.ast.LiteralExpression.STRING;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import software.amazon.smithy.jmespath.ast.AndExpression;\n+import software.amazon.smithy.jmespath.ast.ComparatorType;\n+import software.amazon.smithy.jmespath.ast.ComparisonExpression;\n+import software.amazon.smithy.jmespath.ast.CurrentExpression;\n+import software.amazon.smithy.jmespath.ast.ExpressionReferenceExpression;\n+import software.amazon.smithy.jmespath.ast.FieldExpression;\n+import software.amazon.smithy.jmespath.ast.FilterProjectionExpression;\n+import software.amazon.smithy.jmespath.ast.FlattenExpression;\n+import software.amazon.smithy.jmespath.ast.FunctionExpression;\n+import software.amazon.smithy.jmespath.ast.IndexExpression;\n+import software.amazon.smithy.jmespath.ast.LiteralExpression;\n+import software.amazon.smithy.jmespath.ast.MultiSelectHashExpression;\n+import software.amazon.smithy.jmespath.ast.MultiSelectListExpression;\n+import software.amazon.smithy.jmespath.ast.NotExpression;\n+import software.amazon.smithy.jmespath.ast.ObjectProjectionExpression;\n+import software.amazon.smithy.jmespath.ast.OrExpression;\n+import software.amazon.smithy.jmespath.ast.ProjectionExpression;\n+import software.amazon.smithy.jmespath.ast.SliceExpression;\n+import software.amazon.smithy.jmespath.ast.Subexpression;\n+\n+final class TypeChecker implements ExpressionVisitor<LiteralExpression> {\n+\n+    private static final Map<String, FunctionDefinition> FUNCTIONS = new HashMap<>();\n+\n+    static {\n+        FunctionDefinition.ArgValidator isAny = isType(RuntimeType.ANY);\n+        FunctionDefinition.ArgValidator isString = isType(RuntimeType.STRING);\n+        FunctionDefinition.ArgValidator isNumber = isType(RuntimeType.NUMBER);\n+        FunctionDefinition.ArgValidator isArray = isType(RuntimeType.ARRAY);\n+\n+        FUNCTIONS.put(\"abs\", new FunctionDefinition(NUMBER, isNumber));\n+        FUNCTIONS.put(\"avg\", new FunctionDefinition(NUMBER, listOfType(RuntimeType.NUMBER)));\n+        FUNCTIONS.put(\"contains\", new FunctionDefinition(\n+                BOOLEAN, oneOf(RuntimeType.ARRAY, RuntimeType.STRING), isAny));\n+        FUNCTIONS.put(\"ceil\", new FunctionDefinition(NUMBER, isNumber));\n+        FUNCTIONS.put(\"ends_with\", new FunctionDefinition(NUMBER, isString, isString));\n+        FUNCTIONS.put(\"floor\", new FunctionDefinition(NUMBER, isNumber));\n+        FUNCTIONS.put(\"join\", new FunctionDefinition(STRING, isString, listOfType(RuntimeType.STRING)));\n+        FUNCTIONS.put(\"keys\", new FunctionDefinition(ARRAY, isType(RuntimeType.OBJECT)));\n+        FUNCTIONS.put(\"length\", new FunctionDefinition(\n+                NUMBER, oneOf(RuntimeType.STRING, RuntimeType.ARRAY, RuntimeType.OBJECT)));\n+        // TODO: Support expression reference return type validation?\n+        FUNCTIONS.put(\"map\", new FunctionDefinition(ARRAY, isType(RuntimeType.EXPRESSION_REFERENCE), isArray));\n+        // TODO: support array<X|Y>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "05b0728331d653844be567dbf3fcc9f07d79a8ba"}, "originalPosition": 80}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjQ2MDcyOA==", "bodyText": "Eh, I'm comfortable leaving this as a todo for now. It's probably several hours of work and testing to implement, and it's not all that important.", "url": "https://github.com/awslabs/smithy/pull/621#discussion_r516460728", "createdAt": "2020-11-03T07:12:42Z", "author": {"login": "mtdowling"}, "path": "smithy-jmespath/src/main/java/software/amazon/smithy/jmespath/TypeChecker.java", "diffHunk": "@@ -0,0 +1,482 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package software.amazon.smithy.jmespath;\n+\n+import static software.amazon.smithy.jmespath.FunctionDefinition.isType;\n+import static software.amazon.smithy.jmespath.FunctionDefinition.listOfType;\n+import static software.amazon.smithy.jmespath.FunctionDefinition.oneOf;\n+import static software.amazon.smithy.jmespath.ast.LiteralExpression.ANY;\n+import static software.amazon.smithy.jmespath.ast.LiteralExpression.ARRAY;\n+import static software.amazon.smithy.jmespath.ast.LiteralExpression.BOOLEAN;\n+import static software.amazon.smithy.jmespath.ast.LiteralExpression.EXPREF;\n+import static software.amazon.smithy.jmespath.ast.LiteralExpression.NULL;\n+import static software.amazon.smithy.jmespath.ast.LiteralExpression.NUMBER;\n+import static software.amazon.smithy.jmespath.ast.LiteralExpression.OBJECT;\n+import static software.amazon.smithy.jmespath.ast.LiteralExpression.STRING;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import software.amazon.smithy.jmespath.ast.AndExpression;\n+import software.amazon.smithy.jmespath.ast.ComparatorType;\n+import software.amazon.smithy.jmespath.ast.ComparisonExpression;\n+import software.amazon.smithy.jmespath.ast.CurrentExpression;\n+import software.amazon.smithy.jmespath.ast.ExpressionReferenceExpression;\n+import software.amazon.smithy.jmespath.ast.FieldExpression;\n+import software.amazon.smithy.jmespath.ast.FilterProjectionExpression;\n+import software.amazon.smithy.jmespath.ast.FlattenExpression;\n+import software.amazon.smithy.jmespath.ast.FunctionExpression;\n+import software.amazon.smithy.jmespath.ast.IndexExpression;\n+import software.amazon.smithy.jmespath.ast.LiteralExpression;\n+import software.amazon.smithy.jmespath.ast.MultiSelectHashExpression;\n+import software.amazon.smithy.jmespath.ast.MultiSelectListExpression;\n+import software.amazon.smithy.jmespath.ast.NotExpression;\n+import software.amazon.smithy.jmespath.ast.ObjectProjectionExpression;\n+import software.amazon.smithy.jmespath.ast.OrExpression;\n+import software.amazon.smithy.jmespath.ast.ProjectionExpression;\n+import software.amazon.smithy.jmespath.ast.SliceExpression;\n+import software.amazon.smithy.jmespath.ast.Subexpression;\n+\n+final class TypeChecker implements ExpressionVisitor<LiteralExpression> {\n+\n+    private static final Map<String, FunctionDefinition> FUNCTIONS = new HashMap<>();\n+\n+    static {\n+        FunctionDefinition.ArgValidator isAny = isType(RuntimeType.ANY);\n+        FunctionDefinition.ArgValidator isString = isType(RuntimeType.STRING);\n+        FunctionDefinition.ArgValidator isNumber = isType(RuntimeType.NUMBER);\n+        FunctionDefinition.ArgValidator isArray = isType(RuntimeType.ARRAY);\n+\n+        FUNCTIONS.put(\"abs\", new FunctionDefinition(NUMBER, isNumber));\n+        FUNCTIONS.put(\"avg\", new FunctionDefinition(NUMBER, listOfType(RuntimeType.NUMBER)));\n+        FUNCTIONS.put(\"contains\", new FunctionDefinition(\n+                BOOLEAN, oneOf(RuntimeType.ARRAY, RuntimeType.STRING), isAny));\n+        FUNCTIONS.put(\"ceil\", new FunctionDefinition(NUMBER, isNumber));\n+        FUNCTIONS.put(\"ends_with\", new FunctionDefinition(NUMBER, isString, isString));\n+        FUNCTIONS.put(\"floor\", new FunctionDefinition(NUMBER, isNumber));\n+        FUNCTIONS.put(\"join\", new FunctionDefinition(STRING, isString, listOfType(RuntimeType.STRING)));\n+        FUNCTIONS.put(\"keys\", new FunctionDefinition(ARRAY, isType(RuntimeType.OBJECT)));\n+        FUNCTIONS.put(\"length\", new FunctionDefinition(\n+                NUMBER, oneOf(RuntimeType.STRING, RuntimeType.ARRAY, RuntimeType.OBJECT)));\n+        // TODO: Support expression reference return type validation?\n+        FUNCTIONS.put(\"map\", new FunctionDefinition(ARRAY, isType(RuntimeType.EXPRESSION_REFERENCE), isArray));\n+        // TODO: support array<X|Y>", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjM0NjgxNg=="}, "originalCommit": {"oid": "05b0728331d653844be567dbf3fcc9f07d79a8ba"}, "originalPosition": 80}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIzNTk3NDkzOnYy", "diffSide": "RIGHT", "path": "smithy-jmespath/src/main/java/software/amazon/smithy/jmespath/ast/IndexExpression.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wM1QwMDowMzo1MlrOHsbZ9g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wM1QwMDowMzo1MlrOHsbZ9g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjM0ODQwNg==", "bodyText": "This should explain - as used for from end, instead of just -1 being possible.", "url": "https://github.com/awslabs/smithy/pull/621#discussion_r516348406", "createdAt": "2020-11-03T00:03:52Z", "author": {"login": "kstich"}, "path": "smithy-jmespath/src/main/java/software/amazon/smithy/jmespath/ast/IndexExpression.java", "diffHunk": "@@ -0,0 +1,73 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package software.amazon.smithy.jmespath.ast;\n+\n+import java.util.Objects;\n+import software.amazon.smithy.jmespath.ExpressionVisitor;\n+import software.amazon.smithy.jmespath.JmespathExpression;\n+\n+/**\n+ * Gets a specific element by zero-based index. Use -1 to get the", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "05b0728331d653844be567dbf3fcc9f07d79a8ba"}, "originalPosition": 23}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3639, "cost": 1, "resetAt": "2021-11-12T11:18:39Z"}}}