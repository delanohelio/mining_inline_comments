{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDEyNzEwMDM1", "number": 416, "reviewThreads": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNFQxNjoxNDo1N1rOD5D4MQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNFQxNjoxNDo1N1rOD5D4MQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYxMTU4OTYxOnYy", "diffSide": "RIGHT", "path": "smithy-model/src/main/java/software/amazon/smithy/model/shapes/ShapeId.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNFQxNjoxNDo1N1rOGQHnRA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNFQxNjo1NjoyMFrOGQJR2A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTU1NTE0MA==", "bodyText": "I think the fromParts functions should route through this cache as well. It's used in LoaderVisitor  for prelude loading.", "url": "https://github.com/awslabs/smithy/pull/416#discussion_r419555140", "createdAt": "2020-05-04T16:14:57Z", "author": {"login": "kstich"}, "path": "smithy-model/src/main/java/software/amazon/smithy/model/shapes/ShapeId.java", "diffHunk": "@@ -59,32 +67,12 @@ private ShapeId(String namespace, String name, String member) {\n     /**\n      * Creates an absolute shape ID from the given string.\n      *\n-     * @param absoluteShapeId Shape ID to parse.\n+     * @param id Shape ID to parse.\n      * @return The parsed ID.\n      * @throws ShapeIdSyntaxException when the ID is malformed.\n      */\n-    public static ShapeId from(String absoluteShapeId) {\n-        int namespacePosition = absoluteShapeId.indexOf('#');\n-        if (namespacePosition <= 0 || namespacePosition == absoluteShapeId.length() - 1) {\n-            throw new ShapeIdSyntaxException(\"Invalid shape ID: \" + absoluteShapeId);\n-        }\n-\n-        String namespace = absoluteShapeId.substring(0, namespacePosition);\n-        String name;\n-        String memberName = null;\n-\n-        int memberPosition = absoluteShapeId.indexOf('$');\n-        if (memberPosition == -1) {\n-            name = absoluteShapeId.substring(namespacePosition + 1);\n-        } else if (memberPosition < namespacePosition) {\n-            throw new ShapeIdSyntaxException(\"Invalid shape ID: \" + absoluteShapeId);\n-        } else {\n-            name = absoluteShapeId.substring(namespacePosition + 1, memberPosition);\n-            memberName = absoluteShapeId.substring(memberPosition + 1);\n-        }\n-\n-        validateParts(absoluteShapeId, namespace, name, memberName);\n-        return new ShapeId(absoluteShapeId, namespace, name, memberName);\n+    public static ShapeId from(String id) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "df8fb1342d8b82527619dcc0879edc5e9c73b500"}, "originalPosition": 60}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTU4MjQyNA==", "bodyText": "Using the cache for that would probably be suboptimal since the check is a guess that a shape might be in the prelude, and many will not. I will add a method to shape ID called withNamespace to optimize this though.", "url": "https://github.com/awslabs/smithy/pull/416#discussion_r419582424", "createdAt": "2020-05-04T16:56:20Z", "author": {"login": "mtdowling"}, "path": "smithy-model/src/main/java/software/amazon/smithy/model/shapes/ShapeId.java", "diffHunk": "@@ -59,32 +67,12 @@ private ShapeId(String namespace, String name, String member) {\n     /**\n      * Creates an absolute shape ID from the given string.\n      *\n-     * @param absoluteShapeId Shape ID to parse.\n+     * @param id Shape ID to parse.\n      * @return The parsed ID.\n      * @throws ShapeIdSyntaxException when the ID is malformed.\n      */\n-    public static ShapeId from(String absoluteShapeId) {\n-        int namespacePosition = absoluteShapeId.indexOf('#');\n-        if (namespacePosition <= 0 || namespacePosition == absoluteShapeId.length() - 1) {\n-            throw new ShapeIdSyntaxException(\"Invalid shape ID: \" + absoluteShapeId);\n-        }\n-\n-        String namespace = absoluteShapeId.substring(0, namespacePosition);\n-        String name;\n-        String memberName = null;\n-\n-        int memberPosition = absoluteShapeId.indexOf('$');\n-        if (memberPosition == -1) {\n-            name = absoluteShapeId.substring(namespacePosition + 1);\n-        } else if (memberPosition < namespacePosition) {\n-            throw new ShapeIdSyntaxException(\"Invalid shape ID: \" + absoluteShapeId);\n-        } else {\n-            name = absoluteShapeId.substring(namespacePosition + 1, memberPosition);\n-            memberName = absoluteShapeId.substring(memberPosition + 1);\n-        }\n-\n-        validateParts(absoluteShapeId, namespace, name, memberName);\n-        return new ShapeId(absoluteShapeId, namespace, name, memberName);\n+    public static ShapeId from(String id) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTU1NTE0MA=="}, "originalCommit": {"oid": "df8fb1342d8b82527619dcc0879edc5e9c73b500"}, "originalPosition": 60}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3804, "cost": 1, "resetAt": "2021-11-12T11:18:39Z"}}}