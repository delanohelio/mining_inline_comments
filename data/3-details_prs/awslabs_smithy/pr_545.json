{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDc1NTE4Njkw", "number": 545, "title": "Add reverse-topological index", "bodyText": "Some languages require types to be defined before they're referenced, so\nthey need a reverse topological ordering of shapes. They also need to\nknow which shapes are recursive so that they can use forward\ndeclarations before referencing recursive types. This commit adds a\nTopologicalIndex to smithy-codegen-core to provide a stable ordered\nreverse-topological set of shapes, and a set of recursive shapes along\nwith their recursive closures. This recursive closure may also be of\ninterest to code generators when deciding whether or not a recursive\nreference needs to be boxed or not to compute a type's size at compile\ntime.\nIssue #, if available:\nDescription of changes:\nBy submitting this pull request, I confirm that my contribution is made under the terms of the Apache 2.0 license.", "createdAt": "2020-08-28T16:43:49Z", "url": "https://github.com/awslabs/smithy/pull/545", "merged": true, "mergeCommit": {"oid": "8ab2c733ee9ce76f02b56c3e15dc6a60f5610a52"}, "closed": true, "closedAt": "2020-08-28T20:08:36Z", "author": {"login": "mtdowling"}, "timelineItems": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdDX1hUgH2gAyNDc1NTE4NjkwOjgyNzlmNTQ5ODUxNTdlN2UxMjllMjdkZmFlMmFkNGRjNTAzOTI5NmE=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdDarfzgFqTQ3Nzk5NDk4Mg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "8279f54985157e7e129e27dfae2ad4dc5039296a", "author": {"user": {"login": "mtdowling", "name": "Michael Dowling"}}, "url": "https://github.com/awslabs/smithy/commit/8279f54985157e7e129e27dfae2ad4dc5039296a", "committedDate": "2020-08-28T16:45:17Z", "message": "Add reverse-topological index\n\nSome languages require types to be defined before they're referenced, so\nthey need a reverse topological ordering of shapes. They also need to\nknow which shapes are recursive so that they can use forward\ndeclarations before referencing recursive types. This commit adds a\nTopologicalIndex to smithy-codegen-core to provide a stable ordered\nreverse-topological set of shapes, and a set of recursive shapes along\nwith their recursive closures. This recursive closure may also be of\ninterest to code generators when deciding whether or not a recursive\nreference needs to be boxed or not to compute a type's size at compile\ntime."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "646c39a2ca43dd6c7f6004e338d72fc5dbdcf2f2", "author": {"user": {"login": "mtdowling", "name": "Michael Dowling"}}, "url": "https://github.com/awslabs/smithy/commit/646c39a2ca43dd6c7f6004e338d72fc5dbdcf2f2", "committedDate": "2020-08-28T16:40:24Z", "message": "Add reverse-topological index\n\nSome languages require types to be defined before they're referenced, so\nthey need a reverse topological ordering of shapes. They also need to\nknow which shapes are recursive so that they can use forward\ndeclarations before referencing recursive types. This commit adds a\nTopologicalIndex to smithy-codegen-core to provide a stable ordered\nreverse-topological set of shapes, and a set of recursive shapes along\nwith their recursive closures. This recursive closure may also be of\ninterest to code generators when deciding whether or not a recursive\nreference needs to be boxed or not to compute a type's size at compile\ntime."}, "afterCommit": {"oid": "8279f54985157e7e129e27dfae2ad4dc5039296a", "author": {"user": {"login": "mtdowling", "name": "Michael Dowling"}}, "url": "https://github.com/awslabs/smithy/commit/8279f54985157e7e129e27dfae2ad4dc5039296a", "committedDate": "2020-08-28T16:45:17Z", "message": "Add reverse-topological index\n\nSome languages require types to be defined before they're referenced, so\nthey need a reverse topological ordering of shapes. They also need to\nknow which shapes are recursive so that they can use forward\ndeclarations before referencing recursive types. This commit adds a\nTopologicalIndex to smithy-codegen-core to provide a stable ordered\nreverse-topological set of shapes, and a set of recursive shapes along\nwith their recursive closures. This recursive closure may also be of\ninterest to code generators when deciding whether or not a recursive\nreference needs to be boxed or not to compute a type's size at compile\ntime."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDc3OTIyNzg4", "url": "https://github.com/awslabs/smithy/pull/545#pullrequestreview-477922788", "createdAt": "2020-08-28T17:55:47Z", "commit": {"oid": "8279f54985157e7e129e27dfae2ad4dc5039296a"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yOFQxNzo1NTo0N1rOHJPkrg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yOFQxNzo1NTo0N1rOHJPkrg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTQ1NDM4Mg==", "bodyText": "Is the ordering of this stable?", "url": "https://github.com/awslabs/smithy/pull/545#discussion_r479454382", "createdAt": "2020-08-28T17:55:47Z", "author": {"login": "JordonPhillips"}, "path": "smithy-codegen-core/src/main/java/software/amazon/smithy/codegen/core/TopologicalIndex.java", "diffHunk": "@@ -0,0 +1,192 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package software.amazon.smithy.codegen.core;\n+\n+import java.util.Collections;\n+import java.util.LinkedHashMap;\n+import java.util.LinkedHashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.TreeMap;\n+import software.amazon.smithy.model.Model;\n+import software.amazon.smithy.model.knowledge.KnowledgeIndex;\n+import software.amazon.smithy.model.knowledge.NeighborProviderIndex;\n+import software.amazon.smithy.model.loader.Prelude;\n+import software.amazon.smithy.model.neighbor.NeighborProvider;\n+import software.amazon.smithy.model.neighbor.Relationship;\n+import software.amazon.smithy.model.neighbor.RelationshipDirection;\n+import software.amazon.smithy.model.selector.PathFinder;\n+import software.amazon.smithy.model.shapes.Shape;\n+import software.amazon.smithy.model.shapes.ShapeId;\n+import software.amazon.smithy.model.shapes.SimpleShape;\n+import software.amazon.smithy.model.shapes.ToShapeId;\n+import software.amazon.smithy.utils.FunctionalUtils;\n+\n+/**\n+ * Creates a reverse-topological ordering of shapes.\n+ *\n+ * <p>This kind of reverse topological ordering is useful for languages\n+ * like C++ that need to define shapes before they can be referenced.\n+ * Only non-recursive shapes are reverse-topologically ordered using\n+ * {@link #getOrderedShapes()}. However, recursive shapes are queryable\n+ * through {@link #getRecursiveShapes()}. When this returned {@code Set} is\n+ * iterated, recursive shapes are ordered by their degree of recursion (the\n+ * number of edges across all recursive closures), and then by shape ID\n+ * when multiple shapes have the same degree of recursion.\n+ *\n+ * <p>The recursion closures of a shape can be queried using\n+ * {@link #getRecursiveClosure(ToShapeId)}. This method returns a list of\n+ * paths from the shape back to itself. This list can be useful for code\n+ * generation to generate different code based on if a recursive path\n+ * passes through particular types of shapes.\n+ */\n+public final class TopologicalIndex implements KnowledgeIndex {\n+\n+    private final Set<Shape> shapes = new LinkedHashSet<>();\n+    private final Map<Shape, List<PathFinder.Path>> recursiveShapes = new LinkedHashMap<>();\n+\n+    public TopologicalIndex(Model model) {\n+        // A reverse-topological sort can't be performed on recursive shapes,\n+        // so instead, recursive shapes are explored first and removed from\n+        // the topological sort.\n+        computeRecursiveShapes(model);\n+\n+        // Next, the model is explored using a DFS so that targets of shapes\n+        // are ordered before the shape itself.\n+        NeighborProvider provider = NeighborProviderIndex.of(model).getProvider();\n+        model.shapes()\n+                // Note that while we do not scan the prelude here, shapes from\n+                // the prelude are pull into the ordered result if referenced.\n+                .filter(FunctionalUtils.not(Prelude::isPreludeShape))\n+                .filter(shape -> !recursiveShapes.containsKey(shape))\n+                // Sort here to provide a deterministic result.\n+                .sorted()\n+                .forEach(shape -> visitShape(provider, shape));\n+    }\n+\n+    private void computeRecursiveShapes(Model model) {\n+        // PathFinder is used to find all paths from U -> U.\n+        PathFinder finder = PathFinder.create(model);\n+\n+        // The order of recursive shapes is first by the number of edges\n+        // (the degree of recursion), and then alphabetically by shape ID.\n+        Map<Integer, Map<Shape, List<PathFinder.Path>>> edgesToShapePaths = new TreeMap<>();\n+        for (Shape shape : model.toSet()) {\n+            if (!Prelude.isPreludeShape(shape) && !(shape instanceof SimpleShape)) {\n+                // Find all paths from the shape back to itself.\n+                List<PathFinder.Path> paths = finder.search(shape, shape);\n+                if (!paths.isEmpty()) {\n+                    int edgeCount = 0;\n+                    for (PathFinder.Path path : paths) {\n+                        edgeCount += path.size();\n+                    }\n+                    edgesToShapePaths.computeIfAbsent(edgeCount, s -> new TreeMap<>())\n+                            .put(shape, Collections.unmodifiableList(paths));\n+                }\n+            }\n+        }\n+\n+        for (Map.Entry<Integer, Map<Shape, List<PathFinder.Path>>> entry : edgesToShapePaths.entrySet()) {\n+            recursiveShapes.putAll(entry.getValue());\n+        }\n+    }\n+\n+    private void visitShape(NeighborProvider provider, Shape shape) {\n+        // Visit members before visiting containers. Note that no 'visited'\n+        // set is needed since only non-recursive shapes are traversed.\n+        for (Relationship rel : provider.getNeighbors(shape)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8279f54985157e7e129e27dfae2ad4dc5039296a"}, "originalPosition": 111}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDc3OTQ4MDU5", "url": "https://github.com/awslabs/smithy/pull/545#pullrequestreview-477948059", "createdAt": "2020-08-28T18:38:54Z", "commit": {"oid": "8279f54985157e7e129e27dfae2ad4dc5039296a"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "42c944456313cdee003d33910f85fdac113c0bec", "author": {"user": {"login": "mtdowling", "name": "Michael Dowling"}}, "url": "https://github.com/awslabs/smithy/commit/42c944456313cdee003d33910f85fdac113c0bec", "committedDate": "2020-08-28T20:01:40Z", "message": "Visit topological neighbors alphabetically"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDc3OTk0OTgy", "url": "https://github.com/awslabs/smithy/pull/545#pullrequestreview-477994982", "createdAt": "2020-08-28T20:04:03Z", "commit": {"oid": "42c944456313cdee003d33910f85fdac113c0bec"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2234, "cost": 1, "resetAt": "2021-11-01T11:59:11Z"}}}