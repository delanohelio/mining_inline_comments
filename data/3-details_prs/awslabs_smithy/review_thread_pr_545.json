{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDc1NTE4Njkw", "number": 545, "reviewThreads": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yOFQxNzo1NTo0N1rOEd1uTA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yOFQxNzo1NTo0N1rOEd1uTA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk5NzI0MzY0OnYy", "diffSide": "RIGHT", "path": "smithy-codegen-core/src/main/java/software/amazon/smithy/codegen/core/TopologicalIndex.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yOFQxNzo1NTo0N1rOHJPkrg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yOFQyMDowMjo1M1rOHJS9kw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTQ1NDM4Mg==", "bodyText": "Is the ordering of this stable?", "url": "https://github.com/awslabs/smithy/pull/545#discussion_r479454382", "createdAt": "2020-08-28T17:55:47Z", "author": {"login": "JordonPhillips"}, "path": "smithy-codegen-core/src/main/java/software/amazon/smithy/codegen/core/TopologicalIndex.java", "diffHunk": "@@ -0,0 +1,192 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package software.amazon.smithy.codegen.core;\n+\n+import java.util.Collections;\n+import java.util.LinkedHashMap;\n+import java.util.LinkedHashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.TreeMap;\n+import software.amazon.smithy.model.Model;\n+import software.amazon.smithy.model.knowledge.KnowledgeIndex;\n+import software.amazon.smithy.model.knowledge.NeighborProviderIndex;\n+import software.amazon.smithy.model.loader.Prelude;\n+import software.amazon.smithy.model.neighbor.NeighborProvider;\n+import software.amazon.smithy.model.neighbor.Relationship;\n+import software.amazon.smithy.model.neighbor.RelationshipDirection;\n+import software.amazon.smithy.model.selector.PathFinder;\n+import software.amazon.smithy.model.shapes.Shape;\n+import software.amazon.smithy.model.shapes.ShapeId;\n+import software.amazon.smithy.model.shapes.SimpleShape;\n+import software.amazon.smithy.model.shapes.ToShapeId;\n+import software.amazon.smithy.utils.FunctionalUtils;\n+\n+/**\n+ * Creates a reverse-topological ordering of shapes.\n+ *\n+ * <p>This kind of reverse topological ordering is useful for languages\n+ * like C++ that need to define shapes before they can be referenced.\n+ * Only non-recursive shapes are reverse-topologically ordered using\n+ * {@link #getOrderedShapes()}. However, recursive shapes are queryable\n+ * through {@link #getRecursiveShapes()}. When this returned {@code Set} is\n+ * iterated, recursive shapes are ordered by their degree of recursion (the\n+ * number of edges across all recursive closures), and then by shape ID\n+ * when multiple shapes have the same degree of recursion.\n+ *\n+ * <p>The recursion closures of a shape can be queried using\n+ * {@link #getRecursiveClosure(ToShapeId)}. This method returns a list of\n+ * paths from the shape back to itself. This list can be useful for code\n+ * generation to generate different code based on if a recursive path\n+ * passes through particular types of shapes.\n+ */\n+public final class TopologicalIndex implements KnowledgeIndex {\n+\n+    private final Set<Shape> shapes = new LinkedHashSet<>();\n+    private final Map<Shape, List<PathFinder.Path>> recursiveShapes = new LinkedHashMap<>();\n+\n+    public TopologicalIndex(Model model) {\n+        // A reverse-topological sort can't be performed on recursive shapes,\n+        // so instead, recursive shapes are explored first and removed from\n+        // the topological sort.\n+        computeRecursiveShapes(model);\n+\n+        // Next, the model is explored using a DFS so that targets of shapes\n+        // are ordered before the shape itself.\n+        NeighborProvider provider = NeighborProviderIndex.of(model).getProvider();\n+        model.shapes()\n+                // Note that while we do not scan the prelude here, shapes from\n+                // the prelude are pull into the ordered result if referenced.\n+                .filter(FunctionalUtils.not(Prelude::isPreludeShape))\n+                .filter(shape -> !recursiveShapes.containsKey(shape))\n+                // Sort here to provide a deterministic result.\n+                .sorted()\n+                .forEach(shape -> visitShape(provider, shape));\n+    }\n+\n+    private void computeRecursiveShapes(Model model) {\n+        // PathFinder is used to find all paths from U -> U.\n+        PathFinder finder = PathFinder.create(model);\n+\n+        // The order of recursive shapes is first by the number of edges\n+        // (the degree of recursion), and then alphabetically by shape ID.\n+        Map<Integer, Map<Shape, List<PathFinder.Path>>> edgesToShapePaths = new TreeMap<>();\n+        for (Shape shape : model.toSet()) {\n+            if (!Prelude.isPreludeShape(shape) && !(shape instanceof SimpleShape)) {\n+                // Find all paths from the shape back to itself.\n+                List<PathFinder.Path> paths = finder.search(shape, shape);\n+                if (!paths.isEmpty()) {\n+                    int edgeCount = 0;\n+                    for (PathFinder.Path path : paths) {\n+                        edgeCount += path.size();\n+                    }\n+                    edgesToShapePaths.computeIfAbsent(edgeCount, s -> new TreeMap<>())\n+                            .put(shape, Collections.unmodifiableList(paths));\n+                }\n+            }\n+        }\n+\n+        for (Map.Entry<Integer, Map<Shape, List<PathFinder.Path>>> entry : edgesToShapePaths.entrySet()) {\n+            recursiveShapes.putAll(entry.getValue());\n+        }\n+    }\n+\n+    private void visitShape(NeighborProvider provider, Shape shape) {\n+        // Visit members before visiting containers. Note that no 'visited'\n+        // set is needed since only non-recursive shapes are traversed.\n+        for (Relationship rel : provider.getNeighbors(shape)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8279f54985157e7e129e27dfae2ad4dc5039296a"}, "originalPosition": 111}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTUwOTkwNw==", "bodyText": "It is stable, but not alphabetically ordered. I updated it to sort neighbors alphabetically to make it more predictable.", "url": "https://github.com/awslabs/smithy/pull/545#discussion_r479509907", "createdAt": "2020-08-28T20:02:53Z", "author": {"login": "mtdowling"}, "path": "smithy-codegen-core/src/main/java/software/amazon/smithy/codegen/core/TopologicalIndex.java", "diffHunk": "@@ -0,0 +1,192 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package software.amazon.smithy.codegen.core;\n+\n+import java.util.Collections;\n+import java.util.LinkedHashMap;\n+import java.util.LinkedHashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.TreeMap;\n+import software.amazon.smithy.model.Model;\n+import software.amazon.smithy.model.knowledge.KnowledgeIndex;\n+import software.amazon.smithy.model.knowledge.NeighborProviderIndex;\n+import software.amazon.smithy.model.loader.Prelude;\n+import software.amazon.smithy.model.neighbor.NeighborProvider;\n+import software.amazon.smithy.model.neighbor.Relationship;\n+import software.amazon.smithy.model.neighbor.RelationshipDirection;\n+import software.amazon.smithy.model.selector.PathFinder;\n+import software.amazon.smithy.model.shapes.Shape;\n+import software.amazon.smithy.model.shapes.ShapeId;\n+import software.amazon.smithy.model.shapes.SimpleShape;\n+import software.amazon.smithy.model.shapes.ToShapeId;\n+import software.amazon.smithy.utils.FunctionalUtils;\n+\n+/**\n+ * Creates a reverse-topological ordering of shapes.\n+ *\n+ * <p>This kind of reverse topological ordering is useful for languages\n+ * like C++ that need to define shapes before they can be referenced.\n+ * Only non-recursive shapes are reverse-topologically ordered using\n+ * {@link #getOrderedShapes()}. However, recursive shapes are queryable\n+ * through {@link #getRecursiveShapes()}. When this returned {@code Set} is\n+ * iterated, recursive shapes are ordered by their degree of recursion (the\n+ * number of edges across all recursive closures), and then by shape ID\n+ * when multiple shapes have the same degree of recursion.\n+ *\n+ * <p>The recursion closures of a shape can be queried using\n+ * {@link #getRecursiveClosure(ToShapeId)}. This method returns a list of\n+ * paths from the shape back to itself. This list can be useful for code\n+ * generation to generate different code based on if a recursive path\n+ * passes through particular types of shapes.\n+ */\n+public final class TopologicalIndex implements KnowledgeIndex {\n+\n+    private final Set<Shape> shapes = new LinkedHashSet<>();\n+    private final Map<Shape, List<PathFinder.Path>> recursiveShapes = new LinkedHashMap<>();\n+\n+    public TopologicalIndex(Model model) {\n+        // A reverse-topological sort can't be performed on recursive shapes,\n+        // so instead, recursive shapes are explored first and removed from\n+        // the topological sort.\n+        computeRecursiveShapes(model);\n+\n+        // Next, the model is explored using a DFS so that targets of shapes\n+        // are ordered before the shape itself.\n+        NeighborProvider provider = NeighborProviderIndex.of(model).getProvider();\n+        model.shapes()\n+                // Note that while we do not scan the prelude here, shapes from\n+                // the prelude are pull into the ordered result if referenced.\n+                .filter(FunctionalUtils.not(Prelude::isPreludeShape))\n+                .filter(shape -> !recursiveShapes.containsKey(shape))\n+                // Sort here to provide a deterministic result.\n+                .sorted()\n+                .forEach(shape -> visitShape(provider, shape));\n+    }\n+\n+    private void computeRecursiveShapes(Model model) {\n+        // PathFinder is used to find all paths from U -> U.\n+        PathFinder finder = PathFinder.create(model);\n+\n+        // The order of recursive shapes is first by the number of edges\n+        // (the degree of recursion), and then alphabetically by shape ID.\n+        Map<Integer, Map<Shape, List<PathFinder.Path>>> edgesToShapePaths = new TreeMap<>();\n+        for (Shape shape : model.toSet()) {\n+            if (!Prelude.isPreludeShape(shape) && !(shape instanceof SimpleShape)) {\n+                // Find all paths from the shape back to itself.\n+                List<PathFinder.Path> paths = finder.search(shape, shape);\n+                if (!paths.isEmpty()) {\n+                    int edgeCount = 0;\n+                    for (PathFinder.Path path : paths) {\n+                        edgeCount += path.size();\n+                    }\n+                    edgesToShapePaths.computeIfAbsent(edgeCount, s -> new TreeMap<>())\n+                            .put(shape, Collections.unmodifiableList(paths));\n+                }\n+            }\n+        }\n+\n+        for (Map.Entry<Integer, Map<Shape, List<PathFinder.Path>>> entry : edgesToShapePaths.entrySet()) {\n+            recursiveShapes.putAll(entry.getValue());\n+        }\n+    }\n+\n+    private void visitShape(NeighborProvider provider, Shape shape) {\n+        // Visit members before visiting containers. Note that no 'visited'\n+        // set is needed since only non-recursive shapes are traversed.\n+        for (Relationship rel : provider.getNeighbors(shape)) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTQ1NDM4Mg=="}, "originalCommit": {"oid": "8279f54985157e7e129e27dfae2ad4dc5039296a"}, "originalPosition": 111}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3732, "cost": 1, "resetAt": "2021-11-12T11:18:39Z"}}}