{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzU4OTk0MDQ3", "number": 2919, "reviewThreads": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xMFQwODowMDoyNFrODXE17w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOFQxMToxODowM1rODbLwWw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI1NTIzMTgzOnYy", "diffSide": "RIGHT", "path": "src/ext/java/org/opentripplanner/ext/siri/SiriTripPatternCache.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xMFQwODowMDoyNFrOFcMidA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNlQwOTozNTo1M1rOFeTKqg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTEwOTg3Ng==", "bodyText": "This is dropping the feed scope, but I guess realtime sources are always matched to one specific feed so this is not needed, and in any case if we did want it we would use FeedScopedId instead of prepending another string.", "url": "https://github.com/opentripplanner/OpenTripPlanner/pull/2919#discussion_r365109876", "createdAt": "2020-01-10T08:00:24Z", "author": {"login": "abyrd"}, "path": "src/ext/java/org/opentripplanner/ext/siri/SiriTripPatternCache.java", "diffHunk": "@@ -157,7 +157,7 @@ private String generateUniqueTripPatternCode(TripPattern tripPattern) {\n             counter++;\n         }\n         // OBA library uses underscore as separator, we're moving toward colon.\n-        String code = String.format(\"%s:%s:%s:rt#%d\", routeId.getFeedId(), routeId.getId(), direction, counter);\n+        String code = String.format(\"%s:%s:rt#%d\", routeId.getId(), direction, counter);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "81a5cf495862146200874fa87f2c5acaf46e7e53"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzMxNTYyNg==", "bodyText": "I agree that once the reference to the TransitLayer has been handed off, it should not change. As you suggested, I have now changed the TransitLayerUpdater to make a shallow copy of of the TransitLayer before updating it. As none of the objects that are referenced at the top level of the TransitLayer (except tripPatternsForDate, which is also copied in the TransitLayer constructor), a shallow copy is enough to ensure that the original object is not changed.", "url": "https://github.com/opentripplanner/OpenTripPlanner/pull/2919#discussion_r367315626", "createdAt": "2020-01-16T09:35:53Z", "author": {"login": "gmellemstrand"}, "path": "src/ext/java/org/opentripplanner/ext/siri/SiriTripPatternCache.java", "diffHunk": "@@ -157,7 +157,7 @@ private String generateUniqueTripPatternCode(TripPattern tripPattern) {\n             counter++;\n         }\n         // OBA library uses underscore as separator, we're moving toward colon.\n-        String code = String.format(\"%s:%s:%s:rt#%d\", routeId.getFeedId(), routeId.getId(), direction, counter);\n+        String code = String.format(\"%s:%s:rt#%d\", routeId.getId(), direction, counter);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTEwOTg3Ng=="}, "originalCommit": {"oid": "81a5cf495862146200874fa87f2c5acaf46e7e53"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI5ODI5NDY0OnYy", "diffSide": "RIGHT", "path": "src/main/java/org/opentripplanner/routing/algorithm/raptor/transit/mappers/TransitLayerUpdater.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOFQxMToxMzoyM1rOFihSZA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOFQxMjozMzoyMVrOFijVFA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTc0MTI4NA==", "bodyText": "The operation is atomic only in the sense that reference assignment is atomic in Java. Readers may already take for granted the low-level fact that pointer read-tearing cannot happen. What is important here is not so much that the reference write is atomic, but that the object is only \"published\" and visible to other threads after all writes are complete, and that the combined act of writing and publishing happens-before any reads.  Many people will associate the term \"atomic\" with this kind of update operations composed of two or more distinct actions.\nUnfortunately, although the reference assignment is atomic, I believe this whole update operation is not atomic, in the sense that if thread A writes to fields of object X before it shares a reference to X, thread Y may see the reference update before it sees the fields within the referenced object (and so on recursively into collections). In practice, in my experience I've never encountered outright failures with the approach of simply setting fields before revealing a reference to their containing object, but if I'm not mistaken the Java Memory Model does not guarantee this will work. Strictly speaking, the reading thread could see a partially initialized Map or even a null field. I will do some more research to design a truly correct mechanism for a single writer thread \"publishing\" completed objects to a pool of reader threads. That mechanism will be reused many times in different places, so it's good to perfect it. I think the main idea is only accessing the published reference through synchronized blocks, and setting final fields in a constructor may also be an important ingredient.", "url": "https://github.com/opentripplanner/OpenTripPlanner/pull/2919#discussion_r371741284", "createdAt": "2020-01-28T11:13:23Z", "author": {"login": "abyrd"}, "path": "src/main/java/org/opentripplanner/routing/algorithm/raptor/transit/mappers/TransitLayerUpdater.java", "diffHunk": "@@ -23,15 +24,17 @@\n import static org.opentripplanner.routing.algorithm.raptor.transit.mappers.TripPatternMapper.mapOldTripPatternToRaptorTripPattern;\n \n /**\n- * Update the TransitLayer from a set of TimeTables. TripPatterns are matched on id and replaced\n- * by their updated versions. A list of TripPatternsForDate is copied from the TransitLayer for\n- * each relevant date, updated and then atomically replaced in the TransitLayer.\n+ * Update the TransitLayer from a set of TimeTables. A shallow copy is made of the TransitLayer\n+ * (this also includes a shallow copy of the TripPatternsForDate map). TripPatterns are matched on\n+ * id and replaced by their updated versions. The realtime TransitLayer is then switched out\n+ * with the updated copy in an atomic operation. This ensures that any TransitLayer that is\n+ * referenced from the Graph is never changed.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7d570b9f1d0f4c1e32d8b3f646e8e2769c8f07e8"}, "originalPosition": 19}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTc3NDc0MA==", "bodyText": "Based on your comments and discussion with @t2gran I made the realtimeTransitLayer private, wrapped it in ConcurrentPublished and made is accessible through a getter and setter.", "url": "https://github.com/opentripplanner/OpenTripPlanner/pull/2919#discussion_r371774740", "createdAt": "2020-01-28T12:33:21Z", "author": {"login": "gmellemstrand"}, "path": "src/main/java/org/opentripplanner/routing/algorithm/raptor/transit/mappers/TransitLayerUpdater.java", "diffHunk": "@@ -23,15 +24,17 @@\n import static org.opentripplanner.routing.algorithm.raptor.transit.mappers.TripPatternMapper.mapOldTripPatternToRaptorTripPattern;\n \n /**\n- * Update the TransitLayer from a set of TimeTables. TripPatterns are matched on id and replaced\n- * by their updated versions. A list of TripPatternsForDate is copied from the TransitLayer for\n- * each relevant date, updated and then atomically replaced in the TransitLayer.\n+ * Update the TransitLayer from a set of TimeTables. A shallow copy is made of the TransitLayer\n+ * (this also includes a shallow copy of the TripPatternsForDate map). TripPatterns are matched on\n+ * id and replaced by their updated versions. The realtime TransitLayer is then switched out\n+ * with the updated copy in an atomic operation. This ensures that any TransitLayer that is\n+ * referenced from the Graph is never changed.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTc0MTI4NA=="}, "originalCommit": {"oid": "7d570b9f1d0f4c1e32d8b3f646e8e2769c8f07e8"}, "originalPosition": 19}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI5ODI5ODIzOnYy", "diffSide": "RIGHT", "path": "src/main/java/org/opentripplanner/routing/algorithm/raptor/transit/mappers/TransitLayerUpdater.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOFQxMToxNDozOVrOFihUdQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOFQxMjoyODozOFrOFijNNA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTc0MTgxMw==", "bodyText": "Personally I would not make the shallow-copy method a constructor because it is tailored for a specific use case. I'd make a basic private all-fields constructor that does not transform any of its input parameters, then call that constructor from a factory method that makes a shallow copy of the one Map tripPatternsForDate. Then that factory method is specific to the use case, and can have a name like TransitLayer#copyForTripPatternUpdates. This is of course not critical now, since all constructor calls are for this purpose. It's more of a long-term style and maintenance issue.", "url": "https://github.com/opentripplanner/OpenTripPlanner/pull/2919#discussion_r371741813", "createdAt": "2020-01-28T11:14:39Z", "author": {"login": "abyrd"}, "path": "src/main/java/org/opentripplanner/routing/algorithm/raptor/transit/mappers/TransitLayerUpdater.java", "diffHunk": "@@ -43,22 +46,25 @@\n                 tripPatternForDateMapCache = new HashMap<>();\n \n   public TransitLayerUpdater(\n-      TransitLayer transitLayer,\n+      Graph graph,\n       Map<ServiceDate, TIntSet> serviceCodesRunningForDate\n   ) {\n-    this.transitLayer = transitLayer;\n+    this.graph = graph;\n     this.serviceCodesRunningForDate = serviceCodesRunningForDate;\n   }\n \n   public void update(Set<Timetable> updatedTimetables) {\n-    if (transitLayer == null) { return; }\n+    // Make a shallow copy of the realtime transit layer\n+    TransitLayer realtimeTransitLayer = new TransitLayer(graph.realtimeTransitLayer);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7d570b9f1d0f4c1e32d8b3f646e8e2769c8f07e8"}, "originalPosition": 46}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTc3MjcyNA==", "bodyText": "Actually, it is also used for making a shallow copy of the non-realtime TransitLayer to initialize the RealtimeTransitLayer. As you said, we could probably merge this now and rethink how that should work.", "url": "https://github.com/opentripplanner/OpenTripPlanner/pull/2919#discussion_r371772724", "createdAt": "2020-01-28T12:28:38Z", "author": {"login": "gmellemstrand"}, "path": "src/main/java/org/opentripplanner/routing/algorithm/raptor/transit/mappers/TransitLayerUpdater.java", "diffHunk": "@@ -43,22 +46,25 @@\n                 tripPatternForDateMapCache = new HashMap<>();\n \n   public TransitLayerUpdater(\n-      TransitLayer transitLayer,\n+      Graph graph,\n       Map<ServiceDate, TIntSet> serviceCodesRunningForDate\n   ) {\n-    this.transitLayer = transitLayer;\n+    this.graph = graph;\n     this.serviceCodesRunningForDate = serviceCodesRunningForDate;\n   }\n \n   public void update(Set<Timetable> updatedTimetables) {\n-    if (transitLayer == null) { return; }\n+    // Make a shallow copy of the realtime transit layer\n+    TransitLayer realtimeTransitLayer = new TransitLayer(graph.realtimeTransitLayer);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTc0MTgxMw=="}, "originalCommit": {"oid": "7d570b9f1d0f4c1e32d8b3f646e8e2769c8f07e8"}, "originalPosition": 46}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI5ODMwNzQ3OnYy", "diffSide": "RIGHT", "path": "src/main/java/org/opentripplanner/routing/algorithm/raptor/transit/mappers/TransitLayerUpdater.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOFQxMToxODowM1rOFihaAQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOFQxMjozNDoxNVrOFijWhQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTc0MzIzMw==", "bodyText": "Considering what I wrote above, I would change these comments to say \"The JMM guarantees reference assignment is atomic, but does not guarantee that the combined process of assigning field contents and publishing the reference is atomic. We should soon replace this assignment with a more strictly correct implementation.\"", "url": "https://github.com/opentripplanner/OpenTripPlanner/pull/2919#discussion_r371743233", "createdAt": "2020-01-28T11:18:03Z", "author": {"login": "abyrd"}, "path": "src/main/java/org/opentripplanner/routing/algorithm/raptor/transit/mappers/TransitLayerUpdater.java", "diffHunk": "@@ -99,11 +106,14 @@ public void update(Set<Timetable> updatedTimetables) {\n         }\n       }\n \n-      transitLayer.replaceTripPatternsForDate(\n+      realtimeTransitLayer.replaceTripPatternsForDate(\n           date,\n           new ArrayList<>(patternsForDateMap.values())\n       );\n \n+      // Switch out the reference with the updated transit layer. This is an atomic operation.\n+      graph.realtimeTransitLayer = realtimeTransitLayer;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7d570b9f1d0f4c1e32d8b3f646e8e2769c8f07e8"}, "originalPosition": 81}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTc3NTEwOQ==", "bodyText": "As I commented above, I wrapped the realtimeTransitLayer in ConcurrentPublished, so this change should not be needed anymore.", "url": "https://github.com/opentripplanner/OpenTripPlanner/pull/2919#discussion_r371775109", "createdAt": "2020-01-28T12:34:15Z", "author": {"login": "gmellemstrand"}, "path": "src/main/java/org/opentripplanner/routing/algorithm/raptor/transit/mappers/TransitLayerUpdater.java", "diffHunk": "@@ -99,11 +106,14 @@ public void update(Set<Timetable> updatedTimetables) {\n         }\n       }\n \n-      transitLayer.replaceTripPatternsForDate(\n+      realtimeTransitLayer.replaceTripPatternsForDate(\n           date,\n           new ArrayList<>(patternsForDateMap.values())\n       );\n \n+      // Switch out the reference with the updated transit layer. This is an atomic operation.\n+      graph.realtimeTransitLayer = realtimeTransitLayer;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTc0MzIzMw=="}, "originalCommit": {"oid": "7d570b9f1d0f4c1e32d8b3f646e8e2769c8f07e8"}, "originalPosition": 81}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1879, "cost": 1, "resetAt": "2021-11-13T12:10:21Z"}}}