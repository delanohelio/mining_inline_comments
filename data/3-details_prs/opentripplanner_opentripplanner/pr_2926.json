{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzYyODM1NTYw", "number": 2926, "title": "Otp2 limit transit service period", "bodyText": "This PR fixes the #2925, The first commit is a pure refactoring moving some of the calendar\nclasses in the otp internal model into the calendar package. I recommend looking at the second commit to review.\nThis is marked as a Regression, because this feature was not needed in OTP1, but for people with unlimited (or close to unlimited) service calendars the OTP will use a very long time to build in OTP2 - before this PR.\nTo be completed by pull request submitter:\n\n issue: Closes #2925\n roadmap: No.\n tests:  Yes, unit tests add on new code.\n formatting: Yes\n documentation: Yes, the Configuration.md and JavaDoc is updated.\n changelog: Yes\n\nTo be completed by @opentripplanner/plc:\n\n reviews and approvals by 2 members, ideally from different organizations\n after merging: update the relevant card on the roadmap", "createdAt": "2020-01-14T20:57:40Z", "url": "https://github.com/opentripplanner/OpenTripPlanner/pull/2926", "merged": true, "mergeCommit": {"oid": "0530752fdac1f5cb29bca7afd17143c2d6aeba9c"}, "closed": true, "closedAt": "2020-01-24T09:24:49Z", "author": {"login": "t2gran"}, "timelineItems": {"totalCount": 11, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABb590l8AH2gAyMzYyODM1NTYwOmM3Y2E1NDczOTI0Y2RhNTFlOTgyMjk3NTAyMzQ2MmE2MDJmNDUyNjg=", "endCursor": "Y3Vyc29yOnYyOpPPAAABb9bRbdgFqTM0NzgyMjUzNA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "c7ca5473924cda51e9822975023462a602f45268", "author": {"user": {"login": "t2gran", "name": "Thomas Gran"}}, "url": "https://github.com/opentripplanner/OpenTripPlanner/commit/c7ca5473924cda51e9822975023462a602f45268", "committedDate": "2020-01-13T15:10:16Z", "message": "Move otp calendar classes into the calendar package. The package existed, but not all date/calendar classes was in the package."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "270577cb83cdd613610572d7c3891e04f19cb603", "author": {"user": {"login": "t2gran", "name": "Thomas Gran"}}, "url": "https://github.com/opentripplanner/OpenTripPlanner/commit/270577cb83cdd613610572d7c3891e04f19cb603", "committedDate": "2020-01-15T09:34:02Z", "message": "Limit the transit service period(#2925)."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "0c17d331b37ce8cccf747631df1a1aba1a5b7874", "author": {"user": {"login": "t2gran", "name": "Thomas Gran"}}, "url": "https://github.com/opentripplanner/OpenTripPlanner/commit/0c17d331b37ce8cccf747631df1a1aba1a5b7874", "committedDate": "2020-01-14T20:48:09Z", "message": "Limit the transit service period(#2925)."}, "afterCommit": {"oid": "270577cb83cdd613610572d7c3891e04f19cb603", "author": {"user": {"login": "t2gran", "name": "Thomas Gran"}}, "url": "https://github.com/opentripplanner/OpenTripPlanner/commit/270577cb83cdd613610572d7c3891e04f19cb603", "committedDate": "2020-01-15T09:34:02Z", "message": "Limit the transit service period(#2925)."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQzMTA0NTM1", "url": "https://github.com/opentripplanner/OpenTripPlanner/pull/2926#pullrequestreview-343104535", "createdAt": "2020-01-15T10:02:13Z", "commit": {"oid": "270577cb83cdd613610572d7c3891e04f19cb603"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNVQxMDowMjoxM1rOFdy72A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNVQxMDowMjoxM1rOFdy72A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Njc4NzU0NA==", "bodyText": "Info", "url": "https://github.com/opentripplanner/OpenTripPlanner/pull/2926#discussion_r366787544", "createdAt": "2020-01-15T10:02:13Z", "author": {"login": "t2gran"}, "path": "src/main/java/org/opentripplanner/model/impl/OtpTransitServiceBuilder.java", "diffHunk": "@@ -212,4 +218,101 @@ public void regenerateIndexes() {\n         this.routesById.reindex();\n         this.stopTimesByTrip.reindex();\n     }\n+\n+    /**\n+     * Limit the transit service to a time period removing calendar dates and services\n+     * outside the period. If a service is start before and/or ends after the period\n+     * then the service is modified to match the period.\n+     */\n+    public void limitServiceDays(ServiceDateInterval periodLimit) {\n+        if(periodLimit.isUnbounded()) {\n+            LOG.warn(\"Limiting transit service is skipped, the period is unbounded.\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "270577cb83cdd613610572d7c3891e04f19cb603"}, "originalPosition": 48}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQzMTA2NTA3", "url": "https://github.com/opentripplanner/OpenTripPlanner/pull/2926#pullrequestreview-343106507", "createdAt": "2020-01-15T10:05:08Z", "commit": {"oid": "270577cb83cdd613610572d7c3891e04f19cb603"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNVQxMDowNTowOVrOFdzCKQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNVQxMDowNTowOVrOFdzCKQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Njc4OTE2MQ==", "bodyText": "Check the service codes.", "url": "https://github.com/opentripplanner/OpenTripPlanner/pull/2926#discussion_r366789161", "createdAt": "2020-01-15T10:05:09Z", "author": {"login": "t2gran"}, "path": "src/main/java/org/opentripplanner/model/impl/OtpTransitServiceBuilder.java", "diffHunk": "@@ -212,4 +218,101 @@ public void regenerateIndexes() {\n         this.routesById.reindex();\n         this.stopTimesByTrip.reindex();\n     }\n+\n+    /**\n+     * Limit the transit service to a time period removing calendar dates and services\n+     * outside the period. If a service is start before and/or ends after the period\n+     * then the service is modified to match the period.\n+     */\n+    public void limitServiceDays(ServiceDateInterval periodLimit) {\n+        if(periodLimit.isUnbounded()) {\n+            LOG.warn(\"Limiting transit service is skipped, the period is unbounded.\");\n+            return;\n+        }\n+\n+        LOG.warn(\"Limiting transit service days to time period: {}\", periodLimit);\n+\n+        int orgSize = calendarDates.size();\n+        calendarDates.removeIf(c -> !periodLimit.include(c.getDate()));\n+        logRemove(\"ServiceCalendarDate\", orgSize, calendarDates.size(), \"Outside time period.\");\n+\n+        List<ServiceCalendar> keepCal = new ArrayList<>();\n+        for (ServiceCalendar calendar : calendars) {\n+            if(calendar.getPeriod().overlap(periodLimit)) {\n+                calendar.setPeriod(calendar.getPeriod().union(periodLimit));\n+                keepCal.add(calendar);\n+            }\n+        }\n+\n+        orgSize = calendars.size();\n+        if(orgSize != keepCal.size()) {\n+            calendars.clear();\n+            calendars.addAll(keepCal);\n+            logRemove(\"ServiceCalendar\", orgSize, calendars.size(), \"Outside time period.\");\n+        }\n+        removeEntitiesWithInvalidReferences();\n+        LOG.info(\"Limiting transit service days to time period complete.\");\n+    }\n+\n+    /**\n+     * Check all relations and remove entities witch reference none existing entries. This\n+     * may happen as a result of inconsistent data or by deliberate removal of elements in the\n+     * builder.\n+     */\n+    private void removeEntitiesWithInvalidReferences() {\n+        removeTripsWithNoneExistingServiceIds();\n+        removeStopTimesForNoneExistingTrips();\n+        fixOrRemovePatternsWhichReferenceNoneExistingTrips();\n+        removeTransfersForNoneExistingTrips();\n+    }\n+\n+    /** Remove all trips witch reference none existing service ids */\n+    private void removeTripsWithNoneExistingServiceIds() {\n+        Set<FeedScopedId> serviceIds = findAllServiceIds();\n+        int orgSize = tripsById.size();\n+        tripsById.removeIf(t -> !serviceIds.contains(t.getServiceId()));\n+        logRemove(\"Trip\", orgSize, tripsById.size(), \"Trip service id does not exist.\");\n+    }\n+\n+    /** Remove all stopTimes witch reference none existing trips */\n+    private void removeStopTimesForNoneExistingTrips() {\n+        int orgSize = stopTimesByTrip.size();\n+        stopTimesByTrip.removeIf(t -> !tripsById.containsKey(t.getId()));\n+        logRemove(\"StopTime\", orgSize, stopTimesByTrip.size(), \"StopTime trip does not exist.\");\n+    }\n+\n+    /** Remove none existing trips from patterns and then remove empty patterns */\n+    private void fixOrRemovePatternsWhichReferenceNoneExistingTrips() {\n+        int orgSize = tripPatterns.size();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "270577cb83cdd613610572d7c3891e04f19cb603"}, "originalPosition": 105}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQzMjE1NTg5", "url": "https://github.com/opentripplanner/OpenTripPlanner/pull/2926#pullrequestreview-343215589", "createdAt": "2020-01-15T13:26:58Z", "commit": {"oid": "270577cb83cdd613610572d7c3891e04f19cb603"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNVQxMzoyNjo1OFrOFd4LSw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNVQxMzoyNjo1OFrOFd4LSw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Njg3MzQxOQ==", "bodyText": "The should be intersection not union.", "url": "https://github.com/opentripplanner/OpenTripPlanner/pull/2926#discussion_r366873419", "createdAt": "2020-01-15T13:26:58Z", "author": {"login": "t2gran"}, "path": "src/main/java/org/opentripplanner/model/calendar/ServiceDateInterval.java", "diffHunk": "@@ -0,0 +1,113 @@\n+package org.opentripplanner.model.calendar;\n+\n+import java.util.Objects;\n+\n+\n+/**\n+ * Value object witch represent an service date interval from a starting date\n+ * until an end date. Both start and end is inclusive.\n+ *\n+ * The {@code start} must be equals or before the {@code end} to form a valid\n+ * period.\n+ *\n+ * {@code null} is used to represent an unbounded interval. One or both the of the {@code start} and\n+ * {@code end} can be {@code null} (unbounded).\n+ */\n+public final class ServiceDateInterval {\n+\n+    /**\n+     * The unbounded values will represent an unbounded value internally in this class.\n+     * They are converted to {@code null} when exported outside the class. This little\n+     * trick make internal logic a bit simpler, since there is no need for {@code null} checks.\n+     */\n+    private static final ServiceDate UNBOUNDED_START = new ServiceDate(0, 1, 1);\n+    private static final ServiceDate UNBOUNDED_END = new ServiceDate(9999, 12, 31);\n+    private static final ServiceDateInterval UNBOUNDED = new ServiceDateInterval(null, null);\n+\n+    private final ServiceDate start;\n+    private final ServiceDate end;\n+\n+\n+    public ServiceDateInterval(ServiceDate start, ServiceDate end) {\n+        this.start = start == null ? UNBOUNDED_START : start;\n+        this.end = end == null ? UNBOUNDED_END : end;\n+\n+        // Guarantee that the start is before or equal the end.\n+        if(this.end.isBefore(this.start)) {\n+            throw new IllegalArgumentException(\n+                    \"Invalid interval, the end \" + end + \" is before the start \" +  start\n+            );\n+        }\n+    }\n+\n+    /**\n+     * Return a interval with start or end unbounded ({@code null}).\n+     */\n+    public static ServiceDateInterval unbounded() {\n+        return UNBOUNDED;\n+    }\n+\n+    public boolean isUnbounded() {\n+        return start.equals(UNBOUNDED_START) && end.equals(UNBOUNDED_END);\n+    }\n+\n+    public ServiceDate getStart() {\n+        return start == UNBOUNDED_START ? null : start;\n+    }\n+\n+    public ServiceDate getEnd() {\n+        return end == UNBOUNDED_END ? null : end;\n+    }\n+\n+    /**\n+     * The intervals have at least one day in common.\n+     * @see #union(ServiceDateInterval)\n+     */\n+    public boolean overlap(ServiceDateInterval other) {\n+        if(start.isBeforeOrEq(other.end)) {\n+            return end.isAfterOrEq(other.start);\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Return a new service interval that contains the period witch is common for both periods\n+     * (common set of service days).\n+     *\n+     * @see #overlap(ServiceDateInterval) for checking an union exist.\n+     *\n+     * @throws IllegalArgumentException it the to periods do not overlap.\n+     */\n+    public ServiceDateInterval union(ServiceDateInterval other) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "270577cb83cdd613610572d7c3891e04f19cb603"}, "originalPosition": 81}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "882195c77a222161d5de84bd7ed58cc562f93159", "author": {"user": {"login": "t2gran", "name": "Thomas Gran"}}, "url": "https://github.com/opentripplanner/OpenTripPlanner/commit/882195c77a222161d5de84bd7ed58cc562f93159", "committedDate": "2020-01-15T13:33:59Z", "message": "Limit the transit service period(#2925) - code review:\n - Renamed `union` method to `intersection` and updated comments\n - Changed log level from warn to info in `OtpTransitServiceBuilder.limitServiceDays(..)`"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "146ab5c043b722069b47a7c99798424542609a30", "author": {"user": {"login": "t2gran", "name": "Thomas Gran"}}, "url": "https://github.com/opentripplanner/OpenTripPlanner/commit/146ab5c043b722069b47a7c99798424542609a30", "committedDate": "2020-01-17T15:32:56Z", "message": "Merge branch 'dev-2.x' into otp2_limit_transit_service_period"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ2NDczMTc1", "url": "https://github.com/opentripplanner/OpenTripPlanner/pull/2926#pullrequestreview-346473175", "createdAt": "2020-01-22T10:12:07Z", "commit": {"oid": "270577cb83cdd613610572d7c3891e04f19cb603"}, "state": "COMMENTED", "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yMlQxMDoxMjowOFrOFgWwUg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yMlQxMDo0MTowMFrOFgXoHw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTQ3MTU3MA==", "bodyText": "This method is modifying instances in place. It might be more consistent with our planned approach to immutability to copy any TripPattern that is changed by the filtering. Then again, we can also say that during building instances are mutable, in which case this could be fine.", "url": "https://github.com/opentripplanner/OpenTripPlanner/pull/2926#discussion_r369471570", "createdAt": "2020-01-22T10:12:08Z", "author": {"login": "abyrd"}, "path": "src/main/java/org/opentripplanner/model/TripPattern.java", "diffHunk": "@@ -294,6 +295,20 @@ public void add(FrequencyEntry freq) {\n         }\n     }\n \n+    /**\n+     * Remove all trips matching the given predicate.\n+     * @param removeTrip it the predicate returns true\n+     */\n+    public void removeTrips(Predicate<Trip> removeTrip) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "270577cb83cdd613610572d7c3891e04f19cb603"}, "originalPosition": 16}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTQ3MzUxOQ==", "bodyText": "This class seems like derived data, if the trips were filtered out early enough maybe they would never even be put into this map. We looked at where this TripStopTimes is used, and it seems to only be in org.opentripplanner.graph_builder.module.geometry.GeometryAndBlockProcessor#createGeometry, where it serves as an index for making trip geometries. The index could be constructed within the scope of that method, after trips have already been filtered, which would allow eliminating this filtering method.", "url": "https://github.com/opentripplanner/OpenTripPlanner/pull/2926#discussion_r369473519", "createdAt": "2020-01-22T10:16:03Z", "author": {"login": "abyrd"}, "path": "src/main/java/org/opentripplanner/model/TripStopTimes.java", "diffHunk": "@@ -50,14 +51,21 @@ public void put(Trip key, Collection<StopTime> list) {\n         map.put(key, sort(list));\n     }\n \n+    public void removeIf(Predicate<Trip> test) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "270577cb83cdd613610572d7c3891e04f19cb603"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTQ4MjU5MQ==", "bodyText": "Overall approach is good, another possibility that could work is just 20200113 for 2020-01-13. This is just easier to debug if we ever need to observe the code in operation.", "url": "https://github.com/opentripplanner/OpenTripPlanner/pull/2926#discussion_r369482591", "createdAt": "2020-01-22T10:34:06Z", "author": {"login": "abyrd"}, "path": "src/main/java/org/opentripplanner/model/calendar/ServiceDate.java", "diffHunk": "@@ -39,25 +39,46 @@\n     private final int day;\n \n     /**\n-     * Construct a new ServiceDate by specifying the numeric year, month, and day\n+     * A uniq increasing number for any valid day between 0000-01-01 and 9999-12-31.\n+     * Holes in the sequence is allowed to simplify the calculation.\n+     *\n+     * The value can safely be used for comparison, equals and hashCode.\n+     */\n+    private final int sequenceNumber;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "146ab5c043b722069b47a7c99798424542609a30"}, "originalPosition": 37}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTQ4NDY2Mw==", "bodyText": "It might even  be more readable to export the symbolic constants outside the class, instead of null. Either way is fine. It might be clearer for debugging and logging.", "url": "https://github.com/opentripplanner/OpenTripPlanner/pull/2926#discussion_r369484663", "createdAt": "2020-01-22T10:38:27Z", "author": {"login": "abyrd"}, "path": "src/main/java/org/opentripplanner/model/calendar/ServiceDateInterval.java", "diffHunk": "@@ -0,0 +1,116 @@\n+package org.opentripplanner.model.calendar;\n+\n+import java.util.Objects;\n+\n+\n+/**\n+ * Value object witch represent an service date interval from a starting date\n+ * until an end date. Both start and end is inclusive.\n+ *\n+ * The {@code start} must be equals or before the {@code end} to form a valid\n+ * period.\n+ *\n+ * {@code null} is used to represent an unbounded interval. One or both the of the {@code start} and\n+ * {@code end} can be {@code null} (unbounded).\n+ */\n+public final class ServiceDateInterval {\n+\n+    /**\n+     * The unbounded values will represent an unbounded value internally in this class.\n+     * They are converted to {@code null} when exported outside the class. This little\n+     * trick make internal logic a bit simpler, since there is no need for {@code null} checks.\n+     */\n+    private static final ServiceDate UNBOUNDED_START = new ServiceDate(0, 1, 1);\n+    private static final ServiceDate UNBOUNDED_END = new ServiceDate(9999, 12, 31);\n+    private static final ServiceDateInterval UNBOUNDED = new ServiceDateInterval(null, null);\n+\n+    private final ServiceDate start;\n+    private final ServiceDate end;\n+\n+\n+    public ServiceDateInterval(ServiceDate start, ServiceDate end) {\n+        this.start = start == null ? UNBOUNDED_START : start;\n+        this.end = end == null ? UNBOUNDED_END : end;\n+\n+        // Guarantee that the start is before or equal the end.\n+        if(this.end.isBefore(this.start)) {\n+            throw new IllegalArgumentException(\n+                    \"Invalid interval, the end \" + end + \" is before the start \" +  start\n+            );\n+        }\n+    }\n+\n+    /**\n+     * Return a interval with start or end unbounded ({@code null}).\n+     */\n+    public static ServiceDateInterval unbounded() {\n+        return UNBOUNDED;\n+    }\n+\n+    public boolean isUnbounded() {\n+        return start.equals(UNBOUNDED_START) && end.equals(UNBOUNDED_END);\n+    }\n+\n+    public ServiceDate getStart() {\n+        return start == UNBOUNDED_START ? null : start;\n+    }\n+\n+    public ServiceDate getEnd() {\n+        return end == UNBOUNDED_END ? null : end;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "146ab5c043b722069b47a7c99798424542609a30"}, "originalPosition": 59}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTQ4NTg1NQ==", "bodyText": "If these special values were defined in ServiceDate, and its toString knew about them, then ServiceDateInterval's toString could just recursively call ServiceDate's.", "url": "https://github.com/opentripplanner/OpenTripPlanner/pull/2926#discussion_r369485855", "createdAt": "2020-01-22T10:41:00Z", "author": {"login": "abyrd"}, "path": "src/main/java/org/opentripplanner/model/calendar/ServiceDateInterval.java", "diffHunk": "@@ -0,0 +1,116 @@\n+package org.opentripplanner.model.calendar;\n+\n+import java.util.Objects;\n+\n+\n+/**\n+ * Value object witch represent an service date interval from a starting date\n+ * until an end date. Both start and end is inclusive.\n+ *\n+ * The {@code start} must be equals or before the {@code end} to form a valid\n+ * period.\n+ *\n+ * {@code null} is used to represent an unbounded interval. One or both the of the {@code start} and\n+ * {@code end} can be {@code null} (unbounded).\n+ */\n+public final class ServiceDateInterval {\n+\n+    /**\n+     * The unbounded values will represent an unbounded value internally in this class.\n+     * They are converted to {@code null} when exported outside the class. This little\n+     * trick make internal logic a bit simpler, since there is no need for {@code null} checks.\n+     */\n+    private static final ServiceDate UNBOUNDED_START = new ServiceDate(0, 1, 1);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "146ab5c043b722069b47a7c99798424542609a30"}, "originalPosition": 23}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "747b4b63e8a3743280a6a1ba9126071c674f728b", "author": {"user": {"login": "t2gran", "name": "Thomas Gran"}}, "url": "https://github.com/opentripplanner/OpenTripPlanner/commit/747b4b63e8a3743280a6a1ba9126071c674f728b", "committedDate": "2020-01-22T16:50:07Z", "message": "Limit the transit service period(#2925) - code review:\n - Some JavaDoc updates.\n - ServiceDate set to sequenceNumber = yyyymmdd (as int) - used for comparison.\n - ServiceDate constants for upper and lover bound added, and used by the ServiceDateInterval.\n - ServiceDateInterval unbounded start/end represented with MIN and MAX, not null.\n - Add TODOs to GeometryAndBlockProcessor and NetexModule."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ3ODIyNTM0", "url": "https://github.com/opentripplanner/OpenTripPlanner/pull/2926#pullrequestreview-347822534", "createdAt": "2020-01-24T09:10:47Z", "commit": {"oid": "747b4b63e8a3743280a6a1ba9126071c674f728b"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2189, "cost": 1, "resetAt": "2021-11-01T15:33:45Z"}}}