{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDc1MjMyMzUy", "number": 3166, "title": "Re-implementation of SIRI support", "bodyText": "To be completed by pull request submitter:\n\n issue: Link to or create an issue that describes the relevant feature or bug. Add GitHub keywords to this PR's description (e.g., closes #45).\n roadmap: Check the roadmap for this feature or bug. If it is not already on the roadmap, PLC will discuss as part of the review process.\n tests: Have you added relevant test coverage? Are all the tests passing on the continuous integration service (Travis CI)?\n formatting: Have you followed the suggested code style?\n documentation: If you are adding a new configuration option, have you added an explanation to the configuration documentation tables and sections?\n changelog: add a bullet point to the changelog file with description and link to the linked issue\n\nTo be completed by @opentripplanner/plc:\n\n reviews and approvals by 2 members, ideally from different organizations\n after merging: update the relevant card on the roadmap", "createdAt": "2020-08-28T07:18:50Z", "url": "https://github.com/opentripplanner/OpenTripPlanner/pull/3166", "merged": true, "mergeCommit": {"oid": "81d657fff46a5d9ab212d04e0a60814a26ba168e"}, "closed": true, "closedAt": "2020-09-30T09:37:13Z", "author": {"login": "lassetyr"}, "timelineItems": {"totalCount": 26, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABc8f_8FAH2gAyNDc1MjMyMzUyOjVmZTE4ZGVjMTVjZjZlNTE0NGJmZDhkMmNkODAwOGE3M2JlZTU5MDk=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdN5fF4AFqTQ5OTI1MzI0Mw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "5fe18dec15cf6e5144bfd8d2cd8008a73bee5909", "author": {"user": {"login": "lassetyr", "name": null}}, "url": "https://github.com/opentripplanner/OpenTripPlanner/commit/5fe18dec15cf6e5144bfd8d2cd8008a73bee5909", "committedDate": "2020-08-07T08:18:26Z", "message": "Initial commit of SIRI-reimplementation from OTP1"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "61802f4468da112388c9c31121ce5e52d58cf063", "author": {"user": {"login": "lassetyr", "name": null}}, "url": "https://github.com/opentripplanner/OpenTripPlanner/commit/61802f4468da112388c9c31121ce5e52d58cf063", "committedDate": "2020-08-10T12:44:55Z", "message": "Merge branch 'kyyticom-remove-alert-patcher' into siri-realtime"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5b64fb0079a3cbaa6a340112a8fbdb0afd8d9a86", "author": {"user": {"login": "lassetyr", "name": null}}, "url": "https://github.com/opentripplanner/OpenTripPlanner/commit/5b64fb0079a3cbaa6a340112a8fbdb0afd8d9a86", "committedDate": "2020-08-11T06:53:51Z", "message": "Updating SIRI-implementation to changes from PR #3134"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "49880da748519e1e260413636efa6fe77c20d1ba", "author": {"user": {"login": "lassetyr", "name": null}}, "url": "https://github.com/opentripplanner/OpenTripPlanner/commit/49880da748519e1e260413636efa6fe77c20d1ba", "committedDate": "2020-08-11T11:04:37Z", "message": "Avoiding NPE when setting id on alert"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d87862c309aa01e515406a6597c2cc0bd1a7c263", "author": {"user": {"login": "lassetyr", "name": null}}, "url": "https://github.com/opentripplanner/OpenTripPlanner/commit/d87862c309aa01e515406a6597c2cc0bd1a7c263", "committedDate": "2020-08-27T10:32:53Z", "message": "Merge branch 'dev-2.x' into siri-realtime"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2c40ff2f0505bb0d6c7ebe49397123fd335fe787", "author": {"user": {"login": "lassetyr", "name": null}}, "url": "https://github.com/opentripplanner/OpenTripPlanner/commit/2c40ff2f0505bb0d6c7ebe49397123fd335fe787", "committedDate": "2020-08-27T14:05:40Z", "message": "Returning decoded id as SituationNumber"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ab89d17d5a1626a02986591efc97c43bae82cc24", "author": {"user": {"login": "lassetyr", "name": null}}, "url": "https://github.com/opentripplanner/OpenTripPlanner/commit/ab89d17d5a1626a02986591efc97c43bae82cc24", "committedDate": "2020-08-27T14:06:37Z", "message": "Added GraphQL-field for severity"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "363e782ddde17fb6aef87e6f9bea56aa5ae64e52", "author": {"user": {"login": "lassetyr", "name": null}}, "url": "https://github.com/opentripplanner/OpenTripPlanner/commit/363e782ddde17fb6aef87e6f9bea56aa5ae64e52", "committedDate": "2020-08-27T14:07:37Z", "message": "Also checking for sibling-matches when applying TransitAlerts to Leg"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "af2f6dbce50f6d74369692095008d63c40d145db", "author": {"user": {"login": "lassetyr", "name": null}}, "url": "https://github.com/opentripplanner/OpenTripPlanner/commit/af2f6dbce50f6d74369692095008d63c40d145db", "committedDate": "2020-08-27T14:09:24Z", "message": "Handling SIRI ET-updates with only RecordedCalls"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "98ae088441b9ff37eea34c67d5417be2d11833c4", "author": {"user": {"login": "lassetyr", "name": null}}, "url": "https://github.com/opentripplanner/OpenTripPlanner/commit/98ae088441b9ff37eea34c67d5417be2d11833c4", "committedDate": "2020-08-27T14:27:12Z", "message": "Added simple retry-functionality for when the SIRI-request times out."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ff6c346b67aec964dee5f2c6e3eac20e11e49ef0", "author": {"user": {"login": "lassetyr", "name": null}}, "url": "https://github.com/opentripplanner/OpenTripPlanner/commit/ff6c346b67aec964dee5f2c6e3eac20e11e49ef0", "committedDate": "2020-09-04T08:18:45Z", "message": "Merge branch 'dev-2.x' into siri-realtime"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9c24322f269177b9cdf4f381fbc8a2b36d462d13", "author": {"user": {"login": "lassetyr", "name": null}}, "url": "https://github.com/opentripplanner/OpenTripPlanner/commit/9c24322f269177b9cdf4f381fbc8a2b36d462d13", "committedDate": "2020-09-09T13:37:26Z", "message": "Updating siri-protobuf-mapper to public version"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1853a44ae4cac535aad915f92e24aff2912056b3", "author": {"user": {"login": "lassetyr", "name": null}}, "url": "https://github.com/opentripplanner/OpenTripPlanner/commit/1853a44ae4cac535aad915f92e24aff2912056b3", "committedDate": "2020-09-09T14:52:06Z", "message": "Merge branch 'dev-2.x' into siri-realtime"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "abe0d21c32aca02da5acae76ea4595cdfc3895ae", "author": {"user": {"login": "t2gran", "name": "Thomas Gran"}}, "url": "https://github.com/opentripplanner/OpenTripPlanner/commit/abe0d21c32aca02da5acae76ea4595cdfc3895ae", "committedDate": "2020-09-14T10:48:39Z", "message": "Merge branch 'dev-2.x' into siri-realtime"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "67617ca5b74d85bb0ec489e33dc704e1188e4d3a", "author": {"user": {"login": "t2gran", "name": "Thomas Gran"}}, "url": "https://github.com/opentripplanner/OpenTripPlanner/commit/67617ca5b74d85bb0ec489e33dc704e1188e4d3a", "committedDate": "2020-09-14T14:06:52Z", "message": "Clean code\n  - Avoid adding new methods just because there is one extra argument.\n  - Remove unused code.\n  - Make a few things final.\n  - catch typed exceptions(IOException|JAXBException|XMLStreamException) not just the generic Exception - avoid entering a infinite loop on NPE.\n  - Remove obsolete null checks.\n  - Remove empty JavaDoc tags."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDg3NTAyMDIy", "url": "https://github.com/opentripplanner/OpenTripPlanner/pull/3166#pullrequestreview-487502022", "createdAt": "2020-09-14T07:52:08Z", "commit": {"oid": "1853a44ae4cac535aad915f92e24aff2912056b3"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 13, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNFQwNzo1MjowOFrOHRH8Lg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNFQxMzoyMTozNlrOHRTeXg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzcxNzkzNA==", "bodyText": "Remove this - The licence for the code is maintained in one place, and unless this code have a different licence it should not include anything about the licence at all. If the code is coped from some other project with a different licence then that licence needs to be added to the documentation and referenced from here.", "url": "https://github.com/opentripplanner/OpenTripPlanner/pull/3166#discussion_r487717934", "createdAt": "2020-09-14T07:52:08Z", "author": {"login": "t2gran"}, "path": "src/ext/java/org/opentripplanner/ext/siri/updater/SiriEstimatedTimetableGooglePubsubUpdater.java", "diffHunk": "@@ -0,0 +1,385 @@\n+/* This program is free software: you can redistribute it and/or\n+ modify it under the terms of the GNU Lesser General Public License\n+ as published by the Free Software Foundation, either version 3 of\n+ the License, or (at your option) any later version.\n+\n+ This program is distributed in the hope that it will be useful,\n+ but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+ GNU General Public License for more details.\n+\n+ You should have received a copy of the GNU General Public License\n+ along with this program.  If not, see <http://www.gnu.org/licenses/>. */", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1853a44ae4cac535aad915f92e24aff2912056b3"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzcyMDQwNg==", "bodyText": "Empty annotations can just be removed.", "url": "https://github.com/opentripplanner/OpenTripPlanner/pull/3166#discussion_r487720406", "createdAt": "2020-09-14T07:56:26Z", "author": {"login": "t2gran"}, "path": "src/main/java/org/opentripplanner/routing/StopTimesHelper.java", "diffHunk": "@@ -34,6 +34,8 @@\n    * @param timeRange Searches forward for timeRange seconds from startTime\n    * @param numberOfDepartures Number of departures to fetch per pattern\n    * @param omitNonPickups If true, do not include vehicles that will not pick up passengers.\n+   * @param includeCancelledTrips If true, cancelled trips will also be included in result\n+   * @return", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1853a44ae4cac535aad915f92e24aff2912056b3"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzcyMjY2Ng==", "bodyText": "Add as JavaDoc", "url": "https://github.com/opentripplanner/OpenTripPlanner/pull/3166#discussion_r487722666", "createdAt": "2020-09-14T08:00:24Z", "author": {"login": "t2gran"}, "path": "src/main/java/org/opentripplanner/model/TripPattern.java", "diffHunk": "@@ -639,4 +640,29 @@ public String getFeedId() {\n     private static Coordinate coordinate(Stop s) {\n         return new Coordinate(s.getLon(), s.getLat());\n     }\n+\n+    // Need an equals() since \"Trips in a pattern are no longer necessarily running on the same service ID.\"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1853a44ae4cac535aad915f92e24aff2912056b3"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Nzc0NzYwMQ==", "bodyText": "Use the /intellij-code-style.xml to format the code.", "url": "https://github.com/opentripplanner/OpenTripPlanner/pull/3166#discussion_r487747601", "createdAt": "2020-09-14T08:43:10Z", "author": {"login": "t2gran"}, "path": "src/ext-test/java/org/opentripplanner/ext/siri/SiriAlertsUpdateHandlerTest.java", "diffHunk": "@@ -0,0 +1,933 @@\n+package org.opentripplanner.ext.siri;\n+\n+import org.junit.Test;\n+import org.opentripplanner.GtfsTest;\n+import org.opentripplanner.model.FeedScopedId;\n+import org.opentripplanner.routing.RoutingService;\n+import org.opentripplanner.routing.alertpatch.AlertUrl;\n+import org.opentripplanner.routing.alertpatch.EntitySelector;\n+import org.opentripplanner.routing.alertpatch.StopCondition;\n+import org.opentripplanner.routing.alertpatch.TransitAlert;\n+import org.opentripplanner.routing.impl.TransitAlertServiceImpl;\n+import org.opentripplanner.updater.GraphUpdaterManager;\n+import uk.org.ifopt.siri20.StopPlaceRef;\n+import uk.org.siri.siri20.AffectedLineStructure;\n+import uk.org.siri.siri20.AffectedRouteStructure;\n+import uk.org.siri.siri20.AffectedStopPlaceStructure;\n+import uk.org.siri.siri20.AffectedStopPointStructure;\n+import uk.org.siri.siri20.AffectedVehicleJourneyStructure;\n+import uk.org.siri.siri20.AffectsScopeStructure;\n+import uk.org.siri.siri20.DataFrameRefStructure;\n+import uk.org.siri.siri20.DefaultedTextStructure;\n+import uk.org.siri.siri20.FramedVehicleJourneyRefStructure;\n+import uk.org.siri.siri20.HalfOpenTimestampOutputRangeStructure;\n+import uk.org.siri.siri20.InfoLinkStructure;\n+import uk.org.siri.siri20.LineRef;\n+import uk.org.siri.siri20.PtSituationElement;\n+import uk.org.siri.siri20.RoutePointTypeEnumeration;\n+import uk.org.siri.siri20.ServiceDelivery;\n+import uk.org.siri.siri20.SeverityEnumeration;\n+import uk.org.siri.siri20.SituationExchangeDeliveryStructure;\n+import uk.org.siri.siri20.SituationNumber;\n+import uk.org.siri.siri20.StopPointRef;\n+import uk.org.siri.siri20.VehicleJourneyRef;\n+import uk.org.siri.siri20.WorkflowStatusEnumeration;\n+\n+import java.math.BigInteger;\n+import java.time.ZonedDateTime;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.List;\n+\n+public class SiriAlertsUpdateHandlerTest  extends GtfsTest {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1853a44ae4cac535aad915f92e24aff2912056b3"}, "originalPosition": 42}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Nzc4NDA5Nw==", "bodyText": "FYI\nThese methods made me ask: Should these be pushed into the TransitAlert class? Is there other places in the code that perform the same logic? Then I investigated a little and it seems that this is over-engineered. The list of TransitAlert.entities is always filtered down to a specific type - So maybe just keeping a set of Selectors for each type is sufficient. The selectors do not select anything - they are just a placeholder witch reference a type(inderect) and one or two ids. It toke me a while before I got that. Or am I missing something?\nI do not expect this to be fixed as part of the PR, but I it would be good to clean it up at some point.", "url": "https://github.com/opentripplanner/OpenTripPlanner/pull/3166#discussion_r487784097", "createdAt": "2020-09-14T09:43:46Z", "author": {"login": "t2gran"}, "path": "src/ext-test/java/org/opentripplanner/ext/siri/SiriAlertsUpdateHandlerTest.java", "diffHunk": "@@ -0,0 +1,933 @@\n+package org.opentripplanner.ext.siri;\n+\n+import org.junit.Test;\n+import org.opentripplanner.GtfsTest;\n+import org.opentripplanner.model.FeedScopedId;\n+import org.opentripplanner.routing.RoutingService;\n+import org.opentripplanner.routing.alertpatch.AlertUrl;\n+import org.opentripplanner.routing.alertpatch.EntitySelector;\n+import org.opentripplanner.routing.alertpatch.StopCondition;\n+import org.opentripplanner.routing.alertpatch.TransitAlert;\n+import org.opentripplanner.routing.impl.TransitAlertServiceImpl;\n+import org.opentripplanner.updater.GraphUpdaterManager;\n+import uk.org.ifopt.siri20.StopPlaceRef;\n+import uk.org.siri.siri20.AffectedLineStructure;\n+import uk.org.siri.siri20.AffectedRouteStructure;\n+import uk.org.siri.siri20.AffectedStopPlaceStructure;\n+import uk.org.siri.siri20.AffectedStopPointStructure;\n+import uk.org.siri.siri20.AffectedVehicleJourneyStructure;\n+import uk.org.siri.siri20.AffectsScopeStructure;\n+import uk.org.siri.siri20.DataFrameRefStructure;\n+import uk.org.siri.siri20.DefaultedTextStructure;\n+import uk.org.siri.siri20.FramedVehicleJourneyRefStructure;\n+import uk.org.siri.siri20.HalfOpenTimestampOutputRangeStructure;\n+import uk.org.siri.siri20.InfoLinkStructure;\n+import uk.org.siri.siri20.LineRef;\n+import uk.org.siri.siri20.PtSituationElement;\n+import uk.org.siri.siri20.RoutePointTypeEnumeration;\n+import uk.org.siri.siri20.ServiceDelivery;\n+import uk.org.siri.siri20.SeverityEnumeration;\n+import uk.org.siri.siri20.SituationExchangeDeliveryStructure;\n+import uk.org.siri.siri20.SituationNumber;\n+import uk.org.siri.siri20.StopPointRef;\n+import uk.org.siri.siri20.VehicleJourneyRef;\n+import uk.org.siri.siri20.WorkflowStatusEnumeration;\n+\n+import java.math.BigInteger;\n+import java.time.ZonedDateTime;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.List;\n+\n+public class SiriAlertsUpdateHandlerTest  extends GtfsTest {\n+\n+    SiriAlertsUpdateHandler alertsUpdateHandler;\n+\n+    TransitAlertServiceImpl transitAlertService;\n+\n+    RoutingService routingService;\n+    private String feedId = \"FEED\";\n+\n+    public void init() {\n+            if (routingService == null) {\n+                routingService = new RoutingService(graph);\n+                graph.updaterManager = new GraphUpdaterManager(graph);\n+\n+            } else {\n+                transitAlertService.getAllAlerts().clear();\n+            }\n+            if (alertsUpdateHandler == null) {\n+                alertsUpdateHandler = new SiriAlertsUpdateHandler(feedId);\n+\n+                transitAlertService = new TransitAlertServiceImpl(graph);\n+                alertsUpdateHandler.setTransitAlertService(transitAlertService);\n+\n+                alertsUpdateHandler.setSiriFuzzyTripMatcher(new SiriFuzzyTripMatcher(routingService));\n+            }\n+        }\n+\n+        @Test\n+        public void testSiriSxUpdateForStop() {\n+            init();\n+            assertTrue(transitAlertService.getAllAlerts().isEmpty());\n+\n+            final String situationNumber = \"TST:SituationNumber:1234\";\n+            final FeedScopedId stopId = new FeedScopedId(feedId, \"stop0\");\n+            List<RoutePointTypeEnumeration> stopConditions = Arrays.asList(RoutePointTypeEnumeration.DESTINATION, RoutePointTypeEnumeration.NOT_STOPPING, RoutePointTypeEnumeration.REQUEST_STOP, RoutePointTypeEnumeration.EXCEPTIONAL_STOP, RoutePointTypeEnumeration.START_POINT);\n+\n+            PtSituationElement ptSituation = createPtSituationElement(\n+                    situationNumber,\n+                    ZonedDateTime.parse(\"2014-01-01T00:00:00+01:00\"),\n+                    ZonedDateTime.parse(\"2014-01-01T23:59:59+01:00\"),\n+                    createAffectsStop(stopConditions, stopId.getId()));\n+\n+            long priorityValue = 3;\n+            ptSituation.setPriority(BigInteger.valueOf(priorityValue));\n+\n+            InfoLinkStructure infoLink = new InfoLinkStructure();\n+            final String infoLinkUri = \"http://www.test.com\";\n+            final String infoLinkLabel = \"testlabel\";\n+\n+            infoLink.setUri(infoLinkUri);\n+            infoLink.getLabels().add(createDefaultedTextStructure(infoLinkLabel));\n+\n+            ptSituation.setInfoLinks(new PtSituationElement.InfoLinks());\n+            ptSituation.getInfoLinks().getInfoLinks().add(infoLink);\n+\n+            final String reportType = \"incident\";\n+            ptSituation.setReportType(reportType);\n+\n+            final SeverityEnumeration severity = SeverityEnumeration.SEVERE;\n+            ptSituation.setSeverity(SeverityEnumeration.SEVERE);\n+\n+            final ServiceDelivery serviceDelivery = createServiceDelivery(ptSituation);\n+            alertsUpdateHandler.update(serviceDelivery);\n+\n+            assertFalse(transitAlertService.getAllAlerts().isEmpty());\n+\n+            final Collection<TransitAlert> stopPatches = transitAlertService.getStopAlerts(stopId);\n+\n+            assertNotNull(stopPatches);\n+            assertEquals(1, stopPatches.size());\n+            final TransitAlert transitAlert = stopPatches.iterator().next();\n+\n+            assertFalse(containsTripEntity(transitAlert));\n+            assertEquals(situationNumber, transitAlert.getId());\n+            assertEquals(reportType, transitAlert.alertType);\n+            assertEquals(severity.value(), transitAlert.severity);\n+            assertEquals(priorityValue, transitAlert.priority);\n+\n+            assertTrue(matchesEntity(transitAlert, stopId));\n+\n+            assertTrue(transitAlert.getStopConditions().contains(StopCondition.DESTINATION));\n+            assertTrue(transitAlert.getStopConditions().contains(StopCondition.NOT_STOPPING));\n+            assertTrue(transitAlert.getStopConditions().contains(StopCondition.REQUEST_STOP));\n+\n+            assertNotNull(transitAlert.getAlertUrlList());\n+            assertFalse(transitAlert.getAlertUrlList().isEmpty());\n+\n+            final List<AlertUrl> alertUrlList = transitAlert.getAlertUrlList();\n+            AlertUrl alertUrl = alertUrlList.get(0);\n+            assertEquals(infoLinkUri, alertUrl.uri);\n+            assertEquals(infoLinkLabel, alertUrl.label);\n+\n+        }\n+\n+    private boolean containsStopEntity(TransitAlert transitAlert) {\n+        for (EntitySelector entity : transitAlert.getEntities()) {\n+            if (entity instanceof EntitySelector.Stop) {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    private boolean containsTripEntity(TransitAlert transitAlert) {\n+        for (EntitySelector entity : transitAlert.getEntities()) {\n+            if (entity instanceof EntitySelector.Trip) {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    private boolean containsRouteEntity(TransitAlert transitAlert) {\n+        for (EntitySelector entity : transitAlert.getEntities()) {\n+            if (entity instanceof EntitySelector.Route) {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    private boolean containsStopAndRouteEntity(TransitAlert transitAlert) {\n+        for (EntitySelector entity : transitAlert.getEntities()) {\n+            if (entity instanceof EntitySelector.StopAndRoute) {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1853a44ae4cac535aad915f92e24aff2912056b3"}, "originalPosition": 170}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzgzMDk4NA==", "bodyText": "Below on line 364:\n\nif (!effectiveValiditySetExplicitly) {\n\nthe if is never entered. The only way the effectiveValiditySetExplicitly can be true is that there is no tipIds added above. Clean up this - I am not sure if it is a mistake or just dead code.", "url": "https://github.com/opentripplanner/OpenTripPlanner/pull/3166#discussion_r487830984", "createdAt": "2020-09-14T11:08:54Z", "author": {"login": "t2gran"}, "path": "src/ext/java/org/opentripplanner/ext/siri/SiriAlertsUpdateHandler.java", "diffHunk": "@@ -335,13 +343,20 @@ private TransitAlert handleAlert(PtSituationElement situation) {\n                                 effectiveValiditySetExplicitly = true;\n \n                             } else {\n-                                // TODO - SIRI: Support submode when fuzzy-searching for trips\n-                                tripIds = siriFuzzyTripMatcher.getTripIdForTripShortNameServiceDateAndMode(vehicleJourneyRef.getValue(),\n-                                        serviceDate, TraverseMode.RAIL/*, TransmodelTransportSubmode.RAIL_REPLACEMENT_BUS*/);\n \n-                                // ServiceJourneyId does NOT match - calculate validity based on originAimedDepartureTime\n-                                effectiveStartDate = serviceDate.getAsDate();\n-                                effectiveEndDate = serviceDate.next().getAsDate();\n+//                                Commented out for now\n+//\n+//                                // TODO - SIRI: Support submode when fuzzy-searching for trips\n+//                                tripIds = siriFuzzyTripMatcher.getTripIdForTripShortNameServiceDateAndMode(vehicleJourneyRef.getValue(),\n+//                                        serviceDate, TraverseMode.RAIL/*, TransmodelTransportSubmode.RAIL_REPLACEMENT_BUS*/);\n+//\n+//                                // ServiceJourneyId does NOT match - calculate validity based on originAimedDepartureTime\n+//                                effectiveStartDate = serviceDate.getAsDate();\n+//                                effectiveEndDate = serviceDate.next().getAsDate();\n+\n+                                effectiveStartDate = null;\n+                                effectiveEndDate = null;\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "abe0d21c32aca02da5acae76ea4595cdfc3895ae"}, "originalPosition": 207}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzgzNTc0Nw==", "bodyText": "Below on line 227:\nif (tripPattern != null &&\n                        (tripPattern.getMode().equals(TraverseMode.RAIL) /*||\t                        (tripPattern.getMode().equals(TraverseMode.RAIL)\n\nthe tripPattern.getMode() return type is TransitMode, not TraverseMode so the if branch is never entered.", "url": "https://github.com/opentripplanner/OpenTripPlanner/pull/3166#discussion_r487835747", "createdAt": "2020-09-14T11:18:30Z", "author": {"login": "t2gran"}, "path": "src/ext/java/org/opentripplanner/ext/siri/SiriFuzzyTripMatcher.java", "diffHunk": "@@ -129,12 +131,27 @@ private String resolveDatedVehicleJourneyRef(EstimatedVehicleJourney journey) {\n             }\n         }\n         if (trips == null || trips.isEmpty()) {\n-            List<EstimatedCall> estimatedCalls = journey.getEstimatedCalls().getEstimatedCalls();\n-            EstimatedCall lastStop = estimatedCalls.get(estimatedCalls.size() - 1);\n \n-            String lastStopPoint = lastStop.getStopPointRef().getValue();\n+            String lastStopPoint = null;\n+            ZonedDateTime arrivalTime = null;\n \n-            ZonedDateTime arrivalTime = lastStop.getAimedArrivalTime() != null ? lastStop.getAimedArrivalTime() : lastStop.getAimedDepartureTime();\n+            if (journey.getEstimatedCalls() != null && journey.getEstimatedCalls().getEstimatedCalls() != null\n+                    && !journey.getEstimatedCalls().getEstimatedCalls().isEmpty()) { // Pick last stop from EstimatedCalls\n+                List<EstimatedCall> estimatedCalls = journey.getEstimatedCalls().getEstimatedCalls();\n+                EstimatedCall lastStop = estimatedCalls.get(estimatedCalls.size() - 1);\n+\n+                lastStopPoint = lastStop.getStopPointRef().getValue();\n+                arrivalTime = lastStop.getAimedArrivalTime() != null ? lastStop.getAimedArrivalTime() : lastStop.getAimedDepartureTime();\n+\n+            } else if (journey.getRecordedCalls() != null && journey.getRecordedCalls().getRecordedCalls() != null\n+                    && !journey.getRecordedCalls().getRecordedCalls().isEmpty()) { // No EstimatedCalls exist - pick last RecordedCall\n+\n+                List<RecordedCall> recordedCalls = journey.getRecordedCalls().getRecordedCalls();\n+                final RecordedCall lastStop = recordedCalls.get(recordedCalls.size() - 1);\n+\n+                lastStopPoint = lastStop.getStopPointRef().getValue();\n+                arrivalTime = lastStop.getAimedArrivalTime() != null ? lastStop.getAimedArrivalTime() : lastStop.getAimedDepartureTime();\n+            }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "abe0d21c32aca02da5acae76ea4595cdfc3895ae"}, "originalPosition": 43}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Nzg0NDk5MA==", "bodyText": "Call to 'Thread.sleep()' in a loop, probably busy-waiting.", "url": "https://github.com/opentripplanner/OpenTripPlanner/pull/3166#discussion_r487844990", "createdAt": "2020-09-14T11:37:13Z", "author": {"login": "t2gran"}, "path": "src/ext/java/org/opentripplanner/ext/siri/updater/SiriEstimatedTimetableGooglePubsubUpdater.java", "diffHunk": "@@ -0,0 +1,385 @@\n+/* This program is free software: you can redistribute it and/or\n+ modify it under the terms of the GNU Lesser General Public License\n+ as published by the Free Software Foundation, either version 3 of\n+ the License, or (at your option) any later version.\n+\n+ This program is distributed in the hope that it will be useful,\n+ but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+ GNU General Public License for more details.\n+\n+ You should have received a copy of the GNU General Public License\n+ along with this program.  If not, see <http://www.gnu.org/licenses/>. */\n+\n+package org.opentripplanner.ext.siri.updater;\n+\n+import com.google.cloud.pubsub.v1.AckReplyConsumer;\n+import com.google.cloud.pubsub.v1.MessageReceiver;\n+import com.google.cloud.pubsub.v1.Subscriber;\n+import com.google.cloud.pubsub.v1.SubscriptionAdminClient;\n+import com.google.protobuf.ByteString;\n+import com.google.protobuf.Duration;\n+import com.google.protobuf.InvalidProtocolBufferException;\n+import com.google.pubsub.v1.ExpirationPolicy;\n+import com.google.pubsub.v1.ProjectSubscriptionName;\n+import com.google.pubsub.v1.ProjectTopicName;\n+import com.google.pubsub.v1.PubsubMessage;\n+import com.google.pubsub.v1.PushConfig;\n+import com.google.pubsub.v1.Subscription;\n+import org.apache.commons.io.FileUtils;\n+import org.apache.commons.lang3.time.DurationFormatUtils;\n+import org.entur.protobuf.mapper.SiriMapper;\n+import org.opentripplanner.ext.siri.SiriTimetableSnapshotSource;\n+import org.opentripplanner.routing.graph.Graph;\n+import org.opentripplanner.updater.GraphUpdater;\n+import org.opentripplanner.updater.GraphUpdaterManager;\n+import org.opentripplanner.util.HttpUtils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import uk.org.siri.siri20.EstimatedTimetableDeliveryStructure;\n+import uk.org.siri.siri20.Siri;\n+import uk.org.siri.www.siri.SiriType;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.net.URI;\n+import java.time.ZonedDateTime;\n+import java.util.List;\n+import java.util.UUID;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+/**\n+ * This class starts a Google PubSub subscription\n+ *\n+ * NOTE:\n+ *   - Path to Google credentials (.json-file) MUST exist in environment-variable \"GOOGLE_APPLICATION_CREDENTIALS\"\n+ *     as described here: https://cloud.google.com/docs/authentication/getting-started\n+ *   - ServiceAccount need access to create subscription (\"editor\")\n+ *\n+ *\n+ *\n+ * Startup-flow:\n+ *   1. Create subscription to topic. Subscription will receive all updates after creation.\n+ *   2. Fetch current data to initialize state.\n+ *   3. Flag updater as initialized\n+ *   3. Start receiving updates from Pubsub-subscription\n+ *\n+ *\n+ * <pre>\n+ *   \"type\": \"google-pubsub-siri-et-updater\",\n+ *   \"projectName\":\"project-1234\",                                                      // Google Cloud project name\n+ *   \"topicName\": \"protobuf.estimated_timetables\",                                      // Google Cloud Pubsub topic\n+ *   \"dataInitializationUrl\": \"http://server/realtime/protobuf/et\"  // Optional URL used to initialize OTP with all existing data\n+ * </pre>\n+ *\n+ */\n+public class SiriEstimatedTimetableGooglePubsubUpdater implements GraphUpdater {\n+\n+    private static final int DEFAULT_RECONNECT_PERIOD_SEC = 5; // Five seconds\n+\n+    private static Logger LOG = LoggerFactory.getLogger(SiriEstimatedTimetableGooglePubsubUpdater.class);\n+\n+    /**\n+     * Parent update manager. Is used to execute graph writer runnables.\n+     */\n+    private GraphUpdaterManager updaterManager;\n+\n+    private SiriTimetableSnapshotSource snapshotSource;\n+\n+    /**\n+     * The URL used to fetch all initial updates\n+     */\n+    private URI dataInitializationUrl;\n+\n+    /**\n+     * The ID for the static feed to which these TripUpdates are applied\n+     */\n+    private String feedId;\n+\n+    /**\n+     * The number of seconds to wait before reconnecting after a failed connection.\n+     */\n+    private int reconnectPeriodSec;\n+\n+    private SubscriptionAdminClient subscriptionAdminClient;\n+    private ProjectSubscriptionName subscriptionName;\n+    private ProjectTopicName topic;\n+    private PushConfig pushConfig;\n+\n+    private static transient final AtomicLong messageCounter = new AtomicLong(0);\n+    private static transient final AtomicLong updateCounter = new AtomicLong(0);\n+    private static transient final AtomicLong sizeCounter = new AtomicLong(0);\n+    private transient long startTime;\n+    private boolean primed;\n+\n+\n+    public SiriEstimatedTimetableGooglePubsubUpdater(Parameters config) {\n+\n+        try {\n+            configure(config);\n+\n+            if (System.getenv(\"GOOGLE_APPLICATION_CREDENTIALS\") != null &&\n+                    !System.getenv(\"GOOGLE_APPLICATION_CREDENTIALS\").isEmpty()) {\n+\n+                /*\n+                  Google libraries expects path to credentials json-file is stored in environment variable \"GOOGLE_APPLICATION_CREDENTIALS\"\n+                  Ref.: https://cloud.google.com/docs/authentication/getting-started\n+                 */\n+\n+                subscriptionAdminClient = SubscriptionAdminClient.create();\n+\n+                addShutdownHook();\n+\n+            } else {\n+                throw new RuntimeException(\"Google Pubsub updater is configured, but environment variable 'GOOGLE_APPLICATION_CREDENTIALS' is not defined. \" +\n+                        \"See https://cloud.google.com/docs/authentication/getting-started\");\n+            }\n+        } catch (IOException e) {\n+            e.printStackTrace();\n+        }\n+    }\n+\n+    private void addShutdownHook() {\n+        // TODO: This should probably be on a higher level?\n+        try {\n+            Runtime.getRuntime().addShutdownHook(new Thread(this::teardown));\n+            LOG.info(\"Shutdown-hook to clean up Google Pubsub subscription has been added.\");\n+        } catch (IllegalStateException e) {\n+            // Handling cornercase when instance is being shut down before it has been initialized\n+            LOG.info(\"Instance is already shutting down - cleaning up immediately.\", e);\n+            teardown();\n+        }\n+    }\n+\n+    @Override\n+    public void setGraphUpdaterManager(GraphUpdaterManager updaterManager) {\n+        this.updaterManager = updaterManager;\n+    }\n+\n+    @Override\n+    public void setup(Graph graph) throws Exception {\n+        // TODO OTP2 - This is thread safe, but only because updater setup methods are called sequentially.\n+        //           - Ideally we should inject the snapshotSource on this class.\n+        snapshotSource = graph.getOrSetupTimetableSnapshotProvider(SiriTimetableSnapshotSource::new);\n+    }\n+\n+    private void configure(Parameters config) {\n+\n+        /*\n+           URL that responds to HTTP GET which returns all initial data in protobuf-format.\n+           Will be called once to initialize realtime-data. All updates will be received from Google Cloud Pubsub\n+          */\n+        dataInitializationUrl = URI.create(config.getDataInitializationUrl());\n+\n+        feedId = config.getFeedId();\n+        reconnectPeriodSec = config.getReconnectPeriodSec();\n+\n+        // set subscriber\n+        String subscriptionId = System.getenv(\"HOSTNAME\");\n+        if (subscriptionId == null || subscriptionId.isEmpty()) {\n+            subscriptionId = \"otp-\"+UUID.randomUUID().toString();\n+        }\n+\n+        String projectName = config.getProjectName();\n+\n+        String topicName = config.getTopicName();\n+\n+        subscriptionName = ProjectSubscriptionName.of(\n+                projectName, subscriptionId);\n+        topic = ProjectTopicName.of(projectName, topicName);\n+\n+        pushConfig = PushConfig.getDefaultInstance();\n+\n+    }\n+\n+    @Override\n+    public void run() throws IOException {\n+\n+        if (subscriptionAdminClient == null) {\n+            throw new RuntimeException(\"Unable to initialize Google Pubsub-updater: System.getenv('GOOGLE_APPLICATION_CREDENTIALS') = \" + System.getenv(\"GOOGLE_APPLICATION_CREDENTIALS\"));\n+        }\n+\n+        LOG.info(\"Creating subscription {}\", subscriptionName);\n+\n+        Subscription subscription = subscriptionAdminClient.createSubscription(Subscription.newBuilder()\n+                .setTopic(topic.toString())\n+                .setName(subscriptionName.toString())\n+                .setPushConfig(pushConfig)\n+                .setMessageRetentionDuration(\n+                        // How long will an unprocessed message be kept - minimum 10 minutes\n+                        Duration.newBuilder().setSeconds(600).build()\n+                )\n+                .setExpirationPolicy(ExpirationPolicy.newBuilder()\n+                        // How long will the subscription exist when no longer in use - minimum 1 day\n+                        .setTtl(Duration.newBuilder().setSeconds(86400).build()).build()\n+                )\n+                .build());\n+\n+        LOG.info(\"Created subscription {}\", subscriptionName);\n+\n+        startTime = now();\n+\n+        final EstimatedTimetableMessageReceiver receiver = new EstimatedTimetableMessageReceiver();\n+\n+        int sleepPeriod = 1000;\n+        int attemptCounter = 1;\n+        while (!isPrimed()) {  // Retrying until data is initialized successfully\n+            try {\n+                initializeData(dataInitializationUrl, receiver);\n+\n+            } catch (Exception e) {\n+\n+                sleepPeriod = sleepPeriod * 2;\n+\n+                LOG.warn(\"Caught Exception while initializing data, will retry after {} ms - attempt number {}. ({})\", sleepPeriod, attemptCounter++, e.toString());\n+\n+                try {\n+                    Thread.sleep(sleepPeriod);\n+                } catch (InterruptedException interruptedException) {\n+                    //Ignore\n+                }\n+            }\n+        }\n+\n+        Subscriber subscriber = null;\n+        while (true) {\n+            try {\n+                subscriber = Subscriber.newBuilder(subscription.getName(), receiver).build();\n+                subscriber.startAsync().awaitRunning();\n+\n+                subscriber.awaitTerminated();\n+            } catch (IllegalStateException e) {\n+\n+                if (subscriber != null) {\n+                    subscriber.stopAsync();\n+                }\n+            }\n+            try {\n+                Thread.sleep(reconnectPeriodSec * 1000);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "abe0d21c32aca02da5acae76ea4595cdfc3895ae"}, "originalPosition": 258}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Nzg0NTE2NA==", "bodyText": "Call to 'Thread.sleep()' in a loop, probably busy-waiting\nInspection info: Reports calls to java.lang.Thread.sleep() that occur inside loops. Such calls are indicative of \"busy-waiting\". Busy-waiting is often inefficient, and may result in unexpected deadlocks as busy-waiting threads do not release locked resources.", "url": "https://github.com/opentripplanner/OpenTripPlanner/pull/3166#discussion_r487845164", "createdAt": "2020-09-14T11:37:36Z", "author": {"login": "t2gran"}, "path": "src/ext/java/org/opentripplanner/ext/siri/updater/SiriEstimatedTimetableGooglePubsubUpdater.java", "diffHunk": "@@ -0,0 +1,385 @@\n+/* This program is free software: you can redistribute it and/or\n+ modify it under the terms of the GNU Lesser General Public License\n+ as published by the Free Software Foundation, either version 3 of\n+ the License, or (at your option) any later version.\n+\n+ This program is distributed in the hope that it will be useful,\n+ but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+ GNU General Public License for more details.\n+\n+ You should have received a copy of the GNU General Public License\n+ along with this program.  If not, see <http://www.gnu.org/licenses/>. */\n+\n+package org.opentripplanner.ext.siri.updater;\n+\n+import com.google.cloud.pubsub.v1.AckReplyConsumer;\n+import com.google.cloud.pubsub.v1.MessageReceiver;\n+import com.google.cloud.pubsub.v1.Subscriber;\n+import com.google.cloud.pubsub.v1.SubscriptionAdminClient;\n+import com.google.protobuf.ByteString;\n+import com.google.protobuf.Duration;\n+import com.google.protobuf.InvalidProtocolBufferException;\n+import com.google.pubsub.v1.ExpirationPolicy;\n+import com.google.pubsub.v1.ProjectSubscriptionName;\n+import com.google.pubsub.v1.ProjectTopicName;\n+import com.google.pubsub.v1.PubsubMessage;\n+import com.google.pubsub.v1.PushConfig;\n+import com.google.pubsub.v1.Subscription;\n+import org.apache.commons.io.FileUtils;\n+import org.apache.commons.lang3.time.DurationFormatUtils;\n+import org.entur.protobuf.mapper.SiriMapper;\n+import org.opentripplanner.ext.siri.SiriTimetableSnapshotSource;\n+import org.opentripplanner.routing.graph.Graph;\n+import org.opentripplanner.updater.GraphUpdater;\n+import org.opentripplanner.updater.GraphUpdaterManager;\n+import org.opentripplanner.util.HttpUtils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import uk.org.siri.siri20.EstimatedTimetableDeliveryStructure;\n+import uk.org.siri.siri20.Siri;\n+import uk.org.siri.www.siri.SiriType;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.net.URI;\n+import java.time.ZonedDateTime;\n+import java.util.List;\n+import java.util.UUID;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+/**\n+ * This class starts a Google PubSub subscription\n+ *\n+ * NOTE:\n+ *   - Path to Google credentials (.json-file) MUST exist in environment-variable \"GOOGLE_APPLICATION_CREDENTIALS\"\n+ *     as described here: https://cloud.google.com/docs/authentication/getting-started\n+ *   - ServiceAccount need access to create subscription (\"editor\")\n+ *\n+ *\n+ *\n+ * Startup-flow:\n+ *   1. Create subscription to topic. Subscription will receive all updates after creation.\n+ *   2. Fetch current data to initialize state.\n+ *   3. Flag updater as initialized\n+ *   3. Start receiving updates from Pubsub-subscription\n+ *\n+ *\n+ * <pre>\n+ *   \"type\": \"google-pubsub-siri-et-updater\",\n+ *   \"projectName\":\"project-1234\",                                                      // Google Cloud project name\n+ *   \"topicName\": \"protobuf.estimated_timetables\",                                      // Google Cloud Pubsub topic\n+ *   \"dataInitializationUrl\": \"http://server/realtime/protobuf/et\"  // Optional URL used to initialize OTP with all existing data\n+ * </pre>\n+ *\n+ */\n+public class SiriEstimatedTimetableGooglePubsubUpdater implements GraphUpdater {\n+\n+    private static final int DEFAULT_RECONNECT_PERIOD_SEC = 5; // Five seconds\n+\n+    private static Logger LOG = LoggerFactory.getLogger(SiriEstimatedTimetableGooglePubsubUpdater.class);\n+\n+    /**\n+     * Parent update manager. Is used to execute graph writer runnables.\n+     */\n+    private GraphUpdaterManager updaterManager;\n+\n+    private SiriTimetableSnapshotSource snapshotSource;\n+\n+    /**\n+     * The URL used to fetch all initial updates\n+     */\n+    private URI dataInitializationUrl;\n+\n+    /**\n+     * The ID for the static feed to which these TripUpdates are applied\n+     */\n+    private String feedId;\n+\n+    /**\n+     * The number of seconds to wait before reconnecting after a failed connection.\n+     */\n+    private int reconnectPeriodSec;\n+\n+    private SubscriptionAdminClient subscriptionAdminClient;\n+    private ProjectSubscriptionName subscriptionName;\n+    private ProjectTopicName topic;\n+    private PushConfig pushConfig;\n+\n+    private static transient final AtomicLong messageCounter = new AtomicLong(0);\n+    private static transient final AtomicLong updateCounter = new AtomicLong(0);\n+    private static transient final AtomicLong sizeCounter = new AtomicLong(0);\n+    private transient long startTime;\n+    private boolean primed;\n+\n+\n+    public SiriEstimatedTimetableGooglePubsubUpdater(Parameters config) {\n+\n+        try {\n+            configure(config);\n+\n+            if (System.getenv(\"GOOGLE_APPLICATION_CREDENTIALS\") != null &&\n+                    !System.getenv(\"GOOGLE_APPLICATION_CREDENTIALS\").isEmpty()) {\n+\n+                /*\n+                  Google libraries expects path to credentials json-file is stored in environment variable \"GOOGLE_APPLICATION_CREDENTIALS\"\n+                  Ref.: https://cloud.google.com/docs/authentication/getting-started\n+                 */\n+\n+                subscriptionAdminClient = SubscriptionAdminClient.create();\n+\n+                addShutdownHook();\n+\n+            } else {\n+                throw new RuntimeException(\"Google Pubsub updater is configured, but environment variable 'GOOGLE_APPLICATION_CREDENTIALS' is not defined. \" +\n+                        \"See https://cloud.google.com/docs/authentication/getting-started\");\n+            }\n+        } catch (IOException e) {\n+            e.printStackTrace();\n+        }\n+    }\n+\n+    private void addShutdownHook() {\n+        // TODO: This should probably be on a higher level?\n+        try {\n+            Runtime.getRuntime().addShutdownHook(new Thread(this::teardown));\n+            LOG.info(\"Shutdown-hook to clean up Google Pubsub subscription has been added.\");\n+        } catch (IllegalStateException e) {\n+            // Handling cornercase when instance is being shut down before it has been initialized\n+            LOG.info(\"Instance is already shutting down - cleaning up immediately.\", e);\n+            teardown();\n+        }\n+    }\n+\n+    @Override\n+    public void setGraphUpdaterManager(GraphUpdaterManager updaterManager) {\n+        this.updaterManager = updaterManager;\n+    }\n+\n+    @Override\n+    public void setup(Graph graph) throws Exception {\n+        // TODO OTP2 - This is thread safe, but only because updater setup methods are called sequentially.\n+        //           - Ideally we should inject the snapshotSource on this class.\n+        snapshotSource = graph.getOrSetupTimetableSnapshotProvider(SiriTimetableSnapshotSource::new);\n+    }\n+\n+    private void configure(Parameters config) {\n+\n+        /*\n+           URL that responds to HTTP GET which returns all initial data in protobuf-format.\n+           Will be called once to initialize realtime-data. All updates will be received from Google Cloud Pubsub\n+          */\n+        dataInitializationUrl = URI.create(config.getDataInitializationUrl());\n+\n+        feedId = config.getFeedId();\n+        reconnectPeriodSec = config.getReconnectPeriodSec();\n+\n+        // set subscriber\n+        String subscriptionId = System.getenv(\"HOSTNAME\");\n+        if (subscriptionId == null || subscriptionId.isEmpty()) {\n+            subscriptionId = \"otp-\"+UUID.randomUUID().toString();\n+        }\n+\n+        String projectName = config.getProjectName();\n+\n+        String topicName = config.getTopicName();\n+\n+        subscriptionName = ProjectSubscriptionName.of(\n+                projectName, subscriptionId);\n+        topic = ProjectTopicName.of(projectName, topicName);\n+\n+        pushConfig = PushConfig.getDefaultInstance();\n+\n+    }\n+\n+    @Override\n+    public void run() throws IOException {\n+\n+        if (subscriptionAdminClient == null) {\n+            throw new RuntimeException(\"Unable to initialize Google Pubsub-updater: System.getenv('GOOGLE_APPLICATION_CREDENTIALS') = \" + System.getenv(\"GOOGLE_APPLICATION_CREDENTIALS\"));\n+        }\n+\n+        LOG.info(\"Creating subscription {}\", subscriptionName);\n+\n+        Subscription subscription = subscriptionAdminClient.createSubscription(Subscription.newBuilder()\n+                .setTopic(topic.toString())\n+                .setName(subscriptionName.toString())\n+                .setPushConfig(pushConfig)\n+                .setMessageRetentionDuration(\n+                        // How long will an unprocessed message be kept - minimum 10 minutes\n+                        Duration.newBuilder().setSeconds(600).build()\n+                )\n+                .setExpirationPolicy(ExpirationPolicy.newBuilder()\n+                        // How long will the subscription exist when no longer in use - minimum 1 day\n+                        .setTtl(Duration.newBuilder().setSeconds(86400).build()).build()\n+                )\n+                .build());\n+\n+        LOG.info(\"Created subscription {}\", subscriptionName);\n+\n+        startTime = now();\n+\n+        final EstimatedTimetableMessageReceiver receiver = new EstimatedTimetableMessageReceiver();\n+\n+        int sleepPeriod = 1000;\n+        int attemptCounter = 1;\n+        while (!isPrimed()) {  // Retrying until data is initialized successfully\n+            try {\n+                initializeData(dataInitializationUrl, receiver);\n+\n+            } catch (Exception e) {\n+\n+                sleepPeriod = sleepPeriod * 2;\n+\n+                LOG.warn(\"Caught Exception while initializing data, will retry after {} ms - attempt number {}. ({})\", sleepPeriod, attemptCounter++, e.toString());\n+\n+                try {\n+                    Thread.sleep(sleepPeriod);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "abe0d21c32aca02da5acae76ea4595cdfc3895ae"}, "originalPosition": 237}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Nzg3MDk0MQ==", "bodyText": "You may leave this as is, since it follows what seems to be the practice in OTP, but this is not the recomended way to treat InterruptedException and as mention above the Thread.sleep blockes.", "url": "https://github.com/opentripplanner/OpenTripPlanner/pull/3166#discussion_r487870941", "createdAt": "2020-09-14T12:26:11Z", "author": {"login": "t2gran"}, "path": "src/ext/java/org/opentripplanner/ext/siri/updater/SiriSXUpdater.java", "diffHunk": "@@ -94,25 +103,44 @@ public void setup(Graph graph) {\n \n     @Override\n     protected void runPolling() {\n-        boolean moreData = false;\n-        do {\n-            Siri updates = getUpdates();\n-            if (updates != null) {\n-                ServiceDelivery serviceDelivery = updates.getServiceDelivery();\n-                // Use isTrue in case isMoreData returns null. Mark the updater as primed after last page of updates.\n-                moreData = BooleanUtils.isTrue(serviceDelivery.isMoreData());\n-                final boolean markPrimed = !moreData;\n-                if (serviceDelivery.getSituationExchangeDeliveries() != null) {\n-                    updaterManager.execute(graph -> {\n-                        updateHandler.update(serviceDelivery);\n-                        if (markPrimed) primed = true;\n-                    });\n+        try {\n+            boolean moreData = false;\n+            do {\n+                Siri updates = getUpdates();\n+                if (updates != null) {\n+                    ServiceDelivery serviceDelivery = updates.getServiceDelivery();\n+                    // Use isTrue in case isMoreData returns null. Mark the updater as primed after last page of updates.\n+                    moreData = BooleanUtils.isTrue(serviceDelivery.isMoreData());\n+                    final boolean markPrimed = !moreData;\n+                    if (serviceDelivery.getSituationExchangeDeliveries() != null) {\n+                        updaterManager.execute(graph -> {\n+                            updateHandler.update(serviceDelivery);\n+                            if (markPrimed) primed = true;\n+                        });\n+                    }\n                 }\n+            } while (moreData);\n+        } catch (IOException e) {\n+\n+            final long sleepTime = retryIntervalMillis + retryIntervalMillis * retryCount;\n+\n+            retryCount++;\n+\n+            LOG.info(\"Caught timeout - retry no. {} after {} millis\", retryCount, sleepTime);\n+\n+            try {\n+                Thread.sleep(sleepTime);\n+            } catch (InterruptedException ex) {\n+                //Ignore\n             }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "abe0d21c32aca02da5acae76ea4595cdfc3895ae"}, "originalPosition": 76}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Nzg3NTYxNw==", "bodyText": "Any Exception (even a NPE) will cause this method to enter an infinite recursion - this is not pretty. Catching the typed exceptions like IOException ++ would be better.", "url": "https://github.com/opentripplanner/OpenTripPlanner/pull/3166#discussion_r487875617", "createdAt": "2020-09-14T12:33:47Z", "author": {"login": "t2gran"}, "path": "src/ext/java/org/opentripplanner/ext/siri/updater/SiriVMHttpTripUpdateSource.java", "diffHunk": "@@ -90,6 +97,24 @@ public Siri getUpdates() {\n         } catch (Exception e) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "abe0d21c32aca02da5acae76ea4595cdfc3895ae"}, "originalPosition": 22}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Nzg5MzQ1MQ==", "bodyText": "This break the assumption that all entities can be identified by the id. The solution might be that a TripPattern should NOT be an TransitEntity or that the id is made uniq in all contexts it exist.\nIn OTP the TransitEntity.equals means same identity, not same value. In the above method things like scheduledTimetable, hopGeometries and perStopFlags is part of the equals method. But is it really not allowed for these to change in the lifecycle of a TripPattern?", "url": "https://github.com/opentripplanner/OpenTripPlanner/pull/3166#discussion_r487893451", "createdAt": "2020-09-14T13:01:27Z", "author": {"login": "t2gran"}, "path": "src/main/java/org/opentripplanner/model/TripPattern.java", "diffHunk": "@@ -639,4 +640,29 @@ public String getFeedId() {\n     private static Coordinate coordinate(Stop s) {\n         return new Coordinate(s.getLon(), s.getLat());\n     }\n+\n+    // Need an equals() since \"Trips in a pattern are no longer necessarily running on the same service ID.\"\n+    @Override\n+    public boolean equals(Object o) {\n+        if (this == o) {\n+            return true;\n+        }\n+        if (o == null || getClass() != o.getClass()) {\n+            return false;\n+        }\n+        if (!super.equals(o)) {\n+            return false;\n+        }\n+        TripPattern that = (TripPattern) o;\n+        return directionId == that.directionId &&\n+                Objects.equal(id, that.id) &&\n+                Objects.equal(name, that.name) &&\n+                Objects.equal(route, that.route) &&\n+                Objects.equal(stopPattern, that.stopPattern) &&\n+                Objects.equal(scheduledTimetable, that.scheduledTimetable) &&\n+                Objects.equal(trips, that.trips) &&\n+                Objects.equal(hopGeometries, that.hopGeometries) &&\n+                Objects.equal(perStopFlags, that.perStopFlags) &&\n+                Objects.equal(services, that.services);\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "abe0d21c32aca02da5acae76ea4595cdfc3895ae"}, "originalPosition": 36}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzkwNjkxMA==", "bodyText": "This should be documented or inlined, since the usage is limited inlineing is probably the best.", "url": "https://github.com/opentripplanner/OpenTripPlanner/pull/3166#discussion_r487906910", "createdAt": "2020-09-14T13:21:36Z", "author": {"login": "t2gran"}, "path": "src/main/java/org/opentripplanner/routing/RoutingService.java", "diffHunk": "@@ -79,9 +80,15 @@ public RoutingResponse route(RoutingRequest request, Router router) {\n                 startTime,\n                 timeRange,\n                 numberOfDepartures,\n-                omitNonPickups\n+                omitNonPickups,\n+                includeCancelledTrips\n         );\n     }\n+    public List<StopTimesInPattern> stopTimesForStop(\n+            Stop stop, long startTime, int timeRange, int numberOfDepartures, boolean omitNonPickups\n+    ) {\n+        return stopTimesForStop(stop, startTime, timeRange, numberOfDepartures, omitNonPickups, false);\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "abe0d21c32aca02da5acae76ea4595cdfc3895ae"}, "originalPosition": 35}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "afa16eb606da23d6c30b6a7288e08d0e7a04b878", "author": {"user": {"login": "lassetyr", "name": null}}, "url": "https://github.com/opentripplanner/OpenTripPlanner/commit/afa16eb606da23d6c30b6a7288e08d0e7a04b878", "committedDate": "2020-09-18T14:11:44Z", "message": "Removed custom alerts-handling where \"route OR stop\" was treated as \"route AND stop\""}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e76de7b7f1b8d041941b9ea357c50ce9671bf402", "author": {"user": {"login": "lassetyr", "name": null}}, "url": "https://github.com/opentripplanner/OpenTripPlanner/commit/e76de7b7f1b8d041941b9ea357c50ce9671bf402", "committedDate": "2020-09-24T13:15:55Z", "message": "Including open-ended alerts when calculating valid display-times"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "27c2a63e660df962344672dd8a909c94f3618989", "author": {"user": {"login": "t2gran", "name": "Thomas Gran"}}, "url": "https://github.com/opentripplanner/OpenTripPlanner/commit/27c2a63e660df962344672dd8a909c94f3618989", "committedDate": "2020-09-25T08:21:09Z", "message": "Merge branch 'dev-2.x' into siri-realtime"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7fdbcea712bab20251082750842d0c5c7f0d4f49", "author": {"user": {"login": "lassetyr", "name": null}}, "url": "https://github.com/opentripplanner/OpenTripPlanner/commit/7fdbcea712bab20251082750842d0c5c7f0d4f49", "committedDate": "2020-09-25T11:48:55Z", "message": "Removed license-information"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "655f5c816d61de60833f95a73006669ca9963d4f", "author": {"user": {"login": "lassetyr", "name": null}}, "url": "https://github.com/opentripplanner/OpenTripPlanner/commit/655f5c816d61de60833f95a73006669ca9963d4f", "committedDate": "2020-09-25T11:48:55Z", "message": "Added comment as javadoc"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f28d16ce788e8ad69d18bdea8dc8104ef87c4353", "author": {"user": {"login": "t2gran", "name": "Thomas Gran"}}, "url": "https://github.com/opentripplanner/OpenTripPlanner/commit/f28d16ce788e8ad69d18bdea8dc8104ef87c4353", "committedDate": "2020-09-25T14:23:50Z", "message": "clean code: Reformatted SiriAlertsUpdateHandlerTest.java"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "30a7c7ed9824ade9d66ec424deb1ccc6fceccc52", "author": {"user": {"login": "t2gran", "name": "Thomas Gran"}}, "url": "https://github.com/opentripplanner/OpenTripPlanner/commit/30a7c7ed9824ade9d66ec424deb1ccc6fceccc52", "committedDate": "2020-09-30T08:54:07Z", "message": "Merge branch 'dev-2.x' into siri-realtime"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a9e439fa31f64a648812b7824aac2be8a3e8b42a", "author": {"user": {"login": "t2gran", "name": "Thomas Gran"}}, "url": "https://github.com/opentripplanner/OpenTripPlanner/commit/a9e439fa31f64a648812b7824aac2be8a3e8b42a", "committedDate": "2020-09-30T09:33:13Z", "message": "Add HashCode to TripPattern and document the eq/hc hack."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "6b0b7259a3ad8ba8ce293d4fec689f75000a167e", "author": {"user": {"login": "t2gran", "name": "Thomas Gran"}}, "url": "https://github.com/opentripplanner/OpenTripPlanner/commit/6b0b7259a3ad8ba8ce293d4fec689f75000a167e", "committedDate": "2020-09-30T09:27:19Z", "message": "Add HashCode to TripPattern and document the eq/hc hack."}, "afterCommit": {"oid": "a9e439fa31f64a648812b7824aac2be8a3e8b42a", "author": {"user": {"login": "t2gran", "name": "Thomas Gran"}}, "url": "https://github.com/opentripplanner/OpenTripPlanner/commit/a9e439fa31f64a648812b7824aac2be8a3e8b42a", "committedDate": "2020-09-30T09:33:13Z", "message": "Add HashCode to TripPattern and document the eq/hc hack."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDk5MjUzMjQz", "url": "https://github.com/opentripplanner/OpenTripPlanner/pull/3166#pullrequestreview-499253243", "createdAt": "2020-09-30T09:36:48Z", "commit": {"oid": "a9e439fa31f64a648812b7824aac2be8a3e8b42a"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1955, "cost": 1, "resetAt": "2021-11-01T15:33:45Z"}}}