{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzgxMTI0OTg2", "number": 2990, "title": "Elevation calculation speed-up", "bodyText": "To be completed by pull request submitter:\n\n issue: #2583 seems relevant\n roadmap: Not on roadmap :(\n tests: Test added for elevation module\n formatting:\n documentation: If you are adding a new configuration option, have you added an explanation to the configuration documentation tables and sections?\n changelog: add a bullet point to the changelog file with description and link to the linked issue\n\nTo be completed by @opentripplanner/plc:\n\n reviews and approvals by 2 members, ideally from different organizations\n after merging: update the relevant card on the roadmap\n\nThis PR dramatically speeds up the calculations in the ElevationModule of the graph builder modules. It does so by:\n\nOptimizing as many calculations of elevations for a street edge as possible.\nAdding the ability to read/write cached elevation data\n\nAfter graph building, a file with a lookup of the cached elevation for a coordinate sequence can be written\nIn subsequent graph builds, this file can be loaded and the cached data can be used.\ncustom graph build parameters can be entered to enable or disable reading or writing of this data. The default is to read, but not to write.\n\n\n\nIn addition to the performance improvements, this PR also has changes that:\n\ntolerate areas where elevation tiles are unavailable.\nrefactor a few elevation classes to simplify constructors\nAdd a simple test of the elevation module\nadds documentation of how to optimize elevation calculations", "createdAt": "2020-02-27T23:29:42Z", "url": "https://github.com/opentripplanner/OpenTripPlanner/pull/2990", "merged": true, "mergeCommit": {"oid": "ba415ea90cea5ff2092adcde678ed1d1c97702c4"}, "closed": true, "closedAt": "2020-05-12T08:44:55Z", "author": {"login": "evansiroky"}, "timelineItems": {"totalCount": 55, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcIiisygH2gAyMzgxMTI0OTg2OmQ3MzFkYTI0NDUwOGI1NTMwZjFmODAzY2NmZmFmNmNmZmRiNTBiNTk=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcgNc5JgFqTQwOTA2NDg2Mg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "d731da244508b5530f1f803ccffaf6cffdb50b59", "author": {"user": {"login": "evansiroky", "name": "Evan Siroky"}}, "url": "https://github.com/opentripplanner/OpenTripPlanner/commit/d731da244508b5530f1f803ccffaf6cffdb50b59", "committedDate": "2020-02-27T21:52:09Z", "message": "Add test for elevation module"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4a60443f93619f0e6ddc80dc6123e35d7c338182", "author": {"user": {"login": "evansiroky", "name": "Evan Siroky"}}, "url": "https://github.com/opentripplanner/OpenTripPlanner/commit/4a60443f93619f0e6ddc80dc6123e35d7c338182", "committedDate": "2020-02-27T21:58:21Z", "message": "Transform points to the correct CRS for elevation lookup"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "562864ed028a2212387162eaeec8f0b31ee62b90", "author": {"user": {"login": "evansiroky", "name": "Evan Siroky"}}, "url": "https://github.com/opentripplanner/OpenTripPlanner/commit/562864ed028a2212387162eaeec8f0b31ee62b90", "committedDate": "2020-02-27T22:06:07Z", "message": "Parellelize elevation calculations using parellel streams"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f93a53b413d5d26d7f15730dad3c4fb44cf0b28a", "author": {"user": {"login": "evansiroky", "name": "Evan Siroky"}}, "url": "https://github.com/opentripplanner/OpenTripPlanner/commit/f93a53b413d5d26d7f15730dad3c4fb44cf0b28a", "committedDate": "2020-02-27T22:06:32Z", "message": "Synchronize adding elevation annotations"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5646bdbc83b0250ff39ecf6d854ec596e445ca1c", "author": {"user": {"login": "evansiroky", "name": "Evan Siroky"}}, "url": "https://github.com/opentripplanner/OpenTripPlanner/commit/5646bdbc83b0250ff39ecf6d854ec596e445ca1c", "committedDate": "2020-02-27T22:06:57Z", "message": "Refactor looping in elevation calculations for edges"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "469d4a33813d744bf949d8ea455d51f54dce841e", "author": {"user": {"login": "evansiroky", "name": "Evan Siroky"}}, "url": "https://github.com/opentripplanner/OpenTripPlanner/commit/469d4a33813d744bf949d8ea455d51f54dce841e", "committedDate": "2020-02-27T22:09:50Z", "message": "Some small performance improvements to speed up elevation calculations"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9d1301d92da8fc2eac6088597a3f5461457452ce", "author": {"user": {"login": "landonreed", "name": "Landon Reed"}}, "url": "https://github.com/opentripplanner/OpenTripPlanner/commit/9d1301d92da8fc2eac6088597a3f5461457452ce", "committedDate": "2020-02-27T22:10:15Z", "message": "Replace coverage/datum loops w spatial index"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "638de8ba2dd8893470eb645ec9a0095c982f90a5", "author": {"user": {"login": "landonreed", "name": "Landon Reed"}}, "url": "https://github.com/opentripplanner/OpenTripPlanner/commit/638de8ba2dd8893470eb645ec9a0095c982f90a5", "committedDate": "2020-02-27T22:10:35Z", "message": "Replace 2 indexes with single region/datum index"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "16f96bef6f60f183c712caf3687a521e30665be9", "author": {"user": {"login": "evansiroky", "name": "Evan Siroky"}}, "url": "https://github.com/opentripplanner/OpenTripPlanner/commit/16f96bef6f60f183c712caf3687a521e30665be9", "committedDate": "2020-02-27T22:17:24Z", "message": "Add feature to cache elevation data during graph builds"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5ec25d1879395d89e679313b27aae97f6f98592d", "author": {"user": {"login": "evansiroky", "name": "Evan Siroky"}}, "url": "https://github.com/opentripplanner/OpenTripPlanner/commit/5ec25d1879395d89e679313b27aae97f6f98592d", "committedDate": "2020-02-27T22:17:42Z", "message": "Only try to parse elevation cache if cacheElevations is true"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "27e379eeaf393468000168bc8b082f05cd21174a", "author": {"user": {"login": "evansiroky", "name": "Evan Siroky"}}, "url": "https://github.com/opentripplanner/OpenTripPlanner/commit/27e379eeaf393468000168bc8b082f05cd21174a", "committedDate": "2020-02-27T22:17:57Z", "message": "Don't throw error for tiles that couldn't be downloaded"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1b5abc573a7f3d093cef88d3f9e514c6f7a11d08", "author": {"user": {"login": "evansiroky", "name": "Evan Siroky"}}, "url": "https://github.com/opentripplanner/OpenTripPlanner/commit/1b5abc573a7f3d093cef88d3f9e514c6f7a11d08", "committedDate": "2020-02-27T22:18:39Z", "message": "Add some comments and don't log point-not-found messages"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6c6a62397b018a309b96d0b6447980ff74b7ead0", "author": {"user": {"login": "evansiroky", "name": "Evan Siroky"}}, "url": "https://github.com/opentripplanner/OpenTripPlanner/commit/6c6a62397b018a309b96d0b6447980ff74b7ead0", "committedDate": "2020-02-27T22:19:07Z", "message": "Bail whenever an elevation coordinate can't be found"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e929daa1190a69d3a75af650ddd07ac7f609e9cd", "author": {"user": {"login": "evansiroky", "name": "Evan Siroky"}}, "url": "https://github.com/opentripplanner/OpenTripPlanner/commit/e929daa1190a69d3a75af650ddd07ac7f609e9cd", "committedDate": "2020-02-27T22:26:13Z", "message": "Refactor elevation module and create separate read/write params for elevation caching"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "64b7d66ef7d31b1bc5b03f4c0ceb8daf3ee2cc06", "author": {"user": {"login": "evansiroky", "name": "Evan Siroky"}}, "url": "https://github.com/opentripplanner/OpenTripPlanner/commit/64b7d66ef7d31b1bc5b03f4c0ceb8daf3ee2cc06", "committedDate": "2020-02-27T22:30:26Z", "message": "Fix a few cherry-picked things that don't work in dev-1.x"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "71d392d3e9faa41542b3aff3936dbff1621b4dab", "author": {"user": {"login": "evansiroky", "name": "Evan Siroky"}}, "url": "https://github.com/opentripplanner/OpenTripPlanner/commit/71d392d3e9faa41542b3aff3936dbff1621b4dab", "committedDate": "2020-02-27T23:24:31Z", "message": "Add documentation about elevation calculation enhancements"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "dada25bc7d0d58696fae34f32a3538f1e6bb18f6", "author": {"user": {"login": "evansiroky", "name": "Evan Siroky"}}, "url": "https://github.com/opentripplanner/OpenTripPlanner/commit/dada25bc7d0d58696fae34f32a3538f1e6bb18f6", "committedDate": "2020-02-27T23:27:52Z", "message": "Add changelog entry"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9c3631d1763256bf89103999f509a9ba2bebb7ec", "author": {"user": {"login": "evansiroky", "name": "Evan Siroky"}}, "url": "https://github.com/opentripplanner/OpenTripPlanner/commit/9c3631d1763256bf89103999f509a9ba2bebb7ec", "committedDate": "2020-02-27T23:30:34Z", "message": "Merge branch 'dev-1.x' into dev-1x-elevation-improvements"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c564b0ad2df98f2bb7bc49288973967578a8f697", "author": {"user": {"login": "evansiroky", "name": "Evan Siroky"}}, "url": "https://github.com/opentripplanner/OpenTripPlanner/commit/c564b0ad2df98f2bb7bc49288973967578a8f697", "committedDate": "2020-02-27T23:43:45Z", "message": "Ignore problematic Bano Geocoder test"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "82a60fb5610e8bfc1f4107909904d2b2404e2c24", "author": {"user": {"login": "evansiroky", "name": "Evan Siroky"}}, "url": "https://github.com/opentripplanner/OpenTripPlanner/commit/82a60fb5610e8bfc1f4107909904d2b2404e2c24", "committedDate": "2020-03-03T19:40:16Z", "message": "Merge branch 'otp-dev-1.x' into dev-1x-elevation-improvements"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "350196cdcd82214aa42df73f6e4a3f04060f3eec", "author": {"user": {"login": "evansiroky", "name": "Evan Siroky"}}, "url": "https://github.com/opentripplanner/OpenTripPlanner/commit/350196cdcd82214aa42df73f6e4a3f04060f3eec", "committedDate": "2020-03-03T19:42:16Z", "message": "Remove duplicate import"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "43fbfac4a78bd4e70c8c6a513b48e7d429a4d61c", "author": {"user": {"login": "evansiroky", "name": "Evan Siroky"}}, "url": "https://github.com/opentripplanner/OpenTripPlanner/commit/43fbfac4a78bd4e70c8c6a513b48e7d429a4d61c", "committedDate": "2020-03-03T23:06:52Z", "message": "A few small refactors to address IBI PR review comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a375871ca6549f6b35d5776a9434bbbb5098a6d5", "author": {"user": {"login": "evansiroky", "name": "Evan Siroky"}}, "url": "https://github.com/opentripplanner/OpenTripPlanner/commit/a375871ca6549f6b35d5776a9434bbbb5098a6d5", "committedDate": "2020-03-09T06:39:34Z", "message": "Add edges with elevation after parellelstream to avoid synchronized list"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "dc1d7388be4ef0bbb923988b515612d199cb8eb7", "author": {"user": {"login": "evansiroky", "name": "Evan Siroky"}}, "url": "https://github.com/opentripplanner/OpenTripPlanner/commit/dc1d7388be4ef0bbb923988b515612d199cb8eb7", "committedDate": "2020-03-09T22:09:06Z", "message": "Refactor elevation module to avoid thread locks from Interpolator2D class\n\nAlso only activate coordinate transformation during testing"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1c1c0641018f76b507bd15e76c2eada7be6c0970", "author": {"user": {"login": "evansiroky", "name": "Evan Siroky"}}, "url": "https://github.com/opentripplanner/OpenTripPlanner/commit/1c1c0641018f76b507bd15e76c2eada7be6c0970", "committedDate": "2020-03-10T06:14:19Z", "message": "Synchronize creation of Coverage instances to avoid deadlocks"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b1f4313d71030c096ebbae989bea57e4f309801f", "author": {"user": {"login": "evansiroky", "name": "Evan Siroky"}}, "url": "https://github.com/opentripplanner/OpenTripPlanner/commit/b1f4313d71030c096ebbae989bea57e4f309801f", "committedDate": "2020-03-10T06:20:50Z", "message": "Add ability to precalculate geoid difference values"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8d0491c73984ca84ef9f12feaf435a9f72799811", "author": {"user": {"login": "evansiroky", "name": "Evan Siroky"}}, "url": "https://github.com/opentripplanner/OpenTripPlanner/commit/8d0491c73984ca84ef9f12feaf435a9f72799811", "committedDate": "2020-03-10T18:20:49Z", "message": "Remove geoidDifferenceSignficantDigits builder parameter"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "97b5537dd7cceb9c36085c4498eeae1b9c0abc73", "author": {"user": {"login": "evansiroky", "name": "Evan Siroky"}}, "url": "https://github.com/opentripplanner/OpenTripPlanner/commit/97b5537dd7cceb9c36085c4498eeae1b9c0abc73", "committedDate": "2020-03-10T18:22:51Z", "message": "Add documentation about geoid difference values"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f542ff0d2e1677c1dbd29e6a070bea79c14f37df", "author": {"user": {"login": "evansiroky", "name": "Evan Siroky"}}, "url": "https://github.com/opentripplanner/OpenTripPlanner/commit/f542ff0d2e1677c1dbd29e6a070bea79c14f37df", "committedDate": "2020-03-10T20:31:43Z", "message": "Various refactors for PR review\n\n- Remove coordinate transforms\n- More comments\n- Simplify coverage creation"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a58d4b977e411d83146f7480fb69af93a323c950", "author": {"user": {"login": "evansiroky", "name": "Evan Siroky"}}, "url": "https://github.com/opentripplanner/OpenTripPlanner/commit/a58d4b977e411d83146f7480fb69af93a323c950", "committedDate": "2020-03-10T22:08:16Z", "message": "Correct some typos"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8e9621d9e3f8ab36912e37315278ae019ec0ae7c", "author": {"user": {"login": "evansiroky", "name": "Evan Siroky"}}, "url": "https://github.com/opentripplanner/OpenTripPlanner/commit/8e9621d9e3f8ab36912e37315278ae019ec0ae7c", "committedDate": "2020-03-11T05:29:16Z", "message": "Refactor Coverage Factories to have explicit fetch vs load methods"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7f33461ceb28d4d1a15fed80d7a516055d7ffeca", "author": {"user": {"login": "evansiroky", "name": "Evan Siroky"}}, "url": "https://github.com/opentripplanner/OpenTripPlanner/commit/7f33461ceb28d4d1a15fed80d7a516055d7ffeca", "committedDate": "2020-03-11T18:25:30Z", "message": "Synchronize computeEllipsoidToGeoidDifference method"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "cf78ec424bbac5bcea869675ebea1ddbb3a5342c", "author": {"user": {"login": "evansiroky", "name": "Evan Siroky"}}, "url": "https://github.com/opentripplanner/OpenTripPlanner/commit/cf78ec424bbac5bcea869675ebea1ddbb3a5342c", "committedDate": "2020-03-11T18:25:40Z", "message": "Refactor fetching in NEDTileSource files"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d506c3f7f4d1321b99dbe6890c41d2f283305887", "author": {"user": {"login": "evansiroky", "name": "Evan Siroky"}}, "url": "https://github.com/opentripplanner/OpenTripPlanner/commit/d506c3f7f4d1321b99dbe6890c41d2f283305887", "committedDate": "2020-03-12T07:00:23Z", "message": "Move edge processed incrementation to proper place"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ec0e383768e570609c73327c822fd02ce30bd344", "author": {"user": {"login": "evansiroky", "name": "Evan Siroky"}}, "url": "https://github.com/opentripplanner/OpenTripPlanner/commit/ec0e383768e570609c73327c822fd02ce30bd344", "committedDate": "2020-03-16T23:05:23Z", "message": "Lazy-create thread-specific coverage to immediately process cached edges"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7d44713a1ca574eff04c389edba2ebc02de29b04", "author": {"user": {"login": "evansiroky", "name": "Evan Siroky"}}, "url": "https://github.com/opentripplanner/OpenTripPlanner/commit/7d44713a1ca574eff04c389edba2ebc02de29b04", "committedDate": "2020-03-16T23:05:29Z", "message": "Small comment refactor"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY4MDEzMDEx", "url": "https://github.com/opentripplanner/OpenTripPlanner/pull/2990#pullrequestreview-368013011", "createdAt": "2020-03-03T14:16:34Z", "commit": {"oid": "c564b0ad2df98f2bb7bc49288973967578a8f697"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wM1QxNDoxNjozNFrOFxHeKQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xN1QxNDoyMzowNVrOF3eiLQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzA0Njk1Mw==", "bodyText": "If the cache is writable, it should be possible to have a accessed flag, and skip entries NOT accessed in the current build. I might add that if I port this to OTP2.", "url": "https://github.com/opentripplanner/OpenTripPlanner/pull/2990#discussion_r387046953", "createdAt": "2020-03-03T14:16:34Z", "author": {"login": "t2gran"}, "path": "docs/Configuration.md", "diffHunk": "@@ -230,6 +232,29 @@ it is possible to define a multiplier that converts the elevation values from so\n }\n ```\n \n+### Elevation Data Calculation Optimizations\n+\n+Calculating elevations on all StreetEdges can take a dramatically long time. In a very large graph build for multiple Northeast US states, the time it took to download the elevation data and calculate all of the elevations took 5,509 seconds (roughly 1.5 hours).\n+\n+If you are using cloud computing for your OTP instances, it is recommended to create prebuilt images that contain the elevation data you need. This will save time because all of the data won't need to be downloaded.\n+\n+However, the bulk of the time will still spent calculating elevations for all of the street edges. Therefore, a further optimazation can be done to calculate and save the elevation data during a graph build and then save it for future use.\n+\n+In order to write out the precalculated elevation data, add this to your `build-config.json` file:\n+\n+```JSON\n+// build-config.json\n+{  \n+  \"writeCachedElevations\": true\n+}\n+```\n+\n+After building the graph, a file called `cached_elevations.obj` will be written to the cache directory. By default, this file is not written during graph builds. There is also a graph build parameter called `readCachedElevations` which is set to `true` by default.\n+\n+In graph builds, the elevation module will attempt to read the `cached_elevations.obj` file from the cache directory. The cache directory defaults to `/var/otp/cache`, but this can be overriden via the CLI argument `--cache <directory>`. For the same graph build for multiple Northeast US states, the time it took with using this predownloaded and precalculated data became 543.7 seconds (roughly 9 minutes).\n+\n+The cached data is a lookup table where the coordinate sequences of respective street edges are used as keys for calculated data. Therefore, it is expected that over time various edits to OpenStreetMap will cause this cached data to become stale and not include new OSM ways. Therefore, periodic update of this cached data is recommended.\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c564b0ad2df98f2bb7bc49288973967578a8f697"}, "originalPosition": 35}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzA1MTM2Nw==", "bodyText": "Tip, personally I like to write big number like this 50_000, it is a bit easier to read.", "url": "https://github.com/opentripplanner/OpenTripPlanner/pull/2990#discussion_r387051367", "createdAt": "2020-03-03T14:23:10Z", "author": {"login": "t2gran"}, "path": "src/main/java/org/opentripplanner/graph_builder/module/ned/ElevationModule.java", "diffHunk": "@@ -99,33 +131,83 @@ public void buildGraph(Graph graph, HashMap<Class<?>, Object> extra) {\n         // interpolation internally)\n         coverage = (gridCov instanceof GridCoverage2D) ? Interpolator2D.create(\n                 (GridCoverage2D) gridCov, new InterpolationBilinear()) : gridCov;\n+        try {\n+            transformer = CRS.findMathTransform(\n+                GeometryUtils.WGS84_XY,\n+                coverage.getCoordinateReferenceSystem(),\n+                true\n+            );\n+        } catch (FactoryException e) {\n+            log.error(\"Could not find an appropriate transformer!\");\n+            throw new RuntimeException(e);\n+        }\n+\n+        // try to load in the cached elevation data\n+        if (readCachedElevations) {\n+            try {\n+                ObjectInputStream in = new ObjectInputStream(new FileInputStream(cachedElevationsFile));\n+                cachedElevations = (HashMap<String, PackedCoordinateSequence>) in.readObject();\n+                log.info(\"Cached elevation data loaded into memory!\");\n+            } catch (IOException | ClassNotFoundException e) {\n+                log.warn(graph.addBuilderAnnotation(new Graphwide(\n+                    String.format(\"Cached elevations file could not be read in due to error: %s!\", e.getMessage()))));\n+            }\n+        }\n         log.info(\"Setting street elevation profiles from digital elevation model...\");\n-        List<StreetEdge> edgesWithElevation = new ArrayList<StreetEdge>();\n-        int nProcessed = 0;\n-        int nTotal = graph.countEdges();\n+\n+        List<StreetEdge> edgesWithElevation = Collections.synchronizedList(new ArrayList<>());\n+        AtomicInteger nProcessed = new AtomicInteger();\n+\n+        List<StreetWithElevationEdge> edgesToCalculate = new ArrayList<>();\n         for (Vertex gv : graph.getVertices()) {\n             for (Edge ee : gv.getOutgoing()) {\n                 if (ee instanceof StreetWithElevationEdge) {\n-                    StreetWithElevationEdge edgeWithElevation = (StreetWithElevationEdge) ee;\n-                    processEdge(graph, edgeWithElevation);\n-                    if (edgeWithElevation.getElevationProfile() != null && !edgeWithElevation.isElevationFlattened()) {\n-                        edgesWithElevation.add(edgeWithElevation);\n-                    }\n-                    nProcessed += 1;\n-                    if (nProcessed % 50000 == 0) {\n-                        log.info(\"set elevation on {}/{} edges\", nProcessed, nTotal);\n-                        double failurePercentage = nPointsOutsideDEM / nPointsEvaluated * 100;\n-                        if (failurePercentage > 50) {\n-                            log.warn(\"Fetching elevation failed at {}/{} points ({}%)\",\n-                                    nPointsOutsideDEM, nPointsEvaluated, failurePercentage);\n-                            log.warn(\"Elevation is missing at a large number of points. DEM may be for the wrong region. \" +\n-                                    \"If it is unprojected, perhaps the axes are not in (longitude, latitude) order.\");\n-                        }\n-                    }\n+                    edgesToCalculate.add((StreetWithElevationEdge) ee);\n                 }\n             }\n         }\n \n+        edgesToCalculate.parallelStream().forEach(edgeWithElevation -> {\n+            processEdge(graph, edgeWithElevation);\n+            if (edgeWithElevation.hasPackedElevationProfile() && !edgeWithElevation.isElevationFlattened()) {\n+                edgesWithElevation.add(edgeWithElevation);\n+            }\n+            int curNumProcessed = nProcessed.addAndGet(1);\n+            if (curNumProcessed % 50000 == 0) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c564b0ad2df98f2bb7bc49288973967578a8f697"}, "originalPosition": 193}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzA2OTQ4OQ==", "bodyText": "The class need documentation on multi-threading. Something like this:\n\nTHIS CLASS IS MULTI-THEARED\n<p>\nIt uses a parallell stream to speed up the ...", "url": "https://github.com/opentripplanner/OpenTripPlanner/pull/2990#discussion_r387069489", "createdAt": "2020-03-03T14:48:26Z", "author": {"login": "t2gran"}, "path": "src/main/java/org/opentripplanner/graph_builder/module/ned/ElevationModule.java", "diffHunk": "@@ -44,32 +61,55 @@\n ", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c564b0ad2df98f2bb7bc49288973967578a8f697"}, "originalPosition": 49}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzA3MDE3NQ==", "bodyText": "Convert to JavaDoc /** */ not //.", "url": "https://github.com/opentripplanner/OpenTripPlanner/pull/2990#discussion_r387070175", "createdAt": "2020-03-03T14:49:23Z", "author": {"login": "t2gran"}, "path": "src/main/java/org/opentripplanner/graph_builder/module/ned/ElevationModule.java", "diffHunk": "@@ -44,32 +61,55 @@\n \n     private static final Logger log = LoggerFactory.getLogger(ElevationModule.class);\n \n-    private ElevationGridCoverageFactory gridCoverageFactory;\n+    private final ElevationGridCoverageFactory gridCoverageFactory;\n+    private final boolean readCachedElevations;\n+    private final boolean writeCachedElevations;\n+    private final File cachedElevationsFile;\n+\n+    private HashMap<String, PackedCoordinateSequence> cachedElevations;\n \n     private Coverage coverage;\n \n     // Keep track of the proportion of elevation fetch operations that fail so we can issue warnings.\n-    private int nPointsEvaluated = 0;\n-    private int nPointsOutsideDEM = 0;\n+    private AtomicInteger nPointsEvaluated = new AtomicInteger(0);\n+    private AtomicInteger nPointsOutsideDEM = new AtomicInteger(0);\n \n     /**\n      * The distance between samples in meters. Defaults to 10m, the approximate resolution of 1/3\n      * arc-second NED data.\n      */\n     private double distanceBetweenSamplesM = 10;\n \n-\n     /**\n      * Unit conversion multiplier for elevation values. No conversion needed if the elevation values\n      * are defined in meters in the source data. If, for example, decimetres are used in the source data,\n      * this should be set to 0.1 in build-config.json.\n      */\n-    private double elevationUnitMultiplier = 1;\n+    private final double elevationUnitMultiplier;\n \n-    public ElevationModule() { /* This makes me a \"bean\" */ };\n-    \n-    public ElevationModule(ElevationGridCoverageFactory factory, double elevationUnitMultiplier) {\n-        this.setGridCoverageFactory(factory);\n+    /** used to transform street coordinates into the projection used by the elevation data */\n+    private MathTransform transformer;\n+\n+    // used only for testing purposes", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c564b0ad2df98f2bb7bc49288973967578a8f697"}, "originalPosition": 90}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzA3MjA4Mw==", "bodyText": "Use this(factory, null, false, false, 1). Then if someone add/remove a new parameter to the \"main\" constructor he/she needs to make a decision what to do with this one.", "url": "https://github.com/opentripplanner/OpenTripPlanner/pull/2990#discussion_r387072083", "createdAt": "2020-03-03T14:52:13Z", "author": {"login": "t2gran"}, "path": "src/main/java/org/opentripplanner/graph_builder/module/ned/ElevationModule.java", "diffHunk": "@@ -44,32 +61,55 @@\n \n     private static final Logger log = LoggerFactory.getLogger(ElevationModule.class);\n \n-    private ElevationGridCoverageFactory gridCoverageFactory;\n+    private final ElevationGridCoverageFactory gridCoverageFactory;\n+    private final boolean readCachedElevations;\n+    private final boolean writeCachedElevations;\n+    private final File cachedElevationsFile;\n+\n+    private HashMap<String, PackedCoordinateSequence> cachedElevations;\n \n     private Coverage coverage;\n \n     // Keep track of the proportion of elevation fetch operations that fail so we can issue warnings.\n-    private int nPointsEvaluated = 0;\n-    private int nPointsOutsideDEM = 0;\n+    private AtomicInteger nPointsEvaluated = new AtomicInteger(0);\n+    private AtomicInteger nPointsOutsideDEM = new AtomicInteger(0);\n \n     /**\n      * The distance between samples in meters. Defaults to 10m, the approximate resolution of 1/3\n      * arc-second NED data.\n      */\n     private double distanceBetweenSamplesM = 10;\n \n-\n     /**\n      * Unit conversion multiplier for elevation values. No conversion needed if the elevation values\n      * are defined in meters in the source data. If, for example, decimetres are used in the source data,\n      * this should be set to 0.1 in build-config.json.\n      */\n-    private double elevationUnitMultiplier = 1;\n+    private final double elevationUnitMultiplier;\n \n-    public ElevationModule() { /* This makes me a \"bean\" */ };\n-    \n-    public ElevationModule(ElevationGridCoverageFactory factory, double elevationUnitMultiplier) {\n-        this.setGridCoverageFactory(factory);\n+    /** used to transform street coordinates into the projection used by the elevation data */\n+    private MathTransform transformer;\n+\n+    // used only for testing purposes\n+    public ElevationModule(ElevationGridCoverageFactory factory) {\n+        gridCoverageFactory = factory;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c564b0ad2df98f2bb7bc49288973967578a8f697"}, "originalPosition": 92}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzY2NTk5Nw==", "bodyText": "Two things here:\n\nMy impression is that we use the builder annotations to report input data problems - an InterruptException is a programming error - or am I mistaken? It is not important to me what we land on, but it should be used consistent.\nWhen catching InterruptException you should reset the Thread.currentThread().interrupt();, and if it is not deliberate I would exit like this:\n\ntry {\n  Thread.sleep(100);\n} catch (InterruptedException ex) {\n  Thread.currentThread().interrupt();\n  throw new RuntimeException(ex);\n}\n\nSee: https://stackoverflow.com/questions/4906799/why-invoke-thread-currentthread-interrupt-in-a-catch-interruptexception-block", "url": "https://github.com/opentripplanner/OpenTripPlanner/pull/2990#discussion_r393665997", "createdAt": "2020-03-17T13:09:49Z", "author": {"login": "t2gran"}, "path": "src/main/java/org/opentripplanner/graph_builder/module/ned/ElevationModule.java", "diffHunk": "@@ -80,55 +129,175 @@ public ElevationModule(ElevationGridCoverageFactory factory, double elevationUni\n     public List<String> getPrerequisites() {\n         return Arrays.asList(\"streets\");\n     }\n-    \n-    public void setGridCoverageFactory(ElevationGridCoverageFactory factory) {\n-        gridCoverageFactory = factory;\n-    }\n-\n-    public void setDistanceBetweenSamplesM(double distance) {\n-        distanceBetweenSamplesM = distance;\n-    }\n \n     @Override\n     public void buildGraph(Graph graph, HashMap<Class<?>, Object> extra) {\n-        gridCoverageFactory.setGraph(graph);\n-        Coverage gridCov = gridCoverageFactory.getGridCoverage();\n-\n-        // If gridCov is a GridCoverage2D, apply a bilinear interpolator. Otherwise, just use the\n-        // coverage as is (note: UnifiedGridCoverages created by NEDGridCoverageFactoryImpl handle\n-        // interpolation internally)\n-        coverage = (gridCov instanceof GridCoverage2D) ? Interpolator2D.create(\n-                (GridCoverage2D) gridCov, new InterpolationBilinear()) : gridCov;\n+        this.graph = graph;\n+        gridCoverageFactory.fetchData(graph);\n+\n+        // try to load in the cached elevation data\n+        if (readCachedElevations) {\n+            try {\n+                ObjectInputStream in = new ObjectInputStream(new FileInputStream(cachedElevationsFile));\n+                cachedElevations = (HashMap<String, PackedCoordinateSequence>) in.readObject();\n+                log.info(\"Cached elevation data loaded into memory!\");\n+            } catch (IOException | ClassNotFoundException e) {\n+                log.warn(graph.addBuilderAnnotation(new Graphwide(\n+                    String.format(\"Cached elevations file could not be read in due to error: %s!\", e.getMessage()))));\n+            }\n+        }\n         log.info(\"Setting street elevation profiles from digital elevation model...\");\n-        List<StreetEdge> edgesWithElevation = new ArrayList<StreetEdge>();\n-        int nProcessed = 0;\n-        int nTotal = graph.countEdges();\n+\n+        // Multithread elevation calculations\n+        ForkJoinPool forkJoinPool = new ForkJoinPool();\n+\n+        // For unknown reasons, the interpolation of heights at coordinates is a synchronized method in the commonly\n+        // used Interpolator2D class. Therefore, it is critical to use a dedicated Coverage instance for each thread to\n+        // avoid other threads waiting for a lock to be released on the Coverage instance. This concurrent HashMap will\n+        // store these thread-specific Coverage instances.\n+        ConcurrentHashMap<Long, Coverage> coveragesForThread = new ConcurrentHashMap<>();\n+\n+        // At first, set the totalElevationEdges to the total number of edges in the graph.\n+        totalElevationEdges = graph.countEdges();\n+        List<StreetWithElevationEdge> streetsWithElevationEdges = new LinkedList<>();\n         for (Vertex gv : graph.getVertices()) {\n             for (Edge ee : gv.getOutgoing()) {\n                 if (ee instanceof StreetWithElevationEdge) {\n-                    StreetWithElevationEdge edgeWithElevation = (StreetWithElevationEdge) ee;\n-                    processEdge(graph, edgeWithElevation);\n-                    if (edgeWithElevation.getElevationProfile() != null && !edgeWithElevation.isElevationFlattened()) {\n-                        edgesWithElevation.add(edgeWithElevation);\n-                    }\n-                    nProcessed += 1;\n-                    if (nProcessed % 50000 == 0) {\n-                        log.info(\"set elevation on {}/{} edges\", nProcessed, nTotal);\n-                        double failurePercentage = nPointsOutsideDEM / nPointsEvaluated * 100;\n-                        if (failurePercentage > 50) {\n-                            log.warn(\"Fetching elevation failed at {}/{} points ({}%)\",\n-                                    nPointsOutsideDEM, nPointsEvaluated, failurePercentage);\n-                            log.warn(\"Elevation is missing at a large number of points. DEM may be for the wrong region. \" +\n-                                    \"If it is unprojected, perhaps the axes are not in (longitude, latitude) order.\");\n-                        }\n-                    }\n+                    forkJoinPool.submit(new ProcessEdgeTask((StreetWithElevationEdge) ee, coveragesForThread));\n+                    streetsWithElevationEdges.add((StreetWithElevationEdge) ee);\n                 }\n             }\n         }\n+        // update this value to the now-known amount of edges that are StreetWithElevation edges\n+        totalElevationEdges = streetsWithElevationEdges.size();\n \n+        // shutdown the forkJoinPool and wait until all tasks are finished. If this takes longer than 1 day, give up.\n+        forkJoinPool.shutdown();\n+        try {\n+            forkJoinPool.awaitTermination(1, TimeUnit.DAYS);\n+        } catch (InterruptedException e) {\n+            log.warn(graph.addBuilderAnnotation(new Graphwide(\"Multi-threaded elevation calculations timed-out!\")));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7d44713a1ca574eff04c389edba2ebc02de29b04"}, "originalPosition": 236}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzY4ODQ0Mg==", "bodyText": "Do we want to continue here? I the system is set up to download these files I would prefer that ti failed hard - but this comes down to how you rig the OTP deployment and how often the download fails. I think it is ok to do this in OTP1, but in OTP2 the strategy so fare is to fail hard for critical errors - also things that relay on network communication.  One thing that makes this a bit more robust in OTP2 is that the street graph is build in a separate step - so the \"pipeline\" can fallback to an old street graph when building the transit data on top of it - it then is the responsibility of the pipeline, and not OTP any more.", "url": "https://github.com/opentripplanner/OpenTripPlanner/pull/2990#discussion_r393688442", "createdAt": "2020-03-17T13:43:47Z", "author": {"login": "t2gran"}, "path": "src/main/java/org/opentripplanner/graph_builder/module/ned/DegreeGridNEDTileSource.java", "diffHunk": "@@ -120,18 +119,10 @@ private File getPathToTile(int x, int y) {\n                 }\n                 ostream.close();\n                 istream.close();\n-            } catch (S3ServiceException e) {\n-                path.deleteOnExit();\n-                throw new RuntimeException(e);\n-            } catch (ServiceException e) {\n-                path.deleteOnExit();\n-                throw new RuntimeException(e);\n-            } catch (FileNotFoundException e) {\n-                path.deleteOnExit();\n-                throw new RuntimeException(e);\n-            } catch (IOException e) {\n+            } catch (ServiceException | IOException e) {\n+                log.error(\"Error downloading tile {}! Error: {}.\", key, e.getMessage());\n                 path.deleteOnExit();\n-                throw new RuntimeException(e);\n+                return null;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7d44713a1ca574eff04c389edba2ebc02de29b04"}, "originalPosition": 84}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzcxNjI2OQ==", "bodyText": "It looks like the coveragesForThread is a map for each Thread to store some \"data\", another way to achieve it would be to create a ForkJoinWorkerThreadFactory which return a special thread with this data set. Then the map can be removed and the data only visible to the \"correct\" thread.", "url": "https://github.com/opentripplanner/OpenTripPlanner/pull/2990#discussion_r393716269", "createdAt": "2020-03-17T14:23:05Z", "author": {"login": "t2gran"}, "path": "src/main/java/org/opentripplanner/graph_builder/module/ned/ElevationModule.java", "diffHunk": "@@ -80,55 +129,175 @@ public ElevationModule(ElevationGridCoverageFactory factory, double elevationUni\n     public List<String> getPrerequisites() {\n         return Arrays.asList(\"streets\");\n     }\n-    \n-    public void setGridCoverageFactory(ElevationGridCoverageFactory factory) {\n-        gridCoverageFactory = factory;\n-    }\n-\n-    public void setDistanceBetweenSamplesM(double distance) {\n-        distanceBetweenSamplesM = distance;\n-    }\n \n     @Override\n     public void buildGraph(Graph graph, HashMap<Class<?>, Object> extra) {\n-        gridCoverageFactory.setGraph(graph);\n-        Coverage gridCov = gridCoverageFactory.getGridCoverage();\n-\n-        // If gridCov is a GridCoverage2D, apply a bilinear interpolator. Otherwise, just use the\n-        // coverage as is (note: UnifiedGridCoverages created by NEDGridCoverageFactoryImpl handle\n-        // interpolation internally)\n-        coverage = (gridCov instanceof GridCoverage2D) ? Interpolator2D.create(\n-                (GridCoverage2D) gridCov, new InterpolationBilinear()) : gridCov;\n+        this.graph = graph;\n+        gridCoverageFactory.fetchData(graph);\n+\n+        // try to load in the cached elevation data\n+        if (readCachedElevations) {\n+            try {\n+                ObjectInputStream in = new ObjectInputStream(new FileInputStream(cachedElevationsFile));\n+                cachedElevations = (HashMap<String, PackedCoordinateSequence>) in.readObject();\n+                log.info(\"Cached elevation data loaded into memory!\");\n+            } catch (IOException | ClassNotFoundException e) {\n+                log.warn(graph.addBuilderAnnotation(new Graphwide(\n+                    String.format(\"Cached elevations file could not be read in due to error: %s!\", e.getMessage()))));\n+            }\n+        }\n         log.info(\"Setting street elevation profiles from digital elevation model...\");\n-        List<StreetEdge> edgesWithElevation = new ArrayList<StreetEdge>();\n-        int nProcessed = 0;\n-        int nTotal = graph.countEdges();\n+\n+        // Multithread elevation calculations\n+        ForkJoinPool forkJoinPool = new ForkJoinPool();\n+\n+        // For unknown reasons, the interpolation of heights at coordinates is a synchronized method in the commonly\n+        // used Interpolator2D class. Therefore, it is critical to use a dedicated Coverage instance for each thread to\n+        // avoid other threads waiting for a lock to be released on the Coverage instance. This concurrent HashMap will\n+        // store these thread-specific Coverage instances.\n+        ConcurrentHashMap<Long, Coverage> coveragesForThread = new ConcurrentHashMap<>();\n+\n+        // At first, set the totalElevationEdges to the total number of edges in the graph.\n+        totalElevationEdges = graph.countEdges();\n+        List<StreetWithElevationEdge> streetsWithElevationEdges = new LinkedList<>();\n         for (Vertex gv : graph.getVertices()) {\n             for (Edge ee : gv.getOutgoing()) {\n                 if (ee instanceof StreetWithElevationEdge) {\n-                    StreetWithElevationEdge edgeWithElevation = (StreetWithElevationEdge) ee;\n-                    processEdge(graph, edgeWithElevation);\n-                    if (edgeWithElevation.getElevationProfile() != null && !edgeWithElevation.isElevationFlattened()) {\n-                        edgesWithElevation.add(edgeWithElevation);\n-                    }\n-                    nProcessed += 1;\n-                    if (nProcessed % 50000 == 0) {\n-                        log.info(\"set elevation on {}/{} edges\", nProcessed, nTotal);\n-                        double failurePercentage = nPointsOutsideDEM / nPointsEvaluated * 100;\n-                        if (failurePercentage > 50) {\n-                            log.warn(\"Fetching elevation failed at {}/{} points ({}%)\",\n-                                    nPointsOutsideDEM, nPointsEvaluated, failurePercentage);\n-                            log.warn(\"Elevation is missing at a large number of points. DEM may be for the wrong region. \" +\n-                                    \"If it is unprojected, perhaps the axes are not in (longitude, latitude) order.\");\n-                        }\n-                    }\n+                    forkJoinPool.submit(new ProcessEdgeTask((StreetWithElevationEdge) ee, coveragesForThread));\n+                    streetsWithElevationEdges.add((StreetWithElevationEdge) ee);\n                 }\n             }\n         }\n+        // update this value to the now-known amount of edges that are StreetWithElevation edges\n+        totalElevationEdges = streetsWithElevationEdges.size();\n \n+        // shutdown the forkJoinPool and wait until all tasks are finished. If this takes longer than 1 day, give up.\n+        forkJoinPool.shutdown();\n+        try {\n+            forkJoinPool.awaitTermination(1, TimeUnit.DAYS);\n+        } catch (InterruptedException e) {\n+            log.warn(graph.addBuilderAnnotation(new Graphwide(\"Multi-threaded elevation calculations timed-out!\")));\n+        }\n+\n+        double failurePercentage = nPointsOutsideDEM.get() / nPointsEvaluated.get() * 100;\n+        if (failurePercentage > 50) {\n+            log.warn(graph.addBuilderAnnotation(new Graphwide(\n+                String.format(\n+                    \"Fetching elevation failed at %d/%d points (%d%%)\",\n+                    nPointsOutsideDEM, nPointsEvaluated, failurePercentage\n+                )\n+            )));\n+            log.warn(\"Elevation is missing at a large number of points. DEM may be for the wrong region. \" +\n+                \"If it is unprojected, perhaps the axes are not in (longitude, latitude) order.\");\n+        }\n+\n+        // iterate again to find edges that had elevation calculated. This is done here instead of in the forkJoinPool\n+        // to avoid thread locking for writes to a synchronized list\n+        LinkedList<StreetEdge> edgesWithCalculatedElevations = new LinkedList<>();\n+        for (StreetWithElevationEdge edgeWithElevation : streetsWithElevationEdges) {\n+            if (edgeWithElevation.hasPackedElevationProfile() && !edgeWithElevation.isElevationFlattened()) {\n+                edgesWithCalculatedElevations.add(edgeWithElevation);\n+            }\n+        }\n+\n+        if (writeCachedElevations) {\n+            // write information from edgesWithElevation to a new cache file for subsequent graph builds\n+            HashMap<String, PackedCoordinateSequence> newCachedElevations = new HashMap<>();\n+            for (StreetEdge streetEdge : edgesWithCalculatedElevations) {\n+                newCachedElevations.put(PolylineEncoder.createEncodings(streetEdge.getGeometry()).getPoints(),\n+                    streetEdge.getElevationProfile());\n+            }\n+            try {\n+                ObjectOutputStream out = new ObjectOutputStream(\n+                    new BufferedOutputStream(new FileOutputStream(cachedElevationsFile)));\n+                out.writeObject(newCachedElevations);\n+                out.close();\n+            } catch (IOException e) {\n+                log.error(e.getMessage());\n+                log.error(graph.addBuilderAnnotation(new Graphwide(\"Failed to write cached elevation file!\")));\n+            }\n+        }\n         @SuppressWarnings(\"unchecked\")\n         HashMap<Vertex, Double> extraElevation = (HashMap<Vertex, Double>) extra.get(ElevationPoint.class);\n-        assignMissingElevations(graph, edgesWithElevation, extraElevation);\n+        assignMissingElevations(graph, edgesWithCalculatedElevations, extraElevation);\n+    }\n+\n+    /**\n+     * A runnable that contains the relevant info for executing a process edge operation in a particular thread.\n+     */\n+    private class ProcessEdgeTask implements Runnable {\n+        private final StreetWithElevationEdge swee;\n+        private final ConcurrentHashMap<Long, Coverage> coveragesForThread;\n+\n+        public ProcessEdgeTask(StreetWithElevationEdge swee, ConcurrentHashMap<Long, Coverage> coveragesForThread) {\n+            this.swee = swee;\n+            this.coveragesForThread = coveragesForThread;\n+        }\n+\n+        @Override public void run() {\n+            // First, check if the edge already has been calculated or if it exists in a pre-calculated cache. Checking\n+            // with this method avoids potentially waiting for a lock to be released for calculating the thread-specific\n+            // coverage.\n+            boolean edgeNeedsProcessing = true;\n+            // Store the edge geometry in this block to avoid recalculating it twice if the edge needs a full elevation\n+            // calculation.\n+            Geometry edgeGeometry = null;\n+\n+            if (swee.hasPackedElevationProfile()) {\n+                edgeNeedsProcessing = false; /* already set up */\n+            } else {\n+                edgeGeometry = swee.getGeometry();\n+                // first try to find a cached value if possible\n+                if (cachedElevations != null) {\n+                    PackedCoordinateSequence coordinateSequence = cachedElevations.get(\n+                        PolylineEncoder.createEncodings(edgeGeometry).getPoints()\n+                    );\n+                    if (coordinateSequence != null) {\n+                        // found a cached value! Set the elevation profile with the pre-calculated data.\n+                        setEdgeElevationProfile(swee, coordinateSequence, graph);\n+                        edgeNeedsProcessing = false;\n+                    }\n+                }\n+            }\n+\n+            if (edgeNeedsProcessing) {\n+                // Needs full calculation. Calculate with a thread-specific coverage to avoid waiting for any locks on\n+                // coverage instances in other threads.\n+                processEdge(swee, edgeGeometry, getThreadSpecificCoverageInstance());\n+            }\n+            int curNumProcessed = nEdgesProcessed.addAndGet(1);\n+            if (curNumProcessed % 50000 == 0) {\n+                log.info(\"set elevation on {}/{} edges\", curNumProcessed, totalElevationEdges);\n+            }\n+        }\n+\n+        /**\n+         * Get the thread-specific Coverage instance to avoid multiple threads waiting for a lock to be released on a\n+         * Interpolator2D instance.\n+         */\n+        private Coverage getThreadSpecificCoverageInstance () {\n+            long currentThreadId = Thread.currentThread().getId();\n+            Coverage threadSpecificCoverage = coveragesForThread.get(currentThreadId);\n+            if (threadSpecificCoverage == null) {\n+                // Synchronize the creation of the Thread-specific Coverage instances to avoid potential locks that\n+                // could arise from downstream classes that have synchronized methods.\n+                synchronized (coveragesForThread) {\n+                    // Get a new Coverage instance from the module's ElevationGridCoverageFactory.\n+                    threadSpecificCoverage = gridCoverageFactory.getGridCoverage();\n+                    // The Coverage instance relies on some synchronized static methods shared across all threads that\n+                    // can cause deadlocks if not fully initialized. Therefore, make a single request for the first\n+                    // point on the edge to initialize these other items.\n+                    Coordinate firstEdgeCoord =  swee.getGeometry().getCoordinates()[0];\n+                    double[] dummy = new double[1];\n+                    threadSpecificCoverage.evaluate(\n+                        new DirectPosition2D(GeometryUtils.WGS84_XY, firstEdgeCoord.x, firstEdgeCoord.y),\n+                        dummy\n+                    );\n+                }\n+                coveragesForThread.put(currentThreadId, threadSpecificCoverage);\n+            }\n+            return threadSpecificCoverage;\n+        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7d44713a1ca574eff04c389edba2ebc02de29b04"}, "originalPosition": 358}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "78af1c50544bfe5e938e09d0b80cc079cfe54cfd", "author": {"user": {"login": "evansiroky", "name": "Evan Siroky"}}, "url": "https://github.com/opentripplanner/OpenTripPlanner/commit/78af1c50544bfe5e938e09d0b80cc079cfe54cfd", "committedDate": "2020-03-18T05:10:48Z", "message": "Move elevation cache code back into altered processEdge method"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3706b245e74e8b28ab169beeb89f7556842e9866", "author": {"user": {"login": "evansiroky", "name": "Evan Siroky"}}, "url": "https://github.com/opentripplanner/OpenTripPlanner/commit/3706b245e74e8b28ab169beeb89f7556842e9866", "committedDate": "2020-03-26T20:43:55Z", "message": "Refactor a few things\n\n- Use a custom ForkJOinWorkerThreadFactory\n- Some formatting improvments\n- Improve comments in various places."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1023d85bc80579c5284f0f914ad9c2f879bf8daa", "author": {"user": {"login": "evansiroky", "name": "Evan Siroky"}}, "url": "https://github.com/opentripplanner/OpenTripPlanner/commit/1023d85bc80579c5284f0f914ad9c2f879bf8daa", "committedDate": "2020-03-26T21:52:01Z", "message": "Improve some comments"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzgzMDA4MTM2", "url": "https://github.com/opentripplanner/OpenTripPlanner/pull/2990#pullrequestreview-383008136", "createdAt": "2020-03-27T16:20:20Z", "commit": {"oid": "3706b245e74e8b28ab169beeb89f7556842e9866"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yN1QxNjoyMDoyMFrOF84dDw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yN1QxNjoyMDoyMFrOF84dDw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTM4MzgyMw==", "bodyText": "Do the call to the evaluate method need to be called with the first coordinate from the swee or just any coordinate? If any coordinate will do it, then you could create the Coverage in the constructor and make the  threadSpecificCoverage final. Also, I think the synchronized can be dropped in that case, because the creation of a new Thread should be thread-safe.\nNote! The above code is NOT thread-safe you check the threadSpecificCoverage == null outside of the synchronized block and assign it inside.", "url": "https://github.com/opentripplanner/OpenTripPlanner/pull/2990#discussion_r399383823", "createdAt": "2020-03-27T16:20:20Z", "author": {"login": "t2gran"}, "path": "src/main/java/org/opentripplanner/graph_builder/module/ned/ElevationModule.java", "diffHunk": "@@ -222,22 +231,69 @@ public void buildGraph(Graph graph, HashMap<Class<?>, Object> extra) {\n         assignMissingElevations(graph, edgesWithCalculatedElevations, extraElevation);\n     }\n \n+    /**\n+     * A special extension of the Thread class so that a thread-specific coverage instance can be stored for each\n+     * thread.\n+     */\n+    private class ElevationWorkerThread extends ForkJoinWorkerThread {\n+        private Coverage threadSpecificCoverage;\n+\n+        /**\n+         * Creates a ForkJoinWorkerThread operating in the given pool.\n+         *\n+         * @param pool the pool this thread works in\n+         * @throws NullPointerException if pool is null\n+         */\n+        protected ElevationWorkerThread(ForkJoinPool pool) {\n+            super(pool);\n+        }\n+\n+        /**\n+         * For unknown reasons, the interpolation of heights at coordinates is a synchronized method in the commonly\n+         * used Interpolator2D class. Therefore, it is critical to use a dedicated Coverage instance for each thread to\n+         * avoid other threads waiting for a lock to be released on the Coverage instance. This concurrent HashMap will\n+         * store these thread-specific Coverage instances.\n+         *\n+         * @param swee An exemplar StreetWithElevationEdge to use to initialize a few calculations in the newly created\n+         *             coverage instance.\n+         * @return A thread-specific coverage instance that can be used without being locked from other threads.\n+         */\n+        public Coverage getThreadSpecificCoverageInstance (StreetWithElevationEdge swee) {\n+            if (threadSpecificCoverage == null) {\n+                // Synchronize the creation of the Thread-specific Coverage instances to avoid potential locks that\n+                // could arise from downstream classes that have synchronized methods.\n+                synchronized (gridCoverageFactory) {\n+                    // Get a new Coverage instance from the module's ElevationGridCoverageFactory.\n+                    threadSpecificCoverage = gridCoverageFactory.getGridCoverage();\n+                    // The Coverage instance relies on some synchronized static methods shared across all threads that\n+                    // can cause deadlocks if not fully initialized. Therefore, make a single request for the first\n+                    // point on the edge to initialize these other items.\n+                    Coordinate firstEdgeCoord =  swee.getGeometry().getCoordinates()[0];\n+                    double[] dummy = new double[1];\n+                    threadSpecificCoverage.evaluate(\n+                        new DirectPosition2D(GeometryUtils.WGS84_XY, firstEdgeCoord.x, firstEdgeCoord.y),\n+                        dummy\n+                    );\n+                }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3706b245e74e8b28ab169beeb89f7556842e9866"}, "originalPosition": 142}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6f4ec8a97d8f171552a6e1f5bba1f9e63c63b7d6", "author": {"user": {"login": "evansiroky", "name": "Evan Siroky"}}, "url": "https://github.com/opentripplanner/OpenTripPlanner/commit/6f4ec8a97d8f171552a6e1f5bba1f9e63c63b7d6", "committedDate": "2020-03-28T23:10:24Z", "message": "Refactor coverage creation to hopefully be thread-safe?"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzgzNzk3MTEz", "url": "https://github.com/opentripplanner/OpenTripPlanner/pull/2990#pullrequestreview-383797113", "createdAt": "2020-03-30T12:20:32Z", "commit": {"oid": "6f4ec8a97d8f171552a6e1f5bba1f9e63c63b7d6"}, "state": "COMMENTED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9baab1a51d54aa94b9031128b2ffc528d09836b3", "author": {"user": {"login": "evansiroky", "name": "Evan Siroky"}}, "url": "https://github.com/opentripplanner/OpenTripPlanner/commit/9baab1a51d54aa94b9031128b2ffc528d09836b3", "committedDate": "2020-03-30T21:26:07Z", "message": "Allow setting a custom amount of parallelism for the elevation module"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg0ODU0OTA4", "url": "https://github.com/opentripplanner/OpenTripPlanner/pull/2990#pullrequestreview-384854908", "createdAt": "2020-03-31T15:33:33Z", "commit": {"oid": "9baab1a51d54aa94b9031128b2ffc528d09836b3"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMVQxNTozMzozM1rOF-bthA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMVQxNTozMzozM1rOF-bthA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTAxMDA1Mg==", "bodyText": "Do you know if creating a ThreadPool with just 1 thread will lead to a performance overhead compared with just running the Tasks in the current thread?", "url": "https://github.com/opentripplanner/OpenTripPlanner/pull/2990#discussion_r401010052", "createdAt": "2020-03-31T15:33:33Z", "author": {"login": "t2gran"}, "path": "src/main/java/org/opentripplanner/graph_builder/module/ned/ElevationModule.java", "diffHunk": "@@ -161,7 +169,7 @@ public void buildGraph(Graph graph, HashMap<Class<?>, Object> extra) {\n \n         // Multithread elevation calculations\n         ForkJoinPool forkJoinPool = new ForkJoinPool(\n-            Runtime.getRuntime().availableProcessors(),\n+            parallelism,\n             forkJoinWorkerThreadFactory,\n             null,\n             false", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9baab1a51d54aa94b9031128b2ffc528d09836b3"}, "originalPosition": 48}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ccaf305869662ec72b6dd163cf929f6ae82d534f", "author": {"user": {"login": "evansiroky", "name": "Evan Siroky"}}, "url": "https://github.com/opentripplanner/OpenTripPlanner/commit/ccaf305869662ec72b6dd163cf929f6ae82d534f", "committedDate": "2020-04-03T02:26:25Z", "message": "Only use multithreaded elevation items when multithreading"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "23adacfea3420b39ef1fa6fe2dfc342ecd70aa03", "author": {"user": {"login": "evansiroky", "name": "Evan Siroky"}}, "url": "https://github.com/opentripplanner/OpenTripPlanner/commit/23adacfea3420b39ef1fa6fe2dfc342ecd70aa03", "committedDate": "2020-04-03T02:26:47Z", "message": "Make the default amount of processors for the ElevationModule be 1"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2ce9a89eee5101f83b8c8e45f8d37002c2aa234d", "author": {"user": {"login": "evansiroky", "name": "Evan Siroky"}}, "url": "https://github.com/opentripplanner/OpenTripPlanner/commit/2ce9a89eee5101f83b8c8e45f8d37002c2aa234d", "committedDate": "2020-04-03T02:26:54Z", "message": "Improve comments and docs"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5c61fc71d3484c6f9760bd54ab59cd36211b846a", "author": {"user": {"login": "evansiroky", "name": "Evan Siroky"}}, "url": "https://github.com/opentripplanner/OpenTripPlanner/commit/5c61fc71d3484c6f9760bd54ab59cd36211b846a", "committedDate": "2020-04-03T02:38:04Z", "message": "Correct default elevationModuleParallelism value in build parameter table"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6d3003677dea09cba9b0d4d5b9b832904809749e", "author": {"user": {"login": "evansiroky", "name": "Evan Siroky"}}, "url": "https://github.com/opentripplanner/OpenTripPlanner/commit/6d3003677dea09cba9b0d4d5b9b832904809749e", "committedDate": "2020-04-03T03:11:33Z", "message": "Add a GraphWide annotation for failed elevation tile downloads"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg2MjcyMTE3", "url": "https://github.com/opentripplanner/OpenTripPlanner/pull/2990#pullrequestreview-386272117", "createdAt": "2020-04-02T09:52:27Z", "commit": {"oid": "9baab1a51d54aa94b9031128b2ffc528d09836b3"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMlQwOTo1MjoyN1rOF_jwbw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMlQwOTo1Nzo1NFrOF_j9xw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjE5MDQ0Nw==", "bodyText": "I think it's acceptable to continue after an exception if we distinguish between network failures / server errors (where we don't know whether the tile exists) and successful communication indicating there is no tile. So I think we should keep separate catch clauses, and fail hard or retry on exceptions representing communication/server failures, while soft-failing (continuing) on exceptions representing successful communication that a file is not present on the remote server.", "url": "https://github.com/opentripplanner/OpenTripPlanner/pull/2990#discussion_r402190447", "createdAt": "2020-04-02T09:52:27Z", "author": {"login": "abyrd"}, "path": "src/main/java/org/opentripplanner/graph_builder/module/ned/DegreeGridNEDTileSource.java", "diffHunk": "@@ -120,18 +119,10 @@ private File getPathToTile(int x, int y) {\n                 }\n                 ostream.close();\n                 istream.close();\n-            } catch (S3ServiceException e) {\n-                path.deleteOnExit();\n-                throw new RuntimeException(e);\n-            } catch (ServiceException e) {\n-                path.deleteOnExit();\n-                throw new RuntimeException(e);\n-            } catch (FileNotFoundException e) {\n-                path.deleteOnExit();\n-                throw new RuntimeException(e);\n-            } catch (IOException e) {\n+            } catch (ServiceException | IOException e) {\n+                log.error(\"Error downloading tile {}! Error: {}.\", key, e.getMessage());\n                 path.deleteOnExit();\n-                throw new RuntimeException(e);\n+                return null;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzY4ODQ0Mg=="}, "originalCommit": {"oid": "7d44713a1ca574eff04c389edba2ebc02de29b04"}, "originalPosition": 84}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjE5Mzg2Mw==", "bodyText": "The key for the cache entries is only the edge geometry (one of the calculation inputs), without the corresponding elevation cells (the other calculation input). So the cache will detect new or changed streets, but not new or changed elevation. Storing or hashing the local elevation data around each edge would get very complex, and elevation data changes rarely, so it's probably not worth implementing this. It would be nice though to invalidate the entire elevation profile cache if the elevation input changes. This could probably be accomplished by naming the cache file (or storing in the cache file) a hash of all the elevation input data. But if that's being fetched over a network maybe it's impossible to hash the entire data set.", "url": "https://github.com/opentripplanner/OpenTripPlanner/pull/2990#discussion_r402193863", "createdAt": "2020-04-02T09:57:54Z", "author": {"login": "abyrd"}, "path": "src/main/java/org/opentripplanner/graph_builder/module/ned/ElevationModule.java", "diffHunk": "@@ -80,55 +146,176 @@ public ElevationModule(ElevationGridCoverageFactory factory, double elevationUni\n     public List<String> getPrerequisites() {\n         return Arrays.asList(\"streets\");\n     }\n-    \n-    public void setGridCoverageFactory(ElevationGridCoverageFactory factory) {\n-        gridCoverageFactory = factory;\n-    }\n-\n-    public void setDistanceBetweenSamplesM(double distance) {\n-        distanceBetweenSamplesM = distance;\n-    }\n \n     @Override\n     public void buildGraph(Graph graph, HashMap<Class<?>, Object> extra) {\n-        gridCoverageFactory.setGraph(graph);\n-        Coverage gridCov = gridCoverageFactory.getGridCoverage();\n-\n-        // If gridCov is a GridCoverage2D, apply a bilinear interpolator. Otherwise, just use the\n-        // coverage as is (note: UnifiedGridCoverages created by NEDGridCoverageFactoryImpl handle\n-        // interpolation internally)\n-        coverage = (gridCov instanceof GridCoverage2D) ? Interpolator2D.create(\n-                (GridCoverage2D) gridCov, new InterpolationBilinear()) : gridCov;\n+        this.graph = graph;\n+        gridCoverageFactory.fetchData(graph);\n+\n+        // try to load in the cached elevation data\n+        if (readCachedElevations) {\n+            try {\n+                ObjectInputStream in = new ObjectInputStream(new FileInputStream(cachedElevationsFile));\n+                cachedElevations = (HashMap<String, PackedCoordinateSequence>) in.readObject();\n+                log.info(\"Cached elevation data loaded into memory!\");\n+            } catch (IOException | ClassNotFoundException e) {\n+                log.warn(graph.addBuilderAnnotation(new Graphwide(\n+                    String.format(\"Cached elevations file could not be read in due to error: %s!\", e.getMessage()))));\n+            }\n+        }\n         log.info(\"Setting street elevation profiles from digital elevation model...\");\n-        List<StreetEdge> edgesWithElevation = new ArrayList<StreetEdge>();\n-        int nProcessed = 0;\n-        int nTotal = graph.countEdges();\n+\n+        ForkJoinPool.ForkJoinWorkerThreadFactory forkJoinWorkerThreadFactory = pool -> new ElevationWorkerThread(pool);\n+\n+        // Multithread elevation calculations\n+        ForkJoinPool forkJoinPool = new ForkJoinPool(\n+            parallelism,\n+            forkJoinWorkerThreadFactory,\n+            null,\n+            false\n+        );\n+\n+        // At first, set the totalElevationEdges to the total number of edges in the graph.\n+        totalElevationEdges = graph.countEdges();\n+        List<StreetWithElevationEdge> streetsWithElevationEdges = new LinkedList<>();\n         for (Vertex gv : graph.getVertices()) {\n             for (Edge ee : gv.getOutgoing()) {\n                 if (ee instanceof StreetWithElevationEdge) {\n-                    StreetWithElevationEdge edgeWithElevation = (StreetWithElevationEdge) ee;\n-                    processEdge(graph, edgeWithElevation);\n-                    if (edgeWithElevation.getElevationProfile() != null && !edgeWithElevation.isElevationFlattened()) {\n-                        edgesWithElevation.add(edgeWithElevation);\n-                    }\n-                    nProcessed += 1;\n-                    if (nProcessed % 50000 == 0) {\n-                        log.info(\"set elevation on {}/{} edges\", nProcessed, nTotal);\n-                        double failurePercentage = nPointsOutsideDEM / nPointsEvaluated * 100;\n-                        if (failurePercentage > 50) {\n-                            log.warn(\"Fetching elevation failed at {}/{} points ({}%)\",\n-                                    nPointsOutsideDEM, nPointsEvaluated, failurePercentage);\n-                            log.warn(\"Elevation is missing at a large number of points. DEM may be for the wrong region. \" +\n-                                    \"If it is unprojected, perhaps the axes are not in (longitude, latitude) order.\");\n-                        }\n-                    }\n+                    forkJoinPool.submit(new ProcessEdgeTask((StreetWithElevationEdge) ee));\n+                    streetsWithElevationEdges.add((StreetWithElevationEdge) ee);\n                 }\n             }\n         }\n+        // update this value to the now-known amount of edges that are StreetWithElevation edges\n+        totalElevationEdges = streetsWithElevationEdges.size();\n+\n+        // store the first coordinate of the first StreetEdge for later use ininitializing coverage instances\n+        examplarCoordinate = streetsWithElevationEdges.get(0).getGeometry().getCoordinates()[0];\n+\n+        // shutdown the forkJoinPool and wait until all tasks are finished. If this takes longer than 1 day, give up.\n+        forkJoinPool.shutdown();\n+        try {\n+            forkJoinPool.awaitTermination(1, TimeUnit.DAYS);\n+        } catch (InterruptedException ex) {\n+            log.error(\"Multi-threaded elevation calculations timed-out!\");\n+            Thread.currentThread().interrupt();\n+            throw new RuntimeException(ex);\n+        }\n+\n+        double failurePercentage = nPointsOutsideDEM.get() / nPointsEvaluated.get() * 100;\n+        if (failurePercentage > 50) {\n+            log.warn(graph.addBuilderAnnotation(new Graphwide(\n+                String.format(\n+                    \"Fetching elevation failed at %d/%d points (%d%%)\",\n+                    nPointsOutsideDEM, nPointsEvaluated, failurePercentage\n+                )\n+            )));\n+            log.warn(\"Elevation is missing at a large number of points. DEM may be for the wrong region. \" +\n+                \"If it is unprojected, perhaps the axes are not in (longitude, latitude) order.\");\n+        }\n+\n+        // iterate again to find edges that had elevation calculated. This is done here instead of in the forkJoinPool\n+        // to avoid thread locking for writes to a synchronized list\n+        LinkedList<StreetEdge> edgesWithCalculatedElevations = new LinkedList<>();\n+        for (StreetWithElevationEdge edgeWithElevation : streetsWithElevationEdges) {\n+            if (edgeWithElevation.hasPackedElevationProfile() && !edgeWithElevation.isElevationFlattened()) {\n+                edgesWithCalculatedElevations.add(edgeWithElevation);\n+            }\n+        }\n \n+        if (writeCachedElevations) {\n+            // write information from edgesWithElevation to a new cache file for subsequent graph builds\n+            HashMap<String, PackedCoordinateSequence> newCachedElevations = new HashMap<>();\n+            for (StreetEdge streetEdge : edgesWithCalculatedElevations) {\n+                newCachedElevations.put(PolylineEncoder.createEncodings(streetEdge.getGeometry()).getPoints(),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9baab1a51d54aa94b9031128b2ffc528d09836b3"}, "originalPosition": 285}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0855b9baab41dfb081e86ea5915bda7c0948349a", "author": {"user": {"login": "evansiroky", "name": "Evan Siroky"}}, "url": "https://github.com/opentripplanner/OpenTripPlanner/commit/0855b9baab41dfb081e86ea5915bda7c0948349a", "committedDate": "2020-04-05T01:00:24Z", "message": "Various improvements to elevation module\n\n- Add comment about validity of cached elevations based on input data\n- Go back to failing hard when downloading NED tiles except for when a tile is missing in the s3 bucket\n- Refactor so that Geotiff files are only loaded into GridCoverage2D instances once, but use multiple Interpolator2D instances"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "af4130ce07473385c227e5241ee988cc6eb16af5", "author": {"user": {"login": "evansiroky", "name": "Evan Siroky"}}, "url": "https://github.com/opentripplanner/OpenTripPlanner/commit/af4130ce07473385c227e5241ee988cc6eb16af5", "committedDate": "2020-04-08T06:41:16Z", "message": "Add EllipsoidToGeoidDifference for known elevations in OSM"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d9ec8cbd174a838776bb4fe017b4d8e5c8635063", "author": {"user": {"login": "evansiroky", "name": "Evan Siroky"}}, "url": "https://github.com/opentripplanner/OpenTripPlanner/commit/d9ec8cbd174a838776bb4fe017b4d8e5c8635063", "committedDate": "2020-04-19T07:11:58Z", "message": "Add various improvements\n\n- Make NEDGridCoverageFactory return a UnifiedGridCoverage with thread-specific interpolators\n- Use thread local variables instead of fork/join pool in ElevationModule\n- Make generic multi-threaded parameter for elevation module"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA5MDY0ODYy", "url": "https://github.com/opentripplanner/OpenTripPlanner/pull/2990#pullrequestreview-409064862", "createdAt": "2020-05-11T10:51:59Z", "commit": {"oid": "d9ec8cbd174a838776bb4fe017b4d8e5c8635063"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2067, "cost": 1, "resetAt": "2021-11-01T15:33:45Z"}}}