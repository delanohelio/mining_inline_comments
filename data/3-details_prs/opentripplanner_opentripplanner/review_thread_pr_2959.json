{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzcxNDI2NjI0", "number": 2959, "reviewThreads": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMlQxMDoxNDo0NFrODfHo_A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMlQxMDoyODo0MVrODfH73Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMzOTU3NjI4OnYy", "diffSide": "RIGHT", "path": "src/main/java/org/opentripplanner/model/TimetableSnapshot.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMlQxMDoxNDo0NFrOFooygw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMlQxMDoxNDo0NFrOFooygw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODE1NTY1MQ==", "bodyText": "This conditional is probably not necessary, even from a performance point of view. The meaning might be clearer with only the put() call and no conditional.", "url": "https://github.com/opentripplanner/OpenTripPlanner/pull/2959#discussion_r378155651", "createdAt": "2020-02-12T10:14:44Z", "author": {"login": "abyrd"}, "path": "src/main/java/org/opentripplanner/model/TimetableSnapshot.java", "diffHunk": "@@ -369,4 +385,19 @@ public String toString() {\n         return timetables.keySet();\n     }\n \n+    private void addPatternToIndex(TripPattern tripPattern) {\n+        for (Stop stop: tripPattern.getStops()) {\n+            if (!patternsForStop.containsEntry(stop, tripPattern)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c4997dfb54cb1fca24fd6c148f86e658c463bd03"}, "originalPosition": 50}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMzOTYyNDYxOnYy", "diffSide": "RIGHT", "path": "src/main/java/org/opentripplanner/routing/graph/GraphIndex.java", "isResolved": false, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMlQxMDoyODo0MVrOFopQnQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xNFQxMDoyNTowM1rOFpyBDg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODE2MzM1Nw==", "bodyText": "We just discussed the fact that this is getting a snapshot within a single small method. Snapshots are intended to be held and reused throughout a full request cycle. So methods like this should really be on the snapshot (or applied to a snapshot) rather than applied to the Graph or GraphIndex. The problem is that GraphIndex contains both an index of the essentially immutable data in a Graph, plus a bunch of methods that produce API responses that happen to use that index. But those methods also examine things like realtime data. Really, those API methods should be outside GraphIndex, and they should have a reference to a realtime snapshot, which in turn gives access to an underlying long-lived Graph and GraphIndex.", "url": "https://github.com/opentripplanner/OpenTripPlanner/pull/2959#discussion_r378163357", "createdAt": "2020-02-12T10:28:41Z", "author": {"login": "abyrd"}, "path": "src/main/java/org/opentripplanner/routing/graph/GraphIndex.java", "diffHunk": "@@ -434,14 +436,19 @@ public BitSet servicesRunning (LocalDate date) {\n         return ret;\n     }\n \n-    // TODO OTP2 - Add support for includeRealtimeUpdates\n+    /**\n+     * Returns all the patterns for a specific stop. If includeRealtimeUpdates is set, new patterns\n+     * added by realtime updates are added to the collection.\n+     */\n     public Collection<TripPattern> getPatternsForStop(Stop stop, boolean includeRealtimeUpdates) {\n         List<TripPattern> tripPatterns = new ArrayList<>(patternsForStop.get(stop));\n-        /*\n-        if (includeRealtimeUpdates && graph.timetableSnapshotSource != null) {\n-            tripPatterns.addAll(graph.timetableSnapshotSource.getAddedTripPatternsForStop(stop));\n+\n+        TimetableSnapshot timetableSnapshot = graph.getTimetableSnapshot();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c4997dfb54cb1fca24fd6c148f86e658c463bd03"}, "originalPosition": 37}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODE2ODUxOQ==", "bodyText": "We discussed further - this will work in a loose sense, but it defies some of our assumptions. This method getPatternsForStop is called in many places, various small methods within a GraphQL query. This means a single GraphQL query could fetch different snapshots. It will be easier to reason about this, and to describe behavior to API clients, if we can state concisely that every request always sees exactly one snapshot. There are also performance implications, since the snapshot provider only expects to be called once per request, so may have some slightly time-consuming side effects that amount to committing a transaction.", "url": "https://github.com/opentripplanner/OpenTripPlanner/pull/2959#discussion_r378168519", "createdAt": "2020-02-12T10:38:24Z", "author": {"login": "abyrd"}, "path": "src/main/java/org/opentripplanner/routing/graph/GraphIndex.java", "diffHunk": "@@ -434,14 +436,19 @@ public BitSet servicesRunning (LocalDate date) {\n         return ret;\n     }\n \n-    // TODO OTP2 - Add support for includeRealtimeUpdates\n+    /**\n+     * Returns all the patterns for a specific stop. If includeRealtimeUpdates is set, new patterns\n+     * added by realtime updates are added to the collection.\n+     */\n     public Collection<TripPattern> getPatternsForStop(Stop stop, boolean includeRealtimeUpdates) {\n         List<TripPattern> tripPatterns = new ArrayList<>(patternsForStop.get(stop));\n-        /*\n-        if (includeRealtimeUpdates && graph.timetableSnapshotSource != null) {\n-            tripPatterns.addAll(graph.timetableSnapshotSource.getAddedTripPatternsForStop(stop));\n+\n+        TimetableSnapshot timetableSnapshot = graph.getTimetableSnapshot();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODE2MzM1Nw=="}, "originalCommit": {"oid": "c4997dfb54cb1fca24fd6c148f86e658c463bd03"}, "originalPosition": 37}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODQ5OTE4Mg==", "bodyText": "I had a look at this to see if we could refactor to make it better. Gard will try do the following:\nExtract a fasade out of the GraphIndex and Graph (lets call it RoutingService). The RoutingService should be the entry point for all access to all logic in the routing java package (from outside of the package). Put it on in the org.opentripplanner.routing package.. We can let the routing service have a request scope and delegate to the GraphIndex and Graph. Some of the methods in the Graph and Index should be moved where they belong. The RoutingService will have a lazy getter to the TimeTableSnapshot and inject this instance where needed. The APIs should get one RoutingService and use it for the duration of each request. The RoutingService would be a stateful service. It should contain a minimum of logic, delegating other parts of the routing package like the GraphIndex and Graph.", "url": "https://github.com/opentripplanner/OpenTripPlanner/pull/2959#discussion_r378499182", "createdAt": "2020-02-12T20:38:16Z", "author": {"login": "t2gran"}, "path": "src/main/java/org/opentripplanner/routing/graph/GraphIndex.java", "diffHunk": "@@ -434,14 +436,19 @@ public BitSet servicesRunning (LocalDate date) {\n         return ret;\n     }\n \n-    // TODO OTP2 - Add support for includeRealtimeUpdates\n+    /**\n+     * Returns all the patterns for a specific stop. If includeRealtimeUpdates is set, new patterns\n+     * added by realtime updates are added to the collection.\n+     */\n     public Collection<TripPattern> getPatternsForStop(Stop stop, boolean includeRealtimeUpdates) {\n         List<TripPattern> tripPatterns = new ArrayList<>(patternsForStop.get(stop));\n-        /*\n-        if (includeRealtimeUpdates && graph.timetableSnapshotSource != null) {\n-            tripPatterns.addAll(graph.timetableSnapshotSource.getAddedTripPatternsForStop(stop));\n+\n+        TimetableSnapshot timetableSnapshot = graph.getTimetableSnapshot();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODE2MzM1Nw=="}, "originalCommit": {"oid": "c4997dfb54cb1fca24fd6c148f86e658c463bd03"}, "originalPosition": 37}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTM1NTQwNg==", "bodyText": "We will try to use the Lombok library @Delegate to make this a true Facade.", "url": "https://github.com/opentripplanner/OpenTripPlanner/pull/2959#discussion_r379355406", "createdAt": "2020-02-14T10:25:03Z", "author": {"login": "t2gran"}, "path": "src/main/java/org/opentripplanner/routing/graph/GraphIndex.java", "diffHunk": "@@ -434,14 +436,19 @@ public BitSet servicesRunning (LocalDate date) {\n         return ret;\n     }\n \n-    // TODO OTP2 - Add support for includeRealtimeUpdates\n+    /**\n+     * Returns all the patterns for a specific stop. If includeRealtimeUpdates is set, new patterns\n+     * added by realtime updates are added to the collection.\n+     */\n     public Collection<TripPattern> getPatternsForStop(Stop stop, boolean includeRealtimeUpdates) {\n         List<TripPattern> tripPatterns = new ArrayList<>(patternsForStop.get(stop));\n-        /*\n-        if (includeRealtimeUpdates && graph.timetableSnapshotSource != null) {\n-            tripPatterns.addAll(graph.timetableSnapshotSource.getAddedTripPatternsForStop(stop));\n+\n+        TimetableSnapshot timetableSnapshot = graph.getTimetableSnapshot();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODE2MzM1Nw=="}, "originalCommit": {"oid": "c4997dfb54cb1fca24fd6c148f86e658c463bd03"}, "originalPosition": 37}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1898, "cost": 1, "resetAt": "2021-11-13T12:10:21Z"}}}