{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzgxMTI0OTg2", "number": 2990, "reviewThreads": {"totalCount": 11, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wM1QxNDoxNjozNFrODkqt2w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMlQwOTo1Nzo1NFrODt4bhw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM5Nzc1MTk1OnYy", "diffSide": "RIGHT", "path": "docs/Configuration.md", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wM1QxNDoxNjozNFrOFxHeKQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yN1QxNDozMzo1OFrOF8z3IQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzA0Njk1Mw==", "bodyText": "If the cache is writable, it should be possible to have a accessed flag, and skip entries NOT accessed in the current build. I might add that if I port this to OTP2.", "url": "https://github.com/opentripplanner/OpenTripPlanner/pull/2990#discussion_r387046953", "createdAt": "2020-03-03T14:16:34Z", "author": {"login": "t2gran"}, "path": "docs/Configuration.md", "diffHunk": "@@ -230,6 +232,29 @@ it is possible to define a multiplier that converts the elevation values from so\n }\n ```\n \n+### Elevation Data Calculation Optimizations\n+\n+Calculating elevations on all StreetEdges can take a dramatically long time. In a very large graph build for multiple Northeast US states, the time it took to download the elevation data and calculate all of the elevations took 5,509 seconds (roughly 1.5 hours).\n+\n+If you are using cloud computing for your OTP instances, it is recommended to create prebuilt images that contain the elevation data you need. This will save time because all of the data won't need to be downloaded.\n+\n+However, the bulk of the time will still spent calculating elevations for all of the street edges. Therefore, a further optimazation can be done to calculate and save the elevation data during a graph build and then save it for future use.\n+\n+In order to write out the precalculated elevation data, add this to your `build-config.json` file:\n+\n+```JSON\n+// build-config.json\n+{  \n+  \"writeCachedElevations\": true\n+}\n+```\n+\n+After building the graph, a file called `cached_elevations.obj` will be written to the cache directory. By default, this file is not written during graph builds. There is also a graph build parameter called `readCachedElevations` which is set to `true` by default.\n+\n+In graph builds, the elevation module will attempt to read the `cached_elevations.obj` file from the cache directory. The cache directory defaults to `/var/otp/cache`, but this can be overriden via the CLI argument `--cache <directory>`. For the same graph build for multiple Northeast US states, the time it took with using this predownloaded and precalculated data became 543.7 seconds (roughly 9 minutes).\n+\n+The cached data is a lookup table where the coordinate sequences of respective street edges are used as keys for calculated data. Therefore, it is expected that over time various edits to OpenStreetMap will cause this cached data to become stale and not include new OSM ways. Therefore, periodic update of this cached data is recommended.\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c564b0ad2df98f2bb7bc49288973967578a8f697"}, "originalPosition": 35}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODg2ODAyMA==", "bodyText": "I don't understand what you mean by accessed flag. The elevation cache is only read from. If the writeCachedElevations build parameter is set, then a new map is created and written to a file.", "url": "https://github.com/opentripplanner/OpenTripPlanner/pull/2990#discussion_r398868020", "createdAt": "2020-03-26T20:24:12Z", "author": {"login": "evansiroky"}, "path": "docs/Configuration.md", "diffHunk": "@@ -230,6 +232,29 @@ it is possible to define a multiplier that converts the elevation values from so\n }\n ```\n \n+### Elevation Data Calculation Optimizations\n+\n+Calculating elevations on all StreetEdges can take a dramatically long time. In a very large graph build for multiple Northeast US states, the time it took to download the elevation data and calculate all of the elevations took 5,509 seconds (roughly 1.5 hours).\n+\n+If you are using cloud computing for your OTP instances, it is recommended to create prebuilt images that contain the elevation data you need. This will save time because all of the data won't need to be downloaded.\n+\n+However, the bulk of the time will still spent calculating elevations for all of the street edges. Therefore, a further optimazation can be done to calculate and save the elevation data during a graph build and then save it for future use.\n+\n+In order to write out the precalculated elevation data, add this to your `build-config.json` file:\n+\n+```JSON\n+// build-config.json\n+{  \n+  \"writeCachedElevations\": true\n+}\n+```\n+\n+After building the graph, a file called `cached_elevations.obj` will be written to the cache directory. By default, this file is not written during graph builds. There is also a graph build parameter called `readCachedElevations` which is set to `true` by default.\n+\n+In graph builds, the elevation module will attempt to read the `cached_elevations.obj` file from the cache directory. The cache directory defaults to `/var/otp/cache`, but this can be overriden via the CLI argument `--cache <directory>`. For the same graph build for multiple Northeast US states, the time it took with using this predownloaded and precalculated data became 543.7 seconds (roughly 9 minutes).\n+\n+The cached data is a lookup table where the coordinate sequences of respective street edges are used as keys for calculated data. Therefore, it is expected that over time various edits to OpenStreetMap will cause this cached data to become stale and not include new OSM ways. Therefore, periodic update of this cached data is recommended.\n+", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzA0Njk1Mw=="}, "originalCommit": {"oid": "c564b0ad2df98f2bb7bc49288973967578a8f697"}, "originalPosition": 35}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTMwODU3Nw==", "bodyText": "Ok, that would have the same effect. Keep it like it is, then.", "url": "https://github.com/opentripplanner/OpenTripPlanner/pull/2990#discussion_r399308577", "createdAt": "2020-03-27T14:33:58Z", "author": {"login": "t2gran"}, "path": "docs/Configuration.md", "diffHunk": "@@ -230,6 +232,29 @@ it is possible to define a multiplier that converts the elevation values from so\n }\n ```\n \n+### Elevation Data Calculation Optimizations\n+\n+Calculating elevations on all StreetEdges can take a dramatically long time. In a very large graph build for multiple Northeast US states, the time it took to download the elevation data and calculate all of the elevations took 5,509 seconds (roughly 1.5 hours).\n+\n+If you are using cloud computing for your OTP instances, it is recommended to create prebuilt images that contain the elevation data you need. This will save time because all of the data won't need to be downloaded.\n+\n+However, the bulk of the time will still spent calculating elevations for all of the street edges. Therefore, a further optimazation can be done to calculate and save the elevation data during a graph build and then save it for future use.\n+\n+In order to write out the precalculated elevation data, add this to your `build-config.json` file:\n+\n+```JSON\n+// build-config.json\n+{  \n+  \"writeCachedElevations\": true\n+}\n+```\n+\n+After building the graph, a file called `cached_elevations.obj` will be written to the cache directory. By default, this file is not written during graph builds. There is also a graph build parameter called `readCachedElevations` which is set to `true` by default.\n+\n+In graph builds, the elevation module will attempt to read the `cached_elevations.obj` file from the cache directory. The cache directory defaults to `/var/otp/cache`, but this can be overriden via the CLI argument `--cache <directory>`. For the same graph build for multiple Northeast US states, the time it took with using this predownloaded and precalculated data became 543.7 seconds (roughly 9 minutes).\n+\n+The cached data is a lookup table where the coordinate sequences of respective street edges are used as keys for calculated data. Therefore, it is expected that over time various edits to OpenStreetMap will cause this cached data to become stale and not include new OSM ways. Therefore, periodic update of this cached data is recommended.\n+", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzA0Njk1Mw=="}, "originalCommit": {"oid": "c564b0ad2df98f2bb7bc49288973967578a8f697"}, "originalPosition": 35}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM5Nzc3OTg4OnYy", "diffSide": "RIGHT", "path": "src/main/java/org/opentripplanner/graph_builder/module/ned/ElevationModule.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wM1QxNDoyMzoxMFrOFxHvZw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wM1QxNDoyMzoxMFrOFxHvZw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzA1MTM2Nw==", "bodyText": "Tip, personally I like to write big number like this 50_000, it is a bit easier to read.", "url": "https://github.com/opentripplanner/OpenTripPlanner/pull/2990#discussion_r387051367", "createdAt": "2020-03-03T14:23:10Z", "author": {"login": "t2gran"}, "path": "src/main/java/org/opentripplanner/graph_builder/module/ned/ElevationModule.java", "diffHunk": "@@ -99,33 +131,83 @@ public void buildGraph(Graph graph, HashMap<Class<?>, Object> extra) {\n         // interpolation internally)\n         coverage = (gridCov instanceof GridCoverage2D) ? Interpolator2D.create(\n                 (GridCoverage2D) gridCov, new InterpolationBilinear()) : gridCov;\n+        try {\n+            transformer = CRS.findMathTransform(\n+                GeometryUtils.WGS84_XY,\n+                coverage.getCoordinateReferenceSystem(),\n+                true\n+            );\n+        } catch (FactoryException e) {\n+            log.error(\"Could not find an appropriate transformer!\");\n+            throw new RuntimeException(e);\n+        }\n+\n+        // try to load in the cached elevation data\n+        if (readCachedElevations) {\n+            try {\n+                ObjectInputStream in = new ObjectInputStream(new FileInputStream(cachedElevationsFile));\n+                cachedElevations = (HashMap<String, PackedCoordinateSequence>) in.readObject();\n+                log.info(\"Cached elevation data loaded into memory!\");\n+            } catch (IOException | ClassNotFoundException e) {\n+                log.warn(graph.addBuilderAnnotation(new Graphwide(\n+                    String.format(\"Cached elevations file could not be read in due to error: %s!\", e.getMessage()))));\n+            }\n+        }\n         log.info(\"Setting street elevation profiles from digital elevation model...\");\n-        List<StreetEdge> edgesWithElevation = new ArrayList<StreetEdge>();\n-        int nProcessed = 0;\n-        int nTotal = graph.countEdges();\n+\n+        List<StreetEdge> edgesWithElevation = Collections.synchronizedList(new ArrayList<>());\n+        AtomicInteger nProcessed = new AtomicInteger();\n+\n+        List<StreetWithElevationEdge> edgesToCalculate = new ArrayList<>();\n         for (Vertex gv : graph.getVertices()) {\n             for (Edge ee : gv.getOutgoing()) {\n                 if (ee instanceof StreetWithElevationEdge) {\n-                    StreetWithElevationEdge edgeWithElevation = (StreetWithElevationEdge) ee;\n-                    processEdge(graph, edgeWithElevation);\n-                    if (edgeWithElevation.getElevationProfile() != null && !edgeWithElevation.isElevationFlattened()) {\n-                        edgesWithElevation.add(edgeWithElevation);\n-                    }\n-                    nProcessed += 1;\n-                    if (nProcessed % 50000 == 0) {\n-                        log.info(\"set elevation on {}/{} edges\", nProcessed, nTotal);\n-                        double failurePercentage = nPointsOutsideDEM / nPointsEvaluated * 100;\n-                        if (failurePercentage > 50) {\n-                            log.warn(\"Fetching elevation failed at {}/{} points ({}%)\",\n-                                    nPointsOutsideDEM, nPointsEvaluated, failurePercentage);\n-                            log.warn(\"Elevation is missing at a large number of points. DEM may be for the wrong region. \" +\n-                                    \"If it is unprojected, perhaps the axes are not in (longitude, latitude) order.\");\n-                        }\n-                    }\n+                    edgesToCalculate.add((StreetWithElevationEdge) ee);\n                 }\n             }\n         }\n \n+        edgesToCalculate.parallelStream().forEach(edgeWithElevation -> {\n+            processEdge(graph, edgeWithElevation);\n+            if (edgeWithElevation.hasPackedElevationProfile() && !edgeWithElevation.isElevationFlattened()) {\n+                edgesWithElevation.add(edgeWithElevation);\n+            }\n+            int curNumProcessed = nProcessed.addAndGet(1);\n+            if (curNumProcessed % 50000 == 0) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c564b0ad2df98f2bb7bc49288973967578a8f697"}, "originalPosition": 193}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM5Nzg5OTA1OnYy", "diffSide": "RIGHT", "path": "src/main/java/org/opentripplanner/graph_builder/module/ned/ElevationModule.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wM1QxNDo0ODoyNlrOFxI2MQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wM1QxNDo0ODoyNlrOFxI2MQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzA2OTQ4OQ==", "bodyText": "The class need documentation on multi-threading. Something like this:\n\nTHIS CLASS IS MULTI-THEARED\n<p>\nIt uses a parallell stream to speed up the ...", "url": "https://github.com/opentripplanner/OpenTripPlanner/pull/2990#discussion_r387069489", "createdAt": "2020-03-03T14:48:26Z", "author": {"login": "t2gran"}, "path": "src/main/java/org/opentripplanner/graph_builder/module/ned/ElevationModule.java", "diffHunk": "@@ -44,32 +61,55 @@\n ", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c564b0ad2df98f2bb7bc49288973967578a8f697"}, "originalPosition": 49}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM5NzkwMzc2OnYy", "diffSide": "RIGHT", "path": "src/main/java/org/opentripplanner/graph_builder/module/ned/ElevationModule.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wM1QxNDo0OToyM1rOFxI43w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wM1QxNDo0OToyM1rOFxI43w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzA3MDE3NQ==", "bodyText": "Convert to JavaDoc /** */ not //.", "url": "https://github.com/opentripplanner/OpenTripPlanner/pull/2990#discussion_r387070175", "createdAt": "2020-03-03T14:49:23Z", "author": {"login": "t2gran"}, "path": "src/main/java/org/opentripplanner/graph_builder/module/ned/ElevationModule.java", "diffHunk": "@@ -44,32 +61,55 @@\n \n     private static final Logger log = LoggerFactory.getLogger(ElevationModule.class);\n \n-    private ElevationGridCoverageFactory gridCoverageFactory;\n+    private final ElevationGridCoverageFactory gridCoverageFactory;\n+    private final boolean readCachedElevations;\n+    private final boolean writeCachedElevations;\n+    private final File cachedElevationsFile;\n+\n+    private HashMap<String, PackedCoordinateSequence> cachedElevations;\n \n     private Coverage coverage;\n \n     // Keep track of the proportion of elevation fetch operations that fail so we can issue warnings.\n-    private int nPointsEvaluated = 0;\n-    private int nPointsOutsideDEM = 0;\n+    private AtomicInteger nPointsEvaluated = new AtomicInteger(0);\n+    private AtomicInteger nPointsOutsideDEM = new AtomicInteger(0);\n \n     /**\n      * The distance between samples in meters. Defaults to 10m, the approximate resolution of 1/3\n      * arc-second NED data.\n      */\n     private double distanceBetweenSamplesM = 10;\n \n-\n     /**\n      * Unit conversion multiplier for elevation values. No conversion needed if the elevation values\n      * are defined in meters in the source data. If, for example, decimetres are used in the source data,\n      * this should be set to 0.1 in build-config.json.\n      */\n-    private double elevationUnitMultiplier = 1;\n+    private final double elevationUnitMultiplier;\n \n-    public ElevationModule() { /* This makes me a \"bean\" */ };\n-    \n-    public ElevationModule(ElevationGridCoverageFactory factory, double elevationUnitMultiplier) {\n-        this.setGridCoverageFactory(factory);\n+    /** used to transform street coordinates into the projection used by the elevation data */\n+    private MathTransform transformer;\n+\n+    // used only for testing purposes", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c564b0ad2df98f2bb7bc49288973967578a8f697"}, "originalPosition": 90}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM5NzkxNjQwOnYy", "diffSide": "RIGHT", "path": "src/main/java/org/opentripplanner/graph_builder/module/ned/ElevationModule.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wM1QxNDo1MjoxM1rOFxJAUw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wM1QxNDo1MjoxM1rOFxJAUw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzA3MjA4Mw==", "bodyText": "Use this(factory, null, false, false, 1). Then if someone add/remove a new parameter to the \"main\" constructor he/she needs to make a decision what to do with this one.", "url": "https://github.com/opentripplanner/OpenTripPlanner/pull/2990#discussion_r387072083", "createdAt": "2020-03-03T14:52:13Z", "author": {"login": "t2gran"}, "path": "src/main/java/org/opentripplanner/graph_builder/module/ned/ElevationModule.java", "diffHunk": "@@ -44,32 +61,55 @@\n \n     private static final Logger log = LoggerFactory.getLogger(ElevationModule.class);\n \n-    private ElevationGridCoverageFactory gridCoverageFactory;\n+    private final ElevationGridCoverageFactory gridCoverageFactory;\n+    private final boolean readCachedElevations;\n+    private final boolean writeCachedElevations;\n+    private final File cachedElevationsFile;\n+\n+    private HashMap<String, PackedCoordinateSequence> cachedElevations;\n \n     private Coverage coverage;\n \n     // Keep track of the proportion of elevation fetch operations that fail so we can issue warnings.\n-    private int nPointsEvaluated = 0;\n-    private int nPointsOutsideDEM = 0;\n+    private AtomicInteger nPointsEvaluated = new AtomicInteger(0);\n+    private AtomicInteger nPointsOutsideDEM = new AtomicInteger(0);\n \n     /**\n      * The distance between samples in meters. Defaults to 10m, the approximate resolution of 1/3\n      * arc-second NED data.\n      */\n     private double distanceBetweenSamplesM = 10;\n \n-\n     /**\n      * Unit conversion multiplier for elevation values. No conversion needed if the elevation values\n      * are defined in meters in the source data. If, for example, decimetres are used in the source data,\n      * this should be set to 0.1 in build-config.json.\n      */\n-    private double elevationUnitMultiplier = 1;\n+    private final double elevationUnitMultiplier;\n \n-    public ElevationModule() { /* This makes me a \"bean\" */ };\n-    \n-    public ElevationModule(ElevationGridCoverageFactory factory, double elevationUnitMultiplier) {\n-        this.setGridCoverageFactory(factory);\n+    /** used to transform street coordinates into the projection used by the elevation data */\n+    private MathTransform transformer;\n+\n+    // used only for testing purposes\n+    public ElevationModule(ElevationGridCoverageFactory factory) {\n+        gridCoverageFactory = factory;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c564b0ad2df98f2bb7bc49288973967578a8f697"}, "originalPosition": 92}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ0MDE3NzAxOnYy", "diffSide": "RIGHT", "path": "src/main/java/org/opentripplanner/graph_builder/module/ned/ElevationModule.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xN1QxMzowOTo0OVrOF3bdzQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xN1QxMzowOTo0OVrOF3bdzQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzY2NTk5Nw==", "bodyText": "Two things here:\n\nMy impression is that we use the builder annotations to report input data problems - an InterruptException is a programming error - or am I mistaken? It is not important to me what we land on, but it should be used consistent.\nWhen catching InterruptException you should reset the Thread.currentThread().interrupt();, and if it is not deliberate I would exit like this:\n\ntry {\n  Thread.sleep(100);\n} catch (InterruptedException ex) {\n  Thread.currentThread().interrupt();\n  throw new RuntimeException(ex);\n}\n\nSee: https://stackoverflow.com/questions/4906799/why-invoke-thread-currentthread-interrupt-in-a-catch-interruptexception-block", "url": "https://github.com/opentripplanner/OpenTripPlanner/pull/2990#discussion_r393665997", "createdAt": "2020-03-17T13:09:49Z", "author": {"login": "t2gran"}, "path": "src/main/java/org/opentripplanner/graph_builder/module/ned/ElevationModule.java", "diffHunk": "@@ -80,55 +129,175 @@ public ElevationModule(ElevationGridCoverageFactory factory, double elevationUni\n     public List<String> getPrerequisites() {\n         return Arrays.asList(\"streets\");\n     }\n-    \n-    public void setGridCoverageFactory(ElevationGridCoverageFactory factory) {\n-        gridCoverageFactory = factory;\n-    }\n-\n-    public void setDistanceBetweenSamplesM(double distance) {\n-        distanceBetweenSamplesM = distance;\n-    }\n \n     @Override\n     public void buildGraph(Graph graph, HashMap<Class<?>, Object> extra) {\n-        gridCoverageFactory.setGraph(graph);\n-        Coverage gridCov = gridCoverageFactory.getGridCoverage();\n-\n-        // If gridCov is a GridCoverage2D, apply a bilinear interpolator. Otherwise, just use the\n-        // coverage as is (note: UnifiedGridCoverages created by NEDGridCoverageFactoryImpl handle\n-        // interpolation internally)\n-        coverage = (gridCov instanceof GridCoverage2D) ? Interpolator2D.create(\n-                (GridCoverage2D) gridCov, new InterpolationBilinear()) : gridCov;\n+        this.graph = graph;\n+        gridCoverageFactory.fetchData(graph);\n+\n+        // try to load in the cached elevation data\n+        if (readCachedElevations) {\n+            try {\n+                ObjectInputStream in = new ObjectInputStream(new FileInputStream(cachedElevationsFile));\n+                cachedElevations = (HashMap<String, PackedCoordinateSequence>) in.readObject();\n+                log.info(\"Cached elevation data loaded into memory!\");\n+            } catch (IOException | ClassNotFoundException e) {\n+                log.warn(graph.addBuilderAnnotation(new Graphwide(\n+                    String.format(\"Cached elevations file could not be read in due to error: %s!\", e.getMessage()))));\n+            }\n+        }\n         log.info(\"Setting street elevation profiles from digital elevation model...\");\n-        List<StreetEdge> edgesWithElevation = new ArrayList<StreetEdge>();\n-        int nProcessed = 0;\n-        int nTotal = graph.countEdges();\n+\n+        // Multithread elevation calculations\n+        ForkJoinPool forkJoinPool = new ForkJoinPool();\n+\n+        // For unknown reasons, the interpolation of heights at coordinates is a synchronized method in the commonly\n+        // used Interpolator2D class. Therefore, it is critical to use a dedicated Coverage instance for each thread to\n+        // avoid other threads waiting for a lock to be released on the Coverage instance. This concurrent HashMap will\n+        // store these thread-specific Coverage instances.\n+        ConcurrentHashMap<Long, Coverage> coveragesForThread = new ConcurrentHashMap<>();\n+\n+        // At first, set the totalElevationEdges to the total number of edges in the graph.\n+        totalElevationEdges = graph.countEdges();\n+        List<StreetWithElevationEdge> streetsWithElevationEdges = new LinkedList<>();\n         for (Vertex gv : graph.getVertices()) {\n             for (Edge ee : gv.getOutgoing()) {\n                 if (ee instanceof StreetWithElevationEdge) {\n-                    StreetWithElevationEdge edgeWithElevation = (StreetWithElevationEdge) ee;\n-                    processEdge(graph, edgeWithElevation);\n-                    if (edgeWithElevation.getElevationProfile() != null && !edgeWithElevation.isElevationFlattened()) {\n-                        edgesWithElevation.add(edgeWithElevation);\n-                    }\n-                    nProcessed += 1;\n-                    if (nProcessed % 50000 == 0) {\n-                        log.info(\"set elevation on {}/{} edges\", nProcessed, nTotal);\n-                        double failurePercentage = nPointsOutsideDEM / nPointsEvaluated * 100;\n-                        if (failurePercentage > 50) {\n-                            log.warn(\"Fetching elevation failed at {}/{} points ({}%)\",\n-                                    nPointsOutsideDEM, nPointsEvaluated, failurePercentage);\n-                            log.warn(\"Elevation is missing at a large number of points. DEM may be for the wrong region. \" +\n-                                    \"If it is unprojected, perhaps the axes are not in (longitude, latitude) order.\");\n-                        }\n-                    }\n+                    forkJoinPool.submit(new ProcessEdgeTask((StreetWithElevationEdge) ee, coveragesForThread));\n+                    streetsWithElevationEdges.add((StreetWithElevationEdge) ee);\n                 }\n             }\n         }\n+        // update this value to the now-known amount of edges that are StreetWithElevation edges\n+        totalElevationEdges = streetsWithElevationEdges.size();\n \n+        // shutdown the forkJoinPool and wait until all tasks are finished. If this takes longer than 1 day, give up.\n+        forkJoinPool.shutdown();\n+        try {\n+            forkJoinPool.awaitTermination(1, TimeUnit.DAYS);\n+        } catch (InterruptedException e) {\n+            log.warn(graph.addBuilderAnnotation(new Graphwide(\"Multi-threaded elevation calculations timed-out!\")));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7d44713a1ca574eff04c389edba2ebc02de29b04"}, "originalPosition": 236}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ0MDMxMjk3OnYy", "diffSide": "RIGHT", "path": "src/main/java/org/opentripplanner/graph_builder/module/ned/DegreeGridNEDTileSource.java", "isResolved": false, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xN1QxMzo0Mzo0N1rOF3c1eg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wM1QwMjo1NzowMlrOGADbcA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzY4ODQ0Mg==", "bodyText": "Do we want to continue here? I the system is set up to download these files I would prefer that ti failed hard - but this comes down to how you rig the OTP deployment and how often the download fails. I think it is ok to do this in OTP1, but in OTP2 the strategy so fare is to fail hard for critical errors - also things that relay on network communication.  One thing that makes this a bit more robust in OTP2 is that the street graph is build in a separate step - so the \"pipeline\" can fallback to an old street graph when building the transit data on top of it - it then is the responsibility of the pipeline, and not OTP any more.", "url": "https://github.com/opentripplanner/OpenTripPlanner/pull/2990#discussion_r393688442", "createdAt": "2020-03-17T13:43:47Z", "author": {"login": "t2gran"}, "path": "src/main/java/org/opentripplanner/graph_builder/module/ned/DegreeGridNEDTileSource.java", "diffHunk": "@@ -120,18 +119,10 @@ private File getPathToTile(int x, int y) {\n                 }\n                 ostream.close();\n                 istream.close();\n-            } catch (S3ServiceException e) {\n-                path.deleteOnExit();\n-                throw new RuntimeException(e);\n-            } catch (ServiceException e) {\n-                path.deleteOnExit();\n-                throw new RuntimeException(e);\n-            } catch (FileNotFoundException e) {\n-                path.deleteOnExit();\n-                throw new RuntimeException(e);\n-            } catch (IOException e) {\n+            } catch (ServiceException | IOException e) {\n+                log.error(\"Error downloading tile {}! Error: {}.\", key, e.getMessage());\n                 path.deleteOnExit();\n-                throw new RuntimeException(e);\n+                return null;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7d44713a1ca574eff04c389edba2ebc02de29b04"}, "originalPosition": 84}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODg2MTkxNQ==", "bodyText": "The reason this was done here was that we simply didn't have the needed elevation tiles at certain edges of our graph. Therefore, we needed OTP to be able to continue when a certain tile was requested that we didn't have available.", "url": "https://github.com/opentripplanner/OpenTripPlanner/pull/2990#discussion_r398861915", "createdAt": "2020-03-26T20:13:24Z", "author": {"login": "evansiroky"}, "path": "src/main/java/org/opentripplanner/graph_builder/module/ned/DegreeGridNEDTileSource.java", "diffHunk": "@@ -120,18 +119,10 @@ private File getPathToTile(int x, int y) {\n                 }\n                 ostream.close();\n                 istream.close();\n-            } catch (S3ServiceException e) {\n-                path.deleteOnExit();\n-                throw new RuntimeException(e);\n-            } catch (ServiceException e) {\n-                path.deleteOnExit();\n-                throw new RuntimeException(e);\n-            } catch (FileNotFoundException e) {\n-                path.deleteOnExit();\n-                throw new RuntimeException(e);\n-            } catch (IOException e) {\n+            } catch (ServiceException | IOException e) {\n+                log.error(\"Error downloading tile {}! Error: {}.\", key, e.getMessage());\n                 path.deleteOnExit();\n-                throw new RuntimeException(e);\n+                return null;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzY4ODQ0Mg=="}, "originalCommit": {"oid": "7d44713a1ca574eff04c389edba2ebc02de29b04"}, "originalPosition": 84}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTMxMDc4NA==", "bodyText": "That is understandable - should this be a build annotation, instead then?", "url": "https://github.com/opentripplanner/OpenTripPlanner/pull/2990#discussion_r399310784", "createdAt": "2020-03-27T14:37:16Z", "author": {"login": "t2gran"}, "path": "src/main/java/org/opentripplanner/graph_builder/module/ned/DegreeGridNEDTileSource.java", "diffHunk": "@@ -120,18 +119,10 @@ private File getPathToTile(int x, int y) {\n                 }\n                 ostream.close();\n                 istream.close();\n-            } catch (S3ServiceException e) {\n-                path.deleteOnExit();\n-                throw new RuntimeException(e);\n-            } catch (ServiceException e) {\n-                path.deleteOnExit();\n-                throw new RuntimeException(e);\n-            } catch (FileNotFoundException e) {\n-                path.deleteOnExit();\n-                throw new RuntimeException(e);\n-            } catch (IOException e) {\n+            } catch (ServiceException | IOException e) {\n+                log.error(\"Error downloading tile {}! Error: {}.\", key, e.getMessage());\n                 path.deleteOnExit();\n-                throw new RuntimeException(e);\n+                return null;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzY4ODQ0Mg=="}, "originalCommit": {"oid": "7d44713a1ca574eff04c389edba2ebc02de29b04"}, "originalPosition": 84}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjE5MDQ0Nw==", "bodyText": "I think it's acceptable to continue after an exception if we distinguish between network failures / server errors (where we don't know whether the tile exists) and successful communication indicating there is no tile. So I think we should keep separate catch clauses, and fail hard or retry on exceptions representing communication/server failures, while soft-failing (continuing) on exceptions representing successful communication that a file is not present on the remote server.", "url": "https://github.com/opentripplanner/OpenTripPlanner/pull/2990#discussion_r402190447", "createdAt": "2020-04-02T09:52:27Z", "author": {"login": "abyrd"}, "path": "src/main/java/org/opentripplanner/graph_builder/module/ned/DegreeGridNEDTileSource.java", "diffHunk": "@@ -120,18 +119,10 @@ private File getPathToTile(int x, int y) {\n                 }\n                 ostream.close();\n                 istream.close();\n-            } catch (S3ServiceException e) {\n-                path.deleteOnExit();\n-                throw new RuntimeException(e);\n-            } catch (ServiceException e) {\n-                path.deleteOnExit();\n-                throw new RuntimeException(e);\n-            } catch (FileNotFoundException e) {\n-                path.deleteOnExit();\n-                throw new RuntimeException(e);\n-            } catch (IOException e) {\n+            } catch (ServiceException | IOException e) {\n+                log.error(\"Error downloading tile {}! Error: {}.\", key, e.getMessage());\n                 path.deleteOnExit();\n-                throw new RuntimeException(e);\n+                return null;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzY4ODQ0Mg=="}, "originalCommit": {"oid": "7d44713a1ca574eff04c389edba2ebc02de29b04"}, "originalPosition": 84}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjcwOTM2MA==", "bodyText": "That seems like a good idea.", "url": "https://github.com/opentripplanner/OpenTripPlanner/pull/2990#discussion_r402709360", "createdAt": "2020-04-03T02:57:02Z", "author": {"login": "evansiroky"}, "path": "src/main/java/org/opentripplanner/graph_builder/module/ned/DegreeGridNEDTileSource.java", "diffHunk": "@@ -120,18 +119,10 @@ private File getPathToTile(int x, int y) {\n                 }\n                 ostream.close();\n                 istream.close();\n-            } catch (S3ServiceException e) {\n-                path.deleteOnExit();\n-                throw new RuntimeException(e);\n-            } catch (ServiceException e) {\n-                path.deleteOnExit();\n-                throw new RuntimeException(e);\n-            } catch (FileNotFoundException e) {\n-                path.deleteOnExit();\n-                throw new RuntimeException(e);\n-            } catch (IOException e) {\n+            } catch (ServiceException | IOException e) {\n+                log.error(\"Error downloading tile {}! Error: {}.\", key, e.getMessage());\n                 path.deleteOnExit();\n-                throw new RuntimeException(e);\n+                return null;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzY4ODQ0Mg=="}, "originalCommit": {"oid": "7d44713a1ca574eff04c389edba2ebc02de29b04"}, "originalPosition": 84}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ0MDQ4MDQ4OnYy", "diffSide": "RIGHT", "path": "src/main/java/org/opentripplanner/graph_builder/module/ned/ElevationModule.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xN1QxNDoyMzowNVrOF3eiLQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xN1QxNDoyMzowNVrOF3eiLQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzcxNjI2OQ==", "bodyText": "It looks like the coveragesForThread is a map for each Thread to store some \"data\", another way to achieve it would be to create a ForkJoinWorkerThreadFactory which return a special thread with this data set. Then the map can be removed and the data only visible to the \"correct\" thread.", "url": "https://github.com/opentripplanner/OpenTripPlanner/pull/2990#discussion_r393716269", "createdAt": "2020-03-17T14:23:05Z", "author": {"login": "t2gran"}, "path": "src/main/java/org/opentripplanner/graph_builder/module/ned/ElevationModule.java", "diffHunk": "@@ -80,55 +129,175 @@ public ElevationModule(ElevationGridCoverageFactory factory, double elevationUni\n     public List<String> getPrerequisites() {\n         return Arrays.asList(\"streets\");\n     }\n-    \n-    public void setGridCoverageFactory(ElevationGridCoverageFactory factory) {\n-        gridCoverageFactory = factory;\n-    }\n-\n-    public void setDistanceBetweenSamplesM(double distance) {\n-        distanceBetweenSamplesM = distance;\n-    }\n \n     @Override\n     public void buildGraph(Graph graph, HashMap<Class<?>, Object> extra) {\n-        gridCoverageFactory.setGraph(graph);\n-        Coverage gridCov = gridCoverageFactory.getGridCoverage();\n-\n-        // If gridCov is a GridCoverage2D, apply a bilinear interpolator. Otherwise, just use the\n-        // coverage as is (note: UnifiedGridCoverages created by NEDGridCoverageFactoryImpl handle\n-        // interpolation internally)\n-        coverage = (gridCov instanceof GridCoverage2D) ? Interpolator2D.create(\n-                (GridCoverage2D) gridCov, new InterpolationBilinear()) : gridCov;\n+        this.graph = graph;\n+        gridCoverageFactory.fetchData(graph);\n+\n+        // try to load in the cached elevation data\n+        if (readCachedElevations) {\n+            try {\n+                ObjectInputStream in = new ObjectInputStream(new FileInputStream(cachedElevationsFile));\n+                cachedElevations = (HashMap<String, PackedCoordinateSequence>) in.readObject();\n+                log.info(\"Cached elevation data loaded into memory!\");\n+            } catch (IOException | ClassNotFoundException e) {\n+                log.warn(graph.addBuilderAnnotation(new Graphwide(\n+                    String.format(\"Cached elevations file could not be read in due to error: %s!\", e.getMessage()))));\n+            }\n+        }\n         log.info(\"Setting street elevation profiles from digital elevation model...\");\n-        List<StreetEdge> edgesWithElevation = new ArrayList<StreetEdge>();\n-        int nProcessed = 0;\n-        int nTotal = graph.countEdges();\n+\n+        // Multithread elevation calculations\n+        ForkJoinPool forkJoinPool = new ForkJoinPool();\n+\n+        // For unknown reasons, the interpolation of heights at coordinates is a synchronized method in the commonly\n+        // used Interpolator2D class. Therefore, it is critical to use a dedicated Coverage instance for each thread to\n+        // avoid other threads waiting for a lock to be released on the Coverage instance. This concurrent HashMap will\n+        // store these thread-specific Coverage instances.\n+        ConcurrentHashMap<Long, Coverage> coveragesForThread = new ConcurrentHashMap<>();\n+\n+        // At first, set the totalElevationEdges to the total number of edges in the graph.\n+        totalElevationEdges = graph.countEdges();\n+        List<StreetWithElevationEdge> streetsWithElevationEdges = new LinkedList<>();\n         for (Vertex gv : graph.getVertices()) {\n             for (Edge ee : gv.getOutgoing()) {\n                 if (ee instanceof StreetWithElevationEdge) {\n-                    StreetWithElevationEdge edgeWithElevation = (StreetWithElevationEdge) ee;\n-                    processEdge(graph, edgeWithElevation);\n-                    if (edgeWithElevation.getElevationProfile() != null && !edgeWithElevation.isElevationFlattened()) {\n-                        edgesWithElevation.add(edgeWithElevation);\n-                    }\n-                    nProcessed += 1;\n-                    if (nProcessed % 50000 == 0) {\n-                        log.info(\"set elevation on {}/{} edges\", nProcessed, nTotal);\n-                        double failurePercentage = nPointsOutsideDEM / nPointsEvaluated * 100;\n-                        if (failurePercentage > 50) {\n-                            log.warn(\"Fetching elevation failed at {}/{} points ({}%)\",\n-                                    nPointsOutsideDEM, nPointsEvaluated, failurePercentage);\n-                            log.warn(\"Elevation is missing at a large number of points. DEM may be for the wrong region. \" +\n-                                    \"If it is unprojected, perhaps the axes are not in (longitude, latitude) order.\");\n-                        }\n-                    }\n+                    forkJoinPool.submit(new ProcessEdgeTask((StreetWithElevationEdge) ee, coveragesForThread));\n+                    streetsWithElevationEdges.add((StreetWithElevationEdge) ee);\n                 }\n             }\n         }\n+        // update this value to the now-known amount of edges that are StreetWithElevation edges\n+        totalElevationEdges = streetsWithElevationEdges.size();\n \n+        // shutdown the forkJoinPool and wait until all tasks are finished. If this takes longer than 1 day, give up.\n+        forkJoinPool.shutdown();\n+        try {\n+            forkJoinPool.awaitTermination(1, TimeUnit.DAYS);\n+        } catch (InterruptedException e) {\n+            log.warn(graph.addBuilderAnnotation(new Graphwide(\"Multi-threaded elevation calculations timed-out!\")));\n+        }\n+\n+        double failurePercentage = nPointsOutsideDEM.get() / nPointsEvaluated.get() * 100;\n+        if (failurePercentage > 50) {\n+            log.warn(graph.addBuilderAnnotation(new Graphwide(\n+                String.format(\n+                    \"Fetching elevation failed at %d/%d points (%d%%)\",\n+                    nPointsOutsideDEM, nPointsEvaluated, failurePercentage\n+                )\n+            )));\n+            log.warn(\"Elevation is missing at a large number of points. DEM may be for the wrong region. \" +\n+                \"If it is unprojected, perhaps the axes are not in (longitude, latitude) order.\");\n+        }\n+\n+        // iterate again to find edges that had elevation calculated. This is done here instead of in the forkJoinPool\n+        // to avoid thread locking for writes to a synchronized list\n+        LinkedList<StreetEdge> edgesWithCalculatedElevations = new LinkedList<>();\n+        for (StreetWithElevationEdge edgeWithElevation : streetsWithElevationEdges) {\n+            if (edgeWithElevation.hasPackedElevationProfile() && !edgeWithElevation.isElevationFlattened()) {\n+                edgesWithCalculatedElevations.add(edgeWithElevation);\n+            }\n+        }\n+\n+        if (writeCachedElevations) {\n+            // write information from edgesWithElevation to a new cache file for subsequent graph builds\n+            HashMap<String, PackedCoordinateSequence> newCachedElevations = new HashMap<>();\n+            for (StreetEdge streetEdge : edgesWithCalculatedElevations) {\n+                newCachedElevations.put(PolylineEncoder.createEncodings(streetEdge.getGeometry()).getPoints(),\n+                    streetEdge.getElevationProfile());\n+            }\n+            try {\n+                ObjectOutputStream out = new ObjectOutputStream(\n+                    new BufferedOutputStream(new FileOutputStream(cachedElevationsFile)));\n+                out.writeObject(newCachedElevations);\n+                out.close();\n+            } catch (IOException e) {\n+                log.error(e.getMessage());\n+                log.error(graph.addBuilderAnnotation(new Graphwide(\"Failed to write cached elevation file!\")));\n+            }\n+        }\n         @SuppressWarnings(\"unchecked\")\n         HashMap<Vertex, Double> extraElevation = (HashMap<Vertex, Double>) extra.get(ElevationPoint.class);\n-        assignMissingElevations(graph, edgesWithElevation, extraElevation);\n+        assignMissingElevations(graph, edgesWithCalculatedElevations, extraElevation);\n+    }\n+\n+    /**\n+     * A runnable that contains the relevant info for executing a process edge operation in a particular thread.\n+     */\n+    private class ProcessEdgeTask implements Runnable {\n+        private final StreetWithElevationEdge swee;\n+        private final ConcurrentHashMap<Long, Coverage> coveragesForThread;\n+\n+        public ProcessEdgeTask(StreetWithElevationEdge swee, ConcurrentHashMap<Long, Coverage> coveragesForThread) {\n+            this.swee = swee;\n+            this.coveragesForThread = coveragesForThread;\n+        }\n+\n+        @Override public void run() {\n+            // First, check if the edge already has been calculated or if it exists in a pre-calculated cache. Checking\n+            // with this method avoids potentially waiting for a lock to be released for calculating the thread-specific\n+            // coverage.\n+            boolean edgeNeedsProcessing = true;\n+            // Store the edge geometry in this block to avoid recalculating it twice if the edge needs a full elevation\n+            // calculation.\n+            Geometry edgeGeometry = null;\n+\n+            if (swee.hasPackedElevationProfile()) {\n+                edgeNeedsProcessing = false; /* already set up */\n+            } else {\n+                edgeGeometry = swee.getGeometry();\n+                // first try to find a cached value if possible\n+                if (cachedElevations != null) {\n+                    PackedCoordinateSequence coordinateSequence = cachedElevations.get(\n+                        PolylineEncoder.createEncodings(edgeGeometry).getPoints()\n+                    );\n+                    if (coordinateSequence != null) {\n+                        // found a cached value! Set the elevation profile with the pre-calculated data.\n+                        setEdgeElevationProfile(swee, coordinateSequence, graph);\n+                        edgeNeedsProcessing = false;\n+                    }\n+                }\n+            }\n+\n+            if (edgeNeedsProcessing) {\n+                // Needs full calculation. Calculate with a thread-specific coverage to avoid waiting for any locks on\n+                // coverage instances in other threads.\n+                processEdge(swee, edgeGeometry, getThreadSpecificCoverageInstance());\n+            }\n+            int curNumProcessed = nEdgesProcessed.addAndGet(1);\n+            if (curNumProcessed % 50000 == 0) {\n+                log.info(\"set elevation on {}/{} edges\", curNumProcessed, totalElevationEdges);\n+            }\n+        }\n+\n+        /**\n+         * Get the thread-specific Coverage instance to avoid multiple threads waiting for a lock to be released on a\n+         * Interpolator2D instance.\n+         */\n+        private Coverage getThreadSpecificCoverageInstance () {\n+            long currentThreadId = Thread.currentThread().getId();\n+            Coverage threadSpecificCoverage = coveragesForThread.get(currentThreadId);\n+            if (threadSpecificCoverage == null) {\n+                // Synchronize the creation of the Thread-specific Coverage instances to avoid potential locks that\n+                // could arise from downstream classes that have synchronized methods.\n+                synchronized (coveragesForThread) {\n+                    // Get a new Coverage instance from the module's ElevationGridCoverageFactory.\n+                    threadSpecificCoverage = gridCoverageFactory.getGridCoverage();\n+                    // The Coverage instance relies on some synchronized static methods shared across all threads that\n+                    // can cause deadlocks if not fully initialized. Therefore, make a single request for the first\n+                    // point on the edge to initialize these other items.\n+                    Coordinate firstEdgeCoord =  swee.getGeometry().getCoordinates()[0];\n+                    double[] dummy = new double[1];\n+                    threadSpecificCoverage.evaluate(\n+                        new DirectPosition2D(GeometryUtils.WGS84_XY, firstEdgeCoord.x, firstEdgeCoord.y),\n+                        dummy\n+                    );\n+                }\n+                coveragesForThread.put(currentThreadId, threadSpecificCoverage);\n+            }\n+            return threadSpecificCoverage;\n+        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7d44713a1ca574eff04c389edba2ebc02de29b04"}, "originalPosition": 358}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ3NjA2NzA3OnYy", "diffSide": "RIGHT", "path": "src/main/java/org/opentripplanner/graph_builder/module/ned/ElevationModule.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yN1QxNjoyMDoyMFrOF84dDw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMFQxNTo1MzoyMFrOF9wigQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTM4MzgyMw==", "bodyText": "Do the call to the evaluate method need to be called with the first coordinate from the swee or just any coordinate? If any coordinate will do it, then you could create the Coverage in the constructor and make the  threadSpecificCoverage final. Also, I think the synchronized can be dropped in that case, because the creation of a new Thread should be thread-safe.\nNote! The above code is NOT thread-safe you check the threadSpecificCoverage == null outside of the synchronized block and assign it inside.", "url": "https://github.com/opentripplanner/OpenTripPlanner/pull/2990#discussion_r399383823", "createdAt": "2020-03-27T16:20:20Z", "author": {"login": "t2gran"}, "path": "src/main/java/org/opentripplanner/graph_builder/module/ned/ElevationModule.java", "diffHunk": "@@ -222,22 +231,69 @@ public void buildGraph(Graph graph, HashMap<Class<?>, Object> extra) {\n         assignMissingElevations(graph, edgesWithCalculatedElevations, extraElevation);\n     }\n \n+    /**\n+     * A special extension of the Thread class so that a thread-specific coverage instance can be stored for each\n+     * thread.\n+     */\n+    private class ElevationWorkerThread extends ForkJoinWorkerThread {\n+        private Coverage threadSpecificCoverage;\n+\n+        /**\n+         * Creates a ForkJoinWorkerThread operating in the given pool.\n+         *\n+         * @param pool the pool this thread works in\n+         * @throws NullPointerException if pool is null\n+         */\n+        protected ElevationWorkerThread(ForkJoinPool pool) {\n+            super(pool);\n+        }\n+\n+        /**\n+         * For unknown reasons, the interpolation of heights at coordinates is a synchronized method in the commonly\n+         * used Interpolator2D class. Therefore, it is critical to use a dedicated Coverage instance for each thread to\n+         * avoid other threads waiting for a lock to be released on the Coverage instance. This concurrent HashMap will\n+         * store these thread-specific Coverage instances.\n+         *\n+         * @param swee An exemplar StreetWithElevationEdge to use to initialize a few calculations in the newly created\n+         *             coverage instance.\n+         * @return A thread-specific coverage instance that can be used without being locked from other threads.\n+         */\n+        public Coverage getThreadSpecificCoverageInstance (StreetWithElevationEdge swee) {\n+            if (threadSpecificCoverage == null) {\n+                // Synchronize the creation of the Thread-specific Coverage instances to avoid potential locks that\n+                // could arise from downstream classes that have synchronized methods.\n+                synchronized (gridCoverageFactory) {\n+                    // Get a new Coverage instance from the module's ElevationGridCoverageFactory.\n+                    threadSpecificCoverage = gridCoverageFactory.getGridCoverage();\n+                    // The Coverage instance relies on some synchronized static methods shared across all threads that\n+                    // can cause deadlocks if not fully initialized. Therefore, make a single request for the first\n+                    // point on the edge to initialize these other items.\n+                    Coordinate firstEdgeCoord =  swee.getGeometry().getCoordinates()[0];\n+                    double[] dummy = new double[1];\n+                    threadSpecificCoverage.evaluate(\n+                        new DirectPosition2D(GeometryUtils.WGS84_XY, firstEdgeCoord.x, firstEdgeCoord.y),\n+                        dummy\n+                    );\n+                }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3706b245e74e8b28ab169beeb89f7556842e9866"}, "originalPosition": 142}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTcyMTE3NQ==", "bodyText": "I have pushed a change that will hopefully resolve the issues you brought up. The reasoning behind not immediately creating a coverage instance is that it can cause a lot of blocking in the beginning when the ForkJoinPool begins. When using the cached elevations, it is highly likely that most edges will already have a value present in the cache and therefore not even need a coverage instance. By lazy-creating the coverage instances other threads can continue to process edges that are available in the cache that don't need a coverage instance, otherwise, a lot of threads will be waiting for each other at the start until a coverage instance has been calculated for each thread.\nRegarding the thread-safe assignment, I don't fully understand how it would not be thread-safe to assign the value in this way since the field would only be accessed by the thread doing the assignment and not by anything else. Nonetheless, I attempted to break out the assignment of the variable as suggested, so hopefully, this now makes it thread-safe.", "url": "https://github.com/opentripplanner/OpenTripPlanner/pull/2990#discussion_r399721175", "createdAt": "2020-03-28T23:17:51Z", "author": {"login": "evansiroky"}, "path": "src/main/java/org/opentripplanner/graph_builder/module/ned/ElevationModule.java", "diffHunk": "@@ -222,22 +231,69 @@ public void buildGraph(Graph graph, HashMap<Class<?>, Object> extra) {\n         assignMissingElevations(graph, edgesWithCalculatedElevations, extraElevation);\n     }\n \n+    /**\n+     * A special extension of the Thread class so that a thread-specific coverage instance can be stored for each\n+     * thread.\n+     */\n+    private class ElevationWorkerThread extends ForkJoinWorkerThread {\n+        private Coverage threadSpecificCoverage;\n+\n+        /**\n+         * Creates a ForkJoinWorkerThread operating in the given pool.\n+         *\n+         * @param pool the pool this thread works in\n+         * @throws NullPointerException if pool is null\n+         */\n+        protected ElevationWorkerThread(ForkJoinPool pool) {\n+            super(pool);\n+        }\n+\n+        /**\n+         * For unknown reasons, the interpolation of heights at coordinates is a synchronized method in the commonly\n+         * used Interpolator2D class. Therefore, it is critical to use a dedicated Coverage instance for each thread to\n+         * avoid other threads waiting for a lock to be released on the Coverage instance. This concurrent HashMap will\n+         * store these thread-specific Coverage instances.\n+         *\n+         * @param swee An exemplar StreetWithElevationEdge to use to initialize a few calculations in the newly created\n+         *             coverage instance.\n+         * @return A thread-specific coverage instance that can be used without being locked from other threads.\n+         */\n+        public Coverage getThreadSpecificCoverageInstance (StreetWithElevationEdge swee) {\n+            if (threadSpecificCoverage == null) {\n+                // Synchronize the creation of the Thread-specific Coverage instances to avoid potential locks that\n+                // could arise from downstream classes that have synchronized methods.\n+                synchronized (gridCoverageFactory) {\n+                    // Get a new Coverage instance from the module's ElevationGridCoverageFactory.\n+                    threadSpecificCoverage = gridCoverageFactory.getGridCoverage();\n+                    // The Coverage instance relies on some synchronized static methods shared across all threads that\n+                    // can cause deadlocks if not fully initialized. Therefore, make a single request for the first\n+                    // point on the edge to initialize these other items.\n+                    Coordinate firstEdgeCoord =  swee.getGeometry().getCoordinates()[0];\n+                    double[] dummy = new double[1];\n+                    threadSpecificCoverage.evaluate(\n+                        new DirectPosition2D(GeometryUtils.WGS84_XY, firstEdgeCoord.x, firstEdgeCoord.y),\n+                        dummy\n+                    );\n+                }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTM4MzgyMw=="}, "originalCommit": {"oid": "3706b245e74e8b28ab169beeb89f7556842e9866"}, "originalPosition": 142}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDMwMjcyMQ==", "bodyText": "Sorry, I forgot the threadSpecificCoverage was inside the thread. It looks ok then. You could also have achieved this with a ThreadLocal but this good. The main point is to avoid every task to wait on the synchronized (gridCoverageFactory).", "url": "https://github.com/opentripplanner/OpenTripPlanner/pull/2990#discussion_r400302721", "createdAt": "2020-03-30T15:53:20Z", "author": {"login": "t2gran"}, "path": "src/main/java/org/opentripplanner/graph_builder/module/ned/ElevationModule.java", "diffHunk": "@@ -222,22 +231,69 @@ public void buildGraph(Graph graph, HashMap<Class<?>, Object> extra) {\n         assignMissingElevations(graph, edgesWithCalculatedElevations, extraElevation);\n     }\n \n+    /**\n+     * A special extension of the Thread class so that a thread-specific coverage instance can be stored for each\n+     * thread.\n+     */\n+    private class ElevationWorkerThread extends ForkJoinWorkerThread {\n+        private Coverage threadSpecificCoverage;\n+\n+        /**\n+         * Creates a ForkJoinWorkerThread operating in the given pool.\n+         *\n+         * @param pool the pool this thread works in\n+         * @throws NullPointerException if pool is null\n+         */\n+        protected ElevationWorkerThread(ForkJoinPool pool) {\n+            super(pool);\n+        }\n+\n+        /**\n+         * For unknown reasons, the interpolation of heights at coordinates is a synchronized method in the commonly\n+         * used Interpolator2D class. Therefore, it is critical to use a dedicated Coverage instance for each thread to\n+         * avoid other threads waiting for a lock to be released on the Coverage instance. This concurrent HashMap will\n+         * store these thread-specific Coverage instances.\n+         *\n+         * @param swee An exemplar StreetWithElevationEdge to use to initialize a few calculations in the newly created\n+         *             coverage instance.\n+         * @return A thread-specific coverage instance that can be used without being locked from other threads.\n+         */\n+        public Coverage getThreadSpecificCoverageInstance (StreetWithElevationEdge swee) {\n+            if (threadSpecificCoverage == null) {\n+                // Synchronize the creation of the Thread-specific Coverage instances to avoid potential locks that\n+                // could arise from downstream classes that have synchronized methods.\n+                synchronized (gridCoverageFactory) {\n+                    // Get a new Coverage instance from the module's ElevationGridCoverageFactory.\n+                    threadSpecificCoverage = gridCoverageFactory.getGridCoverage();\n+                    // The Coverage instance relies on some synchronized static methods shared across all threads that\n+                    // can cause deadlocks if not fully initialized. Therefore, make a single request for the first\n+                    // point on the edge to initialize these other items.\n+                    Coordinate firstEdgeCoord =  swee.getGeometry().getCoordinates()[0];\n+                    double[] dummy = new double[1];\n+                    threadSpecificCoverage.evaluate(\n+                        new DirectPosition2D(GeometryUtils.WGS84_XY, firstEdgeCoord.x, firstEdgeCoord.y),\n+                        dummy\n+                    );\n+                }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTM4MzgyMw=="}, "originalCommit": {"oid": "3706b245e74e8b28ab169beeb89f7556842e9866"}, "originalPosition": 142}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ4Njg3MDQ2OnYy", "diffSide": "RIGHT", "path": "src/main/java/org/opentripplanner/graph_builder/module/ned/ElevationModule.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMVQxNTozMzozM1rOF-bthA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wM1QwMjo0MzoxNVrOGADMyA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTAxMDA1Mg==", "bodyText": "Do you know if creating a ThreadPool with just 1 thread will lead to a performance overhead compared with just running the Tasks in the current thread?", "url": "https://github.com/opentripplanner/OpenTripPlanner/pull/2990#discussion_r401010052", "createdAt": "2020-03-31T15:33:33Z", "author": {"login": "t2gran"}, "path": "src/main/java/org/opentripplanner/graph_builder/module/ned/ElevationModule.java", "diffHunk": "@@ -161,7 +169,7 @@ public void buildGraph(Graph graph, HashMap<Class<?>, Object> extra) {\n \n         // Multithread elevation calculations\n         ForkJoinPool forkJoinPool = new ForkJoinPool(\n-            Runtime.getRuntime().availableProcessors(),\n+            parallelism,\n             forkJoinWorkerThreadFactory,\n             null,\n             false", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9baab1a51d54aa94b9031128b2ffc528d09836b3"}, "originalPosition": 48}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjcwNTYwOA==", "bodyText": "Yes, it appears that the ThreadPool does have slightly worse performance with the HSL setup. Over 10 runs, the code that didn't use a ThreadPool was on average 9 seconds faster. I have added this code to this PR.", "url": "https://github.com/opentripplanner/OpenTripPlanner/pull/2990#discussion_r402705608", "createdAt": "2020-04-03T02:43:15Z", "author": {"login": "evansiroky"}, "path": "src/main/java/org/opentripplanner/graph_builder/module/ned/ElevationModule.java", "diffHunk": "@@ -161,7 +169,7 @@ public void buildGraph(Graph graph, HashMap<Class<?>, Object> extra) {\n \n         // Multithread elevation calculations\n         ForkJoinPool forkJoinPool = new ForkJoinPool(\n-            Runtime.getRuntime().availableProcessors(),\n+            parallelism,\n             forkJoinWorkerThreadFactory,\n             null,\n             false", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTAxMDA1Mg=="}, "originalCommit": {"oid": "9baab1a51d54aa94b9031128b2ffc528d09836b3"}, "originalPosition": 48}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ5NDM3MDYzOnYy", "diffSide": "RIGHT", "path": "src/main/java/org/opentripplanner/graph_builder/module/ned/ElevationModule.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMlQwOTo1Nzo1NFrOF_j9xw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMlQwOTo1Nzo1NFrOF_j9xw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjE5Mzg2Mw==", "bodyText": "The key for the cache entries is only the edge geometry (one of the calculation inputs), without the corresponding elevation cells (the other calculation input). So the cache will detect new or changed streets, but not new or changed elevation. Storing or hashing the local elevation data around each edge would get very complex, and elevation data changes rarely, so it's probably not worth implementing this. It would be nice though to invalidate the entire elevation profile cache if the elevation input changes. This could probably be accomplished by naming the cache file (or storing in the cache file) a hash of all the elevation input data. But if that's being fetched over a network maybe it's impossible to hash the entire data set.", "url": "https://github.com/opentripplanner/OpenTripPlanner/pull/2990#discussion_r402193863", "createdAt": "2020-04-02T09:57:54Z", "author": {"login": "abyrd"}, "path": "src/main/java/org/opentripplanner/graph_builder/module/ned/ElevationModule.java", "diffHunk": "@@ -80,55 +146,176 @@ public ElevationModule(ElevationGridCoverageFactory factory, double elevationUni\n     public List<String> getPrerequisites() {\n         return Arrays.asList(\"streets\");\n     }\n-    \n-    public void setGridCoverageFactory(ElevationGridCoverageFactory factory) {\n-        gridCoverageFactory = factory;\n-    }\n-\n-    public void setDistanceBetweenSamplesM(double distance) {\n-        distanceBetweenSamplesM = distance;\n-    }\n \n     @Override\n     public void buildGraph(Graph graph, HashMap<Class<?>, Object> extra) {\n-        gridCoverageFactory.setGraph(graph);\n-        Coverage gridCov = gridCoverageFactory.getGridCoverage();\n-\n-        // If gridCov is a GridCoverage2D, apply a bilinear interpolator. Otherwise, just use the\n-        // coverage as is (note: UnifiedGridCoverages created by NEDGridCoverageFactoryImpl handle\n-        // interpolation internally)\n-        coverage = (gridCov instanceof GridCoverage2D) ? Interpolator2D.create(\n-                (GridCoverage2D) gridCov, new InterpolationBilinear()) : gridCov;\n+        this.graph = graph;\n+        gridCoverageFactory.fetchData(graph);\n+\n+        // try to load in the cached elevation data\n+        if (readCachedElevations) {\n+            try {\n+                ObjectInputStream in = new ObjectInputStream(new FileInputStream(cachedElevationsFile));\n+                cachedElevations = (HashMap<String, PackedCoordinateSequence>) in.readObject();\n+                log.info(\"Cached elevation data loaded into memory!\");\n+            } catch (IOException | ClassNotFoundException e) {\n+                log.warn(graph.addBuilderAnnotation(new Graphwide(\n+                    String.format(\"Cached elevations file could not be read in due to error: %s!\", e.getMessage()))));\n+            }\n+        }\n         log.info(\"Setting street elevation profiles from digital elevation model...\");\n-        List<StreetEdge> edgesWithElevation = new ArrayList<StreetEdge>();\n-        int nProcessed = 0;\n-        int nTotal = graph.countEdges();\n+\n+        ForkJoinPool.ForkJoinWorkerThreadFactory forkJoinWorkerThreadFactory = pool -> new ElevationWorkerThread(pool);\n+\n+        // Multithread elevation calculations\n+        ForkJoinPool forkJoinPool = new ForkJoinPool(\n+            parallelism,\n+            forkJoinWorkerThreadFactory,\n+            null,\n+            false\n+        );\n+\n+        // At first, set the totalElevationEdges to the total number of edges in the graph.\n+        totalElevationEdges = graph.countEdges();\n+        List<StreetWithElevationEdge> streetsWithElevationEdges = new LinkedList<>();\n         for (Vertex gv : graph.getVertices()) {\n             for (Edge ee : gv.getOutgoing()) {\n                 if (ee instanceof StreetWithElevationEdge) {\n-                    StreetWithElevationEdge edgeWithElevation = (StreetWithElevationEdge) ee;\n-                    processEdge(graph, edgeWithElevation);\n-                    if (edgeWithElevation.getElevationProfile() != null && !edgeWithElevation.isElevationFlattened()) {\n-                        edgesWithElevation.add(edgeWithElevation);\n-                    }\n-                    nProcessed += 1;\n-                    if (nProcessed % 50000 == 0) {\n-                        log.info(\"set elevation on {}/{} edges\", nProcessed, nTotal);\n-                        double failurePercentage = nPointsOutsideDEM / nPointsEvaluated * 100;\n-                        if (failurePercentage > 50) {\n-                            log.warn(\"Fetching elevation failed at {}/{} points ({}%)\",\n-                                    nPointsOutsideDEM, nPointsEvaluated, failurePercentage);\n-                            log.warn(\"Elevation is missing at a large number of points. DEM may be for the wrong region. \" +\n-                                    \"If it is unprojected, perhaps the axes are not in (longitude, latitude) order.\");\n-                        }\n-                    }\n+                    forkJoinPool.submit(new ProcessEdgeTask((StreetWithElevationEdge) ee));\n+                    streetsWithElevationEdges.add((StreetWithElevationEdge) ee);\n                 }\n             }\n         }\n+        // update this value to the now-known amount of edges that are StreetWithElevation edges\n+        totalElevationEdges = streetsWithElevationEdges.size();\n+\n+        // store the first coordinate of the first StreetEdge for later use ininitializing coverage instances\n+        examplarCoordinate = streetsWithElevationEdges.get(0).getGeometry().getCoordinates()[0];\n+\n+        // shutdown the forkJoinPool and wait until all tasks are finished. If this takes longer than 1 day, give up.\n+        forkJoinPool.shutdown();\n+        try {\n+            forkJoinPool.awaitTermination(1, TimeUnit.DAYS);\n+        } catch (InterruptedException ex) {\n+            log.error(\"Multi-threaded elevation calculations timed-out!\");\n+            Thread.currentThread().interrupt();\n+            throw new RuntimeException(ex);\n+        }\n+\n+        double failurePercentage = nPointsOutsideDEM.get() / nPointsEvaluated.get() * 100;\n+        if (failurePercentage > 50) {\n+            log.warn(graph.addBuilderAnnotation(new Graphwide(\n+                String.format(\n+                    \"Fetching elevation failed at %d/%d points (%d%%)\",\n+                    nPointsOutsideDEM, nPointsEvaluated, failurePercentage\n+                )\n+            )));\n+            log.warn(\"Elevation is missing at a large number of points. DEM may be for the wrong region. \" +\n+                \"If it is unprojected, perhaps the axes are not in (longitude, latitude) order.\");\n+        }\n+\n+        // iterate again to find edges that had elevation calculated. This is done here instead of in the forkJoinPool\n+        // to avoid thread locking for writes to a synchronized list\n+        LinkedList<StreetEdge> edgesWithCalculatedElevations = new LinkedList<>();\n+        for (StreetWithElevationEdge edgeWithElevation : streetsWithElevationEdges) {\n+            if (edgeWithElevation.hasPackedElevationProfile() && !edgeWithElevation.isElevationFlattened()) {\n+                edgesWithCalculatedElevations.add(edgeWithElevation);\n+            }\n+        }\n \n+        if (writeCachedElevations) {\n+            // write information from edgesWithElevation to a new cache file for subsequent graph builds\n+            HashMap<String, PackedCoordinateSequence> newCachedElevations = new HashMap<>();\n+            for (StreetEdge streetEdge : edgesWithCalculatedElevations) {\n+                newCachedElevations.put(PolylineEncoder.createEncodings(streetEdge.getGeometry()).getPoints(),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9baab1a51d54aa94b9031128b2ffc528d09836b3"}, "originalPosition": 285}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1770, "cost": 1, "resetAt": "2021-11-13T12:10:21Z"}}}