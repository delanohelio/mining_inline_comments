{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDg5MTc2MDky", "number": 3187, "reviewThreads": {"totalCount": 27, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMlQwOToyMDozMFrOEl_y2w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNFQxMDo0NDoyMlrOEm-5Vw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA4Mjc3OTc5OnYy", "diffSide": "RIGHT", "path": "src/main/java/org/opentripplanner/routing/graphfinder/StopAtDistance.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMlQwOToyMDozMFrOHVxZHw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMlQwOToyMDozMFrOHVxZHw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjU5MTM5MQ==", "bodyText": "Move the mapping to a Mapper class under the RoutingWorker, and rename this class to something like NearByStop.", "url": "https://github.com/opentripplanner/OpenTripPlanner/pull/3187#discussion_r492591391", "createdAt": "2020-09-22T09:20:30Z", "author": {"login": "t2gran"}, "path": "src/main/java/org/opentripplanner/routing/graphfinder/StopAtDistance.java", "diffHunk": "@@ -55,6 +57,15 @@ public int compareTo(StopAtDistance that) {\n     return (int) (this.distance) - (int) (that.distance);\n   }\n \n+  public AccessEgress toAccessEgress(StopIndexForRaptor stopIndex, boolean fromTarget) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "29145c7230a80f0c21fc25d5b541d8ad000758b3"}, "originalPosition": 13}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA4MjgwMDU1OnYy", "diffSide": "RIGHT", "path": "src/ext/java/org/opentripplanner/ext/flex/distancecalculator/DistanceCalculator.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMlQwOToyNToxN1rOHVxlBw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMlQwOToyNToxN1rOHVxlBw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjU5NDQzOQ==", "bodyText": "Rename parameters to fromStopIndex, toStopIndex", "url": "https://github.com/opentripplanner/OpenTripPlanner/pull/3187#discussion_r492594439", "createdAt": "2020-09-22T09:25:17Z", "author": {"login": "t2gran"}, "path": "src/ext/java/org/opentripplanner/ext/flex/distancecalculator/DistanceCalculator.java", "diffHunk": "@@ -0,0 +1,11 @@\n+package org.opentripplanner.ext.flex.distancecalculator;\n+\n+import org.opentripplanner.routing.graph.Vertex;\n+\n+/**\n+ * DistanceCalculator is used to calculate the driving times and distances during flex routing\n+ */\n+public interface DistanceCalculator {\n+  DistanceAndDuration getDuration(Vertex fromv, Vertex tov, int fromIndex, int toIndex);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0219bb8f2f795fc9f14b034210507e9722c58edd"}, "originalPosition": 9}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA4Mjg1MDcyOnYy", "diffSide": "RIGHT", "path": "src/ext/java/org/opentripplanner/ext/flex/distancecalculator/DistanceAndDuration.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMlQwOTozODozMFrOHVyDzQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMlQwOTozODozMFrOHVyDzQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjYwMjMxNw==", "bodyText": "Add the geometry here? And then the class name become FlexPath?", "url": "https://github.com/opentripplanner/OpenTripPlanner/pull/3187#discussion_r492602317", "createdAt": "2020-09-22T09:38:30Z", "author": {"login": "t2gran"}, "path": "src/ext/java/org/opentripplanner/ext/flex/distancecalculator/DistanceAndDuration.java", "diffHunk": "@@ -0,0 +1,15 @@\n+package org.opentripplanner.ext.flex.distancecalculator;\n+\n+/**\n+ * This class contains the results from a DistanceCalculator.\n+ */\n+public class DistanceAndDuration {\n+\n+  public int distanceMeters;\n+  public int durationSeconds;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0219bb8f2f795fc9f14b034210507e9722c58edd"}, "originalPosition": 9}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA4Mjg2MjUzOnYy", "diffSide": "RIGHT", "path": "src/ext/java/org/opentripplanner/ext/flex/distancecalculator/StreetDistanceCalculator.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMlQwOTo0MTo0NlrOHVyLOQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMlQwOTo0MTo0NlrOHVyLOQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjYwNDIxNw==", "bodyText": "get more than duration, rename calculaeFlexPath", "url": "https://github.com/opentripplanner/OpenTripPlanner/pull/3187#discussion_r492604217", "createdAt": "2020-09-22T09:41:46Z", "author": {"login": "t2gran"}, "path": "src/ext/java/org/opentripplanner/ext/flex/distancecalculator/StreetDistanceCalculator.java", "diffHunk": "@@ -0,0 +1,58 @@\n+package org.opentripplanner.ext.flex.distancecalculator;\n+\n+import org.opentripplanner.common.model.T2;\n+import org.opentripplanner.routing.algorithm.astar.AStar;\n+import org.opentripplanner.routing.api.request.RoutingRequest;\n+import org.opentripplanner.routing.core.TraverseMode;\n+import org.opentripplanner.routing.graph.Edge;\n+import org.opentripplanner.routing.graph.Graph;\n+import org.opentripplanner.routing.graph.Vertex;\n+import org.opentripplanner.routing.spt.DominanceFunction;\n+import org.opentripplanner.routing.spt.GraphPath;\n+import org.opentripplanner.routing.spt.ShortestPathTree;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+/**\n+ * StreetDistanceCalculator calculates the driving times and distances based on the street network\n+ * using the AStar algorithm.\n+ *\n+ * TODO: - Mast fast enough to be usable\n+ *       - Use a one-to-many search\n+ *       - Cache found times\n+ */\n+public class StreetDistanceCalculator implements DistanceCalculator {\n+  private Graph graph;\n+  private Map<T2<Vertex, Vertex>, DistanceAndDuration> cache = new HashMap<>();\n+\n+  public StreetDistanceCalculator(Graph graph) {\n+    this.graph = graph;\n+  }\n+\n+  @Override\n+  public DistanceAndDuration getDuration(Vertex fromv, Vertex tov, int fromIndex, int toIndex) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0219bb8f2f795fc9f14b034210507e9722c58edd"}, "originalPosition": 34}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA4Mjg2NjE3OnYy", "diffSide": "RIGHT", "path": "src/ext/java/org/opentripplanner/ext/flex/distancecalculator/StreetDistanceCalculator.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMlQwOTo0Mjo0OVrOHVyNZQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMlQwOTo0Mjo0OVrOHVyNZQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjYwNDc3Mw==", "bodyText": "What happes if we can not find a path?", "url": "https://github.com/opentripplanner/OpenTripPlanner/pull/3187#discussion_r492604773", "createdAt": "2020-09-22T09:42:49Z", "author": {"login": "t2gran"}, "path": "src/ext/java/org/opentripplanner/ext/flex/distancecalculator/StreetDistanceCalculator.java", "diffHunk": "@@ -0,0 +1,58 @@\n+package org.opentripplanner.ext.flex.distancecalculator;\n+\n+import org.opentripplanner.common.model.T2;\n+import org.opentripplanner.routing.algorithm.astar.AStar;\n+import org.opentripplanner.routing.api.request.RoutingRequest;\n+import org.opentripplanner.routing.core.TraverseMode;\n+import org.opentripplanner.routing.graph.Edge;\n+import org.opentripplanner.routing.graph.Graph;\n+import org.opentripplanner.routing.graph.Vertex;\n+import org.opentripplanner.routing.spt.DominanceFunction;\n+import org.opentripplanner.routing.spt.GraphPath;\n+import org.opentripplanner.routing.spt.ShortestPathTree;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+/**\n+ * StreetDistanceCalculator calculates the driving times and distances based on the street network\n+ * using the AStar algorithm.\n+ *\n+ * TODO: - Mast fast enough to be usable\n+ *       - Use a one-to-many search\n+ *       - Cache found times\n+ */\n+public class StreetDistanceCalculator implements DistanceCalculator {\n+  private Graph graph;\n+  private Map<T2<Vertex, Vertex>, DistanceAndDuration> cache = new HashMap<>();\n+\n+  public StreetDistanceCalculator(Graph graph) {\n+    this.graph = graph;\n+  }\n+\n+  @Override\n+  public DistanceAndDuration getDuration(Vertex fromv, Vertex tov, int fromIndex, int toIndex) {\n+    T2<Vertex, Vertex> key = new T2<>(fromv, tov);\n+    DistanceAndDuration cacheValue = cache.get(key);\n+    if (cacheValue != null) return cacheValue;\n+\n+    RoutingRequest routingRequest = new RoutingRequest(TraverseMode.CAR);\n+    routingRequest.setNumItineraries(1);\n+\n+    routingRequest.setRoutingContext(graph, fromv, tov);\n+    routingRequest.dominanceFunction = new DominanceFunction.EarliestArrival();\n+    AStar search = new AStar();\n+    ShortestPathTree spt = search.getShortestPathTree(routingRequest);\n+\n+    GraphPath path = spt.getPaths().get(0);\n+\n+    int distance = (int) path.edges.stream().mapToDouble(Edge::getDistanceMeters).sum();\n+    int duration = path.getDuration();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0219bb8f2f795fc9f14b034210507e9722c58edd"}, "originalPosition": 50}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA4Mjg4MDc4OnYy", "diffSide": "RIGHT", "path": "src/main/java/org/opentripplanner/graph_builder/linking/SimpleStreetSplitter.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMlQwOTo0Njo1OFrOHVyWgA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNFQwNzowNDowN1rOHXMeFA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjYwNzEwNA==", "bodyText": "Use the isEligibleForCarPickupDropOff()  here instead.", "url": "https://github.com/opentripplanner/OpenTripPlanner/pull/3187#discussion_r492607104", "createdAt": "2020-09-22T09:46:58Z", "author": {"login": "t2gran"}, "path": "src/main/java/org/opentripplanner/graph_builder/linking/SimpleStreetSplitter.java", "diffHunk": "@@ -408,6 +412,22 @@ else if (ll.getSegmentIndex() == orig.getNumPoints() - 2 && ll.getSegmentFractio\n             SplitterVertex v0 = split(edge, ll, temporaryVertex != null, endVertex);\n             makeLinkEdges(tstop, v0);\n \n+            if (OTPFeature.FlexRouting.isOn() && graph.index != null) {\n+                Point p = GeometryUtils\n+                    .getGeometryFactory()\n+                    .createPoint(v0.getCoordinate());\n+                Envelope env = p.getEnvelopeInternal();\n+                for (FlexStopLocation flexStopLocation : graph.index.getFlexIndex().locationIndex.query(env)) {\n+                    if (edge.canTraverse(new TraverseModeSet(TraverseMode.CAR))", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9f70dbc10f1e0f69f6e686b42085fc5eb8b1b837"}, "originalPosition": 40}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDA4MzYwNA==", "bodyText": "Using StreetTraversalPermission.PEDESTRIAN_AND_CAR, as isEligibleForCarPickupDropOff() operates on vertices", "url": "https://github.com/opentripplanner/OpenTripPlanner/pull/3187#discussion_r494083604", "createdAt": "2020-09-24T07:04:07Z", "author": {"login": "hannesj"}, "path": "src/main/java/org/opentripplanner/graph_builder/linking/SimpleStreetSplitter.java", "diffHunk": "@@ -408,6 +412,22 @@ else if (ll.getSegmentIndex() == orig.getNumPoints() - 2 && ll.getSegmentFractio\n             SplitterVertex v0 = split(edge, ll, temporaryVertex != null, endVertex);\n             makeLinkEdges(tstop, v0);\n \n+            if (OTPFeature.FlexRouting.isOn() && graph.index != null) {\n+                Point p = GeometryUtils\n+                    .getGeometryFactory()\n+                    .createPoint(v0.getCoordinate());\n+                Envelope env = p.getEnvelopeInternal();\n+                for (FlexStopLocation flexStopLocation : graph.index.getFlexIndex().locationIndex.query(env)) {\n+                    if (edge.canTraverse(new TraverseModeSet(TraverseMode.CAR))", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjYwNzEwNA=="}, "originalCommit": {"oid": "9f70dbc10f1e0f69f6e686b42085fc5eb8b1b837"}, "originalPosition": 40}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA4Mjk0NTc5OnYy", "diffSide": "RIGHT", "path": "src/ext/java/org/opentripplanner/ext/flex/FlexAccessEgress.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMlQxMDowNDoxNlrOHVy9eA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMlQxMDowNDoxNlrOHVy9eA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjYxNzA4MA==", "bodyText": "Decuple the raptor API from Flex", "url": "https://github.com/opentripplanner/OpenTripPlanner/pull/3187#discussion_r492617080", "createdAt": "2020-09-22T10:04:16Z", "author": {"login": "t2gran"}, "path": "src/ext/java/org/opentripplanner/ext/flex/FlexAccessEgress.java", "diffHunk": "@@ -0,0 +1,76 @@\n+package org.opentripplanner.ext.flex;\n+\n+import org.opentripplanner.ext.flex.trip.FlexTrip;\n+import org.opentripplanner.routing.algorithm.raptor.transit.AccessEgress;\n+import org.opentripplanner.routing.core.State;\n+\n+public class FlexAccessEgress extends AccessEgress {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "41d4f78595351387691e689a96c930c0940ce274"}, "originalPosition": 7}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA4Mjk2NjUyOnYy", "diffSide": "RIGHT", "path": "src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMlQxMDoxMDoxNFrOHVzKEQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMlQxMDoxMDoxNFrOHVzKEQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjYyMDMwNQ==", "bodyText": "Remove this parameter, the stopIndex - it should not be necessary if the mapping to Raptor is moved out of flex.", "url": "https://github.com/opentripplanner/OpenTripPlanner/pull/3187#discussion_r492620305", "createdAt": "2020-09-22T10:10:14Z", "author": {"login": "t2gran"}, "path": "src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java", "diffHunk": "@@ -0,0 +1,200 @@\n+package org.opentripplanner.ext.flex;\n+\n+import gnu.trove.set.TIntSet;\n+import org.opentripplanner.common.model.T2;\n+import org.opentripplanner.ext.flex.distancecalculator.DirectDistanceCalculator;\n+import org.opentripplanner.ext.flex.distancecalculator.DistanceCalculator;\n+import org.opentripplanner.ext.flex.template.FlexAccessTemplate;\n+import org.opentripplanner.ext.flex.template.FlexEgressTemplate;\n+import org.opentripplanner.ext.flex.trip.FlexTrip;\n+import org.opentripplanner.model.Stop;\n+import org.opentripplanner.model.StopLocation;\n+import org.opentripplanner.model.Transfer;\n+import org.opentripplanner.model.calendar.ServiceDate;\n+import org.opentripplanner.model.plan.Itinerary;\n+import org.opentripplanner.routing.algorithm.raptor.transit.StopIndexForRaptor;\n+import org.opentripplanner.routing.algorithm.raptor.transit.mappers.DateMapper;\n+import org.opentripplanner.routing.api.request.RoutingRequest;\n+import org.opentripplanner.routing.graph.Graph;\n+import org.opentripplanner.routing.graphfinder.StopAtDistance;\n+\n+import java.time.Instant;\n+import java.time.LocalDate;\n+import java.time.ZoneId;\n+import java.time.ZonedDateTime;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Comparator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+\n+public class FlexRouter {\n+\n+  /* Transit data */\n+  private final Graph graph;\n+  private final Collection<StopAtDistance> streetAccesses;\n+  private final Collection<StopAtDistance> streetEgresses;\n+  private final StopIndexForRaptor stopIndex;\n+  private final Collection<Transfer> transitTransfers;\n+  private final FlexIndex flexIndex;\n+  private final DistanceCalculator distanceCalculator;\n+\n+  /* Request data */\n+  private final ZonedDateTime startOfTime;\n+  private final int departureTime;\n+  private final boolean arriveBy;\n+\n+  private final TIntSet[] servicesRunning;\n+  private final int[] differenceFromStartOfTime;\n+  private final ServiceDate[] serviceDates;\n+\n+  /* State */\n+  private List<FlexAccessTemplate> flexAccessTemplates = null;\n+  private List<FlexEgressTemplate> flexEgressTemplates = null;\n+\n+  public FlexRouter(\n+      RoutingRequest request,\n+      int additionalPastSearchDays,\n+      int additionalFutureSearchDays,\n+      Collection<StopAtDistance> streetAccesses,\n+      Collection<StopAtDistance> egressTransfers,\n+      StopIndexForRaptor stopIndex", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "41d4f78595351387691e689a96c930c0940ce274"}, "originalPosition": 66}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA4Mjk5OTE3OnYy", "diffSide": "RIGHT", "path": "src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMlQxMDoxOTo1NVrOHVzeEg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMlQxMDoxOTo1NVrOHVzeEg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjYyNTQyNg==", "bodyText": "Maybe something like this:\nclass FlexServicesOnDate {\n  private final TIntSet servicesRunning;\n  private final int secondsFromStartOfTime;\n  private final ServiceDate serviceDate;\n}", "url": "https://github.com/opentripplanner/OpenTripPlanner/pull/3187#discussion_r492625426", "createdAt": "2020-09-22T10:19:55Z", "author": {"login": "t2gran"}, "path": "src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java", "diffHunk": "@@ -0,0 +1,200 @@\n+package org.opentripplanner.ext.flex;\n+\n+import gnu.trove.set.TIntSet;\n+import org.opentripplanner.common.model.T2;\n+import org.opentripplanner.ext.flex.distancecalculator.DirectDistanceCalculator;\n+import org.opentripplanner.ext.flex.distancecalculator.DistanceCalculator;\n+import org.opentripplanner.ext.flex.template.FlexAccessTemplate;\n+import org.opentripplanner.ext.flex.template.FlexEgressTemplate;\n+import org.opentripplanner.ext.flex.trip.FlexTrip;\n+import org.opentripplanner.model.Stop;\n+import org.opentripplanner.model.StopLocation;\n+import org.opentripplanner.model.Transfer;\n+import org.opentripplanner.model.calendar.ServiceDate;\n+import org.opentripplanner.model.plan.Itinerary;\n+import org.opentripplanner.routing.algorithm.raptor.transit.StopIndexForRaptor;\n+import org.opentripplanner.routing.algorithm.raptor.transit.mappers.DateMapper;\n+import org.opentripplanner.routing.api.request.RoutingRequest;\n+import org.opentripplanner.routing.graph.Graph;\n+import org.opentripplanner.routing.graphfinder.StopAtDistance;\n+\n+import java.time.Instant;\n+import java.time.LocalDate;\n+import java.time.ZoneId;\n+import java.time.ZonedDateTime;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Comparator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+\n+public class FlexRouter {\n+\n+  /* Transit data */\n+  private final Graph graph;\n+  private final Collection<StopAtDistance> streetAccesses;\n+  private final Collection<StopAtDistance> streetEgresses;\n+  private final StopIndexForRaptor stopIndex;\n+  private final Collection<Transfer> transitTransfers;\n+  private final FlexIndex flexIndex;\n+  private final DistanceCalculator distanceCalculator;\n+\n+  /* Request data */\n+  private final ZonedDateTime startOfTime;\n+  private final int departureTime;\n+  private final boolean arriveBy;\n+\n+  private final TIntSet[] servicesRunning;\n+  private final int[] differenceFromStartOfTime;\n+  private final ServiceDate[] serviceDates;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "41d4f78595351387691e689a96c930c0940ce274"}, "originalPosition": 54}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA4MzAzMDgzOnYy", "diffSide": "RIGHT", "path": "src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMlQxMDoyOTo0MFrOHVzxbw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMlQxMDoyOTo0MFrOHVzxbw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjYzMDM4Mw==", "bodyText": "Maybe add some JavaDoc on this method to explain the the intention of the method and any optimalizations.", "url": "https://github.com/opentripplanner/OpenTripPlanner/pull/3187#discussion_r492630383", "createdAt": "2020-09-22T10:29:40Z", "author": {"login": "t2gran"}, "path": "src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java", "diffHunk": "@@ -0,0 +1,200 @@\n+package org.opentripplanner.ext.flex;\n+\n+import gnu.trove.set.TIntSet;\n+import org.opentripplanner.common.model.T2;\n+import org.opentripplanner.ext.flex.distancecalculator.DirectDistanceCalculator;\n+import org.opentripplanner.ext.flex.distancecalculator.DistanceCalculator;\n+import org.opentripplanner.ext.flex.template.FlexAccessTemplate;\n+import org.opentripplanner.ext.flex.template.FlexEgressTemplate;\n+import org.opentripplanner.ext.flex.trip.FlexTrip;\n+import org.opentripplanner.model.Stop;\n+import org.opentripplanner.model.StopLocation;\n+import org.opentripplanner.model.Transfer;\n+import org.opentripplanner.model.calendar.ServiceDate;\n+import org.opentripplanner.model.plan.Itinerary;\n+import org.opentripplanner.routing.algorithm.raptor.transit.StopIndexForRaptor;\n+import org.opentripplanner.routing.algorithm.raptor.transit.mappers.DateMapper;\n+import org.opentripplanner.routing.api.request.RoutingRequest;\n+import org.opentripplanner.routing.graph.Graph;\n+import org.opentripplanner.routing.graphfinder.StopAtDistance;\n+\n+import java.time.Instant;\n+import java.time.LocalDate;\n+import java.time.ZoneId;\n+import java.time.ZonedDateTime;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Comparator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+\n+public class FlexRouter {\n+\n+  /* Transit data */\n+  private final Graph graph;\n+  private final Collection<StopAtDistance> streetAccesses;\n+  private final Collection<StopAtDistance> streetEgresses;\n+  private final StopIndexForRaptor stopIndex;\n+  private final Collection<Transfer> transitTransfers;\n+  private final FlexIndex flexIndex;\n+  private final DistanceCalculator distanceCalculator;\n+\n+  /* Request data */\n+  private final ZonedDateTime startOfTime;\n+  private final int departureTime;\n+  private final boolean arriveBy;\n+\n+  private final TIntSet[] servicesRunning;\n+  private final int[] differenceFromStartOfTime;\n+  private final ServiceDate[] serviceDates;\n+\n+  /* State */\n+  private List<FlexAccessTemplate> flexAccessTemplates = null;\n+  private List<FlexEgressTemplate> flexEgressTemplates = null;\n+\n+  public FlexRouter(\n+      RoutingRequest request,\n+      int additionalPastSearchDays,\n+      int additionalFutureSearchDays,\n+      Collection<StopAtDistance> streetAccesses,\n+      Collection<StopAtDistance> egressTransfers,\n+      StopIndexForRaptor stopIndex\n+  ) {\n+    this.graph = request.rctx.graph;\n+    this.streetAccesses = streetAccesses;\n+    this.streetEgresses = egressTransfers;\n+    this.stopIndex = stopIndex;\n+    this.transitTransfers = graph.getTransferTable().getTransfers();\n+    this.flexIndex = graph.index.getFlexIndex();\n+    this.distanceCalculator = new DirectDistanceCalculator(graph);\n+\n+    ZoneId tz = graph.getTimeZone().toZoneId();\n+    Instant searchInstant = request.getDateTime().toInstant();\n+    LocalDate searchDate = LocalDate.ofInstant(searchInstant, tz);\n+    this.startOfTime = DateMapper.asStartOfService(searchDate, tz);\n+    this.departureTime = DateMapper.secondsSinceStartOfTime(startOfTime, searchInstant);\n+    this.arriveBy = request.arriveBy;\n+\n+    int totalDays = additionalPastSearchDays + 1 + additionalFutureSearchDays;\n+\n+    this.differenceFromStartOfTime = new int[totalDays];\n+    this.servicesRunning = new TIntSet[totalDays];\n+    this.serviceDates = new ServiceDate[totalDays];\n+\n+    for (int d = -additionalPastSearchDays; d <= additionalFutureSearchDays; ++d) {\n+      LocalDate date = searchDate.plusDays(d);\n+      int index = d + additionalPastSearchDays;\n+      ServiceDate serviceDate = new ServiceDate(date);\n+      differenceFromStartOfTime[index] = DateMapper.secondsSinceStartOfTime(startOfTime, date);\n+      servicesRunning[index] = graph.index.getServiceCodesRunningForDate().get(serviceDate);\n+      serviceDates[index] = serviceDate;\n+    }\n+  }\n+\n+  private void calculateFlexAccessTemplates() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "41d4f78595351387691e689a96c930c0940ce274"}, "originalPosition": 99}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA4MzAzNzY3OnYy", "diffSide": "RIGHT", "path": "src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMlQxMDozMTo0MFrOHVz1ng==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMlQxMDozMTo0MFrOHVz1ng==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjYzMTQ1NA==", "bodyText": "Make this a local varable.", "url": "https://github.com/opentripplanner/OpenTripPlanner/pull/3187#discussion_r492631454", "createdAt": "2020-09-22T10:31:40Z", "author": {"login": "t2gran"}, "path": "src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java", "diffHunk": "@@ -0,0 +1,200 @@\n+package org.opentripplanner.ext.flex;\n+\n+import gnu.trove.set.TIntSet;\n+import org.opentripplanner.common.model.T2;\n+import org.opentripplanner.ext.flex.distancecalculator.DirectDistanceCalculator;\n+import org.opentripplanner.ext.flex.distancecalculator.DistanceCalculator;\n+import org.opentripplanner.ext.flex.template.FlexAccessTemplate;\n+import org.opentripplanner.ext.flex.template.FlexEgressTemplate;\n+import org.opentripplanner.ext.flex.trip.FlexTrip;\n+import org.opentripplanner.model.Stop;\n+import org.opentripplanner.model.StopLocation;\n+import org.opentripplanner.model.Transfer;\n+import org.opentripplanner.model.calendar.ServiceDate;\n+import org.opentripplanner.model.plan.Itinerary;\n+import org.opentripplanner.routing.algorithm.raptor.transit.StopIndexForRaptor;\n+import org.opentripplanner.routing.algorithm.raptor.transit.mappers.DateMapper;\n+import org.opentripplanner.routing.api.request.RoutingRequest;\n+import org.opentripplanner.routing.graph.Graph;\n+import org.opentripplanner.routing.graphfinder.StopAtDistance;\n+\n+import java.time.Instant;\n+import java.time.LocalDate;\n+import java.time.ZoneId;\n+import java.time.ZonedDateTime;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Comparator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+\n+public class FlexRouter {\n+\n+  /* Transit data */\n+  private final Graph graph;\n+  private final Collection<StopAtDistance> streetAccesses;\n+  private final Collection<StopAtDistance> streetEgresses;\n+  private final StopIndexForRaptor stopIndex;\n+  private final Collection<Transfer> transitTransfers;\n+  private final FlexIndex flexIndex;\n+  private final DistanceCalculator distanceCalculator;\n+\n+  /* Request data */\n+  private final ZonedDateTime startOfTime;\n+  private final int departureTime;\n+  private final boolean arriveBy;\n+\n+  private final TIntSet[] servicesRunning;\n+  private final int[] differenceFromStartOfTime;\n+  private final ServiceDate[] serviceDates;\n+\n+  /* State */\n+  private List<FlexAccessTemplate> flexAccessTemplates = null;\n+  private List<FlexEgressTemplate> flexEgressTemplates = null;\n+\n+  public FlexRouter(\n+      RoutingRequest request,\n+      int additionalPastSearchDays,\n+      int additionalFutureSearchDays,\n+      Collection<StopAtDistance> streetAccesses,\n+      Collection<StopAtDistance> egressTransfers,\n+      StopIndexForRaptor stopIndex\n+  ) {\n+    this.graph = request.rctx.graph;\n+    this.streetAccesses = streetAccesses;\n+    this.streetEgresses = egressTransfers;\n+    this.stopIndex = stopIndex;\n+    this.transitTransfers = graph.getTransferTable().getTransfers();\n+    this.flexIndex = graph.index.getFlexIndex();\n+    this.distanceCalculator = new DirectDistanceCalculator(graph);\n+\n+    ZoneId tz = graph.getTimeZone().toZoneId();\n+    Instant searchInstant = request.getDateTime().toInstant();\n+    LocalDate searchDate = LocalDate.ofInstant(searchInstant, tz);\n+    this.startOfTime = DateMapper.asStartOfService(searchDate, tz);\n+    this.departureTime = DateMapper.secondsSinceStartOfTime(startOfTime, searchInstant);\n+    this.arriveBy = request.arriveBy;\n+\n+    int totalDays = additionalPastSearchDays + 1 + additionalFutureSearchDays;\n+\n+    this.differenceFromStartOfTime = new int[totalDays];\n+    this.servicesRunning = new TIntSet[totalDays];\n+    this.serviceDates = new ServiceDate[totalDays];\n+\n+    for (int d = -additionalPastSearchDays; d <= additionalFutureSearchDays; ++d) {\n+      LocalDate date = searchDate.plusDays(d);\n+      int index = d + additionalPastSearchDays;\n+      ServiceDate serviceDate = new ServiceDate(date);\n+      differenceFromStartOfTime[index] = DateMapper.secondsSinceStartOfTime(startOfTime, date);\n+      servicesRunning[index] = graph.index.getServiceCodesRunningForDate().get(serviceDate);\n+      serviceDates[index] = serviceDate;\n+    }\n+  }\n+\n+  private void calculateFlexAccessTemplates() {\n+    if (this.flexAccessTemplates != null) { return; }\n+\n+    this.flexAccessTemplates = streetAccesses\n+        .stream()\n+        .flatMap(accessEgress -> flexIndex\n+            .getFlexTripsByStop(accessEgress.stop)\n+            .map(flexTrip -> new T2<>(accessEgress, flexTrip)))\n+        .collect(Collectors.groupingBy(t2 -> t2.second))\n+        .values()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "41d4f78595351387691e689a96c930c0940ce274"}, "originalPosition": 108}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA4MzA2ODY1OnYy", "diffSide": "RIGHT", "path": "src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMlQxMDo0MDo1OFrOHV0IDg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMlQxMDo0MDo1OFrOHV0IDg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjYzNjE3NA==", "bodyText": "Add the call of these methods to the beginning of the method.", "url": "https://github.com/opentripplanner/OpenTripPlanner/pull/3187#discussion_r492636174", "createdAt": "2020-09-22T10:40:58Z", "author": {"login": "t2gran"}, "path": "src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java", "diffHunk": "@@ -0,0 +1,200 @@\n+package org.opentripplanner.ext.flex;\n+\n+import gnu.trove.set.TIntSet;\n+import org.opentripplanner.common.model.T2;\n+import org.opentripplanner.ext.flex.distancecalculator.DirectDistanceCalculator;\n+import org.opentripplanner.ext.flex.distancecalculator.DistanceCalculator;\n+import org.opentripplanner.ext.flex.template.FlexAccessTemplate;\n+import org.opentripplanner.ext.flex.template.FlexEgressTemplate;\n+import org.opentripplanner.ext.flex.trip.FlexTrip;\n+import org.opentripplanner.model.Stop;\n+import org.opentripplanner.model.StopLocation;\n+import org.opentripplanner.model.Transfer;\n+import org.opentripplanner.model.calendar.ServiceDate;\n+import org.opentripplanner.model.plan.Itinerary;\n+import org.opentripplanner.routing.algorithm.raptor.transit.StopIndexForRaptor;\n+import org.opentripplanner.routing.algorithm.raptor.transit.mappers.DateMapper;\n+import org.opentripplanner.routing.api.request.RoutingRequest;\n+import org.opentripplanner.routing.graph.Graph;\n+import org.opentripplanner.routing.graphfinder.StopAtDistance;\n+\n+import java.time.Instant;\n+import java.time.LocalDate;\n+import java.time.ZoneId;\n+import java.time.ZonedDateTime;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Comparator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+\n+public class FlexRouter {\n+\n+  /* Transit data */\n+  private final Graph graph;\n+  private final Collection<StopAtDistance> streetAccesses;\n+  private final Collection<StopAtDistance> streetEgresses;\n+  private final StopIndexForRaptor stopIndex;\n+  private final Collection<Transfer> transitTransfers;\n+  private final FlexIndex flexIndex;\n+  private final DistanceCalculator distanceCalculator;\n+\n+  /* Request data */\n+  private final ZonedDateTime startOfTime;\n+  private final int departureTime;\n+  private final boolean arriveBy;\n+\n+  private final TIntSet[] servicesRunning;\n+  private final int[] differenceFromStartOfTime;\n+  private final ServiceDate[] serviceDates;\n+\n+  /* State */\n+  private List<FlexAccessTemplate> flexAccessTemplates = null;\n+  private List<FlexEgressTemplate> flexEgressTemplates = null;\n+\n+  public FlexRouter(\n+      RoutingRequest request,\n+      int additionalPastSearchDays,\n+      int additionalFutureSearchDays,\n+      Collection<StopAtDistance> streetAccesses,\n+      Collection<StopAtDistance> egressTransfers,\n+      StopIndexForRaptor stopIndex\n+  ) {\n+    this.graph = request.rctx.graph;\n+    this.streetAccesses = streetAccesses;\n+    this.streetEgresses = egressTransfers;\n+    this.stopIndex = stopIndex;\n+    this.transitTransfers = graph.getTransferTable().getTransfers();\n+    this.flexIndex = graph.index.getFlexIndex();\n+    this.distanceCalculator = new DirectDistanceCalculator(graph);\n+\n+    ZoneId tz = graph.getTimeZone().toZoneId();\n+    Instant searchInstant = request.getDateTime().toInstant();\n+    LocalDate searchDate = LocalDate.ofInstant(searchInstant, tz);\n+    this.startOfTime = DateMapper.asStartOfService(searchDate, tz);\n+    this.departureTime = DateMapper.secondsSinceStartOfTime(startOfTime, searchInstant);\n+    this.arriveBy = request.arriveBy;\n+\n+    int totalDays = additionalPastSearchDays + 1 + additionalFutureSearchDays;\n+\n+    this.differenceFromStartOfTime = new int[totalDays];\n+    this.servicesRunning = new TIntSet[totalDays];\n+    this.serviceDates = new ServiceDate[totalDays];\n+\n+    for (int d = -additionalPastSearchDays; d <= additionalFutureSearchDays; ++d) {\n+      LocalDate date = searchDate.plusDays(d);\n+      int index = d + additionalPastSearchDays;\n+      ServiceDate serviceDate = new ServiceDate(date);\n+      differenceFromStartOfTime[index] = DateMapper.secondsSinceStartOfTime(startOfTime, date);\n+      servicesRunning[index] = graph.index.getServiceCodesRunningForDate().get(serviceDate);\n+      serviceDates[index] = serviceDate;\n+    }\n+  }\n+\n+  private void calculateFlexAccessTemplates() {\n+    if (this.flexAccessTemplates != null) { return; }\n+\n+    this.flexAccessTemplates = streetAccesses\n+        .stream()\n+        .flatMap(accessEgress -> flexIndex\n+            .getFlexTripsByStop(accessEgress.stop)\n+            .map(flexTrip -> new T2<>(accessEgress, flexTrip)))\n+        .collect(Collectors.groupingBy(t2 -> t2.second))\n+        .values()\n+        .stream()\n+        .map(t2s -> t2s.stream().min(Comparator.comparingLong(t2 -> t2.first.state.getElapsedTimeSeconds())))\n+        .flatMap(Optional::stream)\n+        .flatMap(t2 -> IntStream.range(0, servicesRunning.length)\n+            .filter(i -> isFlexTripRunning(servicesRunning[i], t2.second))\n+            .mapToObj(i -> t2.second.getFlexAccessTemplates(\n+                t2.first,\n+                differenceFromStartOfTime[i],\n+                serviceDates[i],\n+                distanceCalculator\n+            ))\n+            // TODO: Optimization: Could we filter here if earliestDepartureTime or latestArrivalTime is -1\n+            .flatMap(Function.identity()))\n+        .collect(Collectors.toList());\n+  }\n+\n+  private void calculateFlexEgressTemplates() {\n+    if (this.flexEgressTemplates != null) { return; }\n+\n+    this.flexEgressTemplates = streetEgresses\n+        .stream()\n+        .flatMap(accessEgress -> flexIndex\n+            .getFlexTripsByStop(accessEgress.stop)\n+            .map(flexTrip -> new T2<>(accessEgress, flexTrip)))\n+        .collect(Collectors.groupingBy(t2 -> t2.second))\n+        .values()\n+        .stream()\n+        .map(t2s -> t2s.stream().min(Comparator.comparingLong(t2 -> t2.first.state.getElapsedTimeSeconds())))\n+        .flatMap(Optional::stream)\n+        .flatMap(t2 -> IntStream.range(0, servicesRunning.length)\n+            .filter(i -> isFlexTripRunning(servicesRunning[i], t2.second))\n+            .mapToObj(i -> t2.second.getFlexEgressTemplates(\n+                t2.first,\n+                differenceFromStartOfTime[i],\n+                serviceDates[i],\n+                distanceCalculator\n+            ))\n+            // TODO: Optimization: Could we filter here if earliestDepartureTime or latestArrivalTime is -1\n+            .flatMap(Function.identity()))\n+        .collect(Collectors.toList());\n+  }\n+\n+\n+  public Collection<Itinerary> getFlexOnlyItineraries() {\n+    Map<StopLocation, StopAtDistance> egressTransferByStop = streetEgresses\n+        .stream()\n+        .collect(Collectors.toMap(stopAtDistance -> stopAtDistance.stop, Function.identity()));\n+\n+    Set<StopLocation> egressStops = egressTransferByStop.keySet();\n+\n+    calculateFlexAccessTemplates();\n+    calculateFlexEgressTemplates();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "41d4f78595351387691e689a96c930c0940ce274"}, "originalPosition": 160}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA4MzA3MDU4OnYy", "diffSide": "RIGHT", "path": "src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMlQxMDo0MTo0MVrOHV0JWQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMlQxMDo0MTo0MVrOHV0JWQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjYzNjUwNQ==", "bodyText": "Maybe rename to streetEgressByStop", "url": "https://github.com/opentripplanner/OpenTripPlanner/pull/3187#discussion_r492636505", "createdAt": "2020-09-22T10:41:41Z", "author": {"login": "t2gran"}, "path": "src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java", "diffHunk": "@@ -0,0 +1,200 @@\n+package org.opentripplanner.ext.flex;\n+\n+import gnu.trove.set.TIntSet;\n+import org.opentripplanner.common.model.T2;\n+import org.opentripplanner.ext.flex.distancecalculator.DirectDistanceCalculator;\n+import org.opentripplanner.ext.flex.distancecalculator.DistanceCalculator;\n+import org.opentripplanner.ext.flex.template.FlexAccessTemplate;\n+import org.opentripplanner.ext.flex.template.FlexEgressTemplate;\n+import org.opentripplanner.ext.flex.trip.FlexTrip;\n+import org.opentripplanner.model.Stop;\n+import org.opentripplanner.model.StopLocation;\n+import org.opentripplanner.model.Transfer;\n+import org.opentripplanner.model.calendar.ServiceDate;\n+import org.opentripplanner.model.plan.Itinerary;\n+import org.opentripplanner.routing.algorithm.raptor.transit.StopIndexForRaptor;\n+import org.opentripplanner.routing.algorithm.raptor.transit.mappers.DateMapper;\n+import org.opentripplanner.routing.api.request.RoutingRequest;\n+import org.opentripplanner.routing.graph.Graph;\n+import org.opentripplanner.routing.graphfinder.StopAtDistance;\n+\n+import java.time.Instant;\n+import java.time.LocalDate;\n+import java.time.ZoneId;\n+import java.time.ZonedDateTime;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Comparator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+\n+public class FlexRouter {\n+\n+  /* Transit data */\n+  private final Graph graph;\n+  private final Collection<StopAtDistance> streetAccesses;\n+  private final Collection<StopAtDistance> streetEgresses;\n+  private final StopIndexForRaptor stopIndex;\n+  private final Collection<Transfer> transitTransfers;\n+  private final FlexIndex flexIndex;\n+  private final DistanceCalculator distanceCalculator;\n+\n+  /* Request data */\n+  private final ZonedDateTime startOfTime;\n+  private final int departureTime;\n+  private final boolean arriveBy;\n+\n+  private final TIntSet[] servicesRunning;\n+  private final int[] differenceFromStartOfTime;\n+  private final ServiceDate[] serviceDates;\n+\n+  /* State */\n+  private List<FlexAccessTemplate> flexAccessTemplates = null;\n+  private List<FlexEgressTemplate> flexEgressTemplates = null;\n+\n+  public FlexRouter(\n+      RoutingRequest request,\n+      int additionalPastSearchDays,\n+      int additionalFutureSearchDays,\n+      Collection<StopAtDistance> streetAccesses,\n+      Collection<StopAtDistance> egressTransfers,\n+      StopIndexForRaptor stopIndex\n+  ) {\n+    this.graph = request.rctx.graph;\n+    this.streetAccesses = streetAccesses;\n+    this.streetEgresses = egressTransfers;\n+    this.stopIndex = stopIndex;\n+    this.transitTransfers = graph.getTransferTable().getTransfers();\n+    this.flexIndex = graph.index.getFlexIndex();\n+    this.distanceCalculator = new DirectDistanceCalculator(graph);\n+\n+    ZoneId tz = graph.getTimeZone().toZoneId();\n+    Instant searchInstant = request.getDateTime().toInstant();\n+    LocalDate searchDate = LocalDate.ofInstant(searchInstant, tz);\n+    this.startOfTime = DateMapper.asStartOfService(searchDate, tz);\n+    this.departureTime = DateMapper.secondsSinceStartOfTime(startOfTime, searchInstant);\n+    this.arriveBy = request.arriveBy;\n+\n+    int totalDays = additionalPastSearchDays + 1 + additionalFutureSearchDays;\n+\n+    this.differenceFromStartOfTime = new int[totalDays];\n+    this.servicesRunning = new TIntSet[totalDays];\n+    this.serviceDates = new ServiceDate[totalDays];\n+\n+    for (int d = -additionalPastSearchDays; d <= additionalFutureSearchDays; ++d) {\n+      LocalDate date = searchDate.plusDays(d);\n+      int index = d + additionalPastSearchDays;\n+      ServiceDate serviceDate = new ServiceDate(date);\n+      differenceFromStartOfTime[index] = DateMapper.secondsSinceStartOfTime(startOfTime, date);\n+      servicesRunning[index] = graph.index.getServiceCodesRunningForDate().get(serviceDate);\n+      serviceDates[index] = serviceDate;\n+    }\n+  }\n+\n+  private void calculateFlexAccessTemplates() {\n+    if (this.flexAccessTemplates != null) { return; }\n+\n+    this.flexAccessTemplates = streetAccesses\n+        .stream()\n+        .flatMap(accessEgress -> flexIndex\n+            .getFlexTripsByStop(accessEgress.stop)\n+            .map(flexTrip -> new T2<>(accessEgress, flexTrip)))\n+        .collect(Collectors.groupingBy(t2 -> t2.second))\n+        .values()\n+        .stream()\n+        .map(t2s -> t2s.stream().min(Comparator.comparingLong(t2 -> t2.first.state.getElapsedTimeSeconds())))\n+        .flatMap(Optional::stream)\n+        .flatMap(t2 -> IntStream.range(0, servicesRunning.length)\n+            .filter(i -> isFlexTripRunning(servicesRunning[i], t2.second))\n+            .mapToObj(i -> t2.second.getFlexAccessTemplates(\n+                t2.first,\n+                differenceFromStartOfTime[i],\n+                serviceDates[i],\n+                distanceCalculator\n+            ))\n+            // TODO: Optimization: Could we filter here if earliestDepartureTime or latestArrivalTime is -1\n+            .flatMap(Function.identity()))\n+        .collect(Collectors.toList());\n+  }\n+\n+  private void calculateFlexEgressTemplates() {\n+    if (this.flexEgressTemplates != null) { return; }\n+\n+    this.flexEgressTemplates = streetEgresses\n+        .stream()\n+        .flatMap(accessEgress -> flexIndex\n+            .getFlexTripsByStop(accessEgress.stop)\n+            .map(flexTrip -> new T2<>(accessEgress, flexTrip)))\n+        .collect(Collectors.groupingBy(t2 -> t2.second))\n+        .values()\n+        .stream()\n+        .map(t2s -> t2s.stream().min(Comparator.comparingLong(t2 -> t2.first.state.getElapsedTimeSeconds())))\n+        .flatMap(Optional::stream)\n+        .flatMap(t2 -> IntStream.range(0, servicesRunning.length)\n+            .filter(i -> isFlexTripRunning(servicesRunning[i], t2.second))\n+            .mapToObj(i -> t2.second.getFlexEgressTemplates(\n+                t2.first,\n+                differenceFromStartOfTime[i],\n+                serviceDates[i],\n+                distanceCalculator\n+            ))\n+            // TODO: Optimization: Could we filter here if earliestDepartureTime or latestArrivalTime is -1\n+            .flatMap(Function.identity()))\n+        .collect(Collectors.toList());\n+  }\n+\n+\n+  public Collection<Itinerary> getFlexOnlyItineraries() {\n+    Map<StopLocation, StopAtDistance> egressTransferByStop = streetEgresses", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "41d4f78595351387691e689a96c930c0940ce274"}, "originalPosition": 153}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA4MzA3NTIyOnYy", "diffSide": "RIGHT", "path": "src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMlQxMDo0MzoyMFrOHV0MIg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMlQxMDo0MzoyMFrOHV0MIg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjYzNzIxOA==", "bodyText": "Rename getDirectItinerary to createDirectItinerary", "url": "https://github.com/opentripplanner/OpenTripPlanner/pull/3187#discussion_r492637218", "createdAt": "2020-09-22T10:43:20Z", "author": {"login": "t2gran"}, "path": "src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java", "diffHunk": "@@ -0,0 +1,200 @@\n+package org.opentripplanner.ext.flex;\n+\n+import gnu.trove.set.TIntSet;\n+import org.opentripplanner.common.model.T2;\n+import org.opentripplanner.ext.flex.distancecalculator.DirectDistanceCalculator;\n+import org.opentripplanner.ext.flex.distancecalculator.DistanceCalculator;\n+import org.opentripplanner.ext.flex.template.FlexAccessTemplate;\n+import org.opentripplanner.ext.flex.template.FlexEgressTemplate;\n+import org.opentripplanner.ext.flex.trip.FlexTrip;\n+import org.opentripplanner.model.Stop;\n+import org.opentripplanner.model.StopLocation;\n+import org.opentripplanner.model.Transfer;\n+import org.opentripplanner.model.calendar.ServiceDate;\n+import org.opentripplanner.model.plan.Itinerary;\n+import org.opentripplanner.routing.algorithm.raptor.transit.StopIndexForRaptor;\n+import org.opentripplanner.routing.algorithm.raptor.transit.mappers.DateMapper;\n+import org.opentripplanner.routing.api.request.RoutingRequest;\n+import org.opentripplanner.routing.graph.Graph;\n+import org.opentripplanner.routing.graphfinder.StopAtDistance;\n+\n+import java.time.Instant;\n+import java.time.LocalDate;\n+import java.time.ZoneId;\n+import java.time.ZonedDateTime;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Comparator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+\n+public class FlexRouter {\n+\n+  /* Transit data */\n+  private final Graph graph;\n+  private final Collection<StopAtDistance> streetAccesses;\n+  private final Collection<StopAtDistance> streetEgresses;\n+  private final StopIndexForRaptor stopIndex;\n+  private final Collection<Transfer> transitTransfers;\n+  private final FlexIndex flexIndex;\n+  private final DistanceCalculator distanceCalculator;\n+\n+  /* Request data */\n+  private final ZonedDateTime startOfTime;\n+  private final int departureTime;\n+  private final boolean arriveBy;\n+\n+  private final TIntSet[] servicesRunning;\n+  private final int[] differenceFromStartOfTime;\n+  private final ServiceDate[] serviceDates;\n+\n+  /* State */\n+  private List<FlexAccessTemplate> flexAccessTemplates = null;\n+  private List<FlexEgressTemplate> flexEgressTemplates = null;\n+\n+  public FlexRouter(\n+      RoutingRequest request,\n+      int additionalPastSearchDays,\n+      int additionalFutureSearchDays,\n+      Collection<StopAtDistance> streetAccesses,\n+      Collection<StopAtDistance> egressTransfers,\n+      StopIndexForRaptor stopIndex\n+  ) {\n+    this.graph = request.rctx.graph;\n+    this.streetAccesses = streetAccesses;\n+    this.streetEgresses = egressTransfers;\n+    this.stopIndex = stopIndex;\n+    this.transitTransfers = graph.getTransferTable().getTransfers();\n+    this.flexIndex = graph.index.getFlexIndex();\n+    this.distanceCalculator = new DirectDistanceCalculator(graph);\n+\n+    ZoneId tz = graph.getTimeZone().toZoneId();\n+    Instant searchInstant = request.getDateTime().toInstant();\n+    LocalDate searchDate = LocalDate.ofInstant(searchInstant, tz);\n+    this.startOfTime = DateMapper.asStartOfService(searchDate, tz);\n+    this.departureTime = DateMapper.secondsSinceStartOfTime(startOfTime, searchInstant);\n+    this.arriveBy = request.arriveBy;\n+\n+    int totalDays = additionalPastSearchDays + 1 + additionalFutureSearchDays;\n+\n+    this.differenceFromStartOfTime = new int[totalDays];\n+    this.servicesRunning = new TIntSet[totalDays];\n+    this.serviceDates = new ServiceDate[totalDays];\n+\n+    for (int d = -additionalPastSearchDays; d <= additionalFutureSearchDays; ++d) {\n+      LocalDate date = searchDate.plusDays(d);\n+      int index = d + additionalPastSearchDays;\n+      ServiceDate serviceDate = new ServiceDate(date);\n+      differenceFromStartOfTime[index] = DateMapper.secondsSinceStartOfTime(startOfTime, date);\n+      servicesRunning[index] = graph.index.getServiceCodesRunningForDate().get(serviceDate);\n+      serviceDates[index] = serviceDate;\n+    }\n+  }\n+\n+  private void calculateFlexAccessTemplates() {\n+    if (this.flexAccessTemplates != null) { return; }\n+\n+    this.flexAccessTemplates = streetAccesses\n+        .stream()\n+        .flatMap(accessEgress -> flexIndex\n+            .getFlexTripsByStop(accessEgress.stop)\n+            .map(flexTrip -> new T2<>(accessEgress, flexTrip)))\n+        .collect(Collectors.groupingBy(t2 -> t2.second))\n+        .values()\n+        .stream()\n+        .map(t2s -> t2s.stream().min(Comparator.comparingLong(t2 -> t2.first.state.getElapsedTimeSeconds())))\n+        .flatMap(Optional::stream)\n+        .flatMap(t2 -> IntStream.range(0, servicesRunning.length)\n+            .filter(i -> isFlexTripRunning(servicesRunning[i], t2.second))\n+            .mapToObj(i -> t2.second.getFlexAccessTemplates(\n+                t2.first,\n+                differenceFromStartOfTime[i],\n+                serviceDates[i],\n+                distanceCalculator\n+            ))\n+            // TODO: Optimization: Could we filter here if earliestDepartureTime or latestArrivalTime is -1\n+            .flatMap(Function.identity()))\n+        .collect(Collectors.toList());\n+  }\n+\n+  private void calculateFlexEgressTemplates() {\n+    if (this.flexEgressTemplates != null) { return; }\n+\n+    this.flexEgressTemplates = streetEgresses\n+        .stream()\n+        .flatMap(accessEgress -> flexIndex\n+            .getFlexTripsByStop(accessEgress.stop)\n+            .map(flexTrip -> new T2<>(accessEgress, flexTrip)))\n+        .collect(Collectors.groupingBy(t2 -> t2.second))\n+        .values()\n+        .stream()\n+        .map(t2s -> t2s.stream().min(Comparator.comparingLong(t2 -> t2.first.state.getElapsedTimeSeconds())))\n+        .flatMap(Optional::stream)\n+        .flatMap(t2 -> IntStream.range(0, servicesRunning.length)\n+            .filter(i -> isFlexTripRunning(servicesRunning[i], t2.second))\n+            .mapToObj(i -> t2.second.getFlexEgressTemplates(\n+                t2.first,\n+                differenceFromStartOfTime[i],\n+                serviceDates[i],\n+                distanceCalculator\n+            ))\n+            // TODO: Optimization: Could we filter here if earliestDepartureTime or latestArrivalTime is -1\n+            .flatMap(Function.identity()))\n+        .collect(Collectors.toList());\n+  }\n+\n+\n+  public Collection<Itinerary> getFlexOnlyItineraries() {\n+    Map<StopLocation, StopAtDistance> egressTransferByStop = streetEgresses\n+        .stream()\n+        .collect(Collectors.toMap(stopAtDistance -> stopAtDistance.stop, Function.identity()));\n+\n+    Set<StopLocation> egressStops = egressTransferByStop.keySet();\n+\n+    calculateFlexAccessTemplates();\n+    calculateFlexEgressTemplates();\n+\n+    Collection<Itinerary> itineraries = new ArrayList<>();\n+\n+    for (FlexAccessTemplate template : this.flexAccessTemplates) {\n+      StopLocation transferStop = template.getTransferStop();\n+      if (egressStops.contains(transferStop)) {\n+        StopAtDistance egress = egressTransferByStop.get(transferStop);\n+        Itinerary itinerary = template.getDirectItinerary(egress, arriveBy, departureTime, startOfTime);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "41d4f78595351387691e689a96c930c0940ce274"}, "originalPosition": 168}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA4MzA4MTQ4OnYy", "diffSide": "RIGHT", "path": "src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMlQxMDo0NToyMVrOHV0P3Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMlQxMDo0NToyMVrOHV0P3Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjYzODE3Mw==", "bodyText": "Not Base use template", "url": "https://github.com/opentripplanner/OpenTripPlanner/pull/3187#discussion_r492638173", "createdAt": "2020-09-22T10:45:21Z", "author": {"login": "t2gran"}, "path": "src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java", "diffHunk": "@@ -0,0 +1,200 @@\n+package org.opentripplanner.ext.flex;\n+\n+import gnu.trove.set.TIntSet;\n+import org.opentripplanner.common.model.T2;\n+import org.opentripplanner.ext.flex.distancecalculator.DirectDistanceCalculator;\n+import org.opentripplanner.ext.flex.distancecalculator.DistanceCalculator;\n+import org.opentripplanner.ext.flex.template.FlexAccessTemplate;\n+import org.opentripplanner.ext.flex.template.FlexEgressTemplate;\n+import org.opentripplanner.ext.flex.trip.FlexTrip;\n+import org.opentripplanner.model.Stop;\n+import org.opentripplanner.model.StopLocation;\n+import org.opentripplanner.model.Transfer;\n+import org.opentripplanner.model.calendar.ServiceDate;\n+import org.opentripplanner.model.plan.Itinerary;\n+import org.opentripplanner.routing.algorithm.raptor.transit.StopIndexForRaptor;\n+import org.opentripplanner.routing.algorithm.raptor.transit.mappers.DateMapper;\n+import org.opentripplanner.routing.api.request.RoutingRequest;\n+import org.opentripplanner.routing.graph.Graph;\n+import org.opentripplanner.routing.graphfinder.StopAtDistance;\n+\n+import java.time.Instant;\n+import java.time.LocalDate;\n+import java.time.ZoneId;\n+import java.time.ZonedDateTime;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Comparator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+\n+public class FlexRouter {\n+\n+  /* Transit data */\n+  private final Graph graph;\n+  private final Collection<StopAtDistance> streetAccesses;\n+  private final Collection<StopAtDistance> streetEgresses;\n+  private final StopIndexForRaptor stopIndex;\n+  private final Collection<Transfer> transitTransfers;\n+  private final FlexIndex flexIndex;\n+  private final DistanceCalculator distanceCalculator;\n+\n+  /* Request data */\n+  private final ZonedDateTime startOfTime;\n+  private final int departureTime;\n+  private final boolean arriveBy;\n+\n+  private final TIntSet[] servicesRunning;\n+  private final int[] differenceFromStartOfTime;\n+  private final ServiceDate[] serviceDates;\n+\n+  /* State */\n+  private List<FlexAccessTemplate> flexAccessTemplates = null;\n+  private List<FlexEgressTemplate> flexEgressTemplates = null;\n+\n+  public FlexRouter(\n+      RoutingRequest request,\n+      int additionalPastSearchDays,\n+      int additionalFutureSearchDays,\n+      Collection<StopAtDistance> streetAccesses,\n+      Collection<StopAtDistance> egressTransfers,\n+      StopIndexForRaptor stopIndex\n+  ) {\n+    this.graph = request.rctx.graph;\n+    this.streetAccesses = streetAccesses;\n+    this.streetEgresses = egressTransfers;\n+    this.stopIndex = stopIndex;\n+    this.transitTransfers = graph.getTransferTable().getTransfers();\n+    this.flexIndex = graph.index.getFlexIndex();\n+    this.distanceCalculator = new DirectDistanceCalculator(graph);\n+\n+    ZoneId tz = graph.getTimeZone().toZoneId();\n+    Instant searchInstant = request.getDateTime().toInstant();\n+    LocalDate searchDate = LocalDate.ofInstant(searchInstant, tz);\n+    this.startOfTime = DateMapper.asStartOfService(searchDate, tz);\n+    this.departureTime = DateMapper.secondsSinceStartOfTime(startOfTime, searchInstant);\n+    this.arriveBy = request.arriveBy;\n+\n+    int totalDays = additionalPastSearchDays + 1 + additionalFutureSearchDays;\n+\n+    this.differenceFromStartOfTime = new int[totalDays];\n+    this.servicesRunning = new TIntSet[totalDays];\n+    this.serviceDates = new ServiceDate[totalDays];\n+\n+    for (int d = -additionalPastSearchDays; d <= additionalFutureSearchDays; ++d) {\n+      LocalDate date = searchDate.plusDays(d);\n+      int index = d + additionalPastSearchDays;\n+      ServiceDate serviceDate = new ServiceDate(date);\n+      differenceFromStartOfTime[index] = DateMapper.secondsSinceStartOfTime(startOfTime, date);\n+      servicesRunning[index] = graph.index.getServiceCodesRunningForDate().get(serviceDate);\n+      serviceDates[index] = serviceDate;\n+    }\n+  }\n+\n+  private void calculateFlexAccessTemplates() {\n+    if (this.flexAccessTemplates != null) { return; }\n+\n+    this.flexAccessTemplates = streetAccesses\n+        .stream()\n+        .flatMap(accessEgress -> flexIndex\n+            .getFlexTripsByStop(accessEgress.stop)\n+            .map(flexTrip -> new T2<>(accessEgress, flexTrip)))\n+        .collect(Collectors.groupingBy(t2 -> t2.second))\n+        .values()\n+        .stream()\n+        .map(t2s -> t2s.stream().min(Comparator.comparingLong(t2 -> t2.first.state.getElapsedTimeSeconds())))\n+        .flatMap(Optional::stream)\n+        .flatMap(t2 -> IntStream.range(0, servicesRunning.length)\n+            .filter(i -> isFlexTripRunning(servicesRunning[i], t2.second))\n+            .mapToObj(i -> t2.second.getFlexAccessTemplates(\n+                t2.first,\n+                differenceFromStartOfTime[i],\n+                serviceDates[i],\n+                distanceCalculator\n+            ))\n+            // TODO: Optimization: Could we filter here if earliestDepartureTime or latestArrivalTime is -1\n+            .flatMap(Function.identity()))\n+        .collect(Collectors.toList());\n+  }\n+\n+  private void calculateFlexEgressTemplates() {\n+    if (this.flexEgressTemplates != null) { return; }\n+\n+    this.flexEgressTemplates = streetEgresses\n+        .stream()\n+        .flatMap(accessEgress -> flexIndex\n+            .getFlexTripsByStop(accessEgress.stop)\n+            .map(flexTrip -> new T2<>(accessEgress, flexTrip)))\n+        .collect(Collectors.groupingBy(t2 -> t2.second))\n+        .values()\n+        .stream()\n+        .map(t2s -> t2s.stream().min(Comparator.comparingLong(t2 -> t2.first.state.getElapsedTimeSeconds())))\n+        .flatMap(Optional::stream)\n+        .flatMap(t2 -> IntStream.range(0, servicesRunning.length)\n+            .filter(i -> isFlexTripRunning(servicesRunning[i], t2.second))\n+            .mapToObj(i -> t2.second.getFlexEgressTemplates(\n+                t2.first,\n+                differenceFromStartOfTime[i],\n+                serviceDates[i],\n+                distanceCalculator\n+            ))\n+            // TODO: Optimization: Could we filter here if earliestDepartureTime or latestArrivalTime is -1\n+            .flatMap(Function.identity()))\n+        .collect(Collectors.toList());\n+  }\n+\n+\n+  public Collection<Itinerary> getFlexOnlyItineraries() {\n+    Map<StopLocation, StopAtDistance> egressTransferByStop = streetEgresses\n+        .stream()\n+        .collect(Collectors.toMap(stopAtDistance -> stopAtDistance.stop, Function.identity()));\n+\n+    Set<StopLocation> egressStops = egressTransferByStop.keySet();\n+\n+    calculateFlexAccessTemplates();\n+    calculateFlexEgressTemplates();\n+\n+    Collection<Itinerary> itineraries = new ArrayList<>();\n+\n+    for (FlexAccessTemplate template : this.flexAccessTemplates) {\n+      StopLocation transferStop = template.getTransferStop();\n+      if (egressStops.contains(transferStop)) {\n+        StopAtDistance egress = egressTransferByStop.get(transferStop);\n+        Itinerary itinerary = template.getDirectItinerary(egress, arriveBy, departureTime, startOfTime);\n+        if (itinerary != null) {\n+          itineraries.add(itinerary);\n+        }\n+      }\n+    }\n+\n+    return itineraries;\n+  }\n+\n+  public Collection<FlexAccessEgress> getFlexAccesses() {\n+    calculateFlexAccessTemplates();\n+\n+    return this.flexAccessTemplates\n+        .stream()\n+        .flatMap(flexAccessEgressBase -> flexAccessEgressBase.getFlexAccessEgressStream(graph, stopIndex.indexByStop))", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "41d4f78595351387691e689a96c930c0940ce274"}, "originalPosition": 183}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA4MzA5MTU1OnYy", "diffSide": "RIGHT", "path": "src/ext/java/org/opentripplanner/ext/flex/template/FlexAccessEgressTemplate.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMlQxMDo0ODozOFrOHV0WEQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMlQxMDo0ODozOFrOHV0WEQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjYzOTc2MQ==", "bodyText": "create/generate not get, maybe?", "url": "https://github.com/opentripplanner/OpenTripPlanner/pull/3187#discussion_r492639761", "createdAt": "2020-09-22T10:48:38Z", "author": {"login": "t2gran"}, "path": "src/ext/java/org/opentripplanner/ext/flex/template/FlexAccessEgressTemplate.java", "diffHunk": "@@ -0,0 +1,126 @@\n+package org.opentripplanner.ext.flex.template;\n+\n+import org.opentripplanner.ext.flex.FlexAccessEgress;\n+import org.opentripplanner.ext.flex.FlexTripEdge;\n+import org.opentripplanner.ext.flex.distancecalculator.DistanceCalculator;\n+import org.opentripplanner.ext.flex.trip.FlexTrip;\n+import org.opentripplanner.model.SimpleTransfer;\n+import org.opentripplanner.model.Stop;\n+import org.opentripplanner.model.StopLocation;\n+import org.opentripplanner.model.calendar.ServiceDate;\n+import org.opentripplanner.routing.core.State;\n+import org.opentripplanner.routing.graph.Edge;\n+import org.opentripplanner.routing.graph.Graph;\n+import org.opentripplanner.routing.graph.Vertex;\n+import org.opentripplanner.routing.graphfinder.StopAtDistance;\n+import org.opentripplanner.routing.vertextype.TransitStopVertex;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Stream;\n+\n+public abstract class FlexAccessEgressTemplate {\n+  protected final StopAtDistance accessEgress;\n+  protected final FlexTrip trip;\n+  public final int fromStopIndex;\n+  public final int toStopIndex;\n+  protected final StopLocation transferStop;\n+  protected final int differenceFromStartOfTime;\n+  public final ServiceDate serviceDate;\n+  protected final DistanceCalculator calculator;\n+\n+  FlexAccessEgressTemplate(\n+      StopAtDistance accessEgress,\n+      FlexTrip trip,\n+      int fromStopIndex,\n+      int toStopIndex,\n+      StopLocation transferStop,\n+      int differenceFromStartOfTime,\n+      ServiceDate serviceDate,\n+      DistanceCalculator calculator\n+  ) {\n+    this.accessEgress = accessEgress;\n+    this.trip = trip;\n+    this.fromStopIndex = fromStopIndex;\n+    this.toStopIndex = toStopIndex;\n+    this.transferStop = transferStop;\n+    this.differenceFromStartOfTime = differenceFromStartOfTime;\n+    this.serviceDate = serviceDate;\n+    this.calculator = calculator;\n+  }\n+\n+  public StopLocation getTransferStop() {\n+    return transferStop;\n+  }\n+\n+  public FlexTrip getFlexTrip() {\n+    return trip;\n+  }\n+\n+  abstract protected List<Edge> getTransferEdges(SimpleTransfer simpleTransfer);\n+\n+  abstract protected StopLocation getFinalStop(SimpleTransfer simpleTransfer);\n+\n+  abstract protected Collection<SimpleTransfer> getTransfersFromTransferStop(Graph graph);\n+\n+  abstract protected Vertex getFlexVertex(Edge edge);\n+\n+  abstract protected int[] getFlexTimes(FlexTripEdge flexEdge, State state);\n+\n+  abstract protected FlexTripEdge getFlexEdge(Vertex flexFromVertex, StopLocation transferStop);\n+\n+  abstract protected boolean isRouteable(Vertex flexVertex);\n+\n+  public Stream<FlexAccessEgress> getFlexAccessEgressStream(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "41d4f78595351387691e689a96c930c0940ce274"}, "originalPosition": 76}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA4MzA5ODg3OnYy", "diffSide": "RIGHT", "path": "src/ext/java/org/opentripplanner/ext/flex/template/FlexAccessEgressTemplate.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMlQxMDo1MDo1M1rOHV0acg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMlQxMDo1MDo1M1rOHV0acg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjY0MDg4Mg==", "bodyText": "}\n// Location Area/Line\nelse {", "url": "https://github.com/opentripplanner/OpenTripPlanner/pull/3187#discussion_r492640882", "createdAt": "2020-09-22T10:50:53Z", "author": {"login": "t2gran"}, "path": "src/ext/java/org/opentripplanner/ext/flex/template/FlexAccessEgressTemplate.java", "diffHunk": "@@ -0,0 +1,126 @@\n+package org.opentripplanner.ext.flex.template;\n+\n+import org.opentripplanner.ext.flex.FlexAccessEgress;\n+import org.opentripplanner.ext.flex.FlexTripEdge;\n+import org.opentripplanner.ext.flex.distancecalculator.DistanceCalculator;\n+import org.opentripplanner.ext.flex.trip.FlexTrip;\n+import org.opentripplanner.model.SimpleTransfer;\n+import org.opentripplanner.model.Stop;\n+import org.opentripplanner.model.StopLocation;\n+import org.opentripplanner.model.calendar.ServiceDate;\n+import org.opentripplanner.routing.core.State;\n+import org.opentripplanner.routing.graph.Edge;\n+import org.opentripplanner.routing.graph.Graph;\n+import org.opentripplanner.routing.graph.Vertex;\n+import org.opentripplanner.routing.graphfinder.StopAtDistance;\n+import org.opentripplanner.routing.vertextype.TransitStopVertex;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Stream;\n+\n+public abstract class FlexAccessEgressTemplate {\n+  protected final StopAtDistance accessEgress;\n+  protected final FlexTrip trip;\n+  public final int fromStopIndex;\n+  public final int toStopIndex;\n+  protected final StopLocation transferStop;\n+  protected final int differenceFromStartOfTime;\n+  public final ServiceDate serviceDate;\n+  protected final DistanceCalculator calculator;\n+\n+  FlexAccessEgressTemplate(\n+      StopAtDistance accessEgress,\n+      FlexTrip trip,\n+      int fromStopIndex,\n+      int toStopIndex,\n+      StopLocation transferStop,\n+      int differenceFromStartOfTime,\n+      ServiceDate serviceDate,\n+      DistanceCalculator calculator\n+  ) {\n+    this.accessEgress = accessEgress;\n+    this.trip = trip;\n+    this.fromStopIndex = fromStopIndex;\n+    this.toStopIndex = toStopIndex;\n+    this.transferStop = transferStop;\n+    this.differenceFromStartOfTime = differenceFromStartOfTime;\n+    this.serviceDate = serviceDate;\n+    this.calculator = calculator;\n+  }\n+\n+  public StopLocation getTransferStop() {\n+    return transferStop;\n+  }\n+\n+  public FlexTrip getFlexTrip() {\n+    return trip;\n+  }\n+\n+  abstract protected List<Edge> getTransferEdges(SimpleTransfer simpleTransfer);\n+\n+  abstract protected StopLocation getFinalStop(SimpleTransfer simpleTransfer);\n+\n+  abstract protected Collection<SimpleTransfer> getTransfersFromTransferStop(Graph graph);\n+\n+  abstract protected Vertex getFlexVertex(Edge edge);\n+\n+  abstract protected int[] getFlexTimes(FlexTripEdge flexEdge, State state);\n+\n+  abstract protected FlexTripEdge getFlexEdge(Vertex flexFromVertex, StopLocation transferStop);\n+\n+  abstract protected boolean isRouteable(Vertex flexVertex);\n+\n+  public Stream<FlexAccessEgress> getFlexAccessEgressStream(\n+      Graph graph, Map<Stop, Integer> indexByStop\n+  ) {\n+    if (transferStop instanceof Stop) {\n+      TransitStopVertex flexVertex = graph.index.getStopVertexForStop().get(transferStop);\n+      if (isRouteable(flexVertex)) {\n+        return Stream.of(\n+            getFlexAccessEgress(new ArrayList<>(), flexVertex, indexByStop.get(transferStop))\n+        );\n+      }\n+      return Stream.empty();\n+    } else {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "41d4f78595351387691e689a96c930c0940ce274"}, "originalPosition": 87}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA4MzE0MTk5OnYy", "diffSide": "RIGHT", "path": "src/ext/java/org/opentripplanner/ext/flex/trip/ScheduledDeviatedTrip.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMlQxMTowMjoyMVrOHV0z0g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMlQxMTowMjoyMVrOHV0z0g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjY0NzM3OA==", "bodyText": "Could you use the constant here. The ultimate goal would be to have enums in the internal model.", "url": "https://github.com/opentripplanner/OpenTripPlanner/pull/3187#discussion_r492647378", "createdAt": "2020-09-22T11:02:21Z", "author": {"login": "t2gran"}, "path": "src/ext/java/org/opentripplanner/ext/flex/trip/ScheduledDeviatedTrip.java", "diffHunk": "@@ -43,6 +55,70 @@ public ScheduledDeviatedTrip(Trip trip, List<StopTime> stopTimes) {\n     }\n   }\n \n+  @Override\n+  public Stream<FlexAccessTemplate> getFlexAccessTemplates(\n+      StopAtDistance access, int differenceFromStartOfTime, ServiceDate serviceDate, DistanceCalculator calculator\n+  ) {\n+    DistanceCalculator scheduledDistanceCalculator = new ScheduledDistanceCalculator(calculator, this);\n+\n+    int fromIndex = getFromIndex(access);\n+\n+    if (fromIndex == -1) return Stream.empty();\n+\n+    ArrayList<FlexAccessTemplate> res = new ArrayList<>();\n+\n+    for (int toIndex = fromIndex + 1; toIndex < stopTimes.length; toIndex++) {\n+      if (stopTimes[toIndex].dropOffType == 1) continue;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "41d4f78595351387691e689a96c930c0940ce274"}, "originalPosition": 51}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA4MzE2NTA1OnYy", "diffSide": "RIGHT", "path": "src/ext/java/org/opentripplanner/ext/flex/trip/ScheduledDeviatedTrip.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMlQxMTowOTozN1rOHV1B0w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMlQxMTowOTozN1rOHV1B0w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjY1MDk2Mw==", "bodyText": "These are good candidates for UnitTests", "url": "https://github.com/opentripplanner/OpenTripPlanner/pull/3187#discussion_r492650963", "createdAt": "2020-09-22T11:09:37Z", "author": {"login": "t2gran"}, "path": "src/ext/java/org/opentripplanner/ext/flex/trip/ScheduledDeviatedTrip.java", "diffHunk": "@@ -43,6 +55,70 @@ public ScheduledDeviatedTrip(Trip trip, List<StopTime> stopTimes) {\n     }\n   }\n \n+  @Override\n+  public Stream<FlexAccessTemplate> getFlexAccessTemplates(\n+      StopAtDistance access, int differenceFromStartOfTime, ServiceDate serviceDate, DistanceCalculator calculator\n+  ) {\n+    DistanceCalculator scheduledDistanceCalculator = new ScheduledDistanceCalculator(calculator, this);\n+\n+    int fromIndex = getFromIndex(access);\n+\n+    if (fromIndex == -1) return Stream.empty();\n+\n+    ArrayList<FlexAccessTemplate> res = new ArrayList<>();\n+\n+    for (int toIndex = fromIndex + 1; toIndex < stopTimes.length; toIndex++) {\n+      if (stopTimes[toIndex].dropOffType == 1) continue;\n+      for (StopLocation stop : expandStops(stopTimes[toIndex].stop)) {\n+        res.add(new FlexAccessTemplate(access, this, fromIndex, toIndex, stop, differenceFromStartOfTime, serviceDate, scheduledDistanceCalculator));\n+      }\n+    }\n+\n+    return res.stream();\n+  }\n+\n+  @Override\n+  public Stream<FlexEgressTemplate> getFlexEgressTemplates(\n+      StopAtDistance egress, int differenceFromStartOfTime, ServiceDate serviceDate, DistanceCalculator calculator\n+  ) {\n+    DistanceCalculator scheduledDistanceCalculator = new ScheduledDistanceCalculator(calculator, this);\n+\n+    int toIndex = getToIndex(egress);\n+\n+    if (toIndex == -1) return Stream.empty();\n+\n+    ArrayList<FlexEgressTemplate> res = new ArrayList<>();\n+\n+    for (int fromIndex = toIndex - 1; fromIndex >= 0; fromIndex--) {\n+      if (stopTimes[fromIndex].pickupType == 1) continue;\n+      for (StopLocation stop : expandStops(stopTimes[fromIndex].stop)) {\n+        res.add(new FlexEgressTemplate(egress, this, fromIndex, toIndex, stop, differenceFromStartOfTime, serviceDate, scheduledDistanceCalculator));\n+      }\n+    }\n+\n+    return res.stream();\n+  }\n+\n+  @Override\n+  public int earliestDepartureTime(\n+      int departureTime, int fromStopIndex, int toStopIndex, int flexTime\n+  ) {\n+    int stopTime = MISSING_VALUE;\n+    for (int i = fromStopIndex; stopTime == MISSING_VALUE && i >= 0; i--) {\n+      stopTime = stopTimes[i].departureTime;\n+    }\n+    return stopTime != MISSING_VALUE && stopTime >= departureTime ? stopTime : -1;\n+  }\n+\n+  @Override\n+  public int latestArrivalTime(int arrivalTime, int fromStopIndex, int toStopIndex, int flexTime) {\n+    int stopTime = MISSING_VALUE;\n+    for (int i = toStopIndex; stopTime == MISSING_VALUE && i < stopTimes.length; i++) {\n+      stopTime = stopTimes[i].arrivalTime;\n+    }\n+    return stopTime != MISSING_VALUE && stopTime <= arrivalTime ? stopTime : -1;\n+  }\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "41d4f78595351387691e689a96c930c0940ce274"}, "originalPosition": 101}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA4MzE2Nzg4OnYy", "diffSide": "RIGHT", "path": "src/ext/java/org/opentripplanner/ext/flex/trip/ScheduledDeviatedTrip.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMlQxMToxMDoyNlrOHV1DfQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMlQxMToxMDoyNlrOHV1DfQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjY1MTM4OQ==", "bodyText": "UnitTests", "url": "https://github.com/opentripplanner/OpenTripPlanner/pull/3187#discussion_r492651389", "createdAt": "2020-09-22T11:10:26Z", "author": {"login": "t2gran"}, "path": "src/ext/java/org/opentripplanner/ext/flex/trip/ScheduledDeviatedTrip.java", "diffHunk": "@@ -51,7 +127,49 @@ public ScheduledDeviatedTrip(Trip trip, List<StopTime> stopTimes) {\n         .collect(Collectors.toSet());\n   }\n \n-  private static class ScheduledDeviatedStopTime {\n+  private Collection<StopLocation> expandStops(StopLocation stop) {\n+    return stop instanceof FlexLocationGroup\n+        ? ((FlexLocationGroup) stop).getLocations()\n+        : Collections.singleton(stop);\n+  }\n+\n+  private int getFromIndex(StopAtDistance accessEgress) {\n+    for (int i = 0; i < stopTimes.length; i++) {\n+      if (stopTimes[i].pickupType == 1) continue; // No pickup allowed here\n+      StopLocation stop = stopTimes[i].stop;\n+      if (stop instanceof FlexLocationGroup) {\n+        if (((FlexLocationGroup) stop).getLocations().contains(accessEgress.stop)) {\n+          return i;\n+        }\n+      }\n+      else {\n+        if (stop.equals(accessEgress.stop)) {\n+          return i;\n+        }\n+      }\n+    }\n+    return -1;\n+  }\n+\n+  private int getToIndex(StopAtDistance accessEgress) {\n+    for (int i = stopTimes.length - 1; i >= 0; i--) {\n+      if (stopTimes[i].dropOffType == 1) continue; // No drop off allowed here\n+      StopLocation stop = stopTimes[i].stop;\n+      if (stop instanceof FlexLocationGroup) {\n+        if (((FlexLocationGroup) stop).getLocations().contains(accessEgress.stop)) {\n+          return i;\n+        }\n+      }\n+      else {\n+        if (stop.equals(accessEgress.stop)) {\n+          return i;\n+        }\n+      }\n+    }\n+    return -1;\n+  }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "41d4f78595351387691e689a96c930c0940ce274"}, "originalPosition": 150}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA4MzE4NzMwOnYy", "diffSide": "RIGHT", "path": "src/main/java/org/opentripplanner/model/StopTime.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMlQxMToxNjo1OVrOHV1PIA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMlQxMToxNjo1OVrOHV1PIA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjY1NDM2OA==", "bodyText": "Rename flexContinuousPickup", "url": "https://github.com/opentripplanner/OpenTripPlanner/pull/3187#discussion_r492654368", "createdAt": "2020-09-22T11:16:59Z", "author": {"login": "t2gran"}, "path": "src/main/java/org/opentripplanner/model/StopTime.java", "diffHunk": "@@ -46,9 +46,11 @@\n \n     private int maxDepartureTime = MISSING_VALUE;\n \n-    private int continuousPickup;\n+    // Disabled by default\n+    private int continuousPickup = MISSING_VALUE;\n \n-    private int continuousDropOff;\n+    // Disabled by default\n+    private int continuousDropOff = MISSING_VALUE;\n ", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "681acd20acf9c56073616856d09c49f43668be45"}, "originalPosition": 11}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA5Mjg2NzM2OnYy", "diffSide": "RIGHT", "path": "src/main/java/org/opentripplanner/routing/algorithm/raptor/transit/mappers/AccessEgressMapper.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNFQwOTozNjo0NFrOHXSHYA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNFQwOTozNjo0NFrOHXSHYA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDE3NjA5Ng==", "bodyText": "Put this in org.opentripplanner.routing.algorithm.raptor.transit", "url": "https://github.com/opentripplanner/OpenTripPlanner/pull/3187#discussion_r494176096", "createdAt": "2020-09-24T09:36:44Z", "author": {"login": "hannesj"}, "path": "src/main/java/org/opentripplanner/routing/algorithm/raptor/transit/mappers/AccessEgressMapper.java", "diffHunk": "@@ -0,0 +1,78 @@\n+package org.opentripplanner.routing.algorithm.raptor.transit.mappers;\n+\n+import org.opentripplanner.ext.flex.FlexAccessEgress;\n+import org.opentripplanner.model.Stop;\n+import org.opentripplanner.routing.algorithm.raptor.transit.AccessEgress;\n+import org.opentripplanner.routing.algorithm.raptor.transit.StopIndexForRaptor;\n+import org.opentripplanner.routing.graphfinder.NearbyStop;\n+\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.stream.Collectors;\n+\n+public class AccessEgressMapper {\n+\n+  private final StopIndexForRaptor stopIndex;\n+\n+  public AccessEgressMapper(StopIndexForRaptor stopIndex) {\n+    this.stopIndex = stopIndex;\n+  }\n+\n+  public AccessEgress mapNearbyStop(NearbyStop nearbyStop, boolean isEgress) {\n+    if (!(nearbyStop.stop instanceof Stop)) { return null; }\n+    return new AccessEgress(\n+        stopIndex.indexByStop.get(nearbyStop.stop),\n+        (int) nearbyStop.state.getElapsedTimeSeconds(),\n+        isEgress ? nearbyStop.state.reverse() : nearbyStop.state\n+    );\n+  }\n+\n+  public List<AccessEgress> mapNearbyStops(Collection<NearbyStop> accessStops, boolean isEgress) {\n+    return accessStops\n+        .stream()\n+        .map(stopAtDistance -> mapNearbyStop(stopAtDistance, isEgress))\n+        .filter(Objects::nonNull)\n+        .collect(Collectors.toList());\n+  }\n+\n+  public Collection<AccessEgress> mapFlexAccessEgresses(\n+      Collection<FlexAccessEgress> flexAccessEgresses\n+  ) {\n+    return flexAccessEgresses.stream().map(FlexAccessEgressAdapter::new).collect(Collectors.toList());\n+  }\n+\n+  private class FlexAccessEgressAdapter extends AccessEgress {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2d309285ec07c8e3cfde7affcfbd6470733458d6"}, "originalPosition": 45}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA5MjkwODA3OnYy", "diffSide": "RIGHT", "path": "src/ext/java/org/opentripplanner/ext/flex/FlexLocationsToStreetEdgesMapper.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNFQwOTo0NzowOFrOHXSglw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNFQwOTo0NzowOFrOHXSglw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDE4MjU1MQ==", "bodyText": "Paralellize? Collect vertices and add afterwards", "url": "https://github.com/opentripplanner/OpenTripPlanner/pull/3187#discussion_r494182551", "createdAt": "2020-09-24T09:47:08Z", "author": {"login": "hannesj"}, "path": "src/ext/java/org/opentripplanner/ext/flex/FlexLocationsToStreetEdgesMapper.java", "diffHunk": "@@ -25,6 +30,9 @@ public void buildGraph(\n \n     StreetVertexIndex streetIndex = new StreetVertexIndex(graph);\n \n+    ProgressTracker progress = ProgressTracker.track(\"Add flex locations to street vertices\", 1, graph.locationsById.size());\n+\n+    LOG.info(progress.startMessage());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2d309285ec07c8e3cfde7affcfbd6470733458d6"}, "originalPosition": 24}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA5MjkzOTQ5OnYy", "diffSide": "RIGHT", "path": "src/ext/java/org/opentripplanner/ext/flex/edgetype/FlexTripEdge.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNFQwOTo1NToxMVrOHXSzqA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNFQwOTo1NToxMVrOHXSzqA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDE4NzQzMg==", "bodyText": "Move this up", "url": "https://github.com/opentripplanner/OpenTripPlanner/pull/3187#discussion_r494187432", "createdAt": "2020-09-24T09:55:11Z", "author": {"login": "hannesj"}, "path": "src/ext/java/org/opentripplanner/ext/flex/edgetype/FlexTripEdge.java", "diffHunk": "@@ -0,0 +1,93 @@\n+package org.opentripplanner.ext.flex.edgetype;\n+\n+import org.locationtech.jts.geom.Coordinate;\n+import org.locationtech.jts.geom.LineString;\n+import org.opentripplanner.common.geometry.GeometryUtils;\n+import org.opentripplanner.ext.flex.flexpathcalculator.FlexPath;\n+import org.opentripplanner.ext.flex.flexpathcalculator.FlexPathCalculator;\n+import org.opentripplanner.ext.flex.template.FlexAccessEgressTemplate;\n+import org.opentripplanner.ext.flex.trip.FlexTrip;\n+import org.opentripplanner.model.StopLocation;\n+import org.opentripplanner.model.Trip;\n+import org.opentripplanner.routing.core.State;\n+import org.opentripplanner.routing.core.StateEditor;\n+import org.opentripplanner.routing.core.TraverseMode;\n+import org.opentripplanner.routing.graph.Edge;\n+import org.opentripplanner.routing.graph.Vertex;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.Locale;\n+\n+public class FlexTripEdge extends Edge {\n+\n+  private static final Logger LOG = LoggerFactory.getLogger(FlexTripEdge.class);\n+\n+  private static final long serialVersionUID = 1L;\n+\n+  public StopLocation s1;\n+  public StopLocation s2;\n+  private FlexTrip trip;\n+  public FlexAccessEgressTemplate flexTemplate;\n+  public FlexPath flexPath;\n+\n+  public FlexTripEdge(\n+      Vertex v1, Vertex v2, StopLocation s1, StopLocation s2, FlexTrip trip,\n+      FlexAccessEgressTemplate flexTemplate, FlexPathCalculator calculator\n+  ) {\n+    super(new Vertex(null, null, 0.0, 0.0) {}, new Vertex(null, null, 0.0, 0.0) {});\n+    this.s1 = s1;\n+    this.s2 = s2;\n+    this.trip = trip;\n+    this.flexTemplate = flexTemplate;\n+    this.fromv = v1;\n+    this.tov = v2;\n+    // Why is this code so dirty? Because we don't want this edge to be added to the edge lists.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2d309285ec07c8e3cfde7affcfbd6470733458d6"}, "originalPosition": 45}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA5MzAwNzgwOnYy", "diffSide": "RIGHT", "path": "src/ext/java/org/opentripplanner/ext/flex/FlexServiceDate.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNFQxMDoxMzowNlrOHXTdFw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNFQxMDoxMzowNlrOHXTdFw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDE5ODAzOQ==", "bodyText": "Add javadoc for the fields", "url": "https://github.com/opentripplanner/OpenTripPlanner/pull/3187#discussion_r494198039", "createdAt": "2020-09-24T10:13:06Z", "author": {"login": "hannesj"}, "path": "src/ext/java/org/opentripplanner/ext/flex/FlexServiceDate.java", "diffHunk": "@@ -0,0 +1,24 @@\n+package org.opentripplanner.ext.flex;\n+\n+import gnu.trove.set.TIntSet;\n+import org.opentripplanner.ext.flex.trip.FlexTrip;\n+import org.opentripplanner.model.calendar.ServiceDate;\n+import org.opentripplanner.routing.graph.Graph;\n+\n+public class FlexServiceDate {\n+  public final ServiceDate serviceDate;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2d309285ec07c8e3cfde7affcfbd6470733458d6"}, "originalPosition": 9}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA5MzA2NTY2OnYy", "diffSide": "RIGHT", "path": "src/ext/java/org/opentripplanner/ext/flex/template/FlexAccessEgressTemplate.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNFQxMDoyODo0MlrOHXT_3Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNFQxMDoyODo0MlrOHXT_3Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDIwNjk0MQ==", "bodyText": "Add Javadoc to all these methods, why are they different in access/egress", "url": "https://github.com/opentripplanner/OpenTripPlanner/pull/3187#discussion_r494206941", "createdAt": "2020-09-24T10:28:42Z", "author": {"login": "hannesj"}, "path": "src/ext/java/org/opentripplanner/ext/flex/template/FlexAccessEgressTemplate.java", "diffHunk": "@@ -0,0 +1,122 @@\n+package org.opentripplanner.ext.flex.template;\n+\n+import org.opentripplanner.ext.flex.FlexAccessEgress;\n+import org.opentripplanner.ext.flex.FlexServiceDate;\n+import org.opentripplanner.ext.flex.edgetype.FlexTripEdge;\n+import org.opentripplanner.ext.flex.flexpathcalculator.FlexPathCalculator;\n+import org.opentripplanner.ext.flex.trip.FlexTrip;\n+import org.opentripplanner.model.SimpleTransfer;\n+import org.opentripplanner.model.Stop;\n+import org.opentripplanner.model.StopLocation;\n+import org.opentripplanner.model.calendar.ServiceDate;\n+import org.opentripplanner.routing.core.State;\n+import org.opentripplanner.routing.graph.Edge;\n+import org.opentripplanner.routing.graph.Graph;\n+import org.opentripplanner.routing.graph.Vertex;\n+import org.opentripplanner.routing.graphfinder.NearbyStop;\n+import org.opentripplanner.routing.vertextype.TransitStopVertex;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.stream.Stream;\n+\n+public abstract class FlexAccessEgressTemplate {\n+  protected final NearbyStop accessEgress;\n+  protected final FlexTrip trip;\n+  public final int fromStopIndex;\n+  public final int toStopIndex;\n+  protected final StopLocation transferStop;\n+  protected final int secondsFromStartOfTime;\n+  public final ServiceDate serviceDate;\n+  protected final FlexPathCalculator calculator;\n+\n+  FlexAccessEgressTemplate(\n+      NearbyStop accessEgress,\n+      FlexTrip trip,\n+      int fromStopIndex,\n+      int toStopIndex,\n+      StopLocation transferStop,\n+      FlexServiceDate date,\n+      FlexPathCalculator calculator\n+  ) {\n+    this.accessEgress = accessEgress;\n+    this.trip = trip;\n+    this.fromStopIndex = fromStopIndex;\n+    this.toStopIndex = toStopIndex;\n+    this.transferStop = transferStop;\n+    this.secondsFromStartOfTime = date.secondsFromStartOfTime;\n+    this.serviceDate = date.serviceDate;\n+    this.calculator = calculator;\n+  }\n+\n+  public StopLocation getTransferStop() {\n+    return transferStop;\n+  }\n+\n+  public FlexTrip getFlexTrip() {\n+    return trip;\n+  }\n+\n+  abstract protected List<Edge> getTransferEdges(SimpleTransfer simpleTransfer);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2d309285ec07c8e3cfde7affcfbd6470733458d6"}, "originalPosition": 61}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA5MzExODMxOnYy", "diffSide": "RIGHT", "path": "src/main/java/org/opentripplanner/model/StopTime.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNFQxMDo0NDoyMlrOHXUf_g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNFQxMDo0NDoyMlrOHXUf_g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDIxNTE2Ng==", "bodyText": "Change these to flexWindowStart and flexWindowEnd", "url": "https://github.com/opentripplanner/OpenTripPlanner/pull/3187#discussion_r494215166", "createdAt": "2020-09-24T10:44:22Z", "author": {"login": "hannesj"}, "path": "src/main/java/org/opentripplanner/model/StopTime.java", "diffHunk": "@@ -46,9 +46,11 @@\n \n     private int maxDepartureTime = MISSING_VALUE;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2d309285ec07c8e3cfde7affcfbd6470733458d6"}, "originalPosition": 2}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1683, "cost": 1, "resetAt": "2021-11-13T12:10:21Z"}}}