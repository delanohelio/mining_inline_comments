{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzc2ODczMjg2", "number": 2981, "reviewThreads": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNVQxMDoxOTowNlrODipKVg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNVQxMTowNjozN1rODiqN5A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM3NjUyNTY2OnYy", "diffSide": "RIGHT", "path": "src/main/java/org/opentripplanner/kryo/GraphBuildParametersSerializer.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNVQxMDoxOTowNlrOFuAXjg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNVQxMzowODoyMlrOFuFX4Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mzc4NDg0Ng==", "bodyText": "Add comment to say this only exists to construct an \"immutable\" instance with the right constructor. There might be a better way, a comment will help with any future refactor.", "url": "https://github.com/opentripplanner/OpenTripPlanner/pull/2981#discussion_r383784846", "createdAt": "2020-02-25T10:19:06Z", "author": {"login": "abyrd"}, "path": "src/main/java/org/opentripplanner/kryo/GraphBuildParametersSerializer.java", "diffHunk": "@@ -0,0 +1,25 @@\n+package org.opentripplanner.kryo;\n+\n+import com.esotericsoftware.kryo.Kryo;\n+import com.esotericsoftware.kryo.Serializer;\n+import com.esotericsoftware.kryo.io.Input;\n+import com.esotericsoftware.kryo.io.Output;\n+import org.opentripplanner.standalone.config.ConfigLoader;\n+import org.opentripplanner.standalone.config.GraphBuildParameters;\n+\n+public class GraphBuildParametersSerializer extends Serializer<GraphBuildParameters> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3f61ed0a92490e73a4d47db0c8a36eb9a4abf2f0"}, "originalPosition": 10}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mzg2Njg0OQ==", "bodyText": "I added JavaDoc to this to explain why the Serializer is needed, and why we do not serialize just the text String read from the file.", "url": "https://github.com/opentripplanner/OpenTripPlanner/pull/2981#discussion_r383866849", "createdAt": "2020-02-25T13:08:22Z", "author": {"login": "t2gran"}, "path": "src/main/java/org/opentripplanner/kryo/GraphBuildParametersSerializer.java", "diffHunk": "@@ -0,0 +1,25 @@\n+package org.opentripplanner.kryo;\n+\n+import com.esotericsoftware.kryo.Kryo;\n+import com.esotericsoftware.kryo.Serializer;\n+import com.esotericsoftware.kryo.io.Input;\n+import com.esotericsoftware.kryo.io.Output;\n+import org.opentripplanner.standalone.config.ConfigLoader;\n+import org.opentripplanner.standalone.config.GraphBuildParameters;\n+\n+public class GraphBuildParametersSerializer extends Serializer<GraphBuildParameters> {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mzc4NDg0Ng=="}, "originalCommit": {"oid": "3f61ed0a92490e73a4d47db0c8a36eb9a4abf2f0"}, "originalPosition": 10}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM3NjUyNzQ0OnYy", "diffSide": "RIGHT", "path": "src/main/java/org/opentripplanner/kryo/RouterConfigParamsSerializer.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNVQxMDoxOToyOVrOFuAYjg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNVQxMDoxOToyOVrOFuAYjg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mzc4NTEwMg==", "bodyText": "Add comment like the other serializer.", "url": "https://github.com/opentripplanner/OpenTripPlanner/pull/2981#discussion_r383785102", "createdAt": "2020-02-25T10:19:29Z", "author": {"login": "abyrd"}, "path": "src/main/java/org/opentripplanner/kryo/RouterConfigParamsSerializer.java", "diffHunk": "@@ -0,0 +1,24 @@\n+package org.opentripplanner.kryo;\n+\n+import com.esotericsoftware.kryo.Kryo;\n+import com.esotericsoftware.kryo.Serializer;\n+import com.esotericsoftware.kryo.io.Input;\n+import com.esotericsoftware.kryo.io.Output;\n+import org.opentripplanner.standalone.config.ConfigLoader;\n+import org.opentripplanner.standalone.config.RouterConfigParams;\n+\n+public class RouterConfigParamsSerializer extends Serializer<RouterConfigParams> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3f61ed0a92490e73a4d47db0c8a36eb9a4abf2f0"}, "originalPosition": 10}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM3NjU0MTM0OnYy", "diffSide": "RIGHT", "path": "src/main/java/org/opentripplanner/routing/algorithm/RoutingWorker.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNVQxMDoyMjo1OFrOFuAguA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNVQxMDoyMjo1OFrOFuAguA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mzc4NzE5Mg==", "bodyText": "We have a merge conflict because other code does not yet use this constructor.", "url": "https://github.com/opentripplanner/OpenTripPlanner/pull/2981#discussion_r383787192", "createdAt": "2020-02-25T10:22:58Z", "author": {"login": "abyrd"}, "path": "src/main/java/org/opentripplanner/routing/algorithm/RoutingWorker.java", "diffHunk": "@@ -71,7 +72,8 @@\n     private TripSearchMetadata responseMetadata = null;\n     private Instant filterOnLatestDepartureTime = null;\n \n-    public RoutingWorker(RoutingRequest request) {\n+    public RoutingWorker(RaptorConfig<TripSchedule> config, RoutingRequest request) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3f61ed0a92490e73a4d47db0c8a36eb9a4abf2f0"}, "originalPosition": 45}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM3NjY5ODYwOnYy", "diffSide": "RIGHT", "path": "src/test/java/org/opentripplanner/standalone/config/NodeAdapterTest.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNVQxMTowNjozN1rOFuB-tA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNVQxMTowNjozN1rOFuB-tA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzgxMTI1Mg==", "bodyText": "Generally use dots for nesting in JSON since those are used in the JSON itself.", "url": "https://github.com/opentripplanner/OpenTripPlanner/pull/2981#discussion_r383811252", "createdAt": "2020-02-25T11:06:37Z", "author": {"login": "abyrd"}, "path": "src/test/java/org/opentripplanner/standalone/config/NodeAdapterTest.java", "diffHunk": "@@ -0,0 +1,249 @@\n+package org.opentripplanner.standalone.config;\n+\n+import org.junit.Test;\n+import org.mockito.Mockito;\n+import org.opentripplanner.model.FeedScopedId;\n+import org.opentripplanner.util.OtpAppException;\n+import org.slf4j.Logger;\n+\n+import java.time.LocalDate;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertNull;\n+import static org.junit.Assert.assertTrue;\n+import static org.junit.Assert.fail;\n+import static org.opentripplanner.standalone.config.JsonSupport.newNodeAdapterForTest;\n+\n+public class NodeAdapterTest {\n+    private enum AnEnum { A, B, C }\n+\n+    @Test\n+    public void testAsRawNode() {\n+        NodeAdapter subject  = newNodeAdapterForTest(\"{ foo : 'bar' }\");\n+        assertFalse(subject.asRawNode(\"anObject\").has(\"withText\"));\n+    }\n+    @Test\n+    public void isEmpty() {\n+        NodeAdapter subject  = newNodeAdapterForTest(\"\");\n+        assertTrue(subject.path(\"alf\").isEmpty());\n+\n+        subject  = newNodeAdapterForTest(\"{}\");\n+        assertTrue(subject.path(\"alf\").isEmpty());\n+        assertTrue(subject.path(\"alfa\").path(\"bet\").isEmpty());\n+    }\n+\n+    @Test\n+    public void path() {\n+        NodeAdapter subject  = newNodeAdapterForTest(\"{ foo : 'bar' }\");\n+        assertFalse(subject.path(\"foo\").isEmpty());\n+        assertTrue(subject.path(\"missingObject\").isEmpty());\n+    }\n+\n+    @Test\n+    public void asBoolean() {\n+        NodeAdapter subject  = newNodeAdapterForTest(\"{ aBoolean : true }\");\n+        assertTrue(subject.asBoolean(\"aBoolean\", false));\n+        assertFalse(subject.asBoolean(\"missingField\", false));\n+    }\n+\n+    @Test\n+    public void asDouble() {\n+        NodeAdapter subject  = newNodeAdapterForTest(\"{ aDouble : 7.0 }\");\n+        assertEquals(7.0, subject.asDouble(\"aDouble\", -1d), 0.01);\n+        assertEquals(7.0, subject.asDouble(\"aDouble\"), 0.01);\n+        assertEquals(-1d, subject.asDouble(\"missingField\", -1d), 00.1);\n+    }\n+\n+    @Test\n+    public void asDoubles() {\n+        NodeAdapter subject  = newNodeAdapterForTest(\"{ key : [ 2.0, 3.0, 5.0 ] }\");\n+        assertEquals(List.of(2d, 3d, 5d), subject.asDoubles(\"key\", null));\n+    }\n+\n+    @Test\n+    public void asInt() {\n+        NodeAdapter subject  = newNodeAdapterForTest(\"{ aInt : 5 }\");\n+        assertEquals(5, subject.asInt(\"aInt\", -1));\n+        assertEquals(-1, subject.asInt(\"missingField\", -1));\n+    }\n+\n+    @Test\n+    public void asLong() {\n+        NodeAdapter subject  = newNodeAdapterForTest(\"{ key : 5 }\");\n+        assertEquals(5, subject.asLong(\"key\", -1));\n+        assertEquals(-1, subject.asLong(\"missingField\", -1));\n+    }\n+\n+    @Test\n+    public void asText() {\n+        NodeAdapter subject  = newNodeAdapterForTest(\"{ aText : 'TEXT' }\");\n+        assertEquals(\"TEXT\", subject.asText(\"aText\", \"DEFAULT\"));\n+        assertEquals(\"DEFAULT\", subject.asText(\"missingField\", \"DEFAULT\"));\n+        assertNull(subject.asText(\"missingField\", null));\n+\n+        assertEquals(\"TEXT\", subject.asText(\"aText\"));\n+    }\n+\n+    @Test(expected = OtpAppException.class)\n+    public void requiredAsText() {\n+        NodeAdapter subject  = newNodeAdapterForTest(\"{ }\");\n+        subject.asText(\"missingField\");\n+    }\n+\n+    @Test\n+    public void asEnum() {\n+        // Given\n+        NodeAdapter subject  = newNodeAdapterForTest(\"{ key : 'A' }\");\n+\n+        // Then\n+        assertEquals(\"Get existing property\", AnEnum.A, subject.asEnum(\"key\", AnEnum.B));\n+        assertEquals(\"Get default value\", AnEnum.B, subject.asEnum(\"missing-key\", AnEnum.B));\n+    }\n+\n+    @Test(expected = OtpAppException.class)\n+    public void asEnumWithIllegalPropertySet() {\n+        // Given\n+        NodeAdapter subject  = newNodeAdapterForTest(\"{ key : 'NONE_EXISTING_ENUM_VALUE' }\");\n+\n+        // Then expect an error when value 'NONE_EXISTING_ENUM_VALUE' is not in the set of legal\n+        // values: ['A', 'B', 'C']\n+        subject.asEnum(\"key\", AnEnum.B);\n+    }\n+\n+    @Test\n+    public void asEnumMap() {\n+        NodeAdapter subject  = newNodeAdapterForTest(\"{ key : { A: true, B: false } }\");\n+        assertEquals(Map.of(AnEnum.A, true, AnEnum.B, false), subject.asEnumMap(\"key\", AnEnum.class, NodeAdapter::asBoolean));\n+        assertEquals(Collections.<AnEnum, Boolean>emptyMap(), subject.asEnumMap(\"missing-key\", AnEnum.class, NodeAdapter::asBoolean));\n+    }\n+\n+    @Test\n+    public void asEnumMapWithUnknownValue() {\n+\n+        NodeAdapter subject  = newNodeAdapterForTest(\"{ key : { unknown : 7 } }\");\n+        assertEquals(Map.<AnEnum, Double>of(), subject.asEnumMap(\"key\", AnEnum.class, NodeAdapter::asDouble));\n+\n+        // Assert unknown parameter is logged at warning level and with full pathname\n+        Logger log = Mockito.mock(Logger.class);\n+        subject.logUnusedParameters(log);\n+        Mockito.verify(log).warn(Mockito.anyString(), Mockito.eq(\"Test/key/unknown\"));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3f61ed0a92490e73a4d47db0c8a36eb9a4abf2f0"}, "originalPosition": 135}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1761, "cost": 1, "resetAt": "2021-11-13T12:10:21Z"}}}