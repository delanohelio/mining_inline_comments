{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzYxNTg2NjU5", "number": 2922, "title": "Make the TransitLayerMapper multi-threaded to decrease startup time.", "bodyText": "BACKGROUND\nWhile working with changes to the Raptor algorithm I frequently have to run the Speed test. The SpeedTest uses the standard OTP load mechanism. Currently it takes roughly 80 seconds to load the Norwegian graph on my machine. The break down task is:\n\n20 sec - Read graph.obj from file and deserialize it\n15 sec - Index the graph\n36 sec - TransitLayerMapper\n20 sec - First street search\n\nIMPROVMENT\nSo, I looked at the TransitLayerMapper to see if the work could be done in parallell. Using parallell streams, I reduced the total startup time with 20 seconds, reducing the TransitLayerMapper part form 36 seconds to 15 seconds.\nDICUSSION\nEven though I think we will get rid of this code in the future, the improvement is significant enough, and the risk of this NOT working is quite low. Using parallell streams on a web server is NOT recommended(the overhead might degrade overall performance with many users), but I think it is ok to use it during startup - which I have done here.\n\n issue: No issue - pure optimization.\n roadmap: No.\n tests: No.\n formatting: Yes\n documentation: The concurrency is documented in code and JavaDoc.\n changelog: No.\n\nTo be completed by @opentripplanner/plc:\n\n reviews and approvals by 2 members, ideally from different organizations\n after merging: update the relevant card on the roadmap", "createdAt": "2020-01-10T19:18:41Z", "url": "https://github.com/opentripplanner/OpenTripPlanner/pull/2922", "merged": true, "mergeCommit": {"oid": "19c66b8659f66687243bf9b7ff44aff952f99368"}, "closed": true, "closedAt": "2020-02-12T14:44:36Z", "author": {"login": "t2gran"}, "timelineItems": {"totalCount": 10, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABb6ixCKAFqTM0MzExMTMxMA==", "endCursor": "Y3Vyc29yOnYyOpPPAAABcDnF5yAH2gAyMzYxNTg2NjU5OjE2NWZiNTQxNGJjYjVjMTcyZmE3ODFmZGI2Njc4ZjNkMTVhOWVlMTM=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQzMTExMzEw", "url": "https://github.com/opentripplanner/OpenTripPlanner/pull/2922#pullrequestreview-343111310", "createdAt": "2020-01-15T10:12:51Z", "commit": {"oid": "73068f9245c5b79b1ca63c6397bf23bb3dce453e"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNVQxMDoxMjo1MlrOFdzQXA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNVQxMDoxMjo1MlrOFdzQXA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Njc5Mjc5Ng==", "bodyText": "This modify its input - sideeffects.", "url": "https://github.com/opentripplanner/OpenTripPlanner/pull/2922#discussion_r366792796", "createdAt": "2020-01-15T10:12:52Z", "author": {"login": "t2gran"}, "path": "src/main/java/org/opentripplanner/routing/algorithm/raptor/transit/mappers/TransitLayerMapper.java", "diffHunk": "@@ -139,70 +145,119 @@ private TransitLayer map() {\n             LOG.info(\"This TransitLayerMapper got a realtime timetable snapshot. The TransitLayer will reflect realtime updates to scheduled service.\");\n         }\n         Set<ServiceDate> allServiceDates = serviceIdsForServiceDate.keySet();\n-        Map<Timetable, List<TripTimes>> sortedTripTimesForTimetable = new HashMap<>();\n-        for (ServiceDate serviceDate : allServiceDates) {\n-            // Create LocalDate equivalent to the OTP/GTFS ServiceDate object, serving as the key of\n-            // the return Map.\n-            LocalDate localDate = ServiceCalendarMapper.localDateFromServiceDate(serviceDate);\n-\n-            // Create a List to hold the values for one entry in the return Map.\n-            List<TripPatternForDate> values = new ArrayList<>();\n-            TIntSet serviceCodesRunning = new TIntHashSet();\n-\n-            for (FeedScopedId serviceId : serviceIdsForServiceDate.get(serviceDate)) {\n-                serviceCodesRunning.add(graph.serviceCodes.get(serviceId));\n-            }\n+        ConcurrentMap<Timetable, List<TripTimes>> sortedTripTimesForTimetable = new ConcurrentHashMap<>();\n \n-            // This nested loop could be quite inefficient.\n-            // Maybe determine in advance which patterns are running on each service and day.\n-            for (org.opentripplanner.model.TripPattern oldTripPattern : allTripPatterns) {\n-                // Get an updated or scheduled timetable depending on the date. This might have the\n-                // trips pre-filtered for the specified date, that needs to be investigated. But in\n-                // any case we might end up with a scheduled timetable, which can include\n-                // non-running trips. So filter the trips according to which service IDs are running\n-                // on the given day.\n-                Timetable timetable = oldTripPattern.scheduledTimetable;\n-                if (timetableSnapshot != null) {\n-                    timetable = timetableSnapshot.resolve(oldTripPattern, serviceDate);\n-                }\n-                List<TripSchedule> newTripSchedules = new ArrayList<>();\n-                // The TripTimes are not sorted by departure time in the source timetable because\n-                // OTP1 performs a simple/ linear search. Raptor results depend on trips being\n-                // sorted. We reuse the same timetables many times on different days, so cache the\n-                // sorted versions to avoid repeated compute-intensive sorting. Anecdotally this\n-                // reduces mapping time by more than half, but it is still rather slow. NL Mapping\n-                // takes 32 seconds sorting every timetable, 9 seconds with cached sorting, and 6\n-                // seconds with no timetable sorting at all.\n-                List<TripTimes> sortedTripTimes = sortedTripTimesForTimetable.computeIfAbsent(\n-                    timetable,\n-                    TransitLayerMapper::getSortedTripTimes\n-                );\n-                for (TripTimes tripTimes : sortedTripTimes) {\n-                    if (!serviceCodesRunning.contains(tripTimes.serviceCode)) {\n-                        continue;\n-                    }\n-                    if (tripTimes.getRealTimeState() == RealTimeState.CANCELED) {\n-                        continue;\n-                    }\n-                    TripSchedule tripSchedule = tripScheduleForTripTimes.computeIfAbsent(\n-                        tripTimes,\n-                        // The following are two alternative implementations of TripSchedule\n-                        tt -> new TripScheduleWrapperImpl(tt, oldTripPattern)\n-                        // tt -> tt.toTripSchedulImpl(oldTripPattern)\n+        // CONCURRENT !!! The following stream is running in multiple threads. For a dataset like\n+        // the Norwegian NeTEx hole of Norway, running this in parallel on a Mac book PRO, JAN 2020,\n+        // this saves 20 seconds - from 36s down to 15s.\n+        allServiceDates\n+                .parallelStream()\n+                .forEach(serviceDate -> {\n+                    // Create LocalDate equivalent to the OTP/GTFS ServiceDate object, serving as the key of\n+                    // the return Map.\n+                    LocalDate date = ServiceCalendarMapper.localDateFromServiceDate(\n+                            serviceDate);\n+\n+                    List<TripPatternForDate> res = mapTripPatternForDay(\n+                            serviceIdsForServiceDate,\n+                            allTripPatterns,\n+                            newTripPatternForOld,\n+                            tripScheduleForTripTimes,\n+                            sortedTripTimesForTimetable,\n+                            serviceDate,\n+                            date\n                     );\n-                    newTripSchedules.add(tripSchedule);\n-                } \n-                TripPattern newTripPattern = newTripPatternForOld.get(oldTripPattern);\n-                TripPatternForDate tripPatternForDate = new TripPatternForDate(\n-                        newTripPattern,\n-                        newTripSchedules,\n-                        localDate\n+                    if(!res.isEmpty()) {\n+                        synchronized (tripPatternsForDates) {\n+                            tripPatternsForDates.put(date, res);\n+                        }\n+                    }\n+                });\n+        return tripPatternsForDates;\n+    }\n+\n+    /**\n+     * Create a list of trip patterns for a given {@code serviceDate}.\n+     * <p>\n+     * THREAD SAFE - This method is called from multiple threads and MUST be thread safe.\n+     *", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "73068f9245c5b79b1ca63c6397bf23bb3dce453e"}, "originalPosition": 142}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e0b3e7c15ed9222ba9e89dad38d9d3132cf1b69e", "author": {"user": {"login": "gmellemstrand", "name": null}}, "url": "https://github.com/opentripplanner/OpenTripPlanner/commit/e0b3e7c15ed9222ba9e89dad38d9d3132cf1b69e", "committedDate": "2020-02-06T09:35:17Z", "message": "Make the TransitLayerMapper multithreaded to decrease startup time"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d316e88e3246fac699cd64092fa6c58338844150", "author": {"user": {"login": "t2gran", "name": "Thomas Gran"}}, "url": "https://github.com/opentripplanner/OpenTripPlanner/commit/d316e88e3246fac699cd64092fa6c58338844150", "committedDate": "2020-02-06T09:44:28Z", "message": "Improve logging for Graph indexing, to be able to see, when it start and ends. This is a major part of the startup time."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a9dfaedb5e58d7682842e8fe645ab30618209cb7", "author": {"user": {"login": "gmellemstrand", "name": null}}, "url": "https://github.com/opentripplanner/OpenTripPlanner/commit/a9dfaedb5e58d7682842e8fe645ab30618209cb7", "committedDate": "2020-02-06T09:55:27Z", "message": "Added javadoc"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "71d473d6232269d3ba8f8e8ee5c3e9570856695e", "author": {"user": {"login": "t2gran", "name": "Thomas Gran"}}, "url": "https://github.com/opentripplanner/OpenTripPlanner/commit/71d473d6232269d3ba8f8e8ee5c3e9570856695e", "committedDate": "2020-01-15T13:58:08Z", "message": "Make the TransitLayerMapper multi-threaded to decrease startup time - code review, JavaDoc updated."}, "afterCommit": {"oid": "a9dfaedb5e58d7682842e8fe645ab30618209cb7", "author": {"user": {"login": "gmellemstrand", "name": null}}, "url": "https://github.com/opentripplanner/OpenTripPlanner/commit/a9dfaedb5e58d7682842e8fe645ab30618209cb7", "committedDate": "2020-02-06T09:55:27Z", "message": "Added javadoc"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU3MDM2ODU1", "url": "https://github.com/opentripplanner/OpenTripPlanner/pull/2922#pullrequestreview-357036855", "createdAt": "2020-02-11T22:15:19Z", "commit": {"oid": "a9dfaedb5e58d7682842e8fe645ab30618209cb7"}, "state": "COMMENTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQyMjoxNToxOVrOFobJEQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQyMjoyNToxN1rOFobaZg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzkzMjA0OQ==", "bodyText": "Mak a comment here so it is REALY easy to see this this is running in multiple threads.", "url": "https://github.com/opentripplanner/OpenTripPlanner/pull/2922#discussion_r377932049", "createdAt": "2020-02-11T22:15:19Z", "author": {"login": "t2gran"}, "path": "src/main/java/org/opentripplanner/routing/algorithm/raptor/transit/mappers/TransitLayerMapper.java", "diffHunk": "@@ -90,29 +95,39 @@ private TransitLayer map() {\n             newTripPatternForOld\n         );\n \n-        for (ServiceDate serviceDate : graph.index.getServiceCodesRunningForDate().keySet()) {\n-            // Create LocalDate equivalent to the OTP/GTFS ServiceDate object, serving as the key of\n-            // the return Map.\n-            LocalDate localDate = ServiceCalendarMapper.localDateFromServiceDate(serviceDate);\n-\n-            // Create a List to hold the values for one entry in the return Map.\n-            List<TripPatternForDate> values = new ArrayList<>();\n-\n-            // This nested loop could be quite inefficient.\n-            // Maybe determine in advance which patterns are running on each service and day.\n-            for (org.opentripplanner.model.TripPattern oldTripPattern : allTripPatterns) {\n-                TripPatternForDate tripPatternForDate = tripPatternForDateMapper.map(oldTripPattern.scheduledTimetable, serviceDate);\n-                if (tripPatternForDate != null) {\n-                    values.add(tripPatternForDate);\n+        Set<ServiceDate> allServiceDates = graph.index.getServiceCodesRunningForDate().keySet();\n+\n+        allServiceDates", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a9dfaedb5e58d7682842e8fe645ab30618209cb7"}, "originalPosition": 65}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzkzMzgwMQ==", "bodyText": "This class needs JavaDoc documentation that it is Thread safe - why it is so.", "url": "https://github.com/opentripplanner/OpenTripPlanner/pull/2922#discussion_r377933801", "createdAt": "2020-02-11T22:19:14Z", "author": {"login": "t2gran"}, "path": "src/main/java/org/opentripplanner/routing/algorithm/raptor/transit/mappers/TripPatternForDateMapper.java", "diffHunk": "@@ -28,14 +29,20 @@\n \n   private static final Logger LOG = LoggerFactory.getLogger(TripPatternForDateMapper.class);\n \n-  private final Map<Timetable, List<TripTimes>> sortedTripTimesForTimetable = new HashMap<>();\n+  private final ConcurrentMap<Timetable, List<TripTimes>> sortedTripTimesForTimetable =\n+      new ConcurrentHashMap<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a9dfaedb5e58d7682842e8fe645ab30618209cb7"}, "originalPosition": 18}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzkzNjQ4Ng==", "bodyText": "Using the Collection.unmodifiableMap(...) would be good idea here, then it becomes clear that these are READ_ONLY.", "url": "https://github.com/opentripplanner/OpenTripPlanner/pull/2922#discussion_r377936486", "createdAt": "2020-02-11T22:25:17Z", "author": {"login": "t2gran"}, "path": "src/main/java/org/opentripplanner/routing/algorithm/raptor/transit/mappers/TripPatternForDateMapper.java", "diffHunk": "@@ -44,6 +51,13 @@\n     this.newTripPatternForOld = newTripPatternForOld;\n   }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a9dfaedb5e58d7682842e8fe645ab30618209cb7"}, "originalPosition": 37}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ce162fb04225dcfd144e610b46c79562249becec", "author": {"user": {"login": "gmellemstrand", "name": null}}, "url": "https://github.com/opentripplanner/OpenTripPlanner/commit/ce162fb04225dcfd144e610b46c79562249becec", "committedDate": "2020-02-12T11:52:00Z", "message": "Added javadoc and comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9f385bb4b66946e8db7fcdf60cb64df19deb366c", "author": {"user": {"login": "gmellemstrand", "name": null}}, "url": "https://github.com/opentripplanner/OpenTripPlanner/commit/9f385bb4b66946e8db7fcdf60cb64df19deb366c", "committedDate": "2020-02-12T11:52:30Z", "message": "Merge branch 'dev-2.x' into otp2_TransitLayerMapper_optimize"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "584245f686b23423c013cfd797a9e9880ab72290", "author": {"user": {"login": "gmellemstrand", "name": null}}, "url": "https://github.com/opentripplanner/OpenTripPlanner/commit/584245f686b23423c013cfd797a9e9880ab72290", "committedDate": "2020-02-12T13:53:28Z", "message": "Merge branch 'dev-2.x' into otp2_TransitLayerMapper_optimize"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "165fb5414bcb5c172fa781fdb6678f3d15a9ee13", "author": {"user": {"login": "t2gran", "name": "Thomas Gran"}}, "url": "https://github.com/opentripplanner/OpenTripPlanner/commit/165fb5414bcb5c172fa781fdb6678f3d15a9ee13", "committedDate": "2020-02-12T14:20:36Z", "message": "Review - Minor cosmetic changes, removed 'synchronized' block by converting to a 'ConcurrentHashMap' instead."}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2185, "cost": 1, "resetAt": "2021-11-01T15:33:45Z"}}}