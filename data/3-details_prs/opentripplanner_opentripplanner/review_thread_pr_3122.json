{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDM5ODEwMjIy", "number": 3122, "reviewThreads": {"totalCount": 19, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMFQxNDoxNzoyMFrOETswMA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNlQxNTowNjoxMVrOEV3pVA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg5MDkxNjMyOnYy", "diffSide": "RIGHT", "path": "src/main/java/org/opentripplanner/routing/core/RoutingContext.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMFQxNDoxNzoyMFrOG5lFOw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNFQxMjo1NzoyM1rOG7fK-g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzAyOTU2Mw==", "bodyText": "I think this check was simplified, because we do not allow one-to-many search any more, just in the access/egress search - but this code should not be part of that?", "url": "https://github.com/opentripplanner/OpenTripPlanner/pull/3122#discussion_r463029563", "createdAt": "2020-07-30T14:17:20Z", "author": {"login": "t2gran"}, "path": "src/main/java/org/opentripplanner/routing/core/RoutingContext.java", "diffHunk": "@@ -237,14 +237,14 @@ public void checkIfVerticesFound() {\n         List<RoutingError> routingErrors = new ArrayList<>();\n \n         // check origin present when not doing an arrive-by batch search\n-        if (fromVertices == null) {\n+        if (fromVertices == null && !(opt.oneToMany == true && opt.arriveBy == true)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "557ea50e8b14a8ddd70729a8de08a7b6b61dde8c"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTAyOTg4Mg==", "bodyText": "This code is needed for the AStar search in StopFinder", "url": "https://github.com/opentripplanner/OpenTripPlanner/pull/3122#discussion_r465029882", "createdAt": "2020-08-04T12:57:23Z", "author": {"login": "hannesj"}, "path": "src/main/java/org/opentripplanner/routing/core/RoutingContext.java", "diffHunk": "@@ -237,14 +237,14 @@ public void checkIfVerticesFound() {\n         List<RoutingError> routingErrors = new ArrayList<>();\n \n         // check origin present when not doing an arrive-by batch search\n-        if (fromVertices == null) {\n+        if (fromVertices == null && !(opt.oneToMany == true && opt.arriveBy == true)) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzAyOTU2Mw=="}, "originalCommit": {"oid": "557ea50e8b14a8ddd70729a8de08a7b6b61dde8c"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg5MDkxNzQxOnYy", "diffSide": "RIGHT", "path": "src/main/java/org/opentripplanner/routing/core/RoutingContext.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMFQxNDoxNzozN1rOG5lF4w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMFQxNDoxNzozN1rOG5lF4w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzAyOTczMQ==", "bodyText": "See above.", "url": "https://github.com/opentripplanner/OpenTripPlanner/pull/3122#discussion_r463029731", "createdAt": "2020-07-30T14:17:37Z", "author": {"login": "t2gran"}, "path": "src/main/java/org/opentripplanner/routing/core/RoutingContext.java", "diffHunk": "@@ -237,14 +237,14 @@ public void checkIfVerticesFound() {\n         List<RoutingError> routingErrors = new ArrayList<>();\n \n         // check origin present when not doing an arrive-by batch search\n-        if (fromVertices == null) {\n+        if (fromVertices == null && !(opt.oneToMany == true && opt.arriveBy == true)) {\n             routingErrors.add(\n                 new RoutingError(RoutingErrorCode.LOCATION_NOT_FOUND, InputField.FROM_PLACE)\n             );\n         }\n \n         // check destination present when not doing a depart-after batch search\n-        if (toVertices == null) {\n+        if (toVertices == null && !(opt.oneToMany == true && opt.arriveBy == false)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "557ea50e8b14a8ddd70729a8de08a7b6b61dde8c"}, "originalPosition": 13}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg5MDk0MDg0OnYy", "diffSide": "RIGHT", "path": "src/main/java/org/opentripplanner/model/TripPattern.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMFQxNDoyMjo0MVrOG5lUCg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMFQxNDoyMjo0MVrOG5lUCg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzAzMzM1NA==", "bodyText": "These 2 methods seems to be extremely inefficient, but I guess if they are not called very often it should be ok.", "url": "https://github.com/opentripplanner/OpenTripPlanner/pull/3122#discussion_r463033354", "createdAt": "2020-07-30T14:22:41Z", "author": {"login": "t2gran"}, "path": "src/main/java/org/opentripplanner/model/TripPattern.java", "diffHunk": "@@ -236,6 +236,11 @@ public Stop getStop(int stopIndex) {\n         return stopPattern.stops[stopIndex];\n     }\n \n+\n+    public int getStopIndex(Stop stop) {\n+        return Arrays.asList(stopPattern.stops).indexOf(stop);\n+    }\n+\n     public List<Stop> getStops() {\n         return Arrays.asList(stopPattern.stops);\n     }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "557ea50e8b14a8ddd70729a8de08a7b6b61dde8c"}, "originalPosition": 11}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg5NDA4NTgwOnYy", "diffSide": "RIGHT", "path": "src/ext/java/org/opentripplanner/ext/legacygraphqlapi/LegacyGraphQLAPI.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMVQxMDowMDowMlrOG6DDig==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNlQxMzo0ODozMlrOG80WEw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzUyMDY1MA==", "bodyText": "OTPTimeout header param missing from this regular endpoint", "url": "https://github.com/opentripplanner/OpenTripPlanner/pull/3122#discussion_r463520650", "createdAt": "2020-07-31T10:00:02Z", "author": {"login": "optionsome"}, "path": "src/ext/java/org/opentripplanner/ext/legacygraphqlapi/LegacyGraphQLAPI.java", "diffHunk": "@@ -0,0 +1,189 @@\n+package org.opentripplanner.ext.legacygraphqlapi;\n+\n+import com.fasterxml.jackson.annotation.JsonInclude;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import org.opentripplanner.standalone.server.OTPServer;\n+import org.opentripplanner.standalone.server.Router;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import javax.ws.rs.Consumes;\n+import javax.ws.rs.DefaultValue;\n+import javax.ws.rs.HeaderParam;\n+import javax.ws.rs.POST;\n+import javax.ws.rs.Path;\n+import javax.ws.rs.PathParam;\n+import javax.ws.rs.Produces;\n+import javax.ws.rs.core.Context;\n+import javax.ws.rs.core.HttpHeaders;\n+import javax.ws.rs.core.MediaType;\n+import javax.ws.rs.core.Response;\n+import javax.ws.rs.ext.ContextResolver;\n+import javax.ws.rs.ext.Providers;\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.CancellationException;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.Future;\n+\n+// TODO move to org.opentripplanner.api.resource, this is a Jersey resource class\n+\n+@Path(\"/routers/{routerId}/index/graphql\")\n+@Produces(MediaType.APPLICATION_JSON) // One @Produces annotation for all endpoints.\n+public class LegacyGraphQLAPI {\n+\n+  @SuppressWarnings(\"unused\")\n+  private static final Logger LOG = LoggerFactory.getLogger(org.opentripplanner.ext.transmodelapi.TransmodelIndexAPI.class);\n+\n+  private final Router router;\n+  private final ObjectMapper deserializer = new ObjectMapper();\n+\n+  public LegacyGraphQLAPI(\n+      @Context OTPServer otpServer,\n+      @Context Providers providers,\n+      @PathParam(\"routerId\") String routerId\n+  ) {\n+    this.router = otpServer.getRouter();\n+\n+    ContextResolver<ObjectMapper> resolver =\n+        providers.getContextResolver(ObjectMapper.class, MediaType.APPLICATION_JSON_TYPE);\n+    ObjectMapper mapper = resolver.getContext(ObjectMapper.class);\n+    mapper.setDefaultPropertyInclusion(JsonInclude.Include.ALWAYS);\n+  }\n+\n+  @POST\n+  @Path(\"/\")\n+  @Consumes(MediaType.APPLICATION_JSON)\n+  public Response getGraphQL(\n+      HashMap<String, Object> queryParameters,\n+      @HeaderParam(\"OTPMaxResolves\") @DefaultValue(\"1000000\") int maxResolves,\n+      @Context HttpHeaders headers\n+  ) {\n+    if (queryParameters == null || !queryParameters.containsKey(\"query\")) {\n+      LOG.debug(\"No query found in body\");\n+      return Response\n+          .status(Response.Status.BAD_REQUEST)\n+          .type(MediaType.TEXT_PLAIN_TYPE)\n+          .entity(\"No query found in body\")\n+          .build();\n+    }\n+\n+    Locale locale = headers.getAcceptableLanguages().size() > 0\n+        ? headers.getAcceptableLanguages().get(0)\n+        : router.defaultRoutingRequest.locale;\n+\n+    String query = (String) queryParameters.get(\"query\");\n+    Object queryVariables = queryParameters.getOrDefault(\"variables\", null);\n+    String operationName = (String) queryParameters.getOrDefault(\"operationName\", null);\n+    Map<String, Object> variables;\n+    if (queryVariables instanceof Map) {\n+      variables = (Map) queryVariables;\n+    }\n+    else if (queryVariables instanceof String && !((String) queryVariables).isEmpty()) {\n+      try {\n+        variables = deserializer.readValue((String) queryVariables, Map.class);\n+      }\n+      catch (IOException e) {\n+        return Response\n+            .status(Response.Status.BAD_REQUEST)\n+            .type(MediaType.TEXT_PLAIN_TYPE)\n+            .entity(\"Variables must be a valid json object\")\n+            .build();\n+      }\n+    }\n+    else {\n+      variables = new HashMap<>();\n+    }\n+    return LegacyGraphQLIndex.getGraphQLResponse(\n+        query,\n+        router,\n+        variables,\n+        operationName,\n+        maxResolves,\n+        locale\n+    );\n+  }\n+\n+  @POST\n+  @Path(\"/\")\n+  @Consumes(\"application/graphql\")\n+  public Response getGraphQL(\n+      String query,\n+      @HeaderParam(\"OTPMaxResolves\") @DefaultValue(\"1000000\") int maxResolves,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "557ea50e8b14a8ddd70729a8de08a7b6b61dde8c"}, "originalPosition": 117}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjQyNTM2Mw==", "bodyText": "done", "url": "https://github.com/opentripplanner/OpenTripPlanner/pull/3122#discussion_r466425363", "createdAt": "2020-08-06T13:48:32Z", "author": {"login": "hannesj"}, "path": "src/ext/java/org/opentripplanner/ext/legacygraphqlapi/LegacyGraphQLAPI.java", "diffHunk": "@@ -0,0 +1,189 @@\n+package org.opentripplanner.ext.legacygraphqlapi;\n+\n+import com.fasterxml.jackson.annotation.JsonInclude;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import org.opentripplanner.standalone.server.OTPServer;\n+import org.opentripplanner.standalone.server.Router;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import javax.ws.rs.Consumes;\n+import javax.ws.rs.DefaultValue;\n+import javax.ws.rs.HeaderParam;\n+import javax.ws.rs.POST;\n+import javax.ws.rs.Path;\n+import javax.ws.rs.PathParam;\n+import javax.ws.rs.Produces;\n+import javax.ws.rs.core.Context;\n+import javax.ws.rs.core.HttpHeaders;\n+import javax.ws.rs.core.MediaType;\n+import javax.ws.rs.core.Response;\n+import javax.ws.rs.ext.ContextResolver;\n+import javax.ws.rs.ext.Providers;\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.CancellationException;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.Future;\n+\n+// TODO move to org.opentripplanner.api.resource, this is a Jersey resource class\n+\n+@Path(\"/routers/{routerId}/index/graphql\")\n+@Produces(MediaType.APPLICATION_JSON) // One @Produces annotation for all endpoints.\n+public class LegacyGraphQLAPI {\n+\n+  @SuppressWarnings(\"unused\")\n+  private static final Logger LOG = LoggerFactory.getLogger(org.opentripplanner.ext.transmodelapi.TransmodelIndexAPI.class);\n+\n+  private final Router router;\n+  private final ObjectMapper deserializer = new ObjectMapper();\n+\n+  public LegacyGraphQLAPI(\n+      @Context OTPServer otpServer,\n+      @Context Providers providers,\n+      @PathParam(\"routerId\") String routerId\n+  ) {\n+    this.router = otpServer.getRouter();\n+\n+    ContextResolver<ObjectMapper> resolver =\n+        providers.getContextResolver(ObjectMapper.class, MediaType.APPLICATION_JSON_TYPE);\n+    ObjectMapper mapper = resolver.getContext(ObjectMapper.class);\n+    mapper.setDefaultPropertyInclusion(JsonInclude.Include.ALWAYS);\n+  }\n+\n+  @POST\n+  @Path(\"/\")\n+  @Consumes(MediaType.APPLICATION_JSON)\n+  public Response getGraphQL(\n+      HashMap<String, Object> queryParameters,\n+      @HeaderParam(\"OTPMaxResolves\") @DefaultValue(\"1000000\") int maxResolves,\n+      @Context HttpHeaders headers\n+  ) {\n+    if (queryParameters == null || !queryParameters.containsKey(\"query\")) {\n+      LOG.debug(\"No query found in body\");\n+      return Response\n+          .status(Response.Status.BAD_REQUEST)\n+          .type(MediaType.TEXT_PLAIN_TYPE)\n+          .entity(\"No query found in body\")\n+          .build();\n+    }\n+\n+    Locale locale = headers.getAcceptableLanguages().size() > 0\n+        ? headers.getAcceptableLanguages().get(0)\n+        : router.defaultRoutingRequest.locale;\n+\n+    String query = (String) queryParameters.get(\"query\");\n+    Object queryVariables = queryParameters.getOrDefault(\"variables\", null);\n+    String operationName = (String) queryParameters.getOrDefault(\"operationName\", null);\n+    Map<String, Object> variables;\n+    if (queryVariables instanceof Map) {\n+      variables = (Map) queryVariables;\n+    }\n+    else if (queryVariables instanceof String && !((String) queryVariables).isEmpty()) {\n+      try {\n+        variables = deserializer.readValue((String) queryVariables, Map.class);\n+      }\n+      catch (IOException e) {\n+        return Response\n+            .status(Response.Status.BAD_REQUEST)\n+            .type(MediaType.TEXT_PLAIN_TYPE)\n+            .entity(\"Variables must be a valid json object\")\n+            .build();\n+      }\n+    }\n+    else {\n+      variables = new HashMap<>();\n+    }\n+    return LegacyGraphQLIndex.getGraphQLResponse(\n+        query,\n+        router,\n+        variables,\n+        operationName,\n+        maxResolves,\n+        locale\n+    );\n+  }\n+\n+  @POST\n+  @Path(\"/\")\n+  @Consumes(\"application/graphql\")\n+  public Response getGraphQL(\n+      String query,\n+      @HeaderParam(\"OTPMaxResolves\") @DefaultValue(\"1000000\") int maxResolves,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzUyMDY1MA=="}, "originalCommit": {"oid": "557ea50e8b14a8ddd70729a8de08a7b6b61dde8c"}, "originalPosition": 117}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg5NDA5MDc1OnYy", "diffSide": "RIGHT", "path": "src/ext/java/org/opentripplanner/ext/legacygraphqlapi/LegacyGraphQLAPI.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMVQxMDowMTozOVrOG6DGmg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNlQxMzo0ODozOFrOG80WYA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzUyMTQzNA==", "bodyText": "In the current hsldevcom version the default value is 30000", "url": "https://github.com/opentripplanner/OpenTripPlanner/pull/3122#discussion_r463521434", "createdAt": "2020-07-31T10:01:39Z", "author": {"login": "optionsome"}, "path": "src/ext/java/org/opentripplanner/ext/legacygraphqlapi/LegacyGraphQLAPI.java", "diffHunk": "@@ -0,0 +1,189 @@\n+package org.opentripplanner.ext.legacygraphqlapi;\n+\n+import com.fasterxml.jackson.annotation.JsonInclude;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import org.opentripplanner.standalone.server.OTPServer;\n+import org.opentripplanner.standalone.server.Router;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import javax.ws.rs.Consumes;\n+import javax.ws.rs.DefaultValue;\n+import javax.ws.rs.HeaderParam;\n+import javax.ws.rs.POST;\n+import javax.ws.rs.Path;\n+import javax.ws.rs.PathParam;\n+import javax.ws.rs.Produces;\n+import javax.ws.rs.core.Context;\n+import javax.ws.rs.core.HttpHeaders;\n+import javax.ws.rs.core.MediaType;\n+import javax.ws.rs.core.Response;\n+import javax.ws.rs.ext.ContextResolver;\n+import javax.ws.rs.ext.Providers;\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.CancellationException;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.Future;\n+\n+// TODO move to org.opentripplanner.api.resource, this is a Jersey resource class\n+\n+@Path(\"/routers/{routerId}/index/graphql\")\n+@Produces(MediaType.APPLICATION_JSON) // One @Produces annotation for all endpoints.\n+public class LegacyGraphQLAPI {\n+\n+  @SuppressWarnings(\"unused\")\n+  private static final Logger LOG = LoggerFactory.getLogger(org.opentripplanner.ext.transmodelapi.TransmodelIndexAPI.class);\n+\n+  private final Router router;\n+  private final ObjectMapper deserializer = new ObjectMapper();\n+\n+  public LegacyGraphQLAPI(\n+      @Context OTPServer otpServer,\n+      @Context Providers providers,\n+      @PathParam(\"routerId\") String routerId\n+  ) {\n+    this.router = otpServer.getRouter();\n+\n+    ContextResolver<ObjectMapper> resolver =\n+        providers.getContextResolver(ObjectMapper.class, MediaType.APPLICATION_JSON_TYPE);\n+    ObjectMapper mapper = resolver.getContext(ObjectMapper.class);\n+    mapper.setDefaultPropertyInclusion(JsonInclude.Include.ALWAYS);\n+  }\n+\n+  @POST\n+  @Path(\"/\")\n+  @Consumes(MediaType.APPLICATION_JSON)\n+  public Response getGraphQL(\n+      HashMap<String, Object> queryParameters,\n+      @HeaderParam(\"OTPMaxResolves\") @DefaultValue(\"1000000\") int maxResolves,\n+      @Context HttpHeaders headers\n+  ) {\n+    if (queryParameters == null || !queryParameters.containsKey(\"query\")) {\n+      LOG.debug(\"No query found in body\");\n+      return Response\n+          .status(Response.Status.BAD_REQUEST)\n+          .type(MediaType.TEXT_PLAIN_TYPE)\n+          .entity(\"No query found in body\")\n+          .build();\n+    }\n+\n+    Locale locale = headers.getAcceptableLanguages().size() > 0\n+        ? headers.getAcceptableLanguages().get(0)\n+        : router.defaultRoutingRequest.locale;\n+\n+    String query = (String) queryParameters.get(\"query\");\n+    Object queryVariables = queryParameters.getOrDefault(\"variables\", null);\n+    String operationName = (String) queryParameters.getOrDefault(\"operationName\", null);\n+    Map<String, Object> variables;\n+    if (queryVariables instanceof Map) {\n+      variables = (Map) queryVariables;\n+    }\n+    else if (queryVariables instanceof String && !((String) queryVariables).isEmpty()) {\n+      try {\n+        variables = deserializer.readValue((String) queryVariables, Map.class);\n+      }\n+      catch (IOException e) {\n+        return Response\n+            .status(Response.Status.BAD_REQUEST)\n+            .type(MediaType.TEXT_PLAIN_TYPE)\n+            .entity(\"Variables must be a valid json object\")\n+            .build();\n+      }\n+    }\n+    else {\n+      variables = new HashMap<>();\n+    }\n+    return LegacyGraphQLIndex.getGraphQLResponse(\n+        query,\n+        router,\n+        variables,\n+        operationName,\n+        maxResolves,\n+        locale\n+    );\n+  }\n+\n+  @POST\n+  @Path(\"/\")\n+  @Consumes(\"application/graphql\")\n+  public Response getGraphQL(\n+      String query,\n+      @HeaderParam(\"OTPMaxResolves\") @DefaultValue(\"1000000\") int maxResolves,\n+      @Context HttpHeaders headers\n+  ) {\n+    Locale locale = headers.getAcceptableLanguages().size() > 0\n+        ? headers.getAcceptableLanguages().get(0)\n+        : router.defaultRoutingRequest.locale;\n+    return LegacyGraphQLIndex.getGraphQLResponse(query, router, null, null, maxResolves, locale);\n+  }\n+\n+  @POST\n+  @Path(\"/batch\")\n+  @Consumes(MediaType.APPLICATION_JSON)\n+  public Response getGraphQLBatch(\n+      List<HashMap<String, Object>> queries,\n+      @HeaderParam(\"OTPTimeout\") @DefaultValue(\"10000\") int timeout,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "557ea50e8b14a8ddd70729a8de08a7b6b61dde8c"}, "originalPosition": 131}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjQyNTQ0MA==", "bodyText": "done", "url": "https://github.com/opentripplanner/OpenTripPlanner/pull/3122#discussion_r466425440", "createdAt": "2020-08-06T13:48:38Z", "author": {"login": "hannesj"}, "path": "src/ext/java/org/opentripplanner/ext/legacygraphqlapi/LegacyGraphQLAPI.java", "diffHunk": "@@ -0,0 +1,189 @@\n+package org.opentripplanner.ext.legacygraphqlapi;\n+\n+import com.fasterxml.jackson.annotation.JsonInclude;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import org.opentripplanner.standalone.server.OTPServer;\n+import org.opentripplanner.standalone.server.Router;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import javax.ws.rs.Consumes;\n+import javax.ws.rs.DefaultValue;\n+import javax.ws.rs.HeaderParam;\n+import javax.ws.rs.POST;\n+import javax.ws.rs.Path;\n+import javax.ws.rs.PathParam;\n+import javax.ws.rs.Produces;\n+import javax.ws.rs.core.Context;\n+import javax.ws.rs.core.HttpHeaders;\n+import javax.ws.rs.core.MediaType;\n+import javax.ws.rs.core.Response;\n+import javax.ws.rs.ext.ContextResolver;\n+import javax.ws.rs.ext.Providers;\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.CancellationException;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.Future;\n+\n+// TODO move to org.opentripplanner.api.resource, this is a Jersey resource class\n+\n+@Path(\"/routers/{routerId}/index/graphql\")\n+@Produces(MediaType.APPLICATION_JSON) // One @Produces annotation for all endpoints.\n+public class LegacyGraphQLAPI {\n+\n+  @SuppressWarnings(\"unused\")\n+  private static final Logger LOG = LoggerFactory.getLogger(org.opentripplanner.ext.transmodelapi.TransmodelIndexAPI.class);\n+\n+  private final Router router;\n+  private final ObjectMapper deserializer = new ObjectMapper();\n+\n+  public LegacyGraphQLAPI(\n+      @Context OTPServer otpServer,\n+      @Context Providers providers,\n+      @PathParam(\"routerId\") String routerId\n+  ) {\n+    this.router = otpServer.getRouter();\n+\n+    ContextResolver<ObjectMapper> resolver =\n+        providers.getContextResolver(ObjectMapper.class, MediaType.APPLICATION_JSON_TYPE);\n+    ObjectMapper mapper = resolver.getContext(ObjectMapper.class);\n+    mapper.setDefaultPropertyInclusion(JsonInclude.Include.ALWAYS);\n+  }\n+\n+  @POST\n+  @Path(\"/\")\n+  @Consumes(MediaType.APPLICATION_JSON)\n+  public Response getGraphQL(\n+      HashMap<String, Object> queryParameters,\n+      @HeaderParam(\"OTPMaxResolves\") @DefaultValue(\"1000000\") int maxResolves,\n+      @Context HttpHeaders headers\n+  ) {\n+    if (queryParameters == null || !queryParameters.containsKey(\"query\")) {\n+      LOG.debug(\"No query found in body\");\n+      return Response\n+          .status(Response.Status.BAD_REQUEST)\n+          .type(MediaType.TEXT_PLAIN_TYPE)\n+          .entity(\"No query found in body\")\n+          .build();\n+    }\n+\n+    Locale locale = headers.getAcceptableLanguages().size() > 0\n+        ? headers.getAcceptableLanguages().get(0)\n+        : router.defaultRoutingRequest.locale;\n+\n+    String query = (String) queryParameters.get(\"query\");\n+    Object queryVariables = queryParameters.getOrDefault(\"variables\", null);\n+    String operationName = (String) queryParameters.getOrDefault(\"operationName\", null);\n+    Map<String, Object> variables;\n+    if (queryVariables instanceof Map) {\n+      variables = (Map) queryVariables;\n+    }\n+    else if (queryVariables instanceof String && !((String) queryVariables).isEmpty()) {\n+      try {\n+        variables = deserializer.readValue((String) queryVariables, Map.class);\n+      }\n+      catch (IOException e) {\n+        return Response\n+            .status(Response.Status.BAD_REQUEST)\n+            .type(MediaType.TEXT_PLAIN_TYPE)\n+            .entity(\"Variables must be a valid json object\")\n+            .build();\n+      }\n+    }\n+    else {\n+      variables = new HashMap<>();\n+    }\n+    return LegacyGraphQLIndex.getGraphQLResponse(\n+        query,\n+        router,\n+        variables,\n+        operationName,\n+        maxResolves,\n+        locale\n+    );\n+  }\n+\n+  @POST\n+  @Path(\"/\")\n+  @Consumes(\"application/graphql\")\n+  public Response getGraphQL(\n+      String query,\n+      @HeaderParam(\"OTPMaxResolves\") @DefaultValue(\"1000000\") int maxResolves,\n+      @Context HttpHeaders headers\n+  ) {\n+    Locale locale = headers.getAcceptableLanguages().size() > 0\n+        ? headers.getAcceptableLanguages().get(0)\n+        : router.defaultRoutingRequest.locale;\n+    return LegacyGraphQLIndex.getGraphQLResponse(query, router, null, null, maxResolves, locale);\n+  }\n+\n+  @POST\n+  @Path(\"/batch\")\n+  @Consumes(MediaType.APPLICATION_JSON)\n+  public Response getGraphQLBatch(\n+      List<HashMap<String, Object>> queries,\n+      @HeaderParam(\"OTPTimeout\") @DefaultValue(\"10000\") int timeout,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzUyMTQzNA=="}, "originalCommit": {"oid": "557ea50e8b14a8ddd70729a8de08a7b6b61dde8c"}, "originalPosition": 131}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkwMzYwNjczOnYy", "diffSide": "RIGHT", "path": "src/main/java/org/opentripplanner/model/Stop.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNFQwODo1NzowMlrOG7XeiA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNFQwODo1NzowMlrOG7XeiA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDkwMzgxNg==", "bodyText": "Add JAvaDoc here", "url": "https://github.com/opentripplanner/OpenTripPlanner/pull/3122#discussion_r464903816", "createdAt": "2020-08-04T08:57:02Z", "author": {"login": "t2gran"}, "path": "src/main/java/org/opentripplanner/model/Stop.java", "diffHunk": "@@ -81,6 +101,14 @@ public String getUrl() {\n     return url;\n   }\n \n+  public TimeZone getTimeZone() {\n+    return timeZone;\n+  }\n+\n+  public TransitMode getVehicleType() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "557ea50e8b14a8ddd70729a8de08a7b6b61dde8c"}, "originalPosition": 77}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkwMzYxMDQ0OnYy", "diffSide": "RIGHT", "path": "src/main/java/org/opentripplanner/model/Stop.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNFQwODo1ODowM1rOG7XgzQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNFQwODo1ODowM1rOG7XgzQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDkwNDM5Nw==", "bodyText": "JavaDoc", "url": "https://github.com/opentripplanner/OpenTripPlanner/pull/3122#discussion_r464904397", "createdAt": "2020-08-04T08:58:03Z", "author": {"login": "t2gran"}, "path": "src/main/java/org/opentripplanner/model/Stop.java", "diffHunk": "@@ -73,6 +89,10 @@ public String toString() {\n     return \"<Stop \" + this.id + \">\";\n   }\n \n+  public String getPlatformCode() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "557ea50e8b14a8ddd70729a8de08a7b6b61dde8c"}, "originalPosition": 62}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkwMzYxMTE1OnYy", "diffSide": "RIGHT", "path": "src/main/java/org/opentripplanner/model/Stop.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNFQwODo1ODoxM1rOG7XhNg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNFQwODo1ODoxM1rOG7XhNg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDkwNDUwMg==", "bodyText": "Add documentation about how this should be used", "url": "https://github.com/opentripplanner/OpenTripPlanner/pull/3122#discussion_r464904502", "createdAt": "2020-08-04T08:58:13Z", "author": {"login": "hannesj"}, "path": "src/main/java/org/opentripplanner/model/Stop.java", "diffHunk": "@@ -24,6 +27,10 @@\n    */\n   private final String url;\n \n+  private final TimeZone timeZone;\n+\n+  private final TransitMode vehicleType;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "557ea50e8b14a8ddd70729a8de08a7b6b61dde8c"}, "originalPosition": 23}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkwMzY0MDc0OnYy", "diffSide": "RIGHT", "path": "src/main/java/org/opentripplanner/netex/loader/mapping/StopMapper.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNFQwOTowNjoyMVrOG7XzMw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNFQwOTowNjoyMVrOG7XzMw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDkwOTEwNw==", "bodyText": "The mapper should handle null.", "url": "https://github.com/opentripplanner/OpenTripPlanner/pull/3122#discussion_r464909107", "createdAt": "2020-08-04T09:06:21Z", "author": {"login": "t2gran"}, "path": "src/main/java/org/opentripplanner/netex/loader/mapping/StopMapper.java", "diffHunk": "@@ -38,7 +39,12 @@ Stop mapQuayToStop(Quay quay, Station parentStation) {\n         null,\n         null,\n         null,\n-        null\n+        null,\n+        null,\n+        null,\n+        quay.getTransportMode() == null\n+            ? null\n+            : TransitModeMapper.mapMode(TransportModeMapper.mapVehicleMode(quay.getTransportMode()))", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "557ea50e8b14a8ddd70729a8de08a7b6b61dde8c"}, "originalPosition": 18}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkwMzY2MjY3OnYy", "diffSide": "RIGHT", "path": "src/main/java/org/opentripplanner/routing/RoutingService.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNFQwOToxMjoxMlrOG7YAgg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNFQwOToxMjoxMlrOG7YAgg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDkxMjUxNA==", "bodyText": "JavaDoc", "url": "https://github.com/opentripplanner/OpenTripPlanner/pull/3122#discussion_r464912514", "createdAt": "2020-08-04T09:12:12Z", "author": {"login": "t2gran"}, "path": "src/main/java/org/opentripplanner/routing/RoutingService.java", "diffHunk": "@@ -52,7 +57,32 @@ public RoutingResponse route(RoutingRequest request, Router router) {\n     public List<StopFinder.StopAndDistance> findClosestStopsByWalking(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "557ea50e8b14a8ddd70729a8de08a7b6b61dde8c"}, "originalPosition": 33}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkwMzY4MzQ3OnYy", "diffSide": "RIGHT", "path": "src/main/java/org/opentripplanner/routing/StopFinder.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNFQwOToxNzo0M1rOG7YNaw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNFQwOToxNzo0M1rOG7YNaw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDkxNTgxOQ==", "bodyText": "Rename to something like \"StreetGraphFinder\"...", "url": "https://github.com/opentripplanner/OpenTripPlanner/pull/3122#discussion_r464915819", "createdAt": "2020-08-04T09:17:43Z", "author": {"login": "t2gran"}, "path": "src/main/java/org/opentripplanner/routing/StopFinder.java", "diffHunk": "@@ -1,49 +1,59 @@\n package org.opentripplanner.routing;\n \n+import org.opentripplanner.model.FeedScopedId;\n import org.opentripplanner.model.GenericLocation;\n import org.opentripplanner.model.Stop;\n+import org.opentripplanner.model.TransitMode;\n+import org.opentripplanner.model.TripPattern;\n+import org.opentripplanner.model.TripTimeShort;\n import org.opentripplanner.routing.algorithm.astar.AStar;\n import org.opentripplanner.routing.algorithm.astar.TraverseVisitor;\n+import org.opentripplanner.routing.algorithm.astar.strategies.SearchTerminationStrategy;\n+import org.opentripplanner.routing.algorithm.astar.strategies.TrivialRemainingWeightHeuristic;\n import org.opentripplanner.routing.api.request.RoutingRequest;\n+import org.opentripplanner.routing.bike_rental.BikeRentalStation;\n import org.opentripplanner.routing.core.State;\n import org.opentripplanner.routing.core.TraverseMode;\n import org.opentripplanner.routing.graph.Edge;\n import org.opentripplanner.routing.graph.Graph;\n import org.opentripplanner.routing.graph.Vertex;\n import org.opentripplanner.routing.spt.DominanceFunction;\n+import org.opentripplanner.routing.spt.ShortestPathTree;\n+import org.opentripplanner.routing.vertextype.BikeRentalStationVertex;\n import org.opentripplanner.routing.vertextype.TransitStopVertex;\n \n import java.util.ArrayList;\n+import java.util.HashSet;\n import java.util.List;\n+import java.util.Set;\n+\n+import static java.util.stream.Collectors.toList;\n \n public class StopFinder {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "557ea50e8b14a8ddd70729a8de08a7b6b61dde8c"}, "originalPosition": 32}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkwMzcxMzQxOnYy", "diffSide": "RIGHT", "path": "src/main/java/org/opentripplanner/routing/StopFinder.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNFQwOToyNTo0NVrOG7YfrQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNFQwOToyNTo0NVrOG7YfrQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDkyMDQ5Mw==", "bodyText": "Doc: Move this and consolidate with the code in the NerbyStopFinder.", "url": "https://github.com/opentripplanner/OpenTripPlanner/pull/3122#discussion_r464920493", "createdAt": "2020-08-04T09:25:45Z", "author": {"login": "t2gran"}, "path": "src/main/java/org/opentripplanner/routing/StopFinder.java", "diffHunk": "@@ -1,49 +1,59 @@\n package org.opentripplanner.routing;\n \n+import org.opentripplanner.model.FeedScopedId;\n import org.opentripplanner.model.GenericLocation;\n import org.opentripplanner.model.Stop;\n+import org.opentripplanner.model.TransitMode;\n+import org.opentripplanner.model.TripPattern;\n+import org.opentripplanner.model.TripTimeShort;\n import org.opentripplanner.routing.algorithm.astar.AStar;\n import org.opentripplanner.routing.algorithm.astar.TraverseVisitor;\n+import org.opentripplanner.routing.algorithm.astar.strategies.SearchTerminationStrategy;\n+import org.opentripplanner.routing.algorithm.astar.strategies.TrivialRemainingWeightHeuristic;\n import org.opentripplanner.routing.api.request.RoutingRequest;\n+import org.opentripplanner.routing.bike_rental.BikeRentalStation;\n import org.opentripplanner.routing.core.State;\n import org.opentripplanner.routing.core.TraverseMode;\n import org.opentripplanner.routing.graph.Edge;\n import org.opentripplanner.routing.graph.Graph;\n import org.opentripplanner.routing.graph.Vertex;\n import org.opentripplanner.routing.spt.DominanceFunction;\n+import org.opentripplanner.routing.spt.ShortestPathTree;\n+import org.opentripplanner.routing.vertextype.BikeRentalStationVertex;\n import org.opentripplanner.routing.vertextype.TransitStopVertex;\n \n import java.util.ArrayList;\n+import java.util.HashSet;\n import java.util.List;\n+import java.util.Set;\n+\n+import static java.util.stream.Collectors.toList;\n \n public class StopFinder {\n \n   /* TODO: an almost similar function exists in ProfileRouter, combine these.\n    *  Should these live in a separate class? */", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "557ea50e8b14a8ddd70729a8de08a7b6b61dde8c"}, "originalPosition": 35}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkwMzcxODgzOnYy", "diffSide": "RIGHT", "path": "src/main/java/org/opentripplanner/routing/StopFinder.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNFQwOToyNzoyMFrOG7YjNA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNFQwOToyNzoyMFrOG7YjNA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDkyMTM5Ng==", "bodyText": "All public classes and enums should be in their own file.", "url": "https://github.com/opentripplanner/OpenTripPlanner/pull/3122#discussion_r464921396", "createdAt": "2020-08-04T09:27:20Z", "author": {"login": "t2gran"}, "path": "src/main/java/org/opentripplanner/routing/StopFinder.java", "diffHunk": "@@ -78,4 +88,199 @@ public void visitVertex(State state) {\n       }\n     }\n   }\n+\n+  public enum PlaceType {\n+    STOP, DEPARTURE_ROW, BICYCLE_RENT, BIKE_PARK, CAR_PARK;\n+  }\n+\n+  public static class PlaceAndDistance {\n+    public Object place;\n+    public int distance;\n+\n+    public PlaceAndDistance(Object place, int distance) {\n+      this.place = place;\n+      this.distance = distance;\n+    }\n+  }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "557ea50e8b14a8ddd70729a8de08a7b6b61dde8c"}, "originalPosition": 93}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkxMzM3ODY4OnYy", "diffSide": "RIGHT", "path": "src/main/java/org/opentripplanner/model/SimpleTransfer.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNlQxNDowMDoyMVrOG803-A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNlQxNToxNjo1N1rOG84LcA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjQzNDA0MA==", "bodyText": "in the .... ?", "url": "https://github.com/opentripplanner/OpenTripPlanner/pull/3122#discussion_r466434040", "createdAt": "2020-08-06T14:00:21Z", "author": {"login": "t2gran"}, "path": "src/main/java/org/opentripplanner/model/SimpleTransfer.java", "diffHunk": "@@ -9,6 +9,7 @@\n  * Represents a transfer between stops that does not take the street network into account.\n  *\n  * TODO these should really have a set of valid modes in case bike vs. walk transfers are different\n+ * TODO Should we just store the StopAtDistance in the", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "97af284c5aa522cd4f7f552c37482b4e11c2b827"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjQ4ODE3Ng==", "bodyText": "Fixed", "url": "https://github.com/opentripplanner/OpenTripPlanner/pull/3122#discussion_r466488176", "createdAt": "2020-08-06T15:16:57Z", "author": {"login": "hannesj"}, "path": "src/main/java/org/opentripplanner/model/SimpleTransfer.java", "diffHunk": "@@ -9,6 +9,7 @@\n  * Represents a transfer between stops that does not take the street network into account.\n  *\n  * TODO these should really have a set of valid modes in case bike vs. walk transfers are different\n+ * TODO Should we just store the StopAtDistance in the", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjQzNDA0MA=="}, "originalCommit": {"oid": "97af284c5aa522cd4f7f552c37482b4e11c2b827"}, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkxMzQyMTIwOnYy", "diffSide": "RIGHT", "path": "src/main/java/org/opentripplanner/routing/RoutingService.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNlQxNDoxMDoxOVrOG81Snw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNlQxNDo1ODo1MFrOG83aew==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjQ0MDg2Mw==", "bodyText": "FYI: In the feature I would like us to use the java.time types, not a long (epoch). There is a separate issue on this, and I think it is best to change this all over in a separate PR.", "url": "https://github.com/opentripplanner/OpenTripPlanner/pull/3122#discussion_r466440863", "createdAt": "2020-08-06T14:10:19Z", "author": {"login": "t2gran"}, "path": "src/main/java/org/opentripplanner/routing/RoutingService.java", "diffHunk": "@@ -96,6 +95,36 @@ public RoutingResponse route(RoutingRequest request, Router router) {\n         return StopTimesHelper.getStopTimesForStop(this, stop, serviceDate, omitNonPickups);\n     }\n \n+\n+    /**\n+     * Fetch upcoming vehicle departures from a stop for a specific pattern, passing the stop\n+     * for the previous, current and next service date. It uses a priority queue to keep track of\n+     * the next departures. The queue is shared between all dates, as services from the previous\n+     * service date can visit the stop later than the current service date's services.\n+     * <p>\n+     * TODO: Add frequency based trips\n+     *\n+     * @param stop               Stop object to perform the search for\n+     * @param pattern            Pattern object to perform the search for\n+     * @param startTime          Start time for the search. Seconds from UNIX epoch\n+     * @param timeRange          Searches forward for timeRange seconds from startTime\n+     * @param numberOfDepartures Number of departures to fetch per pattern\n+     * @param omitNonPickups     If true, do not include vehicles that will not pick up passengers.\n+     */\n+    public List<TripTimeShort> stopTimesForPatternAtStop(\n+            Stop stop, TripPattern pattern, long startTime, int timeRange, int numberOfDepartures, boolean omitNonPickups\n+    ) {\n+        return StopTimesHelper.stopTimesForPatternAtStop(this,\n+                lazyGetTimeTableSnapShot(),\n+                stop,\n+                pattern,\n+                startTime,\n+                timeRange,\n+                numberOfDepartures,\n+                omitNonPickups\n+        );\n+    }\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "97af284c5aa522cd4f7f552c37482b4e11c2b827"}, "originalPosition": 78}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjQ3NTY0Mw==", "bodyText": "\ud83d\udc4d", "url": "https://github.com/opentripplanner/OpenTripPlanner/pull/3122#discussion_r466475643", "createdAt": "2020-08-06T14:58:50Z", "author": {"login": "hannesj"}, "path": "src/main/java/org/opentripplanner/routing/RoutingService.java", "diffHunk": "@@ -96,6 +95,36 @@ public RoutingResponse route(RoutingRequest request, Router router) {\n         return StopTimesHelper.getStopTimesForStop(this, stop, serviceDate, omitNonPickups);\n     }\n \n+\n+    /**\n+     * Fetch upcoming vehicle departures from a stop for a specific pattern, passing the stop\n+     * for the previous, current and next service date. It uses a priority queue to keep track of\n+     * the next departures. The queue is shared between all dates, as services from the previous\n+     * service date can visit the stop later than the current service date's services.\n+     * <p>\n+     * TODO: Add frequency based trips\n+     *\n+     * @param stop               Stop object to perform the search for\n+     * @param pattern            Pattern object to perform the search for\n+     * @param startTime          Start time for the search. Seconds from UNIX epoch\n+     * @param timeRange          Searches forward for timeRange seconds from startTime\n+     * @param numberOfDepartures Number of departures to fetch per pattern\n+     * @param omitNonPickups     If true, do not include vehicles that will not pick up passengers.\n+     */\n+    public List<TripTimeShort> stopTimesForPatternAtStop(\n+            Stop stop, TripPattern pattern, long startTime, int timeRange, int numberOfDepartures, boolean omitNonPickups\n+    ) {\n+        return StopTimesHelper.stopTimesForPatternAtStop(this,\n+                lazyGetTimeTableSnapShot(),\n+                stop,\n+                pattern,\n+                startTime,\n+                timeRange,\n+                numberOfDepartures,\n+                omitNonPickups\n+        );\n+    }\n+", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjQ0MDg2Mw=="}, "originalCommit": {"oid": "97af284c5aa522cd4f7f552c37482b4e11c2b827"}, "originalPosition": 78}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkxMzQ5MDcwOnYy", "diffSide": "RIGHT", "path": "src/main/java/org/opentripplanner/routing/graph_finder/DirectGraphFinder.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNlQxNDoyNTozOFrOG819bg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNlQxNDo1NzowMlrOG83VYg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjQ1MTgyMg==", "bodyText": "FYI: We have a few of these package names with _ in them, but strictly they are not recommended by the original Java Style guide. I might refactor it at some point to be compliant. The standard recommend using just graphfinder. I guess the reason is quite old; some filesystems having problems with special characters.", "url": "https://github.com/opentripplanner/OpenTripPlanner/pull/3122#discussion_r466451822", "createdAt": "2020-08-06T14:25:38Z", "author": {"login": "t2gran"}, "path": "src/main/java/org/opentripplanner/routing/graph_finder/DirectGraphFinder.java", "diffHunk": "@@ -0,0 +1,65 @@\n+package org.opentripplanner.routing.graph_finder;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "97af284c5aa522cd4f7f552c37482b4e11c2b827"}, "originalPosition": 1}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjQ3NDMzOA==", "bodyText": "Renamed, easier to do now.", "url": "https://github.com/opentripplanner/OpenTripPlanner/pull/3122#discussion_r466474338", "createdAt": "2020-08-06T14:57:02Z", "author": {"login": "hannesj"}, "path": "src/main/java/org/opentripplanner/routing/graph_finder/DirectGraphFinder.java", "diffHunk": "@@ -0,0 +1,65 @@\n+package org.opentripplanner.routing.graph_finder;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjQ1MTgyMg=="}, "originalCommit": {"oid": "97af284c5aa522cd4f7f552c37482b4e11c2b827"}, "originalPosition": 1}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkxMzUxMzc4OnYy", "diffSide": "RIGHT", "path": "src/main/java/org/opentripplanner/routing/graph_finder/DirectGraphFinder.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNlQxNDozMDoyN1rOG82Lrg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNlQxNDo1NTowMVrOG83P9A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjQ1NTQ3MA==", "bodyText": "For the inner most loop iterator variable, the defacto standard I am used to, is to use it, which is also used in lambdas. What is the rationale behind the number in the variable names here?", "url": "https://github.com/opentripplanner/OpenTripPlanner/pull/3122#discussion_r466455470", "createdAt": "2020-08-06T14:30:27Z", "author": {"login": "t2gran"}, "path": "src/main/java/org/opentripplanner/routing/graph_finder/DirectGraphFinder.java", "diffHunk": "@@ -0,0 +1,65 @@\n+package org.opentripplanner.routing.graph_finder;\n+\n+import com.beust.jcommander.internal.Lists;\n+import org.locationtech.jts.geom.Coordinate;\n+import org.locationtech.jts.geom.GeometryFactory;\n+import org.opentripplanner.common.geometry.GeometryUtils;\n+import org.opentripplanner.common.geometry.SphericalDistanceLibrary;\n+import org.opentripplanner.model.FeedScopedId;\n+import org.opentripplanner.model.TransitMode;\n+import org.opentripplanner.routing.RoutingService;\n+import org.opentripplanner.routing.graph.Graph;\n+import org.opentripplanner.routing.impl.StreetVertexIndex;\n+import org.opentripplanner.routing.vertextype.TransitStopVertex;\n+\n+import java.util.List;\n+\n+/**\n+ * A Graph finder used in conjunction with a graph, which does not have a street network included.\n+ * Also usable if performance is more important or if the \"as the crow flies\" distance id required.\n+ */\n+public class DirectGraphFinder implements GraphFinder {\n+\n+  private static GeometryFactory geometryFactory = GeometryUtils.getGeometryFactory();\n+\n+  private StreetVertexIndex streetIndex;\n+\n+  public DirectGraphFinder(Graph graph) {\n+    this.streetIndex = graph.streetIndex != null ? graph.streetIndex : new StreetVertexIndex(graph);\n+  }\n+\n+  /**\n+   * Return all stops within a certain radius of the given vertex, using straight-line distance independent of streets.\n+   * If the origin vertex is a StopVertex, the result will include it.\n+   */\n+  @Override\n+  public List<StopAtDistance> findClosestStops(double lat, double lon, double radiusMeters) {\n+    List<StopAtDistance> stopsFound = Lists.newArrayList();\n+    Coordinate c0 = new Coordinate(lon, lat);\n+    for (TransitStopVertex ts1 : streetIndex.getNearbyTransitStops(c0, radiusMeters)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "97af284c5aa522cd4f7f552c37482b4e11c2b827"}, "originalPosition": 39}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjQ3Mjk0OA==", "bodyText": "This was just lifted off from here https://github.com/opentripplanner/OpenTripPlanner/pull/3122/files#diff-7aa5baeb59c0d0b53802ce6ec0efe627L216-L233. I'll update it.", "url": "https://github.com/opentripplanner/OpenTripPlanner/pull/3122#discussion_r466472948", "createdAt": "2020-08-06T14:55:01Z", "author": {"login": "hannesj"}, "path": "src/main/java/org/opentripplanner/routing/graph_finder/DirectGraphFinder.java", "diffHunk": "@@ -0,0 +1,65 @@\n+package org.opentripplanner.routing.graph_finder;\n+\n+import com.beust.jcommander.internal.Lists;\n+import org.locationtech.jts.geom.Coordinate;\n+import org.locationtech.jts.geom.GeometryFactory;\n+import org.opentripplanner.common.geometry.GeometryUtils;\n+import org.opentripplanner.common.geometry.SphericalDistanceLibrary;\n+import org.opentripplanner.model.FeedScopedId;\n+import org.opentripplanner.model.TransitMode;\n+import org.opentripplanner.routing.RoutingService;\n+import org.opentripplanner.routing.graph.Graph;\n+import org.opentripplanner.routing.impl.StreetVertexIndex;\n+import org.opentripplanner.routing.vertextype.TransitStopVertex;\n+\n+import java.util.List;\n+\n+/**\n+ * A Graph finder used in conjunction with a graph, which does not have a street network included.\n+ * Also usable if performance is more important or if the \"as the crow flies\" distance id required.\n+ */\n+public class DirectGraphFinder implements GraphFinder {\n+\n+  private static GeometryFactory geometryFactory = GeometryUtils.getGeometryFactory();\n+\n+  private StreetVertexIndex streetIndex;\n+\n+  public DirectGraphFinder(Graph graph) {\n+    this.streetIndex = graph.streetIndex != null ? graph.streetIndex : new StreetVertexIndex(graph);\n+  }\n+\n+  /**\n+   * Return all stops within a certain radius of the given vertex, using straight-line distance independent of streets.\n+   * If the origin vertex is a StopVertex, the result will include it.\n+   */\n+  @Override\n+  public List<StopAtDistance> findClosestStops(double lat, double lon, double radiusMeters) {\n+    List<StopAtDistance> stopsFound = Lists.newArrayList();\n+    Coordinate c0 = new Coordinate(lon, lat);\n+    for (TransitStopVertex ts1 : streetIndex.getNearbyTransitStops(c0, radiusMeters)) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjQ1NTQ3MA=="}, "originalCommit": {"oid": "97af284c5aa522cd4f7f552c37482b4e11c2b827"}, "originalPosition": 39}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkxMzYyMjg3OnYy", "diffSide": "RIGHT", "path": "src/main/java/org/opentripplanner/routing/graph_finder/PlaceFinderTraverseVisitor.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNlQxNDo1NDo0NVrOG83PIg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNlQxNToxNjo0M1rOG84Kyg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjQ3MjczOA==", "bodyText": "Tip: Set.copyOf(list) is preferable since there is no modifications to the set afterwards.", "url": "https://github.com/opentripplanner/OpenTripPlanner/pull/3122#discussion_r466472738", "createdAt": "2020-08-06T14:54:45Z", "author": {"login": "t2gran"}, "path": "src/main/java/org/opentripplanner/routing/graph_finder/PlaceFinderTraverseVisitor.java", "diffHunk": "@@ -0,0 +1,175 @@\n+package org.opentripplanner.routing.graph_finder;\n+\n+import org.opentripplanner.model.FeedScopedId;\n+import org.opentripplanner.model.Stop;\n+import org.opentripplanner.model.TransitMode;\n+import org.opentripplanner.model.TripPattern;\n+import org.opentripplanner.routing.RoutingService;\n+import org.opentripplanner.routing.algorithm.astar.TraverseVisitor;\n+import org.opentripplanner.routing.algorithm.astar.strategies.SearchTerminationStrategy;\n+import org.opentripplanner.routing.bike_rental.BikeRentalStation;\n+import org.opentripplanner.routing.core.State;\n+import org.opentripplanner.routing.graph.Edge;\n+import org.opentripplanner.routing.graph.Vertex;\n+import org.opentripplanner.routing.vertextype.BikeRentalStationVertex;\n+import org.opentripplanner.routing.vertextype.TransitStopVertex;\n+\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+\n+import static java.util.stream.Collectors.toList;\n+\n+/**\n+ * A TraverseVisitor used in finding various types of places while walking the street graph.\n+ *\n+ * TODO Add car and bike parks\n+ */\n+public class PlaceFinderTraverseVisitor implements TraverseVisitor {\n+\n+  public final List<PlaceAtDistance> placesFound = new ArrayList<>();\n+  private final RoutingService routingService;\n+  private final Set<TransitMode> filterByModes;\n+  private final Set<FeedScopedId> filterByStops;\n+  private final Set<FeedScopedId> filterByRoutes;\n+  private final Set<String> filterByBikeRentalStation;\n+  private final Set<String> seenPatternAtStops = new HashSet<>();\n+  private final Set<FeedScopedId> seenStops = new HashSet<>();\n+  private final Set<String> seenBicycleRentalStations = new HashSet<>();\n+  private final boolean includeStops;\n+  private final boolean includePatternAtStops;\n+  private final boolean includeBikeShares;\n+  private final int maxResults;\n+\n+  /**\n+   *\n+   * @param routingService A RoutingService used in finding information about the various places.\n+   * @param filterByModes A list of TransitModes for which to find Stops and PatternAtStops. Use null to disable the filtering.\n+   * @param filterByPlaceTypes A list of PlaceTypes to search for. Use null to disable the filtering, and search for all types.\n+   * @param filterByStops A list of Stop ids for which to find Stops and PatternAtStops. Use null to disable the filtering.\n+   * @param filterByRoutes A list of Route ids used for filtering Stops. Only the stops which are served by the route are returned. Use null to disable the filtering.\n+   * @param filterByBikeRentalStations A list of BikeRentalStation ids to use in filtering.  Use null to disable the filtering.\n+   * @param maxResults Maximum number of results to return.\n+   */\n+  public PlaceFinderTraverseVisitor(\n+      RoutingService routingService, List<TransitMode> filterByModes,\n+      List<PlaceType> filterByPlaceTypes, List<FeedScopedId> filterByStops,\n+      List<FeedScopedId> filterByRoutes, List<String> filterByBikeRentalStations, int maxResults\n+  ) {\n+    this.routingService = routingService;\n+    this.filterByModes = toSet(filterByModes);\n+    this.filterByStops = toSet(filterByStops);\n+    this.filterByRoutes = toSet(filterByRoutes);\n+    this.filterByBikeRentalStation = toSet(filterByBikeRentalStations);\n+\n+    includeStops = filterByPlaceTypes == null || filterByPlaceTypes.contains(PlaceType.STOP);\n+    includePatternAtStops = filterByPlaceTypes == null\n+        || filterByPlaceTypes.contains(PlaceType.PATTERN_AT_STOP);\n+    includeBikeShares = filterByPlaceTypes == null\n+        || filterByPlaceTypes.contains(PlaceType.BICYCLE_RENT);\n+    this.maxResults = maxResults;\n+  }\n+\n+  private static <T> Set<T> toSet(List<T> list) {\n+    if (list == null) { return null; }\n+    return new HashSet<T>(list);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "97af284c5aa522cd4f7f552c37482b4e11c2b827"}, "originalPosition": 76}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjQ4ODAxMA==", "bodyText": "Changed", "url": "https://github.com/opentripplanner/OpenTripPlanner/pull/3122#discussion_r466488010", "createdAt": "2020-08-06T15:16:43Z", "author": {"login": "hannesj"}, "path": "src/main/java/org/opentripplanner/routing/graph_finder/PlaceFinderTraverseVisitor.java", "diffHunk": "@@ -0,0 +1,175 @@\n+package org.opentripplanner.routing.graph_finder;\n+\n+import org.opentripplanner.model.FeedScopedId;\n+import org.opentripplanner.model.Stop;\n+import org.opentripplanner.model.TransitMode;\n+import org.opentripplanner.model.TripPattern;\n+import org.opentripplanner.routing.RoutingService;\n+import org.opentripplanner.routing.algorithm.astar.TraverseVisitor;\n+import org.opentripplanner.routing.algorithm.astar.strategies.SearchTerminationStrategy;\n+import org.opentripplanner.routing.bike_rental.BikeRentalStation;\n+import org.opentripplanner.routing.core.State;\n+import org.opentripplanner.routing.graph.Edge;\n+import org.opentripplanner.routing.graph.Vertex;\n+import org.opentripplanner.routing.vertextype.BikeRentalStationVertex;\n+import org.opentripplanner.routing.vertextype.TransitStopVertex;\n+\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+\n+import static java.util.stream.Collectors.toList;\n+\n+/**\n+ * A TraverseVisitor used in finding various types of places while walking the street graph.\n+ *\n+ * TODO Add car and bike parks\n+ */\n+public class PlaceFinderTraverseVisitor implements TraverseVisitor {\n+\n+  public final List<PlaceAtDistance> placesFound = new ArrayList<>();\n+  private final RoutingService routingService;\n+  private final Set<TransitMode> filterByModes;\n+  private final Set<FeedScopedId> filterByStops;\n+  private final Set<FeedScopedId> filterByRoutes;\n+  private final Set<String> filterByBikeRentalStation;\n+  private final Set<String> seenPatternAtStops = new HashSet<>();\n+  private final Set<FeedScopedId> seenStops = new HashSet<>();\n+  private final Set<String> seenBicycleRentalStations = new HashSet<>();\n+  private final boolean includeStops;\n+  private final boolean includePatternAtStops;\n+  private final boolean includeBikeShares;\n+  private final int maxResults;\n+\n+  /**\n+   *\n+   * @param routingService A RoutingService used in finding information about the various places.\n+   * @param filterByModes A list of TransitModes for which to find Stops and PatternAtStops. Use null to disable the filtering.\n+   * @param filterByPlaceTypes A list of PlaceTypes to search for. Use null to disable the filtering, and search for all types.\n+   * @param filterByStops A list of Stop ids for which to find Stops and PatternAtStops. Use null to disable the filtering.\n+   * @param filterByRoutes A list of Route ids used for filtering Stops. Only the stops which are served by the route are returned. Use null to disable the filtering.\n+   * @param filterByBikeRentalStations A list of BikeRentalStation ids to use in filtering.  Use null to disable the filtering.\n+   * @param maxResults Maximum number of results to return.\n+   */\n+  public PlaceFinderTraverseVisitor(\n+      RoutingService routingService, List<TransitMode> filterByModes,\n+      List<PlaceType> filterByPlaceTypes, List<FeedScopedId> filterByStops,\n+      List<FeedScopedId> filterByRoutes, List<String> filterByBikeRentalStations, int maxResults\n+  ) {\n+    this.routingService = routingService;\n+    this.filterByModes = toSet(filterByModes);\n+    this.filterByStops = toSet(filterByStops);\n+    this.filterByRoutes = toSet(filterByRoutes);\n+    this.filterByBikeRentalStation = toSet(filterByBikeRentalStations);\n+\n+    includeStops = filterByPlaceTypes == null || filterByPlaceTypes.contains(PlaceType.STOP);\n+    includePatternAtStops = filterByPlaceTypes == null\n+        || filterByPlaceTypes.contains(PlaceType.PATTERN_AT_STOP);\n+    includeBikeShares = filterByPlaceTypes == null\n+        || filterByPlaceTypes.contains(PlaceType.BICYCLE_RENT);\n+    this.maxResults = maxResults;\n+  }\n+\n+  private static <T> Set<T> toSet(List<T> list) {\n+    if (list == null) { return null; }\n+    return new HashSet<T>(list);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjQ3MjczOA=="}, "originalCommit": {"oid": "97af284c5aa522cd4f7f552c37482b4e11c2b827"}, "originalPosition": 76}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkxMzY3MjUyOnYy", "diffSide": "RIGHT", "path": "src/main/java/org/opentripplanner/routing/graph_finder/PatternAtStop.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNlQxNTowNjoxMVrOG83uzQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNlQxNTowNjoxMVrOG83uzQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjQ4MDg0NQ==", "bodyText": "FYI: Nice, we do this in at least one other place - so at some point we can extract the (de-)serialization of the 2 ids and reuse it.", "url": "https://github.com/opentripplanner/OpenTripPlanner/pull/3122#discussion_r466480845", "createdAt": "2020-08-06T15:06:11Z", "author": {"login": "t2gran"}, "path": "src/main/java/org/opentripplanner/routing/graph_finder/PatternAtStop.java", "diffHunk": "@@ -0,0 +1,81 @@\n+package org.opentripplanner.routing.graph_finder;\n+\n+import org.opentripplanner.model.FeedScopedId;\n+import org.opentripplanner.model.Stop;\n+import org.opentripplanner.model.TripPattern;\n+import org.opentripplanner.model.TripTimeShort;\n+import org.opentripplanner.routing.RoutingService;\n+\n+import java.nio.charset.Charset;\n+import java.nio.charset.StandardCharsets;\n+import java.util.Base64;\n+import java.util.List;\n+\n+/**\n+ * A reference to a pattern at a specific stop.\n+ *\n+ * TODO Is this the right package for this?\n+ */\n+public class PatternAtStop {\n+\n+  public String id;\n+  public Stop stop;\n+  public TripPattern pattern;\n+\n+  public PatternAtStop(Stop stop, TripPattern pattern) {\n+    this.id = toId(stop, pattern);\n+    this.stop = stop;\n+    this.pattern = pattern;\n+  }\n+\n+  /**\n+   * Converts the ids of the pattern and stop to an opaque id, which can be supplied to the users\n+   * to be used for refetching the combination.\n+   */\n+  private static String toId(Stop stop, TripPattern pattern) {\n+    Base64.Encoder encoder = Base64.getEncoder();\n+    return encoder.encodeToString(stop.getId().toString().getBytes(StandardCharsets.UTF_8)) + \";\" +\n+        encoder.encodeToString(pattern.getId().toString().getBytes(StandardCharsets.UTF_8));\n+  }\n+\n+  /**\n+   * Convert an id generated by the toId method to an instance of PatternAtStop. Uses the supplied\n+   * routingService to fetch the TripPattern and Stop instances.\n+   *\n+   * @see PatternAtStop#toId(Stop, TripPattern)\n+   */\n+  public static PatternAtStop fromId(RoutingService routingService, String id) {\n+    String[] parts = id.split(\";\", 2);\n+    Base64.Decoder decoder = Base64.getDecoder();\n+    FeedScopedId stopId = FeedScopedId.parseId(new String(decoder.decode(parts[0]), StandardCharsets.UTF_8));\n+    FeedScopedId patternId = FeedScopedId.parseId(new String(decoder.decode(parts[1]), StandardCharsets.UTF_8));\n+    return new PatternAtStop(routingService.getStopForId(stopId),\n+        routingService.getTripPatternForId(patternId)\n+    );\n+  }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "97af284c5aa522cd4f7f552c37482b4e11c2b827"}, "originalPosition": 55}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1863, "cost": 1, "resetAt": "2021-11-13T12:10:21Z"}}}