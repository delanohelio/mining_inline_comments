{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzYxNTg2NjU5", "number": 2922, "reviewThreads": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNVQxMDoxMjo1MlrODYH5WA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQyMjoyNToxN1rODe-9GQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI2NjIxNzg0OnYy", "diffSide": "RIGHT", "path": "src/main/java/org/opentripplanner/routing/algorithm/raptor/transit/mappers/TransitLayerMapper.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNVQxMDoxMjo1MlrOFdzQXA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNVQxMDoxMjo1MlrOFdzQXA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Njc5Mjc5Ng==", "bodyText": "This modify its input - sideeffects.", "url": "https://github.com/opentripplanner/OpenTripPlanner/pull/2922#discussion_r366792796", "createdAt": "2020-01-15T10:12:52Z", "author": {"login": "t2gran"}, "path": "src/main/java/org/opentripplanner/routing/algorithm/raptor/transit/mappers/TransitLayerMapper.java", "diffHunk": "@@ -139,70 +145,119 @@ private TransitLayer map() {\n             LOG.info(\"This TransitLayerMapper got a realtime timetable snapshot. The TransitLayer will reflect realtime updates to scheduled service.\");\n         }\n         Set<ServiceDate> allServiceDates = serviceIdsForServiceDate.keySet();\n-        Map<Timetable, List<TripTimes>> sortedTripTimesForTimetable = new HashMap<>();\n-        for (ServiceDate serviceDate : allServiceDates) {\n-            // Create LocalDate equivalent to the OTP/GTFS ServiceDate object, serving as the key of\n-            // the return Map.\n-            LocalDate localDate = ServiceCalendarMapper.localDateFromServiceDate(serviceDate);\n-\n-            // Create a List to hold the values for one entry in the return Map.\n-            List<TripPatternForDate> values = new ArrayList<>();\n-            TIntSet serviceCodesRunning = new TIntHashSet();\n-\n-            for (FeedScopedId serviceId : serviceIdsForServiceDate.get(serviceDate)) {\n-                serviceCodesRunning.add(graph.serviceCodes.get(serviceId));\n-            }\n+        ConcurrentMap<Timetable, List<TripTimes>> sortedTripTimesForTimetable = new ConcurrentHashMap<>();\n \n-            // This nested loop could be quite inefficient.\n-            // Maybe determine in advance which patterns are running on each service and day.\n-            for (org.opentripplanner.model.TripPattern oldTripPattern : allTripPatterns) {\n-                // Get an updated or scheduled timetable depending on the date. This might have the\n-                // trips pre-filtered for the specified date, that needs to be investigated. But in\n-                // any case we might end up with a scheduled timetable, which can include\n-                // non-running trips. So filter the trips according to which service IDs are running\n-                // on the given day.\n-                Timetable timetable = oldTripPattern.scheduledTimetable;\n-                if (timetableSnapshot != null) {\n-                    timetable = timetableSnapshot.resolve(oldTripPattern, serviceDate);\n-                }\n-                List<TripSchedule> newTripSchedules = new ArrayList<>();\n-                // The TripTimes are not sorted by departure time in the source timetable because\n-                // OTP1 performs a simple/ linear search. Raptor results depend on trips being\n-                // sorted. We reuse the same timetables many times on different days, so cache the\n-                // sorted versions to avoid repeated compute-intensive sorting. Anecdotally this\n-                // reduces mapping time by more than half, but it is still rather slow. NL Mapping\n-                // takes 32 seconds sorting every timetable, 9 seconds with cached sorting, and 6\n-                // seconds with no timetable sorting at all.\n-                List<TripTimes> sortedTripTimes = sortedTripTimesForTimetable.computeIfAbsent(\n-                    timetable,\n-                    TransitLayerMapper::getSortedTripTimes\n-                );\n-                for (TripTimes tripTimes : sortedTripTimes) {\n-                    if (!serviceCodesRunning.contains(tripTimes.serviceCode)) {\n-                        continue;\n-                    }\n-                    if (tripTimes.getRealTimeState() == RealTimeState.CANCELED) {\n-                        continue;\n-                    }\n-                    TripSchedule tripSchedule = tripScheduleForTripTimes.computeIfAbsent(\n-                        tripTimes,\n-                        // The following are two alternative implementations of TripSchedule\n-                        tt -> new TripScheduleWrapperImpl(tt, oldTripPattern)\n-                        // tt -> tt.toTripSchedulImpl(oldTripPattern)\n+        // CONCURRENT !!! The following stream is running in multiple threads. For a dataset like\n+        // the Norwegian NeTEx hole of Norway, running this in parallel on a Mac book PRO, JAN 2020,\n+        // this saves 20 seconds - from 36s down to 15s.\n+        allServiceDates\n+                .parallelStream()\n+                .forEach(serviceDate -> {\n+                    // Create LocalDate equivalent to the OTP/GTFS ServiceDate object, serving as the key of\n+                    // the return Map.\n+                    LocalDate date = ServiceCalendarMapper.localDateFromServiceDate(\n+                            serviceDate);\n+\n+                    List<TripPatternForDate> res = mapTripPatternForDay(\n+                            serviceIdsForServiceDate,\n+                            allTripPatterns,\n+                            newTripPatternForOld,\n+                            tripScheduleForTripTimes,\n+                            sortedTripTimesForTimetable,\n+                            serviceDate,\n+                            date\n                     );\n-                    newTripSchedules.add(tripSchedule);\n-                } \n-                TripPattern newTripPattern = newTripPatternForOld.get(oldTripPattern);\n-                TripPatternForDate tripPatternForDate = new TripPatternForDate(\n-                        newTripPattern,\n-                        newTripSchedules,\n-                        localDate\n+                    if(!res.isEmpty()) {\n+                        synchronized (tripPatternsForDates) {\n+                            tripPatternsForDates.put(date, res);\n+                        }\n+                    }\n+                });\n+        return tripPatternsForDates;\n+    }\n+\n+    /**\n+     * Create a list of trip patterns for a given {@code serviceDate}.\n+     * <p>\n+     * THREAD SAFE - This method is called from multiple threads and MUST be thread safe.\n+     *", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "73068f9245c5b79b1ca63c6397bf23bb3dce453e"}, "originalPosition": 142}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMzODEyNDQ3OnYy", "diffSide": "RIGHT", "path": "src/main/java/org/opentripplanner/routing/algorithm/raptor/transit/mappers/TransitLayerMapper.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQyMjoxNToxOVrOFobJEQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQyMjoxNToxOVrOFobJEQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzkzMjA0OQ==", "bodyText": "Mak a comment here so it is REALY easy to see this this is running in multiple threads.", "url": "https://github.com/opentripplanner/OpenTripPlanner/pull/2922#discussion_r377932049", "createdAt": "2020-02-11T22:15:19Z", "author": {"login": "t2gran"}, "path": "src/main/java/org/opentripplanner/routing/algorithm/raptor/transit/mappers/TransitLayerMapper.java", "diffHunk": "@@ -90,29 +95,39 @@ private TransitLayer map() {\n             newTripPatternForOld\n         );\n \n-        for (ServiceDate serviceDate : graph.index.getServiceCodesRunningForDate().keySet()) {\n-            // Create LocalDate equivalent to the OTP/GTFS ServiceDate object, serving as the key of\n-            // the return Map.\n-            LocalDate localDate = ServiceCalendarMapper.localDateFromServiceDate(serviceDate);\n-\n-            // Create a List to hold the values for one entry in the return Map.\n-            List<TripPatternForDate> values = new ArrayList<>();\n-\n-            // This nested loop could be quite inefficient.\n-            // Maybe determine in advance which patterns are running on each service and day.\n-            for (org.opentripplanner.model.TripPattern oldTripPattern : allTripPatterns) {\n-                TripPatternForDate tripPatternForDate = tripPatternForDateMapper.map(oldTripPattern.scheduledTimetable, serviceDate);\n-                if (tripPatternForDate != null) {\n-                    values.add(tripPatternForDate);\n+        Set<ServiceDate> allServiceDates = graph.index.getServiceCodesRunningForDate().keySet();\n+\n+        allServiceDates", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a9dfaedb5e58d7682842e8fe645ab30618209cb7"}, "originalPosition": 65}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMzODEzNjE3OnYy", "diffSide": "RIGHT", "path": "src/main/java/org/opentripplanner/routing/algorithm/raptor/transit/mappers/TripPatternForDateMapper.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQyMjoxOToxNFrOFobP6Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQyMjoxOToxNFrOFobP6Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzkzMzgwMQ==", "bodyText": "This class needs JavaDoc documentation that it is Thread safe - why it is so.", "url": "https://github.com/opentripplanner/OpenTripPlanner/pull/2922#discussion_r377933801", "createdAt": "2020-02-11T22:19:14Z", "author": {"login": "t2gran"}, "path": "src/main/java/org/opentripplanner/routing/algorithm/raptor/transit/mappers/TripPatternForDateMapper.java", "diffHunk": "@@ -28,14 +29,20 @@\n \n   private static final Logger LOG = LoggerFactory.getLogger(TripPatternForDateMapper.class);\n \n-  private final Map<Timetable, List<TripTimes>> sortedTripTimesForTimetable = new HashMap<>();\n+  private final ConcurrentMap<Timetable, List<TripTimes>> sortedTripTimesForTimetable =\n+      new ConcurrentHashMap<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a9dfaedb5e58d7682842e8fe645ab30618209cb7"}, "originalPosition": 18}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMzODE1MzIxOnYy", "diffSide": "RIGHT", "path": "src/main/java/org/opentripplanner/routing/algorithm/raptor/transit/mappers/TripPatternForDateMapper.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQyMjoyNToxN1rOFobaZg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQyMjoyNToxN1rOFobaZg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzkzNjQ4Ng==", "bodyText": "Using the Collection.unmodifiableMap(...) would be good idea here, then it becomes clear that these are READ_ONLY.", "url": "https://github.com/opentripplanner/OpenTripPlanner/pull/2922#discussion_r377936486", "createdAt": "2020-02-11T22:25:17Z", "author": {"login": "t2gran"}, "path": "src/main/java/org/opentripplanner/routing/algorithm/raptor/transit/mappers/TripPatternForDateMapper.java", "diffHunk": "@@ -44,6 +51,13 @@\n     this.newTripPatternForOld = newTripPatternForOld;\n   }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a9dfaedb5e58d7682842e8fe645ab30618209cb7"}, "originalPosition": 37}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1882, "cost": 1, "resetAt": "2021-11-13T12:10:21Z"}}}