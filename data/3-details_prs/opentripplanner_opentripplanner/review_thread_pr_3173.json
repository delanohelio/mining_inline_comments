{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDc4NDU1OTAy", "number": 3173, "reviewThreads": {"totalCount": 13, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wM1QxMzozMTo1N1rOEf_gEw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOFQwOTo0NTo0NVrOEhKtsg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAxOTgxNzE1OnYy", "diffSide": "RIGHT", "path": "src/main/java/org/opentripplanner/graph_builder/module/NearbyStopFinder.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wM1QxMzozMTo1N1rOHMmwVA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wM1QxMzozMTo1N1rOHMmwVA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mjk3OTkyNA==", "bodyText": "Revert change", "url": "https://github.com/opentripplanner/OpenTripPlanner/pull/3173#discussion_r482979924", "createdAt": "2020-09-03T13:31:57Z", "author": {"login": "hannesj"}, "path": "src/main/java/org/opentripplanner/graph_builder/module/NearbyStopFinder.java", "diffHunk": "@@ -84,25 +90,34 @@ public NearbyStopFinder(Graph graph, double radiusMeters, boolean useStreets) {\n      * This is intentional: we don't want to return the next stop down the line for trip patterns that pass through the\n      * origin vertex.\n      */\n-    public Set<StopAtDistance> findNearbyStopsConsideringPatterns (Vertex vertex) {\n+    public Set<StopAtDistance> findNearbyStopsConsideringPatterns(Vertex vertex, boolean reverseDirection) {\n \n         /* Track the closest stop on each pattern passing nearby. */\n         MinMap<TripPattern, StopAtDistance> closestStopForPattern = new MinMap<TripPattern, StopAtDistance>();\n \n+        /* Track the closest stop on each flex trip nearby. */\n+        MinMap<FlexTrip, StopAtDistance> closestStopForFlexTrip = new MinMap<>();\n+\n+        /* Make a transfer from the origin stop to each destination stop that was the closest stop on any pattern. */\n+        Set<StopAtDistance> uniqueStops = Sets.newHashSet();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7058cae7e98588242bb641040b8290f04287b8f8"}, "originalPosition": 42}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAxOTg2NDIzOnYy", "diffSide": "RIGHT", "path": "src/main/java/org/opentripplanner/graph_builder/module/NearbyStopFinder.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wM1QxMzo0Mjo0NFrOHMnM7g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wM1QxMzo0Mjo0NFrOHMnM7g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mjk4NzI0Ng==", "bodyText": "Add comment about \"Simplification so that we only return one vertex from each stop location. Add all vertices tp the map, which is filtered below\"", "url": "https://github.com/opentripplanner/OpenTripPlanner/pull/3173#discussion_r482987246", "createdAt": "2020-09-03T13:42:44Z", "author": {"login": "hannesj"}, "path": "src/main/java/org/opentripplanner/graph_builder/module/NearbyStopFinder.java", "diffHunk": "@@ -165,8 +183,24 @@ public NearbyStopFinder(Graph graph, double radiusMeters, boolean useStreets) {\n                 if (targetVertex instanceof TransitStopVertex && state.isFinal()) {\n                     stopsFound.add(StopAtDistance.stopAtDistanceForState(state, ((TransitStopVertex) targetVertex).getStop()));\n                 }\n+                if (OTPFeature.FlexRouting.isOn()\n+                    && targetVertex instanceof StreetVertex\n+                    && ((StreetVertex) targetVertex).flexStopLocations != null) {\n+                   for (FlexStopLocation flexStopLocation : ((StreetVertex) targetVertex).flexStopLocations) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7058cae7e98588242bb641040b8290f04287b8f8"}, "originalPosition": 96}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAxOTg2ODMzOnYy", "diffSide": "RIGHT", "path": "src/main/java/org/opentripplanner/graph_builder/module/NearbyStopFinder.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wM1QxMzo0Mzo0MFrOHMnPkQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wM1QxMzo0Mzo0MFrOHMnPkQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mjk4NzkyMQ==", "bodyText": "Select the vertex from all vertices that are reachable by taking the minimum walking distance", "url": "https://github.com/opentripplanner/OpenTripPlanner/pull/3173#discussion_r482987921", "createdAt": "2020-09-03T13:43:40Z", "author": {"login": "hannesj"}, "path": "src/main/java/org/opentripplanner/graph_builder/module/NearbyStopFinder.java", "diffHunk": "@@ -165,8 +183,24 @@ public NearbyStopFinder(Graph graph, double radiusMeters, boolean useStreets) {\n                 if (targetVertex instanceof TransitStopVertex && state.isFinal()) {\n                     stopsFound.add(StopAtDistance.stopAtDistanceForState(state, ((TransitStopVertex) targetVertex).getStop()));\n                 }\n+                if (OTPFeature.FlexRouting.isOn()\n+                    && targetVertex instanceof StreetVertex\n+                    && ((StreetVertex) targetVertex).flexStopLocations != null) {\n+                   for (FlexStopLocation flexStopLocation : ((StreetVertex) targetVertex).flexStopLocations) {\n+                        locationsMap.put(flexStopLocation, state);\n+                    }\n+                }\n             }\n         }\n+\n+        for (var locationStates : locationsMap.asMap().entrySet()) {\n+            FlexStopLocation flexStopLocation = locationStates.getKey();\n+            Collection<State> states = locationStates.getValue();\n+            State min = Collections.min(states, (s1, s2) -> (int) (s1.walkDistance - s2.walkDistance));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7058cae7e98588242bb641040b8290f04287b8f8"}, "originalPosition": 106}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAxOTk0MTg0OnYy", "diffSide": "RIGHT", "path": "src/main/java/org/opentripplanner/graph_builder/module/DirectTransferGenerator.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wM1QxMzo1OToxNFrOHMn9Rw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wM1QxMzo1OToxNFrOHMn9Rw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mjk5OTYyMw==", "bodyText": "Stop to stop transfers are already populated by the findNearbyStopsConsideringPatterns(ts0, false)", "url": "https://github.com/opentripplanner/OpenTripPlanner/pull/3173#discussion_r482999623", "createdAt": "2020-09-03T13:59:14Z", "author": {"login": "hannesj"}, "path": "src/main/java/org/opentripplanner/graph_builder/module/DirectTransferGenerator.java", "diffHunk": "@@ -88,6 +89,19 @@ public void buildGraph(\n                 );\n                 n += 1;\n             }\n+            if (OTPFeature.FlexRouting.isOn()) {\n+                for (StopAtDistance sd : nearbyStopFinder.findNearbyStopsConsideringPatterns(ts0,  true)) {\n+                    /* Skip the origin stop, loop transfers are not needed. */\n+                    if (sd.stop == ts0.getStop())\n+                        continue;\n+                    if (sd.stop instanceof Stop)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7058cae7e98588242bb641040b8290f04287b8f8"}, "originalPosition": 26}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAxOTk1MjIwOnYy", "diffSide": "RIGHT", "path": "src/ext/java/org/opentripplanner/ext/flex/trip/UnscheduledTrip.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wM1QxNDowMToyNlrOHMoEDQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wM1QxNDowMToyNlrOHMoEDQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzAwMTM1Nw==", "bodyText": "add to separate class", "url": "https://github.com/opentripplanner/OpenTripPlanner/pull/3173#discussion_r483001357", "createdAt": "2020-09-03T14:01:26Z", "author": {"login": "hannesj"}, "path": "src/ext/java/org/opentripplanner/ext/flex/trip/UnscheduledTrip.java", "diffHunk": "@@ -0,0 +1,54 @@\n+package org.opentripplanner.ext.flex.trip;\n+\n+import org.opentripplanner.model.StopLocation;\n+import org.opentripplanner.model.StopTime;\n+import org.opentripplanner.model.Trip;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.HashSet;\n+import java.util.List;\n+\n+public class UnscheduledTrip extends FlexTrip {\n+\n+  private final StopLocation[] stops;\n+  private final int[] minDepartureTimes;\n+  private final int[] maxDepartureTimes;\n+  private final int[] minArrivalTimes;\n+  private final int[] maxArrivalTimes;\n+\n+  private final int[] pickupTypes;\n+  private final int[] dropOffTypes;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7058cae7e98588242bb641040b8290f04287b8f8"}, "originalPosition": 20}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAxOTk1NTk3OnYy", "diffSide": "RIGHT", "path": "src/ext/java/org/opentripplanner/ext/flex/trip/ScheduledDeviatedTrip.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wM1QxNDowMjoxN1rOHMoGWg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wM1QxNDowMjoxN1rOHMoGWg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzAwMTk0Ng==", "bodyText": "add to separate class", "url": "https://github.com/opentripplanner/OpenTripPlanner/pull/3173#discussion_r483001946", "createdAt": "2020-09-03T14:02:17Z", "author": {"login": "hannesj"}, "path": "src/ext/java/org/opentripplanner/ext/flex/trip/ScheduledDeviatedTrip.java", "diffHunk": "@@ -0,0 +1,47 @@\n+package org.opentripplanner.ext.flex.trip;\n+\n+import org.opentripplanner.model.StopLocation;\n+import org.opentripplanner.model.StopTime;\n+import org.opentripplanner.model.Trip;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.HashSet;\n+import java.util.List;\n+public class ScheduledDeviatedTrip extends FlexTrip {\n+  static final int MISSING_VALUE = -999;\n+\n+  private final StopLocation[] stops;\n+  private final int[] departureTimes;\n+  private final int[] arrivalTimes;\n+\n+  private final int[] pickupTypes;\n+  private final int[] dropOffTypes;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7058cae7e98588242bb641040b8290f04287b8f8"}, "originalPosition": 18}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAyMDAxNzg4OnYy", "diffSide": "RIGHT", "path": "src/ext/java/org/opentripplanner/ext/flex/trip/UnscheduledTrip.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wM1QxNDoxNTo0OFrOHMos1g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wM1QxNDoxNTo0OFrOHMos1g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzAxMTc5OA==", "bodyText": "Add Javadoc", "url": "https://github.com/opentripplanner/OpenTripPlanner/pull/3173#discussion_r483011798", "createdAt": "2020-09-03T14:15:48Z", "author": {"login": "hannesj"}, "path": "src/ext/java/org/opentripplanner/ext/flex/trip/UnscheduledTrip.java", "diffHunk": "@@ -0,0 +1,54 @@\n+package org.opentripplanner.ext.flex.trip;\n+\n+import org.opentripplanner.model.StopLocation;\n+import org.opentripplanner.model.StopTime;\n+import org.opentripplanner.model.Trip;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.HashSet;\n+import java.util.List;\n+\n+public class UnscheduledTrip extends FlexTrip {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7058cae7e98588242bb641040b8290f04287b8f8"}, "originalPosition": 11}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAyMDAxODcwOnYy", "diffSide": "RIGHT", "path": "src/ext/java/org/opentripplanner/ext/flex/trip/ScheduledDeviatedTrip.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wM1QxNDoxNTo1OFrOHMotTw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wM1QxNDoxNTo1OFrOHMotTw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzAxMTkxOQ==", "bodyText": "Add Javadoc", "url": "https://github.com/opentripplanner/OpenTripPlanner/pull/3173#discussion_r483011919", "createdAt": "2020-09-03T14:15:58Z", "author": {"login": "hannesj"}, "path": "src/ext/java/org/opentripplanner/ext/flex/trip/ScheduledDeviatedTrip.java", "diffHunk": "@@ -0,0 +1,47 @@\n+package org.opentripplanner.ext.flex.trip;\n+\n+import org.opentripplanner.model.StopLocation;\n+import org.opentripplanner.model.StopTime;\n+import org.opentripplanner.model.Trip;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.HashSet;\n+import java.util.List;\n+public class ScheduledDeviatedTrip extends FlexTrip {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7058cae7e98588242bb641040b8290f04287b8f8"}, "originalPosition": 10}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAyMDA2NTkxOnYy", "diffSide": "RIGHT", "path": "src/ext/java/org/opentripplanner/ext/flex/FlexLocationsToStreetEdgesMapper.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wM1QxNDoyNjowMFrOHMpKYA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wM1QxNDoyNjowMFrOHMpKYA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzAxOTM2MA==", "bodyText": "Add isConnectedToWalkingEdge, isConnectedToDriveableEdge and isEligibleForPickupDropoff in StreetEdge", "url": "https://github.com/opentripplanner/OpenTripPlanner/pull/3173#discussion_r483019360", "createdAt": "2020-09-03T14:26:00Z", "author": {"login": "hannesj"}, "path": "src/ext/java/org/opentripplanner/ext/flex/FlexLocationsToStreetEdgesMapper.java", "diffHunk": "@@ -0,0 +1,67 @@\n+package org.opentripplanner.ext.flex;\n+\n+import org.locationtech.jts.geom.Point;\n+import org.opentripplanner.common.geometry.GeometryUtils;\n+import org.opentripplanner.graph_builder.DataImportIssueStore;\n+import org.opentripplanner.graph_builder.services.GraphBuilderModule;\n+import org.opentripplanner.model.FlexStopLocation;\n+import org.opentripplanner.routing.core.TraverseMode;\n+import org.opentripplanner.routing.core.TraverseModeSet;\n+import org.opentripplanner.routing.edgetype.StreetEdge;\n+import org.opentripplanner.routing.graph.Graph;\n+import org.opentripplanner.routing.graph.Vertex;\n+import org.opentripplanner.routing.impl.StreetVertexIndex;\n+import org.opentripplanner.routing.vertextype.StreetVertex;\n+\n+import java.util.HashMap;\n+import java.util.HashSet;\n+\n+public class FlexLocationsToStreetEdgesMapper implements GraphBuilderModule {\n+\n+  @Override\n+  public void buildGraph(\n+      Graph graph, HashMap<Class<?>, Object> extra, DataImportIssueStore issueStore\n+  ) {\n+    if (graph.locationsById.isEmpty()) {\n+      return;\n+    }\n+\n+    StreetVertexIndex streetIndex = new StreetVertexIndex(graph);\n+    TraverseModeSet carTraverseModeSet = new TraverseModeSet(TraverseMode.CAR);\n+    TraverseModeSet walkTraverseModeSet = new TraverseModeSet(TraverseMode.WALK);\n+\n+    for (FlexStopLocation flexStopLocation : graph.locationsById.values()) {\n+      for (Vertex vertx : streetIndex.getVerticesForEnvelope(flexStopLocation\n+          .getGeometry()\n+          .getEnvelopeInternal())\n+      ) {\n+        if (!(vertx instanceof StreetVertex)) { continue; }\n+        if (vertx.getOutgoing().stream().noneMatch(edge ->\n+            edge instanceof StreetEdge && ((StreetEdge) edge).canTraverse(carTraverseModeSet))  ||", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7058cae7e98588242bb641040b8290f04287b8f8"}, "originalPosition": 40}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAyMDA3MjYwOnYy", "diffSide": "RIGHT", "path": "src/ext/java/org/opentripplanner/ext/flex/FlexLocationsToStreetEdgesMapper.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wM1QxNDoyNzoxN1rOHMpOWw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wM1QxNDoyNzoxN1rOHMpOWw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzAyMDM3OQ==", "bodyText": "getVerticesForEnvelope can return Vertices which are not inside the search area", "url": "https://github.com/opentripplanner/OpenTripPlanner/pull/3173#discussion_r483020379", "createdAt": "2020-09-03T14:27:17Z", "author": {"login": "hannesj"}, "path": "src/ext/java/org/opentripplanner/ext/flex/FlexLocationsToStreetEdgesMapper.java", "diffHunk": "@@ -0,0 +1,67 @@\n+package org.opentripplanner.ext.flex;\n+\n+import org.locationtech.jts.geom.Point;\n+import org.opentripplanner.common.geometry.GeometryUtils;\n+import org.opentripplanner.graph_builder.DataImportIssueStore;\n+import org.opentripplanner.graph_builder.services.GraphBuilderModule;\n+import org.opentripplanner.model.FlexStopLocation;\n+import org.opentripplanner.routing.core.TraverseMode;\n+import org.opentripplanner.routing.core.TraverseModeSet;\n+import org.opentripplanner.routing.edgetype.StreetEdge;\n+import org.opentripplanner.routing.graph.Graph;\n+import org.opentripplanner.routing.graph.Vertex;\n+import org.opentripplanner.routing.impl.StreetVertexIndex;\n+import org.opentripplanner.routing.vertextype.StreetVertex;\n+\n+import java.util.HashMap;\n+import java.util.HashSet;\n+\n+public class FlexLocationsToStreetEdgesMapper implements GraphBuilderModule {\n+\n+  @Override\n+  public void buildGraph(\n+      Graph graph, HashMap<Class<?>, Object> extra, DataImportIssueStore issueStore\n+  ) {\n+    if (graph.locationsById.isEmpty()) {\n+      return;\n+    }\n+\n+    StreetVertexIndex streetIndex = new StreetVertexIndex(graph);\n+    TraverseModeSet carTraverseModeSet = new TraverseModeSet(TraverseMode.CAR);\n+    TraverseModeSet walkTraverseModeSet = new TraverseModeSet(TraverseMode.WALK);\n+\n+    for (FlexStopLocation flexStopLocation : graph.locationsById.values()) {\n+      for (Vertex vertx : streetIndex.getVerticesForEnvelope(flexStopLocation\n+          .getGeometry()\n+          .getEnvelopeInternal())\n+      ) {\n+        if (!(vertx instanceof StreetVertex)) { continue; }\n+        if (vertx.getOutgoing().stream().noneMatch(edge ->\n+            edge instanceof StreetEdge && ((StreetEdge) edge).canTraverse(carTraverseModeSet))  ||\n+            vertx.getOutgoing().stream().noneMatch(edge ->\n+            edge instanceof StreetEdge && ((StreetEdge) edge).canTraverse(walkTraverseModeSet))\n+        ) {\n+          continue;\n+        }\n+\n+        Point p = GeometryUtils.getGeometryFactory().createPoint(vertx.getCoordinate());\n+        if (flexStopLocation.getGeometry().disjoint(p)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7058cae7e98588242bb641040b8290f04287b8f8"}, "originalPosition": 48}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAyMDA3NjYwOnYy", "diffSide": "RIGHT", "path": "src/ext/java/org/opentripplanner/ext/flex/FlexTripsMapper.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wM1QxNDoyODowNlrOHMpQ0A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wM1QxNDoyOToyM1rOHMpUjw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzAyMTAwOA==", "bodyText": "Document filters and link to trip types", "url": "https://github.com/opentripplanner/OpenTripPlanner/pull/3173#discussion_r483021008", "createdAt": "2020-09-03T14:28:06Z", "author": {"login": "hannesj"}, "path": "src/ext/java/org/opentripplanner/ext/flex/FlexTripsMapper.java", "diffHunk": "@@ -0,0 +1,67 @@\n+package org.opentripplanner.ext.flex;\n+\n+import org.opentripplanner.ext.flex.trip.ScheduledDeviatedTrip;\n+import org.opentripplanner.ext.flex.trip.UnscheduledTrip;\n+import org.opentripplanner.model.Stop;\n+import org.opentripplanner.model.StopTime;\n+import org.opentripplanner.model.TripStopTimes;\n+import org.opentripplanner.model.impl.OtpTransitServiceBuilder;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.function.Predicate;\n+\n+import static org.onebusaway.gtfs.model.StopTime.MISSING_VALUE;\n+\n+public class FlexTripsMapper {\n+\n+  private static final Logger LOG = LoggerFactory.getLogger(FlexTripsMapper.class);\n+\n+  static public void createFlexTrips(OtpTransitServiceBuilder builder) {\n+    TripStopTimes stopTimesByTrip = builder.getStopTimesSortedByTrip();\n+\n+    final int tripSize = stopTimesByTrip.size();\n+    int tripCount = 0;\n+\n+    for (org.opentripplanner.model.Trip trip : stopTimesByTrip.keys()) {\n+      if (++tripCount % 100000 == 0) {\n+        LOG.debug(\"Mapped StopTimes for flex trips {}/{}\", tripCount, tripSize);\n+      }\n+\n+      /* Fetch the stop times for this trip. Copy the list since it's immutable. */\n+      List<StopTime> stopTimes = new ArrayList<>(stopTimesByTrip.get(trip));\n+\n+      if (isUnscheduledTrip(stopTimes)) {\n+        if (stopTimes.size() == 2) {\n+          // TODO: Drop this restriction after time handling and ride times are defined\n+          builder.getFlexTripsById().add(new UnscheduledTrip(trip, stopTimes));\n+        }\n+      } else if (isScheduledFlexTrip(stopTimes)) {\n+        builder.getFlexTripsById().add(new ScheduledDeviatedTrip(trip, stopTimes));\n+      } else if (hasContinuousStops(stopTimes)) {\n+        // builder.getFlexTripsById().add(new ContinuousPickupDropOffTrip(trip, stopTimes));\n+      }\n+    }\n+  }\n+\n+  private static boolean isUnscheduledTrip(List<StopTime> stopTimes) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7058cae7e98588242bb641040b8290f04287b8f8"}, "originalPosition": 49}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzAyMTk2Nw==", "bodyText": "Potentially move as static methods on classes", "url": "https://github.com/opentripplanner/OpenTripPlanner/pull/3173#discussion_r483021967", "createdAt": "2020-09-03T14:29:23Z", "author": {"login": "hannesj"}, "path": "src/ext/java/org/opentripplanner/ext/flex/FlexTripsMapper.java", "diffHunk": "@@ -0,0 +1,67 @@\n+package org.opentripplanner.ext.flex;\n+\n+import org.opentripplanner.ext.flex.trip.ScheduledDeviatedTrip;\n+import org.opentripplanner.ext.flex.trip.UnscheduledTrip;\n+import org.opentripplanner.model.Stop;\n+import org.opentripplanner.model.StopTime;\n+import org.opentripplanner.model.TripStopTimes;\n+import org.opentripplanner.model.impl.OtpTransitServiceBuilder;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.function.Predicate;\n+\n+import static org.onebusaway.gtfs.model.StopTime.MISSING_VALUE;\n+\n+public class FlexTripsMapper {\n+\n+  private static final Logger LOG = LoggerFactory.getLogger(FlexTripsMapper.class);\n+\n+  static public void createFlexTrips(OtpTransitServiceBuilder builder) {\n+    TripStopTimes stopTimesByTrip = builder.getStopTimesSortedByTrip();\n+\n+    final int tripSize = stopTimesByTrip.size();\n+    int tripCount = 0;\n+\n+    for (org.opentripplanner.model.Trip trip : stopTimesByTrip.keys()) {\n+      if (++tripCount % 100000 == 0) {\n+        LOG.debug(\"Mapped StopTimes for flex trips {}/{}\", tripCount, tripSize);\n+      }\n+\n+      /* Fetch the stop times for this trip. Copy the list since it's immutable. */\n+      List<StopTime> stopTimes = new ArrayList<>(stopTimesByTrip.get(trip));\n+\n+      if (isUnscheduledTrip(stopTimes)) {\n+        if (stopTimes.size() == 2) {\n+          // TODO: Drop this restriction after time handling and ride times are defined\n+          builder.getFlexTripsById().add(new UnscheduledTrip(trip, stopTimes));\n+        }\n+      } else if (isScheduledFlexTrip(stopTimes)) {\n+        builder.getFlexTripsById().add(new ScheduledDeviatedTrip(trip, stopTimes));\n+      } else if (hasContinuousStops(stopTimes)) {\n+        // builder.getFlexTripsById().add(new ContinuousPickupDropOffTrip(trip, stopTimes));\n+      }\n+    }\n+  }\n+\n+  private static boolean isUnscheduledTrip(List<StopTime> stopTimes) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzAyMTAwOA=="}, "originalCommit": {"oid": "7058cae7e98588242bb641040b8290f04287b8f8"}, "originalPosition": 49}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAyMDA4MTE2OnYy", "diffSide": "RIGHT", "path": "src/ext/java/org/opentripplanner/ext/flex/FlexTripsMapper.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wM1QxNDoyOTowNlrOHMpTog==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wM1QxNDoyOTowNlrOHMpTog==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzAyMTczMA==", "bodyText": "use new type of progress tracker", "url": "https://github.com/opentripplanner/OpenTripPlanner/pull/3173#discussion_r483021730", "createdAt": "2020-09-03T14:29:06Z", "author": {"login": "hannesj"}, "path": "src/ext/java/org/opentripplanner/ext/flex/FlexTripsMapper.java", "diffHunk": "@@ -0,0 +1,67 @@\n+package org.opentripplanner.ext.flex;\n+\n+import org.opentripplanner.ext.flex.trip.ScheduledDeviatedTrip;\n+import org.opentripplanner.ext.flex.trip.UnscheduledTrip;\n+import org.opentripplanner.model.Stop;\n+import org.opentripplanner.model.StopTime;\n+import org.opentripplanner.model.TripStopTimes;\n+import org.opentripplanner.model.impl.OtpTransitServiceBuilder;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.function.Predicate;\n+\n+import static org.onebusaway.gtfs.model.StopTime.MISSING_VALUE;\n+\n+public class FlexTripsMapper {\n+\n+  private static final Logger LOG = LoggerFactory.getLogger(FlexTripsMapper.class);\n+\n+  static public void createFlexTrips(OtpTransitServiceBuilder builder) {\n+    TripStopTimes stopTimesByTrip = builder.getStopTimesSortedByTrip();\n+\n+    final int tripSize = stopTimesByTrip.size();\n+    int tripCount = 0;\n+\n+    for (org.opentripplanner.model.Trip trip : stopTimesByTrip.keys()) {\n+      if (++tripCount % 100000 == 0) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7058cae7e98588242bb641040b8290f04287b8f8"}, "originalPosition": 29}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAzMjE0MDAyOnYy", "diffSide": "RIGHT", "path": "src/main/java/org/opentripplanner/routing/vertextype/StreetVertex.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOFQwOTo0NTo0NVrOHOVStA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOFQwOTo0NTo0NVrOHOVStA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDc5MDk2NA==", "bodyText": "We could add a method, boolean canTranverse(TraverseMode traverseMode) in StreetEdge", "url": "https://github.com/opentripplanner/OpenTripPlanner/pull/3173#discussion_r484790964", "createdAt": "2020-09-08T09:45:45Z", "author": {"login": "hannesj"}, "path": "src/main/java/org/opentripplanner/routing/vertextype/StreetVertex.java", "diffHunk": "@@ -65,4 +71,18 @@ public I18NString getIntersectionName(Locale locale) {\n         }\n         return calculatedName;\n     }\n+\n+    public boolean isConnectedToWalkingEdge() {\n+        return this.getOutgoing().stream().anyMatch(edge ->\n+            edge instanceof StreetEdge && ((StreetEdge) edge).canTraverse(WALK_TRAVERSE_MODE_SET));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3ffd0b90aee7b39471f38728539429c7c936d0ea"}, "originalPosition": 27}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1673, "cost": 1, "resetAt": "2021-11-13T12:10:21Z"}}}