{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTQxMzIwNjUy", "number": 1826, "title": "[LOCKING_STRATEGY] implementing different strategies for diagnose and\u2026", "bodyText": "Jira: https://issues.redhat.com/browse/JBPM-9521\nstrategies and lock diagnose.", "createdAt": "2020-12-16T17:19:06Z", "url": "https://github.com/kiegroup/jbpm/pull/1826", "merged": true, "mergeCommit": {"oid": "e97dda2240528315c7a70a8a4b1f4ae9b4a86ae9"}, "closed": true, "closedAt": "2021-01-08T07:38:51Z", "author": {"login": "elguardian"}, "timelineItems": {"totalCount": 16, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdm5HKPAFqTU1NDIxMDg2Nw==", "endCursor": "Y3Vyc29yOnYyOpPPAAABdt1-TjgBqjQxODA0MjY1OTM=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTU0MjEwODY3", "url": "https://github.com/kiegroup/jbpm/pull/1826#pullrequestreview-554210867", "createdAt": "2020-12-17T01:18:46Z", "commit": {"oid": "e69f603685b90f45c771f802224af40dad700c3c"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "e69f603685b90f45c771f802224af40dad700c3c", "author": {"user": {"login": "elguardian", "name": "Enrique Gonz\u00e1lez Mart\u00ednez"}}, "url": "https://github.com/kiegroup/jbpm/commit/e69f603685b90f45c771f802224af40dad700c3c", "committedDate": "2020-12-16T17:16:27Z", "message": "[LOCKING_STRATEGY] implementing different strategies for diagnose and execution"}, "afterCommit": {"oid": "3fd114fd9adcac8725b104e28cd3cfe6ad87ac65", "author": {"user": {"login": "elguardian", "name": "Enrique Gonz\u00e1lez Mart\u00ednez"}}, "url": "https://github.com/kiegroup/jbpm/commit/3fd114fd9adcac8725b104e28cd3cfe6ad87ac65", "committedDate": "2020-12-17T07:41:04Z", "message": "[LOCKING_STRATEGY] implementing different strategies for diagnose and execution"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "3fd114fd9adcac8725b104e28cd3cfe6ad87ac65", "author": {"user": {"login": "elguardian", "name": "Enrique Gonz\u00e1lez Mart\u00ednez"}}, "url": "https://github.com/kiegroup/jbpm/commit/3fd114fd9adcac8725b104e28cd3cfe6ad87ac65", "committedDate": "2020-12-17T07:41:04Z", "message": "[LOCKING_STRATEGY] implementing different strategies for diagnose and execution"}, "afterCommit": {"oid": "2a503c0ba72f71b6559f34f5210d66152a8b0fdc", "author": {"user": {"login": "elguardian", "name": "Enrique Gonz\u00e1lez Mart\u00ednez"}}, "url": "https://github.com/kiegroup/jbpm/commit/2a503c0ba72f71b6559f34f5210d66152a8b0fdc", "committedDate": "2020-12-17T16:28:16Z", "message": "[LOCKING_STRATEGY] implementing different strategies for diagnose and execution"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTU0NzE2NjY1", "url": "https://github.com/kiegroup/jbpm/pull/1826#pullrequestreview-554716665", "createdAt": "2020-12-17T15:31:16Z", "commit": {"oid": "3fd114fd9adcac8725b104e28cd3cfe6ad87ac65"}, "state": "COMMENTED", "comments": {"totalCount": 9, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xN1QxNTozMToxNlrOIH7Lpw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xN1QxOToxNjoyNVrOIIE5Yg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTE4MDU4Mw==", "bodyText": "Maybe putIfAbsent is a perfect fit here?", "url": "https://github.com/kiegroup/jbpm/pull/1826#discussion_r545180583", "createdAt": "2020-12-17T15:31:16Z", "author": {"login": "MarianMacik"}, "path": "jbpm-runtime-manager/src/main/java/org/jbpm/runtime/manager/impl/lock/AbstractRuntimeManagerLockStrategy.java", "diffHunk": "@@ -0,0 +1,136 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.jbpm.runtime.manager.impl.lock;\n+\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import org.jbpm.runtime.manager.spi.RuntimeManagerLock;\n+import org.jbpm.runtime.manager.spi.RuntimeManagerLockFactory;\n+import org.jbpm.runtime.manager.spi.RuntimeManagerLockStrategy;\n+import org.kie.api.runtime.manager.RuntimeEngine;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+public abstract class AbstractRuntimeManagerLockStrategy implements RuntimeManagerLockStrategy {\n+\n+    protected static final Logger logger = LoggerFactory.getLogger(AbstractRuntimeManagerLockStrategy.class);\n+\n+    protected Map<Long, RuntimeManagerLockThreadsInfo> engineLocks; \n+\n+    private RuntimeManagerLockFactory runtimeManagerLockFactory;\n+\n+    \n+    public AbstractRuntimeManagerLockStrategy() {\n+        this.runtimeManagerLockFactory = new DefaultRuntimeManagerLockFactory();\n+        this.engineLocks = new HashMap<>();\n+    }\n+\n+    @Override\n+    public void init(RuntimeManagerLockFactory factory) {\n+        this.runtimeManagerLockFactory = factory;\n+    }\n+\n+    @Override\n+    public void lock(Long id, RuntimeEngine runtime) throws InterruptedException {\n+        RuntimeManagerLockThreadsInfo lockThreadsInfo = null;\n+        synchronized (engineLocks) {\n+            if(!engineLocks.containsKey(id)) {\n+                engineLocks.put(id, new RuntimeManagerLockThreadsInfo(runtimeManagerLockFactory.newRuntimeManagerLock()));\n+            }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3fd114fd9adcac8725b104e28cd3cfe6ad87ac65"}, "originalPosition": 57}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTIwMTMwMQ==", "bodyText": "When we call unlock, we already must have the lock in the same thread, or not?\nCalling unlock() from the different thread (\"worker\" thread) than the one which called lock() (the \"main\" thread) can happen only if somebody passes an already locked runtimeEngine to the \"worker\" thread and then the \"worker\" thread calls disposeRuntimeEngine. In that case the engine gets disposed (disposed == true), but the lock is not released as the \"worker\" thread doesn't hold the lock. But if the \"main\" thread calls disposeRuntimeEngine afterwards to release the lock, the engine is already disposed, so canDispose will return false and the lock is never released. So maybe we could remove this check and let the IllegalMonitorStateException which will be thrown by the ReentrantLock propagate? So a user at least knows that the runtime engine is leaking to the other thread?\nBut maybe it is just a precaution/best practice to not get an exception... Just thinking out loud.", "url": "https://github.com/kiegroup/jbpm/pull/1826#discussion_r545201301", "createdAt": "2020-12-17T15:57:08Z", "author": {"login": "MarianMacik"}, "path": "jbpm-runtime-manager/src/main/java/org/jbpm/runtime/manager/impl/lock/AbstractRuntimeManagerLockStrategy.java", "diffHunk": "@@ -0,0 +1,136 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.jbpm.runtime.manager.impl.lock;\n+\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import org.jbpm.runtime.manager.spi.RuntimeManagerLock;\n+import org.jbpm.runtime.manager.spi.RuntimeManagerLockFactory;\n+import org.jbpm.runtime.manager.spi.RuntimeManagerLockStrategy;\n+import org.kie.api.runtime.manager.RuntimeEngine;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+public abstract class AbstractRuntimeManagerLockStrategy implements RuntimeManagerLockStrategy {\n+\n+    protected static final Logger logger = LoggerFactory.getLogger(AbstractRuntimeManagerLockStrategy.class);\n+\n+    protected Map<Long, RuntimeManagerLockThreadsInfo> engineLocks; \n+\n+    private RuntimeManagerLockFactory runtimeManagerLockFactory;\n+\n+    \n+    public AbstractRuntimeManagerLockStrategy() {\n+        this.runtimeManagerLockFactory = new DefaultRuntimeManagerLockFactory();\n+        this.engineLocks = new HashMap<>();\n+    }\n+\n+    @Override\n+    public void init(RuntimeManagerLockFactory factory) {\n+        this.runtimeManagerLockFactory = factory;\n+    }\n+\n+    @Override\n+    public void lock(Long id, RuntimeEngine runtime) throws InterruptedException {\n+        RuntimeManagerLockThreadsInfo lockThreadsInfo = null;\n+        synchronized (engineLocks) {\n+            if(!engineLocks.containsKey(id)) {\n+                engineLocks.put(id, new RuntimeManagerLockThreadsInfo(runtimeManagerLockFactory.newRuntimeManagerLock()));\n+            }\n+            lockThreadsInfo = engineLocks.get(id);\n+            lockThreadsInfo.set();\n+        }\n+        logger.debug(\"Trying to get a lock {} for {} by {}\", lockThreadsInfo, id, runtime);\n+        try {\n+            lock(lockThreadsInfo.getRuntimeManagerLock());\n+        } catch(InterruptedException e) {\n+            logger.warn(\"Interrupted lock {}\", lockThreadsInfo.getRuntimeManagerLock());\n+            throw e;\n+        }\n+        logger.debug(\"Lock {} taken for {} by {} for waiting threads by {}\", lockThreadsInfo, id, runtime, lockThreadsInfo.hasQueuedThreads());\n+    }\n+\n+    protected abstract void lock(RuntimeManagerLock lock) throws InterruptedException;\n+    \n+    @Override\n+    public void unlock(Long id, RuntimeEngine runtime) {\n+        RuntimeManagerLockThreadsInfo lockThreadsInfo = null;\n+        synchronized (engineLocks) {\n+            lockThreadsInfo = engineLocks.get(id);\n+            if (lockThreadsInfo == null) {\n+                logger.warn(\"[LOCK] lock {} is already removed for {} unlocked by {}\", id, lockThreadsInfo, runtime);\n+                return;\n+            }\n+            lockThreadsInfo.unset();\n+            if (lockThreadsInfo.count() == 0) {\n+                logger.debug(\"[LOCK] Removing lock for {} for lock  {} from list as non is waiting for it by {}\", id, lockThreadsInfo, runtime);\n+                engineLocks.remove(id);\n+            }\n+        }\n+\n+        if (lockThreadsInfo.isHeldByCurrentThread()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3fd114fd9adcac8725b104e28cd3cfe6ad87ac65"}, "originalPosition": 89}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTIwMjY5OQ==", "bodyText": "Synchronized block + RuntimeManagerLockThreadsInfo wrapper solves the issue with lockThreadsInfo.hasQueuedThreads() + removal of the lock which wasn't atomic, right? More info in my comment in the LegacyRuntimeManagerLockStrategy.", "url": "https://github.com/kiegroup/jbpm/pull/1826#discussion_r545202699", "createdAt": "2020-12-17T15:58:52Z", "author": {"login": "MarianMacik"}, "path": "jbpm-runtime-manager/src/main/java/org/jbpm/runtime/manager/impl/lock/AbstractRuntimeManagerLockStrategy.java", "diffHunk": "@@ -0,0 +1,136 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.jbpm.runtime.manager.impl.lock;\n+\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import org.jbpm.runtime.manager.spi.RuntimeManagerLock;\n+import org.jbpm.runtime.manager.spi.RuntimeManagerLockFactory;\n+import org.jbpm.runtime.manager.spi.RuntimeManagerLockStrategy;\n+import org.kie.api.runtime.manager.RuntimeEngine;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+public abstract class AbstractRuntimeManagerLockStrategy implements RuntimeManagerLockStrategy {\n+\n+    protected static final Logger logger = LoggerFactory.getLogger(AbstractRuntimeManagerLockStrategy.class);\n+\n+    protected Map<Long, RuntimeManagerLockThreadsInfo> engineLocks; \n+\n+    private RuntimeManagerLockFactory runtimeManagerLockFactory;\n+\n+    \n+    public AbstractRuntimeManagerLockStrategy() {\n+        this.runtimeManagerLockFactory = new DefaultRuntimeManagerLockFactory();\n+        this.engineLocks = new HashMap<>();\n+    }\n+\n+    @Override\n+    public void init(RuntimeManagerLockFactory factory) {\n+        this.runtimeManagerLockFactory = factory;\n+    }\n+\n+    @Override\n+    public void lock(Long id, RuntimeEngine runtime) throws InterruptedException {\n+        RuntimeManagerLockThreadsInfo lockThreadsInfo = null;\n+        synchronized (engineLocks) {\n+            if(!engineLocks.containsKey(id)) {\n+                engineLocks.put(id, new RuntimeManagerLockThreadsInfo(runtimeManagerLockFactory.newRuntimeManagerLock()));\n+            }\n+            lockThreadsInfo = engineLocks.get(id);\n+            lockThreadsInfo.set();\n+        }\n+        logger.debug(\"Trying to get a lock {} for {} by {}\", lockThreadsInfo, id, runtime);\n+        try {\n+            lock(lockThreadsInfo.getRuntimeManagerLock());\n+        } catch(InterruptedException e) {\n+            logger.warn(\"Interrupted lock {}\", lockThreadsInfo.getRuntimeManagerLock());\n+            throw e;\n+        }\n+        logger.debug(\"Lock {} taken for {} by {} for waiting threads by {}\", lockThreadsInfo, id, runtime, lockThreadsInfo.hasQueuedThreads());\n+    }\n+\n+    protected abstract void lock(RuntimeManagerLock lock) throws InterruptedException;\n+    \n+    @Override\n+    public void unlock(Long id, RuntimeEngine runtime) {\n+        RuntimeManagerLockThreadsInfo lockThreadsInfo = null;\n+        synchronized (engineLocks) {\n+            lockThreadsInfo = engineLocks.get(id);\n+            if (lockThreadsInfo == null) {\n+                logger.warn(\"[LOCK] lock {} is already removed for {} unlocked by {}\", id, lockThreadsInfo, runtime);\n+                return;\n+            }\n+            lockThreadsInfo.unset();\n+            if (lockThreadsInfo.count() == 0) {\n+                logger.debug(\"[LOCK] Removing lock for {} for lock  {} from list as non is waiting for it by {}\", id, lockThreadsInfo, runtime);\n+                engineLocks.remove(id);\n+            }\n+        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3fd114fd9adcac8725b104e28cd3cfe6ad87ac65"}, "originalPosition": 87}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTI1MTk2NA==", "bodyText": "In case we can call lock() on the same lock instance more than once in the same thread, we could unify this with the lock method:\nWe can add more and more stack traces for the same thread in case lock() is called more than once by the same thread in succession. But with unlock as soon as there is one unlock(), we throw away all the stacktraces. Maybe we could make use of getHoldCount() to see if this invocation is the last one and clear() only then?", "url": "https://github.com/kiegroup/jbpm/pull/1826#discussion_r545251964", "createdAt": "2020-12-17T17:04:31Z", "author": {"login": "MarianMacik"}, "path": "jbpm-runtime-manager/src/main/java/org/jbpm/runtime/manager/impl/lock/DebugRuntimeManagerLock.java", "diffHunk": "@@ -0,0 +1,101 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.jbpm.runtime.manager.impl.lock;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.locks.ReentrantLock;\n+\n+import org.jbpm.runtime.manager.spi.RuntimeManagerLock;\n+\n+\n+public class DebugRuntimeManagerLock implements RuntimeManagerLock {\n+\n+    private ReentrantLock lock = new ReentrantLock(true);\n+    private List<StackTraceElement[]> traces;\n+    private long currentThreadId;\n+\n+    public DebugRuntimeManagerLock() {\n+        traces = new ArrayList<>();\n+        currentThreadId = -1;\n+    }\n+    \n+    @Override\n+    public void lock() {\n+        lock.lock();\n+        addTraces();\n+    }\n+\n+    @Override\n+    public boolean tryLock(long units, TimeUnit timeUnit) throws InterruptedException {\n+        boolean outcome = lock.tryLock(units, timeUnit);\n+        if(outcome) {\n+            addTraces();\n+        }\n+        return outcome;\n+    }\n+\n+    @Override\n+    public void lockInterruptible() throws InterruptedException {\n+        lock.lockInterruptibly();\n+        addTraces();\n+    }\n+\n+    private void addTraces() {\n+        long newThreadId = Thread.currentThread().getId();\n+        if(currentThreadId < 0 || currentThreadId != newThreadId) {\n+            currentThreadId = newThreadId;\n+            traces.clear();\n+        }\n+        // we add all stack traces during reentrant lock\n+        traces.add(Thread.currentThread().getStackTrace());\n+    }\n+    @Override\n+    public void unlock() {\n+        if(currentThreadId == Thread.currentThread().getId()) {\n+            traces.clear(); // clean up\n+        }\n+        lock.unlock();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2a503c0ba72f71b6559f34f5210d66152a8b0fdc"}, "originalPosition": 73}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTI1NDk5Mw==", "bodyText": "Just for better control we could rather throw here exception. As when a user makes a typo in the system property, they need to be informed ASAP I think. Here it can happen that they choose something, but they make a typo and thus it will work with a different strategy than they might expect. I think the default is already handled well with the default system property value.", "url": "https://github.com/kiegroup/jbpm/pull/1826#discussion_r545254993", "createdAt": "2020-12-17T17:08:56Z", "author": {"login": "MarianMacik"}, "path": "jbpm-runtime-manager/src/main/java/org/jbpm/runtime/manager/impl/lock/RuntimeManagerLockStrategyFactory.java", "diffHunk": "@@ -0,0 +1,95 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.jbpm.runtime.manager.impl.lock;\n+\n+import java.util.Iterator;\n+import java.util.ServiceLoader;\n+\n+import org.jbpm.runtime.manager.spi.RuntimeManagerLockFactory;\n+import org.jbpm.runtime.manager.spi.RuntimeManagerLockStrategy;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public final class RuntimeManagerLockStrategyFactory {\n+\n+    protected static final Logger logger = LoggerFactory.getLogger(RuntimeManagerLockStrategyFactory.class);\n+\n+    public String lockStrategyClassName;\n+    public String lockFactoryClassName;\n+\n+    public RuntimeManagerLockStrategyFactory() {\n+        this(System.getProperty(\"org.kie.jbpm.runtime.manager.lock.strategy\", LegacyRuntimeManagerLockStrategy.class.getName()),\n+             System.getProperty(\"org.kie.jbpm.runtime.manager.lock.factory\", DefaultRuntimeManagerLockFactory.class.getName()));\n+    }\n+\n+    public RuntimeManagerLockStrategyFactory(String strategy, String factory) {\n+        this.lockFactoryClassName = factory;\n+        this.lockStrategyClassName = strategy;\n+    }\n+\n+    public RuntimeManagerLockStrategy createFreeLockStrategy() {\n+        return new FreeRuntimeManagerLockStrategy();\n+    }\n+\n+    public RuntimeManagerLockStrategy createLockStrategy(String identifier) {\n+        RuntimeManagerLockStrategy runtimeManagerLockStrategy = null;\n+\n+        // choose the right locking system\n+        ServiceLoader<RuntimeManagerLockStrategy> loader = ServiceLoader.load(RuntimeManagerLockStrategy.class);\n+        Iterator<RuntimeManagerLockStrategy> iterator = loader.iterator();\n+        while (iterator.hasNext()) {\n+            RuntimeManagerLockStrategy lockStrategy = iterator.next();\n+            if (lockStrategy.getClass().getName().equals(lockStrategyClassName)) {\n+                runtimeManagerLockStrategy = lockStrategy;\n+                break;\n+            }\n+        }\n+\n+\n+        if (runtimeManagerLockStrategy == null) {\n+            runtimeManagerLockStrategy = new LegacyRuntimeManagerLockStrategy();\n+        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2a503c0ba72f71b6559f34f5210d66152a8b0fdc"}, "originalPosition": 65}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTI1NTI3OQ==", "bodyText": "Same for the lock factory.", "url": "https://github.com/kiegroup/jbpm/pull/1826#discussion_r545255279", "createdAt": "2020-12-17T17:09:18Z", "author": {"login": "MarianMacik"}, "path": "jbpm-runtime-manager/src/main/java/org/jbpm/runtime/manager/impl/lock/RuntimeManagerLockStrategyFactory.java", "diffHunk": "@@ -0,0 +1,95 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.jbpm.runtime.manager.impl.lock;\n+\n+import java.util.Iterator;\n+import java.util.ServiceLoader;\n+\n+import org.jbpm.runtime.manager.spi.RuntimeManagerLockFactory;\n+import org.jbpm.runtime.manager.spi.RuntimeManagerLockStrategy;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public final class RuntimeManagerLockStrategyFactory {\n+\n+    protected static final Logger logger = LoggerFactory.getLogger(RuntimeManagerLockStrategyFactory.class);\n+\n+    public String lockStrategyClassName;\n+    public String lockFactoryClassName;\n+\n+    public RuntimeManagerLockStrategyFactory() {\n+        this(System.getProperty(\"org.kie.jbpm.runtime.manager.lock.strategy\", LegacyRuntimeManagerLockStrategy.class.getName()),\n+             System.getProperty(\"org.kie.jbpm.runtime.manager.lock.factory\", DefaultRuntimeManagerLockFactory.class.getName()));\n+    }\n+\n+    public RuntimeManagerLockStrategyFactory(String strategy, String factory) {\n+        this.lockFactoryClassName = factory;\n+        this.lockStrategyClassName = strategy;\n+    }\n+\n+    public RuntimeManagerLockStrategy createFreeLockStrategy() {\n+        return new FreeRuntimeManagerLockStrategy();\n+    }\n+\n+    public RuntimeManagerLockStrategy createLockStrategy(String identifier) {\n+        RuntimeManagerLockStrategy runtimeManagerLockStrategy = null;\n+\n+        // choose the right locking system\n+        ServiceLoader<RuntimeManagerLockStrategy> loader = ServiceLoader.load(RuntimeManagerLockStrategy.class);\n+        Iterator<RuntimeManagerLockStrategy> iterator = loader.iterator();\n+        while (iterator.hasNext()) {\n+            RuntimeManagerLockStrategy lockStrategy = iterator.next();\n+            if (lockStrategy.getClass().getName().equals(lockStrategyClassName)) {\n+                runtimeManagerLockStrategy = lockStrategy;\n+                break;\n+            }\n+        }\n+\n+\n+        if (runtimeManagerLockStrategy == null) {\n+            runtimeManagerLockStrategy = new LegacyRuntimeManagerLockStrategy();\n+        }\n+\n+        RuntimeManagerLockFactory runtimeManagerLockFactory = createRuntimeManagerLockFactory();\n+        runtimeManagerLockStrategy.init(runtimeManagerLockFactory);\n+        logger.info(\"RuntimeManagerLockStrategy {} with lock factory {} is created for {}\", \n+                    runtimeManagerLockStrategy.getClass().getName(),\n+                    runtimeManagerLockFactory.getClass().getName(), identifier);\n+        return runtimeManagerLockStrategy;\n+    }\n+\n+    private RuntimeManagerLockFactory createRuntimeManagerLockFactory () {\n+        // chose the right factory lock\n+        RuntimeManagerLockFactory runtimeManagerLockFactory = null;\n+\n+        ServiceLoader<RuntimeManagerLockFactory> loader = ServiceLoader.load(RuntimeManagerLockFactory.class);\n+        Iterator<RuntimeManagerLockFactory> iterator = loader.iterator();\n+        while (iterator.hasNext()) {\n+            RuntimeManagerLockFactory currentRuntimeManagerLockFactory = iterator.next();\n+            if (currentRuntimeManagerLockFactory.getClass().getName().equals(lockFactoryClassName)) {\n+                runtimeManagerLockFactory = currentRuntimeManagerLockFactory;\n+                break;\n+            }\n+        }\n+\n+        // fallback to default\n+        if (runtimeManagerLockFactory == null) {\n+            runtimeManagerLockFactory = new DefaultRuntimeManagerLockFactory();\n+        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2a503c0ba72f71b6559f34f5210d66152a8b0fdc"}, "originalPosition": 92}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTI2MTQxMg==", "bodyText": "Here the action of calling hasQueuedThreads() and removing the lock is not atomic.\nSo it may happen that there are no queued threads, but before the remove is done there is a new thread which calls lock(). So now the lock is removed from the map and is exclusively available to just that one thread. So in case there is yet another thread calling lock() for the same runtime engine, it gets a different lock, a new one, and both threads are now using the same runtime engine in parallel. I think that is what you tried to fix by introducing the synchronized block + the count of threads using, or planning to use the lock (via the RuntimeManagerLockThreadsInfo)? In theory, just a synchronized block was needed with the hasQueuedThreads() method , but it's good to have also the current state of thread ids.", "url": "https://github.com/kiegroup/jbpm/pull/1826#discussion_r545261412", "createdAt": "2020-12-17T17:18:13Z", "author": {"login": "MarianMacik"}, "path": "jbpm-runtime-manager/src/main/java/org/jbpm/runtime/manager/impl/lock/LegacyRuntimeManagerLockStrategy.java", "diffHunk": "@@ -0,0 +1,80 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.jbpm.runtime.manager.impl.lock;\n+\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentMap;\n+\n+import org.jbpm.runtime.manager.spi.RuntimeManagerLock;\n+import org.jbpm.runtime.manager.spi.RuntimeManagerLockFactory;\n+import org.jbpm.runtime.manager.spi.RuntimeManagerLockStrategy;\n+import org.kie.api.runtime.manager.RuntimeEngine;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+public class LegacyRuntimeManagerLockStrategy implements RuntimeManagerLockStrategy {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(LegacyRuntimeManagerLockStrategy.class);\n+\n+    protected ConcurrentMap<Long, RuntimeManagerLock> engineLocks; \n+\n+    private RuntimeManagerLockFactory runtimeManagerLockFactory;\n+\n+    \n+    \n+    public LegacyRuntimeManagerLockStrategy() {\n+        this.engineLocks = new ConcurrentHashMap<>();\n+        this.runtimeManagerLockFactory = new DefaultRuntimeManagerLockFactory();\n+    }\n+    @Override\n+    public void init(RuntimeManagerLockFactory factory) {\n+        this.runtimeManagerLockFactory = factory;\n+    }\n+\n+    @Override\n+    public void lock(Long id, RuntimeEngine runtime) {\n+        RuntimeManagerLock newLock = runtimeManagerLockFactory.newRuntimeManagerLock();\n+        RuntimeManagerLock lock = engineLocks.putIfAbsent(id, newLock);\n+        if (lock == null) {\n+            lock = newLock;\n+            logger.debug(\"New lock created as it did not exist before\");\n+        } else {\n+            logger.debug(\"Lock exists with {} waiting threads\", lock.internalLock().getQueueLength());\n+        }\n+        logger.debug(\"Trying to get a lock {} for {} by {}\", lock, id, runtime);\n+        lock.lock();\n+        logger.debug(\"Lock {} taken for {} by {} for waiting threads by {}\", lock, id, runtime, lock.internalLock().hasQueuedThreads());\n+\n+    }\n+\n+    @Override\n+    public void unlock(Long id, RuntimeEngine runtime) {\n+        RuntimeManagerLock lock = engineLocks.get(id);\n+        if (lock != null) {\n+            if (!lock.internalLock().hasQueuedThreads()) {\n+                logger.debug(\"Removing lock {} from list as non is waiting for it by {}\", lock, runtime);\n+                engineLocks.remove(id);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2a503c0ba72f71b6559f34f5210d66152a8b0fdc"}, "originalPosition": 71}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTMxOTg0OA==", "bodyText": "This will always use the FreeLockStrategy as when the object is created, the child (e.g. PerProcessInstanceRuntimeManager) is not yet initialized, so isUseLocking() will always return false. I guess we can move this into a separate method which can be then called from the init() method?", "url": "https://github.com/kiegroup/jbpm/pull/1826#discussion_r545319848", "createdAt": "2020-12-17T18:45:24Z", "author": {"login": "MarianMacik"}, "path": "jbpm-runtime-manager/src/main/java/org/jbpm/runtime/manager/impl/AbstractRuntimeManager.java", "diffHunk": "@@ -104,15 +114,22 @@\n     \n     protected SecurityManager securityManager = null;\n     protected ExecutionErrorManager executionErrorManager;\n-        \n-    protected ConcurrentMap<Long, ReentrantLock> engineLocks = new ConcurrentHashMap<Long, ReentrantLock>(); \n+    protected RuntimeManagerLockStrategy runtimeManagerLockStrategy;\n+\n     \n     public AbstractRuntimeManager(RuntimeEnvironment environment, String identifier) {\n         this.environment = environment;\n         this.identifier = identifier;\n         if (registry.isRegistered(identifier)) {\n             throw new IllegalStateException(\"RuntimeManager with id \" + identifier + \" is already active\");\n         }\n+\n+        if (!isUseLocking()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2a503c0ba72f71b6559f34f5210d66152a8b0fdc"}, "originalPosition": 55}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTMzOTc0Ng==", "bodyText": "Can it even happen in the engine that we call lock() more than once in the same thread? By looking at the code when we first get the engine, it is locked and saved to the thread local (saveLocalRuntime method) and then it is reused within the same thread when calling getRuntimeEngine(), so we never reach the line with createLockOnGetEngine(). Just my observation.", "url": "https://github.com/kiegroup/jbpm/pull/1826#discussion_r545339746", "createdAt": "2020-12-17T19:16:25Z", "author": {"login": "MarianMacik"}, "path": "jbpm-runtime-manager/src/main/java/org/jbpm/runtime/manager/impl/lock/DebugRuntimeManagerLock.java", "diffHunk": "@@ -0,0 +1,101 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.jbpm.runtime.manager.impl.lock;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.locks.ReentrantLock;\n+\n+import org.jbpm.runtime.manager.spi.RuntimeManagerLock;\n+\n+\n+public class DebugRuntimeManagerLock implements RuntimeManagerLock {\n+\n+    private ReentrantLock lock = new ReentrantLock(true);\n+    private List<StackTraceElement[]> traces;\n+    private long currentThreadId;\n+\n+    public DebugRuntimeManagerLock() {\n+        traces = new ArrayList<>();\n+        currentThreadId = -1;\n+    }\n+    \n+    @Override\n+    public void lock() {\n+        lock.lock();\n+        addTraces();\n+    }\n+\n+    @Override\n+    public boolean tryLock(long units, TimeUnit timeUnit) throws InterruptedException {\n+        boolean outcome = lock.tryLock(units, timeUnit);\n+        if(outcome) {\n+            addTraces();\n+        }\n+        return outcome;\n+    }\n+\n+    @Override\n+    public void lockInterruptible() throws InterruptedException {\n+        lock.lockInterruptibly();\n+        addTraces();\n+    }\n+\n+    private void addTraces() {\n+        long newThreadId = Thread.currentThread().getId();\n+        if(currentThreadId < 0 || currentThreadId != newThreadId) {\n+            currentThreadId = newThreadId;\n+            traces.clear();\n+        }\n+        // we add all stack traces during reentrant lock\n+        traces.add(Thread.currentThread().getStackTrace());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2a503c0ba72f71b6559f34f5210d66152a8b0fdc"}, "originalPosition": 66}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTU0OTA5MjM2", "url": "https://github.com/kiegroup/jbpm/pull/1826#pullrequestreview-554909236", "createdAt": "2020-12-17T19:13:07Z", "commit": {"oid": "2a503c0ba72f71b6559f34f5210d66152a8b0fdc"}, "state": "COMMENTED", "comments": {"totalCount": 16, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xN1QxOToxMzowN1rOIIEx_g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xN1QxOTo0MToyMVrOIIF0tA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTMzNzg1NA==", "bodyText": "this is not used", "url": "https://github.com/kiegroup/jbpm/pull/1826#discussion_r545337854", "createdAt": "2020-12-17T19:13:07Z", "author": {"login": "gmunozfe"}, "path": "jbpm-runtime-manager/src/main/java/org/jbpm/runtime/manager/impl/AbstractRuntimeManager.java", "diffHunk": "@@ -15,13 +15,15 @@\n  */\n package org.jbpm.runtime.manager.impl;\n \n+import java.util.Iterator;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2a503c0ba72f71b6559f34f5210d66152a8b0fdc"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTMzODQxOQ==", "bodyText": "these 3 imports are not used", "url": "https://github.com/kiegroup/jbpm/pull/1826#discussion_r545338419", "createdAt": "2020-12-17T19:14:07Z", "author": {"login": "gmunozfe"}, "path": "jbpm-runtime-manager/src/main/java/org/jbpm/runtime/manager/impl/AbstractRuntimeManager.java", "diffHunk": "@@ -15,13 +15,15 @@\n  */\n package org.jbpm.runtime.manager.impl;\n \n+import java.util.Iterator;\n import java.util.List;\n import java.util.Map;\n import java.util.Map.Entry;\n import java.util.concurrent.ConcurrentHashMap;\n import java.util.concurrent.ConcurrentMap;\n import java.util.concurrent.locks.ReentrantLock;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2a503c0ba72f71b6559f34f5210d66152a8b0fdc"}, "originalPosition": 10}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTMzOTQwNg==", "bodyText": "Use java util instead:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            import com.sun.tools.javac.util.ServiceLoader;\n          \n          \n            \n            import java.util.ServiceLoader;", "url": "https://github.com/kiegroup/jbpm/pull/1826#discussion_r545339406", "createdAt": "2020-12-17T19:15:48Z", "author": {"login": "gmunozfe"}, "path": "jbpm-runtime-manager/src/main/java/org/jbpm/runtime/manager/impl/AbstractRuntimeManager.java", "diffHunk": "@@ -15,13 +15,15 @@\n  */\n package org.jbpm.runtime.manager.impl;\n \n+import java.util.Iterator;\n import java.util.List;\n import java.util.Map;\n import java.util.Map.Entry;\n import java.util.concurrent.ConcurrentHashMap;\n import java.util.concurrent.ConcurrentMap;\n import java.util.concurrent.locks.ReentrantLock;\n \n+import com.sun.tools.javac.util.ServiceLoader;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2a503c0ba72f71b6559f34f5210d66152a8b0fdc"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTM0MDEyNg==", "bodyText": "These 3 imports are not used", "url": "https://github.com/kiegroup/jbpm/pull/1826#discussion_r545340126", "createdAt": "2020-12-17T19:16:58Z", "author": {"login": "gmunozfe"}, "path": "jbpm-runtime-manager/src/main/java/org/jbpm/runtime/manager/impl/AbstractRuntimeManager.java", "diffHunk": "@@ -34,7 +36,13 @@\n import org.jbpm.runtime.manager.api.SchedulerProvider;\n import org.jbpm.runtime.manager.impl.error.DefaultExecutionErrorStorage;\n import org.jbpm.runtime.manager.impl.error.ExecutionErrorManagerImpl;\n+import org.jbpm.runtime.manager.impl.lock.DefaultRuntimeManagerLockFactory;\n+import org.jbpm.runtime.manager.impl.lock.FreeRuntimeManagerLockStrategy;\n+import org.jbpm.runtime.manager.impl.lock.LegacyRuntimeManagerLockStrategy;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2a503c0ba72f71b6559f34f5210d66152a8b0fdc"}, "originalPosition": 22}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTM0MDUwOQ==", "bodyText": "This is not used", "url": "https://github.com/kiegroup/jbpm/pull/1826#discussion_r545340509", "createdAt": "2020-12-17T19:17:35Z", "author": {"login": "gmunozfe"}, "path": "jbpm-runtime-manager/src/main/java/org/jbpm/runtime/manager/impl/AbstractRuntimeManager.java", "diffHunk": "@@ -34,7 +36,13 @@\n import org.jbpm.runtime.manager.api.SchedulerProvider;\n import org.jbpm.runtime.manager.impl.error.DefaultExecutionErrorStorage;\n import org.jbpm.runtime.manager.impl.error.ExecutionErrorManagerImpl;\n+import org.jbpm.runtime.manager.impl.lock.DefaultRuntimeManagerLockFactory;\n+import org.jbpm.runtime.manager.impl.lock.FreeRuntimeManagerLockStrategy;\n+import org.jbpm.runtime.manager.impl.lock.LegacyRuntimeManagerLockStrategy;\n+import org.jbpm.runtime.manager.impl.lock.RuntimeManagerLockStrategyFactory;\n import org.jbpm.runtime.manager.impl.tx.NoOpTransactionManager;\n+import org.jbpm.runtime.manager.spi.RuntimeManagerLockFactory;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2a503c0ba72f71b6559f34f5210d66152a8b0fdc"}, "originalPosition": 25}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTM0MjE1Mw==", "bodyText": "Check first if id is null (same as rest of methods)", "url": "https://github.com/kiegroup/jbpm/pull/1826#discussion_r545342153", "createdAt": "2020-12-17T19:20:20Z", "author": {"login": "gmunozfe"}, "path": "jbpm-runtime-manager/src/main/java/org/jbpm/runtime/manager/impl/AbstractRuntimeManager.java", "diffHunk": "@@ -431,43 +448,31 @@ protected void createLockOnGetEngine(Context<?> context, RuntimeEngine runtime)\n     }\n     \n     protected void createLockOnGetEngine(Long id, RuntimeEngine runtime) {\n-        if (!isUseLocking()) {\n-            logger.debug(\"Locking on runtime manager disabled\");\n+        if (id == null) {\n             return;\n         }\n-        \n-        if (id != null) {\n-            ReentrantLock newLock = new ReentrantLock();\n-            ReentrantLock lock = engineLocks.putIfAbsent(id, newLock);\n-            if (lock == null) {\n-                lock = newLock;\n-                logger.debug(\"New lock created as it did not exist before\");\n-            } else {\n-                logger.debug(\"Lock exists with {} waiting threads\", lock.getQueueLength());\n-            }\n-            logger.debug(\"Trying to get a lock {} for {} by {}\", lock, id, runtime);\n-            lock.lock();\n-            logger.debug(\"Lock {} taken for {} by {} for waiting threads by {}\", lock, id, runtime, lock.hasQueuedThreads());\n-            \n+        try {\n+            runtimeManagerLockStrategy.lock(id, runtime);\n+        } catch(InterruptedException e) {\n+            throw new RuntimeException(\"Runtime manager was not able to lock for {\" + id +\"}\", e);\n         }\n-        \n+    }\n+\n+    protected void releaseAndCleanLock(Long id, RuntimeEngine runtime) {\n+        if (id == null) {\n+            return;\n+        }\n+        runtimeManagerLockStrategy.unlock(id, runtime);\n     }\n     \n     protected void createLockOnNewProcessInstance(Long id, RuntimeEngine runtime) {\n         if (!isUseLocking()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2a503c0ba72f71b6559f34f5210d66152a8b0fdc"}, "originalPosition": 112}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTM0MzY1MA==", "bodyText": "As it is abstract, it shouldn't be public\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public AbstractRuntimeManagerLockStrategy() {\n          \n          \n            \n                protected AbstractRuntimeManagerLockStrategy() {", "url": "https://github.com/kiegroup/jbpm/pull/1826#discussion_r545343650", "createdAt": "2020-12-17T19:22:47Z", "author": {"login": "gmunozfe"}, "path": "jbpm-runtime-manager/src/main/java/org/jbpm/runtime/manager/impl/lock/AbstractRuntimeManagerLockStrategy.java", "diffHunk": "@@ -0,0 +1,136 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.jbpm.runtime.manager.impl.lock;\n+\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import org.jbpm.runtime.manager.spi.RuntimeManagerLock;\n+import org.jbpm.runtime.manager.spi.RuntimeManagerLockFactory;\n+import org.jbpm.runtime.manager.spi.RuntimeManagerLockStrategy;\n+import org.kie.api.runtime.manager.RuntimeEngine;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+public abstract class AbstractRuntimeManagerLockStrategy implements RuntimeManagerLockStrategy {\n+\n+    protected static final Logger logger = LoggerFactory.getLogger(AbstractRuntimeManagerLockStrategy.class);\n+\n+    protected Map<Long, RuntimeManagerLockThreadsInfo> engineLocks; \n+\n+    private RuntimeManagerLockFactory runtimeManagerLockFactory;\n+\n+    \n+    public AbstractRuntimeManagerLockStrategy() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2a503c0ba72f71b6559f34f5210d66152a8b0fdc"}, "originalPosition": 41}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTM0NDA5MA==", "bodyText": "consider use \"computeIfAbsent\" instead", "url": "https://github.com/kiegroup/jbpm/pull/1826#discussion_r545344090", "createdAt": "2020-12-17T19:23:30Z", "author": {"login": "gmunozfe"}, "path": "jbpm-runtime-manager/src/main/java/org/jbpm/runtime/manager/impl/lock/AbstractRuntimeManagerLockStrategy.java", "diffHunk": "@@ -0,0 +1,136 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.jbpm.runtime.manager.impl.lock;\n+\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import org.jbpm.runtime.manager.spi.RuntimeManagerLock;\n+import org.jbpm.runtime.manager.spi.RuntimeManagerLockFactory;\n+import org.jbpm.runtime.manager.spi.RuntimeManagerLockStrategy;\n+import org.kie.api.runtime.manager.RuntimeEngine;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+public abstract class AbstractRuntimeManagerLockStrategy implements RuntimeManagerLockStrategy {\n+\n+    protected static final Logger logger = LoggerFactory.getLogger(AbstractRuntimeManagerLockStrategy.class);\n+\n+    protected Map<Long, RuntimeManagerLockThreadsInfo> engineLocks; \n+\n+    private RuntimeManagerLockFactory runtimeManagerLockFactory;\n+\n+    \n+    public AbstractRuntimeManagerLockStrategy() {\n+        this.runtimeManagerLockFactory = new DefaultRuntimeManagerLockFactory();\n+        this.engineLocks = new HashMap<>();\n+    }\n+\n+    @Override\n+    public void init(RuntimeManagerLockFactory factory) {\n+        this.runtimeManagerLockFactory = factory;\n+    }\n+\n+    @Override\n+    public void lock(Long id, RuntimeEngine runtime) throws InterruptedException {\n+        RuntimeManagerLockThreadsInfo lockThreadsInfo = null;\n+        synchronized (engineLocks) {\n+            if(!engineLocks.containsKey(id)) {\n+                engineLocks.put(id, new RuntimeManagerLockThreadsInfo(runtimeManagerLockFactory.newRuntimeManagerLock()));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2a503c0ba72f71b6559f34f5210d66152a8b0fdc"}, "originalPosition": 56}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTM0NDg4NQ==", "bodyText": "Check first if id is null to return", "url": "https://github.com/kiegroup/jbpm/pull/1826#discussion_r545344885", "createdAt": "2020-12-17T19:24:47Z", "author": {"login": "gmunozfe"}, "path": "jbpm-runtime-manager/src/main/java/org/jbpm/runtime/manager/impl/lock/AbstractRuntimeManagerLockStrategy.java", "diffHunk": "@@ -0,0 +1,136 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.jbpm.runtime.manager.impl.lock;\n+\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import org.jbpm.runtime.manager.spi.RuntimeManagerLock;\n+import org.jbpm.runtime.manager.spi.RuntimeManagerLockFactory;\n+import org.jbpm.runtime.manager.spi.RuntimeManagerLockStrategy;\n+import org.kie.api.runtime.manager.RuntimeEngine;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+public abstract class AbstractRuntimeManagerLockStrategy implements RuntimeManagerLockStrategy {\n+\n+    protected static final Logger logger = LoggerFactory.getLogger(AbstractRuntimeManagerLockStrategy.class);\n+\n+    protected Map<Long, RuntimeManagerLockThreadsInfo> engineLocks; \n+\n+    private RuntimeManagerLockFactory runtimeManagerLockFactory;\n+\n+    \n+    public AbstractRuntimeManagerLockStrategy() {\n+        this.runtimeManagerLockFactory = new DefaultRuntimeManagerLockFactory();\n+        this.engineLocks = new HashMap<>();\n+    }\n+\n+    @Override\n+    public void init(RuntimeManagerLockFactory factory) {\n+        this.runtimeManagerLockFactory = factory;\n+    }\n+\n+    @Override\n+    public void lock(Long id, RuntimeEngine runtime) throws InterruptedException {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2a503c0ba72f71b6559f34f5210d66152a8b0fdc"}, "originalPosition": 52}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTM0Njg4Mw==", "bodyText": "Check first if id is null to return", "url": "https://github.com/kiegroup/jbpm/pull/1826#discussion_r545346883", "createdAt": "2020-12-17T19:27:58Z", "author": {"login": "gmunozfe"}, "path": "jbpm-runtime-manager/src/main/java/org/jbpm/runtime/manager/impl/lock/AbstractRuntimeManagerLockStrategy.java", "diffHunk": "@@ -0,0 +1,136 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.jbpm.runtime.manager.impl.lock;\n+\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import org.jbpm.runtime.manager.spi.RuntimeManagerLock;\n+import org.jbpm.runtime.manager.spi.RuntimeManagerLockFactory;\n+import org.jbpm.runtime.manager.spi.RuntimeManagerLockStrategy;\n+import org.kie.api.runtime.manager.RuntimeEngine;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+public abstract class AbstractRuntimeManagerLockStrategy implements RuntimeManagerLockStrategy {\n+\n+    protected static final Logger logger = LoggerFactory.getLogger(AbstractRuntimeManagerLockStrategy.class);\n+\n+    protected Map<Long, RuntimeManagerLockThreadsInfo> engineLocks; \n+\n+    private RuntimeManagerLockFactory runtimeManagerLockFactory;\n+\n+    \n+    public AbstractRuntimeManagerLockStrategy() {\n+        this.runtimeManagerLockFactory = new DefaultRuntimeManagerLockFactory();\n+        this.engineLocks = new HashMap<>();\n+    }\n+\n+    @Override\n+    public void init(RuntimeManagerLockFactory factory) {\n+        this.runtimeManagerLockFactory = factory;\n+    }\n+\n+    @Override\n+    public void lock(Long id, RuntimeEngine runtime) throws InterruptedException {\n+        RuntimeManagerLockThreadsInfo lockThreadsInfo = null;\n+        synchronized (engineLocks) {\n+            if(!engineLocks.containsKey(id)) {\n+                engineLocks.put(id, new RuntimeManagerLockThreadsInfo(runtimeManagerLockFactory.newRuntimeManagerLock()));\n+            }\n+            lockThreadsInfo = engineLocks.get(id);\n+            lockThreadsInfo.set();\n+        }\n+        logger.debug(\"Trying to get a lock {} for {} by {}\", lockThreadsInfo, id, runtime);\n+        try {\n+            lock(lockThreadsInfo.getRuntimeManagerLock());\n+        } catch(InterruptedException e) {\n+            logger.warn(\"Interrupted lock {}\", lockThreadsInfo.getRuntimeManagerLock());\n+            throw e;\n+        }\n+        logger.debug(\"Lock {} taken for {} by {} for waiting threads by {}\", lockThreadsInfo, id, runtime, lockThreadsInfo.hasQueuedThreads());\n+    }\n+\n+    protected abstract void lock(RuntimeManagerLock lock) throws InterruptedException;\n+    \n+    @Override\n+    public void unlock(Long id, RuntimeEngine runtime) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2a503c0ba72f71b6559f34f5210d66152a8b0fdc"}, "originalPosition": 74}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTM0OTI4Ng==", "bodyText": "Check first if id is null to return", "url": "https://github.com/kiegroup/jbpm/pull/1826#discussion_r545349286", "createdAt": "2020-12-17T19:31:56Z", "author": {"login": "gmunozfe"}, "path": "jbpm-runtime-manager/src/main/java/org/jbpm/runtime/manager/impl/lock/LegacyRuntimeManagerLockStrategy.java", "diffHunk": "@@ -0,0 +1,80 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.jbpm.runtime.manager.impl.lock;\n+\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentMap;\n+\n+import org.jbpm.runtime.manager.spi.RuntimeManagerLock;\n+import org.jbpm.runtime.manager.spi.RuntimeManagerLockFactory;\n+import org.jbpm.runtime.manager.spi.RuntimeManagerLockStrategy;\n+import org.kie.api.runtime.manager.RuntimeEngine;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+public class LegacyRuntimeManagerLockStrategy implements RuntimeManagerLockStrategy {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(LegacyRuntimeManagerLockStrategy.class);\n+\n+    protected ConcurrentMap<Long, RuntimeManagerLock> engineLocks; \n+\n+    private RuntimeManagerLockFactory runtimeManagerLockFactory;\n+\n+    \n+    \n+    public LegacyRuntimeManagerLockStrategy() {\n+        this.engineLocks = new ConcurrentHashMap<>();\n+        this.runtimeManagerLockFactory = new DefaultRuntimeManagerLockFactory();\n+    }\n+    @Override\n+    public void init(RuntimeManagerLockFactory factory) {\n+        this.runtimeManagerLockFactory = factory;\n+    }\n+\n+    @Override\n+    public void lock(Long id, RuntimeEngine runtime) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2a503c0ba72f71b6559f34f5210d66152a8b0fdc"}, "originalPosition": 50}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTM0OTM2OA==", "bodyText": "Check first if id is null to return", "url": "https://github.com/kiegroup/jbpm/pull/1826#discussion_r545349368", "createdAt": "2020-12-17T19:32:03Z", "author": {"login": "gmunozfe"}, "path": "jbpm-runtime-manager/src/main/java/org/jbpm/runtime/manager/impl/lock/LegacyRuntimeManagerLockStrategy.java", "diffHunk": "@@ -0,0 +1,80 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.jbpm.runtime.manager.impl.lock;\n+\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentMap;\n+\n+import org.jbpm.runtime.manager.spi.RuntimeManagerLock;\n+import org.jbpm.runtime.manager.spi.RuntimeManagerLockFactory;\n+import org.jbpm.runtime.manager.spi.RuntimeManagerLockStrategy;\n+import org.kie.api.runtime.manager.RuntimeEngine;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+public class LegacyRuntimeManagerLockStrategy implements RuntimeManagerLockStrategy {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(LegacyRuntimeManagerLockStrategy.class);\n+\n+    protected ConcurrentMap<Long, RuntimeManagerLock> engineLocks; \n+\n+    private RuntimeManagerLockFactory runtimeManagerLockFactory;\n+\n+    \n+    \n+    public LegacyRuntimeManagerLockStrategy() {\n+        this.engineLocks = new ConcurrentHashMap<>();\n+        this.runtimeManagerLockFactory = new DefaultRuntimeManagerLockFactory();\n+    }\n+    @Override\n+    public void init(RuntimeManagerLockFactory factory) {\n+        this.runtimeManagerLockFactory = factory;\n+    }\n+\n+    @Override\n+    public void lock(Long id, RuntimeEngine runtime) {\n+        RuntimeManagerLock newLock = runtimeManagerLockFactory.newRuntimeManagerLock();\n+        RuntimeManagerLock lock = engineLocks.putIfAbsent(id, newLock);\n+        if (lock == null) {\n+            lock = newLock;\n+            logger.debug(\"New lock created as it did not exist before\");\n+        } else {\n+            logger.debug(\"Lock exists with {} waiting threads\", lock.internalLock().getQueueLength());\n+        }\n+        logger.debug(\"Trying to get a lock {} for {} by {}\", lock, id, runtime);\n+        lock.lock();\n+        logger.debug(\"Lock {} taken for {} by {} for waiting threads by {}\", lock, id, runtime, lock.internalLock().hasQueuedThreads());\n+\n+    }\n+\n+    @Override\n+    public void unlock(Long id, RuntimeEngine runtime) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2a503c0ba72f71b6559f34f5210d66152a8b0fdc"}, "originalPosition": 66}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTM1MTI1NA==", "bodyText": "Shouldn't it implement \"Serializable\" or is it not necessary?", "url": "https://github.com/kiegroup/jbpm/pull/1826#discussion_r545351254", "createdAt": "2020-12-17T19:35:12Z", "author": {"login": "gmunozfe"}, "path": "jbpm-runtime-manager/src/main/java/org/jbpm/runtime/manager/impl/lock/SerializableRuntimeManagerLockStrategy.java", "diffHunk": "@@ -0,0 +1,35 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.jbpm.runtime.manager.impl.lock;\n+\n+import org.jbpm.runtime.manager.spi.RuntimeManagerLock;\n+\n+\n+public class SerializableRuntimeManagerLockStrategy extends AbstractRuntimeManagerLockStrategy {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2a503c0ba72f71b6559f34f5210d66152a8b0fdc"}, "originalPosition": 22}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTM1Mzk1NA==", "bodyText": "timeout could be also added to the test", "url": "https://github.com/kiegroup/jbpm/pull/1826#discussion_r545353954", "createdAt": "2020-12-17T19:39:37Z", "author": {"login": "gmunozfe"}, "path": "jbpm-runtime-manager/src/test/java/org/jbpm/runtime/manager/impl/lock/CustomRuntimeManagerLockStrategyTest.java", "diffHunk": "@@ -0,0 +1,92 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.jbpm.runtime.manager.impl.lock;\n+\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+import org.jbpm.runtime.manager.spi.RuntimeManagerLockStrategy;\n+import org.junit.After;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class CustomRuntimeManagerLockStrategyTest {\n+\n+    protected static final Logger logger = LoggerFactory.getLogger(CustomRuntimeManagerLockStrategyTest.class);\n+\n+    private static final int NUMBER_OF_WORKING_THREADS = 10;\n+\n+    private ExecutorService executorService;\n+\n+    @Before\n+    public void init() {\n+        executorService = Executors.newFixedThreadPool(NUMBER_OF_WORKING_THREADS);\n+    }\n+\n+    @After\n+    public void destroy() {\n+        executorService.shutdown();\n+        executorService = null;\n+    }\n+\n+    @Test", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2a503c0ba72f71b6559f34f5210d66152a8b0fdc"}, "originalPosition": 52}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTM1NDAxNA==", "bodyText": "timeout could be also added to the test", "url": "https://github.com/kiegroup/jbpm/pull/1826#discussion_r545354014", "createdAt": "2020-12-17T19:39:43Z", "author": {"login": "gmunozfe"}, "path": "jbpm-runtime-manager/src/test/java/org/jbpm/runtime/manager/impl/lock/CustomRuntimeManagerLockStrategyTest.java", "diffHunk": "@@ -0,0 +1,92 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.jbpm.runtime.manager.impl.lock;\n+\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+import org.jbpm.runtime.manager.spi.RuntimeManagerLockStrategy;\n+import org.junit.After;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class CustomRuntimeManagerLockStrategyTest {\n+\n+    protected static final Logger logger = LoggerFactory.getLogger(CustomRuntimeManagerLockStrategyTest.class);\n+\n+    private static final int NUMBER_OF_WORKING_THREADS = 10;\n+\n+    private ExecutorService executorService;\n+\n+    @Before\n+    public void init() {\n+        executorService = Executors.newFixedThreadPool(NUMBER_OF_WORKING_THREADS);\n+    }\n+\n+    @After\n+    public void destroy() {\n+        executorService.shutdown();\n+        executorService = null;\n+    }\n+\n+    @Test\n+    public void testTimeout() throws Exception {\n+        final CriticalSectionClash sectionDetection = new CriticalSectionClash();\n+        String factory = DebugRuntimeManagerLockFactory.class.getName();\n+        final RuntimeManagerLockStrategy lockStrategy = new RuntimeManagerLockStrategyFactory(\"org.jbpm.runtime.manager.impl.lock.TimeoutRuntimeManagerLockStrategy\", factory).createLockStrategy(\"timeout\");\n+        AtomicInteger count = new AtomicInteger(0);\n+\n+        executorService.submit(new Runner(count, sectionDetection, lockStrategy, true)).get();\n+        executorService.submit(new Runner(count, sectionDetection, lockStrategy, false));\n+\n+        logger.info(\"finished jobs test TimeoutRuntimeManagerLockStrategy\");\n+        executorService.shutdown();\n+        executorService.awaitTermination(20, TimeUnit.SECONDS);\n+\n+        // assert hangs\n+        Assert.assertTrue(executorService.isTerminated());\n+        logger.info(\"exiting test TimeoutRuntimeManagerLockStrategy\");\n+    }\n+\n+\n+    @Test", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2a503c0ba72f71b6559f34f5210d66152a8b0fdc"}, "originalPosition": 72}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTM1NDkzMg==", "bodyText": "more meaningful method name is appreciated, something like testLockStrategy", "url": "https://github.com/kiegroup/jbpm/pull/1826#discussion_r545354932", "createdAt": "2020-12-17T19:41:21Z", "author": {"login": "gmunozfe"}, "path": "jbpm-runtime-manager/src/test/java/org/jbpm/runtime/manager/impl/lock/RuntimeManagerLockStrategyTest.java", "diffHunk": "@@ -0,0 +1,104 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.jbpm.runtime.manager.impl.lock;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+import org.jbpm.runtime.manager.spi.RuntimeManagerLockStrategy;\n+import org.junit.After;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.Ignore;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.Parameterized;\n+import org.junit.runners.Parameterized.Parameters;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+@RunWith(Parameterized.class)\n+public class RuntimeManagerLockStrategyTest {\n+\n+    protected static final Logger logger = LoggerFactory.getLogger(RuntimeManagerLockStrategyTest.class);\n+\n+    private static final int NUMBER_OF_WORKING_THREADS = 10;\n+\n+    @Parameters(name = \"Strategy : {0}\")\n+    public static Collection<Object[]> data() {\n+        return Arrays.asList(new Object[][]{\n+                                            {\"org.jbpm.runtime.manager.impl.lock.SerializableRuntimeManagerLockStrategy\"},\n+                                            {\"org.jbpm.runtime.manager.impl.lock.TimeoutRuntimeManagerLockStrategy\"},\n+                                            {\"org.jbpm.runtime.manager.impl.lock.InterruptibleRuntimeManagerLockStrategy\"},\n+                                            {\"org.jbpm.runtime.manager.impl.lock.LegacyRuntimeManagerLockStrategy\"}\n+        });\n+    }\n+\n+    private String strategy;\n+    private ExecutorService executorService;\n+\n+    public RuntimeManagerLockStrategyTest(String strategy) {\n+        this.strategy = strategy;\n+    }\n+\n+    @Before\n+    public void init() {\n+        executorService = Executors.newFixedThreadPool(NUMBER_OF_WORKING_THREADS);\n+    }\n+\n+    @After\n+    public void destroy() {\n+        executorService.shutdown();\n+        executorService = null;\n+    }\n+\n+    @Test\n+    public void test() throws InterruptedException {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2a503c0ba72f71b6559f34f5210d66152a8b0fdc"}, "originalPosition": 77}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "2a503c0ba72f71b6559f34f5210d66152a8b0fdc", "author": {"user": {"login": "elguardian", "name": "Enrique Gonz\u00e1lez Mart\u00ednez"}}, "url": "https://github.com/kiegroup/jbpm/commit/2a503c0ba72f71b6559f34f5210d66152a8b0fdc", "committedDate": "2020-12-17T16:28:16Z", "message": "[LOCKING_STRATEGY] implementing different strategies for diagnose and execution"}, "afterCommit": {"oid": "567716305068e6a91c70efdfaf88e6c0bf069043", "author": {"user": {"login": "elguardian", "name": "Enrique Gonz\u00e1lez Mart\u00ednez"}}, "url": "https://github.com/kiegroup/jbpm/commit/567716305068e6a91c70efdfaf88e6c0bf069043", "committedDate": "2020-12-18T08:57:09Z", "message": "[LOCKING_STRATEGY] implementing different strategies for diagnose and execution"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTU1MzU3OTEz", "url": "https://github.com/kiegroup/jbpm/pull/1826#pullrequestreview-555357913", "createdAt": "2020-12-18T10:10:02Z", "commit": {"oid": "567716305068e6a91c70efdfaf88e6c0bf069043"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xOFQxMDoxMDowMlrOIIcyyA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xOFQxMDoxMDowMlrOIIcyyA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTczMTI3Mg==", "bodyText": "Just a question, why are not we directly using an custom implementation of java.util.concurrent.Lock that delegates into the real lock.", "url": "https://github.com/kiegroup/jbpm/pull/1826#discussion_r545731272", "createdAt": "2020-12-18T10:10:02Z", "author": {"login": "fjtirado"}, "path": "jbpm-runtime-manager/src/main/java/org/jbpm/runtime/manager/spi/RuntimeManagerLock.java", "diffHunk": "@@ -0,0 +1,35 @@\n+/*", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "567716305068e6a91c70efdfaf88e6c0bf069043"}, "originalPosition": 1}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTU1MzY0OTI2", "url": "https://github.com/kiegroup/jbpm/pull/1826#pullrequestreview-555364926", "createdAt": "2020-12-18T10:20:17Z", "commit": {"oid": "567716305068e6a91c70efdfaf88e6c0bf069043"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xOFQxMDoyMDoxN1rOIIdIdw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xOFQxMDoyMDoxN1rOIIdIdw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTczNjgyMw==", "bodyText": "Is that trace right?, last argument is boolean, so is going to pring Lock  taken for  by  for waiting thread by [true|false]", "url": "https://github.com/kiegroup/jbpm/pull/1826#discussion_r545736823", "createdAt": "2020-12-18T10:20:17Z", "author": {"login": "fjtirado"}, "path": "jbpm-runtime-manager/src/main/java/org/jbpm/runtime/manager/impl/lock/LegacyRuntimeManagerLockStrategy.java", "diffHunk": "@@ -0,0 +1,80 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.jbpm.runtime.manager.impl.lock;\n+\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentMap;\n+\n+import org.jbpm.runtime.manager.spi.RuntimeManagerLock;\n+import org.jbpm.runtime.manager.spi.RuntimeManagerLockFactory;\n+import org.jbpm.runtime.manager.spi.RuntimeManagerLockStrategy;\n+import org.kie.api.runtime.manager.RuntimeEngine;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+public class LegacyRuntimeManagerLockStrategy implements RuntimeManagerLockStrategy {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(LegacyRuntimeManagerLockStrategy.class);\n+\n+    protected ConcurrentMap<Long, RuntimeManagerLock> engineLocks; \n+\n+    private RuntimeManagerLockFactory runtimeManagerLockFactory;\n+\n+    \n+    \n+    public LegacyRuntimeManagerLockStrategy() {\n+        this.engineLocks = new ConcurrentHashMap<>();\n+        this.runtimeManagerLockFactory = new DefaultRuntimeManagerLockFactory();\n+    }\n+    @Override\n+    public void init(RuntimeManagerLockFactory factory) {\n+        this.runtimeManagerLockFactory = factory;\n+    }\n+\n+    @Override\n+    public void lock(Long id, RuntimeEngine runtime) {\n+        RuntimeManagerLock newLock = runtimeManagerLockFactory.newRuntimeManagerLock();\n+        RuntimeManagerLock lock = engineLocks.putIfAbsent(id, newLock);\n+        if (lock == null) {\n+            lock = newLock;\n+            logger.debug(\"New lock created as it did not exist before\");\n+        } else {\n+            logger.debug(\"Lock exists with {} waiting threads\", lock.internalLock().getQueueLength());\n+        }\n+        logger.debug(\"Trying to get a lock {} for {} by {}\", lock, id, runtime);\n+        lock.lock();\n+        logger.debug(\"Lock {} taken for {} by {} for waiting threads by {}\", lock, id, runtime, lock.internalLock().hasQueuedThreads());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "567716305068e6a91c70efdfaf88e6c0bf069043"}, "originalPosition": 61}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTU1MzY2ODUz", "url": "https://github.com/kiegroup/jbpm/pull/1826#pullrequestreview-555366853", "createdAt": "2020-12-18T10:23:08Z", "commit": {"oid": "567716305068e6a91c70efdfaf88e6c0bf069043"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xOFQxMDoyMzowOFrOIIdOXQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xOFQxMDoyMzowOFrOIIdOXQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTczODMzMw==", "bodyText": "Style, should we throw a more specifc runtime here? For example, IllegalStateException", "url": "https://github.com/kiegroup/jbpm/pull/1826#discussion_r545738333", "createdAt": "2020-12-18T10:23:08Z", "author": {"login": "fjtirado"}, "path": "jbpm-runtime-manager/src/main/java/org/jbpm/runtime/manager/impl/AbstractRuntimeManager.java", "diffHunk": "@@ -431,49 +440,28 @@ protected void createLockOnGetEngine(Context<?> context, RuntimeEngine runtime)\n     }\n     \n     protected void createLockOnGetEngine(Long id, RuntimeEngine runtime) {\n-        if (!isUseLocking()) {\n-            logger.debug(\"Locking on runtime manager disabled\");\n+        if (id == null) {\n             return;\n         }\n-        \n-        if (id != null) {\n-            ReentrantLock newLock = new ReentrantLock();\n-            ReentrantLock lock = engineLocks.putIfAbsent(id, newLock);\n-            if (lock == null) {\n-                lock = newLock;\n-                logger.debug(\"New lock created as it did not exist before\");\n-            } else {\n-                logger.debug(\"Lock exists with {} waiting threads\", lock.getQueueLength());\n-            }\n-            logger.debug(\"Trying to get a lock {} for {} by {}\", lock, id, runtime);\n-            lock.lock();\n-            logger.debug(\"Lock {} taken for {} by {} for waiting threads by {}\", lock, id, runtime, lock.hasQueuedThreads());\n-            \n+        try {\n+            runtimeManagerLockStrategy.lock(id, runtime);\n+        } catch(InterruptedException e) {\n+            throw new RuntimeException(\"Runtime manager was not able to lock for {\" + id +\"}\", e);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "567716305068e6a91c70efdfaf88e6c0bf069043"}, "originalPosition": 102}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTU1MzY3MDYx", "url": "https://github.com/kiegroup/jbpm/pull/1826#pullrequestreview-555367061", "createdAt": "2020-12-18T10:23:27Z", "commit": {"oid": "567716305068e6a91c70efdfaf88e6c0bf069043"}, "state": "COMMENTED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTU1MzgzMDM5", "url": "https://github.com/kiegroup/jbpm/pull/1826#pullrequestreview-555383039", "createdAt": "2020-12-18T10:46:16Z", "commit": {"oid": "567716305068e6a91c70efdfaf88e6c0bf069043"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "567716305068e6a91c70efdfaf88e6c0bf069043", "author": {"user": {"login": "elguardian", "name": "Enrique Gonz\u00e1lez Mart\u00ednez"}}, "url": "https://github.com/kiegroup/jbpm/commit/567716305068e6a91c70efdfaf88e6c0bf069043", "committedDate": "2020-12-18T08:57:09Z", "message": "[LOCKING_STRATEGY] implementing different strategies for diagnose and execution"}, "afterCommit": {"oid": "5eb0b44cee32fb84ab8bf4e891607d195d443526", "author": {"user": {"login": "elguardian", "name": "Enrique Gonz\u00e1lez Mart\u00ednez"}}, "url": "https://github.com/kiegroup/jbpm/commit/5eb0b44cee32fb84ab8bf4e891607d195d443526", "committedDate": "2020-12-18T11:22:01Z", "message": "[LOCKING_STRATEGY] implementing different strategies for diagnose and execution"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "5eb0b44cee32fb84ab8bf4e891607d195d443526", "author": {"user": {"login": "elguardian", "name": "Enrique Gonz\u00e1lez Mart\u00ednez"}}, "url": "https://github.com/kiegroup/jbpm/commit/5eb0b44cee32fb84ab8bf4e891607d195d443526", "committedDate": "2020-12-18T11:22:01Z", "message": "[LOCKING_STRATEGY] implementing different strategies for diagnose and execution"}, "afterCommit": {"oid": "a3bcb20747ce51a528e8894fb4ba343531936b1f", "author": {"user": {"login": "elguardian", "name": "Enrique Gonz\u00e1lez Mart\u00ednez"}}, "url": "https://github.com/kiegroup/jbpm/commit/a3bcb20747ce51a528e8894fb4ba343531936b1f", "committedDate": "2021-01-04T07:56:06Z", "message": "[LOCKING_STRATEGY] implementing different strategies for diagnose and execution"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTYzNDIyMDQ2", "url": "https://github.com/kiegroup/jbpm/pull/1826#pullrequestreview-563422046", "createdAt": "2021-01-07T11:43:54Z", "commit": {"oid": "a3bcb20747ce51a528e8894fb4ba343531936b1f"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a02ef1c6d1a18b1f55e63731463ae335e020d769", "author": {"user": {"login": "elguardian", "name": "Enrique Gonz\u00e1lez Mart\u00ednez"}}, "url": "https://github.com/kiegroup/jbpm/commit/a02ef1c6d1a18b1f55e63731463ae335e020d769", "committedDate": "2021-01-07T15:36:41Z", "message": "[LOCKING_STRATEGY] implementing different strategies for diagnose and execution"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "a3bcb20747ce51a528e8894fb4ba343531936b1f", "author": {"user": {"login": "elguardian", "name": "Enrique Gonz\u00e1lez Mart\u00ednez"}}, "url": "https://github.com/kiegroup/jbpm/commit/a3bcb20747ce51a528e8894fb4ba343531936b1f", "committedDate": "2021-01-04T07:56:06Z", "message": "[LOCKING_STRATEGY] implementing different strategies for diagnose and execution"}, "afterCommit": {"oid": "a02ef1c6d1a18b1f55e63731463ae335e020d769", "author": {"user": {"login": "elguardian", "name": "Enrique Gonz\u00e1lez Mart\u00ednez"}}, "url": "https://github.com/kiegroup/jbpm/commit/a02ef1c6d1a18b1f55e63731463ae335e020d769", "committedDate": "2021-01-07T15:36:41Z", "message": "[LOCKING_STRATEGY] implementing different strategies for diagnose and execution"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 869, "cost": 1, "resetAt": "2021-11-01T15:33:45Z"}}}