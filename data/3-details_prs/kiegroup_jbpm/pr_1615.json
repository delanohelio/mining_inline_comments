{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzkyODUzMTY1", "number": 1615, "title": "[RHPAM-2552] Ability to Search for tasks by multiple task variables a nd / or process variables via the kie-server api.", "bodyText": "added search for process with variables and task with variables", "createdAt": "2020-03-24T08:40:45Z", "url": "https://github.com/kiegroup/jbpm/pull/1615", "merged": true, "mergeCommit": {"oid": "778e63a718fcc0960f01ff48b196af2d4b031ede"}, "closed": true, "closedAt": "2020-04-20T14:46:03Z", "author": {"login": "elguardian"}, "timelineItems": {"totalCount": 21, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcQv1AFABqjMxNTg4Nzg5NDg=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcZfG9jgFqTM5NjQ1MjM4Mw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "5d5b5f05e7600f69919e64f969c12643dc55703f", "author": {"user": null}, "url": "https://github.com/kiegroup/jbpm/commit/5d5b5f05e7600f69919e64f969c12643dc55703f", "committedDate": "2020-03-24T08:39:59Z", "message": "[RHPAM-2552] Ability to Search for tasks by multiple task variables and / or process variables via the kie-server api.\n\nadded search for process with variables and task with variables"}, "afterCommit": {"oid": "f269fe50fc6e2ae61e2ada0c054df0dac5085faa", "author": {"user": null}, "url": "https://github.com/kiegroup/jbpm/commit/f269fe50fc6e2ae61e2ada0c054df0dac5085faa", "committedDate": "2020-03-24T09:51:23Z", "message": "[RHPAM-2552] Ability to Search for tasks by multiple task variables a nd / or process variables via the kie-server api.\n\nadded the possibility to query process/cases by variables"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "f269fe50fc6e2ae61e2ada0c054df0dac5085faa", "author": {"user": null}, "url": "https://github.com/kiegroup/jbpm/commit/f269fe50fc6e2ae61e2ada0c054df0dac5085faa", "committedDate": "2020-03-24T09:51:23Z", "message": "[RHPAM-2552] Ability to Search for tasks by multiple task variables a nd / or process variables via the kie-server api.\n\nadded the possibility to query process/cases by variables"}, "afterCommit": {"oid": "cdf99a0114e025f440524f9192b93ea1a9b37d02", "author": {"user": null}, "url": "https://github.com/kiegroup/jbpm/commit/cdf99a0114e025f440524f9192b93ea1a9b37d02", "committedDate": "2020-03-24T12:25:40Z", "message": "[RHPAM-2552] Ability to Search for tasks by multiple task variables a nd / or process variables via the kie-server api.\n\nadded the possibility to query process/cases by variables"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "cdf99a0114e025f440524f9192b93ea1a9b37d02", "author": {"user": null}, "url": "https://github.com/kiegroup/jbpm/commit/cdf99a0114e025f440524f9192b93ea1a9b37d02", "committedDate": "2020-03-24T12:25:40Z", "message": "[RHPAM-2552] Ability to Search for tasks by multiple task variables a nd / or process variables via the kie-server api.\n\nadded the possibility to query process/cases by variables"}, "afterCommit": {"oid": "1e57dd6f9a77d2e636949457815115ca83acc4dc", "author": {"user": null}, "url": "https://github.com/kiegroup/jbpm/commit/1e57dd6f9a77d2e636949457815115ca83acc4dc", "committedDate": "2020-03-30T15:29:38Z", "message": "[RHPAM-2552] Ability to Search for tasks by multiple task variables a nd / or process variables via the kie-server api.\n\nadded the possibility to query process/cases by variables"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg0ODE0NjYw", "url": "https://github.com/kiegroup/jbpm/pull/1615#pullrequestreview-384814660", "createdAt": "2020-03-31T14:52:34Z", "commit": {"oid": "1e57dd6f9a77d2e636949457815115ca83acc4dc"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 30, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMVQxNDo1MjozNFrOF-Zv6g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMlQxNjowMzoyM1rOF_yXRg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDk3Nzg5OA==", "bodyText": "This process is not referenced or used in this test class", "url": "https://github.com/kiegroup/jbpm/pull/1615#discussion_r400977898", "createdAt": "2020-03-31T14:52:34Z", "author": {"login": "afalhambra"}, "path": "jbpm-case-mgmt/jbpm-case-mgmt-impl/src/test/java/org/jbpm/casemgmt/impl/AdvanceCaseRuntimeDataServiceImplTest.java", "diffHunk": "@@ -0,0 +1,101 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.jbpm.casemgmt.impl;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.jbpm.casemgmt.api.model.instance.CaseFileInstance;\n+import org.jbpm.casemgmt.impl.util.AbstractCaseServicesBaseTest;\n+import org.jbpm.services.api.model.ProcessInstanceWithVarsDesc;\n+import org.jbpm.services.api.model.UserTaskInstanceWithPotOwnerDesc;\n+import org.jbpm.services.task.impl.model.UserImpl;\n+import org.junit.Test;\n+import org.kie.api.runtime.query.QueryContext;\n+import org.kie.api.task.model.OrganizationalEntity;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static java.util.Collections.emptyList;\n+import static java.util.Collections.emptyMap;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNotNull;\n+\n+public class AdvanceCaseRuntimeDataServiceImplTest extends AbstractCaseServicesBaseTest {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(AdvanceCaseRuntimeDataServiceImplTest.class);\n+\n+    @Override\n+    protected List<String> getProcessDefinitionFiles() {\n+        List<String> processes = new ArrayList<String>();\n+        processes.add(\"cases/EmptyCase.bpmn2\");\n+        processes.add(\"cases/UserTaskCase.bpmn2\");\n+        processes.add(\"processes/UserTaskProcess.bpmn2\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1e57dd6f9a77d2e636949457815115ca83acc4dc"}, "originalPosition": 49}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDk3OTI5MA==", "bodyText": "If statement is not needed. Above assertNotNull will make this never happens.", "url": "https://github.com/kiegroup/jbpm/pull/1615#discussion_r400979290", "createdAt": "2020-03-31T14:54:17Z", "author": {"login": "afalhambra"}, "path": "jbpm-case-mgmt/jbpm-case-mgmt-impl/src/test/java/org/jbpm/casemgmt/impl/AdvanceCaseRuntimeDataServiceImplTest.java", "diffHunk": "@@ -0,0 +1,101 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.jbpm.casemgmt.impl;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.jbpm.casemgmt.api.model.instance.CaseFileInstance;\n+import org.jbpm.casemgmt.impl.util.AbstractCaseServicesBaseTest;\n+import org.jbpm.services.api.model.ProcessInstanceWithVarsDesc;\n+import org.jbpm.services.api.model.UserTaskInstanceWithPotOwnerDesc;\n+import org.jbpm.services.task.impl.model.UserImpl;\n+import org.junit.Test;\n+import org.kie.api.runtime.query.QueryContext;\n+import org.kie.api.task.model.OrganizationalEntity;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static java.util.Collections.emptyList;\n+import static java.util.Collections.emptyMap;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNotNull;\n+\n+public class AdvanceCaseRuntimeDataServiceImplTest extends AbstractCaseServicesBaseTest {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(AdvanceCaseRuntimeDataServiceImplTest.class);\n+\n+    @Override\n+    protected List<String> getProcessDefinitionFiles() {\n+        List<String> processes = new ArrayList<String>();\n+        processes.add(\"cases/EmptyCase.bpmn2\");\n+        processes.add(\"cases/UserTaskCase.bpmn2\");\n+        processes.add(\"processes/UserTaskProcess.bpmn2\");\n+        return processes;\n+    }\n+\n+    /*\n+     * Case instance queries\n+     */\n+    @Test\n+    public void testSearchByVariable() {\n+        Map<String, Object> data = new HashMap<>();\n+        data.put(\"name\", \"my first case\");\n+        CaseFileInstance caseFile = caseService.newCaseFileInstance(deploymentUnit.getIdentifier(), EMPTY_CASE_P_ID, data);\n+\n+        String caseId = caseService.startCase(deploymentUnit.getIdentifier(), EMPTY_CASE_P_ID, caseFile);\n+        Map<String, Object> vars = new HashMap<>();\n+        vars.put(\"name\", \"my first case\");\n+        \n+        List<ProcessInstanceWithVarsDesc> process = advanceCaseRuntimeDataService.queryCaseByVariables(emptyMap(), vars, new QueryContext());\n+        assertEquals(process.size(), 1);\n+        assertEquals(process.get(0).getVariables().get(\"name\"), \"my first case\");\n+\n+        assertNotNull(caseId);\n+        assertEquals(FIRST_CASE_ID, caseId);\n+        if (caseId != null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1e57dd6f9a77d2e636949457815115ca83acc4dc"}, "originalPosition": 72}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDk3OTU1MQ==", "bodyText": "If statement is not needed. Above assertNotNull will make this never happens.", "url": "https://github.com/kiegroup/jbpm/pull/1615#discussion_r400979551", "createdAt": "2020-03-31T14:54:37Z", "author": {"login": "afalhambra"}, "path": "jbpm-case-mgmt/jbpm-case-mgmt-impl/src/test/java/org/jbpm/casemgmt/impl/AdvanceCaseRuntimeDataServiceImplTest.java", "diffHunk": "@@ -0,0 +1,101 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.jbpm.casemgmt.impl;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.jbpm.casemgmt.api.model.instance.CaseFileInstance;\n+import org.jbpm.casemgmt.impl.util.AbstractCaseServicesBaseTest;\n+import org.jbpm.services.api.model.ProcessInstanceWithVarsDesc;\n+import org.jbpm.services.api.model.UserTaskInstanceWithPotOwnerDesc;\n+import org.jbpm.services.task.impl.model.UserImpl;\n+import org.junit.Test;\n+import org.kie.api.runtime.query.QueryContext;\n+import org.kie.api.task.model.OrganizationalEntity;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static java.util.Collections.emptyList;\n+import static java.util.Collections.emptyMap;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNotNull;\n+\n+public class AdvanceCaseRuntimeDataServiceImplTest extends AbstractCaseServicesBaseTest {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(AdvanceCaseRuntimeDataServiceImplTest.class);\n+\n+    @Override\n+    protected List<String> getProcessDefinitionFiles() {\n+        List<String> processes = new ArrayList<String>();\n+        processes.add(\"cases/EmptyCase.bpmn2\");\n+        processes.add(\"cases/UserTaskCase.bpmn2\");\n+        processes.add(\"processes/UserTaskProcess.bpmn2\");\n+        return processes;\n+    }\n+\n+    /*\n+     * Case instance queries\n+     */\n+    @Test\n+    public void testSearchByVariable() {\n+        Map<String, Object> data = new HashMap<>();\n+        data.put(\"name\", \"my first case\");\n+        CaseFileInstance caseFile = caseService.newCaseFileInstance(deploymentUnit.getIdentifier(), EMPTY_CASE_P_ID, data);\n+\n+        String caseId = caseService.startCase(deploymentUnit.getIdentifier(), EMPTY_CASE_P_ID, caseFile);\n+        Map<String, Object> vars = new HashMap<>();\n+        vars.put(\"name\", \"my first case\");\n+        \n+        List<ProcessInstanceWithVarsDesc> process = advanceCaseRuntimeDataService.queryCaseByVariables(emptyMap(), vars, new QueryContext());\n+        assertEquals(process.size(), 1);\n+        assertEquals(process.get(0).getVariables().get(\"name\"), \"my first case\");\n+\n+        assertNotNull(caseId);\n+        assertEquals(FIRST_CASE_ID, caseId);\n+        if (caseId != null) {\n+            caseService.cancelCase(caseId);\n+        }\n+\n+    }\n+\n+    @Test\n+    public void testSearchUserByVariable() {\n+        Map<String, OrganizationalEntity> roleAssignments = new HashMap<>();\n+        roleAssignments.put(\"owner\", new UserImpl(USER));\n+\n+        Map<String, Object> data = new HashMap<>();\n+        data.put(\"name\", \"my first case\");\n+        CaseFileInstance caseFile = caseService.newCaseFileInstance(deploymentUnit.getIdentifier(), USER_TASK_CASE_P_ID, data, roleAssignments);\n+\n+        String caseId = caseService.startCase(deploymentUnit.getIdentifier(), USER_TASK_CASE_P_ID, caseFile);\n+\n+        List<UserTaskInstanceWithPotOwnerDesc> process = advanceCaseRuntimeDataService.queryUserTasksByVariables(emptyMap(), emptyMap(), emptyMap(), emptyList(), new QueryContext());\n+        assertEquals(1, process.size());\n+        assertEquals(process.get(0).getExtraData().get(\"name\"), \"my first case\");\n+\n+        assertNotNull(caseId);\n+        assertEquals(HR_CASE_ID, caseId);\n+        if (caseId != null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1e57dd6f9a77d2e636949457815115ca83acc4dc"}, "originalPosition": 95}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTY0Mzg5NA==", "bodyText": "Expected and actual values should be swapped.", "url": "https://github.com/kiegroup/jbpm/pull/1615#discussion_r401643894", "createdAt": "2020-04-01T14:08:22Z", "author": {"login": "afalhambra"}, "path": "jbpm-case-mgmt/jbpm-case-mgmt-impl/src/test/java/org/jbpm/casemgmt/impl/AdvanceCaseRuntimeDataServiceImplTest.java", "diffHunk": "@@ -0,0 +1,101 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.jbpm.casemgmt.impl;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.jbpm.casemgmt.api.model.instance.CaseFileInstance;\n+import org.jbpm.casemgmt.impl.util.AbstractCaseServicesBaseTest;\n+import org.jbpm.services.api.model.ProcessInstanceWithVarsDesc;\n+import org.jbpm.services.api.model.UserTaskInstanceWithPotOwnerDesc;\n+import org.jbpm.services.task.impl.model.UserImpl;\n+import org.junit.Test;\n+import org.kie.api.runtime.query.QueryContext;\n+import org.kie.api.task.model.OrganizationalEntity;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static java.util.Collections.emptyList;\n+import static java.util.Collections.emptyMap;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNotNull;\n+\n+public class AdvanceCaseRuntimeDataServiceImplTest extends AbstractCaseServicesBaseTest {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(AdvanceCaseRuntimeDataServiceImplTest.class);\n+\n+    @Override\n+    protected List<String> getProcessDefinitionFiles() {\n+        List<String> processes = new ArrayList<String>();\n+        processes.add(\"cases/EmptyCase.bpmn2\");\n+        processes.add(\"cases/UserTaskCase.bpmn2\");\n+        processes.add(\"processes/UserTaskProcess.bpmn2\");\n+        return processes;\n+    }\n+\n+    /*\n+     * Case instance queries\n+     */\n+    @Test\n+    public void testSearchByVariable() {\n+        Map<String, Object> data = new HashMap<>();\n+        data.put(\"name\", \"my first case\");\n+        CaseFileInstance caseFile = caseService.newCaseFileInstance(deploymentUnit.getIdentifier(), EMPTY_CASE_P_ID, data);\n+\n+        String caseId = caseService.startCase(deploymentUnit.getIdentifier(), EMPTY_CASE_P_ID, caseFile);\n+        Map<String, Object> vars = new HashMap<>();\n+        vars.put(\"name\", \"my first case\");\n+        \n+        List<ProcessInstanceWithVarsDesc> process = advanceCaseRuntimeDataService.queryCaseByVariables(emptyMap(), vars, new QueryContext());\n+        assertEquals(process.size(), 1);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1e57dd6f9a77d2e636949457815115ca83acc4dc"}, "originalPosition": 67}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTY0NDI2Ng==", "bodyText": "Expected and actual values should be swapped", "url": "https://github.com/kiegroup/jbpm/pull/1615#discussion_r401644266", "createdAt": "2020-04-01T14:08:53Z", "author": {"login": "afalhambra"}, "path": "jbpm-case-mgmt/jbpm-case-mgmt-impl/src/test/java/org/jbpm/casemgmt/impl/AdvanceCaseRuntimeDataServiceImplTest.java", "diffHunk": "@@ -0,0 +1,101 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.jbpm.casemgmt.impl;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.jbpm.casemgmt.api.model.instance.CaseFileInstance;\n+import org.jbpm.casemgmt.impl.util.AbstractCaseServicesBaseTest;\n+import org.jbpm.services.api.model.ProcessInstanceWithVarsDesc;\n+import org.jbpm.services.api.model.UserTaskInstanceWithPotOwnerDesc;\n+import org.jbpm.services.task.impl.model.UserImpl;\n+import org.junit.Test;\n+import org.kie.api.runtime.query.QueryContext;\n+import org.kie.api.task.model.OrganizationalEntity;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static java.util.Collections.emptyList;\n+import static java.util.Collections.emptyMap;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNotNull;\n+\n+public class AdvanceCaseRuntimeDataServiceImplTest extends AbstractCaseServicesBaseTest {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(AdvanceCaseRuntimeDataServiceImplTest.class);\n+\n+    @Override\n+    protected List<String> getProcessDefinitionFiles() {\n+        List<String> processes = new ArrayList<String>();\n+        processes.add(\"cases/EmptyCase.bpmn2\");\n+        processes.add(\"cases/UserTaskCase.bpmn2\");\n+        processes.add(\"processes/UserTaskProcess.bpmn2\");\n+        return processes;\n+    }\n+\n+    /*\n+     * Case instance queries\n+     */\n+    @Test\n+    public void testSearchByVariable() {\n+        Map<String, Object> data = new HashMap<>();\n+        data.put(\"name\", \"my first case\");\n+        CaseFileInstance caseFile = caseService.newCaseFileInstance(deploymentUnit.getIdentifier(), EMPTY_CASE_P_ID, data);\n+\n+        String caseId = caseService.startCase(deploymentUnit.getIdentifier(), EMPTY_CASE_P_ID, caseFile);\n+        Map<String, Object> vars = new HashMap<>();\n+        vars.put(\"name\", \"my first case\");\n+        \n+        List<ProcessInstanceWithVarsDesc> process = advanceCaseRuntimeDataService.queryCaseByVariables(emptyMap(), vars, new QueryContext());\n+        assertEquals(process.size(), 1);\n+        assertEquals(process.get(0).getVariables().get(\"name\"), \"my first case\");\n+\n+        assertNotNull(caseId);\n+        assertEquals(FIRST_CASE_ID, caseId);\n+        if (caseId != null) {\n+            caseService.cancelCase(caseId);\n+        }\n+\n+    }\n+\n+    @Test\n+    public void testSearchUserByVariable() {\n+        Map<String, OrganizationalEntity> roleAssignments = new HashMap<>();\n+        roleAssignments.put(\"owner\", new UserImpl(USER));\n+\n+        Map<String, Object> data = new HashMap<>();\n+        data.put(\"name\", \"my first case\");\n+        CaseFileInstance caseFile = caseService.newCaseFileInstance(deploymentUnit.getIdentifier(), USER_TASK_CASE_P_ID, data, roleAssignments);\n+\n+        String caseId = caseService.startCase(deploymentUnit.getIdentifier(), USER_TASK_CASE_P_ID, caseFile);\n+\n+        List<UserTaskInstanceWithPotOwnerDesc> process = advanceCaseRuntimeDataService.queryUserTasksByVariables(emptyMap(), emptyMap(), emptyMap(), emptyList(), new QueryContext());\n+        assertEquals(1, process.size());\n+        assertEquals(process.get(0).getExtraData().get(\"name\"), \"my first case\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1e57dd6f9a77d2e636949457815115ca83acc4dc"}, "originalPosition": 91}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTY2ODIwNA==", "bodyText": "As we are querying user tasks by variable I would also add \"USER\" as parameter in the method call by using something like Collections.singletonList(USER) along with the data variable.", "url": "https://github.com/kiegroup/jbpm/pull/1615#discussion_r401668204", "createdAt": "2020-04-01T14:40:32Z", "author": {"login": "afalhambra"}, "path": "jbpm-case-mgmt/jbpm-case-mgmt-impl/src/test/java/org/jbpm/casemgmt/impl/AdvanceCaseRuntimeDataServiceImplTest.java", "diffHunk": "@@ -0,0 +1,101 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.jbpm.casemgmt.impl;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.jbpm.casemgmt.api.model.instance.CaseFileInstance;\n+import org.jbpm.casemgmt.impl.util.AbstractCaseServicesBaseTest;\n+import org.jbpm.services.api.model.ProcessInstanceWithVarsDesc;\n+import org.jbpm.services.api.model.UserTaskInstanceWithPotOwnerDesc;\n+import org.jbpm.services.task.impl.model.UserImpl;\n+import org.junit.Test;\n+import org.kie.api.runtime.query.QueryContext;\n+import org.kie.api.task.model.OrganizationalEntity;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static java.util.Collections.emptyList;\n+import static java.util.Collections.emptyMap;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNotNull;\n+\n+public class AdvanceCaseRuntimeDataServiceImplTest extends AbstractCaseServicesBaseTest {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(AdvanceCaseRuntimeDataServiceImplTest.class);\n+\n+    @Override\n+    protected List<String> getProcessDefinitionFiles() {\n+        List<String> processes = new ArrayList<String>();\n+        processes.add(\"cases/EmptyCase.bpmn2\");\n+        processes.add(\"cases/UserTaskCase.bpmn2\");\n+        processes.add(\"processes/UserTaskProcess.bpmn2\");\n+        return processes;\n+    }\n+\n+    /*\n+     * Case instance queries\n+     */\n+    @Test\n+    public void testSearchByVariable() {\n+        Map<String, Object> data = new HashMap<>();\n+        data.put(\"name\", \"my first case\");\n+        CaseFileInstance caseFile = caseService.newCaseFileInstance(deploymentUnit.getIdentifier(), EMPTY_CASE_P_ID, data);\n+\n+        String caseId = caseService.startCase(deploymentUnit.getIdentifier(), EMPTY_CASE_P_ID, caseFile);\n+        Map<String, Object> vars = new HashMap<>();\n+        vars.put(\"name\", \"my first case\");\n+        \n+        List<ProcessInstanceWithVarsDesc> process = advanceCaseRuntimeDataService.queryCaseByVariables(emptyMap(), vars, new QueryContext());\n+        assertEquals(process.size(), 1);\n+        assertEquals(process.get(0).getVariables().get(\"name\"), \"my first case\");\n+\n+        assertNotNull(caseId);\n+        assertEquals(FIRST_CASE_ID, caseId);\n+        if (caseId != null) {\n+            caseService.cancelCase(caseId);\n+        }\n+\n+    }\n+\n+    @Test\n+    public void testSearchUserByVariable() {\n+        Map<String, OrganizationalEntity> roleAssignments = new HashMap<>();\n+        roleAssignments.put(\"owner\", new UserImpl(USER));\n+\n+        Map<String, Object> data = new HashMap<>();\n+        data.put(\"name\", \"my first case\");\n+        CaseFileInstance caseFile = caseService.newCaseFileInstance(deploymentUnit.getIdentifier(), USER_TASK_CASE_P_ID, data, roleAssignments);\n+\n+        String caseId = caseService.startCase(deploymentUnit.getIdentifier(), USER_TASK_CASE_P_ID, caseFile);\n+\n+        List<UserTaskInstanceWithPotOwnerDesc> process = advanceCaseRuntimeDataService.queryUserTasksByVariables(emptyMap(), emptyMap(), emptyMap(), emptyList(), new QueryContext());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1e57dd6f9a77d2e636949457815115ca83acc4dc"}, "originalPosition": 89}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTcxNTY5OQ==", "bodyText": "Potential security issue when concatenating strings for a query. Though all the query parameters are properly set below these lines. do you see any risk here?", "url": "https://github.com/kiegroup/jbpm/pull/1615#discussion_r401715699", "createdAt": "2020-04-01T15:43:14Z", "author": {"login": "afalhambra"}, "path": "jbpm-services/jbpm-kie-services/src/main/java/org/jbpm/kie/services/impl/AbstractAdvanceRuntimeDataServiceImpl.java", "diffHunk": "@@ -0,0 +1,306 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.jbpm.kie.services.impl;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import javax.persistence.EntityManager;\n+import javax.persistence.EntityManagerFactory;\n+import javax.persistence.Query;\n+\n+import org.jbpm.kie.services.impl.model.ProcessInstanceWithVarsDesc;\n+import org.jbpm.kie.services.impl.model.UserTaskInstanceWithPotOwnerDesc;\n+import org.jbpm.shared.services.impl.QueryManager;\n+import org.jbpm.shared.services.impl.TransactionalCommandService;\n+import org.jbpm.shared.services.impl.commands.QueryNameCommand;\n+import org.kie.api.runtime.query.QueryContext;\n+\n+import static java.util.Collections.singletonMap;\n+\n+public abstract class AbstractAdvanceRuntimeDataServiceImpl {\n+\n+    private EntityManagerFactory emf;\n+    private TransactionalCommandService commandService;\n+\n+    public AbstractAdvanceRuntimeDataServiceImpl() {\n+        QueryManager.get().addNamedQueries(\"META-INF/Servicesorm.xml\");\n+    }\n+    public void setCommandService(TransactionalCommandService commandService) {\n+        this.commandService = commandService;\n+    }\n+\n+    public void setEmf(EntityManagerFactory emf) {\n+        this.emf = emf;\n+    }\n+\n+\n+    public List<org.jbpm.services.api.model.ProcessInstanceWithVarsDesc> queryProcessByVariables(Map<String, Object> attributes,\n+                                                                                                 Map<String, Object> variables,\n+                                                                                                 int processType,\n+                                                                                                 String varPrefix,\n+                                                                                                 QueryContext queryContext) {\n+        EntityManager entityManager = emf.createEntityManager();\n+\n+        // first step is to filter the data creating a derived tables and pivoting var - rows to columns (only the variables we are interested to filter)\n+        StringBuilder where = new StringBuilder();\n+        StringBuilder derivedTables = new StringBuilder();\n+        for (Map.Entry<String, Object> var : variables.entrySet()) {\n+            String alias = \"TABLE_\" + var.getKey();\n+            String varName = var.getKey();\n+\n+            derivedTables.append(\"LEFT JOIN (\" +\n+                                 \"SELECT A1.processId, A1.processInstanceId, A1.variableId AS NAME, A1.value AS VALUE \\n\" +\n+                                 \"FROM VariableInstanceLog A1 \\n\" +\n+                                 \"LEFT JOIN VariableInstanceLog A2 ON A1.processId = A2.processId AND A1.processInstanceId = A2.processInstanceId AND A1.variableInstanceId = A2.variableInstanceId AND A2.log_date < A1.log_date  \\n\" +\n+                                 \"WHERE A2.log_date IS NULL \\n\" +\n+                                 \") \" + alias + \" ON \" + alias + \".processId = pil.processId AND \" + alias + \".processInstanceId = pil.processInstanceId \\n\");\n+\n+            addWhereExpression(where);\n+            where.append(alias + \".NAME = :NAME_\" + varName + \" AND \" + alias + \".VALUE= :VALUE_\" + varName + \"\\n\");\n+        }\n+\n+\n+        for (Map.Entry<String, Object> entry : attributes.entrySet()) {\n+            addWhereExpression(where);\n+            where.append(\" pil.\" + entry.getKey() + \" = :ATTR_\" + entry.getKey() + \" \");\n+        }\n+\n+        addWhereExpression(where);\n+        where.append(\" pil.processType = :processType \");\n+\n+        String procSQLString = \"SELECT DISTINCT pil.processInstanceId FROM ProcessInstanceLog pil \\n \" + derivedTables + where + \" ORDER BY pil.processInstanceId ASC \";\n+        procSQLString += (queryContext.getCount() > 0) ? \" LIMIT \" + queryContext.getCount() + \" OFFSET \" + queryContext.getOffset() + \" \\n\" : \"\";\n+\n+        Query query = entityManager.createNativeQuery(procSQLString);\n+        for (Map.Entry<String, Object> var : variables.entrySet()) {\n+            query.setParameter(\"NAME_\" + var.getKey(), varPrefix + var.getKey());\n+            query.setParameter(\"VALUE_\" + var.getKey(), var.getValue());\n+        }\n+        for (Map.Entry<String, Object> entry : attributes.entrySet()) {\n+            query.setParameter(\"ATTR_\" + entry.getKey(), entry.getValue());\n+        }\n+        query.setParameter(\"processType\", processType);\n+\n+        List<Number> ids = query.getResultList();\n+        if (ids.isEmpty()) {\n+            return Collections.emptyList();\n+        }\n+\n+        // now we get the information\n+\n+        List<Object[]> procRows = commandService.execute(new QueryNameCommand<List<Object[]>>(\"GeProcessInstanceByIdList\", singletonMap(\"idList\", ids)));\n+        List<Object[]> varRows = commandService.execute(new QueryNameCommand<List<Object[]>>(\"GeVariablesByProcessInstanceIdList\", singletonMap(\"idList\", ids)));\n+\n+        int currentVarIdx = 0;\n+        List<org.jbpm.services.api.model.ProcessInstanceWithVarsDesc> data = new ArrayList<>();\n+        for (Object[] row : procRows) {\n+            ProcessInstanceWithVarsDesc pwv = toProcessInstanceWithVarsDesc(row);\n+\n+            Map<String, Object> vars = new HashMap<>();\n+            pwv.setVariables(vars);\n+            while (currentVarIdx < varRows.size() && row[0].equals(varRows.get(currentVarIdx)[0])) {\n+                String name = (String) varRows.get(currentVarIdx)[1];\n+                if (name.startsWith(varPrefix)) {\n+                    vars.put(name.substring(varPrefix.length()), varRows.get(currentVarIdx)[2]);\n+                }\n+                currentVarIdx++;\n+            }\n+            data.add(pwv);\n+        }\n+\n+        entityManager.close();\n+        return data;\n+    }\n+\n+    private ProcessInstanceWithVarsDesc toProcessInstanceWithVarsDesc(Object[] row) {\n+        return new ProcessInstanceWithVarsDesc(((Number) row[0]).longValue(),\n+                                               (String) row[1],\n+                                               (String) row[2],\n+                                               (String) row[3],\n+                                               ((Number) row[4]).intValue(),\n+                                               (String) row[5],\n+                                               (Date) row[6],\n+                                               (String) row[7],\n+                                               (String) row[8]);\n+    }\n+    private void addWhereExpression(StringBuilder where) {\n+        where.append(where.length() == 0 ? \"WHERE \" : \" AND \");\n+    }\n+\n+    public List<org.jbpm.services.api.model.UserTaskInstanceWithPotOwnerDesc> queryUserTasksByVariables(Map<String, Object> attributes,\n+                                                                                                        Map<String, Object> variables,\n+                                                                                                        Map<String, Object> processVariables,\n+                                                                                                        List<String> owners,\n+                                                                                                        int processType,\n+                                                                                                        String varPrefix,\n+                                                                                                        QueryContext queryContext) {\n+        EntityManager entityManager = emf.createEntityManager();\n+\n+        StringBuilder where = new StringBuilder();\n+        StringBuilder derivedTables = new StringBuilder();\n+        for (Map.Entry<String, Object> var : variables.entrySet()) {\n+            String alias = \"V_TABLE_\" + var.getKey();\n+            String varName = var.getKey();\n+            derivedTables.append(\"INNER JOIN (\\n\" +\n+                                  \"SELECT taskId, name, value \\n\" +\n+                                  \"FROM TaskVariableImpl \\n\" +\n+                                  \"WHERE type = 0\\n\" +\n+                                 \") \" + alias + \" ON \" + alias + \".taskId = task.id  \\n\");\n+\n+\n+            addWhereExpression(where);\n+            where.append(alias + \".NAME = :V_NAME_\" + varName + \" AND \" + alias + \".VALUE= :V_VALUE_\" + varName + \"\\n\");\n+        }\n+\n+        for (Map.Entry<String, Object> var : processVariables.entrySet()) {\n+            String alias = \"P_TABLE_\" + var.getKey();\n+            String varName = var.getKey();\n+\n+            derivedTables.append(\"LEFT JOIN (\" +\n+                                 \"SELECT A1.processId, A1.processInstanceId, A1.variableId AS NAME, A1.value AS VALUE \\n\" +\n+                                 \"FROM VariableInstanceLog A1 \\n\" +\n+                                 \"LEFT JOIN VariableInstanceLog A2 ON A1.processId = A2.processId AND A1.processInstanceId = A2.processInstanceId AND A1.variableInstanceId = A2.variableInstanceId AND A2.log_date < A1.log_date  \\n\" +\n+                                 \"WHERE A2.log_date IS NULL \\n\" +\n+                                 \") \" + alias + \" ON \" + alias + \".processId = pil.processId AND \" + alias + \".processInstanceId = pil.processInstanceId \\n\");\n+\n+            addWhereExpression(where);\n+            where.append(alias + \".NAME = :P_NAME_\" + varName + \" AND \" + alias + \".VALUE= :P_VALUE_\" + varName + \"\\n\");\n+        }\n+\n+        if (!owners.isEmpty()) {\n+            derivedTables.append(\"INNER JOIN ( \\n\" +\n+                             \"           SELECT DISTINCT po.task_id \\n\" +\n+                             \"           FROM PeopleAssignments_PotOwners po \\n\" +\n+                             \"           WHERE po.entity_id IN (:owners) \\n\" +\n+                             \"           GROUP BY po.task_id \\n\" +\n+                             \"           HAVING COUNT(po.entity_id) = :num_owners \\n\" +\n+                                 \") AS pot ON pot.task_id = task.id \");\n+        }\n+\n+        for (Map.Entry<String, Object> entry : attributes.entrySet()) {\n+            addWhereExpression(where);\n+            where.append(\" task.\" + entry.getKey() + \" = :ATTR_\" + entry.getKey() + \" \");\n+        }\n+\n+        addWhereExpression(where);\n+        where.append(\" pil.processType = :processType \");\n+\n+        String procSQLString = \"SELECT DISTINCT task.id FROM Task task INNER JOIN ProcessInstanceLog pil ON pil.processInstanceId = task.processInstanceId \\n \" + derivedTables + where + \" ORDER BY id ASC \";\n+        procSQLString += (queryContext.getCount() > 0) ? \" LIMIT \" + queryContext.getCount() + \" OFFSET \" + queryContext.getOffset() + \"\\n\" : \"\";\n+\n+        Query query = entityManager.createNativeQuery(procSQLString);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1e57dd6f9a77d2e636949457815115ca83acc4dc"}, "originalPosition": 210}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTcxNjQ2Mw==", "bodyText": "I would add some java doc to the method.", "url": "https://github.com/kiegroup/jbpm/pull/1615#discussion_r401716463", "createdAt": "2020-04-01T15:44:15Z", "author": {"login": "afalhambra"}, "path": "jbpm-services/jbpm-kie-services/src/main/java/org/jbpm/kie/services/impl/AbstractAdvanceRuntimeDataServiceImpl.java", "diffHunk": "@@ -0,0 +1,306 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.jbpm.kie.services.impl;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import javax.persistence.EntityManager;\n+import javax.persistence.EntityManagerFactory;\n+import javax.persistence.Query;\n+\n+import org.jbpm.kie.services.impl.model.ProcessInstanceWithVarsDesc;\n+import org.jbpm.kie.services.impl.model.UserTaskInstanceWithPotOwnerDesc;\n+import org.jbpm.shared.services.impl.QueryManager;\n+import org.jbpm.shared.services.impl.TransactionalCommandService;\n+import org.jbpm.shared.services.impl.commands.QueryNameCommand;\n+import org.kie.api.runtime.query.QueryContext;\n+\n+import static java.util.Collections.singletonMap;\n+\n+public abstract class AbstractAdvanceRuntimeDataServiceImpl {\n+\n+    private EntityManagerFactory emf;\n+    private TransactionalCommandService commandService;\n+\n+    public AbstractAdvanceRuntimeDataServiceImpl() {\n+        QueryManager.get().addNamedQueries(\"META-INF/Servicesorm.xml\");\n+    }\n+    public void setCommandService(TransactionalCommandService commandService) {\n+        this.commandService = commandService;\n+    }\n+\n+    public void setEmf(EntityManagerFactory emf) {\n+        this.emf = emf;\n+    }\n+\n+\n+    public List<org.jbpm.services.api.model.ProcessInstanceWithVarsDesc> queryProcessByVariables(Map<String, Object> attributes,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1e57dd6f9a77d2e636949457815115ca83acc4dc"}, "originalPosition": 56}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTcxNjY0NA==", "bodyText": "I would add some java doc to the method.", "url": "https://github.com/kiegroup/jbpm/pull/1615#discussion_r401716644", "createdAt": "2020-04-01T15:44:30Z", "author": {"login": "afalhambra"}, "path": "jbpm-services/jbpm-kie-services/src/main/java/org/jbpm/kie/services/impl/AbstractAdvanceRuntimeDataServiceImpl.java", "diffHunk": "@@ -0,0 +1,306 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.jbpm.kie.services.impl;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import javax.persistence.EntityManager;\n+import javax.persistence.EntityManagerFactory;\n+import javax.persistence.Query;\n+\n+import org.jbpm.kie.services.impl.model.ProcessInstanceWithVarsDesc;\n+import org.jbpm.kie.services.impl.model.UserTaskInstanceWithPotOwnerDesc;\n+import org.jbpm.shared.services.impl.QueryManager;\n+import org.jbpm.shared.services.impl.TransactionalCommandService;\n+import org.jbpm.shared.services.impl.commands.QueryNameCommand;\n+import org.kie.api.runtime.query.QueryContext;\n+\n+import static java.util.Collections.singletonMap;\n+\n+public abstract class AbstractAdvanceRuntimeDataServiceImpl {\n+\n+    private EntityManagerFactory emf;\n+    private TransactionalCommandService commandService;\n+\n+    public AbstractAdvanceRuntimeDataServiceImpl() {\n+        QueryManager.get().addNamedQueries(\"META-INF/Servicesorm.xml\");\n+    }\n+    public void setCommandService(TransactionalCommandService commandService) {\n+        this.commandService = commandService;\n+    }\n+\n+    public void setEmf(EntityManagerFactory emf) {\n+        this.emf = emf;\n+    }\n+\n+\n+    public List<org.jbpm.services.api.model.ProcessInstanceWithVarsDesc> queryProcessByVariables(Map<String, Object> attributes,\n+                                                                                                 Map<String, Object> variables,\n+                                                                                                 int processType,\n+                                                                                                 String varPrefix,\n+                                                                                                 QueryContext queryContext) {\n+        EntityManager entityManager = emf.createEntityManager();\n+\n+        // first step is to filter the data creating a derived tables and pivoting var - rows to columns (only the variables we are interested to filter)\n+        StringBuilder where = new StringBuilder();\n+        StringBuilder derivedTables = new StringBuilder();\n+        for (Map.Entry<String, Object> var : variables.entrySet()) {\n+            String alias = \"TABLE_\" + var.getKey();\n+            String varName = var.getKey();\n+\n+            derivedTables.append(\"LEFT JOIN (\" +\n+                                 \"SELECT A1.processId, A1.processInstanceId, A1.variableId AS NAME, A1.value AS VALUE \\n\" +\n+                                 \"FROM VariableInstanceLog A1 \\n\" +\n+                                 \"LEFT JOIN VariableInstanceLog A2 ON A1.processId = A2.processId AND A1.processInstanceId = A2.processInstanceId AND A1.variableInstanceId = A2.variableInstanceId AND A2.log_date < A1.log_date  \\n\" +\n+                                 \"WHERE A2.log_date IS NULL \\n\" +\n+                                 \") \" + alias + \" ON \" + alias + \".processId = pil.processId AND \" + alias + \".processInstanceId = pil.processInstanceId \\n\");\n+\n+            addWhereExpression(where);\n+            where.append(alias + \".NAME = :NAME_\" + varName + \" AND \" + alias + \".VALUE= :VALUE_\" + varName + \"\\n\");\n+        }\n+\n+\n+        for (Map.Entry<String, Object> entry : attributes.entrySet()) {\n+            addWhereExpression(where);\n+            where.append(\" pil.\" + entry.getKey() + \" = :ATTR_\" + entry.getKey() + \" \");\n+        }\n+\n+        addWhereExpression(where);\n+        where.append(\" pil.processType = :processType \");\n+\n+        String procSQLString = \"SELECT DISTINCT pil.processInstanceId FROM ProcessInstanceLog pil \\n \" + derivedTables + where + \" ORDER BY pil.processInstanceId ASC \";\n+        procSQLString += (queryContext.getCount() > 0) ? \" LIMIT \" + queryContext.getCount() + \" OFFSET \" + queryContext.getOffset() + \" \\n\" : \"\";\n+\n+        Query query = entityManager.createNativeQuery(procSQLString);\n+        for (Map.Entry<String, Object> var : variables.entrySet()) {\n+            query.setParameter(\"NAME_\" + var.getKey(), varPrefix + var.getKey());\n+            query.setParameter(\"VALUE_\" + var.getKey(), var.getValue());\n+        }\n+        for (Map.Entry<String, Object> entry : attributes.entrySet()) {\n+            query.setParameter(\"ATTR_\" + entry.getKey(), entry.getValue());\n+        }\n+        query.setParameter(\"processType\", processType);\n+\n+        List<Number> ids = query.getResultList();\n+        if (ids.isEmpty()) {\n+            return Collections.emptyList();\n+        }\n+\n+        // now we get the information\n+\n+        List<Object[]> procRows = commandService.execute(new QueryNameCommand<List<Object[]>>(\"GeProcessInstanceByIdList\", singletonMap(\"idList\", ids)));\n+        List<Object[]> varRows = commandService.execute(new QueryNameCommand<List<Object[]>>(\"GeVariablesByProcessInstanceIdList\", singletonMap(\"idList\", ids)));\n+\n+        int currentVarIdx = 0;\n+        List<org.jbpm.services.api.model.ProcessInstanceWithVarsDesc> data = new ArrayList<>();\n+        for (Object[] row : procRows) {\n+            ProcessInstanceWithVarsDesc pwv = toProcessInstanceWithVarsDesc(row);\n+\n+            Map<String, Object> vars = new HashMap<>();\n+            pwv.setVariables(vars);\n+            while (currentVarIdx < varRows.size() && row[0].equals(varRows.get(currentVarIdx)[0])) {\n+                String name = (String) varRows.get(currentVarIdx)[1];\n+                if (name.startsWith(varPrefix)) {\n+                    vars.put(name.substring(varPrefix.length()), varRows.get(currentVarIdx)[2]);\n+                }\n+                currentVarIdx++;\n+            }\n+            data.add(pwv);\n+        }\n+\n+        entityManager.close();\n+        return data;\n+    }\n+\n+    private ProcessInstanceWithVarsDesc toProcessInstanceWithVarsDesc(Object[] row) {\n+        return new ProcessInstanceWithVarsDesc(((Number) row[0]).longValue(),\n+                                               (String) row[1],\n+                                               (String) row[2],\n+                                               (String) row[3],\n+                                               ((Number) row[4]).intValue(),\n+                                               (String) row[5],\n+                                               (Date) row[6],\n+                                               (String) row[7],\n+                                               (String) row[8]);\n+    }\n+    private void addWhereExpression(StringBuilder where) {\n+        where.append(where.length() == 0 ? \"WHERE \" : \" AND \");\n+    }\n+\n+    public List<org.jbpm.services.api.model.UserTaskInstanceWithPotOwnerDesc> queryUserTasksByVariables(Map<String, Object> attributes,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1e57dd6f9a77d2e636949457815115ca83acc4dc"}, "originalPosition": 149}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTcxOTIzNw==", "bodyText": "We will need to check if there is any performance issue as there are several calls to DB.", "url": "https://github.com/kiegroup/jbpm/pull/1615#discussion_r401719237", "createdAt": "2020-04-01T15:47:54Z", "author": {"login": "afalhambra"}, "path": "jbpm-services/jbpm-kie-services/src/main/java/org/jbpm/kie/services/impl/AbstractAdvanceRuntimeDataServiceImpl.java", "diffHunk": "@@ -0,0 +1,306 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.jbpm.kie.services.impl;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import javax.persistence.EntityManager;\n+import javax.persistence.EntityManagerFactory;\n+import javax.persistence.Query;\n+\n+import org.jbpm.kie.services.impl.model.ProcessInstanceWithVarsDesc;\n+import org.jbpm.kie.services.impl.model.UserTaskInstanceWithPotOwnerDesc;\n+import org.jbpm.shared.services.impl.QueryManager;\n+import org.jbpm.shared.services.impl.TransactionalCommandService;\n+import org.jbpm.shared.services.impl.commands.QueryNameCommand;\n+import org.kie.api.runtime.query.QueryContext;\n+\n+import static java.util.Collections.singletonMap;\n+\n+public abstract class AbstractAdvanceRuntimeDataServiceImpl {\n+\n+    private EntityManagerFactory emf;\n+    private TransactionalCommandService commandService;\n+\n+    public AbstractAdvanceRuntimeDataServiceImpl() {\n+        QueryManager.get().addNamedQueries(\"META-INF/Servicesorm.xml\");\n+    }\n+    public void setCommandService(TransactionalCommandService commandService) {\n+        this.commandService = commandService;\n+    }\n+\n+    public void setEmf(EntityManagerFactory emf) {\n+        this.emf = emf;\n+    }\n+\n+\n+    public List<org.jbpm.services.api.model.ProcessInstanceWithVarsDesc> queryProcessByVariables(Map<String, Object> attributes,\n+                                                                                                 Map<String, Object> variables,\n+                                                                                                 int processType,\n+                                                                                                 String varPrefix,\n+                                                                                                 QueryContext queryContext) {\n+        EntityManager entityManager = emf.createEntityManager();\n+\n+        // first step is to filter the data creating a derived tables and pivoting var - rows to columns (only the variables we are interested to filter)\n+        StringBuilder where = new StringBuilder();\n+        StringBuilder derivedTables = new StringBuilder();\n+        for (Map.Entry<String, Object> var : variables.entrySet()) {\n+            String alias = \"TABLE_\" + var.getKey();\n+            String varName = var.getKey();\n+\n+            derivedTables.append(\"LEFT JOIN (\" +\n+                                 \"SELECT A1.processId, A1.processInstanceId, A1.variableId AS NAME, A1.value AS VALUE \\n\" +\n+                                 \"FROM VariableInstanceLog A1 \\n\" +\n+                                 \"LEFT JOIN VariableInstanceLog A2 ON A1.processId = A2.processId AND A1.processInstanceId = A2.processInstanceId AND A1.variableInstanceId = A2.variableInstanceId AND A2.log_date < A1.log_date  \\n\" +\n+                                 \"WHERE A2.log_date IS NULL \\n\" +\n+                                 \") \" + alias + \" ON \" + alias + \".processId = pil.processId AND \" + alias + \".processInstanceId = pil.processInstanceId \\n\");\n+\n+            addWhereExpression(where);\n+            where.append(alias + \".NAME = :NAME_\" + varName + \" AND \" + alias + \".VALUE= :VALUE_\" + varName + \"\\n\");\n+        }\n+\n+\n+        for (Map.Entry<String, Object> entry : attributes.entrySet()) {\n+            addWhereExpression(where);\n+            where.append(\" pil.\" + entry.getKey() + \" = :ATTR_\" + entry.getKey() + \" \");\n+        }\n+\n+        addWhereExpression(where);\n+        where.append(\" pil.processType = :processType \");\n+\n+        String procSQLString = \"SELECT DISTINCT pil.processInstanceId FROM ProcessInstanceLog pil \\n \" + derivedTables + where + \" ORDER BY pil.processInstanceId ASC \";\n+        procSQLString += (queryContext.getCount() > 0) ? \" LIMIT \" + queryContext.getCount() + \" OFFSET \" + queryContext.getOffset() + \" \\n\" : \"\";\n+\n+        Query query = entityManager.createNativeQuery(procSQLString);\n+        for (Map.Entry<String, Object> var : variables.entrySet()) {\n+            query.setParameter(\"NAME_\" + var.getKey(), varPrefix + var.getKey());\n+            query.setParameter(\"VALUE_\" + var.getKey(), var.getValue());\n+        }\n+        for (Map.Entry<String, Object> entry : attributes.entrySet()) {\n+            query.setParameter(\"ATTR_\" + entry.getKey(), entry.getValue());\n+        }\n+        query.setParameter(\"processType\", processType);\n+\n+        List<Number> ids = query.getResultList();\n+        if (ids.isEmpty()) {\n+            return Collections.emptyList();\n+        }\n+\n+        // now we get the information\n+\n+        List<Object[]> procRows = commandService.execute(new QueryNameCommand<List<Object[]>>(\"GeProcessInstanceByIdList\", singletonMap(\"idList\", ids)));\n+        List<Object[]> varRows = commandService.execute(new QueryNameCommand<List<Object[]>>(\"GeVariablesByProcessInstanceIdList\", singletonMap(\"idList\", ids)));\n+\n+        int currentVarIdx = 0;\n+        List<org.jbpm.services.api.model.ProcessInstanceWithVarsDesc> data = new ArrayList<>();\n+        for (Object[] row : procRows) {\n+            ProcessInstanceWithVarsDesc pwv = toProcessInstanceWithVarsDesc(row);\n+\n+            Map<String, Object> vars = new HashMap<>();\n+            pwv.setVariables(vars);\n+            while (currentVarIdx < varRows.size() && row[0].equals(varRows.get(currentVarIdx)[0])) {\n+                String name = (String) varRows.get(currentVarIdx)[1];\n+                if (name.startsWith(varPrefix)) {\n+                    vars.put(name.substring(varPrefix.length()), varRows.get(currentVarIdx)[2]);\n+                }\n+                currentVarIdx++;\n+            }\n+            data.add(pwv);\n+        }\n+\n+        entityManager.close();\n+        return data;\n+    }\n+\n+    private ProcessInstanceWithVarsDesc toProcessInstanceWithVarsDesc(Object[] row) {\n+        return new ProcessInstanceWithVarsDesc(((Number) row[0]).longValue(),\n+                                               (String) row[1],\n+                                               (String) row[2],\n+                                               (String) row[3],\n+                                               ((Number) row[4]).intValue(),\n+                                               (String) row[5],\n+                                               (Date) row[6],\n+                                               (String) row[7],\n+                                               (String) row[8]);\n+    }\n+    private void addWhereExpression(StringBuilder where) {\n+        where.append(where.length() == 0 ? \"WHERE \" : \" AND \");\n+    }\n+\n+    public List<org.jbpm.services.api.model.UserTaskInstanceWithPotOwnerDesc> queryUserTasksByVariables(Map<String, Object> attributes,\n+                                                                                                        Map<String, Object> variables,\n+                                                                                                        Map<String, Object> processVariables,\n+                                                                                                        List<String> owners,\n+                                                                                                        int processType,\n+                                                                                                        String varPrefix,\n+                                                                                                        QueryContext queryContext) {\n+        EntityManager entityManager = emf.createEntityManager();\n+\n+        StringBuilder where = new StringBuilder();\n+        StringBuilder derivedTables = new StringBuilder();\n+        for (Map.Entry<String, Object> var : variables.entrySet()) {\n+            String alias = \"V_TABLE_\" + var.getKey();\n+            String varName = var.getKey();\n+            derivedTables.append(\"INNER JOIN (\\n\" +\n+                                  \"SELECT taskId, name, value \\n\" +\n+                                  \"FROM TaskVariableImpl \\n\" +\n+                                  \"WHERE type = 0\\n\" +\n+                                 \") \" + alias + \" ON \" + alias + \".taskId = task.id  \\n\");\n+\n+\n+            addWhereExpression(where);\n+            where.append(alias + \".NAME = :V_NAME_\" + varName + \" AND \" + alias + \".VALUE= :V_VALUE_\" + varName + \"\\n\");\n+        }\n+\n+        for (Map.Entry<String, Object> var : processVariables.entrySet()) {\n+            String alias = \"P_TABLE_\" + var.getKey();\n+            String varName = var.getKey();\n+\n+            derivedTables.append(\"LEFT JOIN (\" +\n+                                 \"SELECT A1.processId, A1.processInstanceId, A1.variableId AS NAME, A1.value AS VALUE \\n\" +\n+                                 \"FROM VariableInstanceLog A1 \\n\" +\n+                                 \"LEFT JOIN VariableInstanceLog A2 ON A1.processId = A2.processId AND A1.processInstanceId = A2.processInstanceId AND A1.variableInstanceId = A2.variableInstanceId AND A2.log_date < A1.log_date  \\n\" +\n+                                 \"WHERE A2.log_date IS NULL \\n\" +\n+                                 \") \" + alias + \" ON \" + alias + \".processId = pil.processId AND \" + alias + \".processInstanceId = pil.processInstanceId \\n\");\n+\n+            addWhereExpression(where);\n+            where.append(alias + \".NAME = :P_NAME_\" + varName + \" AND \" + alias + \".VALUE= :P_VALUE_\" + varName + \"\\n\");\n+        }\n+\n+        if (!owners.isEmpty()) {\n+            derivedTables.append(\"INNER JOIN ( \\n\" +\n+                             \"           SELECT DISTINCT po.task_id \\n\" +\n+                             \"           FROM PeopleAssignments_PotOwners po \\n\" +\n+                             \"           WHERE po.entity_id IN (:owners) \\n\" +\n+                             \"           GROUP BY po.task_id \\n\" +\n+                             \"           HAVING COUNT(po.entity_id) = :num_owners \\n\" +\n+                                 \") AS pot ON pot.task_id = task.id \");\n+        }\n+\n+        for (Map.Entry<String, Object> entry : attributes.entrySet()) {\n+            addWhereExpression(where);\n+            where.append(\" task.\" + entry.getKey() + \" = :ATTR_\" + entry.getKey() + \" \");\n+        }\n+\n+        addWhereExpression(where);\n+        where.append(\" pil.processType = :processType \");\n+\n+        String procSQLString = \"SELECT DISTINCT task.id FROM Task task INNER JOIN ProcessInstanceLog pil ON pil.processInstanceId = task.processInstanceId \\n \" + derivedTables + where + \" ORDER BY id ASC \";\n+        procSQLString += (queryContext.getCount() > 0) ? \" LIMIT \" + queryContext.getCount() + \" OFFSET \" + queryContext.getOffset() + \"\\n\" : \"\";\n+\n+        Query query = entityManager.createNativeQuery(procSQLString);\n+        for (Map.Entry<String, Object> var : variables.entrySet()) {\n+            query.setParameter(\"V_NAME_\" + var.getKey(), var.getKey());\n+            query.setParameter(\"V_VALUE_\" + var.getKey(), var.getValue());\n+        }\n+        for (Map.Entry<String, Object> var : processVariables.entrySet()) {\n+            query.setParameter(\"P_NAME_\" + var.getKey(), varPrefix + var.getKey());\n+            query.setParameter(\"P_VALUE_\" + var.getKey(), var.getValue());\n+        }\n+        for (Map.Entry<String, Object> entry : attributes.entrySet()) {\n+            query.setParameter(\"ATTR_\" + entry.getKey(), entry.getValue());\n+        }\n+        if (!owners.isEmpty()) {\n+            query.setParameter(\"num_owners\", owners.size());\n+            query.setParameter(\"owners\", owners);\n+        }\n+        query.setParameter(\"processType\", processType);\n+\n+        List<Number> ids = query.getResultList();\n+        if (ids.isEmpty()) {\n+            return Collections.emptyList();\n+        }\n+\n+\n+        // query data\n+        List<Object[]> taskRows = commandService.execute(new QueryNameCommand<List<Object[]>>(\"GetTasksByIdList\", singletonMap(\"idList\", ids)));\n+        List<Object[]> varRows = commandService.execute(new QueryNameCommand<List<Object[]>>(\"GetTaskVariablesByTaskIdList\", singletonMap(\"idList\", ids)));\n+        List<Object[]> potRows = commandService.execute(new QueryNameCommand<List<Object[]>>(\"GetPotentialOwnersByTaskIdList\", singletonMap(\"idList\", ids)));\n+        List<Object[]> varProcSQLRows = commandService.execute(new QueryNameCommand<List<Object[]>>(\"GeProcessVariablesByTaskIdList\", singletonMap(\"idList\", ids)));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1e57dd6f9a77d2e636949457815115ca83acc4dc"}, "originalPosition": 238}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTc0MTcxNg==", "bodyText": "Shouldn't we have some kind of control about offset and count? A wrong combination of these might not return any results found in the query when for instance offset is greater than count (bear in mind that default count in a querycontext object is 10)", "url": "https://github.com/kiegroup/jbpm/pull/1615#discussion_r401741716", "createdAt": "2020-04-01T16:19:47Z", "author": {"login": "afalhambra"}, "path": "jbpm-services/jbpm-kie-services/src/main/java/org/jbpm/kie/services/impl/AbstractAdvanceRuntimeDataServiceImpl.java", "diffHunk": "@@ -0,0 +1,306 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.jbpm.kie.services.impl;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import javax.persistence.EntityManager;\n+import javax.persistence.EntityManagerFactory;\n+import javax.persistence.Query;\n+\n+import org.jbpm.kie.services.impl.model.ProcessInstanceWithVarsDesc;\n+import org.jbpm.kie.services.impl.model.UserTaskInstanceWithPotOwnerDesc;\n+import org.jbpm.shared.services.impl.QueryManager;\n+import org.jbpm.shared.services.impl.TransactionalCommandService;\n+import org.jbpm.shared.services.impl.commands.QueryNameCommand;\n+import org.kie.api.runtime.query.QueryContext;\n+\n+import static java.util.Collections.singletonMap;\n+\n+public abstract class AbstractAdvanceRuntimeDataServiceImpl {\n+\n+    private EntityManagerFactory emf;\n+    private TransactionalCommandService commandService;\n+\n+    public AbstractAdvanceRuntimeDataServiceImpl() {\n+        QueryManager.get().addNamedQueries(\"META-INF/Servicesorm.xml\");\n+    }\n+    public void setCommandService(TransactionalCommandService commandService) {\n+        this.commandService = commandService;\n+    }\n+\n+    public void setEmf(EntityManagerFactory emf) {\n+        this.emf = emf;\n+    }\n+\n+\n+    public List<org.jbpm.services.api.model.ProcessInstanceWithVarsDesc> queryProcessByVariables(Map<String, Object> attributes,\n+                                                                                                 Map<String, Object> variables,\n+                                                                                                 int processType,\n+                                                                                                 String varPrefix,\n+                                                                                                 QueryContext queryContext) {\n+        EntityManager entityManager = emf.createEntityManager();\n+\n+        // first step is to filter the data creating a derived tables and pivoting var - rows to columns (only the variables we are interested to filter)\n+        StringBuilder where = new StringBuilder();\n+        StringBuilder derivedTables = new StringBuilder();\n+        for (Map.Entry<String, Object> var : variables.entrySet()) {\n+            String alias = \"TABLE_\" + var.getKey();\n+            String varName = var.getKey();\n+\n+            derivedTables.append(\"LEFT JOIN (\" +\n+                                 \"SELECT A1.processId, A1.processInstanceId, A1.variableId AS NAME, A1.value AS VALUE \\n\" +\n+                                 \"FROM VariableInstanceLog A1 \\n\" +\n+                                 \"LEFT JOIN VariableInstanceLog A2 ON A1.processId = A2.processId AND A1.processInstanceId = A2.processInstanceId AND A1.variableInstanceId = A2.variableInstanceId AND A2.log_date < A1.log_date  \\n\" +\n+                                 \"WHERE A2.log_date IS NULL \\n\" +\n+                                 \") \" + alias + \" ON \" + alias + \".processId = pil.processId AND \" + alias + \".processInstanceId = pil.processInstanceId \\n\");\n+\n+            addWhereExpression(where);\n+            where.append(alias + \".NAME = :NAME_\" + varName + \" AND \" + alias + \".VALUE= :VALUE_\" + varName + \"\\n\");\n+        }\n+\n+\n+        for (Map.Entry<String, Object> entry : attributes.entrySet()) {\n+            addWhereExpression(where);\n+            where.append(\" pil.\" + entry.getKey() + \" = :ATTR_\" + entry.getKey() + \" \");\n+        }\n+\n+        addWhereExpression(where);\n+        where.append(\" pil.processType = :processType \");\n+\n+        String procSQLString = \"SELECT DISTINCT pil.processInstanceId FROM ProcessInstanceLog pil \\n \" + derivedTables + where + \" ORDER BY pil.processInstanceId ASC \";\n+        procSQLString += (queryContext.getCount() > 0) ? \" LIMIT \" + queryContext.getCount() + \" OFFSET \" + queryContext.getOffset() + \" \\n\" : \"\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1e57dd6f9a77d2e636949457815115ca83acc4dc"}, "originalPosition": 91}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTc0NDU3NQ==", "bodyText": "I would use VariableType.INPUT instead of hardcoding values in the query.", "url": "https://github.com/kiegroup/jbpm/pull/1615#discussion_r401744575", "createdAt": "2020-04-01T16:23:55Z", "author": {"login": "afalhambra"}, "path": "jbpm-services/jbpm-kie-services/src/main/java/org/jbpm/kie/services/impl/AbstractAdvanceRuntimeDataServiceImpl.java", "diffHunk": "@@ -0,0 +1,306 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.jbpm.kie.services.impl;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import javax.persistence.EntityManager;\n+import javax.persistence.EntityManagerFactory;\n+import javax.persistence.Query;\n+\n+import org.jbpm.kie.services.impl.model.ProcessInstanceWithVarsDesc;\n+import org.jbpm.kie.services.impl.model.UserTaskInstanceWithPotOwnerDesc;\n+import org.jbpm.shared.services.impl.QueryManager;\n+import org.jbpm.shared.services.impl.TransactionalCommandService;\n+import org.jbpm.shared.services.impl.commands.QueryNameCommand;\n+import org.kie.api.runtime.query.QueryContext;\n+\n+import static java.util.Collections.singletonMap;\n+\n+public abstract class AbstractAdvanceRuntimeDataServiceImpl {\n+\n+    private EntityManagerFactory emf;\n+    private TransactionalCommandService commandService;\n+\n+    public AbstractAdvanceRuntimeDataServiceImpl() {\n+        QueryManager.get().addNamedQueries(\"META-INF/Servicesorm.xml\");\n+    }\n+    public void setCommandService(TransactionalCommandService commandService) {\n+        this.commandService = commandService;\n+    }\n+\n+    public void setEmf(EntityManagerFactory emf) {\n+        this.emf = emf;\n+    }\n+\n+\n+    public List<org.jbpm.services.api.model.ProcessInstanceWithVarsDesc> queryProcessByVariables(Map<String, Object> attributes,\n+                                                                                                 Map<String, Object> variables,\n+                                                                                                 int processType,\n+                                                                                                 String varPrefix,\n+                                                                                                 QueryContext queryContext) {\n+        EntityManager entityManager = emf.createEntityManager();\n+\n+        // first step is to filter the data creating a derived tables and pivoting var - rows to columns (only the variables we are interested to filter)\n+        StringBuilder where = new StringBuilder();\n+        StringBuilder derivedTables = new StringBuilder();\n+        for (Map.Entry<String, Object> var : variables.entrySet()) {\n+            String alias = \"TABLE_\" + var.getKey();\n+            String varName = var.getKey();\n+\n+            derivedTables.append(\"LEFT JOIN (\" +\n+                                 \"SELECT A1.processId, A1.processInstanceId, A1.variableId AS NAME, A1.value AS VALUE \\n\" +\n+                                 \"FROM VariableInstanceLog A1 \\n\" +\n+                                 \"LEFT JOIN VariableInstanceLog A2 ON A1.processId = A2.processId AND A1.processInstanceId = A2.processInstanceId AND A1.variableInstanceId = A2.variableInstanceId AND A2.log_date < A1.log_date  \\n\" +\n+                                 \"WHERE A2.log_date IS NULL \\n\" +\n+                                 \") \" + alias + \" ON \" + alias + \".processId = pil.processId AND \" + alias + \".processInstanceId = pil.processInstanceId \\n\");\n+\n+            addWhereExpression(where);\n+            where.append(alias + \".NAME = :NAME_\" + varName + \" AND \" + alias + \".VALUE= :VALUE_\" + varName + \"\\n\");\n+        }\n+\n+\n+        for (Map.Entry<String, Object> entry : attributes.entrySet()) {\n+            addWhereExpression(where);\n+            where.append(\" pil.\" + entry.getKey() + \" = :ATTR_\" + entry.getKey() + \" \");\n+        }\n+\n+        addWhereExpression(where);\n+        where.append(\" pil.processType = :processType \");\n+\n+        String procSQLString = \"SELECT DISTINCT pil.processInstanceId FROM ProcessInstanceLog pil \\n \" + derivedTables + where + \" ORDER BY pil.processInstanceId ASC \";\n+        procSQLString += (queryContext.getCount() > 0) ? \" LIMIT \" + queryContext.getCount() + \" OFFSET \" + queryContext.getOffset() + \" \\n\" : \"\";\n+\n+        Query query = entityManager.createNativeQuery(procSQLString);\n+        for (Map.Entry<String, Object> var : variables.entrySet()) {\n+            query.setParameter(\"NAME_\" + var.getKey(), varPrefix + var.getKey());\n+            query.setParameter(\"VALUE_\" + var.getKey(), var.getValue());\n+        }\n+        for (Map.Entry<String, Object> entry : attributes.entrySet()) {\n+            query.setParameter(\"ATTR_\" + entry.getKey(), entry.getValue());\n+        }\n+        query.setParameter(\"processType\", processType);\n+\n+        List<Number> ids = query.getResultList();\n+        if (ids.isEmpty()) {\n+            return Collections.emptyList();\n+        }\n+\n+        // now we get the information\n+\n+        List<Object[]> procRows = commandService.execute(new QueryNameCommand<List<Object[]>>(\"GeProcessInstanceByIdList\", singletonMap(\"idList\", ids)));\n+        List<Object[]> varRows = commandService.execute(new QueryNameCommand<List<Object[]>>(\"GeVariablesByProcessInstanceIdList\", singletonMap(\"idList\", ids)));\n+\n+        int currentVarIdx = 0;\n+        List<org.jbpm.services.api.model.ProcessInstanceWithVarsDesc> data = new ArrayList<>();\n+        for (Object[] row : procRows) {\n+            ProcessInstanceWithVarsDesc pwv = toProcessInstanceWithVarsDesc(row);\n+\n+            Map<String, Object> vars = new HashMap<>();\n+            pwv.setVariables(vars);\n+            while (currentVarIdx < varRows.size() && row[0].equals(varRows.get(currentVarIdx)[0])) {\n+                String name = (String) varRows.get(currentVarIdx)[1];\n+                if (name.startsWith(varPrefix)) {\n+                    vars.put(name.substring(varPrefix.length()), varRows.get(currentVarIdx)[2]);\n+                }\n+                currentVarIdx++;\n+            }\n+            data.add(pwv);\n+        }\n+\n+        entityManager.close();\n+        return data;\n+    }\n+\n+    private ProcessInstanceWithVarsDesc toProcessInstanceWithVarsDesc(Object[] row) {\n+        return new ProcessInstanceWithVarsDesc(((Number) row[0]).longValue(),\n+                                               (String) row[1],\n+                                               (String) row[2],\n+                                               (String) row[3],\n+                                               ((Number) row[4]).intValue(),\n+                                               (String) row[5],\n+                                               (Date) row[6],\n+                                               (String) row[7],\n+                                               (String) row[8]);\n+    }\n+    private void addWhereExpression(StringBuilder where) {\n+        where.append(where.length() == 0 ? \"WHERE \" : \" AND \");\n+    }\n+\n+    public List<org.jbpm.services.api.model.UserTaskInstanceWithPotOwnerDesc> queryUserTasksByVariables(Map<String, Object> attributes,\n+                                                                                                        Map<String, Object> variables,\n+                                                                                                        Map<String, Object> processVariables,\n+                                                                                                        List<String> owners,\n+                                                                                                        int processType,\n+                                                                                                        String varPrefix,\n+                                                                                                        QueryContext queryContext) {\n+        EntityManager entityManager = emf.createEntityManager();\n+\n+        StringBuilder where = new StringBuilder();\n+        StringBuilder derivedTables = new StringBuilder();\n+        for (Map.Entry<String, Object> var : variables.entrySet()) {\n+            String alias = \"V_TABLE_\" + var.getKey();\n+            String varName = var.getKey();\n+            derivedTables.append(\"INNER JOIN (\\n\" +\n+                                  \"SELECT taskId, name, value \\n\" +\n+                                  \"FROM TaskVariableImpl \\n\" +\n+                                  \"WHERE type = 0\\n\" +", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1e57dd6f9a77d2e636949457815115ca83acc4dc"}, "originalPosition": 166}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjI2MzM4OA==", "bodyText": "<String, Object> not needed.", "url": "https://github.com/kiegroup/jbpm/pull/1615#discussion_r402263388", "createdAt": "2020-04-02T12:10:23Z", "author": {"login": "afalhambra"}, "path": "jbpm-services/jbpm-kie-services/src/main/java/org/jbpm/kie/services/impl/model/UserTaskInstanceWithPotOwnerDesc.java", "diffHunk": "@@ -156,5 +158,37 @@ public String getProcessInstanceDescription() {\n     public void setProcessInstanceDescription(String processInstanceDescription) {\n         this.processInstanceDescription = processInstanceDescription;\n     }\n+\n+    public void addProcessVariable(String variable, Object variableValue) {\n+        if (this.processVariables == null) {\n+            this.processVariables = new HashMap<String, Object>();\n+        }\n+        this.processVariables.put(variable, variableValue);\n+    }\n+\n+    @Override\n+    public Map<String, Object> getProcessVariables() {\n+        return processVariables;\n+    }\n+\n+    public void setProcessVariables(Map<String, Object> processVariables) {\n+        this.processVariables = processVariables;\n+    }\n+\n+    public void addExtraData(String variable, Object variableValue) {\n+        if (this.data == null) {\n+            this.data = new HashMap<String, Object>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1e57dd6f9a77d2e636949457815115ca83acc4dc"}, "originalPosition": 32}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjI2MzQ5NQ==", "bodyText": "<String, Object> not needed.", "url": "https://github.com/kiegroup/jbpm/pull/1615#discussion_r402263495", "createdAt": "2020-04-02T12:10:34Z", "author": {"login": "afalhambra"}, "path": "jbpm-services/jbpm-kie-services/src/main/java/org/jbpm/kie/services/impl/model/UserTaskInstanceWithPotOwnerDesc.java", "diffHunk": "@@ -156,5 +158,37 @@ public String getProcessInstanceDescription() {\n     public void setProcessInstanceDescription(String processInstanceDescription) {\n         this.processInstanceDescription = processInstanceDescription;\n     }\n+\n+    public void addProcessVariable(String variable, Object variableValue) {\n+        if (this.processVariables == null) {\n+            this.processVariables = new HashMap<String, Object>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1e57dd6f9a77d2e636949457815115ca83acc4dc"}, "originalPosition": 16}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjI2NDYyMw==", "bodyText": "Collections.<String, Object> singletonMap can be replaced with just Collections.singletonMap", "url": "https://github.com/kiegroup/jbpm/pull/1615#discussion_r402264623", "createdAt": "2020-04-02T12:12:50Z", "author": {"login": "afalhambra"}, "path": "jbpm-services/jbpm-kie-services/src/test/java/org/jbpm/kie/services/test/AdvanceRuntimeDataServiceImplTest.java", "diffHunk": "@@ -0,0 +1,219 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.jbpm.kie.services.test;\n+\n+import java.io.File;\n+import java.io.FileOutputStream;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.drools.compiler.kie.builder.impl.InternalKieModule;\n+import org.jbpm.kie.services.impl.KModuleDeploymentUnit;\n+import org.jbpm.kie.test.util.AbstractKieServicesBaseTest;\n+import org.jbpm.services.api.ProcessInstanceNotFoundException;\n+import org.jbpm.services.api.model.DeploymentUnit;\n+import org.jbpm.services.api.model.ProcessInstanceWithVarsDesc;\n+import org.jbpm.services.api.model.UserTaskInstanceWithPotOwnerDesc;\n+import org.junit.After;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.kie.api.KieServices;\n+import org.kie.api.builder.ReleaseId;\n+import org.kie.api.runtime.process.ProcessInstance;\n+import org.kie.internal.query.QueryContext;\n+import org.kie.scanner.KieMavenRepository;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static java.util.Collections.emptyList;\n+import static java.util.Collections.emptyMap;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertNull;\n+import static org.kie.scanner.KieMavenRepository.getKieMavenRepository;\n+\n+public class AdvanceRuntimeDataServiceImplTest extends AbstractKieServicesBaseTest {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(AdvanceRuntimeDataServiceImplTest.class);\n+\n+    private List<DeploymentUnit> units = new ArrayList<DeploymentUnit>();\n+    protected String correctUser = \"testUser\";\n+    protected String wrongUser = \"wrongUser\";\n+\n+    private List<Long> processIds;\n+    private KModuleDeploymentUnit deploymentUnit = null;\n+\n+    @Before\n+    public void prepare() {\n+\n+        configureServices();\n+        logger.debug(\"Preparing kjar\");\n+        KieServices ks = KieServices.Factory.get();\n+        ReleaseId releaseId = ks.newReleaseId(GROUP_ID, ARTIFACT_ID, VERSION);\n+        List<String> processes = new ArrayList<String>();\n+        processes.add(\"repo/processes/general/SingleHumanTaskWithVarsA.bpmn2\");\n+        processes.add(\"repo/processes/general/SingleHumanTaskWithVarsB.bpmn2\");\n+\n+        InternalKieModule kJar1 = createKieJar(ks, releaseId, processes);\n+        File pom = new File(\"target/kmodule\", \"pom.xml\");\n+        pom.getParentFile().mkdir();\n+        try (FileOutputStream fs = new FileOutputStream(pom);) {\n+            fs.write(getPom(releaseId).getBytes());\n+        } catch (Exception e) {\n+\n+        }\n+        KieMavenRepository repository = getKieMavenRepository();\n+        repository.deployArtifact(releaseId, kJar1, pom);\n+\n+        assertNotNull(deploymentService);\n+\n+        deploymentUnit = new KModuleDeploymentUnit(GROUP_ID, ARTIFACT_ID, VERSION);\n+\n+        deploymentService.deploy(deploymentUnit);\n+        units.add(deploymentUnit);\n+        assertNotNull(processService);\n+\n+        processIds = new ArrayList<>();\n+        for (int i = 0; i < 10; i++) {\n+            Map<String, Object> inputsA1 = new HashMap<>();\n+            inputsA1.put(\"var_a\", \"a\" + (i % 3));\n+            inputsA1.put(\"var_b\", (i % 3));\n+            processIds.add(processService.startProcess(deploymentUnit.getIdentifier(), \"test.test_A\", inputsA1));\n+        }\n+        for (int i = 0; i < 10; i++) {\n+            Map<String, Object> inputsB1 = new HashMap<>();\n+            inputsB1.put(\"var_a\", \"b\" + (i % 3));\n+            inputsB1.put(\"var_b\", (i % 3));\n+            processIds.add(processService.startProcess(deploymentUnit.getIdentifier(), \"test.test_B\", inputsB1));\n+        }\n+    }\n+\n+    @After\n+    public void cleanup() {\n+        for (Long processInstanceId : processIds) {\n+            try {\n+                // let's abort process instance to leave the system in clear state\n+                processService.abortProcessInstance(processInstanceId);\n+\n+                ProcessInstance pi = processService.getProcessInstance(processInstanceId);\n+                assertNull(pi);\n+            } catch (ProcessInstanceNotFoundException e) {\n+                // ignore it as it was already completed/aborted\n+            }\n+        }\n+        cleanupSingletonSessionId();\n+        if (units != null && !units.isEmpty()) {\n+            for (DeploymentUnit unit : units) {\n+                try {\n+                    deploymentService.undeploy(unit);\n+                } catch (Exception e) {\n+                    // do nothing in case of some failed tests to avoid next test to fail as well\n+                }\n+            }\n+            units.clear();\n+        }\n+        close();\n+    }\n+\n+    @Test\n+    public void testQueryProcessByVariables() {\n+        Map<String, Object> variables = Collections.<String, Object> singletonMap(\"var_a\", \"a1\");\n+        Map<String, Object> attributes = Collections.<String, Object> singletonMap(\"processId\", \"test.test_A\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1e57dd6f9a77d2e636949457815115ca83acc4dc"}, "originalPosition": 139}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjI2NDc2OQ==", "bodyText": "Collections.<String, Object> singletonMap can be replaced with just Collections.singletonMap", "url": "https://github.com/kiegroup/jbpm/pull/1615#discussion_r402264769", "createdAt": "2020-04-02T12:13:06Z", "author": {"login": "afalhambra"}, "path": "jbpm-services/jbpm-kie-services/src/test/java/org/jbpm/kie/services/test/AdvanceRuntimeDataServiceImplTest.java", "diffHunk": "@@ -0,0 +1,219 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.jbpm.kie.services.test;\n+\n+import java.io.File;\n+import java.io.FileOutputStream;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.drools.compiler.kie.builder.impl.InternalKieModule;\n+import org.jbpm.kie.services.impl.KModuleDeploymentUnit;\n+import org.jbpm.kie.test.util.AbstractKieServicesBaseTest;\n+import org.jbpm.services.api.ProcessInstanceNotFoundException;\n+import org.jbpm.services.api.model.DeploymentUnit;\n+import org.jbpm.services.api.model.ProcessInstanceWithVarsDesc;\n+import org.jbpm.services.api.model.UserTaskInstanceWithPotOwnerDesc;\n+import org.junit.After;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.kie.api.KieServices;\n+import org.kie.api.builder.ReleaseId;\n+import org.kie.api.runtime.process.ProcessInstance;\n+import org.kie.internal.query.QueryContext;\n+import org.kie.scanner.KieMavenRepository;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static java.util.Collections.emptyList;\n+import static java.util.Collections.emptyMap;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertNull;\n+import static org.kie.scanner.KieMavenRepository.getKieMavenRepository;\n+\n+public class AdvanceRuntimeDataServiceImplTest extends AbstractKieServicesBaseTest {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(AdvanceRuntimeDataServiceImplTest.class);\n+\n+    private List<DeploymentUnit> units = new ArrayList<DeploymentUnit>();\n+    protected String correctUser = \"testUser\";\n+    protected String wrongUser = \"wrongUser\";\n+\n+    private List<Long> processIds;\n+    private KModuleDeploymentUnit deploymentUnit = null;\n+\n+    @Before\n+    public void prepare() {\n+\n+        configureServices();\n+        logger.debug(\"Preparing kjar\");\n+        KieServices ks = KieServices.Factory.get();\n+        ReleaseId releaseId = ks.newReleaseId(GROUP_ID, ARTIFACT_ID, VERSION);\n+        List<String> processes = new ArrayList<String>();\n+        processes.add(\"repo/processes/general/SingleHumanTaskWithVarsA.bpmn2\");\n+        processes.add(\"repo/processes/general/SingleHumanTaskWithVarsB.bpmn2\");\n+\n+        InternalKieModule kJar1 = createKieJar(ks, releaseId, processes);\n+        File pom = new File(\"target/kmodule\", \"pom.xml\");\n+        pom.getParentFile().mkdir();\n+        try (FileOutputStream fs = new FileOutputStream(pom);) {\n+            fs.write(getPom(releaseId).getBytes());\n+        } catch (Exception e) {\n+\n+        }\n+        KieMavenRepository repository = getKieMavenRepository();\n+        repository.deployArtifact(releaseId, kJar1, pom);\n+\n+        assertNotNull(deploymentService);\n+\n+        deploymentUnit = new KModuleDeploymentUnit(GROUP_ID, ARTIFACT_ID, VERSION);\n+\n+        deploymentService.deploy(deploymentUnit);\n+        units.add(deploymentUnit);\n+        assertNotNull(processService);\n+\n+        processIds = new ArrayList<>();\n+        for (int i = 0; i < 10; i++) {\n+            Map<String, Object> inputsA1 = new HashMap<>();\n+            inputsA1.put(\"var_a\", \"a\" + (i % 3));\n+            inputsA1.put(\"var_b\", (i % 3));\n+            processIds.add(processService.startProcess(deploymentUnit.getIdentifier(), \"test.test_A\", inputsA1));\n+        }\n+        for (int i = 0; i < 10; i++) {\n+            Map<String, Object> inputsB1 = new HashMap<>();\n+            inputsB1.put(\"var_a\", \"b\" + (i % 3));\n+            inputsB1.put(\"var_b\", (i % 3));\n+            processIds.add(processService.startProcess(deploymentUnit.getIdentifier(), \"test.test_B\", inputsB1));\n+        }\n+    }\n+\n+    @After\n+    public void cleanup() {\n+        for (Long processInstanceId : processIds) {\n+            try {\n+                // let's abort process instance to leave the system in clear state\n+                processService.abortProcessInstance(processInstanceId);\n+\n+                ProcessInstance pi = processService.getProcessInstance(processInstanceId);\n+                assertNull(pi);\n+            } catch (ProcessInstanceNotFoundException e) {\n+                // ignore it as it was already completed/aborted\n+            }\n+        }\n+        cleanupSingletonSessionId();\n+        if (units != null && !units.isEmpty()) {\n+            for (DeploymentUnit unit : units) {\n+                try {\n+                    deploymentService.undeploy(unit);\n+                } catch (Exception e) {\n+                    // do nothing in case of some failed tests to avoid next test to fail as well\n+                }\n+            }\n+            units.clear();\n+        }\n+        close();\n+    }\n+\n+    @Test\n+    public void testQueryProcessByVariables() {\n+        Map<String, Object> variables = Collections.<String, Object> singletonMap(\"var_a\", \"a1\");\n+        Map<String, Object> attributes = Collections.<String, Object> singletonMap(\"processId\", \"test.test_A\");\n+        List<ProcessInstanceWithVarsDesc> data = advanceVariableDataService.queryProcessByVariables(attributes, variables, new QueryContext());\n+        Assert.assertEquals(3, data.size());\n+        for (ProcessInstanceWithVarsDesc p : data) {\n+            Assert.assertEquals(\"a1\", p.getVariables().get(\"var_a\"));\n+            Assert.assertEquals(\"test.test_A\", p.getProcessId());\n+        }\n+    }\n+\n+    @Test\n+    public void testQueryProcessByVariablesWithPagination() {\n+        Map<String, Object> variables = Collections.<String, Object> singletonMap(\"var_a\", \"a1\");\n+        Map<String, Object> attributes = Collections.<String, Object> singletonMap(\"processId\", \"test.test_A\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1e57dd6f9a77d2e636949457815115ca83acc4dc"}, "originalPosition": 151}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjI2NDgzOQ==", "bodyText": "Collections.<String, Object> singletonMap can be replaced with just Collections.singletonMap", "url": "https://github.com/kiegroup/jbpm/pull/1615#discussion_r402264839", "createdAt": "2020-04-02T12:13:12Z", "author": {"login": "afalhambra"}, "path": "jbpm-services/jbpm-kie-services/src/test/java/org/jbpm/kie/services/test/AdvanceRuntimeDataServiceImplTest.java", "diffHunk": "@@ -0,0 +1,219 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.jbpm.kie.services.test;\n+\n+import java.io.File;\n+import java.io.FileOutputStream;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.drools.compiler.kie.builder.impl.InternalKieModule;\n+import org.jbpm.kie.services.impl.KModuleDeploymentUnit;\n+import org.jbpm.kie.test.util.AbstractKieServicesBaseTest;\n+import org.jbpm.services.api.ProcessInstanceNotFoundException;\n+import org.jbpm.services.api.model.DeploymentUnit;\n+import org.jbpm.services.api.model.ProcessInstanceWithVarsDesc;\n+import org.jbpm.services.api.model.UserTaskInstanceWithPotOwnerDesc;\n+import org.junit.After;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.kie.api.KieServices;\n+import org.kie.api.builder.ReleaseId;\n+import org.kie.api.runtime.process.ProcessInstance;\n+import org.kie.internal.query.QueryContext;\n+import org.kie.scanner.KieMavenRepository;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static java.util.Collections.emptyList;\n+import static java.util.Collections.emptyMap;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertNull;\n+import static org.kie.scanner.KieMavenRepository.getKieMavenRepository;\n+\n+public class AdvanceRuntimeDataServiceImplTest extends AbstractKieServicesBaseTest {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(AdvanceRuntimeDataServiceImplTest.class);\n+\n+    private List<DeploymentUnit> units = new ArrayList<DeploymentUnit>();\n+    protected String correctUser = \"testUser\";\n+    protected String wrongUser = \"wrongUser\";\n+\n+    private List<Long> processIds;\n+    private KModuleDeploymentUnit deploymentUnit = null;\n+\n+    @Before\n+    public void prepare() {\n+\n+        configureServices();\n+        logger.debug(\"Preparing kjar\");\n+        KieServices ks = KieServices.Factory.get();\n+        ReleaseId releaseId = ks.newReleaseId(GROUP_ID, ARTIFACT_ID, VERSION);\n+        List<String> processes = new ArrayList<String>();\n+        processes.add(\"repo/processes/general/SingleHumanTaskWithVarsA.bpmn2\");\n+        processes.add(\"repo/processes/general/SingleHumanTaskWithVarsB.bpmn2\");\n+\n+        InternalKieModule kJar1 = createKieJar(ks, releaseId, processes);\n+        File pom = new File(\"target/kmodule\", \"pom.xml\");\n+        pom.getParentFile().mkdir();\n+        try (FileOutputStream fs = new FileOutputStream(pom);) {\n+            fs.write(getPom(releaseId).getBytes());\n+        } catch (Exception e) {\n+\n+        }\n+        KieMavenRepository repository = getKieMavenRepository();\n+        repository.deployArtifact(releaseId, kJar1, pom);\n+\n+        assertNotNull(deploymentService);\n+\n+        deploymentUnit = new KModuleDeploymentUnit(GROUP_ID, ARTIFACT_ID, VERSION);\n+\n+        deploymentService.deploy(deploymentUnit);\n+        units.add(deploymentUnit);\n+        assertNotNull(processService);\n+\n+        processIds = new ArrayList<>();\n+        for (int i = 0; i < 10; i++) {\n+            Map<String, Object> inputsA1 = new HashMap<>();\n+            inputsA1.put(\"var_a\", \"a\" + (i % 3));\n+            inputsA1.put(\"var_b\", (i % 3));\n+            processIds.add(processService.startProcess(deploymentUnit.getIdentifier(), \"test.test_A\", inputsA1));\n+        }\n+        for (int i = 0; i < 10; i++) {\n+            Map<String, Object> inputsB1 = new HashMap<>();\n+            inputsB1.put(\"var_a\", \"b\" + (i % 3));\n+            inputsB1.put(\"var_b\", (i % 3));\n+            processIds.add(processService.startProcess(deploymentUnit.getIdentifier(), \"test.test_B\", inputsB1));\n+        }\n+    }\n+\n+    @After\n+    public void cleanup() {\n+        for (Long processInstanceId : processIds) {\n+            try {\n+                // let's abort process instance to leave the system in clear state\n+                processService.abortProcessInstance(processInstanceId);\n+\n+                ProcessInstance pi = processService.getProcessInstance(processInstanceId);\n+                assertNull(pi);\n+            } catch (ProcessInstanceNotFoundException e) {\n+                // ignore it as it was already completed/aborted\n+            }\n+        }\n+        cleanupSingletonSessionId();\n+        if (units != null && !units.isEmpty()) {\n+            for (DeploymentUnit unit : units) {\n+                try {\n+                    deploymentService.undeploy(unit);\n+                } catch (Exception e) {\n+                    // do nothing in case of some failed tests to avoid next test to fail as well\n+                }\n+            }\n+            units.clear();\n+        }\n+        close();\n+    }\n+\n+    @Test\n+    public void testQueryProcessByVariables() {\n+        Map<String, Object> variables = Collections.<String, Object> singletonMap(\"var_a\", \"a1\");\n+        Map<String, Object> attributes = Collections.<String, Object> singletonMap(\"processId\", \"test.test_A\");\n+        List<ProcessInstanceWithVarsDesc> data = advanceVariableDataService.queryProcessByVariables(attributes, variables, new QueryContext());\n+        Assert.assertEquals(3, data.size());\n+        for (ProcessInstanceWithVarsDesc p : data) {\n+            Assert.assertEquals(\"a1\", p.getVariables().get(\"var_a\"));\n+            Assert.assertEquals(\"test.test_A\", p.getProcessId());\n+        }\n+    }\n+\n+    @Test\n+    public void testQueryProcessByVariablesWithPagination() {\n+        Map<String, Object> variables = Collections.<String, Object> singletonMap(\"var_a\", \"a1\");\n+        Map<String, Object> attributes = Collections.<String, Object> singletonMap(\"processId\", \"test.test_A\");\n+        List<ProcessInstanceWithVarsDesc> data = advanceVariableDataService.queryProcessByVariables(attributes, variables, new QueryContext(0, 2));\n+        Assert.assertEquals(2, data.size());\n+        for (ProcessInstanceWithVarsDesc p : data) {\n+            Assert.assertEquals(\"a1\", p.getVariables().get(\"var_a\"));\n+            Assert.assertEquals(\"test.test_A\", p.getProcessId());\n+        }\n+    }\n+\n+    @Test\n+    public void testQueryTaskByVariables() {\n+        Map<String, Object> variables = Collections.<String, Object> singletonMap(\"task_in_a1\", \"a0\");\n+        Map<String, Object> attributes = Collections.<String, Object> singletonMap(\"deploymentId\", \"org.jbpm.test:test-module:1.0.0\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1e57dd6f9a77d2e636949457815115ca83acc4dc"}, "originalPosition": 163}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjI2NDg5Mw==", "bodyText": "Collections.<String, Object> singletonMap can be replaced with just Collections.singletonMap", "url": "https://github.com/kiegroup/jbpm/pull/1615#discussion_r402264893", "createdAt": "2020-04-02T12:13:20Z", "author": {"login": "afalhambra"}, "path": "jbpm-services/jbpm-kie-services/src/test/java/org/jbpm/kie/services/test/AdvanceRuntimeDataServiceImplTest.java", "diffHunk": "@@ -0,0 +1,219 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.jbpm.kie.services.test;\n+\n+import java.io.File;\n+import java.io.FileOutputStream;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.drools.compiler.kie.builder.impl.InternalKieModule;\n+import org.jbpm.kie.services.impl.KModuleDeploymentUnit;\n+import org.jbpm.kie.test.util.AbstractKieServicesBaseTest;\n+import org.jbpm.services.api.ProcessInstanceNotFoundException;\n+import org.jbpm.services.api.model.DeploymentUnit;\n+import org.jbpm.services.api.model.ProcessInstanceWithVarsDesc;\n+import org.jbpm.services.api.model.UserTaskInstanceWithPotOwnerDesc;\n+import org.junit.After;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.kie.api.KieServices;\n+import org.kie.api.builder.ReleaseId;\n+import org.kie.api.runtime.process.ProcessInstance;\n+import org.kie.internal.query.QueryContext;\n+import org.kie.scanner.KieMavenRepository;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static java.util.Collections.emptyList;\n+import static java.util.Collections.emptyMap;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertNull;\n+import static org.kie.scanner.KieMavenRepository.getKieMavenRepository;\n+\n+public class AdvanceRuntimeDataServiceImplTest extends AbstractKieServicesBaseTest {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(AdvanceRuntimeDataServiceImplTest.class);\n+\n+    private List<DeploymentUnit> units = new ArrayList<DeploymentUnit>();\n+    protected String correctUser = \"testUser\";\n+    protected String wrongUser = \"wrongUser\";\n+\n+    private List<Long> processIds;\n+    private KModuleDeploymentUnit deploymentUnit = null;\n+\n+    @Before\n+    public void prepare() {\n+\n+        configureServices();\n+        logger.debug(\"Preparing kjar\");\n+        KieServices ks = KieServices.Factory.get();\n+        ReleaseId releaseId = ks.newReleaseId(GROUP_ID, ARTIFACT_ID, VERSION);\n+        List<String> processes = new ArrayList<String>();\n+        processes.add(\"repo/processes/general/SingleHumanTaskWithVarsA.bpmn2\");\n+        processes.add(\"repo/processes/general/SingleHumanTaskWithVarsB.bpmn2\");\n+\n+        InternalKieModule kJar1 = createKieJar(ks, releaseId, processes);\n+        File pom = new File(\"target/kmodule\", \"pom.xml\");\n+        pom.getParentFile().mkdir();\n+        try (FileOutputStream fs = new FileOutputStream(pom);) {\n+            fs.write(getPom(releaseId).getBytes());\n+        } catch (Exception e) {\n+\n+        }\n+        KieMavenRepository repository = getKieMavenRepository();\n+        repository.deployArtifact(releaseId, kJar1, pom);\n+\n+        assertNotNull(deploymentService);\n+\n+        deploymentUnit = new KModuleDeploymentUnit(GROUP_ID, ARTIFACT_ID, VERSION);\n+\n+        deploymentService.deploy(deploymentUnit);\n+        units.add(deploymentUnit);\n+        assertNotNull(processService);\n+\n+        processIds = new ArrayList<>();\n+        for (int i = 0; i < 10; i++) {\n+            Map<String, Object> inputsA1 = new HashMap<>();\n+            inputsA1.put(\"var_a\", \"a\" + (i % 3));\n+            inputsA1.put(\"var_b\", (i % 3));\n+            processIds.add(processService.startProcess(deploymentUnit.getIdentifier(), \"test.test_A\", inputsA1));\n+        }\n+        for (int i = 0; i < 10; i++) {\n+            Map<String, Object> inputsB1 = new HashMap<>();\n+            inputsB1.put(\"var_a\", \"b\" + (i % 3));\n+            inputsB1.put(\"var_b\", (i % 3));\n+            processIds.add(processService.startProcess(deploymentUnit.getIdentifier(), \"test.test_B\", inputsB1));\n+        }\n+    }\n+\n+    @After\n+    public void cleanup() {\n+        for (Long processInstanceId : processIds) {\n+            try {\n+                // let's abort process instance to leave the system in clear state\n+                processService.abortProcessInstance(processInstanceId);\n+\n+                ProcessInstance pi = processService.getProcessInstance(processInstanceId);\n+                assertNull(pi);\n+            } catch (ProcessInstanceNotFoundException e) {\n+                // ignore it as it was already completed/aborted\n+            }\n+        }\n+        cleanupSingletonSessionId();\n+        if (units != null && !units.isEmpty()) {\n+            for (DeploymentUnit unit : units) {\n+                try {\n+                    deploymentService.undeploy(unit);\n+                } catch (Exception e) {\n+                    // do nothing in case of some failed tests to avoid next test to fail as well\n+                }\n+            }\n+            units.clear();\n+        }\n+        close();\n+    }\n+\n+    @Test\n+    public void testQueryProcessByVariables() {\n+        Map<String, Object> variables = Collections.<String, Object> singletonMap(\"var_a\", \"a1\");\n+        Map<String, Object> attributes = Collections.<String, Object> singletonMap(\"processId\", \"test.test_A\");\n+        List<ProcessInstanceWithVarsDesc> data = advanceVariableDataService.queryProcessByVariables(attributes, variables, new QueryContext());\n+        Assert.assertEquals(3, data.size());\n+        for (ProcessInstanceWithVarsDesc p : data) {\n+            Assert.assertEquals(\"a1\", p.getVariables().get(\"var_a\"));\n+            Assert.assertEquals(\"test.test_A\", p.getProcessId());\n+        }\n+    }\n+\n+    @Test\n+    public void testQueryProcessByVariablesWithPagination() {\n+        Map<String, Object> variables = Collections.<String, Object> singletonMap(\"var_a\", \"a1\");\n+        Map<String, Object> attributes = Collections.<String, Object> singletonMap(\"processId\", \"test.test_A\");\n+        List<ProcessInstanceWithVarsDesc> data = advanceVariableDataService.queryProcessByVariables(attributes, variables, new QueryContext(0, 2));\n+        Assert.assertEquals(2, data.size());\n+        for (ProcessInstanceWithVarsDesc p : data) {\n+            Assert.assertEquals(\"a1\", p.getVariables().get(\"var_a\"));\n+            Assert.assertEquals(\"test.test_A\", p.getProcessId());\n+        }\n+    }\n+\n+    @Test\n+    public void testQueryTaskByVariables() {\n+        Map<String, Object> variables = Collections.<String, Object> singletonMap(\"task_in_a1\", \"a0\");\n+        Map<String, Object> attributes = Collections.<String, Object> singletonMap(\"deploymentId\", \"org.jbpm.test:test-module:1.0.0\");\n+        List<String> potOwners = emptyList();\n+        List<UserTaskInstanceWithPotOwnerDesc> data = advanceVariableDataService.queryUserTasksByVariables(attributes, variables, emptyMap(), potOwners, new QueryContext());\n+        Assert.assertEquals(4, data.size());\n+        for (UserTaskInstanceWithPotOwnerDesc p : data) {\n+            Assert.assertEquals(\"a0\", p.getInputdata().get(\"task_in_a1\"));\n+            Assert.assertEquals(\"org.jbpm.test:test-module:1.0.0\", p.getDeploymentId());\n+        }\n+    }\n+\n+    @Test\n+    public void testQueryTaskByVariablesWithPagination() {\n+        Map<String, Object> variables = Collections.<String, Object> singletonMap(\"task_in_a1\", \"a0\");\n+        Map<String, Object> attributes = Collections.<String, Object> singletonMap(\"deploymentId\", \"org.jbpm.test:test-module:1.0.0\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1e57dd6f9a77d2e636949457815115ca83acc4dc"}, "originalPosition": 176}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjM3MDY5NA==", "bodyText": "Why not just use emptyList() as input parameter for the queryUserTaskByVariables rather than creating a non-used variable potOwners?", "url": "https://github.com/kiegroup/jbpm/pull/1615#discussion_r402370694", "createdAt": "2020-04-02T14:45:33Z", "author": {"login": "afalhambra"}, "path": "jbpm-services/jbpm-kie-services/src/test/java/org/jbpm/kie/services/test/AdvanceRuntimeDataServiceImplTest.java", "diffHunk": "@@ -0,0 +1,219 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.jbpm.kie.services.test;\n+\n+import java.io.File;\n+import java.io.FileOutputStream;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.drools.compiler.kie.builder.impl.InternalKieModule;\n+import org.jbpm.kie.services.impl.KModuleDeploymentUnit;\n+import org.jbpm.kie.test.util.AbstractKieServicesBaseTest;\n+import org.jbpm.services.api.ProcessInstanceNotFoundException;\n+import org.jbpm.services.api.model.DeploymentUnit;\n+import org.jbpm.services.api.model.ProcessInstanceWithVarsDesc;\n+import org.jbpm.services.api.model.UserTaskInstanceWithPotOwnerDesc;\n+import org.junit.After;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.kie.api.KieServices;\n+import org.kie.api.builder.ReleaseId;\n+import org.kie.api.runtime.process.ProcessInstance;\n+import org.kie.internal.query.QueryContext;\n+import org.kie.scanner.KieMavenRepository;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static java.util.Collections.emptyList;\n+import static java.util.Collections.emptyMap;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertNull;\n+import static org.kie.scanner.KieMavenRepository.getKieMavenRepository;\n+\n+public class AdvanceRuntimeDataServiceImplTest extends AbstractKieServicesBaseTest {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(AdvanceRuntimeDataServiceImplTest.class);\n+\n+    private List<DeploymentUnit> units = new ArrayList<DeploymentUnit>();\n+    protected String correctUser = \"testUser\";\n+    protected String wrongUser = \"wrongUser\";\n+\n+    private List<Long> processIds;\n+    private KModuleDeploymentUnit deploymentUnit = null;\n+\n+    @Before\n+    public void prepare() {\n+\n+        configureServices();\n+        logger.debug(\"Preparing kjar\");\n+        KieServices ks = KieServices.Factory.get();\n+        ReleaseId releaseId = ks.newReleaseId(GROUP_ID, ARTIFACT_ID, VERSION);\n+        List<String> processes = new ArrayList<String>();\n+        processes.add(\"repo/processes/general/SingleHumanTaskWithVarsA.bpmn2\");\n+        processes.add(\"repo/processes/general/SingleHumanTaskWithVarsB.bpmn2\");\n+\n+        InternalKieModule kJar1 = createKieJar(ks, releaseId, processes);\n+        File pom = new File(\"target/kmodule\", \"pom.xml\");\n+        pom.getParentFile().mkdir();\n+        try (FileOutputStream fs = new FileOutputStream(pom);) {\n+            fs.write(getPom(releaseId).getBytes());\n+        } catch (Exception e) {\n+\n+        }\n+        KieMavenRepository repository = getKieMavenRepository();\n+        repository.deployArtifact(releaseId, kJar1, pom);\n+\n+        assertNotNull(deploymentService);\n+\n+        deploymentUnit = new KModuleDeploymentUnit(GROUP_ID, ARTIFACT_ID, VERSION);\n+\n+        deploymentService.deploy(deploymentUnit);\n+        units.add(deploymentUnit);\n+        assertNotNull(processService);\n+\n+        processIds = new ArrayList<>();\n+        for (int i = 0; i < 10; i++) {\n+            Map<String, Object> inputsA1 = new HashMap<>();\n+            inputsA1.put(\"var_a\", \"a\" + (i % 3));\n+            inputsA1.put(\"var_b\", (i % 3));\n+            processIds.add(processService.startProcess(deploymentUnit.getIdentifier(), \"test.test_A\", inputsA1));\n+        }\n+        for (int i = 0; i < 10; i++) {\n+            Map<String, Object> inputsB1 = new HashMap<>();\n+            inputsB1.put(\"var_a\", \"b\" + (i % 3));\n+            inputsB1.put(\"var_b\", (i % 3));\n+            processIds.add(processService.startProcess(deploymentUnit.getIdentifier(), \"test.test_B\", inputsB1));\n+        }\n+    }\n+\n+    @After\n+    public void cleanup() {\n+        for (Long processInstanceId : processIds) {\n+            try {\n+                // let's abort process instance to leave the system in clear state\n+                processService.abortProcessInstance(processInstanceId);\n+\n+                ProcessInstance pi = processService.getProcessInstance(processInstanceId);\n+                assertNull(pi);\n+            } catch (ProcessInstanceNotFoundException e) {\n+                // ignore it as it was already completed/aborted\n+            }\n+        }\n+        cleanupSingletonSessionId();\n+        if (units != null && !units.isEmpty()) {\n+            for (DeploymentUnit unit : units) {\n+                try {\n+                    deploymentService.undeploy(unit);\n+                } catch (Exception e) {\n+                    // do nothing in case of some failed tests to avoid next test to fail as well\n+                }\n+            }\n+            units.clear();\n+        }\n+        close();\n+    }\n+\n+    @Test\n+    public void testQueryProcessByVariables() {\n+        Map<String, Object> variables = Collections.<String, Object> singletonMap(\"var_a\", \"a1\");\n+        Map<String, Object> attributes = Collections.<String, Object> singletonMap(\"processId\", \"test.test_A\");\n+        List<ProcessInstanceWithVarsDesc> data = advanceVariableDataService.queryProcessByVariables(attributes, variables, new QueryContext());\n+        Assert.assertEquals(3, data.size());\n+        for (ProcessInstanceWithVarsDesc p : data) {\n+            Assert.assertEquals(\"a1\", p.getVariables().get(\"var_a\"));\n+            Assert.assertEquals(\"test.test_A\", p.getProcessId());\n+        }\n+    }\n+\n+    @Test\n+    public void testQueryProcessByVariablesWithPagination() {\n+        Map<String, Object> variables = Collections.<String, Object> singletonMap(\"var_a\", \"a1\");\n+        Map<String, Object> attributes = Collections.<String, Object> singletonMap(\"processId\", \"test.test_A\");\n+        List<ProcessInstanceWithVarsDesc> data = advanceVariableDataService.queryProcessByVariables(attributes, variables, new QueryContext(0, 2));\n+        Assert.assertEquals(2, data.size());\n+        for (ProcessInstanceWithVarsDesc p : data) {\n+            Assert.assertEquals(\"a1\", p.getVariables().get(\"var_a\"));\n+            Assert.assertEquals(\"test.test_A\", p.getProcessId());\n+        }\n+    }\n+\n+    @Test\n+    public void testQueryTaskByVariables() {\n+        Map<String, Object> variables = Collections.<String, Object> singletonMap(\"task_in_a1\", \"a0\");\n+        Map<String, Object> attributes = Collections.<String, Object> singletonMap(\"deploymentId\", \"org.jbpm.test:test-module:1.0.0\");\n+        List<String> potOwners = emptyList();\n+        List<UserTaskInstanceWithPotOwnerDesc> data = advanceVariableDataService.queryUserTasksByVariables(attributes, variables, emptyMap(), potOwners, new QueryContext());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1e57dd6f9a77d2e636949457815115ca83acc4dc"}, "originalPosition": 165}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjM3MTMzNQ==", "bodyText": "Why not just use emptyList() as input parameter for the queryUserTaskByVariables rather than creating a non-used variable potOwners?", "url": "https://github.com/kiegroup/jbpm/pull/1615#discussion_r402371335", "createdAt": "2020-04-02T14:46:22Z", "author": {"login": "afalhambra"}, "path": "jbpm-services/jbpm-kie-services/src/test/java/org/jbpm/kie/services/test/AdvanceRuntimeDataServiceImplTest.java", "diffHunk": "@@ -0,0 +1,219 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.jbpm.kie.services.test;\n+\n+import java.io.File;\n+import java.io.FileOutputStream;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.drools.compiler.kie.builder.impl.InternalKieModule;\n+import org.jbpm.kie.services.impl.KModuleDeploymentUnit;\n+import org.jbpm.kie.test.util.AbstractKieServicesBaseTest;\n+import org.jbpm.services.api.ProcessInstanceNotFoundException;\n+import org.jbpm.services.api.model.DeploymentUnit;\n+import org.jbpm.services.api.model.ProcessInstanceWithVarsDesc;\n+import org.jbpm.services.api.model.UserTaskInstanceWithPotOwnerDesc;\n+import org.junit.After;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.kie.api.KieServices;\n+import org.kie.api.builder.ReleaseId;\n+import org.kie.api.runtime.process.ProcessInstance;\n+import org.kie.internal.query.QueryContext;\n+import org.kie.scanner.KieMavenRepository;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static java.util.Collections.emptyList;\n+import static java.util.Collections.emptyMap;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertNull;\n+import static org.kie.scanner.KieMavenRepository.getKieMavenRepository;\n+\n+public class AdvanceRuntimeDataServiceImplTest extends AbstractKieServicesBaseTest {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(AdvanceRuntimeDataServiceImplTest.class);\n+\n+    private List<DeploymentUnit> units = new ArrayList<DeploymentUnit>();\n+    protected String correctUser = \"testUser\";\n+    protected String wrongUser = \"wrongUser\";\n+\n+    private List<Long> processIds;\n+    private KModuleDeploymentUnit deploymentUnit = null;\n+\n+    @Before\n+    public void prepare() {\n+\n+        configureServices();\n+        logger.debug(\"Preparing kjar\");\n+        KieServices ks = KieServices.Factory.get();\n+        ReleaseId releaseId = ks.newReleaseId(GROUP_ID, ARTIFACT_ID, VERSION);\n+        List<String> processes = new ArrayList<String>();\n+        processes.add(\"repo/processes/general/SingleHumanTaskWithVarsA.bpmn2\");\n+        processes.add(\"repo/processes/general/SingleHumanTaskWithVarsB.bpmn2\");\n+\n+        InternalKieModule kJar1 = createKieJar(ks, releaseId, processes);\n+        File pom = new File(\"target/kmodule\", \"pom.xml\");\n+        pom.getParentFile().mkdir();\n+        try (FileOutputStream fs = new FileOutputStream(pom);) {\n+            fs.write(getPom(releaseId).getBytes());\n+        } catch (Exception e) {\n+\n+        }\n+        KieMavenRepository repository = getKieMavenRepository();\n+        repository.deployArtifact(releaseId, kJar1, pom);\n+\n+        assertNotNull(deploymentService);\n+\n+        deploymentUnit = new KModuleDeploymentUnit(GROUP_ID, ARTIFACT_ID, VERSION);\n+\n+        deploymentService.deploy(deploymentUnit);\n+        units.add(deploymentUnit);\n+        assertNotNull(processService);\n+\n+        processIds = new ArrayList<>();\n+        for (int i = 0; i < 10; i++) {\n+            Map<String, Object> inputsA1 = new HashMap<>();\n+            inputsA1.put(\"var_a\", \"a\" + (i % 3));\n+            inputsA1.put(\"var_b\", (i % 3));\n+            processIds.add(processService.startProcess(deploymentUnit.getIdentifier(), \"test.test_A\", inputsA1));\n+        }\n+        for (int i = 0; i < 10; i++) {\n+            Map<String, Object> inputsB1 = new HashMap<>();\n+            inputsB1.put(\"var_a\", \"b\" + (i % 3));\n+            inputsB1.put(\"var_b\", (i % 3));\n+            processIds.add(processService.startProcess(deploymentUnit.getIdentifier(), \"test.test_B\", inputsB1));\n+        }\n+    }\n+\n+    @After\n+    public void cleanup() {\n+        for (Long processInstanceId : processIds) {\n+            try {\n+                // let's abort process instance to leave the system in clear state\n+                processService.abortProcessInstance(processInstanceId);\n+\n+                ProcessInstance pi = processService.getProcessInstance(processInstanceId);\n+                assertNull(pi);\n+            } catch (ProcessInstanceNotFoundException e) {\n+                // ignore it as it was already completed/aborted\n+            }\n+        }\n+        cleanupSingletonSessionId();\n+        if (units != null && !units.isEmpty()) {\n+            for (DeploymentUnit unit : units) {\n+                try {\n+                    deploymentService.undeploy(unit);\n+                } catch (Exception e) {\n+                    // do nothing in case of some failed tests to avoid next test to fail as well\n+                }\n+            }\n+            units.clear();\n+        }\n+        close();\n+    }\n+\n+    @Test\n+    public void testQueryProcessByVariables() {\n+        Map<String, Object> variables = Collections.<String, Object> singletonMap(\"var_a\", \"a1\");\n+        Map<String, Object> attributes = Collections.<String, Object> singletonMap(\"processId\", \"test.test_A\");\n+        List<ProcessInstanceWithVarsDesc> data = advanceVariableDataService.queryProcessByVariables(attributes, variables, new QueryContext());\n+        Assert.assertEquals(3, data.size());\n+        for (ProcessInstanceWithVarsDesc p : data) {\n+            Assert.assertEquals(\"a1\", p.getVariables().get(\"var_a\"));\n+            Assert.assertEquals(\"test.test_A\", p.getProcessId());\n+        }\n+    }\n+\n+    @Test\n+    public void testQueryProcessByVariablesWithPagination() {\n+        Map<String, Object> variables = Collections.<String, Object> singletonMap(\"var_a\", \"a1\");\n+        Map<String, Object> attributes = Collections.<String, Object> singletonMap(\"processId\", \"test.test_A\");\n+        List<ProcessInstanceWithVarsDesc> data = advanceVariableDataService.queryProcessByVariables(attributes, variables, new QueryContext(0, 2));\n+        Assert.assertEquals(2, data.size());\n+        for (ProcessInstanceWithVarsDesc p : data) {\n+            Assert.assertEquals(\"a1\", p.getVariables().get(\"var_a\"));\n+            Assert.assertEquals(\"test.test_A\", p.getProcessId());\n+        }\n+    }\n+\n+    @Test\n+    public void testQueryTaskByVariables() {\n+        Map<String, Object> variables = Collections.<String, Object> singletonMap(\"task_in_a1\", \"a0\");\n+        Map<String, Object> attributes = Collections.<String, Object> singletonMap(\"deploymentId\", \"org.jbpm.test:test-module:1.0.0\");\n+        List<String> potOwners = emptyList();\n+        List<UserTaskInstanceWithPotOwnerDesc> data = advanceVariableDataService.queryUserTasksByVariables(attributes, variables, emptyMap(), potOwners, new QueryContext());\n+        Assert.assertEquals(4, data.size());\n+        for (UserTaskInstanceWithPotOwnerDesc p : data) {\n+            Assert.assertEquals(\"a0\", p.getInputdata().get(\"task_in_a1\"));\n+            Assert.assertEquals(\"org.jbpm.test:test-module:1.0.0\", p.getDeploymentId());\n+        }\n+    }\n+\n+    @Test\n+    public void testQueryTaskByVariablesWithPagination() {\n+        Map<String, Object> variables = Collections.<String, Object> singletonMap(\"task_in_a1\", \"a0\");\n+        Map<String, Object> attributes = Collections.<String, Object> singletonMap(\"deploymentId\", \"org.jbpm.test:test-module:1.0.0\");\n+        List<String> potOwners = emptyList();\n+        List<UserTaskInstanceWithPotOwnerDesc> data = advanceVariableDataService.queryUserTasksByVariables(attributes, variables, emptyMap(), potOwners, new QueryContext(0, 2));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1e57dd6f9a77d2e636949457815115ca83acc4dc"}, "originalPosition": 178}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjM3NjU1MA==", "bodyText": "How do we iterate through batches of a particular query with some pagination?", "url": "https://github.com/kiegroup/jbpm/pull/1615#discussion_r402376550", "createdAt": "2020-04-02T14:52:45Z", "author": {"login": "afalhambra"}, "path": "jbpm-services/jbpm-kie-services/src/main/java/org/jbpm/kie/services/impl/AbstractAdvanceRuntimeDataServiceImpl.java", "diffHunk": "@@ -0,0 +1,306 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.jbpm.kie.services.impl;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import javax.persistence.EntityManager;\n+import javax.persistence.EntityManagerFactory;\n+import javax.persistence.Query;\n+\n+import org.jbpm.kie.services.impl.model.ProcessInstanceWithVarsDesc;\n+import org.jbpm.kie.services.impl.model.UserTaskInstanceWithPotOwnerDesc;\n+import org.jbpm.shared.services.impl.QueryManager;\n+import org.jbpm.shared.services.impl.TransactionalCommandService;\n+import org.jbpm.shared.services.impl.commands.QueryNameCommand;\n+import org.kie.api.runtime.query.QueryContext;\n+\n+import static java.util.Collections.singletonMap;\n+\n+public abstract class AbstractAdvanceRuntimeDataServiceImpl {\n+\n+    private EntityManagerFactory emf;\n+    private TransactionalCommandService commandService;\n+\n+    public AbstractAdvanceRuntimeDataServiceImpl() {\n+        QueryManager.get().addNamedQueries(\"META-INF/Servicesorm.xml\");\n+    }\n+    public void setCommandService(TransactionalCommandService commandService) {\n+        this.commandService = commandService;\n+    }\n+\n+    public void setEmf(EntityManagerFactory emf) {\n+        this.emf = emf;\n+    }\n+\n+\n+    public List<org.jbpm.services.api.model.ProcessInstanceWithVarsDesc> queryProcessByVariables(Map<String, Object> attributes,\n+                                                                                                 Map<String, Object> variables,\n+                                                                                                 int processType,\n+                                                                                                 String varPrefix,\n+                                                                                                 QueryContext queryContext) {\n+        EntityManager entityManager = emf.createEntityManager();\n+\n+        // first step is to filter the data creating a derived tables and pivoting var - rows to columns (only the variables we are interested to filter)\n+        StringBuilder where = new StringBuilder();\n+        StringBuilder derivedTables = new StringBuilder();\n+        for (Map.Entry<String, Object> var : variables.entrySet()) {\n+            String alias = \"TABLE_\" + var.getKey();\n+            String varName = var.getKey();\n+\n+            derivedTables.append(\"LEFT JOIN (\" +\n+                                 \"SELECT A1.processId, A1.processInstanceId, A1.variableId AS NAME, A1.value AS VALUE \\n\" +\n+                                 \"FROM VariableInstanceLog A1 \\n\" +\n+                                 \"LEFT JOIN VariableInstanceLog A2 ON A1.processId = A2.processId AND A1.processInstanceId = A2.processInstanceId AND A1.variableInstanceId = A2.variableInstanceId AND A2.log_date < A1.log_date  \\n\" +\n+                                 \"WHERE A2.log_date IS NULL \\n\" +\n+                                 \") \" + alias + \" ON \" + alias + \".processId = pil.processId AND \" + alias + \".processInstanceId = pil.processInstanceId \\n\");\n+\n+            addWhereExpression(where);\n+            where.append(alias + \".NAME = :NAME_\" + varName + \" AND \" + alias + \".VALUE= :VALUE_\" + varName + \"\\n\");\n+        }\n+\n+\n+        for (Map.Entry<String, Object> entry : attributes.entrySet()) {\n+            addWhereExpression(where);\n+            where.append(\" pil.\" + entry.getKey() + \" = :ATTR_\" + entry.getKey() + \" \");\n+        }\n+\n+        addWhereExpression(where);\n+        where.append(\" pil.processType = :processType \");\n+\n+        String procSQLString = \"SELECT DISTINCT pil.processInstanceId FROM ProcessInstanceLog pil \\n \" + derivedTables + where + \" ORDER BY pil.processInstanceId ASC \";\n+        procSQLString += (queryContext.getCount() > 0) ? \" LIMIT \" + queryContext.getCount() + \" OFFSET \" + queryContext.getOffset() + \" \\n\" : \"\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1e57dd6f9a77d2e636949457815115ca83acc4dc"}, "originalPosition": 91}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjM3OTIzMw==", "bodyText": "We're already passing processVariables as emptyMap*) in call, why not do the same for these?", "url": "https://github.com/kiegroup/jbpm/pull/1615#discussion_r402379233", "createdAt": "2020-04-02T14:56:00Z", "author": {"login": "afalhambra"}, "path": "jbpm-services/jbpm-kie-services/src/test/java/org/jbpm/kie/services/test/AdvanceRuntimeDataServiceImplTest.java", "diffHunk": "@@ -0,0 +1,219 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.jbpm.kie.services.test;\n+\n+import java.io.File;\n+import java.io.FileOutputStream;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.drools.compiler.kie.builder.impl.InternalKieModule;\n+import org.jbpm.kie.services.impl.KModuleDeploymentUnit;\n+import org.jbpm.kie.test.util.AbstractKieServicesBaseTest;\n+import org.jbpm.services.api.ProcessInstanceNotFoundException;\n+import org.jbpm.services.api.model.DeploymentUnit;\n+import org.jbpm.services.api.model.ProcessInstanceWithVarsDesc;\n+import org.jbpm.services.api.model.UserTaskInstanceWithPotOwnerDesc;\n+import org.junit.After;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.kie.api.KieServices;\n+import org.kie.api.builder.ReleaseId;\n+import org.kie.api.runtime.process.ProcessInstance;\n+import org.kie.internal.query.QueryContext;\n+import org.kie.scanner.KieMavenRepository;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static java.util.Collections.emptyList;\n+import static java.util.Collections.emptyMap;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertNull;\n+import static org.kie.scanner.KieMavenRepository.getKieMavenRepository;\n+\n+public class AdvanceRuntimeDataServiceImplTest extends AbstractKieServicesBaseTest {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(AdvanceRuntimeDataServiceImplTest.class);\n+\n+    private List<DeploymentUnit> units = new ArrayList<DeploymentUnit>();\n+    protected String correctUser = \"testUser\";\n+    protected String wrongUser = \"wrongUser\";\n+\n+    private List<Long> processIds;\n+    private KModuleDeploymentUnit deploymentUnit = null;\n+\n+    @Before\n+    public void prepare() {\n+\n+        configureServices();\n+        logger.debug(\"Preparing kjar\");\n+        KieServices ks = KieServices.Factory.get();\n+        ReleaseId releaseId = ks.newReleaseId(GROUP_ID, ARTIFACT_ID, VERSION);\n+        List<String> processes = new ArrayList<String>();\n+        processes.add(\"repo/processes/general/SingleHumanTaskWithVarsA.bpmn2\");\n+        processes.add(\"repo/processes/general/SingleHumanTaskWithVarsB.bpmn2\");\n+\n+        InternalKieModule kJar1 = createKieJar(ks, releaseId, processes);\n+        File pom = new File(\"target/kmodule\", \"pom.xml\");\n+        pom.getParentFile().mkdir();\n+        try (FileOutputStream fs = new FileOutputStream(pom);) {\n+            fs.write(getPom(releaseId).getBytes());\n+        } catch (Exception e) {\n+\n+        }\n+        KieMavenRepository repository = getKieMavenRepository();\n+        repository.deployArtifact(releaseId, kJar1, pom);\n+\n+        assertNotNull(deploymentService);\n+\n+        deploymentUnit = new KModuleDeploymentUnit(GROUP_ID, ARTIFACT_ID, VERSION);\n+\n+        deploymentService.deploy(deploymentUnit);\n+        units.add(deploymentUnit);\n+        assertNotNull(processService);\n+\n+        processIds = new ArrayList<>();\n+        for (int i = 0; i < 10; i++) {\n+            Map<String, Object> inputsA1 = new HashMap<>();\n+            inputsA1.put(\"var_a\", \"a\" + (i % 3));\n+            inputsA1.put(\"var_b\", (i % 3));\n+            processIds.add(processService.startProcess(deploymentUnit.getIdentifier(), \"test.test_A\", inputsA1));\n+        }\n+        for (int i = 0; i < 10; i++) {\n+            Map<String, Object> inputsB1 = new HashMap<>();\n+            inputsB1.put(\"var_a\", \"b\" + (i % 3));\n+            inputsB1.put(\"var_b\", (i % 3));\n+            processIds.add(processService.startProcess(deploymentUnit.getIdentifier(), \"test.test_B\", inputsB1));\n+        }\n+    }\n+\n+    @After\n+    public void cleanup() {\n+        for (Long processInstanceId : processIds) {\n+            try {\n+                // let's abort process instance to leave the system in clear state\n+                processService.abortProcessInstance(processInstanceId);\n+\n+                ProcessInstance pi = processService.getProcessInstance(processInstanceId);\n+                assertNull(pi);\n+            } catch (ProcessInstanceNotFoundException e) {\n+                // ignore it as it was already completed/aborted\n+            }\n+        }\n+        cleanupSingletonSessionId();\n+        if (units != null && !units.isEmpty()) {\n+            for (DeploymentUnit unit : units) {\n+                try {\n+                    deploymentService.undeploy(unit);\n+                } catch (Exception e) {\n+                    // do nothing in case of some failed tests to avoid next test to fail as well\n+                }\n+            }\n+            units.clear();\n+        }\n+        close();\n+    }\n+\n+    @Test\n+    public void testQueryProcessByVariables() {\n+        Map<String, Object> variables = Collections.<String, Object> singletonMap(\"var_a\", \"a1\");\n+        Map<String, Object> attributes = Collections.<String, Object> singletonMap(\"processId\", \"test.test_A\");\n+        List<ProcessInstanceWithVarsDesc> data = advanceVariableDataService.queryProcessByVariables(attributes, variables, new QueryContext());\n+        Assert.assertEquals(3, data.size());\n+        for (ProcessInstanceWithVarsDesc p : data) {\n+            Assert.assertEquals(\"a1\", p.getVariables().get(\"var_a\"));\n+            Assert.assertEquals(\"test.test_A\", p.getProcessId());\n+        }\n+    }\n+\n+    @Test\n+    public void testQueryProcessByVariablesWithPagination() {\n+        Map<String, Object> variables = Collections.<String, Object> singletonMap(\"var_a\", \"a1\");\n+        Map<String, Object> attributes = Collections.<String, Object> singletonMap(\"processId\", \"test.test_A\");\n+        List<ProcessInstanceWithVarsDesc> data = advanceVariableDataService.queryProcessByVariables(attributes, variables, new QueryContext(0, 2));\n+        Assert.assertEquals(2, data.size());\n+        for (ProcessInstanceWithVarsDesc p : data) {\n+            Assert.assertEquals(\"a1\", p.getVariables().get(\"var_a\"));\n+            Assert.assertEquals(\"test.test_A\", p.getProcessId());\n+        }\n+    }\n+\n+    @Test\n+    public void testQueryTaskByVariables() {\n+        Map<String, Object> variables = Collections.<String, Object> singletonMap(\"task_in_a1\", \"a0\");\n+        Map<String, Object> attributes = Collections.<String, Object> singletonMap(\"deploymentId\", \"org.jbpm.test:test-module:1.0.0\");\n+        List<String> potOwners = emptyList();\n+        List<UserTaskInstanceWithPotOwnerDesc> data = advanceVariableDataService.queryUserTasksByVariables(attributes, variables, emptyMap(), potOwners, new QueryContext());\n+        Assert.assertEquals(4, data.size());\n+        for (UserTaskInstanceWithPotOwnerDesc p : data) {\n+            Assert.assertEquals(\"a0\", p.getInputdata().get(\"task_in_a1\"));\n+            Assert.assertEquals(\"org.jbpm.test:test-module:1.0.0\", p.getDeploymentId());\n+        }\n+    }\n+\n+    @Test\n+    public void testQueryTaskByVariablesWithPagination() {\n+        Map<String, Object> variables = Collections.<String, Object> singletonMap(\"task_in_a1\", \"a0\");\n+        Map<String, Object> attributes = Collections.<String, Object> singletonMap(\"deploymentId\", \"org.jbpm.test:test-module:1.0.0\");\n+        List<String> potOwners = emptyList();\n+        List<UserTaskInstanceWithPotOwnerDesc> data = advanceVariableDataService.queryUserTasksByVariables(attributes, variables, emptyMap(), potOwners, new QueryContext(0, 2));\n+        Assert.assertEquals(2, data.size());\n+        for (UserTaskInstanceWithPotOwnerDesc p : data) {\n+            Assert.assertEquals(\"a0\", p.getInputdata().get(\"task_in_a1\"));\n+            Assert.assertEquals(\"org.jbpm.test:test-module:1.0.0\", p.getDeploymentId());\n+        }\n+    }\n+\n+    @Test\n+    public void testQueryTaskByVariablesWithOwners() {\n+        Map<String, Object> variables = emptyMap();\n+        Map<String, Object> attributes = emptyMap();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1e57dd6f9a77d2e636949457815115ca83acc4dc"}, "originalPosition": 189}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjM4NDc4OA==", "bodyText": "How would you get the next batch for pagination?", "url": "https://github.com/kiegroup/jbpm/pull/1615#discussion_r402384788", "createdAt": "2020-04-02T15:02:50Z", "author": {"login": "afalhambra"}, "path": "jbpm-services/jbpm-kie-services/src/test/java/org/jbpm/kie/services/test/AdvanceRuntimeDataServiceImplTest.java", "diffHunk": "@@ -0,0 +1,219 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.jbpm.kie.services.test;\n+\n+import java.io.File;\n+import java.io.FileOutputStream;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.drools.compiler.kie.builder.impl.InternalKieModule;\n+import org.jbpm.kie.services.impl.KModuleDeploymentUnit;\n+import org.jbpm.kie.test.util.AbstractKieServicesBaseTest;\n+import org.jbpm.services.api.ProcessInstanceNotFoundException;\n+import org.jbpm.services.api.model.DeploymentUnit;\n+import org.jbpm.services.api.model.ProcessInstanceWithVarsDesc;\n+import org.jbpm.services.api.model.UserTaskInstanceWithPotOwnerDesc;\n+import org.junit.After;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.kie.api.KieServices;\n+import org.kie.api.builder.ReleaseId;\n+import org.kie.api.runtime.process.ProcessInstance;\n+import org.kie.internal.query.QueryContext;\n+import org.kie.scanner.KieMavenRepository;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static java.util.Collections.emptyList;\n+import static java.util.Collections.emptyMap;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertNull;\n+import static org.kie.scanner.KieMavenRepository.getKieMavenRepository;\n+\n+public class AdvanceRuntimeDataServiceImplTest extends AbstractKieServicesBaseTest {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(AdvanceRuntimeDataServiceImplTest.class);\n+\n+    private List<DeploymentUnit> units = new ArrayList<DeploymentUnit>();\n+    protected String correctUser = \"testUser\";\n+    protected String wrongUser = \"wrongUser\";\n+\n+    private List<Long> processIds;\n+    private KModuleDeploymentUnit deploymentUnit = null;\n+\n+    @Before\n+    public void prepare() {\n+\n+        configureServices();\n+        logger.debug(\"Preparing kjar\");\n+        KieServices ks = KieServices.Factory.get();\n+        ReleaseId releaseId = ks.newReleaseId(GROUP_ID, ARTIFACT_ID, VERSION);\n+        List<String> processes = new ArrayList<String>();\n+        processes.add(\"repo/processes/general/SingleHumanTaskWithVarsA.bpmn2\");\n+        processes.add(\"repo/processes/general/SingleHumanTaskWithVarsB.bpmn2\");\n+\n+        InternalKieModule kJar1 = createKieJar(ks, releaseId, processes);\n+        File pom = new File(\"target/kmodule\", \"pom.xml\");\n+        pom.getParentFile().mkdir();\n+        try (FileOutputStream fs = new FileOutputStream(pom);) {\n+            fs.write(getPom(releaseId).getBytes());\n+        } catch (Exception e) {\n+\n+        }\n+        KieMavenRepository repository = getKieMavenRepository();\n+        repository.deployArtifact(releaseId, kJar1, pom);\n+\n+        assertNotNull(deploymentService);\n+\n+        deploymentUnit = new KModuleDeploymentUnit(GROUP_ID, ARTIFACT_ID, VERSION);\n+\n+        deploymentService.deploy(deploymentUnit);\n+        units.add(deploymentUnit);\n+        assertNotNull(processService);\n+\n+        processIds = new ArrayList<>();\n+        for (int i = 0; i < 10; i++) {\n+            Map<String, Object> inputsA1 = new HashMap<>();\n+            inputsA1.put(\"var_a\", \"a\" + (i % 3));\n+            inputsA1.put(\"var_b\", (i % 3));\n+            processIds.add(processService.startProcess(deploymentUnit.getIdentifier(), \"test.test_A\", inputsA1));\n+        }\n+        for (int i = 0; i < 10; i++) {\n+            Map<String, Object> inputsB1 = new HashMap<>();\n+            inputsB1.put(\"var_a\", \"b\" + (i % 3));\n+            inputsB1.put(\"var_b\", (i % 3));\n+            processIds.add(processService.startProcess(deploymentUnit.getIdentifier(), \"test.test_B\", inputsB1));\n+        }\n+    }\n+\n+    @After\n+    public void cleanup() {\n+        for (Long processInstanceId : processIds) {\n+            try {\n+                // let's abort process instance to leave the system in clear state\n+                processService.abortProcessInstance(processInstanceId);\n+\n+                ProcessInstance pi = processService.getProcessInstance(processInstanceId);\n+                assertNull(pi);\n+            } catch (ProcessInstanceNotFoundException e) {\n+                // ignore it as it was already completed/aborted\n+            }\n+        }\n+        cleanupSingletonSessionId();\n+        if (units != null && !units.isEmpty()) {\n+            for (DeploymentUnit unit : units) {\n+                try {\n+                    deploymentService.undeploy(unit);\n+                } catch (Exception e) {\n+                    // do nothing in case of some failed tests to avoid next test to fail as well\n+                }\n+            }\n+            units.clear();\n+        }\n+        close();\n+    }\n+\n+    @Test\n+    public void testQueryProcessByVariables() {\n+        Map<String, Object> variables = Collections.<String, Object> singletonMap(\"var_a\", \"a1\");\n+        Map<String, Object> attributes = Collections.<String, Object> singletonMap(\"processId\", \"test.test_A\");\n+        List<ProcessInstanceWithVarsDesc> data = advanceVariableDataService.queryProcessByVariables(attributes, variables, new QueryContext());\n+        Assert.assertEquals(3, data.size());\n+        for (ProcessInstanceWithVarsDesc p : data) {\n+            Assert.assertEquals(\"a1\", p.getVariables().get(\"var_a\"));\n+            Assert.assertEquals(\"test.test_A\", p.getProcessId());\n+        }\n+    }\n+\n+    @Test\n+    public void testQueryProcessByVariablesWithPagination() {\n+        Map<String, Object> variables = Collections.<String, Object> singletonMap(\"var_a\", \"a1\");\n+        Map<String, Object> attributes = Collections.<String, Object> singletonMap(\"processId\", \"test.test_A\");\n+        List<ProcessInstanceWithVarsDesc> data = advanceVariableDataService.queryProcessByVariables(attributes, variables, new QueryContext(0, 2));\n+        Assert.assertEquals(2, data.size());\n+        for (ProcessInstanceWithVarsDesc p : data) {\n+            Assert.assertEquals(\"a1\", p.getVariables().get(\"var_a\"));\n+            Assert.assertEquals(\"test.test_A\", p.getProcessId());\n+        }\n+    }\n+\n+    @Test\n+    public void testQueryTaskByVariables() {\n+        Map<String, Object> variables = Collections.<String, Object> singletonMap(\"task_in_a1\", \"a0\");\n+        Map<String, Object> attributes = Collections.<String, Object> singletonMap(\"deploymentId\", \"org.jbpm.test:test-module:1.0.0\");\n+        List<String> potOwners = emptyList();\n+        List<UserTaskInstanceWithPotOwnerDesc> data = advanceVariableDataService.queryUserTasksByVariables(attributes, variables, emptyMap(), potOwners, new QueryContext());\n+        Assert.assertEquals(4, data.size());\n+        for (UserTaskInstanceWithPotOwnerDesc p : data) {\n+            Assert.assertEquals(\"a0\", p.getInputdata().get(\"task_in_a1\"));\n+            Assert.assertEquals(\"org.jbpm.test:test-module:1.0.0\", p.getDeploymentId());\n+        }\n+    }\n+\n+    @Test\n+    public void testQueryTaskByVariablesWithPagination() {\n+        Map<String, Object> variables = Collections.<String, Object> singletonMap(\"task_in_a1\", \"a0\");\n+        Map<String, Object> attributes = Collections.<String, Object> singletonMap(\"deploymentId\", \"org.jbpm.test:test-module:1.0.0\");\n+        List<String> potOwners = emptyList();\n+        List<UserTaskInstanceWithPotOwnerDesc> data = advanceVariableDataService.queryUserTasksByVariables(attributes, variables, emptyMap(), potOwners, new QueryContext(0, 2));\n+        Assert.assertEquals(2, data.size());\n+        for (UserTaskInstanceWithPotOwnerDesc p : data) {\n+            Assert.assertEquals(\"a0\", p.getInputdata().get(\"task_in_a1\"));\n+            Assert.assertEquals(\"org.jbpm.test:test-module:1.0.0\", p.getDeploymentId());\n+        }\n+    }\n+\n+    @Test\n+    public void testQueryTaskByVariablesWithOwners() {\n+        Map<String, Object> variables = emptyMap();\n+        Map<String, Object> attributes = emptyMap();\n+        List<String> potOwners = Collections.singletonList(\"katy\");\n+        List<UserTaskInstanceWithPotOwnerDesc> data = advanceVariableDataService.queryUserTasksByVariables(attributes, variables, emptyMap(), potOwners, new QueryContext(0, 2));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1e57dd6f9a77d2e636949457815115ca83acc4dc"}, "originalPosition": 191}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjM5MzEzNA==", "bodyText": "Is \"deploymentId\" part of the requirements? I don't see it listed on the filters table.", "url": "https://github.com/kiegroup/jbpm/pull/1615#discussion_r402393134", "createdAt": "2020-04-02T15:13:41Z", "author": {"login": "afalhambra"}, "path": "jbpm-services/jbpm-kie-services/src/test/java/org/jbpm/kie/services/test/AdvanceRuntimeDataServiceImplTest.java", "diffHunk": "@@ -0,0 +1,219 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.jbpm.kie.services.test;\n+\n+import java.io.File;\n+import java.io.FileOutputStream;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.drools.compiler.kie.builder.impl.InternalKieModule;\n+import org.jbpm.kie.services.impl.KModuleDeploymentUnit;\n+import org.jbpm.kie.test.util.AbstractKieServicesBaseTest;\n+import org.jbpm.services.api.ProcessInstanceNotFoundException;\n+import org.jbpm.services.api.model.DeploymentUnit;\n+import org.jbpm.services.api.model.ProcessInstanceWithVarsDesc;\n+import org.jbpm.services.api.model.UserTaskInstanceWithPotOwnerDesc;\n+import org.junit.After;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.kie.api.KieServices;\n+import org.kie.api.builder.ReleaseId;\n+import org.kie.api.runtime.process.ProcessInstance;\n+import org.kie.internal.query.QueryContext;\n+import org.kie.scanner.KieMavenRepository;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static java.util.Collections.emptyList;\n+import static java.util.Collections.emptyMap;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertNull;\n+import static org.kie.scanner.KieMavenRepository.getKieMavenRepository;\n+\n+public class AdvanceRuntimeDataServiceImplTest extends AbstractKieServicesBaseTest {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(AdvanceRuntimeDataServiceImplTest.class);\n+\n+    private List<DeploymentUnit> units = new ArrayList<DeploymentUnit>();\n+    protected String correctUser = \"testUser\";\n+    protected String wrongUser = \"wrongUser\";\n+\n+    private List<Long> processIds;\n+    private KModuleDeploymentUnit deploymentUnit = null;\n+\n+    @Before\n+    public void prepare() {\n+\n+        configureServices();\n+        logger.debug(\"Preparing kjar\");\n+        KieServices ks = KieServices.Factory.get();\n+        ReleaseId releaseId = ks.newReleaseId(GROUP_ID, ARTIFACT_ID, VERSION);\n+        List<String> processes = new ArrayList<String>();\n+        processes.add(\"repo/processes/general/SingleHumanTaskWithVarsA.bpmn2\");\n+        processes.add(\"repo/processes/general/SingleHumanTaskWithVarsB.bpmn2\");\n+\n+        InternalKieModule kJar1 = createKieJar(ks, releaseId, processes);\n+        File pom = new File(\"target/kmodule\", \"pom.xml\");\n+        pom.getParentFile().mkdir();\n+        try (FileOutputStream fs = new FileOutputStream(pom);) {\n+            fs.write(getPom(releaseId).getBytes());\n+        } catch (Exception e) {\n+\n+        }\n+        KieMavenRepository repository = getKieMavenRepository();\n+        repository.deployArtifact(releaseId, kJar1, pom);\n+\n+        assertNotNull(deploymentService);\n+\n+        deploymentUnit = new KModuleDeploymentUnit(GROUP_ID, ARTIFACT_ID, VERSION);\n+\n+        deploymentService.deploy(deploymentUnit);\n+        units.add(deploymentUnit);\n+        assertNotNull(processService);\n+\n+        processIds = new ArrayList<>();\n+        for (int i = 0; i < 10; i++) {\n+            Map<String, Object> inputsA1 = new HashMap<>();\n+            inputsA1.put(\"var_a\", \"a\" + (i % 3));\n+            inputsA1.put(\"var_b\", (i % 3));\n+            processIds.add(processService.startProcess(deploymentUnit.getIdentifier(), \"test.test_A\", inputsA1));\n+        }\n+        for (int i = 0; i < 10; i++) {\n+            Map<String, Object> inputsB1 = new HashMap<>();\n+            inputsB1.put(\"var_a\", \"b\" + (i % 3));\n+            inputsB1.put(\"var_b\", (i % 3));\n+            processIds.add(processService.startProcess(deploymentUnit.getIdentifier(), \"test.test_B\", inputsB1));\n+        }\n+    }\n+\n+    @After\n+    public void cleanup() {\n+        for (Long processInstanceId : processIds) {\n+            try {\n+                // let's abort process instance to leave the system in clear state\n+                processService.abortProcessInstance(processInstanceId);\n+\n+                ProcessInstance pi = processService.getProcessInstance(processInstanceId);\n+                assertNull(pi);\n+            } catch (ProcessInstanceNotFoundException e) {\n+                // ignore it as it was already completed/aborted\n+            }\n+        }\n+        cleanupSingletonSessionId();\n+        if (units != null && !units.isEmpty()) {\n+            for (DeploymentUnit unit : units) {\n+                try {\n+                    deploymentService.undeploy(unit);\n+                } catch (Exception e) {\n+                    // do nothing in case of some failed tests to avoid next test to fail as well\n+                }\n+            }\n+            units.clear();\n+        }\n+        close();\n+    }\n+\n+    @Test\n+    public void testQueryProcessByVariables() {\n+        Map<String, Object> variables = Collections.<String, Object> singletonMap(\"var_a\", \"a1\");\n+        Map<String, Object> attributes = Collections.<String, Object> singletonMap(\"processId\", \"test.test_A\");\n+        List<ProcessInstanceWithVarsDesc> data = advanceVariableDataService.queryProcessByVariables(attributes, variables, new QueryContext());\n+        Assert.assertEquals(3, data.size());\n+        for (ProcessInstanceWithVarsDesc p : data) {\n+            Assert.assertEquals(\"a1\", p.getVariables().get(\"var_a\"));\n+            Assert.assertEquals(\"test.test_A\", p.getProcessId());\n+        }\n+    }\n+\n+    @Test\n+    public void testQueryProcessByVariablesWithPagination() {\n+        Map<String, Object> variables = Collections.<String, Object> singletonMap(\"var_a\", \"a1\");\n+        Map<String, Object> attributes = Collections.<String, Object> singletonMap(\"processId\", \"test.test_A\");\n+        List<ProcessInstanceWithVarsDesc> data = advanceVariableDataService.queryProcessByVariables(attributes, variables, new QueryContext(0, 2));\n+        Assert.assertEquals(2, data.size());\n+        for (ProcessInstanceWithVarsDesc p : data) {\n+            Assert.assertEquals(\"a1\", p.getVariables().get(\"var_a\"));\n+            Assert.assertEquals(\"test.test_A\", p.getProcessId());\n+        }\n+    }\n+\n+    @Test\n+    public void testQueryTaskByVariables() {\n+        Map<String, Object> variables = Collections.<String, Object> singletonMap(\"task_in_a1\", \"a0\");\n+        Map<String, Object> attributes = Collections.<String, Object> singletonMap(\"deploymentId\", \"org.jbpm.test:test-module:1.0.0\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1e57dd6f9a77d2e636949457815115ca83acc4dc"}, "originalPosition": 163}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjQwMDI0NQ==", "bodyText": "Shouldn't return any record that matches with one of the owners? If I set potOwners as \"katy\" and \"nobody\", I would expect to get all the records concerning to the potential owner for the task. In this case it would be all the tasks for \"katy\" - data.size()=10?", "url": "https://github.com/kiegroup/jbpm/pull/1615#discussion_r402400245", "createdAt": "2020-04-02T15:23:07Z", "author": {"login": "afalhambra"}, "path": "jbpm-services/jbpm-kie-services/src/test/java/org/jbpm/kie/services/test/AdvanceRuntimeDataServiceImplTest.java", "diffHunk": "@@ -0,0 +1,219 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.jbpm.kie.services.test;\n+\n+import java.io.File;\n+import java.io.FileOutputStream;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.drools.compiler.kie.builder.impl.InternalKieModule;\n+import org.jbpm.kie.services.impl.KModuleDeploymentUnit;\n+import org.jbpm.kie.test.util.AbstractKieServicesBaseTest;\n+import org.jbpm.services.api.ProcessInstanceNotFoundException;\n+import org.jbpm.services.api.model.DeploymentUnit;\n+import org.jbpm.services.api.model.ProcessInstanceWithVarsDesc;\n+import org.jbpm.services.api.model.UserTaskInstanceWithPotOwnerDesc;\n+import org.junit.After;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.kie.api.KieServices;\n+import org.kie.api.builder.ReleaseId;\n+import org.kie.api.runtime.process.ProcessInstance;\n+import org.kie.internal.query.QueryContext;\n+import org.kie.scanner.KieMavenRepository;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static java.util.Collections.emptyList;\n+import static java.util.Collections.emptyMap;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertNull;\n+import static org.kie.scanner.KieMavenRepository.getKieMavenRepository;\n+\n+public class AdvanceRuntimeDataServiceImplTest extends AbstractKieServicesBaseTest {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(AdvanceRuntimeDataServiceImplTest.class);\n+\n+    private List<DeploymentUnit> units = new ArrayList<DeploymentUnit>();\n+    protected String correctUser = \"testUser\";\n+    protected String wrongUser = \"wrongUser\";\n+\n+    private List<Long> processIds;\n+    private KModuleDeploymentUnit deploymentUnit = null;\n+\n+    @Before\n+    public void prepare() {\n+\n+        configureServices();\n+        logger.debug(\"Preparing kjar\");\n+        KieServices ks = KieServices.Factory.get();\n+        ReleaseId releaseId = ks.newReleaseId(GROUP_ID, ARTIFACT_ID, VERSION);\n+        List<String> processes = new ArrayList<String>();\n+        processes.add(\"repo/processes/general/SingleHumanTaskWithVarsA.bpmn2\");\n+        processes.add(\"repo/processes/general/SingleHumanTaskWithVarsB.bpmn2\");\n+\n+        InternalKieModule kJar1 = createKieJar(ks, releaseId, processes);\n+        File pom = new File(\"target/kmodule\", \"pom.xml\");\n+        pom.getParentFile().mkdir();\n+        try (FileOutputStream fs = new FileOutputStream(pom);) {\n+            fs.write(getPom(releaseId).getBytes());\n+        } catch (Exception e) {\n+\n+        }\n+        KieMavenRepository repository = getKieMavenRepository();\n+        repository.deployArtifact(releaseId, kJar1, pom);\n+\n+        assertNotNull(deploymentService);\n+\n+        deploymentUnit = new KModuleDeploymentUnit(GROUP_ID, ARTIFACT_ID, VERSION);\n+\n+        deploymentService.deploy(deploymentUnit);\n+        units.add(deploymentUnit);\n+        assertNotNull(processService);\n+\n+        processIds = new ArrayList<>();\n+        for (int i = 0; i < 10; i++) {\n+            Map<String, Object> inputsA1 = new HashMap<>();\n+            inputsA1.put(\"var_a\", \"a\" + (i % 3));\n+            inputsA1.put(\"var_b\", (i % 3));\n+            processIds.add(processService.startProcess(deploymentUnit.getIdentifier(), \"test.test_A\", inputsA1));\n+        }\n+        for (int i = 0; i < 10; i++) {\n+            Map<String, Object> inputsB1 = new HashMap<>();\n+            inputsB1.put(\"var_a\", \"b\" + (i % 3));\n+            inputsB1.put(\"var_b\", (i % 3));\n+            processIds.add(processService.startProcess(deploymentUnit.getIdentifier(), \"test.test_B\", inputsB1));\n+        }\n+    }\n+\n+    @After\n+    public void cleanup() {\n+        for (Long processInstanceId : processIds) {\n+            try {\n+                // let's abort process instance to leave the system in clear state\n+                processService.abortProcessInstance(processInstanceId);\n+\n+                ProcessInstance pi = processService.getProcessInstance(processInstanceId);\n+                assertNull(pi);\n+            } catch (ProcessInstanceNotFoundException e) {\n+                // ignore it as it was already completed/aborted\n+            }\n+        }\n+        cleanupSingletonSessionId();\n+        if (units != null && !units.isEmpty()) {\n+            for (DeploymentUnit unit : units) {\n+                try {\n+                    deploymentService.undeploy(unit);\n+                } catch (Exception e) {\n+                    // do nothing in case of some failed tests to avoid next test to fail as well\n+                }\n+            }\n+            units.clear();\n+        }\n+        close();\n+    }\n+\n+    @Test\n+    public void testQueryProcessByVariables() {\n+        Map<String, Object> variables = Collections.<String, Object> singletonMap(\"var_a\", \"a1\");\n+        Map<String, Object> attributes = Collections.<String, Object> singletonMap(\"processId\", \"test.test_A\");\n+        List<ProcessInstanceWithVarsDesc> data = advanceVariableDataService.queryProcessByVariables(attributes, variables, new QueryContext());\n+        Assert.assertEquals(3, data.size());\n+        for (ProcessInstanceWithVarsDesc p : data) {\n+            Assert.assertEquals(\"a1\", p.getVariables().get(\"var_a\"));\n+            Assert.assertEquals(\"test.test_A\", p.getProcessId());\n+        }\n+    }\n+\n+    @Test\n+    public void testQueryProcessByVariablesWithPagination() {\n+        Map<String, Object> variables = Collections.<String, Object> singletonMap(\"var_a\", \"a1\");\n+        Map<String, Object> attributes = Collections.<String, Object> singletonMap(\"processId\", \"test.test_A\");\n+        List<ProcessInstanceWithVarsDesc> data = advanceVariableDataService.queryProcessByVariables(attributes, variables, new QueryContext(0, 2));\n+        Assert.assertEquals(2, data.size());\n+        for (ProcessInstanceWithVarsDesc p : data) {\n+            Assert.assertEquals(\"a1\", p.getVariables().get(\"var_a\"));\n+            Assert.assertEquals(\"test.test_A\", p.getProcessId());\n+        }\n+    }\n+\n+    @Test\n+    public void testQueryTaskByVariables() {\n+        Map<String, Object> variables = Collections.<String, Object> singletonMap(\"task_in_a1\", \"a0\");\n+        Map<String, Object> attributes = Collections.<String, Object> singletonMap(\"deploymentId\", \"org.jbpm.test:test-module:1.0.0\");\n+        List<String> potOwners = emptyList();\n+        List<UserTaskInstanceWithPotOwnerDesc> data = advanceVariableDataService.queryUserTasksByVariables(attributes, variables, emptyMap(), potOwners, new QueryContext());\n+        Assert.assertEquals(4, data.size());\n+        for (UserTaskInstanceWithPotOwnerDesc p : data) {\n+            Assert.assertEquals(\"a0\", p.getInputdata().get(\"task_in_a1\"));\n+            Assert.assertEquals(\"org.jbpm.test:test-module:1.0.0\", p.getDeploymentId());\n+        }\n+    }\n+\n+    @Test\n+    public void testQueryTaskByVariablesWithPagination() {\n+        Map<String, Object> variables = Collections.<String, Object> singletonMap(\"task_in_a1\", \"a0\");\n+        Map<String, Object> attributes = Collections.<String, Object> singletonMap(\"deploymentId\", \"org.jbpm.test:test-module:1.0.0\");\n+        List<String> potOwners = emptyList();\n+        List<UserTaskInstanceWithPotOwnerDesc> data = advanceVariableDataService.queryUserTasksByVariables(attributes, variables, emptyMap(), potOwners, new QueryContext(0, 2));\n+        Assert.assertEquals(2, data.size());\n+        for (UserTaskInstanceWithPotOwnerDesc p : data) {\n+            Assert.assertEquals(\"a0\", p.getInputdata().get(\"task_in_a1\"));\n+            Assert.assertEquals(\"org.jbpm.test:test-module:1.0.0\", p.getDeploymentId());\n+        }\n+    }\n+\n+    @Test\n+    public void testQueryTaskByVariablesWithOwners() {\n+        Map<String, Object> variables = emptyMap();\n+        Map<String, Object> attributes = emptyMap();\n+        List<String> potOwners = Collections.singletonList(\"katy\");\n+        List<UserTaskInstanceWithPotOwnerDesc> data = advanceVariableDataService.queryUserTasksByVariables(attributes, variables, emptyMap(), potOwners, new QueryContext(0, 2));\n+        Assert.assertEquals(2, data.size());\n+        for (UserTaskInstanceWithPotOwnerDesc p : data) {\n+            Assert.assertTrue(p.getPotentialOwners().contains(\"katy\"));\n+        }\n+    }\n+\n+    @Test\n+    public void testQueryTaskByVariablesWithAllOwners() {\n+        Map<String, Object> variables = emptyMap();\n+        Map<String, Object> attributes = emptyMap();\n+        List<String> potOwners = Arrays.asList(\"katy\", \"nobody\");\n+        List<UserTaskInstanceWithPotOwnerDesc> data = advanceVariableDataService.queryUserTasksByVariables(attributes, variables, emptyMap(), potOwners, new QueryContext(0, 2));\n+        Assert.assertEquals(0, data.size());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1e57dd6f9a77d2e636949457815115ca83acc4dc"}, "originalPosition": 204}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjQwMTIwNA==", "bodyText": "I would probably not use pagination to avoid any confusion in the test. I would create a separate test for pagination.", "url": "https://github.com/kiegroup/jbpm/pull/1615#discussion_r402401204", "createdAt": "2020-04-02T15:24:21Z", "author": {"login": "afalhambra"}, "path": "jbpm-services/jbpm-kie-services/src/test/java/org/jbpm/kie/services/test/AdvanceRuntimeDataServiceImplTest.java", "diffHunk": "@@ -0,0 +1,219 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.jbpm.kie.services.test;\n+\n+import java.io.File;\n+import java.io.FileOutputStream;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.drools.compiler.kie.builder.impl.InternalKieModule;\n+import org.jbpm.kie.services.impl.KModuleDeploymentUnit;\n+import org.jbpm.kie.test.util.AbstractKieServicesBaseTest;\n+import org.jbpm.services.api.ProcessInstanceNotFoundException;\n+import org.jbpm.services.api.model.DeploymentUnit;\n+import org.jbpm.services.api.model.ProcessInstanceWithVarsDesc;\n+import org.jbpm.services.api.model.UserTaskInstanceWithPotOwnerDesc;\n+import org.junit.After;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.kie.api.KieServices;\n+import org.kie.api.builder.ReleaseId;\n+import org.kie.api.runtime.process.ProcessInstance;\n+import org.kie.internal.query.QueryContext;\n+import org.kie.scanner.KieMavenRepository;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static java.util.Collections.emptyList;\n+import static java.util.Collections.emptyMap;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertNull;\n+import static org.kie.scanner.KieMavenRepository.getKieMavenRepository;\n+\n+public class AdvanceRuntimeDataServiceImplTest extends AbstractKieServicesBaseTest {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(AdvanceRuntimeDataServiceImplTest.class);\n+\n+    private List<DeploymentUnit> units = new ArrayList<DeploymentUnit>();\n+    protected String correctUser = \"testUser\";\n+    protected String wrongUser = \"wrongUser\";\n+\n+    private List<Long> processIds;\n+    private KModuleDeploymentUnit deploymentUnit = null;\n+\n+    @Before\n+    public void prepare() {\n+\n+        configureServices();\n+        logger.debug(\"Preparing kjar\");\n+        KieServices ks = KieServices.Factory.get();\n+        ReleaseId releaseId = ks.newReleaseId(GROUP_ID, ARTIFACT_ID, VERSION);\n+        List<String> processes = new ArrayList<String>();\n+        processes.add(\"repo/processes/general/SingleHumanTaskWithVarsA.bpmn2\");\n+        processes.add(\"repo/processes/general/SingleHumanTaskWithVarsB.bpmn2\");\n+\n+        InternalKieModule kJar1 = createKieJar(ks, releaseId, processes);\n+        File pom = new File(\"target/kmodule\", \"pom.xml\");\n+        pom.getParentFile().mkdir();\n+        try (FileOutputStream fs = new FileOutputStream(pom);) {\n+            fs.write(getPom(releaseId).getBytes());\n+        } catch (Exception e) {\n+\n+        }\n+        KieMavenRepository repository = getKieMavenRepository();\n+        repository.deployArtifact(releaseId, kJar1, pom);\n+\n+        assertNotNull(deploymentService);\n+\n+        deploymentUnit = new KModuleDeploymentUnit(GROUP_ID, ARTIFACT_ID, VERSION);\n+\n+        deploymentService.deploy(deploymentUnit);\n+        units.add(deploymentUnit);\n+        assertNotNull(processService);\n+\n+        processIds = new ArrayList<>();\n+        for (int i = 0; i < 10; i++) {\n+            Map<String, Object> inputsA1 = new HashMap<>();\n+            inputsA1.put(\"var_a\", \"a\" + (i % 3));\n+            inputsA1.put(\"var_b\", (i % 3));\n+            processIds.add(processService.startProcess(deploymentUnit.getIdentifier(), \"test.test_A\", inputsA1));\n+        }\n+        for (int i = 0; i < 10; i++) {\n+            Map<String, Object> inputsB1 = new HashMap<>();\n+            inputsB1.put(\"var_a\", \"b\" + (i % 3));\n+            inputsB1.put(\"var_b\", (i % 3));\n+            processIds.add(processService.startProcess(deploymentUnit.getIdentifier(), \"test.test_B\", inputsB1));\n+        }\n+    }\n+\n+    @After\n+    public void cleanup() {\n+        for (Long processInstanceId : processIds) {\n+            try {\n+                // let's abort process instance to leave the system in clear state\n+                processService.abortProcessInstance(processInstanceId);\n+\n+                ProcessInstance pi = processService.getProcessInstance(processInstanceId);\n+                assertNull(pi);\n+            } catch (ProcessInstanceNotFoundException e) {\n+                // ignore it as it was already completed/aborted\n+            }\n+        }\n+        cleanupSingletonSessionId();\n+        if (units != null && !units.isEmpty()) {\n+            for (DeploymentUnit unit : units) {\n+                try {\n+                    deploymentService.undeploy(unit);\n+                } catch (Exception e) {\n+                    // do nothing in case of some failed tests to avoid next test to fail as well\n+                }\n+            }\n+            units.clear();\n+        }\n+        close();\n+    }\n+\n+    @Test\n+    public void testQueryProcessByVariables() {\n+        Map<String, Object> variables = Collections.<String, Object> singletonMap(\"var_a\", \"a1\");\n+        Map<String, Object> attributes = Collections.<String, Object> singletonMap(\"processId\", \"test.test_A\");\n+        List<ProcessInstanceWithVarsDesc> data = advanceVariableDataService.queryProcessByVariables(attributes, variables, new QueryContext());\n+        Assert.assertEquals(3, data.size());\n+        for (ProcessInstanceWithVarsDesc p : data) {\n+            Assert.assertEquals(\"a1\", p.getVariables().get(\"var_a\"));\n+            Assert.assertEquals(\"test.test_A\", p.getProcessId());\n+        }\n+    }\n+\n+    @Test\n+    public void testQueryProcessByVariablesWithPagination() {\n+        Map<String, Object> variables = Collections.<String, Object> singletonMap(\"var_a\", \"a1\");\n+        Map<String, Object> attributes = Collections.<String, Object> singletonMap(\"processId\", \"test.test_A\");\n+        List<ProcessInstanceWithVarsDesc> data = advanceVariableDataService.queryProcessByVariables(attributes, variables, new QueryContext(0, 2));\n+        Assert.assertEquals(2, data.size());\n+        for (ProcessInstanceWithVarsDesc p : data) {\n+            Assert.assertEquals(\"a1\", p.getVariables().get(\"var_a\"));\n+            Assert.assertEquals(\"test.test_A\", p.getProcessId());\n+        }\n+    }\n+\n+    @Test\n+    public void testQueryTaskByVariables() {\n+        Map<String, Object> variables = Collections.<String, Object> singletonMap(\"task_in_a1\", \"a0\");\n+        Map<String, Object> attributes = Collections.<String, Object> singletonMap(\"deploymentId\", \"org.jbpm.test:test-module:1.0.0\");\n+        List<String> potOwners = emptyList();\n+        List<UserTaskInstanceWithPotOwnerDesc> data = advanceVariableDataService.queryUserTasksByVariables(attributes, variables, emptyMap(), potOwners, new QueryContext());\n+        Assert.assertEquals(4, data.size());\n+        for (UserTaskInstanceWithPotOwnerDesc p : data) {\n+            Assert.assertEquals(\"a0\", p.getInputdata().get(\"task_in_a1\"));\n+            Assert.assertEquals(\"org.jbpm.test:test-module:1.0.0\", p.getDeploymentId());\n+        }\n+    }\n+\n+    @Test\n+    public void testQueryTaskByVariablesWithPagination() {\n+        Map<String, Object> variables = Collections.<String, Object> singletonMap(\"task_in_a1\", \"a0\");\n+        Map<String, Object> attributes = Collections.<String, Object> singletonMap(\"deploymentId\", \"org.jbpm.test:test-module:1.0.0\");\n+        List<String> potOwners = emptyList();\n+        List<UserTaskInstanceWithPotOwnerDesc> data = advanceVariableDataService.queryUserTasksByVariables(attributes, variables, emptyMap(), potOwners, new QueryContext(0, 2));\n+        Assert.assertEquals(2, data.size());\n+        for (UserTaskInstanceWithPotOwnerDesc p : data) {\n+            Assert.assertEquals(\"a0\", p.getInputdata().get(\"task_in_a1\"));\n+            Assert.assertEquals(\"org.jbpm.test:test-module:1.0.0\", p.getDeploymentId());\n+        }\n+    }\n+\n+    @Test\n+    public void testQueryTaskByVariablesWithOwners() {\n+        Map<String, Object> variables = emptyMap();\n+        Map<String, Object> attributes = emptyMap();\n+        List<String> potOwners = Collections.singletonList(\"katy\");\n+        List<UserTaskInstanceWithPotOwnerDesc> data = advanceVariableDataService.queryUserTasksByVariables(attributes, variables, emptyMap(), potOwners, new QueryContext(0, 2));\n+        Assert.assertEquals(2, data.size());\n+        for (UserTaskInstanceWithPotOwnerDesc p : data) {\n+            Assert.assertTrue(p.getPotentialOwners().contains(\"katy\"));\n+        }\n+    }\n+\n+    @Test\n+    public void testQueryTaskByVariablesWithAllOwners() {\n+        Map<String, Object> variables = emptyMap();\n+        Map<String, Object> attributes = emptyMap();\n+        List<String> potOwners = Arrays.asList(\"katy\", \"nobody\");\n+        List<UserTaskInstanceWithPotOwnerDesc> data = advanceVariableDataService.queryUserTasksByVariables(attributes, variables, emptyMap(), potOwners, new QueryContext(0, 2));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1e57dd6f9a77d2e636949457815115ca83acc4dc"}, "originalPosition": 203}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjQxNjc0Mg==", "bodyText": "Number of instances matching search criteria ( processVariable = \"var_a\", \"a1\" ) are 3, or am I missing something?.\nIf I change it to the following below, I get data size = 3 (which I presume it is correct):\nMap<String, Object> variables = Collections.<String, Object> singletonMap(\"task_in_a1\", \"a1\");", "url": "https://github.com/kiegroup/jbpm/pull/1615#discussion_r402416742", "createdAt": "2020-04-02T15:45:28Z", "author": {"login": "afalhambra"}, "path": "jbpm-services/jbpm-kie-services/src/test/java/org/jbpm/kie/services/test/AdvanceRuntimeDataServiceImplTest.java", "diffHunk": "@@ -0,0 +1,219 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.jbpm.kie.services.test;\n+\n+import java.io.File;\n+import java.io.FileOutputStream;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.drools.compiler.kie.builder.impl.InternalKieModule;\n+import org.jbpm.kie.services.impl.KModuleDeploymentUnit;\n+import org.jbpm.kie.test.util.AbstractKieServicesBaseTest;\n+import org.jbpm.services.api.ProcessInstanceNotFoundException;\n+import org.jbpm.services.api.model.DeploymentUnit;\n+import org.jbpm.services.api.model.ProcessInstanceWithVarsDesc;\n+import org.jbpm.services.api.model.UserTaskInstanceWithPotOwnerDesc;\n+import org.junit.After;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.kie.api.KieServices;\n+import org.kie.api.builder.ReleaseId;\n+import org.kie.api.runtime.process.ProcessInstance;\n+import org.kie.internal.query.QueryContext;\n+import org.kie.scanner.KieMavenRepository;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static java.util.Collections.emptyList;\n+import static java.util.Collections.emptyMap;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertNull;\n+import static org.kie.scanner.KieMavenRepository.getKieMavenRepository;\n+\n+public class AdvanceRuntimeDataServiceImplTest extends AbstractKieServicesBaseTest {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(AdvanceRuntimeDataServiceImplTest.class);\n+\n+    private List<DeploymentUnit> units = new ArrayList<DeploymentUnit>();\n+    protected String correctUser = \"testUser\";\n+    protected String wrongUser = \"wrongUser\";\n+\n+    private List<Long> processIds;\n+    private KModuleDeploymentUnit deploymentUnit = null;\n+\n+    @Before\n+    public void prepare() {\n+\n+        configureServices();\n+        logger.debug(\"Preparing kjar\");\n+        KieServices ks = KieServices.Factory.get();\n+        ReleaseId releaseId = ks.newReleaseId(GROUP_ID, ARTIFACT_ID, VERSION);\n+        List<String> processes = new ArrayList<String>();\n+        processes.add(\"repo/processes/general/SingleHumanTaskWithVarsA.bpmn2\");\n+        processes.add(\"repo/processes/general/SingleHumanTaskWithVarsB.bpmn2\");\n+\n+        InternalKieModule kJar1 = createKieJar(ks, releaseId, processes);\n+        File pom = new File(\"target/kmodule\", \"pom.xml\");\n+        pom.getParentFile().mkdir();\n+        try (FileOutputStream fs = new FileOutputStream(pom);) {\n+            fs.write(getPom(releaseId).getBytes());\n+        } catch (Exception e) {\n+\n+        }\n+        KieMavenRepository repository = getKieMavenRepository();\n+        repository.deployArtifact(releaseId, kJar1, pom);\n+\n+        assertNotNull(deploymentService);\n+\n+        deploymentUnit = new KModuleDeploymentUnit(GROUP_ID, ARTIFACT_ID, VERSION);\n+\n+        deploymentService.deploy(deploymentUnit);\n+        units.add(deploymentUnit);\n+        assertNotNull(processService);\n+\n+        processIds = new ArrayList<>();\n+        for (int i = 0; i < 10; i++) {\n+            Map<String, Object> inputsA1 = new HashMap<>();\n+            inputsA1.put(\"var_a\", \"a\" + (i % 3));\n+            inputsA1.put(\"var_b\", (i % 3));\n+            processIds.add(processService.startProcess(deploymentUnit.getIdentifier(), \"test.test_A\", inputsA1));\n+        }\n+        for (int i = 0; i < 10; i++) {\n+            Map<String, Object> inputsB1 = new HashMap<>();\n+            inputsB1.put(\"var_a\", \"b\" + (i % 3));\n+            inputsB1.put(\"var_b\", (i % 3));\n+            processIds.add(processService.startProcess(deploymentUnit.getIdentifier(), \"test.test_B\", inputsB1));\n+        }\n+    }\n+\n+    @After\n+    public void cleanup() {\n+        for (Long processInstanceId : processIds) {\n+            try {\n+                // let's abort process instance to leave the system in clear state\n+                processService.abortProcessInstance(processInstanceId);\n+\n+                ProcessInstance pi = processService.getProcessInstance(processInstanceId);\n+                assertNull(pi);\n+            } catch (ProcessInstanceNotFoundException e) {\n+                // ignore it as it was already completed/aborted\n+            }\n+        }\n+        cleanupSingletonSessionId();\n+        if (units != null && !units.isEmpty()) {\n+            for (DeploymentUnit unit : units) {\n+                try {\n+                    deploymentService.undeploy(unit);\n+                } catch (Exception e) {\n+                    // do nothing in case of some failed tests to avoid next test to fail as well\n+                }\n+            }\n+            units.clear();\n+        }\n+        close();\n+    }\n+\n+    @Test\n+    public void testQueryProcessByVariables() {\n+        Map<String, Object> variables = Collections.<String, Object> singletonMap(\"var_a\", \"a1\");\n+        Map<String, Object> attributes = Collections.<String, Object> singletonMap(\"processId\", \"test.test_A\");\n+        List<ProcessInstanceWithVarsDesc> data = advanceVariableDataService.queryProcessByVariables(attributes, variables, new QueryContext());\n+        Assert.assertEquals(3, data.size());\n+        for (ProcessInstanceWithVarsDesc p : data) {\n+            Assert.assertEquals(\"a1\", p.getVariables().get(\"var_a\"));\n+            Assert.assertEquals(\"test.test_A\", p.getProcessId());\n+        }\n+    }\n+\n+    @Test\n+    public void testQueryProcessByVariablesWithPagination() {\n+        Map<String, Object> variables = Collections.<String, Object> singletonMap(\"var_a\", \"a1\");\n+        Map<String, Object> attributes = Collections.<String, Object> singletonMap(\"processId\", \"test.test_A\");\n+        List<ProcessInstanceWithVarsDesc> data = advanceVariableDataService.queryProcessByVariables(attributes, variables, new QueryContext(0, 2));\n+        Assert.assertEquals(2, data.size());\n+        for (ProcessInstanceWithVarsDesc p : data) {\n+            Assert.assertEquals(\"a1\", p.getVariables().get(\"var_a\"));\n+            Assert.assertEquals(\"test.test_A\", p.getProcessId());\n+        }\n+    }\n+\n+    @Test\n+    public void testQueryTaskByVariables() {\n+        Map<String, Object> variables = Collections.<String, Object> singletonMap(\"task_in_a1\", \"a0\");\n+        Map<String, Object> attributes = Collections.<String, Object> singletonMap(\"deploymentId\", \"org.jbpm.test:test-module:1.0.0\");\n+        List<String> potOwners = emptyList();\n+        List<UserTaskInstanceWithPotOwnerDesc> data = advanceVariableDataService.queryUserTasksByVariables(attributes, variables, emptyMap(), potOwners, new QueryContext());\n+        Assert.assertEquals(4, data.size());\n+        for (UserTaskInstanceWithPotOwnerDesc p : data) {\n+            Assert.assertEquals(\"a0\", p.getInputdata().get(\"task_in_a1\"));\n+            Assert.assertEquals(\"org.jbpm.test:test-module:1.0.0\", p.getDeploymentId());\n+        }\n+    }\n+\n+    @Test\n+    public void testQueryTaskByVariablesWithPagination() {\n+        Map<String, Object> variables = Collections.<String, Object> singletonMap(\"task_in_a1\", \"a0\");\n+        Map<String, Object> attributes = Collections.<String, Object> singletonMap(\"deploymentId\", \"org.jbpm.test:test-module:1.0.0\");\n+        List<String> potOwners = emptyList();\n+        List<UserTaskInstanceWithPotOwnerDesc> data = advanceVariableDataService.queryUserTasksByVariables(attributes, variables, emptyMap(), potOwners, new QueryContext(0, 2));\n+        Assert.assertEquals(2, data.size());\n+        for (UserTaskInstanceWithPotOwnerDesc p : data) {\n+            Assert.assertEquals(\"a0\", p.getInputdata().get(\"task_in_a1\"));\n+            Assert.assertEquals(\"org.jbpm.test:test-module:1.0.0\", p.getDeploymentId());\n+        }\n+    }\n+\n+    @Test\n+    public void testQueryTaskByVariablesWithOwners() {\n+        Map<String, Object> variables = emptyMap();\n+        Map<String, Object> attributes = emptyMap();\n+        List<String> potOwners = Collections.singletonList(\"katy\");\n+        List<UserTaskInstanceWithPotOwnerDesc> data = advanceVariableDataService.queryUserTasksByVariables(attributes, variables, emptyMap(), potOwners, new QueryContext(0, 2));\n+        Assert.assertEquals(2, data.size());\n+        for (UserTaskInstanceWithPotOwnerDesc p : data) {\n+            Assert.assertTrue(p.getPotentialOwners().contains(\"katy\"));\n+        }\n+    }\n+\n+    @Test\n+    public void testQueryTaskByVariablesWithAllOwners() {\n+        Map<String, Object> variables = emptyMap();\n+        Map<String, Object> attributes = emptyMap();\n+        List<String> potOwners = Arrays.asList(\"katy\", \"nobody\");\n+        List<UserTaskInstanceWithPotOwnerDesc> data = advanceVariableDataService.queryUserTasksByVariables(attributes, variables, emptyMap(), potOwners, new QueryContext(0, 2));\n+        Assert.assertEquals(0, data.size());\n+\n+    }\n+\n+    @Test\n+    public void testQueryTaskByVariablesWithByProcessVar() {\n+        Map<String, Object> variables = emptyMap();\n+        Map<String, Object> attributes = emptyMap();\n+        Map<String, Object> processVariables = Collections.singletonMap(\"var_a\", \"a1\");\n+        List<String> potOwners = Collections.emptyList();\n+        List<UserTaskInstanceWithPotOwnerDesc> data = advanceVariableDataService.queryUserTasksByVariables(attributes, variables, processVariables, potOwners, new QueryContext(0, 2));\n+        Assert.assertEquals(2, data.size());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1e57dd6f9a77d2e636949457815115ca83acc4dc"}, "originalPosition": 215}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjQyMDk0NA==", "bodyText": "I think it would be good to add at least one test for each of the different filters we agreed on the jira ticket.\nAnd I'm missing some tests regarding:\nActual task owner | \u2718 | \u2718 | \u2713 | \u2713 | Filters by task actual owner\nCorrelation key | \u2713 | \u2713 | \u2713 | \u2713 | Filters by correlation key name\nTask name | \u2718 | \u2718 | \u2713 | \u2713 | Filters by task name\nProcess definition id | \u2718 | \u2713 | \u2718 | \u2713 | Filters by process definition id\nMaybe a test containing a combination of them with some pagination would be nice too, but maybe it is too much, wdyt?", "url": "https://github.com/kiegroup/jbpm/pull/1615#discussion_r402420944", "createdAt": "2020-04-02T15:51:18Z", "author": {"login": "afalhambra"}, "path": "jbpm-services/jbpm-kie-services/src/test/java/org/jbpm/kie/services/test/AdvanceRuntimeDataServiceImplTest.java", "diffHunk": "@@ -0,0 +1,219 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.jbpm.kie.services.test;\n+\n+import java.io.File;\n+import java.io.FileOutputStream;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.drools.compiler.kie.builder.impl.InternalKieModule;\n+import org.jbpm.kie.services.impl.KModuleDeploymentUnit;\n+import org.jbpm.kie.test.util.AbstractKieServicesBaseTest;\n+import org.jbpm.services.api.ProcessInstanceNotFoundException;\n+import org.jbpm.services.api.model.DeploymentUnit;\n+import org.jbpm.services.api.model.ProcessInstanceWithVarsDesc;\n+import org.jbpm.services.api.model.UserTaskInstanceWithPotOwnerDesc;\n+import org.junit.After;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.kie.api.KieServices;\n+import org.kie.api.builder.ReleaseId;\n+import org.kie.api.runtime.process.ProcessInstance;\n+import org.kie.internal.query.QueryContext;\n+import org.kie.scanner.KieMavenRepository;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static java.util.Collections.emptyList;\n+import static java.util.Collections.emptyMap;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertNull;\n+import static org.kie.scanner.KieMavenRepository.getKieMavenRepository;\n+\n+public class AdvanceRuntimeDataServiceImplTest extends AbstractKieServicesBaseTest {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(AdvanceRuntimeDataServiceImplTest.class);\n+\n+    private List<DeploymentUnit> units = new ArrayList<DeploymentUnit>();\n+    protected String correctUser = \"testUser\";\n+    protected String wrongUser = \"wrongUser\";\n+\n+    private List<Long> processIds;\n+    private KModuleDeploymentUnit deploymentUnit = null;\n+\n+    @Before\n+    public void prepare() {\n+\n+        configureServices();\n+        logger.debug(\"Preparing kjar\");\n+        KieServices ks = KieServices.Factory.get();\n+        ReleaseId releaseId = ks.newReleaseId(GROUP_ID, ARTIFACT_ID, VERSION);\n+        List<String> processes = new ArrayList<String>();\n+        processes.add(\"repo/processes/general/SingleHumanTaskWithVarsA.bpmn2\");\n+        processes.add(\"repo/processes/general/SingleHumanTaskWithVarsB.bpmn2\");\n+\n+        InternalKieModule kJar1 = createKieJar(ks, releaseId, processes);\n+        File pom = new File(\"target/kmodule\", \"pom.xml\");\n+        pom.getParentFile().mkdir();\n+        try (FileOutputStream fs = new FileOutputStream(pom);) {\n+            fs.write(getPom(releaseId).getBytes());\n+        } catch (Exception e) {\n+\n+        }\n+        KieMavenRepository repository = getKieMavenRepository();\n+        repository.deployArtifact(releaseId, kJar1, pom);\n+\n+        assertNotNull(deploymentService);\n+\n+        deploymentUnit = new KModuleDeploymentUnit(GROUP_ID, ARTIFACT_ID, VERSION);\n+\n+        deploymentService.deploy(deploymentUnit);\n+        units.add(deploymentUnit);\n+        assertNotNull(processService);\n+\n+        processIds = new ArrayList<>();\n+        for (int i = 0; i < 10; i++) {\n+            Map<String, Object> inputsA1 = new HashMap<>();\n+            inputsA1.put(\"var_a\", \"a\" + (i % 3));\n+            inputsA1.put(\"var_b\", (i % 3));\n+            processIds.add(processService.startProcess(deploymentUnit.getIdentifier(), \"test.test_A\", inputsA1));\n+        }\n+        for (int i = 0; i < 10; i++) {\n+            Map<String, Object> inputsB1 = new HashMap<>();\n+            inputsB1.put(\"var_a\", \"b\" + (i % 3));\n+            inputsB1.put(\"var_b\", (i % 3));\n+            processIds.add(processService.startProcess(deploymentUnit.getIdentifier(), \"test.test_B\", inputsB1));\n+        }\n+    }\n+\n+    @After\n+    public void cleanup() {\n+        for (Long processInstanceId : processIds) {\n+            try {\n+                // let's abort process instance to leave the system in clear state\n+                processService.abortProcessInstance(processInstanceId);\n+\n+                ProcessInstance pi = processService.getProcessInstance(processInstanceId);\n+                assertNull(pi);\n+            } catch (ProcessInstanceNotFoundException e) {\n+                // ignore it as it was already completed/aborted\n+            }\n+        }\n+        cleanupSingletonSessionId();\n+        if (units != null && !units.isEmpty()) {\n+            for (DeploymentUnit unit : units) {\n+                try {\n+                    deploymentService.undeploy(unit);\n+                } catch (Exception e) {\n+                    // do nothing in case of some failed tests to avoid next test to fail as well\n+                }\n+            }\n+            units.clear();\n+        }\n+        close();\n+    }\n+\n+    @Test\n+    public void testQueryProcessByVariables() {\n+        Map<String, Object> variables = Collections.<String, Object> singletonMap(\"var_a\", \"a1\");\n+        Map<String, Object> attributes = Collections.<String, Object> singletonMap(\"processId\", \"test.test_A\");\n+        List<ProcessInstanceWithVarsDesc> data = advanceVariableDataService.queryProcessByVariables(attributes, variables, new QueryContext());\n+        Assert.assertEquals(3, data.size());\n+        for (ProcessInstanceWithVarsDesc p : data) {\n+            Assert.assertEquals(\"a1\", p.getVariables().get(\"var_a\"));\n+            Assert.assertEquals(\"test.test_A\", p.getProcessId());\n+        }\n+    }\n+\n+    @Test\n+    public void testQueryProcessByVariablesWithPagination() {\n+        Map<String, Object> variables = Collections.<String, Object> singletonMap(\"var_a\", \"a1\");\n+        Map<String, Object> attributes = Collections.<String, Object> singletonMap(\"processId\", \"test.test_A\");\n+        List<ProcessInstanceWithVarsDesc> data = advanceVariableDataService.queryProcessByVariables(attributes, variables, new QueryContext(0, 2));\n+        Assert.assertEquals(2, data.size());\n+        for (ProcessInstanceWithVarsDesc p : data) {\n+            Assert.assertEquals(\"a1\", p.getVariables().get(\"var_a\"));\n+            Assert.assertEquals(\"test.test_A\", p.getProcessId());\n+        }\n+    }\n+\n+    @Test\n+    public void testQueryTaskByVariables() {\n+        Map<String, Object> variables = Collections.<String, Object> singletonMap(\"task_in_a1\", \"a0\");\n+        Map<String, Object> attributes = Collections.<String, Object> singletonMap(\"deploymentId\", \"org.jbpm.test:test-module:1.0.0\");\n+        List<String> potOwners = emptyList();\n+        List<UserTaskInstanceWithPotOwnerDesc> data = advanceVariableDataService.queryUserTasksByVariables(attributes, variables, emptyMap(), potOwners, new QueryContext());\n+        Assert.assertEquals(4, data.size());\n+        for (UserTaskInstanceWithPotOwnerDesc p : data) {\n+            Assert.assertEquals(\"a0\", p.getInputdata().get(\"task_in_a1\"));\n+            Assert.assertEquals(\"org.jbpm.test:test-module:1.0.0\", p.getDeploymentId());\n+        }\n+    }\n+\n+    @Test\n+    public void testQueryTaskByVariablesWithPagination() {\n+        Map<String, Object> variables = Collections.<String, Object> singletonMap(\"task_in_a1\", \"a0\");\n+        Map<String, Object> attributes = Collections.<String, Object> singletonMap(\"deploymentId\", \"org.jbpm.test:test-module:1.0.0\");\n+        List<String> potOwners = emptyList();\n+        List<UserTaskInstanceWithPotOwnerDesc> data = advanceVariableDataService.queryUserTasksByVariables(attributes, variables, emptyMap(), potOwners, new QueryContext(0, 2));\n+        Assert.assertEquals(2, data.size());\n+        for (UserTaskInstanceWithPotOwnerDesc p : data) {\n+            Assert.assertEquals(\"a0\", p.getInputdata().get(\"task_in_a1\"));\n+            Assert.assertEquals(\"org.jbpm.test:test-module:1.0.0\", p.getDeploymentId());\n+        }\n+    }\n+\n+    @Test\n+    public void testQueryTaskByVariablesWithOwners() {\n+        Map<String, Object> variables = emptyMap();\n+        Map<String, Object> attributes = emptyMap();\n+        List<String> potOwners = Collections.singletonList(\"katy\");\n+        List<UserTaskInstanceWithPotOwnerDesc> data = advanceVariableDataService.queryUserTasksByVariables(attributes, variables, emptyMap(), potOwners, new QueryContext(0, 2));\n+        Assert.assertEquals(2, data.size());\n+        for (UserTaskInstanceWithPotOwnerDesc p : data) {\n+            Assert.assertTrue(p.getPotentialOwners().contains(\"katy\"));\n+        }\n+    }\n+\n+    @Test\n+    public void testQueryTaskByVariablesWithAllOwners() {\n+        Map<String, Object> variables = emptyMap();\n+        Map<String, Object> attributes = emptyMap();\n+        List<String> potOwners = Arrays.asList(\"katy\", \"nobody\");\n+        List<UserTaskInstanceWithPotOwnerDesc> data = advanceVariableDataService.queryUserTasksByVariables(attributes, variables, emptyMap(), potOwners, new QueryContext(0, 2));\n+        Assert.assertEquals(0, data.size());\n+\n+    }\n+\n+    @Test\n+    public void testQueryTaskByVariablesWithByProcessVar() {\n+        Map<String, Object> variables = emptyMap();\n+        Map<String, Object> attributes = emptyMap();\n+        Map<String, Object> processVariables = Collections.singletonMap(\"var_a\", \"a1\");\n+        List<String> potOwners = Collections.emptyList();\n+        List<UserTaskInstanceWithPotOwnerDesc> data = advanceVariableDataService.queryUserTasksByVariables(attributes, variables, processVariables, potOwners, new QueryContext(0, 2));\n+        Assert.assertEquals(2, data.size());\n+\n+    }\n+\n+}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1e57dd6f9a77d2e636949457815115ca83acc4dc"}, "originalPosition": 219}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjQyOTU0MA==", "bodyText": "You mean \"for getting\" instead of \"adding\"?", "url": "https://github.com/kiegroup/jbpm/pull/1615#discussion_r402429540", "createdAt": "2020-04-02T16:03:02Z", "author": {"login": "afalhambra"}, "path": "jbpm-services/jbpm-services-api/src/build/revapi-config.json", "diffHunk": "@@ -1,23 +1,60 @@\n {\n-  \"filters\": {\n-    \"revapi\": {\n-      \"java\": {\n-        \"filter\": {\n-          \"_comment\": \"We don't want to check transitive classes, e.g. from kie-api, since we already check them in their own module.\",\n-          \"packages\": {\n-            \"regex\": true,\n-            \"include\": [\n-              \"org\\\\.jbpm\\\\.services\\\\.api.*\"\n+    \"filters\": {\n+        \"revapi\": {\n+            \"java\": {\n+                \"filter\": {\n+                    \"_comment\": \"We don't want to check transitive classes, e.g. from kie-api, since we already check them in their own module.\",\n+                    \"packages\": {\n+                        \"regex\": true,\n+                        \"include\": [\n+                            \"org\\\\.jbpm\\\\.services\\\\.api.*\"\n+                        ]\n+                    }\n+                }\n+            }\n+        }\n+    },\n+    \"ignores\": {\n+        \"revapi\": {\n+            \"_comment\": \"Changes between 7.33.0.Final and the current branch. These changes are desired and thus ignored.\",\n+            \"ignore\": [\n+                {\n+                    \"code\": \"java.method.addedToInterface\",\n+                    \"new\": \"method java.util.Map<java.lang.String, java.lang.Object> org.jbpm.services.api.model.UserTaskInstanceWithVarsDesc::getExtraData()\",\n+                    \"package\": \"org.jbpm.services.api.model\",\n+                    \"classSimpleName\": \"UserTaskInstanceWithVarsDesc\",\n+                    \"methodName\": \"getExtraData\",\n+                    \"elementKind\": \"method\",\n+                    \"justification\": \"new method for adding extra information to this entity\"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1e57dd6f9a77d2e636949457815115ca83acc4dc"}, "originalPosition": 37}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjQyOTc2Ng==", "bodyText": "You mean \"for getting\" instead of \"adding\"?", "url": "https://github.com/kiegroup/jbpm/pull/1615#discussion_r402429766", "createdAt": "2020-04-02T16:03:23Z", "author": {"login": "afalhambra"}, "path": "jbpm-services/jbpm-services-api/src/build/revapi-config.json", "diffHunk": "@@ -1,23 +1,60 @@\n {\n-  \"filters\": {\n-    \"revapi\": {\n-      \"java\": {\n-        \"filter\": {\n-          \"_comment\": \"We don't want to check transitive classes, e.g. from kie-api, since we already check them in their own module.\",\n-          \"packages\": {\n-            \"regex\": true,\n-            \"include\": [\n-              \"org\\\\.jbpm\\\\.services\\\\.api.*\"\n+    \"filters\": {\n+        \"revapi\": {\n+            \"java\": {\n+                \"filter\": {\n+                    \"_comment\": \"We don't want to check transitive classes, e.g. from kie-api, since we already check them in their own module.\",\n+                    \"packages\": {\n+                        \"regex\": true,\n+                        \"include\": [\n+                            \"org\\\\.jbpm\\\\.services\\\\.api.*\"\n+                        ]\n+                    }\n+                }\n+            }\n+        }\n+    },\n+    \"ignores\": {\n+        \"revapi\": {\n+            \"_comment\": \"Changes between 7.33.0.Final and the current branch. These changes are desired and thus ignored.\",\n+            \"ignore\": [\n+                {\n+                    \"code\": \"java.method.addedToInterface\",\n+                    \"new\": \"method java.util.Map<java.lang.String, java.lang.Object> org.jbpm.services.api.model.UserTaskInstanceWithVarsDesc::getExtraData()\",\n+                    \"package\": \"org.jbpm.services.api.model\",\n+                    \"classSimpleName\": \"UserTaskInstanceWithVarsDesc\",\n+                    \"methodName\": \"getExtraData\",\n+                    \"elementKind\": \"method\",\n+                    \"justification\": \"new method for adding extra information to this entity\"\n+                },\n+                {\n+                    \"code\": \"java.method.addedToInterface\",\n+                    \"new\": \"method java.util.Map<java.lang.String, java.lang.Object> org.jbpm.services.api.model.UserTaskInstanceWithPotOwnerDesc::getProcessVariables()\",\n+                    \"package\": \"org.jbpm.services.api.model\",\n+                    \"classSimpleName\": \"UserTaskInstanceWithPotOwnerDesc\",\n+                    \"methodName\": \"getProcessVariables\",\n+                    \"elementKind\": \"method\",\n+                    \"justification\": \"new method for adding process variables information to this entity\"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1e57dd6f9a77d2e636949457815115ca83acc4dc"}, "originalPosition": 46}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg4MDI5MDA1", "url": "https://github.com/kiegroup/jbpm/pull/1615#pullrequestreview-388029005", "createdAt": "2020-04-06T08:22:20Z", "commit": {"oid": "1e57dd6f9a77d2e636949457815115ca83acc4dc"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNlQwODoyMjoyMFrOGBMvFg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNlQwODoyNDo1OVrOGBM1KQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzkxMDQyMg==", "bodyText": "It must be in lowercase for mysql, etc.", "url": "https://github.com/kiegroup/jbpm/pull/1615#discussion_r403910422", "createdAt": "2020-04-06T08:22:20Z", "author": {"login": "gmunozfe"}, "path": "jbpm-services/jbpm-kie-services/src/main/resources/META-INF/Servicesorm.xml", "diffHunk": "@@ -1182,5 +1182,71 @@\n     </query>\n     <!-- hint name=\"org.hibernate.timeout\" value=\"200\"/ -->\n   </named-query>   \n-        \n+\n+\n+  <!-- advance runtime queries -->\n+  <named-native-query name=\"GeProcessInstanceByIdList\">\n+      <query>\n+        SELECT processInstanceId, processId, processName, processVersion, status, externalId, start_date, user_identity, correlationKey \n+          FROM ProcessInstanceLog pil \n+         WHERE processInstanceId IN (:idList) \n+      ORDER BY processInstanceId ASC \n+    </query>\n+  </named-native-query>\n+  \n+  <named-native-query name=\"GeVariablesByProcessInstanceIdList\">\n+      <query>\n+            SELECT A1.processInstanceId, A1.variableId, A1.value \n+              FROM VariableInstanceLog A1 \n+         LEFT JOIN VariableInstanceLog A2 ON A1.processId = A2.processId \n+                                         AND A1.processInstanceId = A2.processInstanceId \n+                                         AND A1.variableInstanceId = A2.variableInstanceId \n+                                         AND A1.log_date &#60; A2.log_date \n+             WHERE A2.log_date IS NULL AND A1.processInstanceId IN (:idList) \n+          ORDER BY A1.processInstanceId ASC \n+      </query>\n+  </named-native-query>\n+  <named-native-query name=\"GetTasksByIdList\">\n+      <query>\n+              SELECT task.id, task.name, task.formName, task.subject, \n+                     task.actualOwner_id, log.correlationKey, task.createdOn,\n+                     task.createdBy_id, task.expirationTime, task.priority,\n+                     task.status, log.processInstanceId, log.processId, log.externalId,\n+                     log.processInstanceDescription \n+                FROM Task task \n+          INNER JOIN ProcessInstanceLog log ON log.processInstanceId = task.processInstanceId\n+               WHERE Task.id IN (:idList)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1e57dd6f9a77d2e636949457815115ca83acc4dc"}, "originalPosition": 38}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzkxMDU5Nw==", "bodyText": "Same here", "url": "https://github.com/kiegroup/jbpm/pull/1615#discussion_r403910597", "createdAt": "2020-04-06T08:22:38Z", "author": {"login": "gmunozfe"}, "path": "jbpm-services/jbpm-kie-services/src/main/resources/META-INF/Servicesorm.xml", "diffHunk": "@@ -1182,5 +1182,71 @@\n     </query>\n     <!-- hint name=\"org.hibernate.timeout\" value=\"200\"/ -->\n   </named-query>   \n-        \n+\n+\n+  <!-- advance runtime queries -->\n+  <named-native-query name=\"GeProcessInstanceByIdList\">\n+      <query>\n+        SELECT processInstanceId, processId, processName, processVersion, status, externalId, start_date, user_identity, correlationKey \n+          FROM ProcessInstanceLog pil \n+         WHERE processInstanceId IN (:idList) \n+      ORDER BY processInstanceId ASC \n+    </query>\n+  </named-native-query>\n+  \n+  <named-native-query name=\"GeVariablesByProcessInstanceIdList\">\n+      <query>\n+            SELECT A1.processInstanceId, A1.variableId, A1.value \n+              FROM VariableInstanceLog A1 \n+         LEFT JOIN VariableInstanceLog A2 ON A1.processId = A2.processId \n+                                         AND A1.processInstanceId = A2.processInstanceId \n+                                         AND A1.variableInstanceId = A2.variableInstanceId \n+                                         AND A1.log_date &#60; A2.log_date \n+             WHERE A2.log_date IS NULL AND A1.processInstanceId IN (:idList) \n+          ORDER BY A1.processInstanceId ASC \n+      </query>\n+  </named-native-query>\n+  <named-native-query name=\"GetTasksByIdList\">\n+      <query>\n+              SELECT task.id, task.name, task.formName, task.subject, \n+                     task.actualOwner_id, log.correlationKey, task.createdOn,\n+                     task.createdBy_id, task.expirationTime, task.priority,\n+                     task.status, log.processInstanceId, log.processId, log.externalId,\n+                     log.processInstanceDescription \n+                FROM Task task \n+          INNER JOIN ProcessInstanceLog log ON log.processInstanceId = task.processInstanceId\n+               WHERE Task.id IN (:idList)\n+            ORDER BY Task.id ASC ", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1e57dd6f9a77d2e636949457815115ca83acc4dc"}, "originalPosition": 39}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzkxMTk3Nw==", "bodyText": "Do not use log_date, but id, for ordering, as log_date may be the same.\nInvert the order to pick up the current value", "url": "https://github.com/kiegroup/jbpm/pull/1615#discussion_r403911977", "createdAt": "2020-04-06T08:24:59Z", "author": {"login": "gmunozfe"}, "path": "jbpm-services/jbpm-kie-services/src/main/java/org/jbpm/kie/services/impl/AbstractAdvanceRuntimeDataServiceImpl.java", "diffHunk": "@@ -0,0 +1,306 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.jbpm.kie.services.impl;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import javax.persistence.EntityManager;\n+import javax.persistence.EntityManagerFactory;\n+import javax.persistence.Query;\n+\n+import org.jbpm.kie.services.impl.model.ProcessInstanceWithVarsDesc;\n+import org.jbpm.kie.services.impl.model.UserTaskInstanceWithPotOwnerDesc;\n+import org.jbpm.shared.services.impl.QueryManager;\n+import org.jbpm.shared.services.impl.TransactionalCommandService;\n+import org.jbpm.shared.services.impl.commands.QueryNameCommand;\n+import org.kie.api.runtime.query.QueryContext;\n+\n+import static java.util.Collections.singletonMap;\n+\n+public abstract class AbstractAdvanceRuntimeDataServiceImpl {\n+\n+    private EntityManagerFactory emf;\n+    private TransactionalCommandService commandService;\n+\n+    public AbstractAdvanceRuntimeDataServiceImpl() {\n+        QueryManager.get().addNamedQueries(\"META-INF/Servicesorm.xml\");\n+    }\n+    public void setCommandService(TransactionalCommandService commandService) {\n+        this.commandService = commandService;\n+    }\n+\n+    public void setEmf(EntityManagerFactory emf) {\n+        this.emf = emf;\n+    }\n+\n+\n+    public List<org.jbpm.services.api.model.ProcessInstanceWithVarsDesc> queryProcessByVariables(Map<String, Object> attributes,\n+                                                                                                 Map<String, Object> variables,\n+                                                                                                 int processType,\n+                                                                                                 String varPrefix,\n+                                                                                                 QueryContext queryContext) {\n+        EntityManager entityManager = emf.createEntityManager();\n+\n+        // first step is to filter the data creating a derived tables and pivoting var - rows to columns (only the variables we are interested to filter)\n+        StringBuilder where = new StringBuilder();\n+        StringBuilder derivedTables = new StringBuilder();\n+        for (Map.Entry<String, Object> var : variables.entrySet()) {\n+            String alias = \"TABLE_\" + var.getKey();\n+            String varName = var.getKey();\n+\n+            derivedTables.append(\"LEFT JOIN (\" +\n+                                 \"SELECT A1.processId, A1.processInstanceId, A1.variableId AS NAME, A1.value AS VALUE \\n\" +\n+                                 \"FROM VariableInstanceLog A1 \\n\" +\n+                                 \"LEFT JOIN VariableInstanceLog A2 ON A1.processId = A2.processId AND A1.processInstanceId = A2.processInstanceId AND A1.variableInstanceId = A2.variableInstanceId AND A2.log_date < A1.log_date  \\n\" +\n+                                 \"WHERE A2.log_date IS NULL \\n\" +\n+                                 \") \" + alias + \" ON \" + alias + \".processId = pil.processId AND \" + alias + \".processInstanceId = pil.processInstanceId \\n\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1e57dd6f9a77d2e636949457815115ca83acc4dc"}, "originalPosition": 75}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg4MDY0Mjgw", "url": "https://github.com/kiegroup/jbpm/pull/1615#pullrequestreview-388064280", "createdAt": "2020-04-06T09:09:49Z", "commit": {"oid": "1e57dd6f9a77d2e636949457815115ca83acc4dc"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNlQwOTowOTo0OVrOGBOhkQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNlQwOTowOTo0OVrOGBOhkQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzkzOTcyOQ==", "bodyText": "This native query is failing when using an Oracle database: ORA-00933: SQL command not properly ended\nSeems it could be related to the pagination part of the SQL statement.", "url": "https://github.com/kiegroup/jbpm/pull/1615#discussion_r403939729", "createdAt": "2020-04-06T09:09:49Z", "author": {"login": "afalhambra"}, "path": "jbpm-services/jbpm-kie-services/src/main/java/org/jbpm/kie/services/impl/AbstractAdvanceRuntimeDataServiceImpl.java", "diffHunk": "@@ -0,0 +1,306 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.jbpm.kie.services.impl;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import javax.persistence.EntityManager;\n+import javax.persistence.EntityManagerFactory;\n+import javax.persistence.Query;\n+\n+import org.jbpm.kie.services.impl.model.ProcessInstanceWithVarsDesc;\n+import org.jbpm.kie.services.impl.model.UserTaskInstanceWithPotOwnerDesc;\n+import org.jbpm.shared.services.impl.QueryManager;\n+import org.jbpm.shared.services.impl.TransactionalCommandService;\n+import org.jbpm.shared.services.impl.commands.QueryNameCommand;\n+import org.kie.api.runtime.query.QueryContext;\n+\n+import static java.util.Collections.singletonMap;\n+\n+public abstract class AbstractAdvanceRuntimeDataServiceImpl {\n+\n+    private EntityManagerFactory emf;\n+    private TransactionalCommandService commandService;\n+\n+    public AbstractAdvanceRuntimeDataServiceImpl() {\n+        QueryManager.get().addNamedQueries(\"META-INF/Servicesorm.xml\");\n+    }\n+    public void setCommandService(TransactionalCommandService commandService) {\n+        this.commandService = commandService;\n+    }\n+\n+    public void setEmf(EntityManagerFactory emf) {\n+        this.emf = emf;\n+    }\n+\n+\n+    public List<org.jbpm.services.api.model.ProcessInstanceWithVarsDesc> queryProcessByVariables(Map<String, Object> attributes,\n+                                                                                                 Map<String, Object> variables,\n+                                                                                                 int processType,\n+                                                                                                 String varPrefix,\n+                                                                                                 QueryContext queryContext) {\n+        EntityManager entityManager = emf.createEntityManager();\n+\n+        // first step is to filter the data creating a derived tables and pivoting var - rows to columns (only the variables we are interested to filter)\n+        StringBuilder where = new StringBuilder();\n+        StringBuilder derivedTables = new StringBuilder();\n+        for (Map.Entry<String, Object> var : variables.entrySet()) {\n+            String alias = \"TABLE_\" + var.getKey();\n+            String varName = var.getKey();\n+\n+            derivedTables.append(\"LEFT JOIN (\" +\n+                                 \"SELECT A1.processId, A1.processInstanceId, A1.variableId AS NAME, A1.value AS VALUE \\n\" +\n+                                 \"FROM VariableInstanceLog A1 \\n\" +\n+                                 \"LEFT JOIN VariableInstanceLog A2 ON A1.processId = A2.processId AND A1.processInstanceId = A2.processInstanceId AND A1.variableInstanceId = A2.variableInstanceId AND A2.log_date < A1.log_date  \\n\" +\n+                                 \"WHERE A2.log_date IS NULL \\n\" +\n+                                 \") \" + alias + \" ON \" + alias + \".processId = pil.processId AND \" + alias + \".processInstanceId = pil.processInstanceId \\n\");\n+\n+            addWhereExpression(where);\n+            where.append(alias + \".NAME = :NAME_\" + varName + \" AND \" + alias + \".VALUE= :VALUE_\" + varName + \"\\n\");\n+        }\n+\n+\n+        for (Map.Entry<String, Object> entry : attributes.entrySet()) {\n+            addWhereExpression(where);\n+            where.append(\" pil.\" + entry.getKey() + \" = :ATTR_\" + entry.getKey() + \" \");\n+        }\n+\n+        addWhereExpression(where);\n+        where.append(\" pil.processType = :processType \");\n+\n+        String procSQLString = \"SELECT DISTINCT pil.processInstanceId FROM ProcessInstanceLog pil \\n \" + derivedTables + where + \" ORDER BY pil.processInstanceId ASC \";\n+        procSQLString += (queryContext.getCount() > 0) ? \" LIMIT \" + queryContext.getCount() + \" OFFSET \" + queryContext.getOffset() + \" \\n\" : \"\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1e57dd6f9a77d2e636949457815115ca83acc4dc"}, "originalPosition": 91}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg4MDY0NDky", "url": "https://github.com/kiegroup/jbpm/pull/1615#pullrequestreview-388064492", "createdAt": "2020-04-06T09:10:08Z", "commit": {"oid": "1e57dd6f9a77d2e636949457815115ca83acc4dc"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNlQwOToxMDowOFrOGBOiQQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNlQwOToxMDowOFrOGBOiQQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzkzOTkwNQ==", "bodyText": "This native query is failing when using an Oracle database: ORA-00933: SQL command not properly ended\nSeems it could be related to the pagination part of the SQL statement.", "url": "https://github.com/kiegroup/jbpm/pull/1615#discussion_r403939905", "createdAt": "2020-04-06T09:10:08Z", "author": {"login": "afalhambra"}, "path": "jbpm-services/jbpm-kie-services/src/main/java/org/jbpm/kie/services/impl/AbstractAdvanceRuntimeDataServiceImpl.java", "diffHunk": "@@ -0,0 +1,306 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.jbpm.kie.services.impl;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import javax.persistence.EntityManager;\n+import javax.persistence.EntityManagerFactory;\n+import javax.persistence.Query;\n+\n+import org.jbpm.kie.services.impl.model.ProcessInstanceWithVarsDesc;\n+import org.jbpm.kie.services.impl.model.UserTaskInstanceWithPotOwnerDesc;\n+import org.jbpm.shared.services.impl.QueryManager;\n+import org.jbpm.shared.services.impl.TransactionalCommandService;\n+import org.jbpm.shared.services.impl.commands.QueryNameCommand;\n+import org.kie.api.runtime.query.QueryContext;\n+\n+import static java.util.Collections.singletonMap;\n+\n+public abstract class AbstractAdvanceRuntimeDataServiceImpl {\n+\n+    private EntityManagerFactory emf;\n+    private TransactionalCommandService commandService;\n+\n+    public AbstractAdvanceRuntimeDataServiceImpl() {\n+        QueryManager.get().addNamedQueries(\"META-INF/Servicesorm.xml\");\n+    }\n+    public void setCommandService(TransactionalCommandService commandService) {\n+        this.commandService = commandService;\n+    }\n+\n+    public void setEmf(EntityManagerFactory emf) {\n+        this.emf = emf;\n+    }\n+\n+\n+    public List<org.jbpm.services.api.model.ProcessInstanceWithVarsDesc> queryProcessByVariables(Map<String, Object> attributes,\n+                                                                                                 Map<String, Object> variables,\n+                                                                                                 int processType,\n+                                                                                                 String varPrefix,\n+                                                                                                 QueryContext queryContext) {\n+        EntityManager entityManager = emf.createEntityManager();\n+\n+        // first step is to filter the data creating a derived tables and pivoting var - rows to columns (only the variables we are interested to filter)\n+        StringBuilder where = new StringBuilder();\n+        StringBuilder derivedTables = new StringBuilder();\n+        for (Map.Entry<String, Object> var : variables.entrySet()) {\n+            String alias = \"TABLE_\" + var.getKey();\n+            String varName = var.getKey();\n+\n+            derivedTables.append(\"LEFT JOIN (\" +\n+                                 \"SELECT A1.processId, A1.processInstanceId, A1.variableId AS NAME, A1.value AS VALUE \\n\" +\n+                                 \"FROM VariableInstanceLog A1 \\n\" +\n+                                 \"LEFT JOIN VariableInstanceLog A2 ON A1.processId = A2.processId AND A1.processInstanceId = A2.processInstanceId AND A1.variableInstanceId = A2.variableInstanceId AND A2.log_date < A1.log_date  \\n\" +\n+                                 \"WHERE A2.log_date IS NULL \\n\" +\n+                                 \") \" + alias + \" ON \" + alias + \".processId = pil.processId AND \" + alias + \".processInstanceId = pil.processInstanceId \\n\");\n+\n+            addWhereExpression(where);\n+            where.append(alias + \".NAME = :NAME_\" + varName + \" AND \" + alias + \".VALUE= :VALUE_\" + varName + \"\\n\");\n+        }\n+\n+\n+        for (Map.Entry<String, Object> entry : attributes.entrySet()) {\n+            addWhereExpression(where);\n+            where.append(\" pil.\" + entry.getKey() + \" = :ATTR_\" + entry.getKey() + \" \");\n+        }\n+\n+        addWhereExpression(where);\n+        where.append(\" pil.processType = :processType \");\n+\n+        String procSQLString = \"SELECT DISTINCT pil.processInstanceId FROM ProcessInstanceLog pil \\n \" + derivedTables + where + \" ORDER BY pil.processInstanceId ASC \";\n+        procSQLString += (queryContext.getCount() > 0) ? \" LIMIT \" + queryContext.getCount() + \" OFFSET \" + queryContext.getOffset() + \" \\n\" : \"\";\n+\n+        Query query = entityManager.createNativeQuery(procSQLString);\n+        for (Map.Entry<String, Object> var : variables.entrySet()) {\n+            query.setParameter(\"NAME_\" + var.getKey(), varPrefix + var.getKey());\n+            query.setParameter(\"VALUE_\" + var.getKey(), var.getValue());\n+        }\n+        for (Map.Entry<String, Object> entry : attributes.entrySet()) {\n+            query.setParameter(\"ATTR_\" + entry.getKey(), entry.getValue());\n+        }\n+        query.setParameter(\"processType\", processType);\n+\n+        List<Number> ids = query.getResultList();\n+        if (ids.isEmpty()) {\n+            return Collections.emptyList();\n+        }\n+\n+        // now we get the information\n+\n+        List<Object[]> procRows = commandService.execute(new QueryNameCommand<List<Object[]>>(\"GeProcessInstanceByIdList\", singletonMap(\"idList\", ids)));\n+        List<Object[]> varRows = commandService.execute(new QueryNameCommand<List<Object[]>>(\"GeVariablesByProcessInstanceIdList\", singletonMap(\"idList\", ids)));\n+\n+        int currentVarIdx = 0;\n+        List<org.jbpm.services.api.model.ProcessInstanceWithVarsDesc> data = new ArrayList<>();\n+        for (Object[] row : procRows) {\n+            ProcessInstanceWithVarsDesc pwv = toProcessInstanceWithVarsDesc(row);\n+\n+            Map<String, Object> vars = new HashMap<>();\n+            pwv.setVariables(vars);\n+            while (currentVarIdx < varRows.size() && row[0].equals(varRows.get(currentVarIdx)[0])) {\n+                String name = (String) varRows.get(currentVarIdx)[1];\n+                if (name.startsWith(varPrefix)) {\n+                    vars.put(name.substring(varPrefix.length()), varRows.get(currentVarIdx)[2]);\n+                }\n+                currentVarIdx++;\n+            }\n+            data.add(pwv);\n+        }\n+\n+        entityManager.close();\n+        return data;\n+    }\n+\n+    private ProcessInstanceWithVarsDesc toProcessInstanceWithVarsDesc(Object[] row) {\n+        return new ProcessInstanceWithVarsDesc(((Number) row[0]).longValue(),\n+                                               (String) row[1],\n+                                               (String) row[2],\n+                                               (String) row[3],\n+                                               ((Number) row[4]).intValue(),\n+                                               (String) row[5],\n+                                               (Date) row[6],\n+                                               (String) row[7],\n+                                               (String) row[8]);\n+    }\n+    private void addWhereExpression(StringBuilder where) {\n+        where.append(where.length() == 0 ? \"WHERE \" : \" AND \");\n+    }\n+\n+    public List<org.jbpm.services.api.model.UserTaskInstanceWithPotOwnerDesc> queryUserTasksByVariables(Map<String, Object> attributes,\n+                                                                                                        Map<String, Object> variables,\n+                                                                                                        Map<String, Object> processVariables,\n+                                                                                                        List<String> owners,\n+                                                                                                        int processType,\n+                                                                                                        String varPrefix,\n+                                                                                                        QueryContext queryContext) {\n+        EntityManager entityManager = emf.createEntityManager();\n+\n+        StringBuilder where = new StringBuilder();\n+        StringBuilder derivedTables = new StringBuilder();\n+        for (Map.Entry<String, Object> var : variables.entrySet()) {\n+            String alias = \"V_TABLE_\" + var.getKey();\n+            String varName = var.getKey();\n+            derivedTables.append(\"INNER JOIN (\\n\" +\n+                                  \"SELECT taskId, name, value \\n\" +\n+                                  \"FROM TaskVariableImpl \\n\" +\n+                                  \"WHERE type = 0\\n\" +\n+                                 \") \" + alias + \" ON \" + alias + \".taskId = task.id  \\n\");\n+\n+\n+            addWhereExpression(where);\n+            where.append(alias + \".NAME = :V_NAME_\" + varName + \" AND \" + alias + \".VALUE= :V_VALUE_\" + varName + \"\\n\");\n+        }\n+\n+        for (Map.Entry<String, Object> var : processVariables.entrySet()) {\n+            String alias = \"P_TABLE_\" + var.getKey();\n+            String varName = var.getKey();\n+\n+            derivedTables.append(\"LEFT JOIN (\" +\n+                                 \"SELECT A1.processId, A1.processInstanceId, A1.variableId AS NAME, A1.value AS VALUE \\n\" +\n+                                 \"FROM VariableInstanceLog A1 \\n\" +\n+                                 \"LEFT JOIN VariableInstanceLog A2 ON A1.processId = A2.processId AND A1.processInstanceId = A2.processInstanceId AND A1.variableInstanceId = A2.variableInstanceId AND A2.log_date < A1.log_date  \\n\" +\n+                                 \"WHERE A2.log_date IS NULL \\n\" +\n+                                 \") \" + alias + \" ON \" + alias + \".processId = pil.processId AND \" + alias + \".processInstanceId = pil.processInstanceId \\n\");\n+\n+            addWhereExpression(where);\n+            where.append(alias + \".NAME = :P_NAME_\" + varName + \" AND \" + alias + \".VALUE= :P_VALUE_\" + varName + \"\\n\");\n+        }\n+\n+        if (!owners.isEmpty()) {\n+            derivedTables.append(\"INNER JOIN ( \\n\" +\n+                             \"           SELECT DISTINCT po.task_id \\n\" +\n+                             \"           FROM PeopleAssignments_PotOwners po \\n\" +\n+                             \"           WHERE po.entity_id IN (:owners) \\n\" +\n+                             \"           GROUP BY po.task_id \\n\" +\n+                             \"           HAVING COUNT(po.entity_id) = :num_owners \\n\" +\n+                                 \") AS pot ON pot.task_id = task.id \");\n+        }\n+\n+        for (Map.Entry<String, Object> entry : attributes.entrySet()) {\n+            addWhereExpression(where);\n+            where.append(\" task.\" + entry.getKey() + \" = :ATTR_\" + entry.getKey() + \" \");\n+        }\n+\n+        addWhereExpression(where);\n+        where.append(\" pil.processType = :processType \");\n+\n+        String procSQLString = \"SELECT DISTINCT task.id FROM Task task INNER JOIN ProcessInstanceLog pil ON pil.processInstanceId = task.processInstanceId \\n \" + derivedTables + where + \" ORDER BY id ASC \";\n+        procSQLString += (queryContext.getCount() > 0) ? \" LIMIT \" + queryContext.getCount() + \" OFFSET \" + queryContext.getOffset() + \"\\n\" : \"\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1e57dd6f9a77d2e636949457815115ca83acc4dc"}, "originalPosition": 208}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg4MTc2NTE4", "url": "https://github.com/kiegroup/jbpm/pull/1615#pullrequestreview-388176518", "createdAt": "2020-04-06T11:55:08Z", "commit": {"oid": "1e57dd6f9a77d2e636949457815115ca83acc4dc"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNlQxMTo1NTowOFrOGBUNTw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNlQxMTo1NTowOFrOGBUNTw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDAzMjg0Nw==", "bodyText": "Not sure whether it makes sense to have a \"ProcessInstanceWithVarDes\" as a class and another class for cases something like \"CaseInstanceWithVarDes\"? wdyt?. Only to make it a little more clear.", "url": "https://github.com/kiegroup/jbpm/pull/1615#discussion_r404032847", "createdAt": "2020-04-06T11:55:08Z", "author": {"login": "afalhambra"}, "path": "jbpm-case-mgmt/jbpm-case-mgmt-impl/src/main/java/org/jbpm/casemgmt/impl/AdvanceCaseRuntimeDataServiceImpl.java", "diffHunk": "@@ -0,0 +1,52 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.jbpm.casemgmt.impl;\n+\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.jbpm.casemgmt.api.AdvanceCaseRuntimeDataService;\n+import org.jbpm.kie.services.impl.AbstractAdvanceRuntimeDataServiceImpl;\n+import org.kie.api.runtime.query.QueryContext;\n+\n+import static org.jbpm.process.core.context.variable.VariableScope.CASE_FILE_PREFIX;\n+import static org.jbpm.workflow.core.WorkflowProcess.CASE_TYPE;\n+\n+public class AdvanceCaseRuntimeDataServiceImpl extends AbstractAdvanceRuntimeDataServiceImpl implements AdvanceCaseRuntimeDataService {\n+\n+\n+    @Override\n+    public List<org.jbpm.services.api.model.ProcessInstanceWithVarsDesc> queryCaseByVariables(Map<String, Object> attributes,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1e57dd6f9a77d2e636949457815115ca83acc4dc"}, "originalPosition": 33}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "1e57dd6f9a77d2e636949457815115ca83acc4dc", "author": {"user": null}, "url": "https://github.com/kiegroup/jbpm/commit/1e57dd6f9a77d2e636949457815115ca83acc4dc", "committedDate": "2020-03-30T15:29:38Z", "message": "[RHPAM-2552] Ability to Search for tasks by multiple task variables a nd / or process variables via the kie-server api.\n\nadded the possibility to query process/cases by variables"}, "afterCommit": {"oid": "dff54f99161103a3aa333b880692a15f1e9f4e62", "author": {"user": null}, "url": "https://github.com/kiegroup/jbpm/commit/dff54f99161103a3aa333b880692a15f1e9f4e62", "committedDate": "2020-04-07T07:15:02Z", "message": "[RHPAM-2552] Ability to Search for tasks by multiple task variables a nd / or process variables via the kie-server api.\n\nadded the possibility to query process/cases by variables"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "dff54f99161103a3aa333b880692a15f1e9f4e62", "author": {"user": null}, "url": "https://github.com/kiegroup/jbpm/commit/dff54f99161103a3aa333b880692a15f1e9f4e62", "committedDate": "2020-04-07T07:15:02Z", "message": "[RHPAM-2552] Ability to Search for tasks by multiple task variables a nd / or process variables via the kie-server api.\n\nadded the possibility to query process/cases by variables"}, "afterCommit": {"oid": "6fd45ee7d05cde3ff61064aea2bb498a4f24cf13", "author": {"user": null}, "url": "https://github.com/kiegroup/jbpm/commit/6fd45ee7d05cde3ff61064aea2bb498a4f24cf13", "committedDate": "2020-04-08T15:25:44Z", "message": "[RHPAM-2552] Ability to Search for tasks by multiple task variables a nd / or process variables via the kie-server api.\n\nadded the possibility to query process/cases by variables"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "a697f99748849f5951499ac07121b2ee3a440cc0", "author": {"user": null}, "url": "https://github.com/kiegroup/jbpm/commit/a697f99748849f5951499ac07121b2ee3a440cc0", "committedDate": "2020-04-08T15:54:19Z", "message": "fix"}, "afterCommit": {"oid": "8f6dc5c29e4b25d899d77449a7cc8f582ecb6cec", "author": {"user": null}, "url": "https://github.com/kiegroup/jbpm/commit/8f6dc5c29e4b25d899d77449a7cc8f582ecb6cec", "committedDate": "2020-04-08T18:45:00Z", "message": "[RHPAM-2552] Ability to Search for tasks by multiple task variables a nd / or process variables via the kie-server api.\n\nadded the possibility to query process/cases by variables"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "8f6dc5c29e4b25d899d77449a7cc8f582ecb6cec", "author": {"user": null}, "url": "https://github.com/kiegroup/jbpm/commit/8f6dc5c29e4b25d899d77449a7cc8f582ecb6cec", "committedDate": "2020-04-08T18:45:00Z", "message": "[RHPAM-2552] Ability to Search for tasks by multiple task variables a nd / or process variables via the kie-server api.\n\nadded the possibility to query process/cases by variables"}, "afterCommit": {"oid": "a85cc9afbb1d98d23d4755b7dfd572a6a6cc360e", "author": {"user": null}, "url": "https://github.com/kiegroup/jbpm/commit/a85cc9afbb1d98d23d4755b7dfd572a6a6cc360e", "committedDate": "2020-04-09T15:18:45Z", "message": "[RHPAM-2552] Ability to Search for tasks by multiple task variables a nd / or process variables via the kie-server api.\n\nadded the possibility to query process/cases by variables"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "a85cc9afbb1d98d23d4755b7dfd572a6a6cc360e", "author": {"user": null}, "url": "https://github.com/kiegroup/jbpm/commit/a85cc9afbb1d98d23d4755b7dfd572a6a6cc360e", "committedDate": "2020-04-09T15:18:45Z", "message": "[RHPAM-2552] Ability to Search for tasks by multiple task variables a nd / or process variables via the kie-server api.\n\nadded the possibility to query process/cases by variables"}, "afterCommit": {"oid": "be7638ebf3d5375b391afebd158bc99a5008f0c7", "author": {"user": null}, "url": "https://github.com/kiegroup/jbpm/commit/be7638ebf3d5375b391afebd158bc99a5008f0c7", "committedDate": "2020-04-09T15:25:46Z", "message": "[RHPAM-2552] Ability to Search for tasks by multiple task variables a nd / or process variables via the kie-server api.\n\nadded the possibility to query process/cases by variables"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "be7638ebf3d5375b391afebd158bc99a5008f0c7", "author": {"user": null}, "url": "https://github.com/kiegroup/jbpm/commit/be7638ebf3d5375b391afebd158bc99a5008f0c7", "committedDate": "2020-04-09T15:25:46Z", "message": "[RHPAM-2552] Ability to Search for tasks by multiple task variables a nd / or process variables via the kie-server api.\n\nadded the possibility to query process/cases by variables"}, "afterCommit": {"oid": "7254bbd4405c29a3f8eb4f1b3967ee8c78cfd26a", "author": {"user": null}, "url": "https://github.com/kiegroup/jbpm/commit/7254bbd4405c29a3f8eb4f1b3967ee8c78cfd26a", "committedDate": "2020-04-12T16:59:41Z", "message": "[RHPAM-2552] Ability to Search for tasks by multiple task variables a nd / or process variables via the kie-server api.\n\nadded the possibility to query process/cases by variables"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzkyMDMyOTk2", "url": "https://github.com/kiegroup/jbpm/pull/1615#pullrequestreview-392032996", "createdAt": "2020-04-13T08:53:32Z", "commit": {"oid": "7254bbd4405c29a3f8eb4f1b3967ee8c78cfd26a"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xM1QwODo1MzozM1rOGEg0IA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xM1QxMToyMzoyMlrOGEj2WA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzM4NTEyMA==", "bodyText": "These 3 operators can be grouped", "url": "https://github.com/kiegroup/jbpm/pull/1615#discussion_r407385120", "createdAt": "2020-04-13T08:53:33Z", "author": {"login": "gmunozfe"}, "path": "jbpm-services/jbpm-services-api/src/main/java/org/jbpm/services/api/query/model/QueryParam.java", "diffHunk": "@@ -303,6 +313,67 @@ public void setValue(List<?> value) {\n         this.value = value;\n     }\n \n+    public Object getObjectValue() {\n+        if (value == null || value.isEmpty()) {\n+            return null;\n+        }\n+        switch (type()) {\n+            case BINARY_OPERAND:\n+                return value.get(0);\n+            case RANGE_OPERAND:\n+                return value.subList(0, 2);\n+            case UNARY_OPERAND:\n+            case AGGREGATE:\n+                return null;\n+            case LIST_OPERAND:\n+            default:\n+                return value;\n+        }\n+\n+    }\n+\n+    private enum Type {\n+        DEFAULT,\n+        AGGREGATE,\n+        UNARY_OPERAND,\n+        BINARY_OPERAND,\n+        RANGE_OPERAND,\n+        LIST_OPERAND\n+    }\n+\n+    private Type type() {\n+        switch (operator) {\n+            case \"IS_NULL\":\n+            case \"NOT_NULL\":\n+            case \"DISTINCT\":\n+                return Type.UNARY_OPERAND;\n+            case \"MIN\":\n+            case \"MAX\":\n+            case \"SUM\":\n+            case \"AVERAGE\":\n+            case \"COUNT\":\n+                return Type.AGGREGATE;\n+            case \"EQUALS_TO\":\n+            case \"NOT_EQUALS_TO\":\n+            case \"LIKE_TO\":\n+            case \"GREATER_THAN\":\n+            case \"LESS_THAN\":\n+            case \"GREATER_OR_EQUALS_TO\":\n+            case \"LESS_OR_EQUALS_TO\":\n+                return Type.BINARY_OPERAND;\n+            case \"BETWEEN\":\n+                return Type.LIST_OPERAND;\n+            case \"IN\":\n+            case \"NOT_IN\":", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7254bbd4405c29a3f8eb4f1b3967ee8c78cfd26a"}, "originalPosition": 86}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzQyMTE4Nw==", "bodyText": "It's selecting the first value, and target is the last one\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                                     AND A1.id &gt; A2.id \n          \n          \n            \n                                                     AND A2.id &gt; A1.id", "url": "https://github.com/kiegroup/jbpm/pull/1615#discussion_r407421187", "createdAt": "2020-04-13T10:38:22Z", "author": {"login": "gmunozfe"}, "path": "jbpm-services/jbpm-kie-services/src/main/resources/META-INF/Servicesorm.xml", "diffHunk": "@@ -1182,5 +1182,71 @@\n     </query>\n     <!-- hint name=\"org.hibernate.timeout\" value=\"200\"/ -->\n   </named-query>   \n-        \n+\n+\n+  <!-- advance runtime queries -->\n+  <named-native-query name=\"GeProcessInstanceByIdList\">\n+      <query>\n+        SELECT processInstanceId, processId, processName, processVersion, status, externalId, start_date, user_identity, correlationKey \n+          FROM ProcessInstanceLog pil \n+         WHERE processInstanceId IN (:idList) \n+      ORDER BY processInstanceId ASC \n+    </query>\n+  </named-native-query>\n+  \n+  <named-native-query name=\"GeVariablesByProcessInstanceIdList\">\n+      <query>\n+            SELECT A1.processInstanceId, A1.variableId, A1.value \n+              FROM VariableInstanceLog A1 \n+         LEFT JOIN VariableInstanceLog A2 ON A1.processId = A2.processId \n+                                         AND A1.processInstanceId = A2.processInstanceId \n+                                         AND A1.variableInstanceId = A2.variableInstanceId \n+                                         AND A1.id &gt; A2.id ", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7254bbd4405c29a3f8eb4f1b3967ee8c78cfd26a"}, "originalPosition": 24}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzQyODUxMw==", "bodyText": "Change the test name as it is testing isNotNull operator\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public void testQueryIsNullOperator() {\n          \n          \n            \n                public void testQueryIsNotNullOperator() {", "url": "https://github.com/kiegroup/jbpm/pull/1615#discussion_r407428513", "createdAt": "2020-04-13T11:02:40Z", "author": {"login": "gmunozfe"}, "path": "jbpm-services/jbpm-kie-services/src/test/java/org/jbpm/kie/services/test/AdvanceRuntimeDataServiceImplTest.java", "diffHunk": "@@ -0,0 +1,348 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.jbpm.kie.services.test;\n+\n+import java.io.File;\n+import java.io.FileOutputStream;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.drools.compiler.kie.builder.impl.InternalKieModule;\n+import org.jbpm.kie.services.impl.KModuleDeploymentUnit;\n+import org.jbpm.kie.test.util.AbstractKieServicesBaseTest;\n+import org.jbpm.services.api.ProcessInstanceNotFoundException;\n+import org.jbpm.services.api.model.DeploymentUnit;\n+import org.jbpm.services.api.model.ProcessInstanceWithVarsDesc;\n+import org.jbpm.services.api.model.UserTaskInstanceWithPotOwnerDesc;\n+import org.jbpm.services.api.query.model.QueryParam;\n+import org.junit.After;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.Parameterized;\n+import org.junit.runners.Parameterized.Parameters;\n+import org.kie.api.KieServices;\n+import org.kie.api.builder.ReleaseId;\n+import org.kie.api.runtime.process.ProcessInstance;\n+import org.kie.internal.query.QueryContext;\n+import org.kie.scanner.KieMavenRepository;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static java.util.Collections.emptyList;\n+import static org.hamcrest.CoreMatchers.is;\n+import static org.jbpm.services.api.AdvanceRuntimeDataService.PROCESS_ATTR_CORRELATION_KEY;\n+import static org.jbpm.services.api.AdvanceRuntimeDataService.PROCESS_ATTR_DEFINITION_ID;\n+import static org.jbpm.services.api.AdvanceRuntimeDataService.PROCESS_ATTR_DEPLOYMENT_ID;\n+import static org.jbpm.services.api.AdvanceRuntimeDataService.TASK_ATTR_NAME;\n+import static org.jbpm.services.api.AdvanceRuntimeDataService.TASK_ATTR_OWNER;\n+import static org.jbpm.services.api.query.model.QueryParam.equalsTo;\n+import static org.jbpm.services.api.query.model.QueryParam.in;\n+import static org.jbpm.services.api.query.model.QueryParam.isNotNull;\n+import static org.jbpm.services.api.query.model.QueryParam.likeTo;\n+import static org.jbpm.services.api.query.model.QueryParam.list;\n+import static org.jbpm.services.api.query.model.QueryParam.notEqualsTo;\n+import static org.jbpm.services.api.query.model.QueryParam.notIn;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertNull;\n+import static org.kie.scanner.KieMavenRepository.getKieMavenRepository;\n+\n+@RunWith(Parameterized.class)\n+public class AdvanceRuntimeDataServiceImplTest extends AbstractKieServicesBaseTest {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(AdvanceRuntimeDataServiceImplTest.class);\n+\n+    @Parameters(name = \"Pagination {0}\")\n+    public static Iterable<? extends Object> data() {\n+        return Arrays.asList(0, 2);\n+    }\n+\n+    private List<DeploymentUnit> units = new ArrayList<DeploymentUnit>();\n+    protected String correctUser = \"testUser\";\n+    protected String wrongUser = \"wrongUser\";\n+\n+    private List<Long> processIds;\n+    private KModuleDeploymentUnit deploymentUnit = null;\n+    private QueryContext queryContext;\n+\n+    public AdvanceRuntimeDataServiceImplTest(Integer count) {\n+        this.queryContext = new QueryContext(0, count);\n+    }\n+\n+    @Before\n+    public void prepare() {\n+\n+        configureServices();\n+        logger.debug(\"Preparing kjar\");\n+        KieServices ks = KieServices.Factory.get();\n+        ReleaseId releaseId = ks.newReleaseId(GROUP_ID, ARTIFACT_ID, VERSION);\n+        List<String> processes = new ArrayList<String>();\n+        processes.add(\"repo/processes/general/SingleHumanTaskWithVarsA.bpmn2\");\n+        processes.add(\"repo/processes/general/SingleHumanTaskWithVarsB.bpmn2\");\n+\n+        InternalKieModule kJar1 = createKieJar(ks, releaseId, processes);\n+        File pom = new File(\"target/kmodule\", \"pom.xml\");\n+        pom.getParentFile().mkdir();\n+        try (FileOutputStream fs = new FileOutputStream(pom);) {\n+            fs.write(getPom(releaseId).getBytes());\n+        } catch (Exception e) {\n+\n+        }\n+        KieMavenRepository repository = getKieMavenRepository();\n+        repository.deployArtifact(releaseId, kJar1, pom);\n+\n+        assertNotNull(deploymentService);\n+\n+        deploymentUnit = new KModuleDeploymentUnit(GROUP_ID, ARTIFACT_ID, VERSION);\n+\n+        deploymentService.deploy(deploymentUnit);\n+        units.add(deploymentUnit);\n+        assertNotNull(processService);\n+\n+        processIds = new ArrayList<>();\n+        for (int i = 0; i < 10; i++) {\n+            Map<String, Object> inputsA1 = new HashMap<>();\n+            inputsA1.put(\"var_a\", \"a\" + (i % 3));\n+            inputsA1.put(\"var_b\", (i % 3));\n+            processIds.add(processService.startProcess(deploymentUnit.getIdentifier(), \"test.test_A\", inputsA1));\n+        }\n+        for (int i = 0; i < 10; i++) {\n+            Map<String, Object> inputsB1 = new HashMap<>();\n+            inputsB1.put(\"var_a\", \"b\" + (i % 3));\n+            inputsB1.put(\"var_b\", (i % 3));\n+            processIds.add(processService.startProcess(deploymentUnit.getIdentifier(), \"test.test_B\", inputsB1));\n+        }\n+    }\n+\n+    @After\n+    public void cleanup() {\n+        for (Long processInstanceId : processIds) {\n+            try {\n+                // let's abort process instance to leave the system in clear state\n+                processService.abortProcessInstance(processInstanceId);\n+\n+                ProcessInstance pi = processService.getProcessInstance(processInstanceId);\n+                assertNull(pi);\n+            } catch (ProcessInstanceNotFoundException e) {\n+                // ignore it as it was already completed/aborted\n+            }\n+        }\n+        cleanupSingletonSessionId();\n+        if (units != null && !units.isEmpty()) {\n+            for (DeploymentUnit unit : units) {\n+                try {\n+                    deploymentService.undeploy(unit);\n+                } catch (Exception e) {\n+                    // do nothing in case of some failed tests to avoid next test to fail as well\n+                }\n+            }\n+            units.clear();\n+        }\n+        close();\n+    }\n+\n+    @Test\n+    public void testQueryProcessByVariables() {\n+        List<QueryParam> variables = list(equalsTo(\"var_a\", \"a1\"), equalsTo(\"var_b\", \"1\"));\n+        List<QueryParam> attributes = list(equalsTo(PROCESS_ATTR_DEFINITION_ID, \"test.test_A\"));\n+\n+        List<ProcessInstanceWithVarsDesc> data = advanceVariableDataService.queryProcessByVariables(attributes, variables, queryContext);\n+        if (queryContext.getCount() > 0) {\n+            Assert.assertThat(data.size(), is(queryContext.getCount()));\n+        }\n+        for (ProcessInstanceWithVarsDesc p : data) {\n+            Assert.assertEquals(\"a1\", p.getVariables().get(\"var_a\"));\n+            Assert.assertEquals(\"1\", p.getVariables().get(\"var_b\"));\n+            Assert.assertEquals(\"test.test_A\", p.getProcessId());\n+        }\n+    }\n+\n+    @Test\n+    public void testQueryInOperator() {\n+\n+        List<QueryParam> variables = list(in(\"var_a\", \"a1\", \"a2\"));\n+        List<QueryParam> attributes = list(equalsTo(PROCESS_ATTR_DEFINITION_ID, \"test.test_A\"));\n+\n+        List<ProcessInstanceWithVarsDesc> data = advanceVariableDataService.queryProcessByVariables(attributes, variables, queryContext);\n+        if (queryContext.getCount() > 0) {\n+            Assert.assertThat(data.size(), is(queryContext.getCount()));\n+        }\n+        List<String> values = Arrays.asList(\"a1\", \"a2\");\n+        for (ProcessInstanceWithVarsDesc p : data) {\n+            Assert.assertTrue(values.contains(p.getVariables().get(\"var_a\")));\n+            Assert.assertEquals(\"test.test_A\", p.getProcessId());\n+        }\n+    }\n+\n+    @Test\n+    public void testQueryLikeToOperator() {\n+\n+        List<QueryParam> variables = list(likeTo(\"var_a\", false, \"a%\"));\n+        List<QueryParam> attributes = list(likeTo(PROCESS_ATTR_DEFINITION_ID, false, \"%test_A%\"));\n+\n+        List<ProcessInstanceWithVarsDesc> data = advanceVariableDataService.queryProcessByVariables(attributes, variables, queryContext);\n+        if (queryContext.getCount() > 0) {\n+            Assert.assertThat(data.size(), is(queryContext.getCount()));\n+        }\n+\n+        for (ProcessInstanceWithVarsDesc p : data) {\n+            Assert.assertTrue(((String) p.getVariables().get(\"var_a\")).startsWith(\"a\"));\n+            Assert.assertEquals(\"test.test_A\", p.getProcessId());\n+        }\n+    }\n+\n+    @Test\n+    public void testQueryIsNullOperator() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7254bbd4405c29a3f8eb4f1b3967ee8c78cfd26a"}, "originalPosition": 214}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzQzNDc3OA==", "bodyText": "typo? (Get)", "url": "https://github.com/kiegroup/jbpm/pull/1615#discussion_r407434778", "createdAt": "2020-04-13T11:23:06Z", "author": {"login": "gmunozfe"}, "path": "jbpm-services/jbpm-kie-services/src/main/resources/META-INF/Servicesorm.xml", "diffHunk": "@@ -1182,5 +1182,71 @@\n     </query>\n     <!-- hint name=\"org.hibernate.timeout\" value=\"200\"/ -->\n   </named-query>   \n-        \n+\n+\n+  <!-- advance runtime queries -->\n+  <named-native-query name=\"GeProcessInstanceByIdList\">", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7254bbd4405c29a3f8eb4f1b3967ee8c78cfd26a"}, "originalPosition": 8}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzQzNDg0MA==", "bodyText": "typo? (Get)", "url": "https://github.com/kiegroup/jbpm/pull/1615#discussion_r407434840", "createdAt": "2020-04-13T11:23:22Z", "author": {"login": "gmunozfe"}, "path": "jbpm-services/jbpm-kie-services/src/main/resources/META-INF/Servicesorm.xml", "diffHunk": "@@ -1182,5 +1182,71 @@\n     </query>\n     <!-- hint name=\"org.hibernate.timeout\" value=\"200\"/ -->\n   </named-query>   \n-        \n+\n+\n+  <!-- advance runtime queries -->\n+  <named-native-query name=\"GeProcessInstanceByIdList\">\n+      <query>\n+        SELECT processInstanceId, processId, processName, processVersion, status, externalId, start_date, user_identity, correlationKey \n+          FROM ProcessInstanceLog pil \n+         WHERE processInstanceId IN (:idList) \n+      ORDER BY processInstanceId ASC \n+    </query>\n+  </named-native-query>\n+  \n+  <named-native-query name=\"GeVariablesByProcessInstanceIdList\">", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7254bbd4405c29a3f8eb4f1b3967ee8c78cfd26a"}, "originalPosition": 17}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "7254bbd4405c29a3f8eb4f1b3967ee8c78cfd26a", "author": {"user": null}, "url": "https://github.com/kiegroup/jbpm/commit/7254bbd4405c29a3f8eb4f1b3967ee8c78cfd26a", "committedDate": "2020-04-12T16:59:41Z", "message": "[RHPAM-2552] Ability to Search for tasks by multiple task variables a nd / or process variables via the kie-server api.\n\nadded the possibility to query process/cases by variables"}, "afterCommit": {"oid": "f04f50355ec285330b3467d42754a036a04b1db3", "author": {"user": null}, "url": "https://github.com/kiegroup/jbpm/commit/f04f50355ec285330b3467d42754a036a04b1db3", "committedDate": "2020-04-14T06:53:04Z", "message": "[RHPAM-2552] Ability to Search for tasks by multiple task variables a nd / or process variables via the kie-server api.\n\nadded the possibility to query process/cases by variables"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg5MDUxNDM4", "url": "https://github.com/kiegroup/jbpm/pull/1615#pullrequestreview-389051438", "createdAt": "2020-04-07T12:09:32Z", "commit": {"oid": "dff54f99161103a3aa333b880692a15f1e9f4e62"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 31, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wN1QxMjowOTozMlrOGCAdBg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNVQwOTowNTo0MlrOGFwlkw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDc1Nzc2Ng==", "bodyText": "\"public static\" are redundant for an interface. Please remove them.", "url": "https://github.com/kiegroup/jbpm/pull/1615#discussion_r404757766", "createdAt": "2020-04-07T12:09:32Z", "author": {"login": "afalhambra"}, "path": "jbpm-case-mgmt/jbpm-case-mgmt-api/src/main/java/org/jbpm/casemgmt/api/AdvanceCaseRuntimeDataService.java", "diffHunk": "@@ -0,0 +1,45 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.jbpm.casemgmt.api;\n+\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.jbpm.services.api.model.ProcessInstanceWithVarsDesc;\n+import org.jbpm.services.api.model.UserTaskInstanceWithPotOwnerDesc;\n+import org.kie.api.runtime.query.QueryContext;\n+\n+public interface AdvanceCaseRuntimeDataService {\n+\n+    public static String TASK_ATTR_NAME = \"TASK_NAME\";\n+    public static String TASK_ATTR_OWNER = \"TASK_OWNER\";\n+    public static String CASE_ATTR_INSTANCE_ID = \"PROCESS_INSTANCE_ID\";\n+    public static String CASE_ATTR_CORRELATION_KEY = \"PROCESS_CORRELATION_KEY\";\n+    public static String CASE_ATTR_DEFINITION_ID = \"PROCESS_DEFINITION_ID\";\n+    public static String CASE_ATTR_DEPLOYMENT_ID = \"PROCESS_DEPLOYMENT_ID\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dff54f99161103a3aa333b880692a15f1e9f4e62"}, "originalPosition": 33}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDg3MTY4Nw==", "bodyText": "\"public static\" are redundant for an interface. Please remove them.", "url": "https://github.com/kiegroup/jbpm/pull/1615#discussion_r404871687", "createdAt": "2020-04-07T14:51:46Z", "author": {"login": "afalhambra"}, "path": "jbpm-services/jbpm-services-api/src/main/java/org/jbpm/services/api/AdvanceRuntimeDataService.java", "diffHunk": "@@ -0,0 +1,39 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.jbpm.services.api;\n+\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.jbpm.services.api.model.ProcessInstanceWithVarsDesc;\n+import org.jbpm.services.api.model.UserTaskInstanceWithPotOwnerDesc;\n+import org.kie.api.runtime.query.QueryContext;\n+\n+public interface AdvanceRuntimeDataService {\n+\n+    public static String TASK_ATTR_NAME = \"TASK_NAME\";\n+    public static String TASK_ATTR_OWNER = \"TASK_OWNER\";\n+    public static String PROCESS_ATTR_INSTANCE_ID = \"PROCESS_INSTANCE_ID\";\n+    public static String PROCESS_ATTR_CORRELATION_KEY = \"PROCESS_CORRELATION_KEY\";\n+    public static String PROCESS_ATTR_DEFINITION_ID = \"PROCESS_DEFINITION_ID\";\n+    public static String PROCESS_ATTR_DEPLOYMENT_ID = \"PROCESS_DEPLOYMENT_ID\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dff54f99161103a3aa333b880692a15f1e9f4e62"}, "originalPosition": 33}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODA3NTczOQ==", "bodyText": "Deployment ID is not specified in the jira ticket. We should either update jira ticket or remove this field. What do you think @elguardian?", "url": "https://github.com/kiegroup/jbpm/pull/1615#discussion_r408075739", "createdAt": "2020-04-14T11:51:38Z", "author": {"login": "afalhambra"}, "path": "jbpm-services/jbpm-services-api/src/main/java/org/jbpm/services/api/AdvanceRuntimeDataService.java", "diffHunk": "@@ -0,0 +1,39 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.jbpm.services.api;\n+\n+import java.util.List;\n+\n+import org.jbpm.services.api.model.ProcessInstanceWithVarsDesc;\n+import org.jbpm.services.api.model.UserTaskInstanceWithPotOwnerDesc;\n+import org.jbpm.services.api.query.model.QueryParam;\n+import org.kie.api.runtime.query.QueryContext;\n+\n+public interface AdvanceRuntimeDataService {\n+\n+    public static String TASK_ATTR_NAME = \"TASK_NAME\";\n+    public static String TASK_ATTR_OWNER = \"TASK_OWNER\";\n+    public static String PROCESS_ATTR_INSTANCE_ID = \"PROCESS_INSTANCE_ID\";\n+    public static String PROCESS_ATTR_CORRELATION_KEY = \"PROCESS_CORRELATION_KEY\";\n+    public static String PROCESS_ATTR_DEFINITION_ID = \"PROCESS_DEFINITION_ID\";\n+    public static String PROCESS_ATTR_DEPLOYMENT_ID = \"PROCESS_DEPLOYMENT_ID\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f04f50355ec285330b3467d42754a036a04b1db3"}, "originalPosition": 33}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODA4NTg3MA==", "bodyText": "Would it make sense to rename it to caseVariables rather than processVariables?", "url": "https://github.com/kiegroup/jbpm/pull/1615#discussion_r408085870", "createdAt": "2020-04-14T12:10:39Z", "author": {"login": "afalhambra"}, "path": "jbpm-case-mgmt/jbpm-case-mgmt-api/src/main/java/org/jbpm/casemgmt/api/AdvanceCaseRuntimeDataService.java", "diffHunk": "@@ -0,0 +1,45 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.jbpm.casemgmt.api;\n+\n+import java.util.List;\n+\n+import org.jbpm.services.api.model.ProcessInstanceWithVarsDesc;\n+import org.jbpm.services.api.model.UserTaskInstanceWithPotOwnerDesc;\n+import org.jbpm.services.api.query.model.QueryParam;\n+import org.kie.api.runtime.query.QueryContext;\n+\n+public interface AdvanceCaseRuntimeDataService {\n+\n+    public static String TASK_ATTR_NAME = \"TASK_NAME\";\n+    public static String TASK_ATTR_OWNER = \"TASK_OWNER\";\n+    public static String CASE_ATTR_INSTANCE_ID = \"PROCESS_INSTANCE_ID\";\n+    public static String CASE_ATTR_CORRELATION_KEY = \"PROCESS_CORRELATION_KEY\";\n+    public static String CASE_ATTR_DEFINITION_ID = \"PROCESS_DEFINITION_ID\";\n+    public static String CASE_ATTR_DEPLOYMENT_ID = \"PROCESS_DEPLOYMENT_ID\";\n+\n+    List<ProcessInstanceWithVarsDesc> queryCaseByVariables(List<QueryParam> attributes,\n+                                                           List<QueryParam> variables,\n+                                                           QueryContext queryContext);\n+\n+    List<UserTaskInstanceWithPotOwnerDesc> queryUserTasksByVariables(List<QueryParam> attributes,\n+                                                                     List<QueryParam> variables,\n+                                                                     List<QueryParam> processVariables,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f04f50355ec285330b3467d42754a036a04b1db3"}, "originalPosition": 41}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODA4NzE0MA==", "bodyText": "Deployment ID is not specified in the jira ticket. We should either update jira ticket or remove this field. What do you think @elguardian?", "url": "https://github.com/kiegroup/jbpm/pull/1615#discussion_r408087140", "createdAt": "2020-04-14T12:12:56Z", "author": {"login": "afalhambra"}, "path": "jbpm-case-mgmt/jbpm-case-mgmt-api/src/main/java/org/jbpm/casemgmt/api/AdvanceCaseRuntimeDataService.java", "diffHunk": "@@ -0,0 +1,45 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.jbpm.casemgmt.api;\n+\n+import java.util.List;\n+\n+import org.jbpm.services.api.model.ProcessInstanceWithVarsDesc;\n+import org.jbpm.services.api.model.UserTaskInstanceWithPotOwnerDesc;\n+import org.jbpm.services.api.query.model.QueryParam;\n+import org.kie.api.runtime.query.QueryContext;\n+\n+public interface AdvanceCaseRuntimeDataService {\n+\n+    public static String TASK_ATTR_NAME = \"TASK_NAME\";\n+    public static String TASK_ATTR_OWNER = \"TASK_OWNER\";\n+    public static String CASE_ATTR_INSTANCE_ID = \"PROCESS_INSTANCE_ID\";\n+    public static String CASE_ATTR_CORRELATION_KEY = \"PROCESS_CORRELATION_KEY\";\n+    public static String CASE_ATTR_DEFINITION_ID = \"PROCESS_DEFINITION_ID\";\n+    public static String CASE_ATTR_DEPLOYMENT_ID = \"PROCESS_DEPLOYMENT_ID\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f04f50355ec285330b3467d42754a036a04b1db3"}, "originalPosition": 33}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODA4NzkyNA==", "bodyText": "Would it make sense to declare translateTable as final?", "url": "https://github.com/kiegroup/jbpm/pull/1615#discussion_r408087924", "createdAt": "2020-04-14T12:14:25Z", "author": {"login": "afalhambra"}, "path": "jbpm-case-mgmt/jbpm-case-mgmt-impl/src/main/java/org/jbpm/casemgmt/impl/AdvanceCaseRuntimeDataServiceImpl.java", "diffHunk": "@@ -0,0 +1,65 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.jbpm.casemgmt.impl;\n+\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.jbpm.casemgmt.api.AdvanceCaseRuntimeDataService;\n+import org.jbpm.kie.services.impl.AbstractAdvanceRuntimeDataServiceImpl;\n+import org.jbpm.services.api.query.model.QueryParam;\n+import org.kie.api.runtime.query.QueryContext;\n+\n+import static org.jbpm.process.core.context.variable.VariableScope.CASE_FILE_PREFIX;\n+import static org.jbpm.workflow.core.WorkflowProcess.CASE_TYPE;\n+\n+public class AdvanceCaseRuntimeDataServiceImpl extends AbstractAdvanceRuntimeDataServiceImpl implements AdvanceCaseRuntimeDataService {\n+\n+    private Map<String, String> translateTable = new HashMap<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f04f50355ec285330b3467d42754a036a04b1db3"}, "originalPosition": 33}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODA4ODQ0Ng==", "bodyText": "Would it make sense to rename it to caseVariables rather than processVariables?", "url": "https://github.com/kiegroup/jbpm/pull/1615#discussion_r408088446", "createdAt": "2020-04-14T12:15:23Z", "author": {"login": "afalhambra"}, "path": "jbpm-case-mgmt/jbpm-case-mgmt-impl/src/main/java/org/jbpm/casemgmt/impl/AdvanceCaseRuntimeDataServiceImpl.java", "diffHunk": "@@ -0,0 +1,65 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.jbpm.casemgmt.impl;\n+\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.jbpm.casemgmt.api.AdvanceCaseRuntimeDataService;\n+import org.jbpm.kie.services.impl.AbstractAdvanceRuntimeDataServiceImpl;\n+import org.jbpm.services.api.query.model.QueryParam;\n+import org.kie.api.runtime.query.QueryContext;\n+\n+import static org.jbpm.process.core.context.variable.VariableScope.CASE_FILE_PREFIX;\n+import static org.jbpm.workflow.core.WorkflowProcess.CASE_TYPE;\n+\n+public class AdvanceCaseRuntimeDataServiceImpl extends AbstractAdvanceRuntimeDataServiceImpl implements AdvanceCaseRuntimeDataService {\n+\n+    private Map<String, String> translateTable = new HashMap<>();\n+\n+    public AdvanceCaseRuntimeDataServiceImpl() {\n+        translateTable.put(CASE_ATTR_CORRELATION_KEY, \"pil.correlationKey\");\n+        translateTable.put(CASE_ATTR_DEFINITION_ID, \"pil.processId\");\n+        translateTable.put(CASE_ATTR_INSTANCE_ID, \"pil.processInstanceId\");\n+        translateTable.put(CASE_ATTR_DEPLOYMENT_ID, \"pil.externalId\");\n+        translateTable.put(TASK_ATTR_NAME, \"task.name\");\n+        translateTable.put(TASK_ATTR_OWNER, \"task.actualOwner_id\");\n+\n+    }\n+\n+    @Override\n+    public List<org.jbpm.services.api.model.ProcessInstanceWithVarsDesc> queryCaseByVariables(List<QueryParam> attributes,\n+                                                                                              List<QueryParam> variables,\n+                                                                                              QueryContext queryContext) {\n+        return queryProcessByVariables(translate(translateTable, attributes), variables, CASE_TYPE, CASE_FILE_PREFIX, queryContext);\n+\n+    }\n+\n+\n+    @Override\n+    public List<org.jbpm.services.api.model.UserTaskInstanceWithPotOwnerDesc> queryUserTasksByVariables(List<QueryParam> attributes,\n+                                                                                                        List<QueryParam> variables,\n+                                                                                                        List<QueryParam> processVariables,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f04f50355ec285330b3467d42754a036a04b1db3"}, "originalPosition": 57}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODEyNzQ1OA==", "bodyText": "I would expect to pass variable data and owners as part of the query criteria in this call.", "url": "https://github.com/kiegroup/jbpm/pull/1615#discussion_r408127458", "createdAt": "2020-04-14T13:16:52Z", "author": {"login": "afalhambra"}, "path": "jbpm-case-mgmt/jbpm-case-mgmt-impl/src/test/java/org/jbpm/casemgmt/impl/AdvanceCaseRuntimeDataServiceImplTest.java", "diffHunk": "@@ -0,0 +1,96 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.jbpm.casemgmt.impl;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.jbpm.casemgmt.api.model.instance.CaseFileInstance;\n+import org.jbpm.casemgmt.impl.util.AbstractCaseServicesBaseTest;\n+import org.jbpm.services.api.model.ProcessInstanceWithVarsDesc;\n+import org.jbpm.services.api.model.UserTaskInstanceWithPotOwnerDesc;\n+import org.jbpm.services.api.query.model.QueryParam;\n+import org.jbpm.services.task.impl.model.UserImpl;\n+import org.junit.Test;\n+import org.kie.api.runtime.query.QueryContext;\n+import org.kie.api.task.model.OrganizationalEntity;\n+\n+import static java.util.Collections.emptyList;\n+import static org.jbpm.services.api.query.model.QueryParam.equalsTo;\n+import static org.jbpm.services.api.query.model.QueryParam.list;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNotNull;\n+\n+public class AdvanceCaseRuntimeDataServiceImplTest extends AbstractCaseServicesBaseTest {\n+\n+\n+    @Override\n+    protected List<String> getProcessDefinitionFiles() {\n+        List<String> processes = new ArrayList<String>();\n+        processes.add(\"cases/EmptyCase.bpmn2\");\n+        processes.add(\"cases/UserTaskCase.bpmn2\");\n+        return processes;\n+    }\n+\n+    /*\n+     * Case instance queries\n+     */\n+    @Test\n+    public void testSearchByVariable() {\n+        Map<String, Object> data = new HashMap<>();\n+        data.put(\"name\", \"my first case\");\n+\n+        CaseFileInstance caseFile = caseService.newCaseFileInstance(deploymentUnit.getIdentifier(), EMPTY_CASE_P_ID, data);\n+\n+        String caseId = caseService.startCase(deploymentUnit.getIdentifier(), EMPTY_CASE_P_ID, caseFile);\n+\n+        List<QueryParam> vars = list(equalsTo(\"name\", \"my first case\"));\n+\n+        List<ProcessInstanceWithVarsDesc> process = advanceCaseRuntimeDataService.queryCaseByVariables(emptyList(), vars, new QueryContext());\n+        assertEquals(1, process.size());\n+        assertEquals(\"my first case\", process.get(0).getExtraData().get(\"name\"));\n+\n+        assertNotNull(caseId);\n+        assertEquals(FIRST_CASE_ID, caseId);\n+        caseService.cancelCase(caseId);\n+\n+    }\n+\n+    @Test\n+    public void testSearchUserByVariable() {\n+        Map<String, OrganizationalEntity> roleAssignments = new HashMap<>();\n+        roleAssignments.put(\"owner\", new UserImpl(USER));\n+\n+        Map<String, Object> data = new HashMap<>();\n+        data.put(\"name\", \"my first case\");\n+        CaseFileInstance caseFile = caseService.newCaseFileInstance(deploymentUnit.getIdentifier(), USER_TASK_CASE_P_ID, data, roleAssignments);\n+\n+        String caseId = caseService.startCase(deploymentUnit.getIdentifier(), USER_TASK_CASE_P_ID, caseFile);\n+\n+        List<UserTaskInstanceWithPotOwnerDesc> process = advanceCaseRuntimeDataService.queryUserTasksByVariables(emptyList(), emptyList(), emptyList(), emptyList(), new QueryContext());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f04f50355ec285330b3467d42754a036a04b1db3"}, "originalPosition": 86}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODEyODQwMQ==", "bodyText": "For case and casetasks I would be missing some tests regarding to the requirements we have. So far we are currently testing:\nPotential owner\t\u2718\t\u2718\t\u2713\t\u2713\tFilters by task potential owner (in case of more than one, all must match)\nCase File Var\t\u2713\t\u2718\t\u2713\t\u2718\tFilter by case var name=value\nAnd I'm missing:\nActual task owner | \u2718 | \u2718 | \u2713 | \u2713 | Filters by task actual owner\nCorrelation key | \u2713 | \u2713 | \u2713 | \u2713 | Filters by correlation key name\nTask name | \u2718 | \u2718 | \u2713 | \u2713 | Filters by task name\nCase definition id | \u2713 | \u2718 | \u2713 | \u2718 | Filters by case definition id\nCase instance id | \u2713 | \u2718 | \u2713 | \u2718 | Filters by case instance id\nTask Variables | \u2718 | \u2718 | \u2713 | \u2713 | Filter by task variable name=value\nAlso, would be nice to have some pagination test along with the use of the operator (equal, not_equal, etc). Let me know, if not I can add some to it afterwards. What do you think?", "url": "https://github.com/kiegroup/jbpm/pull/1615#discussion_r408128401", "createdAt": "2020-04-14T13:18:15Z", "author": {"login": "afalhambra"}, "path": "jbpm-case-mgmt/jbpm-case-mgmt-impl/src/test/java/org/jbpm/casemgmt/impl/AdvanceCaseRuntimeDataServiceImplTest.java", "diffHunk": "@@ -0,0 +1,96 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.jbpm.casemgmt.impl;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.jbpm.casemgmt.api.model.instance.CaseFileInstance;\n+import org.jbpm.casemgmt.impl.util.AbstractCaseServicesBaseTest;\n+import org.jbpm.services.api.model.ProcessInstanceWithVarsDesc;\n+import org.jbpm.services.api.model.UserTaskInstanceWithPotOwnerDesc;\n+import org.jbpm.services.api.query.model.QueryParam;\n+import org.jbpm.services.task.impl.model.UserImpl;\n+import org.junit.Test;\n+import org.kie.api.runtime.query.QueryContext;\n+import org.kie.api.task.model.OrganizationalEntity;\n+\n+import static java.util.Collections.emptyList;\n+import static org.jbpm.services.api.query.model.QueryParam.equalsTo;\n+import static org.jbpm.services.api.query.model.QueryParam.list;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNotNull;\n+\n+public class AdvanceCaseRuntimeDataServiceImplTest extends AbstractCaseServicesBaseTest {\n+\n+\n+    @Override\n+    protected List<String> getProcessDefinitionFiles() {\n+        List<String> processes = new ArrayList<String>();\n+        processes.add(\"cases/EmptyCase.bpmn2\");\n+        processes.add(\"cases/UserTaskCase.bpmn2\");\n+        return processes;\n+    }\n+\n+    /*\n+     * Case instance queries\n+     */\n+    @Test\n+    public void testSearchByVariable() {\n+        Map<String, Object> data = new HashMap<>();\n+        data.put(\"name\", \"my first case\");\n+\n+        CaseFileInstance caseFile = caseService.newCaseFileInstance(deploymentUnit.getIdentifier(), EMPTY_CASE_P_ID, data);\n+\n+        String caseId = caseService.startCase(deploymentUnit.getIdentifier(), EMPTY_CASE_P_ID, caseFile);\n+\n+        List<QueryParam> vars = list(equalsTo(\"name\", \"my first case\"));\n+\n+        List<ProcessInstanceWithVarsDesc> process = advanceCaseRuntimeDataService.queryCaseByVariables(emptyList(), vars, new QueryContext());\n+        assertEquals(1, process.size());\n+        assertEquals(\"my first case\", process.get(0).getExtraData().get(\"name\"));\n+\n+        assertNotNull(caseId);\n+        assertEquals(FIRST_CASE_ID, caseId);\n+        caseService.cancelCase(caseId);\n+\n+    }\n+\n+    @Test\n+    public void testSearchUserByVariable() {\n+        Map<String, OrganizationalEntity> roleAssignments = new HashMap<>();\n+        roleAssignments.put(\"owner\", new UserImpl(USER));\n+\n+        Map<String, Object> data = new HashMap<>();\n+        data.put(\"name\", \"my first case\");\n+        CaseFileInstance caseFile = caseService.newCaseFileInstance(deploymentUnit.getIdentifier(), USER_TASK_CASE_P_ID, data, roleAssignments);\n+\n+        String caseId = caseService.startCase(deploymentUnit.getIdentifier(), USER_TASK_CASE_P_ID, caseFile);\n+\n+        List<UserTaskInstanceWithPotOwnerDesc> process = advanceCaseRuntimeDataService.queryUserTasksByVariables(emptyList(), emptyList(), emptyList(), emptyList(), new QueryContext());\n+        assertEquals(1, process.size());\n+        assertEquals(\"my first case\", process.get(0).getExtraData().get(\"name\"));\n+\n+        assertNotNull(caseId);\n+        assertEquals(HR_CASE_ID, caseId);\n+        caseService.cancelCase(caseId);\n+\n+    }\n+\n+}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f04f50355ec285330b3467d42754a036a04b1db3"}, "originalPosition": 96}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODEyOTExNQ==", "bodyText": "QueryContext has ordering asc or desc capabilities but it is not used in the query. Should we take this into account?", "url": "https://github.com/kiegroup/jbpm/pull/1615#discussion_r408129115", "createdAt": "2020-04-14T13:19:14Z", "author": {"login": "afalhambra"}, "path": "jbpm-services/jbpm-kie-services/src/main/java/org/jbpm/kie/services/impl/AbstractAdvanceRuntimeDataServiceImpl.java", "diffHunk": "@@ -0,0 +1,346 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.jbpm.kie.services.impl;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import javax.persistence.EntityManager;\n+import javax.persistence.EntityManagerFactory;\n+import javax.persistence.Query;\n+\n+import org.dashbuilder.dataset.filter.CoreFunctionType;\n+import org.jbpm.kie.services.impl.model.ProcessInstanceWithVarsDesc;\n+import org.jbpm.kie.services.impl.model.UserTaskInstanceWithPotOwnerDesc;\n+import org.jbpm.services.api.query.model.QueryParam;\n+import org.jbpm.shared.services.impl.QueryManager;\n+import org.jbpm.shared.services.impl.TransactionalCommandService;\n+import org.jbpm.shared.services.impl.commands.QueryNameCommand;\n+import org.kie.api.runtime.query.QueryContext;\n+\n+import static java.util.Collections.singletonMap;\n+\n+public abstract class AbstractAdvanceRuntimeDataServiceImpl {\n+\n+    private static final String ID_LIST = \"idList\";\n+    private EntityManagerFactory emf;\n+    private TransactionalCommandService commandService;\n+\n+    public AbstractAdvanceRuntimeDataServiceImpl() {\n+        QueryManager.get().addNamedQueries(\"META-INF/Servicesorm.xml\");\n+    }\n+    public void setCommandService(TransactionalCommandService commandService) {\n+        this.commandService = commandService;\n+    }\n+\n+    public void setEmf(EntityManagerFactory emf) {\n+        this.emf = emf;\n+    }\n+\n+\n+    public List<org.jbpm.services.api.model.ProcessInstanceWithVarsDesc> queryProcessByVariables(List<QueryParam> attributes,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f04f50355ec285330b3467d42754a036a04b1db3"}, "originalPosition": 59}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODEzNTg0MA==", "bodyText": "I would rename it to \"uwv\" (UserTaskInstanceWithPotOwnerDesc) instead of \"pwv\" (ProcessInstanceWithVarsDesc)", "url": "https://github.com/kiegroup/jbpm/pull/1615#discussion_r408135840", "createdAt": "2020-04-14T13:28:38Z", "author": {"login": "afalhambra"}, "path": "jbpm-services/jbpm-kie-services/src/main/java/org/jbpm/kie/services/impl/AbstractAdvanceRuntimeDataServiceImpl.java", "diffHunk": "@@ -0,0 +1,346 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.jbpm.kie.services.impl;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import javax.persistence.EntityManager;\n+import javax.persistence.EntityManagerFactory;\n+import javax.persistence.Query;\n+\n+import org.dashbuilder.dataset.filter.CoreFunctionType;\n+import org.jbpm.kie.services.impl.model.ProcessInstanceWithVarsDesc;\n+import org.jbpm.kie.services.impl.model.UserTaskInstanceWithPotOwnerDesc;\n+import org.jbpm.services.api.query.model.QueryParam;\n+import org.jbpm.shared.services.impl.QueryManager;\n+import org.jbpm.shared.services.impl.TransactionalCommandService;\n+import org.jbpm.shared.services.impl.commands.QueryNameCommand;\n+import org.kie.api.runtime.query.QueryContext;\n+\n+import static java.util.Collections.singletonMap;\n+\n+public abstract class AbstractAdvanceRuntimeDataServiceImpl {\n+\n+    private static final String ID_LIST = \"idList\";\n+    private EntityManagerFactory emf;\n+    private TransactionalCommandService commandService;\n+\n+    public AbstractAdvanceRuntimeDataServiceImpl() {\n+        QueryManager.get().addNamedQueries(\"META-INF/Servicesorm.xml\");\n+    }\n+    public void setCommandService(TransactionalCommandService commandService) {\n+        this.commandService = commandService;\n+    }\n+\n+    public void setEmf(EntityManagerFactory emf) {\n+        this.emf = emf;\n+    }\n+\n+\n+    public List<org.jbpm.services.api.model.ProcessInstanceWithVarsDesc> queryProcessByVariables(List<QueryParam> attributes,\n+                                                                                                 List<QueryParam> variables,\n+                                                                                                 int processType,\n+                                                                                                 String varPrefix,\n+                                                                                                 QueryContext queryContext) {\n+        EntityManager entityManager = emf.createEntityManager();\n+\n+        // first step is to filter the data creating a derived tables and pivoting var - rows to columns (only the variables we are interested to filter)\n+        StringBuilder derivedTables = new StringBuilder();\n+        if (!variables.isEmpty()) {\n+            List<String> conditions = new ArrayList<>();\n+            variables.stream().forEach(expr -> conditions.add(\"(A1.variableId = :NAME_\" + expr.getColumn() + \" AND \" + computeExpression(expr, \"A1.value\", \":VALUE_\" + expr.getColumn()) + \")\\n\"));\n+            String where = String.join(\" OR \", conditions);\n+            derivedTables.append(\"INNER JOIN (\" +\n+                                 \"SELECT A1.processInstanceId \\n\" +\n+                                 \"FROM VariableInstanceLog A1 \\n\" +\n+                                 \"LEFT JOIN VariableInstanceLog A2 ON A1.processId = A2.processId AND A1.processInstanceId = A2.processInstanceId AND A1.variableInstanceId = A2.variableInstanceId AND A2.id > A1.id  \\n\" +\n+                                 \"WHERE A2.id IS NULL AND (\" + where + \") \" +\n+                                 \"GROUP BY A1.processInstanceId \" +\n+                                 \"HAVING COUNT(*) = :NUMBER_OF_VARS \" +\n+                                 \") TABLE_VAR ON TABLE_VAR.processInstanceId = pil.processInstanceId \\n\");\n+        }\n+\n+        StringBuilder globalWhere = new StringBuilder();\n+        attributes.stream().forEach(expr -> globalWhere.append(\" AND \" + computeExpression(expr, expr.getColumn(), \":ATTR_\" + expr.getColumn())));\n+\n+        String procSQLString =\n+                \" SELECT DISTINCT pil.processInstanceId \" +\n+                               \" FROM ProcessInstanceLog pil \\n \" +\n+                               derivedTables +\n+                               \" WHERE pil.processType = :processType \" + globalWhere +\n+                               \" ORDER BY pil.processInstanceId ASC \";\n+\n+        Query query = entityManager.createNativeQuery(procSQLString);\n+        variables.stream().forEach(var -> query.setParameter(\"NAME_\" + var.getColumn(), varPrefix + var.getColumn()));\n+        variables.stream().filter(e -> e.getObjectValue() != null).forEach(var -> query.setParameter(\"VALUE_\" + var.getColumn(), var.getObjectValue()));\n+        attributes.stream().filter(e -> e.getObjectValue() != null).forEach((entry) -> query.setParameter(\"ATTR_\" + entry.getColumn(), entry.getObjectValue()));\n+\n+        if (!variables.isEmpty()) {\n+            query.setParameter(\"NUMBER_OF_VARS\", variables.size());\n+        }\n+        query.setParameter(\"processType\", processType);\n+\n+        addPagination(query, queryContext);\n+        List<Number> ids = query.getResultList();\n+        if (ids.isEmpty()) {\n+            return Collections.emptyList();\n+        }\n+\n+        // now we get the information\n+\n+        List<Object[]> procRows = commandService.execute(new QueryNameCommand<List<Object[]>>(\"GetProcessInstanceByIdList\", singletonMap(ID_LIST, ids)));\n+        List<Object[]> varRows = commandService.execute(new QueryNameCommand<List<Object[]>>(\"GetVariablesByProcessInstanceIdList\", singletonMap(ID_LIST, ids)));\n+\n+        int currentVarIdx = 0;\n+        List<org.jbpm.services.api.model.ProcessInstanceWithVarsDesc> data = new ArrayList<>();\n+        for (Object[] row : procRows) {\n+            ProcessInstanceWithVarsDesc pwv = toProcessInstanceWithVarsDesc(row);\n+\n+            Map<String, Object> vars = new HashMap<>();\n+            pwv.setVariables(vars);\n+\n+            Map<String, Object> extra = new HashMap<>();\n+            pwv.setExtraData(extra);\n+            while (currentVarIdx < varRows.size() && row[0].equals(varRows.get(currentVarIdx)[0])) {\n+                String name = (String) varRows.get(currentVarIdx)[1];\n+                if (!varPrefix.isEmpty() && name.startsWith(varPrefix)) {\n+                    extra.put(name.substring(varPrefix.length()), varRows.get(currentVarIdx)[2]);\n+                } else {\n+                    vars.put(name, varRows.get(currentVarIdx)[2]);\n+                }\n+                currentVarIdx++;\n+            }\n+            data.add(pwv);\n+        }\n+\n+        entityManager.close();\n+        return data;\n+    }\n+\n+    private String computeExpression(QueryParam expr, String leftOperand, String rightOperand) {\n+        CoreFunctionType type = CoreFunctionType.getByName(expr.getOperator());\n+        switch (type) {\n+            case IS_NULL:\n+                return leftOperand + \" IS NULL \";\n+            case NOT_NULL:\n+                return leftOperand + \" IS NOT NULL \";\n+            case IN:\n+                return leftOperand + \" IN (\" + rightOperand + \") \";\n+            case NOT_IN:\n+                return leftOperand + \" NOT IN (\" + rightOperand + \") \";\n+            case EQUALS_TO:\n+                return leftOperand + \" = \" + rightOperand + \" \";\n+            case NOT_EQUALS_TO:\n+                return leftOperand + \" <> \" + rightOperand + \" \";\n+            case LIKE_TO:\n+                return leftOperand + \" LIKE \" + rightOperand + \" \";\n+            default:\n+                throw new UnsupportedOperationException(\"Queryparam: \" + expr + \" not supported\");\n+        }\n+    }\n+    private ProcessInstanceWithVarsDesc toProcessInstanceWithVarsDesc(Object[] row) {\n+        return new ProcessInstanceWithVarsDesc(((Number) row[0]).longValue(),\n+                                               (String) row[1],\n+                                               (String) row[2],\n+                                               (String) row[3],\n+                                               ((Number) row[4]).intValue(),\n+                                               (String) row[5],\n+                                               (Date) row[6],\n+                                               (String) row[7],\n+                                               (String) row[8]);\n+    }\n+\n+    private void addPagination(Query query, QueryContext context) {\n+        if (context.getCount() > 0) {\n+            query.setFirstResult(context.getOffset());\n+            query.setMaxResults(context.getCount());\n+        }\n+    }\n+\n+    public List<org.jbpm.services.api.model.UserTaskInstanceWithPotOwnerDesc> queryUserTasksByVariables(List<QueryParam> attributes,\n+                                                                                                        List<QueryParam> variables,\n+                                                                                                        List<QueryParam> processVariables,\n+                                                                                                        List<String> owners,\n+                                                                                                        int processType,\n+                                                                                                        String varPrefix,\n+                                                                                                        QueryContext queryContext) {\n+        EntityManager entityManager = emf.createEntityManager();\n+        StringBuilder globalWhere = new StringBuilder();\n+        StringBuilder derivedTables = new StringBuilder();\n+        if (!variables.isEmpty()) {\n+            List<String> conditions = new ArrayList<>();\n+            variables.stream().forEach((expr) -> conditions.add(\"(name = :V_NAME_\" + expr.getColumn() + \" AND \" + computeExpression(expr, \"value\", \":V_VALUE_\" + expr.getColumn()) + \")\\n\"));\n+            String where = String.join(\" OR \", conditions);\n+            derivedTables.append(\"INNER JOIN (\\n\" +\n+                                 \"SELECT taskId \\n\" +\n+                                 \"FROM TaskVariableImpl \\n\" +\n+                                 \"WHERE type = 0 AND (\" + where + \")\\n\" +\n+                                 \"GROUP BY taskId \\n\" +\n+                                 \"HAVING COUNT(*) = :NUMBER_OF_TASKVARS \\n\" +\n+                                 \") TABLE_TASK_VAR ON TABLE_TASK_VAR.taskId = task.id  \\n\");\n+        }\n+\n+        if (!processVariables.isEmpty()) {\n+            List<String> conditions = new ArrayList<>();\n+            processVariables.stream().forEach((expr) -> conditions.add(\"(A1.variableId = :P_NAME_\" + expr.getColumn() + \" AND \" + computeExpression(expr, \"A1.value\", \":P_VALUE_\" + expr.getColumn()) + \")\\n\"));\n+            String where = String.join(\" OR \", conditions);\n+            derivedTables.append(\"INNER JOIN (\" +\n+                                 \"SELECT A1.processInstanceId \\n\" +\n+                                 \"FROM VariableInstanceLog A1 \\n\" +\n+                                 \"LEFT JOIN VariableInstanceLog A2 ON A1.processId = A2.processId AND A1.processInstanceId = A2.processInstanceId AND A1.variableInstanceId = A2.variableInstanceId AND A2.id > A1.id  \\n\" +\n+                                 \"WHERE A2.id IS NULL AND (\" + where + \") \" +\n+                                 \"GROUP BY A1.processInstanceId \" +\n+                                 \"HAVING COUNT(*) = :NUMBER_OF_PROCVARS \" +\n+                                 \") TABLE_PROC_VAR ON TABLE_PROC_VAR.processInstanceId = pil.processInstanceId \\n\");\n+        }\n+\n+        if (!owners.isEmpty()) {\n+            derivedTables.append(\"INNER JOIN ( \\n\" +\n+                             \"           SELECT DISTINCT po.task_id \\n\" +\n+                             \"           FROM PeopleAssignments_PotOwners po \\n\" +\n+                             \"           WHERE po.entity_id IN (:owners) \\n\" +\n+                             \"           GROUP BY po.task_id \\n\" +\n+                             \"           HAVING COUNT(po.entity_id) = :num_owners \\n\" +\n+                                 \") pot ON pot.task_id = task.id \");\n+        }\n+\n+        attributes.stream().forEach((expr) -> globalWhere.append(\" AND \" + computeExpression(expr, expr.getColumn(), \":ATTR_\" + expr.getColumn())));\n+\n+        String procSQLString = \"SELECT DISTINCT task.id \" +\n+                               \" FROM Task task \" +\n+                               \" INNER JOIN ProcessInstanceLog pil ON pil.processInstanceId = task.processInstanceId \\n \" +\n+                               derivedTables +\n+                               \" WHERE  pil.processType = :processType \" + globalWhere +\n+                               \" ORDER BY task.id ASC \";\n+\n+        Query query = entityManager.createNativeQuery(procSQLString);\n+        variables.stream().forEach(var -> query.setParameter(\"V_NAME_\" + var.getColumn(), var.getColumn()));\n+        variables.stream().filter(e -> e.getObjectValue() != null).forEach((var) -> query.setParameter(\"V_VALUE_\" + var.getColumn(), var.getObjectValue()));\n+\n+        if (!variables.isEmpty()) {\n+            query.setParameter(\"NUMBER_OF_TASKVARS\", variables.size());\n+        }\n+\n+        processVariables.stream().forEach(var -> query.setParameter(\"P_NAME_\" + var.getColumn(), varPrefix + var.getColumn()));\n+        processVariables.stream().filter(e -> e.getObjectValue() != null).forEach((var) -> query.setParameter(\"P_VALUE_\" + var.getColumn(), var.getObjectValue()));\n+\n+        if (!processVariables.isEmpty()) {\n+            query.setParameter(\"NUMBER_OF_PROCVARS\", processVariables.size());\n+        }\n+\n+        if (!owners.isEmpty()) {\n+            query.setParameter(\"num_owners\", owners.size());\n+            query.setParameter(\"owners\", owners);\n+        }\n+\n+        attributes.stream().filter(e -> e.getObjectValue() != null).forEach(entry -> query.setParameter(\"ATTR_\" + entry.getColumn(), entry.getObjectValue()));\n+        query.setParameter(\"processType\", processType);\n+\n+        addPagination(query, queryContext);\n+\n+        List<Number> ids = query.getResultList();\n+        if (ids.isEmpty()) {\n+            return Collections.emptyList();\n+        }\n+\n+        entityManager.close();\n+        return collectData(ids, varPrefix);\n+\n+    }\n+\n+    private List<org.jbpm.services.api.model.UserTaskInstanceWithPotOwnerDesc> collectData(List<Number> ids, String varPrefix) {\n+        // query data\n+        List<Object[]> taskRows = commandService.execute(new QueryNameCommand<List<Object[]>>(\"GetTasksByIdList\", singletonMap(ID_LIST, ids)));\n+        List<Object[]> varRows = commandService.execute(new QueryNameCommand<List<Object[]>>(\"GetTaskVariablesByTaskIdList\", singletonMap(ID_LIST, ids)));\n+        List<Object[]> potRows = commandService.execute(new QueryNameCommand<List<Object[]>>(\"GetPotentialOwnersByTaskIdList\", singletonMap(ID_LIST, ids)));\n+        List<Object[]> varProcSQLRows = commandService.execute(new QueryNameCommand<List<Object[]>>(\"GetProcessVariablesByTaskIdList\", singletonMap(ID_LIST, ids)));\n+\n+        int currentVarIdx = 0;\n+        int currentPotIdx = 0;\n+        int currentVarProcIdx = 0;\n+        List<org.jbpm.services.api.model.UserTaskInstanceWithPotOwnerDesc> data = new ArrayList<>();\n+        for (Object[] row : taskRows) {\n+            UserTaskInstanceWithPotOwnerDesc pwv = toUserTaskInstanceWithPotOwnerDesc(row);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f04f50355ec285330b3467d42754a036a04b1db3"}, "originalPosition": 282}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODI1NzM5NQ==", "bodyText": "I would use TaskVariable.VariableType.INPUT instead of hardcoding values in the query.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                             \"WHERE type = 0 AND (\" + where + \")\\n\" +\n          \n          \n            \n                                             \"WHERE type = :type AND (\" + where + \")\\n\" +\n          \n          \n            \n                                             ...\n          \n          \n            \n                                             query.setParameter(type, TaskVariable.VariableType.INPUT)", "url": "https://github.com/kiegroup/jbpm/pull/1615#discussion_r408257395", "createdAt": "2020-04-14T16:07:18Z", "author": {"login": "afalhambra"}, "path": "jbpm-services/jbpm-kie-services/src/main/java/org/jbpm/kie/services/impl/AbstractAdvanceRuntimeDataServiceImpl.java", "diffHunk": "@@ -0,0 +1,346 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.jbpm.kie.services.impl;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import javax.persistence.EntityManager;\n+import javax.persistence.EntityManagerFactory;\n+import javax.persistence.Query;\n+\n+import org.dashbuilder.dataset.filter.CoreFunctionType;\n+import org.jbpm.kie.services.impl.model.ProcessInstanceWithVarsDesc;\n+import org.jbpm.kie.services.impl.model.UserTaskInstanceWithPotOwnerDesc;\n+import org.jbpm.services.api.query.model.QueryParam;\n+import org.jbpm.shared.services.impl.QueryManager;\n+import org.jbpm.shared.services.impl.TransactionalCommandService;\n+import org.jbpm.shared.services.impl.commands.QueryNameCommand;\n+import org.kie.api.runtime.query.QueryContext;\n+\n+import static java.util.Collections.singletonMap;\n+\n+public abstract class AbstractAdvanceRuntimeDataServiceImpl {\n+\n+    private static final String ID_LIST = \"idList\";\n+    private EntityManagerFactory emf;\n+    private TransactionalCommandService commandService;\n+\n+    public AbstractAdvanceRuntimeDataServiceImpl() {\n+        QueryManager.get().addNamedQueries(\"META-INF/Servicesorm.xml\");\n+    }\n+    public void setCommandService(TransactionalCommandService commandService) {\n+        this.commandService = commandService;\n+    }\n+\n+    public void setEmf(EntityManagerFactory emf) {\n+        this.emf = emf;\n+    }\n+\n+\n+    public List<org.jbpm.services.api.model.ProcessInstanceWithVarsDesc> queryProcessByVariables(List<QueryParam> attributes,\n+                                                                                                 List<QueryParam> variables,\n+                                                                                                 int processType,\n+                                                                                                 String varPrefix,\n+                                                                                                 QueryContext queryContext) {\n+        EntityManager entityManager = emf.createEntityManager();\n+\n+        // first step is to filter the data creating a derived tables and pivoting var - rows to columns (only the variables we are interested to filter)\n+        StringBuilder derivedTables = new StringBuilder();\n+        if (!variables.isEmpty()) {\n+            List<String> conditions = new ArrayList<>();\n+            variables.stream().forEach(expr -> conditions.add(\"(A1.variableId = :NAME_\" + expr.getColumn() + \" AND \" + computeExpression(expr, \"A1.value\", \":VALUE_\" + expr.getColumn()) + \")\\n\"));\n+            String where = String.join(\" OR \", conditions);\n+            derivedTables.append(\"INNER JOIN (\" +\n+                                 \"SELECT A1.processInstanceId \\n\" +\n+                                 \"FROM VariableInstanceLog A1 \\n\" +\n+                                 \"LEFT JOIN VariableInstanceLog A2 ON A1.processId = A2.processId AND A1.processInstanceId = A2.processInstanceId AND A1.variableInstanceId = A2.variableInstanceId AND A2.id > A1.id  \\n\" +\n+                                 \"WHERE A2.id IS NULL AND (\" + where + \") \" +\n+                                 \"GROUP BY A1.processInstanceId \" +\n+                                 \"HAVING COUNT(*) = :NUMBER_OF_VARS \" +\n+                                 \") TABLE_VAR ON TABLE_VAR.processInstanceId = pil.processInstanceId \\n\");\n+        }\n+\n+        StringBuilder globalWhere = new StringBuilder();\n+        attributes.stream().forEach(expr -> globalWhere.append(\" AND \" + computeExpression(expr, expr.getColumn(), \":ATTR_\" + expr.getColumn())));\n+\n+        String procSQLString =\n+                \" SELECT DISTINCT pil.processInstanceId \" +\n+                               \" FROM ProcessInstanceLog pil \\n \" +\n+                               derivedTables +\n+                               \" WHERE pil.processType = :processType \" + globalWhere +\n+                               \" ORDER BY pil.processInstanceId ASC \";\n+\n+        Query query = entityManager.createNativeQuery(procSQLString);\n+        variables.stream().forEach(var -> query.setParameter(\"NAME_\" + var.getColumn(), varPrefix + var.getColumn()));\n+        variables.stream().filter(e -> e.getObjectValue() != null).forEach(var -> query.setParameter(\"VALUE_\" + var.getColumn(), var.getObjectValue()));\n+        attributes.stream().filter(e -> e.getObjectValue() != null).forEach((entry) -> query.setParameter(\"ATTR_\" + entry.getColumn(), entry.getObjectValue()));\n+\n+        if (!variables.isEmpty()) {\n+            query.setParameter(\"NUMBER_OF_VARS\", variables.size());\n+        }\n+        query.setParameter(\"processType\", processType);\n+\n+        addPagination(query, queryContext);\n+        List<Number> ids = query.getResultList();\n+        if (ids.isEmpty()) {\n+            return Collections.emptyList();\n+        }\n+\n+        // now we get the information\n+\n+        List<Object[]> procRows = commandService.execute(new QueryNameCommand<List<Object[]>>(\"GetProcessInstanceByIdList\", singletonMap(ID_LIST, ids)));\n+        List<Object[]> varRows = commandService.execute(new QueryNameCommand<List<Object[]>>(\"GetVariablesByProcessInstanceIdList\", singletonMap(ID_LIST, ids)));\n+\n+        int currentVarIdx = 0;\n+        List<org.jbpm.services.api.model.ProcessInstanceWithVarsDesc> data = new ArrayList<>();\n+        for (Object[] row : procRows) {\n+            ProcessInstanceWithVarsDesc pwv = toProcessInstanceWithVarsDesc(row);\n+\n+            Map<String, Object> vars = new HashMap<>();\n+            pwv.setVariables(vars);\n+\n+            Map<String, Object> extra = new HashMap<>();\n+            pwv.setExtraData(extra);\n+            while (currentVarIdx < varRows.size() && row[0].equals(varRows.get(currentVarIdx)[0])) {\n+                String name = (String) varRows.get(currentVarIdx)[1];\n+                if (!varPrefix.isEmpty() && name.startsWith(varPrefix)) {\n+                    extra.put(name.substring(varPrefix.length()), varRows.get(currentVarIdx)[2]);\n+                } else {\n+                    vars.put(name, varRows.get(currentVarIdx)[2]);\n+                }\n+                currentVarIdx++;\n+            }\n+            data.add(pwv);\n+        }\n+\n+        entityManager.close();\n+        return data;\n+    }\n+\n+    private String computeExpression(QueryParam expr, String leftOperand, String rightOperand) {\n+        CoreFunctionType type = CoreFunctionType.getByName(expr.getOperator());\n+        switch (type) {\n+            case IS_NULL:\n+                return leftOperand + \" IS NULL \";\n+            case NOT_NULL:\n+                return leftOperand + \" IS NOT NULL \";\n+            case IN:\n+                return leftOperand + \" IN (\" + rightOperand + \") \";\n+            case NOT_IN:\n+                return leftOperand + \" NOT IN (\" + rightOperand + \") \";\n+            case EQUALS_TO:\n+                return leftOperand + \" = \" + rightOperand + \" \";\n+            case NOT_EQUALS_TO:\n+                return leftOperand + \" <> \" + rightOperand + \" \";\n+            case LIKE_TO:\n+                return leftOperand + \" LIKE \" + rightOperand + \" \";\n+            default:\n+                throw new UnsupportedOperationException(\"Queryparam: \" + expr + \" not supported\");\n+        }\n+    }\n+    private ProcessInstanceWithVarsDesc toProcessInstanceWithVarsDesc(Object[] row) {\n+        return new ProcessInstanceWithVarsDesc(((Number) row[0]).longValue(),\n+                                               (String) row[1],\n+                                               (String) row[2],\n+                                               (String) row[3],\n+                                               ((Number) row[4]).intValue(),\n+                                               (String) row[5],\n+                                               (Date) row[6],\n+                                               (String) row[7],\n+                                               (String) row[8]);\n+    }\n+\n+    private void addPagination(Query query, QueryContext context) {\n+        if (context.getCount() > 0) {\n+            query.setFirstResult(context.getOffset());\n+            query.setMaxResults(context.getCount());\n+        }\n+    }\n+\n+    public List<org.jbpm.services.api.model.UserTaskInstanceWithPotOwnerDesc> queryUserTasksByVariables(List<QueryParam> attributes,\n+                                                                                                        List<QueryParam> variables,\n+                                                                                                        List<QueryParam> processVariables,\n+                                                                                                        List<String> owners,\n+                                                                                                        int processType,\n+                                                                                                        String varPrefix,\n+                                                                                                        QueryContext queryContext) {\n+        EntityManager entityManager = emf.createEntityManager();\n+        StringBuilder globalWhere = new StringBuilder();\n+        StringBuilder derivedTables = new StringBuilder();\n+        if (!variables.isEmpty()) {\n+            List<String> conditions = new ArrayList<>();\n+            variables.stream().forEach((expr) -> conditions.add(\"(name = :V_NAME_\" + expr.getColumn() + \" AND \" + computeExpression(expr, \"value\", \":V_VALUE_\" + expr.getColumn()) + \")\\n\"));\n+            String where = String.join(\" OR \", conditions);\n+            derivedTables.append(\"INNER JOIN (\\n\" +\n+                                 \"SELECT taskId \\n\" +\n+                                 \"FROM TaskVariableImpl \\n\" +\n+                                 \"WHERE type = 0 AND (\" + where + \")\\n\" +", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f04f50355ec285330b3467d42754a036a04b1db3"}, "originalPosition": 196}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODI5Mzg1Nw==", "bodyText": "a list can contain duplicate values. It is not supposed to happen but it could and if so, this query wouldn't work - wdyt?", "url": "https://github.com/kiegroup/jbpm/pull/1615#discussion_r408293857", "createdAt": "2020-04-14T17:01:06Z", "author": {"login": "afalhambra"}, "path": "jbpm-services/jbpm-kie-services/src/main/java/org/jbpm/kie/services/impl/AbstractAdvanceRuntimeDataServiceImpl.java", "diffHunk": "@@ -0,0 +1,346 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.jbpm.kie.services.impl;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import javax.persistence.EntityManager;\n+import javax.persistence.EntityManagerFactory;\n+import javax.persistence.Query;\n+\n+import org.dashbuilder.dataset.filter.CoreFunctionType;\n+import org.jbpm.kie.services.impl.model.ProcessInstanceWithVarsDesc;\n+import org.jbpm.kie.services.impl.model.UserTaskInstanceWithPotOwnerDesc;\n+import org.jbpm.services.api.query.model.QueryParam;\n+import org.jbpm.shared.services.impl.QueryManager;\n+import org.jbpm.shared.services.impl.TransactionalCommandService;\n+import org.jbpm.shared.services.impl.commands.QueryNameCommand;\n+import org.kie.api.runtime.query.QueryContext;\n+\n+import static java.util.Collections.singletonMap;\n+\n+public abstract class AbstractAdvanceRuntimeDataServiceImpl {\n+\n+    private static final String ID_LIST = \"idList\";\n+    private EntityManagerFactory emf;\n+    private TransactionalCommandService commandService;\n+\n+    public AbstractAdvanceRuntimeDataServiceImpl() {\n+        QueryManager.get().addNamedQueries(\"META-INF/Servicesorm.xml\");\n+    }\n+    public void setCommandService(TransactionalCommandService commandService) {\n+        this.commandService = commandService;\n+    }\n+\n+    public void setEmf(EntityManagerFactory emf) {\n+        this.emf = emf;\n+    }\n+\n+\n+    public List<org.jbpm.services.api.model.ProcessInstanceWithVarsDesc> queryProcessByVariables(List<QueryParam> attributes,\n+                                                                                                 List<QueryParam> variables,\n+                                                                                                 int processType,\n+                                                                                                 String varPrefix,\n+                                                                                                 QueryContext queryContext) {\n+        EntityManager entityManager = emf.createEntityManager();\n+\n+        // first step is to filter the data creating a derived tables and pivoting var - rows to columns (only the variables we are interested to filter)\n+        StringBuilder derivedTables = new StringBuilder();\n+        if (!variables.isEmpty()) {\n+            List<String> conditions = new ArrayList<>();\n+            variables.stream().forEach(expr -> conditions.add(\"(A1.variableId = :NAME_\" + expr.getColumn() + \" AND \" + computeExpression(expr, \"A1.value\", \":VALUE_\" + expr.getColumn()) + \")\\n\"));\n+            String where = String.join(\" OR \", conditions);\n+            derivedTables.append(\"INNER JOIN (\" +\n+                                 \"SELECT A1.processInstanceId \\n\" +\n+                                 \"FROM VariableInstanceLog A1 \\n\" +\n+                                 \"LEFT JOIN VariableInstanceLog A2 ON A1.processId = A2.processId AND A1.processInstanceId = A2.processInstanceId AND A1.variableInstanceId = A2.variableInstanceId AND A2.id > A1.id  \\n\" +\n+                                 \"WHERE A2.id IS NULL AND (\" + where + \") \" +\n+                                 \"GROUP BY A1.processInstanceId \" +\n+                                 \"HAVING COUNT(*) = :NUMBER_OF_VARS \" +", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f04f50355ec285330b3467d42754a036a04b1db3"}, "originalPosition": 78}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODI5NDc3MA==", "bodyText": "I think it would nice to have some of these important method with some java documentation. wdyt?", "url": "https://github.com/kiegroup/jbpm/pull/1615#discussion_r408294770", "createdAt": "2020-04-14T17:02:33Z", "author": {"login": "afalhambra"}, "path": "jbpm-services/jbpm-kie-services/src/main/java/org/jbpm/kie/services/impl/AbstractAdvanceRuntimeDataServiceImpl.java", "diffHunk": "@@ -0,0 +1,346 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.jbpm.kie.services.impl;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import javax.persistence.EntityManager;\n+import javax.persistence.EntityManagerFactory;\n+import javax.persistence.Query;\n+\n+import org.dashbuilder.dataset.filter.CoreFunctionType;\n+import org.jbpm.kie.services.impl.model.ProcessInstanceWithVarsDesc;\n+import org.jbpm.kie.services.impl.model.UserTaskInstanceWithPotOwnerDesc;\n+import org.jbpm.services.api.query.model.QueryParam;\n+import org.jbpm.shared.services.impl.QueryManager;\n+import org.jbpm.shared.services.impl.TransactionalCommandService;\n+import org.jbpm.shared.services.impl.commands.QueryNameCommand;\n+import org.kie.api.runtime.query.QueryContext;\n+\n+import static java.util.Collections.singletonMap;\n+\n+public abstract class AbstractAdvanceRuntimeDataServiceImpl {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f04f50355ec285330b3467d42754a036a04b1db3"}, "originalPosition": 41}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODYyNzQ5NA==", "bodyText": "Why \"owners\" is only matching those with \"IN\" statement condition? Shouldn't be like the others? I mean, should it not depend on the operator condition like \"EQUALS\", \"NOT_EQUALS\", etc? I know it's in the jira ticket, but not really sure why this different behavior for \"owners\"?", "url": "https://github.com/kiegroup/jbpm/pull/1615#discussion_r408627494", "createdAt": "2020-04-15T07:12:55Z", "author": {"login": "afalhambra"}, "path": "jbpm-services/jbpm-kie-services/src/main/java/org/jbpm/kie/services/impl/AbstractAdvanceRuntimeDataServiceImpl.java", "diffHunk": "@@ -0,0 +1,346 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.jbpm.kie.services.impl;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import javax.persistence.EntityManager;\n+import javax.persistence.EntityManagerFactory;\n+import javax.persistence.Query;\n+\n+import org.dashbuilder.dataset.filter.CoreFunctionType;\n+import org.jbpm.kie.services.impl.model.ProcessInstanceWithVarsDesc;\n+import org.jbpm.kie.services.impl.model.UserTaskInstanceWithPotOwnerDesc;\n+import org.jbpm.services.api.query.model.QueryParam;\n+import org.jbpm.shared.services.impl.QueryManager;\n+import org.jbpm.shared.services.impl.TransactionalCommandService;\n+import org.jbpm.shared.services.impl.commands.QueryNameCommand;\n+import org.kie.api.runtime.query.QueryContext;\n+\n+import static java.util.Collections.singletonMap;\n+\n+public abstract class AbstractAdvanceRuntimeDataServiceImpl {\n+\n+    private static final String ID_LIST = \"idList\";\n+    private EntityManagerFactory emf;\n+    private TransactionalCommandService commandService;\n+\n+    public AbstractAdvanceRuntimeDataServiceImpl() {\n+        QueryManager.get().addNamedQueries(\"META-INF/Servicesorm.xml\");\n+    }\n+    public void setCommandService(TransactionalCommandService commandService) {\n+        this.commandService = commandService;\n+    }\n+\n+    public void setEmf(EntityManagerFactory emf) {\n+        this.emf = emf;\n+    }\n+\n+\n+    public List<org.jbpm.services.api.model.ProcessInstanceWithVarsDesc> queryProcessByVariables(List<QueryParam> attributes,\n+                                                                                                 List<QueryParam> variables,\n+                                                                                                 int processType,\n+                                                                                                 String varPrefix,\n+                                                                                                 QueryContext queryContext) {\n+        EntityManager entityManager = emf.createEntityManager();\n+\n+        // first step is to filter the data creating a derived tables and pivoting var - rows to columns (only the variables we are interested to filter)\n+        StringBuilder derivedTables = new StringBuilder();\n+        if (!variables.isEmpty()) {\n+            List<String> conditions = new ArrayList<>();\n+            variables.stream().forEach(expr -> conditions.add(\"(A1.variableId = :NAME_\" + expr.getColumn() + \" AND \" + computeExpression(expr, \"A1.value\", \":VALUE_\" + expr.getColumn()) + \")\\n\"));\n+            String where = String.join(\" OR \", conditions);\n+            derivedTables.append(\"INNER JOIN (\" +\n+                                 \"SELECT A1.processInstanceId \\n\" +\n+                                 \"FROM VariableInstanceLog A1 \\n\" +\n+                                 \"LEFT JOIN VariableInstanceLog A2 ON A1.processId = A2.processId AND A1.processInstanceId = A2.processInstanceId AND A1.variableInstanceId = A2.variableInstanceId AND A2.id > A1.id  \\n\" +\n+                                 \"WHERE A2.id IS NULL AND (\" + where + \") \" +\n+                                 \"GROUP BY A1.processInstanceId \" +\n+                                 \"HAVING COUNT(*) = :NUMBER_OF_VARS \" +\n+                                 \") TABLE_VAR ON TABLE_VAR.processInstanceId = pil.processInstanceId \\n\");\n+        }\n+\n+        StringBuilder globalWhere = new StringBuilder();\n+        attributes.stream().forEach(expr -> globalWhere.append(\" AND \" + computeExpression(expr, expr.getColumn(), \":ATTR_\" + expr.getColumn())));\n+\n+        String procSQLString =\n+                \" SELECT DISTINCT pil.processInstanceId \" +\n+                               \" FROM ProcessInstanceLog pil \\n \" +\n+                               derivedTables +\n+                               \" WHERE pil.processType = :processType \" + globalWhere +\n+                               \" ORDER BY pil.processInstanceId ASC \";\n+\n+        Query query = entityManager.createNativeQuery(procSQLString);\n+        variables.stream().forEach(var -> query.setParameter(\"NAME_\" + var.getColumn(), varPrefix + var.getColumn()));\n+        variables.stream().filter(e -> e.getObjectValue() != null).forEach(var -> query.setParameter(\"VALUE_\" + var.getColumn(), var.getObjectValue()));\n+        attributes.stream().filter(e -> e.getObjectValue() != null).forEach((entry) -> query.setParameter(\"ATTR_\" + entry.getColumn(), entry.getObjectValue()));\n+\n+        if (!variables.isEmpty()) {\n+            query.setParameter(\"NUMBER_OF_VARS\", variables.size());\n+        }\n+        query.setParameter(\"processType\", processType);\n+\n+        addPagination(query, queryContext);\n+        List<Number> ids = query.getResultList();\n+        if (ids.isEmpty()) {\n+            return Collections.emptyList();\n+        }\n+\n+        // now we get the information\n+\n+        List<Object[]> procRows = commandService.execute(new QueryNameCommand<List<Object[]>>(\"GetProcessInstanceByIdList\", singletonMap(ID_LIST, ids)));\n+        List<Object[]> varRows = commandService.execute(new QueryNameCommand<List<Object[]>>(\"GetVariablesByProcessInstanceIdList\", singletonMap(ID_LIST, ids)));\n+\n+        int currentVarIdx = 0;\n+        List<org.jbpm.services.api.model.ProcessInstanceWithVarsDesc> data = new ArrayList<>();\n+        for (Object[] row : procRows) {\n+            ProcessInstanceWithVarsDesc pwv = toProcessInstanceWithVarsDesc(row);\n+\n+            Map<String, Object> vars = new HashMap<>();\n+            pwv.setVariables(vars);\n+\n+            Map<String, Object> extra = new HashMap<>();\n+            pwv.setExtraData(extra);\n+            while (currentVarIdx < varRows.size() && row[0].equals(varRows.get(currentVarIdx)[0])) {\n+                String name = (String) varRows.get(currentVarIdx)[1];\n+                if (!varPrefix.isEmpty() && name.startsWith(varPrefix)) {\n+                    extra.put(name.substring(varPrefix.length()), varRows.get(currentVarIdx)[2]);\n+                } else {\n+                    vars.put(name, varRows.get(currentVarIdx)[2]);\n+                }\n+                currentVarIdx++;\n+            }\n+            data.add(pwv);\n+        }\n+\n+        entityManager.close();\n+        return data;\n+    }\n+\n+    private String computeExpression(QueryParam expr, String leftOperand, String rightOperand) {\n+        CoreFunctionType type = CoreFunctionType.getByName(expr.getOperator());\n+        switch (type) {\n+            case IS_NULL:\n+                return leftOperand + \" IS NULL \";\n+            case NOT_NULL:\n+                return leftOperand + \" IS NOT NULL \";\n+            case IN:\n+                return leftOperand + \" IN (\" + rightOperand + \") \";\n+            case NOT_IN:\n+                return leftOperand + \" NOT IN (\" + rightOperand + \") \";\n+            case EQUALS_TO:\n+                return leftOperand + \" = \" + rightOperand + \" \";\n+            case NOT_EQUALS_TO:\n+                return leftOperand + \" <> \" + rightOperand + \" \";\n+            case LIKE_TO:\n+                return leftOperand + \" LIKE \" + rightOperand + \" \";\n+            default:\n+                throw new UnsupportedOperationException(\"Queryparam: \" + expr + \" not supported\");\n+        }\n+    }\n+    private ProcessInstanceWithVarsDesc toProcessInstanceWithVarsDesc(Object[] row) {\n+        return new ProcessInstanceWithVarsDesc(((Number) row[0]).longValue(),\n+                                               (String) row[1],\n+                                               (String) row[2],\n+                                               (String) row[3],\n+                                               ((Number) row[4]).intValue(),\n+                                               (String) row[5],\n+                                               (Date) row[6],\n+                                               (String) row[7],\n+                                               (String) row[8]);\n+    }\n+\n+    private void addPagination(Query query, QueryContext context) {\n+        if (context.getCount() > 0) {\n+            query.setFirstResult(context.getOffset());\n+            query.setMaxResults(context.getCount());\n+        }\n+    }\n+\n+    public List<org.jbpm.services.api.model.UserTaskInstanceWithPotOwnerDesc> queryUserTasksByVariables(List<QueryParam> attributes,\n+                                                                                                        List<QueryParam> variables,\n+                                                                                                        List<QueryParam> processVariables,\n+                                                                                                        List<String> owners,\n+                                                                                                        int processType,\n+                                                                                                        String varPrefix,\n+                                                                                                        QueryContext queryContext) {\n+        EntityManager entityManager = emf.createEntityManager();\n+        StringBuilder globalWhere = new StringBuilder();\n+        StringBuilder derivedTables = new StringBuilder();\n+        if (!variables.isEmpty()) {\n+            List<String> conditions = new ArrayList<>();\n+            variables.stream().forEach((expr) -> conditions.add(\"(name = :V_NAME_\" + expr.getColumn() + \" AND \" + computeExpression(expr, \"value\", \":V_VALUE_\" + expr.getColumn()) + \")\\n\"));\n+            String where = String.join(\" OR \", conditions);\n+            derivedTables.append(\"INNER JOIN (\\n\" +\n+                                 \"SELECT taskId \\n\" +\n+                                 \"FROM TaskVariableImpl \\n\" +\n+                                 \"WHERE type = 0 AND (\" + where + \")\\n\" +\n+                                 \"GROUP BY taskId \\n\" +\n+                                 \"HAVING COUNT(*) = :NUMBER_OF_TASKVARS \\n\" +\n+                                 \") TABLE_TASK_VAR ON TABLE_TASK_VAR.taskId = task.id  \\n\");\n+        }\n+\n+        if (!processVariables.isEmpty()) {\n+            List<String> conditions = new ArrayList<>();\n+            processVariables.stream().forEach((expr) -> conditions.add(\"(A1.variableId = :P_NAME_\" + expr.getColumn() + \" AND \" + computeExpression(expr, \"A1.value\", \":P_VALUE_\" + expr.getColumn()) + \")\\n\"));\n+            String where = String.join(\" OR \", conditions);\n+            derivedTables.append(\"INNER JOIN (\" +\n+                                 \"SELECT A1.processInstanceId \\n\" +\n+                                 \"FROM VariableInstanceLog A1 \\n\" +\n+                                 \"LEFT JOIN VariableInstanceLog A2 ON A1.processId = A2.processId AND A1.processInstanceId = A2.processInstanceId AND A1.variableInstanceId = A2.variableInstanceId AND A2.id > A1.id  \\n\" +\n+                                 \"WHERE A2.id IS NULL AND (\" + where + \") \" +\n+                                 \"GROUP BY A1.processInstanceId \" +\n+                                 \"HAVING COUNT(*) = :NUMBER_OF_PROCVARS \" +\n+                                 \") TABLE_PROC_VAR ON TABLE_PROC_VAR.processInstanceId = pil.processInstanceId \\n\");\n+        }\n+\n+        if (!owners.isEmpty()) {\n+            derivedTables.append(\"INNER JOIN ( \\n\" +\n+                             \"           SELECT DISTINCT po.task_id \\n\" +\n+                             \"           FROM PeopleAssignments_PotOwners po \\n\" +\n+                             \"           WHERE po.entity_id IN (:owners) \\n\" +", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f04f50355ec285330b3467d42754a036a04b1db3"}, "originalPosition": 220}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODYzNTc4Mw==", "bodyText": "Should we not close entityManager after fetching data in the collectData method?", "url": "https://github.com/kiegroup/jbpm/pull/1615#discussion_r408635783", "createdAt": "2020-04-15T07:29:00Z", "author": {"login": "afalhambra"}, "path": "jbpm-services/jbpm-kie-services/src/main/java/org/jbpm/kie/services/impl/AbstractAdvanceRuntimeDataServiceImpl.java", "diffHunk": "@@ -0,0 +1,346 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.jbpm.kie.services.impl;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import javax.persistence.EntityManager;\n+import javax.persistence.EntityManagerFactory;\n+import javax.persistence.Query;\n+\n+import org.dashbuilder.dataset.filter.CoreFunctionType;\n+import org.jbpm.kie.services.impl.model.ProcessInstanceWithVarsDesc;\n+import org.jbpm.kie.services.impl.model.UserTaskInstanceWithPotOwnerDesc;\n+import org.jbpm.services.api.query.model.QueryParam;\n+import org.jbpm.shared.services.impl.QueryManager;\n+import org.jbpm.shared.services.impl.TransactionalCommandService;\n+import org.jbpm.shared.services.impl.commands.QueryNameCommand;\n+import org.kie.api.runtime.query.QueryContext;\n+\n+import static java.util.Collections.singletonMap;\n+\n+public abstract class AbstractAdvanceRuntimeDataServiceImpl {\n+\n+    private static final String ID_LIST = \"idList\";\n+    private EntityManagerFactory emf;\n+    private TransactionalCommandService commandService;\n+\n+    public AbstractAdvanceRuntimeDataServiceImpl() {\n+        QueryManager.get().addNamedQueries(\"META-INF/Servicesorm.xml\");\n+    }\n+    public void setCommandService(TransactionalCommandService commandService) {\n+        this.commandService = commandService;\n+    }\n+\n+    public void setEmf(EntityManagerFactory emf) {\n+        this.emf = emf;\n+    }\n+\n+\n+    public List<org.jbpm.services.api.model.ProcessInstanceWithVarsDesc> queryProcessByVariables(List<QueryParam> attributes,\n+                                                                                                 List<QueryParam> variables,\n+                                                                                                 int processType,\n+                                                                                                 String varPrefix,\n+                                                                                                 QueryContext queryContext) {\n+        EntityManager entityManager = emf.createEntityManager();\n+\n+        // first step is to filter the data creating a derived tables and pivoting var - rows to columns (only the variables we are interested to filter)\n+        StringBuilder derivedTables = new StringBuilder();\n+        if (!variables.isEmpty()) {\n+            List<String> conditions = new ArrayList<>();\n+            variables.stream().forEach(expr -> conditions.add(\"(A1.variableId = :NAME_\" + expr.getColumn() + \" AND \" + computeExpression(expr, \"A1.value\", \":VALUE_\" + expr.getColumn()) + \")\\n\"));\n+            String where = String.join(\" OR \", conditions);\n+            derivedTables.append(\"INNER JOIN (\" +\n+                                 \"SELECT A1.processInstanceId \\n\" +\n+                                 \"FROM VariableInstanceLog A1 \\n\" +\n+                                 \"LEFT JOIN VariableInstanceLog A2 ON A1.processId = A2.processId AND A1.processInstanceId = A2.processInstanceId AND A1.variableInstanceId = A2.variableInstanceId AND A2.id > A1.id  \\n\" +\n+                                 \"WHERE A2.id IS NULL AND (\" + where + \") \" +\n+                                 \"GROUP BY A1.processInstanceId \" +\n+                                 \"HAVING COUNT(*) = :NUMBER_OF_VARS \" +\n+                                 \") TABLE_VAR ON TABLE_VAR.processInstanceId = pil.processInstanceId \\n\");\n+        }\n+\n+        StringBuilder globalWhere = new StringBuilder();\n+        attributes.stream().forEach(expr -> globalWhere.append(\" AND \" + computeExpression(expr, expr.getColumn(), \":ATTR_\" + expr.getColumn())));\n+\n+        String procSQLString =\n+                \" SELECT DISTINCT pil.processInstanceId \" +\n+                               \" FROM ProcessInstanceLog pil \\n \" +\n+                               derivedTables +\n+                               \" WHERE pil.processType = :processType \" + globalWhere +\n+                               \" ORDER BY pil.processInstanceId ASC \";\n+\n+        Query query = entityManager.createNativeQuery(procSQLString);\n+        variables.stream().forEach(var -> query.setParameter(\"NAME_\" + var.getColumn(), varPrefix + var.getColumn()));\n+        variables.stream().filter(e -> e.getObjectValue() != null).forEach(var -> query.setParameter(\"VALUE_\" + var.getColumn(), var.getObjectValue()));\n+        attributes.stream().filter(e -> e.getObjectValue() != null).forEach((entry) -> query.setParameter(\"ATTR_\" + entry.getColumn(), entry.getObjectValue()));\n+\n+        if (!variables.isEmpty()) {\n+            query.setParameter(\"NUMBER_OF_VARS\", variables.size());\n+        }\n+        query.setParameter(\"processType\", processType);\n+\n+        addPagination(query, queryContext);\n+        List<Number> ids = query.getResultList();\n+        if (ids.isEmpty()) {\n+            return Collections.emptyList();\n+        }\n+\n+        // now we get the information\n+\n+        List<Object[]> procRows = commandService.execute(new QueryNameCommand<List<Object[]>>(\"GetProcessInstanceByIdList\", singletonMap(ID_LIST, ids)));\n+        List<Object[]> varRows = commandService.execute(new QueryNameCommand<List<Object[]>>(\"GetVariablesByProcessInstanceIdList\", singletonMap(ID_LIST, ids)));\n+\n+        int currentVarIdx = 0;\n+        List<org.jbpm.services.api.model.ProcessInstanceWithVarsDesc> data = new ArrayList<>();\n+        for (Object[] row : procRows) {\n+            ProcessInstanceWithVarsDesc pwv = toProcessInstanceWithVarsDesc(row);\n+\n+            Map<String, Object> vars = new HashMap<>();\n+            pwv.setVariables(vars);\n+\n+            Map<String, Object> extra = new HashMap<>();\n+            pwv.setExtraData(extra);\n+            while (currentVarIdx < varRows.size() && row[0].equals(varRows.get(currentVarIdx)[0])) {\n+                String name = (String) varRows.get(currentVarIdx)[1];\n+                if (!varPrefix.isEmpty() && name.startsWith(varPrefix)) {\n+                    extra.put(name.substring(varPrefix.length()), varRows.get(currentVarIdx)[2]);\n+                } else {\n+                    vars.put(name, varRows.get(currentVarIdx)[2]);\n+                }\n+                currentVarIdx++;\n+            }\n+            data.add(pwv);\n+        }\n+\n+        entityManager.close();\n+        return data;\n+    }\n+\n+    private String computeExpression(QueryParam expr, String leftOperand, String rightOperand) {\n+        CoreFunctionType type = CoreFunctionType.getByName(expr.getOperator());\n+        switch (type) {\n+            case IS_NULL:\n+                return leftOperand + \" IS NULL \";\n+            case NOT_NULL:\n+                return leftOperand + \" IS NOT NULL \";\n+            case IN:\n+                return leftOperand + \" IN (\" + rightOperand + \") \";\n+            case NOT_IN:\n+                return leftOperand + \" NOT IN (\" + rightOperand + \") \";\n+            case EQUALS_TO:\n+                return leftOperand + \" = \" + rightOperand + \" \";\n+            case NOT_EQUALS_TO:\n+                return leftOperand + \" <> \" + rightOperand + \" \";\n+            case LIKE_TO:\n+                return leftOperand + \" LIKE \" + rightOperand + \" \";\n+            default:\n+                throw new UnsupportedOperationException(\"Queryparam: \" + expr + \" not supported\");\n+        }\n+    }\n+    private ProcessInstanceWithVarsDesc toProcessInstanceWithVarsDesc(Object[] row) {\n+        return new ProcessInstanceWithVarsDesc(((Number) row[0]).longValue(),\n+                                               (String) row[1],\n+                                               (String) row[2],\n+                                               (String) row[3],\n+                                               ((Number) row[4]).intValue(),\n+                                               (String) row[5],\n+                                               (Date) row[6],\n+                                               (String) row[7],\n+                                               (String) row[8]);\n+    }\n+\n+    private void addPagination(Query query, QueryContext context) {\n+        if (context.getCount() > 0) {\n+            query.setFirstResult(context.getOffset());\n+            query.setMaxResults(context.getCount());\n+        }\n+    }\n+\n+    public List<org.jbpm.services.api.model.UserTaskInstanceWithPotOwnerDesc> queryUserTasksByVariables(List<QueryParam> attributes,\n+                                                                                                        List<QueryParam> variables,\n+                                                                                                        List<QueryParam> processVariables,\n+                                                                                                        List<String> owners,\n+                                                                                                        int processType,\n+                                                                                                        String varPrefix,\n+                                                                                                        QueryContext queryContext) {\n+        EntityManager entityManager = emf.createEntityManager();\n+        StringBuilder globalWhere = new StringBuilder();\n+        StringBuilder derivedTables = new StringBuilder();\n+        if (!variables.isEmpty()) {\n+            List<String> conditions = new ArrayList<>();\n+            variables.stream().forEach((expr) -> conditions.add(\"(name = :V_NAME_\" + expr.getColumn() + \" AND \" + computeExpression(expr, \"value\", \":V_VALUE_\" + expr.getColumn()) + \")\\n\"));\n+            String where = String.join(\" OR \", conditions);\n+            derivedTables.append(\"INNER JOIN (\\n\" +\n+                                 \"SELECT taskId \\n\" +\n+                                 \"FROM TaskVariableImpl \\n\" +\n+                                 \"WHERE type = 0 AND (\" + where + \")\\n\" +\n+                                 \"GROUP BY taskId \\n\" +\n+                                 \"HAVING COUNT(*) = :NUMBER_OF_TASKVARS \\n\" +\n+                                 \") TABLE_TASK_VAR ON TABLE_TASK_VAR.taskId = task.id  \\n\");\n+        }\n+\n+        if (!processVariables.isEmpty()) {\n+            List<String> conditions = new ArrayList<>();\n+            processVariables.stream().forEach((expr) -> conditions.add(\"(A1.variableId = :P_NAME_\" + expr.getColumn() + \" AND \" + computeExpression(expr, \"A1.value\", \":P_VALUE_\" + expr.getColumn()) + \")\\n\"));\n+            String where = String.join(\" OR \", conditions);\n+            derivedTables.append(\"INNER JOIN (\" +\n+                                 \"SELECT A1.processInstanceId \\n\" +\n+                                 \"FROM VariableInstanceLog A1 \\n\" +\n+                                 \"LEFT JOIN VariableInstanceLog A2 ON A1.processId = A2.processId AND A1.processInstanceId = A2.processInstanceId AND A1.variableInstanceId = A2.variableInstanceId AND A2.id > A1.id  \\n\" +\n+                                 \"WHERE A2.id IS NULL AND (\" + where + \") \" +\n+                                 \"GROUP BY A1.processInstanceId \" +\n+                                 \"HAVING COUNT(*) = :NUMBER_OF_PROCVARS \" +\n+                                 \") TABLE_PROC_VAR ON TABLE_PROC_VAR.processInstanceId = pil.processInstanceId \\n\");\n+        }\n+\n+        if (!owners.isEmpty()) {\n+            derivedTables.append(\"INNER JOIN ( \\n\" +\n+                             \"           SELECT DISTINCT po.task_id \\n\" +\n+                             \"           FROM PeopleAssignments_PotOwners po \\n\" +\n+                             \"           WHERE po.entity_id IN (:owners) \\n\" +\n+                             \"           GROUP BY po.task_id \\n\" +\n+                             \"           HAVING COUNT(po.entity_id) = :num_owners \\n\" +\n+                                 \") pot ON pot.task_id = task.id \");\n+        }\n+\n+        attributes.stream().forEach((expr) -> globalWhere.append(\" AND \" + computeExpression(expr, expr.getColumn(), \":ATTR_\" + expr.getColumn())));\n+\n+        String procSQLString = \"SELECT DISTINCT task.id \" +\n+                               \" FROM Task task \" +\n+                               \" INNER JOIN ProcessInstanceLog pil ON pil.processInstanceId = task.processInstanceId \\n \" +\n+                               derivedTables +\n+                               \" WHERE  pil.processType = :processType \" + globalWhere +\n+                               \" ORDER BY task.id ASC \";\n+\n+        Query query = entityManager.createNativeQuery(procSQLString);\n+        variables.stream().forEach(var -> query.setParameter(\"V_NAME_\" + var.getColumn(), var.getColumn()));\n+        variables.stream().filter(e -> e.getObjectValue() != null).forEach((var) -> query.setParameter(\"V_VALUE_\" + var.getColumn(), var.getObjectValue()));\n+\n+        if (!variables.isEmpty()) {\n+            query.setParameter(\"NUMBER_OF_TASKVARS\", variables.size());\n+        }\n+\n+        processVariables.stream().forEach(var -> query.setParameter(\"P_NAME_\" + var.getColumn(), varPrefix + var.getColumn()));\n+        processVariables.stream().filter(e -> e.getObjectValue() != null).forEach((var) -> query.setParameter(\"P_VALUE_\" + var.getColumn(), var.getObjectValue()));\n+\n+        if (!processVariables.isEmpty()) {\n+            query.setParameter(\"NUMBER_OF_PROCVARS\", processVariables.size());\n+        }\n+\n+        if (!owners.isEmpty()) {\n+            query.setParameter(\"num_owners\", owners.size());\n+            query.setParameter(\"owners\", owners);\n+        }\n+\n+        attributes.stream().filter(e -> e.getObjectValue() != null).forEach(entry -> query.setParameter(\"ATTR_\" + entry.getColumn(), entry.getObjectValue()));\n+        query.setParameter(\"processType\", processType);\n+\n+        addPagination(query, queryContext);\n+\n+        List<Number> ids = query.getResultList();\n+        if (ids.isEmpty()) {\n+            return Collections.emptyList();\n+        }\n+\n+        entityManager.close();\n+        return collectData(ids, varPrefix);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f04f50355ec285330b3467d42754a036a04b1db3"}, "originalPosition": 266}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODYzODM5Mw==", "bodyText": "Would it not be better to use TaskVariable.VariableType.INPUT here instead of \"0\"?", "url": "https://github.com/kiegroup/jbpm/pull/1615#discussion_r408638393", "createdAt": "2020-04-15T07:33:46Z", "author": {"login": "afalhambra"}, "path": "jbpm-services/jbpm-kie-services/src/main/java/org/jbpm/kie/services/impl/AbstractAdvanceRuntimeDataServiceImpl.java", "diffHunk": "@@ -0,0 +1,346 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.jbpm.kie.services.impl;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import javax.persistence.EntityManager;\n+import javax.persistence.EntityManagerFactory;\n+import javax.persistence.Query;\n+\n+import org.dashbuilder.dataset.filter.CoreFunctionType;\n+import org.jbpm.kie.services.impl.model.ProcessInstanceWithVarsDesc;\n+import org.jbpm.kie.services.impl.model.UserTaskInstanceWithPotOwnerDesc;\n+import org.jbpm.services.api.query.model.QueryParam;\n+import org.jbpm.shared.services.impl.QueryManager;\n+import org.jbpm.shared.services.impl.TransactionalCommandService;\n+import org.jbpm.shared.services.impl.commands.QueryNameCommand;\n+import org.kie.api.runtime.query.QueryContext;\n+\n+import static java.util.Collections.singletonMap;\n+\n+public abstract class AbstractAdvanceRuntimeDataServiceImpl {\n+\n+    private static final String ID_LIST = \"idList\";\n+    private EntityManagerFactory emf;\n+    private TransactionalCommandService commandService;\n+\n+    public AbstractAdvanceRuntimeDataServiceImpl() {\n+        QueryManager.get().addNamedQueries(\"META-INF/Servicesorm.xml\");\n+    }\n+    public void setCommandService(TransactionalCommandService commandService) {\n+        this.commandService = commandService;\n+    }\n+\n+    public void setEmf(EntityManagerFactory emf) {\n+        this.emf = emf;\n+    }\n+\n+\n+    public List<org.jbpm.services.api.model.ProcessInstanceWithVarsDesc> queryProcessByVariables(List<QueryParam> attributes,\n+                                                                                                 List<QueryParam> variables,\n+                                                                                                 int processType,\n+                                                                                                 String varPrefix,\n+                                                                                                 QueryContext queryContext) {\n+        EntityManager entityManager = emf.createEntityManager();\n+\n+        // first step is to filter the data creating a derived tables and pivoting var - rows to columns (only the variables we are interested to filter)\n+        StringBuilder derivedTables = new StringBuilder();\n+        if (!variables.isEmpty()) {\n+            List<String> conditions = new ArrayList<>();\n+            variables.stream().forEach(expr -> conditions.add(\"(A1.variableId = :NAME_\" + expr.getColumn() + \" AND \" + computeExpression(expr, \"A1.value\", \":VALUE_\" + expr.getColumn()) + \")\\n\"));\n+            String where = String.join(\" OR \", conditions);\n+            derivedTables.append(\"INNER JOIN (\" +\n+                                 \"SELECT A1.processInstanceId \\n\" +\n+                                 \"FROM VariableInstanceLog A1 \\n\" +\n+                                 \"LEFT JOIN VariableInstanceLog A2 ON A1.processId = A2.processId AND A1.processInstanceId = A2.processInstanceId AND A1.variableInstanceId = A2.variableInstanceId AND A2.id > A1.id  \\n\" +\n+                                 \"WHERE A2.id IS NULL AND (\" + where + \") \" +\n+                                 \"GROUP BY A1.processInstanceId \" +\n+                                 \"HAVING COUNT(*) = :NUMBER_OF_VARS \" +\n+                                 \") TABLE_VAR ON TABLE_VAR.processInstanceId = pil.processInstanceId \\n\");\n+        }\n+\n+        StringBuilder globalWhere = new StringBuilder();\n+        attributes.stream().forEach(expr -> globalWhere.append(\" AND \" + computeExpression(expr, expr.getColumn(), \":ATTR_\" + expr.getColumn())));\n+\n+        String procSQLString =\n+                \" SELECT DISTINCT pil.processInstanceId \" +\n+                               \" FROM ProcessInstanceLog pil \\n \" +\n+                               derivedTables +\n+                               \" WHERE pil.processType = :processType \" + globalWhere +\n+                               \" ORDER BY pil.processInstanceId ASC \";\n+\n+        Query query = entityManager.createNativeQuery(procSQLString);\n+        variables.stream().forEach(var -> query.setParameter(\"NAME_\" + var.getColumn(), varPrefix + var.getColumn()));\n+        variables.stream().filter(e -> e.getObjectValue() != null).forEach(var -> query.setParameter(\"VALUE_\" + var.getColumn(), var.getObjectValue()));\n+        attributes.stream().filter(e -> e.getObjectValue() != null).forEach((entry) -> query.setParameter(\"ATTR_\" + entry.getColumn(), entry.getObjectValue()));\n+\n+        if (!variables.isEmpty()) {\n+            query.setParameter(\"NUMBER_OF_VARS\", variables.size());\n+        }\n+        query.setParameter(\"processType\", processType);\n+\n+        addPagination(query, queryContext);\n+        List<Number> ids = query.getResultList();\n+        if (ids.isEmpty()) {\n+            return Collections.emptyList();\n+        }\n+\n+        // now we get the information\n+\n+        List<Object[]> procRows = commandService.execute(new QueryNameCommand<List<Object[]>>(\"GetProcessInstanceByIdList\", singletonMap(ID_LIST, ids)));\n+        List<Object[]> varRows = commandService.execute(new QueryNameCommand<List<Object[]>>(\"GetVariablesByProcessInstanceIdList\", singletonMap(ID_LIST, ids)));\n+\n+        int currentVarIdx = 0;\n+        List<org.jbpm.services.api.model.ProcessInstanceWithVarsDesc> data = new ArrayList<>();\n+        for (Object[] row : procRows) {\n+            ProcessInstanceWithVarsDesc pwv = toProcessInstanceWithVarsDesc(row);\n+\n+            Map<String, Object> vars = new HashMap<>();\n+            pwv.setVariables(vars);\n+\n+            Map<String, Object> extra = new HashMap<>();\n+            pwv.setExtraData(extra);\n+            while (currentVarIdx < varRows.size() && row[0].equals(varRows.get(currentVarIdx)[0])) {\n+                String name = (String) varRows.get(currentVarIdx)[1];\n+                if (!varPrefix.isEmpty() && name.startsWith(varPrefix)) {\n+                    extra.put(name.substring(varPrefix.length()), varRows.get(currentVarIdx)[2]);\n+                } else {\n+                    vars.put(name, varRows.get(currentVarIdx)[2]);\n+                }\n+                currentVarIdx++;\n+            }\n+            data.add(pwv);\n+        }\n+\n+        entityManager.close();\n+        return data;\n+    }\n+\n+    private String computeExpression(QueryParam expr, String leftOperand, String rightOperand) {\n+        CoreFunctionType type = CoreFunctionType.getByName(expr.getOperator());\n+        switch (type) {\n+            case IS_NULL:\n+                return leftOperand + \" IS NULL \";\n+            case NOT_NULL:\n+                return leftOperand + \" IS NOT NULL \";\n+            case IN:\n+                return leftOperand + \" IN (\" + rightOperand + \") \";\n+            case NOT_IN:\n+                return leftOperand + \" NOT IN (\" + rightOperand + \") \";\n+            case EQUALS_TO:\n+                return leftOperand + \" = \" + rightOperand + \" \";\n+            case NOT_EQUALS_TO:\n+                return leftOperand + \" <> \" + rightOperand + \" \";\n+            case LIKE_TO:\n+                return leftOperand + \" LIKE \" + rightOperand + \" \";\n+            default:\n+                throw new UnsupportedOperationException(\"Queryparam: \" + expr + \" not supported\");\n+        }\n+    }\n+    private ProcessInstanceWithVarsDesc toProcessInstanceWithVarsDesc(Object[] row) {\n+        return new ProcessInstanceWithVarsDesc(((Number) row[0]).longValue(),\n+                                               (String) row[1],\n+                                               (String) row[2],\n+                                               (String) row[3],\n+                                               ((Number) row[4]).intValue(),\n+                                               (String) row[5],\n+                                               (Date) row[6],\n+                                               (String) row[7],\n+                                               (String) row[8]);\n+    }\n+\n+    private void addPagination(Query query, QueryContext context) {\n+        if (context.getCount() > 0) {\n+            query.setFirstResult(context.getOffset());\n+            query.setMaxResults(context.getCount());\n+        }\n+    }\n+\n+    public List<org.jbpm.services.api.model.UserTaskInstanceWithPotOwnerDesc> queryUserTasksByVariables(List<QueryParam> attributes,\n+                                                                                                        List<QueryParam> variables,\n+                                                                                                        List<QueryParam> processVariables,\n+                                                                                                        List<String> owners,\n+                                                                                                        int processType,\n+                                                                                                        String varPrefix,\n+                                                                                                        QueryContext queryContext) {\n+        EntityManager entityManager = emf.createEntityManager();\n+        StringBuilder globalWhere = new StringBuilder();\n+        StringBuilder derivedTables = new StringBuilder();\n+        if (!variables.isEmpty()) {\n+            List<String> conditions = new ArrayList<>();\n+            variables.stream().forEach((expr) -> conditions.add(\"(name = :V_NAME_\" + expr.getColumn() + \" AND \" + computeExpression(expr, \"value\", \":V_VALUE_\" + expr.getColumn()) + \")\\n\"));\n+            String where = String.join(\" OR \", conditions);\n+            derivedTables.append(\"INNER JOIN (\\n\" +\n+                                 \"SELECT taskId \\n\" +\n+                                 \"FROM TaskVariableImpl \\n\" +\n+                                 \"WHERE type = 0 AND (\" + where + \")\\n\" +\n+                                 \"GROUP BY taskId \\n\" +\n+                                 \"HAVING COUNT(*) = :NUMBER_OF_TASKVARS \\n\" +\n+                                 \") TABLE_TASK_VAR ON TABLE_TASK_VAR.taskId = task.id  \\n\");\n+        }\n+\n+        if (!processVariables.isEmpty()) {\n+            List<String> conditions = new ArrayList<>();\n+            processVariables.stream().forEach((expr) -> conditions.add(\"(A1.variableId = :P_NAME_\" + expr.getColumn() + \" AND \" + computeExpression(expr, \"A1.value\", \":P_VALUE_\" + expr.getColumn()) + \")\\n\"));\n+            String where = String.join(\" OR \", conditions);\n+            derivedTables.append(\"INNER JOIN (\" +\n+                                 \"SELECT A1.processInstanceId \\n\" +\n+                                 \"FROM VariableInstanceLog A1 \\n\" +\n+                                 \"LEFT JOIN VariableInstanceLog A2 ON A1.processId = A2.processId AND A1.processInstanceId = A2.processInstanceId AND A1.variableInstanceId = A2.variableInstanceId AND A2.id > A1.id  \\n\" +\n+                                 \"WHERE A2.id IS NULL AND (\" + where + \") \" +\n+                                 \"GROUP BY A1.processInstanceId \" +\n+                                 \"HAVING COUNT(*) = :NUMBER_OF_PROCVARS \" +\n+                                 \") TABLE_PROC_VAR ON TABLE_PROC_VAR.processInstanceId = pil.processInstanceId \\n\");\n+        }\n+\n+        if (!owners.isEmpty()) {\n+            derivedTables.append(\"INNER JOIN ( \\n\" +\n+                             \"           SELECT DISTINCT po.task_id \\n\" +\n+                             \"           FROM PeopleAssignments_PotOwners po \\n\" +\n+                             \"           WHERE po.entity_id IN (:owners) \\n\" +\n+                             \"           GROUP BY po.task_id \\n\" +\n+                             \"           HAVING COUNT(po.entity_id) = :num_owners \\n\" +\n+                                 \") pot ON pot.task_id = task.id \");\n+        }\n+\n+        attributes.stream().forEach((expr) -> globalWhere.append(\" AND \" + computeExpression(expr, expr.getColumn(), \":ATTR_\" + expr.getColumn())));\n+\n+        String procSQLString = \"SELECT DISTINCT task.id \" +\n+                               \" FROM Task task \" +\n+                               \" INNER JOIN ProcessInstanceLog pil ON pil.processInstanceId = task.processInstanceId \\n \" +\n+                               derivedTables +\n+                               \" WHERE  pil.processType = :processType \" + globalWhere +\n+                               \" ORDER BY task.id ASC \";\n+\n+        Query query = entityManager.createNativeQuery(procSQLString);\n+        variables.stream().forEach(var -> query.setParameter(\"V_NAME_\" + var.getColumn(), var.getColumn()));\n+        variables.stream().filter(e -> e.getObjectValue() != null).forEach((var) -> query.setParameter(\"V_VALUE_\" + var.getColumn(), var.getObjectValue()));\n+\n+        if (!variables.isEmpty()) {\n+            query.setParameter(\"NUMBER_OF_TASKVARS\", variables.size());\n+        }\n+\n+        processVariables.stream().forEach(var -> query.setParameter(\"P_NAME_\" + var.getColumn(), varPrefix + var.getColumn()));\n+        processVariables.stream().filter(e -> e.getObjectValue() != null).forEach((var) -> query.setParameter(\"P_VALUE_\" + var.getColumn(), var.getObjectValue()));\n+\n+        if (!processVariables.isEmpty()) {\n+            query.setParameter(\"NUMBER_OF_PROCVARS\", processVariables.size());\n+        }\n+\n+        if (!owners.isEmpty()) {\n+            query.setParameter(\"num_owners\", owners.size());\n+            query.setParameter(\"owners\", owners);\n+        }\n+\n+        attributes.stream().filter(e -> e.getObjectValue() != null).forEach(entry -> query.setParameter(\"ATTR_\" + entry.getColumn(), entry.getObjectValue()));\n+        query.setParameter(\"processType\", processType);\n+\n+        addPagination(query, queryContext);\n+\n+        List<Number> ids = query.getResultList();\n+        if (ids.isEmpty()) {\n+            return Collections.emptyList();\n+        }\n+\n+        entityManager.close();\n+        return collectData(ids, varPrefix);\n+\n+    }\n+\n+    private List<org.jbpm.services.api.model.UserTaskInstanceWithPotOwnerDesc> collectData(List<Number> ids, String varPrefix) {\n+        // query data\n+        List<Object[]> taskRows = commandService.execute(new QueryNameCommand<List<Object[]>>(\"GetTasksByIdList\", singletonMap(ID_LIST, ids)));\n+        List<Object[]> varRows = commandService.execute(new QueryNameCommand<List<Object[]>>(\"GetTaskVariablesByTaskIdList\", singletonMap(ID_LIST, ids)));\n+        List<Object[]> potRows = commandService.execute(new QueryNameCommand<List<Object[]>>(\"GetPotentialOwnersByTaskIdList\", singletonMap(ID_LIST, ids)));\n+        List<Object[]> varProcSQLRows = commandService.execute(new QueryNameCommand<List<Object[]>>(\"GetProcessVariablesByTaskIdList\", singletonMap(ID_LIST, ids)));\n+\n+        int currentVarIdx = 0;\n+        int currentPotIdx = 0;\n+        int currentVarProcIdx = 0;\n+        List<org.jbpm.services.api.model.UserTaskInstanceWithPotOwnerDesc> data = new ArrayList<>();\n+        for (Object[] row : taskRows) {\n+            UserTaskInstanceWithPotOwnerDesc pwv = toUserTaskInstanceWithPotOwnerDesc(row);\n+\n+            while (currentVarIdx < varRows.size() && row[0].equals(varRows.get(currentVarIdx)[0])) {\n+                if (((Number) varRows.get(currentVarIdx)[1]).intValue() == 0) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f04f50355ec285330b3467d42754a036a04b1db3"}, "originalPosition": 285}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODY0MjYwOQ==", "bodyText": "Would it make sense to declare translateTable as final?", "url": "https://github.com/kiegroup/jbpm/pull/1615#discussion_r408642609", "createdAt": "2020-04-15T07:41:36Z", "author": {"login": "afalhambra"}, "path": "jbpm-services/jbpm-kie-services/src/main/java/org/jbpm/kie/services/impl/AdvanceRuntimeDataServiceImpl.java", "diffHunk": "@@ -0,0 +1,62 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.jbpm.kie.services.impl;\n+\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.jbpm.services.api.AdvanceRuntimeDataService;\n+import org.jbpm.services.api.query.model.QueryParam;\n+import org.kie.api.runtime.query.QueryContext;\n+\n+import static org.jbpm.workflow.core.WorkflowProcess.PROCESS_TYPE;\n+\n+public class AdvanceRuntimeDataServiceImpl extends AbstractAdvanceRuntimeDataServiceImpl implements AdvanceRuntimeDataService {\n+\n+    private Map<String, String> translateTable = new HashMap<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f04f50355ec285330b3467d42754a036a04b1db3"}, "originalPosition": 31}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODY0NDQzMQ==", "bodyText": "Map is not serializable (same as inputdata and outputdata members). I guess it won't be an issue? It could cause some issues when serializing/deserializing these. Should we use HashMap instead or should we leave it as is? wdyt?", "url": "https://github.com/kiegroup/jbpm/pull/1615#discussion_r408644431", "createdAt": "2020-04-15T07:44:41Z", "author": {"login": "afalhambra"}, "path": "jbpm-services/jbpm-kie-services/src/main/java/org/jbpm/kie/services/impl/model/UserTaskInstanceWithPotOwnerDesc.java", "diffHunk": "@@ -36,6 +36,8 @@\n     private Map<String,Object> inputdata;\n     private Map<String,Object> outputdata;\n     private String processInstanceDescription;\n+    private Map<String, Object> processVariables;\n+    private Map<String, Object> data;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f04f50355ec285330b3467d42754a036a04b1db3"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODY1ODU5NQ==", "bodyText": "ArrayList < String > is redundant. ArrayList<> should be enough", "url": "https://github.com/kiegroup/jbpm/pull/1615#discussion_r408658595", "createdAt": "2020-04-15T08:09:54Z", "author": {"login": "afalhambra"}, "path": "jbpm-services/jbpm-kie-services/src/test/java/org/jbpm/kie/services/test/AdvanceRuntimeDataServiceImplTest.java", "diffHunk": "@@ -0,0 +1,359 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.jbpm.kie.services.test;\n+\n+import java.io.File;\n+import java.io.FileOutputStream;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.drools.compiler.kie.builder.impl.InternalKieModule;\n+import org.jbpm.kie.services.impl.KModuleDeploymentUnit;\n+import org.jbpm.kie.test.util.AbstractKieServicesBaseTest;\n+import org.jbpm.services.api.ProcessInstanceNotFoundException;\n+import org.jbpm.services.api.model.DeploymentUnit;\n+import org.jbpm.services.api.model.ProcessInstanceWithVarsDesc;\n+import org.jbpm.services.api.model.UserTaskInstanceWithPotOwnerDesc;\n+import org.jbpm.services.api.query.model.QueryParam;\n+import org.junit.After;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.Parameterized;\n+import org.junit.runners.Parameterized.Parameters;\n+import org.kie.api.KieServices;\n+import org.kie.api.builder.ReleaseId;\n+import org.kie.api.runtime.process.ProcessInstance;\n+import org.kie.internal.query.QueryContext;\n+import org.kie.scanner.KieMavenRepository;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static java.util.Collections.emptyList;\n+import static org.hamcrest.CoreMatchers.is;\n+import static org.jbpm.services.api.AdvanceRuntimeDataService.PROCESS_ATTR_CORRELATION_KEY;\n+import static org.jbpm.services.api.AdvanceRuntimeDataService.PROCESS_ATTR_DEFINITION_ID;\n+import static org.jbpm.services.api.AdvanceRuntimeDataService.PROCESS_ATTR_DEPLOYMENT_ID;\n+import static org.jbpm.services.api.AdvanceRuntimeDataService.TASK_ATTR_NAME;\n+import static org.jbpm.services.api.AdvanceRuntimeDataService.TASK_ATTR_OWNER;\n+import static org.jbpm.services.api.query.model.QueryParam.equalsTo;\n+import static org.jbpm.services.api.query.model.QueryParam.in;\n+import static org.jbpm.services.api.query.model.QueryParam.isNotNull;\n+import static org.jbpm.services.api.query.model.QueryParam.isNull;\n+import static org.jbpm.services.api.query.model.QueryParam.likeTo;\n+import static org.jbpm.services.api.query.model.QueryParam.list;\n+import static org.jbpm.services.api.query.model.QueryParam.notEqualsTo;\n+import static org.jbpm.services.api.query.model.QueryParam.notIn;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertNull;\n+import static org.kie.scanner.KieMavenRepository.getKieMavenRepository;\n+\n+@RunWith(Parameterized.class)\n+public class AdvanceRuntimeDataServiceImplTest extends AbstractKieServicesBaseTest {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(AdvanceRuntimeDataServiceImplTest.class);\n+\n+    @Parameters(name = \"Pagination {0}\")\n+    public static Iterable<? extends Object> data() {\n+        return Arrays.asList(0, 2);\n+    }\n+\n+    private List<DeploymentUnit> units = new ArrayList<DeploymentUnit>();\n+    protected String correctUser = \"testUser\";\n+    protected String wrongUser = \"wrongUser\";\n+\n+    private List<Long> processIds;\n+    private KModuleDeploymentUnit deploymentUnit = null;\n+    private QueryContext queryContext;\n+\n+    public AdvanceRuntimeDataServiceImplTest(Integer count) {\n+        this.queryContext = new QueryContext(0, count);\n+    }\n+\n+    @Before\n+    public void prepare() {\n+\n+        configureServices();\n+        logger.debug(\"Preparing kjar\");\n+        KieServices ks = KieServices.Factory.get();\n+        ReleaseId releaseId = ks.newReleaseId(GROUP_ID, ARTIFACT_ID, VERSION);\n+        List<String> processes = new ArrayList<String>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f04f50355ec285330b3467d42754a036a04b1db3"}, "originalPosition": 99}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODY1ODk4Mg==", "bodyText": "These members are not used. Please remove them.", "url": "https://github.com/kiegroup/jbpm/pull/1615#discussion_r408658982", "createdAt": "2020-04-15T08:10:38Z", "author": {"login": "afalhambra"}, "path": "jbpm-services/jbpm-kie-services/src/test/java/org/jbpm/kie/services/test/AdvanceRuntimeDataServiceImplTest.java", "diffHunk": "@@ -0,0 +1,359 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.jbpm.kie.services.test;\n+\n+import java.io.File;\n+import java.io.FileOutputStream;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.drools.compiler.kie.builder.impl.InternalKieModule;\n+import org.jbpm.kie.services.impl.KModuleDeploymentUnit;\n+import org.jbpm.kie.test.util.AbstractKieServicesBaseTest;\n+import org.jbpm.services.api.ProcessInstanceNotFoundException;\n+import org.jbpm.services.api.model.DeploymentUnit;\n+import org.jbpm.services.api.model.ProcessInstanceWithVarsDesc;\n+import org.jbpm.services.api.model.UserTaskInstanceWithPotOwnerDesc;\n+import org.jbpm.services.api.query.model.QueryParam;\n+import org.junit.After;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.Parameterized;\n+import org.junit.runners.Parameterized.Parameters;\n+import org.kie.api.KieServices;\n+import org.kie.api.builder.ReleaseId;\n+import org.kie.api.runtime.process.ProcessInstance;\n+import org.kie.internal.query.QueryContext;\n+import org.kie.scanner.KieMavenRepository;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static java.util.Collections.emptyList;\n+import static org.hamcrest.CoreMatchers.is;\n+import static org.jbpm.services.api.AdvanceRuntimeDataService.PROCESS_ATTR_CORRELATION_KEY;\n+import static org.jbpm.services.api.AdvanceRuntimeDataService.PROCESS_ATTR_DEFINITION_ID;\n+import static org.jbpm.services.api.AdvanceRuntimeDataService.PROCESS_ATTR_DEPLOYMENT_ID;\n+import static org.jbpm.services.api.AdvanceRuntimeDataService.TASK_ATTR_NAME;\n+import static org.jbpm.services.api.AdvanceRuntimeDataService.TASK_ATTR_OWNER;\n+import static org.jbpm.services.api.query.model.QueryParam.equalsTo;\n+import static org.jbpm.services.api.query.model.QueryParam.in;\n+import static org.jbpm.services.api.query.model.QueryParam.isNotNull;\n+import static org.jbpm.services.api.query.model.QueryParam.isNull;\n+import static org.jbpm.services.api.query.model.QueryParam.likeTo;\n+import static org.jbpm.services.api.query.model.QueryParam.list;\n+import static org.jbpm.services.api.query.model.QueryParam.notEqualsTo;\n+import static org.jbpm.services.api.query.model.QueryParam.notIn;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertNull;\n+import static org.kie.scanner.KieMavenRepository.getKieMavenRepository;\n+\n+@RunWith(Parameterized.class)\n+public class AdvanceRuntimeDataServiceImplTest extends AbstractKieServicesBaseTest {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(AdvanceRuntimeDataServiceImplTest.class);\n+\n+    @Parameters(name = \"Pagination {0}\")\n+    public static Iterable<? extends Object> data() {\n+        return Arrays.asList(0, 2);\n+    }\n+\n+    private List<DeploymentUnit> units = new ArrayList<DeploymentUnit>();\n+    protected String correctUser = \"testUser\";\n+    protected String wrongUser = \"wrongUser\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f04f50355ec285330b3467d42754a036a04b1db3"}, "originalPosition": 82}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODY1OTMwNw==", "bodyText": "ArrayList < DeploymentUnit > is redundant. ArrayList<> should be enough", "url": "https://github.com/kiegroup/jbpm/pull/1615#discussion_r408659307", "createdAt": "2020-04-15T08:11:17Z", "author": {"login": "afalhambra"}, "path": "jbpm-services/jbpm-kie-services/src/test/java/org/jbpm/kie/services/test/AdvanceRuntimeDataServiceImplTest.java", "diffHunk": "@@ -0,0 +1,359 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.jbpm.kie.services.test;\n+\n+import java.io.File;\n+import java.io.FileOutputStream;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.drools.compiler.kie.builder.impl.InternalKieModule;\n+import org.jbpm.kie.services.impl.KModuleDeploymentUnit;\n+import org.jbpm.kie.test.util.AbstractKieServicesBaseTest;\n+import org.jbpm.services.api.ProcessInstanceNotFoundException;\n+import org.jbpm.services.api.model.DeploymentUnit;\n+import org.jbpm.services.api.model.ProcessInstanceWithVarsDesc;\n+import org.jbpm.services.api.model.UserTaskInstanceWithPotOwnerDesc;\n+import org.jbpm.services.api.query.model.QueryParam;\n+import org.junit.After;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.Parameterized;\n+import org.junit.runners.Parameterized.Parameters;\n+import org.kie.api.KieServices;\n+import org.kie.api.builder.ReleaseId;\n+import org.kie.api.runtime.process.ProcessInstance;\n+import org.kie.internal.query.QueryContext;\n+import org.kie.scanner.KieMavenRepository;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static java.util.Collections.emptyList;\n+import static org.hamcrest.CoreMatchers.is;\n+import static org.jbpm.services.api.AdvanceRuntimeDataService.PROCESS_ATTR_CORRELATION_KEY;\n+import static org.jbpm.services.api.AdvanceRuntimeDataService.PROCESS_ATTR_DEFINITION_ID;\n+import static org.jbpm.services.api.AdvanceRuntimeDataService.PROCESS_ATTR_DEPLOYMENT_ID;\n+import static org.jbpm.services.api.AdvanceRuntimeDataService.TASK_ATTR_NAME;\n+import static org.jbpm.services.api.AdvanceRuntimeDataService.TASK_ATTR_OWNER;\n+import static org.jbpm.services.api.query.model.QueryParam.equalsTo;\n+import static org.jbpm.services.api.query.model.QueryParam.in;\n+import static org.jbpm.services.api.query.model.QueryParam.isNotNull;\n+import static org.jbpm.services.api.query.model.QueryParam.isNull;\n+import static org.jbpm.services.api.query.model.QueryParam.likeTo;\n+import static org.jbpm.services.api.query.model.QueryParam.list;\n+import static org.jbpm.services.api.query.model.QueryParam.notEqualsTo;\n+import static org.jbpm.services.api.query.model.QueryParam.notIn;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertNull;\n+import static org.kie.scanner.KieMavenRepository.getKieMavenRepository;\n+\n+@RunWith(Parameterized.class)\n+public class AdvanceRuntimeDataServiceImplTest extends AbstractKieServicesBaseTest {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(AdvanceRuntimeDataServiceImplTest.class);\n+\n+    @Parameters(name = \"Pagination {0}\")\n+    public static Iterable<? extends Object> data() {\n+        return Arrays.asList(0, 2);\n+    }\n+\n+    private List<DeploymentUnit> units = new ArrayList<DeploymentUnit>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f04f50355ec285330b3467d42754a036a04b1db3"}, "originalPosition": 80}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODY4Mjk2Nw==", "bodyText": "I see that pagination has been set at the test class level, but I'm missing a specific test method for testing this in combination with the offset and fetch the next batch of results/records. wdyt?", "url": "https://github.com/kiegroup/jbpm/pull/1615#discussion_r408682967", "createdAt": "2020-04-15T08:50:51Z", "author": {"login": "afalhambra"}, "path": "jbpm-services/jbpm-kie-services/src/test/java/org/jbpm/kie/services/test/AdvanceRuntimeDataServiceImplTest.java", "diffHunk": "@@ -0,0 +1,359 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.jbpm.kie.services.test;\n+\n+import java.io.File;\n+import java.io.FileOutputStream;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.drools.compiler.kie.builder.impl.InternalKieModule;\n+import org.jbpm.kie.services.impl.KModuleDeploymentUnit;\n+import org.jbpm.kie.test.util.AbstractKieServicesBaseTest;\n+import org.jbpm.services.api.ProcessInstanceNotFoundException;\n+import org.jbpm.services.api.model.DeploymentUnit;\n+import org.jbpm.services.api.model.ProcessInstanceWithVarsDesc;\n+import org.jbpm.services.api.model.UserTaskInstanceWithPotOwnerDesc;\n+import org.jbpm.services.api.query.model.QueryParam;\n+import org.junit.After;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.Parameterized;\n+import org.junit.runners.Parameterized.Parameters;\n+import org.kie.api.KieServices;\n+import org.kie.api.builder.ReleaseId;\n+import org.kie.api.runtime.process.ProcessInstance;\n+import org.kie.internal.query.QueryContext;\n+import org.kie.scanner.KieMavenRepository;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static java.util.Collections.emptyList;\n+import static org.hamcrest.CoreMatchers.is;\n+import static org.jbpm.services.api.AdvanceRuntimeDataService.PROCESS_ATTR_CORRELATION_KEY;\n+import static org.jbpm.services.api.AdvanceRuntimeDataService.PROCESS_ATTR_DEFINITION_ID;\n+import static org.jbpm.services.api.AdvanceRuntimeDataService.PROCESS_ATTR_DEPLOYMENT_ID;\n+import static org.jbpm.services.api.AdvanceRuntimeDataService.TASK_ATTR_NAME;\n+import static org.jbpm.services.api.AdvanceRuntimeDataService.TASK_ATTR_OWNER;\n+import static org.jbpm.services.api.query.model.QueryParam.equalsTo;\n+import static org.jbpm.services.api.query.model.QueryParam.in;\n+import static org.jbpm.services.api.query.model.QueryParam.isNotNull;\n+import static org.jbpm.services.api.query.model.QueryParam.isNull;\n+import static org.jbpm.services.api.query.model.QueryParam.likeTo;\n+import static org.jbpm.services.api.query.model.QueryParam.list;\n+import static org.jbpm.services.api.query.model.QueryParam.notEqualsTo;\n+import static org.jbpm.services.api.query.model.QueryParam.notIn;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertNull;\n+import static org.kie.scanner.KieMavenRepository.getKieMavenRepository;\n+\n+@RunWith(Parameterized.class)\n+public class AdvanceRuntimeDataServiceImplTest extends AbstractKieServicesBaseTest {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(AdvanceRuntimeDataServiceImplTest.class);\n+\n+    @Parameters(name = \"Pagination {0}\")\n+    public static Iterable<? extends Object> data() {\n+        return Arrays.asList(0, 2);\n+    }\n+\n+    private List<DeploymentUnit> units = new ArrayList<DeploymentUnit>();\n+    protected String correctUser = \"testUser\";\n+    protected String wrongUser = \"wrongUser\";\n+\n+    private List<Long> processIds;\n+    private KModuleDeploymentUnit deploymentUnit = null;\n+    private QueryContext queryContext;\n+\n+    public AdvanceRuntimeDataServiceImplTest(Integer count) {\n+        this.queryContext = new QueryContext(0, count);\n+    }\n+\n+    @Before\n+    public void prepare() {\n+\n+        configureServices();\n+        logger.debug(\"Preparing kjar\");\n+        KieServices ks = KieServices.Factory.get();\n+        ReleaseId releaseId = ks.newReleaseId(GROUP_ID, ARTIFACT_ID, VERSION);\n+        List<String> processes = new ArrayList<String>();\n+        processes.add(\"repo/processes/general/SingleHumanTaskWithVarsA.bpmn2\");\n+        processes.add(\"repo/processes/general/SingleHumanTaskWithVarsB.bpmn2\");\n+\n+        InternalKieModule kJar1 = createKieJar(ks, releaseId, processes);\n+        File pom = new File(\"target/kmodule\", \"pom.xml\");\n+        pom.getParentFile().mkdir();\n+        try (FileOutputStream fs = new FileOutputStream(pom);) {\n+            fs.write(getPom(releaseId).getBytes());\n+        } catch (Exception e) {\n+\n+        }\n+        KieMavenRepository repository = getKieMavenRepository();\n+        repository.deployArtifact(releaseId, kJar1, pom);\n+\n+        assertNotNull(deploymentService);\n+\n+        deploymentUnit = new KModuleDeploymentUnit(GROUP_ID, ARTIFACT_ID, VERSION);\n+\n+        deploymentService.deploy(deploymentUnit);\n+        units.add(deploymentUnit);\n+        assertNotNull(processService);\n+\n+        processIds = new ArrayList<>();\n+        for (int i = 0; i < 10; i++) {\n+            Map<String, Object> inputsA1 = new HashMap<>();\n+            inputsA1.put(\"var_a\", \"a\" + (i % 3));\n+            inputsA1.put(\"var_b\", (i % 3));\n+            processIds.add(processService.startProcess(deploymentUnit.getIdentifier(), \"test.test_A\", inputsA1));\n+        }\n+        for (int i = 0; i < 10; i++) {\n+            Map<String, Object> inputsB1 = new HashMap<>();\n+            inputsB1.put(\"var_a\", \"b\" + (i % 3));\n+            inputsB1.put(\"var_b\", (i % 3));\n+            processIds.add(processService.startProcess(deploymentUnit.getIdentifier(), \"test.test_B\", inputsB1));\n+        }\n+    }\n+\n+    @After\n+    public void cleanup() {\n+        for (Long processInstanceId : processIds) {\n+            try {\n+                // let's abort process instance to leave the system in clear state\n+                processService.abortProcessInstance(processInstanceId);\n+\n+                ProcessInstance pi = processService.getProcessInstance(processInstanceId);\n+                assertNull(pi);\n+            } catch (ProcessInstanceNotFoundException e) {\n+                // ignore it as it was already completed/aborted\n+            }\n+        }\n+        cleanupSingletonSessionId();\n+        if (units != null && !units.isEmpty()) {\n+            for (DeploymentUnit unit : units) {\n+                try {\n+                    deploymentService.undeploy(unit);\n+                } catch (Exception e) {\n+                    // do nothing in case of some failed tests to avoid next test to fail as well\n+                }\n+            }\n+            units.clear();\n+        }\n+        close();\n+    }\n+\n+    @Test\n+    public void testQueryProcessByVariables() {\n+        List<QueryParam> variables = list(equalsTo(\"var_a\", \"a1\"), equalsTo(\"var_b\", \"1\"));\n+        List<QueryParam> attributes = list(equalsTo(PROCESS_ATTR_DEFINITION_ID, \"test.test_A\"));\n+\n+        List<ProcessInstanceWithVarsDesc> data = advanceVariableDataService.queryProcessByVariables(attributes, variables, queryContext);\n+        if (queryContext.getCount() > 0) {\n+            Assert.assertThat(data.size(), is(queryContext.getCount()));\n+        }\n+        for (ProcessInstanceWithVarsDesc p : data) {\n+            Assert.assertEquals(\"a1\", p.getVariables().get(\"var_a\"));\n+            Assert.assertEquals(\"1\", p.getVariables().get(\"var_b\"));\n+            Assert.assertEquals(\"test.test_A\", p.getProcessId());\n+        }\n+    }\n+\n+    @Test\n+    public void testQueryInOperator() {\n+\n+        List<QueryParam> variables = list(in(\"var_a\", \"a1\", \"a2\"));\n+        List<QueryParam> attributes = list(equalsTo(PROCESS_ATTR_DEFINITION_ID, \"test.test_A\"));\n+\n+        List<ProcessInstanceWithVarsDesc> data = advanceVariableDataService.queryProcessByVariables(attributes, variables, queryContext);\n+        if (queryContext.getCount() > 0) {\n+            Assert.assertThat(data.size(), is(queryContext.getCount()));\n+        }\n+        List<String> values = Arrays.asList(\"a1\", \"a2\");\n+        for (ProcessInstanceWithVarsDesc p : data) {\n+            Assert.assertTrue(values.contains(p.getVariables().get(\"var_a\")));\n+            Assert.assertEquals(\"test.test_A\", p.getProcessId());\n+        }\n+    }\n+\n+    @Test\n+    public void testQueryLikeToOperator() {\n+\n+        List<QueryParam> variables = list(likeTo(\"var_a\", false, \"a%\"));\n+        List<QueryParam> attributes = list(likeTo(PROCESS_ATTR_DEFINITION_ID, false, \"%test_A%\"));\n+\n+        List<ProcessInstanceWithVarsDesc> data = advanceVariableDataService.queryProcessByVariables(attributes, variables, queryContext);\n+        if (queryContext.getCount() > 0) {\n+            Assert.assertThat(data.size(), is(queryContext.getCount()));\n+        }\n+\n+        for (ProcessInstanceWithVarsDesc p : data) {\n+            Assert.assertTrue(((String) p.getVariables().get(\"var_a\")).startsWith(\"a\"));\n+            Assert.assertEquals(\"test.test_A\", p.getProcessId());\n+        }\n+    }\n+\n+    @Test\n+    public void testQueryIsNotNullOperator() {\n+\n+        List<QueryParam> attributes = list(isNotNull(TASK_ATTR_OWNER));\n+\n+        List<UserTaskInstanceWithPotOwnerDesc> data = advanceVariableDataService.queryUserTasksByVariables(attributes, emptyList(), emptyList(), emptyList(), queryContext);\n+        Assert.assertThat(data.size(), is(0));\n+\n+    }\n+\n+    @Test\n+    public void testQueryIsNullOperator() {\n+\n+        List<QueryParam> attributes = list(isNull(TASK_ATTR_OWNER));\n+\n+        List<UserTaskInstanceWithPotOwnerDesc> data = advanceVariableDataService.queryUserTasksByVariables(attributes, emptyList(), emptyList(), emptyList(), queryContext);\n+        if (queryContext.getCount() > 0) {\n+            Assert.assertThat(data.size(), is(queryContext.getCount()));\n+        }\n+\n+        for (UserTaskInstanceWithPotOwnerDesc p : data) {\n+            Assert.assertNull(p.getActualOwner());\n+        }\n+    }\n+\n+    @Test\n+    public void testQueryNotInOperator() {\n+\n+        List<QueryParam> variables = list(notIn(\"var_a\", \"a1\", \"a2\"));\n+        List<QueryParam> attributes = list(equalsTo(PROCESS_ATTR_DEFINITION_ID, \"test.test_A\"));\n+\n+        List<ProcessInstanceWithVarsDesc> data = advanceVariableDataService.queryProcessByVariables(attributes, variables, queryContext);\n+        if (queryContext.getCount() > 0) {\n+            Assert.assertThat(data.size(), is(queryContext.getCount()));\n+        }\n+        List<String> values = Arrays.asList(\"a1\", \"a2\");\n+        for (ProcessInstanceWithVarsDesc p : data) {\n+            Assert.assertTrue(!values.contains(p.getVariables().get(\"var_a\")));\n+            Assert.assertEquals(\"test.test_A\", p.getProcessId());\n+        }\n+    }\n+\n+    @Test\n+    public void testQueryNotEqualsOperator() {\n+        List<QueryParam> attributes = list(notEqualsTo(PROCESS_ATTR_DEFINITION_ID, \"test.test_A\"));\n+\n+        List<ProcessInstanceWithVarsDesc> data = advanceVariableDataService.queryProcessByVariables(attributes, emptyList(), queryContext);\n+        if (queryContext.getCount() > 0) {\n+            Assert.assertThat(data.size(), is(queryContext.getCount()));\n+        }\n+\n+        for (ProcessInstanceWithVarsDesc p : data) {\n+            Assert.assertNotEquals(\"test.test_A\", p.getProcessId());\n+        }\n+    }\n+\n+    @Test\n+    public void testQueryProcessByAttributes() {\n+        List<QueryParam> attributes = list(equalsTo(PROCESS_ATTR_DEFINITION_ID, \"test.test_A\"), equalsTo(PROCESS_ATTR_CORRELATION_KEY, \"1\"));\n+\n+        List<ProcessInstanceWithVarsDesc> data = advanceVariableDataService.queryProcessByVariables(attributes, emptyList(), queryContext);\n+        Assert.assertThat(data.size(), is(1));\n+    }\n+\n+    @Test\n+    public void testQueryTaskByVariables() {\n+        List<QueryParam> variables = list(equalsTo(\"task_in_a1\", \"a0\"));\n+        List<QueryParam> attributes = list(equalsTo(PROCESS_ATTR_DEPLOYMENT_ID, \"org.jbpm.test:test-module:1.0.0\"));\n+\n+        List<String> potOwners = emptyList();\n+        List<UserTaskInstanceWithPotOwnerDesc> data = advanceVariableDataService.queryUserTasksByVariables(attributes, variables, emptyList(), potOwners, queryContext);\n+        if (queryContext.getCount() > 0) {\n+            Assert.assertThat(data.size(), is(queryContext.getCount()));\n+        }\n+        for (UserTaskInstanceWithPotOwnerDesc p : data) {\n+            Assert.assertEquals(\"a0\", p.getInputdata().get(\"task_in_a1\"));\n+            Assert.assertEquals(\"org.jbpm.test:test-module:1.0.0\", p.getDeploymentId());\n+        }\n+    }\n+\n+    @Test\n+    public void testQueryTaskNotEqualsByVariables() {\n+        List<QueryParam> attributes = list(notEqualsTo(PROCESS_ATTR_DEFINITION_ID, \"test.test_A\"));\n+\n+        List<String> potOwners = emptyList();\n+        List<UserTaskInstanceWithPotOwnerDesc> data = advanceVariableDataService.queryUserTasksByVariables(attributes, emptyList(), emptyList(), potOwners, queryContext);\n+        if (queryContext.getCount() > 0) {\n+            Assert.assertThat(data.size(), is(queryContext.getCount()));\n+        }\n+        for (UserTaskInstanceWithPotOwnerDesc p : data) {\n+            Assert.assertNotEquals(\"test.test_A\", p.getProcessId());\n+        }\n+    }\n+\n+    @Test\n+    public void testQueryTaskByVariablesWithOwners() {\n+\n+        List<String> potOwners = Collections.singletonList(\"katy\");\n+        List<UserTaskInstanceWithPotOwnerDesc> data = advanceVariableDataService.queryUserTasksByVariables(emptyList(), emptyList(), emptyList(), potOwners, queryContext);\n+        if (queryContext.getCount() > 0) {\n+            Assert.assertThat(data.size(), is(queryContext.getCount()));\n+        }\n+\n+        for (UserTaskInstanceWithPotOwnerDesc p : data) {\n+            Assert.assertTrue(p.getPotentialOwners().contains(\"katy\"));\n+        }\n+    }\n+\n+    @Test\n+    public void testQueryTaskByVariablesWithAllOwners() {\n+        List<String> potOwners = Arrays.asList(\"katy\", \"nobody\");\n+        List<UserTaskInstanceWithPotOwnerDesc> data = advanceVariableDataService.queryUserTasksByVariables(emptyList(), emptyList(), emptyList(), potOwners, queryContext);\n+        Assert.assertEquals(0, data.size());\n+\n+    }\n+\n+    @Test\n+    public void testQueryTaskByVariablesWithByProcessVar() {\n+        List<QueryParam> processVariables = list(equalsTo(\"var_a\", \"a1\"));\n+\n+        List<String> potOwners = Collections.emptyList();\n+        List<UserTaskInstanceWithPotOwnerDesc> data = advanceVariableDataService.queryUserTasksByVariables(emptyList(), emptyList(), processVariables, potOwners, queryContext);\n+        if (queryContext.getCount() > 0) {\n+            Assert.assertThat(data.size(), is(queryContext.getCount()));\n+        } else {\n+            Assert.assertThat(data.size(), is(3));\n+        }\n+\n+    }\n+\n+    @Test\n+    public void testQueryTaskByAttributes() {\n+        List<QueryParam> attributes = list(equalsTo(PROCESS_ATTR_DEFINITION_ID, \"test.test_A\"), equalsTo(PROCESS_ATTR_CORRELATION_KEY, \"1\"), equalsTo(TASK_ATTR_NAME, \"Task\"));\n+\n+        List<UserTaskInstanceWithPotOwnerDesc> data = advanceVariableDataService.queryUserTasksByVariables(attributes, emptyList(), emptyList(), emptyList(), queryContext);\n+        Assert.assertThat(data.size(), is(1));\n+    }\n+\n+    @Test\n+    public void testQueryTaskByAttributesOwner() {\n+        List<QueryParam> attributes = list(equalsTo(TASK_ATTR_OWNER, \"Error\"));\n+        List<UserTaskInstanceWithPotOwnerDesc> data = advanceVariableDataService.queryUserTasksByVariables(attributes, emptyList(), emptyList(), emptyList(), queryContext);\n+        Assert.assertThat(data.size(), is(0));\n+    }\n+\n+}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f04f50355ec285330b3467d42754a036a04b1db3"}, "originalPosition": 359}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODY4NzExNg==", "bodyText": "Please remove extra parentheses here around \"entry\"\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    attributes.stream().filter(e -> e.getObjectValue() != null).forEach((entry) -> query.setParameter(\"ATTR_\" + entry.getColumn(), entry.getObjectValue()));\n          \n          \n            \n                    attributes.stream().filter(e -> e.getObjectValue() != null).forEach(entry -> query.setParameter(\"ATTR_\" + entry.getColumn(), entry.getObjectValue()));", "url": "https://github.com/kiegroup/jbpm/pull/1615#discussion_r408687116", "createdAt": "2020-04-15T08:57:38Z", "author": {"login": "afalhambra"}, "path": "jbpm-services/jbpm-kie-services/src/main/java/org/jbpm/kie/services/impl/AbstractAdvanceRuntimeDataServiceImpl.java", "diffHunk": "@@ -0,0 +1,346 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.jbpm.kie.services.impl;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import javax.persistence.EntityManager;\n+import javax.persistence.EntityManagerFactory;\n+import javax.persistence.Query;\n+\n+import org.dashbuilder.dataset.filter.CoreFunctionType;\n+import org.jbpm.kie.services.impl.model.ProcessInstanceWithVarsDesc;\n+import org.jbpm.kie.services.impl.model.UserTaskInstanceWithPotOwnerDesc;\n+import org.jbpm.services.api.query.model.QueryParam;\n+import org.jbpm.shared.services.impl.QueryManager;\n+import org.jbpm.shared.services.impl.TransactionalCommandService;\n+import org.jbpm.shared.services.impl.commands.QueryNameCommand;\n+import org.kie.api.runtime.query.QueryContext;\n+\n+import static java.util.Collections.singletonMap;\n+\n+public abstract class AbstractAdvanceRuntimeDataServiceImpl {\n+\n+    private static final String ID_LIST = \"idList\";\n+    private EntityManagerFactory emf;\n+    private TransactionalCommandService commandService;\n+\n+    public AbstractAdvanceRuntimeDataServiceImpl() {\n+        QueryManager.get().addNamedQueries(\"META-INF/Servicesorm.xml\");\n+    }\n+    public void setCommandService(TransactionalCommandService commandService) {\n+        this.commandService = commandService;\n+    }\n+\n+    public void setEmf(EntityManagerFactory emf) {\n+        this.emf = emf;\n+    }\n+\n+\n+    public List<org.jbpm.services.api.model.ProcessInstanceWithVarsDesc> queryProcessByVariables(List<QueryParam> attributes,\n+                                                                                                 List<QueryParam> variables,\n+                                                                                                 int processType,\n+                                                                                                 String varPrefix,\n+                                                                                                 QueryContext queryContext) {\n+        EntityManager entityManager = emf.createEntityManager();\n+\n+        // first step is to filter the data creating a derived tables and pivoting var - rows to columns (only the variables we are interested to filter)\n+        StringBuilder derivedTables = new StringBuilder();\n+        if (!variables.isEmpty()) {\n+            List<String> conditions = new ArrayList<>();\n+            variables.stream().forEach(expr -> conditions.add(\"(A1.variableId = :NAME_\" + expr.getColumn() + \" AND \" + computeExpression(expr, \"A1.value\", \":VALUE_\" + expr.getColumn()) + \")\\n\"));\n+            String where = String.join(\" OR \", conditions);\n+            derivedTables.append(\"INNER JOIN (\" +\n+                                 \"SELECT A1.processInstanceId \\n\" +\n+                                 \"FROM VariableInstanceLog A1 \\n\" +\n+                                 \"LEFT JOIN VariableInstanceLog A2 ON A1.processId = A2.processId AND A1.processInstanceId = A2.processInstanceId AND A1.variableInstanceId = A2.variableInstanceId AND A2.id > A1.id  \\n\" +\n+                                 \"WHERE A2.id IS NULL AND (\" + where + \") \" +\n+                                 \"GROUP BY A1.processInstanceId \" +\n+                                 \"HAVING COUNT(*) = :NUMBER_OF_VARS \" +\n+                                 \") TABLE_VAR ON TABLE_VAR.processInstanceId = pil.processInstanceId \\n\");\n+        }\n+\n+        StringBuilder globalWhere = new StringBuilder();\n+        attributes.stream().forEach(expr -> globalWhere.append(\" AND \" + computeExpression(expr, expr.getColumn(), \":ATTR_\" + expr.getColumn())));\n+\n+        String procSQLString =\n+                \" SELECT DISTINCT pil.processInstanceId \" +\n+                               \" FROM ProcessInstanceLog pil \\n \" +\n+                               derivedTables +\n+                               \" WHERE pil.processType = :processType \" + globalWhere +\n+                               \" ORDER BY pil.processInstanceId ASC \";\n+\n+        Query query = entityManager.createNativeQuery(procSQLString);\n+        variables.stream().forEach(var -> query.setParameter(\"NAME_\" + var.getColumn(), varPrefix + var.getColumn()));\n+        variables.stream().filter(e -> e.getObjectValue() != null).forEach(var -> query.setParameter(\"VALUE_\" + var.getColumn(), var.getObjectValue()));\n+        attributes.stream().filter(e -> e.getObjectValue() != null).forEach((entry) -> query.setParameter(\"ATTR_\" + entry.getColumn(), entry.getObjectValue()));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f04f50355ec285330b3467d42754a036a04b1db3"}, "originalPosition": 95}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODY4Nzg1Mg==", "bodyText": "Please remove the extra parentheses around \"expr\"\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        variables.stream().forEach((expr) -> conditions.add(\"(name = :V_NAME_\" + expr.getColumn() + \" AND \" + computeExpression(expr, \"value\", \":V_VALUE_\" + expr.getColumn()) + \")\\n\"));\n          \n          \n            \n                        variables.stream().forEach(expr -> conditions.add(\"(name = :V_NAME_\" + expr.getColumn() + \" AND \" + computeExpression(expr, \"value\", \":V_VALUE_\" + expr.getColumn()) + \")\\n\"));", "url": "https://github.com/kiegroup/jbpm/pull/1615#discussion_r408687852", "createdAt": "2020-04-15T08:58:47Z", "author": {"login": "afalhambra"}, "path": "jbpm-services/jbpm-kie-services/src/main/java/org/jbpm/kie/services/impl/AbstractAdvanceRuntimeDataServiceImpl.java", "diffHunk": "@@ -0,0 +1,346 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.jbpm.kie.services.impl;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import javax.persistence.EntityManager;\n+import javax.persistence.EntityManagerFactory;\n+import javax.persistence.Query;\n+\n+import org.dashbuilder.dataset.filter.CoreFunctionType;\n+import org.jbpm.kie.services.impl.model.ProcessInstanceWithVarsDesc;\n+import org.jbpm.kie.services.impl.model.UserTaskInstanceWithPotOwnerDesc;\n+import org.jbpm.services.api.query.model.QueryParam;\n+import org.jbpm.shared.services.impl.QueryManager;\n+import org.jbpm.shared.services.impl.TransactionalCommandService;\n+import org.jbpm.shared.services.impl.commands.QueryNameCommand;\n+import org.kie.api.runtime.query.QueryContext;\n+\n+import static java.util.Collections.singletonMap;\n+\n+public abstract class AbstractAdvanceRuntimeDataServiceImpl {\n+\n+    private static final String ID_LIST = \"idList\";\n+    private EntityManagerFactory emf;\n+    private TransactionalCommandService commandService;\n+\n+    public AbstractAdvanceRuntimeDataServiceImpl() {\n+        QueryManager.get().addNamedQueries(\"META-INF/Servicesorm.xml\");\n+    }\n+    public void setCommandService(TransactionalCommandService commandService) {\n+        this.commandService = commandService;\n+    }\n+\n+    public void setEmf(EntityManagerFactory emf) {\n+        this.emf = emf;\n+    }\n+\n+\n+    public List<org.jbpm.services.api.model.ProcessInstanceWithVarsDesc> queryProcessByVariables(List<QueryParam> attributes,\n+                                                                                                 List<QueryParam> variables,\n+                                                                                                 int processType,\n+                                                                                                 String varPrefix,\n+                                                                                                 QueryContext queryContext) {\n+        EntityManager entityManager = emf.createEntityManager();\n+\n+        // first step is to filter the data creating a derived tables and pivoting var - rows to columns (only the variables we are interested to filter)\n+        StringBuilder derivedTables = new StringBuilder();\n+        if (!variables.isEmpty()) {\n+            List<String> conditions = new ArrayList<>();\n+            variables.stream().forEach(expr -> conditions.add(\"(A1.variableId = :NAME_\" + expr.getColumn() + \" AND \" + computeExpression(expr, \"A1.value\", \":VALUE_\" + expr.getColumn()) + \")\\n\"));\n+            String where = String.join(\" OR \", conditions);\n+            derivedTables.append(\"INNER JOIN (\" +\n+                                 \"SELECT A1.processInstanceId \\n\" +\n+                                 \"FROM VariableInstanceLog A1 \\n\" +\n+                                 \"LEFT JOIN VariableInstanceLog A2 ON A1.processId = A2.processId AND A1.processInstanceId = A2.processInstanceId AND A1.variableInstanceId = A2.variableInstanceId AND A2.id > A1.id  \\n\" +\n+                                 \"WHERE A2.id IS NULL AND (\" + where + \") \" +\n+                                 \"GROUP BY A1.processInstanceId \" +\n+                                 \"HAVING COUNT(*) = :NUMBER_OF_VARS \" +\n+                                 \") TABLE_VAR ON TABLE_VAR.processInstanceId = pil.processInstanceId \\n\");\n+        }\n+\n+        StringBuilder globalWhere = new StringBuilder();\n+        attributes.stream().forEach(expr -> globalWhere.append(\" AND \" + computeExpression(expr, expr.getColumn(), \":ATTR_\" + expr.getColumn())));\n+\n+        String procSQLString =\n+                \" SELECT DISTINCT pil.processInstanceId \" +\n+                               \" FROM ProcessInstanceLog pil \\n \" +\n+                               derivedTables +\n+                               \" WHERE pil.processType = :processType \" + globalWhere +\n+                               \" ORDER BY pil.processInstanceId ASC \";\n+\n+        Query query = entityManager.createNativeQuery(procSQLString);\n+        variables.stream().forEach(var -> query.setParameter(\"NAME_\" + var.getColumn(), varPrefix + var.getColumn()));\n+        variables.stream().filter(e -> e.getObjectValue() != null).forEach(var -> query.setParameter(\"VALUE_\" + var.getColumn(), var.getObjectValue()));\n+        attributes.stream().filter(e -> e.getObjectValue() != null).forEach((entry) -> query.setParameter(\"ATTR_\" + entry.getColumn(), entry.getObjectValue()));\n+\n+        if (!variables.isEmpty()) {\n+            query.setParameter(\"NUMBER_OF_VARS\", variables.size());\n+        }\n+        query.setParameter(\"processType\", processType);\n+\n+        addPagination(query, queryContext);\n+        List<Number> ids = query.getResultList();\n+        if (ids.isEmpty()) {\n+            return Collections.emptyList();\n+        }\n+\n+        // now we get the information\n+\n+        List<Object[]> procRows = commandService.execute(new QueryNameCommand<List<Object[]>>(\"GetProcessInstanceByIdList\", singletonMap(ID_LIST, ids)));\n+        List<Object[]> varRows = commandService.execute(new QueryNameCommand<List<Object[]>>(\"GetVariablesByProcessInstanceIdList\", singletonMap(ID_LIST, ids)));\n+\n+        int currentVarIdx = 0;\n+        List<org.jbpm.services.api.model.ProcessInstanceWithVarsDesc> data = new ArrayList<>();\n+        for (Object[] row : procRows) {\n+            ProcessInstanceWithVarsDesc pwv = toProcessInstanceWithVarsDesc(row);\n+\n+            Map<String, Object> vars = new HashMap<>();\n+            pwv.setVariables(vars);\n+\n+            Map<String, Object> extra = new HashMap<>();\n+            pwv.setExtraData(extra);\n+            while (currentVarIdx < varRows.size() && row[0].equals(varRows.get(currentVarIdx)[0])) {\n+                String name = (String) varRows.get(currentVarIdx)[1];\n+                if (!varPrefix.isEmpty() && name.startsWith(varPrefix)) {\n+                    extra.put(name.substring(varPrefix.length()), varRows.get(currentVarIdx)[2]);\n+                } else {\n+                    vars.put(name, varRows.get(currentVarIdx)[2]);\n+                }\n+                currentVarIdx++;\n+            }\n+            data.add(pwv);\n+        }\n+\n+        entityManager.close();\n+        return data;\n+    }\n+\n+    private String computeExpression(QueryParam expr, String leftOperand, String rightOperand) {\n+        CoreFunctionType type = CoreFunctionType.getByName(expr.getOperator());\n+        switch (type) {\n+            case IS_NULL:\n+                return leftOperand + \" IS NULL \";\n+            case NOT_NULL:\n+                return leftOperand + \" IS NOT NULL \";\n+            case IN:\n+                return leftOperand + \" IN (\" + rightOperand + \") \";\n+            case NOT_IN:\n+                return leftOperand + \" NOT IN (\" + rightOperand + \") \";\n+            case EQUALS_TO:\n+                return leftOperand + \" = \" + rightOperand + \" \";\n+            case NOT_EQUALS_TO:\n+                return leftOperand + \" <> \" + rightOperand + \" \";\n+            case LIKE_TO:\n+                return leftOperand + \" LIKE \" + rightOperand + \" \";\n+            default:\n+                throw new UnsupportedOperationException(\"Queryparam: \" + expr + \" not supported\");\n+        }\n+    }\n+    private ProcessInstanceWithVarsDesc toProcessInstanceWithVarsDesc(Object[] row) {\n+        return new ProcessInstanceWithVarsDesc(((Number) row[0]).longValue(),\n+                                               (String) row[1],\n+                                               (String) row[2],\n+                                               (String) row[3],\n+                                               ((Number) row[4]).intValue(),\n+                                               (String) row[5],\n+                                               (Date) row[6],\n+                                               (String) row[7],\n+                                               (String) row[8]);\n+    }\n+\n+    private void addPagination(Query query, QueryContext context) {\n+        if (context.getCount() > 0) {\n+            query.setFirstResult(context.getOffset());\n+            query.setMaxResults(context.getCount());\n+        }\n+    }\n+\n+    public List<org.jbpm.services.api.model.UserTaskInstanceWithPotOwnerDesc> queryUserTasksByVariables(List<QueryParam> attributes,\n+                                                                                                        List<QueryParam> variables,\n+                                                                                                        List<QueryParam> processVariables,\n+                                                                                                        List<String> owners,\n+                                                                                                        int processType,\n+                                                                                                        String varPrefix,\n+                                                                                                        QueryContext queryContext) {\n+        EntityManager entityManager = emf.createEntityManager();\n+        StringBuilder globalWhere = new StringBuilder();\n+        StringBuilder derivedTables = new StringBuilder();\n+        if (!variables.isEmpty()) {\n+            List<String> conditions = new ArrayList<>();\n+            variables.stream().forEach((expr) -> conditions.add(\"(name = :V_NAME_\" + expr.getColumn() + \" AND \" + computeExpression(expr, \"value\", \":V_VALUE_\" + expr.getColumn()) + \")\\n\"));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f04f50355ec285330b3467d42754a036a04b1db3"}, "originalPosition": 191}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODY4ODM3Ng==", "bodyText": "Please remove the extra parentheses around \"expr\"\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        processVariables.stream().forEach((expr) -> conditions.add(\"(A1.variableId = :P_NAME_\" + expr.getColumn() + \" AND \" + computeExpression(expr, \"A1.value\", \":P_VALUE_\" + expr.getColumn()) + \")\\n\"));\n          \n          \n            \n                        processVariables.stream().forEach(expr -> conditions.add(\"(A1.variableId = :P_NAME_\" + expr.getColumn() + \" AND \" + computeExpression(expr, \"A1.value\", \":P_VALUE_\" + expr.getColumn()) + \")\\n\"));", "url": "https://github.com/kiegroup/jbpm/pull/1615#discussion_r408688376", "createdAt": "2020-04-15T08:59:37Z", "author": {"login": "afalhambra"}, "path": "jbpm-services/jbpm-kie-services/src/main/java/org/jbpm/kie/services/impl/AbstractAdvanceRuntimeDataServiceImpl.java", "diffHunk": "@@ -0,0 +1,346 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.jbpm.kie.services.impl;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import javax.persistence.EntityManager;\n+import javax.persistence.EntityManagerFactory;\n+import javax.persistence.Query;\n+\n+import org.dashbuilder.dataset.filter.CoreFunctionType;\n+import org.jbpm.kie.services.impl.model.ProcessInstanceWithVarsDesc;\n+import org.jbpm.kie.services.impl.model.UserTaskInstanceWithPotOwnerDesc;\n+import org.jbpm.services.api.query.model.QueryParam;\n+import org.jbpm.shared.services.impl.QueryManager;\n+import org.jbpm.shared.services.impl.TransactionalCommandService;\n+import org.jbpm.shared.services.impl.commands.QueryNameCommand;\n+import org.kie.api.runtime.query.QueryContext;\n+\n+import static java.util.Collections.singletonMap;\n+\n+public abstract class AbstractAdvanceRuntimeDataServiceImpl {\n+\n+    private static final String ID_LIST = \"idList\";\n+    private EntityManagerFactory emf;\n+    private TransactionalCommandService commandService;\n+\n+    public AbstractAdvanceRuntimeDataServiceImpl() {\n+        QueryManager.get().addNamedQueries(\"META-INF/Servicesorm.xml\");\n+    }\n+    public void setCommandService(TransactionalCommandService commandService) {\n+        this.commandService = commandService;\n+    }\n+\n+    public void setEmf(EntityManagerFactory emf) {\n+        this.emf = emf;\n+    }\n+\n+\n+    public List<org.jbpm.services.api.model.ProcessInstanceWithVarsDesc> queryProcessByVariables(List<QueryParam> attributes,\n+                                                                                                 List<QueryParam> variables,\n+                                                                                                 int processType,\n+                                                                                                 String varPrefix,\n+                                                                                                 QueryContext queryContext) {\n+        EntityManager entityManager = emf.createEntityManager();\n+\n+        // first step is to filter the data creating a derived tables and pivoting var - rows to columns (only the variables we are interested to filter)\n+        StringBuilder derivedTables = new StringBuilder();\n+        if (!variables.isEmpty()) {\n+            List<String> conditions = new ArrayList<>();\n+            variables.stream().forEach(expr -> conditions.add(\"(A1.variableId = :NAME_\" + expr.getColumn() + \" AND \" + computeExpression(expr, \"A1.value\", \":VALUE_\" + expr.getColumn()) + \")\\n\"));\n+            String where = String.join(\" OR \", conditions);\n+            derivedTables.append(\"INNER JOIN (\" +\n+                                 \"SELECT A1.processInstanceId \\n\" +\n+                                 \"FROM VariableInstanceLog A1 \\n\" +\n+                                 \"LEFT JOIN VariableInstanceLog A2 ON A1.processId = A2.processId AND A1.processInstanceId = A2.processInstanceId AND A1.variableInstanceId = A2.variableInstanceId AND A2.id > A1.id  \\n\" +\n+                                 \"WHERE A2.id IS NULL AND (\" + where + \") \" +\n+                                 \"GROUP BY A1.processInstanceId \" +\n+                                 \"HAVING COUNT(*) = :NUMBER_OF_VARS \" +\n+                                 \") TABLE_VAR ON TABLE_VAR.processInstanceId = pil.processInstanceId \\n\");\n+        }\n+\n+        StringBuilder globalWhere = new StringBuilder();\n+        attributes.stream().forEach(expr -> globalWhere.append(\" AND \" + computeExpression(expr, expr.getColumn(), \":ATTR_\" + expr.getColumn())));\n+\n+        String procSQLString =\n+                \" SELECT DISTINCT pil.processInstanceId \" +\n+                               \" FROM ProcessInstanceLog pil \\n \" +\n+                               derivedTables +\n+                               \" WHERE pil.processType = :processType \" + globalWhere +\n+                               \" ORDER BY pil.processInstanceId ASC \";\n+\n+        Query query = entityManager.createNativeQuery(procSQLString);\n+        variables.stream().forEach(var -> query.setParameter(\"NAME_\" + var.getColumn(), varPrefix + var.getColumn()));\n+        variables.stream().filter(e -> e.getObjectValue() != null).forEach(var -> query.setParameter(\"VALUE_\" + var.getColumn(), var.getObjectValue()));\n+        attributes.stream().filter(e -> e.getObjectValue() != null).forEach((entry) -> query.setParameter(\"ATTR_\" + entry.getColumn(), entry.getObjectValue()));\n+\n+        if (!variables.isEmpty()) {\n+            query.setParameter(\"NUMBER_OF_VARS\", variables.size());\n+        }\n+        query.setParameter(\"processType\", processType);\n+\n+        addPagination(query, queryContext);\n+        List<Number> ids = query.getResultList();\n+        if (ids.isEmpty()) {\n+            return Collections.emptyList();\n+        }\n+\n+        // now we get the information\n+\n+        List<Object[]> procRows = commandService.execute(new QueryNameCommand<List<Object[]>>(\"GetProcessInstanceByIdList\", singletonMap(ID_LIST, ids)));\n+        List<Object[]> varRows = commandService.execute(new QueryNameCommand<List<Object[]>>(\"GetVariablesByProcessInstanceIdList\", singletonMap(ID_LIST, ids)));\n+\n+        int currentVarIdx = 0;\n+        List<org.jbpm.services.api.model.ProcessInstanceWithVarsDesc> data = new ArrayList<>();\n+        for (Object[] row : procRows) {\n+            ProcessInstanceWithVarsDesc pwv = toProcessInstanceWithVarsDesc(row);\n+\n+            Map<String, Object> vars = new HashMap<>();\n+            pwv.setVariables(vars);\n+\n+            Map<String, Object> extra = new HashMap<>();\n+            pwv.setExtraData(extra);\n+            while (currentVarIdx < varRows.size() && row[0].equals(varRows.get(currentVarIdx)[0])) {\n+                String name = (String) varRows.get(currentVarIdx)[1];\n+                if (!varPrefix.isEmpty() && name.startsWith(varPrefix)) {\n+                    extra.put(name.substring(varPrefix.length()), varRows.get(currentVarIdx)[2]);\n+                } else {\n+                    vars.put(name, varRows.get(currentVarIdx)[2]);\n+                }\n+                currentVarIdx++;\n+            }\n+            data.add(pwv);\n+        }\n+\n+        entityManager.close();\n+        return data;\n+    }\n+\n+    private String computeExpression(QueryParam expr, String leftOperand, String rightOperand) {\n+        CoreFunctionType type = CoreFunctionType.getByName(expr.getOperator());\n+        switch (type) {\n+            case IS_NULL:\n+                return leftOperand + \" IS NULL \";\n+            case NOT_NULL:\n+                return leftOperand + \" IS NOT NULL \";\n+            case IN:\n+                return leftOperand + \" IN (\" + rightOperand + \") \";\n+            case NOT_IN:\n+                return leftOperand + \" NOT IN (\" + rightOperand + \") \";\n+            case EQUALS_TO:\n+                return leftOperand + \" = \" + rightOperand + \" \";\n+            case NOT_EQUALS_TO:\n+                return leftOperand + \" <> \" + rightOperand + \" \";\n+            case LIKE_TO:\n+                return leftOperand + \" LIKE \" + rightOperand + \" \";\n+            default:\n+                throw new UnsupportedOperationException(\"Queryparam: \" + expr + \" not supported\");\n+        }\n+    }\n+    private ProcessInstanceWithVarsDesc toProcessInstanceWithVarsDesc(Object[] row) {\n+        return new ProcessInstanceWithVarsDesc(((Number) row[0]).longValue(),\n+                                               (String) row[1],\n+                                               (String) row[2],\n+                                               (String) row[3],\n+                                               ((Number) row[4]).intValue(),\n+                                               (String) row[5],\n+                                               (Date) row[6],\n+                                               (String) row[7],\n+                                               (String) row[8]);\n+    }\n+\n+    private void addPagination(Query query, QueryContext context) {\n+        if (context.getCount() > 0) {\n+            query.setFirstResult(context.getOffset());\n+            query.setMaxResults(context.getCount());\n+        }\n+    }\n+\n+    public List<org.jbpm.services.api.model.UserTaskInstanceWithPotOwnerDesc> queryUserTasksByVariables(List<QueryParam> attributes,\n+                                                                                                        List<QueryParam> variables,\n+                                                                                                        List<QueryParam> processVariables,\n+                                                                                                        List<String> owners,\n+                                                                                                        int processType,\n+                                                                                                        String varPrefix,\n+                                                                                                        QueryContext queryContext) {\n+        EntityManager entityManager = emf.createEntityManager();\n+        StringBuilder globalWhere = new StringBuilder();\n+        StringBuilder derivedTables = new StringBuilder();\n+        if (!variables.isEmpty()) {\n+            List<String> conditions = new ArrayList<>();\n+            variables.stream().forEach((expr) -> conditions.add(\"(name = :V_NAME_\" + expr.getColumn() + \" AND \" + computeExpression(expr, \"value\", \":V_VALUE_\" + expr.getColumn()) + \")\\n\"));\n+            String where = String.join(\" OR \", conditions);\n+            derivedTables.append(\"INNER JOIN (\\n\" +\n+                                 \"SELECT taskId \\n\" +\n+                                 \"FROM TaskVariableImpl \\n\" +\n+                                 \"WHERE type = 0 AND (\" + where + \")\\n\" +\n+                                 \"GROUP BY taskId \\n\" +\n+                                 \"HAVING COUNT(*) = :NUMBER_OF_TASKVARS \\n\" +\n+                                 \") TABLE_TASK_VAR ON TABLE_TASK_VAR.taskId = task.id  \\n\");\n+        }\n+\n+        if (!processVariables.isEmpty()) {\n+            List<String> conditions = new ArrayList<>();\n+            processVariables.stream().forEach((expr) -> conditions.add(\"(A1.variableId = :P_NAME_\" + expr.getColumn() + \" AND \" + computeExpression(expr, \"A1.value\", \":P_VALUE_\" + expr.getColumn()) + \")\\n\"));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f04f50355ec285330b3467d42754a036a04b1db3"}, "originalPosition": 204}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODY4ODc2NQ==", "bodyText": "Please remove extra parentheses around \"expr\"\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    attributes.stream().forEach((expr) -> globalWhere.append(\" AND \" + computeExpression(expr, expr.getColumn(), \":ATTR_\" + expr.getColumn())));\n          \n          \n            \n                    attributes.stream().forEach(expr -> globalWhere.append(\" AND \" + computeExpression(expr, expr.getColumn(), \":ATTR_\" + expr.getColumn())));", "url": "https://github.com/kiegroup/jbpm/pull/1615#discussion_r408688765", "createdAt": "2020-04-15T09:00:15Z", "author": {"login": "afalhambra"}, "path": "jbpm-services/jbpm-kie-services/src/main/java/org/jbpm/kie/services/impl/AbstractAdvanceRuntimeDataServiceImpl.java", "diffHunk": "@@ -0,0 +1,346 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.jbpm.kie.services.impl;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import javax.persistence.EntityManager;\n+import javax.persistence.EntityManagerFactory;\n+import javax.persistence.Query;\n+\n+import org.dashbuilder.dataset.filter.CoreFunctionType;\n+import org.jbpm.kie.services.impl.model.ProcessInstanceWithVarsDesc;\n+import org.jbpm.kie.services.impl.model.UserTaskInstanceWithPotOwnerDesc;\n+import org.jbpm.services.api.query.model.QueryParam;\n+import org.jbpm.shared.services.impl.QueryManager;\n+import org.jbpm.shared.services.impl.TransactionalCommandService;\n+import org.jbpm.shared.services.impl.commands.QueryNameCommand;\n+import org.kie.api.runtime.query.QueryContext;\n+\n+import static java.util.Collections.singletonMap;\n+\n+public abstract class AbstractAdvanceRuntimeDataServiceImpl {\n+\n+    private static final String ID_LIST = \"idList\";\n+    private EntityManagerFactory emf;\n+    private TransactionalCommandService commandService;\n+\n+    public AbstractAdvanceRuntimeDataServiceImpl() {\n+        QueryManager.get().addNamedQueries(\"META-INF/Servicesorm.xml\");\n+    }\n+    public void setCommandService(TransactionalCommandService commandService) {\n+        this.commandService = commandService;\n+    }\n+\n+    public void setEmf(EntityManagerFactory emf) {\n+        this.emf = emf;\n+    }\n+\n+\n+    public List<org.jbpm.services.api.model.ProcessInstanceWithVarsDesc> queryProcessByVariables(List<QueryParam> attributes,\n+                                                                                                 List<QueryParam> variables,\n+                                                                                                 int processType,\n+                                                                                                 String varPrefix,\n+                                                                                                 QueryContext queryContext) {\n+        EntityManager entityManager = emf.createEntityManager();\n+\n+        // first step is to filter the data creating a derived tables and pivoting var - rows to columns (only the variables we are interested to filter)\n+        StringBuilder derivedTables = new StringBuilder();\n+        if (!variables.isEmpty()) {\n+            List<String> conditions = new ArrayList<>();\n+            variables.stream().forEach(expr -> conditions.add(\"(A1.variableId = :NAME_\" + expr.getColumn() + \" AND \" + computeExpression(expr, \"A1.value\", \":VALUE_\" + expr.getColumn()) + \")\\n\"));\n+            String where = String.join(\" OR \", conditions);\n+            derivedTables.append(\"INNER JOIN (\" +\n+                                 \"SELECT A1.processInstanceId \\n\" +\n+                                 \"FROM VariableInstanceLog A1 \\n\" +\n+                                 \"LEFT JOIN VariableInstanceLog A2 ON A1.processId = A2.processId AND A1.processInstanceId = A2.processInstanceId AND A1.variableInstanceId = A2.variableInstanceId AND A2.id > A1.id  \\n\" +\n+                                 \"WHERE A2.id IS NULL AND (\" + where + \") \" +\n+                                 \"GROUP BY A1.processInstanceId \" +\n+                                 \"HAVING COUNT(*) = :NUMBER_OF_VARS \" +\n+                                 \") TABLE_VAR ON TABLE_VAR.processInstanceId = pil.processInstanceId \\n\");\n+        }\n+\n+        StringBuilder globalWhere = new StringBuilder();\n+        attributes.stream().forEach(expr -> globalWhere.append(\" AND \" + computeExpression(expr, expr.getColumn(), \":ATTR_\" + expr.getColumn())));\n+\n+        String procSQLString =\n+                \" SELECT DISTINCT pil.processInstanceId \" +\n+                               \" FROM ProcessInstanceLog pil \\n \" +\n+                               derivedTables +\n+                               \" WHERE pil.processType = :processType \" + globalWhere +\n+                               \" ORDER BY pil.processInstanceId ASC \";\n+\n+        Query query = entityManager.createNativeQuery(procSQLString);\n+        variables.stream().forEach(var -> query.setParameter(\"NAME_\" + var.getColumn(), varPrefix + var.getColumn()));\n+        variables.stream().filter(e -> e.getObjectValue() != null).forEach(var -> query.setParameter(\"VALUE_\" + var.getColumn(), var.getObjectValue()));\n+        attributes.stream().filter(e -> e.getObjectValue() != null).forEach((entry) -> query.setParameter(\"ATTR_\" + entry.getColumn(), entry.getObjectValue()));\n+\n+        if (!variables.isEmpty()) {\n+            query.setParameter(\"NUMBER_OF_VARS\", variables.size());\n+        }\n+        query.setParameter(\"processType\", processType);\n+\n+        addPagination(query, queryContext);\n+        List<Number> ids = query.getResultList();\n+        if (ids.isEmpty()) {\n+            return Collections.emptyList();\n+        }\n+\n+        // now we get the information\n+\n+        List<Object[]> procRows = commandService.execute(new QueryNameCommand<List<Object[]>>(\"GetProcessInstanceByIdList\", singletonMap(ID_LIST, ids)));\n+        List<Object[]> varRows = commandService.execute(new QueryNameCommand<List<Object[]>>(\"GetVariablesByProcessInstanceIdList\", singletonMap(ID_LIST, ids)));\n+\n+        int currentVarIdx = 0;\n+        List<org.jbpm.services.api.model.ProcessInstanceWithVarsDesc> data = new ArrayList<>();\n+        for (Object[] row : procRows) {\n+            ProcessInstanceWithVarsDesc pwv = toProcessInstanceWithVarsDesc(row);\n+\n+            Map<String, Object> vars = new HashMap<>();\n+            pwv.setVariables(vars);\n+\n+            Map<String, Object> extra = new HashMap<>();\n+            pwv.setExtraData(extra);\n+            while (currentVarIdx < varRows.size() && row[0].equals(varRows.get(currentVarIdx)[0])) {\n+                String name = (String) varRows.get(currentVarIdx)[1];\n+                if (!varPrefix.isEmpty() && name.startsWith(varPrefix)) {\n+                    extra.put(name.substring(varPrefix.length()), varRows.get(currentVarIdx)[2]);\n+                } else {\n+                    vars.put(name, varRows.get(currentVarIdx)[2]);\n+                }\n+                currentVarIdx++;\n+            }\n+            data.add(pwv);\n+        }\n+\n+        entityManager.close();\n+        return data;\n+    }\n+\n+    private String computeExpression(QueryParam expr, String leftOperand, String rightOperand) {\n+        CoreFunctionType type = CoreFunctionType.getByName(expr.getOperator());\n+        switch (type) {\n+            case IS_NULL:\n+                return leftOperand + \" IS NULL \";\n+            case NOT_NULL:\n+                return leftOperand + \" IS NOT NULL \";\n+            case IN:\n+                return leftOperand + \" IN (\" + rightOperand + \") \";\n+            case NOT_IN:\n+                return leftOperand + \" NOT IN (\" + rightOperand + \") \";\n+            case EQUALS_TO:\n+                return leftOperand + \" = \" + rightOperand + \" \";\n+            case NOT_EQUALS_TO:\n+                return leftOperand + \" <> \" + rightOperand + \" \";\n+            case LIKE_TO:\n+                return leftOperand + \" LIKE \" + rightOperand + \" \";\n+            default:\n+                throw new UnsupportedOperationException(\"Queryparam: \" + expr + \" not supported\");\n+        }\n+    }\n+    private ProcessInstanceWithVarsDesc toProcessInstanceWithVarsDesc(Object[] row) {\n+        return new ProcessInstanceWithVarsDesc(((Number) row[0]).longValue(),\n+                                               (String) row[1],\n+                                               (String) row[2],\n+                                               (String) row[3],\n+                                               ((Number) row[4]).intValue(),\n+                                               (String) row[5],\n+                                               (Date) row[6],\n+                                               (String) row[7],\n+                                               (String) row[8]);\n+    }\n+\n+    private void addPagination(Query query, QueryContext context) {\n+        if (context.getCount() > 0) {\n+            query.setFirstResult(context.getOffset());\n+            query.setMaxResults(context.getCount());\n+        }\n+    }\n+\n+    public List<org.jbpm.services.api.model.UserTaskInstanceWithPotOwnerDesc> queryUserTasksByVariables(List<QueryParam> attributes,\n+                                                                                                        List<QueryParam> variables,\n+                                                                                                        List<QueryParam> processVariables,\n+                                                                                                        List<String> owners,\n+                                                                                                        int processType,\n+                                                                                                        String varPrefix,\n+                                                                                                        QueryContext queryContext) {\n+        EntityManager entityManager = emf.createEntityManager();\n+        StringBuilder globalWhere = new StringBuilder();\n+        StringBuilder derivedTables = new StringBuilder();\n+        if (!variables.isEmpty()) {\n+            List<String> conditions = new ArrayList<>();\n+            variables.stream().forEach((expr) -> conditions.add(\"(name = :V_NAME_\" + expr.getColumn() + \" AND \" + computeExpression(expr, \"value\", \":V_VALUE_\" + expr.getColumn()) + \")\\n\"));\n+            String where = String.join(\" OR \", conditions);\n+            derivedTables.append(\"INNER JOIN (\\n\" +\n+                                 \"SELECT taskId \\n\" +\n+                                 \"FROM TaskVariableImpl \\n\" +\n+                                 \"WHERE type = 0 AND (\" + where + \")\\n\" +\n+                                 \"GROUP BY taskId \\n\" +\n+                                 \"HAVING COUNT(*) = :NUMBER_OF_TASKVARS \\n\" +\n+                                 \") TABLE_TASK_VAR ON TABLE_TASK_VAR.taskId = task.id  \\n\");\n+        }\n+\n+        if (!processVariables.isEmpty()) {\n+            List<String> conditions = new ArrayList<>();\n+            processVariables.stream().forEach((expr) -> conditions.add(\"(A1.variableId = :P_NAME_\" + expr.getColumn() + \" AND \" + computeExpression(expr, \"A1.value\", \":P_VALUE_\" + expr.getColumn()) + \")\\n\"));\n+            String where = String.join(\" OR \", conditions);\n+            derivedTables.append(\"INNER JOIN (\" +\n+                                 \"SELECT A1.processInstanceId \\n\" +\n+                                 \"FROM VariableInstanceLog A1 \\n\" +\n+                                 \"LEFT JOIN VariableInstanceLog A2 ON A1.processId = A2.processId AND A1.processInstanceId = A2.processInstanceId AND A1.variableInstanceId = A2.variableInstanceId AND A2.id > A1.id  \\n\" +\n+                                 \"WHERE A2.id IS NULL AND (\" + where + \") \" +\n+                                 \"GROUP BY A1.processInstanceId \" +\n+                                 \"HAVING COUNT(*) = :NUMBER_OF_PROCVARS \" +\n+                                 \") TABLE_PROC_VAR ON TABLE_PROC_VAR.processInstanceId = pil.processInstanceId \\n\");\n+        }\n+\n+        if (!owners.isEmpty()) {\n+            derivedTables.append(\"INNER JOIN ( \\n\" +\n+                             \"           SELECT DISTINCT po.task_id \\n\" +\n+                             \"           FROM PeopleAssignments_PotOwners po \\n\" +\n+                             \"           WHERE po.entity_id IN (:owners) \\n\" +\n+                             \"           GROUP BY po.task_id \\n\" +\n+                             \"           HAVING COUNT(po.entity_id) = :num_owners \\n\" +\n+                                 \") pot ON pot.task_id = task.id \");\n+        }\n+\n+        attributes.stream().forEach((expr) -> globalWhere.append(\" AND \" + computeExpression(expr, expr.getColumn(), \":ATTR_\" + expr.getColumn())));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f04f50355ec285330b3467d42754a036a04b1db3"}, "originalPosition": 226}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODY4OTE3Mg==", "bodyText": "Please remove the extra parentheses around \"var\"\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    variables.stream().filter(e -> e.getObjectValue() != null).forEach((var) -> query.setParameter(\"V_VALUE_\" + var.getColumn(), var.getObjectValue()));\n          \n          \n            \n                    variables.stream().filter(e -> e.getObjectValue() != null).forEach(var -> query.setParameter(\"V_VALUE_\" + var.getColumn(), var.getObjectValue()));", "url": "https://github.com/kiegroup/jbpm/pull/1615#discussion_r408689172", "createdAt": "2020-04-15T09:00:56Z", "author": {"login": "afalhambra"}, "path": "jbpm-services/jbpm-kie-services/src/main/java/org/jbpm/kie/services/impl/AbstractAdvanceRuntimeDataServiceImpl.java", "diffHunk": "@@ -0,0 +1,346 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.jbpm.kie.services.impl;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import javax.persistence.EntityManager;\n+import javax.persistence.EntityManagerFactory;\n+import javax.persistence.Query;\n+\n+import org.dashbuilder.dataset.filter.CoreFunctionType;\n+import org.jbpm.kie.services.impl.model.ProcessInstanceWithVarsDesc;\n+import org.jbpm.kie.services.impl.model.UserTaskInstanceWithPotOwnerDesc;\n+import org.jbpm.services.api.query.model.QueryParam;\n+import org.jbpm.shared.services.impl.QueryManager;\n+import org.jbpm.shared.services.impl.TransactionalCommandService;\n+import org.jbpm.shared.services.impl.commands.QueryNameCommand;\n+import org.kie.api.runtime.query.QueryContext;\n+\n+import static java.util.Collections.singletonMap;\n+\n+public abstract class AbstractAdvanceRuntimeDataServiceImpl {\n+\n+    private static final String ID_LIST = \"idList\";\n+    private EntityManagerFactory emf;\n+    private TransactionalCommandService commandService;\n+\n+    public AbstractAdvanceRuntimeDataServiceImpl() {\n+        QueryManager.get().addNamedQueries(\"META-INF/Servicesorm.xml\");\n+    }\n+    public void setCommandService(TransactionalCommandService commandService) {\n+        this.commandService = commandService;\n+    }\n+\n+    public void setEmf(EntityManagerFactory emf) {\n+        this.emf = emf;\n+    }\n+\n+\n+    public List<org.jbpm.services.api.model.ProcessInstanceWithVarsDesc> queryProcessByVariables(List<QueryParam> attributes,\n+                                                                                                 List<QueryParam> variables,\n+                                                                                                 int processType,\n+                                                                                                 String varPrefix,\n+                                                                                                 QueryContext queryContext) {\n+        EntityManager entityManager = emf.createEntityManager();\n+\n+        // first step is to filter the data creating a derived tables and pivoting var - rows to columns (only the variables we are interested to filter)\n+        StringBuilder derivedTables = new StringBuilder();\n+        if (!variables.isEmpty()) {\n+            List<String> conditions = new ArrayList<>();\n+            variables.stream().forEach(expr -> conditions.add(\"(A1.variableId = :NAME_\" + expr.getColumn() + \" AND \" + computeExpression(expr, \"A1.value\", \":VALUE_\" + expr.getColumn()) + \")\\n\"));\n+            String where = String.join(\" OR \", conditions);\n+            derivedTables.append(\"INNER JOIN (\" +\n+                                 \"SELECT A1.processInstanceId \\n\" +\n+                                 \"FROM VariableInstanceLog A1 \\n\" +\n+                                 \"LEFT JOIN VariableInstanceLog A2 ON A1.processId = A2.processId AND A1.processInstanceId = A2.processInstanceId AND A1.variableInstanceId = A2.variableInstanceId AND A2.id > A1.id  \\n\" +\n+                                 \"WHERE A2.id IS NULL AND (\" + where + \") \" +\n+                                 \"GROUP BY A1.processInstanceId \" +\n+                                 \"HAVING COUNT(*) = :NUMBER_OF_VARS \" +\n+                                 \") TABLE_VAR ON TABLE_VAR.processInstanceId = pil.processInstanceId \\n\");\n+        }\n+\n+        StringBuilder globalWhere = new StringBuilder();\n+        attributes.stream().forEach(expr -> globalWhere.append(\" AND \" + computeExpression(expr, expr.getColumn(), \":ATTR_\" + expr.getColumn())));\n+\n+        String procSQLString =\n+                \" SELECT DISTINCT pil.processInstanceId \" +\n+                               \" FROM ProcessInstanceLog pil \\n \" +\n+                               derivedTables +\n+                               \" WHERE pil.processType = :processType \" + globalWhere +\n+                               \" ORDER BY pil.processInstanceId ASC \";\n+\n+        Query query = entityManager.createNativeQuery(procSQLString);\n+        variables.stream().forEach(var -> query.setParameter(\"NAME_\" + var.getColumn(), varPrefix + var.getColumn()));\n+        variables.stream().filter(e -> e.getObjectValue() != null).forEach(var -> query.setParameter(\"VALUE_\" + var.getColumn(), var.getObjectValue()));\n+        attributes.stream().filter(e -> e.getObjectValue() != null).forEach((entry) -> query.setParameter(\"ATTR_\" + entry.getColumn(), entry.getObjectValue()));\n+\n+        if (!variables.isEmpty()) {\n+            query.setParameter(\"NUMBER_OF_VARS\", variables.size());\n+        }\n+        query.setParameter(\"processType\", processType);\n+\n+        addPagination(query, queryContext);\n+        List<Number> ids = query.getResultList();\n+        if (ids.isEmpty()) {\n+            return Collections.emptyList();\n+        }\n+\n+        // now we get the information\n+\n+        List<Object[]> procRows = commandService.execute(new QueryNameCommand<List<Object[]>>(\"GetProcessInstanceByIdList\", singletonMap(ID_LIST, ids)));\n+        List<Object[]> varRows = commandService.execute(new QueryNameCommand<List<Object[]>>(\"GetVariablesByProcessInstanceIdList\", singletonMap(ID_LIST, ids)));\n+\n+        int currentVarIdx = 0;\n+        List<org.jbpm.services.api.model.ProcessInstanceWithVarsDesc> data = new ArrayList<>();\n+        for (Object[] row : procRows) {\n+            ProcessInstanceWithVarsDesc pwv = toProcessInstanceWithVarsDesc(row);\n+\n+            Map<String, Object> vars = new HashMap<>();\n+            pwv.setVariables(vars);\n+\n+            Map<String, Object> extra = new HashMap<>();\n+            pwv.setExtraData(extra);\n+            while (currentVarIdx < varRows.size() && row[0].equals(varRows.get(currentVarIdx)[0])) {\n+                String name = (String) varRows.get(currentVarIdx)[1];\n+                if (!varPrefix.isEmpty() && name.startsWith(varPrefix)) {\n+                    extra.put(name.substring(varPrefix.length()), varRows.get(currentVarIdx)[2]);\n+                } else {\n+                    vars.put(name, varRows.get(currentVarIdx)[2]);\n+                }\n+                currentVarIdx++;\n+            }\n+            data.add(pwv);\n+        }\n+\n+        entityManager.close();\n+        return data;\n+    }\n+\n+    private String computeExpression(QueryParam expr, String leftOperand, String rightOperand) {\n+        CoreFunctionType type = CoreFunctionType.getByName(expr.getOperator());\n+        switch (type) {\n+            case IS_NULL:\n+                return leftOperand + \" IS NULL \";\n+            case NOT_NULL:\n+                return leftOperand + \" IS NOT NULL \";\n+            case IN:\n+                return leftOperand + \" IN (\" + rightOperand + \") \";\n+            case NOT_IN:\n+                return leftOperand + \" NOT IN (\" + rightOperand + \") \";\n+            case EQUALS_TO:\n+                return leftOperand + \" = \" + rightOperand + \" \";\n+            case NOT_EQUALS_TO:\n+                return leftOperand + \" <> \" + rightOperand + \" \";\n+            case LIKE_TO:\n+                return leftOperand + \" LIKE \" + rightOperand + \" \";\n+            default:\n+                throw new UnsupportedOperationException(\"Queryparam: \" + expr + \" not supported\");\n+        }\n+    }\n+    private ProcessInstanceWithVarsDesc toProcessInstanceWithVarsDesc(Object[] row) {\n+        return new ProcessInstanceWithVarsDesc(((Number) row[0]).longValue(),\n+                                               (String) row[1],\n+                                               (String) row[2],\n+                                               (String) row[3],\n+                                               ((Number) row[4]).intValue(),\n+                                               (String) row[5],\n+                                               (Date) row[6],\n+                                               (String) row[7],\n+                                               (String) row[8]);\n+    }\n+\n+    private void addPagination(Query query, QueryContext context) {\n+        if (context.getCount() > 0) {\n+            query.setFirstResult(context.getOffset());\n+            query.setMaxResults(context.getCount());\n+        }\n+    }\n+\n+    public List<org.jbpm.services.api.model.UserTaskInstanceWithPotOwnerDesc> queryUserTasksByVariables(List<QueryParam> attributes,\n+                                                                                                        List<QueryParam> variables,\n+                                                                                                        List<QueryParam> processVariables,\n+                                                                                                        List<String> owners,\n+                                                                                                        int processType,\n+                                                                                                        String varPrefix,\n+                                                                                                        QueryContext queryContext) {\n+        EntityManager entityManager = emf.createEntityManager();\n+        StringBuilder globalWhere = new StringBuilder();\n+        StringBuilder derivedTables = new StringBuilder();\n+        if (!variables.isEmpty()) {\n+            List<String> conditions = new ArrayList<>();\n+            variables.stream().forEach((expr) -> conditions.add(\"(name = :V_NAME_\" + expr.getColumn() + \" AND \" + computeExpression(expr, \"value\", \":V_VALUE_\" + expr.getColumn()) + \")\\n\"));\n+            String where = String.join(\" OR \", conditions);\n+            derivedTables.append(\"INNER JOIN (\\n\" +\n+                                 \"SELECT taskId \\n\" +\n+                                 \"FROM TaskVariableImpl \\n\" +\n+                                 \"WHERE type = 0 AND (\" + where + \")\\n\" +\n+                                 \"GROUP BY taskId \\n\" +\n+                                 \"HAVING COUNT(*) = :NUMBER_OF_TASKVARS \\n\" +\n+                                 \") TABLE_TASK_VAR ON TABLE_TASK_VAR.taskId = task.id  \\n\");\n+        }\n+\n+        if (!processVariables.isEmpty()) {\n+            List<String> conditions = new ArrayList<>();\n+            processVariables.stream().forEach((expr) -> conditions.add(\"(A1.variableId = :P_NAME_\" + expr.getColumn() + \" AND \" + computeExpression(expr, \"A1.value\", \":P_VALUE_\" + expr.getColumn()) + \")\\n\"));\n+            String where = String.join(\" OR \", conditions);\n+            derivedTables.append(\"INNER JOIN (\" +\n+                                 \"SELECT A1.processInstanceId \\n\" +\n+                                 \"FROM VariableInstanceLog A1 \\n\" +\n+                                 \"LEFT JOIN VariableInstanceLog A2 ON A1.processId = A2.processId AND A1.processInstanceId = A2.processInstanceId AND A1.variableInstanceId = A2.variableInstanceId AND A2.id > A1.id  \\n\" +\n+                                 \"WHERE A2.id IS NULL AND (\" + where + \") \" +\n+                                 \"GROUP BY A1.processInstanceId \" +\n+                                 \"HAVING COUNT(*) = :NUMBER_OF_PROCVARS \" +\n+                                 \") TABLE_PROC_VAR ON TABLE_PROC_VAR.processInstanceId = pil.processInstanceId \\n\");\n+        }\n+\n+        if (!owners.isEmpty()) {\n+            derivedTables.append(\"INNER JOIN ( \\n\" +\n+                             \"           SELECT DISTINCT po.task_id \\n\" +\n+                             \"           FROM PeopleAssignments_PotOwners po \\n\" +\n+                             \"           WHERE po.entity_id IN (:owners) \\n\" +\n+                             \"           GROUP BY po.task_id \\n\" +\n+                             \"           HAVING COUNT(po.entity_id) = :num_owners \\n\" +\n+                                 \") pot ON pot.task_id = task.id \");\n+        }\n+\n+        attributes.stream().forEach((expr) -> globalWhere.append(\" AND \" + computeExpression(expr, expr.getColumn(), \":ATTR_\" + expr.getColumn())));\n+\n+        String procSQLString = \"SELECT DISTINCT task.id \" +\n+                               \" FROM Task task \" +\n+                               \" INNER JOIN ProcessInstanceLog pil ON pil.processInstanceId = task.processInstanceId \\n \" +\n+                               derivedTables +\n+                               \" WHERE  pil.processType = :processType \" + globalWhere +\n+                               \" ORDER BY task.id ASC \";\n+\n+        Query query = entityManager.createNativeQuery(procSQLString);\n+        variables.stream().forEach(var -> query.setParameter(\"V_NAME_\" + var.getColumn(), var.getColumn()));\n+        variables.stream().filter(e -> e.getObjectValue() != null).forEach((var) -> query.setParameter(\"V_VALUE_\" + var.getColumn(), var.getObjectValue()));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f04f50355ec285330b3467d42754a036a04b1db3"}, "originalPosition": 237}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODY4OTQ2NA==", "bodyText": "Please remove the extra parentheses around \"var\"\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    processVariables.stream().filter(e -> e.getObjectValue() != null).forEach((var) -> query.setParameter(\"P_VALUE_\" + var.getColumn(), var.getObjectValue()));\n          \n          \n            \n                    processVariables.stream().filter(e -> e.getObjectValue() != null).forEach(var -> query.setParameter(\"P_VALUE_\" + var.getColumn(), var.getObjectValue()));", "url": "https://github.com/kiegroup/jbpm/pull/1615#discussion_r408689464", "createdAt": "2020-04-15T09:01:23Z", "author": {"login": "afalhambra"}, "path": "jbpm-services/jbpm-kie-services/src/main/java/org/jbpm/kie/services/impl/AbstractAdvanceRuntimeDataServiceImpl.java", "diffHunk": "@@ -0,0 +1,346 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.jbpm.kie.services.impl;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import javax.persistence.EntityManager;\n+import javax.persistence.EntityManagerFactory;\n+import javax.persistence.Query;\n+\n+import org.dashbuilder.dataset.filter.CoreFunctionType;\n+import org.jbpm.kie.services.impl.model.ProcessInstanceWithVarsDesc;\n+import org.jbpm.kie.services.impl.model.UserTaskInstanceWithPotOwnerDesc;\n+import org.jbpm.services.api.query.model.QueryParam;\n+import org.jbpm.shared.services.impl.QueryManager;\n+import org.jbpm.shared.services.impl.TransactionalCommandService;\n+import org.jbpm.shared.services.impl.commands.QueryNameCommand;\n+import org.kie.api.runtime.query.QueryContext;\n+\n+import static java.util.Collections.singletonMap;\n+\n+public abstract class AbstractAdvanceRuntimeDataServiceImpl {\n+\n+    private static final String ID_LIST = \"idList\";\n+    private EntityManagerFactory emf;\n+    private TransactionalCommandService commandService;\n+\n+    public AbstractAdvanceRuntimeDataServiceImpl() {\n+        QueryManager.get().addNamedQueries(\"META-INF/Servicesorm.xml\");\n+    }\n+    public void setCommandService(TransactionalCommandService commandService) {\n+        this.commandService = commandService;\n+    }\n+\n+    public void setEmf(EntityManagerFactory emf) {\n+        this.emf = emf;\n+    }\n+\n+\n+    public List<org.jbpm.services.api.model.ProcessInstanceWithVarsDesc> queryProcessByVariables(List<QueryParam> attributes,\n+                                                                                                 List<QueryParam> variables,\n+                                                                                                 int processType,\n+                                                                                                 String varPrefix,\n+                                                                                                 QueryContext queryContext) {\n+        EntityManager entityManager = emf.createEntityManager();\n+\n+        // first step is to filter the data creating a derived tables and pivoting var - rows to columns (only the variables we are interested to filter)\n+        StringBuilder derivedTables = new StringBuilder();\n+        if (!variables.isEmpty()) {\n+            List<String> conditions = new ArrayList<>();\n+            variables.stream().forEach(expr -> conditions.add(\"(A1.variableId = :NAME_\" + expr.getColumn() + \" AND \" + computeExpression(expr, \"A1.value\", \":VALUE_\" + expr.getColumn()) + \")\\n\"));\n+            String where = String.join(\" OR \", conditions);\n+            derivedTables.append(\"INNER JOIN (\" +\n+                                 \"SELECT A1.processInstanceId \\n\" +\n+                                 \"FROM VariableInstanceLog A1 \\n\" +\n+                                 \"LEFT JOIN VariableInstanceLog A2 ON A1.processId = A2.processId AND A1.processInstanceId = A2.processInstanceId AND A1.variableInstanceId = A2.variableInstanceId AND A2.id > A1.id  \\n\" +\n+                                 \"WHERE A2.id IS NULL AND (\" + where + \") \" +\n+                                 \"GROUP BY A1.processInstanceId \" +\n+                                 \"HAVING COUNT(*) = :NUMBER_OF_VARS \" +\n+                                 \") TABLE_VAR ON TABLE_VAR.processInstanceId = pil.processInstanceId \\n\");\n+        }\n+\n+        StringBuilder globalWhere = new StringBuilder();\n+        attributes.stream().forEach(expr -> globalWhere.append(\" AND \" + computeExpression(expr, expr.getColumn(), \":ATTR_\" + expr.getColumn())));\n+\n+        String procSQLString =\n+                \" SELECT DISTINCT pil.processInstanceId \" +\n+                               \" FROM ProcessInstanceLog pil \\n \" +\n+                               derivedTables +\n+                               \" WHERE pil.processType = :processType \" + globalWhere +\n+                               \" ORDER BY pil.processInstanceId ASC \";\n+\n+        Query query = entityManager.createNativeQuery(procSQLString);\n+        variables.stream().forEach(var -> query.setParameter(\"NAME_\" + var.getColumn(), varPrefix + var.getColumn()));\n+        variables.stream().filter(e -> e.getObjectValue() != null).forEach(var -> query.setParameter(\"VALUE_\" + var.getColumn(), var.getObjectValue()));\n+        attributes.stream().filter(e -> e.getObjectValue() != null).forEach((entry) -> query.setParameter(\"ATTR_\" + entry.getColumn(), entry.getObjectValue()));\n+\n+        if (!variables.isEmpty()) {\n+            query.setParameter(\"NUMBER_OF_VARS\", variables.size());\n+        }\n+        query.setParameter(\"processType\", processType);\n+\n+        addPagination(query, queryContext);\n+        List<Number> ids = query.getResultList();\n+        if (ids.isEmpty()) {\n+            return Collections.emptyList();\n+        }\n+\n+        // now we get the information\n+\n+        List<Object[]> procRows = commandService.execute(new QueryNameCommand<List<Object[]>>(\"GetProcessInstanceByIdList\", singletonMap(ID_LIST, ids)));\n+        List<Object[]> varRows = commandService.execute(new QueryNameCommand<List<Object[]>>(\"GetVariablesByProcessInstanceIdList\", singletonMap(ID_LIST, ids)));\n+\n+        int currentVarIdx = 0;\n+        List<org.jbpm.services.api.model.ProcessInstanceWithVarsDesc> data = new ArrayList<>();\n+        for (Object[] row : procRows) {\n+            ProcessInstanceWithVarsDesc pwv = toProcessInstanceWithVarsDesc(row);\n+\n+            Map<String, Object> vars = new HashMap<>();\n+            pwv.setVariables(vars);\n+\n+            Map<String, Object> extra = new HashMap<>();\n+            pwv.setExtraData(extra);\n+            while (currentVarIdx < varRows.size() && row[0].equals(varRows.get(currentVarIdx)[0])) {\n+                String name = (String) varRows.get(currentVarIdx)[1];\n+                if (!varPrefix.isEmpty() && name.startsWith(varPrefix)) {\n+                    extra.put(name.substring(varPrefix.length()), varRows.get(currentVarIdx)[2]);\n+                } else {\n+                    vars.put(name, varRows.get(currentVarIdx)[2]);\n+                }\n+                currentVarIdx++;\n+            }\n+            data.add(pwv);\n+        }\n+\n+        entityManager.close();\n+        return data;\n+    }\n+\n+    private String computeExpression(QueryParam expr, String leftOperand, String rightOperand) {\n+        CoreFunctionType type = CoreFunctionType.getByName(expr.getOperator());\n+        switch (type) {\n+            case IS_NULL:\n+                return leftOperand + \" IS NULL \";\n+            case NOT_NULL:\n+                return leftOperand + \" IS NOT NULL \";\n+            case IN:\n+                return leftOperand + \" IN (\" + rightOperand + \") \";\n+            case NOT_IN:\n+                return leftOperand + \" NOT IN (\" + rightOperand + \") \";\n+            case EQUALS_TO:\n+                return leftOperand + \" = \" + rightOperand + \" \";\n+            case NOT_EQUALS_TO:\n+                return leftOperand + \" <> \" + rightOperand + \" \";\n+            case LIKE_TO:\n+                return leftOperand + \" LIKE \" + rightOperand + \" \";\n+            default:\n+                throw new UnsupportedOperationException(\"Queryparam: \" + expr + \" not supported\");\n+        }\n+    }\n+    private ProcessInstanceWithVarsDesc toProcessInstanceWithVarsDesc(Object[] row) {\n+        return new ProcessInstanceWithVarsDesc(((Number) row[0]).longValue(),\n+                                               (String) row[1],\n+                                               (String) row[2],\n+                                               (String) row[3],\n+                                               ((Number) row[4]).intValue(),\n+                                               (String) row[5],\n+                                               (Date) row[6],\n+                                               (String) row[7],\n+                                               (String) row[8]);\n+    }\n+\n+    private void addPagination(Query query, QueryContext context) {\n+        if (context.getCount() > 0) {\n+            query.setFirstResult(context.getOffset());\n+            query.setMaxResults(context.getCount());\n+        }\n+    }\n+\n+    public List<org.jbpm.services.api.model.UserTaskInstanceWithPotOwnerDesc> queryUserTasksByVariables(List<QueryParam> attributes,\n+                                                                                                        List<QueryParam> variables,\n+                                                                                                        List<QueryParam> processVariables,\n+                                                                                                        List<String> owners,\n+                                                                                                        int processType,\n+                                                                                                        String varPrefix,\n+                                                                                                        QueryContext queryContext) {\n+        EntityManager entityManager = emf.createEntityManager();\n+        StringBuilder globalWhere = new StringBuilder();\n+        StringBuilder derivedTables = new StringBuilder();\n+        if (!variables.isEmpty()) {\n+            List<String> conditions = new ArrayList<>();\n+            variables.stream().forEach((expr) -> conditions.add(\"(name = :V_NAME_\" + expr.getColumn() + \" AND \" + computeExpression(expr, \"value\", \":V_VALUE_\" + expr.getColumn()) + \")\\n\"));\n+            String where = String.join(\" OR \", conditions);\n+            derivedTables.append(\"INNER JOIN (\\n\" +\n+                                 \"SELECT taskId \\n\" +\n+                                 \"FROM TaskVariableImpl \\n\" +\n+                                 \"WHERE type = 0 AND (\" + where + \")\\n\" +\n+                                 \"GROUP BY taskId \\n\" +\n+                                 \"HAVING COUNT(*) = :NUMBER_OF_TASKVARS \\n\" +\n+                                 \") TABLE_TASK_VAR ON TABLE_TASK_VAR.taskId = task.id  \\n\");\n+        }\n+\n+        if (!processVariables.isEmpty()) {\n+            List<String> conditions = new ArrayList<>();\n+            processVariables.stream().forEach((expr) -> conditions.add(\"(A1.variableId = :P_NAME_\" + expr.getColumn() + \" AND \" + computeExpression(expr, \"A1.value\", \":P_VALUE_\" + expr.getColumn()) + \")\\n\"));\n+            String where = String.join(\" OR \", conditions);\n+            derivedTables.append(\"INNER JOIN (\" +\n+                                 \"SELECT A1.processInstanceId \\n\" +\n+                                 \"FROM VariableInstanceLog A1 \\n\" +\n+                                 \"LEFT JOIN VariableInstanceLog A2 ON A1.processId = A2.processId AND A1.processInstanceId = A2.processInstanceId AND A1.variableInstanceId = A2.variableInstanceId AND A2.id > A1.id  \\n\" +\n+                                 \"WHERE A2.id IS NULL AND (\" + where + \") \" +\n+                                 \"GROUP BY A1.processInstanceId \" +\n+                                 \"HAVING COUNT(*) = :NUMBER_OF_PROCVARS \" +\n+                                 \") TABLE_PROC_VAR ON TABLE_PROC_VAR.processInstanceId = pil.processInstanceId \\n\");\n+        }\n+\n+        if (!owners.isEmpty()) {\n+            derivedTables.append(\"INNER JOIN ( \\n\" +\n+                             \"           SELECT DISTINCT po.task_id \\n\" +\n+                             \"           FROM PeopleAssignments_PotOwners po \\n\" +\n+                             \"           WHERE po.entity_id IN (:owners) \\n\" +\n+                             \"           GROUP BY po.task_id \\n\" +\n+                             \"           HAVING COUNT(po.entity_id) = :num_owners \\n\" +\n+                                 \") pot ON pot.task_id = task.id \");\n+        }\n+\n+        attributes.stream().forEach((expr) -> globalWhere.append(\" AND \" + computeExpression(expr, expr.getColumn(), \":ATTR_\" + expr.getColumn())));\n+\n+        String procSQLString = \"SELECT DISTINCT task.id \" +\n+                               \" FROM Task task \" +\n+                               \" INNER JOIN ProcessInstanceLog pil ON pil.processInstanceId = task.processInstanceId \\n \" +\n+                               derivedTables +\n+                               \" WHERE  pil.processType = :processType \" + globalWhere +\n+                               \" ORDER BY task.id ASC \";\n+\n+        Query query = entityManager.createNativeQuery(procSQLString);\n+        variables.stream().forEach(var -> query.setParameter(\"V_NAME_\" + var.getColumn(), var.getColumn()));\n+        variables.stream().filter(e -> e.getObjectValue() != null).forEach((var) -> query.setParameter(\"V_VALUE_\" + var.getColumn(), var.getObjectValue()));\n+\n+        if (!variables.isEmpty()) {\n+            query.setParameter(\"NUMBER_OF_TASKVARS\", variables.size());\n+        }\n+\n+        processVariables.stream().forEach(var -> query.setParameter(\"P_NAME_\" + var.getColumn(), varPrefix + var.getColumn()));\n+        processVariables.stream().filter(e -> e.getObjectValue() != null).forEach((var) -> query.setParameter(\"P_VALUE_\" + var.getColumn(), var.getObjectValue()));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f04f50355ec285330b3467d42754a036a04b1db3"}, "originalPosition": 244}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODY5MTg4Ng==", "bodyText": "Would it not be better to have an Enum for these constants?", "url": "https://github.com/kiegroup/jbpm/pull/1615#discussion_r408691886", "createdAt": "2020-04-15T09:05:20Z", "author": {"login": "afalhambra"}, "path": "jbpm-services/jbpm-services-api/src/main/java/org/jbpm/services/api/AdvanceRuntimeDataService.java", "diffHunk": "@@ -0,0 +1,39 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.jbpm.services.api;\n+\n+import java.util.List;\n+\n+import org.jbpm.services.api.model.ProcessInstanceWithVarsDesc;\n+import org.jbpm.services.api.model.UserTaskInstanceWithPotOwnerDesc;\n+import org.jbpm.services.api.query.model.QueryParam;\n+import org.kie.api.runtime.query.QueryContext;\n+\n+public interface AdvanceRuntimeDataService {\n+\n+    public static String TASK_ATTR_NAME = \"TASK_NAME\";\n+    public static String TASK_ATTR_OWNER = \"TASK_OWNER\";\n+    public static String PROCESS_ATTR_INSTANCE_ID = \"PROCESS_INSTANCE_ID\";\n+    public static String PROCESS_ATTR_CORRELATION_KEY = \"PROCESS_CORRELATION_KEY\";\n+    public static String PROCESS_ATTR_DEFINITION_ID = \"PROCESS_DEFINITION_ID\";\n+    public static String PROCESS_ATTR_DEPLOYMENT_ID = \"PROCESS_DEPLOYMENT_ID\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f04f50355ec285330b3467d42754a036a04b1db3"}, "originalPosition": 33}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODY5MjExNQ==", "bodyText": "Would it not be better to have an Enum for these constants?", "url": "https://github.com/kiegroup/jbpm/pull/1615#discussion_r408692115", "createdAt": "2020-04-15T09:05:42Z", "author": {"login": "afalhambra"}, "path": "jbpm-case-mgmt/jbpm-case-mgmt-api/src/main/java/org/jbpm/casemgmt/api/AdvanceCaseRuntimeDataService.java", "diffHunk": "@@ -0,0 +1,45 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.jbpm.casemgmt.api;\n+\n+import java.util.List;\n+\n+import org.jbpm.services.api.model.ProcessInstanceWithVarsDesc;\n+import org.jbpm.services.api.model.UserTaskInstanceWithPotOwnerDesc;\n+import org.jbpm.services.api.query.model.QueryParam;\n+import org.kie.api.runtime.query.QueryContext;\n+\n+public interface AdvanceCaseRuntimeDataService {\n+\n+    public static String TASK_ATTR_NAME = \"TASK_NAME\";\n+    public static String TASK_ATTR_OWNER = \"TASK_OWNER\";\n+    public static String CASE_ATTR_INSTANCE_ID = \"PROCESS_INSTANCE_ID\";\n+    public static String CASE_ATTR_CORRELATION_KEY = \"PROCESS_CORRELATION_KEY\";\n+    public static String CASE_ATTR_DEFINITION_ID = \"PROCESS_DEFINITION_ID\";\n+    public static String CASE_ATTR_DEPLOYMENT_ID = \"PROCESS_DEPLOYMENT_ID\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f04f50355ec285330b3467d42754a036a04b1db3"}, "originalPosition": 33}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "f04f50355ec285330b3467d42754a036a04b1db3", "author": {"user": null}, "url": "https://github.com/kiegroup/jbpm/commit/f04f50355ec285330b3467d42754a036a04b1db3", "committedDate": "2020-04-14T06:53:04Z", "message": "[RHPAM-2552] Ability to Search for tasks by multiple task variables a nd / or process variables via the kie-server api.\n\nadded the possibility to query process/cases by variables"}, "afterCommit": {"oid": "17c40137da86b2cb4604496e634e2a7a623784ec", "author": {"user": null}, "url": "https://github.com/kiegroup/jbpm/commit/17c40137da86b2cb4604496e634e2a7a623784ec", "committedDate": "2020-04-17T07:07:13Z", "message": "[RHPAM-2552] Ability to Search for tasks by multiple task variables a nd / or process variables via the kie-server api.\n\nadded the possibility to query process/cases by variables"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ec84d965517b278f53051e64acf8230e885957a3", "author": {"user": null}, "url": "https://github.com/kiegroup/jbpm/commit/ec84d965517b278f53051e64acf8230e885957a3", "committedDate": "2020-04-20T09:06:02Z", "message": "[RHPAM-2552] Ability to Search for tasks by multiple task variables a nd / or process variables via the kie-server api.\n\nadded the possibility to query process/cases by variables"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "17c40137da86b2cb4604496e634e2a7a623784ec", "author": {"user": null}, "url": "https://github.com/kiegroup/jbpm/commit/17c40137da86b2cb4604496e634e2a7a623784ec", "committedDate": "2020-04-17T07:07:13Z", "message": "[RHPAM-2552] Ability to Search for tasks by multiple task variables a nd / or process variables via the kie-server api.\n\nadded the possibility to query process/cases by variables"}, "afterCommit": {"oid": "ec84d965517b278f53051e64acf8230e885957a3", "author": {"user": null}, "url": "https://github.com/kiegroup/jbpm/commit/ec84d965517b278f53051e64acf8230e885957a3", "committedDate": "2020-04-20T09:06:02Z", "message": "[RHPAM-2552] Ability to Search for tasks by multiple task variables a nd / or process variables via the kie-server api.\n\nadded the possibility to query process/cases by variables"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk2NDUyMzgz", "url": "https://github.com/kiegroup/jbpm/pull/1615#pullrequestreview-396452383", "createdAt": "2020-04-20T13:28:51Z", "commit": {"oid": "ec84d965517b278f53051e64acf8230e885957a3"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1063, "cost": 1, "resetAt": "2021-11-01T15:33:45Z"}}}