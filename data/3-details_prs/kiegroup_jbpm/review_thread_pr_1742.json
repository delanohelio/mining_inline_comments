{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDc0MDI4MTc1", "number": 1742, "reviewThreads": {"totalCount": 12, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QwNzoxNTo0MVrOEdF6jg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QxMToxNjo1OVrOEdLGrg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk4OTQxMDcwOnYy", "diffSide": "RIGHT", "path": "jbpm-bpmn2/src/main/java/org/jbpm/bpmn2/xml/ProcessHandler.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QwNzoxNTo0MVrOHIDamA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QwNzoxNTo0MVrOHIDamA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODIwNjYxNg==", "bodyText": "String concatenation should be done using append method instead. And I would add a delimiter character to show a cleaner message when more than link is wrong, otherwise it may be confusing.\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        errors.append(\"\\nThere is not connection from any throw link to these catch links \"+unconnectedTarget.stream().map(IntermediateLink::getUniqueId).collect(Collectors.joining()));\n          \n          \n            \n                        errors.append(\"\\nThere is not connection from any throw link to these catch links \").append(unconnectedTarget.stream().map(IntermediateLink::getUniqueId).collect(Collectors.joining(\", \"))));", "url": "https://github.com/kiegroup/jbpm/pull/1742#discussion_r478206616", "createdAt": "2020-08-27T07:15:41Z", "author": {"login": "afalhambra"}, "path": "jbpm-bpmn2/src/main/java/org/jbpm/bpmn2/xml/ProcessHandler.java", "diffHunk": "@@ -201,73 +202,83 @@ public Object end(final String uri, final String localName,\n \t\treturn process;\n \t}\n \t\n-\t public static void linkIntermediateLinks(NodeContainer process,\n-\t            List<IntermediateLink> links) {\n-\n \n-        if (null != links) {\n-            List<IntermediateLink> errors = links.stream().filter(l -> l.getName() == null || l.getName().isEmpty()).collect(toList());\n-            if (!errors.isEmpty()) {\n-                StringBuilder builder = new StringBuilder();\n-                for (IntermediateLink l : errors) {\n-                    builder.append(\"\\tIntermediate Link: \" + l.getUniqueId() + \"\\n\");\n+    public static void linkIntermediateLinks(NodeContainer process,List<IntermediateLink> links) {\n+        if (links == null) { \n+            return;\n+        }\n+        Map<String,IntermediateLink> catchLinks = new HashMap<>();\n+        Map<String,Collection<IntermediateLink>> throwLinks = new HashMap<>();\n+        Collection<IntermediateLink> notNameLinks = new ArrayList<>();\n+        Collection<IntermediateLink> duplicatedTarget = new LinkedHashSet<>();\n+        Collection<IntermediateLink> unconnectedTarget = new ArrayList<>();\n+        \n+        // collect errors and nodes in first loop\n+        for (IntermediateLink link : links) {\n+            if (link.getName() == null || link.getName().isEmpty()) {\n+                notNameLinks.add(link);\n+            }\n+            else if (link.isThrowLink()) {\n+                throwLinks.computeIfAbsent(link.getName(), s -> new ArrayList<>()).add(link);\n+            }\n+            else {\n+                IntermediateLink duplicateLink = catchLinks.putIfAbsent(link.getName(),link);\n+                if (duplicateLink != null) {\n+                    duplicatedTarget.add(duplicateLink);\n+                    duplicatedTarget.add(link);\n                 }\n-                throw new IllegalArgumentException(\"There are \" + errors.size() + \" links that does not have a name.\\n\" + builder.toString());\n             }\n-\t            // Search throw links\n-\t            ArrayList<IntermediateLink> throwLinks = new ArrayList<IntermediateLink>();\n-\t            for (IntermediateLink aLinks : links) {\n-\t                if (aLinks.isThrowLink()) {\n-\t                    throwLinks.add(aLinks);\n-\t                }\n-\t            }\n-\n-\t            // Look for catch links for a throw link\n-\t            for (IntermediateLink throwLink : throwLinks) {\n-\n-\t                ArrayList<IntermediateLink> linksWithSharedNames = new ArrayList<IntermediateLink>();\n-\t                for (IntermediateLink aLink : links) {\n-\t                    if (throwLink.getName().equals(aLink.getName())) {\n-\t                        linksWithSharedNames.add(aLink);\n-\t                    }\n-\t                }\n-\n-\t                if (linksWithSharedNames.size() < 2) {\n-\t                    throw new IllegalArgumentException(\n-\t                            \"There should be at least 2 link events to make a connection\");\n-\t                }\n-\n-\t                linksWithSharedNames.remove(throwLink);\n-\n-\t                // Make the connections\n-\t                Node t = findNodeByIdOrUniqueIdInMetadata(process,\n-\t                        throwLink.getUniqueId());\n-\n-\t                // connect throw to catch\n-\t                for (IntermediateLink catchLink : linksWithSharedNames) {\n-\n-\t                    Node c = findNodeByIdOrUniqueIdInMetadata(process,\n-\t                            catchLink.getUniqueId());\n-\t                    if (t != null && c != null) {\n-\t                        Connection result = new ConnectionImpl(t,\n-\t                                NodeImpl.CONNECTION_DEFAULT_TYPE, c,\n-\t                                NodeImpl.CONNECTION_DEFAULT_TYPE);\n-\t                        result.setMetaData(\"linkNodeHidden\", \"yes\");\n-\t                    }\n-\t                }\n-\n-\t                // Remove processed links\n-\t                links.remove(throwLink);\n-\t                links.removeAll(linksWithSharedNames);\n-\t            }\n-\n-\t            if (links.size() > 0) {\n-\t                throw new IllegalArgumentException(links.size()\n-\t                        + \" links were not processed\");\n-\t            }\n+        }\n \n-\t        }\n-\t }\n+        // second loop for connection\n+        for (IntermediateLink catchLink : catchLinks.values()) {\n+            Collection<IntermediateLink> associatedLinks = throwLinks.remove(catchLink.getName());\n+            if (associatedLinks != null) {\n+                // connect throw to catch\n+                Node catchNode = findNodeByIdOrUniqueIdInMetadata(process,catchLink.getUniqueId());\n+                if (catchNode != null) {\n+                    for (IntermediateLink throwLink : associatedLinks) {\n+                        Node throwNode = findNodeByIdOrUniqueIdInMetadata(process,\n+                            throwLink.getUniqueId());\n+                        if (throwNode != null) {\n+                            Connection result = new ConnectionImpl(throwNode,\n+                                NodeImpl.CONNECTION_DEFAULT_TYPE, catchNode,\n+                                NodeImpl.CONNECTION_DEFAULT_TYPE);\n+                            result.setMetaData(\"linkNodeHidden\", \"yes\");\n+                        }\n+                    }\n+                }\n+            }\n+            else {\n+                unconnectedTarget.add(catchLink);\n+            }\n+        }\n+        \n+        // throw exception if any error (this is done late in the process to show the user as much errors as possible) \n+        StringBuilder errors = new StringBuilder();\n+        if (!notNameLinks.isEmpty()) {\n+            errors.append(\"These nodes do not have a name \"+notNameLinks.stream().map(IntermediateLink::getUniqueId).collect(Collectors.joining()));\n+        }\n+        if (!duplicatedTarget.isEmpty()) {\n+            errors.append(\"\\nThere are multiple catch nodes with the same name \"+duplicatedTarget.stream().map(IntermediateLink::getUniqueId).collect(Collectors.joining()));\n+        }\n+        if (!unconnectedTarget.isEmpty()) {\n+            errors.append(\"\\nThere is not connection from any throw link to these catch links \"+unconnectedTarget.stream().map(IntermediateLink::getUniqueId).collect(Collectors.joining()));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5bb415761d5b798520e128f3510e294bf0f96301"}, "originalPosition": 152}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk4OTQxMDg4OnYy", "diffSide": "RIGHT", "path": "jbpm-bpmn2/src/main/java/org/jbpm/bpmn2/xml/ProcessHandler.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QwNzoxNTo0NlrOHIDavA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QwNzoxNTo0NlrOHIDavA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODIwNjY1Mg==", "bodyText": "String concatenation should be done using append method instead. And I would add a delimiter character to show a cleaner message when more than link is wrong, otherwise it may be confusing.\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        errors.append(\"\\nThere are multiple catch nodes with the same name \"+duplicatedTarget.stream().map(IntermediateLink::getUniqueId).collect(Collectors.joining()));\n          \n          \n            \n                        errors.append(\"\\nThere are multiple catch nodes with the same name \").append(duplicatedTarget.stream().map(IntermediateLink::getUniqueId).collect(Collectors.joining(\", \"))));", "url": "https://github.com/kiegroup/jbpm/pull/1742#discussion_r478206652", "createdAt": "2020-08-27T07:15:46Z", "author": {"login": "afalhambra"}, "path": "jbpm-bpmn2/src/main/java/org/jbpm/bpmn2/xml/ProcessHandler.java", "diffHunk": "@@ -201,73 +202,83 @@ public Object end(final String uri, final String localName,\n \t\treturn process;\n \t}\n \t\n-\t public static void linkIntermediateLinks(NodeContainer process,\n-\t            List<IntermediateLink> links) {\n-\n \n-        if (null != links) {\n-            List<IntermediateLink> errors = links.stream().filter(l -> l.getName() == null || l.getName().isEmpty()).collect(toList());\n-            if (!errors.isEmpty()) {\n-                StringBuilder builder = new StringBuilder();\n-                for (IntermediateLink l : errors) {\n-                    builder.append(\"\\tIntermediate Link: \" + l.getUniqueId() + \"\\n\");\n+    public static void linkIntermediateLinks(NodeContainer process,List<IntermediateLink> links) {\n+        if (links == null) { \n+            return;\n+        }\n+        Map<String,IntermediateLink> catchLinks = new HashMap<>();\n+        Map<String,Collection<IntermediateLink>> throwLinks = new HashMap<>();\n+        Collection<IntermediateLink> notNameLinks = new ArrayList<>();\n+        Collection<IntermediateLink> duplicatedTarget = new LinkedHashSet<>();\n+        Collection<IntermediateLink> unconnectedTarget = new ArrayList<>();\n+        \n+        // collect errors and nodes in first loop\n+        for (IntermediateLink link : links) {\n+            if (link.getName() == null || link.getName().isEmpty()) {\n+                notNameLinks.add(link);\n+            }\n+            else if (link.isThrowLink()) {\n+                throwLinks.computeIfAbsent(link.getName(), s -> new ArrayList<>()).add(link);\n+            }\n+            else {\n+                IntermediateLink duplicateLink = catchLinks.putIfAbsent(link.getName(),link);\n+                if (duplicateLink != null) {\n+                    duplicatedTarget.add(duplicateLink);\n+                    duplicatedTarget.add(link);\n                 }\n-                throw new IllegalArgumentException(\"There are \" + errors.size() + \" links that does not have a name.\\n\" + builder.toString());\n             }\n-\t            // Search throw links\n-\t            ArrayList<IntermediateLink> throwLinks = new ArrayList<IntermediateLink>();\n-\t            for (IntermediateLink aLinks : links) {\n-\t                if (aLinks.isThrowLink()) {\n-\t                    throwLinks.add(aLinks);\n-\t                }\n-\t            }\n-\n-\t            // Look for catch links for a throw link\n-\t            for (IntermediateLink throwLink : throwLinks) {\n-\n-\t                ArrayList<IntermediateLink> linksWithSharedNames = new ArrayList<IntermediateLink>();\n-\t                for (IntermediateLink aLink : links) {\n-\t                    if (throwLink.getName().equals(aLink.getName())) {\n-\t                        linksWithSharedNames.add(aLink);\n-\t                    }\n-\t                }\n-\n-\t                if (linksWithSharedNames.size() < 2) {\n-\t                    throw new IllegalArgumentException(\n-\t                            \"There should be at least 2 link events to make a connection\");\n-\t                }\n-\n-\t                linksWithSharedNames.remove(throwLink);\n-\n-\t                // Make the connections\n-\t                Node t = findNodeByIdOrUniqueIdInMetadata(process,\n-\t                        throwLink.getUniqueId());\n-\n-\t                // connect throw to catch\n-\t                for (IntermediateLink catchLink : linksWithSharedNames) {\n-\n-\t                    Node c = findNodeByIdOrUniqueIdInMetadata(process,\n-\t                            catchLink.getUniqueId());\n-\t                    if (t != null && c != null) {\n-\t                        Connection result = new ConnectionImpl(t,\n-\t                                NodeImpl.CONNECTION_DEFAULT_TYPE, c,\n-\t                                NodeImpl.CONNECTION_DEFAULT_TYPE);\n-\t                        result.setMetaData(\"linkNodeHidden\", \"yes\");\n-\t                    }\n-\t                }\n-\n-\t                // Remove processed links\n-\t                links.remove(throwLink);\n-\t                links.removeAll(linksWithSharedNames);\n-\t            }\n-\n-\t            if (links.size() > 0) {\n-\t                throw new IllegalArgumentException(links.size()\n-\t                        + \" links were not processed\");\n-\t            }\n+        }\n \n-\t        }\n-\t }\n+        // second loop for connection\n+        for (IntermediateLink catchLink : catchLinks.values()) {\n+            Collection<IntermediateLink> associatedLinks = throwLinks.remove(catchLink.getName());\n+            if (associatedLinks != null) {\n+                // connect throw to catch\n+                Node catchNode = findNodeByIdOrUniqueIdInMetadata(process,catchLink.getUniqueId());\n+                if (catchNode != null) {\n+                    for (IntermediateLink throwLink : associatedLinks) {\n+                        Node throwNode = findNodeByIdOrUniqueIdInMetadata(process,\n+                            throwLink.getUniqueId());\n+                        if (throwNode != null) {\n+                            Connection result = new ConnectionImpl(throwNode,\n+                                NodeImpl.CONNECTION_DEFAULT_TYPE, catchNode,\n+                                NodeImpl.CONNECTION_DEFAULT_TYPE);\n+                            result.setMetaData(\"linkNodeHidden\", \"yes\");\n+                        }\n+                    }\n+                }\n+            }\n+            else {\n+                unconnectedTarget.add(catchLink);\n+            }\n+        }\n+        \n+        // throw exception if any error (this is done late in the process to show the user as much errors as possible) \n+        StringBuilder errors = new StringBuilder();\n+        if (!notNameLinks.isEmpty()) {\n+            errors.append(\"These nodes do not have a name \"+notNameLinks.stream().map(IntermediateLink::getUniqueId).collect(Collectors.joining()));\n+        }\n+        if (!duplicatedTarget.isEmpty()) {\n+            errors.append(\"\\nThere are multiple catch nodes with the same name \"+duplicatedTarget.stream().map(IntermediateLink::getUniqueId).collect(Collectors.joining()));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5bb415761d5b798520e128f3510e294bf0f96301"}, "originalPosition": 149}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk4OTQxMTAxOnYy", "diffSide": "RIGHT", "path": "jbpm-bpmn2/src/main/java/org/jbpm/bpmn2/xml/ProcessHandler.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QwNzoxNTo1MFrOHIDa1Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QwNzoxNTo1MFrOHIDa1Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODIwNjY3Nw==", "bodyText": "String concatenation should be done using append method instead. And I would add a delimiter character to show a cleaner message when more than link is wrong, otherwise it may be confusing.\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        errors.append(\"These nodes do not have a name \"+notNameLinks.stream().map(IntermediateLink::getUniqueId).collect(Collectors.joining()));\n          \n          \n            \n                        errors.append(\"These nodes do not have a name \").append(notNameLinks.stream().map(IntermediateLink::getUniqueId).collect(Collectors.joining(\", \"))));", "url": "https://github.com/kiegroup/jbpm/pull/1742#discussion_r478206677", "createdAt": "2020-08-27T07:15:50Z", "author": {"login": "afalhambra"}, "path": "jbpm-bpmn2/src/main/java/org/jbpm/bpmn2/xml/ProcessHandler.java", "diffHunk": "@@ -201,73 +202,83 @@ public Object end(final String uri, final String localName,\n \t\treturn process;\n \t}\n \t\n-\t public static void linkIntermediateLinks(NodeContainer process,\n-\t            List<IntermediateLink> links) {\n-\n \n-        if (null != links) {\n-            List<IntermediateLink> errors = links.stream().filter(l -> l.getName() == null || l.getName().isEmpty()).collect(toList());\n-            if (!errors.isEmpty()) {\n-                StringBuilder builder = new StringBuilder();\n-                for (IntermediateLink l : errors) {\n-                    builder.append(\"\\tIntermediate Link: \" + l.getUniqueId() + \"\\n\");\n+    public static void linkIntermediateLinks(NodeContainer process,List<IntermediateLink> links) {\n+        if (links == null) { \n+            return;\n+        }\n+        Map<String,IntermediateLink> catchLinks = new HashMap<>();\n+        Map<String,Collection<IntermediateLink>> throwLinks = new HashMap<>();\n+        Collection<IntermediateLink> notNameLinks = new ArrayList<>();\n+        Collection<IntermediateLink> duplicatedTarget = new LinkedHashSet<>();\n+        Collection<IntermediateLink> unconnectedTarget = new ArrayList<>();\n+        \n+        // collect errors and nodes in first loop\n+        for (IntermediateLink link : links) {\n+            if (link.getName() == null || link.getName().isEmpty()) {\n+                notNameLinks.add(link);\n+            }\n+            else if (link.isThrowLink()) {\n+                throwLinks.computeIfAbsent(link.getName(), s -> new ArrayList<>()).add(link);\n+            }\n+            else {\n+                IntermediateLink duplicateLink = catchLinks.putIfAbsent(link.getName(),link);\n+                if (duplicateLink != null) {\n+                    duplicatedTarget.add(duplicateLink);\n+                    duplicatedTarget.add(link);\n                 }\n-                throw new IllegalArgumentException(\"There are \" + errors.size() + \" links that does not have a name.\\n\" + builder.toString());\n             }\n-\t            // Search throw links\n-\t            ArrayList<IntermediateLink> throwLinks = new ArrayList<IntermediateLink>();\n-\t            for (IntermediateLink aLinks : links) {\n-\t                if (aLinks.isThrowLink()) {\n-\t                    throwLinks.add(aLinks);\n-\t                }\n-\t            }\n-\n-\t            // Look for catch links for a throw link\n-\t            for (IntermediateLink throwLink : throwLinks) {\n-\n-\t                ArrayList<IntermediateLink> linksWithSharedNames = new ArrayList<IntermediateLink>();\n-\t                for (IntermediateLink aLink : links) {\n-\t                    if (throwLink.getName().equals(aLink.getName())) {\n-\t                        linksWithSharedNames.add(aLink);\n-\t                    }\n-\t                }\n-\n-\t                if (linksWithSharedNames.size() < 2) {\n-\t                    throw new IllegalArgumentException(\n-\t                            \"There should be at least 2 link events to make a connection\");\n-\t                }\n-\n-\t                linksWithSharedNames.remove(throwLink);\n-\n-\t                // Make the connections\n-\t                Node t = findNodeByIdOrUniqueIdInMetadata(process,\n-\t                        throwLink.getUniqueId());\n-\n-\t                // connect throw to catch\n-\t                for (IntermediateLink catchLink : linksWithSharedNames) {\n-\n-\t                    Node c = findNodeByIdOrUniqueIdInMetadata(process,\n-\t                            catchLink.getUniqueId());\n-\t                    if (t != null && c != null) {\n-\t                        Connection result = new ConnectionImpl(t,\n-\t                                NodeImpl.CONNECTION_DEFAULT_TYPE, c,\n-\t                                NodeImpl.CONNECTION_DEFAULT_TYPE);\n-\t                        result.setMetaData(\"linkNodeHidden\", \"yes\");\n-\t                    }\n-\t                }\n-\n-\t                // Remove processed links\n-\t                links.remove(throwLink);\n-\t                links.removeAll(linksWithSharedNames);\n-\t            }\n-\n-\t            if (links.size() > 0) {\n-\t                throw new IllegalArgumentException(links.size()\n-\t                        + \" links were not processed\");\n-\t            }\n+        }\n \n-\t        }\n-\t }\n+        // second loop for connection\n+        for (IntermediateLink catchLink : catchLinks.values()) {\n+            Collection<IntermediateLink> associatedLinks = throwLinks.remove(catchLink.getName());\n+            if (associatedLinks != null) {\n+                // connect throw to catch\n+                Node catchNode = findNodeByIdOrUniqueIdInMetadata(process,catchLink.getUniqueId());\n+                if (catchNode != null) {\n+                    for (IntermediateLink throwLink : associatedLinks) {\n+                        Node throwNode = findNodeByIdOrUniqueIdInMetadata(process,\n+                            throwLink.getUniqueId());\n+                        if (throwNode != null) {\n+                            Connection result = new ConnectionImpl(throwNode,\n+                                NodeImpl.CONNECTION_DEFAULT_TYPE, catchNode,\n+                                NodeImpl.CONNECTION_DEFAULT_TYPE);\n+                            result.setMetaData(\"linkNodeHidden\", \"yes\");\n+                        }\n+                    }\n+                }\n+            }\n+            else {\n+                unconnectedTarget.add(catchLink);\n+            }\n+        }\n+        \n+        // throw exception if any error (this is done late in the process to show the user as much errors as possible) \n+        StringBuilder errors = new StringBuilder();\n+        if (!notNameLinks.isEmpty()) {\n+            errors.append(\"These nodes do not have a name \"+notNameLinks.stream().map(IntermediateLink::getUniqueId).collect(Collectors.joining()));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5bb415761d5b798520e128f3510e294bf0f96301"}, "originalPosition": 146}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk4OTcyMTUyOnYy", "diffSide": "RIGHT", "path": "jbpm-bpmn2/src/main/java/org/jbpm/bpmn2/xml/ProcessHandler.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QwODo0NDozMVrOHIGc8w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QxMTo0NDoxMVrOHIMbhA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODI1NjM3MQ==", "bodyText": "typo\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    Collection<IntermediateLink> notNameLinks = new ArrayList<>();\n          \n          \n            \n                    Collection<IntermediateLink> noNameLinks = new ArrayList<>();", "url": "https://github.com/kiegroup/jbpm/pull/1742#discussion_r478256371", "createdAt": "2020-08-27T08:44:31Z", "author": {"login": "afalhambra"}, "path": "jbpm-bpmn2/src/main/java/org/jbpm/bpmn2/xml/ProcessHandler.java", "diffHunk": "@@ -201,73 +202,83 @@ public Object end(final String uri, final String localName,\n \t\treturn process;\n \t}\n \t\n-\t public static void linkIntermediateLinks(NodeContainer process,\n-\t            List<IntermediateLink> links) {\n-\n \n-        if (null != links) {\n-            List<IntermediateLink> errors = links.stream().filter(l -> l.getName() == null || l.getName().isEmpty()).collect(toList());\n-            if (!errors.isEmpty()) {\n-                StringBuilder builder = new StringBuilder();\n-                for (IntermediateLink l : errors) {\n-                    builder.append(\"\\tIntermediate Link: \" + l.getUniqueId() + \"\\n\");\n+    public static void linkIntermediateLinks(NodeContainer process,List<IntermediateLink> links) {\n+        if (links == null) { \n+            return;\n+        }\n+        Map<String,IntermediateLink> catchLinks = new HashMap<>();\n+        Map<String,Collection<IntermediateLink>> throwLinks = new HashMap<>();\n+        Collection<IntermediateLink> notNameLinks = new ArrayList<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5bb415761d5b798520e128f3510e294bf0f96301"}, "originalPosition": 44}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODM1NDMwOA==", "bodyText": "Ok", "url": "https://github.com/kiegroup/jbpm/pull/1742#discussion_r478354308", "createdAt": "2020-08-27T11:44:11Z", "author": {"login": "fjtirado"}, "path": "jbpm-bpmn2/src/main/java/org/jbpm/bpmn2/xml/ProcessHandler.java", "diffHunk": "@@ -201,73 +202,83 @@ public Object end(final String uri, final String localName,\n \t\treturn process;\n \t}\n \t\n-\t public static void linkIntermediateLinks(NodeContainer process,\n-\t            List<IntermediateLink> links) {\n-\n \n-        if (null != links) {\n-            List<IntermediateLink> errors = links.stream().filter(l -> l.getName() == null || l.getName().isEmpty()).collect(toList());\n-            if (!errors.isEmpty()) {\n-                StringBuilder builder = new StringBuilder();\n-                for (IntermediateLink l : errors) {\n-                    builder.append(\"\\tIntermediate Link: \" + l.getUniqueId() + \"\\n\");\n+    public static void linkIntermediateLinks(NodeContainer process,List<IntermediateLink> links) {\n+        if (links == null) { \n+            return;\n+        }\n+        Map<String,IntermediateLink> catchLinks = new HashMap<>();\n+        Map<String,Collection<IntermediateLink>> throwLinks = new HashMap<>();\n+        Collection<IntermediateLink> notNameLinks = new ArrayList<>();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODI1NjM3MQ=="}, "originalCommit": {"oid": "5bb415761d5b798520e128f3510e294bf0f96301"}, "originalPosition": 44}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk4OTcyNTYyOnYy", "diffSide": "RIGHT", "path": "jbpm-bpmn2/src/main/java/org/jbpm/bpmn2/xml/ProcessHandler.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QwODo0NTozMFrOHIGfgg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QxMTo0NDoyNlrOHIMcCQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODI1NzAyNg==", "bodyText": "typo\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    // throw exception if any error (this is done late in the process to show the user as much errors as possible) \n          \n          \n            \n                    // throw exception if any error (this is done later in the process to show the user as much errors as possible)", "url": "https://github.com/kiegroup/jbpm/pull/1742#discussion_r478257026", "createdAt": "2020-08-27T08:45:30Z", "author": {"login": "afalhambra"}, "path": "jbpm-bpmn2/src/main/java/org/jbpm/bpmn2/xml/ProcessHandler.java", "diffHunk": "@@ -201,73 +202,83 @@ public Object end(final String uri, final String localName,\n \t\treturn process;\n \t}\n \t\n-\t public static void linkIntermediateLinks(NodeContainer process,\n-\t            List<IntermediateLink> links) {\n-\n \n-        if (null != links) {\n-            List<IntermediateLink> errors = links.stream().filter(l -> l.getName() == null || l.getName().isEmpty()).collect(toList());\n-            if (!errors.isEmpty()) {\n-                StringBuilder builder = new StringBuilder();\n-                for (IntermediateLink l : errors) {\n-                    builder.append(\"\\tIntermediate Link: \" + l.getUniqueId() + \"\\n\");\n+    public static void linkIntermediateLinks(NodeContainer process,List<IntermediateLink> links) {\n+        if (links == null) { \n+            return;\n+        }\n+        Map<String,IntermediateLink> catchLinks = new HashMap<>();\n+        Map<String,Collection<IntermediateLink>> throwLinks = new HashMap<>();\n+        Collection<IntermediateLink> notNameLinks = new ArrayList<>();\n+        Collection<IntermediateLink> duplicatedTarget = new LinkedHashSet<>();\n+        Collection<IntermediateLink> unconnectedTarget = new ArrayList<>();\n+        \n+        // collect errors and nodes in first loop\n+        for (IntermediateLink link : links) {\n+            if (link.getName() == null || link.getName().isEmpty()) {\n+                notNameLinks.add(link);\n+            }\n+            else if (link.isThrowLink()) {\n+                throwLinks.computeIfAbsent(link.getName(), s -> new ArrayList<>()).add(link);\n+            }\n+            else {\n+                IntermediateLink duplicateLink = catchLinks.putIfAbsent(link.getName(),link);\n+                if (duplicateLink != null) {\n+                    duplicatedTarget.add(duplicateLink);\n+                    duplicatedTarget.add(link);\n                 }\n-                throw new IllegalArgumentException(\"There are \" + errors.size() + \" links that does not have a name.\\n\" + builder.toString());\n             }\n-\t            // Search throw links\n-\t            ArrayList<IntermediateLink> throwLinks = new ArrayList<IntermediateLink>();\n-\t            for (IntermediateLink aLinks : links) {\n-\t                if (aLinks.isThrowLink()) {\n-\t                    throwLinks.add(aLinks);\n-\t                }\n-\t            }\n-\n-\t            // Look for catch links for a throw link\n-\t            for (IntermediateLink throwLink : throwLinks) {\n-\n-\t                ArrayList<IntermediateLink> linksWithSharedNames = new ArrayList<IntermediateLink>();\n-\t                for (IntermediateLink aLink : links) {\n-\t                    if (throwLink.getName().equals(aLink.getName())) {\n-\t                        linksWithSharedNames.add(aLink);\n-\t                    }\n-\t                }\n-\n-\t                if (linksWithSharedNames.size() < 2) {\n-\t                    throw new IllegalArgumentException(\n-\t                            \"There should be at least 2 link events to make a connection\");\n-\t                }\n-\n-\t                linksWithSharedNames.remove(throwLink);\n-\n-\t                // Make the connections\n-\t                Node t = findNodeByIdOrUniqueIdInMetadata(process,\n-\t                        throwLink.getUniqueId());\n-\n-\t                // connect throw to catch\n-\t                for (IntermediateLink catchLink : linksWithSharedNames) {\n-\n-\t                    Node c = findNodeByIdOrUniqueIdInMetadata(process,\n-\t                            catchLink.getUniqueId());\n-\t                    if (t != null && c != null) {\n-\t                        Connection result = new ConnectionImpl(t,\n-\t                                NodeImpl.CONNECTION_DEFAULT_TYPE, c,\n-\t                                NodeImpl.CONNECTION_DEFAULT_TYPE);\n-\t                        result.setMetaData(\"linkNodeHidden\", \"yes\");\n-\t                    }\n-\t                }\n-\n-\t                // Remove processed links\n-\t                links.remove(throwLink);\n-\t                links.removeAll(linksWithSharedNames);\n-\t            }\n-\n-\t            if (links.size() > 0) {\n-\t                throw new IllegalArgumentException(links.size()\n-\t                        + \" links were not processed\");\n-\t            }\n+        }\n \n-\t        }\n-\t }\n+        // second loop for connection\n+        for (IntermediateLink catchLink : catchLinks.values()) {\n+            Collection<IntermediateLink> associatedLinks = throwLinks.remove(catchLink.getName());\n+            if (associatedLinks != null) {\n+                // connect throw to catch\n+                Node catchNode = findNodeByIdOrUniqueIdInMetadata(process,catchLink.getUniqueId());\n+                if (catchNode != null) {\n+                    for (IntermediateLink throwLink : associatedLinks) {\n+                        Node throwNode = findNodeByIdOrUniqueIdInMetadata(process,\n+                            throwLink.getUniqueId());\n+                        if (throwNode != null) {\n+                            Connection result = new ConnectionImpl(throwNode,\n+                                NodeImpl.CONNECTION_DEFAULT_TYPE, catchNode,\n+                                NodeImpl.CONNECTION_DEFAULT_TYPE);\n+                            result.setMetaData(\"linkNodeHidden\", \"yes\");\n+                        }\n+                    }\n+                }\n+            }\n+            else {\n+                unconnectedTarget.add(catchLink);\n+            }\n+        }\n+        \n+        // throw exception if any error (this is done late in the process to show the user as much errors as possible) ", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5bb415761d5b798520e128f3510e294bf0f96301"}, "originalPosition": 143}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODM0ODExOQ==", "bodyText": "I think late here is properly used, Im not doing it later, it is done late (meaning at the end)", "url": "https://github.com/kiegroup/jbpm/pull/1742#discussion_r478348119", "createdAt": "2020-08-27T11:32:14Z", "author": {"login": "fjtirado"}, "path": "jbpm-bpmn2/src/main/java/org/jbpm/bpmn2/xml/ProcessHandler.java", "diffHunk": "@@ -201,73 +202,83 @@ public Object end(final String uri, final String localName,\n \t\treturn process;\n \t}\n \t\n-\t public static void linkIntermediateLinks(NodeContainer process,\n-\t            List<IntermediateLink> links) {\n-\n \n-        if (null != links) {\n-            List<IntermediateLink> errors = links.stream().filter(l -> l.getName() == null || l.getName().isEmpty()).collect(toList());\n-            if (!errors.isEmpty()) {\n-                StringBuilder builder = new StringBuilder();\n-                for (IntermediateLink l : errors) {\n-                    builder.append(\"\\tIntermediate Link: \" + l.getUniqueId() + \"\\n\");\n+    public static void linkIntermediateLinks(NodeContainer process,List<IntermediateLink> links) {\n+        if (links == null) { \n+            return;\n+        }\n+        Map<String,IntermediateLink> catchLinks = new HashMap<>();\n+        Map<String,Collection<IntermediateLink>> throwLinks = new HashMap<>();\n+        Collection<IntermediateLink> notNameLinks = new ArrayList<>();\n+        Collection<IntermediateLink> duplicatedTarget = new LinkedHashSet<>();\n+        Collection<IntermediateLink> unconnectedTarget = new ArrayList<>();\n+        \n+        // collect errors and nodes in first loop\n+        for (IntermediateLink link : links) {\n+            if (link.getName() == null || link.getName().isEmpty()) {\n+                notNameLinks.add(link);\n+            }\n+            else if (link.isThrowLink()) {\n+                throwLinks.computeIfAbsent(link.getName(), s -> new ArrayList<>()).add(link);\n+            }\n+            else {\n+                IntermediateLink duplicateLink = catchLinks.putIfAbsent(link.getName(),link);\n+                if (duplicateLink != null) {\n+                    duplicatedTarget.add(duplicateLink);\n+                    duplicatedTarget.add(link);\n                 }\n-                throw new IllegalArgumentException(\"There are \" + errors.size() + \" links that does not have a name.\\n\" + builder.toString());\n             }\n-\t            // Search throw links\n-\t            ArrayList<IntermediateLink> throwLinks = new ArrayList<IntermediateLink>();\n-\t            for (IntermediateLink aLinks : links) {\n-\t                if (aLinks.isThrowLink()) {\n-\t                    throwLinks.add(aLinks);\n-\t                }\n-\t            }\n-\n-\t            // Look for catch links for a throw link\n-\t            for (IntermediateLink throwLink : throwLinks) {\n-\n-\t                ArrayList<IntermediateLink> linksWithSharedNames = new ArrayList<IntermediateLink>();\n-\t                for (IntermediateLink aLink : links) {\n-\t                    if (throwLink.getName().equals(aLink.getName())) {\n-\t                        linksWithSharedNames.add(aLink);\n-\t                    }\n-\t                }\n-\n-\t                if (linksWithSharedNames.size() < 2) {\n-\t                    throw new IllegalArgumentException(\n-\t                            \"There should be at least 2 link events to make a connection\");\n-\t                }\n-\n-\t                linksWithSharedNames.remove(throwLink);\n-\n-\t                // Make the connections\n-\t                Node t = findNodeByIdOrUniqueIdInMetadata(process,\n-\t                        throwLink.getUniqueId());\n-\n-\t                // connect throw to catch\n-\t                for (IntermediateLink catchLink : linksWithSharedNames) {\n-\n-\t                    Node c = findNodeByIdOrUniqueIdInMetadata(process,\n-\t                            catchLink.getUniqueId());\n-\t                    if (t != null && c != null) {\n-\t                        Connection result = new ConnectionImpl(t,\n-\t                                NodeImpl.CONNECTION_DEFAULT_TYPE, c,\n-\t                                NodeImpl.CONNECTION_DEFAULT_TYPE);\n-\t                        result.setMetaData(\"linkNodeHidden\", \"yes\");\n-\t                    }\n-\t                }\n-\n-\t                // Remove processed links\n-\t                links.remove(throwLink);\n-\t                links.removeAll(linksWithSharedNames);\n-\t            }\n-\n-\t            if (links.size() > 0) {\n-\t                throw new IllegalArgumentException(links.size()\n-\t                        + \" links were not processed\");\n-\t            }\n+        }\n \n-\t        }\n-\t }\n+        // second loop for connection\n+        for (IntermediateLink catchLink : catchLinks.values()) {\n+            Collection<IntermediateLink> associatedLinks = throwLinks.remove(catchLink.getName());\n+            if (associatedLinks != null) {\n+                // connect throw to catch\n+                Node catchNode = findNodeByIdOrUniqueIdInMetadata(process,catchLink.getUniqueId());\n+                if (catchNode != null) {\n+                    for (IntermediateLink throwLink : associatedLinks) {\n+                        Node throwNode = findNodeByIdOrUniqueIdInMetadata(process,\n+                            throwLink.getUniqueId());\n+                        if (throwNode != null) {\n+                            Connection result = new ConnectionImpl(throwNode,\n+                                NodeImpl.CONNECTION_DEFAULT_TYPE, catchNode,\n+                                NodeImpl.CONNECTION_DEFAULT_TYPE);\n+                            result.setMetaData(\"linkNodeHidden\", \"yes\");\n+                        }\n+                    }\n+                }\n+            }\n+            else {\n+                unconnectedTarget.add(catchLink);\n+            }\n+        }\n+        \n+        // throw exception if any error (this is done late in the process to show the user as much errors as possible) ", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODI1NzAyNg=="}, "originalCommit": {"oid": "5bb415761d5b798520e128f3510e294bf0f96301"}, "originalPosition": 143}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODM1NDQ0MQ==", "bodyText": "I changed to \" at the end\"", "url": "https://github.com/kiegroup/jbpm/pull/1742#discussion_r478354441", "createdAt": "2020-08-27T11:44:26Z", "author": {"login": "fjtirado"}, "path": "jbpm-bpmn2/src/main/java/org/jbpm/bpmn2/xml/ProcessHandler.java", "diffHunk": "@@ -201,73 +202,83 @@ public Object end(final String uri, final String localName,\n \t\treturn process;\n \t}\n \t\n-\t public static void linkIntermediateLinks(NodeContainer process,\n-\t            List<IntermediateLink> links) {\n-\n \n-        if (null != links) {\n-            List<IntermediateLink> errors = links.stream().filter(l -> l.getName() == null || l.getName().isEmpty()).collect(toList());\n-            if (!errors.isEmpty()) {\n-                StringBuilder builder = new StringBuilder();\n-                for (IntermediateLink l : errors) {\n-                    builder.append(\"\\tIntermediate Link: \" + l.getUniqueId() + \"\\n\");\n+    public static void linkIntermediateLinks(NodeContainer process,List<IntermediateLink> links) {\n+        if (links == null) { \n+            return;\n+        }\n+        Map<String,IntermediateLink> catchLinks = new HashMap<>();\n+        Map<String,Collection<IntermediateLink>> throwLinks = new HashMap<>();\n+        Collection<IntermediateLink> notNameLinks = new ArrayList<>();\n+        Collection<IntermediateLink> duplicatedTarget = new LinkedHashSet<>();\n+        Collection<IntermediateLink> unconnectedTarget = new ArrayList<>();\n+        \n+        // collect errors and nodes in first loop\n+        for (IntermediateLink link : links) {\n+            if (link.getName() == null || link.getName().isEmpty()) {\n+                notNameLinks.add(link);\n+            }\n+            else if (link.isThrowLink()) {\n+                throwLinks.computeIfAbsent(link.getName(), s -> new ArrayList<>()).add(link);\n+            }\n+            else {\n+                IntermediateLink duplicateLink = catchLinks.putIfAbsent(link.getName(),link);\n+                if (duplicateLink != null) {\n+                    duplicatedTarget.add(duplicateLink);\n+                    duplicatedTarget.add(link);\n                 }\n-                throw new IllegalArgumentException(\"There are \" + errors.size() + \" links that does not have a name.\\n\" + builder.toString());\n             }\n-\t            // Search throw links\n-\t            ArrayList<IntermediateLink> throwLinks = new ArrayList<IntermediateLink>();\n-\t            for (IntermediateLink aLinks : links) {\n-\t                if (aLinks.isThrowLink()) {\n-\t                    throwLinks.add(aLinks);\n-\t                }\n-\t            }\n-\n-\t            // Look for catch links for a throw link\n-\t            for (IntermediateLink throwLink : throwLinks) {\n-\n-\t                ArrayList<IntermediateLink> linksWithSharedNames = new ArrayList<IntermediateLink>();\n-\t                for (IntermediateLink aLink : links) {\n-\t                    if (throwLink.getName().equals(aLink.getName())) {\n-\t                        linksWithSharedNames.add(aLink);\n-\t                    }\n-\t                }\n-\n-\t                if (linksWithSharedNames.size() < 2) {\n-\t                    throw new IllegalArgumentException(\n-\t                            \"There should be at least 2 link events to make a connection\");\n-\t                }\n-\n-\t                linksWithSharedNames.remove(throwLink);\n-\n-\t                // Make the connections\n-\t                Node t = findNodeByIdOrUniqueIdInMetadata(process,\n-\t                        throwLink.getUniqueId());\n-\n-\t                // connect throw to catch\n-\t                for (IntermediateLink catchLink : linksWithSharedNames) {\n-\n-\t                    Node c = findNodeByIdOrUniqueIdInMetadata(process,\n-\t                            catchLink.getUniqueId());\n-\t                    if (t != null && c != null) {\n-\t                        Connection result = new ConnectionImpl(t,\n-\t                                NodeImpl.CONNECTION_DEFAULT_TYPE, c,\n-\t                                NodeImpl.CONNECTION_DEFAULT_TYPE);\n-\t                        result.setMetaData(\"linkNodeHidden\", \"yes\");\n-\t                    }\n-\t                }\n-\n-\t                // Remove processed links\n-\t                links.remove(throwLink);\n-\t                links.removeAll(linksWithSharedNames);\n-\t            }\n-\n-\t            if (links.size() > 0) {\n-\t                throw new IllegalArgumentException(links.size()\n-\t                        + \" links were not processed\");\n-\t            }\n+        }\n \n-\t        }\n-\t }\n+        // second loop for connection\n+        for (IntermediateLink catchLink : catchLinks.values()) {\n+            Collection<IntermediateLink> associatedLinks = throwLinks.remove(catchLink.getName());\n+            if (associatedLinks != null) {\n+                // connect throw to catch\n+                Node catchNode = findNodeByIdOrUniqueIdInMetadata(process,catchLink.getUniqueId());\n+                if (catchNode != null) {\n+                    for (IntermediateLink throwLink : associatedLinks) {\n+                        Node throwNode = findNodeByIdOrUniqueIdInMetadata(process,\n+                            throwLink.getUniqueId());\n+                        if (throwNode != null) {\n+                            Connection result = new ConnectionImpl(throwNode,\n+                                NodeImpl.CONNECTION_DEFAULT_TYPE, catchNode,\n+                                NodeImpl.CONNECTION_DEFAULT_TYPE);\n+                            result.setMetaData(\"linkNodeHidden\", \"yes\");\n+                        }\n+                    }\n+                }\n+            }\n+            else {\n+                unconnectedTarget.add(catchLink);\n+            }\n+        }\n+        \n+        // throw exception if any error (this is done late in the process to show the user as much errors as possible) ", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODI1NzAyNg=="}, "originalCommit": {"oid": "5bb415761d5b798520e128f3510e294bf0f96301"}, "originalPosition": 143}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk4OTc1NDIxOnYy", "diffSide": "RIGHT", "path": "jbpm-bpmn2/src/main/java/org/jbpm/bpmn2/xml/ProcessHandler.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QwODo1Mjo1NFrOHIGw8g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QxMTo0NzoxMlrOHIMiKg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODI2MTQ5MA==", "bodyText": "I think this is not needed. wdyt?", "url": "https://github.com/kiegroup/jbpm/pull/1742#discussion_r478261490", "createdAt": "2020-08-27T08:52:54Z", "author": {"login": "afalhambra"}, "path": "jbpm-bpmn2/src/main/java/org/jbpm/bpmn2/xml/ProcessHandler.java", "diffHunk": "@@ -201,73 +202,83 @@ public Object end(final String uri, final String localName,\n \t\treturn process;\n \t}\n \t\n-\t public static void linkIntermediateLinks(NodeContainer process,\n-\t            List<IntermediateLink> links) {\n-\n \n-        if (null != links) {\n-            List<IntermediateLink> errors = links.stream().filter(l -> l.getName() == null || l.getName().isEmpty()).collect(toList());\n-            if (!errors.isEmpty()) {\n-                StringBuilder builder = new StringBuilder();\n-                for (IntermediateLink l : errors) {\n-                    builder.append(\"\\tIntermediate Link: \" + l.getUniqueId() + \"\\n\");\n+    public static void linkIntermediateLinks(NodeContainer process,List<IntermediateLink> links) {\n+        if (links == null) { \n+            return;\n+        }\n+        Map<String,IntermediateLink> catchLinks = new HashMap<>();\n+        Map<String,Collection<IntermediateLink>> throwLinks = new HashMap<>();\n+        Collection<IntermediateLink> notNameLinks = new ArrayList<>();\n+        Collection<IntermediateLink> duplicatedTarget = new LinkedHashSet<>();\n+        Collection<IntermediateLink> unconnectedTarget = new ArrayList<>();\n+        \n+        // collect errors and nodes in first loop\n+        for (IntermediateLink link : links) {\n+            if (link.getName() == null || link.getName().isEmpty()) {\n+                notNameLinks.add(link);\n+            }\n+            else if (link.isThrowLink()) {\n+                throwLinks.computeIfAbsent(link.getName(), s -> new ArrayList<>()).add(link);\n+            }\n+            else {\n+                IntermediateLink duplicateLink = catchLinks.putIfAbsent(link.getName(),link);\n+                if (duplicateLink != null) {\n+                    duplicatedTarget.add(duplicateLink);\n+                    duplicatedTarget.add(link);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5bb415761d5b798520e128f3510e294bf0f96301"}, "originalPosition": 60}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODM1NjAxMA==", "bodyText": "yes,  we need to add the ids of the links with the same names for the error message, if not, only one id will appear", "url": "https://github.com/kiegroup/jbpm/pull/1742#discussion_r478356010", "createdAt": "2020-08-27T11:47:12Z", "author": {"login": "fjtirado"}, "path": "jbpm-bpmn2/src/main/java/org/jbpm/bpmn2/xml/ProcessHandler.java", "diffHunk": "@@ -201,73 +202,83 @@ public Object end(final String uri, final String localName,\n \t\treturn process;\n \t}\n \t\n-\t public static void linkIntermediateLinks(NodeContainer process,\n-\t            List<IntermediateLink> links) {\n-\n \n-        if (null != links) {\n-            List<IntermediateLink> errors = links.stream().filter(l -> l.getName() == null || l.getName().isEmpty()).collect(toList());\n-            if (!errors.isEmpty()) {\n-                StringBuilder builder = new StringBuilder();\n-                for (IntermediateLink l : errors) {\n-                    builder.append(\"\\tIntermediate Link: \" + l.getUniqueId() + \"\\n\");\n+    public static void linkIntermediateLinks(NodeContainer process,List<IntermediateLink> links) {\n+        if (links == null) { \n+            return;\n+        }\n+        Map<String,IntermediateLink> catchLinks = new HashMap<>();\n+        Map<String,Collection<IntermediateLink>> throwLinks = new HashMap<>();\n+        Collection<IntermediateLink> notNameLinks = new ArrayList<>();\n+        Collection<IntermediateLink> duplicatedTarget = new LinkedHashSet<>();\n+        Collection<IntermediateLink> unconnectedTarget = new ArrayList<>();\n+        \n+        // collect errors and nodes in first loop\n+        for (IntermediateLink link : links) {\n+            if (link.getName() == null || link.getName().isEmpty()) {\n+                notNameLinks.add(link);\n+            }\n+            else if (link.isThrowLink()) {\n+                throwLinks.computeIfAbsent(link.getName(), s -> new ArrayList<>()).add(link);\n+            }\n+            else {\n+                IntermediateLink duplicateLink = catchLinks.putIfAbsent(link.getName(),link);\n+                if (duplicateLink != null) {\n+                    duplicatedTarget.add(duplicateLink);\n+                    duplicatedTarget.add(link);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODI2MTQ5MA=="}, "originalCommit": {"oid": "5bb415761d5b798520e128f3510e294bf0f96301"}, "originalPosition": 60}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk5MDAzNDA3OnYy", "diffSide": "RIGHT", "path": "jbpm-bpmn2/src/main/java/org/jbpm/bpmn2/xml/ProcessHandler.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QxMDowNTo1OFrOHIJZ9Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QxMTo0NTowNFrOHIMdpA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODMwNDc1Nw==", "bodyText": "String concatenation should be done using append method instead. And I would add a delimiter character to show a cleaner message when more than link is wrong, otherwise it may be confusing.\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        errors.append(\"\\nThere is not connection from any catch link to these throw links \"+throwLinks\n          \n          \n            \n                                                           .values()\n          \n          \n            \n                                                           .stream()\n          \n          \n            \n                                                           .flatMap(Collection::stream)\n          \n          \n            \n                                                           .map(IntermediateLink::getUniqueId)\n          \n          \n            \n                                                           .collect(Collectors.joining()));\n          \n          \n            \n                        errors.append(\"\\nThere is not connection from any catch link to these throw links \").append(throwLinks\n          \n          \n            \n                                                           .values()\n          \n          \n            \n                                                           .stream()\n          \n          \n            \n                                                           .flatMap(Collection::stream)\n          \n          \n            \n                                                           .map(IntermediateLink::getUniqueId)\n          \n          \n            \n                                                           .collect(Collectors.joining(\", \"))));", "url": "https://github.com/kiegroup/jbpm/pull/1742#discussion_r478304757", "createdAt": "2020-08-27T10:05:58Z", "author": {"login": "afalhambra"}, "path": "jbpm-bpmn2/src/main/java/org/jbpm/bpmn2/xml/ProcessHandler.java", "diffHunk": "@@ -201,73 +202,83 @@ public Object end(final String uri, final String localName,\n \t\treturn process;\n \t}\n \t\n-\t public static void linkIntermediateLinks(NodeContainer process,\n-\t            List<IntermediateLink> links) {\n-\n \n-        if (null != links) {\n-            List<IntermediateLink> errors = links.stream().filter(l -> l.getName() == null || l.getName().isEmpty()).collect(toList());\n-            if (!errors.isEmpty()) {\n-                StringBuilder builder = new StringBuilder();\n-                for (IntermediateLink l : errors) {\n-                    builder.append(\"\\tIntermediate Link: \" + l.getUniqueId() + \"\\n\");\n+    public static void linkIntermediateLinks(NodeContainer process,List<IntermediateLink> links) {\n+        if (links == null) { \n+            return;\n+        }\n+        Map<String,IntermediateLink> catchLinks = new HashMap<>();\n+        Map<String,Collection<IntermediateLink>> throwLinks = new HashMap<>();\n+        Collection<IntermediateLink> notNameLinks = new ArrayList<>();\n+        Collection<IntermediateLink> duplicatedTarget = new LinkedHashSet<>();\n+        Collection<IntermediateLink> unconnectedTarget = new ArrayList<>();\n+        \n+        // collect errors and nodes in first loop\n+        for (IntermediateLink link : links) {\n+            if (link.getName() == null || link.getName().isEmpty()) {\n+                notNameLinks.add(link);\n+            }\n+            else if (link.isThrowLink()) {\n+                throwLinks.computeIfAbsent(link.getName(), s -> new ArrayList<>()).add(link);\n+            }\n+            else {\n+                IntermediateLink duplicateLink = catchLinks.putIfAbsent(link.getName(),link);\n+                if (duplicateLink != null) {\n+                    duplicatedTarget.add(duplicateLink);\n+                    duplicatedTarget.add(link);\n                 }\n-                throw new IllegalArgumentException(\"There are \" + errors.size() + \" links that does not have a name.\\n\" + builder.toString());\n             }\n-\t            // Search throw links\n-\t            ArrayList<IntermediateLink> throwLinks = new ArrayList<IntermediateLink>();\n-\t            for (IntermediateLink aLinks : links) {\n-\t                if (aLinks.isThrowLink()) {\n-\t                    throwLinks.add(aLinks);\n-\t                }\n-\t            }\n-\n-\t            // Look for catch links for a throw link\n-\t            for (IntermediateLink throwLink : throwLinks) {\n-\n-\t                ArrayList<IntermediateLink> linksWithSharedNames = new ArrayList<IntermediateLink>();\n-\t                for (IntermediateLink aLink : links) {\n-\t                    if (throwLink.getName().equals(aLink.getName())) {\n-\t                        linksWithSharedNames.add(aLink);\n-\t                    }\n-\t                }\n-\n-\t                if (linksWithSharedNames.size() < 2) {\n-\t                    throw new IllegalArgumentException(\n-\t                            \"There should be at least 2 link events to make a connection\");\n-\t                }\n-\n-\t                linksWithSharedNames.remove(throwLink);\n-\n-\t                // Make the connections\n-\t                Node t = findNodeByIdOrUniqueIdInMetadata(process,\n-\t                        throwLink.getUniqueId());\n-\n-\t                // connect throw to catch\n-\t                for (IntermediateLink catchLink : linksWithSharedNames) {\n-\n-\t                    Node c = findNodeByIdOrUniqueIdInMetadata(process,\n-\t                            catchLink.getUniqueId());\n-\t                    if (t != null && c != null) {\n-\t                        Connection result = new ConnectionImpl(t,\n-\t                                NodeImpl.CONNECTION_DEFAULT_TYPE, c,\n-\t                                NodeImpl.CONNECTION_DEFAULT_TYPE);\n-\t                        result.setMetaData(\"linkNodeHidden\", \"yes\");\n-\t                    }\n-\t                }\n-\n-\t                // Remove processed links\n-\t                links.remove(throwLink);\n-\t                links.removeAll(linksWithSharedNames);\n-\t            }\n-\n-\t            if (links.size() > 0) {\n-\t                throw new IllegalArgumentException(links.size()\n-\t                        + \" links were not processed\");\n-\t            }\n+        }\n \n-\t        }\n-\t }\n+        // second loop for connection\n+        for (IntermediateLink catchLink : catchLinks.values()) {\n+            Collection<IntermediateLink> associatedLinks = throwLinks.remove(catchLink.getName());\n+            if (associatedLinks != null) {\n+                // connect throw to catch\n+                Node catchNode = findNodeByIdOrUniqueIdInMetadata(process,catchLink.getUniqueId());\n+                if (catchNode != null) {\n+                    for (IntermediateLink throwLink : associatedLinks) {\n+                        Node throwNode = findNodeByIdOrUniqueIdInMetadata(process,\n+                            throwLink.getUniqueId());\n+                        if (throwNode != null) {\n+                            Connection result = new ConnectionImpl(throwNode,\n+                                NodeImpl.CONNECTION_DEFAULT_TYPE, catchNode,\n+                                NodeImpl.CONNECTION_DEFAULT_TYPE);\n+                            result.setMetaData(\"linkNodeHidden\", \"yes\");\n+                        }\n+                    }\n+                }\n+            }\n+            else {\n+                unconnectedTarget.add(catchLink);\n+            }\n+        }\n+        \n+        // throw exception if any error (this is done late in the process to show the user as much errors as possible) \n+        StringBuilder errors = new StringBuilder();\n+        if (!notNameLinks.isEmpty()) {\n+            errors.append(\"These nodes do not have a name \"+notNameLinks.stream().map(IntermediateLink::getUniqueId).collect(Collectors.joining()));\n+        }\n+        if (!duplicatedTarget.isEmpty()) {\n+            errors.append(\"\\nThere are multiple catch nodes with the same name \"+duplicatedTarget.stream().map(IntermediateLink::getUniqueId).collect(Collectors.joining()));\n+        }\n+        if (!unconnectedTarget.isEmpty()) {\n+            errors.append(\"\\nThere is not connection from any throw link to these catch links \"+unconnectedTarget.stream().map(IntermediateLink::getUniqueId).collect(Collectors.joining()));\n+        }\n+        if (!throwLinks.isEmpty()) {\n+            errors.append(\"\\nThere is not connection from any catch link to these throw links \"+throwLinks\n+                                               .values()\n+                                               .stream()\n+                                               .flatMap(Collection::stream)\n+                                               .map(IntermediateLink::getUniqueId)\n+                                               .collect(Collectors.joining()));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5bb415761d5b798520e128f3510e294bf0f96301"}, "originalPosition": 160}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODM1NDg1Mg==", "bodyText": "code refactor to move error formatting to private method", "url": "https://github.com/kiegroup/jbpm/pull/1742#discussion_r478354852", "createdAt": "2020-08-27T11:45:04Z", "author": {"login": "fjtirado"}, "path": "jbpm-bpmn2/src/main/java/org/jbpm/bpmn2/xml/ProcessHandler.java", "diffHunk": "@@ -201,73 +202,83 @@ public Object end(final String uri, final String localName,\n \t\treturn process;\n \t}\n \t\n-\t public static void linkIntermediateLinks(NodeContainer process,\n-\t            List<IntermediateLink> links) {\n-\n \n-        if (null != links) {\n-            List<IntermediateLink> errors = links.stream().filter(l -> l.getName() == null || l.getName().isEmpty()).collect(toList());\n-            if (!errors.isEmpty()) {\n-                StringBuilder builder = new StringBuilder();\n-                for (IntermediateLink l : errors) {\n-                    builder.append(\"\\tIntermediate Link: \" + l.getUniqueId() + \"\\n\");\n+    public static void linkIntermediateLinks(NodeContainer process,List<IntermediateLink> links) {\n+        if (links == null) { \n+            return;\n+        }\n+        Map<String,IntermediateLink> catchLinks = new HashMap<>();\n+        Map<String,Collection<IntermediateLink>> throwLinks = new HashMap<>();\n+        Collection<IntermediateLink> notNameLinks = new ArrayList<>();\n+        Collection<IntermediateLink> duplicatedTarget = new LinkedHashSet<>();\n+        Collection<IntermediateLink> unconnectedTarget = new ArrayList<>();\n+        \n+        // collect errors and nodes in first loop\n+        for (IntermediateLink link : links) {\n+            if (link.getName() == null || link.getName().isEmpty()) {\n+                notNameLinks.add(link);\n+            }\n+            else if (link.isThrowLink()) {\n+                throwLinks.computeIfAbsent(link.getName(), s -> new ArrayList<>()).add(link);\n+            }\n+            else {\n+                IntermediateLink duplicateLink = catchLinks.putIfAbsent(link.getName(),link);\n+                if (duplicateLink != null) {\n+                    duplicatedTarget.add(duplicateLink);\n+                    duplicatedTarget.add(link);\n                 }\n-                throw new IllegalArgumentException(\"There are \" + errors.size() + \" links that does not have a name.\\n\" + builder.toString());\n             }\n-\t            // Search throw links\n-\t            ArrayList<IntermediateLink> throwLinks = new ArrayList<IntermediateLink>();\n-\t            for (IntermediateLink aLinks : links) {\n-\t                if (aLinks.isThrowLink()) {\n-\t                    throwLinks.add(aLinks);\n-\t                }\n-\t            }\n-\n-\t            // Look for catch links for a throw link\n-\t            for (IntermediateLink throwLink : throwLinks) {\n-\n-\t                ArrayList<IntermediateLink> linksWithSharedNames = new ArrayList<IntermediateLink>();\n-\t                for (IntermediateLink aLink : links) {\n-\t                    if (throwLink.getName().equals(aLink.getName())) {\n-\t                        linksWithSharedNames.add(aLink);\n-\t                    }\n-\t                }\n-\n-\t                if (linksWithSharedNames.size() < 2) {\n-\t                    throw new IllegalArgumentException(\n-\t                            \"There should be at least 2 link events to make a connection\");\n-\t                }\n-\n-\t                linksWithSharedNames.remove(throwLink);\n-\n-\t                // Make the connections\n-\t                Node t = findNodeByIdOrUniqueIdInMetadata(process,\n-\t                        throwLink.getUniqueId());\n-\n-\t                // connect throw to catch\n-\t                for (IntermediateLink catchLink : linksWithSharedNames) {\n-\n-\t                    Node c = findNodeByIdOrUniqueIdInMetadata(process,\n-\t                            catchLink.getUniqueId());\n-\t                    if (t != null && c != null) {\n-\t                        Connection result = new ConnectionImpl(t,\n-\t                                NodeImpl.CONNECTION_DEFAULT_TYPE, c,\n-\t                                NodeImpl.CONNECTION_DEFAULT_TYPE);\n-\t                        result.setMetaData(\"linkNodeHidden\", \"yes\");\n-\t                    }\n-\t                }\n-\n-\t                // Remove processed links\n-\t                links.remove(throwLink);\n-\t                links.removeAll(linksWithSharedNames);\n-\t            }\n-\n-\t            if (links.size() > 0) {\n-\t                throw new IllegalArgumentException(links.size()\n-\t                        + \" links were not processed\");\n-\t            }\n+        }\n \n-\t        }\n-\t }\n+        // second loop for connection\n+        for (IntermediateLink catchLink : catchLinks.values()) {\n+            Collection<IntermediateLink> associatedLinks = throwLinks.remove(catchLink.getName());\n+            if (associatedLinks != null) {\n+                // connect throw to catch\n+                Node catchNode = findNodeByIdOrUniqueIdInMetadata(process,catchLink.getUniqueId());\n+                if (catchNode != null) {\n+                    for (IntermediateLink throwLink : associatedLinks) {\n+                        Node throwNode = findNodeByIdOrUniqueIdInMetadata(process,\n+                            throwLink.getUniqueId());\n+                        if (throwNode != null) {\n+                            Connection result = new ConnectionImpl(throwNode,\n+                                NodeImpl.CONNECTION_DEFAULT_TYPE, catchNode,\n+                                NodeImpl.CONNECTION_DEFAULT_TYPE);\n+                            result.setMetaData(\"linkNodeHidden\", \"yes\");\n+                        }\n+                    }\n+                }\n+            }\n+            else {\n+                unconnectedTarget.add(catchLink);\n+            }\n+        }\n+        \n+        // throw exception if any error (this is done late in the process to show the user as much errors as possible) \n+        StringBuilder errors = new StringBuilder();\n+        if (!notNameLinks.isEmpty()) {\n+            errors.append(\"These nodes do not have a name \"+notNameLinks.stream().map(IntermediateLink::getUniqueId).collect(Collectors.joining()));\n+        }\n+        if (!duplicatedTarget.isEmpty()) {\n+            errors.append(\"\\nThere are multiple catch nodes with the same name \"+duplicatedTarget.stream().map(IntermediateLink::getUniqueId).collect(Collectors.joining()));\n+        }\n+        if (!unconnectedTarget.isEmpty()) {\n+            errors.append(\"\\nThere is not connection from any throw link to these catch links \"+unconnectedTarget.stream().map(IntermediateLink::getUniqueId).collect(Collectors.joining()));\n+        }\n+        if (!throwLinks.isEmpty()) {\n+            errors.append(\"\\nThere is not connection from any catch link to these throw links \"+throwLinks\n+                                               .values()\n+                                               .stream()\n+                                               .flatMap(Collection::stream)\n+                                               .map(IntermediateLink::getUniqueId)\n+                                               .collect(Collectors.joining()));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODMwNDc1Nw=="}, "originalCommit": {"oid": "5bb415761d5b798520e128f3510e294bf0f96301"}, "originalPosition": 160}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk5MDE5ODgyOnYy", "diffSide": "RIGHT", "path": "jbpm-test-coverage/src/test/java/org/jbpm/test/functional/ErrorLinkProcessTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QxMDo1NjoxMVrOHIK-5g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QxMTo0NToyNFrOHIMeRg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODMzMDU5OA==", "bodyText": "I don't think we really need to set a timeout for any of these tests - wdyt?", "url": "https://github.com/kiegroup/jbpm/pull/1742#discussion_r478330598", "createdAt": "2020-08-27T10:56:11Z", "author": {"login": "afalhambra"}, "path": "jbpm-test-coverage/src/test/java/org/jbpm/test/functional/ErrorLinkProcessTest.java", "diffHunk": "@@ -0,0 +1,84 @@\n+/*\n+ * Copyright 2017 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+/*\n+ * To change this template, choose Tools | Templates\n+ * and open the template in the editor.\n+ */\n+package org.jbpm.test.functional;\n+\n+import org.jbpm.test.JbpmTestCase;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.ExpectedException;\n+import org.kie.api.runtime.KieSession;\n+\n+import static org.junit.Assert.assertNotNull;\n+\n+/**\n+ */\n+public class ErrorLinkProcessTest extends JbpmTestCase {\n+\n+    @Rule\n+    public ExpectedException exceptionRule = ExpectedException.none();\n+\n+    public static final String PROCESS_EMPTY = \"org/jbpm/test/functional/common/EmptyLinkProcess.bpmn2\";\n+    public static final String PROCESS_EMPTY_ID = \"org.jbpm.test.functional.common.EmptyLinkProcess\";\n+    \n+    public static final String PROCESS_MULTI_THROW = \"org/jbpm/test/functional/common/MultipleThrowLinkProcess.bpmn2\";\n+    public static final String PROCESS_MULTI_THROW_ID = \"org.jbpm.test.functional.common.MultipleThrowLinkProcess\";\n+    \n+    public static final String PROCESS_MULTI_CATCH = \"org/jbpm/test/functional/common/MultipleCatchLinkProcess.bpmn2\";\n+    public static final String PROCESS_MULTI_CATCH_ID = \"org.jbpm.test.functional.common.MultipleCatchLinkProcess\";\n+    \n+    public static final String PROCESS_UNCONNECTED = \"org/jbpm/test/functional/common/UnconnectedLinkProcess.bpmn2\";\n+    public static final String PROCESS_UNCONNECTED_ID = \"org.jbpm.test.functional.common.UnconnectedLinkProcess\";\n+\n+    public ErrorLinkProcessTest() {\n+        super(false);\n+    }\n+\n+    @Test(timeout = 30000)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f074cf209b43f328b658ee1f5d2598e9cfcd6a98"}, "originalPosition": 54}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODM1NTAxNA==", "bodyText": "no, not really, I was keeping the original just in case, removing", "url": "https://github.com/kiegroup/jbpm/pull/1742#discussion_r478355014", "createdAt": "2020-08-27T11:45:24Z", "author": {"login": "fjtirado"}, "path": "jbpm-test-coverage/src/test/java/org/jbpm/test/functional/ErrorLinkProcessTest.java", "diffHunk": "@@ -0,0 +1,84 @@\n+/*\n+ * Copyright 2017 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+/*\n+ * To change this template, choose Tools | Templates\n+ * and open the template in the editor.\n+ */\n+package org.jbpm.test.functional;\n+\n+import org.jbpm.test.JbpmTestCase;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.ExpectedException;\n+import org.kie.api.runtime.KieSession;\n+\n+import static org.junit.Assert.assertNotNull;\n+\n+/**\n+ */\n+public class ErrorLinkProcessTest extends JbpmTestCase {\n+\n+    @Rule\n+    public ExpectedException exceptionRule = ExpectedException.none();\n+\n+    public static final String PROCESS_EMPTY = \"org/jbpm/test/functional/common/EmptyLinkProcess.bpmn2\";\n+    public static final String PROCESS_EMPTY_ID = \"org.jbpm.test.functional.common.EmptyLinkProcess\";\n+    \n+    public static final String PROCESS_MULTI_THROW = \"org/jbpm/test/functional/common/MultipleThrowLinkProcess.bpmn2\";\n+    public static final String PROCESS_MULTI_THROW_ID = \"org.jbpm.test.functional.common.MultipleThrowLinkProcess\";\n+    \n+    public static final String PROCESS_MULTI_CATCH = \"org/jbpm/test/functional/common/MultipleCatchLinkProcess.bpmn2\";\n+    public static final String PROCESS_MULTI_CATCH_ID = \"org.jbpm.test.functional.common.MultipleCatchLinkProcess\";\n+    \n+    public static final String PROCESS_UNCONNECTED = \"org/jbpm/test/functional/common/UnconnectedLinkProcess.bpmn2\";\n+    public static final String PROCESS_UNCONNECTED_ID = \"org.jbpm.test.functional.common.UnconnectedLinkProcess\";\n+\n+    public ErrorLinkProcessTest() {\n+        super(false);\n+    }\n+\n+    @Test(timeout = 30000)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODMzMDU5OA=="}, "originalCommit": {"oid": "f074cf209b43f328b658ee1f5d2598e9cfcd6a98"}, "originalPosition": 54}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk5MDIzNzkzOnYy", "diffSide": "RIGHT", "path": "jbpm-test-coverage/src/test/java/org/jbpm/test/functional/ErrorLinkProcessTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QxMTowOToyMlrOHILXQQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QxMTo0NTo0N1rOHIMe_Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODMzNjgzMw==", "bodyText": "2020", "url": "https://github.com/kiegroup/jbpm/pull/1742#discussion_r478336833", "createdAt": "2020-08-27T11:09:22Z", "author": {"login": "afalhambra"}, "path": "jbpm-test-coverage/src/test/java/org/jbpm/test/functional/ErrorLinkProcessTest.java", "diffHunk": "@@ -0,0 +1,84 @@\n+/*\n+ * Copyright 2017 Red Hat, Inc. and/or its affiliates.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f074cf209b43f328b658ee1f5d2598e9cfcd6a98"}, "originalPosition": 2}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODM1NTE5Nw==", "bodyText": "\"donde va la gente\" ;)", "url": "https://github.com/kiegroup/jbpm/pull/1742#discussion_r478355197", "createdAt": "2020-08-27T11:45:47Z", "author": {"login": "fjtirado"}, "path": "jbpm-test-coverage/src/test/java/org/jbpm/test/functional/ErrorLinkProcessTest.java", "diffHunk": "@@ -0,0 +1,84 @@\n+/*\n+ * Copyright 2017 Red Hat, Inc. and/or its affiliates.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODMzNjgzMw=="}, "originalCommit": {"oid": "f074cf209b43f328b658ee1f5d2598e9cfcd6a98"}, "originalPosition": 2}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk5MDIzODYyOnYy", "diffSide": "RIGHT", "path": "jbpm-test-coverage/src/test/java/org/jbpm/test/functional/ErrorLinkProcessTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QxMTowOTozM1rOHILXoQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QxMTo0NjoxMlrOHIMf9Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODMzNjkyOQ==", "bodyText": "Please remove", "url": "https://github.com/kiegroup/jbpm/pull/1742#discussion_r478336929", "createdAt": "2020-08-27T11:09:33Z", "author": {"login": "afalhambra"}, "path": "jbpm-test-coverage/src/test/java/org/jbpm/test/functional/ErrorLinkProcessTest.java", "diffHunk": "@@ -0,0 +1,84 @@\n+/*\n+ * Copyright 2017 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+/*\n+ * To change this template, choose Tools | Templates\n+ * and open the template in the editor.\n+ */\n+package org.jbpm.test.functional;\n+\n+import org.jbpm.test.JbpmTestCase;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.ExpectedException;\n+import org.kie.api.runtime.KieSession;\n+\n+import static org.junit.Assert.assertNotNull;\n+\n+/**\n+ */", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f074cf209b43f328b658ee1f5d2598e9cfcd6a98"}, "originalPosition": 32}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODM1NTQ0NQ==", "bodyText": "Done", "url": "https://github.com/kiegroup/jbpm/pull/1742#discussion_r478355445", "createdAt": "2020-08-27T11:46:12Z", "author": {"login": "fjtirado"}, "path": "jbpm-test-coverage/src/test/java/org/jbpm/test/functional/ErrorLinkProcessTest.java", "diffHunk": "@@ -0,0 +1,84 @@\n+/*\n+ * Copyright 2017 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+/*\n+ * To change this template, choose Tools | Templates\n+ * and open the template in the editor.\n+ */\n+package org.jbpm.test.functional;\n+\n+import org.jbpm.test.JbpmTestCase;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.ExpectedException;\n+import org.kie.api.runtime.KieSession;\n+\n+import static org.junit.Assert.assertNotNull;\n+\n+/**\n+ */", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODMzNjkyOQ=="}, "originalCommit": {"oid": "f074cf209b43f328b658ee1f5d2598e9cfcd6a98"}, "originalPosition": 32}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk5MDI0ODQzOnYy", "diffSide": "RIGHT", "path": "jbpm-test-coverage/src/test/java/org/jbpm/test/functional/ErrorLinkProcessTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QxMToxMjozOFrOHILdlw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QxMToxMjozOFrOHILdlw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODMzODQ1NQ==", "bodyText": "We don't really need to start any process for any of these tests as in case of any exceptions/errors these will be thrown while creating Kie session.", "url": "https://github.com/kiegroup/jbpm/pull/1742#discussion_r478338455", "createdAt": "2020-08-27T11:12:38Z", "author": {"login": "afalhambra"}, "path": "jbpm-test-coverage/src/test/java/org/jbpm/test/functional/ErrorLinkProcessTest.java", "diffHunk": "@@ -0,0 +1,84 @@\n+/*\n+ * Copyright 2017 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+/*\n+ * To change this template, choose Tools | Templates\n+ * and open the template in the editor.\n+ */\n+package org.jbpm.test.functional;\n+\n+import org.jbpm.test.JbpmTestCase;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.ExpectedException;\n+import org.kie.api.runtime.KieSession;\n+\n+import static org.junit.Assert.assertNotNull;\n+\n+/**\n+ */\n+public class ErrorLinkProcessTest extends JbpmTestCase {\n+\n+    @Rule\n+    public ExpectedException exceptionRule = ExpectedException.none();\n+\n+    public static final String PROCESS_EMPTY = \"org/jbpm/test/functional/common/EmptyLinkProcess.bpmn2\";\n+    public static final String PROCESS_EMPTY_ID = \"org.jbpm.test.functional.common.EmptyLinkProcess\";\n+    \n+    public static final String PROCESS_MULTI_THROW = \"org/jbpm/test/functional/common/MultipleThrowLinkProcess.bpmn2\";\n+    public static final String PROCESS_MULTI_THROW_ID = \"org.jbpm.test.functional.common.MultipleThrowLinkProcess\";\n+    \n+    public static final String PROCESS_MULTI_CATCH = \"org/jbpm/test/functional/common/MultipleCatchLinkProcess.bpmn2\";\n+    public static final String PROCESS_MULTI_CATCH_ID = \"org.jbpm.test.functional.common.MultipleCatchLinkProcess\";\n+    \n+    public static final String PROCESS_UNCONNECTED = \"org/jbpm/test/functional/common/UnconnectedLinkProcess.bpmn2\";\n+    public static final String PROCESS_UNCONNECTED_ID = \"org.jbpm.test.functional.common.UnconnectedLinkProcess\";\n+\n+    public ErrorLinkProcessTest() {\n+        super(false);\n+    }\n+\n+    @Test(timeout = 30000)\n+    public void testEmptyLinkEvents() {\n+        exceptionRule.expect(IllegalArgumentException.class);\n+        exceptionRule.expectMessage(\"nodes do not have a name\");\n+        KieSession ksession = createKSession(PROCESS_EMPTY);\n+        ksession.startProcess(PROCESS_EMPTY_ID);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f074cf209b43f328b658ee1f5d2598e9cfcd6a98"}, "originalPosition": 59}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk5MDI2MDk0OnYy", "diffSide": "RIGHT", "path": "jbpm-test-coverage/src/test/java/org/jbpm/test/functional/ErrorLinkProcessTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QxMToxNjo1OVrOHILlhA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QxMTo0NjoyOVrOHIMggQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODM0MDQ4NA==", "bodyText": "Sorry forgot to add a comment about this. This needs to be removed.", "url": "https://github.com/kiegroup/jbpm/pull/1742#discussion_r478340484", "createdAt": "2020-08-27T11:16:59Z", "author": {"login": "afalhambra"}, "path": "jbpm-test-coverage/src/test/java/org/jbpm/test/functional/ErrorLinkProcessTest.java", "diffHunk": "@@ -0,0 +1,84 @@\n+/*\n+ * Copyright 2017 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+/*\n+ * To change this template, choose Tools | Templates\n+ * and open the template in the editor.\n+ */", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f074cf209b43f328b658ee1f5d2598e9cfcd6a98"}, "originalPosition": 20}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODM1NTU4NQ==", "bodyText": "Yes, now I see it, removed too", "url": "https://github.com/kiegroup/jbpm/pull/1742#discussion_r478355585", "createdAt": "2020-08-27T11:46:29Z", "author": {"login": "fjtirado"}, "path": "jbpm-test-coverage/src/test/java/org/jbpm/test/functional/ErrorLinkProcessTest.java", "diffHunk": "@@ -0,0 +1,84 @@\n+/*\n+ * Copyright 2017 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+/*\n+ * To change this template, choose Tools | Templates\n+ * and open the template in the editor.\n+ */", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODM0MDQ4NA=="}, "originalCommit": {"oid": "f074cf209b43f328b658ee1f5d2598e9cfcd6a98"}, "originalPosition": 20}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1556, "cost": 1, "resetAt": "2021-11-12T20:28:25Z"}}}