{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzg1NDQ4NjI5", "number": 1603, "reviewThreads": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wOVQxMTozOTo0M1rODmQCyQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMlQxMDozMzoyNVrODnaURw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQxNDM1MzM3OnYy", "diffSide": "RIGHT", "path": "jbpm-case-mgmt/jbpm-case-mgmt-impl/src/main/java/org/jbpm/casemgmt/impl/CaseRuntimeDataServiceImpl.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wOVQxMTozOTo0M1rOFzjvIw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wOVQxMzo1ODo1OVrOFzpTFw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTYwNzIwMw==", "bodyText": "The map contains lists with one element, so ordering is applying to that list and therefore not working.\nPerhaps you can order after generating the list of CaseMilestoneInstance.\nmilestones.sort(Comparator.comparing(CaseMilestoneInstance::getAchievedAt));", "url": "https://github.com/kiegroup/jbpm/pull/1603#discussion_r389607203", "createdAt": "2020-03-09T11:39:43Z", "author": {"login": "gmunozfe"}, "path": "jbpm-case-mgmt/jbpm-case-mgmt-impl/src/main/java/org/jbpm/casemgmt/impl/CaseRuntimeDataServiceImpl.java", "diffHunk": "@@ -340,43 +340,36 @@ public CaseDefinition getCase(String deploymentId, String caseDefinitionId) {\n \n     @Override\n     public Collection<CaseMilestoneInstance> getCaseInstanceMilestones(String caseId, boolean achievedOnly, QueryContext queryContext) {\n-        ProcessInstanceDesc pi = runtimeDataService.getProcessInstanceByCorrelationKey(correlationKeyFactory.newCorrelationKey(caseId));        \n+        ProcessInstanceDesc pi = runtimeDataService.getProcessInstanceByCorrelationKey(correlationKeyFactory.newCorrelationKey(caseId));\n         if (pi == null || !pi.getState().equals(ProcessInstance.STATE_ACTIVE)) {\n             throw new CaseNotFoundException(\"No case instance found with id \" + caseId + \" or it's not active anymore\");\n         }\n         CorrelationKey correlationKey = correlationKeyFactory.newCorrelationKey(caseId);\n-        \n-        Collection<org.jbpm.services.api.model.NodeInstanceDesc> nodes = runtimeDataService.getNodeInstancesByCorrelationKeyNodeType(correlationKey, \n-                                                                                                Arrays.asList(ProcessInstance.STATE_ACTIVE), \n-                                                                                                Arrays.asList(\"MilestoneNode\"), \n-                                                                                                queryContext);\n-        \n-        Collection<Long> completedNodes = nodes.stream().filter(n -> ((NodeInstanceDesc)n).getType() == 1).map(n -> n.getId()).collect(toList());\n-        Predicate<org.jbpm.services.api.model.NodeInstanceDesc> filterNodes = null;\n-        if (achievedOnly) {            \n-            filterNodes = n -> ((NodeInstanceDesc)n).getType() == 1;             \n-        } else {\n-            filterNodes = n -> ((NodeInstanceDesc)n).getType() == 0;\n-        }\n-        List<String> foundMilestones = new ArrayList<>();\n-        \n-        List<CaseMilestoneInstance> milestones = nodes.stream()\n-        .filter(filterNodes)\n-        .map(n -> {\n-            foundMilestones.add(n.getName());\n-            return new CaseMilestoneInstanceImpl(String.valueOf(n.getId()), n.getName(), completedNodes.contains(n.getId()), n.getDataTimeStamp());        \n-        })\n-        .collect(toList());\n-        \n+\n+        Collection<org.jbpm.services.api.model.NodeInstanceDesc> nodes = runtimeDataService.getNodeInstancesByCorrelationKeyNodeType(correlationKey,\n+                                                                                                                                     Arrays.asList(ProcessInstance.STATE_ACTIVE, ProcessInstance.STATE_ABORTED),\n+                                                                                                                                     Arrays.asList(\"MilestoneNode\"),\n+                                                                                                                                     queryContext);\n+\n+        // achieved milestones\n+        Map<String, List<CaseMilestoneInstance>> milestonesGroup = nodes.stream()\n+                                                                        .map(n -> (NodeInstanceDesc) n)\n+                                                                        .filter(n -> n.getType() == 1)\n+                                                                        .map(n -> new CaseMilestoneInstanceImpl(String.valueOf(n.getId()), n.getName(), true, n.getDataTimeStamp()))\n+                                                                        .collect(Collectors.groupingBy(CaseMilestoneInstance::getName));\n+\n+        List<CaseMilestoneInstance> milestones = milestonesGroup.values().stream().map(e -> e.stream().min((o1, o2) -> o1.getAchievedAt().compareTo(o2.getAchievedAt())).get()).collect(toList());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ab35c2b1f9ae9bdde151d414c5017aa31b9febe4"}, "originalPosition": 46}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTY2NTI0MA==", "bodyText": "Not really sure I understand your comments. If a case is cancelled and then reopen it should contain at least two elements and so on ?... do you mind to check again ?", "url": "https://github.com/kiegroup/jbpm/pull/1603#discussion_r389665240", "createdAt": "2020-03-09T13:30:08Z", "author": {"login": "elguardian"}, "path": "jbpm-case-mgmt/jbpm-case-mgmt-impl/src/main/java/org/jbpm/casemgmt/impl/CaseRuntimeDataServiceImpl.java", "diffHunk": "@@ -340,43 +340,36 @@ public CaseDefinition getCase(String deploymentId, String caseDefinitionId) {\n \n     @Override\n     public Collection<CaseMilestoneInstance> getCaseInstanceMilestones(String caseId, boolean achievedOnly, QueryContext queryContext) {\n-        ProcessInstanceDesc pi = runtimeDataService.getProcessInstanceByCorrelationKey(correlationKeyFactory.newCorrelationKey(caseId));        \n+        ProcessInstanceDesc pi = runtimeDataService.getProcessInstanceByCorrelationKey(correlationKeyFactory.newCorrelationKey(caseId));\n         if (pi == null || !pi.getState().equals(ProcessInstance.STATE_ACTIVE)) {\n             throw new CaseNotFoundException(\"No case instance found with id \" + caseId + \" or it's not active anymore\");\n         }\n         CorrelationKey correlationKey = correlationKeyFactory.newCorrelationKey(caseId);\n-        \n-        Collection<org.jbpm.services.api.model.NodeInstanceDesc> nodes = runtimeDataService.getNodeInstancesByCorrelationKeyNodeType(correlationKey, \n-                                                                                                Arrays.asList(ProcessInstance.STATE_ACTIVE), \n-                                                                                                Arrays.asList(\"MilestoneNode\"), \n-                                                                                                queryContext);\n-        \n-        Collection<Long> completedNodes = nodes.stream().filter(n -> ((NodeInstanceDesc)n).getType() == 1).map(n -> n.getId()).collect(toList());\n-        Predicate<org.jbpm.services.api.model.NodeInstanceDesc> filterNodes = null;\n-        if (achievedOnly) {            \n-            filterNodes = n -> ((NodeInstanceDesc)n).getType() == 1;             \n-        } else {\n-            filterNodes = n -> ((NodeInstanceDesc)n).getType() == 0;\n-        }\n-        List<String> foundMilestones = new ArrayList<>();\n-        \n-        List<CaseMilestoneInstance> milestones = nodes.stream()\n-        .filter(filterNodes)\n-        .map(n -> {\n-            foundMilestones.add(n.getName());\n-            return new CaseMilestoneInstanceImpl(String.valueOf(n.getId()), n.getName(), completedNodes.contains(n.getId()), n.getDataTimeStamp());        \n-        })\n-        .collect(toList());\n-        \n+\n+        Collection<org.jbpm.services.api.model.NodeInstanceDesc> nodes = runtimeDataService.getNodeInstancesByCorrelationKeyNodeType(correlationKey,\n+                                                                                                                                     Arrays.asList(ProcessInstance.STATE_ACTIVE, ProcessInstance.STATE_ABORTED),\n+                                                                                                                                     Arrays.asList(\"MilestoneNode\"),\n+                                                                                                                                     queryContext);\n+\n+        // achieved milestones\n+        Map<String, List<CaseMilestoneInstance>> milestonesGroup = nodes.stream()\n+                                                                        .map(n -> (NodeInstanceDesc) n)\n+                                                                        .filter(n -> n.getType() == 1)\n+                                                                        .map(n -> new CaseMilestoneInstanceImpl(String.valueOf(n.getId()), n.getName(), true, n.getDataTimeStamp()))\n+                                                                        .collect(Collectors.groupingBy(CaseMilestoneInstance::getName));\n+\n+        List<CaseMilestoneInstance> milestones = milestonesGroup.values().stream().map(e -> e.stream().min((o1, o2) -> o1.getAchievedAt().compareTo(o2.getAchievedAt())).get()).collect(toList());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTYwNzIwMw=="}, "originalCommit": {"oid": "ab35c2b1f9ae9bdde151d414c5017aa31b9febe4"}, "originalPosition": 46}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTY5ODMyNw==", "bodyText": "I meant for the failing test, which contained only one element per key, and the list obtained from the map was not ordered. Now, it's working fine, thanks!", "url": "https://github.com/kiegroup/jbpm/pull/1603#discussion_r389698327", "createdAt": "2020-03-09T13:58:59Z", "author": {"login": "gmunozfe"}, "path": "jbpm-case-mgmt/jbpm-case-mgmt-impl/src/main/java/org/jbpm/casemgmt/impl/CaseRuntimeDataServiceImpl.java", "diffHunk": "@@ -340,43 +340,36 @@ public CaseDefinition getCase(String deploymentId, String caseDefinitionId) {\n \n     @Override\n     public Collection<CaseMilestoneInstance> getCaseInstanceMilestones(String caseId, boolean achievedOnly, QueryContext queryContext) {\n-        ProcessInstanceDesc pi = runtimeDataService.getProcessInstanceByCorrelationKey(correlationKeyFactory.newCorrelationKey(caseId));        \n+        ProcessInstanceDesc pi = runtimeDataService.getProcessInstanceByCorrelationKey(correlationKeyFactory.newCorrelationKey(caseId));\n         if (pi == null || !pi.getState().equals(ProcessInstance.STATE_ACTIVE)) {\n             throw new CaseNotFoundException(\"No case instance found with id \" + caseId + \" or it's not active anymore\");\n         }\n         CorrelationKey correlationKey = correlationKeyFactory.newCorrelationKey(caseId);\n-        \n-        Collection<org.jbpm.services.api.model.NodeInstanceDesc> nodes = runtimeDataService.getNodeInstancesByCorrelationKeyNodeType(correlationKey, \n-                                                                                                Arrays.asList(ProcessInstance.STATE_ACTIVE), \n-                                                                                                Arrays.asList(\"MilestoneNode\"), \n-                                                                                                queryContext);\n-        \n-        Collection<Long> completedNodes = nodes.stream().filter(n -> ((NodeInstanceDesc)n).getType() == 1).map(n -> n.getId()).collect(toList());\n-        Predicate<org.jbpm.services.api.model.NodeInstanceDesc> filterNodes = null;\n-        if (achievedOnly) {            \n-            filterNodes = n -> ((NodeInstanceDesc)n).getType() == 1;             \n-        } else {\n-            filterNodes = n -> ((NodeInstanceDesc)n).getType() == 0;\n-        }\n-        List<String> foundMilestones = new ArrayList<>();\n-        \n-        List<CaseMilestoneInstance> milestones = nodes.stream()\n-        .filter(filterNodes)\n-        .map(n -> {\n-            foundMilestones.add(n.getName());\n-            return new CaseMilestoneInstanceImpl(String.valueOf(n.getId()), n.getName(), completedNodes.contains(n.getId()), n.getDataTimeStamp());        \n-        })\n-        .collect(toList());\n-        \n+\n+        Collection<org.jbpm.services.api.model.NodeInstanceDesc> nodes = runtimeDataService.getNodeInstancesByCorrelationKeyNodeType(correlationKey,\n+                                                                                                                                     Arrays.asList(ProcessInstance.STATE_ACTIVE, ProcessInstance.STATE_ABORTED),\n+                                                                                                                                     Arrays.asList(\"MilestoneNode\"),\n+                                                                                                                                     queryContext);\n+\n+        // achieved milestones\n+        Map<String, List<CaseMilestoneInstance>> milestonesGroup = nodes.stream()\n+                                                                        .map(n -> (NodeInstanceDesc) n)\n+                                                                        .filter(n -> n.getType() == 1)\n+                                                                        .map(n -> new CaseMilestoneInstanceImpl(String.valueOf(n.getId()), n.getName(), true, n.getDataTimeStamp()))\n+                                                                        .collect(Collectors.groupingBy(CaseMilestoneInstance::getName));\n+\n+        List<CaseMilestoneInstance> milestones = milestonesGroup.values().stream().map(e -> e.stream().min((o1, o2) -> o1.getAchievedAt().compareTo(o2.getAchievedAt())).get()).collect(toList());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTYwNzIwMw=="}, "originalCommit": {"oid": "ab35c2b1f9ae9bdde151d414c5017aa31b9febe4"}, "originalPosition": 46}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQyNjQ3MjczOnYy", "diffSide": "RIGHT", "path": "jbpm-installer/src/test/resources/ddl60/postgresql/postgresql-jbpm-schema.sql", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMlQxMDoxOTowOFrOF1Yn7w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMlQxMDoxOTowOFrOF1Yn7w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTUyMjI4Nw==", "bodyText": "shouldn't it be \"cancel\"?", "url": "https://github.com/kiegroup/jbpm/pull/1603#discussion_r391522287", "createdAt": "2020-03-12T10:19:08Z", "author": {"login": "gmunozfe"}, "path": "jbpm-installer/src/test/resources/ddl60/postgresql/postgresql-jbpm-schema.sql", "diffHunk": "@@ -130,6 +130,7 @@\n         processInstanceId int8 not null,\n         type int4 not null,\n         workItemId int8,\n+        skipable boolean,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7ac30e55062b2b5f650c74368ed59bd4054f41dc"}, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQyNjQ4MDkxOnYy", "diffSide": "RIGHT", "path": "jbpm-installer/src/test/resources/ddl60/db2/db2-jbpm-schema.sql", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMlQxMDoyMTozM1rOF1YtLw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMlQxNDo0MToyMFrOF1hirA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTUyMzYzMQ==", "bodyText": "do we need to update ddl60 schemas? my understanding is that this is used to test migration from 6.0 to 7.x", "url": "https://github.com/kiegroup/jbpm/pull/1603#discussion_r391523631", "createdAt": "2020-03-12T10:21:33Z", "author": {"login": "gmunozfe"}, "path": "jbpm-installer/src/test/resources/ddl60/db2/db2-jbpm-schema.sql", "diffHunk": "@@ -130,6 +130,7 @@\n         processInstanceId bigint not null,\n         type integer not null,\n         workItemId bigint,\n+        cancel smallint not null,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7ac30e55062b2b5f650c74368ed59bd4054f41dc"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTY2ODM5Ng==", "bodyText": "this flag will be changed in exchange for new type of nodeinstancelog", "url": "https://github.com/kiegroup/jbpm/pull/1603#discussion_r391668396", "createdAt": "2020-03-12T14:41:20Z", "author": {"login": "elguardian"}, "path": "jbpm-installer/src/test/resources/ddl60/db2/db2-jbpm-schema.sql", "diffHunk": "@@ -130,6 +130,7 @@\n         processInstanceId bigint not null,\n         type integer not null,\n         workItemId bigint,\n+        cancel smallint not null,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTUyMzYzMQ=="}, "originalCommit": {"oid": "7ac30e55062b2b5f650c74368ed59bd4054f41dc"}, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQyNjUyMjMxOnYy", "diffSide": "RIGHT", "path": "jbpm-case-mgmt/jbpm-case-mgmt-impl/src/main/java/org/jbpm/casemgmt/impl/CaseRuntimeDataServiceImpl.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMlQxMDozMzoyNVrOF1ZGeQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMlQxNDo0MDo1N1rOF1hhlA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTUzMDEwNQ==", "bodyText": "if both are null, shouldn't it return 0?", "url": "https://github.com/kiegroup/jbpm/pull/1603#discussion_r391530105", "createdAt": "2020-03-12T10:33:25Z", "author": {"login": "gmunozfe"}, "path": "jbpm-case-mgmt/jbpm-case-mgmt-impl/src/main/java/org/jbpm/casemgmt/impl/CaseRuntimeDataServiceImpl.java", "diffHunk": "@@ -340,44 +340,47 @@ public CaseDefinition getCase(String deploymentId, String caseDefinitionId) {\n \n     @Override\n     public Collection<CaseMilestoneInstance> getCaseInstanceMilestones(String caseId, boolean achievedOnly, QueryContext queryContext) {\n-        ProcessInstanceDesc pi = runtimeDataService.getProcessInstanceByCorrelationKey(correlationKeyFactory.newCorrelationKey(caseId));        \n+        ProcessInstanceDesc pi = runtimeDataService.getProcessInstanceByCorrelationKey(correlationKeyFactory.newCorrelationKey(caseId));\n         if (pi == null || !pi.getState().equals(ProcessInstance.STATE_ACTIVE)) {\n             throw new CaseNotFoundException(\"No case instance found with id \" + caseId + \" or it's not active anymore\");\n         }\n         CorrelationKey correlationKey = correlationKeyFactory.newCorrelationKey(caseId);\n-        \n-        Collection<org.jbpm.services.api.model.NodeInstanceDesc> nodes = runtimeDataService.getNodeInstancesByCorrelationKeyNodeType(correlationKey, \n-                                                                                                Arrays.asList(ProcessInstance.STATE_ACTIVE), \n-                                                                                                Arrays.asList(\"MilestoneNode\"), \n-                                                                                                queryContext);\n-        \n-        Collection<Long> completedNodes = nodes.stream().filter(n -> ((NodeInstanceDesc)n).getType() == 1).map(n -> n.getId()).collect(toList());\n-        Predicate<org.jbpm.services.api.model.NodeInstanceDesc> filterNodes = null;\n-        if (achievedOnly) {            \n-            filterNodes = n -> ((NodeInstanceDesc)n).getType() == 1;             \n-        } else {\n-            filterNodes = n -> ((NodeInstanceDesc)n).getType() == 0;\n-        }\n-        List<String> foundMilestones = new ArrayList<>();\n-        \n-        List<CaseMilestoneInstance> milestones = nodes.stream()\n-        .filter(filterNodes)\n-        .map(n -> {\n-            foundMilestones.add(n.getName());\n-            return new CaseMilestoneInstanceImpl(String.valueOf(n.getId()), n.getName(), completedNodes.contains(n.getId()), n.getDataTimeStamp());        \n-        })\n-        .collect(toList());\n-        \n+\n+        Collection<org.jbpm.services.api.model.NodeInstanceDesc> nodes = runtimeDataService.getValidNodeInstancesByCorrelationKeyNodeType(correlationKey,\n+                                                                                                                                     Arrays.asList(ProcessInstance.STATE_ACTIVE, ProcessInstance.STATE_ABORTED),\n+                                                                                                                                     Arrays.asList(\"MilestoneNode\"),\n+                                                                                                                                     queryContext);\n+\n+        // achieved milestones\n+        Map<String, List<CaseMilestoneInstance>> milestonesGroup = nodes.stream()\n+                                                                        .map(n -> (NodeInstanceDesc) n)\n+                                                                        .filter(n -> n.getType() == 1)\n+                                                                        .map(n -> new CaseMilestoneInstanceImpl(String.valueOf(n.getId()), n.getName(), true, n.getDataTimeStamp()))\n+                                                                        .collect(Collectors.groupingBy(CaseMilestoneInstance::getName));\n+\n+        List<CaseMilestoneInstance> milestones = milestonesGroup.values().stream().map(e -> e.stream().min(this::compareMilestones).get()).collect(toList());\n+        List<String> foundMilestones = milestones.stream().map(e -> e.getName()).collect(toList());\n+\n         if (!achievedOnly) {\n             // add other milestones that are present in the definition\n             CaseDefinition caseDef = getCase(pi.getDeploymentId(), pi.getProcessId());\n             caseDef.getCaseMilestones().stream()\n-            .filter(cm -> !foundMilestones.contains(cm.getName()))\n-            .map(cm -> new CaseMilestoneInstanceImpl(cm.getId(), cm.getName(), false, null))\n-            .forEach(cmi -> milestones.add(cmi));\n+                   .filter(cm -> !foundMilestones.contains(cm.getName()))\n+                   .map(cm -> new CaseMilestoneInstanceImpl(cm.getId(), cm.getName(), false, null))\n+                   .forEach(cmi -> milestones.add(cmi));\n         }\n-        \n-        return applyPagination(milestones, queryContext);\n+\n+        List<CaseMilestoneInstance> sortedMilestones = milestones.stream().sorted(this::compareMilestones).collect(toList());\n+        return applyPagination(sortedMilestones, queryContext);\n+    }\n+\n+    private int compareMilestones(CaseMilestoneInstance o1, CaseMilestoneInstance o2) {\n+        if (o1.getAchievedAt() == null) {\n+            return -1;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7ac30e55062b2b5f650c74368ed59bd4054f41dc"}, "originalPosition": 69}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTY2ODExNg==", "bodyText": "null <> null = true... null == null = false... depends on our view.", "url": "https://github.com/kiegroup/jbpm/pull/1603#discussion_r391668116", "createdAt": "2020-03-12T14:40:57Z", "author": {"login": "elguardian"}, "path": "jbpm-case-mgmt/jbpm-case-mgmt-impl/src/main/java/org/jbpm/casemgmt/impl/CaseRuntimeDataServiceImpl.java", "diffHunk": "@@ -340,44 +340,47 @@ public CaseDefinition getCase(String deploymentId, String caseDefinitionId) {\n \n     @Override\n     public Collection<CaseMilestoneInstance> getCaseInstanceMilestones(String caseId, boolean achievedOnly, QueryContext queryContext) {\n-        ProcessInstanceDesc pi = runtimeDataService.getProcessInstanceByCorrelationKey(correlationKeyFactory.newCorrelationKey(caseId));        \n+        ProcessInstanceDesc pi = runtimeDataService.getProcessInstanceByCorrelationKey(correlationKeyFactory.newCorrelationKey(caseId));\n         if (pi == null || !pi.getState().equals(ProcessInstance.STATE_ACTIVE)) {\n             throw new CaseNotFoundException(\"No case instance found with id \" + caseId + \" or it's not active anymore\");\n         }\n         CorrelationKey correlationKey = correlationKeyFactory.newCorrelationKey(caseId);\n-        \n-        Collection<org.jbpm.services.api.model.NodeInstanceDesc> nodes = runtimeDataService.getNodeInstancesByCorrelationKeyNodeType(correlationKey, \n-                                                                                                Arrays.asList(ProcessInstance.STATE_ACTIVE), \n-                                                                                                Arrays.asList(\"MilestoneNode\"), \n-                                                                                                queryContext);\n-        \n-        Collection<Long> completedNodes = nodes.stream().filter(n -> ((NodeInstanceDesc)n).getType() == 1).map(n -> n.getId()).collect(toList());\n-        Predicate<org.jbpm.services.api.model.NodeInstanceDesc> filterNodes = null;\n-        if (achievedOnly) {            \n-            filterNodes = n -> ((NodeInstanceDesc)n).getType() == 1;             \n-        } else {\n-            filterNodes = n -> ((NodeInstanceDesc)n).getType() == 0;\n-        }\n-        List<String> foundMilestones = new ArrayList<>();\n-        \n-        List<CaseMilestoneInstance> milestones = nodes.stream()\n-        .filter(filterNodes)\n-        .map(n -> {\n-            foundMilestones.add(n.getName());\n-            return new CaseMilestoneInstanceImpl(String.valueOf(n.getId()), n.getName(), completedNodes.contains(n.getId()), n.getDataTimeStamp());        \n-        })\n-        .collect(toList());\n-        \n+\n+        Collection<org.jbpm.services.api.model.NodeInstanceDesc> nodes = runtimeDataService.getValidNodeInstancesByCorrelationKeyNodeType(correlationKey,\n+                                                                                                                                     Arrays.asList(ProcessInstance.STATE_ACTIVE, ProcessInstance.STATE_ABORTED),\n+                                                                                                                                     Arrays.asList(\"MilestoneNode\"),\n+                                                                                                                                     queryContext);\n+\n+        // achieved milestones\n+        Map<String, List<CaseMilestoneInstance>> milestonesGroup = nodes.stream()\n+                                                                        .map(n -> (NodeInstanceDesc) n)\n+                                                                        .filter(n -> n.getType() == 1)\n+                                                                        .map(n -> new CaseMilestoneInstanceImpl(String.valueOf(n.getId()), n.getName(), true, n.getDataTimeStamp()))\n+                                                                        .collect(Collectors.groupingBy(CaseMilestoneInstance::getName));\n+\n+        List<CaseMilestoneInstance> milestones = milestonesGroup.values().stream().map(e -> e.stream().min(this::compareMilestones).get()).collect(toList());\n+        List<String> foundMilestones = milestones.stream().map(e -> e.getName()).collect(toList());\n+\n         if (!achievedOnly) {\n             // add other milestones that are present in the definition\n             CaseDefinition caseDef = getCase(pi.getDeploymentId(), pi.getProcessId());\n             caseDef.getCaseMilestones().stream()\n-            .filter(cm -> !foundMilestones.contains(cm.getName()))\n-            .map(cm -> new CaseMilestoneInstanceImpl(cm.getId(), cm.getName(), false, null))\n-            .forEach(cmi -> milestones.add(cmi));\n+                   .filter(cm -> !foundMilestones.contains(cm.getName()))\n+                   .map(cm -> new CaseMilestoneInstanceImpl(cm.getId(), cm.getName(), false, null))\n+                   .forEach(cmi -> milestones.add(cmi));\n         }\n-        \n-        return applyPagination(milestones, queryContext);\n+\n+        List<CaseMilestoneInstance> sortedMilestones = milestones.stream().sorted(this::compareMilestones).collect(toList());\n+        return applyPagination(sortedMilestones, queryContext);\n+    }\n+\n+    private int compareMilestones(CaseMilestoneInstance o1, CaseMilestoneInstance o2) {\n+        if (o1.getAchievedAt() == null) {\n+            return -1;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTUzMDEwNQ=="}, "originalCommit": {"oid": "7ac30e55062b2b5f650c74368ed59bd4054f41dc"}, "originalPosition": 69}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1819, "cost": 1, "resetAt": "2021-11-12T20:28:25Z"}}}