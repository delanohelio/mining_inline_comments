{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTM2OTEzMzQw", "number": 1822, "title": "[JBPM-9507] Align DataAssociation behavior with kogito", "bodyText": "Changes in parser and evaluator to align with non standard behavior\nJIRA:\nJBPM-9507", "createdAt": "2020-12-11T13:52:48Z", "url": "https://github.com/kiegroup/jbpm/pull/1822", "merged": true, "mergeCommit": {"oid": "b0cd4dd80a9ca0a18199267c740ca44327210622"}, "closed": true, "closedAt": "2020-12-16T11:19:01Z", "author": {"login": "fjtirado"}, "timelineItems": {"totalCount": 12, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdlKfldgBqjQxMDEyMDQxMjI=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdmretUgFqTU1MzQ5NzgyMg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "a638125ebd7cf4d48975ed899d97d6c39bf75374", "author": {"user": {"login": "fjtirado", "name": "Francisco Javier Tirado Sarti"}}, "url": "https://github.com/kiegroup/jbpm/commit/a638125ebd7cf4d48975ed899d97d6c39bf75374", "committedDate": "2020-12-11T13:52:20Z", "message": "[JBPM-9507] Align DataAssociation behavior with kogito\n\nChanges in parser and evaluator to align with non standard behavior"}, "afterCommit": {"oid": "27c6569ff1c061584b8e14b3c5837ae1b3cd6162", "author": {"user": {"login": "fjtirado", "name": "Francisco Javier Tirado Sarti"}}, "url": "https://github.com/kiegroup/jbpm/commit/27c6569ff1c061584b8e14b3c5837ae1b3cd6162", "committedDate": "2020-12-11T16:25:28Z", "message": "[JBPM-9507] Align DataAssociation behavior with kogito\n\nChanges in parser and evaluator to align with non standard behavior"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "27c6569ff1c061584b8e14b3c5837ae1b3cd6162", "author": {"user": {"login": "fjtirado", "name": "Francisco Javier Tirado Sarti"}}, "url": "https://github.com/kiegroup/jbpm/commit/27c6569ff1c061584b8e14b3c5837ae1b3cd6162", "committedDate": "2020-12-11T16:25:28Z", "message": "[JBPM-9507] Align DataAssociation behavior with kogito\n\nChanges in parser and evaluator to align with non standard behavior"}, "afterCommit": {"oid": "85fca05f7f72af2e73f27a72b25c882b00e70e69", "author": {"user": {"login": "fjtirado", "name": "Francisco Javier Tirado Sarti"}}, "url": "https://github.com/kiegroup/jbpm/commit/85fca05f7f72af2e73f27a72b25c882b00e70e69", "committedDate": "2020-12-11T16:47:18Z", "message": "[JBPM-9507] Align DataAssociation behavior with kogito\n\nChanges in parser and evaluator to align with non standard behavior"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "85fca05f7f72af2e73f27a72b25c882b00e70e69", "author": {"user": {"login": "fjtirado", "name": "Francisco Javier Tirado Sarti"}}, "url": "https://github.com/kiegroup/jbpm/commit/85fca05f7f72af2e73f27a72b25c882b00e70e69", "committedDate": "2020-12-11T16:47:18Z", "message": "[JBPM-9507] Align DataAssociation behavior with kogito\n\nChanges in parser and evaluator to align with non standard behavior"}, "afterCommit": {"oid": "439fa0ec68474e97e86003de1a879f88e20f284f", "author": {"user": {"login": "fjtirado", "name": "Francisco Javier Tirado Sarti"}}, "url": "https://github.com/kiegroup/jbpm/commit/439fa0ec68474e97e86003de1a879f88e20f284f", "committedDate": "2020-12-11T17:05:54Z", "message": "[JBPM-9507] Align DataAssociation behavior with kogito\n\nChanges in parser and evaluator to align with non standard behavior"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "439fa0ec68474e97e86003de1a879f88e20f284f", "author": {"user": {"login": "fjtirado", "name": "Francisco Javier Tirado Sarti"}}, "url": "https://github.com/kiegroup/jbpm/commit/439fa0ec68474e97e86003de1a879f88e20f284f", "committedDate": "2020-12-11T17:05:54Z", "message": "[JBPM-9507] Align DataAssociation behavior with kogito\n\nChanges in parser and evaluator to align with non standard behavior"}, "afterCommit": {"oid": "9f271d537d84be0aafab5545f62c59f9aae0b67b", "author": {"user": {"login": "fjtirado", "name": "Francisco Javier Tirado Sarti"}}, "url": "https://github.com/kiegroup/jbpm/commit/9f271d537d84be0aafab5545f62c59f9aae0b67b", "committedDate": "2020-12-11T17:18:06Z", "message": "[JBPM-9507] Align DataAssociation behavior with kogito\n\nChanges in parser and evaluator to align with non standard behavior"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "9f271d537d84be0aafab5545f62c59f9aae0b67b", "author": {"user": {"login": "fjtirado", "name": "Francisco Javier Tirado Sarti"}}, "url": "https://github.com/kiegroup/jbpm/commit/9f271d537d84be0aafab5545f62c59f9aae0b67b", "committedDate": "2020-12-11T17:18:06Z", "message": "[JBPM-9507] Align DataAssociation behavior with kogito\n\nChanges in parser and evaluator to align with non standard behavior"}, "afterCommit": {"oid": "8f451ed5064e5f1c4819568153515cc5f2c8212a", "author": {"user": {"login": "fjtirado", "name": "Francisco Javier Tirado Sarti"}}, "url": "https://github.com/kiegroup/jbpm/commit/8f451ed5064e5f1c4819568153515cc5f2c8212a", "committedDate": "2020-12-11T17:20:45Z", "message": "[JBPM-9507] Align DataAssociation behavior with kogito\n\nChanges in parser and evaluator to align with non standard behavior"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "8f451ed5064e5f1c4819568153515cc5f2c8212a", "author": {"user": {"login": "fjtirado", "name": "Francisco Javier Tirado Sarti"}}, "url": "https://github.com/kiegroup/jbpm/commit/8f451ed5064e5f1c4819568153515cc5f2c8212a", "committedDate": "2020-12-11T17:20:45Z", "message": "[JBPM-9507] Align DataAssociation behavior with kogito\n\nChanges in parser and evaluator to align with non standard behavior"}, "afterCommit": {"oid": "9ea31f0debf0032104f736a28e8a4b2fc5a7a748", "author": {"user": {"login": "fjtirado", "name": "Francisco Javier Tirado Sarti"}}, "url": "https://github.com/kiegroup/jbpm/commit/9ea31f0debf0032104f736a28e8a4b2fc5a7a748", "committedDate": "2020-12-14T10:49:42Z", "message": "[JBPM-9507] Align DataAssociation behavior with kogito\n\nChanges in parser and evaluator to align with non standard behavior"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "9ea31f0debf0032104f736a28e8a4b2fc5a7a748", "author": {"user": {"login": "fjtirado", "name": "Francisco Javier Tirado Sarti"}}, "url": "https://github.com/kiegroup/jbpm/commit/9ea31f0debf0032104f736a28e8a4b2fc5a7a748", "committedDate": "2020-12-14T10:49:42Z", "message": "[JBPM-9507] Align DataAssociation behavior with kogito\n\nChanges in parser and evaluator to align with non standard behavior"}, "afterCommit": {"oid": "51c65b810e66e0e23eedcf03abca9c08d167cd1f", "author": {"user": {"login": "fjtirado", "name": "Francisco Javier Tirado Sarti"}}, "url": "https://github.com/kiegroup/jbpm/commit/51c65b810e66e0e23eedcf03abca9c08d167cd1f", "committedDate": "2020-12-14T11:42:42Z", "message": "[JBPM-9507] Align DataAssociation behavior with kogito\n\nChanges in parser and evaluator to align with non standard behavior"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "51c65b810e66e0e23eedcf03abca9c08d167cd1f", "author": {"user": {"login": "fjtirado", "name": "Francisco Javier Tirado Sarti"}}, "url": "https://github.com/kiegroup/jbpm/commit/51c65b810e66e0e23eedcf03abca9c08d167cd1f", "committedDate": "2020-12-14T11:42:42Z", "message": "[JBPM-9507] Align DataAssociation behavior with kogito\n\nChanges in parser and evaluator to align with non standard behavior"}, "afterCommit": {"oid": "ff06d823ef343533eb7d6db57b1a3facbd1316cc", "author": {"user": {"login": "fjtirado", "name": "Francisco Javier Tirado Sarti"}}, "url": "https://github.com/kiegroup/jbpm/commit/ff06d823ef343533eb7d6db57b1a3facbd1316cc", "committedDate": "2020-12-14T11:50:50Z", "message": "[JBPM-9507] Align DataAssociation behavior with kogito\n\nChanges in parser and evaluator to align with non standard behavior"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTUyMjAwNjU2", "url": "https://github.com/kiegroup/jbpm/pull/1822#pullrequestreview-552200656", "createdAt": "2020-12-15T08:18:57Z", "commit": {"oid": "ff06d823ef343533eb7d6db57b1a3facbd1316cc"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 16, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNVQwODoxODo1N1rOIF-Urg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNVQxMTo0MToyMVrOIGGsrA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzEzNDg5NA==", "bodyText": "small typo\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public static boolean isLegacyAssigment(String source, List<Assignment> assignments) {\n          \n          \n            \n                public static boolean isLegacyAssignment(String source, List<Assignment> assignments) {", "url": "https://github.com/kiegroup/jbpm/pull/1822#discussion_r543134894", "createdAt": "2020-12-15T08:18:57Z", "author": {"login": "afalhambra"}, "path": "jbpm-bpmn2/src/main/java/org/jbpm/bpmn2/xml/elements/DataAssociationFactory.java", "diffHunk": "@@ -33,84 +37,181 @@\n import org.slf4j.LoggerFactory;\n import org.w3c.dom.Node;\n import org.w3c.dom.NodeList;\n+import org.w3c.dom.Text;\n \n public final class DataAssociationFactory {\n-    \n+\n     protected static final String LANG_EXPRESSION_ATTR = \"language\";\n     protected static final String DEFAULT_DIALECT = \"XPath\";\n     protected static final String USE_DEFINITION_LANGUAGE_PROPERTY = \"org.kie.jbpm.bpmn2.useDefinitionLanguage\";\n+    private static final String SOURCE_REF = \"sourceRef\";\n+    private static final String TARGET_REF = \"targetRef\";\n+    private static final String TRANSFORMATION = \"transformation\";\n+    private static final String ASSIGNMENT = \"assignment\";\n     private static final Logger logger = LoggerFactory.getLogger(DataAssociationFactory.class);\n-    \n     private static Map<String, Pattern> dialectPatterns = buildDialectPatterns(ProcessDialectRegistry.getDialects());\n \n-    private DataAssociationFactory() {\n-        // do nothing\n-    }\n+    private DataAssociationFactory() {}\n \n     public static DataAssociation readDataOutputAssociation(Node xmlNode, Map<String, String> dataOutputs) {\n-\n         NodeList nodeList = xmlNode.getChildNodes();\n         String source = null;\n         String target = null;\n         Transformation transformation = null;\n         List<Assignment> assignment = new ArrayList<>();\n-        for(int i = 0; i < nodeList.getLength(); i++) {\n+        for (int i = 0; i < nodeList.getLength(); i++) {\n             Node subNode = nodeList.item(i);\n-            switch(subNode.getNodeName()) {\n-                case \"sourceRef\":\n-                {\n+            switch (subNode.getNodeName()) {\n+                case SOURCE_REF:\n                     source = subNode.getTextContent();\n-                    if(!dataOutputs.containsKey(source)) {\n-                        logger.warn(\"Data outputs in this node {} does not contain source {}\", xmlNode.getAttributes().getNamedItem(\"id\"), source);\n+                    String mapped = dataOutputs.get(source);\n+                    if (mapped == null) {\n+                        logger.warn(\"Data outputs in this node {} does not contain source {}\", xmlNode.getAttributes()\n+                                .getNamedItem(\"id\"), source);\n+                    }\n+                    else {\n+                        source = mapped;\n                     }\n-                    // indirection\n-                    source = dataOutputs.get(source);\n                     break;\n-                }\n-                case \"targetRef\":\n-                {\n+                case TARGET_REF:\n                     target = subNode.getTextContent();\n                     break;\n-                }\n-                case \"transformation\":\n-                {\n+                case TRANSFORMATION:\n                     String lang = subNode.getAttributes().getNamedItem(LANG_EXPRESSION_ATTR).getNodeValue();\n                     String expression = subNode.getTextContent();\n                     transformation = new Transformation(lang, expression, source);\n                     break;\n-                }\n-                case \"assignment\":\n-                {\n-                    assignment.add(readAssignment(subNode));\n+                case ASSIGNMENT:\n+                    assignment.add(readAssignment(subNode, dataOutputs));\n                     break;\n-                }\n             }\n-\n         }\n         return new DataAssociation(source, target, assignment, transformation);\n     }\n-    \n+\n+    public static void readDataInputAssociation(Node xmlNode,\n+                                                Map<String, String> dataInputs,\n+                                                BiPredicate<String, List<Assignment>> isLegacy,\n+                                                Consumer<DataAssociation> addAssigment,\n+                                                BiConsumer<String, Object> legacyAssigment) {\n+        NodeList nodeList = xmlNode.getChildNodes();\n+        String source = null;\n+        String target = null;\n+        Transformation transformation = null;\n+        List<Assignment> assignments = new ArrayList<>();\n+        Node assignmentNode = null;\n+        for (int i = 0; i < nodeList.getLength(); i++) {\n+            Node subNode = nodeList.item(i);\n+            switch (subNode.getNodeName()) {\n+                case SOURCE_REF:\n+                    source = subNode.getTextContent();\n+                    break;\n+                case TARGET_REF:\n+                    target = subNode.getTextContent();\n+                    String mapped = dataInputs.get(target);\n+                    if (mapped == null) {\n+                        logger.warn(\"Data inputs in this node {} does not contain target {}\", xmlNode.getAttributes()\n+                                .getNamedItem(\"id\"), target);\n+                    }\n+                    else {\n+                        target = mapped;\n+                    }\n+                    break;\n+                case TRANSFORMATION:\n+                    transformation = new Transformation(subNode.getAttributes().getNamedItem(LANG_EXPRESSION_ATTR)\n+                            .getNodeValue(), subNode.getTextContent());\n+                    break;\n+                case ASSIGNMENT:\n+                    assignmentNode = subNode;\n+                    assignments.add(readAssignment(subNode, dataInputs));\n+                    break;\n+            }\n+        }\n+        if (isLegacy.test(source, assignments))\n+        {\n+            Object value = getValue(assignmentNode);\n+            if (value != null) {\n+                legacyAssigment.accept(target, value);\n+            }\n+        } else {\n+            addAssigment.accept(new DataAssociation(source, target, assignments, transformation));\n+        }\n+    }\n+\n+    public static boolean isLegacyAssigment(String source, List<Assignment> assignments) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ff06d823ef343533eb7d6db57b1a3facbd1316cc"}, "originalPosition": 146}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzE0NTc0Mg==", "bodyText": "!assignments.isEmpty() when reached is always false. Expression can be simplified to\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    return source == null && assignments.isEmpty() || source == null && !assignments.isEmpty() && assignments.get(0)\n          \n          \n            \n                            .getDialect().equals(DEFAULT_DIALECT);\n          \n          \n            \n                    return source == null && assignments.isEmpty() || source == null && assignments.get(0)\n          \n          \n            \n                            .getDialect().equals(DEFAULT_DIALECT);\n          \n      \n    \n    \n  \n\nAlso, as this is declared as a public static method, just for safety - wouldn't be worth checking a non-empty source and a non-null assignment? wdyt?", "url": "https://github.com/kiegroup/jbpm/pull/1822#discussion_r543145742", "createdAt": "2020-12-15T08:35:40Z", "author": {"login": "afalhambra"}, "path": "jbpm-bpmn2/src/main/java/org/jbpm/bpmn2/xml/elements/DataAssociationFactory.java", "diffHunk": "@@ -33,84 +37,181 @@\n import org.slf4j.LoggerFactory;\n import org.w3c.dom.Node;\n import org.w3c.dom.NodeList;\n+import org.w3c.dom.Text;\n \n public final class DataAssociationFactory {\n-    \n+\n     protected static final String LANG_EXPRESSION_ATTR = \"language\";\n     protected static final String DEFAULT_DIALECT = \"XPath\";\n     protected static final String USE_DEFINITION_LANGUAGE_PROPERTY = \"org.kie.jbpm.bpmn2.useDefinitionLanguage\";\n+    private static final String SOURCE_REF = \"sourceRef\";\n+    private static final String TARGET_REF = \"targetRef\";\n+    private static final String TRANSFORMATION = \"transformation\";\n+    private static final String ASSIGNMENT = \"assignment\";\n     private static final Logger logger = LoggerFactory.getLogger(DataAssociationFactory.class);\n-    \n     private static Map<String, Pattern> dialectPatterns = buildDialectPatterns(ProcessDialectRegistry.getDialects());\n \n-    private DataAssociationFactory() {\n-        // do nothing\n-    }\n+    private DataAssociationFactory() {}\n \n     public static DataAssociation readDataOutputAssociation(Node xmlNode, Map<String, String> dataOutputs) {\n-\n         NodeList nodeList = xmlNode.getChildNodes();\n         String source = null;\n         String target = null;\n         Transformation transformation = null;\n         List<Assignment> assignment = new ArrayList<>();\n-        for(int i = 0; i < nodeList.getLength(); i++) {\n+        for (int i = 0; i < nodeList.getLength(); i++) {\n             Node subNode = nodeList.item(i);\n-            switch(subNode.getNodeName()) {\n-                case \"sourceRef\":\n-                {\n+            switch (subNode.getNodeName()) {\n+                case SOURCE_REF:\n                     source = subNode.getTextContent();\n-                    if(!dataOutputs.containsKey(source)) {\n-                        logger.warn(\"Data outputs in this node {} does not contain source {}\", xmlNode.getAttributes().getNamedItem(\"id\"), source);\n+                    String mapped = dataOutputs.get(source);\n+                    if (mapped == null) {\n+                        logger.warn(\"Data outputs in this node {} does not contain source {}\", xmlNode.getAttributes()\n+                                .getNamedItem(\"id\"), source);\n+                    }\n+                    else {\n+                        source = mapped;\n                     }\n-                    // indirection\n-                    source = dataOutputs.get(source);\n                     break;\n-                }\n-                case \"targetRef\":\n-                {\n+                case TARGET_REF:\n                     target = subNode.getTextContent();\n                     break;\n-                }\n-                case \"transformation\":\n-                {\n+                case TRANSFORMATION:\n                     String lang = subNode.getAttributes().getNamedItem(LANG_EXPRESSION_ATTR).getNodeValue();\n                     String expression = subNode.getTextContent();\n                     transformation = new Transformation(lang, expression, source);\n                     break;\n-                }\n-                case \"assignment\":\n-                {\n-                    assignment.add(readAssignment(subNode));\n+                case ASSIGNMENT:\n+                    assignment.add(readAssignment(subNode, dataOutputs));\n                     break;\n-                }\n             }\n-\n         }\n         return new DataAssociation(source, target, assignment, transformation);\n     }\n-    \n+\n+    public static void readDataInputAssociation(Node xmlNode,\n+                                                Map<String, String> dataInputs,\n+                                                BiPredicate<String, List<Assignment>> isLegacy,\n+                                                Consumer<DataAssociation> addAssigment,\n+                                                BiConsumer<String, Object> legacyAssigment) {\n+        NodeList nodeList = xmlNode.getChildNodes();\n+        String source = null;\n+        String target = null;\n+        Transformation transformation = null;\n+        List<Assignment> assignments = new ArrayList<>();\n+        Node assignmentNode = null;\n+        for (int i = 0; i < nodeList.getLength(); i++) {\n+            Node subNode = nodeList.item(i);\n+            switch (subNode.getNodeName()) {\n+                case SOURCE_REF:\n+                    source = subNode.getTextContent();\n+                    break;\n+                case TARGET_REF:\n+                    target = subNode.getTextContent();\n+                    String mapped = dataInputs.get(target);\n+                    if (mapped == null) {\n+                        logger.warn(\"Data inputs in this node {} does not contain target {}\", xmlNode.getAttributes()\n+                                .getNamedItem(\"id\"), target);\n+                    }\n+                    else {\n+                        target = mapped;\n+                    }\n+                    break;\n+                case TRANSFORMATION:\n+                    transformation = new Transformation(subNode.getAttributes().getNamedItem(LANG_EXPRESSION_ATTR)\n+                            .getNodeValue(), subNode.getTextContent());\n+                    break;\n+                case ASSIGNMENT:\n+                    assignmentNode = subNode;\n+                    assignments.add(readAssignment(subNode, dataInputs));\n+                    break;\n+            }\n+        }\n+        if (isLegacy.test(source, assignments))\n+        {\n+            Object value = getValue(assignmentNode);\n+            if (value != null) {\n+                legacyAssigment.accept(target, value);\n+            }\n+        } else {\n+            addAssigment.accept(new DataAssociation(source, target, assignments, transformation));\n+        }\n+    }\n+\n+    public static boolean isLegacyAssigment(String source, List<Assignment> assignments) {\n+        return source == null && assignments.isEmpty() || source == null && !assignments.isEmpty() && assignments.get(0)\n+                .getDialect().equals(DEFAULT_DIALECT);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ff06d823ef343533eb7d6db57b1a3facbd1316cc"}, "originalPosition": 148}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzE0NjE1OQ==", "bodyText": "typo\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                                            Consumer<DataAssociation> addAssigment,\n          \n          \n            \n                                                            BiConsumer<String, Object> legacyAssigment) {\n          \n          \n            \n                                                            Consumer<DataAssociation> addAssignment,\n          \n          \n            \n                                                            BiConsumer<String, Object> legacyAssignment) {", "url": "https://github.com/kiegroup/jbpm/pull/1822#discussion_r543146159", "createdAt": "2020-12-15T08:36:23Z", "author": {"login": "afalhambra"}, "path": "jbpm-bpmn2/src/main/java/org/jbpm/bpmn2/xml/elements/DataAssociationFactory.java", "diffHunk": "@@ -33,84 +37,181 @@\n import org.slf4j.LoggerFactory;\n import org.w3c.dom.Node;\n import org.w3c.dom.NodeList;\n+import org.w3c.dom.Text;\n \n public final class DataAssociationFactory {\n-    \n+\n     protected static final String LANG_EXPRESSION_ATTR = \"language\";\n     protected static final String DEFAULT_DIALECT = \"XPath\";\n     protected static final String USE_DEFINITION_LANGUAGE_PROPERTY = \"org.kie.jbpm.bpmn2.useDefinitionLanguage\";\n+    private static final String SOURCE_REF = \"sourceRef\";\n+    private static final String TARGET_REF = \"targetRef\";\n+    private static final String TRANSFORMATION = \"transformation\";\n+    private static final String ASSIGNMENT = \"assignment\";\n     private static final Logger logger = LoggerFactory.getLogger(DataAssociationFactory.class);\n-    \n     private static Map<String, Pattern> dialectPatterns = buildDialectPatterns(ProcessDialectRegistry.getDialects());\n \n-    private DataAssociationFactory() {\n-        // do nothing\n-    }\n+    private DataAssociationFactory() {}\n \n     public static DataAssociation readDataOutputAssociation(Node xmlNode, Map<String, String> dataOutputs) {\n-\n         NodeList nodeList = xmlNode.getChildNodes();\n         String source = null;\n         String target = null;\n         Transformation transformation = null;\n         List<Assignment> assignment = new ArrayList<>();\n-        for(int i = 0; i < nodeList.getLength(); i++) {\n+        for (int i = 0; i < nodeList.getLength(); i++) {\n             Node subNode = nodeList.item(i);\n-            switch(subNode.getNodeName()) {\n-                case \"sourceRef\":\n-                {\n+            switch (subNode.getNodeName()) {\n+                case SOURCE_REF:\n                     source = subNode.getTextContent();\n-                    if(!dataOutputs.containsKey(source)) {\n-                        logger.warn(\"Data outputs in this node {} does not contain source {}\", xmlNode.getAttributes().getNamedItem(\"id\"), source);\n+                    String mapped = dataOutputs.get(source);\n+                    if (mapped == null) {\n+                        logger.warn(\"Data outputs in this node {} does not contain source {}\", xmlNode.getAttributes()\n+                                .getNamedItem(\"id\"), source);\n+                    }\n+                    else {\n+                        source = mapped;\n                     }\n-                    // indirection\n-                    source = dataOutputs.get(source);\n                     break;\n-                }\n-                case \"targetRef\":\n-                {\n+                case TARGET_REF:\n                     target = subNode.getTextContent();\n                     break;\n-                }\n-                case \"transformation\":\n-                {\n+                case TRANSFORMATION:\n                     String lang = subNode.getAttributes().getNamedItem(LANG_EXPRESSION_ATTR).getNodeValue();\n                     String expression = subNode.getTextContent();\n                     transformation = new Transformation(lang, expression, source);\n                     break;\n-                }\n-                case \"assignment\":\n-                {\n-                    assignment.add(readAssignment(subNode));\n+                case ASSIGNMENT:\n+                    assignment.add(readAssignment(subNode, dataOutputs));\n                     break;\n-                }\n             }\n-\n         }\n         return new DataAssociation(source, target, assignment, transformation);\n     }\n-    \n+\n+    public static void readDataInputAssociation(Node xmlNode,\n+                                                Map<String, String> dataInputs,\n+                                                BiPredicate<String, List<Assignment>> isLegacy,\n+                                                Consumer<DataAssociation> addAssigment,\n+                                                BiConsumer<String, Object> legacyAssigment) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ff06d823ef343533eb7d6db57b1a3facbd1316cc"}, "originalPosition": 101}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzE3MDY3OA==", "bodyText": "class member transformerRegistry is now no longer used - please remove\n\n  \n    \n      jbpm/jbpm-bpmn2/src/main/java/org/jbpm/bpmn2/xml/BusinessRuleTaskHandler.java\n    \n    \n         Line 37\n      in\n      ff06d82\n    \n    \n    \n    \n\n        \n          \n           private DataTransformerRegistry transformerRegistry = DataTransformerRegistry.get();", "url": "https://github.com/kiegroup/jbpm/pull/1822#discussion_r543170678", "createdAt": "2020-12-15T09:13:00Z", "author": {"login": "afalhambra"}, "path": "jbpm-bpmn2/src/main/java/org/jbpm/bpmn2/xml/BusinessRuleTaskHandler.java", "diffHunk": "@@ -99,87 +94,18 @@ public void writeNode(Node node, StringBuilder xmlDump, int metaDataType) {\n \t\tendNode(\"businessRuleTask\", xmlDump);\n \t}\n \t\n-\tprotected void readDataInputAssociation(org.w3c.dom.Node xmlNode, RuleSetNode ruleSetNode, Map<String, String> dataInputs) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ff06d823ef343533eb7d6db57b1a3facbd1316cc"}, "originalPosition": 18}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzE3MTE5OA==", "bodyText": "class member transformerRegistry is now no longer used - please remove\n\n  \n    \n      jbpm/jbpm-bpmn2/src/main/java/org/jbpm/bpmn2/xml/TaskHandler.java\n    \n    \n         Line 41\n      in\n      ff06d82\n    \n    \n    \n    \n\n        \n          \n           private DataTransformerRegistry transformerRegistry = DataTransformerRegistry.get();", "url": "https://github.com/kiegroup/jbpm/pull/1822#discussion_r543171198", "createdAt": "2020-12-15T09:13:49Z", "author": {"login": "afalhambra"}, "path": "jbpm-bpmn2/src/main/java/org/jbpm/bpmn2/xml/TaskHandler.java", "diffHunk": "@@ -150,86 +145,12 @@ protected void readIoSpecification(org.w3c.dom.Node xmlNode, Map<String, String>\n     }\n \n     protected void readDataInputAssociation(org.w3c.dom.Node xmlNode, WorkItemNode workItemNode, Map<String, String> dataInputs) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ff06d823ef343533eb7d6db57b1a3facbd1316cc"}, "originalPosition": 19}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzE3Mjg5Ng==", "bodyText": "I can't find this check in new change. Not sure if this is still applicable. Let me know.", "url": "https://github.com/kiegroup/jbpm/pull/1822#discussion_r543172896", "createdAt": "2020-12-15T09:16:15Z", "author": {"login": "afalhambra"}, "path": "jbpm-bpmn2/src/main/java/org/jbpm/bpmn2/xml/BusinessRuleTaskHandler.java", "diffHunk": "@@ -99,87 +94,18 @@ public void writeNode(Node node, StringBuilder xmlDump, int metaDataType) {\n \t\tendNode(\"businessRuleTask\", xmlDump);\n \t}\n \t\n-\tprotected void readDataInputAssociation(org.w3c.dom.Node xmlNode, RuleSetNode ruleSetNode, Map<String, String> dataInputs) {\n-        // sourceRef\n-        org.w3c.dom.Node subNode = xmlNode.getFirstChild();\n-        if (\"sourceRef\".equals(subNode.getNodeName())) {\n-            String source = subNode.getTextContent();\n-            // targetRef\n-            subNode = subNode.getNextSibling();\n-            String target = subNode.getTextContent();\n-            // transformation\n-    \t\tTransformation transformation = null;\n-    \t\tsubNode = subNode.getNextSibling();\n-    \t\tif (subNode != null && \"transformation\".equals(subNode.getNodeName())) {\n-    \t\t\tString lang = subNode.getAttributes().getNamedItem(\"language\").getNodeValue();\n-    \t\t\tString expression = subNode.getTextContent();\n-    \t\t\t\n-    \t\t\tDataTransformer transformer = transformerRegistry.find(lang);\n-    \t\t\tif (transformer == null) {\n-    \t\t\t\tthrow new IllegalArgumentException(\"No transformer registered for language \" + lang);\n-    \t\t\t}    \t\t\t", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ff06d823ef343533eb7d6db57b1a3facbd1316cc"}, "originalPosition": 36}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzE3MzIxNw==", "bodyText": "I can't find this check in new change. Not sure if this is still applicable. Let me know.", "url": "https://github.com/kiegroup/jbpm/pull/1822#discussion_r543173217", "createdAt": "2020-12-15T09:16:43Z", "author": {"login": "afalhambra"}, "path": "jbpm-bpmn2/src/main/java/org/jbpm/bpmn2/xml/BusinessRuleTaskHandler.java", "diffHunk": "@@ -99,87 +94,18 @@ public void writeNode(Node node, StringBuilder xmlDump, int metaDataType) {\n \t\tendNode(\"businessRuleTask\", xmlDump);\n \t}\n \t\n-\tprotected void readDataInputAssociation(org.w3c.dom.Node xmlNode, RuleSetNode ruleSetNode, Map<String, String> dataInputs) {\n-        // sourceRef\n-        org.w3c.dom.Node subNode = xmlNode.getFirstChild();\n-        if (\"sourceRef\".equals(subNode.getNodeName())) {\n-            String source = subNode.getTextContent();\n-            // targetRef\n-            subNode = subNode.getNextSibling();\n-            String target = subNode.getTextContent();\n-            // transformation\n-    \t\tTransformation transformation = null;\n-    \t\tsubNode = subNode.getNextSibling();\n-    \t\tif (subNode != null && \"transformation\".equals(subNode.getNodeName())) {\n-    \t\t\tString lang = subNode.getAttributes().getNamedItem(\"language\").getNodeValue();\n-    \t\t\tString expression = subNode.getTextContent();\n-    \t\t\t\n-    \t\t\tDataTransformer transformer = transformerRegistry.find(lang);\n-    \t\t\tif (transformer == null) {\n-    \t\t\t\tthrow new IllegalArgumentException(\"No transformer registered for language \" + lang);\n-    \t\t\t}    \t\t\t\n-    \t\t\ttransformation = new Transformation(lang, expression);    \t\t\t\n-    \t\t\t\n-    \t\t\tsubNode = subNode.getNextSibling();\n-    \t\t}\n-    \t\t// assignments  \n-            ruleSetNode.addInAssociation(new DataAssociation(source, dataInputs.get(target), DataAssociationFactory\n-                    .readAssignments(subNode), transformation));\n-        } else {\n-            // targetRef\n-            String to = subNode.getTextContent();\n-            // assignment\n-            subNode = subNode.getNextSibling();\n-            if (subNode != null) {\n-                org.w3c.dom.Node subSubNode = subNode.getFirstChild();\n-                NodeList nl = subSubNode.getChildNodes();\n-                if (nl.getLength() > 1) {\n-                    // not supported ?\n-                    ruleSetNode.setParameter(dataInputs.get(to), subSubNode.getTextContent());\n-                    return;\n-                } else if (nl.getLength() == 0) {\n-                    return;\n-                }\n-                Object result = null;\n-                Object from = nl.item(0);\n-                if (from instanceof Text) {\n-                    String text = ((Text) from).getTextContent();\n-                    if (text.startsWith(\"\\\"\") && text.endsWith(\"\\\"\")) {\n-                        result = text.substring(1, text.length() -1);\n-                    } else {\n-                        result = text;\n-                    }\n-                } else {\n-                    result = nl.item(0);\n-                }\n-                ruleSetNode.setParameter(dataInputs.get(to), result);\n-            }\n-        }\n+    protected void readDataInputAssociation(org.w3c.dom.Node xmlNode,\n+                                            RuleSetNode ruleSetNode,\n+                                            Map<String, String> dataInputs) {\n+        DataAssociationFactory.readDataInputAssociation(xmlNode, dataInputs, (s, a) -> s == null,\n+                ruleSetNode::addInAssociation,\n+                ruleSetNode::setParameter);\n     }\n-    \n-    protected void readDataOutputAssociation(org.w3c.dom.Node xmlNode, RuleSetNode ruleSetNode, Map<String, String> dataOutputs) {\n-        // sourceRef\n-        org.w3c.dom.Node subNode = xmlNode.getFirstChild();\n-        String source = subNode.getTextContent();\n-        // targetRef\n-        subNode = subNode.getNextSibling();\n-        String target = subNode.getTextContent();\n-        // transformation\n- \t\tTransformation transformation = null;\n- \t\tsubNode = subNode.getNextSibling();\n- \t\tif (subNode != null && \"transformation\".equals(subNode.getNodeName())) {\n- \t\t\tString lang = subNode.getAttributes().getNamedItem(\"language\").getNodeValue();\n- \t\t\tString expression = subNode.getTextContent();\n- \t\t\tDataTransformer transformer = transformerRegistry.find(lang);\n- \t\t\tif (transformer == null) {\n- \t\t\t\tthrow new IllegalArgumentException(\"No transformer registered for language \" + lang);\n- \t\t\t}    \t\t\t", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ff06d823ef343533eb7d6db57b1a3facbd1316cc"}, "originalPosition": 98}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzE3MzUyNw==", "bodyText": "Same comment regarding this check", "url": "https://github.com/kiegroup/jbpm/pull/1822#discussion_r543173527", "createdAt": "2020-12-15T09:17:10Z", "author": {"login": "afalhambra"}, "path": "jbpm-bpmn2/src/main/java/org/jbpm/bpmn2/xml/TaskHandler.java", "diffHunk": "@@ -150,86 +145,12 @@ protected void readIoSpecification(org.w3c.dom.Node xmlNode, Map<String, String>\n     }\n \n     protected void readDataInputAssociation(org.w3c.dom.Node xmlNode, WorkItemNode workItemNode, Map<String, String> dataInputs) {\n-\t\t// sourceRef\n-\t\torg.w3c.dom.Node subNode = xmlNode.getFirstChild();\n-\t\tif (\"sourceRef\".equals(subNode.getNodeName())) {\n-    \t\tString source = subNode.getTextContent();    \t\t\n-    \t\t// targetRef\n-    \t\tsubNode = subNode.getNextSibling();\n-    \t\tString target = subNode.getTextContent();\n-    \t\t// transformation\n-    \t\tTransformation transformation = null;\n-    \t\tsubNode = subNode.getNextSibling();\n-    \t\tif (subNode != null && \"transformation\".equals(subNode.getNodeName())) {\n-    \t\t\tString lang = subNode.getAttributes().getNamedItem(\"language\").getNodeValue();\n-    \t\t\tString expression = subNode.getTextContent();\n-    \t\t\t\n-    \t\t\tDataTransformer transformer = transformerRegistry.find(lang);\n-    \t\t\tif (transformer == null) {\n-    \t\t\t\tthrow new IllegalArgumentException(\"No transformer registered for language \" + lang);\n-    \t\t\t}    \t\t\t", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ff06d823ef343533eb7d6db57b1a3facbd1316cc"}, "originalPosition": 37}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzE3MzgyMw==", "bodyText": "same comment with regards to this check", "url": "https://github.com/kiegroup/jbpm/pull/1822#discussion_r543173823", "createdAt": "2020-12-15T09:17:33Z", "author": {"login": "afalhambra"}, "path": "jbpm-bpmn2/src/main/java/org/jbpm/bpmn2/xml/TaskHandler.java", "diffHunk": "@@ -150,86 +145,12 @@ protected void readIoSpecification(org.w3c.dom.Node xmlNode, Map<String, String>\n     }\n \n     protected void readDataInputAssociation(org.w3c.dom.Node xmlNode, WorkItemNode workItemNode, Map<String, String> dataInputs) {\n-\t\t// sourceRef\n-\t\torg.w3c.dom.Node subNode = xmlNode.getFirstChild();\n-\t\tif (\"sourceRef\".equals(subNode.getNodeName())) {\n-    \t\tString source = subNode.getTextContent();    \t\t\n-    \t\t// targetRef\n-    \t\tsubNode = subNode.getNextSibling();\n-    \t\tString target = subNode.getTextContent();\n-    \t\t// transformation\n-    \t\tTransformation transformation = null;\n-    \t\tsubNode = subNode.getNextSibling();\n-    \t\tif (subNode != null && \"transformation\".equals(subNode.getNodeName())) {\n-    \t\t\tString lang = subNode.getAttributes().getNamedItem(\"language\").getNodeValue();\n-    \t\t\tString expression = subNode.getTextContent();\n-    \t\t\t\n-    \t\t\tDataTransformer transformer = transformerRegistry.find(lang);\n-    \t\t\tif (transformer == null) {\n-    \t\t\t\tthrow new IllegalArgumentException(\"No transformer registered for language \" + lang);\n-    \t\t\t}    \t\t\t\n-    \t\t\ttransformation = new Transformation(lang, expression);\n-//    \t\t\ttransformation.setCompiledExpression(transformer.compile(expression));\n-    \t\t\t\n-    \t\t\tsubNode = subNode.getNextSibling();\n-    \t\t}\n-            workItemNode.addInAssociation(new DataAssociation(source, dataInputs.get(target), DataAssociationFactory\n-                    .readAssignments(subNode), transformation));\n-\t\t} else {\n-\t\t\t// targetRef\n-\t\t\tString to = subNode.getTextContent();\n-\t\t\t// assignment\n-\t\t\tsubNode = subNode.getNextSibling();\n-\t\t\tif (subNode != null) {\n-\t    \t\torg.w3c.dom.Node subSubNode = subNode.getFirstChild();\n-\t    \t\tNodeList nl = subSubNode.getChildNodes();\n-\t    \t\tif (nl.getLength() > 1) {\n-\t    \t\t    // not supported ?\n-\t    \t\t    workItemNode.getWork().setParameter(dataInputs.get(to), subSubNode.getTextContent());\n-\t    \t\t    return;\n-\t    \t\t} else if (nl.getLength() == 0) {\n-\t    \t\t    return;\n-\t    \t\t}\n-\t    \t\tObject result = null;\n-\t    \t\tObject from = nl.item(0);\n-\t    \t\tif (from instanceof Text) {\n-\t    \t\t    String text = ((Text) from).getTextContent();\n-\t    \t\t    if (text.startsWith(\"\\\"\") && text.endsWith(\"\\\"\")) {\n-\t                    result = text.substring(1, text.length() -1);\n-\t    \t\t    } else {\n-\t    \t\t        result = text;\n-\t    \t\t    }\n-\t\t\t\t} else {\n-\t\t\t\t    result = nl.item(0);\n-\t\t\t\t}\n-\t    \t\tworkItemNode.getWork().setParameter(dataInputs.get(to), result);\n-\t\t\t}\n-\t\t}\n+        DataAssociationFactory.readDataInputAssociation(xmlNode, dataInputs, DataAssociationFactory::isLegacyAssigment,\n+                workItemNode::addInAssociation, (name, value) -> workItemNode.getWork().setParameter(name, value));\n     }\n-    \n+\n     protected void readDataOutputAssociation(org.w3c.dom.Node xmlNode, WorkItemNode workItemNode, Map<String, String> dataOutputs) {\n-\t\t// sourceRef\n-\t\torg.w3c.dom.Node subNode = xmlNode.getFirstChild();\n-\t\tString source = subNode.getTextContent();\n-\t\t// targetRef\n-\t\tsubNode = subNode.getNextSibling();\n-\t\tString target = subNode.getTextContent();\n-\t\t// transformation\n-\t\tTransformation transformation = null;\n-\t\tsubNode = subNode.getNextSibling();\n-\t\tif (subNode != null && \"transformation\".equals(subNode.getNodeName())) {\n-\t\t\tString lang = subNode.getAttributes().getNamedItem(\"language\").getNodeValue();\n-\t\t\tString expression = subNode.getTextContent();\n-\t\t\tDataTransformer transformer = transformerRegistry.find(lang);\n-\t\t\tif (transformer == null) {\n-\t\t\t\tthrow new IllegalArgumentException(\"No transformer registered for language \" + lang);\n-\t\t\t}    \t\t\t", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ff06d823ef343533eb7d6db57b1a3facbd1316cc"}, "originalPosition": 96}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzE5MTE1NQ==", "bodyText": "full package name is not needed\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        org.w3c.dom.Node fromNode = assignmentNode.getFirstChild();\n          \n          \n            \n                        Node fromNode = assignmentNode.getFirstChild();", "url": "https://github.com/kiegroup/jbpm/pull/1822#discussion_r543191155", "createdAt": "2020-12-15T09:41:31Z", "author": {"login": "afalhambra"}, "path": "jbpm-bpmn2/src/main/java/org/jbpm/bpmn2/xml/elements/DataAssociationFactory.java", "diffHunk": "@@ -33,84 +37,181 @@\n import org.slf4j.LoggerFactory;\n import org.w3c.dom.Node;\n import org.w3c.dom.NodeList;\n+import org.w3c.dom.Text;\n \n public final class DataAssociationFactory {\n-    \n+\n     protected static final String LANG_EXPRESSION_ATTR = \"language\";\n     protected static final String DEFAULT_DIALECT = \"XPath\";\n     protected static final String USE_DEFINITION_LANGUAGE_PROPERTY = \"org.kie.jbpm.bpmn2.useDefinitionLanguage\";\n+    private static final String SOURCE_REF = \"sourceRef\";\n+    private static final String TARGET_REF = \"targetRef\";\n+    private static final String TRANSFORMATION = \"transformation\";\n+    private static final String ASSIGNMENT = \"assignment\";\n     private static final Logger logger = LoggerFactory.getLogger(DataAssociationFactory.class);\n-    \n     private static Map<String, Pattern> dialectPatterns = buildDialectPatterns(ProcessDialectRegistry.getDialects());\n \n-    private DataAssociationFactory() {\n-        // do nothing\n-    }\n+    private DataAssociationFactory() {}\n \n     public static DataAssociation readDataOutputAssociation(Node xmlNode, Map<String, String> dataOutputs) {\n-\n         NodeList nodeList = xmlNode.getChildNodes();\n         String source = null;\n         String target = null;\n         Transformation transformation = null;\n         List<Assignment> assignment = new ArrayList<>();\n-        for(int i = 0; i < nodeList.getLength(); i++) {\n+        for (int i = 0; i < nodeList.getLength(); i++) {\n             Node subNode = nodeList.item(i);\n-            switch(subNode.getNodeName()) {\n-                case \"sourceRef\":\n-                {\n+            switch (subNode.getNodeName()) {\n+                case SOURCE_REF:\n                     source = subNode.getTextContent();\n-                    if(!dataOutputs.containsKey(source)) {\n-                        logger.warn(\"Data outputs in this node {} does not contain source {}\", xmlNode.getAttributes().getNamedItem(\"id\"), source);\n+                    String mapped = dataOutputs.get(source);\n+                    if (mapped == null) {\n+                        logger.warn(\"Data outputs in this node {} does not contain source {}\", xmlNode.getAttributes()\n+                                .getNamedItem(\"id\"), source);\n+                    }\n+                    else {\n+                        source = mapped;\n                     }\n-                    // indirection\n-                    source = dataOutputs.get(source);\n                     break;\n-                }\n-                case \"targetRef\":\n-                {\n+                case TARGET_REF:\n                     target = subNode.getTextContent();\n                     break;\n-                }\n-                case \"transformation\":\n-                {\n+                case TRANSFORMATION:\n                     String lang = subNode.getAttributes().getNamedItem(LANG_EXPRESSION_ATTR).getNodeValue();\n                     String expression = subNode.getTextContent();\n                     transformation = new Transformation(lang, expression, source);\n                     break;\n-                }\n-                case \"assignment\":\n-                {\n-                    assignment.add(readAssignment(subNode));\n+                case ASSIGNMENT:\n+                    assignment.add(readAssignment(subNode, dataOutputs));\n                     break;\n-                }\n             }\n-\n         }\n         return new DataAssociation(source, target, assignment, transformation);\n     }\n-    \n+\n+    public static void readDataInputAssociation(Node xmlNode,\n+                                                Map<String, String> dataInputs,\n+                                                BiPredicate<String, List<Assignment>> isLegacy,\n+                                                Consumer<DataAssociation> addAssigment,\n+                                                BiConsumer<String, Object> legacyAssigment) {\n+        NodeList nodeList = xmlNode.getChildNodes();\n+        String source = null;\n+        String target = null;\n+        Transformation transformation = null;\n+        List<Assignment> assignments = new ArrayList<>();\n+        Node assignmentNode = null;\n+        for (int i = 0; i < nodeList.getLength(); i++) {\n+            Node subNode = nodeList.item(i);\n+            switch (subNode.getNodeName()) {\n+                case SOURCE_REF:\n+                    source = subNode.getTextContent();\n+                    break;\n+                case TARGET_REF:\n+                    target = subNode.getTextContent();\n+                    String mapped = dataInputs.get(target);\n+                    if (mapped == null) {\n+                        logger.warn(\"Data inputs in this node {} does not contain target {}\", xmlNode.getAttributes()\n+                                .getNamedItem(\"id\"), target);\n+                    }\n+                    else {\n+                        target = mapped;\n+                    }\n+                    break;\n+                case TRANSFORMATION:\n+                    transformation = new Transformation(subNode.getAttributes().getNamedItem(LANG_EXPRESSION_ATTR)\n+                            .getNodeValue(), subNode.getTextContent());\n+                    break;\n+                case ASSIGNMENT:\n+                    assignmentNode = subNode;\n+                    assignments.add(readAssignment(subNode, dataInputs));\n+                    break;\n+            }\n+        }\n+        if (isLegacy.test(source, assignments))\n+        {\n+            Object value = getValue(assignmentNode);\n+            if (value != null) {\n+                legacyAssigment.accept(target, value);\n+            }\n+        } else {\n+            addAssigment.accept(new DataAssociation(source, target, assignments, transformation));\n+        }\n+    }\n+\n+    public static boolean isLegacyAssigment(String source, List<Assignment> assignments) {\n+        return source == null && assignments.isEmpty() || source == null && !assignments.isEmpty() && assignments.get(0)\n+                .getDialect().equals(DEFAULT_DIALECT);\n+    }\n+\n+    private static Object getValue(Node assignmentNode) {\n+        Object value = null;\n+        if (assignmentNode != null) {\n+            org.w3c.dom.Node fromNode = assignmentNode.getFirstChild();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ff06d823ef343533eb7d6db57b1a3facbd1316cc"}, "originalPosition": 154}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzE5MjkzNA==", "bodyText": "method name is quite generic, though argument name is not. So seems a little weird. Maybe you can rename either assignmentNode or method name getValue - but it's only just a suggestion, up to you. Same is applicable to fromNode variable in this method.", "url": "https://github.com/kiegroup/jbpm/pull/1822#discussion_r543192934", "createdAt": "2020-12-15T09:44:00Z", "author": {"login": "afalhambra"}, "path": "jbpm-bpmn2/src/main/java/org/jbpm/bpmn2/xml/elements/DataAssociationFactory.java", "diffHunk": "@@ -33,84 +37,181 @@\n import org.slf4j.LoggerFactory;\n import org.w3c.dom.Node;\n import org.w3c.dom.NodeList;\n+import org.w3c.dom.Text;\n \n public final class DataAssociationFactory {\n-    \n+\n     protected static final String LANG_EXPRESSION_ATTR = \"language\";\n     protected static final String DEFAULT_DIALECT = \"XPath\";\n     protected static final String USE_DEFINITION_LANGUAGE_PROPERTY = \"org.kie.jbpm.bpmn2.useDefinitionLanguage\";\n+    private static final String SOURCE_REF = \"sourceRef\";\n+    private static final String TARGET_REF = \"targetRef\";\n+    private static final String TRANSFORMATION = \"transformation\";\n+    private static final String ASSIGNMENT = \"assignment\";\n     private static final Logger logger = LoggerFactory.getLogger(DataAssociationFactory.class);\n-    \n     private static Map<String, Pattern> dialectPatterns = buildDialectPatterns(ProcessDialectRegistry.getDialects());\n \n-    private DataAssociationFactory() {\n-        // do nothing\n-    }\n+    private DataAssociationFactory() {}\n \n     public static DataAssociation readDataOutputAssociation(Node xmlNode, Map<String, String> dataOutputs) {\n-\n         NodeList nodeList = xmlNode.getChildNodes();\n         String source = null;\n         String target = null;\n         Transformation transformation = null;\n         List<Assignment> assignment = new ArrayList<>();\n-        for(int i = 0; i < nodeList.getLength(); i++) {\n+        for (int i = 0; i < nodeList.getLength(); i++) {\n             Node subNode = nodeList.item(i);\n-            switch(subNode.getNodeName()) {\n-                case \"sourceRef\":\n-                {\n+            switch (subNode.getNodeName()) {\n+                case SOURCE_REF:\n                     source = subNode.getTextContent();\n-                    if(!dataOutputs.containsKey(source)) {\n-                        logger.warn(\"Data outputs in this node {} does not contain source {}\", xmlNode.getAttributes().getNamedItem(\"id\"), source);\n+                    String mapped = dataOutputs.get(source);\n+                    if (mapped == null) {\n+                        logger.warn(\"Data outputs in this node {} does not contain source {}\", xmlNode.getAttributes()\n+                                .getNamedItem(\"id\"), source);\n+                    }\n+                    else {\n+                        source = mapped;\n                     }\n-                    // indirection\n-                    source = dataOutputs.get(source);\n                     break;\n-                }\n-                case \"targetRef\":\n-                {\n+                case TARGET_REF:\n                     target = subNode.getTextContent();\n                     break;\n-                }\n-                case \"transformation\":\n-                {\n+                case TRANSFORMATION:\n                     String lang = subNode.getAttributes().getNamedItem(LANG_EXPRESSION_ATTR).getNodeValue();\n                     String expression = subNode.getTextContent();\n                     transformation = new Transformation(lang, expression, source);\n                     break;\n-                }\n-                case \"assignment\":\n-                {\n-                    assignment.add(readAssignment(subNode));\n+                case ASSIGNMENT:\n+                    assignment.add(readAssignment(subNode, dataOutputs));\n                     break;\n-                }\n             }\n-\n         }\n         return new DataAssociation(source, target, assignment, transformation);\n     }\n-    \n+\n+    public static void readDataInputAssociation(Node xmlNode,\n+                                                Map<String, String> dataInputs,\n+                                                BiPredicate<String, List<Assignment>> isLegacy,\n+                                                Consumer<DataAssociation> addAssigment,\n+                                                BiConsumer<String, Object> legacyAssigment) {\n+        NodeList nodeList = xmlNode.getChildNodes();\n+        String source = null;\n+        String target = null;\n+        Transformation transformation = null;\n+        List<Assignment> assignments = new ArrayList<>();\n+        Node assignmentNode = null;\n+        for (int i = 0; i < nodeList.getLength(); i++) {\n+            Node subNode = nodeList.item(i);\n+            switch (subNode.getNodeName()) {\n+                case SOURCE_REF:\n+                    source = subNode.getTextContent();\n+                    break;\n+                case TARGET_REF:\n+                    target = subNode.getTextContent();\n+                    String mapped = dataInputs.get(target);\n+                    if (mapped == null) {\n+                        logger.warn(\"Data inputs in this node {} does not contain target {}\", xmlNode.getAttributes()\n+                                .getNamedItem(\"id\"), target);\n+                    }\n+                    else {\n+                        target = mapped;\n+                    }\n+                    break;\n+                case TRANSFORMATION:\n+                    transformation = new Transformation(subNode.getAttributes().getNamedItem(LANG_EXPRESSION_ATTR)\n+                            .getNodeValue(), subNode.getTextContent());\n+                    break;\n+                case ASSIGNMENT:\n+                    assignmentNode = subNode;\n+                    assignments.add(readAssignment(subNode, dataInputs));\n+                    break;\n+            }\n+        }\n+        if (isLegacy.test(source, assignments))\n+        {\n+            Object value = getValue(assignmentNode);\n+            if (value != null) {\n+                legacyAssigment.accept(target, value);\n+            }\n+        } else {\n+            addAssigment.accept(new DataAssociation(source, target, assignments, transformation));\n+        }\n+    }\n+\n+    public static boolean isLegacyAssigment(String source, List<Assignment> assignments) {\n+        return source == null && assignments.isEmpty() || source == null && !assignments.isEmpty() && assignments.get(0)\n+                .getDialect().equals(DEFAULT_DIALECT);\n+    }\n+\n+    private static Object getValue(Node assignmentNode) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ff06d823ef343533eb7d6db57b1a3facbd1316cc"}, "originalPosition": 151}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzIwNTQ3MQ==", "bodyText": "it can be either dataOutputs or dataInputs\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public static Assignment readAssignment(Node xmlNode, Map<String, String> dataOutputs) {\n          \n          \n            \n                public static Assignment readAssignment(Node xmlNode, Map<String, String> data) {", "url": "https://github.com/kiegroup/jbpm/pull/1822#discussion_r543205471", "createdAt": "2020-12-15T10:01:05Z", "author": {"login": "afalhambra"}, "path": "jbpm-bpmn2/src/main/java/org/jbpm/bpmn2/xml/elements/DataAssociationFactory.java", "diffHunk": "@@ -33,84 +37,181 @@\n import org.slf4j.LoggerFactory;\n import org.w3c.dom.Node;\n import org.w3c.dom.NodeList;\n+import org.w3c.dom.Text;\n \n public final class DataAssociationFactory {\n-    \n+\n     protected static final String LANG_EXPRESSION_ATTR = \"language\";\n     protected static final String DEFAULT_DIALECT = \"XPath\";\n     protected static final String USE_DEFINITION_LANGUAGE_PROPERTY = \"org.kie.jbpm.bpmn2.useDefinitionLanguage\";\n+    private static final String SOURCE_REF = \"sourceRef\";\n+    private static final String TARGET_REF = \"targetRef\";\n+    private static final String TRANSFORMATION = \"transformation\";\n+    private static final String ASSIGNMENT = \"assignment\";\n     private static final Logger logger = LoggerFactory.getLogger(DataAssociationFactory.class);\n-    \n     private static Map<String, Pattern> dialectPatterns = buildDialectPatterns(ProcessDialectRegistry.getDialects());\n \n-    private DataAssociationFactory() {\n-        // do nothing\n-    }\n+    private DataAssociationFactory() {}\n \n     public static DataAssociation readDataOutputAssociation(Node xmlNode, Map<String, String> dataOutputs) {\n-\n         NodeList nodeList = xmlNode.getChildNodes();\n         String source = null;\n         String target = null;\n         Transformation transformation = null;\n         List<Assignment> assignment = new ArrayList<>();\n-        for(int i = 0; i < nodeList.getLength(); i++) {\n+        for (int i = 0; i < nodeList.getLength(); i++) {\n             Node subNode = nodeList.item(i);\n-            switch(subNode.getNodeName()) {\n-                case \"sourceRef\":\n-                {\n+            switch (subNode.getNodeName()) {\n+                case SOURCE_REF:\n                     source = subNode.getTextContent();\n-                    if(!dataOutputs.containsKey(source)) {\n-                        logger.warn(\"Data outputs in this node {} does not contain source {}\", xmlNode.getAttributes().getNamedItem(\"id\"), source);\n+                    String mapped = dataOutputs.get(source);\n+                    if (mapped == null) {\n+                        logger.warn(\"Data outputs in this node {} does not contain source {}\", xmlNode.getAttributes()\n+                                .getNamedItem(\"id\"), source);\n+                    }\n+                    else {\n+                        source = mapped;\n                     }\n-                    // indirection\n-                    source = dataOutputs.get(source);\n                     break;\n-                }\n-                case \"targetRef\":\n-                {\n+                case TARGET_REF:\n                     target = subNode.getTextContent();\n                     break;\n-                }\n-                case \"transformation\":\n-                {\n+                case TRANSFORMATION:\n                     String lang = subNode.getAttributes().getNamedItem(LANG_EXPRESSION_ATTR).getNodeValue();\n                     String expression = subNode.getTextContent();\n                     transformation = new Transformation(lang, expression, source);\n                     break;\n-                }\n-                case \"assignment\":\n-                {\n-                    assignment.add(readAssignment(subNode));\n+                case ASSIGNMENT:\n+                    assignment.add(readAssignment(subNode, dataOutputs));\n                     break;\n-                }\n             }\n-\n         }\n         return new DataAssociation(source, target, assignment, transformation);\n     }\n-    \n+\n+    public static void readDataInputAssociation(Node xmlNode,\n+                                                Map<String, String> dataInputs,\n+                                                BiPredicate<String, List<Assignment>> isLegacy,\n+                                                Consumer<DataAssociation> addAssigment,\n+                                                BiConsumer<String, Object> legacyAssigment) {\n+        NodeList nodeList = xmlNode.getChildNodes();\n+        String source = null;\n+        String target = null;\n+        Transformation transformation = null;\n+        List<Assignment> assignments = new ArrayList<>();\n+        Node assignmentNode = null;\n+        for (int i = 0; i < nodeList.getLength(); i++) {\n+            Node subNode = nodeList.item(i);\n+            switch (subNode.getNodeName()) {\n+                case SOURCE_REF:\n+                    source = subNode.getTextContent();\n+                    break;\n+                case TARGET_REF:\n+                    target = subNode.getTextContent();\n+                    String mapped = dataInputs.get(target);\n+                    if (mapped == null) {\n+                        logger.warn(\"Data inputs in this node {} does not contain target {}\", xmlNode.getAttributes()\n+                                .getNamedItem(\"id\"), target);\n+                    }\n+                    else {\n+                        target = mapped;\n+                    }\n+                    break;\n+                case TRANSFORMATION:\n+                    transformation = new Transformation(subNode.getAttributes().getNamedItem(LANG_EXPRESSION_ATTR)\n+                            .getNodeValue(), subNode.getTextContent());\n+                    break;\n+                case ASSIGNMENT:\n+                    assignmentNode = subNode;\n+                    assignments.add(readAssignment(subNode, dataInputs));\n+                    break;\n+            }\n+        }\n+        if (isLegacy.test(source, assignments))\n+        {\n+            Object value = getValue(assignmentNode);\n+            if (value != null) {\n+                legacyAssigment.accept(target, value);\n+            }\n+        } else {\n+            addAssigment.accept(new DataAssociation(source, target, assignments, transformation));\n+        }\n+    }\n+\n+    public static boolean isLegacyAssigment(String source, List<Assignment> assignments) {\n+        return source == null && assignments.isEmpty() || source == null && !assignments.isEmpty() && assignments.get(0)\n+                .getDialect().equals(DEFAULT_DIALECT);\n+    }\n+\n+    private static Object getValue(Node assignmentNode) {\n+        Object value = null;\n+        if (assignmentNode != null) {\n+            org.w3c.dom.Node fromNode = assignmentNode.getFirstChild();\n+            NodeList nl = fromNode.getChildNodes();\n+            if (nl.getLength() > 1) {\n+                value = fromNode.getNodeValue();\n+            } else if (nl.getLength() == 1) {\n+                value = nl.item(0);\n+                if (value instanceof Text) {\n+                    String text = ((Text) value).getTextContent();\n+                    value = text.startsWith(\"\\\"\") && text.endsWith(\"\\\"\") ? text.substring(1, text.length() - 1)\n+                            : text;\n+                }\n+            }\n+        }\n+        return value;\n+    }\n+\n+\n     public static List<Assignment> readAssignments(Node subNode) {\n         List<Assignment> assignments = new LinkedList<>();\n         while (subNode != null) {\n-            assignments.add(DataAssociationFactory.readAssignment(subNode));\n+            assignments.add(readAssignment(subNode));\n             subNode = subNode.getNextSibling();\n         }\n         return assignments;\n     }\n \n     public static Assignment readAssignment(Node xmlNode) {\n-        Node from = xmlNode.getFirstChild();\n-        if (from == null) {\n-            throw new IllegalArgumentException(\"missing from for assignment\");\n+        return readAssignment(xmlNode, Collections.emptyMap());\n+    }\n+\n+    public static Assignment readAssignment(Node xmlNode, Map<String, String> dataOutputs) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ff06d823ef343533eb7d6db57b1a3facbd1316cc"}, "originalPosition": 188}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzIwNjk2Mw==", "bodyText": "same - it can be either output or input\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private static String resolveContent(Node node, Map<String, String> dataOutputs) {\n          \n          \n            \n                private static String resolveContent(Node node, Map<String, String> data) {", "url": "https://github.com/kiegroup/jbpm/pull/1822#discussion_r543206963", "createdAt": "2020-12-15T10:03:06Z", "author": {"login": "afalhambra"}, "path": "jbpm-bpmn2/src/main/java/org/jbpm/bpmn2/xml/elements/DataAssociationFactory.java", "diffHunk": "@@ -33,84 +37,181 @@\n import org.slf4j.LoggerFactory;\n import org.w3c.dom.Node;\n import org.w3c.dom.NodeList;\n+import org.w3c.dom.Text;\n \n public final class DataAssociationFactory {\n-    \n+\n     protected static final String LANG_EXPRESSION_ATTR = \"language\";\n     protected static final String DEFAULT_DIALECT = \"XPath\";\n     protected static final String USE_DEFINITION_LANGUAGE_PROPERTY = \"org.kie.jbpm.bpmn2.useDefinitionLanguage\";\n+    private static final String SOURCE_REF = \"sourceRef\";\n+    private static final String TARGET_REF = \"targetRef\";\n+    private static final String TRANSFORMATION = \"transformation\";\n+    private static final String ASSIGNMENT = \"assignment\";\n     private static final Logger logger = LoggerFactory.getLogger(DataAssociationFactory.class);\n-    \n     private static Map<String, Pattern> dialectPatterns = buildDialectPatterns(ProcessDialectRegistry.getDialects());\n \n-    private DataAssociationFactory() {\n-        // do nothing\n-    }\n+    private DataAssociationFactory() {}\n \n     public static DataAssociation readDataOutputAssociation(Node xmlNode, Map<String, String> dataOutputs) {\n-\n         NodeList nodeList = xmlNode.getChildNodes();\n         String source = null;\n         String target = null;\n         Transformation transformation = null;\n         List<Assignment> assignment = new ArrayList<>();\n-        for(int i = 0; i < nodeList.getLength(); i++) {\n+        for (int i = 0; i < nodeList.getLength(); i++) {\n             Node subNode = nodeList.item(i);\n-            switch(subNode.getNodeName()) {\n-                case \"sourceRef\":\n-                {\n+            switch (subNode.getNodeName()) {\n+                case SOURCE_REF:\n                     source = subNode.getTextContent();\n-                    if(!dataOutputs.containsKey(source)) {\n-                        logger.warn(\"Data outputs in this node {} does not contain source {}\", xmlNode.getAttributes().getNamedItem(\"id\"), source);\n+                    String mapped = dataOutputs.get(source);\n+                    if (mapped == null) {\n+                        logger.warn(\"Data outputs in this node {} does not contain source {}\", xmlNode.getAttributes()\n+                                .getNamedItem(\"id\"), source);\n+                    }\n+                    else {\n+                        source = mapped;\n                     }\n-                    // indirection\n-                    source = dataOutputs.get(source);\n                     break;\n-                }\n-                case \"targetRef\":\n-                {\n+                case TARGET_REF:\n                     target = subNode.getTextContent();\n                     break;\n-                }\n-                case \"transformation\":\n-                {\n+                case TRANSFORMATION:\n                     String lang = subNode.getAttributes().getNamedItem(LANG_EXPRESSION_ATTR).getNodeValue();\n                     String expression = subNode.getTextContent();\n                     transformation = new Transformation(lang, expression, source);\n                     break;\n-                }\n-                case \"assignment\":\n-                {\n-                    assignment.add(readAssignment(subNode));\n+                case ASSIGNMENT:\n+                    assignment.add(readAssignment(subNode, dataOutputs));\n                     break;\n-                }\n             }\n-\n         }\n         return new DataAssociation(source, target, assignment, transformation);\n     }\n-    \n+\n+    public static void readDataInputAssociation(Node xmlNode,\n+                                                Map<String, String> dataInputs,\n+                                                BiPredicate<String, List<Assignment>> isLegacy,\n+                                                Consumer<DataAssociation> addAssigment,\n+                                                BiConsumer<String, Object> legacyAssigment) {\n+        NodeList nodeList = xmlNode.getChildNodes();\n+        String source = null;\n+        String target = null;\n+        Transformation transformation = null;\n+        List<Assignment> assignments = new ArrayList<>();\n+        Node assignmentNode = null;\n+        for (int i = 0; i < nodeList.getLength(); i++) {\n+            Node subNode = nodeList.item(i);\n+            switch (subNode.getNodeName()) {\n+                case SOURCE_REF:\n+                    source = subNode.getTextContent();\n+                    break;\n+                case TARGET_REF:\n+                    target = subNode.getTextContent();\n+                    String mapped = dataInputs.get(target);\n+                    if (mapped == null) {\n+                        logger.warn(\"Data inputs in this node {} does not contain target {}\", xmlNode.getAttributes()\n+                                .getNamedItem(\"id\"), target);\n+                    }\n+                    else {\n+                        target = mapped;\n+                    }\n+                    break;\n+                case TRANSFORMATION:\n+                    transformation = new Transformation(subNode.getAttributes().getNamedItem(LANG_EXPRESSION_ATTR)\n+                            .getNodeValue(), subNode.getTextContent());\n+                    break;\n+                case ASSIGNMENT:\n+                    assignmentNode = subNode;\n+                    assignments.add(readAssignment(subNode, dataInputs));\n+                    break;\n+            }\n+        }\n+        if (isLegacy.test(source, assignments))\n+        {\n+            Object value = getValue(assignmentNode);\n+            if (value != null) {\n+                legacyAssigment.accept(target, value);\n+            }\n+        } else {\n+            addAssigment.accept(new DataAssociation(source, target, assignments, transformation));\n+        }\n+    }\n+\n+    public static boolean isLegacyAssigment(String source, List<Assignment> assignments) {\n+        return source == null && assignments.isEmpty() || source == null && !assignments.isEmpty() && assignments.get(0)\n+                .getDialect().equals(DEFAULT_DIALECT);\n+    }\n+\n+    private static Object getValue(Node assignmentNode) {\n+        Object value = null;\n+        if (assignmentNode != null) {\n+            org.w3c.dom.Node fromNode = assignmentNode.getFirstChild();\n+            NodeList nl = fromNode.getChildNodes();\n+            if (nl.getLength() > 1) {\n+                value = fromNode.getNodeValue();\n+            } else if (nl.getLength() == 1) {\n+                value = nl.item(0);\n+                if (value instanceof Text) {\n+                    String text = ((Text) value).getTextContent();\n+                    value = text.startsWith(\"\\\"\") && text.endsWith(\"\\\"\") ? text.substring(1, text.length() - 1)\n+                            : text;\n+                }\n+            }\n+        }\n+        return value;\n+    }\n+\n+\n     public static List<Assignment> readAssignments(Node subNode) {\n         List<Assignment> assignments = new LinkedList<>();\n         while (subNode != null) {\n-            assignments.add(DataAssociationFactory.readAssignment(subNode));\n+            assignments.add(readAssignment(subNode));\n             subNode = subNode.getNextSibling();\n         }\n         return assignments;\n     }\n \n     public static Assignment readAssignment(Node xmlNode) {\n-        Node from = xmlNode.getFirstChild();\n-        if (from == null) {\n-            throw new IllegalArgumentException(\"missing from for assignment\");\n+        return readAssignment(xmlNode, Collections.emptyMap());\n+    }\n+\n+    public static Assignment readAssignment(Node xmlNode, Map<String, String> dataOutputs) {\n+\n+        NodeList nodeList = xmlNode.getChildNodes();\n+        Node from = null;\n+        Node to = null;\n+        for (int i = 0; i < nodeList.getLength(); i++) {\n+            Node subNode = nodeList.item(i);\n+            switch (subNode.getNodeName()) {\n+                case \"from\":\n+                    from = subNode;\n+                    break;\n+                case \"to\":\n+                    to = subNode;\n+                    break;\n+                default:\n+                    throw new IllegalArgumentException(\"Unrecognized node name \" + subNode.getNodeName() +\n+                                                       \" in assigment \" + xmlNode.getAttributes().getNamedItem(\"id\")\n+                                                               .getNodeValue());\n+            }\n         }\n-        Node to = from.getNextSibling();\n-        if (to == null) {\n-            throw new IllegalArgumentException(\"missing to for assignment\");\n+        if (to == null && from == null) {\n+            throw new IllegalArgumentException(\" Assigment \" + xmlNode.getAttributes().getNamedItem(\"id\")\n+                    .getNodeValue() + \" should have at least from or to subnode\");\n         }\n-        return new Assignment(getDialect(xmlNode, from, to), from.getTextContent(), to.getTextContent());\n+        return new Assignment(getDialect(xmlNode, from, to), resolveContent(from, dataOutputs), resolveContent(to,\n+                dataOutputs));\n     }\n \n+    private static String resolveContent(Node node, Map<String, String> dataOutputs) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ff06d823ef343533eb7d6db57b1a3facbd1316cc"}, "originalPosition": 220}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzIxNTkxMw==", "bodyText": "typo\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        throw new IllegalArgumentException(\" Assigment \" + xmlNode.getAttributes().getNamedItem(\"id\")\n          \n          \n            \n                        throw new IllegalArgumentException(\" Assignment \" + xmlNode.getAttributes().getNamedItem(\"id\")", "url": "https://github.com/kiegroup/jbpm/pull/1822#discussion_r543215913", "createdAt": "2020-12-15T10:15:41Z", "author": {"login": "afalhambra"}, "path": "jbpm-bpmn2/src/main/java/org/jbpm/bpmn2/xml/elements/DataAssociationFactory.java", "diffHunk": "@@ -33,84 +37,181 @@\n import org.slf4j.LoggerFactory;\n import org.w3c.dom.Node;\n import org.w3c.dom.NodeList;\n+import org.w3c.dom.Text;\n \n public final class DataAssociationFactory {\n-    \n+\n     protected static final String LANG_EXPRESSION_ATTR = \"language\";\n     protected static final String DEFAULT_DIALECT = \"XPath\";\n     protected static final String USE_DEFINITION_LANGUAGE_PROPERTY = \"org.kie.jbpm.bpmn2.useDefinitionLanguage\";\n+    private static final String SOURCE_REF = \"sourceRef\";\n+    private static final String TARGET_REF = \"targetRef\";\n+    private static final String TRANSFORMATION = \"transformation\";\n+    private static final String ASSIGNMENT = \"assignment\";\n     private static final Logger logger = LoggerFactory.getLogger(DataAssociationFactory.class);\n-    \n     private static Map<String, Pattern> dialectPatterns = buildDialectPatterns(ProcessDialectRegistry.getDialects());\n \n-    private DataAssociationFactory() {\n-        // do nothing\n-    }\n+    private DataAssociationFactory() {}\n \n     public static DataAssociation readDataOutputAssociation(Node xmlNode, Map<String, String> dataOutputs) {\n-\n         NodeList nodeList = xmlNode.getChildNodes();\n         String source = null;\n         String target = null;\n         Transformation transformation = null;\n         List<Assignment> assignment = new ArrayList<>();\n-        for(int i = 0; i < nodeList.getLength(); i++) {\n+        for (int i = 0; i < nodeList.getLength(); i++) {\n             Node subNode = nodeList.item(i);\n-            switch(subNode.getNodeName()) {\n-                case \"sourceRef\":\n-                {\n+            switch (subNode.getNodeName()) {\n+                case SOURCE_REF:\n                     source = subNode.getTextContent();\n-                    if(!dataOutputs.containsKey(source)) {\n-                        logger.warn(\"Data outputs in this node {} does not contain source {}\", xmlNode.getAttributes().getNamedItem(\"id\"), source);\n+                    String mapped = dataOutputs.get(source);\n+                    if (mapped == null) {\n+                        logger.warn(\"Data outputs in this node {} does not contain source {}\", xmlNode.getAttributes()\n+                                .getNamedItem(\"id\"), source);\n+                    }\n+                    else {\n+                        source = mapped;\n                     }\n-                    // indirection\n-                    source = dataOutputs.get(source);\n                     break;\n-                }\n-                case \"targetRef\":\n-                {\n+                case TARGET_REF:\n                     target = subNode.getTextContent();\n                     break;\n-                }\n-                case \"transformation\":\n-                {\n+                case TRANSFORMATION:\n                     String lang = subNode.getAttributes().getNamedItem(LANG_EXPRESSION_ATTR).getNodeValue();\n                     String expression = subNode.getTextContent();\n                     transformation = new Transformation(lang, expression, source);\n                     break;\n-                }\n-                case \"assignment\":\n-                {\n-                    assignment.add(readAssignment(subNode));\n+                case ASSIGNMENT:\n+                    assignment.add(readAssignment(subNode, dataOutputs));\n                     break;\n-                }\n             }\n-\n         }\n         return new DataAssociation(source, target, assignment, transformation);\n     }\n-    \n+\n+    public static void readDataInputAssociation(Node xmlNode,\n+                                                Map<String, String> dataInputs,\n+                                                BiPredicate<String, List<Assignment>> isLegacy,\n+                                                Consumer<DataAssociation> addAssigment,\n+                                                BiConsumer<String, Object> legacyAssigment) {\n+        NodeList nodeList = xmlNode.getChildNodes();\n+        String source = null;\n+        String target = null;\n+        Transformation transformation = null;\n+        List<Assignment> assignments = new ArrayList<>();\n+        Node assignmentNode = null;\n+        for (int i = 0; i < nodeList.getLength(); i++) {\n+            Node subNode = nodeList.item(i);\n+            switch (subNode.getNodeName()) {\n+                case SOURCE_REF:\n+                    source = subNode.getTextContent();\n+                    break;\n+                case TARGET_REF:\n+                    target = subNode.getTextContent();\n+                    String mapped = dataInputs.get(target);\n+                    if (mapped == null) {\n+                        logger.warn(\"Data inputs in this node {} does not contain target {}\", xmlNode.getAttributes()\n+                                .getNamedItem(\"id\"), target);\n+                    }\n+                    else {\n+                        target = mapped;\n+                    }\n+                    break;\n+                case TRANSFORMATION:\n+                    transformation = new Transformation(subNode.getAttributes().getNamedItem(LANG_EXPRESSION_ATTR)\n+                            .getNodeValue(), subNode.getTextContent());\n+                    break;\n+                case ASSIGNMENT:\n+                    assignmentNode = subNode;\n+                    assignments.add(readAssignment(subNode, dataInputs));\n+                    break;\n+            }\n+        }\n+        if (isLegacy.test(source, assignments))\n+        {\n+            Object value = getValue(assignmentNode);\n+            if (value != null) {\n+                legacyAssigment.accept(target, value);\n+            }\n+        } else {\n+            addAssigment.accept(new DataAssociation(source, target, assignments, transformation));\n+        }\n+    }\n+\n+    public static boolean isLegacyAssigment(String source, List<Assignment> assignments) {\n+        return source == null && assignments.isEmpty() || source == null && !assignments.isEmpty() && assignments.get(0)\n+                .getDialect().equals(DEFAULT_DIALECT);\n+    }\n+\n+    private static Object getValue(Node assignmentNode) {\n+        Object value = null;\n+        if (assignmentNode != null) {\n+            org.w3c.dom.Node fromNode = assignmentNode.getFirstChild();\n+            NodeList nl = fromNode.getChildNodes();\n+            if (nl.getLength() > 1) {\n+                value = fromNode.getNodeValue();\n+            } else if (nl.getLength() == 1) {\n+                value = nl.item(0);\n+                if (value instanceof Text) {\n+                    String text = ((Text) value).getTextContent();\n+                    value = text.startsWith(\"\\\"\") && text.endsWith(\"\\\"\") ? text.substring(1, text.length() - 1)\n+                            : text;\n+                }\n+            }\n+        }\n+        return value;\n+    }\n+\n+\n     public static List<Assignment> readAssignments(Node subNode) {\n         List<Assignment> assignments = new LinkedList<>();\n         while (subNode != null) {\n-            assignments.add(DataAssociationFactory.readAssignment(subNode));\n+            assignments.add(readAssignment(subNode));\n             subNode = subNode.getNextSibling();\n         }\n         return assignments;\n     }\n \n     public static Assignment readAssignment(Node xmlNode) {\n-        Node from = xmlNode.getFirstChild();\n-        if (from == null) {\n-            throw new IllegalArgumentException(\"missing from for assignment\");\n+        return readAssignment(xmlNode, Collections.emptyMap());\n+    }\n+\n+    public static Assignment readAssignment(Node xmlNode, Map<String, String> dataOutputs) {\n+\n+        NodeList nodeList = xmlNode.getChildNodes();\n+        Node from = null;\n+        Node to = null;\n+        for (int i = 0; i < nodeList.getLength(); i++) {\n+            Node subNode = nodeList.item(i);\n+            switch (subNode.getNodeName()) {\n+                case \"from\":\n+                    from = subNode;\n+                    break;\n+                case \"to\":\n+                    to = subNode;\n+                    break;\n+                default:\n+                    throw new IllegalArgumentException(\"Unrecognized node name \" + subNode.getNodeName() +\n+                                                       \" in assigment \" + xmlNode.getAttributes().getNamedItem(\"id\")\n+                                                               .getNodeValue());\n+            }\n         }\n-        Node to = from.getNextSibling();\n-        if (to == null) {\n-            throw new IllegalArgumentException(\"missing to for assignment\");\n+        if (to == null && from == null) {\n+            throw new IllegalArgumentException(\" Assigment \" + xmlNode.getAttributes().getNamedItem(\"id\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ff06d823ef343533eb7d6db57b1a3facbd1316cc"}, "originalPosition": 212}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzIyOTMyNA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public void testDataInputAssociationsWithPojoWithoutsource() throws Exception {\n          \n          \n            \n                public void testDataInputAssociationsWithPojoWithoutSource() throws Exception {", "url": "https://github.com/kiegroup/jbpm/pull/1822#discussion_r543229324", "createdAt": "2020-12-15T10:34:37Z", "author": {"login": "afalhambra"}, "path": "jbpm-bpmn2/src/test/java/org/jbpm/bpmn2/DataTest.java", "diffHunk": "@@ -329,6 +329,11 @@ public void testDataInputAssociationsWithPojoPartial() throws Exception {\n         internalTestDataInputAssociationWithPojo(\"BPMN2-DataInputAssociations-Pojo.bpmn2\");\n     }\n \n+    @Test\n+    public void testDataInputAssociationsWithPojoWithoutsource() throws Exception {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ff06d823ef343533eb7d6db57b1a3facbd1316cc"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzI3MjEwOA==", "bodyText": "I think it would be good to add another similar test case to check dataInputsAssociations work when only sourceRef is defined.\nSame for dataOutputAssociations.", "url": "https://github.com/kiegroup/jbpm/pull/1822#discussion_r543272108", "createdAt": "2020-12-15T11:41:21Z", "author": {"login": "afalhambra"}, "path": "jbpm-bpmn2/src/test/java/org/jbpm/bpmn2/DataTest.java", "diffHunk": "@@ -329,6 +329,11 @@ public void testDataInputAssociationsWithPojoPartial() throws Exception {\n         internalTestDataInputAssociationWithPojo(\"BPMN2-DataInputAssociations-Pojo.bpmn2\");\n     }\n \n+    @Test\n+    public void testDataInputAssociationsWithPojoWithoutsource() throws Exception {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ff06d823ef343533eb7d6db57b1a3facbd1316cc"}, "originalPosition": 5}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f805920c306411ae6385357cc81e0045af272a0b", "author": {"user": {"login": "fjtirado", "name": "Francisco Javier Tirado Sarti"}}, "url": "https://github.com/kiegroup/jbpm/commit/f805920c306411ae6385357cc81e0045af272a0b", "committedDate": "2020-12-15T15:51:40Z", "message": "[JBPM-9507] Align DataAssociation behavior with kogito\n\nChanges in parser and evaluator to align with non standard behavior"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "ff06d823ef343533eb7d6db57b1a3facbd1316cc", "author": {"user": {"login": "fjtirado", "name": "Francisco Javier Tirado Sarti"}}, "url": "https://github.com/kiegroup/jbpm/commit/ff06d823ef343533eb7d6db57b1a3facbd1316cc", "committedDate": "2020-12-14T11:50:50Z", "message": "[JBPM-9507] Align DataAssociation behavior with kogito\n\nChanges in parser and evaluator to align with non standard behavior"}, "afterCommit": {"oid": "f805920c306411ae6385357cc81e0045af272a0b", "author": {"user": {"login": "fjtirado", "name": "Francisco Javier Tirado Sarti"}}, "url": "https://github.com/kiegroup/jbpm/commit/f805920c306411ae6385357cc81e0045af272a0b", "committedDate": "2020-12-15T15:51:40Z", "message": "[JBPM-9507] Align DataAssociation behavior with kogito\n\nChanges in parser and evaluator to align with non standard behavior"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTUzNDk3ODIy", "url": "https://github.com/kiegroup/jbpm/pull/1822#pullrequestreview-553497822", "createdAt": "2020-12-16T09:25:49Z", "commit": {"oid": "f805920c306411ae6385357cc81e0045af272a0b"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 865, "cost": 1, "resetAt": "2021-11-01T15:33:45Z"}}}