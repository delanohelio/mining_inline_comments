{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzkyODUzMTY1", "number": 1615, "reviewThreads": {"totalCount": 72, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMVQxNDo1MjozNFrODtJb7A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNVQwOTowNTo0MlrODx-0ww==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ4NjY3MTE2OnYy", "diffSide": "RIGHT", "path": "jbpm-case-mgmt/jbpm-case-mgmt-impl/src/test/java/org/jbpm/casemgmt/impl/AdvanceCaseRuntimeDataServiceImplTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMVQxNDo1MjozNFrOF-Zv6g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNlQxNjo1NTo1OVrOGBhGWQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDk3Nzg5OA==", "bodyText": "This process is not referenced or used in this test class", "url": "https://github.com/kiegroup/jbpm/pull/1615#discussion_r400977898", "createdAt": "2020-03-31T14:52:34Z", "author": {"login": "afalhambra"}, "path": "jbpm-case-mgmt/jbpm-case-mgmt-impl/src/test/java/org/jbpm/casemgmt/impl/AdvanceCaseRuntimeDataServiceImplTest.java", "diffHunk": "@@ -0,0 +1,101 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.jbpm.casemgmt.impl;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.jbpm.casemgmt.api.model.instance.CaseFileInstance;\n+import org.jbpm.casemgmt.impl.util.AbstractCaseServicesBaseTest;\n+import org.jbpm.services.api.model.ProcessInstanceWithVarsDesc;\n+import org.jbpm.services.api.model.UserTaskInstanceWithPotOwnerDesc;\n+import org.jbpm.services.task.impl.model.UserImpl;\n+import org.junit.Test;\n+import org.kie.api.runtime.query.QueryContext;\n+import org.kie.api.task.model.OrganizationalEntity;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static java.util.Collections.emptyList;\n+import static java.util.Collections.emptyMap;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNotNull;\n+\n+public class AdvanceCaseRuntimeDataServiceImplTest extends AbstractCaseServicesBaseTest {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(AdvanceCaseRuntimeDataServiceImplTest.class);\n+\n+    @Override\n+    protected List<String> getProcessDefinitionFiles() {\n+        List<String> processes = new ArrayList<String>();\n+        processes.add(\"cases/EmptyCase.bpmn2\");\n+        processes.add(\"cases/UserTaskCase.bpmn2\");\n+        processes.add(\"processes/UserTaskProcess.bpmn2\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1e57dd6f9a77d2e636949457815115ca83acc4dc"}, "originalPosition": 49}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDI0NDA1Nw==", "bodyText": "ok", "url": "https://github.com/kiegroup/jbpm/pull/1615#discussion_r404244057", "createdAt": "2020-04-06T16:55:59Z", "author": {"login": "elguardian"}, "path": "jbpm-case-mgmt/jbpm-case-mgmt-impl/src/test/java/org/jbpm/casemgmt/impl/AdvanceCaseRuntimeDataServiceImplTest.java", "diffHunk": "@@ -0,0 +1,101 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.jbpm.casemgmt.impl;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.jbpm.casemgmt.api.model.instance.CaseFileInstance;\n+import org.jbpm.casemgmt.impl.util.AbstractCaseServicesBaseTest;\n+import org.jbpm.services.api.model.ProcessInstanceWithVarsDesc;\n+import org.jbpm.services.api.model.UserTaskInstanceWithPotOwnerDesc;\n+import org.jbpm.services.task.impl.model.UserImpl;\n+import org.junit.Test;\n+import org.kie.api.runtime.query.QueryContext;\n+import org.kie.api.task.model.OrganizationalEntity;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static java.util.Collections.emptyList;\n+import static java.util.Collections.emptyMap;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNotNull;\n+\n+public class AdvanceCaseRuntimeDataServiceImplTest extends AbstractCaseServicesBaseTest {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(AdvanceCaseRuntimeDataServiceImplTest.class);\n+\n+    @Override\n+    protected List<String> getProcessDefinitionFiles() {\n+        List<String> processes = new ArrayList<String>();\n+        processes.add(\"cases/EmptyCase.bpmn2\");\n+        processes.add(\"cases/UserTaskCase.bpmn2\");\n+        processes.add(\"processes/UserTaskProcess.bpmn2\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDk3Nzg5OA=="}, "originalCommit": {"oid": "1e57dd6f9a77d2e636949457815115ca83acc4dc"}, "originalPosition": 49}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ4NjY3OTgyOnYy", "diffSide": "RIGHT", "path": "jbpm-case-mgmt/jbpm-case-mgmt-impl/src/test/java/org/jbpm/casemgmt/impl/AdvanceCaseRuntimeDataServiceImplTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMVQxNDo1NDoxN1rOF-Z1Wg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMVQxNDo1NDoxN1rOF-Z1Wg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDk3OTI5MA==", "bodyText": "If statement is not needed. Above assertNotNull will make this never happens.", "url": "https://github.com/kiegroup/jbpm/pull/1615#discussion_r400979290", "createdAt": "2020-03-31T14:54:17Z", "author": {"login": "afalhambra"}, "path": "jbpm-case-mgmt/jbpm-case-mgmt-impl/src/test/java/org/jbpm/casemgmt/impl/AdvanceCaseRuntimeDataServiceImplTest.java", "diffHunk": "@@ -0,0 +1,101 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.jbpm.casemgmt.impl;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.jbpm.casemgmt.api.model.instance.CaseFileInstance;\n+import org.jbpm.casemgmt.impl.util.AbstractCaseServicesBaseTest;\n+import org.jbpm.services.api.model.ProcessInstanceWithVarsDesc;\n+import org.jbpm.services.api.model.UserTaskInstanceWithPotOwnerDesc;\n+import org.jbpm.services.task.impl.model.UserImpl;\n+import org.junit.Test;\n+import org.kie.api.runtime.query.QueryContext;\n+import org.kie.api.task.model.OrganizationalEntity;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static java.util.Collections.emptyList;\n+import static java.util.Collections.emptyMap;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNotNull;\n+\n+public class AdvanceCaseRuntimeDataServiceImplTest extends AbstractCaseServicesBaseTest {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(AdvanceCaseRuntimeDataServiceImplTest.class);\n+\n+    @Override\n+    protected List<String> getProcessDefinitionFiles() {\n+        List<String> processes = new ArrayList<String>();\n+        processes.add(\"cases/EmptyCase.bpmn2\");\n+        processes.add(\"cases/UserTaskCase.bpmn2\");\n+        processes.add(\"processes/UserTaskProcess.bpmn2\");\n+        return processes;\n+    }\n+\n+    /*\n+     * Case instance queries\n+     */\n+    @Test\n+    public void testSearchByVariable() {\n+        Map<String, Object> data = new HashMap<>();\n+        data.put(\"name\", \"my first case\");\n+        CaseFileInstance caseFile = caseService.newCaseFileInstance(deploymentUnit.getIdentifier(), EMPTY_CASE_P_ID, data);\n+\n+        String caseId = caseService.startCase(deploymentUnit.getIdentifier(), EMPTY_CASE_P_ID, caseFile);\n+        Map<String, Object> vars = new HashMap<>();\n+        vars.put(\"name\", \"my first case\");\n+        \n+        List<ProcessInstanceWithVarsDesc> process = advanceCaseRuntimeDataService.queryCaseByVariables(emptyMap(), vars, new QueryContext());\n+        assertEquals(process.size(), 1);\n+        assertEquals(process.get(0).getVariables().get(\"name\"), \"my first case\");\n+\n+        assertNotNull(caseId);\n+        assertEquals(FIRST_CASE_ID, caseId);\n+        if (caseId != null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1e57dd6f9a77d2e636949457815115ca83acc4dc"}, "originalPosition": 72}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ4NjY4MTQwOnYy", "diffSide": "RIGHT", "path": "jbpm-case-mgmt/jbpm-case-mgmt-impl/src/test/java/org/jbpm/casemgmt/impl/AdvanceCaseRuntimeDataServiceImplTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMVQxNDo1NDozN1rOF-Z2Xw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMVQxNDo1NDozN1rOF-Z2Xw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDk3OTU1MQ==", "bodyText": "If statement is not needed. Above assertNotNull will make this never happens.", "url": "https://github.com/kiegroup/jbpm/pull/1615#discussion_r400979551", "createdAt": "2020-03-31T14:54:37Z", "author": {"login": "afalhambra"}, "path": "jbpm-case-mgmt/jbpm-case-mgmt-impl/src/test/java/org/jbpm/casemgmt/impl/AdvanceCaseRuntimeDataServiceImplTest.java", "diffHunk": "@@ -0,0 +1,101 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.jbpm.casemgmt.impl;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.jbpm.casemgmt.api.model.instance.CaseFileInstance;\n+import org.jbpm.casemgmt.impl.util.AbstractCaseServicesBaseTest;\n+import org.jbpm.services.api.model.ProcessInstanceWithVarsDesc;\n+import org.jbpm.services.api.model.UserTaskInstanceWithPotOwnerDesc;\n+import org.jbpm.services.task.impl.model.UserImpl;\n+import org.junit.Test;\n+import org.kie.api.runtime.query.QueryContext;\n+import org.kie.api.task.model.OrganizationalEntity;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static java.util.Collections.emptyList;\n+import static java.util.Collections.emptyMap;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNotNull;\n+\n+public class AdvanceCaseRuntimeDataServiceImplTest extends AbstractCaseServicesBaseTest {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(AdvanceCaseRuntimeDataServiceImplTest.class);\n+\n+    @Override\n+    protected List<String> getProcessDefinitionFiles() {\n+        List<String> processes = new ArrayList<String>();\n+        processes.add(\"cases/EmptyCase.bpmn2\");\n+        processes.add(\"cases/UserTaskCase.bpmn2\");\n+        processes.add(\"processes/UserTaskProcess.bpmn2\");\n+        return processes;\n+    }\n+\n+    /*\n+     * Case instance queries\n+     */\n+    @Test\n+    public void testSearchByVariable() {\n+        Map<String, Object> data = new HashMap<>();\n+        data.put(\"name\", \"my first case\");\n+        CaseFileInstance caseFile = caseService.newCaseFileInstance(deploymentUnit.getIdentifier(), EMPTY_CASE_P_ID, data);\n+\n+        String caseId = caseService.startCase(deploymentUnit.getIdentifier(), EMPTY_CASE_P_ID, caseFile);\n+        Map<String, Object> vars = new HashMap<>();\n+        vars.put(\"name\", \"my first case\");\n+        \n+        List<ProcessInstanceWithVarsDesc> process = advanceCaseRuntimeDataService.queryCaseByVariables(emptyMap(), vars, new QueryContext());\n+        assertEquals(process.size(), 1);\n+        assertEquals(process.get(0).getVariables().get(\"name\"), \"my first case\");\n+\n+        assertNotNull(caseId);\n+        assertEquals(FIRST_CASE_ID, caseId);\n+        if (caseId != null) {\n+            caseService.cancelCase(caseId);\n+        }\n+\n+    }\n+\n+    @Test\n+    public void testSearchUserByVariable() {\n+        Map<String, OrganizationalEntity> roleAssignments = new HashMap<>();\n+        roleAssignments.put(\"owner\", new UserImpl(USER));\n+\n+        Map<String, Object> data = new HashMap<>();\n+        data.put(\"name\", \"my first case\");\n+        CaseFileInstance caseFile = caseService.newCaseFileInstance(deploymentUnit.getIdentifier(), USER_TASK_CASE_P_ID, data, roleAssignments);\n+\n+        String caseId = caseService.startCase(deploymentUnit.getIdentifier(), USER_TASK_CASE_P_ID, caseFile);\n+\n+        List<UserTaskInstanceWithPotOwnerDesc> process = advanceCaseRuntimeDataService.queryUserTasksByVariables(emptyMap(), emptyMap(), emptyMap(), emptyList(), new QueryContext());\n+        assertEquals(1, process.size());\n+        assertEquals(process.get(0).getExtraData().get(\"name\"), \"my first case\");\n+\n+        assertNotNull(caseId);\n+        assertEquals(HR_CASE_ID, caseId);\n+        if (caseId != null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1e57dd6f9a77d2e636949457815115ca83acc4dc"}, "originalPosition": 95}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ5MDg4NTAzOnYy", "diffSide": "RIGHT", "path": "jbpm-case-mgmt/jbpm-case-mgmt-impl/src/test/java/org/jbpm/casemgmt/impl/AdvanceCaseRuntimeDataServiceImplTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMVQxNDowODoyMlrOF_CZdg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMVQxNDowODoyMlrOF_CZdg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTY0Mzg5NA==", "bodyText": "Expected and actual values should be swapped.", "url": "https://github.com/kiegroup/jbpm/pull/1615#discussion_r401643894", "createdAt": "2020-04-01T14:08:22Z", "author": {"login": "afalhambra"}, "path": "jbpm-case-mgmt/jbpm-case-mgmt-impl/src/test/java/org/jbpm/casemgmt/impl/AdvanceCaseRuntimeDataServiceImplTest.java", "diffHunk": "@@ -0,0 +1,101 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.jbpm.casemgmt.impl;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.jbpm.casemgmt.api.model.instance.CaseFileInstance;\n+import org.jbpm.casemgmt.impl.util.AbstractCaseServicesBaseTest;\n+import org.jbpm.services.api.model.ProcessInstanceWithVarsDesc;\n+import org.jbpm.services.api.model.UserTaskInstanceWithPotOwnerDesc;\n+import org.jbpm.services.task.impl.model.UserImpl;\n+import org.junit.Test;\n+import org.kie.api.runtime.query.QueryContext;\n+import org.kie.api.task.model.OrganizationalEntity;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static java.util.Collections.emptyList;\n+import static java.util.Collections.emptyMap;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNotNull;\n+\n+public class AdvanceCaseRuntimeDataServiceImplTest extends AbstractCaseServicesBaseTest {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(AdvanceCaseRuntimeDataServiceImplTest.class);\n+\n+    @Override\n+    protected List<String> getProcessDefinitionFiles() {\n+        List<String> processes = new ArrayList<String>();\n+        processes.add(\"cases/EmptyCase.bpmn2\");\n+        processes.add(\"cases/UserTaskCase.bpmn2\");\n+        processes.add(\"processes/UserTaskProcess.bpmn2\");\n+        return processes;\n+    }\n+\n+    /*\n+     * Case instance queries\n+     */\n+    @Test\n+    public void testSearchByVariable() {\n+        Map<String, Object> data = new HashMap<>();\n+        data.put(\"name\", \"my first case\");\n+        CaseFileInstance caseFile = caseService.newCaseFileInstance(deploymentUnit.getIdentifier(), EMPTY_CASE_P_ID, data);\n+\n+        String caseId = caseService.startCase(deploymentUnit.getIdentifier(), EMPTY_CASE_P_ID, caseFile);\n+        Map<String, Object> vars = new HashMap<>();\n+        vars.put(\"name\", \"my first case\");\n+        \n+        List<ProcessInstanceWithVarsDesc> process = advanceCaseRuntimeDataService.queryCaseByVariables(emptyMap(), vars, new QueryContext());\n+        assertEquals(process.size(), 1);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1e57dd6f9a77d2e636949457815115ca83acc4dc"}, "originalPosition": 67}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ5MDg4NzMwOnYy", "diffSide": "RIGHT", "path": "jbpm-case-mgmt/jbpm-case-mgmt-impl/src/test/java/org/jbpm/casemgmt/impl/AdvanceCaseRuntimeDataServiceImplTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMVQxNDowODo1M1rOF_Ca6g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMVQxNDowODo1M1rOF_Ca6g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTY0NDI2Ng==", "bodyText": "Expected and actual values should be swapped", "url": "https://github.com/kiegroup/jbpm/pull/1615#discussion_r401644266", "createdAt": "2020-04-01T14:08:53Z", "author": {"login": "afalhambra"}, "path": "jbpm-case-mgmt/jbpm-case-mgmt-impl/src/test/java/org/jbpm/casemgmt/impl/AdvanceCaseRuntimeDataServiceImplTest.java", "diffHunk": "@@ -0,0 +1,101 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.jbpm.casemgmt.impl;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.jbpm.casemgmt.api.model.instance.CaseFileInstance;\n+import org.jbpm.casemgmt.impl.util.AbstractCaseServicesBaseTest;\n+import org.jbpm.services.api.model.ProcessInstanceWithVarsDesc;\n+import org.jbpm.services.api.model.UserTaskInstanceWithPotOwnerDesc;\n+import org.jbpm.services.task.impl.model.UserImpl;\n+import org.junit.Test;\n+import org.kie.api.runtime.query.QueryContext;\n+import org.kie.api.task.model.OrganizationalEntity;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static java.util.Collections.emptyList;\n+import static java.util.Collections.emptyMap;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNotNull;\n+\n+public class AdvanceCaseRuntimeDataServiceImplTest extends AbstractCaseServicesBaseTest {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(AdvanceCaseRuntimeDataServiceImplTest.class);\n+\n+    @Override\n+    protected List<String> getProcessDefinitionFiles() {\n+        List<String> processes = new ArrayList<String>();\n+        processes.add(\"cases/EmptyCase.bpmn2\");\n+        processes.add(\"cases/UserTaskCase.bpmn2\");\n+        processes.add(\"processes/UserTaskProcess.bpmn2\");\n+        return processes;\n+    }\n+\n+    /*\n+     * Case instance queries\n+     */\n+    @Test\n+    public void testSearchByVariable() {\n+        Map<String, Object> data = new HashMap<>();\n+        data.put(\"name\", \"my first case\");\n+        CaseFileInstance caseFile = caseService.newCaseFileInstance(deploymentUnit.getIdentifier(), EMPTY_CASE_P_ID, data);\n+\n+        String caseId = caseService.startCase(deploymentUnit.getIdentifier(), EMPTY_CASE_P_ID, caseFile);\n+        Map<String, Object> vars = new HashMap<>();\n+        vars.put(\"name\", \"my first case\");\n+        \n+        List<ProcessInstanceWithVarsDesc> process = advanceCaseRuntimeDataService.queryCaseByVariables(emptyMap(), vars, new QueryContext());\n+        assertEquals(process.size(), 1);\n+        assertEquals(process.get(0).getVariables().get(\"name\"), \"my first case\");\n+\n+        assertNotNull(caseId);\n+        assertEquals(FIRST_CASE_ID, caseId);\n+        if (caseId != null) {\n+            caseService.cancelCase(caseId);\n+        }\n+\n+    }\n+\n+    @Test\n+    public void testSearchUserByVariable() {\n+        Map<String, OrganizationalEntity> roleAssignments = new HashMap<>();\n+        roleAssignments.put(\"owner\", new UserImpl(USER));\n+\n+        Map<String, Object> data = new HashMap<>();\n+        data.put(\"name\", \"my first case\");\n+        CaseFileInstance caseFile = caseService.newCaseFileInstance(deploymentUnit.getIdentifier(), USER_TASK_CASE_P_ID, data, roleAssignments);\n+\n+        String caseId = caseService.startCase(deploymentUnit.getIdentifier(), USER_TASK_CASE_P_ID, caseFile);\n+\n+        List<UserTaskInstanceWithPotOwnerDesc> process = advanceCaseRuntimeDataService.queryUserTasksByVariables(emptyMap(), emptyMap(), emptyMap(), emptyList(), new QueryContext());\n+        assertEquals(1, process.size());\n+        assertEquals(process.get(0).getExtraData().get(\"name\"), \"my first case\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1e57dd6f9a77d2e636949457815115ca83acc4dc"}, "originalPosition": 91}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ5MTAzNDAxOnYy", "diffSide": "RIGHT", "path": "jbpm-case-mgmt/jbpm-case-mgmt-impl/src/test/java/org/jbpm/casemgmt/impl/AdvanceCaseRuntimeDataServiceImplTest.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMVQxNDo0MDozMlrOF_D4bA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMVQxNDo0MDozMlrOF_D4bA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTY2ODIwNA==", "bodyText": "As we are querying user tasks by variable I would also add \"USER\" as parameter in the method call by using something like Collections.singletonList(USER) along with the data variable.", "url": "https://github.com/kiegroup/jbpm/pull/1615#discussion_r401668204", "createdAt": "2020-04-01T14:40:32Z", "author": {"login": "afalhambra"}, "path": "jbpm-case-mgmt/jbpm-case-mgmt-impl/src/test/java/org/jbpm/casemgmt/impl/AdvanceCaseRuntimeDataServiceImplTest.java", "diffHunk": "@@ -0,0 +1,101 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.jbpm.casemgmt.impl;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.jbpm.casemgmt.api.model.instance.CaseFileInstance;\n+import org.jbpm.casemgmt.impl.util.AbstractCaseServicesBaseTest;\n+import org.jbpm.services.api.model.ProcessInstanceWithVarsDesc;\n+import org.jbpm.services.api.model.UserTaskInstanceWithPotOwnerDesc;\n+import org.jbpm.services.task.impl.model.UserImpl;\n+import org.junit.Test;\n+import org.kie.api.runtime.query.QueryContext;\n+import org.kie.api.task.model.OrganizationalEntity;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static java.util.Collections.emptyList;\n+import static java.util.Collections.emptyMap;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNotNull;\n+\n+public class AdvanceCaseRuntimeDataServiceImplTest extends AbstractCaseServicesBaseTest {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(AdvanceCaseRuntimeDataServiceImplTest.class);\n+\n+    @Override\n+    protected List<String> getProcessDefinitionFiles() {\n+        List<String> processes = new ArrayList<String>();\n+        processes.add(\"cases/EmptyCase.bpmn2\");\n+        processes.add(\"cases/UserTaskCase.bpmn2\");\n+        processes.add(\"processes/UserTaskProcess.bpmn2\");\n+        return processes;\n+    }\n+\n+    /*\n+     * Case instance queries\n+     */\n+    @Test\n+    public void testSearchByVariable() {\n+        Map<String, Object> data = new HashMap<>();\n+        data.put(\"name\", \"my first case\");\n+        CaseFileInstance caseFile = caseService.newCaseFileInstance(deploymentUnit.getIdentifier(), EMPTY_CASE_P_ID, data);\n+\n+        String caseId = caseService.startCase(deploymentUnit.getIdentifier(), EMPTY_CASE_P_ID, caseFile);\n+        Map<String, Object> vars = new HashMap<>();\n+        vars.put(\"name\", \"my first case\");\n+        \n+        List<ProcessInstanceWithVarsDesc> process = advanceCaseRuntimeDataService.queryCaseByVariables(emptyMap(), vars, new QueryContext());\n+        assertEquals(process.size(), 1);\n+        assertEquals(process.get(0).getVariables().get(\"name\"), \"my first case\");\n+\n+        assertNotNull(caseId);\n+        assertEquals(FIRST_CASE_ID, caseId);\n+        if (caseId != null) {\n+            caseService.cancelCase(caseId);\n+        }\n+\n+    }\n+\n+    @Test\n+    public void testSearchUserByVariable() {\n+        Map<String, OrganizationalEntity> roleAssignments = new HashMap<>();\n+        roleAssignments.put(\"owner\", new UserImpl(USER));\n+\n+        Map<String, Object> data = new HashMap<>();\n+        data.put(\"name\", \"my first case\");\n+        CaseFileInstance caseFile = caseService.newCaseFileInstance(deploymentUnit.getIdentifier(), USER_TASK_CASE_P_ID, data, roleAssignments);\n+\n+        String caseId = caseService.startCase(deploymentUnit.getIdentifier(), USER_TASK_CASE_P_ID, caseFile);\n+\n+        List<UserTaskInstanceWithPotOwnerDesc> process = advanceCaseRuntimeDataService.queryUserTasksByVariables(emptyMap(), emptyMap(), emptyMap(), emptyList(), new QueryContext());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1e57dd6f9a77d2e636949457815115ca83acc4dc"}, "originalPosition": 89}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ5MTMyMzM2OnYy", "diffSide": "RIGHT", "path": "jbpm-services/jbpm-kie-services/src/main/java/org/jbpm/kie/services/impl/AbstractAdvanceRuntimeDataServiceImpl.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMVQxNTo0MzoxNFrOF_Gx8w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMVQxNTo0MzoxNFrOF_Gx8w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTcxNTY5OQ==", "bodyText": "Potential security issue when concatenating strings for a query. Though all the query parameters are properly set below these lines. do you see any risk here?", "url": "https://github.com/kiegroup/jbpm/pull/1615#discussion_r401715699", "createdAt": "2020-04-01T15:43:14Z", "author": {"login": "afalhambra"}, "path": "jbpm-services/jbpm-kie-services/src/main/java/org/jbpm/kie/services/impl/AbstractAdvanceRuntimeDataServiceImpl.java", "diffHunk": "@@ -0,0 +1,306 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.jbpm.kie.services.impl;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import javax.persistence.EntityManager;\n+import javax.persistence.EntityManagerFactory;\n+import javax.persistence.Query;\n+\n+import org.jbpm.kie.services.impl.model.ProcessInstanceWithVarsDesc;\n+import org.jbpm.kie.services.impl.model.UserTaskInstanceWithPotOwnerDesc;\n+import org.jbpm.shared.services.impl.QueryManager;\n+import org.jbpm.shared.services.impl.TransactionalCommandService;\n+import org.jbpm.shared.services.impl.commands.QueryNameCommand;\n+import org.kie.api.runtime.query.QueryContext;\n+\n+import static java.util.Collections.singletonMap;\n+\n+public abstract class AbstractAdvanceRuntimeDataServiceImpl {\n+\n+    private EntityManagerFactory emf;\n+    private TransactionalCommandService commandService;\n+\n+    public AbstractAdvanceRuntimeDataServiceImpl() {\n+        QueryManager.get().addNamedQueries(\"META-INF/Servicesorm.xml\");\n+    }\n+    public void setCommandService(TransactionalCommandService commandService) {\n+        this.commandService = commandService;\n+    }\n+\n+    public void setEmf(EntityManagerFactory emf) {\n+        this.emf = emf;\n+    }\n+\n+\n+    public List<org.jbpm.services.api.model.ProcessInstanceWithVarsDesc> queryProcessByVariables(Map<String, Object> attributes,\n+                                                                                                 Map<String, Object> variables,\n+                                                                                                 int processType,\n+                                                                                                 String varPrefix,\n+                                                                                                 QueryContext queryContext) {\n+        EntityManager entityManager = emf.createEntityManager();\n+\n+        // first step is to filter the data creating a derived tables and pivoting var - rows to columns (only the variables we are interested to filter)\n+        StringBuilder where = new StringBuilder();\n+        StringBuilder derivedTables = new StringBuilder();\n+        for (Map.Entry<String, Object> var : variables.entrySet()) {\n+            String alias = \"TABLE_\" + var.getKey();\n+            String varName = var.getKey();\n+\n+            derivedTables.append(\"LEFT JOIN (\" +\n+                                 \"SELECT A1.processId, A1.processInstanceId, A1.variableId AS NAME, A1.value AS VALUE \\n\" +\n+                                 \"FROM VariableInstanceLog A1 \\n\" +\n+                                 \"LEFT JOIN VariableInstanceLog A2 ON A1.processId = A2.processId AND A1.processInstanceId = A2.processInstanceId AND A1.variableInstanceId = A2.variableInstanceId AND A2.log_date < A1.log_date  \\n\" +\n+                                 \"WHERE A2.log_date IS NULL \\n\" +\n+                                 \") \" + alias + \" ON \" + alias + \".processId = pil.processId AND \" + alias + \".processInstanceId = pil.processInstanceId \\n\");\n+\n+            addWhereExpression(where);\n+            where.append(alias + \".NAME = :NAME_\" + varName + \" AND \" + alias + \".VALUE= :VALUE_\" + varName + \"\\n\");\n+        }\n+\n+\n+        for (Map.Entry<String, Object> entry : attributes.entrySet()) {\n+            addWhereExpression(where);\n+            where.append(\" pil.\" + entry.getKey() + \" = :ATTR_\" + entry.getKey() + \" \");\n+        }\n+\n+        addWhereExpression(where);\n+        where.append(\" pil.processType = :processType \");\n+\n+        String procSQLString = \"SELECT DISTINCT pil.processInstanceId FROM ProcessInstanceLog pil \\n \" + derivedTables + where + \" ORDER BY pil.processInstanceId ASC \";\n+        procSQLString += (queryContext.getCount() > 0) ? \" LIMIT \" + queryContext.getCount() + \" OFFSET \" + queryContext.getOffset() + \" \\n\" : \"\";\n+\n+        Query query = entityManager.createNativeQuery(procSQLString);\n+        for (Map.Entry<String, Object> var : variables.entrySet()) {\n+            query.setParameter(\"NAME_\" + var.getKey(), varPrefix + var.getKey());\n+            query.setParameter(\"VALUE_\" + var.getKey(), var.getValue());\n+        }\n+        for (Map.Entry<String, Object> entry : attributes.entrySet()) {\n+            query.setParameter(\"ATTR_\" + entry.getKey(), entry.getValue());\n+        }\n+        query.setParameter(\"processType\", processType);\n+\n+        List<Number> ids = query.getResultList();\n+        if (ids.isEmpty()) {\n+            return Collections.emptyList();\n+        }\n+\n+        // now we get the information\n+\n+        List<Object[]> procRows = commandService.execute(new QueryNameCommand<List<Object[]>>(\"GeProcessInstanceByIdList\", singletonMap(\"idList\", ids)));\n+        List<Object[]> varRows = commandService.execute(new QueryNameCommand<List<Object[]>>(\"GeVariablesByProcessInstanceIdList\", singletonMap(\"idList\", ids)));\n+\n+        int currentVarIdx = 0;\n+        List<org.jbpm.services.api.model.ProcessInstanceWithVarsDesc> data = new ArrayList<>();\n+        for (Object[] row : procRows) {\n+            ProcessInstanceWithVarsDesc pwv = toProcessInstanceWithVarsDesc(row);\n+\n+            Map<String, Object> vars = new HashMap<>();\n+            pwv.setVariables(vars);\n+            while (currentVarIdx < varRows.size() && row[0].equals(varRows.get(currentVarIdx)[0])) {\n+                String name = (String) varRows.get(currentVarIdx)[1];\n+                if (name.startsWith(varPrefix)) {\n+                    vars.put(name.substring(varPrefix.length()), varRows.get(currentVarIdx)[2]);\n+                }\n+                currentVarIdx++;\n+            }\n+            data.add(pwv);\n+        }\n+\n+        entityManager.close();\n+        return data;\n+    }\n+\n+    private ProcessInstanceWithVarsDesc toProcessInstanceWithVarsDesc(Object[] row) {\n+        return new ProcessInstanceWithVarsDesc(((Number) row[0]).longValue(),\n+                                               (String) row[1],\n+                                               (String) row[2],\n+                                               (String) row[3],\n+                                               ((Number) row[4]).intValue(),\n+                                               (String) row[5],\n+                                               (Date) row[6],\n+                                               (String) row[7],\n+                                               (String) row[8]);\n+    }\n+    private void addWhereExpression(StringBuilder where) {\n+        where.append(where.length() == 0 ? \"WHERE \" : \" AND \");\n+    }\n+\n+    public List<org.jbpm.services.api.model.UserTaskInstanceWithPotOwnerDesc> queryUserTasksByVariables(Map<String, Object> attributes,\n+                                                                                                        Map<String, Object> variables,\n+                                                                                                        Map<String, Object> processVariables,\n+                                                                                                        List<String> owners,\n+                                                                                                        int processType,\n+                                                                                                        String varPrefix,\n+                                                                                                        QueryContext queryContext) {\n+        EntityManager entityManager = emf.createEntityManager();\n+\n+        StringBuilder where = new StringBuilder();\n+        StringBuilder derivedTables = new StringBuilder();\n+        for (Map.Entry<String, Object> var : variables.entrySet()) {\n+            String alias = \"V_TABLE_\" + var.getKey();\n+            String varName = var.getKey();\n+            derivedTables.append(\"INNER JOIN (\\n\" +\n+                                  \"SELECT taskId, name, value \\n\" +\n+                                  \"FROM TaskVariableImpl \\n\" +\n+                                  \"WHERE type = 0\\n\" +\n+                                 \") \" + alias + \" ON \" + alias + \".taskId = task.id  \\n\");\n+\n+\n+            addWhereExpression(where);\n+            where.append(alias + \".NAME = :V_NAME_\" + varName + \" AND \" + alias + \".VALUE= :V_VALUE_\" + varName + \"\\n\");\n+        }\n+\n+        for (Map.Entry<String, Object> var : processVariables.entrySet()) {\n+            String alias = \"P_TABLE_\" + var.getKey();\n+            String varName = var.getKey();\n+\n+            derivedTables.append(\"LEFT JOIN (\" +\n+                                 \"SELECT A1.processId, A1.processInstanceId, A1.variableId AS NAME, A1.value AS VALUE \\n\" +\n+                                 \"FROM VariableInstanceLog A1 \\n\" +\n+                                 \"LEFT JOIN VariableInstanceLog A2 ON A1.processId = A2.processId AND A1.processInstanceId = A2.processInstanceId AND A1.variableInstanceId = A2.variableInstanceId AND A2.log_date < A1.log_date  \\n\" +\n+                                 \"WHERE A2.log_date IS NULL \\n\" +\n+                                 \") \" + alias + \" ON \" + alias + \".processId = pil.processId AND \" + alias + \".processInstanceId = pil.processInstanceId \\n\");\n+\n+            addWhereExpression(where);\n+            where.append(alias + \".NAME = :P_NAME_\" + varName + \" AND \" + alias + \".VALUE= :P_VALUE_\" + varName + \"\\n\");\n+        }\n+\n+        if (!owners.isEmpty()) {\n+            derivedTables.append(\"INNER JOIN ( \\n\" +\n+                             \"           SELECT DISTINCT po.task_id \\n\" +\n+                             \"           FROM PeopleAssignments_PotOwners po \\n\" +\n+                             \"           WHERE po.entity_id IN (:owners) \\n\" +\n+                             \"           GROUP BY po.task_id \\n\" +\n+                             \"           HAVING COUNT(po.entity_id) = :num_owners \\n\" +\n+                                 \") AS pot ON pot.task_id = task.id \");\n+        }\n+\n+        for (Map.Entry<String, Object> entry : attributes.entrySet()) {\n+            addWhereExpression(where);\n+            where.append(\" task.\" + entry.getKey() + \" = :ATTR_\" + entry.getKey() + \" \");\n+        }\n+\n+        addWhereExpression(where);\n+        where.append(\" pil.processType = :processType \");\n+\n+        String procSQLString = \"SELECT DISTINCT task.id FROM Task task INNER JOIN ProcessInstanceLog pil ON pil.processInstanceId = task.processInstanceId \\n \" + derivedTables + where + \" ORDER BY id ASC \";\n+        procSQLString += (queryContext.getCount() > 0) ? \" LIMIT \" + queryContext.getCount() + \" OFFSET \" + queryContext.getOffset() + \"\\n\" : \"\";\n+\n+        Query query = entityManager.createNativeQuery(procSQLString);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1e57dd6f9a77d2e636949457815115ca83acc4dc"}, "originalPosition": 210}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ5MTMyODA2OnYy", "diffSide": "RIGHT", "path": "jbpm-services/jbpm-kie-services/src/main/java/org/jbpm/kie/services/impl/AbstractAdvanceRuntimeDataServiceImpl.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMVQxNTo0NDoxNVrOF_G07w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMVQxNTo0NDoxNVrOF_G07w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTcxNjQ2Mw==", "bodyText": "I would add some java doc to the method.", "url": "https://github.com/kiegroup/jbpm/pull/1615#discussion_r401716463", "createdAt": "2020-04-01T15:44:15Z", "author": {"login": "afalhambra"}, "path": "jbpm-services/jbpm-kie-services/src/main/java/org/jbpm/kie/services/impl/AbstractAdvanceRuntimeDataServiceImpl.java", "diffHunk": "@@ -0,0 +1,306 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.jbpm.kie.services.impl;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import javax.persistence.EntityManager;\n+import javax.persistence.EntityManagerFactory;\n+import javax.persistence.Query;\n+\n+import org.jbpm.kie.services.impl.model.ProcessInstanceWithVarsDesc;\n+import org.jbpm.kie.services.impl.model.UserTaskInstanceWithPotOwnerDesc;\n+import org.jbpm.shared.services.impl.QueryManager;\n+import org.jbpm.shared.services.impl.TransactionalCommandService;\n+import org.jbpm.shared.services.impl.commands.QueryNameCommand;\n+import org.kie.api.runtime.query.QueryContext;\n+\n+import static java.util.Collections.singletonMap;\n+\n+public abstract class AbstractAdvanceRuntimeDataServiceImpl {\n+\n+    private EntityManagerFactory emf;\n+    private TransactionalCommandService commandService;\n+\n+    public AbstractAdvanceRuntimeDataServiceImpl() {\n+        QueryManager.get().addNamedQueries(\"META-INF/Servicesorm.xml\");\n+    }\n+    public void setCommandService(TransactionalCommandService commandService) {\n+        this.commandService = commandService;\n+    }\n+\n+    public void setEmf(EntityManagerFactory emf) {\n+        this.emf = emf;\n+    }\n+\n+\n+    public List<org.jbpm.services.api.model.ProcessInstanceWithVarsDesc> queryProcessByVariables(Map<String, Object> attributes,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1e57dd6f9a77d2e636949457815115ca83acc4dc"}, "originalPosition": 56}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ5MTMyOTEyOnYy", "diffSide": "RIGHT", "path": "jbpm-services/jbpm-kie-services/src/main/java/org/jbpm/kie/services/impl/AbstractAdvanceRuntimeDataServiceImpl.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMVQxNTo0NDozMFrOF_G1pA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMVQxNTo0NDozMFrOF_G1pA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTcxNjY0NA==", "bodyText": "I would add some java doc to the method.", "url": "https://github.com/kiegroup/jbpm/pull/1615#discussion_r401716644", "createdAt": "2020-04-01T15:44:30Z", "author": {"login": "afalhambra"}, "path": "jbpm-services/jbpm-kie-services/src/main/java/org/jbpm/kie/services/impl/AbstractAdvanceRuntimeDataServiceImpl.java", "diffHunk": "@@ -0,0 +1,306 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.jbpm.kie.services.impl;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import javax.persistence.EntityManager;\n+import javax.persistence.EntityManagerFactory;\n+import javax.persistence.Query;\n+\n+import org.jbpm.kie.services.impl.model.ProcessInstanceWithVarsDesc;\n+import org.jbpm.kie.services.impl.model.UserTaskInstanceWithPotOwnerDesc;\n+import org.jbpm.shared.services.impl.QueryManager;\n+import org.jbpm.shared.services.impl.TransactionalCommandService;\n+import org.jbpm.shared.services.impl.commands.QueryNameCommand;\n+import org.kie.api.runtime.query.QueryContext;\n+\n+import static java.util.Collections.singletonMap;\n+\n+public abstract class AbstractAdvanceRuntimeDataServiceImpl {\n+\n+    private EntityManagerFactory emf;\n+    private TransactionalCommandService commandService;\n+\n+    public AbstractAdvanceRuntimeDataServiceImpl() {\n+        QueryManager.get().addNamedQueries(\"META-INF/Servicesorm.xml\");\n+    }\n+    public void setCommandService(TransactionalCommandService commandService) {\n+        this.commandService = commandService;\n+    }\n+\n+    public void setEmf(EntityManagerFactory emf) {\n+        this.emf = emf;\n+    }\n+\n+\n+    public List<org.jbpm.services.api.model.ProcessInstanceWithVarsDesc> queryProcessByVariables(Map<String, Object> attributes,\n+                                                                                                 Map<String, Object> variables,\n+                                                                                                 int processType,\n+                                                                                                 String varPrefix,\n+                                                                                                 QueryContext queryContext) {\n+        EntityManager entityManager = emf.createEntityManager();\n+\n+        // first step is to filter the data creating a derived tables and pivoting var - rows to columns (only the variables we are interested to filter)\n+        StringBuilder where = new StringBuilder();\n+        StringBuilder derivedTables = new StringBuilder();\n+        for (Map.Entry<String, Object> var : variables.entrySet()) {\n+            String alias = \"TABLE_\" + var.getKey();\n+            String varName = var.getKey();\n+\n+            derivedTables.append(\"LEFT JOIN (\" +\n+                                 \"SELECT A1.processId, A1.processInstanceId, A1.variableId AS NAME, A1.value AS VALUE \\n\" +\n+                                 \"FROM VariableInstanceLog A1 \\n\" +\n+                                 \"LEFT JOIN VariableInstanceLog A2 ON A1.processId = A2.processId AND A1.processInstanceId = A2.processInstanceId AND A1.variableInstanceId = A2.variableInstanceId AND A2.log_date < A1.log_date  \\n\" +\n+                                 \"WHERE A2.log_date IS NULL \\n\" +\n+                                 \") \" + alias + \" ON \" + alias + \".processId = pil.processId AND \" + alias + \".processInstanceId = pil.processInstanceId \\n\");\n+\n+            addWhereExpression(where);\n+            where.append(alias + \".NAME = :NAME_\" + varName + \" AND \" + alias + \".VALUE= :VALUE_\" + varName + \"\\n\");\n+        }\n+\n+\n+        for (Map.Entry<String, Object> entry : attributes.entrySet()) {\n+            addWhereExpression(where);\n+            where.append(\" pil.\" + entry.getKey() + \" = :ATTR_\" + entry.getKey() + \" \");\n+        }\n+\n+        addWhereExpression(where);\n+        where.append(\" pil.processType = :processType \");\n+\n+        String procSQLString = \"SELECT DISTINCT pil.processInstanceId FROM ProcessInstanceLog pil \\n \" + derivedTables + where + \" ORDER BY pil.processInstanceId ASC \";\n+        procSQLString += (queryContext.getCount() > 0) ? \" LIMIT \" + queryContext.getCount() + \" OFFSET \" + queryContext.getOffset() + \" \\n\" : \"\";\n+\n+        Query query = entityManager.createNativeQuery(procSQLString);\n+        for (Map.Entry<String, Object> var : variables.entrySet()) {\n+            query.setParameter(\"NAME_\" + var.getKey(), varPrefix + var.getKey());\n+            query.setParameter(\"VALUE_\" + var.getKey(), var.getValue());\n+        }\n+        for (Map.Entry<String, Object> entry : attributes.entrySet()) {\n+            query.setParameter(\"ATTR_\" + entry.getKey(), entry.getValue());\n+        }\n+        query.setParameter(\"processType\", processType);\n+\n+        List<Number> ids = query.getResultList();\n+        if (ids.isEmpty()) {\n+            return Collections.emptyList();\n+        }\n+\n+        // now we get the information\n+\n+        List<Object[]> procRows = commandService.execute(new QueryNameCommand<List<Object[]>>(\"GeProcessInstanceByIdList\", singletonMap(\"idList\", ids)));\n+        List<Object[]> varRows = commandService.execute(new QueryNameCommand<List<Object[]>>(\"GeVariablesByProcessInstanceIdList\", singletonMap(\"idList\", ids)));\n+\n+        int currentVarIdx = 0;\n+        List<org.jbpm.services.api.model.ProcessInstanceWithVarsDesc> data = new ArrayList<>();\n+        for (Object[] row : procRows) {\n+            ProcessInstanceWithVarsDesc pwv = toProcessInstanceWithVarsDesc(row);\n+\n+            Map<String, Object> vars = new HashMap<>();\n+            pwv.setVariables(vars);\n+            while (currentVarIdx < varRows.size() && row[0].equals(varRows.get(currentVarIdx)[0])) {\n+                String name = (String) varRows.get(currentVarIdx)[1];\n+                if (name.startsWith(varPrefix)) {\n+                    vars.put(name.substring(varPrefix.length()), varRows.get(currentVarIdx)[2]);\n+                }\n+                currentVarIdx++;\n+            }\n+            data.add(pwv);\n+        }\n+\n+        entityManager.close();\n+        return data;\n+    }\n+\n+    private ProcessInstanceWithVarsDesc toProcessInstanceWithVarsDesc(Object[] row) {\n+        return new ProcessInstanceWithVarsDesc(((Number) row[0]).longValue(),\n+                                               (String) row[1],\n+                                               (String) row[2],\n+                                               (String) row[3],\n+                                               ((Number) row[4]).intValue(),\n+                                               (String) row[5],\n+                                               (Date) row[6],\n+                                               (String) row[7],\n+                                               (String) row[8]);\n+    }\n+    private void addWhereExpression(StringBuilder where) {\n+        where.append(where.length() == 0 ? \"WHERE \" : \" AND \");\n+    }\n+\n+    public List<org.jbpm.services.api.model.UserTaskInstanceWithPotOwnerDesc> queryUserTasksByVariables(Map<String, Object> attributes,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1e57dd6f9a77d2e636949457815115ca83acc4dc"}, "originalPosition": 149}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ5MTM0NTUyOnYy", "diffSide": "RIGHT", "path": "jbpm-services/jbpm-kie-services/src/main/java/org/jbpm/kie/services/impl/AbstractAdvanceRuntimeDataServiceImpl.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMVQxNTo0Nzo1NFrOF_G_xQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMVQxNTo0Nzo1NFrOF_G_xQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTcxOTIzNw==", "bodyText": "We will need to check if there is any performance issue as there are several calls to DB.", "url": "https://github.com/kiegroup/jbpm/pull/1615#discussion_r401719237", "createdAt": "2020-04-01T15:47:54Z", "author": {"login": "afalhambra"}, "path": "jbpm-services/jbpm-kie-services/src/main/java/org/jbpm/kie/services/impl/AbstractAdvanceRuntimeDataServiceImpl.java", "diffHunk": "@@ -0,0 +1,306 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.jbpm.kie.services.impl;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import javax.persistence.EntityManager;\n+import javax.persistence.EntityManagerFactory;\n+import javax.persistence.Query;\n+\n+import org.jbpm.kie.services.impl.model.ProcessInstanceWithVarsDesc;\n+import org.jbpm.kie.services.impl.model.UserTaskInstanceWithPotOwnerDesc;\n+import org.jbpm.shared.services.impl.QueryManager;\n+import org.jbpm.shared.services.impl.TransactionalCommandService;\n+import org.jbpm.shared.services.impl.commands.QueryNameCommand;\n+import org.kie.api.runtime.query.QueryContext;\n+\n+import static java.util.Collections.singletonMap;\n+\n+public abstract class AbstractAdvanceRuntimeDataServiceImpl {\n+\n+    private EntityManagerFactory emf;\n+    private TransactionalCommandService commandService;\n+\n+    public AbstractAdvanceRuntimeDataServiceImpl() {\n+        QueryManager.get().addNamedQueries(\"META-INF/Servicesorm.xml\");\n+    }\n+    public void setCommandService(TransactionalCommandService commandService) {\n+        this.commandService = commandService;\n+    }\n+\n+    public void setEmf(EntityManagerFactory emf) {\n+        this.emf = emf;\n+    }\n+\n+\n+    public List<org.jbpm.services.api.model.ProcessInstanceWithVarsDesc> queryProcessByVariables(Map<String, Object> attributes,\n+                                                                                                 Map<String, Object> variables,\n+                                                                                                 int processType,\n+                                                                                                 String varPrefix,\n+                                                                                                 QueryContext queryContext) {\n+        EntityManager entityManager = emf.createEntityManager();\n+\n+        // first step is to filter the data creating a derived tables and pivoting var - rows to columns (only the variables we are interested to filter)\n+        StringBuilder where = new StringBuilder();\n+        StringBuilder derivedTables = new StringBuilder();\n+        for (Map.Entry<String, Object> var : variables.entrySet()) {\n+            String alias = \"TABLE_\" + var.getKey();\n+            String varName = var.getKey();\n+\n+            derivedTables.append(\"LEFT JOIN (\" +\n+                                 \"SELECT A1.processId, A1.processInstanceId, A1.variableId AS NAME, A1.value AS VALUE \\n\" +\n+                                 \"FROM VariableInstanceLog A1 \\n\" +\n+                                 \"LEFT JOIN VariableInstanceLog A2 ON A1.processId = A2.processId AND A1.processInstanceId = A2.processInstanceId AND A1.variableInstanceId = A2.variableInstanceId AND A2.log_date < A1.log_date  \\n\" +\n+                                 \"WHERE A2.log_date IS NULL \\n\" +\n+                                 \") \" + alias + \" ON \" + alias + \".processId = pil.processId AND \" + alias + \".processInstanceId = pil.processInstanceId \\n\");\n+\n+            addWhereExpression(where);\n+            where.append(alias + \".NAME = :NAME_\" + varName + \" AND \" + alias + \".VALUE= :VALUE_\" + varName + \"\\n\");\n+        }\n+\n+\n+        for (Map.Entry<String, Object> entry : attributes.entrySet()) {\n+            addWhereExpression(where);\n+            where.append(\" pil.\" + entry.getKey() + \" = :ATTR_\" + entry.getKey() + \" \");\n+        }\n+\n+        addWhereExpression(where);\n+        where.append(\" pil.processType = :processType \");\n+\n+        String procSQLString = \"SELECT DISTINCT pil.processInstanceId FROM ProcessInstanceLog pil \\n \" + derivedTables + where + \" ORDER BY pil.processInstanceId ASC \";\n+        procSQLString += (queryContext.getCount() > 0) ? \" LIMIT \" + queryContext.getCount() + \" OFFSET \" + queryContext.getOffset() + \" \\n\" : \"\";\n+\n+        Query query = entityManager.createNativeQuery(procSQLString);\n+        for (Map.Entry<String, Object> var : variables.entrySet()) {\n+            query.setParameter(\"NAME_\" + var.getKey(), varPrefix + var.getKey());\n+            query.setParameter(\"VALUE_\" + var.getKey(), var.getValue());\n+        }\n+        for (Map.Entry<String, Object> entry : attributes.entrySet()) {\n+            query.setParameter(\"ATTR_\" + entry.getKey(), entry.getValue());\n+        }\n+        query.setParameter(\"processType\", processType);\n+\n+        List<Number> ids = query.getResultList();\n+        if (ids.isEmpty()) {\n+            return Collections.emptyList();\n+        }\n+\n+        // now we get the information\n+\n+        List<Object[]> procRows = commandService.execute(new QueryNameCommand<List<Object[]>>(\"GeProcessInstanceByIdList\", singletonMap(\"idList\", ids)));\n+        List<Object[]> varRows = commandService.execute(new QueryNameCommand<List<Object[]>>(\"GeVariablesByProcessInstanceIdList\", singletonMap(\"idList\", ids)));\n+\n+        int currentVarIdx = 0;\n+        List<org.jbpm.services.api.model.ProcessInstanceWithVarsDesc> data = new ArrayList<>();\n+        for (Object[] row : procRows) {\n+            ProcessInstanceWithVarsDesc pwv = toProcessInstanceWithVarsDesc(row);\n+\n+            Map<String, Object> vars = new HashMap<>();\n+            pwv.setVariables(vars);\n+            while (currentVarIdx < varRows.size() && row[0].equals(varRows.get(currentVarIdx)[0])) {\n+                String name = (String) varRows.get(currentVarIdx)[1];\n+                if (name.startsWith(varPrefix)) {\n+                    vars.put(name.substring(varPrefix.length()), varRows.get(currentVarIdx)[2]);\n+                }\n+                currentVarIdx++;\n+            }\n+            data.add(pwv);\n+        }\n+\n+        entityManager.close();\n+        return data;\n+    }\n+\n+    private ProcessInstanceWithVarsDesc toProcessInstanceWithVarsDesc(Object[] row) {\n+        return new ProcessInstanceWithVarsDesc(((Number) row[0]).longValue(),\n+                                               (String) row[1],\n+                                               (String) row[2],\n+                                               (String) row[3],\n+                                               ((Number) row[4]).intValue(),\n+                                               (String) row[5],\n+                                               (Date) row[6],\n+                                               (String) row[7],\n+                                               (String) row[8]);\n+    }\n+    private void addWhereExpression(StringBuilder where) {\n+        where.append(where.length() == 0 ? \"WHERE \" : \" AND \");\n+    }\n+\n+    public List<org.jbpm.services.api.model.UserTaskInstanceWithPotOwnerDesc> queryUserTasksByVariables(Map<String, Object> attributes,\n+                                                                                                        Map<String, Object> variables,\n+                                                                                                        Map<String, Object> processVariables,\n+                                                                                                        List<String> owners,\n+                                                                                                        int processType,\n+                                                                                                        String varPrefix,\n+                                                                                                        QueryContext queryContext) {\n+        EntityManager entityManager = emf.createEntityManager();\n+\n+        StringBuilder where = new StringBuilder();\n+        StringBuilder derivedTables = new StringBuilder();\n+        for (Map.Entry<String, Object> var : variables.entrySet()) {\n+            String alias = \"V_TABLE_\" + var.getKey();\n+            String varName = var.getKey();\n+            derivedTables.append(\"INNER JOIN (\\n\" +\n+                                  \"SELECT taskId, name, value \\n\" +\n+                                  \"FROM TaskVariableImpl \\n\" +\n+                                  \"WHERE type = 0\\n\" +\n+                                 \") \" + alias + \" ON \" + alias + \".taskId = task.id  \\n\");\n+\n+\n+            addWhereExpression(where);\n+            where.append(alias + \".NAME = :V_NAME_\" + varName + \" AND \" + alias + \".VALUE= :V_VALUE_\" + varName + \"\\n\");\n+        }\n+\n+        for (Map.Entry<String, Object> var : processVariables.entrySet()) {\n+            String alias = \"P_TABLE_\" + var.getKey();\n+            String varName = var.getKey();\n+\n+            derivedTables.append(\"LEFT JOIN (\" +\n+                                 \"SELECT A1.processId, A1.processInstanceId, A1.variableId AS NAME, A1.value AS VALUE \\n\" +\n+                                 \"FROM VariableInstanceLog A1 \\n\" +\n+                                 \"LEFT JOIN VariableInstanceLog A2 ON A1.processId = A2.processId AND A1.processInstanceId = A2.processInstanceId AND A1.variableInstanceId = A2.variableInstanceId AND A2.log_date < A1.log_date  \\n\" +\n+                                 \"WHERE A2.log_date IS NULL \\n\" +\n+                                 \") \" + alias + \" ON \" + alias + \".processId = pil.processId AND \" + alias + \".processInstanceId = pil.processInstanceId \\n\");\n+\n+            addWhereExpression(where);\n+            where.append(alias + \".NAME = :P_NAME_\" + varName + \" AND \" + alias + \".VALUE= :P_VALUE_\" + varName + \"\\n\");\n+        }\n+\n+        if (!owners.isEmpty()) {\n+            derivedTables.append(\"INNER JOIN ( \\n\" +\n+                             \"           SELECT DISTINCT po.task_id \\n\" +\n+                             \"           FROM PeopleAssignments_PotOwners po \\n\" +\n+                             \"           WHERE po.entity_id IN (:owners) \\n\" +\n+                             \"           GROUP BY po.task_id \\n\" +\n+                             \"           HAVING COUNT(po.entity_id) = :num_owners \\n\" +\n+                                 \") AS pot ON pot.task_id = task.id \");\n+        }\n+\n+        for (Map.Entry<String, Object> entry : attributes.entrySet()) {\n+            addWhereExpression(where);\n+            where.append(\" task.\" + entry.getKey() + \" = :ATTR_\" + entry.getKey() + \" \");\n+        }\n+\n+        addWhereExpression(where);\n+        where.append(\" pil.processType = :processType \");\n+\n+        String procSQLString = \"SELECT DISTINCT task.id FROM Task task INNER JOIN ProcessInstanceLog pil ON pil.processInstanceId = task.processInstanceId \\n \" + derivedTables + where + \" ORDER BY id ASC \";\n+        procSQLString += (queryContext.getCount() > 0) ? \" LIMIT \" + queryContext.getCount() + \" OFFSET \" + queryContext.getOffset() + \"\\n\" : \"\";\n+\n+        Query query = entityManager.createNativeQuery(procSQLString);\n+        for (Map.Entry<String, Object> var : variables.entrySet()) {\n+            query.setParameter(\"V_NAME_\" + var.getKey(), var.getKey());\n+            query.setParameter(\"V_VALUE_\" + var.getKey(), var.getValue());\n+        }\n+        for (Map.Entry<String, Object> var : processVariables.entrySet()) {\n+            query.setParameter(\"P_NAME_\" + var.getKey(), varPrefix + var.getKey());\n+            query.setParameter(\"P_VALUE_\" + var.getKey(), var.getValue());\n+        }\n+        for (Map.Entry<String, Object> entry : attributes.entrySet()) {\n+            query.setParameter(\"ATTR_\" + entry.getKey(), entry.getValue());\n+        }\n+        if (!owners.isEmpty()) {\n+            query.setParameter(\"num_owners\", owners.size());\n+            query.setParameter(\"owners\", owners);\n+        }\n+        query.setParameter(\"processType\", processType);\n+\n+        List<Number> ids = query.getResultList();\n+        if (ids.isEmpty()) {\n+            return Collections.emptyList();\n+        }\n+\n+\n+        // query data\n+        List<Object[]> taskRows = commandService.execute(new QueryNameCommand<List<Object[]>>(\"GetTasksByIdList\", singletonMap(\"idList\", ids)));\n+        List<Object[]> varRows = commandService.execute(new QueryNameCommand<List<Object[]>>(\"GetTaskVariablesByTaskIdList\", singletonMap(\"idList\", ids)));\n+        List<Object[]> potRows = commandService.execute(new QueryNameCommand<List<Object[]>>(\"GetPotentialOwnersByTaskIdList\", singletonMap(\"idList\", ids)));\n+        List<Object[]> varProcSQLRows = commandService.execute(new QueryNameCommand<List<Object[]>>(\"GeProcessVariablesByTaskIdList\", singletonMap(\"idList\", ids)));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1e57dd6f9a77d2e636949457815115ca83acc4dc"}, "originalPosition": 238}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ5MTQ4NDM3OnYy", "diffSide": "RIGHT", "path": "jbpm-services/jbpm-kie-services/src/main/java/org/jbpm/kie/services/impl/AbstractAdvanceRuntimeDataServiceImpl.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMVQxNjoxOTo0N1rOF_IXlA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMVQxNjoxOTo0N1rOF_IXlA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTc0MTcxNg==", "bodyText": "Shouldn't we have some kind of control about offset and count? A wrong combination of these might not return any results found in the query when for instance offset is greater than count (bear in mind that default count in a querycontext object is 10)", "url": "https://github.com/kiegroup/jbpm/pull/1615#discussion_r401741716", "createdAt": "2020-04-01T16:19:47Z", "author": {"login": "afalhambra"}, "path": "jbpm-services/jbpm-kie-services/src/main/java/org/jbpm/kie/services/impl/AbstractAdvanceRuntimeDataServiceImpl.java", "diffHunk": "@@ -0,0 +1,306 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.jbpm.kie.services.impl;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import javax.persistence.EntityManager;\n+import javax.persistence.EntityManagerFactory;\n+import javax.persistence.Query;\n+\n+import org.jbpm.kie.services.impl.model.ProcessInstanceWithVarsDesc;\n+import org.jbpm.kie.services.impl.model.UserTaskInstanceWithPotOwnerDesc;\n+import org.jbpm.shared.services.impl.QueryManager;\n+import org.jbpm.shared.services.impl.TransactionalCommandService;\n+import org.jbpm.shared.services.impl.commands.QueryNameCommand;\n+import org.kie.api.runtime.query.QueryContext;\n+\n+import static java.util.Collections.singletonMap;\n+\n+public abstract class AbstractAdvanceRuntimeDataServiceImpl {\n+\n+    private EntityManagerFactory emf;\n+    private TransactionalCommandService commandService;\n+\n+    public AbstractAdvanceRuntimeDataServiceImpl() {\n+        QueryManager.get().addNamedQueries(\"META-INF/Servicesorm.xml\");\n+    }\n+    public void setCommandService(TransactionalCommandService commandService) {\n+        this.commandService = commandService;\n+    }\n+\n+    public void setEmf(EntityManagerFactory emf) {\n+        this.emf = emf;\n+    }\n+\n+\n+    public List<org.jbpm.services.api.model.ProcessInstanceWithVarsDesc> queryProcessByVariables(Map<String, Object> attributes,\n+                                                                                                 Map<String, Object> variables,\n+                                                                                                 int processType,\n+                                                                                                 String varPrefix,\n+                                                                                                 QueryContext queryContext) {\n+        EntityManager entityManager = emf.createEntityManager();\n+\n+        // first step is to filter the data creating a derived tables and pivoting var - rows to columns (only the variables we are interested to filter)\n+        StringBuilder where = new StringBuilder();\n+        StringBuilder derivedTables = new StringBuilder();\n+        for (Map.Entry<String, Object> var : variables.entrySet()) {\n+            String alias = \"TABLE_\" + var.getKey();\n+            String varName = var.getKey();\n+\n+            derivedTables.append(\"LEFT JOIN (\" +\n+                                 \"SELECT A1.processId, A1.processInstanceId, A1.variableId AS NAME, A1.value AS VALUE \\n\" +\n+                                 \"FROM VariableInstanceLog A1 \\n\" +\n+                                 \"LEFT JOIN VariableInstanceLog A2 ON A1.processId = A2.processId AND A1.processInstanceId = A2.processInstanceId AND A1.variableInstanceId = A2.variableInstanceId AND A2.log_date < A1.log_date  \\n\" +\n+                                 \"WHERE A2.log_date IS NULL \\n\" +\n+                                 \") \" + alias + \" ON \" + alias + \".processId = pil.processId AND \" + alias + \".processInstanceId = pil.processInstanceId \\n\");\n+\n+            addWhereExpression(where);\n+            where.append(alias + \".NAME = :NAME_\" + varName + \" AND \" + alias + \".VALUE= :VALUE_\" + varName + \"\\n\");\n+        }\n+\n+\n+        for (Map.Entry<String, Object> entry : attributes.entrySet()) {\n+            addWhereExpression(where);\n+            where.append(\" pil.\" + entry.getKey() + \" = :ATTR_\" + entry.getKey() + \" \");\n+        }\n+\n+        addWhereExpression(where);\n+        where.append(\" pil.processType = :processType \");\n+\n+        String procSQLString = \"SELECT DISTINCT pil.processInstanceId FROM ProcessInstanceLog pil \\n \" + derivedTables + where + \" ORDER BY pil.processInstanceId ASC \";\n+        procSQLString += (queryContext.getCount() > 0) ? \" LIMIT \" + queryContext.getCount() + \" OFFSET \" + queryContext.getOffset() + \" \\n\" : \"\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1e57dd6f9a77d2e636949457815115ca83acc4dc"}, "originalPosition": 91}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ5MTUwMjIwOnYy", "diffSide": "RIGHT", "path": "jbpm-services/jbpm-kie-services/src/main/java/org/jbpm/kie/services/impl/AbstractAdvanceRuntimeDataServiceImpl.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMVQxNjoyMzo1NVrOF_Iivw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMVQxNjoyMzo1NVrOF_Iivw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTc0NDU3NQ==", "bodyText": "I would use VariableType.INPUT instead of hardcoding values in the query.", "url": "https://github.com/kiegroup/jbpm/pull/1615#discussion_r401744575", "createdAt": "2020-04-01T16:23:55Z", "author": {"login": "afalhambra"}, "path": "jbpm-services/jbpm-kie-services/src/main/java/org/jbpm/kie/services/impl/AbstractAdvanceRuntimeDataServiceImpl.java", "diffHunk": "@@ -0,0 +1,306 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.jbpm.kie.services.impl;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import javax.persistence.EntityManager;\n+import javax.persistence.EntityManagerFactory;\n+import javax.persistence.Query;\n+\n+import org.jbpm.kie.services.impl.model.ProcessInstanceWithVarsDesc;\n+import org.jbpm.kie.services.impl.model.UserTaskInstanceWithPotOwnerDesc;\n+import org.jbpm.shared.services.impl.QueryManager;\n+import org.jbpm.shared.services.impl.TransactionalCommandService;\n+import org.jbpm.shared.services.impl.commands.QueryNameCommand;\n+import org.kie.api.runtime.query.QueryContext;\n+\n+import static java.util.Collections.singletonMap;\n+\n+public abstract class AbstractAdvanceRuntimeDataServiceImpl {\n+\n+    private EntityManagerFactory emf;\n+    private TransactionalCommandService commandService;\n+\n+    public AbstractAdvanceRuntimeDataServiceImpl() {\n+        QueryManager.get().addNamedQueries(\"META-INF/Servicesorm.xml\");\n+    }\n+    public void setCommandService(TransactionalCommandService commandService) {\n+        this.commandService = commandService;\n+    }\n+\n+    public void setEmf(EntityManagerFactory emf) {\n+        this.emf = emf;\n+    }\n+\n+\n+    public List<org.jbpm.services.api.model.ProcessInstanceWithVarsDesc> queryProcessByVariables(Map<String, Object> attributes,\n+                                                                                                 Map<String, Object> variables,\n+                                                                                                 int processType,\n+                                                                                                 String varPrefix,\n+                                                                                                 QueryContext queryContext) {\n+        EntityManager entityManager = emf.createEntityManager();\n+\n+        // first step is to filter the data creating a derived tables and pivoting var - rows to columns (only the variables we are interested to filter)\n+        StringBuilder where = new StringBuilder();\n+        StringBuilder derivedTables = new StringBuilder();\n+        for (Map.Entry<String, Object> var : variables.entrySet()) {\n+            String alias = \"TABLE_\" + var.getKey();\n+            String varName = var.getKey();\n+\n+            derivedTables.append(\"LEFT JOIN (\" +\n+                                 \"SELECT A1.processId, A1.processInstanceId, A1.variableId AS NAME, A1.value AS VALUE \\n\" +\n+                                 \"FROM VariableInstanceLog A1 \\n\" +\n+                                 \"LEFT JOIN VariableInstanceLog A2 ON A1.processId = A2.processId AND A1.processInstanceId = A2.processInstanceId AND A1.variableInstanceId = A2.variableInstanceId AND A2.log_date < A1.log_date  \\n\" +\n+                                 \"WHERE A2.log_date IS NULL \\n\" +\n+                                 \") \" + alias + \" ON \" + alias + \".processId = pil.processId AND \" + alias + \".processInstanceId = pil.processInstanceId \\n\");\n+\n+            addWhereExpression(where);\n+            where.append(alias + \".NAME = :NAME_\" + varName + \" AND \" + alias + \".VALUE= :VALUE_\" + varName + \"\\n\");\n+        }\n+\n+\n+        for (Map.Entry<String, Object> entry : attributes.entrySet()) {\n+            addWhereExpression(where);\n+            where.append(\" pil.\" + entry.getKey() + \" = :ATTR_\" + entry.getKey() + \" \");\n+        }\n+\n+        addWhereExpression(where);\n+        where.append(\" pil.processType = :processType \");\n+\n+        String procSQLString = \"SELECT DISTINCT pil.processInstanceId FROM ProcessInstanceLog pil \\n \" + derivedTables + where + \" ORDER BY pil.processInstanceId ASC \";\n+        procSQLString += (queryContext.getCount() > 0) ? \" LIMIT \" + queryContext.getCount() + \" OFFSET \" + queryContext.getOffset() + \" \\n\" : \"\";\n+\n+        Query query = entityManager.createNativeQuery(procSQLString);\n+        for (Map.Entry<String, Object> var : variables.entrySet()) {\n+            query.setParameter(\"NAME_\" + var.getKey(), varPrefix + var.getKey());\n+            query.setParameter(\"VALUE_\" + var.getKey(), var.getValue());\n+        }\n+        for (Map.Entry<String, Object> entry : attributes.entrySet()) {\n+            query.setParameter(\"ATTR_\" + entry.getKey(), entry.getValue());\n+        }\n+        query.setParameter(\"processType\", processType);\n+\n+        List<Number> ids = query.getResultList();\n+        if (ids.isEmpty()) {\n+            return Collections.emptyList();\n+        }\n+\n+        // now we get the information\n+\n+        List<Object[]> procRows = commandService.execute(new QueryNameCommand<List<Object[]>>(\"GeProcessInstanceByIdList\", singletonMap(\"idList\", ids)));\n+        List<Object[]> varRows = commandService.execute(new QueryNameCommand<List<Object[]>>(\"GeVariablesByProcessInstanceIdList\", singletonMap(\"idList\", ids)));\n+\n+        int currentVarIdx = 0;\n+        List<org.jbpm.services.api.model.ProcessInstanceWithVarsDesc> data = new ArrayList<>();\n+        for (Object[] row : procRows) {\n+            ProcessInstanceWithVarsDesc pwv = toProcessInstanceWithVarsDesc(row);\n+\n+            Map<String, Object> vars = new HashMap<>();\n+            pwv.setVariables(vars);\n+            while (currentVarIdx < varRows.size() && row[0].equals(varRows.get(currentVarIdx)[0])) {\n+                String name = (String) varRows.get(currentVarIdx)[1];\n+                if (name.startsWith(varPrefix)) {\n+                    vars.put(name.substring(varPrefix.length()), varRows.get(currentVarIdx)[2]);\n+                }\n+                currentVarIdx++;\n+            }\n+            data.add(pwv);\n+        }\n+\n+        entityManager.close();\n+        return data;\n+    }\n+\n+    private ProcessInstanceWithVarsDesc toProcessInstanceWithVarsDesc(Object[] row) {\n+        return new ProcessInstanceWithVarsDesc(((Number) row[0]).longValue(),\n+                                               (String) row[1],\n+                                               (String) row[2],\n+                                               (String) row[3],\n+                                               ((Number) row[4]).intValue(),\n+                                               (String) row[5],\n+                                               (Date) row[6],\n+                                               (String) row[7],\n+                                               (String) row[8]);\n+    }\n+    private void addWhereExpression(StringBuilder where) {\n+        where.append(where.length() == 0 ? \"WHERE \" : \" AND \");\n+    }\n+\n+    public List<org.jbpm.services.api.model.UserTaskInstanceWithPotOwnerDesc> queryUserTasksByVariables(Map<String, Object> attributes,\n+                                                                                                        Map<String, Object> variables,\n+                                                                                                        Map<String, Object> processVariables,\n+                                                                                                        List<String> owners,\n+                                                                                                        int processType,\n+                                                                                                        String varPrefix,\n+                                                                                                        QueryContext queryContext) {\n+        EntityManager entityManager = emf.createEntityManager();\n+\n+        StringBuilder where = new StringBuilder();\n+        StringBuilder derivedTables = new StringBuilder();\n+        for (Map.Entry<String, Object> var : variables.entrySet()) {\n+            String alias = \"V_TABLE_\" + var.getKey();\n+            String varName = var.getKey();\n+            derivedTables.append(\"INNER JOIN (\\n\" +\n+                                  \"SELECT taskId, name, value \\n\" +\n+                                  \"FROM TaskVariableImpl \\n\" +\n+                                  \"WHERE type = 0\\n\" +", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1e57dd6f9a77d2e636949457815115ca83acc4dc"}, "originalPosition": 166}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ5NDgwNjY1OnYy", "diffSide": "RIGHT", "path": "jbpm-services/jbpm-kie-services/src/main/java/org/jbpm/kie/services/impl/model/UserTaskInstanceWithPotOwnerDesc.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMlQxMjoxMDoyM1rOF_oNXA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMlQxMjoxMDoyM1rOF_oNXA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjI2MzM4OA==", "bodyText": "<String, Object> not needed.", "url": "https://github.com/kiegroup/jbpm/pull/1615#discussion_r402263388", "createdAt": "2020-04-02T12:10:23Z", "author": {"login": "afalhambra"}, "path": "jbpm-services/jbpm-kie-services/src/main/java/org/jbpm/kie/services/impl/model/UserTaskInstanceWithPotOwnerDesc.java", "diffHunk": "@@ -156,5 +158,37 @@ public String getProcessInstanceDescription() {\n     public void setProcessInstanceDescription(String processInstanceDescription) {\n         this.processInstanceDescription = processInstanceDescription;\n     }\n+\n+    public void addProcessVariable(String variable, Object variableValue) {\n+        if (this.processVariables == null) {\n+            this.processVariables = new HashMap<String, Object>();\n+        }\n+        this.processVariables.put(variable, variableValue);\n+    }\n+\n+    @Override\n+    public Map<String, Object> getProcessVariables() {\n+        return processVariables;\n+    }\n+\n+    public void setProcessVariables(Map<String, Object> processVariables) {\n+        this.processVariables = processVariables;\n+    }\n+\n+    public void addExtraData(String variable, Object variableValue) {\n+        if (this.data == null) {\n+            this.data = new HashMap<String, Object>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1e57dd6f9a77d2e636949457815115ca83acc4dc"}, "originalPosition": 32}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ5NDgwNzM0OnYy", "diffSide": "RIGHT", "path": "jbpm-services/jbpm-kie-services/src/main/java/org/jbpm/kie/services/impl/model/UserTaskInstanceWithPotOwnerDesc.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMlQxMjoxMDozNFrOF_oNxw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMlQxMjoxMDozNFrOF_oNxw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjI2MzQ5NQ==", "bodyText": "<String, Object> not needed.", "url": "https://github.com/kiegroup/jbpm/pull/1615#discussion_r402263495", "createdAt": "2020-04-02T12:10:34Z", "author": {"login": "afalhambra"}, "path": "jbpm-services/jbpm-kie-services/src/main/java/org/jbpm/kie/services/impl/model/UserTaskInstanceWithPotOwnerDesc.java", "diffHunk": "@@ -156,5 +158,37 @@ public String getProcessInstanceDescription() {\n     public void setProcessInstanceDescription(String processInstanceDescription) {\n         this.processInstanceDescription = processInstanceDescription;\n     }\n+\n+    public void addProcessVariable(String variable, Object variableValue) {\n+        if (this.processVariables == null) {\n+            this.processVariables = new HashMap<String, Object>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1e57dd6f9a77d2e636949457815115ca83acc4dc"}, "originalPosition": 16}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ5NDgxNDEyOnYy", "diffSide": "RIGHT", "path": "jbpm-services/jbpm-kie-services/src/test/java/org/jbpm/kie/services/test/AdvanceRuntimeDataServiceImplTest.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMlQxMjoxMjo1MFrOF_oSLw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMlQxMjoxMjo1MFrOF_oSLw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjI2NDYyMw==", "bodyText": "Collections.<String, Object> singletonMap can be replaced with just Collections.singletonMap", "url": "https://github.com/kiegroup/jbpm/pull/1615#discussion_r402264623", "createdAt": "2020-04-02T12:12:50Z", "author": {"login": "afalhambra"}, "path": "jbpm-services/jbpm-kie-services/src/test/java/org/jbpm/kie/services/test/AdvanceRuntimeDataServiceImplTest.java", "diffHunk": "@@ -0,0 +1,219 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.jbpm.kie.services.test;\n+\n+import java.io.File;\n+import java.io.FileOutputStream;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.drools.compiler.kie.builder.impl.InternalKieModule;\n+import org.jbpm.kie.services.impl.KModuleDeploymentUnit;\n+import org.jbpm.kie.test.util.AbstractKieServicesBaseTest;\n+import org.jbpm.services.api.ProcessInstanceNotFoundException;\n+import org.jbpm.services.api.model.DeploymentUnit;\n+import org.jbpm.services.api.model.ProcessInstanceWithVarsDesc;\n+import org.jbpm.services.api.model.UserTaskInstanceWithPotOwnerDesc;\n+import org.junit.After;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.kie.api.KieServices;\n+import org.kie.api.builder.ReleaseId;\n+import org.kie.api.runtime.process.ProcessInstance;\n+import org.kie.internal.query.QueryContext;\n+import org.kie.scanner.KieMavenRepository;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static java.util.Collections.emptyList;\n+import static java.util.Collections.emptyMap;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertNull;\n+import static org.kie.scanner.KieMavenRepository.getKieMavenRepository;\n+\n+public class AdvanceRuntimeDataServiceImplTest extends AbstractKieServicesBaseTest {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(AdvanceRuntimeDataServiceImplTest.class);\n+\n+    private List<DeploymentUnit> units = new ArrayList<DeploymentUnit>();\n+    protected String correctUser = \"testUser\";\n+    protected String wrongUser = \"wrongUser\";\n+\n+    private List<Long> processIds;\n+    private KModuleDeploymentUnit deploymentUnit = null;\n+\n+    @Before\n+    public void prepare() {\n+\n+        configureServices();\n+        logger.debug(\"Preparing kjar\");\n+        KieServices ks = KieServices.Factory.get();\n+        ReleaseId releaseId = ks.newReleaseId(GROUP_ID, ARTIFACT_ID, VERSION);\n+        List<String> processes = new ArrayList<String>();\n+        processes.add(\"repo/processes/general/SingleHumanTaskWithVarsA.bpmn2\");\n+        processes.add(\"repo/processes/general/SingleHumanTaskWithVarsB.bpmn2\");\n+\n+        InternalKieModule kJar1 = createKieJar(ks, releaseId, processes);\n+        File pom = new File(\"target/kmodule\", \"pom.xml\");\n+        pom.getParentFile().mkdir();\n+        try (FileOutputStream fs = new FileOutputStream(pom);) {\n+            fs.write(getPom(releaseId).getBytes());\n+        } catch (Exception e) {\n+\n+        }\n+        KieMavenRepository repository = getKieMavenRepository();\n+        repository.deployArtifact(releaseId, kJar1, pom);\n+\n+        assertNotNull(deploymentService);\n+\n+        deploymentUnit = new KModuleDeploymentUnit(GROUP_ID, ARTIFACT_ID, VERSION);\n+\n+        deploymentService.deploy(deploymentUnit);\n+        units.add(deploymentUnit);\n+        assertNotNull(processService);\n+\n+        processIds = new ArrayList<>();\n+        for (int i = 0; i < 10; i++) {\n+            Map<String, Object> inputsA1 = new HashMap<>();\n+            inputsA1.put(\"var_a\", \"a\" + (i % 3));\n+            inputsA1.put(\"var_b\", (i % 3));\n+            processIds.add(processService.startProcess(deploymentUnit.getIdentifier(), \"test.test_A\", inputsA1));\n+        }\n+        for (int i = 0; i < 10; i++) {\n+            Map<String, Object> inputsB1 = new HashMap<>();\n+            inputsB1.put(\"var_a\", \"b\" + (i % 3));\n+            inputsB1.put(\"var_b\", (i % 3));\n+            processIds.add(processService.startProcess(deploymentUnit.getIdentifier(), \"test.test_B\", inputsB1));\n+        }\n+    }\n+\n+    @After\n+    public void cleanup() {\n+        for (Long processInstanceId : processIds) {\n+            try {\n+                // let's abort process instance to leave the system in clear state\n+                processService.abortProcessInstance(processInstanceId);\n+\n+                ProcessInstance pi = processService.getProcessInstance(processInstanceId);\n+                assertNull(pi);\n+            } catch (ProcessInstanceNotFoundException e) {\n+                // ignore it as it was already completed/aborted\n+            }\n+        }\n+        cleanupSingletonSessionId();\n+        if (units != null && !units.isEmpty()) {\n+            for (DeploymentUnit unit : units) {\n+                try {\n+                    deploymentService.undeploy(unit);\n+                } catch (Exception e) {\n+                    // do nothing in case of some failed tests to avoid next test to fail as well\n+                }\n+            }\n+            units.clear();\n+        }\n+        close();\n+    }\n+\n+    @Test\n+    public void testQueryProcessByVariables() {\n+        Map<String, Object> variables = Collections.<String, Object> singletonMap(\"var_a\", \"a1\");\n+        Map<String, Object> attributes = Collections.<String, Object> singletonMap(\"processId\", \"test.test_A\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1e57dd6f9a77d2e636949457815115ca83acc4dc"}, "originalPosition": 139}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ5NDgxNTAwOnYy", "diffSide": "RIGHT", "path": "jbpm-services/jbpm-kie-services/src/test/java/org/jbpm/kie/services/test/AdvanceRuntimeDataServiceImplTest.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMlQxMjoxMzowNlrOF_oSwQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMlQxMjoxMzowNlrOF_oSwQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjI2NDc2OQ==", "bodyText": "Collections.<String, Object> singletonMap can be replaced with just Collections.singletonMap", "url": "https://github.com/kiegroup/jbpm/pull/1615#discussion_r402264769", "createdAt": "2020-04-02T12:13:06Z", "author": {"login": "afalhambra"}, "path": "jbpm-services/jbpm-kie-services/src/test/java/org/jbpm/kie/services/test/AdvanceRuntimeDataServiceImplTest.java", "diffHunk": "@@ -0,0 +1,219 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.jbpm.kie.services.test;\n+\n+import java.io.File;\n+import java.io.FileOutputStream;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.drools.compiler.kie.builder.impl.InternalKieModule;\n+import org.jbpm.kie.services.impl.KModuleDeploymentUnit;\n+import org.jbpm.kie.test.util.AbstractKieServicesBaseTest;\n+import org.jbpm.services.api.ProcessInstanceNotFoundException;\n+import org.jbpm.services.api.model.DeploymentUnit;\n+import org.jbpm.services.api.model.ProcessInstanceWithVarsDesc;\n+import org.jbpm.services.api.model.UserTaskInstanceWithPotOwnerDesc;\n+import org.junit.After;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.kie.api.KieServices;\n+import org.kie.api.builder.ReleaseId;\n+import org.kie.api.runtime.process.ProcessInstance;\n+import org.kie.internal.query.QueryContext;\n+import org.kie.scanner.KieMavenRepository;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static java.util.Collections.emptyList;\n+import static java.util.Collections.emptyMap;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertNull;\n+import static org.kie.scanner.KieMavenRepository.getKieMavenRepository;\n+\n+public class AdvanceRuntimeDataServiceImplTest extends AbstractKieServicesBaseTest {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(AdvanceRuntimeDataServiceImplTest.class);\n+\n+    private List<DeploymentUnit> units = new ArrayList<DeploymentUnit>();\n+    protected String correctUser = \"testUser\";\n+    protected String wrongUser = \"wrongUser\";\n+\n+    private List<Long> processIds;\n+    private KModuleDeploymentUnit deploymentUnit = null;\n+\n+    @Before\n+    public void prepare() {\n+\n+        configureServices();\n+        logger.debug(\"Preparing kjar\");\n+        KieServices ks = KieServices.Factory.get();\n+        ReleaseId releaseId = ks.newReleaseId(GROUP_ID, ARTIFACT_ID, VERSION);\n+        List<String> processes = new ArrayList<String>();\n+        processes.add(\"repo/processes/general/SingleHumanTaskWithVarsA.bpmn2\");\n+        processes.add(\"repo/processes/general/SingleHumanTaskWithVarsB.bpmn2\");\n+\n+        InternalKieModule kJar1 = createKieJar(ks, releaseId, processes);\n+        File pom = new File(\"target/kmodule\", \"pom.xml\");\n+        pom.getParentFile().mkdir();\n+        try (FileOutputStream fs = new FileOutputStream(pom);) {\n+            fs.write(getPom(releaseId).getBytes());\n+        } catch (Exception e) {\n+\n+        }\n+        KieMavenRepository repository = getKieMavenRepository();\n+        repository.deployArtifact(releaseId, kJar1, pom);\n+\n+        assertNotNull(deploymentService);\n+\n+        deploymentUnit = new KModuleDeploymentUnit(GROUP_ID, ARTIFACT_ID, VERSION);\n+\n+        deploymentService.deploy(deploymentUnit);\n+        units.add(deploymentUnit);\n+        assertNotNull(processService);\n+\n+        processIds = new ArrayList<>();\n+        for (int i = 0; i < 10; i++) {\n+            Map<String, Object> inputsA1 = new HashMap<>();\n+            inputsA1.put(\"var_a\", \"a\" + (i % 3));\n+            inputsA1.put(\"var_b\", (i % 3));\n+            processIds.add(processService.startProcess(deploymentUnit.getIdentifier(), \"test.test_A\", inputsA1));\n+        }\n+        for (int i = 0; i < 10; i++) {\n+            Map<String, Object> inputsB1 = new HashMap<>();\n+            inputsB1.put(\"var_a\", \"b\" + (i % 3));\n+            inputsB1.put(\"var_b\", (i % 3));\n+            processIds.add(processService.startProcess(deploymentUnit.getIdentifier(), \"test.test_B\", inputsB1));\n+        }\n+    }\n+\n+    @After\n+    public void cleanup() {\n+        for (Long processInstanceId : processIds) {\n+            try {\n+                // let's abort process instance to leave the system in clear state\n+                processService.abortProcessInstance(processInstanceId);\n+\n+                ProcessInstance pi = processService.getProcessInstance(processInstanceId);\n+                assertNull(pi);\n+            } catch (ProcessInstanceNotFoundException e) {\n+                // ignore it as it was already completed/aborted\n+            }\n+        }\n+        cleanupSingletonSessionId();\n+        if (units != null && !units.isEmpty()) {\n+            for (DeploymentUnit unit : units) {\n+                try {\n+                    deploymentService.undeploy(unit);\n+                } catch (Exception e) {\n+                    // do nothing in case of some failed tests to avoid next test to fail as well\n+                }\n+            }\n+            units.clear();\n+        }\n+        close();\n+    }\n+\n+    @Test\n+    public void testQueryProcessByVariables() {\n+        Map<String, Object> variables = Collections.<String, Object> singletonMap(\"var_a\", \"a1\");\n+        Map<String, Object> attributes = Collections.<String, Object> singletonMap(\"processId\", \"test.test_A\");\n+        List<ProcessInstanceWithVarsDesc> data = advanceVariableDataService.queryProcessByVariables(attributes, variables, new QueryContext());\n+        Assert.assertEquals(3, data.size());\n+        for (ProcessInstanceWithVarsDesc p : data) {\n+            Assert.assertEquals(\"a1\", p.getVariables().get(\"var_a\"));\n+            Assert.assertEquals(\"test.test_A\", p.getProcessId());\n+        }\n+    }\n+\n+    @Test\n+    public void testQueryProcessByVariablesWithPagination() {\n+        Map<String, Object> variables = Collections.<String, Object> singletonMap(\"var_a\", \"a1\");\n+        Map<String, Object> attributes = Collections.<String, Object> singletonMap(\"processId\", \"test.test_A\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1e57dd6f9a77d2e636949457815115ca83acc4dc"}, "originalPosition": 151}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ5NDgxNTM4OnYy", "diffSide": "RIGHT", "path": "jbpm-services/jbpm-kie-services/src/test/java/org/jbpm/kie/services/test/AdvanceRuntimeDataServiceImplTest.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMlQxMjoxMzoxMlrOF_oTBw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMlQxMjoxMzoxMlrOF_oTBw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjI2NDgzOQ==", "bodyText": "Collections.<String, Object> singletonMap can be replaced with just Collections.singletonMap", "url": "https://github.com/kiegroup/jbpm/pull/1615#discussion_r402264839", "createdAt": "2020-04-02T12:13:12Z", "author": {"login": "afalhambra"}, "path": "jbpm-services/jbpm-kie-services/src/test/java/org/jbpm/kie/services/test/AdvanceRuntimeDataServiceImplTest.java", "diffHunk": "@@ -0,0 +1,219 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.jbpm.kie.services.test;\n+\n+import java.io.File;\n+import java.io.FileOutputStream;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.drools.compiler.kie.builder.impl.InternalKieModule;\n+import org.jbpm.kie.services.impl.KModuleDeploymentUnit;\n+import org.jbpm.kie.test.util.AbstractKieServicesBaseTest;\n+import org.jbpm.services.api.ProcessInstanceNotFoundException;\n+import org.jbpm.services.api.model.DeploymentUnit;\n+import org.jbpm.services.api.model.ProcessInstanceWithVarsDesc;\n+import org.jbpm.services.api.model.UserTaskInstanceWithPotOwnerDesc;\n+import org.junit.After;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.kie.api.KieServices;\n+import org.kie.api.builder.ReleaseId;\n+import org.kie.api.runtime.process.ProcessInstance;\n+import org.kie.internal.query.QueryContext;\n+import org.kie.scanner.KieMavenRepository;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static java.util.Collections.emptyList;\n+import static java.util.Collections.emptyMap;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertNull;\n+import static org.kie.scanner.KieMavenRepository.getKieMavenRepository;\n+\n+public class AdvanceRuntimeDataServiceImplTest extends AbstractKieServicesBaseTest {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(AdvanceRuntimeDataServiceImplTest.class);\n+\n+    private List<DeploymentUnit> units = new ArrayList<DeploymentUnit>();\n+    protected String correctUser = \"testUser\";\n+    protected String wrongUser = \"wrongUser\";\n+\n+    private List<Long> processIds;\n+    private KModuleDeploymentUnit deploymentUnit = null;\n+\n+    @Before\n+    public void prepare() {\n+\n+        configureServices();\n+        logger.debug(\"Preparing kjar\");\n+        KieServices ks = KieServices.Factory.get();\n+        ReleaseId releaseId = ks.newReleaseId(GROUP_ID, ARTIFACT_ID, VERSION);\n+        List<String> processes = new ArrayList<String>();\n+        processes.add(\"repo/processes/general/SingleHumanTaskWithVarsA.bpmn2\");\n+        processes.add(\"repo/processes/general/SingleHumanTaskWithVarsB.bpmn2\");\n+\n+        InternalKieModule kJar1 = createKieJar(ks, releaseId, processes);\n+        File pom = new File(\"target/kmodule\", \"pom.xml\");\n+        pom.getParentFile().mkdir();\n+        try (FileOutputStream fs = new FileOutputStream(pom);) {\n+            fs.write(getPom(releaseId).getBytes());\n+        } catch (Exception e) {\n+\n+        }\n+        KieMavenRepository repository = getKieMavenRepository();\n+        repository.deployArtifact(releaseId, kJar1, pom);\n+\n+        assertNotNull(deploymentService);\n+\n+        deploymentUnit = new KModuleDeploymentUnit(GROUP_ID, ARTIFACT_ID, VERSION);\n+\n+        deploymentService.deploy(deploymentUnit);\n+        units.add(deploymentUnit);\n+        assertNotNull(processService);\n+\n+        processIds = new ArrayList<>();\n+        for (int i = 0; i < 10; i++) {\n+            Map<String, Object> inputsA1 = new HashMap<>();\n+            inputsA1.put(\"var_a\", \"a\" + (i % 3));\n+            inputsA1.put(\"var_b\", (i % 3));\n+            processIds.add(processService.startProcess(deploymentUnit.getIdentifier(), \"test.test_A\", inputsA1));\n+        }\n+        for (int i = 0; i < 10; i++) {\n+            Map<String, Object> inputsB1 = new HashMap<>();\n+            inputsB1.put(\"var_a\", \"b\" + (i % 3));\n+            inputsB1.put(\"var_b\", (i % 3));\n+            processIds.add(processService.startProcess(deploymentUnit.getIdentifier(), \"test.test_B\", inputsB1));\n+        }\n+    }\n+\n+    @After\n+    public void cleanup() {\n+        for (Long processInstanceId : processIds) {\n+            try {\n+                // let's abort process instance to leave the system in clear state\n+                processService.abortProcessInstance(processInstanceId);\n+\n+                ProcessInstance pi = processService.getProcessInstance(processInstanceId);\n+                assertNull(pi);\n+            } catch (ProcessInstanceNotFoundException e) {\n+                // ignore it as it was already completed/aborted\n+            }\n+        }\n+        cleanupSingletonSessionId();\n+        if (units != null && !units.isEmpty()) {\n+            for (DeploymentUnit unit : units) {\n+                try {\n+                    deploymentService.undeploy(unit);\n+                } catch (Exception e) {\n+                    // do nothing in case of some failed tests to avoid next test to fail as well\n+                }\n+            }\n+            units.clear();\n+        }\n+        close();\n+    }\n+\n+    @Test\n+    public void testQueryProcessByVariables() {\n+        Map<String, Object> variables = Collections.<String, Object> singletonMap(\"var_a\", \"a1\");\n+        Map<String, Object> attributes = Collections.<String, Object> singletonMap(\"processId\", \"test.test_A\");\n+        List<ProcessInstanceWithVarsDesc> data = advanceVariableDataService.queryProcessByVariables(attributes, variables, new QueryContext());\n+        Assert.assertEquals(3, data.size());\n+        for (ProcessInstanceWithVarsDesc p : data) {\n+            Assert.assertEquals(\"a1\", p.getVariables().get(\"var_a\"));\n+            Assert.assertEquals(\"test.test_A\", p.getProcessId());\n+        }\n+    }\n+\n+    @Test\n+    public void testQueryProcessByVariablesWithPagination() {\n+        Map<String, Object> variables = Collections.<String, Object> singletonMap(\"var_a\", \"a1\");\n+        Map<String, Object> attributes = Collections.<String, Object> singletonMap(\"processId\", \"test.test_A\");\n+        List<ProcessInstanceWithVarsDesc> data = advanceVariableDataService.queryProcessByVariables(attributes, variables, new QueryContext(0, 2));\n+        Assert.assertEquals(2, data.size());\n+        for (ProcessInstanceWithVarsDesc p : data) {\n+            Assert.assertEquals(\"a1\", p.getVariables().get(\"var_a\"));\n+            Assert.assertEquals(\"test.test_A\", p.getProcessId());\n+        }\n+    }\n+\n+    @Test\n+    public void testQueryTaskByVariables() {\n+        Map<String, Object> variables = Collections.<String, Object> singletonMap(\"task_in_a1\", \"a0\");\n+        Map<String, Object> attributes = Collections.<String, Object> singletonMap(\"deploymentId\", \"org.jbpm.test:test-module:1.0.0\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1e57dd6f9a77d2e636949457815115ca83acc4dc"}, "originalPosition": 163}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ5NDgxNTcwOnYy", "diffSide": "RIGHT", "path": "jbpm-services/jbpm-kie-services/src/test/java/org/jbpm/kie/services/test/AdvanceRuntimeDataServiceImplTest.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMlQxMjoxMzoyMFrOF_oTPQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMlQxMjoxMzoyMFrOF_oTPQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjI2NDg5Mw==", "bodyText": "Collections.<String, Object> singletonMap can be replaced with just Collections.singletonMap", "url": "https://github.com/kiegroup/jbpm/pull/1615#discussion_r402264893", "createdAt": "2020-04-02T12:13:20Z", "author": {"login": "afalhambra"}, "path": "jbpm-services/jbpm-kie-services/src/test/java/org/jbpm/kie/services/test/AdvanceRuntimeDataServiceImplTest.java", "diffHunk": "@@ -0,0 +1,219 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.jbpm.kie.services.test;\n+\n+import java.io.File;\n+import java.io.FileOutputStream;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.drools.compiler.kie.builder.impl.InternalKieModule;\n+import org.jbpm.kie.services.impl.KModuleDeploymentUnit;\n+import org.jbpm.kie.test.util.AbstractKieServicesBaseTest;\n+import org.jbpm.services.api.ProcessInstanceNotFoundException;\n+import org.jbpm.services.api.model.DeploymentUnit;\n+import org.jbpm.services.api.model.ProcessInstanceWithVarsDesc;\n+import org.jbpm.services.api.model.UserTaskInstanceWithPotOwnerDesc;\n+import org.junit.After;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.kie.api.KieServices;\n+import org.kie.api.builder.ReleaseId;\n+import org.kie.api.runtime.process.ProcessInstance;\n+import org.kie.internal.query.QueryContext;\n+import org.kie.scanner.KieMavenRepository;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static java.util.Collections.emptyList;\n+import static java.util.Collections.emptyMap;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertNull;\n+import static org.kie.scanner.KieMavenRepository.getKieMavenRepository;\n+\n+public class AdvanceRuntimeDataServiceImplTest extends AbstractKieServicesBaseTest {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(AdvanceRuntimeDataServiceImplTest.class);\n+\n+    private List<DeploymentUnit> units = new ArrayList<DeploymentUnit>();\n+    protected String correctUser = \"testUser\";\n+    protected String wrongUser = \"wrongUser\";\n+\n+    private List<Long> processIds;\n+    private KModuleDeploymentUnit deploymentUnit = null;\n+\n+    @Before\n+    public void prepare() {\n+\n+        configureServices();\n+        logger.debug(\"Preparing kjar\");\n+        KieServices ks = KieServices.Factory.get();\n+        ReleaseId releaseId = ks.newReleaseId(GROUP_ID, ARTIFACT_ID, VERSION);\n+        List<String> processes = new ArrayList<String>();\n+        processes.add(\"repo/processes/general/SingleHumanTaskWithVarsA.bpmn2\");\n+        processes.add(\"repo/processes/general/SingleHumanTaskWithVarsB.bpmn2\");\n+\n+        InternalKieModule kJar1 = createKieJar(ks, releaseId, processes);\n+        File pom = new File(\"target/kmodule\", \"pom.xml\");\n+        pom.getParentFile().mkdir();\n+        try (FileOutputStream fs = new FileOutputStream(pom);) {\n+            fs.write(getPom(releaseId).getBytes());\n+        } catch (Exception e) {\n+\n+        }\n+        KieMavenRepository repository = getKieMavenRepository();\n+        repository.deployArtifact(releaseId, kJar1, pom);\n+\n+        assertNotNull(deploymentService);\n+\n+        deploymentUnit = new KModuleDeploymentUnit(GROUP_ID, ARTIFACT_ID, VERSION);\n+\n+        deploymentService.deploy(deploymentUnit);\n+        units.add(deploymentUnit);\n+        assertNotNull(processService);\n+\n+        processIds = new ArrayList<>();\n+        for (int i = 0; i < 10; i++) {\n+            Map<String, Object> inputsA1 = new HashMap<>();\n+            inputsA1.put(\"var_a\", \"a\" + (i % 3));\n+            inputsA1.put(\"var_b\", (i % 3));\n+            processIds.add(processService.startProcess(deploymentUnit.getIdentifier(), \"test.test_A\", inputsA1));\n+        }\n+        for (int i = 0; i < 10; i++) {\n+            Map<String, Object> inputsB1 = new HashMap<>();\n+            inputsB1.put(\"var_a\", \"b\" + (i % 3));\n+            inputsB1.put(\"var_b\", (i % 3));\n+            processIds.add(processService.startProcess(deploymentUnit.getIdentifier(), \"test.test_B\", inputsB1));\n+        }\n+    }\n+\n+    @After\n+    public void cleanup() {\n+        for (Long processInstanceId : processIds) {\n+            try {\n+                // let's abort process instance to leave the system in clear state\n+                processService.abortProcessInstance(processInstanceId);\n+\n+                ProcessInstance pi = processService.getProcessInstance(processInstanceId);\n+                assertNull(pi);\n+            } catch (ProcessInstanceNotFoundException e) {\n+                // ignore it as it was already completed/aborted\n+            }\n+        }\n+        cleanupSingletonSessionId();\n+        if (units != null && !units.isEmpty()) {\n+            for (DeploymentUnit unit : units) {\n+                try {\n+                    deploymentService.undeploy(unit);\n+                } catch (Exception e) {\n+                    // do nothing in case of some failed tests to avoid next test to fail as well\n+                }\n+            }\n+            units.clear();\n+        }\n+        close();\n+    }\n+\n+    @Test\n+    public void testQueryProcessByVariables() {\n+        Map<String, Object> variables = Collections.<String, Object> singletonMap(\"var_a\", \"a1\");\n+        Map<String, Object> attributes = Collections.<String, Object> singletonMap(\"processId\", \"test.test_A\");\n+        List<ProcessInstanceWithVarsDesc> data = advanceVariableDataService.queryProcessByVariables(attributes, variables, new QueryContext());\n+        Assert.assertEquals(3, data.size());\n+        for (ProcessInstanceWithVarsDesc p : data) {\n+            Assert.assertEquals(\"a1\", p.getVariables().get(\"var_a\"));\n+            Assert.assertEquals(\"test.test_A\", p.getProcessId());\n+        }\n+    }\n+\n+    @Test\n+    public void testQueryProcessByVariablesWithPagination() {\n+        Map<String, Object> variables = Collections.<String, Object> singletonMap(\"var_a\", \"a1\");\n+        Map<String, Object> attributes = Collections.<String, Object> singletonMap(\"processId\", \"test.test_A\");\n+        List<ProcessInstanceWithVarsDesc> data = advanceVariableDataService.queryProcessByVariables(attributes, variables, new QueryContext(0, 2));\n+        Assert.assertEquals(2, data.size());\n+        for (ProcessInstanceWithVarsDesc p : data) {\n+            Assert.assertEquals(\"a1\", p.getVariables().get(\"var_a\"));\n+            Assert.assertEquals(\"test.test_A\", p.getProcessId());\n+        }\n+    }\n+\n+    @Test\n+    public void testQueryTaskByVariables() {\n+        Map<String, Object> variables = Collections.<String, Object> singletonMap(\"task_in_a1\", \"a0\");\n+        Map<String, Object> attributes = Collections.<String, Object> singletonMap(\"deploymentId\", \"org.jbpm.test:test-module:1.0.0\");\n+        List<String> potOwners = emptyList();\n+        List<UserTaskInstanceWithPotOwnerDesc> data = advanceVariableDataService.queryUserTasksByVariables(attributes, variables, emptyMap(), potOwners, new QueryContext());\n+        Assert.assertEquals(4, data.size());\n+        for (UserTaskInstanceWithPotOwnerDesc p : data) {\n+            Assert.assertEquals(\"a0\", p.getInputdata().get(\"task_in_a1\"));\n+            Assert.assertEquals(\"org.jbpm.test:test-module:1.0.0\", p.getDeploymentId());\n+        }\n+    }\n+\n+    @Test\n+    public void testQueryTaskByVariablesWithPagination() {\n+        Map<String, Object> variables = Collections.<String, Object> singletonMap(\"task_in_a1\", \"a0\");\n+        Map<String, Object> attributes = Collections.<String, Object> singletonMap(\"deploymentId\", \"org.jbpm.test:test-module:1.0.0\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1e57dd6f9a77d2e636949457815115ca83acc4dc"}, "originalPosition": 176}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ5NTQ3Nzg1OnYy", "diffSide": "RIGHT", "path": "jbpm-services/jbpm-kie-services/src/test/java/org/jbpm/kie/services/test/AdvanceRuntimeDataServiceImplTest.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMlQxNDo0NTozM1rOF_uwhg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMlQxNDo0NTozM1rOF_uwhg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjM3MDY5NA==", "bodyText": "Why not just use emptyList() as input parameter for the queryUserTaskByVariables rather than creating a non-used variable potOwners?", "url": "https://github.com/kiegroup/jbpm/pull/1615#discussion_r402370694", "createdAt": "2020-04-02T14:45:33Z", "author": {"login": "afalhambra"}, "path": "jbpm-services/jbpm-kie-services/src/test/java/org/jbpm/kie/services/test/AdvanceRuntimeDataServiceImplTest.java", "diffHunk": "@@ -0,0 +1,219 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.jbpm.kie.services.test;\n+\n+import java.io.File;\n+import java.io.FileOutputStream;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.drools.compiler.kie.builder.impl.InternalKieModule;\n+import org.jbpm.kie.services.impl.KModuleDeploymentUnit;\n+import org.jbpm.kie.test.util.AbstractKieServicesBaseTest;\n+import org.jbpm.services.api.ProcessInstanceNotFoundException;\n+import org.jbpm.services.api.model.DeploymentUnit;\n+import org.jbpm.services.api.model.ProcessInstanceWithVarsDesc;\n+import org.jbpm.services.api.model.UserTaskInstanceWithPotOwnerDesc;\n+import org.junit.After;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.kie.api.KieServices;\n+import org.kie.api.builder.ReleaseId;\n+import org.kie.api.runtime.process.ProcessInstance;\n+import org.kie.internal.query.QueryContext;\n+import org.kie.scanner.KieMavenRepository;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static java.util.Collections.emptyList;\n+import static java.util.Collections.emptyMap;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertNull;\n+import static org.kie.scanner.KieMavenRepository.getKieMavenRepository;\n+\n+public class AdvanceRuntimeDataServiceImplTest extends AbstractKieServicesBaseTest {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(AdvanceRuntimeDataServiceImplTest.class);\n+\n+    private List<DeploymentUnit> units = new ArrayList<DeploymentUnit>();\n+    protected String correctUser = \"testUser\";\n+    protected String wrongUser = \"wrongUser\";\n+\n+    private List<Long> processIds;\n+    private KModuleDeploymentUnit deploymentUnit = null;\n+\n+    @Before\n+    public void prepare() {\n+\n+        configureServices();\n+        logger.debug(\"Preparing kjar\");\n+        KieServices ks = KieServices.Factory.get();\n+        ReleaseId releaseId = ks.newReleaseId(GROUP_ID, ARTIFACT_ID, VERSION);\n+        List<String> processes = new ArrayList<String>();\n+        processes.add(\"repo/processes/general/SingleHumanTaskWithVarsA.bpmn2\");\n+        processes.add(\"repo/processes/general/SingleHumanTaskWithVarsB.bpmn2\");\n+\n+        InternalKieModule kJar1 = createKieJar(ks, releaseId, processes);\n+        File pom = new File(\"target/kmodule\", \"pom.xml\");\n+        pom.getParentFile().mkdir();\n+        try (FileOutputStream fs = new FileOutputStream(pom);) {\n+            fs.write(getPom(releaseId).getBytes());\n+        } catch (Exception e) {\n+\n+        }\n+        KieMavenRepository repository = getKieMavenRepository();\n+        repository.deployArtifact(releaseId, kJar1, pom);\n+\n+        assertNotNull(deploymentService);\n+\n+        deploymentUnit = new KModuleDeploymentUnit(GROUP_ID, ARTIFACT_ID, VERSION);\n+\n+        deploymentService.deploy(deploymentUnit);\n+        units.add(deploymentUnit);\n+        assertNotNull(processService);\n+\n+        processIds = new ArrayList<>();\n+        for (int i = 0; i < 10; i++) {\n+            Map<String, Object> inputsA1 = new HashMap<>();\n+            inputsA1.put(\"var_a\", \"a\" + (i % 3));\n+            inputsA1.put(\"var_b\", (i % 3));\n+            processIds.add(processService.startProcess(deploymentUnit.getIdentifier(), \"test.test_A\", inputsA1));\n+        }\n+        for (int i = 0; i < 10; i++) {\n+            Map<String, Object> inputsB1 = new HashMap<>();\n+            inputsB1.put(\"var_a\", \"b\" + (i % 3));\n+            inputsB1.put(\"var_b\", (i % 3));\n+            processIds.add(processService.startProcess(deploymentUnit.getIdentifier(), \"test.test_B\", inputsB1));\n+        }\n+    }\n+\n+    @After\n+    public void cleanup() {\n+        for (Long processInstanceId : processIds) {\n+            try {\n+                // let's abort process instance to leave the system in clear state\n+                processService.abortProcessInstance(processInstanceId);\n+\n+                ProcessInstance pi = processService.getProcessInstance(processInstanceId);\n+                assertNull(pi);\n+            } catch (ProcessInstanceNotFoundException e) {\n+                // ignore it as it was already completed/aborted\n+            }\n+        }\n+        cleanupSingletonSessionId();\n+        if (units != null && !units.isEmpty()) {\n+            for (DeploymentUnit unit : units) {\n+                try {\n+                    deploymentService.undeploy(unit);\n+                } catch (Exception e) {\n+                    // do nothing in case of some failed tests to avoid next test to fail as well\n+                }\n+            }\n+            units.clear();\n+        }\n+        close();\n+    }\n+\n+    @Test\n+    public void testQueryProcessByVariables() {\n+        Map<String, Object> variables = Collections.<String, Object> singletonMap(\"var_a\", \"a1\");\n+        Map<String, Object> attributes = Collections.<String, Object> singletonMap(\"processId\", \"test.test_A\");\n+        List<ProcessInstanceWithVarsDesc> data = advanceVariableDataService.queryProcessByVariables(attributes, variables, new QueryContext());\n+        Assert.assertEquals(3, data.size());\n+        for (ProcessInstanceWithVarsDesc p : data) {\n+            Assert.assertEquals(\"a1\", p.getVariables().get(\"var_a\"));\n+            Assert.assertEquals(\"test.test_A\", p.getProcessId());\n+        }\n+    }\n+\n+    @Test\n+    public void testQueryProcessByVariablesWithPagination() {\n+        Map<String, Object> variables = Collections.<String, Object> singletonMap(\"var_a\", \"a1\");\n+        Map<String, Object> attributes = Collections.<String, Object> singletonMap(\"processId\", \"test.test_A\");\n+        List<ProcessInstanceWithVarsDesc> data = advanceVariableDataService.queryProcessByVariables(attributes, variables, new QueryContext(0, 2));\n+        Assert.assertEquals(2, data.size());\n+        for (ProcessInstanceWithVarsDesc p : data) {\n+            Assert.assertEquals(\"a1\", p.getVariables().get(\"var_a\"));\n+            Assert.assertEquals(\"test.test_A\", p.getProcessId());\n+        }\n+    }\n+\n+    @Test\n+    public void testQueryTaskByVariables() {\n+        Map<String, Object> variables = Collections.<String, Object> singletonMap(\"task_in_a1\", \"a0\");\n+        Map<String, Object> attributes = Collections.<String, Object> singletonMap(\"deploymentId\", \"org.jbpm.test:test-module:1.0.0\");\n+        List<String> potOwners = emptyList();\n+        List<UserTaskInstanceWithPotOwnerDesc> data = advanceVariableDataService.queryUserTasksByVariables(attributes, variables, emptyMap(), potOwners, new QueryContext());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1e57dd6f9a77d2e636949457815115ca83acc4dc"}, "originalPosition": 165}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ5NTQ4MTYyOnYy", "diffSide": "RIGHT", "path": "jbpm-services/jbpm-kie-services/src/test/java/org/jbpm/kie/services/test/AdvanceRuntimeDataServiceImplTest.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMlQxNDo0NjoyMlrOF_uzBw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMlQxNDo0NjoyMlrOF_uzBw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjM3MTMzNQ==", "bodyText": "Why not just use emptyList() as input parameter for the queryUserTaskByVariables rather than creating a non-used variable potOwners?", "url": "https://github.com/kiegroup/jbpm/pull/1615#discussion_r402371335", "createdAt": "2020-04-02T14:46:22Z", "author": {"login": "afalhambra"}, "path": "jbpm-services/jbpm-kie-services/src/test/java/org/jbpm/kie/services/test/AdvanceRuntimeDataServiceImplTest.java", "diffHunk": "@@ -0,0 +1,219 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.jbpm.kie.services.test;\n+\n+import java.io.File;\n+import java.io.FileOutputStream;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.drools.compiler.kie.builder.impl.InternalKieModule;\n+import org.jbpm.kie.services.impl.KModuleDeploymentUnit;\n+import org.jbpm.kie.test.util.AbstractKieServicesBaseTest;\n+import org.jbpm.services.api.ProcessInstanceNotFoundException;\n+import org.jbpm.services.api.model.DeploymentUnit;\n+import org.jbpm.services.api.model.ProcessInstanceWithVarsDesc;\n+import org.jbpm.services.api.model.UserTaskInstanceWithPotOwnerDesc;\n+import org.junit.After;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.kie.api.KieServices;\n+import org.kie.api.builder.ReleaseId;\n+import org.kie.api.runtime.process.ProcessInstance;\n+import org.kie.internal.query.QueryContext;\n+import org.kie.scanner.KieMavenRepository;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static java.util.Collections.emptyList;\n+import static java.util.Collections.emptyMap;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertNull;\n+import static org.kie.scanner.KieMavenRepository.getKieMavenRepository;\n+\n+public class AdvanceRuntimeDataServiceImplTest extends AbstractKieServicesBaseTest {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(AdvanceRuntimeDataServiceImplTest.class);\n+\n+    private List<DeploymentUnit> units = new ArrayList<DeploymentUnit>();\n+    protected String correctUser = \"testUser\";\n+    protected String wrongUser = \"wrongUser\";\n+\n+    private List<Long> processIds;\n+    private KModuleDeploymentUnit deploymentUnit = null;\n+\n+    @Before\n+    public void prepare() {\n+\n+        configureServices();\n+        logger.debug(\"Preparing kjar\");\n+        KieServices ks = KieServices.Factory.get();\n+        ReleaseId releaseId = ks.newReleaseId(GROUP_ID, ARTIFACT_ID, VERSION);\n+        List<String> processes = new ArrayList<String>();\n+        processes.add(\"repo/processes/general/SingleHumanTaskWithVarsA.bpmn2\");\n+        processes.add(\"repo/processes/general/SingleHumanTaskWithVarsB.bpmn2\");\n+\n+        InternalKieModule kJar1 = createKieJar(ks, releaseId, processes);\n+        File pom = new File(\"target/kmodule\", \"pom.xml\");\n+        pom.getParentFile().mkdir();\n+        try (FileOutputStream fs = new FileOutputStream(pom);) {\n+            fs.write(getPom(releaseId).getBytes());\n+        } catch (Exception e) {\n+\n+        }\n+        KieMavenRepository repository = getKieMavenRepository();\n+        repository.deployArtifact(releaseId, kJar1, pom);\n+\n+        assertNotNull(deploymentService);\n+\n+        deploymentUnit = new KModuleDeploymentUnit(GROUP_ID, ARTIFACT_ID, VERSION);\n+\n+        deploymentService.deploy(deploymentUnit);\n+        units.add(deploymentUnit);\n+        assertNotNull(processService);\n+\n+        processIds = new ArrayList<>();\n+        for (int i = 0; i < 10; i++) {\n+            Map<String, Object> inputsA1 = new HashMap<>();\n+            inputsA1.put(\"var_a\", \"a\" + (i % 3));\n+            inputsA1.put(\"var_b\", (i % 3));\n+            processIds.add(processService.startProcess(deploymentUnit.getIdentifier(), \"test.test_A\", inputsA1));\n+        }\n+        for (int i = 0; i < 10; i++) {\n+            Map<String, Object> inputsB1 = new HashMap<>();\n+            inputsB1.put(\"var_a\", \"b\" + (i % 3));\n+            inputsB1.put(\"var_b\", (i % 3));\n+            processIds.add(processService.startProcess(deploymentUnit.getIdentifier(), \"test.test_B\", inputsB1));\n+        }\n+    }\n+\n+    @After\n+    public void cleanup() {\n+        for (Long processInstanceId : processIds) {\n+            try {\n+                // let's abort process instance to leave the system in clear state\n+                processService.abortProcessInstance(processInstanceId);\n+\n+                ProcessInstance pi = processService.getProcessInstance(processInstanceId);\n+                assertNull(pi);\n+            } catch (ProcessInstanceNotFoundException e) {\n+                // ignore it as it was already completed/aborted\n+            }\n+        }\n+        cleanupSingletonSessionId();\n+        if (units != null && !units.isEmpty()) {\n+            for (DeploymentUnit unit : units) {\n+                try {\n+                    deploymentService.undeploy(unit);\n+                } catch (Exception e) {\n+                    // do nothing in case of some failed tests to avoid next test to fail as well\n+                }\n+            }\n+            units.clear();\n+        }\n+        close();\n+    }\n+\n+    @Test\n+    public void testQueryProcessByVariables() {\n+        Map<String, Object> variables = Collections.<String, Object> singletonMap(\"var_a\", \"a1\");\n+        Map<String, Object> attributes = Collections.<String, Object> singletonMap(\"processId\", \"test.test_A\");\n+        List<ProcessInstanceWithVarsDesc> data = advanceVariableDataService.queryProcessByVariables(attributes, variables, new QueryContext());\n+        Assert.assertEquals(3, data.size());\n+        for (ProcessInstanceWithVarsDesc p : data) {\n+            Assert.assertEquals(\"a1\", p.getVariables().get(\"var_a\"));\n+            Assert.assertEquals(\"test.test_A\", p.getProcessId());\n+        }\n+    }\n+\n+    @Test\n+    public void testQueryProcessByVariablesWithPagination() {\n+        Map<String, Object> variables = Collections.<String, Object> singletonMap(\"var_a\", \"a1\");\n+        Map<String, Object> attributes = Collections.<String, Object> singletonMap(\"processId\", \"test.test_A\");\n+        List<ProcessInstanceWithVarsDesc> data = advanceVariableDataService.queryProcessByVariables(attributes, variables, new QueryContext(0, 2));\n+        Assert.assertEquals(2, data.size());\n+        for (ProcessInstanceWithVarsDesc p : data) {\n+            Assert.assertEquals(\"a1\", p.getVariables().get(\"var_a\"));\n+            Assert.assertEquals(\"test.test_A\", p.getProcessId());\n+        }\n+    }\n+\n+    @Test\n+    public void testQueryTaskByVariables() {\n+        Map<String, Object> variables = Collections.<String, Object> singletonMap(\"task_in_a1\", \"a0\");\n+        Map<String, Object> attributes = Collections.<String, Object> singletonMap(\"deploymentId\", \"org.jbpm.test:test-module:1.0.0\");\n+        List<String> potOwners = emptyList();\n+        List<UserTaskInstanceWithPotOwnerDesc> data = advanceVariableDataService.queryUserTasksByVariables(attributes, variables, emptyMap(), potOwners, new QueryContext());\n+        Assert.assertEquals(4, data.size());\n+        for (UserTaskInstanceWithPotOwnerDesc p : data) {\n+            Assert.assertEquals(\"a0\", p.getInputdata().get(\"task_in_a1\"));\n+            Assert.assertEquals(\"org.jbpm.test:test-module:1.0.0\", p.getDeploymentId());\n+        }\n+    }\n+\n+    @Test\n+    public void testQueryTaskByVariablesWithPagination() {\n+        Map<String, Object> variables = Collections.<String, Object> singletonMap(\"task_in_a1\", \"a0\");\n+        Map<String, Object> attributes = Collections.<String, Object> singletonMap(\"deploymentId\", \"org.jbpm.test:test-module:1.0.0\");\n+        List<String> potOwners = emptyList();\n+        List<UserTaskInstanceWithPotOwnerDesc> data = advanceVariableDataService.queryUserTasksByVariables(attributes, variables, emptyMap(), potOwners, new QueryContext(0, 2));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1e57dd6f9a77d2e636949457815115ca83acc4dc"}, "originalPosition": 178}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ5NTUxMzg0OnYy", "diffSide": "RIGHT", "path": "jbpm-services/jbpm-kie-services/src/main/java/org/jbpm/kie/services/impl/AbstractAdvanceRuntimeDataServiceImpl.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMlQxNDo1Mjo0NVrOF_vHZg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMlQxNDo1Mjo0NVrOF_vHZg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjM3NjU1MA==", "bodyText": "How do we iterate through batches of a particular query with some pagination?", "url": "https://github.com/kiegroup/jbpm/pull/1615#discussion_r402376550", "createdAt": "2020-04-02T14:52:45Z", "author": {"login": "afalhambra"}, "path": "jbpm-services/jbpm-kie-services/src/main/java/org/jbpm/kie/services/impl/AbstractAdvanceRuntimeDataServiceImpl.java", "diffHunk": "@@ -0,0 +1,306 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.jbpm.kie.services.impl;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import javax.persistence.EntityManager;\n+import javax.persistence.EntityManagerFactory;\n+import javax.persistence.Query;\n+\n+import org.jbpm.kie.services.impl.model.ProcessInstanceWithVarsDesc;\n+import org.jbpm.kie.services.impl.model.UserTaskInstanceWithPotOwnerDesc;\n+import org.jbpm.shared.services.impl.QueryManager;\n+import org.jbpm.shared.services.impl.TransactionalCommandService;\n+import org.jbpm.shared.services.impl.commands.QueryNameCommand;\n+import org.kie.api.runtime.query.QueryContext;\n+\n+import static java.util.Collections.singletonMap;\n+\n+public abstract class AbstractAdvanceRuntimeDataServiceImpl {\n+\n+    private EntityManagerFactory emf;\n+    private TransactionalCommandService commandService;\n+\n+    public AbstractAdvanceRuntimeDataServiceImpl() {\n+        QueryManager.get().addNamedQueries(\"META-INF/Servicesorm.xml\");\n+    }\n+    public void setCommandService(TransactionalCommandService commandService) {\n+        this.commandService = commandService;\n+    }\n+\n+    public void setEmf(EntityManagerFactory emf) {\n+        this.emf = emf;\n+    }\n+\n+\n+    public List<org.jbpm.services.api.model.ProcessInstanceWithVarsDesc> queryProcessByVariables(Map<String, Object> attributes,\n+                                                                                                 Map<String, Object> variables,\n+                                                                                                 int processType,\n+                                                                                                 String varPrefix,\n+                                                                                                 QueryContext queryContext) {\n+        EntityManager entityManager = emf.createEntityManager();\n+\n+        // first step is to filter the data creating a derived tables and pivoting var - rows to columns (only the variables we are interested to filter)\n+        StringBuilder where = new StringBuilder();\n+        StringBuilder derivedTables = new StringBuilder();\n+        for (Map.Entry<String, Object> var : variables.entrySet()) {\n+            String alias = \"TABLE_\" + var.getKey();\n+            String varName = var.getKey();\n+\n+            derivedTables.append(\"LEFT JOIN (\" +\n+                                 \"SELECT A1.processId, A1.processInstanceId, A1.variableId AS NAME, A1.value AS VALUE \\n\" +\n+                                 \"FROM VariableInstanceLog A1 \\n\" +\n+                                 \"LEFT JOIN VariableInstanceLog A2 ON A1.processId = A2.processId AND A1.processInstanceId = A2.processInstanceId AND A1.variableInstanceId = A2.variableInstanceId AND A2.log_date < A1.log_date  \\n\" +\n+                                 \"WHERE A2.log_date IS NULL \\n\" +\n+                                 \") \" + alias + \" ON \" + alias + \".processId = pil.processId AND \" + alias + \".processInstanceId = pil.processInstanceId \\n\");\n+\n+            addWhereExpression(where);\n+            where.append(alias + \".NAME = :NAME_\" + varName + \" AND \" + alias + \".VALUE= :VALUE_\" + varName + \"\\n\");\n+        }\n+\n+\n+        for (Map.Entry<String, Object> entry : attributes.entrySet()) {\n+            addWhereExpression(where);\n+            where.append(\" pil.\" + entry.getKey() + \" = :ATTR_\" + entry.getKey() + \" \");\n+        }\n+\n+        addWhereExpression(where);\n+        where.append(\" pil.processType = :processType \");\n+\n+        String procSQLString = \"SELECT DISTINCT pil.processInstanceId FROM ProcessInstanceLog pil \\n \" + derivedTables + where + \" ORDER BY pil.processInstanceId ASC \";\n+        procSQLString += (queryContext.getCount() > 0) ? \" LIMIT \" + queryContext.getCount() + \" OFFSET \" + queryContext.getOffset() + \" \\n\" : \"\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1e57dd6f9a77d2e636949457815115ca83acc4dc"}, "originalPosition": 91}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ5NTUyOTg5OnYy", "diffSide": "RIGHT", "path": "jbpm-services/jbpm-kie-services/src/test/java/org/jbpm/kie/services/test/AdvanceRuntimeDataServiceImplTest.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMlQxNDo1NjowMFrOF_vR4Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMlQxNDo1NjowMFrOF_vR4Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjM3OTIzMw==", "bodyText": "We're already passing processVariables as emptyMap*) in call, why not do the same for these?", "url": "https://github.com/kiegroup/jbpm/pull/1615#discussion_r402379233", "createdAt": "2020-04-02T14:56:00Z", "author": {"login": "afalhambra"}, "path": "jbpm-services/jbpm-kie-services/src/test/java/org/jbpm/kie/services/test/AdvanceRuntimeDataServiceImplTest.java", "diffHunk": "@@ -0,0 +1,219 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.jbpm.kie.services.test;\n+\n+import java.io.File;\n+import java.io.FileOutputStream;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.drools.compiler.kie.builder.impl.InternalKieModule;\n+import org.jbpm.kie.services.impl.KModuleDeploymentUnit;\n+import org.jbpm.kie.test.util.AbstractKieServicesBaseTest;\n+import org.jbpm.services.api.ProcessInstanceNotFoundException;\n+import org.jbpm.services.api.model.DeploymentUnit;\n+import org.jbpm.services.api.model.ProcessInstanceWithVarsDesc;\n+import org.jbpm.services.api.model.UserTaskInstanceWithPotOwnerDesc;\n+import org.junit.After;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.kie.api.KieServices;\n+import org.kie.api.builder.ReleaseId;\n+import org.kie.api.runtime.process.ProcessInstance;\n+import org.kie.internal.query.QueryContext;\n+import org.kie.scanner.KieMavenRepository;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static java.util.Collections.emptyList;\n+import static java.util.Collections.emptyMap;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertNull;\n+import static org.kie.scanner.KieMavenRepository.getKieMavenRepository;\n+\n+public class AdvanceRuntimeDataServiceImplTest extends AbstractKieServicesBaseTest {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(AdvanceRuntimeDataServiceImplTest.class);\n+\n+    private List<DeploymentUnit> units = new ArrayList<DeploymentUnit>();\n+    protected String correctUser = \"testUser\";\n+    protected String wrongUser = \"wrongUser\";\n+\n+    private List<Long> processIds;\n+    private KModuleDeploymentUnit deploymentUnit = null;\n+\n+    @Before\n+    public void prepare() {\n+\n+        configureServices();\n+        logger.debug(\"Preparing kjar\");\n+        KieServices ks = KieServices.Factory.get();\n+        ReleaseId releaseId = ks.newReleaseId(GROUP_ID, ARTIFACT_ID, VERSION);\n+        List<String> processes = new ArrayList<String>();\n+        processes.add(\"repo/processes/general/SingleHumanTaskWithVarsA.bpmn2\");\n+        processes.add(\"repo/processes/general/SingleHumanTaskWithVarsB.bpmn2\");\n+\n+        InternalKieModule kJar1 = createKieJar(ks, releaseId, processes);\n+        File pom = new File(\"target/kmodule\", \"pom.xml\");\n+        pom.getParentFile().mkdir();\n+        try (FileOutputStream fs = new FileOutputStream(pom);) {\n+            fs.write(getPom(releaseId).getBytes());\n+        } catch (Exception e) {\n+\n+        }\n+        KieMavenRepository repository = getKieMavenRepository();\n+        repository.deployArtifact(releaseId, kJar1, pom);\n+\n+        assertNotNull(deploymentService);\n+\n+        deploymentUnit = new KModuleDeploymentUnit(GROUP_ID, ARTIFACT_ID, VERSION);\n+\n+        deploymentService.deploy(deploymentUnit);\n+        units.add(deploymentUnit);\n+        assertNotNull(processService);\n+\n+        processIds = new ArrayList<>();\n+        for (int i = 0; i < 10; i++) {\n+            Map<String, Object> inputsA1 = new HashMap<>();\n+            inputsA1.put(\"var_a\", \"a\" + (i % 3));\n+            inputsA1.put(\"var_b\", (i % 3));\n+            processIds.add(processService.startProcess(deploymentUnit.getIdentifier(), \"test.test_A\", inputsA1));\n+        }\n+        for (int i = 0; i < 10; i++) {\n+            Map<String, Object> inputsB1 = new HashMap<>();\n+            inputsB1.put(\"var_a\", \"b\" + (i % 3));\n+            inputsB1.put(\"var_b\", (i % 3));\n+            processIds.add(processService.startProcess(deploymentUnit.getIdentifier(), \"test.test_B\", inputsB1));\n+        }\n+    }\n+\n+    @After\n+    public void cleanup() {\n+        for (Long processInstanceId : processIds) {\n+            try {\n+                // let's abort process instance to leave the system in clear state\n+                processService.abortProcessInstance(processInstanceId);\n+\n+                ProcessInstance pi = processService.getProcessInstance(processInstanceId);\n+                assertNull(pi);\n+            } catch (ProcessInstanceNotFoundException e) {\n+                // ignore it as it was already completed/aborted\n+            }\n+        }\n+        cleanupSingletonSessionId();\n+        if (units != null && !units.isEmpty()) {\n+            for (DeploymentUnit unit : units) {\n+                try {\n+                    deploymentService.undeploy(unit);\n+                } catch (Exception e) {\n+                    // do nothing in case of some failed tests to avoid next test to fail as well\n+                }\n+            }\n+            units.clear();\n+        }\n+        close();\n+    }\n+\n+    @Test\n+    public void testQueryProcessByVariables() {\n+        Map<String, Object> variables = Collections.<String, Object> singletonMap(\"var_a\", \"a1\");\n+        Map<String, Object> attributes = Collections.<String, Object> singletonMap(\"processId\", \"test.test_A\");\n+        List<ProcessInstanceWithVarsDesc> data = advanceVariableDataService.queryProcessByVariables(attributes, variables, new QueryContext());\n+        Assert.assertEquals(3, data.size());\n+        for (ProcessInstanceWithVarsDesc p : data) {\n+            Assert.assertEquals(\"a1\", p.getVariables().get(\"var_a\"));\n+            Assert.assertEquals(\"test.test_A\", p.getProcessId());\n+        }\n+    }\n+\n+    @Test\n+    public void testQueryProcessByVariablesWithPagination() {\n+        Map<String, Object> variables = Collections.<String, Object> singletonMap(\"var_a\", \"a1\");\n+        Map<String, Object> attributes = Collections.<String, Object> singletonMap(\"processId\", \"test.test_A\");\n+        List<ProcessInstanceWithVarsDesc> data = advanceVariableDataService.queryProcessByVariables(attributes, variables, new QueryContext(0, 2));\n+        Assert.assertEquals(2, data.size());\n+        for (ProcessInstanceWithVarsDesc p : data) {\n+            Assert.assertEquals(\"a1\", p.getVariables().get(\"var_a\"));\n+            Assert.assertEquals(\"test.test_A\", p.getProcessId());\n+        }\n+    }\n+\n+    @Test\n+    public void testQueryTaskByVariables() {\n+        Map<String, Object> variables = Collections.<String, Object> singletonMap(\"task_in_a1\", \"a0\");\n+        Map<String, Object> attributes = Collections.<String, Object> singletonMap(\"deploymentId\", \"org.jbpm.test:test-module:1.0.0\");\n+        List<String> potOwners = emptyList();\n+        List<UserTaskInstanceWithPotOwnerDesc> data = advanceVariableDataService.queryUserTasksByVariables(attributes, variables, emptyMap(), potOwners, new QueryContext());\n+        Assert.assertEquals(4, data.size());\n+        for (UserTaskInstanceWithPotOwnerDesc p : data) {\n+            Assert.assertEquals(\"a0\", p.getInputdata().get(\"task_in_a1\"));\n+            Assert.assertEquals(\"org.jbpm.test:test-module:1.0.0\", p.getDeploymentId());\n+        }\n+    }\n+\n+    @Test\n+    public void testQueryTaskByVariablesWithPagination() {\n+        Map<String, Object> variables = Collections.<String, Object> singletonMap(\"task_in_a1\", \"a0\");\n+        Map<String, Object> attributes = Collections.<String, Object> singletonMap(\"deploymentId\", \"org.jbpm.test:test-module:1.0.0\");\n+        List<String> potOwners = emptyList();\n+        List<UserTaskInstanceWithPotOwnerDesc> data = advanceVariableDataService.queryUserTasksByVariables(attributes, variables, emptyMap(), potOwners, new QueryContext(0, 2));\n+        Assert.assertEquals(2, data.size());\n+        for (UserTaskInstanceWithPotOwnerDesc p : data) {\n+            Assert.assertEquals(\"a0\", p.getInputdata().get(\"task_in_a1\"));\n+            Assert.assertEquals(\"org.jbpm.test:test-module:1.0.0\", p.getDeploymentId());\n+        }\n+    }\n+\n+    @Test\n+    public void testQueryTaskByVariablesWithOwners() {\n+        Map<String, Object> variables = emptyMap();\n+        Map<String, Object> attributes = emptyMap();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1e57dd6f9a77d2e636949457815115ca83acc4dc"}, "originalPosition": 189}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ5NTU2MzgzOnYy", "diffSide": "RIGHT", "path": "jbpm-services/jbpm-kie-services/src/test/java/org/jbpm/kie/services/test/AdvanceRuntimeDataServiceImplTest.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMlQxNTowMjo1MFrOF_vnlA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMlQxNTowMjo1MFrOF_vnlA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjM4NDc4OA==", "bodyText": "How would you get the next batch for pagination?", "url": "https://github.com/kiegroup/jbpm/pull/1615#discussion_r402384788", "createdAt": "2020-04-02T15:02:50Z", "author": {"login": "afalhambra"}, "path": "jbpm-services/jbpm-kie-services/src/test/java/org/jbpm/kie/services/test/AdvanceRuntimeDataServiceImplTest.java", "diffHunk": "@@ -0,0 +1,219 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.jbpm.kie.services.test;\n+\n+import java.io.File;\n+import java.io.FileOutputStream;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.drools.compiler.kie.builder.impl.InternalKieModule;\n+import org.jbpm.kie.services.impl.KModuleDeploymentUnit;\n+import org.jbpm.kie.test.util.AbstractKieServicesBaseTest;\n+import org.jbpm.services.api.ProcessInstanceNotFoundException;\n+import org.jbpm.services.api.model.DeploymentUnit;\n+import org.jbpm.services.api.model.ProcessInstanceWithVarsDesc;\n+import org.jbpm.services.api.model.UserTaskInstanceWithPotOwnerDesc;\n+import org.junit.After;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.kie.api.KieServices;\n+import org.kie.api.builder.ReleaseId;\n+import org.kie.api.runtime.process.ProcessInstance;\n+import org.kie.internal.query.QueryContext;\n+import org.kie.scanner.KieMavenRepository;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static java.util.Collections.emptyList;\n+import static java.util.Collections.emptyMap;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertNull;\n+import static org.kie.scanner.KieMavenRepository.getKieMavenRepository;\n+\n+public class AdvanceRuntimeDataServiceImplTest extends AbstractKieServicesBaseTest {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(AdvanceRuntimeDataServiceImplTest.class);\n+\n+    private List<DeploymentUnit> units = new ArrayList<DeploymentUnit>();\n+    protected String correctUser = \"testUser\";\n+    protected String wrongUser = \"wrongUser\";\n+\n+    private List<Long> processIds;\n+    private KModuleDeploymentUnit deploymentUnit = null;\n+\n+    @Before\n+    public void prepare() {\n+\n+        configureServices();\n+        logger.debug(\"Preparing kjar\");\n+        KieServices ks = KieServices.Factory.get();\n+        ReleaseId releaseId = ks.newReleaseId(GROUP_ID, ARTIFACT_ID, VERSION);\n+        List<String> processes = new ArrayList<String>();\n+        processes.add(\"repo/processes/general/SingleHumanTaskWithVarsA.bpmn2\");\n+        processes.add(\"repo/processes/general/SingleHumanTaskWithVarsB.bpmn2\");\n+\n+        InternalKieModule kJar1 = createKieJar(ks, releaseId, processes);\n+        File pom = new File(\"target/kmodule\", \"pom.xml\");\n+        pom.getParentFile().mkdir();\n+        try (FileOutputStream fs = new FileOutputStream(pom);) {\n+            fs.write(getPom(releaseId).getBytes());\n+        } catch (Exception e) {\n+\n+        }\n+        KieMavenRepository repository = getKieMavenRepository();\n+        repository.deployArtifact(releaseId, kJar1, pom);\n+\n+        assertNotNull(deploymentService);\n+\n+        deploymentUnit = new KModuleDeploymentUnit(GROUP_ID, ARTIFACT_ID, VERSION);\n+\n+        deploymentService.deploy(deploymentUnit);\n+        units.add(deploymentUnit);\n+        assertNotNull(processService);\n+\n+        processIds = new ArrayList<>();\n+        for (int i = 0; i < 10; i++) {\n+            Map<String, Object> inputsA1 = new HashMap<>();\n+            inputsA1.put(\"var_a\", \"a\" + (i % 3));\n+            inputsA1.put(\"var_b\", (i % 3));\n+            processIds.add(processService.startProcess(deploymentUnit.getIdentifier(), \"test.test_A\", inputsA1));\n+        }\n+        for (int i = 0; i < 10; i++) {\n+            Map<String, Object> inputsB1 = new HashMap<>();\n+            inputsB1.put(\"var_a\", \"b\" + (i % 3));\n+            inputsB1.put(\"var_b\", (i % 3));\n+            processIds.add(processService.startProcess(deploymentUnit.getIdentifier(), \"test.test_B\", inputsB1));\n+        }\n+    }\n+\n+    @After\n+    public void cleanup() {\n+        for (Long processInstanceId : processIds) {\n+            try {\n+                // let's abort process instance to leave the system in clear state\n+                processService.abortProcessInstance(processInstanceId);\n+\n+                ProcessInstance pi = processService.getProcessInstance(processInstanceId);\n+                assertNull(pi);\n+            } catch (ProcessInstanceNotFoundException e) {\n+                // ignore it as it was already completed/aborted\n+            }\n+        }\n+        cleanupSingletonSessionId();\n+        if (units != null && !units.isEmpty()) {\n+            for (DeploymentUnit unit : units) {\n+                try {\n+                    deploymentService.undeploy(unit);\n+                } catch (Exception e) {\n+                    // do nothing in case of some failed tests to avoid next test to fail as well\n+                }\n+            }\n+            units.clear();\n+        }\n+        close();\n+    }\n+\n+    @Test\n+    public void testQueryProcessByVariables() {\n+        Map<String, Object> variables = Collections.<String, Object> singletonMap(\"var_a\", \"a1\");\n+        Map<String, Object> attributes = Collections.<String, Object> singletonMap(\"processId\", \"test.test_A\");\n+        List<ProcessInstanceWithVarsDesc> data = advanceVariableDataService.queryProcessByVariables(attributes, variables, new QueryContext());\n+        Assert.assertEquals(3, data.size());\n+        for (ProcessInstanceWithVarsDesc p : data) {\n+            Assert.assertEquals(\"a1\", p.getVariables().get(\"var_a\"));\n+            Assert.assertEquals(\"test.test_A\", p.getProcessId());\n+        }\n+    }\n+\n+    @Test\n+    public void testQueryProcessByVariablesWithPagination() {\n+        Map<String, Object> variables = Collections.<String, Object> singletonMap(\"var_a\", \"a1\");\n+        Map<String, Object> attributes = Collections.<String, Object> singletonMap(\"processId\", \"test.test_A\");\n+        List<ProcessInstanceWithVarsDesc> data = advanceVariableDataService.queryProcessByVariables(attributes, variables, new QueryContext(0, 2));\n+        Assert.assertEquals(2, data.size());\n+        for (ProcessInstanceWithVarsDesc p : data) {\n+            Assert.assertEquals(\"a1\", p.getVariables().get(\"var_a\"));\n+            Assert.assertEquals(\"test.test_A\", p.getProcessId());\n+        }\n+    }\n+\n+    @Test\n+    public void testQueryTaskByVariables() {\n+        Map<String, Object> variables = Collections.<String, Object> singletonMap(\"task_in_a1\", \"a0\");\n+        Map<String, Object> attributes = Collections.<String, Object> singletonMap(\"deploymentId\", \"org.jbpm.test:test-module:1.0.0\");\n+        List<String> potOwners = emptyList();\n+        List<UserTaskInstanceWithPotOwnerDesc> data = advanceVariableDataService.queryUserTasksByVariables(attributes, variables, emptyMap(), potOwners, new QueryContext());\n+        Assert.assertEquals(4, data.size());\n+        for (UserTaskInstanceWithPotOwnerDesc p : data) {\n+            Assert.assertEquals(\"a0\", p.getInputdata().get(\"task_in_a1\"));\n+            Assert.assertEquals(\"org.jbpm.test:test-module:1.0.0\", p.getDeploymentId());\n+        }\n+    }\n+\n+    @Test\n+    public void testQueryTaskByVariablesWithPagination() {\n+        Map<String, Object> variables = Collections.<String, Object> singletonMap(\"task_in_a1\", \"a0\");\n+        Map<String, Object> attributes = Collections.<String, Object> singletonMap(\"deploymentId\", \"org.jbpm.test:test-module:1.0.0\");\n+        List<String> potOwners = emptyList();\n+        List<UserTaskInstanceWithPotOwnerDesc> data = advanceVariableDataService.queryUserTasksByVariables(attributes, variables, emptyMap(), potOwners, new QueryContext(0, 2));\n+        Assert.assertEquals(2, data.size());\n+        for (UserTaskInstanceWithPotOwnerDesc p : data) {\n+            Assert.assertEquals(\"a0\", p.getInputdata().get(\"task_in_a1\"));\n+            Assert.assertEquals(\"org.jbpm.test:test-module:1.0.0\", p.getDeploymentId());\n+        }\n+    }\n+\n+    @Test\n+    public void testQueryTaskByVariablesWithOwners() {\n+        Map<String, Object> variables = emptyMap();\n+        Map<String, Object> attributes = emptyMap();\n+        List<String> potOwners = Collections.singletonList(\"katy\");\n+        List<UserTaskInstanceWithPotOwnerDesc> data = advanceVariableDataService.queryUserTasksByVariables(attributes, variables, emptyMap(), potOwners, new QueryContext(0, 2));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1e57dd6f9a77d2e636949457815115ca83acc4dc"}, "originalPosition": 191}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ5NTYxNDk2OnYy", "diffSide": "RIGHT", "path": "jbpm-services/jbpm-kie-services/src/test/java/org/jbpm/kie/services/test/AdvanceRuntimeDataServiceImplTest.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMlQxNToxMzo0MVrOF_wILg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMlQxNToxMzo0MVrOF_wILg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjM5MzEzNA==", "bodyText": "Is \"deploymentId\" part of the requirements? I don't see it listed on the filters table.", "url": "https://github.com/kiegroup/jbpm/pull/1615#discussion_r402393134", "createdAt": "2020-04-02T15:13:41Z", "author": {"login": "afalhambra"}, "path": "jbpm-services/jbpm-kie-services/src/test/java/org/jbpm/kie/services/test/AdvanceRuntimeDataServiceImplTest.java", "diffHunk": "@@ -0,0 +1,219 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.jbpm.kie.services.test;\n+\n+import java.io.File;\n+import java.io.FileOutputStream;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.drools.compiler.kie.builder.impl.InternalKieModule;\n+import org.jbpm.kie.services.impl.KModuleDeploymentUnit;\n+import org.jbpm.kie.test.util.AbstractKieServicesBaseTest;\n+import org.jbpm.services.api.ProcessInstanceNotFoundException;\n+import org.jbpm.services.api.model.DeploymentUnit;\n+import org.jbpm.services.api.model.ProcessInstanceWithVarsDesc;\n+import org.jbpm.services.api.model.UserTaskInstanceWithPotOwnerDesc;\n+import org.junit.After;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.kie.api.KieServices;\n+import org.kie.api.builder.ReleaseId;\n+import org.kie.api.runtime.process.ProcessInstance;\n+import org.kie.internal.query.QueryContext;\n+import org.kie.scanner.KieMavenRepository;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static java.util.Collections.emptyList;\n+import static java.util.Collections.emptyMap;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertNull;\n+import static org.kie.scanner.KieMavenRepository.getKieMavenRepository;\n+\n+public class AdvanceRuntimeDataServiceImplTest extends AbstractKieServicesBaseTest {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(AdvanceRuntimeDataServiceImplTest.class);\n+\n+    private List<DeploymentUnit> units = new ArrayList<DeploymentUnit>();\n+    protected String correctUser = \"testUser\";\n+    protected String wrongUser = \"wrongUser\";\n+\n+    private List<Long> processIds;\n+    private KModuleDeploymentUnit deploymentUnit = null;\n+\n+    @Before\n+    public void prepare() {\n+\n+        configureServices();\n+        logger.debug(\"Preparing kjar\");\n+        KieServices ks = KieServices.Factory.get();\n+        ReleaseId releaseId = ks.newReleaseId(GROUP_ID, ARTIFACT_ID, VERSION);\n+        List<String> processes = new ArrayList<String>();\n+        processes.add(\"repo/processes/general/SingleHumanTaskWithVarsA.bpmn2\");\n+        processes.add(\"repo/processes/general/SingleHumanTaskWithVarsB.bpmn2\");\n+\n+        InternalKieModule kJar1 = createKieJar(ks, releaseId, processes);\n+        File pom = new File(\"target/kmodule\", \"pom.xml\");\n+        pom.getParentFile().mkdir();\n+        try (FileOutputStream fs = new FileOutputStream(pom);) {\n+            fs.write(getPom(releaseId).getBytes());\n+        } catch (Exception e) {\n+\n+        }\n+        KieMavenRepository repository = getKieMavenRepository();\n+        repository.deployArtifact(releaseId, kJar1, pom);\n+\n+        assertNotNull(deploymentService);\n+\n+        deploymentUnit = new KModuleDeploymentUnit(GROUP_ID, ARTIFACT_ID, VERSION);\n+\n+        deploymentService.deploy(deploymentUnit);\n+        units.add(deploymentUnit);\n+        assertNotNull(processService);\n+\n+        processIds = new ArrayList<>();\n+        for (int i = 0; i < 10; i++) {\n+            Map<String, Object> inputsA1 = new HashMap<>();\n+            inputsA1.put(\"var_a\", \"a\" + (i % 3));\n+            inputsA1.put(\"var_b\", (i % 3));\n+            processIds.add(processService.startProcess(deploymentUnit.getIdentifier(), \"test.test_A\", inputsA1));\n+        }\n+        for (int i = 0; i < 10; i++) {\n+            Map<String, Object> inputsB1 = new HashMap<>();\n+            inputsB1.put(\"var_a\", \"b\" + (i % 3));\n+            inputsB1.put(\"var_b\", (i % 3));\n+            processIds.add(processService.startProcess(deploymentUnit.getIdentifier(), \"test.test_B\", inputsB1));\n+        }\n+    }\n+\n+    @After\n+    public void cleanup() {\n+        for (Long processInstanceId : processIds) {\n+            try {\n+                // let's abort process instance to leave the system in clear state\n+                processService.abortProcessInstance(processInstanceId);\n+\n+                ProcessInstance pi = processService.getProcessInstance(processInstanceId);\n+                assertNull(pi);\n+            } catch (ProcessInstanceNotFoundException e) {\n+                // ignore it as it was already completed/aborted\n+            }\n+        }\n+        cleanupSingletonSessionId();\n+        if (units != null && !units.isEmpty()) {\n+            for (DeploymentUnit unit : units) {\n+                try {\n+                    deploymentService.undeploy(unit);\n+                } catch (Exception e) {\n+                    // do nothing in case of some failed tests to avoid next test to fail as well\n+                }\n+            }\n+            units.clear();\n+        }\n+        close();\n+    }\n+\n+    @Test\n+    public void testQueryProcessByVariables() {\n+        Map<String, Object> variables = Collections.<String, Object> singletonMap(\"var_a\", \"a1\");\n+        Map<String, Object> attributes = Collections.<String, Object> singletonMap(\"processId\", \"test.test_A\");\n+        List<ProcessInstanceWithVarsDesc> data = advanceVariableDataService.queryProcessByVariables(attributes, variables, new QueryContext());\n+        Assert.assertEquals(3, data.size());\n+        for (ProcessInstanceWithVarsDesc p : data) {\n+            Assert.assertEquals(\"a1\", p.getVariables().get(\"var_a\"));\n+            Assert.assertEquals(\"test.test_A\", p.getProcessId());\n+        }\n+    }\n+\n+    @Test\n+    public void testQueryProcessByVariablesWithPagination() {\n+        Map<String, Object> variables = Collections.<String, Object> singletonMap(\"var_a\", \"a1\");\n+        Map<String, Object> attributes = Collections.<String, Object> singletonMap(\"processId\", \"test.test_A\");\n+        List<ProcessInstanceWithVarsDesc> data = advanceVariableDataService.queryProcessByVariables(attributes, variables, new QueryContext(0, 2));\n+        Assert.assertEquals(2, data.size());\n+        for (ProcessInstanceWithVarsDesc p : data) {\n+            Assert.assertEquals(\"a1\", p.getVariables().get(\"var_a\"));\n+            Assert.assertEquals(\"test.test_A\", p.getProcessId());\n+        }\n+    }\n+\n+    @Test\n+    public void testQueryTaskByVariables() {\n+        Map<String, Object> variables = Collections.<String, Object> singletonMap(\"task_in_a1\", \"a0\");\n+        Map<String, Object> attributes = Collections.<String, Object> singletonMap(\"deploymentId\", \"org.jbpm.test:test-module:1.0.0\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1e57dd6f9a77d2e636949457815115ca83acc4dc"}, "originalPosition": 163}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ5NTY1ODc0OnYy", "diffSide": "RIGHT", "path": "jbpm-services/jbpm-kie-services/src/test/java/org/jbpm/kie/services/test/AdvanceRuntimeDataServiceImplTest.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMlQxNToyMzowN1rOF_wj9Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMlQxNToyMzowN1rOF_wj9Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjQwMDI0NQ==", "bodyText": "Shouldn't return any record that matches with one of the owners? If I set potOwners as \"katy\" and \"nobody\", I would expect to get all the records concerning to the potential owner for the task. In this case it would be all the tasks for \"katy\" - data.size()=10?", "url": "https://github.com/kiegroup/jbpm/pull/1615#discussion_r402400245", "createdAt": "2020-04-02T15:23:07Z", "author": {"login": "afalhambra"}, "path": "jbpm-services/jbpm-kie-services/src/test/java/org/jbpm/kie/services/test/AdvanceRuntimeDataServiceImplTest.java", "diffHunk": "@@ -0,0 +1,219 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.jbpm.kie.services.test;\n+\n+import java.io.File;\n+import java.io.FileOutputStream;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.drools.compiler.kie.builder.impl.InternalKieModule;\n+import org.jbpm.kie.services.impl.KModuleDeploymentUnit;\n+import org.jbpm.kie.test.util.AbstractKieServicesBaseTest;\n+import org.jbpm.services.api.ProcessInstanceNotFoundException;\n+import org.jbpm.services.api.model.DeploymentUnit;\n+import org.jbpm.services.api.model.ProcessInstanceWithVarsDesc;\n+import org.jbpm.services.api.model.UserTaskInstanceWithPotOwnerDesc;\n+import org.junit.After;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.kie.api.KieServices;\n+import org.kie.api.builder.ReleaseId;\n+import org.kie.api.runtime.process.ProcessInstance;\n+import org.kie.internal.query.QueryContext;\n+import org.kie.scanner.KieMavenRepository;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static java.util.Collections.emptyList;\n+import static java.util.Collections.emptyMap;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertNull;\n+import static org.kie.scanner.KieMavenRepository.getKieMavenRepository;\n+\n+public class AdvanceRuntimeDataServiceImplTest extends AbstractKieServicesBaseTest {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(AdvanceRuntimeDataServiceImplTest.class);\n+\n+    private List<DeploymentUnit> units = new ArrayList<DeploymentUnit>();\n+    protected String correctUser = \"testUser\";\n+    protected String wrongUser = \"wrongUser\";\n+\n+    private List<Long> processIds;\n+    private KModuleDeploymentUnit deploymentUnit = null;\n+\n+    @Before\n+    public void prepare() {\n+\n+        configureServices();\n+        logger.debug(\"Preparing kjar\");\n+        KieServices ks = KieServices.Factory.get();\n+        ReleaseId releaseId = ks.newReleaseId(GROUP_ID, ARTIFACT_ID, VERSION);\n+        List<String> processes = new ArrayList<String>();\n+        processes.add(\"repo/processes/general/SingleHumanTaskWithVarsA.bpmn2\");\n+        processes.add(\"repo/processes/general/SingleHumanTaskWithVarsB.bpmn2\");\n+\n+        InternalKieModule kJar1 = createKieJar(ks, releaseId, processes);\n+        File pom = new File(\"target/kmodule\", \"pom.xml\");\n+        pom.getParentFile().mkdir();\n+        try (FileOutputStream fs = new FileOutputStream(pom);) {\n+            fs.write(getPom(releaseId).getBytes());\n+        } catch (Exception e) {\n+\n+        }\n+        KieMavenRepository repository = getKieMavenRepository();\n+        repository.deployArtifact(releaseId, kJar1, pom);\n+\n+        assertNotNull(deploymentService);\n+\n+        deploymentUnit = new KModuleDeploymentUnit(GROUP_ID, ARTIFACT_ID, VERSION);\n+\n+        deploymentService.deploy(deploymentUnit);\n+        units.add(deploymentUnit);\n+        assertNotNull(processService);\n+\n+        processIds = new ArrayList<>();\n+        for (int i = 0; i < 10; i++) {\n+            Map<String, Object> inputsA1 = new HashMap<>();\n+            inputsA1.put(\"var_a\", \"a\" + (i % 3));\n+            inputsA1.put(\"var_b\", (i % 3));\n+            processIds.add(processService.startProcess(deploymentUnit.getIdentifier(), \"test.test_A\", inputsA1));\n+        }\n+        for (int i = 0; i < 10; i++) {\n+            Map<String, Object> inputsB1 = new HashMap<>();\n+            inputsB1.put(\"var_a\", \"b\" + (i % 3));\n+            inputsB1.put(\"var_b\", (i % 3));\n+            processIds.add(processService.startProcess(deploymentUnit.getIdentifier(), \"test.test_B\", inputsB1));\n+        }\n+    }\n+\n+    @After\n+    public void cleanup() {\n+        for (Long processInstanceId : processIds) {\n+            try {\n+                // let's abort process instance to leave the system in clear state\n+                processService.abortProcessInstance(processInstanceId);\n+\n+                ProcessInstance pi = processService.getProcessInstance(processInstanceId);\n+                assertNull(pi);\n+            } catch (ProcessInstanceNotFoundException e) {\n+                // ignore it as it was already completed/aborted\n+            }\n+        }\n+        cleanupSingletonSessionId();\n+        if (units != null && !units.isEmpty()) {\n+            for (DeploymentUnit unit : units) {\n+                try {\n+                    deploymentService.undeploy(unit);\n+                } catch (Exception e) {\n+                    // do nothing in case of some failed tests to avoid next test to fail as well\n+                }\n+            }\n+            units.clear();\n+        }\n+        close();\n+    }\n+\n+    @Test\n+    public void testQueryProcessByVariables() {\n+        Map<String, Object> variables = Collections.<String, Object> singletonMap(\"var_a\", \"a1\");\n+        Map<String, Object> attributes = Collections.<String, Object> singletonMap(\"processId\", \"test.test_A\");\n+        List<ProcessInstanceWithVarsDesc> data = advanceVariableDataService.queryProcessByVariables(attributes, variables, new QueryContext());\n+        Assert.assertEquals(3, data.size());\n+        for (ProcessInstanceWithVarsDesc p : data) {\n+            Assert.assertEquals(\"a1\", p.getVariables().get(\"var_a\"));\n+            Assert.assertEquals(\"test.test_A\", p.getProcessId());\n+        }\n+    }\n+\n+    @Test\n+    public void testQueryProcessByVariablesWithPagination() {\n+        Map<String, Object> variables = Collections.<String, Object> singletonMap(\"var_a\", \"a1\");\n+        Map<String, Object> attributes = Collections.<String, Object> singletonMap(\"processId\", \"test.test_A\");\n+        List<ProcessInstanceWithVarsDesc> data = advanceVariableDataService.queryProcessByVariables(attributes, variables, new QueryContext(0, 2));\n+        Assert.assertEquals(2, data.size());\n+        for (ProcessInstanceWithVarsDesc p : data) {\n+            Assert.assertEquals(\"a1\", p.getVariables().get(\"var_a\"));\n+            Assert.assertEquals(\"test.test_A\", p.getProcessId());\n+        }\n+    }\n+\n+    @Test\n+    public void testQueryTaskByVariables() {\n+        Map<String, Object> variables = Collections.<String, Object> singletonMap(\"task_in_a1\", \"a0\");\n+        Map<String, Object> attributes = Collections.<String, Object> singletonMap(\"deploymentId\", \"org.jbpm.test:test-module:1.0.0\");\n+        List<String> potOwners = emptyList();\n+        List<UserTaskInstanceWithPotOwnerDesc> data = advanceVariableDataService.queryUserTasksByVariables(attributes, variables, emptyMap(), potOwners, new QueryContext());\n+        Assert.assertEquals(4, data.size());\n+        for (UserTaskInstanceWithPotOwnerDesc p : data) {\n+            Assert.assertEquals(\"a0\", p.getInputdata().get(\"task_in_a1\"));\n+            Assert.assertEquals(\"org.jbpm.test:test-module:1.0.0\", p.getDeploymentId());\n+        }\n+    }\n+\n+    @Test\n+    public void testQueryTaskByVariablesWithPagination() {\n+        Map<String, Object> variables = Collections.<String, Object> singletonMap(\"task_in_a1\", \"a0\");\n+        Map<String, Object> attributes = Collections.<String, Object> singletonMap(\"deploymentId\", \"org.jbpm.test:test-module:1.0.0\");\n+        List<String> potOwners = emptyList();\n+        List<UserTaskInstanceWithPotOwnerDesc> data = advanceVariableDataService.queryUserTasksByVariables(attributes, variables, emptyMap(), potOwners, new QueryContext(0, 2));\n+        Assert.assertEquals(2, data.size());\n+        for (UserTaskInstanceWithPotOwnerDesc p : data) {\n+            Assert.assertEquals(\"a0\", p.getInputdata().get(\"task_in_a1\"));\n+            Assert.assertEquals(\"org.jbpm.test:test-module:1.0.0\", p.getDeploymentId());\n+        }\n+    }\n+\n+    @Test\n+    public void testQueryTaskByVariablesWithOwners() {\n+        Map<String, Object> variables = emptyMap();\n+        Map<String, Object> attributes = emptyMap();\n+        List<String> potOwners = Collections.singletonList(\"katy\");\n+        List<UserTaskInstanceWithPotOwnerDesc> data = advanceVariableDataService.queryUserTasksByVariables(attributes, variables, emptyMap(), potOwners, new QueryContext(0, 2));\n+        Assert.assertEquals(2, data.size());\n+        for (UserTaskInstanceWithPotOwnerDesc p : data) {\n+            Assert.assertTrue(p.getPotentialOwners().contains(\"katy\"));\n+        }\n+    }\n+\n+    @Test\n+    public void testQueryTaskByVariablesWithAllOwners() {\n+        Map<String, Object> variables = emptyMap();\n+        Map<String, Object> attributes = emptyMap();\n+        List<String> potOwners = Arrays.asList(\"katy\", \"nobody\");\n+        List<UserTaskInstanceWithPotOwnerDesc> data = advanceVariableDataService.queryUserTasksByVariables(attributes, variables, emptyMap(), potOwners, new QueryContext(0, 2));\n+        Assert.assertEquals(0, data.size());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1e57dd6f9a77d2e636949457815115ca83acc4dc"}, "originalPosition": 204}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ5NTY2NDYxOnYy", "diffSide": "RIGHT", "path": "jbpm-services/jbpm-kie-services/src/test/java/org/jbpm/kie/services/test/AdvanceRuntimeDataServiceImplTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMlQxNToyNDoyMVrOF_wntA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMlQxNToyNDoyMVrOF_wntA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjQwMTIwNA==", "bodyText": "I would probably not use pagination to avoid any confusion in the test. I would create a separate test for pagination.", "url": "https://github.com/kiegroup/jbpm/pull/1615#discussion_r402401204", "createdAt": "2020-04-02T15:24:21Z", "author": {"login": "afalhambra"}, "path": "jbpm-services/jbpm-kie-services/src/test/java/org/jbpm/kie/services/test/AdvanceRuntimeDataServiceImplTest.java", "diffHunk": "@@ -0,0 +1,219 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.jbpm.kie.services.test;\n+\n+import java.io.File;\n+import java.io.FileOutputStream;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.drools.compiler.kie.builder.impl.InternalKieModule;\n+import org.jbpm.kie.services.impl.KModuleDeploymentUnit;\n+import org.jbpm.kie.test.util.AbstractKieServicesBaseTest;\n+import org.jbpm.services.api.ProcessInstanceNotFoundException;\n+import org.jbpm.services.api.model.DeploymentUnit;\n+import org.jbpm.services.api.model.ProcessInstanceWithVarsDesc;\n+import org.jbpm.services.api.model.UserTaskInstanceWithPotOwnerDesc;\n+import org.junit.After;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.kie.api.KieServices;\n+import org.kie.api.builder.ReleaseId;\n+import org.kie.api.runtime.process.ProcessInstance;\n+import org.kie.internal.query.QueryContext;\n+import org.kie.scanner.KieMavenRepository;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static java.util.Collections.emptyList;\n+import static java.util.Collections.emptyMap;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertNull;\n+import static org.kie.scanner.KieMavenRepository.getKieMavenRepository;\n+\n+public class AdvanceRuntimeDataServiceImplTest extends AbstractKieServicesBaseTest {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(AdvanceRuntimeDataServiceImplTest.class);\n+\n+    private List<DeploymentUnit> units = new ArrayList<DeploymentUnit>();\n+    protected String correctUser = \"testUser\";\n+    protected String wrongUser = \"wrongUser\";\n+\n+    private List<Long> processIds;\n+    private KModuleDeploymentUnit deploymentUnit = null;\n+\n+    @Before\n+    public void prepare() {\n+\n+        configureServices();\n+        logger.debug(\"Preparing kjar\");\n+        KieServices ks = KieServices.Factory.get();\n+        ReleaseId releaseId = ks.newReleaseId(GROUP_ID, ARTIFACT_ID, VERSION);\n+        List<String> processes = new ArrayList<String>();\n+        processes.add(\"repo/processes/general/SingleHumanTaskWithVarsA.bpmn2\");\n+        processes.add(\"repo/processes/general/SingleHumanTaskWithVarsB.bpmn2\");\n+\n+        InternalKieModule kJar1 = createKieJar(ks, releaseId, processes);\n+        File pom = new File(\"target/kmodule\", \"pom.xml\");\n+        pom.getParentFile().mkdir();\n+        try (FileOutputStream fs = new FileOutputStream(pom);) {\n+            fs.write(getPom(releaseId).getBytes());\n+        } catch (Exception e) {\n+\n+        }\n+        KieMavenRepository repository = getKieMavenRepository();\n+        repository.deployArtifact(releaseId, kJar1, pom);\n+\n+        assertNotNull(deploymentService);\n+\n+        deploymentUnit = new KModuleDeploymentUnit(GROUP_ID, ARTIFACT_ID, VERSION);\n+\n+        deploymentService.deploy(deploymentUnit);\n+        units.add(deploymentUnit);\n+        assertNotNull(processService);\n+\n+        processIds = new ArrayList<>();\n+        for (int i = 0; i < 10; i++) {\n+            Map<String, Object> inputsA1 = new HashMap<>();\n+            inputsA1.put(\"var_a\", \"a\" + (i % 3));\n+            inputsA1.put(\"var_b\", (i % 3));\n+            processIds.add(processService.startProcess(deploymentUnit.getIdentifier(), \"test.test_A\", inputsA1));\n+        }\n+        for (int i = 0; i < 10; i++) {\n+            Map<String, Object> inputsB1 = new HashMap<>();\n+            inputsB1.put(\"var_a\", \"b\" + (i % 3));\n+            inputsB1.put(\"var_b\", (i % 3));\n+            processIds.add(processService.startProcess(deploymentUnit.getIdentifier(), \"test.test_B\", inputsB1));\n+        }\n+    }\n+\n+    @After\n+    public void cleanup() {\n+        for (Long processInstanceId : processIds) {\n+            try {\n+                // let's abort process instance to leave the system in clear state\n+                processService.abortProcessInstance(processInstanceId);\n+\n+                ProcessInstance pi = processService.getProcessInstance(processInstanceId);\n+                assertNull(pi);\n+            } catch (ProcessInstanceNotFoundException e) {\n+                // ignore it as it was already completed/aborted\n+            }\n+        }\n+        cleanupSingletonSessionId();\n+        if (units != null && !units.isEmpty()) {\n+            for (DeploymentUnit unit : units) {\n+                try {\n+                    deploymentService.undeploy(unit);\n+                } catch (Exception e) {\n+                    // do nothing in case of some failed tests to avoid next test to fail as well\n+                }\n+            }\n+            units.clear();\n+        }\n+        close();\n+    }\n+\n+    @Test\n+    public void testQueryProcessByVariables() {\n+        Map<String, Object> variables = Collections.<String, Object> singletonMap(\"var_a\", \"a1\");\n+        Map<String, Object> attributes = Collections.<String, Object> singletonMap(\"processId\", \"test.test_A\");\n+        List<ProcessInstanceWithVarsDesc> data = advanceVariableDataService.queryProcessByVariables(attributes, variables, new QueryContext());\n+        Assert.assertEquals(3, data.size());\n+        for (ProcessInstanceWithVarsDesc p : data) {\n+            Assert.assertEquals(\"a1\", p.getVariables().get(\"var_a\"));\n+            Assert.assertEquals(\"test.test_A\", p.getProcessId());\n+        }\n+    }\n+\n+    @Test\n+    public void testQueryProcessByVariablesWithPagination() {\n+        Map<String, Object> variables = Collections.<String, Object> singletonMap(\"var_a\", \"a1\");\n+        Map<String, Object> attributes = Collections.<String, Object> singletonMap(\"processId\", \"test.test_A\");\n+        List<ProcessInstanceWithVarsDesc> data = advanceVariableDataService.queryProcessByVariables(attributes, variables, new QueryContext(0, 2));\n+        Assert.assertEquals(2, data.size());\n+        for (ProcessInstanceWithVarsDesc p : data) {\n+            Assert.assertEquals(\"a1\", p.getVariables().get(\"var_a\"));\n+            Assert.assertEquals(\"test.test_A\", p.getProcessId());\n+        }\n+    }\n+\n+    @Test\n+    public void testQueryTaskByVariables() {\n+        Map<String, Object> variables = Collections.<String, Object> singletonMap(\"task_in_a1\", \"a0\");\n+        Map<String, Object> attributes = Collections.<String, Object> singletonMap(\"deploymentId\", \"org.jbpm.test:test-module:1.0.0\");\n+        List<String> potOwners = emptyList();\n+        List<UserTaskInstanceWithPotOwnerDesc> data = advanceVariableDataService.queryUserTasksByVariables(attributes, variables, emptyMap(), potOwners, new QueryContext());\n+        Assert.assertEquals(4, data.size());\n+        for (UserTaskInstanceWithPotOwnerDesc p : data) {\n+            Assert.assertEquals(\"a0\", p.getInputdata().get(\"task_in_a1\"));\n+            Assert.assertEquals(\"org.jbpm.test:test-module:1.0.0\", p.getDeploymentId());\n+        }\n+    }\n+\n+    @Test\n+    public void testQueryTaskByVariablesWithPagination() {\n+        Map<String, Object> variables = Collections.<String, Object> singletonMap(\"task_in_a1\", \"a0\");\n+        Map<String, Object> attributes = Collections.<String, Object> singletonMap(\"deploymentId\", \"org.jbpm.test:test-module:1.0.0\");\n+        List<String> potOwners = emptyList();\n+        List<UserTaskInstanceWithPotOwnerDesc> data = advanceVariableDataService.queryUserTasksByVariables(attributes, variables, emptyMap(), potOwners, new QueryContext(0, 2));\n+        Assert.assertEquals(2, data.size());\n+        for (UserTaskInstanceWithPotOwnerDesc p : data) {\n+            Assert.assertEquals(\"a0\", p.getInputdata().get(\"task_in_a1\"));\n+            Assert.assertEquals(\"org.jbpm.test:test-module:1.0.0\", p.getDeploymentId());\n+        }\n+    }\n+\n+    @Test\n+    public void testQueryTaskByVariablesWithOwners() {\n+        Map<String, Object> variables = emptyMap();\n+        Map<String, Object> attributes = emptyMap();\n+        List<String> potOwners = Collections.singletonList(\"katy\");\n+        List<UserTaskInstanceWithPotOwnerDesc> data = advanceVariableDataService.queryUserTasksByVariables(attributes, variables, emptyMap(), potOwners, new QueryContext(0, 2));\n+        Assert.assertEquals(2, data.size());\n+        for (UserTaskInstanceWithPotOwnerDesc p : data) {\n+            Assert.assertTrue(p.getPotentialOwners().contains(\"katy\"));\n+        }\n+    }\n+\n+    @Test\n+    public void testQueryTaskByVariablesWithAllOwners() {\n+        Map<String, Object> variables = emptyMap();\n+        Map<String, Object> attributes = emptyMap();\n+        List<String> potOwners = Arrays.asList(\"katy\", \"nobody\");\n+        List<UserTaskInstanceWithPotOwnerDesc> data = advanceVariableDataService.queryUserTasksByVariables(attributes, variables, emptyMap(), potOwners, new QueryContext(0, 2));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1e57dd6f9a77d2e636949457815115ca83acc4dc"}, "originalPosition": 203}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ5NTc1OTkyOnYy", "diffSide": "RIGHT", "path": "jbpm-services/jbpm-kie-services/src/test/java/org/jbpm/kie/services/test/AdvanceRuntimeDataServiceImplTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMlQxNTo0NToyOFrOF_xkZg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNlQxNjo1OToyN1rOGBhPZw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjQxNjc0Mg==", "bodyText": "Number of instances matching search criteria ( processVariable = \"var_a\", \"a1\" ) are 3, or am I missing something?.\nIf I change it to the following below, I get data size = 3 (which I presume it is correct):\nMap<String, Object> variables = Collections.<String, Object> singletonMap(\"task_in_a1\", \"a1\");", "url": "https://github.com/kiegroup/jbpm/pull/1615#discussion_r402416742", "createdAt": "2020-04-02T15:45:28Z", "author": {"login": "afalhambra"}, "path": "jbpm-services/jbpm-kie-services/src/test/java/org/jbpm/kie/services/test/AdvanceRuntimeDataServiceImplTest.java", "diffHunk": "@@ -0,0 +1,219 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.jbpm.kie.services.test;\n+\n+import java.io.File;\n+import java.io.FileOutputStream;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.drools.compiler.kie.builder.impl.InternalKieModule;\n+import org.jbpm.kie.services.impl.KModuleDeploymentUnit;\n+import org.jbpm.kie.test.util.AbstractKieServicesBaseTest;\n+import org.jbpm.services.api.ProcessInstanceNotFoundException;\n+import org.jbpm.services.api.model.DeploymentUnit;\n+import org.jbpm.services.api.model.ProcessInstanceWithVarsDesc;\n+import org.jbpm.services.api.model.UserTaskInstanceWithPotOwnerDesc;\n+import org.junit.After;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.kie.api.KieServices;\n+import org.kie.api.builder.ReleaseId;\n+import org.kie.api.runtime.process.ProcessInstance;\n+import org.kie.internal.query.QueryContext;\n+import org.kie.scanner.KieMavenRepository;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static java.util.Collections.emptyList;\n+import static java.util.Collections.emptyMap;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertNull;\n+import static org.kie.scanner.KieMavenRepository.getKieMavenRepository;\n+\n+public class AdvanceRuntimeDataServiceImplTest extends AbstractKieServicesBaseTest {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(AdvanceRuntimeDataServiceImplTest.class);\n+\n+    private List<DeploymentUnit> units = new ArrayList<DeploymentUnit>();\n+    protected String correctUser = \"testUser\";\n+    protected String wrongUser = \"wrongUser\";\n+\n+    private List<Long> processIds;\n+    private KModuleDeploymentUnit deploymentUnit = null;\n+\n+    @Before\n+    public void prepare() {\n+\n+        configureServices();\n+        logger.debug(\"Preparing kjar\");\n+        KieServices ks = KieServices.Factory.get();\n+        ReleaseId releaseId = ks.newReleaseId(GROUP_ID, ARTIFACT_ID, VERSION);\n+        List<String> processes = new ArrayList<String>();\n+        processes.add(\"repo/processes/general/SingleHumanTaskWithVarsA.bpmn2\");\n+        processes.add(\"repo/processes/general/SingleHumanTaskWithVarsB.bpmn2\");\n+\n+        InternalKieModule kJar1 = createKieJar(ks, releaseId, processes);\n+        File pom = new File(\"target/kmodule\", \"pom.xml\");\n+        pom.getParentFile().mkdir();\n+        try (FileOutputStream fs = new FileOutputStream(pom);) {\n+            fs.write(getPom(releaseId).getBytes());\n+        } catch (Exception e) {\n+\n+        }\n+        KieMavenRepository repository = getKieMavenRepository();\n+        repository.deployArtifact(releaseId, kJar1, pom);\n+\n+        assertNotNull(deploymentService);\n+\n+        deploymentUnit = new KModuleDeploymentUnit(GROUP_ID, ARTIFACT_ID, VERSION);\n+\n+        deploymentService.deploy(deploymentUnit);\n+        units.add(deploymentUnit);\n+        assertNotNull(processService);\n+\n+        processIds = new ArrayList<>();\n+        for (int i = 0; i < 10; i++) {\n+            Map<String, Object> inputsA1 = new HashMap<>();\n+            inputsA1.put(\"var_a\", \"a\" + (i % 3));\n+            inputsA1.put(\"var_b\", (i % 3));\n+            processIds.add(processService.startProcess(deploymentUnit.getIdentifier(), \"test.test_A\", inputsA1));\n+        }\n+        for (int i = 0; i < 10; i++) {\n+            Map<String, Object> inputsB1 = new HashMap<>();\n+            inputsB1.put(\"var_a\", \"b\" + (i % 3));\n+            inputsB1.put(\"var_b\", (i % 3));\n+            processIds.add(processService.startProcess(deploymentUnit.getIdentifier(), \"test.test_B\", inputsB1));\n+        }\n+    }\n+\n+    @After\n+    public void cleanup() {\n+        for (Long processInstanceId : processIds) {\n+            try {\n+                // let's abort process instance to leave the system in clear state\n+                processService.abortProcessInstance(processInstanceId);\n+\n+                ProcessInstance pi = processService.getProcessInstance(processInstanceId);\n+                assertNull(pi);\n+            } catch (ProcessInstanceNotFoundException e) {\n+                // ignore it as it was already completed/aborted\n+            }\n+        }\n+        cleanupSingletonSessionId();\n+        if (units != null && !units.isEmpty()) {\n+            for (DeploymentUnit unit : units) {\n+                try {\n+                    deploymentService.undeploy(unit);\n+                } catch (Exception e) {\n+                    // do nothing in case of some failed tests to avoid next test to fail as well\n+                }\n+            }\n+            units.clear();\n+        }\n+        close();\n+    }\n+\n+    @Test\n+    public void testQueryProcessByVariables() {\n+        Map<String, Object> variables = Collections.<String, Object> singletonMap(\"var_a\", \"a1\");\n+        Map<String, Object> attributes = Collections.<String, Object> singletonMap(\"processId\", \"test.test_A\");\n+        List<ProcessInstanceWithVarsDesc> data = advanceVariableDataService.queryProcessByVariables(attributes, variables, new QueryContext());\n+        Assert.assertEquals(3, data.size());\n+        for (ProcessInstanceWithVarsDesc p : data) {\n+            Assert.assertEquals(\"a1\", p.getVariables().get(\"var_a\"));\n+            Assert.assertEquals(\"test.test_A\", p.getProcessId());\n+        }\n+    }\n+\n+    @Test\n+    public void testQueryProcessByVariablesWithPagination() {\n+        Map<String, Object> variables = Collections.<String, Object> singletonMap(\"var_a\", \"a1\");\n+        Map<String, Object> attributes = Collections.<String, Object> singletonMap(\"processId\", \"test.test_A\");\n+        List<ProcessInstanceWithVarsDesc> data = advanceVariableDataService.queryProcessByVariables(attributes, variables, new QueryContext(0, 2));\n+        Assert.assertEquals(2, data.size());\n+        for (ProcessInstanceWithVarsDesc p : data) {\n+            Assert.assertEquals(\"a1\", p.getVariables().get(\"var_a\"));\n+            Assert.assertEquals(\"test.test_A\", p.getProcessId());\n+        }\n+    }\n+\n+    @Test\n+    public void testQueryTaskByVariables() {\n+        Map<String, Object> variables = Collections.<String, Object> singletonMap(\"task_in_a1\", \"a0\");\n+        Map<String, Object> attributes = Collections.<String, Object> singletonMap(\"deploymentId\", \"org.jbpm.test:test-module:1.0.0\");\n+        List<String> potOwners = emptyList();\n+        List<UserTaskInstanceWithPotOwnerDesc> data = advanceVariableDataService.queryUserTasksByVariables(attributes, variables, emptyMap(), potOwners, new QueryContext());\n+        Assert.assertEquals(4, data.size());\n+        for (UserTaskInstanceWithPotOwnerDesc p : data) {\n+            Assert.assertEquals(\"a0\", p.getInputdata().get(\"task_in_a1\"));\n+            Assert.assertEquals(\"org.jbpm.test:test-module:1.0.0\", p.getDeploymentId());\n+        }\n+    }\n+\n+    @Test\n+    public void testQueryTaskByVariablesWithPagination() {\n+        Map<String, Object> variables = Collections.<String, Object> singletonMap(\"task_in_a1\", \"a0\");\n+        Map<String, Object> attributes = Collections.<String, Object> singletonMap(\"deploymentId\", \"org.jbpm.test:test-module:1.0.0\");\n+        List<String> potOwners = emptyList();\n+        List<UserTaskInstanceWithPotOwnerDesc> data = advanceVariableDataService.queryUserTasksByVariables(attributes, variables, emptyMap(), potOwners, new QueryContext(0, 2));\n+        Assert.assertEquals(2, data.size());\n+        for (UserTaskInstanceWithPotOwnerDesc p : data) {\n+            Assert.assertEquals(\"a0\", p.getInputdata().get(\"task_in_a1\"));\n+            Assert.assertEquals(\"org.jbpm.test:test-module:1.0.0\", p.getDeploymentId());\n+        }\n+    }\n+\n+    @Test\n+    public void testQueryTaskByVariablesWithOwners() {\n+        Map<String, Object> variables = emptyMap();\n+        Map<String, Object> attributes = emptyMap();\n+        List<String> potOwners = Collections.singletonList(\"katy\");\n+        List<UserTaskInstanceWithPotOwnerDesc> data = advanceVariableDataService.queryUserTasksByVariables(attributes, variables, emptyMap(), potOwners, new QueryContext(0, 2));\n+        Assert.assertEquals(2, data.size());\n+        for (UserTaskInstanceWithPotOwnerDesc p : data) {\n+            Assert.assertTrue(p.getPotentialOwners().contains(\"katy\"));\n+        }\n+    }\n+\n+    @Test\n+    public void testQueryTaskByVariablesWithAllOwners() {\n+        Map<String, Object> variables = emptyMap();\n+        Map<String, Object> attributes = emptyMap();\n+        List<String> potOwners = Arrays.asList(\"katy\", \"nobody\");\n+        List<UserTaskInstanceWithPotOwnerDesc> data = advanceVariableDataService.queryUserTasksByVariables(attributes, variables, emptyMap(), potOwners, new QueryContext(0, 2));\n+        Assert.assertEquals(0, data.size());\n+\n+    }\n+\n+    @Test\n+    public void testQueryTaskByVariablesWithByProcessVar() {\n+        Map<String, Object> variables = emptyMap();\n+        Map<String, Object> attributes = emptyMap();\n+        Map<String, Object> processVariables = Collections.singletonMap(\"var_a\", \"a1\");\n+        List<String> potOwners = Collections.emptyList();\n+        List<UserTaskInstanceWithPotOwnerDesc> data = advanceVariableDataService.queryUserTasksByVariables(attributes, variables, processVariables, potOwners, new QueryContext(0, 2));\n+        Assert.assertEquals(2, data.size());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1e57dd6f9a77d2e636949457815115ca83acc4dc"}, "originalPosition": 215}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDI0NjM3NQ==", "bodyText": "pagination... only two returned.", "url": "https://github.com/kiegroup/jbpm/pull/1615#discussion_r404246375", "createdAt": "2020-04-06T16:59:27Z", "author": {"login": "elguardian"}, "path": "jbpm-services/jbpm-kie-services/src/test/java/org/jbpm/kie/services/test/AdvanceRuntimeDataServiceImplTest.java", "diffHunk": "@@ -0,0 +1,219 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.jbpm.kie.services.test;\n+\n+import java.io.File;\n+import java.io.FileOutputStream;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.drools.compiler.kie.builder.impl.InternalKieModule;\n+import org.jbpm.kie.services.impl.KModuleDeploymentUnit;\n+import org.jbpm.kie.test.util.AbstractKieServicesBaseTest;\n+import org.jbpm.services.api.ProcessInstanceNotFoundException;\n+import org.jbpm.services.api.model.DeploymentUnit;\n+import org.jbpm.services.api.model.ProcessInstanceWithVarsDesc;\n+import org.jbpm.services.api.model.UserTaskInstanceWithPotOwnerDesc;\n+import org.junit.After;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.kie.api.KieServices;\n+import org.kie.api.builder.ReleaseId;\n+import org.kie.api.runtime.process.ProcessInstance;\n+import org.kie.internal.query.QueryContext;\n+import org.kie.scanner.KieMavenRepository;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static java.util.Collections.emptyList;\n+import static java.util.Collections.emptyMap;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertNull;\n+import static org.kie.scanner.KieMavenRepository.getKieMavenRepository;\n+\n+public class AdvanceRuntimeDataServiceImplTest extends AbstractKieServicesBaseTest {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(AdvanceRuntimeDataServiceImplTest.class);\n+\n+    private List<DeploymentUnit> units = new ArrayList<DeploymentUnit>();\n+    protected String correctUser = \"testUser\";\n+    protected String wrongUser = \"wrongUser\";\n+\n+    private List<Long> processIds;\n+    private KModuleDeploymentUnit deploymentUnit = null;\n+\n+    @Before\n+    public void prepare() {\n+\n+        configureServices();\n+        logger.debug(\"Preparing kjar\");\n+        KieServices ks = KieServices.Factory.get();\n+        ReleaseId releaseId = ks.newReleaseId(GROUP_ID, ARTIFACT_ID, VERSION);\n+        List<String> processes = new ArrayList<String>();\n+        processes.add(\"repo/processes/general/SingleHumanTaskWithVarsA.bpmn2\");\n+        processes.add(\"repo/processes/general/SingleHumanTaskWithVarsB.bpmn2\");\n+\n+        InternalKieModule kJar1 = createKieJar(ks, releaseId, processes);\n+        File pom = new File(\"target/kmodule\", \"pom.xml\");\n+        pom.getParentFile().mkdir();\n+        try (FileOutputStream fs = new FileOutputStream(pom);) {\n+            fs.write(getPom(releaseId).getBytes());\n+        } catch (Exception e) {\n+\n+        }\n+        KieMavenRepository repository = getKieMavenRepository();\n+        repository.deployArtifact(releaseId, kJar1, pom);\n+\n+        assertNotNull(deploymentService);\n+\n+        deploymentUnit = new KModuleDeploymentUnit(GROUP_ID, ARTIFACT_ID, VERSION);\n+\n+        deploymentService.deploy(deploymentUnit);\n+        units.add(deploymentUnit);\n+        assertNotNull(processService);\n+\n+        processIds = new ArrayList<>();\n+        for (int i = 0; i < 10; i++) {\n+            Map<String, Object> inputsA1 = new HashMap<>();\n+            inputsA1.put(\"var_a\", \"a\" + (i % 3));\n+            inputsA1.put(\"var_b\", (i % 3));\n+            processIds.add(processService.startProcess(deploymentUnit.getIdentifier(), \"test.test_A\", inputsA1));\n+        }\n+        for (int i = 0; i < 10; i++) {\n+            Map<String, Object> inputsB1 = new HashMap<>();\n+            inputsB1.put(\"var_a\", \"b\" + (i % 3));\n+            inputsB1.put(\"var_b\", (i % 3));\n+            processIds.add(processService.startProcess(deploymentUnit.getIdentifier(), \"test.test_B\", inputsB1));\n+        }\n+    }\n+\n+    @After\n+    public void cleanup() {\n+        for (Long processInstanceId : processIds) {\n+            try {\n+                // let's abort process instance to leave the system in clear state\n+                processService.abortProcessInstance(processInstanceId);\n+\n+                ProcessInstance pi = processService.getProcessInstance(processInstanceId);\n+                assertNull(pi);\n+            } catch (ProcessInstanceNotFoundException e) {\n+                // ignore it as it was already completed/aborted\n+            }\n+        }\n+        cleanupSingletonSessionId();\n+        if (units != null && !units.isEmpty()) {\n+            for (DeploymentUnit unit : units) {\n+                try {\n+                    deploymentService.undeploy(unit);\n+                } catch (Exception e) {\n+                    // do nothing in case of some failed tests to avoid next test to fail as well\n+                }\n+            }\n+            units.clear();\n+        }\n+        close();\n+    }\n+\n+    @Test\n+    public void testQueryProcessByVariables() {\n+        Map<String, Object> variables = Collections.<String, Object> singletonMap(\"var_a\", \"a1\");\n+        Map<String, Object> attributes = Collections.<String, Object> singletonMap(\"processId\", \"test.test_A\");\n+        List<ProcessInstanceWithVarsDesc> data = advanceVariableDataService.queryProcessByVariables(attributes, variables, new QueryContext());\n+        Assert.assertEquals(3, data.size());\n+        for (ProcessInstanceWithVarsDesc p : data) {\n+            Assert.assertEquals(\"a1\", p.getVariables().get(\"var_a\"));\n+            Assert.assertEquals(\"test.test_A\", p.getProcessId());\n+        }\n+    }\n+\n+    @Test\n+    public void testQueryProcessByVariablesWithPagination() {\n+        Map<String, Object> variables = Collections.<String, Object> singletonMap(\"var_a\", \"a1\");\n+        Map<String, Object> attributes = Collections.<String, Object> singletonMap(\"processId\", \"test.test_A\");\n+        List<ProcessInstanceWithVarsDesc> data = advanceVariableDataService.queryProcessByVariables(attributes, variables, new QueryContext(0, 2));\n+        Assert.assertEquals(2, data.size());\n+        for (ProcessInstanceWithVarsDesc p : data) {\n+            Assert.assertEquals(\"a1\", p.getVariables().get(\"var_a\"));\n+            Assert.assertEquals(\"test.test_A\", p.getProcessId());\n+        }\n+    }\n+\n+    @Test\n+    public void testQueryTaskByVariables() {\n+        Map<String, Object> variables = Collections.<String, Object> singletonMap(\"task_in_a1\", \"a0\");\n+        Map<String, Object> attributes = Collections.<String, Object> singletonMap(\"deploymentId\", \"org.jbpm.test:test-module:1.0.0\");\n+        List<String> potOwners = emptyList();\n+        List<UserTaskInstanceWithPotOwnerDesc> data = advanceVariableDataService.queryUserTasksByVariables(attributes, variables, emptyMap(), potOwners, new QueryContext());\n+        Assert.assertEquals(4, data.size());\n+        for (UserTaskInstanceWithPotOwnerDesc p : data) {\n+            Assert.assertEquals(\"a0\", p.getInputdata().get(\"task_in_a1\"));\n+            Assert.assertEquals(\"org.jbpm.test:test-module:1.0.0\", p.getDeploymentId());\n+        }\n+    }\n+\n+    @Test\n+    public void testQueryTaskByVariablesWithPagination() {\n+        Map<String, Object> variables = Collections.<String, Object> singletonMap(\"task_in_a1\", \"a0\");\n+        Map<String, Object> attributes = Collections.<String, Object> singletonMap(\"deploymentId\", \"org.jbpm.test:test-module:1.0.0\");\n+        List<String> potOwners = emptyList();\n+        List<UserTaskInstanceWithPotOwnerDesc> data = advanceVariableDataService.queryUserTasksByVariables(attributes, variables, emptyMap(), potOwners, new QueryContext(0, 2));\n+        Assert.assertEquals(2, data.size());\n+        for (UserTaskInstanceWithPotOwnerDesc p : data) {\n+            Assert.assertEquals(\"a0\", p.getInputdata().get(\"task_in_a1\"));\n+            Assert.assertEquals(\"org.jbpm.test:test-module:1.0.0\", p.getDeploymentId());\n+        }\n+    }\n+\n+    @Test\n+    public void testQueryTaskByVariablesWithOwners() {\n+        Map<String, Object> variables = emptyMap();\n+        Map<String, Object> attributes = emptyMap();\n+        List<String> potOwners = Collections.singletonList(\"katy\");\n+        List<UserTaskInstanceWithPotOwnerDesc> data = advanceVariableDataService.queryUserTasksByVariables(attributes, variables, emptyMap(), potOwners, new QueryContext(0, 2));\n+        Assert.assertEquals(2, data.size());\n+        for (UserTaskInstanceWithPotOwnerDesc p : data) {\n+            Assert.assertTrue(p.getPotentialOwners().contains(\"katy\"));\n+        }\n+    }\n+\n+    @Test\n+    public void testQueryTaskByVariablesWithAllOwners() {\n+        Map<String, Object> variables = emptyMap();\n+        Map<String, Object> attributes = emptyMap();\n+        List<String> potOwners = Arrays.asList(\"katy\", \"nobody\");\n+        List<UserTaskInstanceWithPotOwnerDesc> data = advanceVariableDataService.queryUserTasksByVariables(attributes, variables, emptyMap(), potOwners, new QueryContext(0, 2));\n+        Assert.assertEquals(0, data.size());\n+\n+    }\n+\n+    @Test\n+    public void testQueryTaskByVariablesWithByProcessVar() {\n+        Map<String, Object> variables = emptyMap();\n+        Map<String, Object> attributes = emptyMap();\n+        Map<String, Object> processVariables = Collections.singletonMap(\"var_a\", \"a1\");\n+        List<String> potOwners = Collections.emptyList();\n+        List<UserTaskInstanceWithPotOwnerDesc> data = advanceVariableDataService.queryUserTasksByVariables(attributes, variables, processVariables, potOwners, new QueryContext(0, 2));\n+        Assert.assertEquals(2, data.size());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjQxNjc0Mg=="}, "originalCommit": {"oid": "1e57dd6f9a77d2e636949457815115ca83acc4dc"}, "originalPosition": 215}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ5NTc4NDk5OnYy", "diffSide": "RIGHT", "path": "jbpm-services/jbpm-kie-services/src/test/java/org/jbpm/kie/services/test/AdvanceRuntimeDataServiceImplTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMlQxNTo1MToxOFrOF_x00A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wN1QwNzoxNTo1N1rOGB1_2w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjQyMDk0NA==", "bodyText": "I think it would be good to add at least one test for each of the different filters we agreed on the jira ticket.\nAnd I'm missing some tests regarding:\nActual task owner | \u2718 | \u2718 | \u2713 | \u2713 | Filters by task actual owner\nCorrelation key | \u2713 | \u2713 | \u2713 | \u2713 | Filters by correlation key name\nTask name | \u2718 | \u2718 | \u2713 | \u2713 | Filters by task name\nProcess definition id | \u2718 | \u2713 | \u2718 | \u2713 | Filters by process definition id\nMaybe a test containing a combination of them with some pagination would be nice too, but maybe it is too much, wdyt?", "url": "https://github.com/kiegroup/jbpm/pull/1615#discussion_r402420944", "createdAt": "2020-04-02T15:51:18Z", "author": {"login": "afalhambra"}, "path": "jbpm-services/jbpm-kie-services/src/test/java/org/jbpm/kie/services/test/AdvanceRuntimeDataServiceImplTest.java", "diffHunk": "@@ -0,0 +1,219 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.jbpm.kie.services.test;\n+\n+import java.io.File;\n+import java.io.FileOutputStream;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.drools.compiler.kie.builder.impl.InternalKieModule;\n+import org.jbpm.kie.services.impl.KModuleDeploymentUnit;\n+import org.jbpm.kie.test.util.AbstractKieServicesBaseTest;\n+import org.jbpm.services.api.ProcessInstanceNotFoundException;\n+import org.jbpm.services.api.model.DeploymentUnit;\n+import org.jbpm.services.api.model.ProcessInstanceWithVarsDesc;\n+import org.jbpm.services.api.model.UserTaskInstanceWithPotOwnerDesc;\n+import org.junit.After;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.kie.api.KieServices;\n+import org.kie.api.builder.ReleaseId;\n+import org.kie.api.runtime.process.ProcessInstance;\n+import org.kie.internal.query.QueryContext;\n+import org.kie.scanner.KieMavenRepository;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static java.util.Collections.emptyList;\n+import static java.util.Collections.emptyMap;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertNull;\n+import static org.kie.scanner.KieMavenRepository.getKieMavenRepository;\n+\n+public class AdvanceRuntimeDataServiceImplTest extends AbstractKieServicesBaseTest {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(AdvanceRuntimeDataServiceImplTest.class);\n+\n+    private List<DeploymentUnit> units = new ArrayList<DeploymentUnit>();\n+    protected String correctUser = \"testUser\";\n+    protected String wrongUser = \"wrongUser\";\n+\n+    private List<Long> processIds;\n+    private KModuleDeploymentUnit deploymentUnit = null;\n+\n+    @Before\n+    public void prepare() {\n+\n+        configureServices();\n+        logger.debug(\"Preparing kjar\");\n+        KieServices ks = KieServices.Factory.get();\n+        ReleaseId releaseId = ks.newReleaseId(GROUP_ID, ARTIFACT_ID, VERSION);\n+        List<String> processes = new ArrayList<String>();\n+        processes.add(\"repo/processes/general/SingleHumanTaskWithVarsA.bpmn2\");\n+        processes.add(\"repo/processes/general/SingleHumanTaskWithVarsB.bpmn2\");\n+\n+        InternalKieModule kJar1 = createKieJar(ks, releaseId, processes);\n+        File pom = new File(\"target/kmodule\", \"pom.xml\");\n+        pom.getParentFile().mkdir();\n+        try (FileOutputStream fs = new FileOutputStream(pom);) {\n+            fs.write(getPom(releaseId).getBytes());\n+        } catch (Exception e) {\n+\n+        }\n+        KieMavenRepository repository = getKieMavenRepository();\n+        repository.deployArtifact(releaseId, kJar1, pom);\n+\n+        assertNotNull(deploymentService);\n+\n+        deploymentUnit = new KModuleDeploymentUnit(GROUP_ID, ARTIFACT_ID, VERSION);\n+\n+        deploymentService.deploy(deploymentUnit);\n+        units.add(deploymentUnit);\n+        assertNotNull(processService);\n+\n+        processIds = new ArrayList<>();\n+        for (int i = 0; i < 10; i++) {\n+            Map<String, Object> inputsA1 = new HashMap<>();\n+            inputsA1.put(\"var_a\", \"a\" + (i % 3));\n+            inputsA1.put(\"var_b\", (i % 3));\n+            processIds.add(processService.startProcess(deploymentUnit.getIdentifier(), \"test.test_A\", inputsA1));\n+        }\n+        for (int i = 0; i < 10; i++) {\n+            Map<String, Object> inputsB1 = new HashMap<>();\n+            inputsB1.put(\"var_a\", \"b\" + (i % 3));\n+            inputsB1.put(\"var_b\", (i % 3));\n+            processIds.add(processService.startProcess(deploymentUnit.getIdentifier(), \"test.test_B\", inputsB1));\n+        }\n+    }\n+\n+    @After\n+    public void cleanup() {\n+        for (Long processInstanceId : processIds) {\n+            try {\n+                // let's abort process instance to leave the system in clear state\n+                processService.abortProcessInstance(processInstanceId);\n+\n+                ProcessInstance pi = processService.getProcessInstance(processInstanceId);\n+                assertNull(pi);\n+            } catch (ProcessInstanceNotFoundException e) {\n+                // ignore it as it was already completed/aborted\n+            }\n+        }\n+        cleanupSingletonSessionId();\n+        if (units != null && !units.isEmpty()) {\n+            for (DeploymentUnit unit : units) {\n+                try {\n+                    deploymentService.undeploy(unit);\n+                } catch (Exception e) {\n+                    // do nothing in case of some failed tests to avoid next test to fail as well\n+                }\n+            }\n+            units.clear();\n+        }\n+        close();\n+    }\n+\n+    @Test\n+    public void testQueryProcessByVariables() {\n+        Map<String, Object> variables = Collections.<String, Object> singletonMap(\"var_a\", \"a1\");\n+        Map<String, Object> attributes = Collections.<String, Object> singletonMap(\"processId\", \"test.test_A\");\n+        List<ProcessInstanceWithVarsDesc> data = advanceVariableDataService.queryProcessByVariables(attributes, variables, new QueryContext());\n+        Assert.assertEquals(3, data.size());\n+        for (ProcessInstanceWithVarsDesc p : data) {\n+            Assert.assertEquals(\"a1\", p.getVariables().get(\"var_a\"));\n+            Assert.assertEquals(\"test.test_A\", p.getProcessId());\n+        }\n+    }\n+\n+    @Test\n+    public void testQueryProcessByVariablesWithPagination() {\n+        Map<String, Object> variables = Collections.<String, Object> singletonMap(\"var_a\", \"a1\");\n+        Map<String, Object> attributes = Collections.<String, Object> singletonMap(\"processId\", \"test.test_A\");\n+        List<ProcessInstanceWithVarsDesc> data = advanceVariableDataService.queryProcessByVariables(attributes, variables, new QueryContext(0, 2));\n+        Assert.assertEquals(2, data.size());\n+        for (ProcessInstanceWithVarsDesc p : data) {\n+            Assert.assertEquals(\"a1\", p.getVariables().get(\"var_a\"));\n+            Assert.assertEquals(\"test.test_A\", p.getProcessId());\n+        }\n+    }\n+\n+    @Test\n+    public void testQueryTaskByVariables() {\n+        Map<String, Object> variables = Collections.<String, Object> singletonMap(\"task_in_a1\", \"a0\");\n+        Map<String, Object> attributes = Collections.<String, Object> singletonMap(\"deploymentId\", \"org.jbpm.test:test-module:1.0.0\");\n+        List<String> potOwners = emptyList();\n+        List<UserTaskInstanceWithPotOwnerDesc> data = advanceVariableDataService.queryUserTasksByVariables(attributes, variables, emptyMap(), potOwners, new QueryContext());\n+        Assert.assertEquals(4, data.size());\n+        for (UserTaskInstanceWithPotOwnerDesc p : data) {\n+            Assert.assertEquals(\"a0\", p.getInputdata().get(\"task_in_a1\"));\n+            Assert.assertEquals(\"org.jbpm.test:test-module:1.0.0\", p.getDeploymentId());\n+        }\n+    }\n+\n+    @Test\n+    public void testQueryTaskByVariablesWithPagination() {\n+        Map<String, Object> variables = Collections.<String, Object> singletonMap(\"task_in_a1\", \"a0\");\n+        Map<String, Object> attributes = Collections.<String, Object> singletonMap(\"deploymentId\", \"org.jbpm.test:test-module:1.0.0\");\n+        List<String> potOwners = emptyList();\n+        List<UserTaskInstanceWithPotOwnerDesc> data = advanceVariableDataService.queryUserTasksByVariables(attributes, variables, emptyMap(), potOwners, new QueryContext(0, 2));\n+        Assert.assertEquals(2, data.size());\n+        for (UserTaskInstanceWithPotOwnerDesc p : data) {\n+            Assert.assertEquals(\"a0\", p.getInputdata().get(\"task_in_a1\"));\n+            Assert.assertEquals(\"org.jbpm.test:test-module:1.0.0\", p.getDeploymentId());\n+        }\n+    }\n+\n+    @Test\n+    public void testQueryTaskByVariablesWithOwners() {\n+        Map<String, Object> variables = emptyMap();\n+        Map<String, Object> attributes = emptyMap();\n+        List<String> potOwners = Collections.singletonList(\"katy\");\n+        List<UserTaskInstanceWithPotOwnerDesc> data = advanceVariableDataService.queryUserTasksByVariables(attributes, variables, emptyMap(), potOwners, new QueryContext(0, 2));\n+        Assert.assertEquals(2, data.size());\n+        for (UserTaskInstanceWithPotOwnerDesc p : data) {\n+            Assert.assertTrue(p.getPotentialOwners().contains(\"katy\"));\n+        }\n+    }\n+\n+    @Test\n+    public void testQueryTaskByVariablesWithAllOwners() {\n+        Map<String, Object> variables = emptyMap();\n+        Map<String, Object> attributes = emptyMap();\n+        List<String> potOwners = Arrays.asList(\"katy\", \"nobody\");\n+        List<UserTaskInstanceWithPotOwnerDesc> data = advanceVariableDataService.queryUserTasksByVariables(attributes, variables, emptyMap(), potOwners, new QueryContext(0, 2));\n+        Assert.assertEquals(0, data.size());\n+\n+    }\n+\n+    @Test\n+    public void testQueryTaskByVariablesWithByProcessVar() {\n+        Map<String, Object> variables = emptyMap();\n+        Map<String, Object> attributes = emptyMap();\n+        Map<String, Object> processVariables = Collections.singletonMap(\"var_a\", \"a1\");\n+        List<String> potOwners = Collections.emptyList();\n+        List<UserTaskInstanceWithPotOwnerDesc> data = advanceVariableDataService.queryUserTasksByVariables(attributes, variables, processVariables, potOwners, new QueryContext(0, 2));\n+        Assert.assertEquals(2, data.size());\n+\n+    }\n+\n+}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1e57dd6f9a77d2e636949457815115ca83acc4dc"}, "originalPosition": 219}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDU4NjQ1OQ==", "bodyText": "done", "url": "https://github.com/kiegroup/jbpm/pull/1615#discussion_r404586459", "createdAt": "2020-04-07T07:15:57Z", "author": {"login": "elguardian"}, "path": "jbpm-services/jbpm-kie-services/src/test/java/org/jbpm/kie/services/test/AdvanceRuntimeDataServiceImplTest.java", "diffHunk": "@@ -0,0 +1,219 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.jbpm.kie.services.test;\n+\n+import java.io.File;\n+import java.io.FileOutputStream;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.drools.compiler.kie.builder.impl.InternalKieModule;\n+import org.jbpm.kie.services.impl.KModuleDeploymentUnit;\n+import org.jbpm.kie.test.util.AbstractKieServicesBaseTest;\n+import org.jbpm.services.api.ProcessInstanceNotFoundException;\n+import org.jbpm.services.api.model.DeploymentUnit;\n+import org.jbpm.services.api.model.ProcessInstanceWithVarsDesc;\n+import org.jbpm.services.api.model.UserTaskInstanceWithPotOwnerDesc;\n+import org.junit.After;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.kie.api.KieServices;\n+import org.kie.api.builder.ReleaseId;\n+import org.kie.api.runtime.process.ProcessInstance;\n+import org.kie.internal.query.QueryContext;\n+import org.kie.scanner.KieMavenRepository;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static java.util.Collections.emptyList;\n+import static java.util.Collections.emptyMap;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertNull;\n+import static org.kie.scanner.KieMavenRepository.getKieMavenRepository;\n+\n+public class AdvanceRuntimeDataServiceImplTest extends AbstractKieServicesBaseTest {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(AdvanceRuntimeDataServiceImplTest.class);\n+\n+    private List<DeploymentUnit> units = new ArrayList<DeploymentUnit>();\n+    protected String correctUser = \"testUser\";\n+    protected String wrongUser = \"wrongUser\";\n+\n+    private List<Long> processIds;\n+    private KModuleDeploymentUnit deploymentUnit = null;\n+\n+    @Before\n+    public void prepare() {\n+\n+        configureServices();\n+        logger.debug(\"Preparing kjar\");\n+        KieServices ks = KieServices.Factory.get();\n+        ReleaseId releaseId = ks.newReleaseId(GROUP_ID, ARTIFACT_ID, VERSION);\n+        List<String> processes = new ArrayList<String>();\n+        processes.add(\"repo/processes/general/SingleHumanTaskWithVarsA.bpmn2\");\n+        processes.add(\"repo/processes/general/SingleHumanTaskWithVarsB.bpmn2\");\n+\n+        InternalKieModule kJar1 = createKieJar(ks, releaseId, processes);\n+        File pom = new File(\"target/kmodule\", \"pom.xml\");\n+        pom.getParentFile().mkdir();\n+        try (FileOutputStream fs = new FileOutputStream(pom);) {\n+            fs.write(getPom(releaseId).getBytes());\n+        } catch (Exception e) {\n+\n+        }\n+        KieMavenRepository repository = getKieMavenRepository();\n+        repository.deployArtifact(releaseId, kJar1, pom);\n+\n+        assertNotNull(deploymentService);\n+\n+        deploymentUnit = new KModuleDeploymentUnit(GROUP_ID, ARTIFACT_ID, VERSION);\n+\n+        deploymentService.deploy(deploymentUnit);\n+        units.add(deploymentUnit);\n+        assertNotNull(processService);\n+\n+        processIds = new ArrayList<>();\n+        for (int i = 0; i < 10; i++) {\n+            Map<String, Object> inputsA1 = new HashMap<>();\n+            inputsA1.put(\"var_a\", \"a\" + (i % 3));\n+            inputsA1.put(\"var_b\", (i % 3));\n+            processIds.add(processService.startProcess(deploymentUnit.getIdentifier(), \"test.test_A\", inputsA1));\n+        }\n+        for (int i = 0; i < 10; i++) {\n+            Map<String, Object> inputsB1 = new HashMap<>();\n+            inputsB1.put(\"var_a\", \"b\" + (i % 3));\n+            inputsB1.put(\"var_b\", (i % 3));\n+            processIds.add(processService.startProcess(deploymentUnit.getIdentifier(), \"test.test_B\", inputsB1));\n+        }\n+    }\n+\n+    @After\n+    public void cleanup() {\n+        for (Long processInstanceId : processIds) {\n+            try {\n+                // let's abort process instance to leave the system in clear state\n+                processService.abortProcessInstance(processInstanceId);\n+\n+                ProcessInstance pi = processService.getProcessInstance(processInstanceId);\n+                assertNull(pi);\n+            } catch (ProcessInstanceNotFoundException e) {\n+                // ignore it as it was already completed/aborted\n+            }\n+        }\n+        cleanupSingletonSessionId();\n+        if (units != null && !units.isEmpty()) {\n+            for (DeploymentUnit unit : units) {\n+                try {\n+                    deploymentService.undeploy(unit);\n+                } catch (Exception e) {\n+                    // do nothing in case of some failed tests to avoid next test to fail as well\n+                }\n+            }\n+            units.clear();\n+        }\n+        close();\n+    }\n+\n+    @Test\n+    public void testQueryProcessByVariables() {\n+        Map<String, Object> variables = Collections.<String, Object> singletonMap(\"var_a\", \"a1\");\n+        Map<String, Object> attributes = Collections.<String, Object> singletonMap(\"processId\", \"test.test_A\");\n+        List<ProcessInstanceWithVarsDesc> data = advanceVariableDataService.queryProcessByVariables(attributes, variables, new QueryContext());\n+        Assert.assertEquals(3, data.size());\n+        for (ProcessInstanceWithVarsDesc p : data) {\n+            Assert.assertEquals(\"a1\", p.getVariables().get(\"var_a\"));\n+            Assert.assertEquals(\"test.test_A\", p.getProcessId());\n+        }\n+    }\n+\n+    @Test\n+    public void testQueryProcessByVariablesWithPagination() {\n+        Map<String, Object> variables = Collections.<String, Object> singletonMap(\"var_a\", \"a1\");\n+        Map<String, Object> attributes = Collections.<String, Object> singletonMap(\"processId\", \"test.test_A\");\n+        List<ProcessInstanceWithVarsDesc> data = advanceVariableDataService.queryProcessByVariables(attributes, variables, new QueryContext(0, 2));\n+        Assert.assertEquals(2, data.size());\n+        for (ProcessInstanceWithVarsDesc p : data) {\n+            Assert.assertEquals(\"a1\", p.getVariables().get(\"var_a\"));\n+            Assert.assertEquals(\"test.test_A\", p.getProcessId());\n+        }\n+    }\n+\n+    @Test\n+    public void testQueryTaskByVariables() {\n+        Map<String, Object> variables = Collections.<String, Object> singletonMap(\"task_in_a1\", \"a0\");\n+        Map<String, Object> attributes = Collections.<String, Object> singletonMap(\"deploymentId\", \"org.jbpm.test:test-module:1.0.0\");\n+        List<String> potOwners = emptyList();\n+        List<UserTaskInstanceWithPotOwnerDesc> data = advanceVariableDataService.queryUserTasksByVariables(attributes, variables, emptyMap(), potOwners, new QueryContext());\n+        Assert.assertEquals(4, data.size());\n+        for (UserTaskInstanceWithPotOwnerDesc p : data) {\n+            Assert.assertEquals(\"a0\", p.getInputdata().get(\"task_in_a1\"));\n+            Assert.assertEquals(\"org.jbpm.test:test-module:1.0.0\", p.getDeploymentId());\n+        }\n+    }\n+\n+    @Test\n+    public void testQueryTaskByVariablesWithPagination() {\n+        Map<String, Object> variables = Collections.<String, Object> singletonMap(\"task_in_a1\", \"a0\");\n+        Map<String, Object> attributes = Collections.<String, Object> singletonMap(\"deploymentId\", \"org.jbpm.test:test-module:1.0.0\");\n+        List<String> potOwners = emptyList();\n+        List<UserTaskInstanceWithPotOwnerDesc> data = advanceVariableDataService.queryUserTasksByVariables(attributes, variables, emptyMap(), potOwners, new QueryContext(0, 2));\n+        Assert.assertEquals(2, data.size());\n+        for (UserTaskInstanceWithPotOwnerDesc p : data) {\n+            Assert.assertEquals(\"a0\", p.getInputdata().get(\"task_in_a1\"));\n+            Assert.assertEquals(\"org.jbpm.test:test-module:1.0.0\", p.getDeploymentId());\n+        }\n+    }\n+\n+    @Test\n+    public void testQueryTaskByVariablesWithOwners() {\n+        Map<String, Object> variables = emptyMap();\n+        Map<String, Object> attributes = emptyMap();\n+        List<String> potOwners = Collections.singletonList(\"katy\");\n+        List<UserTaskInstanceWithPotOwnerDesc> data = advanceVariableDataService.queryUserTasksByVariables(attributes, variables, emptyMap(), potOwners, new QueryContext(0, 2));\n+        Assert.assertEquals(2, data.size());\n+        for (UserTaskInstanceWithPotOwnerDesc p : data) {\n+            Assert.assertTrue(p.getPotentialOwners().contains(\"katy\"));\n+        }\n+    }\n+\n+    @Test\n+    public void testQueryTaskByVariablesWithAllOwners() {\n+        Map<String, Object> variables = emptyMap();\n+        Map<String, Object> attributes = emptyMap();\n+        List<String> potOwners = Arrays.asList(\"katy\", \"nobody\");\n+        List<UserTaskInstanceWithPotOwnerDesc> data = advanceVariableDataService.queryUserTasksByVariables(attributes, variables, emptyMap(), potOwners, new QueryContext(0, 2));\n+        Assert.assertEquals(0, data.size());\n+\n+    }\n+\n+    @Test\n+    public void testQueryTaskByVariablesWithByProcessVar() {\n+        Map<String, Object> variables = emptyMap();\n+        Map<String, Object> attributes = emptyMap();\n+        Map<String, Object> processVariables = Collections.singletonMap(\"var_a\", \"a1\");\n+        List<String> potOwners = Collections.emptyList();\n+        List<UserTaskInstanceWithPotOwnerDesc> data = advanceVariableDataService.queryUserTasksByVariables(attributes, variables, processVariables, potOwners, new QueryContext(0, 2));\n+        Assert.assertEquals(2, data.size());\n+\n+    }\n+\n+}", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjQyMDk0NA=="}, "originalCommit": {"oid": "1e57dd6f9a77d2e636949457815115ca83acc4dc"}, "originalPosition": 219}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ5NTgzNzA3OnYy", "diffSide": "RIGHT", "path": "jbpm-services/jbpm-services-api/src/build/revapi-config.json", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMlQxNjowMzowMlrOF_yWZA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMlQxNjowMzowMlrOF_yWZA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjQyOTU0MA==", "bodyText": "You mean \"for getting\" instead of \"adding\"?", "url": "https://github.com/kiegroup/jbpm/pull/1615#discussion_r402429540", "createdAt": "2020-04-02T16:03:02Z", "author": {"login": "afalhambra"}, "path": "jbpm-services/jbpm-services-api/src/build/revapi-config.json", "diffHunk": "@@ -1,23 +1,60 @@\n {\n-  \"filters\": {\n-    \"revapi\": {\n-      \"java\": {\n-        \"filter\": {\n-          \"_comment\": \"We don't want to check transitive classes, e.g. from kie-api, since we already check them in their own module.\",\n-          \"packages\": {\n-            \"regex\": true,\n-            \"include\": [\n-              \"org\\\\.jbpm\\\\.services\\\\.api.*\"\n+    \"filters\": {\n+        \"revapi\": {\n+            \"java\": {\n+                \"filter\": {\n+                    \"_comment\": \"We don't want to check transitive classes, e.g. from kie-api, since we already check them in their own module.\",\n+                    \"packages\": {\n+                        \"regex\": true,\n+                        \"include\": [\n+                            \"org\\\\.jbpm\\\\.services\\\\.api.*\"\n+                        ]\n+                    }\n+                }\n+            }\n+        }\n+    },\n+    \"ignores\": {\n+        \"revapi\": {\n+            \"_comment\": \"Changes between 7.33.0.Final and the current branch. These changes are desired and thus ignored.\",\n+            \"ignore\": [\n+                {\n+                    \"code\": \"java.method.addedToInterface\",\n+                    \"new\": \"method java.util.Map<java.lang.String, java.lang.Object> org.jbpm.services.api.model.UserTaskInstanceWithVarsDesc::getExtraData()\",\n+                    \"package\": \"org.jbpm.services.api.model\",\n+                    \"classSimpleName\": \"UserTaskInstanceWithVarsDesc\",\n+                    \"methodName\": \"getExtraData\",\n+                    \"elementKind\": \"method\",\n+                    \"justification\": \"new method for adding extra information to this entity\"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1e57dd6f9a77d2e636949457815115ca83acc4dc"}, "originalPosition": 37}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ5NTgzODM5OnYy", "diffSide": "RIGHT", "path": "jbpm-services/jbpm-services-api/src/build/revapi-config.json", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMlQxNjowMzoyM1rOF_yXRg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMlQxNjowMzoyM1rOF_yXRg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjQyOTc2Ng==", "bodyText": "You mean \"for getting\" instead of \"adding\"?", "url": "https://github.com/kiegroup/jbpm/pull/1615#discussion_r402429766", "createdAt": "2020-04-02T16:03:23Z", "author": {"login": "afalhambra"}, "path": "jbpm-services/jbpm-services-api/src/build/revapi-config.json", "diffHunk": "@@ -1,23 +1,60 @@\n {\n-  \"filters\": {\n-    \"revapi\": {\n-      \"java\": {\n-        \"filter\": {\n-          \"_comment\": \"We don't want to check transitive classes, e.g. from kie-api, since we already check them in their own module.\",\n-          \"packages\": {\n-            \"regex\": true,\n-            \"include\": [\n-              \"org\\\\.jbpm\\\\.services\\\\.api.*\"\n+    \"filters\": {\n+        \"revapi\": {\n+            \"java\": {\n+                \"filter\": {\n+                    \"_comment\": \"We don't want to check transitive classes, e.g. from kie-api, since we already check them in their own module.\",\n+                    \"packages\": {\n+                        \"regex\": true,\n+                        \"include\": [\n+                            \"org\\\\.jbpm\\\\.services\\\\.api.*\"\n+                        ]\n+                    }\n+                }\n+            }\n+        }\n+    },\n+    \"ignores\": {\n+        \"revapi\": {\n+            \"_comment\": \"Changes between 7.33.0.Final and the current branch. These changes are desired and thus ignored.\",\n+            \"ignore\": [\n+                {\n+                    \"code\": \"java.method.addedToInterface\",\n+                    \"new\": \"method java.util.Map<java.lang.String, java.lang.Object> org.jbpm.services.api.model.UserTaskInstanceWithVarsDesc::getExtraData()\",\n+                    \"package\": \"org.jbpm.services.api.model\",\n+                    \"classSimpleName\": \"UserTaskInstanceWithVarsDesc\",\n+                    \"methodName\": \"getExtraData\",\n+                    \"elementKind\": \"method\",\n+                    \"justification\": \"new method for adding extra information to this entity\"\n+                },\n+                {\n+                    \"code\": \"java.method.addedToInterface\",\n+                    \"new\": \"method java.util.Map<java.lang.String, java.lang.Object> org.jbpm.services.api.model.UserTaskInstanceWithPotOwnerDesc::getProcessVariables()\",\n+                    \"package\": \"org.jbpm.services.api.model\",\n+                    \"classSimpleName\": \"UserTaskInstanceWithPotOwnerDesc\",\n+                    \"methodName\": \"getProcessVariables\",\n+                    \"elementKind\": \"method\",\n+                    \"justification\": \"new method for adding process variables information to this entity\"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1e57dd6f9a77d2e636949457815115ca83acc4dc"}, "originalPosition": 46}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUwNjI5MTg3OnYy", "diffSide": "RIGHT", "path": "jbpm-services/jbpm-kie-services/src/main/resources/META-INF/Servicesorm.xml", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNlQwODoyMjoyMFrOGBMvFg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNlQwODoyMjoyMFrOGBMvFg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzkxMDQyMg==", "bodyText": "It must be in lowercase for mysql, etc.", "url": "https://github.com/kiegroup/jbpm/pull/1615#discussion_r403910422", "createdAt": "2020-04-06T08:22:20Z", "author": {"login": "gmunozfe"}, "path": "jbpm-services/jbpm-kie-services/src/main/resources/META-INF/Servicesorm.xml", "diffHunk": "@@ -1182,5 +1182,71 @@\n     </query>\n     <!-- hint name=\"org.hibernate.timeout\" value=\"200\"/ -->\n   </named-query>   \n-        \n+\n+\n+  <!-- advance runtime queries -->\n+  <named-native-query name=\"GeProcessInstanceByIdList\">\n+      <query>\n+        SELECT processInstanceId, processId, processName, processVersion, status, externalId, start_date, user_identity, correlationKey \n+          FROM ProcessInstanceLog pil \n+         WHERE processInstanceId IN (:idList) \n+      ORDER BY processInstanceId ASC \n+    </query>\n+  </named-native-query>\n+  \n+  <named-native-query name=\"GeVariablesByProcessInstanceIdList\">\n+      <query>\n+            SELECT A1.processInstanceId, A1.variableId, A1.value \n+              FROM VariableInstanceLog A1 \n+         LEFT JOIN VariableInstanceLog A2 ON A1.processId = A2.processId \n+                                         AND A1.processInstanceId = A2.processInstanceId \n+                                         AND A1.variableInstanceId = A2.variableInstanceId \n+                                         AND A1.log_date &#60; A2.log_date \n+             WHERE A2.log_date IS NULL AND A1.processInstanceId IN (:idList) \n+          ORDER BY A1.processInstanceId ASC \n+      </query>\n+  </named-native-query>\n+  <named-native-query name=\"GetTasksByIdList\">\n+      <query>\n+              SELECT task.id, task.name, task.formName, task.subject, \n+                     task.actualOwner_id, log.correlationKey, task.createdOn,\n+                     task.createdBy_id, task.expirationTime, task.priority,\n+                     task.status, log.processInstanceId, log.processId, log.externalId,\n+                     log.processInstanceDescription \n+                FROM Task task \n+          INNER JOIN ProcessInstanceLog log ON log.processInstanceId = task.processInstanceId\n+               WHERE Task.id IN (:idList)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1e57dd6f9a77d2e636949457815115ca83acc4dc"}, "originalPosition": 38}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUwNjI5Mjk2OnYy", "diffSide": "RIGHT", "path": "jbpm-services/jbpm-kie-services/src/main/resources/META-INF/Servicesorm.xml", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNlQwODoyMjozOFrOGBMvxQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNlQwODoyMjozOFrOGBMvxQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzkxMDU5Nw==", "bodyText": "Same here", "url": "https://github.com/kiegroup/jbpm/pull/1615#discussion_r403910597", "createdAt": "2020-04-06T08:22:38Z", "author": {"login": "gmunozfe"}, "path": "jbpm-services/jbpm-kie-services/src/main/resources/META-INF/Servicesorm.xml", "diffHunk": "@@ -1182,5 +1182,71 @@\n     </query>\n     <!-- hint name=\"org.hibernate.timeout\" value=\"200\"/ -->\n   </named-query>   \n-        \n+\n+\n+  <!-- advance runtime queries -->\n+  <named-native-query name=\"GeProcessInstanceByIdList\">\n+      <query>\n+        SELECT processInstanceId, processId, processName, processVersion, status, externalId, start_date, user_identity, correlationKey \n+          FROM ProcessInstanceLog pil \n+         WHERE processInstanceId IN (:idList) \n+      ORDER BY processInstanceId ASC \n+    </query>\n+  </named-native-query>\n+  \n+  <named-native-query name=\"GeVariablesByProcessInstanceIdList\">\n+      <query>\n+            SELECT A1.processInstanceId, A1.variableId, A1.value \n+              FROM VariableInstanceLog A1 \n+         LEFT JOIN VariableInstanceLog A2 ON A1.processId = A2.processId \n+                                         AND A1.processInstanceId = A2.processInstanceId \n+                                         AND A1.variableInstanceId = A2.variableInstanceId \n+                                         AND A1.log_date &#60; A2.log_date \n+             WHERE A2.log_date IS NULL AND A1.processInstanceId IN (:idList) \n+          ORDER BY A1.processInstanceId ASC \n+      </query>\n+  </named-native-query>\n+  <named-native-query name=\"GetTasksByIdList\">\n+      <query>\n+              SELECT task.id, task.name, task.formName, task.subject, \n+                     task.actualOwner_id, log.correlationKey, task.createdOn,\n+                     task.createdBy_id, task.expirationTime, task.priority,\n+                     task.status, log.processInstanceId, log.processId, log.externalId,\n+                     log.processInstanceDescription \n+                FROM Task task \n+          INNER JOIN ProcessInstanceLog log ON log.processInstanceId = task.processInstanceId\n+               WHERE Task.id IN (:idList)\n+            ORDER BY Task.id ASC ", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1e57dd6f9a77d2e636949457815115ca83acc4dc"}, "originalPosition": 39}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUwNjMwMTgxOnYy", "diffSide": "RIGHT", "path": "jbpm-services/jbpm-kie-services/src/main/java/org/jbpm/kie/services/impl/AbstractAdvanceRuntimeDataServiceImpl.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNlQwODoyNDo1OVrOGBM1KQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNlQwODoyNDo1OVrOGBM1KQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzkxMTk3Nw==", "bodyText": "Do not use log_date, but id, for ordering, as log_date may be the same.\nInvert the order to pick up the current value", "url": "https://github.com/kiegroup/jbpm/pull/1615#discussion_r403911977", "createdAt": "2020-04-06T08:24:59Z", "author": {"login": "gmunozfe"}, "path": "jbpm-services/jbpm-kie-services/src/main/java/org/jbpm/kie/services/impl/AbstractAdvanceRuntimeDataServiceImpl.java", "diffHunk": "@@ -0,0 +1,306 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.jbpm.kie.services.impl;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import javax.persistence.EntityManager;\n+import javax.persistence.EntityManagerFactory;\n+import javax.persistence.Query;\n+\n+import org.jbpm.kie.services.impl.model.ProcessInstanceWithVarsDesc;\n+import org.jbpm.kie.services.impl.model.UserTaskInstanceWithPotOwnerDesc;\n+import org.jbpm.shared.services.impl.QueryManager;\n+import org.jbpm.shared.services.impl.TransactionalCommandService;\n+import org.jbpm.shared.services.impl.commands.QueryNameCommand;\n+import org.kie.api.runtime.query.QueryContext;\n+\n+import static java.util.Collections.singletonMap;\n+\n+public abstract class AbstractAdvanceRuntimeDataServiceImpl {\n+\n+    private EntityManagerFactory emf;\n+    private TransactionalCommandService commandService;\n+\n+    public AbstractAdvanceRuntimeDataServiceImpl() {\n+        QueryManager.get().addNamedQueries(\"META-INF/Servicesorm.xml\");\n+    }\n+    public void setCommandService(TransactionalCommandService commandService) {\n+        this.commandService = commandService;\n+    }\n+\n+    public void setEmf(EntityManagerFactory emf) {\n+        this.emf = emf;\n+    }\n+\n+\n+    public List<org.jbpm.services.api.model.ProcessInstanceWithVarsDesc> queryProcessByVariables(Map<String, Object> attributes,\n+                                                                                                 Map<String, Object> variables,\n+                                                                                                 int processType,\n+                                                                                                 String varPrefix,\n+                                                                                                 QueryContext queryContext) {\n+        EntityManager entityManager = emf.createEntityManager();\n+\n+        // first step is to filter the data creating a derived tables and pivoting var - rows to columns (only the variables we are interested to filter)\n+        StringBuilder where = new StringBuilder();\n+        StringBuilder derivedTables = new StringBuilder();\n+        for (Map.Entry<String, Object> var : variables.entrySet()) {\n+            String alias = \"TABLE_\" + var.getKey();\n+            String varName = var.getKey();\n+\n+            derivedTables.append(\"LEFT JOIN (\" +\n+                                 \"SELECT A1.processId, A1.processInstanceId, A1.variableId AS NAME, A1.value AS VALUE \\n\" +\n+                                 \"FROM VariableInstanceLog A1 \\n\" +\n+                                 \"LEFT JOIN VariableInstanceLog A2 ON A1.processId = A2.processId AND A1.processInstanceId = A2.processInstanceId AND A1.variableInstanceId = A2.variableInstanceId AND A2.log_date < A1.log_date  \\n\" +\n+                                 \"WHERE A2.log_date IS NULL \\n\" +\n+                                 \") \" + alias + \" ON \" + alias + \".processId = pil.processId AND \" + alias + \".processInstanceId = pil.processInstanceId \\n\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1e57dd6f9a77d2e636949457815115ca83acc4dc"}, "originalPosition": 75}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUwNjQ3NzUyOnYy", "diffSide": "RIGHT", "path": "jbpm-services/jbpm-kie-services/src/main/java/org/jbpm/kie/services/impl/AbstractAdvanceRuntimeDataServiceImpl.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNlQwOTowOTo0OVrOGBOhkQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNlQwOTowOTo0OVrOGBOhkQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzkzOTcyOQ==", "bodyText": "This native query is failing when using an Oracle database: ORA-00933: SQL command not properly ended\nSeems it could be related to the pagination part of the SQL statement.", "url": "https://github.com/kiegroup/jbpm/pull/1615#discussion_r403939729", "createdAt": "2020-04-06T09:09:49Z", "author": {"login": "afalhambra"}, "path": "jbpm-services/jbpm-kie-services/src/main/java/org/jbpm/kie/services/impl/AbstractAdvanceRuntimeDataServiceImpl.java", "diffHunk": "@@ -0,0 +1,306 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.jbpm.kie.services.impl;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import javax.persistence.EntityManager;\n+import javax.persistence.EntityManagerFactory;\n+import javax.persistence.Query;\n+\n+import org.jbpm.kie.services.impl.model.ProcessInstanceWithVarsDesc;\n+import org.jbpm.kie.services.impl.model.UserTaskInstanceWithPotOwnerDesc;\n+import org.jbpm.shared.services.impl.QueryManager;\n+import org.jbpm.shared.services.impl.TransactionalCommandService;\n+import org.jbpm.shared.services.impl.commands.QueryNameCommand;\n+import org.kie.api.runtime.query.QueryContext;\n+\n+import static java.util.Collections.singletonMap;\n+\n+public abstract class AbstractAdvanceRuntimeDataServiceImpl {\n+\n+    private EntityManagerFactory emf;\n+    private TransactionalCommandService commandService;\n+\n+    public AbstractAdvanceRuntimeDataServiceImpl() {\n+        QueryManager.get().addNamedQueries(\"META-INF/Servicesorm.xml\");\n+    }\n+    public void setCommandService(TransactionalCommandService commandService) {\n+        this.commandService = commandService;\n+    }\n+\n+    public void setEmf(EntityManagerFactory emf) {\n+        this.emf = emf;\n+    }\n+\n+\n+    public List<org.jbpm.services.api.model.ProcessInstanceWithVarsDesc> queryProcessByVariables(Map<String, Object> attributes,\n+                                                                                                 Map<String, Object> variables,\n+                                                                                                 int processType,\n+                                                                                                 String varPrefix,\n+                                                                                                 QueryContext queryContext) {\n+        EntityManager entityManager = emf.createEntityManager();\n+\n+        // first step is to filter the data creating a derived tables and pivoting var - rows to columns (only the variables we are interested to filter)\n+        StringBuilder where = new StringBuilder();\n+        StringBuilder derivedTables = new StringBuilder();\n+        for (Map.Entry<String, Object> var : variables.entrySet()) {\n+            String alias = \"TABLE_\" + var.getKey();\n+            String varName = var.getKey();\n+\n+            derivedTables.append(\"LEFT JOIN (\" +\n+                                 \"SELECT A1.processId, A1.processInstanceId, A1.variableId AS NAME, A1.value AS VALUE \\n\" +\n+                                 \"FROM VariableInstanceLog A1 \\n\" +\n+                                 \"LEFT JOIN VariableInstanceLog A2 ON A1.processId = A2.processId AND A1.processInstanceId = A2.processInstanceId AND A1.variableInstanceId = A2.variableInstanceId AND A2.log_date < A1.log_date  \\n\" +\n+                                 \"WHERE A2.log_date IS NULL \\n\" +\n+                                 \") \" + alias + \" ON \" + alias + \".processId = pil.processId AND \" + alias + \".processInstanceId = pil.processInstanceId \\n\");\n+\n+            addWhereExpression(where);\n+            where.append(alias + \".NAME = :NAME_\" + varName + \" AND \" + alias + \".VALUE= :VALUE_\" + varName + \"\\n\");\n+        }\n+\n+\n+        for (Map.Entry<String, Object> entry : attributes.entrySet()) {\n+            addWhereExpression(where);\n+            where.append(\" pil.\" + entry.getKey() + \" = :ATTR_\" + entry.getKey() + \" \");\n+        }\n+\n+        addWhereExpression(where);\n+        where.append(\" pil.processType = :processType \");\n+\n+        String procSQLString = \"SELECT DISTINCT pil.processInstanceId FROM ProcessInstanceLog pil \\n \" + derivedTables + where + \" ORDER BY pil.processInstanceId ASC \";\n+        procSQLString += (queryContext.getCount() > 0) ? \" LIMIT \" + queryContext.getCount() + \" OFFSET \" + queryContext.getOffset() + \" \\n\" : \"\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1e57dd6f9a77d2e636949457815115ca83acc4dc"}, "originalPosition": 91}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUwNjQ3ODY1OnYy", "diffSide": "RIGHT", "path": "jbpm-services/jbpm-kie-services/src/main/java/org/jbpm/kie/services/impl/AbstractAdvanceRuntimeDataServiceImpl.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNlQwOToxMDowOFrOGBOiQQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNlQwOToxMDowOFrOGBOiQQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzkzOTkwNQ==", "bodyText": "This native query is failing when using an Oracle database: ORA-00933: SQL command not properly ended\nSeems it could be related to the pagination part of the SQL statement.", "url": "https://github.com/kiegroup/jbpm/pull/1615#discussion_r403939905", "createdAt": "2020-04-06T09:10:08Z", "author": {"login": "afalhambra"}, "path": "jbpm-services/jbpm-kie-services/src/main/java/org/jbpm/kie/services/impl/AbstractAdvanceRuntimeDataServiceImpl.java", "diffHunk": "@@ -0,0 +1,306 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.jbpm.kie.services.impl;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import javax.persistence.EntityManager;\n+import javax.persistence.EntityManagerFactory;\n+import javax.persistence.Query;\n+\n+import org.jbpm.kie.services.impl.model.ProcessInstanceWithVarsDesc;\n+import org.jbpm.kie.services.impl.model.UserTaskInstanceWithPotOwnerDesc;\n+import org.jbpm.shared.services.impl.QueryManager;\n+import org.jbpm.shared.services.impl.TransactionalCommandService;\n+import org.jbpm.shared.services.impl.commands.QueryNameCommand;\n+import org.kie.api.runtime.query.QueryContext;\n+\n+import static java.util.Collections.singletonMap;\n+\n+public abstract class AbstractAdvanceRuntimeDataServiceImpl {\n+\n+    private EntityManagerFactory emf;\n+    private TransactionalCommandService commandService;\n+\n+    public AbstractAdvanceRuntimeDataServiceImpl() {\n+        QueryManager.get().addNamedQueries(\"META-INF/Servicesorm.xml\");\n+    }\n+    public void setCommandService(TransactionalCommandService commandService) {\n+        this.commandService = commandService;\n+    }\n+\n+    public void setEmf(EntityManagerFactory emf) {\n+        this.emf = emf;\n+    }\n+\n+\n+    public List<org.jbpm.services.api.model.ProcessInstanceWithVarsDesc> queryProcessByVariables(Map<String, Object> attributes,\n+                                                                                                 Map<String, Object> variables,\n+                                                                                                 int processType,\n+                                                                                                 String varPrefix,\n+                                                                                                 QueryContext queryContext) {\n+        EntityManager entityManager = emf.createEntityManager();\n+\n+        // first step is to filter the data creating a derived tables and pivoting var - rows to columns (only the variables we are interested to filter)\n+        StringBuilder where = new StringBuilder();\n+        StringBuilder derivedTables = new StringBuilder();\n+        for (Map.Entry<String, Object> var : variables.entrySet()) {\n+            String alias = \"TABLE_\" + var.getKey();\n+            String varName = var.getKey();\n+\n+            derivedTables.append(\"LEFT JOIN (\" +\n+                                 \"SELECT A1.processId, A1.processInstanceId, A1.variableId AS NAME, A1.value AS VALUE \\n\" +\n+                                 \"FROM VariableInstanceLog A1 \\n\" +\n+                                 \"LEFT JOIN VariableInstanceLog A2 ON A1.processId = A2.processId AND A1.processInstanceId = A2.processInstanceId AND A1.variableInstanceId = A2.variableInstanceId AND A2.log_date < A1.log_date  \\n\" +\n+                                 \"WHERE A2.log_date IS NULL \\n\" +\n+                                 \") \" + alias + \" ON \" + alias + \".processId = pil.processId AND \" + alias + \".processInstanceId = pil.processInstanceId \\n\");\n+\n+            addWhereExpression(where);\n+            where.append(alias + \".NAME = :NAME_\" + varName + \" AND \" + alias + \".VALUE= :VALUE_\" + varName + \"\\n\");\n+        }\n+\n+\n+        for (Map.Entry<String, Object> entry : attributes.entrySet()) {\n+            addWhereExpression(where);\n+            where.append(\" pil.\" + entry.getKey() + \" = :ATTR_\" + entry.getKey() + \" \");\n+        }\n+\n+        addWhereExpression(where);\n+        where.append(\" pil.processType = :processType \");\n+\n+        String procSQLString = \"SELECT DISTINCT pil.processInstanceId FROM ProcessInstanceLog pil \\n \" + derivedTables + where + \" ORDER BY pil.processInstanceId ASC \";\n+        procSQLString += (queryContext.getCount() > 0) ? \" LIMIT \" + queryContext.getCount() + \" OFFSET \" + queryContext.getOffset() + \" \\n\" : \"\";\n+\n+        Query query = entityManager.createNativeQuery(procSQLString);\n+        for (Map.Entry<String, Object> var : variables.entrySet()) {\n+            query.setParameter(\"NAME_\" + var.getKey(), varPrefix + var.getKey());\n+            query.setParameter(\"VALUE_\" + var.getKey(), var.getValue());\n+        }\n+        for (Map.Entry<String, Object> entry : attributes.entrySet()) {\n+            query.setParameter(\"ATTR_\" + entry.getKey(), entry.getValue());\n+        }\n+        query.setParameter(\"processType\", processType);\n+\n+        List<Number> ids = query.getResultList();\n+        if (ids.isEmpty()) {\n+            return Collections.emptyList();\n+        }\n+\n+        // now we get the information\n+\n+        List<Object[]> procRows = commandService.execute(new QueryNameCommand<List<Object[]>>(\"GeProcessInstanceByIdList\", singletonMap(\"idList\", ids)));\n+        List<Object[]> varRows = commandService.execute(new QueryNameCommand<List<Object[]>>(\"GeVariablesByProcessInstanceIdList\", singletonMap(\"idList\", ids)));\n+\n+        int currentVarIdx = 0;\n+        List<org.jbpm.services.api.model.ProcessInstanceWithVarsDesc> data = new ArrayList<>();\n+        for (Object[] row : procRows) {\n+            ProcessInstanceWithVarsDesc pwv = toProcessInstanceWithVarsDesc(row);\n+\n+            Map<String, Object> vars = new HashMap<>();\n+            pwv.setVariables(vars);\n+            while (currentVarIdx < varRows.size() && row[0].equals(varRows.get(currentVarIdx)[0])) {\n+                String name = (String) varRows.get(currentVarIdx)[1];\n+                if (name.startsWith(varPrefix)) {\n+                    vars.put(name.substring(varPrefix.length()), varRows.get(currentVarIdx)[2]);\n+                }\n+                currentVarIdx++;\n+            }\n+            data.add(pwv);\n+        }\n+\n+        entityManager.close();\n+        return data;\n+    }\n+\n+    private ProcessInstanceWithVarsDesc toProcessInstanceWithVarsDesc(Object[] row) {\n+        return new ProcessInstanceWithVarsDesc(((Number) row[0]).longValue(),\n+                                               (String) row[1],\n+                                               (String) row[2],\n+                                               (String) row[3],\n+                                               ((Number) row[4]).intValue(),\n+                                               (String) row[5],\n+                                               (Date) row[6],\n+                                               (String) row[7],\n+                                               (String) row[8]);\n+    }\n+    private void addWhereExpression(StringBuilder where) {\n+        where.append(where.length() == 0 ? \"WHERE \" : \" AND \");\n+    }\n+\n+    public List<org.jbpm.services.api.model.UserTaskInstanceWithPotOwnerDesc> queryUserTasksByVariables(Map<String, Object> attributes,\n+                                                                                                        Map<String, Object> variables,\n+                                                                                                        Map<String, Object> processVariables,\n+                                                                                                        List<String> owners,\n+                                                                                                        int processType,\n+                                                                                                        String varPrefix,\n+                                                                                                        QueryContext queryContext) {\n+        EntityManager entityManager = emf.createEntityManager();\n+\n+        StringBuilder where = new StringBuilder();\n+        StringBuilder derivedTables = new StringBuilder();\n+        for (Map.Entry<String, Object> var : variables.entrySet()) {\n+            String alias = \"V_TABLE_\" + var.getKey();\n+            String varName = var.getKey();\n+            derivedTables.append(\"INNER JOIN (\\n\" +\n+                                  \"SELECT taskId, name, value \\n\" +\n+                                  \"FROM TaskVariableImpl \\n\" +\n+                                  \"WHERE type = 0\\n\" +\n+                                 \") \" + alias + \" ON \" + alias + \".taskId = task.id  \\n\");\n+\n+\n+            addWhereExpression(where);\n+            where.append(alias + \".NAME = :V_NAME_\" + varName + \" AND \" + alias + \".VALUE= :V_VALUE_\" + varName + \"\\n\");\n+        }\n+\n+        for (Map.Entry<String, Object> var : processVariables.entrySet()) {\n+            String alias = \"P_TABLE_\" + var.getKey();\n+            String varName = var.getKey();\n+\n+            derivedTables.append(\"LEFT JOIN (\" +\n+                                 \"SELECT A1.processId, A1.processInstanceId, A1.variableId AS NAME, A1.value AS VALUE \\n\" +\n+                                 \"FROM VariableInstanceLog A1 \\n\" +\n+                                 \"LEFT JOIN VariableInstanceLog A2 ON A1.processId = A2.processId AND A1.processInstanceId = A2.processInstanceId AND A1.variableInstanceId = A2.variableInstanceId AND A2.log_date < A1.log_date  \\n\" +\n+                                 \"WHERE A2.log_date IS NULL \\n\" +\n+                                 \") \" + alias + \" ON \" + alias + \".processId = pil.processId AND \" + alias + \".processInstanceId = pil.processInstanceId \\n\");\n+\n+            addWhereExpression(where);\n+            where.append(alias + \".NAME = :P_NAME_\" + varName + \" AND \" + alias + \".VALUE= :P_VALUE_\" + varName + \"\\n\");\n+        }\n+\n+        if (!owners.isEmpty()) {\n+            derivedTables.append(\"INNER JOIN ( \\n\" +\n+                             \"           SELECT DISTINCT po.task_id \\n\" +\n+                             \"           FROM PeopleAssignments_PotOwners po \\n\" +\n+                             \"           WHERE po.entity_id IN (:owners) \\n\" +\n+                             \"           GROUP BY po.task_id \\n\" +\n+                             \"           HAVING COUNT(po.entity_id) = :num_owners \\n\" +\n+                                 \") AS pot ON pot.task_id = task.id \");\n+        }\n+\n+        for (Map.Entry<String, Object> entry : attributes.entrySet()) {\n+            addWhereExpression(where);\n+            where.append(\" task.\" + entry.getKey() + \" = :ATTR_\" + entry.getKey() + \" \");\n+        }\n+\n+        addWhereExpression(where);\n+        where.append(\" pil.processType = :processType \");\n+\n+        String procSQLString = \"SELECT DISTINCT task.id FROM Task task INNER JOIN ProcessInstanceLog pil ON pil.processInstanceId = task.processInstanceId \\n \" + derivedTables + where + \" ORDER BY id ASC \";\n+        procSQLString += (queryContext.getCount() > 0) ? \" LIMIT \" + queryContext.getCount() + \" OFFSET \" + queryContext.getOffset() + \"\\n\" : \"\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1e57dd6f9a77d2e636949457815115ca83acc4dc"}, "originalPosition": 208}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUwNzA2ODE2OnYy", "diffSide": "RIGHT", "path": "jbpm-case-mgmt/jbpm-case-mgmt-impl/src/main/java/org/jbpm/casemgmt/impl/AdvanceCaseRuntimeDataServiceImpl.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNlQxMTo1NTowOFrOGBUNTw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNlQxNzowODo0N1rOGBhmxw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDAzMjg0Nw==", "bodyText": "Not sure whether it makes sense to have a \"ProcessInstanceWithVarDes\" as a class and another class for cases something like \"CaseInstanceWithVarDes\"? wdyt?. Only to make it a little more clear.", "url": "https://github.com/kiegroup/jbpm/pull/1615#discussion_r404032847", "createdAt": "2020-04-06T11:55:08Z", "author": {"login": "afalhambra"}, "path": "jbpm-case-mgmt/jbpm-case-mgmt-impl/src/main/java/org/jbpm/casemgmt/impl/AdvanceCaseRuntimeDataServiceImpl.java", "diffHunk": "@@ -0,0 +1,52 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.jbpm.casemgmt.impl;\n+\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.jbpm.casemgmt.api.AdvanceCaseRuntimeDataService;\n+import org.jbpm.kie.services.impl.AbstractAdvanceRuntimeDataServiceImpl;\n+import org.kie.api.runtime.query.QueryContext;\n+\n+import static org.jbpm.process.core.context.variable.VariableScope.CASE_FILE_PREFIX;\n+import static org.jbpm.workflow.core.WorkflowProcess.CASE_TYPE;\n+\n+public class AdvanceCaseRuntimeDataServiceImpl extends AbstractAdvanceRuntimeDataServiceImpl implements AdvanceCaseRuntimeDataService {\n+\n+\n+    @Override\n+    public List<org.jbpm.services.api.model.ProcessInstanceWithVarsDesc> queryCaseByVariables(Map<String, Object> attributes,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1e57dd6f9a77d2e636949457815115ca83acc4dc"}, "originalPosition": 33}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDI1MjM1OQ==", "bodyText": "Yeah I did have that in my mind and you are right I did it because they are different concepts.", "url": "https://github.com/kiegroup/jbpm/pull/1615#discussion_r404252359", "createdAt": "2020-04-06T17:08:47Z", "author": {"login": "elguardian"}, "path": "jbpm-case-mgmt/jbpm-case-mgmt-impl/src/main/java/org/jbpm/casemgmt/impl/AdvanceCaseRuntimeDataServiceImpl.java", "diffHunk": "@@ -0,0 +1,52 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.jbpm.casemgmt.impl;\n+\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.jbpm.casemgmt.api.AdvanceCaseRuntimeDataService;\n+import org.jbpm.kie.services.impl.AbstractAdvanceRuntimeDataServiceImpl;\n+import org.kie.api.runtime.query.QueryContext;\n+\n+import static org.jbpm.process.core.context.variable.VariableScope.CASE_FILE_PREFIX;\n+import static org.jbpm.workflow.core.WorkflowProcess.CASE_TYPE;\n+\n+public class AdvanceCaseRuntimeDataServiceImpl extends AbstractAdvanceRuntimeDataServiceImpl implements AdvanceCaseRuntimeDataService {\n+\n+\n+    @Override\n+    public List<org.jbpm.services.api.model.ProcessInstanceWithVarsDesc> queryCaseByVariables(Map<String, Object> attributes,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDAzMjg0Nw=="}, "originalCommit": {"oid": "1e57dd6f9a77d2e636949457815115ca83acc4dc"}, "originalPosition": 33}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUxMTY2MjMxOnYy", "diffSide": "RIGHT", "path": "jbpm-case-mgmt/jbpm-case-mgmt-api/src/main/java/org/jbpm/casemgmt/api/AdvanceCaseRuntimeDataService.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wN1QxMjowOTozMlrOGCAdBg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xN1QwNzowMjowMlrOGHCNMQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDc1Nzc2Ng==", "bodyText": "\"public static\" are redundant for an interface. Please remove them.", "url": "https://github.com/kiegroup/jbpm/pull/1615#discussion_r404757766", "createdAt": "2020-04-07T12:09:32Z", "author": {"login": "afalhambra"}, "path": "jbpm-case-mgmt/jbpm-case-mgmt-api/src/main/java/org/jbpm/casemgmt/api/AdvanceCaseRuntimeDataService.java", "diffHunk": "@@ -0,0 +1,45 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.jbpm.casemgmt.api;\n+\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.jbpm.services.api.model.ProcessInstanceWithVarsDesc;\n+import org.jbpm.services.api.model.UserTaskInstanceWithPotOwnerDesc;\n+import org.kie.api.runtime.query.QueryContext;\n+\n+public interface AdvanceCaseRuntimeDataService {\n+\n+    public static String TASK_ATTR_NAME = \"TASK_NAME\";\n+    public static String TASK_ATTR_OWNER = \"TASK_OWNER\";\n+    public static String CASE_ATTR_INSTANCE_ID = \"PROCESS_INSTANCE_ID\";\n+    public static String CASE_ATTR_CORRELATION_KEY = \"PROCESS_CORRELATION_KEY\";\n+    public static String CASE_ATTR_DEFINITION_ID = \"PROCESS_DEFINITION_ID\";\n+    public static String CASE_ATTR_DEPLOYMENT_ID = \"PROCESS_DEPLOYMENT_ID\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dff54f99161103a3aa333b880692a15f1e9f4e62"}, "originalPosition": 33}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDAyOTM2MQ==", "bodyText": "done", "url": "https://github.com/kiegroup/jbpm/pull/1615#discussion_r410029361", "createdAt": "2020-04-17T07:02:02Z", "author": {"login": "elguardian"}, "path": "jbpm-case-mgmt/jbpm-case-mgmt-api/src/main/java/org/jbpm/casemgmt/api/AdvanceCaseRuntimeDataService.java", "diffHunk": "@@ -0,0 +1,45 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.jbpm.casemgmt.api;\n+\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.jbpm.services.api.model.ProcessInstanceWithVarsDesc;\n+import org.jbpm.services.api.model.UserTaskInstanceWithPotOwnerDesc;\n+import org.kie.api.runtime.query.QueryContext;\n+\n+public interface AdvanceCaseRuntimeDataService {\n+\n+    public static String TASK_ATTR_NAME = \"TASK_NAME\";\n+    public static String TASK_ATTR_OWNER = \"TASK_OWNER\";\n+    public static String CASE_ATTR_INSTANCE_ID = \"PROCESS_INSTANCE_ID\";\n+    public static String CASE_ATTR_CORRELATION_KEY = \"PROCESS_CORRELATION_KEY\";\n+    public static String CASE_ATTR_DEFINITION_ID = \"PROCESS_DEFINITION_ID\";\n+    public static String CASE_ATTR_DEPLOYMENT_ID = \"PROCESS_DEPLOYMENT_ID\";", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDc1Nzc2Ng=="}, "originalCommit": {"oid": "dff54f99161103a3aa333b880692a15f1e9f4e62"}, "originalPosition": 33}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUxMjM3MzE3OnYy", "diffSide": "RIGHT", "path": "jbpm-services/jbpm-services-api/src/main/java/org/jbpm/services/api/AdvanceRuntimeDataService.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wN1QxNDo1MTo0NlrOGCHaBw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xN1QwNzowMjozMVrOGHCOBQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDg3MTY4Nw==", "bodyText": "\"public static\" are redundant for an interface. Please remove them.", "url": "https://github.com/kiegroup/jbpm/pull/1615#discussion_r404871687", "createdAt": "2020-04-07T14:51:46Z", "author": {"login": "afalhambra"}, "path": "jbpm-services/jbpm-services-api/src/main/java/org/jbpm/services/api/AdvanceRuntimeDataService.java", "diffHunk": "@@ -0,0 +1,39 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.jbpm.services.api;\n+\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.jbpm.services.api.model.ProcessInstanceWithVarsDesc;\n+import org.jbpm.services.api.model.UserTaskInstanceWithPotOwnerDesc;\n+import org.kie.api.runtime.query.QueryContext;\n+\n+public interface AdvanceRuntimeDataService {\n+\n+    public static String TASK_ATTR_NAME = \"TASK_NAME\";\n+    public static String TASK_ATTR_OWNER = \"TASK_OWNER\";\n+    public static String PROCESS_ATTR_INSTANCE_ID = \"PROCESS_INSTANCE_ID\";\n+    public static String PROCESS_ATTR_CORRELATION_KEY = \"PROCESS_CORRELATION_KEY\";\n+    public static String PROCESS_ATTR_DEFINITION_ID = \"PROCESS_DEFINITION_ID\";\n+    public static String PROCESS_ATTR_DEPLOYMENT_ID = \"PROCESS_DEPLOYMENT_ID\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dff54f99161103a3aa333b880692a15f1e9f4e62"}, "originalPosition": 33}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDAyOTU3Mw==", "bodyText": "done", "url": "https://github.com/kiegroup/jbpm/pull/1615#discussion_r410029573", "createdAt": "2020-04-17T07:02:31Z", "author": {"login": "elguardian"}, "path": "jbpm-services/jbpm-services-api/src/main/java/org/jbpm/services/api/AdvanceRuntimeDataService.java", "diffHunk": "@@ -0,0 +1,39 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.jbpm.services.api;\n+\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.jbpm.services.api.model.ProcessInstanceWithVarsDesc;\n+import org.jbpm.services.api.model.UserTaskInstanceWithPotOwnerDesc;\n+import org.kie.api.runtime.query.QueryContext;\n+\n+public interface AdvanceRuntimeDataService {\n+\n+    public static String TASK_ATTR_NAME = \"TASK_NAME\";\n+    public static String TASK_ATTR_OWNER = \"TASK_OWNER\";\n+    public static String PROCESS_ATTR_INSTANCE_ID = \"PROCESS_INSTANCE_ID\";\n+    public static String PROCESS_ATTR_CORRELATION_KEY = \"PROCESS_CORRELATION_KEY\";\n+    public static String PROCESS_ATTR_DEFINITION_ID = \"PROCESS_DEFINITION_ID\";\n+    public static String PROCESS_ATTR_DEPLOYMENT_ID = \"PROCESS_DEPLOYMENT_ID\";", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDg3MTY4Nw=="}, "originalCommit": {"oid": "dff54f99161103a3aa333b880692a15f1e9f4e62"}, "originalPosition": 33}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUyODk4Mzk1OnYy", "diffSide": "RIGHT", "path": "jbpm-services/jbpm-services-api/src/main/java/org/jbpm/services/api/query/model/QueryParam.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xM1QwODo1MzozM1rOGEg0IA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNFQwNjozMjo1MFrOGFADBA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzM4NTEyMA==", "bodyText": "These 3 operators can be grouped", "url": "https://github.com/kiegroup/jbpm/pull/1615#discussion_r407385120", "createdAt": "2020-04-13T08:53:33Z", "author": {"login": "gmunozfe"}, "path": "jbpm-services/jbpm-services-api/src/main/java/org/jbpm/services/api/query/model/QueryParam.java", "diffHunk": "@@ -303,6 +313,67 @@ public void setValue(List<?> value) {\n         this.value = value;\n     }\n \n+    public Object getObjectValue() {\n+        if (value == null || value.isEmpty()) {\n+            return null;\n+        }\n+        switch (type()) {\n+            case BINARY_OPERAND:\n+                return value.get(0);\n+            case RANGE_OPERAND:\n+                return value.subList(0, 2);\n+            case UNARY_OPERAND:\n+            case AGGREGATE:\n+                return null;\n+            case LIST_OPERAND:\n+            default:\n+                return value;\n+        }\n+\n+    }\n+\n+    private enum Type {\n+        DEFAULT,\n+        AGGREGATE,\n+        UNARY_OPERAND,\n+        BINARY_OPERAND,\n+        RANGE_OPERAND,\n+        LIST_OPERAND\n+    }\n+\n+    private Type type() {\n+        switch (operator) {\n+            case \"IS_NULL\":\n+            case \"NOT_NULL\":\n+            case \"DISTINCT\":\n+                return Type.UNARY_OPERAND;\n+            case \"MIN\":\n+            case \"MAX\":\n+            case \"SUM\":\n+            case \"AVERAGE\":\n+            case \"COUNT\":\n+                return Type.AGGREGATE;\n+            case \"EQUALS_TO\":\n+            case \"NOT_EQUALS_TO\":\n+            case \"LIKE_TO\":\n+            case \"GREATER_THAN\":\n+            case \"LESS_THAN\":\n+            case \"GREATER_OR_EQUALS_TO\":\n+            case \"LESS_OR_EQUALS_TO\":\n+                return Type.BINARY_OPERAND;\n+            case \"BETWEEN\":\n+                return Type.LIST_OPERAND;\n+            case \"IN\":\n+            case \"NOT_IN\":", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7254bbd4405c29a3f8eb4f1b3967ee8c78cfd26a"}, "originalPosition": 86}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzg5NjgzNg==", "bodyText": "should be range operand.", "url": "https://github.com/kiegroup/jbpm/pull/1615#discussion_r407896836", "createdAt": "2020-04-14T06:32:50Z", "author": {"login": "elguardian"}, "path": "jbpm-services/jbpm-services-api/src/main/java/org/jbpm/services/api/query/model/QueryParam.java", "diffHunk": "@@ -303,6 +313,67 @@ public void setValue(List<?> value) {\n         this.value = value;\n     }\n \n+    public Object getObjectValue() {\n+        if (value == null || value.isEmpty()) {\n+            return null;\n+        }\n+        switch (type()) {\n+            case BINARY_OPERAND:\n+                return value.get(0);\n+            case RANGE_OPERAND:\n+                return value.subList(0, 2);\n+            case UNARY_OPERAND:\n+            case AGGREGATE:\n+                return null;\n+            case LIST_OPERAND:\n+            default:\n+                return value;\n+        }\n+\n+    }\n+\n+    private enum Type {\n+        DEFAULT,\n+        AGGREGATE,\n+        UNARY_OPERAND,\n+        BINARY_OPERAND,\n+        RANGE_OPERAND,\n+        LIST_OPERAND\n+    }\n+\n+    private Type type() {\n+        switch (operator) {\n+            case \"IS_NULL\":\n+            case \"NOT_NULL\":\n+            case \"DISTINCT\":\n+                return Type.UNARY_OPERAND;\n+            case \"MIN\":\n+            case \"MAX\":\n+            case \"SUM\":\n+            case \"AVERAGE\":\n+            case \"COUNT\":\n+                return Type.AGGREGATE;\n+            case \"EQUALS_TO\":\n+            case \"NOT_EQUALS_TO\":\n+            case \"LIKE_TO\":\n+            case \"GREATER_THAN\":\n+            case \"LESS_THAN\":\n+            case \"GREATER_OR_EQUALS_TO\":\n+            case \"LESS_OR_EQUALS_TO\":\n+                return Type.BINARY_OPERAND;\n+            case \"BETWEEN\":\n+                return Type.LIST_OPERAND;\n+            case \"IN\":\n+            case \"NOT_IN\":", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzM4NTEyMA=="}, "originalCommit": {"oid": "7254bbd4405c29a3f8eb4f1b3967ee8c78cfd26a"}, "originalPosition": 86}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUyOTIyMTIzOnYy", "diffSide": "RIGHT", "path": "jbpm-services/jbpm-kie-services/src/main/resources/META-INF/Servicesorm.xml", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xM1QxMDozODoyMlrOGEjBAw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xM1QxMDozODoyMlrOGEjBAw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzQyMTE4Nw==", "bodyText": "It's selecting the first value, and target is the last one\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                                     AND A1.id &gt; A2.id \n          \n          \n            \n                                                     AND A2.id &gt; A1.id", "url": "https://github.com/kiegroup/jbpm/pull/1615#discussion_r407421187", "createdAt": "2020-04-13T10:38:22Z", "author": {"login": "gmunozfe"}, "path": "jbpm-services/jbpm-kie-services/src/main/resources/META-INF/Servicesorm.xml", "diffHunk": "@@ -1182,5 +1182,71 @@\n     </query>\n     <!-- hint name=\"org.hibernate.timeout\" value=\"200\"/ -->\n   </named-query>   \n-        \n+\n+\n+  <!-- advance runtime queries -->\n+  <named-native-query name=\"GeProcessInstanceByIdList\">\n+      <query>\n+        SELECT processInstanceId, processId, processName, processVersion, status, externalId, start_date, user_identity, correlationKey \n+          FROM ProcessInstanceLog pil \n+         WHERE processInstanceId IN (:idList) \n+      ORDER BY processInstanceId ASC \n+    </query>\n+  </named-native-query>\n+  \n+  <named-native-query name=\"GeVariablesByProcessInstanceIdList\">\n+      <query>\n+            SELECT A1.processInstanceId, A1.variableId, A1.value \n+              FROM VariableInstanceLog A1 \n+         LEFT JOIN VariableInstanceLog A2 ON A1.processId = A2.processId \n+                                         AND A1.processInstanceId = A2.processInstanceId \n+                                         AND A1.variableInstanceId = A2.variableInstanceId \n+                                         AND A1.id &gt; A2.id ", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7254bbd4405c29a3f8eb4f1b3967ee8c78cfd26a"}, "originalPosition": 24}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUyOTI2ODU0OnYy", "diffSide": "RIGHT", "path": "jbpm-services/jbpm-kie-services/src/test/java/org/jbpm/kie/services/test/AdvanceRuntimeDataServiceImplTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xM1QxMTowMjo0MFrOGEjdoQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNFQwNjozNTowN1rOGFAGJw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzQyODUxMw==", "bodyText": "Change the test name as it is testing isNotNull operator\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public void testQueryIsNullOperator() {\n          \n          \n            \n                public void testQueryIsNotNullOperator() {", "url": "https://github.com/kiegroup/jbpm/pull/1615#discussion_r407428513", "createdAt": "2020-04-13T11:02:40Z", "author": {"login": "gmunozfe"}, "path": "jbpm-services/jbpm-kie-services/src/test/java/org/jbpm/kie/services/test/AdvanceRuntimeDataServiceImplTest.java", "diffHunk": "@@ -0,0 +1,348 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.jbpm.kie.services.test;\n+\n+import java.io.File;\n+import java.io.FileOutputStream;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.drools.compiler.kie.builder.impl.InternalKieModule;\n+import org.jbpm.kie.services.impl.KModuleDeploymentUnit;\n+import org.jbpm.kie.test.util.AbstractKieServicesBaseTest;\n+import org.jbpm.services.api.ProcessInstanceNotFoundException;\n+import org.jbpm.services.api.model.DeploymentUnit;\n+import org.jbpm.services.api.model.ProcessInstanceWithVarsDesc;\n+import org.jbpm.services.api.model.UserTaskInstanceWithPotOwnerDesc;\n+import org.jbpm.services.api.query.model.QueryParam;\n+import org.junit.After;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.Parameterized;\n+import org.junit.runners.Parameterized.Parameters;\n+import org.kie.api.KieServices;\n+import org.kie.api.builder.ReleaseId;\n+import org.kie.api.runtime.process.ProcessInstance;\n+import org.kie.internal.query.QueryContext;\n+import org.kie.scanner.KieMavenRepository;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static java.util.Collections.emptyList;\n+import static org.hamcrest.CoreMatchers.is;\n+import static org.jbpm.services.api.AdvanceRuntimeDataService.PROCESS_ATTR_CORRELATION_KEY;\n+import static org.jbpm.services.api.AdvanceRuntimeDataService.PROCESS_ATTR_DEFINITION_ID;\n+import static org.jbpm.services.api.AdvanceRuntimeDataService.PROCESS_ATTR_DEPLOYMENT_ID;\n+import static org.jbpm.services.api.AdvanceRuntimeDataService.TASK_ATTR_NAME;\n+import static org.jbpm.services.api.AdvanceRuntimeDataService.TASK_ATTR_OWNER;\n+import static org.jbpm.services.api.query.model.QueryParam.equalsTo;\n+import static org.jbpm.services.api.query.model.QueryParam.in;\n+import static org.jbpm.services.api.query.model.QueryParam.isNotNull;\n+import static org.jbpm.services.api.query.model.QueryParam.likeTo;\n+import static org.jbpm.services.api.query.model.QueryParam.list;\n+import static org.jbpm.services.api.query.model.QueryParam.notEqualsTo;\n+import static org.jbpm.services.api.query.model.QueryParam.notIn;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertNull;\n+import static org.kie.scanner.KieMavenRepository.getKieMavenRepository;\n+\n+@RunWith(Parameterized.class)\n+public class AdvanceRuntimeDataServiceImplTest extends AbstractKieServicesBaseTest {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(AdvanceRuntimeDataServiceImplTest.class);\n+\n+    @Parameters(name = \"Pagination {0}\")\n+    public static Iterable<? extends Object> data() {\n+        return Arrays.asList(0, 2);\n+    }\n+\n+    private List<DeploymentUnit> units = new ArrayList<DeploymentUnit>();\n+    protected String correctUser = \"testUser\";\n+    protected String wrongUser = \"wrongUser\";\n+\n+    private List<Long> processIds;\n+    private KModuleDeploymentUnit deploymentUnit = null;\n+    private QueryContext queryContext;\n+\n+    public AdvanceRuntimeDataServiceImplTest(Integer count) {\n+        this.queryContext = new QueryContext(0, count);\n+    }\n+\n+    @Before\n+    public void prepare() {\n+\n+        configureServices();\n+        logger.debug(\"Preparing kjar\");\n+        KieServices ks = KieServices.Factory.get();\n+        ReleaseId releaseId = ks.newReleaseId(GROUP_ID, ARTIFACT_ID, VERSION);\n+        List<String> processes = new ArrayList<String>();\n+        processes.add(\"repo/processes/general/SingleHumanTaskWithVarsA.bpmn2\");\n+        processes.add(\"repo/processes/general/SingleHumanTaskWithVarsB.bpmn2\");\n+\n+        InternalKieModule kJar1 = createKieJar(ks, releaseId, processes);\n+        File pom = new File(\"target/kmodule\", \"pom.xml\");\n+        pom.getParentFile().mkdir();\n+        try (FileOutputStream fs = new FileOutputStream(pom);) {\n+            fs.write(getPom(releaseId).getBytes());\n+        } catch (Exception e) {\n+\n+        }\n+        KieMavenRepository repository = getKieMavenRepository();\n+        repository.deployArtifact(releaseId, kJar1, pom);\n+\n+        assertNotNull(deploymentService);\n+\n+        deploymentUnit = new KModuleDeploymentUnit(GROUP_ID, ARTIFACT_ID, VERSION);\n+\n+        deploymentService.deploy(deploymentUnit);\n+        units.add(deploymentUnit);\n+        assertNotNull(processService);\n+\n+        processIds = new ArrayList<>();\n+        for (int i = 0; i < 10; i++) {\n+            Map<String, Object> inputsA1 = new HashMap<>();\n+            inputsA1.put(\"var_a\", \"a\" + (i % 3));\n+            inputsA1.put(\"var_b\", (i % 3));\n+            processIds.add(processService.startProcess(deploymentUnit.getIdentifier(), \"test.test_A\", inputsA1));\n+        }\n+        for (int i = 0; i < 10; i++) {\n+            Map<String, Object> inputsB1 = new HashMap<>();\n+            inputsB1.put(\"var_a\", \"b\" + (i % 3));\n+            inputsB1.put(\"var_b\", (i % 3));\n+            processIds.add(processService.startProcess(deploymentUnit.getIdentifier(), \"test.test_B\", inputsB1));\n+        }\n+    }\n+\n+    @After\n+    public void cleanup() {\n+        for (Long processInstanceId : processIds) {\n+            try {\n+                // let's abort process instance to leave the system in clear state\n+                processService.abortProcessInstance(processInstanceId);\n+\n+                ProcessInstance pi = processService.getProcessInstance(processInstanceId);\n+                assertNull(pi);\n+            } catch (ProcessInstanceNotFoundException e) {\n+                // ignore it as it was already completed/aborted\n+            }\n+        }\n+        cleanupSingletonSessionId();\n+        if (units != null && !units.isEmpty()) {\n+            for (DeploymentUnit unit : units) {\n+                try {\n+                    deploymentService.undeploy(unit);\n+                } catch (Exception e) {\n+                    // do nothing in case of some failed tests to avoid next test to fail as well\n+                }\n+            }\n+            units.clear();\n+        }\n+        close();\n+    }\n+\n+    @Test\n+    public void testQueryProcessByVariables() {\n+        List<QueryParam> variables = list(equalsTo(\"var_a\", \"a1\"), equalsTo(\"var_b\", \"1\"));\n+        List<QueryParam> attributes = list(equalsTo(PROCESS_ATTR_DEFINITION_ID, \"test.test_A\"));\n+\n+        List<ProcessInstanceWithVarsDesc> data = advanceVariableDataService.queryProcessByVariables(attributes, variables, queryContext);\n+        if (queryContext.getCount() > 0) {\n+            Assert.assertThat(data.size(), is(queryContext.getCount()));\n+        }\n+        for (ProcessInstanceWithVarsDesc p : data) {\n+            Assert.assertEquals(\"a1\", p.getVariables().get(\"var_a\"));\n+            Assert.assertEquals(\"1\", p.getVariables().get(\"var_b\"));\n+            Assert.assertEquals(\"test.test_A\", p.getProcessId());\n+        }\n+    }\n+\n+    @Test\n+    public void testQueryInOperator() {\n+\n+        List<QueryParam> variables = list(in(\"var_a\", \"a1\", \"a2\"));\n+        List<QueryParam> attributes = list(equalsTo(PROCESS_ATTR_DEFINITION_ID, \"test.test_A\"));\n+\n+        List<ProcessInstanceWithVarsDesc> data = advanceVariableDataService.queryProcessByVariables(attributes, variables, queryContext);\n+        if (queryContext.getCount() > 0) {\n+            Assert.assertThat(data.size(), is(queryContext.getCount()));\n+        }\n+        List<String> values = Arrays.asList(\"a1\", \"a2\");\n+        for (ProcessInstanceWithVarsDesc p : data) {\n+            Assert.assertTrue(values.contains(p.getVariables().get(\"var_a\")));\n+            Assert.assertEquals(\"test.test_A\", p.getProcessId());\n+        }\n+    }\n+\n+    @Test\n+    public void testQueryLikeToOperator() {\n+\n+        List<QueryParam> variables = list(likeTo(\"var_a\", false, \"a%\"));\n+        List<QueryParam> attributes = list(likeTo(PROCESS_ATTR_DEFINITION_ID, false, \"%test_A%\"));\n+\n+        List<ProcessInstanceWithVarsDesc> data = advanceVariableDataService.queryProcessByVariables(attributes, variables, queryContext);\n+        if (queryContext.getCount() > 0) {\n+            Assert.assertThat(data.size(), is(queryContext.getCount()));\n+        }\n+\n+        for (ProcessInstanceWithVarsDesc p : data) {\n+            Assert.assertTrue(((String) p.getVariables().get(\"var_a\")).startsWith(\"a\"));\n+            Assert.assertEquals(\"test.test_A\", p.getProcessId());\n+        }\n+    }\n+\n+    @Test\n+    public void testQueryIsNullOperator() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7254bbd4405c29a3f8eb4f1b3967ee8c78cfd26a"}, "originalPosition": 214}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzg5NzYzOQ==", "bodyText": "done", "url": "https://github.com/kiegroup/jbpm/pull/1615#discussion_r407897639", "createdAt": "2020-04-14T06:35:07Z", "author": {"login": "elguardian"}, "path": "jbpm-services/jbpm-kie-services/src/test/java/org/jbpm/kie/services/test/AdvanceRuntimeDataServiceImplTest.java", "diffHunk": "@@ -0,0 +1,348 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.jbpm.kie.services.test;\n+\n+import java.io.File;\n+import java.io.FileOutputStream;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.drools.compiler.kie.builder.impl.InternalKieModule;\n+import org.jbpm.kie.services.impl.KModuleDeploymentUnit;\n+import org.jbpm.kie.test.util.AbstractKieServicesBaseTest;\n+import org.jbpm.services.api.ProcessInstanceNotFoundException;\n+import org.jbpm.services.api.model.DeploymentUnit;\n+import org.jbpm.services.api.model.ProcessInstanceWithVarsDesc;\n+import org.jbpm.services.api.model.UserTaskInstanceWithPotOwnerDesc;\n+import org.jbpm.services.api.query.model.QueryParam;\n+import org.junit.After;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.Parameterized;\n+import org.junit.runners.Parameterized.Parameters;\n+import org.kie.api.KieServices;\n+import org.kie.api.builder.ReleaseId;\n+import org.kie.api.runtime.process.ProcessInstance;\n+import org.kie.internal.query.QueryContext;\n+import org.kie.scanner.KieMavenRepository;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static java.util.Collections.emptyList;\n+import static org.hamcrest.CoreMatchers.is;\n+import static org.jbpm.services.api.AdvanceRuntimeDataService.PROCESS_ATTR_CORRELATION_KEY;\n+import static org.jbpm.services.api.AdvanceRuntimeDataService.PROCESS_ATTR_DEFINITION_ID;\n+import static org.jbpm.services.api.AdvanceRuntimeDataService.PROCESS_ATTR_DEPLOYMENT_ID;\n+import static org.jbpm.services.api.AdvanceRuntimeDataService.TASK_ATTR_NAME;\n+import static org.jbpm.services.api.AdvanceRuntimeDataService.TASK_ATTR_OWNER;\n+import static org.jbpm.services.api.query.model.QueryParam.equalsTo;\n+import static org.jbpm.services.api.query.model.QueryParam.in;\n+import static org.jbpm.services.api.query.model.QueryParam.isNotNull;\n+import static org.jbpm.services.api.query.model.QueryParam.likeTo;\n+import static org.jbpm.services.api.query.model.QueryParam.list;\n+import static org.jbpm.services.api.query.model.QueryParam.notEqualsTo;\n+import static org.jbpm.services.api.query.model.QueryParam.notIn;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertNull;\n+import static org.kie.scanner.KieMavenRepository.getKieMavenRepository;\n+\n+@RunWith(Parameterized.class)\n+public class AdvanceRuntimeDataServiceImplTest extends AbstractKieServicesBaseTest {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(AdvanceRuntimeDataServiceImplTest.class);\n+\n+    @Parameters(name = \"Pagination {0}\")\n+    public static Iterable<? extends Object> data() {\n+        return Arrays.asList(0, 2);\n+    }\n+\n+    private List<DeploymentUnit> units = new ArrayList<DeploymentUnit>();\n+    protected String correctUser = \"testUser\";\n+    protected String wrongUser = \"wrongUser\";\n+\n+    private List<Long> processIds;\n+    private KModuleDeploymentUnit deploymentUnit = null;\n+    private QueryContext queryContext;\n+\n+    public AdvanceRuntimeDataServiceImplTest(Integer count) {\n+        this.queryContext = new QueryContext(0, count);\n+    }\n+\n+    @Before\n+    public void prepare() {\n+\n+        configureServices();\n+        logger.debug(\"Preparing kjar\");\n+        KieServices ks = KieServices.Factory.get();\n+        ReleaseId releaseId = ks.newReleaseId(GROUP_ID, ARTIFACT_ID, VERSION);\n+        List<String> processes = new ArrayList<String>();\n+        processes.add(\"repo/processes/general/SingleHumanTaskWithVarsA.bpmn2\");\n+        processes.add(\"repo/processes/general/SingleHumanTaskWithVarsB.bpmn2\");\n+\n+        InternalKieModule kJar1 = createKieJar(ks, releaseId, processes);\n+        File pom = new File(\"target/kmodule\", \"pom.xml\");\n+        pom.getParentFile().mkdir();\n+        try (FileOutputStream fs = new FileOutputStream(pom);) {\n+            fs.write(getPom(releaseId).getBytes());\n+        } catch (Exception e) {\n+\n+        }\n+        KieMavenRepository repository = getKieMavenRepository();\n+        repository.deployArtifact(releaseId, kJar1, pom);\n+\n+        assertNotNull(deploymentService);\n+\n+        deploymentUnit = new KModuleDeploymentUnit(GROUP_ID, ARTIFACT_ID, VERSION);\n+\n+        deploymentService.deploy(deploymentUnit);\n+        units.add(deploymentUnit);\n+        assertNotNull(processService);\n+\n+        processIds = new ArrayList<>();\n+        for (int i = 0; i < 10; i++) {\n+            Map<String, Object> inputsA1 = new HashMap<>();\n+            inputsA1.put(\"var_a\", \"a\" + (i % 3));\n+            inputsA1.put(\"var_b\", (i % 3));\n+            processIds.add(processService.startProcess(deploymentUnit.getIdentifier(), \"test.test_A\", inputsA1));\n+        }\n+        for (int i = 0; i < 10; i++) {\n+            Map<String, Object> inputsB1 = new HashMap<>();\n+            inputsB1.put(\"var_a\", \"b\" + (i % 3));\n+            inputsB1.put(\"var_b\", (i % 3));\n+            processIds.add(processService.startProcess(deploymentUnit.getIdentifier(), \"test.test_B\", inputsB1));\n+        }\n+    }\n+\n+    @After\n+    public void cleanup() {\n+        for (Long processInstanceId : processIds) {\n+            try {\n+                // let's abort process instance to leave the system in clear state\n+                processService.abortProcessInstance(processInstanceId);\n+\n+                ProcessInstance pi = processService.getProcessInstance(processInstanceId);\n+                assertNull(pi);\n+            } catch (ProcessInstanceNotFoundException e) {\n+                // ignore it as it was already completed/aborted\n+            }\n+        }\n+        cleanupSingletonSessionId();\n+        if (units != null && !units.isEmpty()) {\n+            for (DeploymentUnit unit : units) {\n+                try {\n+                    deploymentService.undeploy(unit);\n+                } catch (Exception e) {\n+                    // do nothing in case of some failed tests to avoid next test to fail as well\n+                }\n+            }\n+            units.clear();\n+        }\n+        close();\n+    }\n+\n+    @Test\n+    public void testQueryProcessByVariables() {\n+        List<QueryParam> variables = list(equalsTo(\"var_a\", \"a1\"), equalsTo(\"var_b\", \"1\"));\n+        List<QueryParam> attributes = list(equalsTo(PROCESS_ATTR_DEFINITION_ID, \"test.test_A\"));\n+\n+        List<ProcessInstanceWithVarsDesc> data = advanceVariableDataService.queryProcessByVariables(attributes, variables, queryContext);\n+        if (queryContext.getCount() > 0) {\n+            Assert.assertThat(data.size(), is(queryContext.getCount()));\n+        }\n+        for (ProcessInstanceWithVarsDesc p : data) {\n+            Assert.assertEquals(\"a1\", p.getVariables().get(\"var_a\"));\n+            Assert.assertEquals(\"1\", p.getVariables().get(\"var_b\"));\n+            Assert.assertEquals(\"test.test_A\", p.getProcessId());\n+        }\n+    }\n+\n+    @Test\n+    public void testQueryInOperator() {\n+\n+        List<QueryParam> variables = list(in(\"var_a\", \"a1\", \"a2\"));\n+        List<QueryParam> attributes = list(equalsTo(PROCESS_ATTR_DEFINITION_ID, \"test.test_A\"));\n+\n+        List<ProcessInstanceWithVarsDesc> data = advanceVariableDataService.queryProcessByVariables(attributes, variables, queryContext);\n+        if (queryContext.getCount() > 0) {\n+            Assert.assertThat(data.size(), is(queryContext.getCount()));\n+        }\n+        List<String> values = Arrays.asList(\"a1\", \"a2\");\n+        for (ProcessInstanceWithVarsDesc p : data) {\n+            Assert.assertTrue(values.contains(p.getVariables().get(\"var_a\")));\n+            Assert.assertEquals(\"test.test_A\", p.getProcessId());\n+        }\n+    }\n+\n+    @Test\n+    public void testQueryLikeToOperator() {\n+\n+        List<QueryParam> variables = list(likeTo(\"var_a\", false, \"a%\"));\n+        List<QueryParam> attributes = list(likeTo(PROCESS_ATTR_DEFINITION_ID, false, \"%test_A%\"));\n+\n+        List<ProcessInstanceWithVarsDesc> data = advanceVariableDataService.queryProcessByVariables(attributes, variables, queryContext);\n+        if (queryContext.getCount() > 0) {\n+            Assert.assertThat(data.size(), is(queryContext.getCount()));\n+        }\n+\n+        for (ProcessInstanceWithVarsDesc p : data) {\n+            Assert.assertTrue(((String) p.getVariables().get(\"var_a\")).startsWith(\"a\"));\n+            Assert.assertEquals(\"test.test_A\", p.getProcessId());\n+        }\n+    }\n+\n+    @Test\n+    public void testQueryIsNullOperator() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzQyODUxMw=="}, "originalCommit": {"oid": "7254bbd4405c29a3f8eb4f1b3967ee8c78cfd26a"}, "originalPosition": 214}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUyOTMxMTEzOnYy", "diffSide": "RIGHT", "path": "jbpm-services/jbpm-kie-services/src/main/resources/META-INF/Servicesorm.xml", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xM1QxMToyMzowNlrOGEj2Gg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNFQwNjozNToxNlrOGFAGZg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzQzNDc3OA==", "bodyText": "typo? (Get)", "url": "https://github.com/kiegroup/jbpm/pull/1615#discussion_r407434778", "createdAt": "2020-04-13T11:23:06Z", "author": {"login": "gmunozfe"}, "path": "jbpm-services/jbpm-kie-services/src/main/resources/META-INF/Servicesorm.xml", "diffHunk": "@@ -1182,5 +1182,71 @@\n     </query>\n     <!-- hint name=\"org.hibernate.timeout\" value=\"200\"/ -->\n   </named-query>   \n-        \n+\n+\n+  <!-- advance runtime queries -->\n+  <named-native-query name=\"GeProcessInstanceByIdList\">", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7254bbd4405c29a3f8eb4f1b3967ee8c78cfd26a"}, "originalPosition": 8}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzg5NzcwMg==", "bodyText": "done", "url": "https://github.com/kiegroup/jbpm/pull/1615#discussion_r407897702", "createdAt": "2020-04-14T06:35:16Z", "author": {"login": "elguardian"}, "path": "jbpm-services/jbpm-kie-services/src/main/resources/META-INF/Servicesorm.xml", "diffHunk": "@@ -1182,5 +1182,71 @@\n     </query>\n     <!-- hint name=\"org.hibernate.timeout\" value=\"200\"/ -->\n   </named-query>   \n-        \n+\n+\n+  <!-- advance runtime queries -->\n+  <named-native-query name=\"GeProcessInstanceByIdList\">", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzQzNDc3OA=="}, "originalCommit": {"oid": "7254bbd4405c29a3f8eb4f1b3967ee8c78cfd26a"}, "originalPosition": 8}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUyOTMxMTYzOnYy", "diffSide": "RIGHT", "path": "jbpm-services/jbpm-kie-services/src/main/resources/META-INF/Servicesorm.xml", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xM1QxMToyMzoyMlrOGEj2WA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xM1QxMToyMzoyMlrOGEj2WA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzQzNDg0MA==", "bodyText": "typo? (Get)", "url": "https://github.com/kiegroup/jbpm/pull/1615#discussion_r407434840", "createdAt": "2020-04-13T11:23:22Z", "author": {"login": "gmunozfe"}, "path": "jbpm-services/jbpm-kie-services/src/main/resources/META-INF/Servicesorm.xml", "diffHunk": "@@ -1182,5 +1182,71 @@\n     </query>\n     <!-- hint name=\"org.hibernate.timeout\" value=\"200\"/ -->\n   </named-query>   \n-        \n+\n+\n+  <!-- advance runtime queries -->\n+  <named-native-query name=\"GeProcessInstanceByIdList\">\n+      <query>\n+        SELECT processInstanceId, processId, processName, processVersion, status, externalId, start_date, user_identity, correlationKey \n+          FROM ProcessInstanceLog pil \n+         WHERE processInstanceId IN (:idList) \n+      ORDER BY processInstanceId ASC \n+    </query>\n+  </named-native-query>\n+  \n+  <named-native-query name=\"GeVariablesByProcessInstanceIdList\">", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7254bbd4405c29a3f8eb4f1b3967ee8c78cfd26a"}, "originalPosition": 17}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUzMzQ1MjQwOnYy", "diffSide": "RIGHT", "path": "jbpm-services/jbpm-services-api/src/main/java/org/jbpm/services/api/AdvanceRuntimeDataService.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNFQxMTo1MTozOFrOGFK92w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xN1QwNzowMzowM1rOGHCO2w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODA3NTczOQ==", "bodyText": "Deployment ID is not specified in the jira ticket. We should either update jira ticket or remove this field. What do you think @elguardian?", "url": "https://github.com/kiegroup/jbpm/pull/1615#discussion_r408075739", "createdAt": "2020-04-14T11:51:38Z", "author": {"login": "afalhambra"}, "path": "jbpm-services/jbpm-services-api/src/main/java/org/jbpm/services/api/AdvanceRuntimeDataService.java", "diffHunk": "@@ -0,0 +1,39 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.jbpm.services.api;\n+\n+import java.util.List;\n+\n+import org.jbpm.services.api.model.ProcessInstanceWithVarsDesc;\n+import org.jbpm.services.api.model.UserTaskInstanceWithPotOwnerDesc;\n+import org.jbpm.services.api.query.model.QueryParam;\n+import org.kie.api.runtime.query.QueryContext;\n+\n+public interface AdvanceRuntimeDataService {\n+\n+    public static String TASK_ATTR_NAME = \"TASK_NAME\";\n+    public static String TASK_ATTR_OWNER = \"TASK_OWNER\";\n+    public static String PROCESS_ATTR_INSTANCE_ID = \"PROCESS_INSTANCE_ID\";\n+    public static String PROCESS_ATTR_CORRELATION_KEY = \"PROCESS_CORRELATION_KEY\";\n+    public static String PROCESS_ATTR_DEFINITION_ID = \"PROCESS_DEFINITION_ID\";\n+    public static String PROCESS_ATTR_DEPLOYMENT_ID = \"PROCESS_DEPLOYMENT_ID\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f04f50355ec285330b3467d42754a036a04b1db3"}, "originalPosition": 33}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDAyOTc4Nw==", "bodyText": "nope. It is convenient to shrink the results (performance)", "url": "https://github.com/kiegroup/jbpm/pull/1615#discussion_r410029787", "createdAt": "2020-04-17T07:03:03Z", "author": {"login": "elguardian"}, "path": "jbpm-services/jbpm-services-api/src/main/java/org/jbpm/services/api/AdvanceRuntimeDataService.java", "diffHunk": "@@ -0,0 +1,39 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.jbpm.services.api;\n+\n+import java.util.List;\n+\n+import org.jbpm.services.api.model.ProcessInstanceWithVarsDesc;\n+import org.jbpm.services.api.model.UserTaskInstanceWithPotOwnerDesc;\n+import org.jbpm.services.api.query.model.QueryParam;\n+import org.kie.api.runtime.query.QueryContext;\n+\n+public interface AdvanceRuntimeDataService {\n+\n+    public static String TASK_ATTR_NAME = \"TASK_NAME\";\n+    public static String TASK_ATTR_OWNER = \"TASK_OWNER\";\n+    public static String PROCESS_ATTR_INSTANCE_ID = \"PROCESS_INSTANCE_ID\";\n+    public static String PROCESS_ATTR_CORRELATION_KEY = \"PROCESS_CORRELATION_KEY\";\n+    public static String PROCESS_ATTR_DEFINITION_ID = \"PROCESS_DEFINITION_ID\";\n+    public static String PROCESS_ATTR_DEPLOYMENT_ID = \"PROCESS_DEPLOYMENT_ID\";", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODA3NTczOQ=="}, "originalCommit": {"oid": "f04f50355ec285330b3467d42754a036a04b1db3"}, "originalPosition": 33}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUzMzUxNzU5OnYy", "diffSide": "RIGHT", "path": "jbpm-case-mgmt/jbpm-case-mgmt-api/src/main/java/org/jbpm/casemgmt/api/AdvanceCaseRuntimeDataService.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNFQxMjoxMDozOVrOGFLlbg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xN1QwNzowMzozM1rOGHCPuA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODA4NTg3MA==", "bodyText": "Would it make sense to rename it to caseVariables rather than processVariables?", "url": "https://github.com/kiegroup/jbpm/pull/1615#discussion_r408085870", "createdAt": "2020-04-14T12:10:39Z", "author": {"login": "afalhambra"}, "path": "jbpm-case-mgmt/jbpm-case-mgmt-api/src/main/java/org/jbpm/casemgmt/api/AdvanceCaseRuntimeDataService.java", "diffHunk": "@@ -0,0 +1,45 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.jbpm.casemgmt.api;\n+\n+import java.util.List;\n+\n+import org.jbpm.services.api.model.ProcessInstanceWithVarsDesc;\n+import org.jbpm.services.api.model.UserTaskInstanceWithPotOwnerDesc;\n+import org.jbpm.services.api.query.model.QueryParam;\n+import org.kie.api.runtime.query.QueryContext;\n+\n+public interface AdvanceCaseRuntimeDataService {\n+\n+    public static String TASK_ATTR_NAME = \"TASK_NAME\";\n+    public static String TASK_ATTR_OWNER = \"TASK_OWNER\";\n+    public static String CASE_ATTR_INSTANCE_ID = \"PROCESS_INSTANCE_ID\";\n+    public static String CASE_ATTR_CORRELATION_KEY = \"PROCESS_CORRELATION_KEY\";\n+    public static String CASE_ATTR_DEFINITION_ID = \"PROCESS_DEFINITION_ID\";\n+    public static String CASE_ATTR_DEPLOYMENT_ID = \"PROCESS_DEPLOYMENT_ID\";\n+\n+    List<ProcessInstanceWithVarsDesc> queryCaseByVariables(List<QueryParam> attributes,\n+                                                           List<QueryParam> variables,\n+                                                           QueryContext queryContext);\n+\n+    List<UserTaskInstanceWithPotOwnerDesc> queryUserTasksByVariables(List<QueryParam> attributes,\n+                                                                     List<QueryParam> variables,\n+                                                                     List<QueryParam> processVariables,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f04f50355ec285330b3467d42754a036a04b1db3"}, "originalPosition": 41}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDAzMDAwOA==", "bodyText": "well the main entity here is the user tasks not really the process.", "url": "https://github.com/kiegroup/jbpm/pull/1615#discussion_r410030008", "createdAt": "2020-04-17T07:03:33Z", "author": {"login": "elguardian"}, "path": "jbpm-case-mgmt/jbpm-case-mgmt-api/src/main/java/org/jbpm/casemgmt/api/AdvanceCaseRuntimeDataService.java", "diffHunk": "@@ -0,0 +1,45 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.jbpm.casemgmt.api;\n+\n+import java.util.List;\n+\n+import org.jbpm.services.api.model.ProcessInstanceWithVarsDesc;\n+import org.jbpm.services.api.model.UserTaskInstanceWithPotOwnerDesc;\n+import org.jbpm.services.api.query.model.QueryParam;\n+import org.kie.api.runtime.query.QueryContext;\n+\n+public interface AdvanceCaseRuntimeDataService {\n+\n+    public static String TASK_ATTR_NAME = \"TASK_NAME\";\n+    public static String TASK_ATTR_OWNER = \"TASK_OWNER\";\n+    public static String CASE_ATTR_INSTANCE_ID = \"PROCESS_INSTANCE_ID\";\n+    public static String CASE_ATTR_CORRELATION_KEY = \"PROCESS_CORRELATION_KEY\";\n+    public static String CASE_ATTR_DEFINITION_ID = \"PROCESS_DEFINITION_ID\";\n+    public static String CASE_ATTR_DEPLOYMENT_ID = \"PROCESS_DEPLOYMENT_ID\";\n+\n+    List<ProcessInstanceWithVarsDesc> queryCaseByVariables(List<QueryParam> attributes,\n+                                                           List<QueryParam> variables,\n+                                                           QueryContext queryContext);\n+\n+    List<UserTaskInstanceWithPotOwnerDesc> queryUserTasksByVariables(List<QueryParam> attributes,\n+                                                                     List<QueryParam> variables,\n+                                                                     List<QueryParam> processVariables,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODA4NTg3MA=="}, "originalCommit": {"oid": "f04f50355ec285330b3467d42754a036a04b1db3"}, "originalPosition": 41}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUzMzUyNTE3OnYy", "diffSide": "RIGHT", "path": "jbpm-case-mgmt/jbpm-case-mgmt-api/src/main/java/org/jbpm/casemgmt/api/AdvanceCaseRuntimeDataService.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNFQxMjoxMjo1NlrOGFLqZA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xN1QwNzowMzo0NlrOGHCQJw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODA4NzE0MA==", "bodyText": "Deployment ID is not specified in the jira ticket. We should either update jira ticket or remove this field. What do you think @elguardian?", "url": "https://github.com/kiegroup/jbpm/pull/1615#discussion_r408087140", "createdAt": "2020-04-14T12:12:56Z", "author": {"login": "afalhambra"}, "path": "jbpm-case-mgmt/jbpm-case-mgmt-api/src/main/java/org/jbpm/casemgmt/api/AdvanceCaseRuntimeDataService.java", "diffHunk": "@@ -0,0 +1,45 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.jbpm.casemgmt.api;\n+\n+import java.util.List;\n+\n+import org.jbpm.services.api.model.ProcessInstanceWithVarsDesc;\n+import org.jbpm.services.api.model.UserTaskInstanceWithPotOwnerDesc;\n+import org.jbpm.services.api.query.model.QueryParam;\n+import org.kie.api.runtime.query.QueryContext;\n+\n+public interface AdvanceCaseRuntimeDataService {\n+\n+    public static String TASK_ATTR_NAME = \"TASK_NAME\";\n+    public static String TASK_ATTR_OWNER = \"TASK_OWNER\";\n+    public static String CASE_ATTR_INSTANCE_ID = \"PROCESS_INSTANCE_ID\";\n+    public static String CASE_ATTR_CORRELATION_KEY = \"PROCESS_CORRELATION_KEY\";\n+    public static String CASE_ATTR_DEFINITION_ID = \"PROCESS_DEFINITION_ID\";\n+    public static String CASE_ATTR_DEPLOYMENT_ID = \"PROCESS_DEPLOYMENT_ID\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f04f50355ec285330b3467d42754a036a04b1db3"}, "originalPosition": 33}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDAzMDExOQ==", "bodyText": "it is convenient.", "url": "https://github.com/kiegroup/jbpm/pull/1615#discussion_r410030119", "createdAt": "2020-04-17T07:03:46Z", "author": {"login": "elguardian"}, "path": "jbpm-case-mgmt/jbpm-case-mgmt-api/src/main/java/org/jbpm/casemgmt/api/AdvanceCaseRuntimeDataService.java", "diffHunk": "@@ -0,0 +1,45 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.jbpm.casemgmt.api;\n+\n+import java.util.List;\n+\n+import org.jbpm.services.api.model.ProcessInstanceWithVarsDesc;\n+import org.jbpm.services.api.model.UserTaskInstanceWithPotOwnerDesc;\n+import org.jbpm.services.api.query.model.QueryParam;\n+import org.kie.api.runtime.query.QueryContext;\n+\n+public interface AdvanceCaseRuntimeDataService {\n+\n+    public static String TASK_ATTR_NAME = \"TASK_NAME\";\n+    public static String TASK_ATTR_OWNER = \"TASK_OWNER\";\n+    public static String CASE_ATTR_INSTANCE_ID = \"PROCESS_INSTANCE_ID\";\n+    public static String CASE_ATTR_CORRELATION_KEY = \"PROCESS_CORRELATION_KEY\";\n+    public static String CASE_ATTR_DEFINITION_ID = \"PROCESS_DEFINITION_ID\";\n+    public static String CASE_ATTR_DEPLOYMENT_ID = \"PROCESS_DEPLOYMENT_ID\";", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODA4NzE0MA=="}, "originalCommit": {"oid": "f04f50355ec285330b3467d42754a036a04b1db3"}, "originalPosition": 33}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUzMzUzMDA3OnYy", "diffSide": "RIGHT", "path": "jbpm-case-mgmt/jbpm-case-mgmt-impl/src/main/java/org/jbpm/casemgmt/impl/AdvanceCaseRuntimeDataServiceImpl.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNFQxMjoxNDoyNVrOGFLtdA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQwODo1ODo0MlrOGIKTiA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODA4NzkyNA==", "bodyText": "Would it make sense to declare translateTable as final?", "url": "https://github.com/kiegroup/jbpm/pull/1615#discussion_r408087924", "createdAt": "2020-04-14T12:14:25Z", "author": {"login": "afalhambra"}, "path": "jbpm-case-mgmt/jbpm-case-mgmt-impl/src/main/java/org/jbpm/casemgmt/impl/AdvanceCaseRuntimeDataServiceImpl.java", "diffHunk": "@@ -0,0 +1,65 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.jbpm.casemgmt.impl;\n+\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.jbpm.casemgmt.api.AdvanceCaseRuntimeDataService;\n+import org.jbpm.kie.services.impl.AbstractAdvanceRuntimeDataServiceImpl;\n+import org.jbpm.services.api.query.model.QueryParam;\n+import org.kie.api.runtime.query.QueryContext;\n+\n+import static org.jbpm.process.core.context.variable.VariableScope.CASE_FILE_PREFIX;\n+import static org.jbpm.workflow.core.WorkflowProcess.CASE_TYPE;\n+\n+public class AdvanceCaseRuntimeDataServiceImpl extends AbstractAdvanceRuntimeDataServiceImpl implements AdvanceCaseRuntimeDataService {\n+\n+    private Map<String, String> translateTable = new HashMap<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f04f50355ec285330b3467d42754a036a04b1db3"}, "originalPosition": 33}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTIxMDYzMg==", "bodyText": "ok", "url": "https://github.com/kiegroup/jbpm/pull/1615#discussion_r411210632", "createdAt": "2020-04-20T08:58:42Z", "author": {"login": "elguardian"}, "path": "jbpm-case-mgmt/jbpm-case-mgmt-impl/src/main/java/org/jbpm/casemgmt/impl/AdvanceCaseRuntimeDataServiceImpl.java", "diffHunk": "@@ -0,0 +1,65 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.jbpm.casemgmt.impl;\n+\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.jbpm.casemgmt.api.AdvanceCaseRuntimeDataService;\n+import org.jbpm.kie.services.impl.AbstractAdvanceRuntimeDataServiceImpl;\n+import org.jbpm.services.api.query.model.QueryParam;\n+import org.kie.api.runtime.query.QueryContext;\n+\n+import static org.jbpm.process.core.context.variable.VariableScope.CASE_FILE_PREFIX;\n+import static org.jbpm.workflow.core.WorkflowProcess.CASE_TYPE;\n+\n+public class AdvanceCaseRuntimeDataServiceImpl extends AbstractAdvanceRuntimeDataServiceImpl implements AdvanceCaseRuntimeDataService {\n+\n+    private Map<String, String> translateTable = new HashMap<>();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODA4NzkyNA=="}, "originalCommit": {"oid": "f04f50355ec285330b3467d42754a036a04b1db3"}, "originalPosition": 33}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUzMzUzMzQwOnYy", "diffSide": "RIGHT", "path": "jbpm-case-mgmt/jbpm-case-mgmt-impl/src/main/java/org/jbpm/casemgmt/impl/AdvanceCaseRuntimeDataServiceImpl.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNFQxMjoxNToyM1rOGFLvfg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQwODo1OToyNFrOGIKVrA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODA4ODQ0Ng==", "bodyText": "Would it make sense to rename it to caseVariables rather than processVariables?", "url": "https://github.com/kiegroup/jbpm/pull/1615#discussion_r408088446", "createdAt": "2020-04-14T12:15:23Z", "author": {"login": "afalhambra"}, "path": "jbpm-case-mgmt/jbpm-case-mgmt-impl/src/main/java/org/jbpm/casemgmt/impl/AdvanceCaseRuntimeDataServiceImpl.java", "diffHunk": "@@ -0,0 +1,65 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.jbpm.casemgmt.impl;\n+\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.jbpm.casemgmt.api.AdvanceCaseRuntimeDataService;\n+import org.jbpm.kie.services.impl.AbstractAdvanceRuntimeDataServiceImpl;\n+import org.jbpm.services.api.query.model.QueryParam;\n+import org.kie.api.runtime.query.QueryContext;\n+\n+import static org.jbpm.process.core.context.variable.VariableScope.CASE_FILE_PREFIX;\n+import static org.jbpm.workflow.core.WorkflowProcess.CASE_TYPE;\n+\n+public class AdvanceCaseRuntimeDataServiceImpl extends AbstractAdvanceRuntimeDataServiceImpl implements AdvanceCaseRuntimeDataService {\n+\n+    private Map<String, String> translateTable = new HashMap<>();\n+\n+    public AdvanceCaseRuntimeDataServiceImpl() {\n+        translateTable.put(CASE_ATTR_CORRELATION_KEY, \"pil.correlationKey\");\n+        translateTable.put(CASE_ATTR_DEFINITION_ID, \"pil.processId\");\n+        translateTable.put(CASE_ATTR_INSTANCE_ID, \"pil.processInstanceId\");\n+        translateTable.put(CASE_ATTR_DEPLOYMENT_ID, \"pil.externalId\");\n+        translateTable.put(TASK_ATTR_NAME, \"task.name\");\n+        translateTable.put(TASK_ATTR_OWNER, \"task.actualOwner_id\");\n+\n+    }\n+\n+    @Override\n+    public List<org.jbpm.services.api.model.ProcessInstanceWithVarsDesc> queryCaseByVariables(List<QueryParam> attributes,\n+                                                                                              List<QueryParam> variables,\n+                                                                                              QueryContext queryContext) {\n+        return queryProcessByVariables(translate(translateTable, attributes), variables, CASE_TYPE, CASE_FILE_PREFIX, queryContext);\n+\n+    }\n+\n+\n+    @Override\n+    public List<org.jbpm.services.api.model.UserTaskInstanceWithPotOwnerDesc> queryUserTasksByVariables(List<QueryParam> attributes,\n+                                                                                                        List<QueryParam> variables,\n+                                                                                                        List<QueryParam> processVariables,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f04f50355ec285330b3467d42754a036a04b1db3"}, "originalPosition": 57}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTIxMTE4MA==", "bodyText": "ok", "url": "https://github.com/kiegroup/jbpm/pull/1615#discussion_r411211180", "createdAt": "2020-04-20T08:59:24Z", "author": {"login": "elguardian"}, "path": "jbpm-case-mgmt/jbpm-case-mgmt-impl/src/main/java/org/jbpm/casemgmt/impl/AdvanceCaseRuntimeDataServiceImpl.java", "diffHunk": "@@ -0,0 +1,65 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.jbpm.casemgmt.impl;\n+\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.jbpm.casemgmt.api.AdvanceCaseRuntimeDataService;\n+import org.jbpm.kie.services.impl.AbstractAdvanceRuntimeDataServiceImpl;\n+import org.jbpm.services.api.query.model.QueryParam;\n+import org.kie.api.runtime.query.QueryContext;\n+\n+import static org.jbpm.process.core.context.variable.VariableScope.CASE_FILE_PREFIX;\n+import static org.jbpm.workflow.core.WorkflowProcess.CASE_TYPE;\n+\n+public class AdvanceCaseRuntimeDataServiceImpl extends AbstractAdvanceRuntimeDataServiceImpl implements AdvanceCaseRuntimeDataService {\n+\n+    private Map<String, String> translateTable = new HashMap<>();\n+\n+    public AdvanceCaseRuntimeDataServiceImpl() {\n+        translateTable.put(CASE_ATTR_CORRELATION_KEY, \"pil.correlationKey\");\n+        translateTable.put(CASE_ATTR_DEFINITION_ID, \"pil.processId\");\n+        translateTable.put(CASE_ATTR_INSTANCE_ID, \"pil.processInstanceId\");\n+        translateTable.put(CASE_ATTR_DEPLOYMENT_ID, \"pil.externalId\");\n+        translateTable.put(TASK_ATTR_NAME, \"task.name\");\n+        translateTable.put(TASK_ATTR_OWNER, \"task.actualOwner_id\");\n+\n+    }\n+\n+    @Override\n+    public List<org.jbpm.services.api.model.ProcessInstanceWithVarsDesc> queryCaseByVariables(List<QueryParam> attributes,\n+                                                                                              List<QueryParam> variables,\n+                                                                                              QueryContext queryContext) {\n+        return queryProcessByVariables(translate(translateTable, attributes), variables, CASE_TYPE, CASE_FILE_PREFIX, queryContext);\n+\n+    }\n+\n+\n+    @Override\n+    public List<org.jbpm.services.api.model.UserTaskInstanceWithPotOwnerDesc> queryUserTasksByVariables(List<QueryParam> attributes,\n+                                                                                                        List<QueryParam> variables,\n+                                                                                                        List<QueryParam> processVariables,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODA4ODQ0Ng=="}, "originalCommit": {"oid": "f04f50355ec285330b3467d42754a036a04b1db3"}, "originalPosition": 57}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUzMzc4MDg5OnYy", "diffSide": "RIGHT", "path": "jbpm-case-mgmt/jbpm-case-mgmt-impl/src/test/java/org/jbpm/casemgmt/impl/AdvanceCaseRuntimeDataServiceImplTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNFQxMzoxNjo1MlrOGFOH4g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQwOTowMDozMlrOGIKY5w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODEyNzQ1OA==", "bodyText": "I would expect to pass variable data and owners as part of the query criteria in this call.", "url": "https://github.com/kiegroup/jbpm/pull/1615#discussion_r408127458", "createdAt": "2020-04-14T13:16:52Z", "author": {"login": "afalhambra"}, "path": "jbpm-case-mgmt/jbpm-case-mgmt-impl/src/test/java/org/jbpm/casemgmt/impl/AdvanceCaseRuntimeDataServiceImplTest.java", "diffHunk": "@@ -0,0 +1,96 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.jbpm.casemgmt.impl;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.jbpm.casemgmt.api.model.instance.CaseFileInstance;\n+import org.jbpm.casemgmt.impl.util.AbstractCaseServicesBaseTest;\n+import org.jbpm.services.api.model.ProcessInstanceWithVarsDesc;\n+import org.jbpm.services.api.model.UserTaskInstanceWithPotOwnerDesc;\n+import org.jbpm.services.api.query.model.QueryParam;\n+import org.jbpm.services.task.impl.model.UserImpl;\n+import org.junit.Test;\n+import org.kie.api.runtime.query.QueryContext;\n+import org.kie.api.task.model.OrganizationalEntity;\n+\n+import static java.util.Collections.emptyList;\n+import static org.jbpm.services.api.query.model.QueryParam.equalsTo;\n+import static org.jbpm.services.api.query.model.QueryParam.list;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNotNull;\n+\n+public class AdvanceCaseRuntimeDataServiceImplTest extends AbstractCaseServicesBaseTest {\n+\n+\n+    @Override\n+    protected List<String> getProcessDefinitionFiles() {\n+        List<String> processes = new ArrayList<String>();\n+        processes.add(\"cases/EmptyCase.bpmn2\");\n+        processes.add(\"cases/UserTaskCase.bpmn2\");\n+        return processes;\n+    }\n+\n+    /*\n+     * Case instance queries\n+     */\n+    @Test\n+    public void testSearchByVariable() {\n+        Map<String, Object> data = new HashMap<>();\n+        data.put(\"name\", \"my first case\");\n+\n+        CaseFileInstance caseFile = caseService.newCaseFileInstance(deploymentUnit.getIdentifier(), EMPTY_CASE_P_ID, data);\n+\n+        String caseId = caseService.startCase(deploymentUnit.getIdentifier(), EMPTY_CASE_P_ID, caseFile);\n+\n+        List<QueryParam> vars = list(equalsTo(\"name\", \"my first case\"));\n+\n+        List<ProcessInstanceWithVarsDesc> process = advanceCaseRuntimeDataService.queryCaseByVariables(emptyList(), vars, new QueryContext());\n+        assertEquals(1, process.size());\n+        assertEquals(\"my first case\", process.get(0).getExtraData().get(\"name\"));\n+\n+        assertNotNull(caseId);\n+        assertEquals(FIRST_CASE_ID, caseId);\n+        caseService.cancelCase(caseId);\n+\n+    }\n+\n+    @Test\n+    public void testSearchUserByVariable() {\n+        Map<String, OrganizationalEntity> roleAssignments = new HashMap<>();\n+        roleAssignments.put(\"owner\", new UserImpl(USER));\n+\n+        Map<String, Object> data = new HashMap<>();\n+        data.put(\"name\", \"my first case\");\n+        CaseFileInstance caseFile = caseService.newCaseFileInstance(deploymentUnit.getIdentifier(), USER_TASK_CASE_P_ID, data, roleAssignments);\n+\n+        String caseId = caseService.startCase(deploymentUnit.getIdentifier(), USER_TASK_CASE_P_ID, caseFile);\n+\n+        List<UserTaskInstanceWithPotOwnerDesc> process = advanceCaseRuntimeDataService.queryUserTasksByVariables(emptyList(), emptyList(), emptyList(), emptyList(), new QueryContext());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f04f50355ec285330b3467d42754a036a04b1db3"}, "originalPosition": 86}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTIxMjAwNw==", "bodyText": "well that is test already in other integration test.", "url": "https://github.com/kiegroup/jbpm/pull/1615#discussion_r411212007", "createdAt": "2020-04-20T09:00:32Z", "author": {"login": "elguardian"}, "path": "jbpm-case-mgmt/jbpm-case-mgmt-impl/src/test/java/org/jbpm/casemgmt/impl/AdvanceCaseRuntimeDataServiceImplTest.java", "diffHunk": "@@ -0,0 +1,96 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.jbpm.casemgmt.impl;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.jbpm.casemgmt.api.model.instance.CaseFileInstance;\n+import org.jbpm.casemgmt.impl.util.AbstractCaseServicesBaseTest;\n+import org.jbpm.services.api.model.ProcessInstanceWithVarsDesc;\n+import org.jbpm.services.api.model.UserTaskInstanceWithPotOwnerDesc;\n+import org.jbpm.services.api.query.model.QueryParam;\n+import org.jbpm.services.task.impl.model.UserImpl;\n+import org.junit.Test;\n+import org.kie.api.runtime.query.QueryContext;\n+import org.kie.api.task.model.OrganizationalEntity;\n+\n+import static java.util.Collections.emptyList;\n+import static org.jbpm.services.api.query.model.QueryParam.equalsTo;\n+import static org.jbpm.services.api.query.model.QueryParam.list;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNotNull;\n+\n+public class AdvanceCaseRuntimeDataServiceImplTest extends AbstractCaseServicesBaseTest {\n+\n+\n+    @Override\n+    protected List<String> getProcessDefinitionFiles() {\n+        List<String> processes = new ArrayList<String>();\n+        processes.add(\"cases/EmptyCase.bpmn2\");\n+        processes.add(\"cases/UserTaskCase.bpmn2\");\n+        return processes;\n+    }\n+\n+    /*\n+     * Case instance queries\n+     */\n+    @Test\n+    public void testSearchByVariable() {\n+        Map<String, Object> data = new HashMap<>();\n+        data.put(\"name\", \"my first case\");\n+\n+        CaseFileInstance caseFile = caseService.newCaseFileInstance(deploymentUnit.getIdentifier(), EMPTY_CASE_P_ID, data);\n+\n+        String caseId = caseService.startCase(deploymentUnit.getIdentifier(), EMPTY_CASE_P_ID, caseFile);\n+\n+        List<QueryParam> vars = list(equalsTo(\"name\", \"my first case\"));\n+\n+        List<ProcessInstanceWithVarsDesc> process = advanceCaseRuntimeDataService.queryCaseByVariables(emptyList(), vars, new QueryContext());\n+        assertEquals(1, process.size());\n+        assertEquals(\"my first case\", process.get(0).getExtraData().get(\"name\"));\n+\n+        assertNotNull(caseId);\n+        assertEquals(FIRST_CASE_ID, caseId);\n+        caseService.cancelCase(caseId);\n+\n+    }\n+\n+    @Test\n+    public void testSearchUserByVariable() {\n+        Map<String, OrganizationalEntity> roleAssignments = new HashMap<>();\n+        roleAssignments.put(\"owner\", new UserImpl(USER));\n+\n+        Map<String, Object> data = new HashMap<>();\n+        data.put(\"name\", \"my first case\");\n+        CaseFileInstance caseFile = caseService.newCaseFileInstance(deploymentUnit.getIdentifier(), USER_TASK_CASE_P_ID, data, roleAssignments);\n+\n+        String caseId = caseService.startCase(deploymentUnit.getIdentifier(), USER_TASK_CASE_P_ID, caseFile);\n+\n+        List<UserTaskInstanceWithPotOwnerDesc> process = advanceCaseRuntimeDataService.queryUserTasksByVariables(emptyList(), emptyList(), emptyList(), emptyList(), new QueryContext());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODEyNzQ1OA=="}, "originalCommit": {"oid": "f04f50355ec285330b3467d42754a036a04b1db3"}, "originalPosition": 86}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUzMzc4NjgwOnYy", "diffSide": "RIGHT", "path": "jbpm-case-mgmt/jbpm-case-mgmt-impl/src/test/java/org/jbpm/casemgmt/impl/AdvanceCaseRuntimeDataServiceImplTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNFQxMzoxODoxNVrOGFOLkQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQwOTowMToxMlrOGIKagA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODEyODQwMQ==", "bodyText": "For case and casetasks I would be missing some tests regarding to the requirements we have. So far we are currently testing:\nPotential owner\t\u2718\t\u2718\t\u2713\t\u2713\tFilters by task potential owner (in case of more than one, all must match)\nCase File Var\t\u2713\t\u2718\t\u2713\t\u2718\tFilter by case var name=value\nAnd I'm missing:\nActual task owner | \u2718 | \u2718 | \u2713 | \u2713 | Filters by task actual owner\nCorrelation key | \u2713 | \u2713 | \u2713 | \u2713 | Filters by correlation key name\nTask name | \u2718 | \u2718 | \u2713 | \u2713 | Filters by task name\nCase definition id | \u2713 | \u2718 | \u2713 | \u2718 | Filters by case definition id\nCase instance id | \u2713 | \u2718 | \u2713 | \u2718 | Filters by case instance id\nTask Variables | \u2718 | \u2718 | \u2713 | \u2713 | Filter by task variable name=value\nAlso, would be nice to have some pagination test along with the use of the operator (equal, not_equal, etc). Let me know, if not I can add some to it afterwards. What do you think?", "url": "https://github.com/kiegroup/jbpm/pull/1615#discussion_r408128401", "createdAt": "2020-04-14T13:18:15Z", "author": {"login": "afalhambra"}, "path": "jbpm-case-mgmt/jbpm-case-mgmt-impl/src/test/java/org/jbpm/casemgmt/impl/AdvanceCaseRuntimeDataServiceImplTest.java", "diffHunk": "@@ -0,0 +1,96 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.jbpm.casemgmt.impl;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.jbpm.casemgmt.api.model.instance.CaseFileInstance;\n+import org.jbpm.casemgmt.impl.util.AbstractCaseServicesBaseTest;\n+import org.jbpm.services.api.model.ProcessInstanceWithVarsDesc;\n+import org.jbpm.services.api.model.UserTaskInstanceWithPotOwnerDesc;\n+import org.jbpm.services.api.query.model.QueryParam;\n+import org.jbpm.services.task.impl.model.UserImpl;\n+import org.junit.Test;\n+import org.kie.api.runtime.query.QueryContext;\n+import org.kie.api.task.model.OrganizationalEntity;\n+\n+import static java.util.Collections.emptyList;\n+import static org.jbpm.services.api.query.model.QueryParam.equalsTo;\n+import static org.jbpm.services.api.query.model.QueryParam.list;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNotNull;\n+\n+public class AdvanceCaseRuntimeDataServiceImplTest extends AbstractCaseServicesBaseTest {\n+\n+\n+    @Override\n+    protected List<String> getProcessDefinitionFiles() {\n+        List<String> processes = new ArrayList<String>();\n+        processes.add(\"cases/EmptyCase.bpmn2\");\n+        processes.add(\"cases/UserTaskCase.bpmn2\");\n+        return processes;\n+    }\n+\n+    /*\n+     * Case instance queries\n+     */\n+    @Test\n+    public void testSearchByVariable() {\n+        Map<String, Object> data = new HashMap<>();\n+        data.put(\"name\", \"my first case\");\n+\n+        CaseFileInstance caseFile = caseService.newCaseFileInstance(deploymentUnit.getIdentifier(), EMPTY_CASE_P_ID, data);\n+\n+        String caseId = caseService.startCase(deploymentUnit.getIdentifier(), EMPTY_CASE_P_ID, caseFile);\n+\n+        List<QueryParam> vars = list(equalsTo(\"name\", \"my first case\"));\n+\n+        List<ProcessInstanceWithVarsDesc> process = advanceCaseRuntimeDataService.queryCaseByVariables(emptyList(), vars, new QueryContext());\n+        assertEquals(1, process.size());\n+        assertEquals(\"my first case\", process.get(0).getExtraData().get(\"name\"));\n+\n+        assertNotNull(caseId);\n+        assertEquals(FIRST_CASE_ID, caseId);\n+        caseService.cancelCase(caseId);\n+\n+    }\n+\n+    @Test\n+    public void testSearchUserByVariable() {\n+        Map<String, OrganizationalEntity> roleAssignments = new HashMap<>();\n+        roleAssignments.put(\"owner\", new UserImpl(USER));\n+\n+        Map<String, Object> data = new HashMap<>();\n+        data.put(\"name\", \"my first case\");\n+        CaseFileInstance caseFile = caseService.newCaseFileInstance(deploymentUnit.getIdentifier(), USER_TASK_CASE_P_ID, data, roleAssignments);\n+\n+        String caseId = caseService.startCase(deploymentUnit.getIdentifier(), USER_TASK_CASE_P_ID, caseFile);\n+\n+        List<UserTaskInstanceWithPotOwnerDesc> process = advanceCaseRuntimeDataService.queryUserTasksByVariables(emptyList(), emptyList(), emptyList(), emptyList(), new QueryContext());\n+        assertEquals(1, process.size());\n+        assertEquals(\"my first case\", process.get(0).getExtraData().get(\"name\"));\n+\n+        assertNotNull(caseId);\n+        assertEquals(HR_CASE_ID, caseId);\n+        caseService.cancelCase(caseId);\n+\n+    }\n+\n+}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f04f50355ec285330b3467d42754a036a04b1db3"}, "originalPosition": 96}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTIxMjQxNg==", "bodyText": "all those are test. keep in mind that is reusing things from the abstract class.", "url": "https://github.com/kiegroup/jbpm/pull/1615#discussion_r411212416", "createdAt": "2020-04-20T09:01:12Z", "author": {"login": "elguardian"}, "path": "jbpm-case-mgmt/jbpm-case-mgmt-impl/src/test/java/org/jbpm/casemgmt/impl/AdvanceCaseRuntimeDataServiceImplTest.java", "diffHunk": "@@ -0,0 +1,96 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.jbpm.casemgmt.impl;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.jbpm.casemgmt.api.model.instance.CaseFileInstance;\n+import org.jbpm.casemgmt.impl.util.AbstractCaseServicesBaseTest;\n+import org.jbpm.services.api.model.ProcessInstanceWithVarsDesc;\n+import org.jbpm.services.api.model.UserTaskInstanceWithPotOwnerDesc;\n+import org.jbpm.services.api.query.model.QueryParam;\n+import org.jbpm.services.task.impl.model.UserImpl;\n+import org.junit.Test;\n+import org.kie.api.runtime.query.QueryContext;\n+import org.kie.api.task.model.OrganizationalEntity;\n+\n+import static java.util.Collections.emptyList;\n+import static org.jbpm.services.api.query.model.QueryParam.equalsTo;\n+import static org.jbpm.services.api.query.model.QueryParam.list;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNotNull;\n+\n+public class AdvanceCaseRuntimeDataServiceImplTest extends AbstractCaseServicesBaseTest {\n+\n+\n+    @Override\n+    protected List<String> getProcessDefinitionFiles() {\n+        List<String> processes = new ArrayList<String>();\n+        processes.add(\"cases/EmptyCase.bpmn2\");\n+        processes.add(\"cases/UserTaskCase.bpmn2\");\n+        return processes;\n+    }\n+\n+    /*\n+     * Case instance queries\n+     */\n+    @Test\n+    public void testSearchByVariable() {\n+        Map<String, Object> data = new HashMap<>();\n+        data.put(\"name\", \"my first case\");\n+\n+        CaseFileInstance caseFile = caseService.newCaseFileInstance(deploymentUnit.getIdentifier(), EMPTY_CASE_P_ID, data);\n+\n+        String caseId = caseService.startCase(deploymentUnit.getIdentifier(), EMPTY_CASE_P_ID, caseFile);\n+\n+        List<QueryParam> vars = list(equalsTo(\"name\", \"my first case\"));\n+\n+        List<ProcessInstanceWithVarsDesc> process = advanceCaseRuntimeDataService.queryCaseByVariables(emptyList(), vars, new QueryContext());\n+        assertEquals(1, process.size());\n+        assertEquals(\"my first case\", process.get(0).getExtraData().get(\"name\"));\n+\n+        assertNotNull(caseId);\n+        assertEquals(FIRST_CASE_ID, caseId);\n+        caseService.cancelCase(caseId);\n+\n+    }\n+\n+    @Test\n+    public void testSearchUserByVariable() {\n+        Map<String, OrganizationalEntity> roleAssignments = new HashMap<>();\n+        roleAssignments.put(\"owner\", new UserImpl(USER));\n+\n+        Map<String, Object> data = new HashMap<>();\n+        data.put(\"name\", \"my first case\");\n+        CaseFileInstance caseFile = caseService.newCaseFileInstance(deploymentUnit.getIdentifier(), USER_TASK_CASE_P_ID, data, roleAssignments);\n+\n+        String caseId = caseService.startCase(deploymentUnit.getIdentifier(), USER_TASK_CASE_P_ID, caseFile);\n+\n+        List<UserTaskInstanceWithPotOwnerDesc> process = advanceCaseRuntimeDataService.queryUserTasksByVariables(emptyList(), emptyList(), emptyList(), emptyList(), new QueryContext());\n+        assertEquals(1, process.size());\n+        assertEquals(\"my first case\", process.get(0).getExtraData().get(\"name\"));\n+\n+        assertNotNull(caseId);\n+        assertEquals(HR_CASE_ID, caseId);\n+        caseService.cancelCase(caseId);\n+\n+    }\n+\n+}", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODEyODQwMQ=="}, "originalCommit": {"oid": "f04f50355ec285330b3467d42754a036a04b1db3"}, "originalPosition": 96}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUzMzc5MTUzOnYy", "diffSide": "RIGHT", "path": "jbpm-services/jbpm-kie-services/src/main/java/org/jbpm/kie/services/impl/AbstractAdvanceRuntimeDataServiceImpl.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNFQxMzoxOToxNFrOGFOOWw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNFQxMzoxOToxNFrOGFOOWw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODEyOTExNQ==", "bodyText": "QueryContext has ordering asc or desc capabilities but it is not used in the query. Should we take this into account?", "url": "https://github.com/kiegroup/jbpm/pull/1615#discussion_r408129115", "createdAt": "2020-04-14T13:19:14Z", "author": {"login": "afalhambra"}, "path": "jbpm-services/jbpm-kie-services/src/main/java/org/jbpm/kie/services/impl/AbstractAdvanceRuntimeDataServiceImpl.java", "diffHunk": "@@ -0,0 +1,346 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.jbpm.kie.services.impl;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import javax.persistence.EntityManager;\n+import javax.persistence.EntityManagerFactory;\n+import javax.persistence.Query;\n+\n+import org.dashbuilder.dataset.filter.CoreFunctionType;\n+import org.jbpm.kie.services.impl.model.ProcessInstanceWithVarsDesc;\n+import org.jbpm.kie.services.impl.model.UserTaskInstanceWithPotOwnerDesc;\n+import org.jbpm.services.api.query.model.QueryParam;\n+import org.jbpm.shared.services.impl.QueryManager;\n+import org.jbpm.shared.services.impl.TransactionalCommandService;\n+import org.jbpm.shared.services.impl.commands.QueryNameCommand;\n+import org.kie.api.runtime.query.QueryContext;\n+\n+import static java.util.Collections.singletonMap;\n+\n+public abstract class AbstractAdvanceRuntimeDataServiceImpl {\n+\n+    private static final String ID_LIST = \"idList\";\n+    private EntityManagerFactory emf;\n+    private TransactionalCommandService commandService;\n+\n+    public AbstractAdvanceRuntimeDataServiceImpl() {\n+        QueryManager.get().addNamedQueries(\"META-INF/Servicesorm.xml\");\n+    }\n+    public void setCommandService(TransactionalCommandService commandService) {\n+        this.commandService = commandService;\n+    }\n+\n+    public void setEmf(EntityManagerFactory emf) {\n+        this.emf = emf;\n+    }\n+\n+\n+    public List<org.jbpm.services.api.model.ProcessInstanceWithVarsDesc> queryProcessByVariables(List<QueryParam> attributes,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f04f50355ec285330b3467d42754a036a04b1db3"}, "originalPosition": 59}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUzMzgzNDExOnYy", "diffSide": "RIGHT", "path": "jbpm-services/jbpm-kie-services/src/main/java/org/jbpm/kie/services/impl/AbstractAdvanceRuntimeDataServiceImpl.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNFQxMzoyODozOFrOGFOooA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNFQxMzoyODozOFrOGFOooA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODEzNTg0MA==", "bodyText": "I would rename it to \"uwv\" (UserTaskInstanceWithPotOwnerDesc) instead of \"pwv\" (ProcessInstanceWithVarsDesc)", "url": "https://github.com/kiegroup/jbpm/pull/1615#discussion_r408135840", "createdAt": "2020-04-14T13:28:38Z", "author": {"login": "afalhambra"}, "path": "jbpm-services/jbpm-kie-services/src/main/java/org/jbpm/kie/services/impl/AbstractAdvanceRuntimeDataServiceImpl.java", "diffHunk": "@@ -0,0 +1,346 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.jbpm.kie.services.impl;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import javax.persistence.EntityManager;\n+import javax.persistence.EntityManagerFactory;\n+import javax.persistence.Query;\n+\n+import org.dashbuilder.dataset.filter.CoreFunctionType;\n+import org.jbpm.kie.services.impl.model.ProcessInstanceWithVarsDesc;\n+import org.jbpm.kie.services.impl.model.UserTaskInstanceWithPotOwnerDesc;\n+import org.jbpm.services.api.query.model.QueryParam;\n+import org.jbpm.shared.services.impl.QueryManager;\n+import org.jbpm.shared.services.impl.TransactionalCommandService;\n+import org.jbpm.shared.services.impl.commands.QueryNameCommand;\n+import org.kie.api.runtime.query.QueryContext;\n+\n+import static java.util.Collections.singletonMap;\n+\n+public abstract class AbstractAdvanceRuntimeDataServiceImpl {\n+\n+    private static final String ID_LIST = \"idList\";\n+    private EntityManagerFactory emf;\n+    private TransactionalCommandService commandService;\n+\n+    public AbstractAdvanceRuntimeDataServiceImpl() {\n+        QueryManager.get().addNamedQueries(\"META-INF/Servicesorm.xml\");\n+    }\n+    public void setCommandService(TransactionalCommandService commandService) {\n+        this.commandService = commandService;\n+    }\n+\n+    public void setEmf(EntityManagerFactory emf) {\n+        this.emf = emf;\n+    }\n+\n+\n+    public List<org.jbpm.services.api.model.ProcessInstanceWithVarsDesc> queryProcessByVariables(List<QueryParam> attributes,\n+                                                                                                 List<QueryParam> variables,\n+                                                                                                 int processType,\n+                                                                                                 String varPrefix,\n+                                                                                                 QueryContext queryContext) {\n+        EntityManager entityManager = emf.createEntityManager();\n+\n+        // first step is to filter the data creating a derived tables and pivoting var - rows to columns (only the variables we are interested to filter)\n+        StringBuilder derivedTables = new StringBuilder();\n+        if (!variables.isEmpty()) {\n+            List<String> conditions = new ArrayList<>();\n+            variables.stream().forEach(expr -> conditions.add(\"(A1.variableId = :NAME_\" + expr.getColumn() + \" AND \" + computeExpression(expr, \"A1.value\", \":VALUE_\" + expr.getColumn()) + \")\\n\"));\n+            String where = String.join(\" OR \", conditions);\n+            derivedTables.append(\"INNER JOIN (\" +\n+                                 \"SELECT A1.processInstanceId \\n\" +\n+                                 \"FROM VariableInstanceLog A1 \\n\" +\n+                                 \"LEFT JOIN VariableInstanceLog A2 ON A1.processId = A2.processId AND A1.processInstanceId = A2.processInstanceId AND A1.variableInstanceId = A2.variableInstanceId AND A2.id > A1.id  \\n\" +\n+                                 \"WHERE A2.id IS NULL AND (\" + where + \") \" +\n+                                 \"GROUP BY A1.processInstanceId \" +\n+                                 \"HAVING COUNT(*) = :NUMBER_OF_VARS \" +\n+                                 \") TABLE_VAR ON TABLE_VAR.processInstanceId = pil.processInstanceId \\n\");\n+        }\n+\n+        StringBuilder globalWhere = new StringBuilder();\n+        attributes.stream().forEach(expr -> globalWhere.append(\" AND \" + computeExpression(expr, expr.getColumn(), \":ATTR_\" + expr.getColumn())));\n+\n+        String procSQLString =\n+                \" SELECT DISTINCT pil.processInstanceId \" +\n+                               \" FROM ProcessInstanceLog pil \\n \" +\n+                               derivedTables +\n+                               \" WHERE pil.processType = :processType \" + globalWhere +\n+                               \" ORDER BY pil.processInstanceId ASC \";\n+\n+        Query query = entityManager.createNativeQuery(procSQLString);\n+        variables.stream().forEach(var -> query.setParameter(\"NAME_\" + var.getColumn(), varPrefix + var.getColumn()));\n+        variables.stream().filter(e -> e.getObjectValue() != null).forEach(var -> query.setParameter(\"VALUE_\" + var.getColumn(), var.getObjectValue()));\n+        attributes.stream().filter(e -> e.getObjectValue() != null).forEach((entry) -> query.setParameter(\"ATTR_\" + entry.getColumn(), entry.getObjectValue()));\n+\n+        if (!variables.isEmpty()) {\n+            query.setParameter(\"NUMBER_OF_VARS\", variables.size());\n+        }\n+        query.setParameter(\"processType\", processType);\n+\n+        addPagination(query, queryContext);\n+        List<Number> ids = query.getResultList();\n+        if (ids.isEmpty()) {\n+            return Collections.emptyList();\n+        }\n+\n+        // now we get the information\n+\n+        List<Object[]> procRows = commandService.execute(new QueryNameCommand<List<Object[]>>(\"GetProcessInstanceByIdList\", singletonMap(ID_LIST, ids)));\n+        List<Object[]> varRows = commandService.execute(new QueryNameCommand<List<Object[]>>(\"GetVariablesByProcessInstanceIdList\", singletonMap(ID_LIST, ids)));\n+\n+        int currentVarIdx = 0;\n+        List<org.jbpm.services.api.model.ProcessInstanceWithVarsDesc> data = new ArrayList<>();\n+        for (Object[] row : procRows) {\n+            ProcessInstanceWithVarsDesc pwv = toProcessInstanceWithVarsDesc(row);\n+\n+            Map<String, Object> vars = new HashMap<>();\n+            pwv.setVariables(vars);\n+\n+            Map<String, Object> extra = new HashMap<>();\n+            pwv.setExtraData(extra);\n+            while (currentVarIdx < varRows.size() && row[0].equals(varRows.get(currentVarIdx)[0])) {\n+                String name = (String) varRows.get(currentVarIdx)[1];\n+                if (!varPrefix.isEmpty() && name.startsWith(varPrefix)) {\n+                    extra.put(name.substring(varPrefix.length()), varRows.get(currentVarIdx)[2]);\n+                } else {\n+                    vars.put(name, varRows.get(currentVarIdx)[2]);\n+                }\n+                currentVarIdx++;\n+            }\n+            data.add(pwv);\n+        }\n+\n+        entityManager.close();\n+        return data;\n+    }\n+\n+    private String computeExpression(QueryParam expr, String leftOperand, String rightOperand) {\n+        CoreFunctionType type = CoreFunctionType.getByName(expr.getOperator());\n+        switch (type) {\n+            case IS_NULL:\n+                return leftOperand + \" IS NULL \";\n+            case NOT_NULL:\n+                return leftOperand + \" IS NOT NULL \";\n+            case IN:\n+                return leftOperand + \" IN (\" + rightOperand + \") \";\n+            case NOT_IN:\n+                return leftOperand + \" NOT IN (\" + rightOperand + \") \";\n+            case EQUALS_TO:\n+                return leftOperand + \" = \" + rightOperand + \" \";\n+            case NOT_EQUALS_TO:\n+                return leftOperand + \" <> \" + rightOperand + \" \";\n+            case LIKE_TO:\n+                return leftOperand + \" LIKE \" + rightOperand + \" \";\n+            default:\n+                throw new UnsupportedOperationException(\"Queryparam: \" + expr + \" not supported\");\n+        }\n+    }\n+    private ProcessInstanceWithVarsDesc toProcessInstanceWithVarsDesc(Object[] row) {\n+        return new ProcessInstanceWithVarsDesc(((Number) row[0]).longValue(),\n+                                               (String) row[1],\n+                                               (String) row[2],\n+                                               (String) row[3],\n+                                               ((Number) row[4]).intValue(),\n+                                               (String) row[5],\n+                                               (Date) row[6],\n+                                               (String) row[7],\n+                                               (String) row[8]);\n+    }\n+\n+    private void addPagination(Query query, QueryContext context) {\n+        if (context.getCount() > 0) {\n+            query.setFirstResult(context.getOffset());\n+            query.setMaxResults(context.getCount());\n+        }\n+    }\n+\n+    public List<org.jbpm.services.api.model.UserTaskInstanceWithPotOwnerDesc> queryUserTasksByVariables(List<QueryParam> attributes,\n+                                                                                                        List<QueryParam> variables,\n+                                                                                                        List<QueryParam> processVariables,\n+                                                                                                        List<String> owners,\n+                                                                                                        int processType,\n+                                                                                                        String varPrefix,\n+                                                                                                        QueryContext queryContext) {\n+        EntityManager entityManager = emf.createEntityManager();\n+        StringBuilder globalWhere = new StringBuilder();\n+        StringBuilder derivedTables = new StringBuilder();\n+        if (!variables.isEmpty()) {\n+            List<String> conditions = new ArrayList<>();\n+            variables.stream().forEach((expr) -> conditions.add(\"(name = :V_NAME_\" + expr.getColumn() + \" AND \" + computeExpression(expr, \"value\", \":V_VALUE_\" + expr.getColumn()) + \")\\n\"));\n+            String where = String.join(\" OR \", conditions);\n+            derivedTables.append(\"INNER JOIN (\\n\" +\n+                                 \"SELECT taskId \\n\" +\n+                                 \"FROM TaskVariableImpl \\n\" +\n+                                 \"WHERE type = 0 AND (\" + where + \")\\n\" +\n+                                 \"GROUP BY taskId \\n\" +\n+                                 \"HAVING COUNT(*) = :NUMBER_OF_TASKVARS \\n\" +\n+                                 \") TABLE_TASK_VAR ON TABLE_TASK_VAR.taskId = task.id  \\n\");\n+        }\n+\n+        if (!processVariables.isEmpty()) {\n+            List<String> conditions = new ArrayList<>();\n+            processVariables.stream().forEach((expr) -> conditions.add(\"(A1.variableId = :P_NAME_\" + expr.getColumn() + \" AND \" + computeExpression(expr, \"A1.value\", \":P_VALUE_\" + expr.getColumn()) + \")\\n\"));\n+            String where = String.join(\" OR \", conditions);\n+            derivedTables.append(\"INNER JOIN (\" +\n+                                 \"SELECT A1.processInstanceId \\n\" +\n+                                 \"FROM VariableInstanceLog A1 \\n\" +\n+                                 \"LEFT JOIN VariableInstanceLog A2 ON A1.processId = A2.processId AND A1.processInstanceId = A2.processInstanceId AND A1.variableInstanceId = A2.variableInstanceId AND A2.id > A1.id  \\n\" +\n+                                 \"WHERE A2.id IS NULL AND (\" + where + \") \" +\n+                                 \"GROUP BY A1.processInstanceId \" +\n+                                 \"HAVING COUNT(*) = :NUMBER_OF_PROCVARS \" +\n+                                 \") TABLE_PROC_VAR ON TABLE_PROC_VAR.processInstanceId = pil.processInstanceId \\n\");\n+        }\n+\n+        if (!owners.isEmpty()) {\n+            derivedTables.append(\"INNER JOIN ( \\n\" +\n+                             \"           SELECT DISTINCT po.task_id \\n\" +\n+                             \"           FROM PeopleAssignments_PotOwners po \\n\" +\n+                             \"           WHERE po.entity_id IN (:owners) \\n\" +\n+                             \"           GROUP BY po.task_id \\n\" +\n+                             \"           HAVING COUNT(po.entity_id) = :num_owners \\n\" +\n+                                 \") pot ON pot.task_id = task.id \");\n+        }\n+\n+        attributes.stream().forEach((expr) -> globalWhere.append(\" AND \" + computeExpression(expr, expr.getColumn(), \":ATTR_\" + expr.getColumn())));\n+\n+        String procSQLString = \"SELECT DISTINCT task.id \" +\n+                               \" FROM Task task \" +\n+                               \" INNER JOIN ProcessInstanceLog pil ON pil.processInstanceId = task.processInstanceId \\n \" +\n+                               derivedTables +\n+                               \" WHERE  pil.processType = :processType \" + globalWhere +\n+                               \" ORDER BY task.id ASC \";\n+\n+        Query query = entityManager.createNativeQuery(procSQLString);\n+        variables.stream().forEach(var -> query.setParameter(\"V_NAME_\" + var.getColumn(), var.getColumn()));\n+        variables.stream().filter(e -> e.getObjectValue() != null).forEach((var) -> query.setParameter(\"V_VALUE_\" + var.getColumn(), var.getObjectValue()));\n+\n+        if (!variables.isEmpty()) {\n+            query.setParameter(\"NUMBER_OF_TASKVARS\", variables.size());\n+        }\n+\n+        processVariables.stream().forEach(var -> query.setParameter(\"P_NAME_\" + var.getColumn(), varPrefix + var.getColumn()));\n+        processVariables.stream().filter(e -> e.getObjectValue() != null).forEach((var) -> query.setParameter(\"P_VALUE_\" + var.getColumn(), var.getObjectValue()));\n+\n+        if (!processVariables.isEmpty()) {\n+            query.setParameter(\"NUMBER_OF_PROCVARS\", processVariables.size());\n+        }\n+\n+        if (!owners.isEmpty()) {\n+            query.setParameter(\"num_owners\", owners.size());\n+            query.setParameter(\"owners\", owners);\n+        }\n+\n+        attributes.stream().filter(e -> e.getObjectValue() != null).forEach(entry -> query.setParameter(\"ATTR_\" + entry.getColumn(), entry.getObjectValue()));\n+        query.setParameter(\"processType\", processType);\n+\n+        addPagination(query, queryContext);\n+\n+        List<Number> ids = query.getResultList();\n+        if (ids.isEmpty()) {\n+            return Collections.emptyList();\n+        }\n+\n+        entityManager.close();\n+        return collectData(ids, varPrefix);\n+\n+    }\n+\n+    private List<org.jbpm.services.api.model.UserTaskInstanceWithPotOwnerDesc> collectData(List<Number> ids, String varPrefix) {\n+        // query data\n+        List<Object[]> taskRows = commandService.execute(new QueryNameCommand<List<Object[]>>(\"GetTasksByIdList\", singletonMap(ID_LIST, ids)));\n+        List<Object[]> varRows = commandService.execute(new QueryNameCommand<List<Object[]>>(\"GetTaskVariablesByTaskIdList\", singletonMap(ID_LIST, ids)));\n+        List<Object[]> potRows = commandService.execute(new QueryNameCommand<List<Object[]>>(\"GetPotentialOwnersByTaskIdList\", singletonMap(ID_LIST, ids)));\n+        List<Object[]> varProcSQLRows = commandService.execute(new QueryNameCommand<List<Object[]>>(\"GetProcessVariablesByTaskIdList\", singletonMap(ID_LIST, ids)));\n+\n+        int currentVarIdx = 0;\n+        int currentPotIdx = 0;\n+        int currentVarProcIdx = 0;\n+        List<org.jbpm.services.api.model.UserTaskInstanceWithPotOwnerDesc> data = new ArrayList<>();\n+        for (Object[] row : taskRows) {\n+            UserTaskInstanceWithPotOwnerDesc pwv = toUserTaskInstanceWithPotOwnerDesc(row);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f04f50355ec285330b3467d42754a036a04b1db3"}, "originalPosition": 282}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUzNDU4NzQyOnYy", "diffSide": "RIGHT", "path": "jbpm-services/jbpm-kie-services/src/main/java/org/jbpm/kie/services/impl/AbstractAdvanceRuntimeDataServiceImpl.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNFQxNjowNzoxOFrOGFWDcw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNFQxNjowNzoxOFrOGFWDcw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODI1NzM5NQ==", "bodyText": "I would use TaskVariable.VariableType.INPUT instead of hardcoding values in the query.\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                             \"WHERE type = 0 AND (\" + where + \")\\n\" +\n          \n          \n            \n                                             \"WHERE type = :type AND (\" + where + \")\\n\" +\n          \n          \n            \n                                             ...\n          \n          \n            \n                                             query.setParameter(type, TaskVariable.VariableType.INPUT)", "url": "https://github.com/kiegroup/jbpm/pull/1615#discussion_r408257395", "createdAt": "2020-04-14T16:07:18Z", "author": {"login": "afalhambra"}, "path": "jbpm-services/jbpm-kie-services/src/main/java/org/jbpm/kie/services/impl/AbstractAdvanceRuntimeDataServiceImpl.java", "diffHunk": "@@ -0,0 +1,346 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.jbpm.kie.services.impl;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import javax.persistence.EntityManager;\n+import javax.persistence.EntityManagerFactory;\n+import javax.persistence.Query;\n+\n+import org.dashbuilder.dataset.filter.CoreFunctionType;\n+import org.jbpm.kie.services.impl.model.ProcessInstanceWithVarsDesc;\n+import org.jbpm.kie.services.impl.model.UserTaskInstanceWithPotOwnerDesc;\n+import org.jbpm.services.api.query.model.QueryParam;\n+import org.jbpm.shared.services.impl.QueryManager;\n+import org.jbpm.shared.services.impl.TransactionalCommandService;\n+import org.jbpm.shared.services.impl.commands.QueryNameCommand;\n+import org.kie.api.runtime.query.QueryContext;\n+\n+import static java.util.Collections.singletonMap;\n+\n+public abstract class AbstractAdvanceRuntimeDataServiceImpl {\n+\n+    private static final String ID_LIST = \"idList\";\n+    private EntityManagerFactory emf;\n+    private TransactionalCommandService commandService;\n+\n+    public AbstractAdvanceRuntimeDataServiceImpl() {\n+        QueryManager.get().addNamedQueries(\"META-INF/Servicesorm.xml\");\n+    }\n+    public void setCommandService(TransactionalCommandService commandService) {\n+        this.commandService = commandService;\n+    }\n+\n+    public void setEmf(EntityManagerFactory emf) {\n+        this.emf = emf;\n+    }\n+\n+\n+    public List<org.jbpm.services.api.model.ProcessInstanceWithVarsDesc> queryProcessByVariables(List<QueryParam> attributes,\n+                                                                                                 List<QueryParam> variables,\n+                                                                                                 int processType,\n+                                                                                                 String varPrefix,\n+                                                                                                 QueryContext queryContext) {\n+        EntityManager entityManager = emf.createEntityManager();\n+\n+        // first step is to filter the data creating a derived tables and pivoting var - rows to columns (only the variables we are interested to filter)\n+        StringBuilder derivedTables = new StringBuilder();\n+        if (!variables.isEmpty()) {\n+            List<String> conditions = new ArrayList<>();\n+            variables.stream().forEach(expr -> conditions.add(\"(A1.variableId = :NAME_\" + expr.getColumn() + \" AND \" + computeExpression(expr, \"A1.value\", \":VALUE_\" + expr.getColumn()) + \")\\n\"));\n+            String where = String.join(\" OR \", conditions);\n+            derivedTables.append(\"INNER JOIN (\" +\n+                                 \"SELECT A1.processInstanceId \\n\" +\n+                                 \"FROM VariableInstanceLog A1 \\n\" +\n+                                 \"LEFT JOIN VariableInstanceLog A2 ON A1.processId = A2.processId AND A1.processInstanceId = A2.processInstanceId AND A1.variableInstanceId = A2.variableInstanceId AND A2.id > A1.id  \\n\" +\n+                                 \"WHERE A2.id IS NULL AND (\" + where + \") \" +\n+                                 \"GROUP BY A1.processInstanceId \" +\n+                                 \"HAVING COUNT(*) = :NUMBER_OF_VARS \" +\n+                                 \") TABLE_VAR ON TABLE_VAR.processInstanceId = pil.processInstanceId \\n\");\n+        }\n+\n+        StringBuilder globalWhere = new StringBuilder();\n+        attributes.stream().forEach(expr -> globalWhere.append(\" AND \" + computeExpression(expr, expr.getColumn(), \":ATTR_\" + expr.getColumn())));\n+\n+        String procSQLString =\n+                \" SELECT DISTINCT pil.processInstanceId \" +\n+                               \" FROM ProcessInstanceLog pil \\n \" +\n+                               derivedTables +\n+                               \" WHERE pil.processType = :processType \" + globalWhere +\n+                               \" ORDER BY pil.processInstanceId ASC \";\n+\n+        Query query = entityManager.createNativeQuery(procSQLString);\n+        variables.stream().forEach(var -> query.setParameter(\"NAME_\" + var.getColumn(), varPrefix + var.getColumn()));\n+        variables.stream().filter(e -> e.getObjectValue() != null).forEach(var -> query.setParameter(\"VALUE_\" + var.getColumn(), var.getObjectValue()));\n+        attributes.stream().filter(e -> e.getObjectValue() != null).forEach((entry) -> query.setParameter(\"ATTR_\" + entry.getColumn(), entry.getObjectValue()));\n+\n+        if (!variables.isEmpty()) {\n+            query.setParameter(\"NUMBER_OF_VARS\", variables.size());\n+        }\n+        query.setParameter(\"processType\", processType);\n+\n+        addPagination(query, queryContext);\n+        List<Number> ids = query.getResultList();\n+        if (ids.isEmpty()) {\n+            return Collections.emptyList();\n+        }\n+\n+        // now we get the information\n+\n+        List<Object[]> procRows = commandService.execute(new QueryNameCommand<List<Object[]>>(\"GetProcessInstanceByIdList\", singletonMap(ID_LIST, ids)));\n+        List<Object[]> varRows = commandService.execute(new QueryNameCommand<List<Object[]>>(\"GetVariablesByProcessInstanceIdList\", singletonMap(ID_LIST, ids)));\n+\n+        int currentVarIdx = 0;\n+        List<org.jbpm.services.api.model.ProcessInstanceWithVarsDesc> data = new ArrayList<>();\n+        for (Object[] row : procRows) {\n+            ProcessInstanceWithVarsDesc pwv = toProcessInstanceWithVarsDesc(row);\n+\n+            Map<String, Object> vars = new HashMap<>();\n+            pwv.setVariables(vars);\n+\n+            Map<String, Object> extra = new HashMap<>();\n+            pwv.setExtraData(extra);\n+            while (currentVarIdx < varRows.size() && row[0].equals(varRows.get(currentVarIdx)[0])) {\n+                String name = (String) varRows.get(currentVarIdx)[1];\n+                if (!varPrefix.isEmpty() && name.startsWith(varPrefix)) {\n+                    extra.put(name.substring(varPrefix.length()), varRows.get(currentVarIdx)[2]);\n+                } else {\n+                    vars.put(name, varRows.get(currentVarIdx)[2]);\n+                }\n+                currentVarIdx++;\n+            }\n+            data.add(pwv);\n+        }\n+\n+        entityManager.close();\n+        return data;\n+    }\n+\n+    private String computeExpression(QueryParam expr, String leftOperand, String rightOperand) {\n+        CoreFunctionType type = CoreFunctionType.getByName(expr.getOperator());\n+        switch (type) {\n+            case IS_NULL:\n+                return leftOperand + \" IS NULL \";\n+            case NOT_NULL:\n+                return leftOperand + \" IS NOT NULL \";\n+            case IN:\n+                return leftOperand + \" IN (\" + rightOperand + \") \";\n+            case NOT_IN:\n+                return leftOperand + \" NOT IN (\" + rightOperand + \") \";\n+            case EQUALS_TO:\n+                return leftOperand + \" = \" + rightOperand + \" \";\n+            case NOT_EQUALS_TO:\n+                return leftOperand + \" <> \" + rightOperand + \" \";\n+            case LIKE_TO:\n+                return leftOperand + \" LIKE \" + rightOperand + \" \";\n+            default:\n+                throw new UnsupportedOperationException(\"Queryparam: \" + expr + \" not supported\");\n+        }\n+    }\n+    private ProcessInstanceWithVarsDesc toProcessInstanceWithVarsDesc(Object[] row) {\n+        return new ProcessInstanceWithVarsDesc(((Number) row[0]).longValue(),\n+                                               (String) row[1],\n+                                               (String) row[2],\n+                                               (String) row[3],\n+                                               ((Number) row[4]).intValue(),\n+                                               (String) row[5],\n+                                               (Date) row[6],\n+                                               (String) row[7],\n+                                               (String) row[8]);\n+    }\n+\n+    private void addPagination(Query query, QueryContext context) {\n+        if (context.getCount() > 0) {\n+            query.setFirstResult(context.getOffset());\n+            query.setMaxResults(context.getCount());\n+        }\n+    }\n+\n+    public List<org.jbpm.services.api.model.UserTaskInstanceWithPotOwnerDesc> queryUserTasksByVariables(List<QueryParam> attributes,\n+                                                                                                        List<QueryParam> variables,\n+                                                                                                        List<QueryParam> processVariables,\n+                                                                                                        List<String> owners,\n+                                                                                                        int processType,\n+                                                                                                        String varPrefix,\n+                                                                                                        QueryContext queryContext) {\n+        EntityManager entityManager = emf.createEntityManager();\n+        StringBuilder globalWhere = new StringBuilder();\n+        StringBuilder derivedTables = new StringBuilder();\n+        if (!variables.isEmpty()) {\n+            List<String> conditions = new ArrayList<>();\n+            variables.stream().forEach((expr) -> conditions.add(\"(name = :V_NAME_\" + expr.getColumn() + \" AND \" + computeExpression(expr, \"value\", \":V_VALUE_\" + expr.getColumn()) + \")\\n\"));\n+            String where = String.join(\" OR \", conditions);\n+            derivedTables.append(\"INNER JOIN (\\n\" +\n+                                 \"SELECT taskId \\n\" +\n+                                 \"FROM TaskVariableImpl \\n\" +\n+                                 \"WHERE type = 0 AND (\" + where + \")\\n\" +", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f04f50355ec285330b3467d42754a036a04b1db3"}, "originalPosition": 196}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUzNDgxMTg2OnYy", "diffSide": "RIGHT", "path": "jbpm-services/jbpm-kie-services/src/main/java/org/jbpm/kie/services/impl/AbstractAdvanceRuntimeDataServiceImpl.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNFQxNzowMTowNlrOGFYR4Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNFQxNzowMTowNlrOGFYR4Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODI5Mzg1Nw==", "bodyText": "a list can contain duplicate values. It is not supposed to happen but it could and if so, this query wouldn't work - wdyt?", "url": "https://github.com/kiegroup/jbpm/pull/1615#discussion_r408293857", "createdAt": "2020-04-14T17:01:06Z", "author": {"login": "afalhambra"}, "path": "jbpm-services/jbpm-kie-services/src/main/java/org/jbpm/kie/services/impl/AbstractAdvanceRuntimeDataServiceImpl.java", "diffHunk": "@@ -0,0 +1,346 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.jbpm.kie.services.impl;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import javax.persistence.EntityManager;\n+import javax.persistence.EntityManagerFactory;\n+import javax.persistence.Query;\n+\n+import org.dashbuilder.dataset.filter.CoreFunctionType;\n+import org.jbpm.kie.services.impl.model.ProcessInstanceWithVarsDesc;\n+import org.jbpm.kie.services.impl.model.UserTaskInstanceWithPotOwnerDesc;\n+import org.jbpm.services.api.query.model.QueryParam;\n+import org.jbpm.shared.services.impl.QueryManager;\n+import org.jbpm.shared.services.impl.TransactionalCommandService;\n+import org.jbpm.shared.services.impl.commands.QueryNameCommand;\n+import org.kie.api.runtime.query.QueryContext;\n+\n+import static java.util.Collections.singletonMap;\n+\n+public abstract class AbstractAdvanceRuntimeDataServiceImpl {\n+\n+    private static final String ID_LIST = \"idList\";\n+    private EntityManagerFactory emf;\n+    private TransactionalCommandService commandService;\n+\n+    public AbstractAdvanceRuntimeDataServiceImpl() {\n+        QueryManager.get().addNamedQueries(\"META-INF/Servicesorm.xml\");\n+    }\n+    public void setCommandService(TransactionalCommandService commandService) {\n+        this.commandService = commandService;\n+    }\n+\n+    public void setEmf(EntityManagerFactory emf) {\n+        this.emf = emf;\n+    }\n+\n+\n+    public List<org.jbpm.services.api.model.ProcessInstanceWithVarsDesc> queryProcessByVariables(List<QueryParam> attributes,\n+                                                                                                 List<QueryParam> variables,\n+                                                                                                 int processType,\n+                                                                                                 String varPrefix,\n+                                                                                                 QueryContext queryContext) {\n+        EntityManager entityManager = emf.createEntityManager();\n+\n+        // first step is to filter the data creating a derived tables and pivoting var - rows to columns (only the variables we are interested to filter)\n+        StringBuilder derivedTables = new StringBuilder();\n+        if (!variables.isEmpty()) {\n+            List<String> conditions = new ArrayList<>();\n+            variables.stream().forEach(expr -> conditions.add(\"(A1.variableId = :NAME_\" + expr.getColumn() + \" AND \" + computeExpression(expr, \"A1.value\", \":VALUE_\" + expr.getColumn()) + \")\\n\"));\n+            String where = String.join(\" OR \", conditions);\n+            derivedTables.append(\"INNER JOIN (\" +\n+                                 \"SELECT A1.processInstanceId \\n\" +\n+                                 \"FROM VariableInstanceLog A1 \\n\" +\n+                                 \"LEFT JOIN VariableInstanceLog A2 ON A1.processId = A2.processId AND A1.processInstanceId = A2.processInstanceId AND A1.variableInstanceId = A2.variableInstanceId AND A2.id > A1.id  \\n\" +\n+                                 \"WHERE A2.id IS NULL AND (\" + where + \") \" +\n+                                 \"GROUP BY A1.processInstanceId \" +\n+                                 \"HAVING COUNT(*) = :NUMBER_OF_VARS \" +", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f04f50355ec285330b3467d42754a036a04b1db3"}, "originalPosition": 78}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUzNDgxNzMzOnYy", "diffSide": "RIGHT", "path": "jbpm-services/jbpm-kie-services/src/main/java/org/jbpm/kie/services/impl/AbstractAdvanceRuntimeDataServiceImpl.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNFQxNzowMjozM1rOGFYVcg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNFQxNzowMjozM1rOGFYVcg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODI5NDc3MA==", "bodyText": "I think it would nice to have some of these important method with some java documentation. wdyt?", "url": "https://github.com/kiegroup/jbpm/pull/1615#discussion_r408294770", "createdAt": "2020-04-14T17:02:33Z", "author": {"login": "afalhambra"}, "path": "jbpm-services/jbpm-kie-services/src/main/java/org/jbpm/kie/services/impl/AbstractAdvanceRuntimeDataServiceImpl.java", "diffHunk": "@@ -0,0 +1,346 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.jbpm.kie.services.impl;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import javax.persistence.EntityManager;\n+import javax.persistence.EntityManagerFactory;\n+import javax.persistence.Query;\n+\n+import org.dashbuilder.dataset.filter.CoreFunctionType;\n+import org.jbpm.kie.services.impl.model.ProcessInstanceWithVarsDesc;\n+import org.jbpm.kie.services.impl.model.UserTaskInstanceWithPotOwnerDesc;\n+import org.jbpm.services.api.query.model.QueryParam;\n+import org.jbpm.shared.services.impl.QueryManager;\n+import org.jbpm.shared.services.impl.TransactionalCommandService;\n+import org.jbpm.shared.services.impl.commands.QueryNameCommand;\n+import org.kie.api.runtime.query.QueryContext;\n+\n+import static java.util.Collections.singletonMap;\n+\n+public abstract class AbstractAdvanceRuntimeDataServiceImpl {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f04f50355ec285330b3467d42754a036a04b1db3"}, "originalPosition": 41}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUzNjk1NDk0OnYy", "diffSide": "RIGHT", "path": "jbpm-services/jbpm-kie-services/src/main/java/org/jbpm/kie/services/impl/AbstractAdvanceRuntimeDataServiceImpl.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNVQwNzoxMjo1NVrOGFspJg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNVQwNzoxMjo1NVrOGFspJg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODYyNzQ5NA==", "bodyText": "Why \"owners\" is only matching those with \"IN\" statement condition? Shouldn't be like the others? I mean, should it not depend on the operator condition like \"EQUALS\", \"NOT_EQUALS\", etc? I know it's in the jira ticket, but not really sure why this different behavior for \"owners\"?", "url": "https://github.com/kiegroup/jbpm/pull/1615#discussion_r408627494", "createdAt": "2020-04-15T07:12:55Z", "author": {"login": "afalhambra"}, "path": "jbpm-services/jbpm-kie-services/src/main/java/org/jbpm/kie/services/impl/AbstractAdvanceRuntimeDataServiceImpl.java", "diffHunk": "@@ -0,0 +1,346 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.jbpm.kie.services.impl;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import javax.persistence.EntityManager;\n+import javax.persistence.EntityManagerFactory;\n+import javax.persistence.Query;\n+\n+import org.dashbuilder.dataset.filter.CoreFunctionType;\n+import org.jbpm.kie.services.impl.model.ProcessInstanceWithVarsDesc;\n+import org.jbpm.kie.services.impl.model.UserTaskInstanceWithPotOwnerDesc;\n+import org.jbpm.services.api.query.model.QueryParam;\n+import org.jbpm.shared.services.impl.QueryManager;\n+import org.jbpm.shared.services.impl.TransactionalCommandService;\n+import org.jbpm.shared.services.impl.commands.QueryNameCommand;\n+import org.kie.api.runtime.query.QueryContext;\n+\n+import static java.util.Collections.singletonMap;\n+\n+public abstract class AbstractAdvanceRuntimeDataServiceImpl {\n+\n+    private static final String ID_LIST = \"idList\";\n+    private EntityManagerFactory emf;\n+    private TransactionalCommandService commandService;\n+\n+    public AbstractAdvanceRuntimeDataServiceImpl() {\n+        QueryManager.get().addNamedQueries(\"META-INF/Servicesorm.xml\");\n+    }\n+    public void setCommandService(TransactionalCommandService commandService) {\n+        this.commandService = commandService;\n+    }\n+\n+    public void setEmf(EntityManagerFactory emf) {\n+        this.emf = emf;\n+    }\n+\n+\n+    public List<org.jbpm.services.api.model.ProcessInstanceWithVarsDesc> queryProcessByVariables(List<QueryParam> attributes,\n+                                                                                                 List<QueryParam> variables,\n+                                                                                                 int processType,\n+                                                                                                 String varPrefix,\n+                                                                                                 QueryContext queryContext) {\n+        EntityManager entityManager = emf.createEntityManager();\n+\n+        // first step is to filter the data creating a derived tables and pivoting var - rows to columns (only the variables we are interested to filter)\n+        StringBuilder derivedTables = new StringBuilder();\n+        if (!variables.isEmpty()) {\n+            List<String> conditions = new ArrayList<>();\n+            variables.stream().forEach(expr -> conditions.add(\"(A1.variableId = :NAME_\" + expr.getColumn() + \" AND \" + computeExpression(expr, \"A1.value\", \":VALUE_\" + expr.getColumn()) + \")\\n\"));\n+            String where = String.join(\" OR \", conditions);\n+            derivedTables.append(\"INNER JOIN (\" +\n+                                 \"SELECT A1.processInstanceId \\n\" +\n+                                 \"FROM VariableInstanceLog A1 \\n\" +\n+                                 \"LEFT JOIN VariableInstanceLog A2 ON A1.processId = A2.processId AND A1.processInstanceId = A2.processInstanceId AND A1.variableInstanceId = A2.variableInstanceId AND A2.id > A1.id  \\n\" +\n+                                 \"WHERE A2.id IS NULL AND (\" + where + \") \" +\n+                                 \"GROUP BY A1.processInstanceId \" +\n+                                 \"HAVING COUNT(*) = :NUMBER_OF_VARS \" +\n+                                 \") TABLE_VAR ON TABLE_VAR.processInstanceId = pil.processInstanceId \\n\");\n+        }\n+\n+        StringBuilder globalWhere = new StringBuilder();\n+        attributes.stream().forEach(expr -> globalWhere.append(\" AND \" + computeExpression(expr, expr.getColumn(), \":ATTR_\" + expr.getColumn())));\n+\n+        String procSQLString =\n+                \" SELECT DISTINCT pil.processInstanceId \" +\n+                               \" FROM ProcessInstanceLog pil \\n \" +\n+                               derivedTables +\n+                               \" WHERE pil.processType = :processType \" + globalWhere +\n+                               \" ORDER BY pil.processInstanceId ASC \";\n+\n+        Query query = entityManager.createNativeQuery(procSQLString);\n+        variables.stream().forEach(var -> query.setParameter(\"NAME_\" + var.getColumn(), varPrefix + var.getColumn()));\n+        variables.stream().filter(e -> e.getObjectValue() != null).forEach(var -> query.setParameter(\"VALUE_\" + var.getColumn(), var.getObjectValue()));\n+        attributes.stream().filter(e -> e.getObjectValue() != null).forEach((entry) -> query.setParameter(\"ATTR_\" + entry.getColumn(), entry.getObjectValue()));\n+\n+        if (!variables.isEmpty()) {\n+            query.setParameter(\"NUMBER_OF_VARS\", variables.size());\n+        }\n+        query.setParameter(\"processType\", processType);\n+\n+        addPagination(query, queryContext);\n+        List<Number> ids = query.getResultList();\n+        if (ids.isEmpty()) {\n+            return Collections.emptyList();\n+        }\n+\n+        // now we get the information\n+\n+        List<Object[]> procRows = commandService.execute(new QueryNameCommand<List<Object[]>>(\"GetProcessInstanceByIdList\", singletonMap(ID_LIST, ids)));\n+        List<Object[]> varRows = commandService.execute(new QueryNameCommand<List<Object[]>>(\"GetVariablesByProcessInstanceIdList\", singletonMap(ID_LIST, ids)));\n+\n+        int currentVarIdx = 0;\n+        List<org.jbpm.services.api.model.ProcessInstanceWithVarsDesc> data = new ArrayList<>();\n+        for (Object[] row : procRows) {\n+            ProcessInstanceWithVarsDesc pwv = toProcessInstanceWithVarsDesc(row);\n+\n+            Map<String, Object> vars = new HashMap<>();\n+            pwv.setVariables(vars);\n+\n+            Map<String, Object> extra = new HashMap<>();\n+            pwv.setExtraData(extra);\n+            while (currentVarIdx < varRows.size() && row[0].equals(varRows.get(currentVarIdx)[0])) {\n+                String name = (String) varRows.get(currentVarIdx)[1];\n+                if (!varPrefix.isEmpty() && name.startsWith(varPrefix)) {\n+                    extra.put(name.substring(varPrefix.length()), varRows.get(currentVarIdx)[2]);\n+                } else {\n+                    vars.put(name, varRows.get(currentVarIdx)[2]);\n+                }\n+                currentVarIdx++;\n+            }\n+            data.add(pwv);\n+        }\n+\n+        entityManager.close();\n+        return data;\n+    }\n+\n+    private String computeExpression(QueryParam expr, String leftOperand, String rightOperand) {\n+        CoreFunctionType type = CoreFunctionType.getByName(expr.getOperator());\n+        switch (type) {\n+            case IS_NULL:\n+                return leftOperand + \" IS NULL \";\n+            case NOT_NULL:\n+                return leftOperand + \" IS NOT NULL \";\n+            case IN:\n+                return leftOperand + \" IN (\" + rightOperand + \") \";\n+            case NOT_IN:\n+                return leftOperand + \" NOT IN (\" + rightOperand + \") \";\n+            case EQUALS_TO:\n+                return leftOperand + \" = \" + rightOperand + \" \";\n+            case NOT_EQUALS_TO:\n+                return leftOperand + \" <> \" + rightOperand + \" \";\n+            case LIKE_TO:\n+                return leftOperand + \" LIKE \" + rightOperand + \" \";\n+            default:\n+                throw new UnsupportedOperationException(\"Queryparam: \" + expr + \" not supported\");\n+        }\n+    }\n+    private ProcessInstanceWithVarsDesc toProcessInstanceWithVarsDesc(Object[] row) {\n+        return new ProcessInstanceWithVarsDesc(((Number) row[0]).longValue(),\n+                                               (String) row[1],\n+                                               (String) row[2],\n+                                               (String) row[3],\n+                                               ((Number) row[4]).intValue(),\n+                                               (String) row[5],\n+                                               (Date) row[6],\n+                                               (String) row[7],\n+                                               (String) row[8]);\n+    }\n+\n+    private void addPagination(Query query, QueryContext context) {\n+        if (context.getCount() > 0) {\n+            query.setFirstResult(context.getOffset());\n+            query.setMaxResults(context.getCount());\n+        }\n+    }\n+\n+    public List<org.jbpm.services.api.model.UserTaskInstanceWithPotOwnerDesc> queryUserTasksByVariables(List<QueryParam> attributes,\n+                                                                                                        List<QueryParam> variables,\n+                                                                                                        List<QueryParam> processVariables,\n+                                                                                                        List<String> owners,\n+                                                                                                        int processType,\n+                                                                                                        String varPrefix,\n+                                                                                                        QueryContext queryContext) {\n+        EntityManager entityManager = emf.createEntityManager();\n+        StringBuilder globalWhere = new StringBuilder();\n+        StringBuilder derivedTables = new StringBuilder();\n+        if (!variables.isEmpty()) {\n+            List<String> conditions = new ArrayList<>();\n+            variables.stream().forEach((expr) -> conditions.add(\"(name = :V_NAME_\" + expr.getColumn() + \" AND \" + computeExpression(expr, \"value\", \":V_VALUE_\" + expr.getColumn()) + \")\\n\"));\n+            String where = String.join(\" OR \", conditions);\n+            derivedTables.append(\"INNER JOIN (\\n\" +\n+                                 \"SELECT taskId \\n\" +\n+                                 \"FROM TaskVariableImpl \\n\" +\n+                                 \"WHERE type = 0 AND (\" + where + \")\\n\" +\n+                                 \"GROUP BY taskId \\n\" +\n+                                 \"HAVING COUNT(*) = :NUMBER_OF_TASKVARS \\n\" +\n+                                 \") TABLE_TASK_VAR ON TABLE_TASK_VAR.taskId = task.id  \\n\");\n+        }\n+\n+        if (!processVariables.isEmpty()) {\n+            List<String> conditions = new ArrayList<>();\n+            processVariables.stream().forEach((expr) -> conditions.add(\"(A1.variableId = :P_NAME_\" + expr.getColumn() + \" AND \" + computeExpression(expr, \"A1.value\", \":P_VALUE_\" + expr.getColumn()) + \")\\n\"));\n+            String where = String.join(\" OR \", conditions);\n+            derivedTables.append(\"INNER JOIN (\" +\n+                                 \"SELECT A1.processInstanceId \\n\" +\n+                                 \"FROM VariableInstanceLog A1 \\n\" +\n+                                 \"LEFT JOIN VariableInstanceLog A2 ON A1.processId = A2.processId AND A1.processInstanceId = A2.processInstanceId AND A1.variableInstanceId = A2.variableInstanceId AND A2.id > A1.id  \\n\" +\n+                                 \"WHERE A2.id IS NULL AND (\" + where + \") \" +\n+                                 \"GROUP BY A1.processInstanceId \" +\n+                                 \"HAVING COUNT(*) = :NUMBER_OF_PROCVARS \" +\n+                                 \") TABLE_PROC_VAR ON TABLE_PROC_VAR.processInstanceId = pil.processInstanceId \\n\");\n+        }\n+\n+        if (!owners.isEmpty()) {\n+            derivedTables.append(\"INNER JOIN ( \\n\" +\n+                             \"           SELECT DISTINCT po.task_id \\n\" +\n+                             \"           FROM PeopleAssignments_PotOwners po \\n\" +\n+                             \"           WHERE po.entity_id IN (:owners) \\n\" +", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f04f50355ec285330b3467d42754a036a04b1db3"}, "originalPosition": 220}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUzNzAwNzE2OnYy", "diffSide": "RIGHT", "path": "jbpm-services/jbpm-kie-services/src/main/java/org/jbpm/kie/services/impl/AbstractAdvanceRuntimeDataServiceImpl.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNVQwNzoyOTowMFrOGFtJhw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNVQwNzoyOTowMFrOGFtJhw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODYzNTc4Mw==", "bodyText": "Should we not close entityManager after fetching data in the collectData method?", "url": "https://github.com/kiegroup/jbpm/pull/1615#discussion_r408635783", "createdAt": "2020-04-15T07:29:00Z", "author": {"login": "afalhambra"}, "path": "jbpm-services/jbpm-kie-services/src/main/java/org/jbpm/kie/services/impl/AbstractAdvanceRuntimeDataServiceImpl.java", "diffHunk": "@@ -0,0 +1,346 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.jbpm.kie.services.impl;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import javax.persistence.EntityManager;\n+import javax.persistence.EntityManagerFactory;\n+import javax.persistence.Query;\n+\n+import org.dashbuilder.dataset.filter.CoreFunctionType;\n+import org.jbpm.kie.services.impl.model.ProcessInstanceWithVarsDesc;\n+import org.jbpm.kie.services.impl.model.UserTaskInstanceWithPotOwnerDesc;\n+import org.jbpm.services.api.query.model.QueryParam;\n+import org.jbpm.shared.services.impl.QueryManager;\n+import org.jbpm.shared.services.impl.TransactionalCommandService;\n+import org.jbpm.shared.services.impl.commands.QueryNameCommand;\n+import org.kie.api.runtime.query.QueryContext;\n+\n+import static java.util.Collections.singletonMap;\n+\n+public abstract class AbstractAdvanceRuntimeDataServiceImpl {\n+\n+    private static final String ID_LIST = \"idList\";\n+    private EntityManagerFactory emf;\n+    private TransactionalCommandService commandService;\n+\n+    public AbstractAdvanceRuntimeDataServiceImpl() {\n+        QueryManager.get().addNamedQueries(\"META-INF/Servicesorm.xml\");\n+    }\n+    public void setCommandService(TransactionalCommandService commandService) {\n+        this.commandService = commandService;\n+    }\n+\n+    public void setEmf(EntityManagerFactory emf) {\n+        this.emf = emf;\n+    }\n+\n+\n+    public List<org.jbpm.services.api.model.ProcessInstanceWithVarsDesc> queryProcessByVariables(List<QueryParam> attributes,\n+                                                                                                 List<QueryParam> variables,\n+                                                                                                 int processType,\n+                                                                                                 String varPrefix,\n+                                                                                                 QueryContext queryContext) {\n+        EntityManager entityManager = emf.createEntityManager();\n+\n+        // first step is to filter the data creating a derived tables and pivoting var - rows to columns (only the variables we are interested to filter)\n+        StringBuilder derivedTables = new StringBuilder();\n+        if (!variables.isEmpty()) {\n+            List<String> conditions = new ArrayList<>();\n+            variables.stream().forEach(expr -> conditions.add(\"(A1.variableId = :NAME_\" + expr.getColumn() + \" AND \" + computeExpression(expr, \"A1.value\", \":VALUE_\" + expr.getColumn()) + \")\\n\"));\n+            String where = String.join(\" OR \", conditions);\n+            derivedTables.append(\"INNER JOIN (\" +\n+                                 \"SELECT A1.processInstanceId \\n\" +\n+                                 \"FROM VariableInstanceLog A1 \\n\" +\n+                                 \"LEFT JOIN VariableInstanceLog A2 ON A1.processId = A2.processId AND A1.processInstanceId = A2.processInstanceId AND A1.variableInstanceId = A2.variableInstanceId AND A2.id > A1.id  \\n\" +\n+                                 \"WHERE A2.id IS NULL AND (\" + where + \") \" +\n+                                 \"GROUP BY A1.processInstanceId \" +\n+                                 \"HAVING COUNT(*) = :NUMBER_OF_VARS \" +\n+                                 \") TABLE_VAR ON TABLE_VAR.processInstanceId = pil.processInstanceId \\n\");\n+        }\n+\n+        StringBuilder globalWhere = new StringBuilder();\n+        attributes.stream().forEach(expr -> globalWhere.append(\" AND \" + computeExpression(expr, expr.getColumn(), \":ATTR_\" + expr.getColumn())));\n+\n+        String procSQLString =\n+                \" SELECT DISTINCT pil.processInstanceId \" +\n+                               \" FROM ProcessInstanceLog pil \\n \" +\n+                               derivedTables +\n+                               \" WHERE pil.processType = :processType \" + globalWhere +\n+                               \" ORDER BY pil.processInstanceId ASC \";\n+\n+        Query query = entityManager.createNativeQuery(procSQLString);\n+        variables.stream().forEach(var -> query.setParameter(\"NAME_\" + var.getColumn(), varPrefix + var.getColumn()));\n+        variables.stream().filter(e -> e.getObjectValue() != null).forEach(var -> query.setParameter(\"VALUE_\" + var.getColumn(), var.getObjectValue()));\n+        attributes.stream().filter(e -> e.getObjectValue() != null).forEach((entry) -> query.setParameter(\"ATTR_\" + entry.getColumn(), entry.getObjectValue()));\n+\n+        if (!variables.isEmpty()) {\n+            query.setParameter(\"NUMBER_OF_VARS\", variables.size());\n+        }\n+        query.setParameter(\"processType\", processType);\n+\n+        addPagination(query, queryContext);\n+        List<Number> ids = query.getResultList();\n+        if (ids.isEmpty()) {\n+            return Collections.emptyList();\n+        }\n+\n+        // now we get the information\n+\n+        List<Object[]> procRows = commandService.execute(new QueryNameCommand<List<Object[]>>(\"GetProcessInstanceByIdList\", singletonMap(ID_LIST, ids)));\n+        List<Object[]> varRows = commandService.execute(new QueryNameCommand<List<Object[]>>(\"GetVariablesByProcessInstanceIdList\", singletonMap(ID_LIST, ids)));\n+\n+        int currentVarIdx = 0;\n+        List<org.jbpm.services.api.model.ProcessInstanceWithVarsDesc> data = new ArrayList<>();\n+        for (Object[] row : procRows) {\n+            ProcessInstanceWithVarsDesc pwv = toProcessInstanceWithVarsDesc(row);\n+\n+            Map<String, Object> vars = new HashMap<>();\n+            pwv.setVariables(vars);\n+\n+            Map<String, Object> extra = new HashMap<>();\n+            pwv.setExtraData(extra);\n+            while (currentVarIdx < varRows.size() && row[0].equals(varRows.get(currentVarIdx)[0])) {\n+                String name = (String) varRows.get(currentVarIdx)[1];\n+                if (!varPrefix.isEmpty() && name.startsWith(varPrefix)) {\n+                    extra.put(name.substring(varPrefix.length()), varRows.get(currentVarIdx)[2]);\n+                } else {\n+                    vars.put(name, varRows.get(currentVarIdx)[2]);\n+                }\n+                currentVarIdx++;\n+            }\n+            data.add(pwv);\n+        }\n+\n+        entityManager.close();\n+        return data;\n+    }\n+\n+    private String computeExpression(QueryParam expr, String leftOperand, String rightOperand) {\n+        CoreFunctionType type = CoreFunctionType.getByName(expr.getOperator());\n+        switch (type) {\n+            case IS_NULL:\n+                return leftOperand + \" IS NULL \";\n+            case NOT_NULL:\n+                return leftOperand + \" IS NOT NULL \";\n+            case IN:\n+                return leftOperand + \" IN (\" + rightOperand + \") \";\n+            case NOT_IN:\n+                return leftOperand + \" NOT IN (\" + rightOperand + \") \";\n+            case EQUALS_TO:\n+                return leftOperand + \" = \" + rightOperand + \" \";\n+            case NOT_EQUALS_TO:\n+                return leftOperand + \" <> \" + rightOperand + \" \";\n+            case LIKE_TO:\n+                return leftOperand + \" LIKE \" + rightOperand + \" \";\n+            default:\n+                throw new UnsupportedOperationException(\"Queryparam: \" + expr + \" not supported\");\n+        }\n+    }\n+    private ProcessInstanceWithVarsDesc toProcessInstanceWithVarsDesc(Object[] row) {\n+        return new ProcessInstanceWithVarsDesc(((Number) row[0]).longValue(),\n+                                               (String) row[1],\n+                                               (String) row[2],\n+                                               (String) row[3],\n+                                               ((Number) row[4]).intValue(),\n+                                               (String) row[5],\n+                                               (Date) row[6],\n+                                               (String) row[7],\n+                                               (String) row[8]);\n+    }\n+\n+    private void addPagination(Query query, QueryContext context) {\n+        if (context.getCount() > 0) {\n+            query.setFirstResult(context.getOffset());\n+            query.setMaxResults(context.getCount());\n+        }\n+    }\n+\n+    public List<org.jbpm.services.api.model.UserTaskInstanceWithPotOwnerDesc> queryUserTasksByVariables(List<QueryParam> attributes,\n+                                                                                                        List<QueryParam> variables,\n+                                                                                                        List<QueryParam> processVariables,\n+                                                                                                        List<String> owners,\n+                                                                                                        int processType,\n+                                                                                                        String varPrefix,\n+                                                                                                        QueryContext queryContext) {\n+        EntityManager entityManager = emf.createEntityManager();\n+        StringBuilder globalWhere = new StringBuilder();\n+        StringBuilder derivedTables = new StringBuilder();\n+        if (!variables.isEmpty()) {\n+            List<String> conditions = new ArrayList<>();\n+            variables.stream().forEach((expr) -> conditions.add(\"(name = :V_NAME_\" + expr.getColumn() + \" AND \" + computeExpression(expr, \"value\", \":V_VALUE_\" + expr.getColumn()) + \")\\n\"));\n+            String where = String.join(\" OR \", conditions);\n+            derivedTables.append(\"INNER JOIN (\\n\" +\n+                                 \"SELECT taskId \\n\" +\n+                                 \"FROM TaskVariableImpl \\n\" +\n+                                 \"WHERE type = 0 AND (\" + where + \")\\n\" +\n+                                 \"GROUP BY taskId \\n\" +\n+                                 \"HAVING COUNT(*) = :NUMBER_OF_TASKVARS \\n\" +\n+                                 \") TABLE_TASK_VAR ON TABLE_TASK_VAR.taskId = task.id  \\n\");\n+        }\n+\n+        if (!processVariables.isEmpty()) {\n+            List<String> conditions = new ArrayList<>();\n+            processVariables.stream().forEach((expr) -> conditions.add(\"(A1.variableId = :P_NAME_\" + expr.getColumn() + \" AND \" + computeExpression(expr, \"A1.value\", \":P_VALUE_\" + expr.getColumn()) + \")\\n\"));\n+            String where = String.join(\" OR \", conditions);\n+            derivedTables.append(\"INNER JOIN (\" +\n+                                 \"SELECT A1.processInstanceId \\n\" +\n+                                 \"FROM VariableInstanceLog A1 \\n\" +\n+                                 \"LEFT JOIN VariableInstanceLog A2 ON A1.processId = A2.processId AND A1.processInstanceId = A2.processInstanceId AND A1.variableInstanceId = A2.variableInstanceId AND A2.id > A1.id  \\n\" +\n+                                 \"WHERE A2.id IS NULL AND (\" + where + \") \" +\n+                                 \"GROUP BY A1.processInstanceId \" +\n+                                 \"HAVING COUNT(*) = :NUMBER_OF_PROCVARS \" +\n+                                 \") TABLE_PROC_VAR ON TABLE_PROC_VAR.processInstanceId = pil.processInstanceId \\n\");\n+        }\n+\n+        if (!owners.isEmpty()) {\n+            derivedTables.append(\"INNER JOIN ( \\n\" +\n+                             \"           SELECT DISTINCT po.task_id \\n\" +\n+                             \"           FROM PeopleAssignments_PotOwners po \\n\" +\n+                             \"           WHERE po.entity_id IN (:owners) \\n\" +\n+                             \"           GROUP BY po.task_id \\n\" +\n+                             \"           HAVING COUNT(po.entity_id) = :num_owners \\n\" +\n+                                 \") pot ON pot.task_id = task.id \");\n+        }\n+\n+        attributes.stream().forEach((expr) -> globalWhere.append(\" AND \" + computeExpression(expr, expr.getColumn(), \":ATTR_\" + expr.getColumn())));\n+\n+        String procSQLString = \"SELECT DISTINCT task.id \" +\n+                               \" FROM Task task \" +\n+                               \" INNER JOIN ProcessInstanceLog pil ON pil.processInstanceId = task.processInstanceId \\n \" +\n+                               derivedTables +\n+                               \" WHERE  pil.processType = :processType \" + globalWhere +\n+                               \" ORDER BY task.id ASC \";\n+\n+        Query query = entityManager.createNativeQuery(procSQLString);\n+        variables.stream().forEach(var -> query.setParameter(\"V_NAME_\" + var.getColumn(), var.getColumn()));\n+        variables.stream().filter(e -> e.getObjectValue() != null).forEach((var) -> query.setParameter(\"V_VALUE_\" + var.getColumn(), var.getObjectValue()));\n+\n+        if (!variables.isEmpty()) {\n+            query.setParameter(\"NUMBER_OF_TASKVARS\", variables.size());\n+        }\n+\n+        processVariables.stream().forEach(var -> query.setParameter(\"P_NAME_\" + var.getColumn(), varPrefix + var.getColumn()));\n+        processVariables.stream().filter(e -> e.getObjectValue() != null).forEach((var) -> query.setParameter(\"P_VALUE_\" + var.getColumn(), var.getObjectValue()));\n+\n+        if (!processVariables.isEmpty()) {\n+            query.setParameter(\"NUMBER_OF_PROCVARS\", processVariables.size());\n+        }\n+\n+        if (!owners.isEmpty()) {\n+            query.setParameter(\"num_owners\", owners.size());\n+            query.setParameter(\"owners\", owners);\n+        }\n+\n+        attributes.stream().filter(e -> e.getObjectValue() != null).forEach(entry -> query.setParameter(\"ATTR_\" + entry.getColumn(), entry.getObjectValue()));\n+        query.setParameter(\"processType\", processType);\n+\n+        addPagination(query, queryContext);\n+\n+        List<Number> ids = query.getResultList();\n+        if (ids.isEmpty()) {\n+            return Collections.emptyList();\n+        }\n+\n+        entityManager.close();\n+        return collectData(ids, varPrefix);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f04f50355ec285330b3467d42754a036a04b1db3"}, "originalPosition": 266}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUzNzAyMzk5OnYy", "diffSide": "RIGHT", "path": "jbpm-services/jbpm-kie-services/src/main/java/org/jbpm/kie/services/impl/AbstractAdvanceRuntimeDataServiceImpl.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNVQwNzozMzo0NlrOGFtTuQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNVQwNzozMzo0NlrOGFtTuQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODYzODM5Mw==", "bodyText": "Would it not be better to use TaskVariable.VariableType.INPUT here instead of \"0\"?", "url": "https://github.com/kiegroup/jbpm/pull/1615#discussion_r408638393", "createdAt": "2020-04-15T07:33:46Z", "author": {"login": "afalhambra"}, "path": "jbpm-services/jbpm-kie-services/src/main/java/org/jbpm/kie/services/impl/AbstractAdvanceRuntimeDataServiceImpl.java", "diffHunk": "@@ -0,0 +1,346 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.jbpm.kie.services.impl;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import javax.persistence.EntityManager;\n+import javax.persistence.EntityManagerFactory;\n+import javax.persistence.Query;\n+\n+import org.dashbuilder.dataset.filter.CoreFunctionType;\n+import org.jbpm.kie.services.impl.model.ProcessInstanceWithVarsDesc;\n+import org.jbpm.kie.services.impl.model.UserTaskInstanceWithPotOwnerDesc;\n+import org.jbpm.services.api.query.model.QueryParam;\n+import org.jbpm.shared.services.impl.QueryManager;\n+import org.jbpm.shared.services.impl.TransactionalCommandService;\n+import org.jbpm.shared.services.impl.commands.QueryNameCommand;\n+import org.kie.api.runtime.query.QueryContext;\n+\n+import static java.util.Collections.singletonMap;\n+\n+public abstract class AbstractAdvanceRuntimeDataServiceImpl {\n+\n+    private static final String ID_LIST = \"idList\";\n+    private EntityManagerFactory emf;\n+    private TransactionalCommandService commandService;\n+\n+    public AbstractAdvanceRuntimeDataServiceImpl() {\n+        QueryManager.get().addNamedQueries(\"META-INF/Servicesorm.xml\");\n+    }\n+    public void setCommandService(TransactionalCommandService commandService) {\n+        this.commandService = commandService;\n+    }\n+\n+    public void setEmf(EntityManagerFactory emf) {\n+        this.emf = emf;\n+    }\n+\n+\n+    public List<org.jbpm.services.api.model.ProcessInstanceWithVarsDesc> queryProcessByVariables(List<QueryParam> attributes,\n+                                                                                                 List<QueryParam> variables,\n+                                                                                                 int processType,\n+                                                                                                 String varPrefix,\n+                                                                                                 QueryContext queryContext) {\n+        EntityManager entityManager = emf.createEntityManager();\n+\n+        // first step is to filter the data creating a derived tables and pivoting var - rows to columns (only the variables we are interested to filter)\n+        StringBuilder derivedTables = new StringBuilder();\n+        if (!variables.isEmpty()) {\n+            List<String> conditions = new ArrayList<>();\n+            variables.stream().forEach(expr -> conditions.add(\"(A1.variableId = :NAME_\" + expr.getColumn() + \" AND \" + computeExpression(expr, \"A1.value\", \":VALUE_\" + expr.getColumn()) + \")\\n\"));\n+            String where = String.join(\" OR \", conditions);\n+            derivedTables.append(\"INNER JOIN (\" +\n+                                 \"SELECT A1.processInstanceId \\n\" +\n+                                 \"FROM VariableInstanceLog A1 \\n\" +\n+                                 \"LEFT JOIN VariableInstanceLog A2 ON A1.processId = A2.processId AND A1.processInstanceId = A2.processInstanceId AND A1.variableInstanceId = A2.variableInstanceId AND A2.id > A1.id  \\n\" +\n+                                 \"WHERE A2.id IS NULL AND (\" + where + \") \" +\n+                                 \"GROUP BY A1.processInstanceId \" +\n+                                 \"HAVING COUNT(*) = :NUMBER_OF_VARS \" +\n+                                 \") TABLE_VAR ON TABLE_VAR.processInstanceId = pil.processInstanceId \\n\");\n+        }\n+\n+        StringBuilder globalWhere = new StringBuilder();\n+        attributes.stream().forEach(expr -> globalWhere.append(\" AND \" + computeExpression(expr, expr.getColumn(), \":ATTR_\" + expr.getColumn())));\n+\n+        String procSQLString =\n+                \" SELECT DISTINCT pil.processInstanceId \" +\n+                               \" FROM ProcessInstanceLog pil \\n \" +\n+                               derivedTables +\n+                               \" WHERE pil.processType = :processType \" + globalWhere +\n+                               \" ORDER BY pil.processInstanceId ASC \";\n+\n+        Query query = entityManager.createNativeQuery(procSQLString);\n+        variables.stream().forEach(var -> query.setParameter(\"NAME_\" + var.getColumn(), varPrefix + var.getColumn()));\n+        variables.stream().filter(e -> e.getObjectValue() != null).forEach(var -> query.setParameter(\"VALUE_\" + var.getColumn(), var.getObjectValue()));\n+        attributes.stream().filter(e -> e.getObjectValue() != null).forEach((entry) -> query.setParameter(\"ATTR_\" + entry.getColumn(), entry.getObjectValue()));\n+\n+        if (!variables.isEmpty()) {\n+            query.setParameter(\"NUMBER_OF_VARS\", variables.size());\n+        }\n+        query.setParameter(\"processType\", processType);\n+\n+        addPagination(query, queryContext);\n+        List<Number> ids = query.getResultList();\n+        if (ids.isEmpty()) {\n+            return Collections.emptyList();\n+        }\n+\n+        // now we get the information\n+\n+        List<Object[]> procRows = commandService.execute(new QueryNameCommand<List<Object[]>>(\"GetProcessInstanceByIdList\", singletonMap(ID_LIST, ids)));\n+        List<Object[]> varRows = commandService.execute(new QueryNameCommand<List<Object[]>>(\"GetVariablesByProcessInstanceIdList\", singletonMap(ID_LIST, ids)));\n+\n+        int currentVarIdx = 0;\n+        List<org.jbpm.services.api.model.ProcessInstanceWithVarsDesc> data = new ArrayList<>();\n+        for (Object[] row : procRows) {\n+            ProcessInstanceWithVarsDesc pwv = toProcessInstanceWithVarsDesc(row);\n+\n+            Map<String, Object> vars = new HashMap<>();\n+            pwv.setVariables(vars);\n+\n+            Map<String, Object> extra = new HashMap<>();\n+            pwv.setExtraData(extra);\n+            while (currentVarIdx < varRows.size() && row[0].equals(varRows.get(currentVarIdx)[0])) {\n+                String name = (String) varRows.get(currentVarIdx)[1];\n+                if (!varPrefix.isEmpty() && name.startsWith(varPrefix)) {\n+                    extra.put(name.substring(varPrefix.length()), varRows.get(currentVarIdx)[2]);\n+                } else {\n+                    vars.put(name, varRows.get(currentVarIdx)[2]);\n+                }\n+                currentVarIdx++;\n+            }\n+            data.add(pwv);\n+        }\n+\n+        entityManager.close();\n+        return data;\n+    }\n+\n+    private String computeExpression(QueryParam expr, String leftOperand, String rightOperand) {\n+        CoreFunctionType type = CoreFunctionType.getByName(expr.getOperator());\n+        switch (type) {\n+            case IS_NULL:\n+                return leftOperand + \" IS NULL \";\n+            case NOT_NULL:\n+                return leftOperand + \" IS NOT NULL \";\n+            case IN:\n+                return leftOperand + \" IN (\" + rightOperand + \") \";\n+            case NOT_IN:\n+                return leftOperand + \" NOT IN (\" + rightOperand + \") \";\n+            case EQUALS_TO:\n+                return leftOperand + \" = \" + rightOperand + \" \";\n+            case NOT_EQUALS_TO:\n+                return leftOperand + \" <> \" + rightOperand + \" \";\n+            case LIKE_TO:\n+                return leftOperand + \" LIKE \" + rightOperand + \" \";\n+            default:\n+                throw new UnsupportedOperationException(\"Queryparam: \" + expr + \" not supported\");\n+        }\n+    }\n+    private ProcessInstanceWithVarsDesc toProcessInstanceWithVarsDesc(Object[] row) {\n+        return new ProcessInstanceWithVarsDesc(((Number) row[0]).longValue(),\n+                                               (String) row[1],\n+                                               (String) row[2],\n+                                               (String) row[3],\n+                                               ((Number) row[4]).intValue(),\n+                                               (String) row[5],\n+                                               (Date) row[6],\n+                                               (String) row[7],\n+                                               (String) row[8]);\n+    }\n+\n+    private void addPagination(Query query, QueryContext context) {\n+        if (context.getCount() > 0) {\n+            query.setFirstResult(context.getOffset());\n+            query.setMaxResults(context.getCount());\n+        }\n+    }\n+\n+    public List<org.jbpm.services.api.model.UserTaskInstanceWithPotOwnerDesc> queryUserTasksByVariables(List<QueryParam> attributes,\n+                                                                                                        List<QueryParam> variables,\n+                                                                                                        List<QueryParam> processVariables,\n+                                                                                                        List<String> owners,\n+                                                                                                        int processType,\n+                                                                                                        String varPrefix,\n+                                                                                                        QueryContext queryContext) {\n+        EntityManager entityManager = emf.createEntityManager();\n+        StringBuilder globalWhere = new StringBuilder();\n+        StringBuilder derivedTables = new StringBuilder();\n+        if (!variables.isEmpty()) {\n+            List<String> conditions = new ArrayList<>();\n+            variables.stream().forEach((expr) -> conditions.add(\"(name = :V_NAME_\" + expr.getColumn() + \" AND \" + computeExpression(expr, \"value\", \":V_VALUE_\" + expr.getColumn()) + \")\\n\"));\n+            String where = String.join(\" OR \", conditions);\n+            derivedTables.append(\"INNER JOIN (\\n\" +\n+                                 \"SELECT taskId \\n\" +\n+                                 \"FROM TaskVariableImpl \\n\" +\n+                                 \"WHERE type = 0 AND (\" + where + \")\\n\" +\n+                                 \"GROUP BY taskId \\n\" +\n+                                 \"HAVING COUNT(*) = :NUMBER_OF_TASKVARS \\n\" +\n+                                 \") TABLE_TASK_VAR ON TABLE_TASK_VAR.taskId = task.id  \\n\");\n+        }\n+\n+        if (!processVariables.isEmpty()) {\n+            List<String> conditions = new ArrayList<>();\n+            processVariables.stream().forEach((expr) -> conditions.add(\"(A1.variableId = :P_NAME_\" + expr.getColumn() + \" AND \" + computeExpression(expr, \"A1.value\", \":P_VALUE_\" + expr.getColumn()) + \")\\n\"));\n+            String where = String.join(\" OR \", conditions);\n+            derivedTables.append(\"INNER JOIN (\" +\n+                                 \"SELECT A1.processInstanceId \\n\" +\n+                                 \"FROM VariableInstanceLog A1 \\n\" +\n+                                 \"LEFT JOIN VariableInstanceLog A2 ON A1.processId = A2.processId AND A1.processInstanceId = A2.processInstanceId AND A1.variableInstanceId = A2.variableInstanceId AND A2.id > A1.id  \\n\" +\n+                                 \"WHERE A2.id IS NULL AND (\" + where + \") \" +\n+                                 \"GROUP BY A1.processInstanceId \" +\n+                                 \"HAVING COUNT(*) = :NUMBER_OF_PROCVARS \" +\n+                                 \") TABLE_PROC_VAR ON TABLE_PROC_VAR.processInstanceId = pil.processInstanceId \\n\");\n+        }\n+\n+        if (!owners.isEmpty()) {\n+            derivedTables.append(\"INNER JOIN ( \\n\" +\n+                             \"           SELECT DISTINCT po.task_id \\n\" +\n+                             \"           FROM PeopleAssignments_PotOwners po \\n\" +\n+                             \"           WHERE po.entity_id IN (:owners) \\n\" +\n+                             \"           GROUP BY po.task_id \\n\" +\n+                             \"           HAVING COUNT(po.entity_id) = :num_owners \\n\" +\n+                                 \") pot ON pot.task_id = task.id \");\n+        }\n+\n+        attributes.stream().forEach((expr) -> globalWhere.append(\" AND \" + computeExpression(expr, expr.getColumn(), \":ATTR_\" + expr.getColumn())));\n+\n+        String procSQLString = \"SELECT DISTINCT task.id \" +\n+                               \" FROM Task task \" +\n+                               \" INNER JOIN ProcessInstanceLog pil ON pil.processInstanceId = task.processInstanceId \\n \" +\n+                               derivedTables +\n+                               \" WHERE  pil.processType = :processType \" + globalWhere +\n+                               \" ORDER BY task.id ASC \";\n+\n+        Query query = entityManager.createNativeQuery(procSQLString);\n+        variables.stream().forEach(var -> query.setParameter(\"V_NAME_\" + var.getColumn(), var.getColumn()));\n+        variables.stream().filter(e -> e.getObjectValue() != null).forEach((var) -> query.setParameter(\"V_VALUE_\" + var.getColumn(), var.getObjectValue()));\n+\n+        if (!variables.isEmpty()) {\n+            query.setParameter(\"NUMBER_OF_TASKVARS\", variables.size());\n+        }\n+\n+        processVariables.stream().forEach(var -> query.setParameter(\"P_NAME_\" + var.getColumn(), varPrefix + var.getColumn()));\n+        processVariables.stream().filter(e -> e.getObjectValue() != null).forEach((var) -> query.setParameter(\"P_VALUE_\" + var.getColumn(), var.getObjectValue()));\n+\n+        if (!processVariables.isEmpty()) {\n+            query.setParameter(\"NUMBER_OF_PROCVARS\", processVariables.size());\n+        }\n+\n+        if (!owners.isEmpty()) {\n+            query.setParameter(\"num_owners\", owners.size());\n+            query.setParameter(\"owners\", owners);\n+        }\n+\n+        attributes.stream().filter(e -> e.getObjectValue() != null).forEach(entry -> query.setParameter(\"ATTR_\" + entry.getColumn(), entry.getObjectValue()));\n+        query.setParameter(\"processType\", processType);\n+\n+        addPagination(query, queryContext);\n+\n+        List<Number> ids = query.getResultList();\n+        if (ids.isEmpty()) {\n+            return Collections.emptyList();\n+        }\n+\n+        entityManager.close();\n+        return collectData(ids, varPrefix);\n+\n+    }\n+\n+    private List<org.jbpm.services.api.model.UserTaskInstanceWithPotOwnerDesc> collectData(List<Number> ids, String varPrefix) {\n+        // query data\n+        List<Object[]> taskRows = commandService.execute(new QueryNameCommand<List<Object[]>>(\"GetTasksByIdList\", singletonMap(ID_LIST, ids)));\n+        List<Object[]> varRows = commandService.execute(new QueryNameCommand<List<Object[]>>(\"GetTaskVariablesByTaskIdList\", singletonMap(ID_LIST, ids)));\n+        List<Object[]> potRows = commandService.execute(new QueryNameCommand<List<Object[]>>(\"GetPotentialOwnersByTaskIdList\", singletonMap(ID_LIST, ids)));\n+        List<Object[]> varProcSQLRows = commandService.execute(new QueryNameCommand<List<Object[]>>(\"GetProcessVariablesByTaskIdList\", singletonMap(ID_LIST, ids)));\n+\n+        int currentVarIdx = 0;\n+        int currentPotIdx = 0;\n+        int currentVarProcIdx = 0;\n+        List<org.jbpm.services.api.model.UserTaskInstanceWithPotOwnerDesc> data = new ArrayList<>();\n+        for (Object[] row : taskRows) {\n+            UserTaskInstanceWithPotOwnerDesc pwv = toUserTaskInstanceWithPotOwnerDesc(row);\n+\n+            while (currentVarIdx < varRows.size() && row[0].equals(varRows.get(currentVarIdx)[0])) {\n+                if (((Number) varRows.get(currentVarIdx)[1]).intValue() == 0) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f04f50355ec285330b3467d42754a036a04b1db3"}, "originalPosition": 285}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUzNzA1MTM4OnYy", "diffSide": "RIGHT", "path": "jbpm-services/jbpm-kie-services/src/main/java/org/jbpm/kie/services/impl/AdvanceRuntimeDataServiceImpl.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNVQwNzo0MTozNlrOGFtkMQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQwOTowMToyM1rOGIKbAA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODY0MjYwOQ==", "bodyText": "Would it make sense to declare translateTable as final?", "url": "https://github.com/kiegroup/jbpm/pull/1615#discussion_r408642609", "createdAt": "2020-04-15T07:41:36Z", "author": {"login": "afalhambra"}, "path": "jbpm-services/jbpm-kie-services/src/main/java/org/jbpm/kie/services/impl/AdvanceRuntimeDataServiceImpl.java", "diffHunk": "@@ -0,0 +1,62 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.jbpm.kie.services.impl;\n+\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.jbpm.services.api.AdvanceRuntimeDataService;\n+import org.jbpm.services.api.query.model.QueryParam;\n+import org.kie.api.runtime.query.QueryContext;\n+\n+import static org.jbpm.workflow.core.WorkflowProcess.PROCESS_TYPE;\n+\n+public class AdvanceRuntimeDataServiceImpl extends AbstractAdvanceRuntimeDataServiceImpl implements AdvanceRuntimeDataService {\n+\n+    private Map<String, String> translateTable = new HashMap<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f04f50355ec285330b3467d42754a036a04b1db3"}, "originalPosition": 31}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTIxMjU0NA==", "bodyText": "ok", "url": "https://github.com/kiegroup/jbpm/pull/1615#discussion_r411212544", "createdAt": "2020-04-20T09:01:23Z", "author": {"login": "elguardian"}, "path": "jbpm-services/jbpm-kie-services/src/main/java/org/jbpm/kie/services/impl/AdvanceRuntimeDataServiceImpl.java", "diffHunk": "@@ -0,0 +1,62 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.jbpm.kie.services.impl;\n+\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.jbpm.services.api.AdvanceRuntimeDataService;\n+import org.jbpm.services.api.query.model.QueryParam;\n+import org.kie.api.runtime.query.QueryContext;\n+\n+import static org.jbpm.workflow.core.WorkflowProcess.PROCESS_TYPE;\n+\n+public class AdvanceRuntimeDataServiceImpl extends AbstractAdvanceRuntimeDataServiceImpl implements AdvanceRuntimeDataService {\n+\n+    private Map<String, String> translateTable = new HashMap<>();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODY0MjYwOQ=="}, "originalCommit": {"oid": "f04f50355ec285330b3467d42754a036a04b1db3"}, "originalPosition": 31}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUzNzA2MzMzOnYy", "diffSide": "RIGHT", "path": "jbpm-services/jbpm-kie-services/src/main/java/org/jbpm/kie/services/impl/model/UserTaskInstanceWithPotOwnerDesc.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNVQwNzo0NDo0MVrOGFtrTw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQwOTowMTo1M1rOGIKcNw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODY0NDQzMQ==", "bodyText": "Map is not serializable (same as inputdata and outputdata members). I guess it won't be an issue? It could cause some issues when serializing/deserializing these. Should we use HashMap instead or should we leave it as is? wdyt?", "url": "https://github.com/kiegroup/jbpm/pull/1615#discussion_r408644431", "createdAt": "2020-04-15T07:44:41Z", "author": {"login": "afalhambra"}, "path": "jbpm-services/jbpm-kie-services/src/main/java/org/jbpm/kie/services/impl/model/UserTaskInstanceWithPotOwnerDesc.java", "diffHunk": "@@ -36,6 +36,8 @@\n     private Map<String,Object> inputdata;\n     private Map<String,Object> outputdata;\n     private String processInstanceDescription;\n+    private Map<String, Object> processVariables;\n+    private Map<String, Object> data;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f04f50355ec285330b3467d42754a036a04b1db3"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTIxMjg1NQ==", "bodyText": "leave it. just silly thing from sonar. It cannot detect runtime statff.", "url": "https://github.com/kiegroup/jbpm/pull/1615#discussion_r411212855", "createdAt": "2020-04-20T09:01:53Z", "author": {"login": "elguardian"}, "path": "jbpm-services/jbpm-kie-services/src/main/java/org/jbpm/kie/services/impl/model/UserTaskInstanceWithPotOwnerDesc.java", "diffHunk": "@@ -36,6 +36,8 @@\n     private Map<String,Object> inputdata;\n     private Map<String,Object> outputdata;\n     private String processInstanceDescription;\n+    private Map<String, Object> processVariables;\n+    private Map<String, Object> data;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODY0NDQzMQ=="}, "originalCommit": {"oid": "f04f50355ec285330b3467d42754a036a04b1db3"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUzNzE1MDc4OnYy", "diffSide": "RIGHT", "path": "jbpm-services/jbpm-kie-services/src/test/java/org/jbpm/kie/services/test/AdvanceRuntimeDataServiceImplTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNVQwODowOTo1NFrOGFuiow==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQwOTowMzo0NlrOGIKg8g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODY1ODU5NQ==", "bodyText": "ArrayList < String > is redundant. ArrayList<> should be enough", "url": "https://github.com/kiegroup/jbpm/pull/1615#discussion_r408658595", "createdAt": "2020-04-15T08:09:54Z", "author": {"login": "afalhambra"}, "path": "jbpm-services/jbpm-kie-services/src/test/java/org/jbpm/kie/services/test/AdvanceRuntimeDataServiceImplTest.java", "diffHunk": "@@ -0,0 +1,359 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.jbpm.kie.services.test;\n+\n+import java.io.File;\n+import java.io.FileOutputStream;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.drools.compiler.kie.builder.impl.InternalKieModule;\n+import org.jbpm.kie.services.impl.KModuleDeploymentUnit;\n+import org.jbpm.kie.test.util.AbstractKieServicesBaseTest;\n+import org.jbpm.services.api.ProcessInstanceNotFoundException;\n+import org.jbpm.services.api.model.DeploymentUnit;\n+import org.jbpm.services.api.model.ProcessInstanceWithVarsDesc;\n+import org.jbpm.services.api.model.UserTaskInstanceWithPotOwnerDesc;\n+import org.jbpm.services.api.query.model.QueryParam;\n+import org.junit.After;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.Parameterized;\n+import org.junit.runners.Parameterized.Parameters;\n+import org.kie.api.KieServices;\n+import org.kie.api.builder.ReleaseId;\n+import org.kie.api.runtime.process.ProcessInstance;\n+import org.kie.internal.query.QueryContext;\n+import org.kie.scanner.KieMavenRepository;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static java.util.Collections.emptyList;\n+import static org.hamcrest.CoreMatchers.is;\n+import static org.jbpm.services.api.AdvanceRuntimeDataService.PROCESS_ATTR_CORRELATION_KEY;\n+import static org.jbpm.services.api.AdvanceRuntimeDataService.PROCESS_ATTR_DEFINITION_ID;\n+import static org.jbpm.services.api.AdvanceRuntimeDataService.PROCESS_ATTR_DEPLOYMENT_ID;\n+import static org.jbpm.services.api.AdvanceRuntimeDataService.TASK_ATTR_NAME;\n+import static org.jbpm.services.api.AdvanceRuntimeDataService.TASK_ATTR_OWNER;\n+import static org.jbpm.services.api.query.model.QueryParam.equalsTo;\n+import static org.jbpm.services.api.query.model.QueryParam.in;\n+import static org.jbpm.services.api.query.model.QueryParam.isNotNull;\n+import static org.jbpm.services.api.query.model.QueryParam.isNull;\n+import static org.jbpm.services.api.query.model.QueryParam.likeTo;\n+import static org.jbpm.services.api.query.model.QueryParam.list;\n+import static org.jbpm.services.api.query.model.QueryParam.notEqualsTo;\n+import static org.jbpm.services.api.query.model.QueryParam.notIn;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertNull;\n+import static org.kie.scanner.KieMavenRepository.getKieMavenRepository;\n+\n+@RunWith(Parameterized.class)\n+public class AdvanceRuntimeDataServiceImplTest extends AbstractKieServicesBaseTest {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(AdvanceRuntimeDataServiceImplTest.class);\n+\n+    @Parameters(name = \"Pagination {0}\")\n+    public static Iterable<? extends Object> data() {\n+        return Arrays.asList(0, 2);\n+    }\n+\n+    private List<DeploymentUnit> units = new ArrayList<DeploymentUnit>();\n+    protected String correctUser = \"testUser\";\n+    protected String wrongUser = \"wrongUser\";\n+\n+    private List<Long> processIds;\n+    private KModuleDeploymentUnit deploymentUnit = null;\n+    private QueryContext queryContext;\n+\n+    public AdvanceRuntimeDataServiceImplTest(Integer count) {\n+        this.queryContext = new QueryContext(0, count);\n+    }\n+\n+    @Before\n+    public void prepare() {\n+\n+        configureServices();\n+        logger.debug(\"Preparing kjar\");\n+        KieServices ks = KieServices.Factory.get();\n+        ReleaseId releaseId = ks.newReleaseId(GROUP_ID, ARTIFACT_ID, VERSION);\n+        List<String> processes = new ArrayList<String>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f04f50355ec285330b3467d42754a036a04b1db3"}, "originalPosition": 99}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTIxNDA2Ng==", "bodyText": "ok", "url": "https://github.com/kiegroup/jbpm/pull/1615#discussion_r411214066", "createdAt": "2020-04-20T09:03:46Z", "author": {"login": "elguardian"}, "path": "jbpm-services/jbpm-kie-services/src/test/java/org/jbpm/kie/services/test/AdvanceRuntimeDataServiceImplTest.java", "diffHunk": "@@ -0,0 +1,359 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.jbpm.kie.services.test;\n+\n+import java.io.File;\n+import java.io.FileOutputStream;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.drools.compiler.kie.builder.impl.InternalKieModule;\n+import org.jbpm.kie.services.impl.KModuleDeploymentUnit;\n+import org.jbpm.kie.test.util.AbstractKieServicesBaseTest;\n+import org.jbpm.services.api.ProcessInstanceNotFoundException;\n+import org.jbpm.services.api.model.DeploymentUnit;\n+import org.jbpm.services.api.model.ProcessInstanceWithVarsDesc;\n+import org.jbpm.services.api.model.UserTaskInstanceWithPotOwnerDesc;\n+import org.jbpm.services.api.query.model.QueryParam;\n+import org.junit.After;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.Parameterized;\n+import org.junit.runners.Parameterized.Parameters;\n+import org.kie.api.KieServices;\n+import org.kie.api.builder.ReleaseId;\n+import org.kie.api.runtime.process.ProcessInstance;\n+import org.kie.internal.query.QueryContext;\n+import org.kie.scanner.KieMavenRepository;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static java.util.Collections.emptyList;\n+import static org.hamcrest.CoreMatchers.is;\n+import static org.jbpm.services.api.AdvanceRuntimeDataService.PROCESS_ATTR_CORRELATION_KEY;\n+import static org.jbpm.services.api.AdvanceRuntimeDataService.PROCESS_ATTR_DEFINITION_ID;\n+import static org.jbpm.services.api.AdvanceRuntimeDataService.PROCESS_ATTR_DEPLOYMENT_ID;\n+import static org.jbpm.services.api.AdvanceRuntimeDataService.TASK_ATTR_NAME;\n+import static org.jbpm.services.api.AdvanceRuntimeDataService.TASK_ATTR_OWNER;\n+import static org.jbpm.services.api.query.model.QueryParam.equalsTo;\n+import static org.jbpm.services.api.query.model.QueryParam.in;\n+import static org.jbpm.services.api.query.model.QueryParam.isNotNull;\n+import static org.jbpm.services.api.query.model.QueryParam.isNull;\n+import static org.jbpm.services.api.query.model.QueryParam.likeTo;\n+import static org.jbpm.services.api.query.model.QueryParam.list;\n+import static org.jbpm.services.api.query.model.QueryParam.notEqualsTo;\n+import static org.jbpm.services.api.query.model.QueryParam.notIn;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertNull;\n+import static org.kie.scanner.KieMavenRepository.getKieMavenRepository;\n+\n+@RunWith(Parameterized.class)\n+public class AdvanceRuntimeDataServiceImplTest extends AbstractKieServicesBaseTest {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(AdvanceRuntimeDataServiceImplTest.class);\n+\n+    @Parameters(name = \"Pagination {0}\")\n+    public static Iterable<? extends Object> data() {\n+        return Arrays.asList(0, 2);\n+    }\n+\n+    private List<DeploymentUnit> units = new ArrayList<DeploymentUnit>();\n+    protected String correctUser = \"testUser\";\n+    protected String wrongUser = \"wrongUser\";\n+\n+    private List<Long> processIds;\n+    private KModuleDeploymentUnit deploymentUnit = null;\n+    private QueryContext queryContext;\n+\n+    public AdvanceRuntimeDataServiceImplTest(Integer count) {\n+        this.queryContext = new QueryContext(0, count);\n+    }\n+\n+    @Before\n+    public void prepare() {\n+\n+        configureServices();\n+        logger.debug(\"Preparing kjar\");\n+        KieServices ks = KieServices.Factory.get();\n+        ReleaseId releaseId = ks.newReleaseId(GROUP_ID, ARTIFACT_ID, VERSION);\n+        List<String> processes = new ArrayList<String>();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODY1ODU5NQ=="}, "originalCommit": {"oid": "f04f50355ec285330b3467d42754a036a04b1db3"}, "originalPosition": 99}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUzNzE1MzMxOnYy", "diffSide": "RIGHT", "path": "jbpm-services/jbpm-kie-services/src/test/java/org/jbpm/kie/services/test/AdvanceRuntimeDataServiceImplTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNVQwODoxMDozOFrOGFukJg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQwOTowMzoyNVrOGIKf4A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODY1ODk4Mg==", "bodyText": "These members are not used. Please remove them.", "url": "https://github.com/kiegroup/jbpm/pull/1615#discussion_r408658982", "createdAt": "2020-04-15T08:10:38Z", "author": {"login": "afalhambra"}, "path": "jbpm-services/jbpm-kie-services/src/test/java/org/jbpm/kie/services/test/AdvanceRuntimeDataServiceImplTest.java", "diffHunk": "@@ -0,0 +1,359 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.jbpm.kie.services.test;\n+\n+import java.io.File;\n+import java.io.FileOutputStream;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.drools.compiler.kie.builder.impl.InternalKieModule;\n+import org.jbpm.kie.services.impl.KModuleDeploymentUnit;\n+import org.jbpm.kie.test.util.AbstractKieServicesBaseTest;\n+import org.jbpm.services.api.ProcessInstanceNotFoundException;\n+import org.jbpm.services.api.model.DeploymentUnit;\n+import org.jbpm.services.api.model.ProcessInstanceWithVarsDesc;\n+import org.jbpm.services.api.model.UserTaskInstanceWithPotOwnerDesc;\n+import org.jbpm.services.api.query.model.QueryParam;\n+import org.junit.After;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.Parameterized;\n+import org.junit.runners.Parameterized.Parameters;\n+import org.kie.api.KieServices;\n+import org.kie.api.builder.ReleaseId;\n+import org.kie.api.runtime.process.ProcessInstance;\n+import org.kie.internal.query.QueryContext;\n+import org.kie.scanner.KieMavenRepository;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static java.util.Collections.emptyList;\n+import static org.hamcrest.CoreMatchers.is;\n+import static org.jbpm.services.api.AdvanceRuntimeDataService.PROCESS_ATTR_CORRELATION_KEY;\n+import static org.jbpm.services.api.AdvanceRuntimeDataService.PROCESS_ATTR_DEFINITION_ID;\n+import static org.jbpm.services.api.AdvanceRuntimeDataService.PROCESS_ATTR_DEPLOYMENT_ID;\n+import static org.jbpm.services.api.AdvanceRuntimeDataService.TASK_ATTR_NAME;\n+import static org.jbpm.services.api.AdvanceRuntimeDataService.TASK_ATTR_OWNER;\n+import static org.jbpm.services.api.query.model.QueryParam.equalsTo;\n+import static org.jbpm.services.api.query.model.QueryParam.in;\n+import static org.jbpm.services.api.query.model.QueryParam.isNotNull;\n+import static org.jbpm.services.api.query.model.QueryParam.isNull;\n+import static org.jbpm.services.api.query.model.QueryParam.likeTo;\n+import static org.jbpm.services.api.query.model.QueryParam.list;\n+import static org.jbpm.services.api.query.model.QueryParam.notEqualsTo;\n+import static org.jbpm.services.api.query.model.QueryParam.notIn;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertNull;\n+import static org.kie.scanner.KieMavenRepository.getKieMavenRepository;\n+\n+@RunWith(Parameterized.class)\n+public class AdvanceRuntimeDataServiceImplTest extends AbstractKieServicesBaseTest {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(AdvanceRuntimeDataServiceImplTest.class);\n+\n+    @Parameters(name = \"Pagination {0}\")\n+    public static Iterable<? extends Object> data() {\n+        return Arrays.asList(0, 2);\n+    }\n+\n+    private List<DeploymentUnit> units = new ArrayList<DeploymentUnit>();\n+    protected String correctUser = \"testUser\";\n+    protected String wrongUser = \"wrongUser\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f04f50355ec285330b3467d42754a036a04b1db3"}, "originalPosition": 82}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTIxMzc5Mg==", "bodyText": "ok", "url": "https://github.com/kiegroup/jbpm/pull/1615#discussion_r411213792", "createdAt": "2020-04-20T09:03:25Z", "author": {"login": "elguardian"}, "path": "jbpm-services/jbpm-kie-services/src/test/java/org/jbpm/kie/services/test/AdvanceRuntimeDataServiceImplTest.java", "diffHunk": "@@ -0,0 +1,359 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.jbpm.kie.services.test;\n+\n+import java.io.File;\n+import java.io.FileOutputStream;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.drools.compiler.kie.builder.impl.InternalKieModule;\n+import org.jbpm.kie.services.impl.KModuleDeploymentUnit;\n+import org.jbpm.kie.test.util.AbstractKieServicesBaseTest;\n+import org.jbpm.services.api.ProcessInstanceNotFoundException;\n+import org.jbpm.services.api.model.DeploymentUnit;\n+import org.jbpm.services.api.model.ProcessInstanceWithVarsDesc;\n+import org.jbpm.services.api.model.UserTaskInstanceWithPotOwnerDesc;\n+import org.jbpm.services.api.query.model.QueryParam;\n+import org.junit.After;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.Parameterized;\n+import org.junit.runners.Parameterized.Parameters;\n+import org.kie.api.KieServices;\n+import org.kie.api.builder.ReleaseId;\n+import org.kie.api.runtime.process.ProcessInstance;\n+import org.kie.internal.query.QueryContext;\n+import org.kie.scanner.KieMavenRepository;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static java.util.Collections.emptyList;\n+import static org.hamcrest.CoreMatchers.is;\n+import static org.jbpm.services.api.AdvanceRuntimeDataService.PROCESS_ATTR_CORRELATION_KEY;\n+import static org.jbpm.services.api.AdvanceRuntimeDataService.PROCESS_ATTR_DEFINITION_ID;\n+import static org.jbpm.services.api.AdvanceRuntimeDataService.PROCESS_ATTR_DEPLOYMENT_ID;\n+import static org.jbpm.services.api.AdvanceRuntimeDataService.TASK_ATTR_NAME;\n+import static org.jbpm.services.api.AdvanceRuntimeDataService.TASK_ATTR_OWNER;\n+import static org.jbpm.services.api.query.model.QueryParam.equalsTo;\n+import static org.jbpm.services.api.query.model.QueryParam.in;\n+import static org.jbpm.services.api.query.model.QueryParam.isNotNull;\n+import static org.jbpm.services.api.query.model.QueryParam.isNull;\n+import static org.jbpm.services.api.query.model.QueryParam.likeTo;\n+import static org.jbpm.services.api.query.model.QueryParam.list;\n+import static org.jbpm.services.api.query.model.QueryParam.notEqualsTo;\n+import static org.jbpm.services.api.query.model.QueryParam.notIn;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertNull;\n+import static org.kie.scanner.KieMavenRepository.getKieMavenRepository;\n+\n+@RunWith(Parameterized.class)\n+public class AdvanceRuntimeDataServiceImplTest extends AbstractKieServicesBaseTest {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(AdvanceRuntimeDataServiceImplTest.class);\n+\n+    @Parameters(name = \"Pagination {0}\")\n+    public static Iterable<? extends Object> data() {\n+        return Arrays.asList(0, 2);\n+    }\n+\n+    private List<DeploymentUnit> units = new ArrayList<DeploymentUnit>();\n+    protected String correctUser = \"testUser\";\n+    protected String wrongUser = \"wrongUser\";", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODY1ODk4Mg=="}, "originalCommit": {"oid": "f04f50355ec285330b3467d42754a036a04b1db3"}, "originalPosition": 82}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUzNzE1NTQzOnYy", "diffSide": "RIGHT", "path": "jbpm-services/jbpm-kie-services/src/test/java/org/jbpm/kie/services/test/AdvanceRuntimeDataServiceImplTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNVQwODoxMToxN1rOGFulaw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQwOTowMjozM1rOGIKdrA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODY1OTMwNw==", "bodyText": "ArrayList < DeploymentUnit > is redundant. ArrayList<> should be enough", "url": "https://github.com/kiegroup/jbpm/pull/1615#discussion_r408659307", "createdAt": "2020-04-15T08:11:17Z", "author": {"login": "afalhambra"}, "path": "jbpm-services/jbpm-kie-services/src/test/java/org/jbpm/kie/services/test/AdvanceRuntimeDataServiceImplTest.java", "diffHunk": "@@ -0,0 +1,359 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.jbpm.kie.services.test;\n+\n+import java.io.File;\n+import java.io.FileOutputStream;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.drools.compiler.kie.builder.impl.InternalKieModule;\n+import org.jbpm.kie.services.impl.KModuleDeploymentUnit;\n+import org.jbpm.kie.test.util.AbstractKieServicesBaseTest;\n+import org.jbpm.services.api.ProcessInstanceNotFoundException;\n+import org.jbpm.services.api.model.DeploymentUnit;\n+import org.jbpm.services.api.model.ProcessInstanceWithVarsDesc;\n+import org.jbpm.services.api.model.UserTaskInstanceWithPotOwnerDesc;\n+import org.jbpm.services.api.query.model.QueryParam;\n+import org.junit.After;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.Parameterized;\n+import org.junit.runners.Parameterized.Parameters;\n+import org.kie.api.KieServices;\n+import org.kie.api.builder.ReleaseId;\n+import org.kie.api.runtime.process.ProcessInstance;\n+import org.kie.internal.query.QueryContext;\n+import org.kie.scanner.KieMavenRepository;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static java.util.Collections.emptyList;\n+import static org.hamcrest.CoreMatchers.is;\n+import static org.jbpm.services.api.AdvanceRuntimeDataService.PROCESS_ATTR_CORRELATION_KEY;\n+import static org.jbpm.services.api.AdvanceRuntimeDataService.PROCESS_ATTR_DEFINITION_ID;\n+import static org.jbpm.services.api.AdvanceRuntimeDataService.PROCESS_ATTR_DEPLOYMENT_ID;\n+import static org.jbpm.services.api.AdvanceRuntimeDataService.TASK_ATTR_NAME;\n+import static org.jbpm.services.api.AdvanceRuntimeDataService.TASK_ATTR_OWNER;\n+import static org.jbpm.services.api.query.model.QueryParam.equalsTo;\n+import static org.jbpm.services.api.query.model.QueryParam.in;\n+import static org.jbpm.services.api.query.model.QueryParam.isNotNull;\n+import static org.jbpm.services.api.query.model.QueryParam.isNull;\n+import static org.jbpm.services.api.query.model.QueryParam.likeTo;\n+import static org.jbpm.services.api.query.model.QueryParam.list;\n+import static org.jbpm.services.api.query.model.QueryParam.notEqualsTo;\n+import static org.jbpm.services.api.query.model.QueryParam.notIn;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertNull;\n+import static org.kie.scanner.KieMavenRepository.getKieMavenRepository;\n+\n+@RunWith(Parameterized.class)\n+public class AdvanceRuntimeDataServiceImplTest extends AbstractKieServicesBaseTest {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(AdvanceRuntimeDataServiceImplTest.class);\n+\n+    @Parameters(name = \"Pagination {0}\")\n+    public static Iterable<? extends Object> data() {\n+        return Arrays.asList(0, 2);\n+    }\n+\n+    private List<DeploymentUnit> units = new ArrayList<DeploymentUnit>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f04f50355ec285330b3467d42754a036a04b1db3"}, "originalPosition": 80}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTIxMzIyOA==", "bodyText": "ok", "url": "https://github.com/kiegroup/jbpm/pull/1615#discussion_r411213228", "createdAt": "2020-04-20T09:02:33Z", "author": {"login": "elguardian"}, "path": "jbpm-services/jbpm-kie-services/src/test/java/org/jbpm/kie/services/test/AdvanceRuntimeDataServiceImplTest.java", "diffHunk": "@@ -0,0 +1,359 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.jbpm.kie.services.test;\n+\n+import java.io.File;\n+import java.io.FileOutputStream;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.drools.compiler.kie.builder.impl.InternalKieModule;\n+import org.jbpm.kie.services.impl.KModuleDeploymentUnit;\n+import org.jbpm.kie.test.util.AbstractKieServicesBaseTest;\n+import org.jbpm.services.api.ProcessInstanceNotFoundException;\n+import org.jbpm.services.api.model.DeploymentUnit;\n+import org.jbpm.services.api.model.ProcessInstanceWithVarsDesc;\n+import org.jbpm.services.api.model.UserTaskInstanceWithPotOwnerDesc;\n+import org.jbpm.services.api.query.model.QueryParam;\n+import org.junit.After;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.Parameterized;\n+import org.junit.runners.Parameterized.Parameters;\n+import org.kie.api.KieServices;\n+import org.kie.api.builder.ReleaseId;\n+import org.kie.api.runtime.process.ProcessInstance;\n+import org.kie.internal.query.QueryContext;\n+import org.kie.scanner.KieMavenRepository;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static java.util.Collections.emptyList;\n+import static org.hamcrest.CoreMatchers.is;\n+import static org.jbpm.services.api.AdvanceRuntimeDataService.PROCESS_ATTR_CORRELATION_KEY;\n+import static org.jbpm.services.api.AdvanceRuntimeDataService.PROCESS_ATTR_DEFINITION_ID;\n+import static org.jbpm.services.api.AdvanceRuntimeDataService.PROCESS_ATTR_DEPLOYMENT_ID;\n+import static org.jbpm.services.api.AdvanceRuntimeDataService.TASK_ATTR_NAME;\n+import static org.jbpm.services.api.AdvanceRuntimeDataService.TASK_ATTR_OWNER;\n+import static org.jbpm.services.api.query.model.QueryParam.equalsTo;\n+import static org.jbpm.services.api.query.model.QueryParam.in;\n+import static org.jbpm.services.api.query.model.QueryParam.isNotNull;\n+import static org.jbpm.services.api.query.model.QueryParam.isNull;\n+import static org.jbpm.services.api.query.model.QueryParam.likeTo;\n+import static org.jbpm.services.api.query.model.QueryParam.list;\n+import static org.jbpm.services.api.query.model.QueryParam.notEqualsTo;\n+import static org.jbpm.services.api.query.model.QueryParam.notIn;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertNull;\n+import static org.kie.scanner.KieMavenRepository.getKieMavenRepository;\n+\n+@RunWith(Parameterized.class)\n+public class AdvanceRuntimeDataServiceImplTest extends AbstractKieServicesBaseTest {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(AdvanceRuntimeDataServiceImplTest.class);\n+\n+    @Parameters(name = \"Pagination {0}\")\n+    public static Iterable<? extends Object> data() {\n+        return Arrays.asList(0, 2);\n+    }\n+\n+    private List<DeploymentUnit> units = new ArrayList<DeploymentUnit>();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODY1OTMwNw=="}, "originalCommit": {"oid": "f04f50355ec285330b3467d42754a036a04b1db3"}, "originalPosition": 80}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUzNzMwNDM4OnYy", "diffSide": "RIGHT", "path": "jbpm-services/jbpm-kie-services/src/test/java/org/jbpm/kie/services/test/AdvanceRuntimeDataServiceImplTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNVQwODo1MDo1MVrOGFwB1w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQwOTowNToyNlrOGIKlNQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODY4Mjk2Nw==", "bodyText": "I see that pagination has been set at the test class level, but I'm missing a specific test method for testing this in combination with the offset and fetch the next batch of results/records. wdyt?", "url": "https://github.com/kiegroup/jbpm/pull/1615#discussion_r408682967", "createdAt": "2020-04-15T08:50:51Z", "author": {"login": "afalhambra"}, "path": "jbpm-services/jbpm-kie-services/src/test/java/org/jbpm/kie/services/test/AdvanceRuntimeDataServiceImplTest.java", "diffHunk": "@@ -0,0 +1,359 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.jbpm.kie.services.test;\n+\n+import java.io.File;\n+import java.io.FileOutputStream;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.drools.compiler.kie.builder.impl.InternalKieModule;\n+import org.jbpm.kie.services.impl.KModuleDeploymentUnit;\n+import org.jbpm.kie.test.util.AbstractKieServicesBaseTest;\n+import org.jbpm.services.api.ProcessInstanceNotFoundException;\n+import org.jbpm.services.api.model.DeploymentUnit;\n+import org.jbpm.services.api.model.ProcessInstanceWithVarsDesc;\n+import org.jbpm.services.api.model.UserTaskInstanceWithPotOwnerDesc;\n+import org.jbpm.services.api.query.model.QueryParam;\n+import org.junit.After;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.Parameterized;\n+import org.junit.runners.Parameterized.Parameters;\n+import org.kie.api.KieServices;\n+import org.kie.api.builder.ReleaseId;\n+import org.kie.api.runtime.process.ProcessInstance;\n+import org.kie.internal.query.QueryContext;\n+import org.kie.scanner.KieMavenRepository;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static java.util.Collections.emptyList;\n+import static org.hamcrest.CoreMatchers.is;\n+import static org.jbpm.services.api.AdvanceRuntimeDataService.PROCESS_ATTR_CORRELATION_KEY;\n+import static org.jbpm.services.api.AdvanceRuntimeDataService.PROCESS_ATTR_DEFINITION_ID;\n+import static org.jbpm.services.api.AdvanceRuntimeDataService.PROCESS_ATTR_DEPLOYMENT_ID;\n+import static org.jbpm.services.api.AdvanceRuntimeDataService.TASK_ATTR_NAME;\n+import static org.jbpm.services.api.AdvanceRuntimeDataService.TASK_ATTR_OWNER;\n+import static org.jbpm.services.api.query.model.QueryParam.equalsTo;\n+import static org.jbpm.services.api.query.model.QueryParam.in;\n+import static org.jbpm.services.api.query.model.QueryParam.isNotNull;\n+import static org.jbpm.services.api.query.model.QueryParam.isNull;\n+import static org.jbpm.services.api.query.model.QueryParam.likeTo;\n+import static org.jbpm.services.api.query.model.QueryParam.list;\n+import static org.jbpm.services.api.query.model.QueryParam.notEqualsTo;\n+import static org.jbpm.services.api.query.model.QueryParam.notIn;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertNull;\n+import static org.kie.scanner.KieMavenRepository.getKieMavenRepository;\n+\n+@RunWith(Parameterized.class)\n+public class AdvanceRuntimeDataServiceImplTest extends AbstractKieServicesBaseTest {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(AdvanceRuntimeDataServiceImplTest.class);\n+\n+    @Parameters(name = \"Pagination {0}\")\n+    public static Iterable<? extends Object> data() {\n+        return Arrays.asList(0, 2);\n+    }\n+\n+    private List<DeploymentUnit> units = new ArrayList<DeploymentUnit>();\n+    protected String correctUser = \"testUser\";\n+    protected String wrongUser = \"wrongUser\";\n+\n+    private List<Long> processIds;\n+    private KModuleDeploymentUnit deploymentUnit = null;\n+    private QueryContext queryContext;\n+\n+    public AdvanceRuntimeDataServiceImplTest(Integer count) {\n+        this.queryContext = new QueryContext(0, count);\n+    }\n+\n+    @Before\n+    public void prepare() {\n+\n+        configureServices();\n+        logger.debug(\"Preparing kjar\");\n+        KieServices ks = KieServices.Factory.get();\n+        ReleaseId releaseId = ks.newReleaseId(GROUP_ID, ARTIFACT_ID, VERSION);\n+        List<String> processes = new ArrayList<String>();\n+        processes.add(\"repo/processes/general/SingleHumanTaskWithVarsA.bpmn2\");\n+        processes.add(\"repo/processes/general/SingleHumanTaskWithVarsB.bpmn2\");\n+\n+        InternalKieModule kJar1 = createKieJar(ks, releaseId, processes);\n+        File pom = new File(\"target/kmodule\", \"pom.xml\");\n+        pom.getParentFile().mkdir();\n+        try (FileOutputStream fs = new FileOutputStream(pom);) {\n+            fs.write(getPom(releaseId).getBytes());\n+        } catch (Exception e) {\n+\n+        }\n+        KieMavenRepository repository = getKieMavenRepository();\n+        repository.deployArtifact(releaseId, kJar1, pom);\n+\n+        assertNotNull(deploymentService);\n+\n+        deploymentUnit = new KModuleDeploymentUnit(GROUP_ID, ARTIFACT_ID, VERSION);\n+\n+        deploymentService.deploy(deploymentUnit);\n+        units.add(deploymentUnit);\n+        assertNotNull(processService);\n+\n+        processIds = new ArrayList<>();\n+        for (int i = 0; i < 10; i++) {\n+            Map<String, Object> inputsA1 = new HashMap<>();\n+            inputsA1.put(\"var_a\", \"a\" + (i % 3));\n+            inputsA1.put(\"var_b\", (i % 3));\n+            processIds.add(processService.startProcess(deploymentUnit.getIdentifier(), \"test.test_A\", inputsA1));\n+        }\n+        for (int i = 0; i < 10; i++) {\n+            Map<String, Object> inputsB1 = new HashMap<>();\n+            inputsB1.put(\"var_a\", \"b\" + (i % 3));\n+            inputsB1.put(\"var_b\", (i % 3));\n+            processIds.add(processService.startProcess(deploymentUnit.getIdentifier(), \"test.test_B\", inputsB1));\n+        }\n+    }\n+\n+    @After\n+    public void cleanup() {\n+        for (Long processInstanceId : processIds) {\n+            try {\n+                // let's abort process instance to leave the system in clear state\n+                processService.abortProcessInstance(processInstanceId);\n+\n+                ProcessInstance pi = processService.getProcessInstance(processInstanceId);\n+                assertNull(pi);\n+            } catch (ProcessInstanceNotFoundException e) {\n+                // ignore it as it was already completed/aborted\n+            }\n+        }\n+        cleanupSingletonSessionId();\n+        if (units != null && !units.isEmpty()) {\n+            for (DeploymentUnit unit : units) {\n+                try {\n+                    deploymentService.undeploy(unit);\n+                } catch (Exception e) {\n+                    // do nothing in case of some failed tests to avoid next test to fail as well\n+                }\n+            }\n+            units.clear();\n+        }\n+        close();\n+    }\n+\n+    @Test\n+    public void testQueryProcessByVariables() {\n+        List<QueryParam> variables = list(equalsTo(\"var_a\", \"a1\"), equalsTo(\"var_b\", \"1\"));\n+        List<QueryParam> attributes = list(equalsTo(PROCESS_ATTR_DEFINITION_ID, \"test.test_A\"));\n+\n+        List<ProcessInstanceWithVarsDesc> data = advanceVariableDataService.queryProcessByVariables(attributes, variables, queryContext);\n+        if (queryContext.getCount() > 0) {\n+            Assert.assertThat(data.size(), is(queryContext.getCount()));\n+        }\n+        for (ProcessInstanceWithVarsDesc p : data) {\n+            Assert.assertEquals(\"a1\", p.getVariables().get(\"var_a\"));\n+            Assert.assertEquals(\"1\", p.getVariables().get(\"var_b\"));\n+            Assert.assertEquals(\"test.test_A\", p.getProcessId());\n+        }\n+    }\n+\n+    @Test\n+    public void testQueryInOperator() {\n+\n+        List<QueryParam> variables = list(in(\"var_a\", \"a1\", \"a2\"));\n+        List<QueryParam> attributes = list(equalsTo(PROCESS_ATTR_DEFINITION_ID, \"test.test_A\"));\n+\n+        List<ProcessInstanceWithVarsDesc> data = advanceVariableDataService.queryProcessByVariables(attributes, variables, queryContext);\n+        if (queryContext.getCount() > 0) {\n+            Assert.assertThat(data.size(), is(queryContext.getCount()));\n+        }\n+        List<String> values = Arrays.asList(\"a1\", \"a2\");\n+        for (ProcessInstanceWithVarsDesc p : data) {\n+            Assert.assertTrue(values.contains(p.getVariables().get(\"var_a\")));\n+            Assert.assertEquals(\"test.test_A\", p.getProcessId());\n+        }\n+    }\n+\n+    @Test\n+    public void testQueryLikeToOperator() {\n+\n+        List<QueryParam> variables = list(likeTo(\"var_a\", false, \"a%\"));\n+        List<QueryParam> attributes = list(likeTo(PROCESS_ATTR_DEFINITION_ID, false, \"%test_A%\"));\n+\n+        List<ProcessInstanceWithVarsDesc> data = advanceVariableDataService.queryProcessByVariables(attributes, variables, queryContext);\n+        if (queryContext.getCount() > 0) {\n+            Assert.assertThat(data.size(), is(queryContext.getCount()));\n+        }\n+\n+        for (ProcessInstanceWithVarsDesc p : data) {\n+            Assert.assertTrue(((String) p.getVariables().get(\"var_a\")).startsWith(\"a\"));\n+            Assert.assertEquals(\"test.test_A\", p.getProcessId());\n+        }\n+    }\n+\n+    @Test\n+    public void testQueryIsNotNullOperator() {\n+\n+        List<QueryParam> attributes = list(isNotNull(TASK_ATTR_OWNER));\n+\n+        List<UserTaskInstanceWithPotOwnerDesc> data = advanceVariableDataService.queryUserTasksByVariables(attributes, emptyList(), emptyList(), emptyList(), queryContext);\n+        Assert.assertThat(data.size(), is(0));\n+\n+    }\n+\n+    @Test\n+    public void testQueryIsNullOperator() {\n+\n+        List<QueryParam> attributes = list(isNull(TASK_ATTR_OWNER));\n+\n+        List<UserTaskInstanceWithPotOwnerDesc> data = advanceVariableDataService.queryUserTasksByVariables(attributes, emptyList(), emptyList(), emptyList(), queryContext);\n+        if (queryContext.getCount() > 0) {\n+            Assert.assertThat(data.size(), is(queryContext.getCount()));\n+        }\n+\n+        for (UserTaskInstanceWithPotOwnerDesc p : data) {\n+            Assert.assertNull(p.getActualOwner());\n+        }\n+    }\n+\n+    @Test\n+    public void testQueryNotInOperator() {\n+\n+        List<QueryParam> variables = list(notIn(\"var_a\", \"a1\", \"a2\"));\n+        List<QueryParam> attributes = list(equalsTo(PROCESS_ATTR_DEFINITION_ID, \"test.test_A\"));\n+\n+        List<ProcessInstanceWithVarsDesc> data = advanceVariableDataService.queryProcessByVariables(attributes, variables, queryContext);\n+        if (queryContext.getCount() > 0) {\n+            Assert.assertThat(data.size(), is(queryContext.getCount()));\n+        }\n+        List<String> values = Arrays.asList(\"a1\", \"a2\");\n+        for (ProcessInstanceWithVarsDesc p : data) {\n+            Assert.assertTrue(!values.contains(p.getVariables().get(\"var_a\")));\n+            Assert.assertEquals(\"test.test_A\", p.getProcessId());\n+        }\n+    }\n+\n+    @Test\n+    public void testQueryNotEqualsOperator() {\n+        List<QueryParam> attributes = list(notEqualsTo(PROCESS_ATTR_DEFINITION_ID, \"test.test_A\"));\n+\n+        List<ProcessInstanceWithVarsDesc> data = advanceVariableDataService.queryProcessByVariables(attributes, emptyList(), queryContext);\n+        if (queryContext.getCount() > 0) {\n+            Assert.assertThat(data.size(), is(queryContext.getCount()));\n+        }\n+\n+        for (ProcessInstanceWithVarsDesc p : data) {\n+            Assert.assertNotEquals(\"test.test_A\", p.getProcessId());\n+        }\n+    }\n+\n+    @Test\n+    public void testQueryProcessByAttributes() {\n+        List<QueryParam> attributes = list(equalsTo(PROCESS_ATTR_DEFINITION_ID, \"test.test_A\"), equalsTo(PROCESS_ATTR_CORRELATION_KEY, \"1\"));\n+\n+        List<ProcessInstanceWithVarsDesc> data = advanceVariableDataService.queryProcessByVariables(attributes, emptyList(), queryContext);\n+        Assert.assertThat(data.size(), is(1));\n+    }\n+\n+    @Test\n+    public void testQueryTaskByVariables() {\n+        List<QueryParam> variables = list(equalsTo(\"task_in_a1\", \"a0\"));\n+        List<QueryParam> attributes = list(equalsTo(PROCESS_ATTR_DEPLOYMENT_ID, \"org.jbpm.test:test-module:1.0.0\"));\n+\n+        List<String> potOwners = emptyList();\n+        List<UserTaskInstanceWithPotOwnerDesc> data = advanceVariableDataService.queryUserTasksByVariables(attributes, variables, emptyList(), potOwners, queryContext);\n+        if (queryContext.getCount() > 0) {\n+            Assert.assertThat(data.size(), is(queryContext.getCount()));\n+        }\n+        for (UserTaskInstanceWithPotOwnerDesc p : data) {\n+            Assert.assertEquals(\"a0\", p.getInputdata().get(\"task_in_a1\"));\n+            Assert.assertEquals(\"org.jbpm.test:test-module:1.0.0\", p.getDeploymentId());\n+        }\n+    }\n+\n+    @Test\n+    public void testQueryTaskNotEqualsByVariables() {\n+        List<QueryParam> attributes = list(notEqualsTo(PROCESS_ATTR_DEFINITION_ID, \"test.test_A\"));\n+\n+        List<String> potOwners = emptyList();\n+        List<UserTaskInstanceWithPotOwnerDesc> data = advanceVariableDataService.queryUserTasksByVariables(attributes, emptyList(), emptyList(), potOwners, queryContext);\n+        if (queryContext.getCount() > 0) {\n+            Assert.assertThat(data.size(), is(queryContext.getCount()));\n+        }\n+        for (UserTaskInstanceWithPotOwnerDesc p : data) {\n+            Assert.assertNotEquals(\"test.test_A\", p.getProcessId());\n+        }\n+    }\n+\n+    @Test\n+    public void testQueryTaskByVariablesWithOwners() {\n+\n+        List<String> potOwners = Collections.singletonList(\"katy\");\n+        List<UserTaskInstanceWithPotOwnerDesc> data = advanceVariableDataService.queryUserTasksByVariables(emptyList(), emptyList(), emptyList(), potOwners, queryContext);\n+        if (queryContext.getCount() > 0) {\n+            Assert.assertThat(data.size(), is(queryContext.getCount()));\n+        }\n+\n+        for (UserTaskInstanceWithPotOwnerDesc p : data) {\n+            Assert.assertTrue(p.getPotentialOwners().contains(\"katy\"));\n+        }\n+    }\n+\n+    @Test\n+    public void testQueryTaskByVariablesWithAllOwners() {\n+        List<String> potOwners = Arrays.asList(\"katy\", \"nobody\");\n+        List<UserTaskInstanceWithPotOwnerDesc> data = advanceVariableDataService.queryUserTasksByVariables(emptyList(), emptyList(), emptyList(), potOwners, queryContext);\n+        Assert.assertEquals(0, data.size());\n+\n+    }\n+\n+    @Test\n+    public void testQueryTaskByVariablesWithByProcessVar() {\n+        List<QueryParam> processVariables = list(equalsTo(\"var_a\", \"a1\"));\n+\n+        List<String> potOwners = Collections.emptyList();\n+        List<UserTaskInstanceWithPotOwnerDesc> data = advanceVariableDataService.queryUserTasksByVariables(emptyList(), emptyList(), processVariables, potOwners, queryContext);\n+        if (queryContext.getCount() > 0) {\n+            Assert.assertThat(data.size(), is(queryContext.getCount()));\n+        } else {\n+            Assert.assertThat(data.size(), is(3));\n+        }\n+\n+    }\n+\n+    @Test\n+    public void testQueryTaskByAttributes() {\n+        List<QueryParam> attributes = list(equalsTo(PROCESS_ATTR_DEFINITION_ID, \"test.test_A\"), equalsTo(PROCESS_ATTR_CORRELATION_KEY, \"1\"), equalsTo(TASK_ATTR_NAME, \"Task\"));\n+\n+        List<UserTaskInstanceWithPotOwnerDesc> data = advanceVariableDataService.queryUserTasksByVariables(attributes, emptyList(), emptyList(), emptyList(), queryContext);\n+        Assert.assertThat(data.size(), is(1));\n+    }\n+\n+    @Test\n+    public void testQueryTaskByAttributesOwner() {\n+        List<QueryParam> attributes = list(equalsTo(TASK_ATTR_OWNER, \"Error\"));\n+        List<UserTaskInstanceWithPotOwnerDesc> data = advanceVariableDataService.queryUserTasksByVariables(attributes, emptyList(), emptyList(), emptyList(), queryContext);\n+        Assert.assertThat(data.size(), is(0));\n+    }\n+\n+}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f04f50355ec285330b3467d42754a036a04b1db3"}, "originalPosition": 359}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTIxNTE1Nw==", "bodyText": "code coverage covers this scenario. so it is the same to tests 0 - 2 than 2 - 4.", "url": "https://github.com/kiegroup/jbpm/pull/1615#discussion_r411215157", "createdAt": "2020-04-20T09:05:26Z", "author": {"login": "elguardian"}, "path": "jbpm-services/jbpm-kie-services/src/test/java/org/jbpm/kie/services/test/AdvanceRuntimeDataServiceImplTest.java", "diffHunk": "@@ -0,0 +1,359 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.jbpm.kie.services.test;\n+\n+import java.io.File;\n+import java.io.FileOutputStream;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.drools.compiler.kie.builder.impl.InternalKieModule;\n+import org.jbpm.kie.services.impl.KModuleDeploymentUnit;\n+import org.jbpm.kie.test.util.AbstractKieServicesBaseTest;\n+import org.jbpm.services.api.ProcessInstanceNotFoundException;\n+import org.jbpm.services.api.model.DeploymentUnit;\n+import org.jbpm.services.api.model.ProcessInstanceWithVarsDesc;\n+import org.jbpm.services.api.model.UserTaskInstanceWithPotOwnerDesc;\n+import org.jbpm.services.api.query.model.QueryParam;\n+import org.junit.After;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.Parameterized;\n+import org.junit.runners.Parameterized.Parameters;\n+import org.kie.api.KieServices;\n+import org.kie.api.builder.ReleaseId;\n+import org.kie.api.runtime.process.ProcessInstance;\n+import org.kie.internal.query.QueryContext;\n+import org.kie.scanner.KieMavenRepository;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static java.util.Collections.emptyList;\n+import static org.hamcrest.CoreMatchers.is;\n+import static org.jbpm.services.api.AdvanceRuntimeDataService.PROCESS_ATTR_CORRELATION_KEY;\n+import static org.jbpm.services.api.AdvanceRuntimeDataService.PROCESS_ATTR_DEFINITION_ID;\n+import static org.jbpm.services.api.AdvanceRuntimeDataService.PROCESS_ATTR_DEPLOYMENT_ID;\n+import static org.jbpm.services.api.AdvanceRuntimeDataService.TASK_ATTR_NAME;\n+import static org.jbpm.services.api.AdvanceRuntimeDataService.TASK_ATTR_OWNER;\n+import static org.jbpm.services.api.query.model.QueryParam.equalsTo;\n+import static org.jbpm.services.api.query.model.QueryParam.in;\n+import static org.jbpm.services.api.query.model.QueryParam.isNotNull;\n+import static org.jbpm.services.api.query.model.QueryParam.isNull;\n+import static org.jbpm.services.api.query.model.QueryParam.likeTo;\n+import static org.jbpm.services.api.query.model.QueryParam.list;\n+import static org.jbpm.services.api.query.model.QueryParam.notEqualsTo;\n+import static org.jbpm.services.api.query.model.QueryParam.notIn;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertNull;\n+import static org.kie.scanner.KieMavenRepository.getKieMavenRepository;\n+\n+@RunWith(Parameterized.class)\n+public class AdvanceRuntimeDataServiceImplTest extends AbstractKieServicesBaseTest {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(AdvanceRuntimeDataServiceImplTest.class);\n+\n+    @Parameters(name = \"Pagination {0}\")\n+    public static Iterable<? extends Object> data() {\n+        return Arrays.asList(0, 2);\n+    }\n+\n+    private List<DeploymentUnit> units = new ArrayList<DeploymentUnit>();\n+    protected String correctUser = \"testUser\";\n+    protected String wrongUser = \"wrongUser\";\n+\n+    private List<Long> processIds;\n+    private KModuleDeploymentUnit deploymentUnit = null;\n+    private QueryContext queryContext;\n+\n+    public AdvanceRuntimeDataServiceImplTest(Integer count) {\n+        this.queryContext = new QueryContext(0, count);\n+    }\n+\n+    @Before\n+    public void prepare() {\n+\n+        configureServices();\n+        logger.debug(\"Preparing kjar\");\n+        KieServices ks = KieServices.Factory.get();\n+        ReleaseId releaseId = ks.newReleaseId(GROUP_ID, ARTIFACT_ID, VERSION);\n+        List<String> processes = new ArrayList<String>();\n+        processes.add(\"repo/processes/general/SingleHumanTaskWithVarsA.bpmn2\");\n+        processes.add(\"repo/processes/general/SingleHumanTaskWithVarsB.bpmn2\");\n+\n+        InternalKieModule kJar1 = createKieJar(ks, releaseId, processes);\n+        File pom = new File(\"target/kmodule\", \"pom.xml\");\n+        pom.getParentFile().mkdir();\n+        try (FileOutputStream fs = new FileOutputStream(pom);) {\n+            fs.write(getPom(releaseId).getBytes());\n+        } catch (Exception e) {\n+\n+        }\n+        KieMavenRepository repository = getKieMavenRepository();\n+        repository.deployArtifact(releaseId, kJar1, pom);\n+\n+        assertNotNull(deploymentService);\n+\n+        deploymentUnit = new KModuleDeploymentUnit(GROUP_ID, ARTIFACT_ID, VERSION);\n+\n+        deploymentService.deploy(deploymentUnit);\n+        units.add(deploymentUnit);\n+        assertNotNull(processService);\n+\n+        processIds = new ArrayList<>();\n+        for (int i = 0; i < 10; i++) {\n+            Map<String, Object> inputsA1 = new HashMap<>();\n+            inputsA1.put(\"var_a\", \"a\" + (i % 3));\n+            inputsA1.put(\"var_b\", (i % 3));\n+            processIds.add(processService.startProcess(deploymentUnit.getIdentifier(), \"test.test_A\", inputsA1));\n+        }\n+        for (int i = 0; i < 10; i++) {\n+            Map<String, Object> inputsB1 = new HashMap<>();\n+            inputsB1.put(\"var_a\", \"b\" + (i % 3));\n+            inputsB1.put(\"var_b\", (i % 3));\n+            processIds.add(processService.startProcess(deploymentUnit.getIdentifier(), \"test.test_B\", inputsB1));\n+        }\n+    }\n+\n+    @After\n+    public void cleanup() {\n+        for (Long processInstanceId : processIds) {\n+            try {\n+                // let's abort process instance to leave the system in clear state\n+                processService.abortProcessInstance(processInstanceId);\n+\n+                ProcessInstance pi = processService.getProcessInstance(processInstanceId);\n+                assertNull(pi);\n+            } catch (ProcessInstanceNotFoundException e) {\n+                // ignore it as it was already completed/aborted\n+            }\n+        }\n+        cleanupSingletonSessionId();\n+        if (units != null && !units.isEmpty()) {\n+            for (DeploymentUnit unit : units) {\n+                try {\n+                    deploymentService.undeploy(unit);\n+                } catch (Exception e) {\n+                    // do nothing in case of some failed tests to avoid next test to fail as well\n+                }\n+            }\n+            units.clear();\n+        }\n+        close();\n+    }\n+\n+    @Test\n+    public void testQueryProcessByVariables() {\n+        List<QueryParam> variables = list(equalsTo(\"var_a\", \"a1\"), equalsTo(\"var_b\", \"1\"));\n+        List<QueryParam> attributes = list(equalsTo(PROCESS_ATTR_DEFINITION_ID, \"test.test_A\"));\n+\n+        List<ProcessInstanceWithVarsDesc> data = advanceVariableDataService.queryProcessByVariables(attributes, variables, queryContext);\n+        if (queryContext.getCount() > 0) {\n+            Assert.assertThat(data.size(), is(queryContext.getCount()));\n+        }\n+        for (ProcessInstanceWithVarsDesc p : data) {\n+            Assert.assertEquals(\"a1\", p.getVariables().get(\"var_a\"));\n+            Assert.assertEquals(\"1\", p.getVariables().get(\"var_b\"));\n+            Assert.assertEquals(\"test.test_A\", p.getProcessId());\n+        }\n+    }\n+\n+    @Test\n+    public void testQueryInOperator() {\n+\n+        List<QueryParam> variables = list(in(\"var_a\", \"a1\", \"a2\"));\n+        List<QueryParam> attributes = list(equalsTo(PROCESS_ATTR_DEFINITION_ID, \"test.test_A\"));\n+\n+        List<ProcessInstanceWithVarsDesc> data = advanceVariableDataService.queryProcessByVariables(attributes, variables, queryContext);\n+        if (queryContext.getCount() > 0) {\n+            Assert.assertThat(data.size(), is(queryContext.getCount()));\n+        }\n+        List<String> values = Arrays.asList(\"a1\", \"a2\");\n+        for (ProcessInstanceWithVarsDesc p : data) {\n+            Assert.assertTrue(values.contains(p.getVariables().get(\"var_a\")));\n+            Assert.assertEquals(\"test.test_A\", p.getProcessId());\n+        }\n+    }\n+\n+    @Test\n+    public void testQueryLikeToOperator() {\n+\n+        List<QueryParam> variables = list(likeTo(\"var_a\", false, \"a%\"));\n+        List<QueryParam> attributes = list(likeTo(PROCESS_ATTR_DEFINITION_ID, false, \"%test_A%\"));\n+\n+        List<ProcessInstanceWithVarsDesc> data = advanceVariableDataService.queryProcessByVariables(attributes, variables, queryContext);\n+        if (queryContext.getCount() > 0) {\n+            Assert.assertThat(data.size(), is(queryContext.getCount()));\n+        }\n+\n+        for (ProcessInstanceWithVarsDesc p : data) {\n+            Assert.assertTrue(((String) p.getVariables().get(\"var_a\")).startsWith(\"a\"));\n+            Assert.assertEquals(\"test.test_A\", p.getProcessId());\n+        }\n+    }\n+\n+    @Test\n+    public void testQueryIsNotNullOperator() {\n+\n+        List<QueryParam> attributes = list(isNotNull(TASK_ATTR_OWNER));\n+\n+        List<UserTaskInstanceWithPotOwnerDesc> data = advanceVariableDataService.queryUserTasksByVariables(attributes, emptyList(), emptyList(), emptyList(), queryContext);\n+        Assert.assertThat(data.size(), is(0));\n+\n+    }\n+\n+    @Test\n+    public void testQueryIsNullOperator() {\n+\n+        List<QueryParam> attributes = list(isNull(TASK_ATTR_OWNER));\n+\n+        List<UserTaskInstanceWithPotOwnerDesc> data = advanceVariableDataService.queryUserTasksByVariables(attributes, emptyList(), emptyList(), emptyList(), queryContext);\n+        if (queryContext.getCount() > 0) {\n+            Assert.assertThat(data.size(), is(queryContext.getCount()));\n+        }\n+\n+        for (UserTaskInstanceWithPotOwnerDesc p : data) {\n+            Assert.assertNull(p.getActualOwner());\n+        }\n+    }\n+\n+    @Test\n+    public void testQueryNotInOperator() {\n+\n+        List<QueryParam> variables = list(notIn(\"var_a\", \"a1\", \"a2\"));\n+        List<QueryParam> attributes = list(equalsTo(PROCESS_ATTR_DEFINITION_ID, \"test.test_A\"));\n+\n+        List<ProcessInstanceWithVarsDesc> data = advanceVariableDataService.queryProcessByVariables(attributes, variables, queryContext);\n+        if (queryContext.getCount() > 0) {\n+            Assert.assertThat(data.size(), is(queryContext.getCount()));\n+        }\n+        List<String> values = Arrays.asList(\"a1\", \"a2\");\n+        for (ProcessInstanceWithVarsDesc p : data) {\n+            Assert.assertTrue(!values.contains(p.getVariables().get(\"var_a\")));\n+            Assert.assertEquals(\"test.test_A\", p.getProcessId());\n+        }\n+    }\n+\n+    @Test\n+    public void testQueryNotEqualsOperator() {\n+        List<QueryParam> attributes = list(notEqualsTo(PROCESS_ATTR_DEFINITION_ID, \"test.test_A\"));\n+\n+        List<ProcessInstanceWithVarsDesc> data = advanceVariableDataService.queryProcessByVariables(attributes, emptyList(), queryContext);\n+        if (queryContext.getCount() > 0) {\n+            Assert.assertThat(data.size(), is(queryContext.getCount()));\n+        }\n+\n+        for (ProcessInstanceWithVarsDesc p : data) {\n+            Assert.assertNotEquals(\"test.test_A\", p.getProcessId());\n+        }\n+    }\n+\n+    @Test\n+    public void testQueryProcessByAttributes() {\n+        List<QueryParam> attributes = list(equalsTo(PROCESS_ATTR_DEFINITION_ID, \"test.test_A\"), equalsTo(PROCESS_ATTR_CORRELATION_KEY, \"1\"));\n+\n+        List<ProcessInstanceWithVarsDesc> data = advanceVariableDataService.queryProcessByVariables(attributes, emptyList(), queryContext);\n+        Assert.assertThat(data.size(), is(1));\n+    }\n+\n+    @Test\n+    public void testQueryTaskByVariables() {\n+        List<QueryParam> variables = list(equalsTo(\"task_in_a1\", \"a0\"));\n+        List<QueryParam> attributes = list(equalsTo(PROCESS_ATTR_DEPLOYMENT_ID, \"org.jbpm.test:test-module:1.0.0\"));\n+\n+        List<String> potOwners = emptyList();\n+        List<UserTaskInstanceWithPotOwnerDesc> data = advanceVariableDataService.queryUserTasksByVariables(attributes, variables, emptyList(), potOwners, queryContext);\n+        if (queryContext.getCount() > 0) {\n+            Assert.assertThat(data.size(), is(queryContext.getCount()));\n+        }\n+        for (UserTaskInstanceWithPotOwnerDesc p : data) {\n+            Assert.assertEquals(\"a0\", p.getInputdata().get(\"task_in_a1\"));\n+            Assert.assertEquals(\"org.jbpm.test:test-module:1.0.0\", p.getDeploymentId());\n+        }\n+    }\n+\n+    @Test\n+    public void testQueryTaskNotEqualsByVariables() {\n+        List<QueryParam> attributes = list(notEqualsTo(PROCESS_ATTR_DEFINITION_ID, \"test.test_A\"));\n+\n+        List<String> potOwners = emptyList();\n+        List<UserTaskInstanceWithPotOwnerDesc> data = advanceVariableDataService.queryUserTasksByVariables(attributes, emptyList(), emptyList(), potOwners, queryContext);\n+        if (queryContext.getCount() > 0) {\n+            Assert.assertThat(data.size(), is(queryContext.getCount()));\n+        }\n+        for (UserTaskInstanceWithPotOwnerDesc p : data) {\n+            Assert.assertNotEquals(\"test.test_A\", p.getProcessId());\n+        }\n+    }\n+\n+    @Test\n+    public void testQueryTaskByVariablesWithOwners() {\n+\n+        List<String> potOwners = Collections.singletonList(\"katy\");\n+        List<UserTaskInstanceWithPotOwnerDesc> data = advanceVariableDataService.queryUserTasksByVariables(emptyList(), emptyList(), emptyList(), potOwners, queryContext);\n+        if (queryContext.getCount() > 0) {\n+            Assert.assertThat(data.size(), is(queryContext.getCount()));\n+        }\n+\n+        for (UserTaskInstanceWithPotOwnerDesc p : data) {\n+            Assert.assertTrue(p.getPotentialOwners().contains(\"katy\"));\n+        }\n+    }\n+\n+    @Test\n+    public void testQueryTaskByVariablesWithAllOwners() {\n+        List<String> potOwners = Arrays.asList(\"katy\", \"nobody\");\n+        List<UserTaskInstanceWithPotOwnerDesc> data = advanceVariableDataService.queryUserTasksByVariables(emptyList(), emptyList(), emptyList(), potOwners, queryContext);\n+        Assert.assertEquals(0, data.size());\n+\n+    }\n+\n+    @Test\n+    public void testQueryTaskByVariablesWithByProcessVar() {\n+        List<QueryParam> processVariables = list(equalsTo(\"var_a\", \"a1\"));\n+\n+        List<String> potOwners = Collections.emptyList();\n+        List<UserTaskInstanceWithPotOwnerDesc> data = advanceVariableDataService.queryUserTasksByVariables(emptyList(), emptyList(), processVariables, potOwners, queryContext);\n+        if (queryContext.getCount() > 0) {\n+            Assert.assertThat(data.size(), is(queryContext.getCount()));\n+        } else {\n+            Assert.assertThat(data.size(), is(3));\n+        }\n+\n+    }\n+\n+    @Test\n+    public void testQueryTaskByAttributes() {\n+        List<QueryParam> attributes = list(equalsTo(PROCESS_ATTR_DEFINITION_ID, \"test.test_A\"), equalsTo(PROCESS_ATTR_CORRELATION_KEY, \"1\"), equalsTo(TASK_ATTR_NAME, \"Task\"));\n+\n+        List<UserTaskInstanceWithPotOwnerDesc> data = advanceVariableDataService.queryUserTasksByVariables(attributes, emptyList(), emptyList(), emptyList(), queryContext);\n+        Assert.assertThat(data.size(), is(1));\n+    }\n+\n+    @Test\n+    public void testQueryTaskByAttributesOwner() {\n+        List<QueryParam> attributes = list(equalsTo(TASK_ATTR_OWNER, \"Error\"));\n+        List<UserTaskInstanceWithPotOwnerDesc> data = advanceVariableDataService.queryUserTasksByVariables(attributes, emptyList(), emptyList(), emptyList(), queryContext);\n+        Assert.assertThat(data.size(), is(0));\n+    }\n+\n+}", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODY4Mjk2Nw=="}, "originalCommit": {"oid": "f04f50355ec285330b3467d42754a036a04b1db3"}, "originalPosition": 359}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUzNzMzMDUwOnYy", "diffSide": "RIGHT", "path": "jbpm-services/jbpm-kie-services/src/main/java/org/jbpm/kie/services/impl/AbstractAdvanceRuntimeDataServiceImpl.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNVQwODo1NzozOFrOGFwSDA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNVQwODo1NzozOFrOGFwSDA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODY4NzExNg==", "bodyText": "Please remove extra parentheses here around \"entry\"\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    attributes.stream().filter(e -> e.getObjectValue() != null).forEach((entry) -> query.setParameter(\"ATTR_\" + entry.getColumn(), entry.getObjectValue()));\n          \n          \n            \n                    attributes.stream().filter(e -> e.getObjectValue() != null).forEach(entry -> query.setParameter(\"ATTR_\" + entry.getColumn(), entry.getObjectValue()));", "url": "https://github.com/kiegroup/jbpm/pull/1615#discussion_r408687116", "createdAt": "2020-04-15T08:57:38Z", "author": {"login": "afalhambra"}, "path": "jbpm-services/jbpm-kie-services/src/main/java/org/jbpm/kie/services/impl/AbstractAdvanceRuntimeDataServiceImpl.java", "diffHunk": "@@ -0,0 +1,346 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.jbpm.kie.services.impl;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import javax.persistence.EntityManager;\n+import javax.persistence.EntityManagerFactory;\n+import javax.persistence.Query;\n+\n+import org.dashbuilder.dataset.filter.CoreFunctionType;\n+import org.jbpm.kie.services.impl.model.ProcessInstanceWithVarsDesc;\n+import org.jbpm.kie.services.impl.model.UserTaskInstanceWithPotOwnerDesc;\n+import org.jbpm.services.api.query.model.QueryParam;\n+import org.jbpm.shared.services.impl.QueryManager;\n+import org.jbpm.shared.services.impl.TransactionalCommandService;\n+import org.jbpm.shared.services.impl.commands.QueryNameCommand;\n+import org.kie.api.runtime.query.QueryContext;\n+\n+import static java.util.Collections.singletonMap;\n+\n+public abstract class AbstractAdvanceRuntimeDataServiceImpl {\n+\n+    private static final String ID_LIST = \"idList\";\n+    private EntityManagerFactory emf;\n+    private TransactionalCommandService commandService;\n+\n+    public AbstractAdvanceRuntimeDataServiceImpl() {\n+        QueryManager.get().addNamedQueries(\"META-INF/Servicesorm.xml\");\n+    }\n+    public void setCommandService(TransactionalCommandService commandService) {\n+        this.commandService = commandService;\n+    }\n+\n+    public void setEmf(EntityManagerFactory emf) {\n+        this.emf = emf;\n+    }\n+\n+\n+    public List<org.jbpm.services.api.model.ProcessInstanceWithVarsDesc> queryProcessByVariables(List<QueryParam> attributes,\n+                                                                                                 List<QueryParam> variables,\n+                                                                                                 int processType,\n+                                                                                                 String varPrefix,\n+                                                                                                 QueryContext queryContext) {\n+        EntityManager entityManager = emf.createEntityManager();\n+\n+        // first step is to filter the data creating a derived tables and pivoting var - rows to columns (only the variables we are interested to filter)\n+        StringBuilder derivedTables = new StringBuilder();\n+        if (!variables.isEmpty()) {\n+            List<String> conditions = new ArrayList<>();\n+            variables.stream().forEach(expr -> conditions.add(\"(A1.variableId = :NAME_\" + expr.getColumn() + \" AND \" + computeExpression(expr, \"A1.value\", \":VALUE_\" + expr.getColumn()) + \")\\n\"));\n+            String where = String.join(\" OR \", conditions);\n+            derivedTables.append(\"INNER JOIN (\" +\n+                                 \"SELECT A1.processInstanceId \\n\" +\n+                                 \"FROM VariableInstanceLog A1 \\n\" +\n+                                 \"LEFT JOIN VariableInstanceLog A2 ON A1.processId = A2.processId AND A1.processInstanceId = A2.processInstanceId AND A1.variableInstanceId = A2.variableInstanceId AND A2.id > A1.id  \\n\" +\n+                                 \"WHERE A2.id IS NULL AND (\" + where + \") \" +\n+                                 \"GROUP BY A1.processInstanceId \" +\n+                                 \"HAVING COUNT(*) = :NUMBER_OF_VARS \" +\n+                                 \") TABLE_VAR ON TABLE_VAR.processInstanceId = pil.processInstanceId \\n\");\n+        }\n+\n+        StringBuilder globalWhere = new StringBuilder();\n+        attributes.stream().forEach(expr -> globalWhere.append(\" AND \" + computeExpression(expr, expr.getColumn(), \":ATTR_\" + expr.getColumn())));\n+\n+        String procSQLString =\n+                \" SELECT DISTINCT pil.processInstanceId \" +\n+                               \" FROM ProcessInstanceLog pil \\n \" +\n+                               derivedTables +\n+                               \" WHERE pil.processType = :processType \" + globalWhere +\n+                               \" ORDER BY pil.processInstanceId ASC \";\n+\n+        Query query = entityManager.createNativeQuery(procSQLString);\n+        variables.stream().forEach(var -> query.setParameter(\"NAME_\" + var.getColumn(), varPrefix + var.getColumn()));\n+        variables.stream().filter(e -> e.getObjectValue() != null).forEach(var -> query.setParameter(\"VALUE_\" + var.getColumn(), var.getObjectValue()));\n+        attributes.stream().filter(e -> e.getObjectValue() != null).forEach((entry) -> query.setParameter(\"ATTR_\" + entry.getColumn(), entry.getObjectValue()));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f04f50355ec285330b3467d42754a036a04b1db3"}, "originalPosition": 95}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUzNzMzNTAyOnYy", "diffSide": "RIGHT", "path": "jbpm-services/jbpm-kie-services/src/main/java/org/jbpm/kie/services/impl/AbstractAdvanceRuntimeDataServiceImpl.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNVQwODo1ODo0N1rOGFwU7A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNVQwODo1ODo0N1rOGFwU7A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODY4Nzg1Mg==", "bodyText": "Please remove the extra parentheses around \"expr\"\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        variables.stream().forEach((expr) -> conditions.add(\"(name = :V_NAME_\" + expr.getColumn() + \" AND \" + computeExpression(expr, \"value\", \":V_VALUE_\" + expr.getColumn()) + \")\\n\"));\n          \n          \n            \n                        variables.stream().forEach(expr -> conditions.add(\"(name = :V_NAME_\" + expr.getColumn() + \" AND \" + computeExpression(expr, \"value\", \":V_VALUE_\" + expr.getColumn()) + \")\\n\"));", "url": "https://github.com/kiegroup/jbpm/pull/1615#discussion_r408687852", "createdAt": "2020-04-15T08:58:47Z", "author": {"login": "afalhambra"}, "path": "jbpm-services/jbpm-kie-services/src/main/java/org/jbpm/kie/services/impl/AbstractAdvanceRuntimeDataServiceImpl.java", "diffHunk": "@@ -0,0 +1,346 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.jbpm.kie.services.impl;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import javax.persistence.EntityManager;\n+import javax.persistence.EntityManagerFactory;\n+import javax.persistence.Query;\n+\n+import org.dashbuilder.dataset.filter.CoreFunctionType;\n+import org.jbpm.kie.services.impl.model.ProcessInstanceWithVarsDesc;\n+import org.jbpm.kie.services.impl.model.UserTaskInstanceWithPotOwnerDesc;\n+import org.jbpm.services.api.query.model.QueryParam;\n+import org.jbpm.shared.services.impl.QueryManager;\n+import org.jbpm.shared.services.impl.TransactionalCommandService;\n+import org.jbpm.shared.services.impl.commands.QueryNameCommand;\n+import org.kie.api.runtime.query.QueryContext;\n+\n+import static java.util.Collections.singletonMap;\n+\n+public abstract class AbstractAdvanceRuntimeDataServiceImpl {\n+\n+    private static final String ID_LIST = \"idList\";\n+    private EntityManagerFactory emf;\n+    private TransactionalCommandService commandService;\n+\n+    public AbstractAdvanceRuntimeDataServiceImpl() {\n+        QueryManager.get().addNamedQueries(\"META-INF/Servicesorm.xml\");\n+    }\n+    public void setCommandService(TransactionalCommandService commandService) {\n+        this.commandService = commandService;\n+    }\n+\n+    public void setEmf(EntityManagerFactory emf) {\n+        this.emf = emf;\n+    }\n+\n+\n+    public List<org.jbpm.services.api.model.ProcessInstanceWithVarsDesc> queryProcessByVariables(List<QueryParam> attributes,\n+                                                                                                 List<QueryParam> variables,\n+                                                                                                 int processType,\n+                                                                                                 String varPrefix,\n+                                                                                                 QueryContext queryContext) {\n+        EntityManager entityManager = emf.createEntityManager();\n+\n+        // first step is to filter the data creating a derived tables and pivoting var - rows to columns (only the variables we are interested to filter)\n+        StringBuilder derivedTables = new StringBuilder();\n+        if (!variables.isEmpty()) {\n+            List<String> conditions = new ArrayList<>();\n+            variables.stream().forEach(expr -> conditions.add(\"(A1.variableId = :NAME_\" + expr.getColumn() + \" AND \" + computeExpression(expr, \"A1.value\", \":VALUE_\" + expr.getColumn()) + \")\\n\"));\n+            String where = String.join(\" OR \", conditions);\n+            derivedTables.append(\"INNER JOIN (\" +\n+                                 \"SELECT A1.processInstanceId \\n\" +\n+                                 \"FROM VariableInstanceLog A1 \\n\" +\n+                                 \"LEFT JOIN VariableInstanceLog A2 ON A1.processId = A2.processId AND A1.processInstanceId = A2.processInstanceId AND A1.variableInstanceId = A2.variableInstanceId AND A2.id > A1.id  \\n\" +\n+                                 \"WHERE A2.id IS NULL AND (\" + where + \") \" +\n+                                 \"GROUP BY A1.processInstanceId \" +\n+                                 \"HAVING COUNT(*) = :NUMBER_OF_VARS \" +\n+                                 \") TABLE_VAR ON TABLE_VAR.processInstanceId = pil.processInstanceId \\n\");\n+        }\n+\n+        StringBuilder globalWhere = new StringBuilder();\n+        attributes.stream().forEach(expr -> globalWhere.append(\" AND \" + computeExpression(expr, expr.getColumn(), \":ATTR_\" + expr.getColumn())));\n+\n+        String procSQLString =\n+                \" SELECT DISTINCT pil.processInstanceId \" +\n+                               \" FROM ProcessInstanceLog pil \\n \" +\n+                               derivedTables +\n+                               \" WHERE pil.processType = :processType \" + globalWhere +\n+                               \" ORDER BY pil.processInstanceId ASC \";\n+\n+        Query query = entityManager.createNativeQuery(procSQLString);\n+        variables.stream().forEach(var -> query.setParameter(\"NAME_\" + var.getColumn(), varPrefix + var.getColumn()));\n+        variables.stream().filter(e -> e.getObjectValue() != null).forEach(var -> query.setParameter(\"VALUE_\" + var.getColumn(), var.getObjectValue()));\n+        attributes.stream().filter(e -> e.getObjectValue() != null).forEach((entry) -> query.setParameter(\"ATTR_\" + entry.getColumn(), entry.getObjectValue()));\n+\n+        if (!variables.isEmpty()) {\n+            query.setParameter(\"NUMBER_OF_VARS\", variables.size());\n+        }\n+        query.setParameter(\"processType\", processType);\n+\n+        addPagination(query, queryContext);\n+        List<Number> ids = query.getResultList();\n+        if (ids.isEmpty()) {\n+            return Collections.emptyList();\n+        }\n+\n+        // now we get the information\n+\n+        List<Object[]> procRows = commandService.execute(new QueryNameCommand<List<Object[]>>(\"GetProcessInstanceByIdList\", singletonMap(ID_LIST, ids)));\n+        List<Object[]> varRows = commandService.execute(new QueryNameCommand<List<Object[]>>(\"GetVariablesByProcessInstanceIdList\", singletonMap(ID_LIST, ids)));\n+\n+        int currentVarIdx = 0;\n+        List<org.jbpm.services.api.model.ProcessInstanceWithVarsDesc> data = new ArrayList<>();\n+        for (Object[] row : procRows) {\n+            ProcessInstanceWithVarsDesc pwv = toProcessInstanceWithVarsDesc(row);\n+\n+            Map<String, Object> vars = new HashMap<>();\n+            pwv.setVariables(vars);\n+\n+            Map<String, Object> extra = new HashMap<>();\n+            pwv.setExtraData(extra);\n+            while (currentVarIdx < varRows.size() && row[0].equals(varRows.get(currentVarIdx)[0])) {\n+                String name = (String) varRows.get(currentVarIdx)[1];\n+                if (!varPrefix.isEmpty() && name.startsWith(varPrefix)) {\n+                    extra.put(name.substring(varPrefix.length()), varRows.get(currentVarIdx)[2]);\n+                } else {\n+                    vars.put(name, varRows.get(currentVarIdx)[2]);\n+                }\n+                currentVarIdx++;\n+            }\n+            data.add(pwv);\n+        }\n+\n+        entityManager.close();\n+        return data;\n+    }\n+\n+    private String computeExpression(QueryParam expr, String leftOperand, String rightOperand) {\n+        CoreFunctionType type = CoreFunctionType.getByName(expr.getOperator());\n+        switch (type) {\n+            case IS_NULL:\n+                return leftOperand + \" IS NULL \";\n+            case NOT_NULL:\n+                return leftOperand + \" IS NOT NULL \";\n+            case IN:\n+                return leftOperand + \" IN (\" + rightOperand + \") \";\n+            case NOT_IN:\n+                return leftOperand + \" NOT IN (\" + rightOperand + \") \";\n+            case EQUALS_TO:\n+                return leftOperand + \" = \" + rightOperand + \" \";\n+            case NOT_EQUALS_TO:\n+                return leftOperand + \" <> \" + rightOperand + \" \";\n+            case LIKE_TO:\n+                return leftOperand + \" LIKE \" + rightOperand + \" \";\n+            default:\n+                throw new UnsupportedOperationException(\"Queryparam: \" + expr + \" not supported\");\n+        }\n+    }\n+    private ProcessInstanceWithVarsDesc toProcessInstanceWithVarsDesc(Object[] row) {\n+        return new ProcessInstanceWithVarsDesc(((Number) row[0]).longValue(),\n+                                               (String) row[1],\n+                                               (String) row[2],\n+                                               (String) row[3],\n+                                               ((Number) row[4]).intValue(),\n+                                               (String) row[5],\n+                                               (Date) row[6],\n+                                               (String) row[7],\n+                                               (String) row[8]);\n+    }\n+\n+    private void addPagination(Query query, QueryContext context) {\n+        if (context.getCount() > 0) {\n+            query.setFirstResult(context.getOffset());\n+            query.setMaxResults(context.getCount());\n+        }\n+    }\n+\n+    public List<org.jbpm.services.api.model.UserTaskInstanceWithPotOwnerDesc> queryUserTasksByVariables(List<QueryParam> attributes,\n+                                                                                                        List<QueryParam> variables,\n+                                                                                                        List<QueryParam> processVariables,\n+                                                                                                        List<String> owners,\n+                                                                                                        int processType,\n+                                                                                                        String varPrefix,\n+                                                                                                        QueryContext queryContext) {\n+        EntityManager entityManager = emf.createEntityManager();\n+        StringBuilder globalWhere = new StringBuilder();\n+        StringBuilder derivedTables = new StringBuilder();\n+        if (!variables.isEmpty()) {\n+            List<String> conditions = new ArrayList<>();\n+            variables.stream().forEach((expr) -> conditions.add(\"(name = :V_NAME_\" + expr.getColumn() + \" AND \" + computeExpression(expr, \"value\", \":V_VALUE_\" + expr.getColumn()) + \")\\n\"));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f04f50355ec285330b3467d42754a036a04b1db3"}, "originalPosition": 191}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUzNzMzODI3OnYy", "diffSide": "RIGHT", "path": "jbpm-services/jbpm-kie-services/src/main/java/org/jbpm/kie/services/impl/AbstractAdvanceRuntimeDataServiceImpl.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNVQwODo1OTozN1rOGFwW-A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNVQwODo1OTozN1rOGFwW-A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODY4ODM3Ng==", "bodyText": "Please remove the extra parentheses around \"expr\"\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        processVariables.stream().forEach((expr) -> conditions.add(\"(A1.variableId = :P_NAME_\" + expr.getColumn() + \" AND \" + computeExpression(expr, \"A1.value\", \":P_VALUE_\" + expr.getColumn()) + \")\\n\"));\n          \n          \n            \n                        processVariables.stream().forEach(expr -> conditions.add(\"(A1.variableId = :P_NAME_\" + expr.getColumn() + \" AND \" + computeExpression(expr, \"A1.value\", \":P_VALUE_\" + expr.getColumn()) + \")\\n\"));", "url": "https://github.com/kiegroup/jbpm/pull/1615#discussion_r408688376", "createdAt": "2020-04-15T08:59:37Z", "author": {"login": "afalhambra"}, "path": "jbpm-services/jbpm-kie-services/src/main/java/org/jbpm/kie/services/impl/AbstractAdvanceRuntimeDataServiceImpl.java", "diffHunk": "@@ -0,0 +1,346 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.jbpm.kie.services.impl;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import javax.persistence.EntityManager;\n+import javax.persistence.EntityManagerFactory;\n+import javax.persistence.Query;\n+\n+import org.dashbuilder.dataset.filter.CoreFunctionType;\n+import org.jbpm.kie.services.impl.model.ProcessInstanceWithVarsDesc;\n+import org.jbpm.kie.services.impl.model.UserTaskInstanceWithPotOwnerDesc;\n+import org.jbpm.services.api.query.model.QueryParam;\n+import org.jbpm.shared.services.impl.QueryManager;\n+import org.jbpm.shared.services.impl.TransactionalCommandService;\n+import org.jbpm.shared.services.impl.commands.QueryNameCommand;\n+import org.kie.api.runtime.query.QueryContext;\n+\n+import static java.util.Collections.singletonMap;\n+\n+public abstract class AbstractAdvanceRuntimeDataServiceImpl {\n+\n+    private static final String ID_LIST = \"idList\";\n+    private EntityManagerFactory emf;\n+    private TransactionalCommandService commandService;\n+\n+    public AbstractAdvanceRuntimeDataServiceImpl() {\n+        QueryManager.get().addNamedQueries(\"META-INF/Servicesorm.xml\");\n+    }\n+    public void setCommandService(TransactionalCommandService commandService) {\n+        this.commandService = commandService;\n+    }\n+\n+    public void setEmf(EntityManagerFactory emf) {\n+        this.emf = emf;\n+    }\n+\n+\n+    public List<org.jbpm.services.api.model.ProcessInstanceWithVarsDesc> queryProcessByVariables(List<QueryParam> attributes,\n+                                                                                                 List<QueryParam> variables,\n+                                                                                                 int processType,\n+                                                                                                 String varPrefix,\n+                                                                                                 QueryContext queryContext) {\n+        EntityManager entityManager = emf.createEntityManager();\n+\n+        // first step is to filter the data creating a derived tables and pivoting var - rows to columns (only the variables we are interested to filter)\n+        StringBuilder derivedTables = new StringBuilder();\n+        if (!variables.isEmpty()) {\n+            List<String> conditions = new ArrayList<>();\n+            variables.stream().forEach(expr -> conditions.add(\"(A1.variableId = :NAME_\" + expr.getColumn() + \" AND \" + computeExpression(expr, \"A1.value\", \":VALUE_\" + expr.getColumn()) + \")\\n\"));\n+            String where = String.join(\" OR \", conditions);\n+            derivedTables.append(\"INNER JOIN (\" +\n+                                 \"SELECT A1.processInstanceId \\n\" +\n+                                 \"FROM VariableInstanceLog A1 \\n\" +\n+                                 \"LEFT JOIN VariableInstanceLog A2 ON A1.processId = A2.processId AND A1.processInstanceId = A2.processInstanceId AND A1.variableInstanceId = A2.variableInstanceId AND A2.id > A1.id  \\n\" +\n+                                 \"WHERE A2.id IS NULL AND (\" + where + \") \" +\n+                                 \"GROUP BY A1.processInstanceId \" +\n+                                 \"HAVING COUNT(*) = :NUMBER_OF_VARS \" +\n+                                 \") TABLE_VAR ON TABLE_VAR.processInstanceId = pil.processInstanceId \\n\");\n+        }\n+\n+        StringBuilder globalWhere = new StringBuilder();\n+        attributes.stream().forEach(expr -> globalWhere.append(\" AND \" + computeExpression(expr, expr.getColumn(), \":ATTR_\" + expr.getColumn())));\n+\n+        String procSQLString =\n+                \" SELECT DISTINCT pil.processInstanceId \" +\n+                               \" FROM ProcessInstanceLog pil \\n \" +\n+                               derivedTables +\n+                               \" WHERE pil.processType = :processType \" + globalWhere +\n+                               \" ORDER BY pil.processInstanceId ASC \";\n+\n+        Query query = entityManager.createNativeQuery(procSQLString);\n+        variables.stream().forEach(var -> query.setParameter(\"NAME_\" + var.getColumn(), varPrefix + var.getColumn()));\n+        variables.stream().filter(e -> e.getObjectValue() != null).forEach(var -> query.setParameter(\"VALUE_\" + var.getColumn(), var.getObjectValue()));\n+        attributes.stream().filter(e -> e.getObjectValue() != null).forEach((entry) -> query.setParameter(\"ATTR_\" + entry.getColumn(), entry.getObjectValue()));\n+\n+        if (!variables.isEmpty()) {\n+            query.setParameter(\"NUMBER_OF_VARS\", variables.size());\n+        }\n+        query.setParameter(\"processType\", processType);\n+\n+        addPagination(query, queryContext);\n+        List<Number> ids = query.getResultList();\n+        if (ids.isEmpty()) {\n+            return Collections.emptyList();\n+        }\n+\n+        // now we get the information\n+\n+        List<Object[]> procRows = commandService.execute(new QueryNameCommand<List<Object[]>>(\"GetProcessInstanceByIdList\", singletonMap(ID_LIST, ids)));\n+        List<Object[]> varRows = commandService.execute(new QueryNameCommand<List<Object[]>>(\"GetVariablesByProcessInstanceIdList\", singletonMap(ID_LIST, ids)));\n+\n+        int currentVarIdx = 0;\n+        List<org.jbpm.services.api.model.ProcessInstanceWithVarsDesc> data = new ArrayList<>();\n+        for (Object[] row : procRows) {\n+            ProcessInstanceWithVarsDesc pwv = toProcessInstanceWithVarsDesc(row);\n+\n+            Map<String, Object> vars = new HashMap<>();\n+            pwv.setVariables(vars);\n+\n+            Map<String, Object> extra = new HashMap<>();\n+            pwv.setExtraData(extra);\n+            while (currentVarIdx < varRows.size() && row[0].equals(varRows.get(currentVarIdx)[0])) {\n+                String name = (String) varRows.get(currentVarIdx)[1];\n+                if (!varPrefix.isEmpty() && name.startsWith(varPrefix)) {\n+                    extra.put(name.substring(varPrefix.length()), varRows.get(currentVarIdx)[2]);\n+                } else {\n+                    vars.put(name, varRows.get(currentVarIdx)[2]);\n+                }\n+                currentVarIdx++;\n+            }\n+            data.add(pwv);\n+        }\n+\n+        entityManager.close();\n+        return data;\n+    }\n+\n+    private String computeExpression(QueryParam expr, String leftOperand, String rightOperand) {\n+        CoreFunctionType type = CoreFunctionType.getByName(expr.getOperator());\n+        switch (type) {\n+            case IS_NULL:\n+                return leftOperand + \" IS NULL \";\n+            case NOT_NULL:\n+                return leftOperand + \" IS NOT NULL \";\n+            case IN:\n+                return leftOperand + \" IN (\" + rightOperand + \") \";\n+            case NOT_IN:\n+                return leftOperand + \" NOT IN (\" + rightOperand + \") \";\n+            case EQUALS_TO:\n+                return leftOperand + \" = \" + rightOperand + \" \";\n+            case NOT_EQUALS_TO:\n+                return leftOperand + \" <> \" + rightOperand + \" \";\n+            case LIKE_TO:\n+                return leftOperand + \" LIKE \" + rightOperand + \" \";\n+            default:\n+                throw new UnsupportedOperationException(\"Queryparam: \" + expr + \" not supported\");\n+        }\n+    }\n+    private ProcessInstanceWithVarsDesc toProcessInstanceWithVarsDesc(Object[] row) {\n+        return new ProcessInstanceWithVarsDesc(((Number) row[0]).longValue(),\n+                                               (String) row[1],\n+                                               (String) row[2],\n+                                               (String) row[3],\n+                                               ((Number) row[4]).intValue(),\n+                                               (String) row[5],\n+                                               (Date) row[6],\n+                                               (String) row[7],\n+                                               (String) row[8]);\n+    }\n+\n+    private void addPagination(Query query, QueryContext context) {\n+        if (context.getCount() > 0) {\n+            query.setFirstResult(context.getOffset());\n+            query.setMaxResults(context.getCount());\n+        }\n+    }\n+\n+    public List<org.jbpm.services.api.model.UserTaskInstanceWithPotOwnerDesc> queryUserTasksByVariables(List<QueryParam> attributes,\n+                                                                                                        List<QueryParam> variables,\n+                                                                                                        List<QueryParam> processVariables,\n+                                                                                                        List<String> owners,\n+                                                                                                        int processType,\n+                                                                                                        String varPrefix,\n+                                                                                                        QueryContext queryContext) {\n+        EntityManager entityManager = emf.createEntityManager();\n+        StringBuilder globalWhere = new StringBuilder();\n+        StringBuilder derivedTables = new StringBuilder();\n+        if (!variables.isEmpty()) {\n+            List<String> conditions = new ArrayList<>();\n+            variables.stream().forEach((expr) -> conditions.add(\"(name = :V_NAME_\" + expr.getColumn() + \" AND \" + computeExpression(expr, \"value\", \":V_VALUE_\" + expr.getColumn()) + \")\\n\"));\n+            String where = String.join(\" OR \", conditions);\n+            derivedTables.append(\"INNER JOIN (\\n\" +\n+                                 \"SELECT taskId \\n\" +\n+                                 \"FROM TaskVariableImpl \\n\" +\n+                                 \"WHERE type = 0 AND (\" + where + \")\\n\" +\n+                                 \"GROUP BY taskId \\n\" +\n+                                 \"HAVING COUNT(*) = :NUMBER_OF_TASKVARS \\n\" +\n+                                 \") TABLE_TASK_VAR ON TABLE_TASK_VAR.taskId = task.id  \\n\");\n+        }\n+\n+        if (!processVariables.isEmpty()) {\n+            List<String> conditions = new ArrayList<>();\n+            processVariables.stream().forEach((expr) -> conditions.add(\"(A1.variableId = :P_NAME_\" + expr.getColumn() + \" AND \" + computeExpression(expr, \"A1.value\", \":P_VALUE_\" + expr.getColumn()) + \")\\n\"));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f04f50355ec285330b3467d42754a036a04b1db3"}, "originalPosition": 204}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUzNzM0MDU3OnYy", "diffSide": "RIGHT", "path": "jbpm-services/jbpm-kie-services/src/main/java/org/jbpm/kie/services/impl/AbstractAdvanceRuntimeDataServiceImpl.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNVQwOTowMDoxNVrOGFwYfQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNVQwOTowMDoxNVrOGFwYfQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODY4ODc2NQ==", "bodyText": "Please remove extra parentheses around \"expr\"\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    attributes.stream().forEach((expr) -> globalWhere.append(\" AND \" + computeExpression(expr, expr.getColumn(), \":ATTR_\" + expr.getColumn())));\n          \n          \n            \n                    attributes.stream().forEach(expr -> globalWhere.append(\" AND \" + computeExpression(expr, expr.getColumn(), \":ATTR_\" + expr.getColumn())));", "url": "https://github.com/kiegroup/jbpm/pull/1615#discussion_r408688765", "createdAt": "2020-04-15T09:00:15Z", "author": {"login": "afalhambra"}, "path": "jbpm-services/jbpm-kie-services/src/main/java/org/jbpm/kie/services/impl/AbstractAdvanceRuntimeDataServiceImpl.java", "diffHunk": "@@ -0,0 +1,346 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.jbpm.kie.services.impl;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import javax.persistence.EntityManager;\n+import javax.persistence.EntityManagerFactory;\n+import javax.persistence.Query;\n+\n+import org.dashbuilder.dataset.filter.CoreFunctionType;\n+import org.jbpm.kie.services.impl.model.ProcessInstanceWithVarsDesc;\n+import org.jbpm.kie.services.impl.model.UserTaskInstanceWithPotOwnerDesc;\n+import org.jbpm.services.api.query.model.QueryParam;\n+import org.jbpm.shared.services.impl.QueryManager;\n+import org.jbpm.shared.services.impl.TransactionalCommandService;\n+import org.jbpm.shared.services.impl.commands.QueryNameCommand;\n+import org.kie.api.runtime.query.QueryContext;\n+\n+import static java.util.Collections.singletonMap;\n+\n+public abstract class AbstractAdvanceRuntimeDataServiceImpl {\n+\n+    private static final String ID_LIST = \"idList\";\n+    private EntityManagerFactory emf;\n+    private TransactionalCommandService commandService;\n+\n+    public AbstractAdvanceRuntimeDataServiceImpl() {\n+        QueryManager.get().addNamedQueries(\"META-INF/Servicesorm.xml\");\n+    }\n+    public void setCommandService(TransactionalCommandService commandService) {\n+        this.commandService = commandService;\n+    }\n+\n+    public void setEmf(EntityManagerFactory emf) {\n+        this.emf = emf;\n+    }\n+\n+\n+    public List<org.jbpm.services.api.model.ProcessInstanceWithVarsDesc> queryProcessByVariables(List<QueryParam> attributes,\n+                                                                                                 List<QueryParam> variables,\n+                                                                                                 int processType,\n+                                                                                                 String varPrefix,\n+                                                                                                 QueryContext queryContext) {\n+        EntityManager entityManager = emf.createEntityManager();\n+\n+        // first step is to filter the data creating a derived tables and pivoting var - rows to columns (only the variables we are interested to filter)\n+        StringBuilder derivedTables = new StringBuilder();\n+        if (!variables.isEmpty()) {\n+            List<String> conditions = new ArrayList<>();\n+            variables.stream().forEach(expr -> conditions.add(\"(A1.variableId = :NAME_\" + expr.getColumn() + \" AND \" + computeExpression(expr, \"A1.value\", \":VALUE_\" + expr.getColumn()) + \")\\n\"));\n+            String where = String.join(\" OR \", conditions);\n+            derivedTables.append(\"INNER JOIN (\" +\n+                                 \"SELECT A1.processInstanceId \\n\" +\n+                                 \"FROM VariableInstanceLog A1 \\n\" +\n+                                 \"LEFT JOIN VariableInstanceLog A2 ON A1.processId = A2.processId AND A1.processInstanceId = A2.processInstanceId AND A1.variableInstanceId = A2.variableInstanceId AND A2.id > A1.id  \\n\" +\n+                                 \"WHERE A2.id IS NULL AND (\" + where + \") \" +\n+                                 \"GROUP BY A1.processInstanceId \" +\n+                                 \"HAVING COUNT(*) = :NUMBER_OF_VARS \" +\n+                                 \") TABLE_VAR ON TABLE_VAR.processInstanceId = pil.processInstanceId \\n\");\n+        }\n+\n+        StringBuilder globalWhere = new StringBuilder();\n+        attributes.stream().forEach(expr -> globalWhere.append(\" AND \" + computeExpression(expr, expr.getColumn(), \":ATTR_\" + expr.getColumn())));\n+\n+        String procSQLString =\n+                \" SELECT DISTINCT pil.processInstanceId \" +\n+                               \" FROM ProcessInstanceLog pil \\n \" +\n+                               derivedTables +\n+                               \" WHERE pil.processType = :processType \" + globalWhere +\n+                               \" ORDER BY pil.processInstanceId ASC \";\n+\n+        Query query = entityManager.createNativeQuery(procSQLString);\n+        variables.stream().forEach(var -> query.setParameter(\"NAME_\" + var.getColumn(), varPrefix + var.getColumn()));\n+        variables.stream().filter(e -> e.getObjectValue() != null).forEach(var -> query.setParameter(\"VALUE_\" + var.getColumn(), var.getObjectValue()));\n+        attributes.stream().filter(e -> e.getObjectValue() != null).forEach((entry) -> query.setParameter(\"ATTR_\" + entry.getColumn(), entry.getObjectValue()));\n+\n+        if (!variables.isEmpty()) {\n+            query.setParameter(\"NUMBER_OF_VARS\", variables.size());\n+        }\n+        query.setParameter(\"processType\", processType);\n+\n+        addPagination(query, queryContext);\n+        List<Number> ids = query.getResultList();\n+        if (ids.isEmpty()) {\n+            return Collections.emptyList();\n+        }\n+\n+        // now we get the information\n+\n+        List<Object[]> procRows = commandService.execute(new QueryNameCommand<List<Object[]>>(\"GetProcessInstanceByIdList\", singletonMap(ID_LIST, ids)));\n+        List<Object[]> varRows = commandService.execute(new QueryNameCommand<List<Object[]>>(\"GetVariablesByProcessInstanceIdList\", singletonMap(ID_LIST, ids)));\n+\n+        int currentVarIdx = 0;\n+        List<org.jbpm.services.api.model.ProcessInstanceWithVarsDesc> data = new ArrayList<>();\n+        for (Object[] row : procRows) {\n+            ProcessInstanceWithVarsDesc pwv = toProcessInstanceWithVarsDesc(row);\n+\n+            Map<String, Object> vars = new HashMap<>();\n+            pwv.setVariables(vars);\n+\n+            Map<String, Object> extra = new HashMap<>();\n+            pwv.setExtraData(extra);\n+            while (currentVarIdx < varRows.size() && row[0].equals(varRows.get(currentVarIdx)[0])) {\n+                String name = (String) varRows.get(currentVarIdx)[1];\n+                if (!varPrefix.isEmpty() && name.startsWith(varPrefix)) {\n+                    extra.put(name.substring(varPrefix.length()), varRows.get(currentVarIdx)[2]);\n+                } else {\n+                    vars.put(name, varRows.get(currentVarIdx)[2]);\n+                }\n+                currentVarIdx++;\n+            }\n+            data.add(pwv);\n+        }\n+\n+        entityManager.close();\n+        return data;\n+    }\n+\n+    private String computeExpression(QueryParam expr, String leftOperand, String rightOperand) {\n+        CoreFunctionType type = CoreFunctionType.getByName(expr.getOperator());\n+        switch (type) {\n+            case IS_NULL:\n+                return leftOperand + \" IS NULL \";\n+            case NOT_NULL:\n+                return leftOperand + \" IS NOT NULL \";\n+            case IN:\n+                return leftOperand + \" IN (\" + rightOperand + \") \";\n+            case NOT_IN:\n+                return leftOperand + \" NOT IN (\" + rightOperand + \") \";\n+            case EQUALS_TO:\n+                return leftOperand + \" = \" + rightOperand + \" \";\n+            case NOT_EQUALS_TO:\n+                return leftOperand + \" <> \" + rightOperand + \" \";\n+            case LIKE_TO:\n+                return leftOperand + \" LIKE \" + rightOperand + \" \";\n+            default:\n+                throw new UnsupportedOperationException(\"Queryparam: \" + expr + \" not supported\");\n+        }\n+    }\n+    private ProcessInstanceWithVarsDesc toProcessInstanceWithVarsDesc(Object[] row) {\n+        return new ProcessInstanceWithVarsDesc(((Number) row[0]).longValue(),\n+                                               (String) row[1],\n+                                               (String) row[2],\n+                                               (String) row[3],\n+                                               ((Number) row[4]).intValue(),\n+                                               (String) row[5],\n+                                               (Date) row[6],\n+                                               (String) row[7],\n+                                               (String) row[8]);\n+    }\n+\n+    private void addPagination(Query query, QueryContext context) {\n+        if (context.getCount() > 0) {\n+            query.setFirstResult(context.getOffset());\n+            query.setMaxResults(context.getCount());\n+        }\n+    }\n+\n+    public List<org.jbpm.services.api.model.UserTaskInstanceWithPotOwnerDesc> queryUserTasksByVariables(List<QueryParam> attributes,\n+                                                                                                        List<QueryParam> variables,\n+                                                                                                        List<QueryParam> processVariables,\n+                                                                                                        List<String> owners,\n+                                                                                                        int processType,\n+                                                                                                        String varPrefix,\n+                                                                                                        QueryContext queryContext) {\n+        EntityManager entityManager = emf.createEntityManager();\n+        StringBuilder globalWhere = new StringBuilder();\n+        StringBuilder derivedTables = new StringBuilder();\n+        if (!variables.isEmpty()) {\n+            List<String> conditions = new ArrayList<>();\n+            variables.stream().forEach((expr) -> conditions.add(\"(name = :V_NAME_\" + expr.getColumn() + \" AND \" + computeExpression(expr, \"value\", \":V_VALUE_\" + expr.getColumn()) + \")\\n\"));\n+            String where = String.join(\" OR \", conditions);\n+            derivedTables.append(\"INNER JOIN (\\n\" +\n+                                 \"SELECT taskId \\n\" +\n+                                 \"FROM TaskVariableImpl \\n\" +\n+                                 \"WHERE type = 0 AND (\" + where + \")\\n\" +\n+                                 \"GROUP BY taskId \\n\" +\n+                                 \"HAVING COUNT(*) = :NUMBER_OF_TASKVARS \\n\" +\n+                                 \") TABLE_TASK_VAR ON TABLE_TASK_VAR.taskId = task.id  \\n\");\n+        }\n+\n+        if (!processVariables.isEmpty()) {\n+            List<String> conditions = new ArrayList<>();\n+            processVariables.stream().forEach((expr) -> conditions.add(\"(A1.variableId = :P_NAME_\" + expr.getColumn() + \" AND \" + computeExpression(expr, \"A1.value\", \":P_VALUE_\" + expr.getColumn()) + \")\\n\"));\n+            String where = String.join(\" OR \", conditions);\n+            derivedTables.append(\"INNER JOIN (\" +\n+                                 \"SELECT A1.processInstanceId \\n\" +\n+                                 \"FROM VariableInstanceLog A1 \\n\" +\n+                                 \"LEFT JOIN VariableInstanceLog A2 ON A1.processId = A2.processId AND A1.processInstanceId = A2.processInstanceId AND A1.variableInstanceId = A2.variableInstanceId AND A2.id > A1.id  \\n\" +\n+                                 \"WHERE A2.id IS NULL AND (\" + where + \") \" +\n+                                 \"GROUP BY A1.processInstanceId \" +\n+                                 \"HAVING COUNT(*) = :NUMBER_OF_PROCVARS \" +\n+                                 \") TABLE_PROC_VAR ON TABLE_PROC_VAR.processInstanceId = pil.processInstanceId \\n\");\n+        }\n+\n+        if (!owners.isEmpty()) {\n+            derivedTables.append(\"INNER JOIN ( \\n\" +\n+                             \"           SELECT DISTINCT po.task_id \\n\" +\n+                             \"           FROM PeopleAssignments_PotOwners po \\n\" +\n+                             \"           WHERE po.entity_id IN (:owners) \\n\" +\n+                             \"           GROUP BY po.task_id \\n\" +\n+                             \"           HAVING COUNT(po.entity_id) = :num_owners \\n\" +\n+                                 \") pot ON pot.task_id = task.id \");\n+        }\n+\n+        attributes.stream().forEach((expr) -> globalWhere.append(\" AND \" + computeExpression(expr, expr.getColumn(), \":ATTR_\" + expr.getColumn())));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f04f50355ec285330b3467d42754a036a04b1db3"}, "originalPosition": 226}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUzNzM0MzEwOnYy", "diffSide": "RIGHT", "path": "jbpm-services/jbpm-kie-services/src/main/java/org/jbpm/kie/services/impl/AbstractAdvanceRuntimeDataServiceImpl.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNVQwOTowMDo1NlrOGFwaFA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNVQwOTowMDo1NlrOGFwaFA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODY4OTE3Mg==", "bodyText": "Please remove the extra parentheses around \"var\"\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    variables.stream().filter(e -> e.getObjectValue() != null).forEach((var) -> query.setParameter(\"V_VALUE_\" + var.getColumn(), var.getObjectValue()));\n          \n          \n            \n                    variables.stream().filter(e -> e.getObjectValue() != null).forEach(var -> query.setParameter(\"V_VALUE_\" + var.getColumn(), var.getObjectValue()));", "url": "https://github.com/kiegroup/jbpm/pull/1615#discussion_r408689172", "createdAt": "2020-04-15T09:00:56Z", "author": {"login": "afalhambra"}, "path": "jbpm-services/jbpm-kie-services/src/main/java/org/jbpm/kie/services/impl/AbstractAdvanceRuntimeDataServiceImpl.java", "diffHunk": "@@ -0,0 +1,346 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.jbpm.kie.services.impl;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import javax.persistence.EntityManager;\n+import javax.persistence.EntityManagerFactory;\n+import javax.persistence.Query;\n+\n+import org.dashbuilder.dataset.filter.CoreFunctionType;\n+import org.jbpm.kie.services.impl.model.ProcessInstanceWithVarsDesc;\n+import org.jbpm.kie.services.impl.model.UserTaskInstanceWithPotOwnerDesc;\n+import org.jbpm.services.api.query.model.QueryParam;\n+import org.jbpm.shared.services.impl.QueryManager;\n+import org.jbpm.shared.services.impl.TransactionalCommandService;\n+import org.jbpm.shared.services.impl.commands.QueryNameCommand;\n+import org.kie.api.runtime.query.QueryContext;\n+\n+import static java.util.Collections.singletonMap;\n+\n+public abstract class AbstractAdvanceRuntimeDataServiceImpl {\n+\n+    private static final String ID_LIST = \"idList\";\n+    private EntityManagerFactory emf;\n+    private TransactionalCommandService commandService;\n+\n+    public AbstractAdvanceRuntimeDataServiceImpl() {\n+        QueryManager.get().addNamedQueries(\"META-INF/Servicesorm.xml\");\n+    }\n+    public void setCommandService(TransactionalCommandService commandService) {\n+        this.commandService = commandService;\n+    }\n+\n+    public void setEmf(EntityManagerFactory emf) {\n+        this.emf = emf;\n+    }\n+\n+\n+    public List<org.jbpm.services.api.model.ProcessInstanceWithVarsDesc> queryProcessByVariables(List<QueryParam> attributes,\n+                                                                                                 List<QueryParam> variables,\n+                                                                                                 int processType,\n+                                                                                                 String varPrefix,\n+                                                                                                 QueryContext queryContext) {\n+        EntityManager entityManager = emf.createEntityManager();\n+\n+        // first step is to filter the data creating a derived tables and pivoting var - rows to columns (only the variables we are interested to filter)\n+        StringBuilder derivedTables = new StringBuilder();\n+        if (!variables.isEmpty()) {\n+            List<String> conditions = new ArrayList<>();\n+            variables.stream().forEach(expr -> conditions.add(\"(A1.variableId = :NAME_\" + expr.getColumn() + \" AND \" + computeExpression(expr, \"A1.value\", \":VALUE_\" + expr.getColumn()) + \")\\n\"));\n+            String where = String.join(\" OR \", conditions);\n+            derivedTables.append(\"INNER JOIN (\" +\n+                                 \"SELECT A1.processInstanceId \\n\" +\n+                                 \"FROM VariableInstanceLog A1 \\n\" +\n+                                 \"LEFT JOIN VariableInstanceLog A2 ON A1.processId = A2.processId AND A1.processInstanceId = A2.processInstanceId AND A1.variableInstanceId = A2.variableInstanceId AND A2.id > A1.id  \\n\" +\n+                                 \"WHERE A2.id IS NULL AND (\" + where + \") \" +\n+                                 \"GROUP BY A1.processInstanceId \" +\n+                                 \"HAVING COUNT(*) = :NUMBER_OF_VARS \" +\n+                                 \") TABLE_VAR ON TABLE_VAR.processInstanceId = pil.processInstanceId \\n\");\n+        }\n+\n+        StringBuilder globalWhere = new StringBuilder();\n+        attributes.stream().forEach(expr -> globalWhere.append(\" AND \" + computeExpression(expr, expr.getColumn(), \":ATTR_\" + expr.getColumn())));\n+\n+        String procSQLString =\n+                \" SELECT DISTINCT pil.processInstanceId \" +\n+                               \" FROM ProcessInstanceLog pil \\n \" +\n+                               derivedTables +\n+                               \" WHERE pil.processType = :processType \" + globalWhere +\n+                               \" ORDER BY pil.processInstanceId ASC \";\n+\n+        Query query = entityManager.createNativeQuery(procSQLString);\n+        variables.stream().forEach(var -> query.setParameter(\"NAME_\" + var.getColumn(), varPrefix + var.getColumn()));\n+        variables.stream().filter(e -> e.getObjectValue() != null).forEach(var -> query.setParameter(\"VALUE_\" + var.getColumn(), var.getObjectValue()));\n+        attributes.stream().filter(e -> e.getObjectValue() != null).forEach((entry) -> query.setParameter(\"ATTR_\" + entry.getColumn(), entry.getObjectValue()));\n+\n+        if (!variables.isEmpty()) {\n+            query.setParameter(\"NUMBER_OF_VARS\", variables.size());\n+        }\n+        query.setParameter(\"processType\", processType);\n+\n+        addPagination(query, queryContext);\n+        List<Number> ids = query.getResultList();\n+        if (ids.isEmpty()) {\n+            return Collections.emptyList();\n+        }\n+\n+        // now we get the information\n+\n+        List<Object[]> procRows = commandService.execute(new QueryNameCommand<List<Object[]>>(\"GetProcessInstanceByIdList\", singletonMap(ID_LIST, ids)));\n+        List<Object[]> varRows = commandService.execute(new QueryNameCommand<List<Object[]>>(\"GetVariablesByProcessInstanceIdList\", singletonMap(ID_LIST, ids)));\n+\n+        int currentVarIdx = 0;\n+        List<org.jbpm.services.api.model.ProcessInstanceWithVarsDesc> data = new ArrayList<>();\n+        for (Object[] row : procRows) {\n+            ProcessInstanceWithVarsDesc pwv = toProcessInstanceWithVarsDesc(row);\n+\n+            Map<String, Object> vars = new HashMap<>();\n+            pwv.setVariables(vars);\n+\n+            Map<String, Object> extra = new HashMap<>();\n+            pwv.setExtraData(extra);\n+            while (currentVarIdx < varRows.size() && row[0].equals(varRows.get(currentVarIdx)[0])) {\n+                String name = (String) varRows.get(currentVarIdx)[1];\n+                if (!varPrefix.isEmpty() && name.startsWith(varPrefix)) {\n+                    extra.put(name.substring(varPrefix.length()), varRows.get(currentVarIdx)[2]);\n+                } else {\n+                    vars.put(name, varRows.get(currentVarIdx)[2]);\n+                }\n+                currentVarIdx++;\n+            }\n+            data.add(pwv);\n+        }\n+\n+        entityManager.close();\n+        return data;\n+    }\n+\n+    private String computeExpression(QueryParam expr, String leftOperand, String rightOperand) {\n+        CoreFunctionType type = CoreFunctionType.getByName(expr.getOperator());\n+        switch (type) {\n+            case IS_NULL:\n+                return leftOperand + \" IS NULL \";\n+            case NOT_NULL:\n+                return leftOperand + \" IS NOT NULL \";\n+            case IN:\n+                return leftOperand + \" IN (\" + rightOperand + \") \";\n+            case NOT_IN:\n+                return leftOperand + \" NOT IN (\" + rightOperand + \") \";\n+            case EQUALS_TO:\n+                return leftOperand + \" = \" + rightOperand + \" \";\n+            case NOT_EQUALS_TO:\n+                return leftOperand + \" <> \" + rightOperand + \" \";\n+            case LIKE_TO:\n+                return leftOperand + \" LIKE \" + rightOperand + \" \";\n+            default:\n+                throw new UnsupportedOperationException(\"Queryparam: \" + expr + \" not supported\");\n+        }\n+    }\n+    private ProcessInstanceWithVarsDesc toProcessInstanceWithVarsDesc(Object[] row) {\n+        return new ProcessInstanceWithVarsDesc(((Number) row[0]).longValue(),\n+                                               (String) row[1],\n+                                               (String) row[2],\n+                                               (String) row[3],\n+                                               ((Number) row[4]).intValue(),\n+                                               (String) row[5],\n+                                               (Date) row[6],\n+                                               (String) row[7],\n+                                               (String) row[8]);\n+    }\n+\n+    private void addPagination(Query query, QueryContext context) {\n+        if (context.getCount() > 0) {\n+            query.setFirstResult(context.getOffset());\n+            query.setMaxResults(context.getCount());\n+        }\n+    }\n+\n+    public List<org.jbpm.services.api.model.UserTaskInstanceWithPotOwnerDesc> queryUserTasksByVariables(List<QueryParam> attributes,\n+                                                                                                        List<QueryParam> variables,\n+                                                                                                        List<QueryParam> processVariables,\n+                                                                                                        List<String> owners,\n+                                                                                                        int processType,\n+                                                                                                        String varPrefix,\n+                                                                                                        QueryContext queryContext) {\n+        EntityManager entityManager = emf.createEntityManager();\n+        StringBuilder globalWhere = new StringBuilder();\n+        StringBuilder derivedTables = new StringBuilder();\n+        if (!variables.isEmpty()) {\n+            List<String> conditions = new ArrayList<>();\n+            variables.stream().forEach((expr) -> conditions.add(\"(name = :V_NAME_\" + expr.getColumn() + \" AND \" + computeExpression(expr, \"value\", \":V_VALUE_\" + expr.getColumn()) + \")\\n\"));\n+            String where = String.join(\" OR \", conditions);\n+            derivedTables.append(\"INNER JOIN (\\n\" +\n+                                 \"SELECT taskId \\n\" +\n+                                 \"FROM TaskVariableImpl \\n\" +\n+                                 \"WHERE type = 0 AND (\" + where + \")\\n\" +\n+                                 \"GROUP BY taskId \\n\" +\n+                                 \"HAVING COUNT(*) = :NUMBER_OF_TASKVARS \\n\" +\n+                                 \") TABLE_TASK_VAR ON TABLE_TASK_VAR.taskId = task.id  \\n\");\n+        }\n+\n+        if (!processVariables.isEmpty()) {\n+            List<String> conditions = new ArrayList<>();\n+            processVariables.stream().forEach((expr) -> conditions.add(\"(A1.variableId = :P_NAME_\" + expr.getColumn() + \" AND \" + computeExpression(expr, \"A1.value\", \":P_VALUE_\" + expr.getColumn()) + \")\\n\"));\n+            String where = String.join(\" OR \", conditions);\n+            derivedTables.append(\"INNER JOIN (\" +\n+                                 \"SELECT A1.processInstanceId \\n\" +\n+                                 \"FROM VariableInstanceLog A1 \\n\" +\n+                                 \"LEFT JOIN VariableInstanceLog A2 ON A1.processId = A2.processId AND A1.processInstanceId = A2.processInstanceId AND A1.variableInstanceId = A2.variableInstanceId AND A2.id > A1.id  \\n\" +\n+                                 \"WHERE A2.id IS NULL AND (\" + where + \") \" +\n+                                 \"GROUP BY A1.processInstanceId \" +\n+                                 \"HAVING COUNT(*) = :NUMBER_OF_PROCVARS \" +\n+                                 \") TABLE_PROC_VAR ON TABLE_PROC_VAR.processInstanceId = pil.processInstanceId \\n\");\n+        }\n+\n+        if (!owners.isEmpty()) {\n+            derivedTables.append(\"INNER JOIN ( \\n\" +\n+                             \"           SELECT DISTINCT po.task_id \\n\" +\n+                             \"           FROM PeopleAssignments_PotOwners po \\n\" +\n+                             \"           WHERE po.entity_id IN (:owners) \\n\" +\n+                             \"           GROUP BY po.task_id \\n\" +\n+                             \"           HAVING COUNT(po.entity_id) = :num_owners \\n\" +\n+                                 \") pot ON pot.task_id = task.id \");\n+        }\n+\n+        attributes.stream().forEach((expr) -> globalWhere.append(\" AND \" + computeExpression(expr, expr.getColumn(), \":ATTR_\" + expr.getColumn())));\n+\n+        String procSQLString = \"SELECT DISTINCT task.id \" +\n+                               \" FROM Task task \" +\n+                               \" INNER JOIN ProcessInstanceLog pil ON pil.processInstanceId = task.processInstanceId \\n \" +\n+                               derivedTables +\n+                               \" WHERE  pil.processType = :processType \" + globalWhere +\n+                               \" ORDER BY task.id ASC \";\n+\n+        Query query = entityManager.createNativeQuery(procSQLString);\n+        variables.stream().forEach(var -> query.setParameter(\"V_NAME_\" + var.getColumn(), var.getColumn()));\n+        variables.stream().filter(e -> e.getObjectValue() != null).forEach((var) -> query.setParameter(\"V_VALUE_\" + var.getColumn(), var.getObjectValue()));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f04f50355ec285330b3467d42754a036a04b1db3"}, "originalPosition": 237}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUzNzM0NDY5OnYy", "diffSide": "RIGHT", "path": "jbpm-services/jbpm-kie-services/src/main/java/org/jbpm/kie/services/impl/AbstractAdvanceRuntimeDataServiceImpl.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNVQwOTowMToyM1rOGFwbOA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xN1QwNzowNDo1NVrOGHCSFQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODY4OTQ2NA==", "bodyText": "Please remove the extra parentheses around \"var\"\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    processVariables.stream().filter(e -> e.getObjectValue() != null).forEach((var) -> query.setParameter(\"P_VALUE_\" + var.getColumn(), var.getObjectValue()));\n          \n          \n            \n                    processVariables.stream().filter(e -> e.getObjectValue() != null).forEach(var -> query.setParameter(\"P_VALUE_\" + var.getColumn(), var.getObjectValue()));", "url": "https://github.com/kiegroup/jbpm/pull/1615#discussion_r408689464", "createdAt": "2020-04-15T09:01:23Z", "author": {"login": "afalhambra"}, "path": "jbpm-services/jbpm-kie-services/src/main/java/org/jbpm/kie/services/impl/AbstractAdvanceRuntimeDataServiceImpl.java", "diffHunk": "@@ -0,0 +1,346 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.jbpm.kie.services.impl;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import javax.persistence.EntityManager;\n+import javax.persistence.EntityManagerFactory;\n+import javax.persistence.Query;\n+\n+import org.dashbuilder.dataset.filter.CoreFunctionType;\n+import org.jbpm.kie.services.impl.model.ProcessInstanceWithVarsDesc;\n+import org.jbpm.kie.services.impl.model.UserTaskInstanceWithPotOwnerDesc;\n+import org.jbpm.services.api.query.model.QueryParam;\n+import org.jbpm.shared.services.impl.QueryManager;\n+import org.jbpm.shared.services.impl.TransactionalCommandService;\n+import org.jbpm.shared.services.impl.commands.QueryNameCommand;\n+import org.kie.api.runtime.query.QueryContext;\n+\n+import static java.util.Collections.singletonMap;\n+\n+public abstract class AbstractAdvanceRuntimeDataServiceImpl {\n+\n+    private static final String ID_LIST = \"idList\";\n+    private EntityManagerFactory emf;\n+    private TransactionalCommandService commandService;\n+\n+    public AbstractAdvanceRuntimeDataServiceImpl() {\n+        QueryManager.get().addNamedQueries(\"META-INF/Servicesorm.xml\");\n+    }\n+    public void setCommandService(TransactionalCommandService commandService) {\n+        this.commandService = commandService;\n+    }\n+\n+    public void setEmf(EntityManagerFactory emf) {\n+        this.emf = emf;\n+    }\n+\n+\n+    public List<org.jbpm.services.api.model.ProcessInstanceWithVarsDesc> queryProcessByVariables(List<QueryParam> attributes,\n+                                                                                                 List<QueryParam> variables,\n+                                                                                                 int processType,\n+                                                                                                 String varPrefix,\n+                                                                                                 QueryContext queryContext) {\n+        EntityManager entityManager = emf.createEntityManager();\n+\n+        // first step is to filter the data creating a derived tables and pivoting var - rows to columns (only the variables we are interested to filter)\n+        StringBuilder derivedTables = new StringBuilder();\n+        if (!variables.isEmpty()) {\n+            List<String> conditions = new ArrayList<>();\n+            variables.stream().forEach(expr -> conditions.add(\"(A1.variableId = :NAME_\" + expr.getColumn() + \" AND \" + computeExpression(expr, \"A1.value\", \":VALUE_\" + expr.getColumn()) + \")\\n\"));\n+            String where = String.join(\" OR \", conditions);\n+            derivedTables.append(\"INNER JOIN (\" +\n+                                 \"SELECT A1.processInstanceId \\n\" +\n+                                 \"FROM VariableInstanceLog A1 \\n\" +\n+                                 \"LEFT JOIN VariableInstanceLog A2 ON A1.processId = A2.processId AND A1.processInstanceId = A2.processInstanceId AND A1.variableInstanceId = A2.variableInstanceId AND A2.id > A1.id  \\n\" +\n+                                 \"WHERE A2.id IS NULL AND (\" + where + \") \" +\n+                                 \"GROUP BY A1.processInstanceId \" +\n+                                 \"HAVING COUNT(*) = :NUMBER_OF_VARS \" +\n+                                 \") TABLE_VAR ON TABLE_VAR.processInstanceId = pil.processInstanceId \\n\");\n+        }\n+\n+        StringBuilder globalWhere = new StringBuilder();\n+        attributes.stream().forEach(expr -> globalWhere.append(\" AND \" + computeExpression(expr, expr.getColumn(), \":ATTR_\" + expr.getColumn())));\n+\n+        String procSQLString =\n+                \" SELECT DISTINCT pil.processInstanceId \" +\n+                               \" FROM ProcessInstanceLog pil \\n \" +\n+                               derivedTables +\n+                               \" WHERE pil.processType = :processType \" + globalWhere +\n+                               \" ORDER BY pil.processInstanceId ASC \";\n+\n+        Query query = entityManager.createNativeQuery(procSQLString);\n+        variables.stream().forEach(var -> query.setParameter(\"NAME_\" + var.getColumn(), varPrefix + var.getColumn()));\n+        variables.stream().filter(e -> e.getObjectValue() != null).forEach(var -> query.setParameter(\"VALUE_\" + var.getColumn(), var.getObjectValue()));\n+        attributes.stream().filter(e -> e.getObjectValue() != null).forEach((entry) -> query.setParameter(\"ATTR_\" + entry.getColumn(), entry.getObjectValue()));\n+\n+        if (!variables.isEmpty()) {\n+            query.setParameter(\"NUMBER_OF_VARS\", variables.size());\n+        }\n+        query.setParameter(\"processType\", processType);\n+\n+        addPagination(query, queryContext);\n+        List<Number> ids = query.getResultList();\n+        if (ids.isEmpty()) {\n+            return Collections.emptyList();\n+        }\n+\n+        // now we get the information\n+\n+        List<Object[]> procRows = commandService.execute(new QueryNameCommand<List<Object[]>>(\"GetProcessInstanceByIdList\", singletonMap(ID_LIST, ids)));\n+        List<Object[]> varRows = commandService.execute(new QueryNameCommand<List<Object[]>>(\"GetVariablesByProcessInstanceIdList\", singletonMap(ID_LIST, ids)));\n+\n+        int currentVarIdx = 0;\n+        List<org.jbpm.services.api.model.ProcessInstanceWithVarsDesc> data = new ArrayList<>();\n+        for (Object[] row : procRows) {\n+            ProcessInstanceWithVarsDesc pwv = toProcessInstanceWithVarsDesc(row);\n+\n+            Map<String, Object> vars = new HashMap<>();\n+            pwv.setVariables(vars);\n+\n+            Map<String, Object> extra = new HashMap<>();\n+            pwv.setExtraData(extra);\n+            while (currentVarIdx < varRows.size() && row[0].equals(varRows.get(currentVarIdx)[0])) {\n+                String name = (String) varRows.get(currentVarIdx)[1];\n+                if (!varPrefix.isEmpty() && name.startsWith(varPrefix)) {\n+                    extra.put(name.substring(varPrefix.length()), varRows.get(currentVarIdx)[2]);\n+                } else {\n+                    vars.put(name, varRows.get(currentVarIdx)[2]);\n+                }\n+                currentVarIdx++;\n+            }\n+            data.add(pwv);\n+        }\n+\n+        entityManager.close();\n+        return data;\n+    }\n+\n+    private String computeExpression(QueryParam expr, String leftOperand, String rightOperand) {\n+        CoreFunctionType type = CoreFunctionType.getByName(expr.getOperator());\n+        switch (type) {\n+            case IS_NULL:\n+                return leftOperand + \" IS NULL \";\n+            case NOT_NULL:\n+                return leftOperand + \" IS NOT NULL \";\n+            case IN:\n+                return leftOperand + \" IN (\" + rightOperand + \") \";\n+            case NOT_IN:\n+                return leftOperand + \" NOT IN (\" + rightOperand + \") \";\n+            case EQUALS_TO:\n+                return leftOperand + \" = \" + rightOperand + \" \";\n+            case NOT_EQUALS_TO:\n+                return leftOperand + \" <> \" + rightOperand + \" \";\n+            case LIKE_TO:\n+                return leftOperand + \" LIKE \" + rightOperand + \" \";\n+            default:\n+                throw new UnsupportedOperationException(\"Queryparam: \" + expr + \" not supported\");\n+        }\n+    }\n+    private ProcessInstanceWithVarsDesc toProcessInstanceWithVarsDesc(Object[] row) {\n+        return new ProcessInstanceWithVarsDesc(((Number) row[0]).longValue(),\n+                                               (String) row[1],\n+                                               (String) row[2],\n+                                               (String) row[3],\n+                                               ((Number) row[4]).intValue(),\n+                                               (String) row[5],\n+                                               (Date) row[6],\n+                                               (String) row[7],\n+                                               (String) row[8]);\n+    }\n+\n+    private void addPagination(Query query, QueryContext context) {\n+        if (context.getCount() > 0) {\n+            query.setFirstResult(context.getOffset());\n+            query.setMaxResults(context.getCount());\n+        }\n+    }\n+\n+    public List<org.jbpm.services.api.model.UserTaskInstanceWithPotOwnerDesc> queryUserTasksByVariables(List<QueryParam> attributes,\n+                                                                                                        List<QueryParam> variables,\n+                                                                                                        List<QueryParam> processVariables,\n+                                                                                                        List<String> owners,\n+                                                                                                        int processType,\n+                                                                                                        String varPrefix,\n+                                                                                                        QueryContext queryContext) {\n+        EntityManager entityManager = emf.createEntityManager();\n+        StringBuilder globalWhere = new StringBuilder();\n+        StringBuilder derivedTables = new StringBuilder();\n+        if (!variables.isEmpty()) {\n+            List<String> conditions = new ArrayList<>();\n+            variables.stream().forEach((expr) -> conditions.add(\"(name = :V_NAME_\" + expr.getColumn() + \" AND \" + computeExpression(expr, \"value\", \":V_VALUE_\" + expr.getColumn()) + \")\\n\"));\n+            String where = String.join(\" OR \", conditions);\n+            derivedTables.append(\"INNER JOIN (\\n\" +\n+                                 \"SELECT taskId \\n\" +\n+                                 \"FROM TaskVariableImpl \\n\" +\n+                                 \"WHERE type = 0 AND (\" + where + \")\\n\" +\n+                                 \"GROUP BY taskId \\n\" +\n+                                 \"HAVING COUNT(*) = :NUMBER_OF_TASKVARS \\n\" +\n+                                 \") TABLE_TASK_VAR ON TABLE_TASK_VAR.taskId = task.id  \\n\");\n+        }\n+\n+        if (!processVariables.isEmpty()) {\n+            List<String> conditions = new ArrayList<>();\n+            processVariables.stream().forEach((expr) -> conditions.add(\"(A1.variableId = :P_NAME_\" + expr.getColumn() + \" AND \" + computeExpression(expr, \"A1.value\", \":P_VALUE_\" + expr.getColumn()) + \")\\n\"));\n+            String where = String.join(\" OR \", conditions);\n+            derivedTables.append(\"INNER JOIN (\" +\n+                                 \"SELECT A1.processInstanceId \\n\" +\n+                                 \"FROM VariableInstanceLog A1 \\n\" +\n+                                 \"LEFT JOIN VariableInstanceLog A2 ON A1.processId = A2.processId AND A1.processInstanceId = A2.processInstanceId AND A1.variableInstanceId = A2.variableInstanceId AND A2.id > A1.id  \\n\" +\n+                                 \"WHERE A2.id IS NULL AND (\" + where + \") \" +\n+                                 \"GROUP BY A1.processInstanceId \" +\n+                                 \"HAVING COUNT(*) = :NUMBER_OF_PROCVARS \" +\n+                                 \") TABLE_PROC_VAR ON TABLE_PROC_VAR.processInstanceId = pil.processInstanceId \\n\");\n+        }\n+\n+        if (!owners.isEmpty()) {\n+            derivedTables.append(\"INNER JOIN ( \\n\" +\n+                             \"           SELECT DISTINCT po.task_id \\n\" +\n+                             \"           FROM PeopleAssignments_PotOwners po \\n\" +\n+                             \"           WHERE po.entity_id IN (:owners) \\n\" +\n+                             \"           GROUP BY po.task_id \\n\" +\n+                             \"           HAVING COUNT(po.entity_id) = :num_owners \\n\" +\n+                                 \") pot ON pot.task_id = task.id \");\n+        }\n+\n+        attributes.stream().forEach((expr) -> globalWhere.append(\" AND \" + computeExpression(expr, expr.getColumn(), \":ATTR_\" + expr.getColumn())));\n+\n+        String procSQLString = \"SELECT DISTINCT task.id \" +\n+                               \" FROM Task task \" +\n+                               \" INNER JOIN ProcessInstanceLog pil ON pil.processInstanceId = task.processInstanceId \\n \" +\n+                               derivedTables +\n+                               \" WHERE  pil.processType = :processType \" + globalWhere +\n+                               \" ORDER BY task.id ASC \";\n+\n+        Query query = entityManager.createNativeQuery(procSQLString);\n+        variables.stream().forEach(var -> query.setParameter(\"V_NAME_\" + var.getColumn(), var.getColumn()));\n+        variables.stream().filter(e -> e.getObjectValue() != null).forEach((var) -> query.setParameter(\"V_VALUE_\" + var.getColumn(), var.getObjectValue()));\n+\n+        if (!variables.isEmpty()) {\n+            query.setParameter(\"NUMBER_OF_TASKVARS\", variables.size());\n+        }\n+\n+        processVariables.stream().forEach(var -> query.setParameter(\"P_NAME_\" + var.getColumn(), varPrefix + var.getColumn()));\n+        processVariables.stream().filter(e -> e.getObjectValue() != null).forEach((var) -> query.setParameter(\"P_VALUE_\" + var.getColumn(), var.getObjectValue()));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f04f50355ec285330b3467d42754a036a04b1db3"}, "originalPosition": 244}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDAzMDYxMw==", "bodyText": "done", "url": "https://github.com/kiegroup/jbpm/pull/1615#discussion_r410030613", "createdAt": "2020-04-17T07:04:55Z", "author": {"login": "elguardian"}, "path": "jbpm-services/jbpm-kie-services/src/main/java/org/jbpm/kie/services/impl/AbstractAdvanceRuntimeDataServiceImpl.java", "diffHunk": "@@ -0,0 +1,346 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.jbpm.kie.services.impl;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import javax.persistence.EntityManager;\n+import javax.persistence.EntityManagerFactory;\n+import javax.persistence.Query;\n+\n+import org.dashbuilder.dataset.filter.CoreFunctionType;\n+import org.jbpm.kie.services.impl.model.ProcessInstanceWithVarsDesc;\n+import org.jbpm.kie.services.impl.model.UserTaskInstanceWithPotOwnerDesc;\n+import org.jbpm.services.api.query.model.QueryParam;\n+import org.jbpm.shared.services.impl.QueryManager;\n+import org.jbpm.shared.services.impl.TransactionalCommandService;\n+import org.jbpm.shared.services.impl.commands.QueryNameCommand;\n+import org.kie.api.runtime.query.QueryContext;\n+\n+import static java.util.Collections.singletonMap;\n+\n+public abstract class AbstractAdvanceRuntimeDataServiceImpl {\n+\n+    private static final String ID_LIST = \"idList\";\n+    private EntityManagerFactory emf;\n+    private TransactionalCommandService commandService;\n+\n+    public AbstractAdvanceRuntimeDataServiceImpl() {\n+        QueryManager.get().addNamedQueries(\"META-INF/Servicesorm.xml\");\n+    }\n+    public void setCommandService(TransactionalCommandService commandService) {\n+        this.commandService = commandService;\n+    }\n+\n+    public void setEmf(EntityManagerFactory emf) {\n+        this.emf = emf;\n+    }\n+\n+\n+    public List<org.jbpm.services.api.model.ProcessInstanceWithVarsDesc> queryProcessByVariables(List<QueryParam> attributes,\n+                                                                                                 List<QueryParam> variables,\n+                                                                                                 int processType,\n+                                                                                                 String varPrefix,\n+                                                                                                 QueryContext queryContext) {\n+        EntityManager entityManager = emf.createEntityManager();\n+\n+        // first step is to filter the data creating a derived tables and pivoting var - rows to columns (only the variables we are interested to filter)\n+        StringBuilder derivedTables = new StringBuilder();\n+        if (!variables.isEmpty()) {\n+            List<String> conditions = new ArrayList<>();\n+            variables.stream().forEach(expr -> conditions.add(\"(A1.variableId = :NAME_\" + expr.getColumn() + \" AND \" + computeExpression(expr, \"A1.value\", \":VALUE_\" + expr.getColumn()) + \")\\n\"));\n+            String where = String.join(\" OR \", conditions);\n+            derivedTables.append(\"INNER JOIN (\" +\n+                                 \"SELECT A1.processInstanceId \\n\" +\n+                                 \"FROM VariableInstanceLog A1 \\n\" +\n+                                 \"LEFT JOIN VariableInstanceLog A2 ON A1.processId = A2.processId AND A1.processInstanceId = A2.processInstanceId AND A1.variableInstanceId = A2.variableInstanceId AND A2.id > A1.id  \\n\" +\n+                                 \"WHERE A2.id IS NULL AND (\" + where + \") \" +\n+                                 \"GROUP BY A1.processInstanceId \" +\n+                                 \"HAVING COUNT(*) = :NUMBER_OF_VARS \" +\n+                                 \") TABLE_VAR ON TABLE_VAR.processInstanceId = pil.processInstanceId \\n\");\n+        }\n+\n+        StringBuilder globalWhere = new StringBuilder();\n+        attributes.stream().forEach(expr -> globalWhere.append(\" AND \" + computeExpression(expr, expr.getColumn(), \":ATTR_\" + expr.getColumn())));\n+\n+        String procSQLString =\n+                \" SELECT DISTINCT pil.processInstanceId \" +\n+                               \" FROM ProcessInstanceLog pil \\n \" +\n+                               derivedTables +\n+                               \" WHERE pil.processType = :processType \" + globalWhere +\n+                               \" ORDER BY pil.processInstanceId ASC \";\n+\n+        Query query = entityManager.createNativeQuery(procSQLString);\n+        variables.stream().forEach(var -> query.setParameter(\"NAME_\" + var.getColumn(), varPrefix + var.getColumn()));\n+        variables.stream().filter(e -> e.getObjectValue() != null).forEach(var -> query.setParameter(\"VALUE_\" + var.getColumn(), var.getObjectValue()));\n+        attributes.stream().filter(e -> e.getObjectValue() != null).forEach((entry) -> query.setParameter(\"ATTR_\" + entry.getColumn(), entry.getObjectValue()));\n+\n+        if (!variables.isEmpty()) {\n+            query.setParameter(\"NUMBER_OF_VARS\", variables.size());\n+        }\n+        query.setParameter(\"processType\", processType);\n+\n+        addPagination(query, queryContext);\n+        List<Number> ids = query.getResultList();\n+        if (ids.isEmpty()) {\n+            return Collections.emptyList();\n+        }\n+\n+        // now we get the information\n+\n+        List<Object[]> procRows = commandService.execute(new QueryNameCommand<List<Object[]>>(\"GetProcessInstanceByIdList\", singletonMap(ID_LIST, ids)));\n+        List<Object[]> varRows = commandService.execute(new QueryNameCommand<List<Object[]>>(\"GetVariablesByProcessInstanceIdList\", singletonMap(ID_LIST, ids)));\n+\n+        int currentVarIdx = 0;\n+        List<org.jbpm.services.api.model.ProcessInstanceWithVarsDesc> data = new ArrayList<>();\n+        for (Object[] row : procRows) {\n+            ProcessInstanceWithVarsDesc pwv = toProcessInstanceWithVarsDesc(row);\n+\n+            Map<String, Object> vars = new HashMap<>();\n+            pwv.setVariables(vars);\n+\n+            Map<String, Object> extra = new HashMap<>();\n+            pwv.setExtraData(extra);\n+            while (currentVarIdx < varRows.size() && row[0].equals(varRows.get(currentVarIdx)[0])) {\n+                String name = (String) varRows.get(currentVarIdx)[1];\n+                if (!varPrefix.isEmpty() && name.startsWith(varPrefix)) {\n+                    extra.put(name.substring(varPrefix.length()), varRows.get(currentVarIdx)[2]);\n+                } else {\n+                    vars.put(name, varRows.get(currentVarIdx)[2]);\n+                }\n+                currentVarIdx++;\n+            }\n+            data.add(pwv);\n+        }\n+\n+        entityManager.close();\n+        return data;\n+    }\n+\n+    private String computeExpression(QueryParam expr, String leftOperand, String rightOperand) {\n+        CoreFunctionType type = CoreFunctionType.getByName(expr.getOperator());\n+        switch (type) {\n+            case IS_NULL:\n+                return leftOperand + \" IS NULL \";\n+            case NOT_NULL:\n+                return leftOperand + \" IS NOT NULL \";\n+            case IN:\n+                return leftOperand + \" IN (\" + rightOperand + \") \";\n+            case NOT_IN:\n+                return leftOperand + \" NOT IN (\" + rightOperand + \") \";\n+            case EQUALS_TO:\n+                return leftOperand + \" = \" + rightOperand + \" \";\n+            case NOT_EQUALS_TO:\n+                return leftOperand + \" <> \" + rightOperand + \" \";\n+            case LIKE_TO:\n+                return leftOperand + \" LIKE \" + rightOperand + \" \";\n+            default:\n+                throw new UnsupportedOperationException(\"Queryparam: \" + expr + \" not supported\");\n+        }\n+    }\n+    private ProcessInstanceWithVarsDesc toProcessInstanceWithVarsDesc(Object[] row) {\n+        return new ProcessInstanceWithVarsDesc(((Number) row[0]).longValue(),\n+                                               (String) row[1],\n+                                               (String) row[2],\n+                                               (String) row[3],\n+                                               ((Number) row[4]).intValue(),\n+                                               (String) row[5],\n+                                               (Date) row[6],\n+                                               (String) row[7],\n+                                               (String) row[8]);\n+    }\n+\n+    private void addPagination(Query query, QueryContext context) {\n+        if (context.getCount() > 0) {\n+            query.setFirstResult(context.getOffset());\n+            query.setMaxResults(context.getCount());\n+        }\n+    }\n+\n+    public List<org.jbpm.services.api.model.UserTaskInstanceWithPotOwnerDesc> queryUserTasksByVariables(List<QueryParam> attributes,\n+                                                                                                        List<QueryParam> variables,\n+                                                                                                        List<QueryParam> processVariables,\n+                                                                                                        List<String> owners,\n+                                                                                                        int processType,\n+                                                                                                        String varPrefix,\n+                                                                                                        QueryContext queryContext) {\n+        EntityManager entityManager = emf.createEntityManager();\n+        StringBuilder globalWhere = new StringBuilder();\n+        StringBuilder derivedTables = new StringBuilder();\n+        if (!variables.isEmpty()) {\n+            List<String> conditions = new ArrayList<>();\n+            variables.stream().forEach((expr) -> conditions.add(\"(name = :V_NAME_\" + expr.getColumn() + \" AND \" + computeExpression(expr, \"value\", \":V_VALUE_\" + expr.getColumn()) + \")\\n\"));\n+            String where = String.join(\" OR \", conditions);\n+            derivedTables.append(\"INNER JOIN (\\n\" +\n+                                 \"SELECT taskId \\n\" +\n+                                 \"FROM TaskVariableImpl \\n\" +\n+                                 \"WHERE type = 0 AND (\" + where + \")\\n\" +\n+                                 \"GROUP BY taskId \\n\" +\n+                                 \"HAVING COUNT(*) = :NUMBER_OF_TASKVARS \\n\" +\n+                                 \") TABLE_TASK_VAR ON TABLE_TASK_VAR.taskId = task.id  \\n\");\n+        }\n+\n+        if (!processVariables.isEmpty()) {\n+            List<String> conditions = new ArrayList<>();\n+            processVariables.stream().forEach((expr) -> conditions.add(\"(A1.variableId = :P_NAME_\" + expr.getColumn() + \" AND \" + computeExpression(expr, \"A1.value\", \":P_VALUE_\" + expr.getColumn()) + \")\\n\"));\n+            String where = String.join(\" OR \", conditions);\n+            derivedTables.append(\"INNER JOIN (\" +\n+                                 \"SELECT A1.processInstanceId \\n\" +\n+                                 \"FROM VariableInstanceLog A1 \\n\" +\n+                                 \"LEFT JOIN VariableInstanceLog A2 ON A1.processId = A2.processId AND A1.processInstanceId = A2.processInstanceId AND A1.variableInstanceId = A2.variableInstanceId AND A2.id > A1.id  \\n\" +\n+                                 \"WHERE A2.id IS NULL AND (\" + where + \") \" +\n+                                 \"GROUP BY A1.processInstanceId \" +\n+                                 \"HAVING COUNT(*) = :NUMBER_OF_PROCVARS \" +\n+                                 \") TABLE_PROC_VAR ON TABLE_PROC_VAR.processInstanceId = pil.processInstanceId \\n\");\n+        }\n+\n+        if (!owners.isEmpty()) {\n+            derivedTables.append(\"INNER JOIN ( \\n\" +\n+                             \"           SELECT DISTINCT po.task_id \\n\" +\n+                             \"           FROM PeopleAssignments_PotOwners po \\n\" +\n+                             \"           WHERE po.entity_id IN (:owners) \\n\" +\n+                             \"           GROUP BY po.task_id \\n\" +\n+                             \"           HAVING COUNT(po.entity_id) = :num_owners \\n\" +\n+                                 \") pot ON pot.task_id = task.id \");\n+        }\n+\n+        attributes.stream().forEach((expr) -> globalWhere.append(\" AND \" + computeExpression(expr, expr.getColumn(), \":ATTR_\" + expr.getColumn())));\n+\n+        String procSQLString = \"SELECT DISTINCT task.id \" +\n+                               \" FROM Task task \" +\n+                               \" INNER JOIN ProcessInstanceLog pil ON pil.processInstanceId = task.processInstanceId \\n \" +\n+                               derivedTables +\n+                               \" WHERE  pil.processType = :processType \" + globalWhere +\n+                               \" ORDER BY task.id ASC \";\n+\n+        Query query = entityManager.createNativeQuery(procSQLString);\n+        variables.stream().forEach(var -> query.setParameter(\"V_NAME_\" + var.getColumn(), var.getColumn()));\n+        variables.stream().filter(e -> e.getObjectValue() != null).forEach((var) -> query.setParameter(\"V_VALUE_\" + var.getColumn(), var.getObjectValue()));\n+\n+        if (!variables.isEmpty()) {\n+            query.setParameter(\"NUMBER_OF_TASKVARS\", variables.size());\n+        }\n+\n+        processVariables.stream().forEach(var -> query.setParameter(\"P_NAME_\" + var.getColumn(), varPrefix + var.getColumn()));\n+        processVariables.stream().filter(e -> e.getObjectValue() != null).forEach((var) -> query.setParameter(\"P_VALUE_\" + var.getColumn(), var.getObjectValue()));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODY4OTQ2NA=="}, "originalCommit": {"oid": "f04f50355ec285330b3467d42754a036a04b1db3"}, "originalPosition": 244}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUzNzM1OTkyOnYy", "diffSide": "RIGHT", "path": "jbpm-services/jbpm-services-api/src/main/java/org/jbpm/services/api/AdvanceRuntimeDataService.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNVQwOTowNToyMFrOGFwkrg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xN1QwNzowNjo1MVrOGHCVqw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODY5MTg4Ng==", "bodyText": "Would it not be better to have an Enum for these constants?", "url": "https://github.com/kiegroup/jbpm/pull/1615#discussion_r408691886", "createdAt": "2020-04-15T09:05:20Z", "author": {"login": "afalhambra"}, "path": "jbpm-services/jbpm-services-api/src/main/java/org/jbpm/services/api/AdvanceRuntimeDataService.java", "diffHunk": "@@ -0,0 +1,39 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.jbpm.services.api;\n+\n+import java.util.List;\n+\n+import org.jbpm.services.api.model.ProcessInstanceWithVarsDesc;\n+import org.jbpm.services.api.model.UserTaskInstanceWithPotOwnerDesc;\n+import org.jbpm.services.api.query.model.QueryParam;\n+import org.kie.api.runtime.query.QueryContext;\n+\n+public interface AdvanceRuntimeDataService {\n+\n+    public static String TASK_ATTR_NAME = \"TASK_NAME\";\n+    public static String TASK_ATTR_OWNER = \"TASK_OWNER\";\n+    public static String PROCESS_ATTR_INSTANCE_ID = \"PROCESS_INSTANCE_ID\";\n+    public static String PROCESS_ATTR_CORRELATION_KEY = \"PROCESS_CORRELATION_KEY\";\n+    public static String PROCESS_ATTR_DEFINITION_ID = \"PROCESS_DEFINITION_ID\";\n+    public static String PROCESS_ATTR_DEPLOYMENT_ID = \"PROCESS_DEPLOYMENT_ID\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f04f50355ec285330b3467d42754a036a04b1db3"}, "originalPosition": 33}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDAzMTUzMQ==", "bodyText": "keep in mind that this comes for rest service. It would require a conversion causing more problems than anything. Also this is consistent with other approach in the app. Look into QueryParameterIdentifiers.", "url": "https://github.com/kiegroup/jbpm/pull/1615#discussion_r410031531", "createdAt": "2020-04-17T07:06:51Z", "author": {"login": "elguardian"}, "path": "jbpm-services/jbpm-services-api/src/main/java/org/jbpm/services/api/AdvanceRuntimeDataService.java", "diffHunk": "@@ -0,0 +1,39 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.jbpm.services.api;\n+\n+import java.util.List;\n+\n+import org.jbpm.services.api.model.ProcessInstanceWithVarsDesc;\n+import org.jbpm.services.api.model.UserTaskInstanceWithPotOwnerDesc;\n+import org.jbpm.services.api.query.model.QueryParam;\n+import org.kie.api.runtime.query.QueryContext;\n+\n+public interface AdvanceRuntimeDataService {\n+\n+    public static String TASK_ATTR_NAME = \"TASK_NAME\";\n+    public static String TASK_ATTR_OWNER = \"TASK_OWNER\";\n+    public static String PROCESS_ATTR_INSTANCE_ID = \"PROCESS_INSTANCE_ID\";\n+    public static String PROCESS_ATTR_CORRELATION_KEY = \"PROCESS_CORRELATION_KEY\";\n+    public static String PROCESS_ATTR_DEFINITION_ID = \"PROCESS_DEFINITION_ID\";\n+    public static String PROCESS_ATTR_DEPLOYMENT_ID = \"PROCESS_DEPLOYMENT_ID\";", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODY5MTg4Ng=="}, "originalCommit": {"oid": "f04f50355ec285330b3467d42754a036a04b1db3"}, "originalPosition": 33}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUzNzM2MTMxOnYy", "diffSide": "RIGHT", "path": "jbpm-case-mgmt/jbpm-case-mgmt-api/src/main/java/org/jbpm/casemgmt/api/AdvanceCaseRuntimeDataService.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNVQwOTowNTo0MlrOGFwlkw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xN1QwNzowNjo0NlrOGHCVfw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODY5MjExNQ==", "bodyText": "Would it not be better to have an Enum for these constants?", "url": "https://github.com/kiegroup/jbpm/pull/1615#discussion_r408692115", "createdAt": "2020-04-15T09:05:42Z", "author": {"login": "afalhambra"}, "path": "jbpm-case-mgmt/jbpm-case-mgmt-api/src/main/java/org/jbpm/casemgmt/api/AdvanceCaseRuntimeDataService.java", "diffHunk": "@@ -0,0 +1,45 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.jbpm.casemgmt.api;\n+\n+import java.util.List;\n+\n+import org.jbpm.services.api.model.ProcessInstanceWithVarsDesc;\n+import org.jbpm.services.api.model.UserTaskInstanceWithPotOwnerDesc;\n+import org.jbpm.services.api.query.model.QueryParam;\n+import org.kie.api.runtime.query.QueryContext;\n+\n+public interface AdvanceCaseRuntimeDataService {\n+\n+    public static String TASK_ATTR_NAME = \"TASK_NAME\";\n+    public static String TASK_ATTR_OWNER = \"TASK_OWNER\";\n+    public static String CASE_ATTR_INSTANCE_ID = \"PROCESS_INSTANCE_ID\";\n+    public static String CASE_ATTR_CORRELATION_KEY = \"PROCESS_CORRELATION_KEY\";\n+    public static String CASE_ATTR_DEFINITION_ID = \"PROCESS_DEFINITION_ID\";\n+    public static String CASE_ATTR_DEPLOYMENT_ID = \"PROCESS_DEPLOYMENT_ID\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f04f50355ec285330b3467d42754a036a04b1db3"}, "originalPosition": 33}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDAzMTQ4Nw==", "bodyText": "keep in mind that this comes for rest service. It would require a conversion causing more problems than anything. Also this is consistent with other approach in the app. Look into QueryParameterIdentifiers.", "url": "https://github.com/kiegroup/jbpm/pull/1615#discussion_r410031487", "createdAt": "2020-04-17T07:06:46Z", "author": {"login": "elguardian"}, "path": "jbpm-case-mgmt/jbpm-case-mgmt-api/src/main/java/org/jbpm/casemgmt/api/AdvanceCaseRuntimeDataService.java", "diffHunk": "@@ -0,0 +1,45 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.jbpm.casemgmt.api;\n+\n+import java.util.List;\n+\n+import org.jbpm.services.api.model.ProcessInstanceWithVarsDesc;\n+import org.jbpm.services.api.model.UserTaskInstanceWithPotOwnerDesc;\n+import org.jbpm.services.api.query.model.QueryParam;\n+import org.kie.api.runtime.query.QueryContext;\n+\n+public interface AdvanceCaseRuntimeDataService {\n+\n+    public static String TASK_ATTR_NAME = \"TASK_NAME\";\n+    public static String TASK_ATTR_OWNER = \"TASK_OWNER\";\n+    public static String CASE_ATTR_INSTANCE_ID = \"PROCESS_INSTANCE_ID\";\n+    public static String CASE_ATTR_CORRELATION_KEY = \"PROCESS_CORRELATION_KEY\";\n+    public static String CASE_ATTR_DEFINITION_ID = \"PROCESS_DEFINITION_ID\";\n+    public static String CASE_ATTR_DEPLOYMENT_ID = \"PROCESS_DEPLOYMENT_ID\";", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODY5MjExNQ=="}, "originalCommit": {"oid": "f04f50355ec285330b3467d42754a036a04b1db3"}, "originalPosition": 33}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1840, "cost": 1, "resetAt": "2021-11-12T20:28:25Z"}}}