{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzU5MjUxNjY1", "number": 1845, "title": "Adding LICENSE/NOTICE for the VisualStudio Code extension for Java", "bodyText": "We have a sever for the language server protocol that supports Java editing, and there is also a VisualStudio Code extension wrapping the server so that it can be installed into the VS Code. This patch tries to add LICENSE/NOTICE for the binary of the extension, so that is a (hopefully) a valid convenience binary. I'd like to do a (preview) release of the extension sometime soon.\nSome enhancements are done to the CreateLicenseSummary task, so that the files can be generated conveniently. The \"Prepare Bundles\" tool (that packs npm packages and autodetects licenses, etc.) from #1692 is also enhanced and generalized, and is used to generate the LICENSE/NOTICE entries for the included npm packages.", "createdAt": "2020-01-04T22:12:34Z", "url": "https://github.com/apache/netbeans/pull/1845", "merged": true, "mergeCommit": {"oid": "381df1f80a82006adf29d778f2c30052348d59ed"}, "closed": true, "closedAt": "2020-01-14T20:51:50Z", "author": {"login": "jlahoda"}, "timelineItems": {"totalCount": 14, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABb23aNpgH2gAyMzU5MjUxNjY1OjA2ODY0MzdkODY5OTcyOTQ5MWMyNWE0MTEwMWMyN2I4ZWE1NDhjYTM=", "endCursor": "Y3Vyc29yOnYyOpPPAAABb6V96VAFqTM0Mjc3NjM4NQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "0686437d8699729491c25a41101c27b8ea548ca3", "author": {"user": {"login": "jlahoda", "name": "Jan Lahoda"}}, "url": "https://github.com/apache/netbeans/commit/0686437d8699729491c25a41101c27b8ea548ca3", "committedDate": "2020-01-04T00:00:15Z", "message": "Trying to improve the state of the VS Code extension to make it releasable."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b74b479fe0fe0c1e4c3f642f0774de7f02daee7a", "author": {"user": {"login": "jlahoda", "name": "Jan Lahoda"}}, "url": "https://github.com/apache/netbeans/commit/b74b479fe0fe0c1e4c3f642f0774de7f02daee7a", "committedDate": "2020-01-04T07:21:28Z", "message": "Cluster config java should be enough for now."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9be74677add580e5759ab9ce79058ad4401da350", "author": {"user": {"login": "jlahoda", "name": "Jan Lahoda"}}, "url": "https://github.com/apache/netbeans/commit/9be74677add580e5759ab9ce79058ad4401da350", "committedDate": "2020-01-04T09:58:03Z", "message": "Doing complete build in travis for now."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "02d378f3919ae5f48313769f1a944de366778a65", "author": {"user": {"login": "jlahoda", "name": "Jan Lahoda"}}, "url": "https://github.com/apache/netbeans/commit/02d378f3919ae5f48313769f1a944de366778a65", "committedDate": "2020-01-04T11:28:10Z", "message": "Correcting license files."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8ed16dfa4d58ef3ffac8316f402c59b1375389e4", "author": {"user": {"login": "jlahoda", "name": "Jan Lahoda"}}, "url": "https://github.com/apache/netbeans/commit/8ed16dfa4d58ef3ffac8316f402c59b1375389e4", "committedDate": "2020-01-04T16:56:05Z", "message": "Cleanup."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0907de766e319e629f057bd9b06080a5a8842b4e", "author": {"user": {"login": "jlahoda", "name": "Jan Lahoda"}}, "url": "https://github.com/apache/netbeans/commit/0907de766e319e629f057bd9b06080a5a8842b4e", "committedDate": "2020-01-04T18:51:38Z", "message": "Adding forgotten files."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b01605e4dce95e3adac0e1b36129d4ccc348a6bf", "author": {"user": {"login": "jlahoda", "name": "Jan Lahoda"}}, "url": "https://github.com/apache/netbeans/commit/b01605e4dce95e3adac0e1b36129d4ccc348a6bf", "committedDate": "2020-01-04T20:25:56Z", "message": "Correcting paths to license files."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c5486a67142aa30264b80b5192a884d084cfac1a", "author": {"user": {"login": "jlahoda", "name": "Jan Lahoda"}}, "url": "https://github.com/apache/netbeans/commit/c5486a67142aa30264b80b5192a884d084cfac1a", "committedDate": "2020-01-04T22:05:07Z", "message": "Removing unnecessary git-ignored files."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8d3d1a3928a6ab4c6d817e592179dbfcf361bd93", "author": {"user": {"login": "jlahoda", "name": "Jan Lahoda"}}, "url": "https://github.com/apache/netbeans/commit/8d3d1a3928a6ab4c6d817e592179dbfcf361bd93", "committedDate": "2020-01-04T22:09:37Z", "message": "Changing the extension version to 0.0.1"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzM4NDA2Mjcw", "url": "https://github.com/apache/netbeans/pull/1845#pullrequestreview-338406270", "createdAt": "2020-01-05T15:16:24Z", "commit": {"oid": "8d3d1a3928a6ab4c6d817e592179dbfcf361bd93"}, "state": "COMMENTED", "comments": {"totalCount": 9, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0wNVQxNToxNjoyNFrOFaR1Cg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0wNVQxNTo0MzowOVrOFaR6uw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MzA5OTQwMg==", "bodyText": "Shouldn't package be enough? exec:java should use the build package from target, not the one from the local repository.", "url": "https://github.com/apache/netbeans/pull/1845#discussion_r363099402", "createdAt": "2020-01-05T15:16:24Z", "author": {"login": "matthiasblaesing"}, "path": "java/java.lsp.server/build.xml", "diffHunk": "@@ -51,4 +51,65 @@\n     <target name=\"clean\" depends=\"projectized.clean\">\n         <delete dir=\"${lsp.build.dir}\" />\n     </target>\n+    <target name=\"build-vscode-ext\" depends=\"build-lsp-server\" description=\"Build the Visual Studio Code extension.\">\n+        <exec executable=\"npm\" failonerror=\"true\" dir=\"vscode\">\n+            <arg value=\"install\" />\n+        </exec>\n+\n+        <exec executable=\"npm\" failonerror=\"true\" dir=\"vscode\">\n+            <arg value=\"run\" />\n+            <arg value=\"compile\" />\n+        </exec>\n+\n+        <delete dir=\"${build.dir}/vscode\" />\n+        <exec executable=\"cp\" failonerror=\"true\">\n+            <arg value=\"-r\" />\n+            <arg value=\"vscode/\" />\n+            <arg value=\"${build.dir}/\" />\n+        </exec>\n+\n+        <delete dir=\"${build.dir}/bundles\" />\n+        <mkdir dir=\"${build.dir}/bundles/package\" />\n+        <copy file=\"vscode/package.json\" todir=\"${build.dir}/bundles/package\" />\n+\n+        <exec executable=\"mvn\" failonerror=\"true\" dir=\"${nb_all}/nbbuild/misc/prepare-bundles\">\n+            <arg value=\"install\" />", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8d3d1a3928a6ab4c6d817e592179dbfcf361bd93"}, "originalPosition": 26}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MzA5OTgyMg==", "bodyText": "Just a thought: Would it be easier to use a (list of) case insenstive regular expression(s) to match this? I would bet there are \"LICENSE-ALv2.txt\", \"LICENSE-EPL.txt\" and so on out there and the special case for MIT will only catch the most probable one.", "url": "https://github.com/apache/netbeans/pull/1845#discussion_r363099822", "createdAt": "2020-01-05T15:23:49Z", "author": {"login": "matthiasblaesing"}, "path": "nbbuild/misc/prepare-bundles/src/main/java/org/netbeans/prepare/bundles/PrepareBundles.java", "diffHunk": "@@ -0,0 +1,295 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.netbeans.prepare.bundles;\n+\n+import com.google.gson.Gson;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.io.OutputStream;\n+import java.io.OutputStreamWriter;\n+import java.io.Reader;\n+import java.io.UncheckedIOException;\n+import java.io.Writer;\n+import java.net.URL;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.DirectoryStream;\n+import java.nio.file.FileVisitOption;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.security.MessageDigest;\n+import java.security.NoSuchAlgorithmException;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.jar.JarOutputStream;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+import java.util.zip.ZipEntry;\n+\n+/**\n+ * Prepare bundles and license files for a group of node modules.\n+ */\n+public class PrepareBundles {\n+\n+    private static final String[] LICENSE_FILE_NAMES = {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8d3d1a3928a6ab4c6d817e592179dbfcf361bd93"}, "originalPosition": 55}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MzA5OTkxMg==", "bodyText": "I would hardcode this to \\n. That way it is not platform dependent and most editor deal perfectly fine with unix line endings.", "url": "https://github.com/apache/netbeans/pull/1845#discussion_r363099912", "createdAt": "2020-01-05T15:25:30Z", "author": {"login": "matthiasblaesing"}, "path": "nbbuild/misc/prepare-bundles/src/main/java/org/netbeans/prepare/bundles/PrepareBundles.java", "diffHunk": "@@ -0,0 +1,295 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.netbeans.prepare.bundles;\n+\n+import com.google.gson.Gson;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.io.OutputStream;\n+import java.io.OutputStreamWriter;\n+import java.io.Reader;\n+import java.io.UncheckedIOException;\n+import java.io.Writer;\n+import java.net.URL;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.DirectoryStream;\n+import java.nio.file.FileVisitOption;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.security.MessageDigest;\n+import java.security.NoSuchAlgorithmException;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.jar.JarOutputStream;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+import java.util.zip.ZipEntry;\n+\n+/**\n+ * Prepare bundles and license files for a group of node modules.\n+ */\n+public class PrepareBundles {\n+\n+    private static final String[] LICENSE_FILE_NAMES = {\n+        \"license\",\n+        \"License\",\n+        \"LICENSE\",\n+        \"LICENSE.txt\",\n+        \"LICENSE-MIT.txt\",\n+        \"license.txt\",\n+        \"License.txt\",\n+        \"LICENSE.md\",\n+        \"license.md\"\n+    };\n+    private static final String nl = System.getProperty(\"line.separator\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8d3d1a3928a6ab4c6d817e592179dbfcf361bd93"}, "originalPosition": 66}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MzEwMDQyMw==", "bodyText": "I understand that this allows supplying license information for packages, that can't be correctly parsed. Looks ok, though I see potential problems in the future, if we get into the habit of bundling \"many\" JS libraries.\nI would consider removing the null check in 132. That way invalid license info could be overriden.", "url": "https://github.com/apache/netbeans/pull/1845#discussion_r363100423", "createdAt": "2020-01-05T15:34:59Z", "author": {"login": "matthiasblaesing"}, "path": "nbbuild/misc/prepare-bundles/src/main/java/org/netbeans/prepare/bundles/PrepareBundles.java", "diffHunk": "@@ -0,0 +1,295 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.netbeans.prepare.bundles;\n+\n+import com.google.gson.Gson;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.io.OutputStream;\n+import java.io.OutputStreamWriter;\n+import java.io.Reader;\n+import java.io.UncheckedIOException;\n+import java.io.Writer;\n+import java.net.URL;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.DirectoryStream;\n+import java.nio.file.FileVisitOption;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.security.MessageDigest;\n+import java.security.NoSuchAlgorithmException;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.jar.JarOutputStream;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+import java.util.zip.ZipEntry;\n+\n+/**\n+ * Prepare bundles and license files for a group of node modules.\n+ */\n+public class PrepareBundles {\n+\n+    private static final String[] LICENSE_FILE_NAMES = {\n+        \"license\",\n+        \"License\",\n+        \"LICENSE\",\n+        \"LICENSE.txt\",\n+        \"LICENSE-MIT.txt\",\n+        \"license.txt\",\n+        \"License.txt\",\n+        \"LICENSE.md\",\n+        \"license.md\"\n+    };\n+    private static final String nl = System.getProperty(\"line.separator\");\n+\n+    public static void main(String... args) throws IOException, InterruptedException, NoSuchAlgorithmException {\n+        if (args.length != 2) {\n+            throw new IllegalStateException(\"Requires two parameters: location of the bundles directory, and the location of the NetBeans checkout.\");\n+        }\n+\n+        Path targetDir = Paths.get(args[0]);\n+        Path packagesDir = targetDir.resolve(\"package\");\n+        new ProcessBuilder(\"npm\", \"install\").directory(packagesDir.toFile()).inheritIO().start().waitFor();\n+        Path bundlesDir = targetDir.resolve(\"bundles\");\n+        Files.createDirectories(bundlesDir);\n+        try (DirectoryStream<Path> ds = Files.newDirectoryStream(bundlesDir)) {\n+            for (Path bundle : ds) {\n+                Files.delete(bundle);\n+            }\n+        }\n+\n+        Path licensesDir = targetDir.resolve(\"licenses\");\n+\n+        Files.createDirectories(licensesDir);\n+        try (DirectoryStream<Path> ds = Files.newDirectoryStream(licensesDir)) {\n+            for (Path license : ds) {\n+                Files.delete(license);\n+            }\n+        }\n+\n+        Path externalDir = targetDir.resolve(\"external\");\n+        Files.createDirectories(externalDir);\n+        try (DirectoryStream<Path> ds = Files.newDirectoryStream(externalDir)) {\n+            for (Path external : ds) {\n+                Files.delete(external);\n+            }\n+        }\n+\n+        Map<List<String>, LicenseUses> tokens2Projects = new HashMap<>();\n+        Map<String, LicenseDescription> project2License = new HashMap<>();\n+        Map<String, String> project2Notice = new HashMap<>();\n+        try (DirectoryStream<Path> ds = Files.newDirectoryStream(packagesDir.resolve(\"node_modules\"));\n+             Writer binariesList = new OutputStreamWriter(Files.newOutputStream(bundlesDir.resolve(\"binaries-list\")), \"UTF-8\")) {\n+            for (Path module : ds) {\n+                if (\".bin\".equals(module.getFileName().toString())) continue;\n+                if (\"@types\".equals(module.getFileName().toString())) continue;\n+                Path packageJson = module.resolve(\"package.json\");\n+\n+                if (!Files.isReadable(packageJson)) {\n+                    throw new IllegalStateException(\"Cannot find package.json for: \" + module.getFileName());\n+                }\n+\n+                String packageJsonText = readString(packageJson);\n+                Map<String, Object> packageJsonData = new Gson().fromJson(packageJsonText, HashMap.class);\n+                String name = (String) packageJsonData.get(\"name\");\n+                String version = (String) packageJsonData.get(\"version\");\n+                String description = (String) packageJsonData.get(\"description\");\n+                String homepage = (String) packageJsonData.get(\"homepage\");\n+                String licenseKey = (String) packageJsonData.get(\"license\");\n+\n+                String licenseText = null;\n+\n+                for (String l : LICENSE_FILE_NAMES) {\n+                    if (Files.isReadable(module.resolve(l))) {\n+                        licenseText = readString(module.resolve(l));\n+                        break;\n+                    }\n+                }\n+\n+                if (licenseText == null) {\n+                    String hardcodedLicenseName = name + \"-\" + version + \"-license\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8d3d1a3928a6ab4c6d817e592179dbfcf361bd93"}, "originalPosition": 133}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MzEwMDYwMA==", "bodyText": "This seems to be problematic. One sample I found from a quick look at the generated NOTICE file was this:\n/*! *****************************************************************************\nCopyright (c) Microsoft Corporation. All rights reserved. \nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\nthis file except in compliance with the License. You may obtain a copy of the\nLicense at http://www.apache.org/licenses/LICENSE-2.0  \n \nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE, \nMERCHANTABLITY OR NON-INFRINGEMENT. \n \nSee the Apache Version 2.0 License for specific language governing permissions\nand limitations under the License.\n***************************************************************************** */\n\nThe author did not understand the purpose of the NOTICE file and if we'd integrate this file by hand, I'd request it to be completely removed, as nothing of the text has a place in the NOTICE file.\nI admit though, that it is difficult to detect and override. Maybe notices should only done by hand?", "url": "https://github.com/apache/netbeans/pull/1845#discussion_r363100600", "createdAt": "2020-01-05T15:38:03Z", "author": {"login": "matthiasblaesing"}, "path": "nbbuild/misc/prepare-bundles/src/main/java/org/netbeans/prepare/bundles/PrepareBundles.java", "diffHunk": "@@ -0,0 +1,295 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.netbeans.prepare.bundles;\n+\n+import com.google.gson.Gson;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.io.OutputStream;\n+import java.io.OutputStreamWriter;\n+import java.io.Reader;\n+import java.io.UncheckedIOException;\n+import java.io.Writer;\n+import java.net.URL;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.DirectoryStream;\n+import java.nio.file.FileVisitOption;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.security.MessageDigest;\n+import java.security.NoSuchAlgorithmException;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.jar.JarOutputStream;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+import java.util.zip.ZipEntry;\n+\n+/**\n+ * Prepare bundles and license files for a group of node modules.\n+ */\n+public class PrepareBundles {\n+\n+    private static final String[] LICENSE_FILE_NAMES = {\n+        \"license\",\n+        \"License\",\n+        \"LICENSE\",\n+        \"LICENSE.txt\",\n+        \"LICENSE-MIT.txt\",\n+        \"license.txt\",\n+        \"License.txt\",\n+        \"LICENSE.md\",\n+        \"license.md\"\n+    };\n+    private static final String nl = System.getProperty(\"line.separator\");\n+\n+    public static void main(String... args) throws IOException, InterruptedException, NoSuchAlgorithmException {\n+        if (args.length != 2) {\n+            throw new IllegalStateException(\"Requires two parameters: location of the bundles directory, and the location of the NetBeans checkout.\");\n+        }\n+\n+        Path targetDir = Paths.get(args[0]);\n+        Path packagesDir = targetDir.resolve(\"package\");\n+        new ProcessBuilder(\"npm\", \"install\").directory(packagesDir.toFile()).inheritIO().start().waitFor();\n+        Path bundlesDir = targetDir.resolve(\"bundles\");\n+        Files.createDirectories(bundlesDir);\n+        try (DirectoryStream<Path> ds = Files.newDirectoryStream(bundlesDir)) {\n+            for (Path bundle : ds) {\n+                Files.delete(bundle);\n+            }\n+        }\n+\n+        Path licensesDir = targetDir.resolve(\"licenses\");\n+\n+        Files.createDirectories(licensesDir);\n+        try (DirectoryStream<Path> ds = Files.newDirectoryStream(licensesDir)) {\n+            for (Path license : ds) {\n+                Files.delete(license);\n+            }\n+        }\n+\n+        Path externalDir = targetDir.resolve(\"external\");\n+        Files.createDirectories(externalDir);\n+        try (DirectoryStream<Path> ds = Files.newDirectoryStream(externalDir)) {\n+            for (Path external : ds) {\n+                Files.delete(external);\n+            }\n+        }\n+\n+        Map<List<String>, LicenseUses> tokens2Projects = new HashMap<>();\n+        Map<String, LicenseDescription> project2License = new HashMap<>();\n+        Map<String, String> project2Notice = new HashMap<>();\n+        try (DirectoryStream<Path> ds = Files.newDirectoryStream(packagesDir.resolve(\"node_modules\"));\n+             Writer binariesList = new OutputStreamWriter(Files.newOutputStream(bundlesDir.resolve(\"binaries-list\")), \"UTF-8\")) {\n+            for (Path module : ds) {\n+                if (\".bin\".equals(module.getFileName().toString())) continue;\n+                if (\"@types\".equals(module.getFileName().toString())) continue;\n+                Path packageJson = module.resolve(\"package.json\");\n+\n+                if (!Files.isReadable(packageJson)) {\n+                    throw new IllegalStateException(\"Cannot find package.json for: \" + module.getFileName());\n+                }\n+\n+                String packageJsonText = readString(packageJson);\n+                Map<String, Object> packageJsonData = new Gson().fromJson(packageJsonText, HashMap.class);\n+                String name = (String) packageJsonData.get(\"name\");\n+                String version = (String) packageJsonData.get(\"version\");\n+                String description = (String) packageJsonData.get(\"description\");\n+                String homepage = (String) packageJsonData.get(\"homepage\");\n+                String licenseKey = (String) packageJsonData.get(\"license\");\n+\n+                String licenseText = null;\n+\n+                for (String l : LICENSE_FILE_NAMES) {\n+                    if (Files.isReadable(module.resolve(l))) {\n+                        licenseText = readString(module.resolve(l));\n+                        break;\n+                    }\n+                }\n+\n+                if (licenseText == null) {\n+                    String hardcodedLicenseName = name + \"-\" + version + \"-license\";\n+                    URL hardcodedLicense = PrepareBundles.class.getResource(hardcodedLicenseName);\n+                    if (hardcodedLicense == null ){\n+                        throw new IllegalStateException(\"Cannot find license for: \" + module.getFileName());\n+                    }\n+                    StringBuilder licenseTextBuffer = new StringBuilder();\n+                    try (InputStream in = hardcodedLicense.openStream();\n+                         Reader r = new InputStreamReader(in, StandardCharsets.UTF_8)) {\n+                        int read;\n+                        while ((read = r.read()) != (-1)) {\n+                            licenseTextBuffer.append((char) read);\n+                        }\n+                    }\n+                    licenseText = licenseTextBuffer.toString();\n+                }\n+                \n+                Path thirdpartynoticestxt = module.resolve(\"thirdpartynotices.txt\");\n+\n+                if (Files.isReadable(thirdpartynoticestxt)) {\n+                    licenseText = \"Parts of this work are licensed:\\n\" +\n+                                  licenseText +\n+                                  \"\\n\\n\" +\n+                                  \"Parts of this work are licensed:\\n\" +\n+                                  readString(thirdpartynoticestxt);\n+                } else {\n+                    licenseText = licenseText;\n+                }\n+\n+                Path noticestxt = module.resolve(\"CopyrightNotice.txt\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8d3d1a3928a6ab4c6d817e592179dbfcf361bd93"}, "originalPosition": 161}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MzEwMDYyOQ==", "bodyText": "The else block is unnessary.", "url": "https://github.com/apache/netbeans/pull/1845#discussion_r363100629", "createdAt": "2020-01-05T15:38:40Z", "author": {"login": "matthiasblaesing"}, "path": "nbbuild/misc/prepare-bundles/src/main/java/org/netbeans/prepare/bundles/PrepareBundles.java", "diffHunk": "@@ -0,0 +1,295 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.netbeans.prepare.bundles;\n+\n+import com.google.gson.Gson;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.io.OutputStream;\n+import java.io.OutputStreamWriter;\n+import java.io.Reader;\n+import java.io.UncheckedIOException;\n+import java.io.Writer;\n+import java.net.URL;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.DirectoryStream;\n+import java.nio.file.FileVisitOption;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.security.MessageDigest;\n+import java.security.NoSuchAlgorithmException;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.jar.JarOutputStream;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+import java.util.zip.ZipEntry;\n+\n+/**\n+ * Prepare bundles and license files for a group of node modules.\n+ */\n+public class PrepareBundles {\n+\n+    private static final String[] LICENSE_FILE_NAMES = {\n+        \"license\",\n+        \"License\",\n+        \"LICENSE\",\n+        \"LICENSE.txt\",\n+        \"LICENSE-MIT.txt\",\n+        \"license.txt\",\n+        \"License.txt\",\n+        \"LICENSE.md\",\n+        \"license.md\"\n+    };\n+    private static final String nl = System.getProperty(\"line.separator\");\n+\n+    public static void main(String... args) throws IOException, InterruptedException, NoSuchAlgorithmException {\n+        if (args.length != 2) {\n+            throw new IllegalStateException(\"Requires two parameters: location of the bundles directory, and the location of the NetBeans checkout.\");\n+        }\n+\n+        Path targetDir = Paths.get(args[0]);\n+        Path packagesDir = targetDir.resolve(\"package\");\n+        new ProcessBuilder(\"npm\", \"install\").directory(packagesDir.toFile()).inheritIO().start().waitFor();\n+        Path bundlesDir = targetDir.resolve(\"bundles\");\n+        Files.createDirectories(bundlesDir);\n+        try (DirectoryStream<Path> ds = Files.newDirectoryStream(bundlesDir)) {\n+            for (Path bundle : ds) {\n+                Files.delete(bundle);\n+            }\n+        }\n+\n+        Path licensesDir = targetDir.resolve(\"licenses\");\n+\n+        Files.createDirectories(licensesDir);\n+        try (DirectoryStream<Path> ds = Files.newDirectoryStream(licensesDir)) {\n+            for (Path license : ds) {\n+                Files.delete(license);\n+            }\n+        }\n+\n+        Path externalDir = targetDir.resolve(\"external\");\n+        Files.createDirectories(externalDir);\n+        try (DirectoryStream<Path> ds = Files.newDirectoryStream(externalDir)) {\n+            for (Path external : ds) {\n+                Files.delete(external);\n+            }\n+        }\n+\n+        Map<List<String>, LicenseUses> tokens2Projects = new HashMap<>();\n+        Map<String, LicenseDescription> project2License = new HashMap<>();\n+        Map<String, String> project2Notice = new HashMap<>();\n+        try (DirectoryStream<Path> ds = Files.newDirectoryStream(packagesDir.resolve(\"node_modules\"));\n+             Writer binariesList = new OutputStreamWriter(Files.newOutputStream(bundlesDir.resolve(\"binaries-list\")), \"UTF-8\")) {\n+            for (Path module : ds) {\n+                if (\".bin\".equals(module.getFileName().toString())) continue;\n+                if (\"@types\".equals(module.getFileName().toString())) continue;\n+                Path packageJson = module.resolve(\"package.json\");\n+\n+                if (!Files.isReadable(packageJson)) {\n+                    throw new IllegalStateException(\"Cannot find package.json for: \" + module.getFileName());\n+                }\n+\n+                String packageJsonText = readString(packageJson);\n+                Map<String, Object> packageJsonData = new Gson().fromJson(packageJsonText, HashMap.class);\n+                String name = (String) packageJsonData.get(\"name\");\n+                String version = (String) packageJsonData.get(\"version\");\n+                String description = (String) packageJsonData.get(\"description\");\n+                String homepage = (String) packageJsonData.get(\"homepage\");\n+                String licenseKey = (String) packageJsonData.get(\"license\");\n+\n+                String licenseText = null;\n+\n+                for (String l : LICENSE_FILE_NAMES) {\n+                    if (Files.isReadable(module.resolve(l))) {\n+                        licenseText = readString(module.resolve(l));\n+                        break;\n+                    }\n+                }\n+\n+                if (licenseText == null) {\n+                    String hardcodedLicenseName = name + \"-\" + version + \"-license\";\n+                    URL hardcodedLicense = PrepareBundles.class.getResource(hardcodedLicenseName);\n+                    if (hardcodedLicense == null ){\n+                        throw new IllegalStateException(\"Cannot find license for: \" + module.getFileName());\n+                    }\n+                    StringBuilder licenseTextBuffer = new StringBuilder();\n+                    try (InputStream in = hardcodedLicense.openStream();\n+                         Reader r = new InputStreamReader(in, StandardCharsets.UTF_8)) {\n+                        int read;\n+                        while ((read = r.read()) != (-1)) {\n+                            licenseTextBuffer.append((char) read);\n+                        }\n+                    }\n+                    licenseText = licenseTextBuffer.toString();\n+                }\n+                \n+                Path thirdpartynoticestxt = module.resolve(\"thirdpartynotices.txt\");\n+\n+                if (Files.isReadable(thirdpartynoticestxt)) {\n+                    licenseText = \"Parts of this work are licensed:\\n\" +\n+                                  licenseText +\n+                                  \"\\n\\n\" +\n+                                  \"Parts of this work are licensed:\\n\" +\n+                                  readString(thirdpartynoticestxt);\n+                } else {\n+                    licenseText = licenseText;\n+                }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8d3d1a3928a6ab4c6d817e592179dbfcf361bd93"}, "originalPosition": 159}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MzEwMDc1OQ==", "bodyText": "This should be getBytes(\"UTF-8\").", "url": "https://github.com/apache/netbeans/pull/1845#discussion_r363100759", "createdAt": "2020-01-05T15:41:13Z", "author": {"login": "matthiasblaesing"}, "path": "nbbuild/misc/prepare-bundles/src/main/java/org/netbeans/prepare/bundles/PrepareBundles.java", "diffHunk": "@@ -0,0 +1,295 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.netbeans.prepare.bundles;\n+\n+import com.google.gson.Gson;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.io.OutputStream;\n+import java.io.OutputStreamWriter;\n+import java.io.Reader;\n+import java.io.UncheckedIOException;\n+import java.io.Writer;\n+import java.net.URL;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.DirectoryStream;\n+import java.nio.file.FileVisitOption;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.security.MessageDigest;\n+import java.security.NoSuchAlgorithmException;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.jar.JarOutputStream;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+import java.util.zip.ZipEntry;\n+\n+/**\n+ * Prepare bundles and license files for a group of node modules.\n+ */\n+public class PrepareBundles {\n+\n+    private static final String[] LICENSE_FILE_NAMES = {\n+        \"license\",\n+        \"License\",\n+        \"LICENSE\",\n+        \"LICENSE.txt\",\n+        \"LICENSE-MIT.txt\",\n+        \"license.txt\",\n+        \"License.txt\",\n+        \"LICENSE.md\",\n+        \"license.md\"\n+    };\n+    private static final String nl = System.getProperty(\"line.separator\");\n+\n+    public static void main(String... args) throws IOException, InterruptedException, NoSuchAlgorithmException {\n+        if (args.length != 2) {\n+            throw new IllegalStateException(\"Requires two parameters: location of the bundles directory, and the location of the NetBeans checkout.\");\n+        }\n+\n+        Path targetDir = Paths.get(args[0]);\n+        Path packagesDir = targetDir.resolve(\"package\");\n+        new ProcessBuilder(\"npm\", \"install\").directory(packagesDir.toFile()).inheritIO().start().waitFor();\n+        Path bundlesDir = targetDir.resolve(\"bundles\");\n+        Files.createDirectories(bundlesDir);\n+        try (DirectoryStream<Path> ds = Files.newDirectoryStream(bundlesDir)) {\n+            for (Path bundle : ds) {\n+                Files.delete(bundle);\n+            }\n+        }\n+\n+        Path licensesDir = targetDir.resolve(\"licenses\");\n+\n+        Files.createDirectories(licensesDir);\n+        try (DirectoryStream<Path> ds = Files.newDirectoryStream(licensesDir)) {\n+            for (Path license : ds) {\n+                Files.delete(license);\n+            }\n+        }\n+\n+        Path externalDir = targetDir.resolve(\"external\");\n+        Files.createDirectories(externalDir);\n+        try (DirectoryStream<Path> ds = Files.newDirectoryStream(externalDir)) {\n+            for (Path external : ds) {\n+                Files.delete(external);\n+            }\n+        }\n+\n+        Map<List<String>, LicenseUses> tokens2Projects = new HashMap<>();\n+        Map<String, LicenseDescription> project2License = new HashMap<>();\n+        Map<String, String> project2Notice = new HashMap<>();\n+        try (DirectoryStream<Path> ds = Files.newDirectoryStream(packagesDir.resolve(\"node_modules\"));\n+             Writer binariesList = new OutputStreamWriter(Files.newOutputStream(bundlesDir.resolve(\"binaries-list\")), \"UTF-8\")) {\n+            for (Path module : ds) {\n+                if (\".bin\".equals(module.getFileName().toString())) continue;\n+                if (\"@types\".equals(module.getFileName().toString())) continue;\n+                Path packageJson = module.resolve(\"package.json\");\n+\n+                if (!Files.isReadable(packageJson)) {\n+                    throw new IllegalStateException(\"Cannot find package.json for: \" + module.getFileName());\n+                }\n+\n+                String packageJsonText = readString(packageJson);\n+                Map<String, Object> packageJsonData = new Gson().fromJson(packageJsonText, HashMap.class);\n+                String name = (String) packageJsonData.get(\"name\");\n+                String version = (String) packageJsonData.get(\"version\");\n+                String description = (String) packageJsonData.get(\"description\");\n+                String homepage = (String) packageJsonData.get(\"homepage\");\n+                String licenseKey = (String) packageJsonData.get(\"license\");\n+\n+                String licenseText = null;\n+\n+                for (String l : LICENSE_FILE_NAMES) {\n+                    if (Files.isReadable(module.resolve(l))) {\n+                        licenseText = readString(module.resolve(l));\n+                        break;\n+                    }\n+                }\n+\n+                if (licenseText == null) {\n+                    String hardcodedLicenseName = name + \"-\" + version + \"-license\";\n+                    URL hardcodedLicense = PrepareBundles.class.getResource(hardcodedLicenseName);\n+                    if (hardcodedLicense == null ){\n+                        throw new IllegalStateException(\"Cannot find license for: \" + module.getFileName());\n+                    }\n+                    StringBuilder licenseTextBuffer = new StringBuilder();\n+                    try (InputStream in = hardcodedLicense.openStream();\n+                         Reader r = new InputStreamReader(in, StandardCharsets.UTF_8)) {\n+                        int read;\n+                        while ((read = r.read()) != (-1)) {\n+                            licenseTextBuffer.append((char) read);\n+                        }\n+                    }\n+                    licenseText = licenseTextBuffer.toString();\n+                }\n+                \n+                Path thirdpartynoticestxt = module.resolve(\"thirdpartynotices.txt\");\n+\n+                if (Files.isReadable(thirdpartynoticestxt)) {\n+                    licenseText = \"Parts of this work are licensed:\\n\" +\n+                                  licenseText +\n+                                  \"\\n\\n\" +\n+                                  \"Parts of this work are licensed:\\n\" +\n+                                  readString(thirdpartynoticestxt);\n+                } else {\n+                    licenseText = licenseText;\n+                }\n+\n+                Path noticestxt = module.resolve(\"CopyrightNotice.txt\");\n+\n+                if (Files.isReadable(noticestxt)) {\n+                    project2Notice.put(module.getFileName().toString(), readString(noticestxt));\n+                }\n+\n+                List<String> tokens = licenseTextToTokens(licenseText);\n+                String licenseTextFin = licenseText;\n+\n+                tokens2Projects.computeIfAbsent(tokens, t -> new LicenseUses(licenseKey, licenseTextFin)).projects.add(module.getFileName().toString());\n+                project2License.put(module.getFileName().toString(), new LicenseDescription(name, version, description, homepage, licenseKey, licenseText));\n+\n+                Path bundle = bundlesDir.resolve(module.getFileName() + \"-\" + version + \".zip\");\n+                try (JarOutputStream out = new JarOutputStream(Files.newOutputStream(bundle));\n+                     Stream<Path> files = Files.walk(module, FileVisitOption.FOLLOW_LINKS)) {\n+                    files.forEach(p -> {\n+                        if (p == module) return ;\n+                        try {\n+                            String relative = module.getParent().relativize(p).toString();\n+                            boolean isDir = Files.isDirectory(p);\n+                            ZipEntry ze = new ZipEntry(relative + (isDir ? \"/\" : \"\"));\n+                            out.putNextEntry(ze);\n+                            if (!isDir) {\n+                                if (relative.equals(\"package.json\")) {\n+                                    out.write(packageJsonText.replace(targetDir.toString(), \"\").getBytes());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8d3d1a3928a6ab4c6d817e592179dbfcf361bd93"}, "originalPosition": 185}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MzEwMDgzNA==", "bodyText": "Accessing a private field from outside the class looks strange to me. Would you consider moving the declarations here to public final?", "url": "https://github.com/apache/netbeans/pull/1845#discussion_r363100834", "createdAt": "2020-01-05T15:42:51Z", "author": {"login": "matthiasblaesing"}, "path": "nbbuild/misc/prepare-bundles/src/main/java/org/netbeans/prepare/bundles/PrepareBundles.java", "diffHunk": "@@ -0,0 +1,295 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.netbeans.prepare.bundles;\n+\n+import com.google.gson.Gson;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.io.OutputStream;\n+import java.io.OutputStreamWriter;\n+import java.io.Reader;\n+import java.io.UncheckedIOException;\n+import java.io.Writer;\n+import java.net.URL;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.DirectoryStream;\n+import java.nio.file.FileVisitOption;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.security.MessageDigest;\n+import java.security.NoSuchAlgorithmException;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.jar.JarOutputStream;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+import java.util.zip.ZipEntry;\n+\n+/**\n+ * Prepare bundles and license files for a group of node modules.\n+ */\n+public class PrepareBundles {\n+\n+    private static final String[] LICENSE_FILE_NAMES = {\n+        \"license\",\n+        \"License\",\n+        \"LICENSE\",\n+        \"LICENSE.txt\",\n+        \"LICENSE-MIT.txt\",\n+        \"license.txt\",\n+        \"License.txt\",\n+        \"LICENSE.md\",\n+        \"license.md\"\n+    };\n+    private static final String nl = System.getProperty(\"line.separator\");\n+\n+    public static void main(String... args) throws IOException, InterruptedException, NoSuchAlgorithmException {\n+        if (args.length != 2) {\n+            throw new IllegalStateException(\"Requires two parameters: location of the bundles directory, and the location of the NetBeans checkout.\");\n+        }\n+\n+        Path targetDir = Paths.get(args[0]);\n+        Path packagesDir = targetDir.resolve(\"package\");\n+        new ProcessBuilder(\"npm\", \"install\").directory(packagesDir.toFile()).inheritIO().start().waitFor();\n+        Path bundlesDir = targetDir.resolve(\"bundles\");\n+        Files.createDirectories(bundlesDir);\n+        try (DirectoryStream<Path> ds = Files.newDirectoryStream(bundlesDir)) {\n+            for (Path bundle : ds) {\n+                Files.delete(bundle);\n+            }\n+        }\n+\n+        Path licensesDir = targetDir.resolve(\"licenses\");\n+\n+        Files.createDirectories(licensesDir);\n+        try (DirectoryStream<Path> ds = Files.newDirectoryStream(licensesDir)) {\n+            for (Path license : ds) {\n+                Files.delete(license);\n+            }\n+        }\n+\n+        Path externalDir = targetDir.resolve(\"external\");\n+        Files.createDirectories(externalDir);\n+        try (DirectoryStream<Path> ds = Files.newDirectoryStream(externalDir)) {\n+            for (Path external : ds) {\n+                Files.delete(external);\n+            }\n+        }\n+\n+        Map<List<String>, LicenseUses> tokens2Projects = new HashMap<>();\n+        Map<String, LicenseDescription> project2License = new HashMap<>();\n+        Map<String, String> project2Notice = new HashMap<>();\n+        try (DirectoryStream<Path> ds = Files.newDirectoryStream(packagesDir.resolve(\"node_modules\"));\n+             Writer binariesList = new OutputStreamWriter(Files.newOutputStream(bundlesDir.resolve(\"binaries-list\")), \"UTF-8\")) {\n+            for (Path module : ds) {\n+                if (\".bin\".equals(module.getFileName().toString())) continue;\n+                if (\"@types\".equals(module.getFileName().toString())) continue;\n+                Path packageJson = module.resolve(\"package.json\");\n+\n+                if (!Files.isReadable(packageJson)) {\n+                    throw new IllegalStateException(\"Cannot find package.json for: \" + module.getFileName());\n+                }\n+\n+                String packageJsonText = readString(packageJson);\n+                Map<String, Object> packageJsonData = new Gson().fromJson(packageJsonText, HashMap.class);\n+                String name = (String) packageJsonData.get(\"name\");\n+                String version = (String) packageJsonData.get(\"version\");\n+                String description = (String) packageJsonData.get(\"description\");\n+                String homepage = (String) packageJsonData.get(\"homepage\");\n+                String licenseKey = (String) packageJsonData.get(\"license\");\n+\n+                String licenseText = null;\n+\n+                for (String l : LICENSE_FILE_NAMES) {\n+                    if (Files.isReadable(module.resolve(l))) {\n+                        licenseText = readString(module.resolve(l));\n+                        break;\n+                    }\n+                }\n+\n+                if (licenseText == null) {\n+                    String hardcodedLicenseName = name + \"-\" + version + \"-license\";\n+                    URL hardcodedLicense = PrepareBundles.class.getResource(hardcodedLicenseName);\n+                    if (hardcodedLicense == null ){\n+                        throw new IllegalStateException(\"Cannot find license for: \" + module.getFileName());\n+                    }\n+                    StringBuilder licenseTextBuffer = new StringBuilder();\n+                    try (InputStream in = hardcodedLicense.openStream();\n+                         Reader r = new InputStreamReader(in, StandardCharsets.UTF_8)) {\n+                        int read;\n+                        while ((read = r.read()) != (-1)) {\n+                            licenseTextBuffer.append((char) read);\n+                        }\n+                    }\n+                    licenseText = licenseTextBuffer.toString();\n+                }\n+                \n+                Path thirdpartynoticestxt = module.resolve(\"thirdpartynotices.txt\");\n+\n+                if (Files.isReadable(thirdpartynoticestxt)) {\n+                    licenseText = \"Parts of this work are licensed:\\n\" +\n+                                  licenseText +\n+                                  \"\\n\\n\" +\n+                                  \"Parts of this work are licensed:\\n\" +\n+                                  readString(thirdpartynoticestxt);\n+                } else {\n+                    licenseText = licenseText;\n+                }\n+\n+                Path noticestxt = module.resolve(\"CopyrightNotice.txt\");\n+\n+                if (Files.isReadable(noticestxt)) {\n+                    project2Notice.put(module.getFileName().toString(), readString(noticestxt));\n+                }\n+\n+                List<String> tokens = licenseTextToTokens(licenseText);\n+                String licenseTextFin = licenseText;\n+\n+                tokens2Projects.computeIfAbsent(tokens, t -> new LicenseUses(licenseKey, licenseTextFin)).projects.add(module.getFileName().toString());\n+                project2License.put(module.getFileName().toString(), new LicenseDescription(name, version, description, homepage, licenseKey, licenseText));\n+\n+                Path bundle = bundlesDir.resolve(module.getFileName() + \"-\" + version + \".zip\");\n+                try (JarOutputStream out = new JarOutputStream(Files.newOutputStream(bundle));\n+                     Stream<Path> files = Files.walk(module, FileVisitOption.FOLLOW_LINKS)) {\n+                    files.forEach(p -> {\n+                        if (p == module) return ;\n+                        try {\n+                            String relative = module.getParent().relativize(p).toString();\n+                            boolean isDir = Files.isDirectory(p);\n+                            ZipEntry ze = new ZipEntry(relative + (isDir ? \"/\" : \"\"));\n+                            out.putNextEntry(ze);\n+                            if (!isDir) {\n+                                if (relative.equals(\"package.json\")) {\n+                                    out.write(packageJsonText.replace(targetDir.toString(), \"\").getBytes());\n+                                } else {\n+                                    Files.copy(p, out);\n+                                }\n+                            }\n+                        } catch (IOException ex) {\n+                            throw new UncheckedIOException(ex);\n+                        }\n+                    });\n+                }\n+                MessageDigest md = MessageDigest.getInstance(\"SHA1\");\n+                md.update(Files.readAllBytes(bundle));\n+                StringBuilder hash = new StringBuilder();\n+                for (byte b : md.digest()) {\n+                    hash.append(String.format(\"%02X\", b));\n+                }\n+                Path external = externalDir.resolve(hash + \"-\" + bundle.getFileName());\n+                Files.copy(bundle, external);\n+                binariesList.write(hash + \" \" + bundle.getFileName().toString() + nl);\n+            }\n+        }\n+        \n+        Map<String, String> project2LicenseKey = new HashMap<>();\n+\n+        Map<List<String>, String> knownLicenseTokens2LicenseKey = new HashMap<>();\n+        Path nb_all = Paths.get(args[1]);\n+\n+        try (DirectoryStream<Path> ds = Files.newDirectoryStream(nb_all.resolve(\"nbbuild\").resolve(\"licenses\"))) {\n+            for (Path license : ds) {\n+                knownLicenseTokens2LicenseKey.put(licenseTextToTokens(readString(license)), license.getFileName().toString());\n+            }\n+        }\n+\n+        for (Entry<List<String>, LicenseUses> e : tokens2Projects.entrySet()) {\n+            LicenseUses use = e.getValue();\n+            String licenseName = knownLicenseTokens2LicenseKey.get(e.getKey());\n+            if (licenseName == null) {\n+                licenseName = use.key + \"-\" + use.projects.stream().collect(Collectors.joining(\"-\"));\n+                try (OutputStream out = Files.newOutputStream(licensesDir.resolve(licenseName))) {\n+                    out.write(use.licenseText.getBytes(\"UTF-8\"));\n+                }\n+            }\n+            for (String prj : use.projects) {\n+                project2LicenseKey.put(prj, licenseName);\n+            }\n+        }\n+        for (Entry<String, LicenseDescription> e : project2License.entrySet()) {\n+            LicenseDescription licenseDesc = e.getValue();\n+            Path projectLicenseFile = bundlesDir.resolve(e.getKey() + \"-\" + licenseDesc.version + \"-license.txt\");\n+            try (Writer w = new OutputStreamWriter(Files.newOutputStream(projectLicenseFile), \"UTF-8\")) {\n+                w.write(\"Name: \" + licenseDesc.name + nl);\n+                w.write(\"Description: \" + licenseDesc.description + nl);\n+                w.write(\"Version: \" + licenseDesc.version + nl);\n+                w.write(\"License: \" + project2LicenseKey.get(e.getKey()) + nl);\n+                w.write(\"Origin: \" + licenseDesc.homepage + nl);\n+                w.write(nl);\n+                w.write(licenseDesc.licenseText);\n+            }\n+            String notice = project2Notice.get(e.getKey());\n+            if (notice != null) {\n+                Path projectNoticeFile = bundlesDir.resolve(e.getKey() + \"-\" + licenseDesc.version + \"-notice.txt\");\n+                try (Writer w = new OutputStreamWriter(Files.newOutputStream(projectNoticeFile), \"UTF-8\")) {\n+                    w.write(notice);\n+                }\n+            }\n+        }\n+    }\n+\n+    private static String readString(Path p) throws IOException {\n+        return new String(Files.readAllBytes(p), StandardCharsets.UTF_8);\n+    }\n+\n+    private static List<String> licenseTextToTokens(String licenseText) {\n+        return Arrays.asList(licenseText.replaceAll(\"[ \\n\\r\\t]+\", \" \").split(\" \"));\n+    }\n+    private static class LicenseDescription {\n+        private final String name;\n+        private final String version;\n+        private final String description;\n+        private final String homepage;\n+        private final String licenseKey;\n+        private final String licenseText;\n+        private final List<String> bundles = new ArrayList<>();\n+\n+        public LicenseDescription(String name, String version, String description, String homepage, String licenseKey, String licenseText) {\n+            this.name = name;\n+            this.version = version;\n+            this.description = description;\n+            this.homepage = homepage;\n+            this.licenseKey = licenseKey;\n+            this.licenseText = licenseText;\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return \"LicenseDescription{\" + \"version=\" + version + \", description=\" + description + \", homepage=\" + homepage + \", licenseKey=\" + licenseKey + \", licenseText=\" + licenseText + \", bundles=\" + bundles + '}';\n+        }\n+\n+    }\n+    private static class LicenseUses {\n+        private final String key;\n+        private final String licenseText;\n+        private final List<String> projects = new ArrayList<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8d3d1a3928a6ab4c6d817e592179dbfcf361bd93"}, "originalPosition": 287}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MzEwMDg1OQ==", "bodyText": "Same comment as 287.", "url": "https://github.com/apache/netbeans/pull/1845#discussion_r363100859", "createdAt": "2020-01-05T15:43:09Z", "author": {"login": "matthiasblaesing"}, "path": "nbbuild/misc/prepare-bundles/src/main/java/org/netbeans/prepare/bundles/PrepareBundles.java", "diffHunk": "@@ -0,0 +1,295 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.netbeans.prepare.bundles;\n+\n+import com.google.gson.Gson;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.io.OutputStream;\n+import java.io.OutputStreamWriter;\n+import java.io.Reader;\n+import java.io.UncheckedIOException;\n+import java.io.Writer;\n+import java.net.URL;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.DirectoryStream;\n+import java.nio.file.FileVisitOption;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.security.MessageDigest;\n+import java.security.NoSuchAlgorithmException;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.jar.JarOutputStream;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+import java.util.zip.ZipEntry;\n+\n+/**\n+ * Prepare bundles and license files for a group of node modules.\n+ */\n+public class PrepareBundles {\n+\n+    private static final String[] LICENSE_FILE_NAMES = {\n+        \"license\",\n+        \"License\",\n+        \"LICENSE\",\n+        \"LICENSE.txt\",\n+        \"LICENSE-MIT.txt\",\n+        \"license.txt\",\n+        \"License.txt\",\n+        \"LICENSE.md\",\n+        \"license.md\"\n+    };\n+    private static final String nl = System.getProperty(\"line.separator\");\n+\n+    public static void main(String... args) throws IOException, InterruptedException, NoSuchAlgorithmException {\n+        if (args.length != 2) {\n+            throw new IllegalStateException(\"Requires two parameters: location of the bundles directory, and the location of the NetBeans checkout.\");\n+        }\n+\n+        Path targetDir = Paths.get(args[0]);\n+        Path packagesDir = targetDir.resolve(\"package\");\n+        new ProcessBuilder(\"npm\", \"install\").directory(packagesDir.toFile()).inheritIO().start().waitFor();\n+        Path bundlesDir = targetDir.resolve(\"bundles\");\n+        Files.createDirectories(bundlesDir);\n+        try (DirectoryStream<Path> ds = Files.newDirectoryStream(bundlesDir)) {\n+            for (Path bundle : ds) {\n+                Files.delete(bundle);\n+            }\n+        }\n+\n+        Path licensesDir = targetDir.resolve(\"licenses\");\n+\n+        Files.createDirectories(licensesDir);\n+        try (DirectoryStream<Path> ds = Files.newDirectoryStream(licensesDir)) {\n+            for (Path license : ds) {\n+                Files.delete(license);\n+            }\n+        }\n+\n+        Path externalDir = targetDir.resolve(\"external\");\n+        Files.createDirectories(externalDir);\n+        try (DirectoryStream<Path> ds = Files.newDirectoryStream(externalDir)) {\n+            for (Path external : ds) {\n+                Files.delete(external);\n+            }\n+        }\n+\n+        Map<List<String>, LicenseUses> tokens2Projects = new HashMap<>();\n+        Map<String, LicenseDescription> project2License = new HashMap<>();\n+        Map<String, String> project2Notice = new HashMap<>();\n+        try (DirectoryStream<Path> ds = Files.newDirectoryStream(packagesDir.resolve(\"node_modules\"));\n+             Writer binariesList = new OutputStreamWriter(Files.newOutputStream(bundlesDir.resolve(\"binaries-list\")), \"UTF-8\")) {\n+            for (Path module : ds) {\n+                if (\".bin\".equals(module.getFileName().toString())) continue;\n+                if (\"@types\".equals(module.getFileName().toString())) continue;\n+                Path packageJson = module.resolve(\"package.json\");\n+\n+                if (!Files.isReadable(packageJson)) {\n+                    throw new IllegalStateException(\"Cannot find package.json for: \" + module.getFileName());\n+                }\n+\n+                String packageJsonText = readString(packageJson);\n+                Map<String, Object> packageJsonData = new Gson().fromJson(packageJsonText, HashMap.class);\n+                String name = (String) packageJsonData.get(\"name\");\n+                String version = (String) packageJsonData.get(\"version\");\n+                String description = (String) packageJsonData.get(\"description\");\n+                String homepage = (String) packageJsonData.get(\"homepage\");\n+                String licenseKey = (String) packageJsonData.get(\"license\");\n+\n+                String licenseText = null;\n+\n+                for (String l : LICENSE_FILE_NAMES) {\n+                    if (Files.isReadable(module.resolve(l))) {\n+                        licenseText = readString(module.resolve(l));\n+                        break;\n+                    }\n+                }\n+\n+                if (licenseText == null) {\n+                    String hardcodedLicenseName = name + \"-\" + version + \"-license\";\n+                    URL hardcodedLicense = PrepareBundles.class.getResource(hardcodedLicenseName);\n+                    if (hardcodedLicense == null ){\n+                        throw new IllegalStateException(\"Cannot find license for: \" + module.getFileName());\n+                    }\n+                    StringBuilder licenseTextBuffer = new StringBuilder();\n+                    try (InputStream in = hardcodedLicense.openStream();\n+                         Reader r = new InputStreamReader(in, StandardCharsets.UTF_8)) {\n+                        int read;\n+                        while ((read = r.read()) != (-1)) {\n+                            licenseTextBuffer.append((char) read);\n+                        }\n+                    }\n+                    licenseText = licenseTextBuffer.toString();\n+                }\n+                \n+                Path thirdpartynoticestxt = module.resolve(\"thirdpartynotices.txt\");\n+\n+                if (Files.isReadable(thirdpartynoticestxt)) {\n+                    licenseText = \"Parts of this work are licensed:\\n\" +\n+                                  licenseText +\n+                                  \"\\n\\n\" +\n+                                  \"Parts of this work are licensed:\\n\" +\n+                                  readString(thirdpartynoticestxt);\n+                } else {\n+                    licenseText = licenseText;\n+                }\n+\n+                Path noticestxt = module.resolve(\"CopyrightNotice.txt\");\n+\n+                if (Files.isReadable(noticestxt)) {\n+                    project2Notice.put(module.getFileName().toString(), readString(noticestxt));\n+                }\n+\n+                List<String> tokens = licenseTextToTokens(licenseText);\n+                String licenseTextFin = licenseText;\n+\n+                tokens2Projects.computeIfAbsent(tokens, t -> new LicenseUses(licenseKey, licenseTextFin)).projects.add(module.getFileName().toString());\n+                project2License.put(module.getFileName().toString(), new LicenseDescription(name, version, description, homepage, licenseKey, licenseText));\n+\n+                Path bundle = bundlesDir.resolve(module.getFileName() + \"-\" + version + \".zip\");\n+                try (JarOutputStream out = new JarOutputStream(Files.newOutputStream(bundle));\n+                     Stream<Path> files = Files.walk(module, FileVisitOption.FOLLOW_LINKS)) {\n+                    files.forEach(p -> {\n+                        if (p == module) return ;\n+                        try {\n+                            String relative = module.getParent().relativize(p).toString();\n+                            boolean isDir = Files.isDirectory(p);\n+                            ZipEntry ze = new ZipEntry(relative + (isDir ? \"/\" : \"\"));\n+                            out.putNextEntry(ze);\n+                            if (!isDir) {\n+                                if (relative.equals(\"package.json\")) {\n+                                    out.write(packageJsonText.replace(targetDir.toString(), \"\").getBytes());\n+                                } else {\n+                                    Files.copy(p, out);\n+                                }\n+                            }\n+                        } catch (IOException ex) {\n+                            throw new UncheckedIOException(ex);\n+                        }\n+                    });\n+                }\n+                MessageDigest md = MessageDigest.getInstance(\"SHA1\");\n+                md.update(Files.readAllBytes(bundle));\n+                StringBuilder hash = new StringBuilder();\n+                for (byte b : md.digest()) {\n+                    hash.append(String.format(\"%02X\", b));\n+                }\n+                Path external = externalDir.resolve(hash + \"-\" + bundle.getFileName());\n+                Files.copy(bundle, external);\n+                binariesList.write(hash + \" \" + bundle.getFileName().toString() + nl);\n+            }\n+        }\n+        \n+        Map<String, String> project2LicenseKey = new HashMap<>();\n+\n+        Map<List<String>, String> knownLicenseTokens2LicenseKey = new HashMap<>();\n+        Path nb_all = Paths.get(args[1]);\n+\n+        try (DirectoryStream<Path> ds = Files.newDirectoryStream(nb_all.resolve(\"nbbuild\").resolve(\"licenses\"))) {\n+            for (Path license : ds) {\n+                knownLicenseTokens2LicenseKey.put(licenseTextToTokens(readString(license)), license.getFileName().toString());\n+            }\n+        }\n+\n+        for (Entry<List<String>, LicenseUses> e : tokens2Projects.entrySet()) {\n+            LicenseUses use = e.getValue();\n+            String licenseName = knownLicenseTokens2LicenseKey.get(e.getKey());\n+            if (licenseName == null) {\n+                licenseName = use.key + \"-\" + use.projects.stream().collect(Collectors.joining(\"-\"));\n+                try (OutputStream out = Files.newOutputStream(licensesDir.resolve(licenseName))) {\n+                    out.write(use.licenseText.getBytes(\"UTF-8\"));\n+                }\n+            }\n+            for (String prj : use.projects) {\n+                project2LicenseKey.put(prj, licenseName);\n+            }\n+        }\n+        for (Entry<String, LicenseDescription> e : project2License.entrySet()) {\n+            LicenseDescription licenseDesc = e.getValue();\n+            Path projectLicenseFile = bundlesDir.resolve(e.getKey() + \"-\" + licenseDesc.version + \"-license.txt\");\n+            try (Writer w = new OutputStreamWriter(Files.newOutputStream(projectLicenseFile), \"UTF-8\")) {\n+                w.write(\"Name: \" + licenseDesc.name + nl);\n+                w.write(\"Description: \" + licenseDesc.description + nl);\n+                w.write(\"Version: \" + licenseDesc.version + nl);\n+                w.write(\"License: \" + project2LicenseKey.get(e.getKey()) + nl);\n+                w.write(\"Origin: \" + licenseDesc.homepage + nl);\n+                w.write(nl);\n+                w.write(licenseDesc.licenseText);\n+            }\n+            String notice = project2Notice.get(e.getKey());\n+            if (notice != null) {\n+                Path projectNoticeFile = bundlesDir.resolve(e.getKey() + \"-\" + licenseDesc.version + \"-notice.txt\");\n+                try (Writer w = new OutputStreamWriter(Files.newOutputStream(projectNoticeFile), \"UTF-8\")) {\n+                    w.write(notice);\n+                }\n+            }\n+        }\n+    }\n+\n+    private static String readString(Path p) throws IOException {\n+        return new String(Files.readAllBytes(p), StandardCharsets.UTF_8);\n+    }\n+\n+    private static List<String> licenseTextToTokens(String licenseText) {\n+        return Arrays.asList(licenseText.replaceAll(\"[ \\n\\r\\t]+\", \" \").split(\" \"));\n+    }\n+    private static class LicenseDescription {\n+        private final String name;\n+        private final String version;\n+        private final String description;\n+        private final String homepage;\n+        private final String licenseKey;\n+        private final String licenseText;\n+        private final List<String> bundles = new ArrayList<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8d3d1a3928a6ab4c6d817e592179dbfcf361bd93"}, "originalPosition": 267}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4ce9c447bea4e47197857496c887d13c1c3d6211", "author": {"user": {"login": "jlahoda", "name": "Jan Lahoda"}}, "url": "https://github.com/apache/netbeans/commit/4ce9c447bea4e47197857496c887d13c1c3d6211", "committedDate": "2020-01-13T21:14:05Z", "message": "Addressing review comments."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "defed4a7b371ca95f7ab408cdf136c8409da19fe", "author": {"user": {"login": "jlahoda", "name": "Jan Lahoda"}}, "url": "https://github.com/apache/netbeans/commit/defed4a7b371ca95f7ab408cdf136c8409da19fe", "committedDate": "2020-01-13T21:35:19Z", "message": "Merging master into the vscode-ext-mandatory branch"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQyMTg1NjM2", "url": "https://github.com/apache/netbeans/pull/1845#pullrequestreview-342185636", "createdAt": "2020-01-13T22:33:27Z", "commit": {"oid": "defed4a7b371ca95f7ab408cdf136c8409da19fe"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQyNzc2Mzg1", "url": "https://github.com/apache/netbeans/pull/1845#pullrequestreview-342776385", "createdAt": "2020-01-14T19:18:10Z", "commit": {"oid": "defed4a7b371ca95f7ab408cdf136c8409da19fe"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 235, "cost": 1, "resetAt": "2021-10-28T17:48:14Z"}}}