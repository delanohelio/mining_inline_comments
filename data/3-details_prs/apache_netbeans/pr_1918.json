{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzcwODAyNTcw", "number": 1918, "title": "[NETBEANS-3785] Implement simplified HeapView widget", "bodyText": "This fixes the appearance of the HeapView widget on HiDPI displays. The widget is much simplified, consisting only of a background, an area chart showing the last 100 samples, and text showing the current used heap / total. No bitmaps are used so DPI issues should not be present. Tested on Windows 10/JDK 11 with 125% scaling factor.\nNB11.2:\n\nThis PR:\n\nThe colours and presence/absence of text are configurable as before.\nSee bug NETBEANS-3785", "createdAt": "2020-02-04T12:10:06Z", "url": "https://github.com/apache/netbeans/pull/1918", "merged": true, "mergeCommit": {"oid": "0f594abeb0668b30a9045daab991adbf59d14ec9"}, "closed": true, "closedAt": "2020-02-07T17:19:12Z", "author": {"login": "pedro-w"}, "timelineItems": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcA--p_AH2gAyMzcwODAyNTcwOjBlMGQ3MTVjODI3MWNkYTY4NjdlNWFjYjI2ZGNhNzQ1MjE5NTk0MWI=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcBUPvXAH2gAyMzcwODAyNTcwOmY0NWM1OTJiYThkNTE4OTgxMmMxOTRhY2MyM2ViNWJlNDdkMjhjNmQ=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "0e0d715c8271cda6867e5acb26dca7452195941b", "author": {"user": {"login": "pedro-w", "name": "Peter Hull"}}, "url": "https://github.com/apache/netbeans/commit/0e0d715c8271cda6867e5acb26dca7452195941b", "committedDate": "2020-02-04T10:28:38Z", "message": "Implement simplified HeapView widget\n\nThis fixes the appearance of the HeapView widget on HiDPI displays\n\nSee bug NETBEANS-3785"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzUzMTM5NzQz", "url": "https://github.com/apache/netbeans/pull/1918#pullrequestreview-353139743", "createdAt": "2020-02-04T16:55:31Z", "commit": {"oid": "0e0d715c8271cda6867e5acb26dca7452195941b"}, "state": "APPROVED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNFQxNjo1NTozMVrOFlbvVg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNFQxNzowNzozMFrOFlcK_g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDc5NjExOA==", "bodyText": "You(?) mentioned earlier the idea of \"using the cheap & cheerful way of drawing the text twice, the first time displaced and in a darker colour\". Perhaps it would be good to include this to create a little contrast between the text and the graph below? E.g.:\ng.setColor(Color.BLACK);\ng.drawString(text, x + 1, y + 1);\ng.setColor(TEXT_COLOR);\ng.drawString(text, x, y);", "url": "https://github.com/apache/netbeans/pull/1918#discussion_r374796118", "createdAt": "2020-02-04T16:55:31Z", "author": {"login": "eirikbakke"}, "path": "platform/openide.actions/src/org/openide/actions/HeapView.java", "diffHunk": "@@ -465,526 +225,174 @@ private void updateTextWidth() {\n      *\n      * @param e the MouseEvent\n      */\n-    @Override protected void processMouseEvent(MouseEvent e) {\n+    @Override\n+    protected void processMouseEvent(MouseEvent e) {\n         super.processMouseEvent(e);\n         if (!e.isConsumed()) {\n             if (e.isPopupTrigger()) {\n                 // Show a popup allowing to configure the various options\n                 showPopup(e.getX(), e.getY());\n-            }  else if (e.getID() == MouseEvent.MOUSE_ENTERED) {\n-                containsMouse = true;\n-                cachedBorderVaild = false;\n-                repaint();\n-            } else if (e.getID() == MouseEvent.MOUSE_EXITED) {\n-                containsMouse = false;\n-                cachedBorderVaild = false;\n-                repaint();\n             }\n+        }\n \n-        } \n-        \n-        if (e.getID() == MouseEvent.MOUSE_CLICKED &&\n-                SwingUtilities.isLeftMouseButton(e) && \n-                e.getClickCount() == 1) {\n+        if (e.getID() == MouseEvent.MOUSE_CLICKED\n+                && SwingUtilities.isLeftMouseButton(e)\n+                && e.getClickCount() == 1) {\n             // Trigger a gc\n-            GarbageCollectAction.get(GarbageCollectAction.class).performAction();;\n+            GarbageCollectAction.get(GarbageCollectAction.class).performAction();\n         }\n     }\n \n     /**\n-     * Shows a popup at the specified location that allows you to configure\n-     * the various options.\n+     * Shows a popup at the specified location that allows you to configure the\n+     * various options.\n      */\n     private void showPopup(int x, int y) {\n         JPopupMenu popup = new JPopupMenu();\n         JCheckBoxMenuItem cbmi = new JCheckBoxMenuItem(NbBundle.getMessage(HeapView.class, \"LBL_ShowText\"));\n         cbmi.setSelected(getShowText());\n         cbmi.addActionListener(new ActionListener() {\n             public void actionPerformed(ActionEvent e) {\n-                setShowText(((JCheckBoxMenuItem)e.getSource()).\n+                setShowText(((JCheckBoxMenuItem) e.getSource()).\n                         isSelected());\n             }\n         });\n         popup.add(cbmi);\n-        cbmi = new JCheckBoxMenuItem(NbBundle.getMessage(HeapView.class, \"LBL_DropShadow\"));\n-        cbmi.setSelected(getShowDropShadow());\n-        cbmi.addActionListener(new ActionListener() {\n-            public void actionPerformed(ActionEvent e) {\n-                setShowDropShadow(((JCheckBoxMenuItem)e.getSource()).\n-                        isSelected());\n-            }\n-        });\n-        popup.add(cbmi);\n-        cbmi = new JCheckBoxMenuItem(NbBundle.getMessage(HeapView.class, \"LBL_OverlayGrid\"));\n-        cbmi.setSelected(getTickStyle() == STYLE_OVERLAY);\n-        cbmi.addActionListener(new ActionListener() {\n-            public void actionPerformed(ActionEvent e) {\n-                int style = ((JCheckBoxMenuItem)e.getSource()).\n-                        isSelected() ? STYLE_OVERLAY : STYLE_DEFAULT;\n-                setTickStyle(style);\n-            }\n-        });\n-        popup.add(cbmi);\n         popup.show(this, x, y);\n     }\n \n-    /**\n-     * Returns the first index to start rendering from.\n-     */\n-    private int getGraphStartIndex() {\n-        if (graphFilled) {\n-            return graphIndex;\n-        } else {\n-            return 0;\n-        }\n-    }\n-\n     /**\n      * Paints the component.\n      */\n-    @Override protected void paintComponent(Graphics g) {\n-        Graphics2D g2 = (Graphics2D)g;\n+    @Override\n+    protected void paintComponent(Graphics g) {\n+        super.paintComponent(g);\n         int width = getWidth();\n         int height = getHeight();\n-        if (width - BORDER_W > 0 && height - BORDER_H > 0) {\n+\n+        if (width > 0 && height > 0) {\n             startTimerIfNecessary();\n-            updateCacheIfNecessary(width, height);\n-            paintCachedBackground(g2, width, height);\n-            g.translate(1, 2);\n-            if (containsMouse) {\n-                g.clipRect(1, 0, width - 4, height - 4);\n-            }\n-            else {\n-                g.clipRect(0, 0, width - 2, height - 4);\n-            }\n-            int innerW = width - BORDER_W;\n-            int innerH = height - BORDER_H;\n-            if (heapGrowTimer != null) {\n-                // Render the heap growing animation.\n-                Composite lastComposite = ((Graphics2D)g).getComposite();\n-                float percent = 1f - heapGrowTimer.getPercent();\n-                ((Graphics2D)g).setComposite(AlphaComposite.getInstance(AlphaComposite.SRC_OVER, percent));\n-                g.drawImage(heapGrowTimer.image, 0, 0, null);\n-                ((Graphics2D)g).setComposite(lastComposite);\n-            }\n-            paintTicks(g2, innerW, innerH);\n-            if (getTickStyle() == STYLE_OVERLAY) {\n-                g2.drawImage(getGridOverlayImage(), 0, 0, null);\n-            }\n+            Graphics2D g2 = (Graphics2D) g;\n+            g2.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);\n+            // Fill background\n+            g2.setPaint(BACKGROUND_COLOR);\n+            g2.fillRect(0, 0, width + 1, height + 1);\n+            // Draw samples\n+            g2.setPaint(CHART_COLOR);\n+            paintSamples(g2, width, height);\n+            // Draw text if enabled\n             if (getShowText()) {\n-                if (getShowDropShadow()) {\n-                    paintDropShadowText(g, innerW, innerH);\n-                } else {\n-                    g.setColor(textColor);\n-                    paintText(g, innerW, innerH);\n-                }\n+                paintText(g2, width, height);\n             }\n-            g.translate(-1, -2);\n         } else {\n             stopTimerIfNecessary();\n-            // To honor opaque contract, fill in the background\n-            g.setColor(getBackground());\n-            g.fillRect(0, 0, width, height);\n-        }\n-    }\n-    \n-    private void paintTicks(Graphics2D g, int width, int height) {\n-        if (graphIndex > 0 || graphFilled) {\n-            int index = getGraphStartIndex();\n-            int x = 0;\n-            if (!graphFilled) {\n-                x = width - graphIndex;\n-            }\n-            float[] localGraph = graph;\n-            if (localGraph == null) {\n-                return;\n-            }\n-            float min = localGraph[index];\n-            index = (index + 1) % localGraph.length;\n-            while (index != graphIndex) {\n-                min = Math.min(min, localGraph[index]);\n-                index = (index + 1) % localGraph.length;\n-            }\n-            int minHeight = (int)(min * (float)height);\n-            if (minHeight > 0) {\n-               g.drawImage(tickGradientImage, x, height - minHeight, width, height,\n-                        x, height - minHeight, width, height, null);\n-            }\n-            index = getGraphStartIndex();\n-            do {\n-                int tickHeight = (int)(localGraph[index] * (float)height);\n-                if (tickHeight > minHeight) {\n-                    g.drawImage(tickGradientImage, x, height - tickHeight, x + 1, height - minHeight,\n-                            x, height - tickHeight, x + 1, height - minHeight, null);\n-                }\n-                index = (index + 1) % localGraph.length;\n-                x++;\n-            } while (index != graphIndex);\n         }\n     }\n \n     /**\n-     * Renders the text.\n+     * Renders the text using an optional drop shadow.\n      */\n-    private void paintText(Graphics g, int w, int h) {\n+    private void paintText(Graphics2D g, int w, int h) {\n         g.setFont(getFont());\n         String text = getHeapSizeText();\n         FontMetrics fm = g.getFontMetrics();\n         int textWidth = fm.stringWidth(text);\n-        g.drawString(text, (w - maxTextWidth) / 2 + (maxTextWidth - textWidth), \n-                h / 2 + fm.getAscent() / 2 - 2);\n+        int x = (w - maxTextWidth) / 2 + (maxTextWidth - textWidth);\n+        int y = h / 2 + fm.getAscent() / 2 - 2;\n+        g.setColor(TEXT_COLOR);\n+        g.drawString(text, x, y);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0e0d715c8271cda6867e5acb26dca7452195941b"}, "originalPosition": 694}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDc5ODIxMg==", "bodyText": "Perfect--this seems like exactly the right way to draw this, with anti-aliased lines and everything.", "url": "https://github.com/apache/netbeans/pull/1918#discussion_r374798212", "createdAt": "2020-02-04T16:58:54Z", "author": {"login": "eirikbakke"}, "path": "platform/openide.actions/src/org/openide/actions/HeapView.java", "diffHunk": "@@ -465,526 +225,174 @@ private void updateTextWidth() {\n      *\n      * @param e the MouseEvent\n      */\n-    @Override protected void processMouseEvent(MouseEvent e) {\n+    @Override\n+    protected void processMouseEvent(MouseEvent e) {\n         super.processMouseEvent(e);\n         if (!e.isConsumed()) {\n             if (e.isPopupTrigger()) {\n                 // Show a popup allowing to configure the various options\n                 showPopup(e.getX(), e.getY());\n-            }  else if (e.getID() == MouseEvent.MOUSE_ENTERED) {\n-                containsMouse = true;\n-                cachedBorderVaild = false;\n-                repaint();\n-            } else if (e.getID() == MouseEvent.MOUSE_EXITED) {\n-                containsMouse = false;\n-                cachedBorderVaild = false;\n-                repaint();\n             }\n+        }\n \n-        } \n-        \n-        if (e.getID() == MouseEvent.MOUSE_CLICKED &&\n-                SwingUtilities.isLeftMouseButton(e) && \n-                e.getClickCount() == 1) {\n+        if (e.getID() == MouseEvent.MOUSE_CLICKED\n+                && SwingUtilities.isLeftMouseButton(e)\n+                && e.getClickCount() == 1) {\n             // Trigger a gc\n-            GarbageCollectAction.get(GarbageCollectAction.class).performAction();;\n+            GarbageCollectAction.get(GarbageCollectAction.class).performAction();\n         }\n     }\n \n     /**\n-     * Shows a popup at the specified location that allows you to configure\n-     * the various options.\n+     * Shows a popup at the specified location that allows you to configure the\n+     * various options.\n      */\n     private void showPopup(int x, int y) {\n         JPopupMenu popup = new JPopupMenu();\n         JCheckBoxMenuItem cbmi = new JCheckBoxMenuItem(NbBundle.getMessage(HeapView.class, \"LBL_ShowText\"));\n         cbmi.setSelected(getShowText());\n         cbmi.addActionListener(new ActionListener() {\n             public void actionPerformed(ActionEvent e) {\n-                setShowText(((JCheckBoxMenuItem)e.getSource()).\n+                setShowText(((JCheckBoxMenuItem) e.getSource()).\n                         isSelected());\n             }\n         });\n         popup.add(cbmi);\n-        cbmi = new JCheckBoxMenuItem(NbBundle.getMessage(HeapView.class, \"LBL_DropShadow\"));\n-        cbmi.setSelected(getShowDropShadow());\n-        cbmi.addActionListener(new ActionListener() {\n-            public void actionPerformed(ActionEvent e) {\n-                setShowDropShadow(((JCheckBoxMenuItem)e.getSource()).\n-                        isSelected());\n-            }\n-        });\n-        popup.add(cbmi);\n-        cbmi = new JCheckBoxMenuItem(NbBundle.getMessage(HeapView.class, \"LBL_OverlayGrid\"));\n-        cbmi.setSelected(getTickStyle() == STYLE_OVERLAY);\n-        cbmi.addActionListener(new ActionListener() {\n-            public void actionPerformed(ActionEvent e) {\n-                int style = ((JCheckBoxMenuItem)e.getSource()).\n-                        isSelected() ? STYLE_OVERLAY : STYLE_DEFAULT;\n-                setTickStyle(style);\n-            }\n-        });\n-        popup.add(cbmi);\n         popup.show(this, x, y);\n     }\n \n-    /**\n-     * Returns the first index to start rendering from.\n-     */\n-    private int getGraphStartIndex() {\n-        if (graphFilled) {\n-            return graphIndex;\n-        } else {\n-            return 0;\n-        }\n-    }\n-\n     /**\n      * Paints the component.\n      */\n-    @Override protected void paintComponent(Graphics g) {\n-        Graphics2D g2 = (Graphics2D)g;\n+    @Override\n+    protected void paintComponent(Graphics g) {\n+        super.paintComponent(g);\n         int width = getWidth();\n         int height = getHeight();\n-        if (width - BORDER_W > 0 && height - BORDER_H > 0) {\n+\n+        if (width > 0 && height > 0) {\n             startTimerIfNecessary();\n-            updateCacheIfNecessary(width, height);\n-            paintCachedBackground(g2, width, height);\n-            g.translate(1, 2);\n-            if (containsMouse) {\n-                g.clipRect(1, 0, width - 4, height - 4);\n-            }\n-            else {\n-                g.clipRect(0, 0, width - 2, height - 4);\n-            }\n-            int innerW = width - BORDER_W;\n-            int innerH = height - BORDER_H;\n-            if (heapGrowTimer != null) {\n-                // Render the heap growing animation.\n-                Composite lastComposite = ((Graphics2D)g).getComposite();\n-                float percent = 1f - heapGrowTimer.getPercent();\n-                ((Graphics2D)g).setComposite(AlphaComposite.getInstance(AlphaComposite.SRC_OVER, percent));\n-                g.drawImage(heapGrowTimer.image, 0, 0, null);\n-                ((Graphics2D)g).setComposite(lastComposite);\n-            }\n-            paintTicks(g2, innerW, innerH);\n-            if (getTickStyle() == STYLE_OVERLAY) {\n-                g2.drawImage(getGridOverlayImage(), 0, 0, null);\n-            }\n+            Graphics2D g2 = (Graphics2D) g;\n+            g2.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);\n+            // Fill background\n+            g2.setPaint(BACKGROUND_COLOR);\n+            g2.fillRect(0, 0, width + 1, height + 1);\n+            // Draw samples\n+            g2.setPaint(CHART_COLOR);\n+            paintSamples(g2, width, height);\n+            // Draw text if enabled\n             if (getShowText()) {\n-                if (getShowDropShadow()) {\n-                    paintDropShadowText(g, innerW, innerH);\n-                } else {\n-                    g.setColor(textColor);\n-                    paintText(g, innerW, innerH);\n-                }\n+                paintText(g2, width, height);\n             }\n-            g.translate(-1, -2);\n         } else {\n             stopTimerIfNecessary();\n-            // To honor opaque contract, fill in the background\n-            g.setColor(getBackground());\n-            g.fillRect(0, 0, width, height);\n-        }\n-    }\n-    \n-    private void paintTicks(Graphics2D g, int width, int height) {\n-        if (graphIndex > 0 || graphFilled) {\n-            int index = getGraphStartIndex();\n-            int x = 0;\n-            if (!graphFilled) {\n-                x = width - graphIndex;\n-            }\n-            float[] localGraph = graph;\n-            if (localGraph == null) {\n-                return;\n-            }\n-            float min = localGraph[index];\n-            index = (index + 1) % localGraph.length;\n-            while (index != graphIndex) {\n-                min = Math.min(min, localGraph[index]);\n-                index = (index + 1) % localGraph.length;\n-            }\n-            int minHeight = (int)(min * (float)height);\n-            if (minHeight > 0) {\n-               g.drawImage(tickGradientImage, x, height - minHeight, width, height,\n-                        x, height - minHeight, width, height, null);\n-            }\n-            index = getGraphStartIndex();\n-            do {\n-                int tickHeight = (int)(localGraph[index] * (float)height);\n-                if (tickHeight > minHeight) {\n-                    g.drawImage(tickGradientImage, x, height - tickHeight, x + 1, height - minHeight,\n-                            x, height - tickHeight, x + 1, height - minHeight, null);\n-                }\n-                index = (index + 1) % localGraph.length;\n-                x++;\n-            } while (index != graphIndex);\n         }\n     }\n \n     /**\n-     * Renders the text.\n+     * Renders the text using an optional drop shadow.\n      */\n-    private void paintText(Graphics g, int w, int h) {\n+    private void paintText(Graphics2D g, int w, int h) {\n         g.setFont(getFont());\n         String text = getHeapSizeText();\n         FontMetrics fm = g.getFontMetrics();\n         int textWidth = fm.stringWidth(text);\n-        g.drawString(text, (w - maxTextWidth) / 2 + (maxTextWidth - textWidth), \n-                h / 2 + fm.getAscent() / 2 - 2);\n+        int x = (w - maxTextWidth) / 2 + (maxTextWidth - textWidth);\n+        int y = h / 2 + fm.getAscent() / 2 - 2;\n+        g.setColor(TEXT_COLOR);\n+        g.drawString(text, x, y);\n     }\n \n-    /**\n-     * Renders the text using a drop shadow.\n-     */\n-    private void paintDropShadowText(Graphics g, final int w, final int h) {\n-        BufferedImage dsi = dropShadowImage;\n-        BufferedImage tsi = textImage;\n-        if (dsi != null && tsi != null) {\n-            // And finally copy it.\n-            Graphics2D blurryImageG = dsi.createGraphics();\n-            blurryImageG.setComposite(AlphaComposite.Clear);\n-            blurryImageG.fillRect(0, 0, w, h);\n-            blurryImageG.setComposite(AlphaComposite.SrcOver);\n-            blurryImageG.drawImage(tsi, blur, SHIFT_X, SHIFT_Y);\n-            blurryImageG.setColor(textColor);\n-            blurryImageG.setFont(getFont());\n-\n-            // Step 3: render the text again on top.\n-            paintText(blurryImageG, w, h);\n-            blurryImageG.dispose();\n-            g.drawImage(dsi, 0, 0, null);\n-        } else {\n-            class InitTextAndDropShadow implements Runnable {\n-                @Override\n-                public void run() {\n-                    BufferedImage ti = new BufferedImage(w, h, BufferedImage.TYPE_INT_ARGB);\n-                    BufferedImage ds = new BufferedImage(w, h, BufferedImage.TYPE_INT_ARGB);\n-                    // Step 1: render the text.\n-                    Graphics2D textImageG = ti.createGraphics();\n-                    textImageG.setComposite(AlphaComposite.Clear);\n-                    textImageG.fillRect(0, 0, w, h);\n-                    textImageG.setComposite(AlphaComposite.SrcOver);\n-                    textImageG.setColor(textBlurColor);\n-                    paintText(textImageG, w, h);\n-                    textImageG.dispose();\n-\n-                    textImage = ti;\n-                    dropShadowImage = ds;\n-                    repaint();\n-                }\n-            }\n-            RP.post(new InitTextAndDropShadow());\n-        }\n-    }\n-    \n     private String getHeapSizeText() {\n         return heapSizeText;\n     }\n-    \n-    /**\n-     * Paints the grid on top of the ticks.\n-     */\n-    private void paintGridOverlay(Graphics2D g, int w, int h) {\n-        int numCells = GRID_COLORS.length / 2;\n-        int cellSize = (h - numCells - 1) / numCells;\n-        int c1 = 0xD0CCBC;\n-        int c2 = 0xEAE7D7;\n-        g.setPaint(new GradientPaint(\n-                0, 0, new Color((c1 >> 16) & 0xFF, (c1 >> 8) & 0xFF, c1 & 0xFF, 0x30),\n-                0, h, new Color((c2 >> 16) & 0xFF, (c2 >> 8) & 0xFF, c2 & 0xFF, 0x40)));\n-        for (int x = 0; x < w; x += cellSize + 1) {\n-            g.fillRect(x, 0, 1, h);\n-        }\n-        for (int y = h - cellSize - 1; y >= 0; y -= (cellSize + 1)) {\n-            g.fillRect(0, y, w, 1);\n-        }\n-    }\n \n-    private void paintCachedBackground(Graphics2D g, int w, int h) {\n-        if (bgImage != null) {\n-            g.drawImage(bgImage, 0, 0, null);\n-        }\n-    }\n-    \n-    private void paintBackgroundTiles(Graphics2D g, int w, int h) {\n-        g.translate(1, 2);\n-        w -= BORDER_W;\n-        h -= BORDER_H;\n-        int numCells = GRID_COLORS.length / 2;\n-        int cellSize = (h - numCells - 1) / numCells;\n-        for (int i = 0; i < numCells; i++) {\n-            int colorIndex = i;\n-            int y = h - cellSize * (i + 1) - i;\n-            int x = 1;\n-            g.setPaint(new GradientPaint(0, y, GRID_COLORS[colorIndex * 2],\n-                    0, y + cellSize - 1, GRID_COLORS[colorIndex * 2 + 1]));\n-            while (x < w) {\n-                int endX = Math.min(w, x + cellSize);\n-                g.fillRect(x, y, endX - x, cellSize);\n-                x = endX + 1;\n-            }\n-            y += cellSize + 1;\n-        }\n-        g.translate(-1, -2);\n-    }\n-    \n-    private void paintBackground(Graphics2D g, int w, int h) {\n-        g.setPaint(new GradientPaint(0, 0, background1Color,\n-                0, h, background2Color));\n-        g.fillRect(0, 0, w, h);\n-    }\n-    \n-    private void paintBorder(Graphics g, int w, int h) {\n-        // Draw the border\n-        if (containsMouse) {\n-            g.setColor(border3Color);\n-            g.drawRect(0, 0, w - 1, h - 1);\n-            g.drawRect(1, 1, w - 3, h - 3);\n-        }\n-        else {\n-            g.setColor(border1Color);\n-            g.drawRect(0, 0, w - 1, h - 2);\n-            g.setColor(border2Color);\n-            g.fillRect(1, 1, w - 2, 1);\n-            g.setColor(border3Color);\n-            g.fillRect(0, h - 1, w, 1);\n-        }\n-    }\n-    \n-    private void updateCacheIfNecessary(int w, int h) {\n-        if (cachedWidth != w || cachedHeight != h || !cachedBorderVaild) {\n-            cachedWidth = w;\n-            cachedHeight = h;\n-            cachedBorderVaild = true;\n-            updateCache(w, h);\n-        }\n-    }\n-    \n-    private Image getGridOverlayImage() {\n-        if (gridOverlayImage == null) {\n-            gridOverlayImage = new BufferedImage(\n-                    getInnerWidth(), getInnerHeight(),\n-                    BufferedImage.TYPE_INT_ARGB);\n-            Graphics2D g = gridOverlayImage.createGraphics();\n-            paintGridOverlay(g, getInnerWidth(), getInnerHeight());\n-            g.dispose();\n-        }\n-        return gridOverlayImage;\n-    }\n-\n-    /**\n-     * Recreates the various state information needed for rendering.\n-     */\n-    private void updateCache(int w, int h) {\n-        disposeImages();\n-        textImage = null;\n-        dropShadowImage = null;\n-        bgImage = createImage(w, h);\n-        if (bgImage == null) {\n-            return;\n-        }\n-        Graphics2D imageG = (Graphics2D)bgImage.getGraphics();\n-        paintBackground(imageG, w, h);\n-        paintBackgroundTiles(imageG, w, h);\n-        paintBorder(imageG, w, h);\n-        imageG.dispose();\n-        w -= BORDER_W;\n-        h -= BORDER_H;\n-        if (graph == null || graph.length != w) {\n-            graph = new float[w];\n-            graphFilled = false;\n-            graphIndex = 0;\n-        }\n-        GradientPaint tickGradient = new GradientPaint(0, h, minTickColor,\n-                w, 0, maxTickColor);\n-        tickGradientImage = createImage(w, h);\n-        imageG = (Graphics2D)tickGradientImage.getGraphics();\n-        imageG.setPaint(tickGradient);\n-        imageG.fillRect(0, 0, w, h);\n-        imageG.dispose();\n-        if (gridOverlayImage != null) {\n-            gridOverlayImage.flush();\n-            gridOverlayImage = null;\n-        }\n-    }\n-    \n     /**\n      * Invoked when component removed from a heavy weight parent. Stops the\n      * timer.\n      */\n-    @Override public void removeNotify() {\n+    @Override\n+    public void removeNotify() {\n         super.removeNotify();\n         stopTimerIfNecessary();\n     }\n-    \n+\n     /**\n      * Restarts the timer.\n      */\n     private void startTimerIfNecessary() {\n-        if (!AUTOMATIC_REFRESH)\n+        if (!AUTOMATIC_REFRESH) {\n             return;\n-        \n+        }\n         if (updateTimer == null) {\n-            updateTimer = new Timer(TICK, new ActionHandler());\n+            updateTimer = new Timer(TICK, new ActionListener() {\n+                @Override\n+                public void actionPerformed(ActionEvent e) {\n+                    update();\n+                }\n+            });\n             updateTimer.setRepeats(true);\n             updateTimer.start();\n         }\n     }\n-    \n+\n     /**\n      * Stops the timer.\n      */\n     private void stopTimerIfNecessary() {\n         if (updateTimer != null) {\n-            graph = null;\n-            graphFilled = false;\n             updateTimer.stop();\n             updateTimer = null;\n             lastTotal = 0;\n-            disposeImages();\n-            cachedHeight = cachedHeight = -1;\n-            if (heapGrowTimer != null) {\n-                heapGrowTimer.stop();\n-                heapGrowTimer = null;\n-            }\n+            Arrays.fill(graph, 0);\n+            heapSizeText = \"\";\n         }\n     }\n \n-    private void disposeImages() {\n-        if (bgImage != null) {\n-            bgImage.flush();\n-            bgImage = null;\n-        }\n-        if (textImage != null) {\n-            textImage.flush();\n-            textImage = null;\n-        }\n-        if (dropShadowImage != null) {\n-            dropShadowImage.flush();\n-            dropShadowImage = null;\n-        }\n-        if (tickGradientImage != null) {\n-            tickGradientImage.flush();\n-            tickGradientImage = null;\n-        }\n-        if (gridOverlayImage != null) {\n-            gridOverlayImage.flush();\n-            gridOverlayImage = null;\n-        }\n-    }\n-    \n     /**\n      * Invoked when the update timer fires. Updates the necessary data\n      * structures and triggers repaints.\n      */\n     private void update() {\n-        if (!isShowing()) {\n+        if (isShowing()) {\n+            Runtime r = Runtime.getRuntime();\n+            long total = r.totalMemory();\n+            long used = total - r.freeMemory();\n+            graph[graphIndex] = used;\n+            lastTotal = total;\n+            ++graphIndex;\n+            if (graphIndex >= GRAPH_COUNT) {\n+                graphIndex = 0;\n+            }\n+            heapSizeText = format.format(\n+                    new Object[]{(double) used / (1024.0 * 1024.0), (double) total / (1024.0 * 1024.0)});\n+            repaint();\n+        } else {\n             // Either we've become invisible, or one of our ancestors has.\n             // Stop the timer and bale. Next paint will trigger timer to\n             // restart.\n             stopTimerIfNecessary();\n-            return;\n-        }\n-        Runtime r = Runtime.getRuntime();\n-        long total = r.totalMemory();\n-        float[] localGraph = graph;\n-        if (localGraph == null) {\n-            return;\n-        }\n-        if (total != lastTotal) {\n-            if (lastTotal != 0) {\n-                // Total heap size has changed, start an animation.\n-                startHeapAnimate();\n-                // Readjust the graph size based on the new max.\n-                int index = getGraphStartIndex();\n-                do {\n-                    localGraph[index] = (float)(((double)localGraph[index] *\n-                            (double)lastTotal) / (double)total);\n-                    index = (index + 1) % localGraph.length;\n-                } while (index != graphIndex);\n-            }\n-            lastTotal = total;\n-        }\n-        if (heapGrowTimer == null) {\n-            // Not animating a heap size change, update the graph data and text.\n-            long used = total - r.freeMemory();\n-            localGraph[graphIndex] = (float)((double)used / (double)total);\n-            graphIndex = (graphIndex + 1) % localGraph.length;\n-            if (graphIndex == 0) {\n-                graphFilled = true;\n-            }\n-            heapSizeText = format.format(\n-                    new Object[] { new Double((double)used / 1024 / 1024),\n-                                   new Double((double)total / 1024 / 1024) });\n-        }\n-        repaint();\n-    }\n-    \n-    private void startHeapAnimate() {\n-        if (heapGrowTimer == null) {\n-            heapGrowTimer = new HeapGrowTimer();\n-            heapGrowTimer.start();\n-        }\n-    }\n-    \n-    private void stopHeapAnimate() {\n-        if (heapGrowTimer != null) {\n-            heapGrowTimer.stop();\n-            heapGrowTimer = null;\n         }\n     }\n \n-    private int getInnerWidth() {\n-        return getWidth() - BORDER_W;\n-    }\n-\n-    private int getInnerHeight() {\n-        return getHeight() - BORDER_H;\n-    }\n-\n-    \n-    private final class ActionHandler implements ActionListener {\n-        public void actionPerformed(ActionEvent e) {\n-            update();\n-        }\n-    }\n-    \n-    \n-    private final class HeapGrowTimer extends Timer {\n-        private final long startTime;\n-        private float percent;\n-        BufferedImage image;\n-        \n-        HeapGrowTimer() {\n-            super(30, null);\n-            setRepeats(true);\n-            startTime = System.currentTimeMillis();\n-            percent = 0f;\n-            int w = getWidth() - BORDER_W;\n-            int h = getHeight() - BORDER_H;\n-            image = new BufferedImage(w, h, BufferedImage.TYPE_INT_ARGB);\n-            Graphics2D g = image.createGraphics();\n-            paintTicks(g, w, h);\n-            g.dispose();\n-        }\n-        \n-        public float getPercent() {\n-            return percent;\n-        }\n-        \n-        @Override protected void fireActionPerformed(ActionEvent e) {\n-            long time = System.currentTimeMillis();\n-            long delta = Math.max(0L, time - startTime);\n-            if (delta > HEAP_GROW_ANIMATE_TIME) {\n-                stopHeapAnimate();\n-            } else {\n-                percent = (float)delta / (float)HEAP_GROW_ANIMATE_TIME;\n-                repaint();\n-            }\n-        }\n+    /**\n+     * Draw the graph with the heap samples. It is a simple area chart.\n+     *\n+     * @param g Where to draw\n+     * @param width The width of the chart\n+     * @param height The height of the chart\n+     */\n+    private void paintSamples(Graphics2D g, int width, int height) {\n+        Path2D path = new Path2D.Double();\n+        path.moveTo(0, height);\n+        for (int i = 0; i < GRAPH_COUNT; ++i) {\n+            int index = (i + graphIndex) % GRAPH_COUNT;\n+            double x = (double) i / (double) (GRAPH_COUNT - 1) * (double) width;\n+            double y = (double) height * (1.0 - (double) graph[index] / (double) lastTotal);\n+            path.lineTo(x, y);\n+        }\n+        path.lineTo(width, height);\n+        path.closePath();\n+        g.fill(path);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0e0d715c8271cda6867e5acb26dca7452195941b"}, "originalPosition": 1092}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDgwMTk1OA==", "bodyText": "For this one, trying using 0x2e90e8 instead. That's the lighter blue color from the NetBeans logo cube. (Might also want to grep the codebase for customizations of nb.heapview.maxtick.color, and change it there as well.)", "url": "https://github.com/apache/netbeans/pull/1918#discussion_r374801958", "createdAt": "2020-02-04T17:05:18Z", "author": {"login": "eirikbakke"}, "path": "platform/openide.actions/src/org/openide/actions/HeapView.java", "diffHunk": "@@ -47,301 +42,104 @@\n import javax.swing.UIManager;\n import org.openide.util.NbBundle;\n import org.openide.util.NbPreferences;\n-import org.openide.util.RequestProcessor;\n \n /**\n  *\n  * @author sky, radim\n  */\n class HeapView extends JComponent {\n+\n     private static final boolean AUTOMATIC_REFRESH = System.getProperty(\"org.netbeans.log.startup\") == null;\n \n-    /**\n-     * Style for overlay on top of grid.\n-     */\n-    private static final int STYLE_DEFAULT = 0;\n-    \n-    /**\n-     * Grid overlayed on top of heap. This is the default.\n-     */\n-    private static final int STYLE_OVERLAY = 1;\n-    \n     /*\n      * How often the display is updated.\n      */\n     private static final int TICK = 1500;\n-    \n-    /**\n-     * Time (in ms) to animate heap growing.\n-     */\n-    private static final int HEAP_GROW_ANIMATE_TIME = 1000;\n-    \n-    /**\n-     * Width of the border.\n-     */\n-    private static final int BORDER_W = 2;\n-    \n-    /**\n-     * Height of the border area.\n-     */\n-    private static final int BORDER_H = 4;\n-    \n-    /**\n-     * Colors for the grid. This is alternating pairs for a linear gradient.\n-     */\n-    private static final Color[] GRID_COLORS = new Color[8];\n-    \n-    /**\n-     * Border color.\n-     */\n-    private static Color border1Color;\n \n     /**\n-     * Border color of line below the top.\n+     * Foreground color for the chart.\n      */\n-    private static Color border2Color;\n+    private static final Color CHART_COLOR;\n \n-    private static Color border3Color;\n-    \n     /**\n-     * Start color for the tick gradient.\n+     * Color for text.\n      */\n-    private static Color minTickColor;\n+    private static final Color TEXT_COLOR;\n \n     /**\n-     * End color for the tick gradient.\n+     * Color for the background.\n      */\n-    private static Color maxTickColor;\n+    private static final Color BACKGROUND_COLOR;\n \n     /**\n-     * Color for the text before blurred.\n+     * Number of samples to retain in history.\n      */\n-    private static Color textBlurColor;\n+    private static final int GRAPH_COUNT = 100;\n     \n     /**\n-     * Color for text drawn on top of blurred text.\n+     * Key for the Show Text preference.\n      */\n-    private static Color textColor;\n-\n-    /**\n-     * Start color for the background gradient.\n-     */\n-    private static Color background1Color;\n-\n-    /**\n-     * End color for the background gradient.\n-     */\n-    private static Color background2Color;\n-    \n-    /**\n-     * Size used for Kernel used to generate drop shadow.\n-     */\n-    private static final int KERNEL_SIZE = 3;\n-\n-    /**\n-     * Factor used for Kernel used to generate drop shadow.\n-     */\n-    private static final float BLUR_FACTOR = 0.1f;\n-    \n-    /**\n-     * How far to shift the drop shadow along the horizontal axis.\n-     */\n-    private static final int SHIFT_X = 0;\n-\n-    /**\n-     * How far to shift the drop shadow along the vertical axis.\n-     */\n-    private static final int SHIFT_Y = 1;\n+    private static final String SHOW_TEXT = \"showText\";\n \n     static {\n         //init colors\n-        Color c = UIManager.getColor( \"nb.heapview.border1\" ); //NOI18N\n-        if( null == c )\n-            c = new Color(0xA6A295);\n-        border1Color = c;\n-\n-        c = UIManager.getColor( \"nb.heapview.border2\" ); //NOI18N\n-        if( null == c )\n-            c = new Color(0xC0BCAD);\n-        border2Color = c;\n-\n-        c = UIManager.getColor( \"nb.heapview.border3\" ); //NOI18N\n-        if( null == c )\n-            c = Color.WHITE;\n-        border3Color = c;\n-\n-        c = UIManager.getColor( \"nb.heapview.mintick.color\" ); //NOI18N\n-        if( null == c )\n-            c = new Color(0xC7D6AD);\n-        minTickColor = c;\n-\n-        c = UIManager.getColor( \"nb.heapview.maxtick.color\" ); //NOI18N\n-        if( null == c )\n+        Color c = UIManager.getColor(\"nb.heapview.maxtick.color\"); //NOI18N\n+        if (null == c) {\n             c = new Color(0x615d0f);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0e0d715c8271cda6867e5acb26dca7452195941b"}, "originalPosition": 178}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDgwMzE5OA==", "bodyText": "For this one, use 0xCEDBE6 instead. That will go well with the other suggested color change. (It's the light blueish shadow in the NetBeans logo cube.)\nPerhaps also rename this one to nb.heapview.background (without the 1 at the end). This will nullify any LAF customizations from the past, but with the updated branding-consistent colors, that should be fine. New tweaks can be made e.g. for FlatLAF based on the blueish on-brand colors.", "url": "https://github.com/apache/netbeans/pull/1918#discussion_r374803198", "createdAt": "2020-02-04T17:07:30Z", "author": {"login": "eirikbakke"}, "path": "platform/openide.actions/src/org/openide/actions/HeapView.java", "diffHunk": "@@ -47,301 +42,104 @@\n import javax.swing.UIManager;\n import org.openide.util.NbBundle;\n import org.openide.util.NbPreferences;\n-import org.openide.util.RequestProcessor;\n \n /**\n  *\n  * @author sky, radim\n  */\n class HeapView extends JComponent {\n+\n     private static final boolean AUTOMATIC_REFRESH = System.getProperty(\"org.netbeans.log.startup\") == null;\n \n-    /**\n-     * Style for overlay on top of grid.\n-     */\n-    private static final int STYLE_DEFAULT = 0;\n-    \n-    /**\n-     * Grid overlayed on top of heap. This is the default.\n-     */\n-    private static final int STYLE_OVERLAY = 1;\n-    \n     /*\n      * How often the display is updated.\n      */\n     private static final int TICK = 1500;\n-    \n-    /**\n-     * Time (in ms) to animate heap growing.\n-     */\n-    private static final int HEAP_GROW_ANIMATE_TIME = 1000;\n-    \n-    /**\n-     * Width of the border.\n-     */\n-    private static final int BORDER_W = 2;\n-    \n-    /**\n-     * Height of the border area.\n-     */\n-    private static final int BORDER_H = 4;\n-    \n-    /**\n-     * Colors for the grid. This is alternating pairs for a linear gradient.\n-     */\n-    private static final Color[] GRID_COLORS = new Color[8];\n-    \n-    /**\n-     * Border color.\n-     */\n-    private static Color border1Color;\n \n     /**\n-     * Border color of line below the top.\n+     * Foreground color for the chart.\n      */\n-    private static Color border2Color;\n+    private static final Color CHART_COLOR;\n \n-    private static Color border3Color;\n-    \n     /**\n-     * Start color for the tick gradient.\n+     * Color for text.\n      */\n-    private static Color minTickColor;\n+    private static final Color TEXT_COLOR;\n \n     /**\n-     * End color for the tick gradient.\n+     * Color for the background.\n      */\n-    private static Color maxTickColor;\n+    private static final Color BACKGROUND_COLOR;\n \n     /**\n-     * Color for the text before blurred.\n+     * Number of samples to retain in history.\n      */\n-    private static Color textBlurColor;\n+    private static final int GRAPH_COUNT = 100;\n     \n     /**\n-     * Color for text drawn on top of blurred text.\n+     * Key for the Show Text preference.\n      */\n-    private static Color textColor;\n-\n-    /**\n-     * Start color for the background gradient.\n-     */\n-    private static Color background1Color;\n-\n-    /**\n-     * End color for the background gradient.\n-     */\n-    private static Color background2Color;\n-    \n-    /**\n-     * Size used for Kernel used to generate drop shadow.\n-     */\n-    private static final int KERNEL_SIZE = 3;\n-\n-    /**\n-     * Factor used for Kernel used to generate drop shadow.\n-     */\n-    private static final float BLUR_FACTOR = 0.1f;\n-    \n-    /**\n-     * How far to shift the drop shadow along the horizontal axis.\n-     */\n-    private static final int SHIFT_X = 0;\n-\n-    /**\n-     * How far to shift the drop shadow along the vertical axis.\n-     */\n-    private static final int SHIFT_Y = 1;\n+    private static final String SHOW_TEXT = \"showText\";\n \n     static {\n         //init colors\n-        Color c = UIManager.getColor( \"nb.heapview.border1\" ); //NOI18N\n-        if( null == c )\n-            c = new Color(0xA6A295);\n-        border1Color = c;\n-\n-        c = UIManager.getColor( \"nb.heapview.border2\" ); //NOI18N\n-        if( null == c )\n-            c = new Color(0xC0BCAD);\n-        border2Color = c;\n-\n-        c = UIManager.getColor( \"nb.heapview.border3\" ); //NOI18N\n-        if( null == c )\n-            c = Color.WHITE;\n-        border3Color = c;\n-\n-        c = UIManager.getColor( \"nb.heapview.mintick.color\" ); //NOI18N\n-        if( null == c )\n-            c = new Color(0xC7D6AD);\n-        minTickColor = c;\n-\n-        c = UIManager.getColor( \"nb.heapview.maxtick.color\" ); //NOI18N\n-        if( null == c )\n+        Color c = UIManager.getColor(\"nb.heapview.maxtick.color\"); //NOI18N\n+        if (null == c) {\n             c = new Color(0x615d0f);\n-        maxTickColor = c;\n+        }\n+        CHART_COLOR = c;\n \n-        c = UIManager.getColor( \"nb.heapview.textblur\" ); //NOI18N\n-        if( null == c )\n+        c = UIManager.getColor(\"nb.heapview.foreground\"); //NOI18N\n+        if (null == c) {\n             c = Color.WHITE;\n-        textBlurColor = c;\n+        }\n+        TEXT_COLOR = c;\n \n-        c = UIManager.getColor( \"nb.heapview.foreground\" ); //NOI18N\n-        if( null == c )\n-            c = Color.WHITE;\n-        textColor = c;\n-\n-        c = UIManager.getColor( \"nb.heapview.background1\" ); //NOI18N\n-        if( null == c )\n-            c = new Color(0xD0CCBC);\n-        background1Color = c;\n-\n-        c = UIManager.getColor( \"nb.heapview.background2\" ); //NOI18N\n-        if( null == c )\n-            c = new Color(0xEAE7D7);\n-        background2Color = c;\n-\n-        c = UIManager.getColor( \"nb.heapview.grid1.start\" );\n-        if( null == c )\n-            c = new Color(0xE3DFCF);\n-        GRID_COLORS[0] = c;\n-\n-        c = UIManager.getColor( \"nb.heapview.grid1.end\" );\n-        if( null == c )\n-            c = new Color(0xE7E4D3);\n-        GRID_COLORS[1] = c;\n-\n-        c = UIManager.getColor( \"nb.heapview.grid2.start\" );\n-        if( null == c )\n-            c = new Color(0xDAD7C6);\n-        GRID_COLORS[2] = c;\n-\n-        c = UIManager.getColor( \"nb.heapview.grid2.end\" );\n-        if( null == c )\n-            c = new Color(0xDFDCCB);\n-        GRID_COLORS[3] = c;\n-\n-        c = UIManager.getColor( \"nb.heapview.grid3.start\" );\n-        if( null == c )\n-            c = new Color(0xD3CFBF);\n-        GRID_COLORS[4] = c;\n-\n-        c = UIManager.getColor( \"nb.heapview.grid3.end\" );\n-        if( null == c )\n-            c = new Color(0xD7D3C3);\n-        GRID_COLORS[5] = c;\n-\n-        c = UIManager.getColor( \"nb.heapview.grid4.start\" );\n-        if( null == c )\n-            c = new Color(0xCECABA);\n-        GRID_COLORS[6] = c;\n-\n-        c = UIManager.getColor( \"nb.heapview.grid4.end\" );\n-        if( null == c )\n-            c = new Color(0xD0CCBC);\n-        GRID_COLORS[7] = c;\n+        c = UIManager.getColor(\"nb.heapview.background1\"); //NOI18N\n+        if (null == c) {\n+            c = new Color(0xC0BCAC);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0e0d715c8271cda6867e5acb26dca7452195941b"}, "originalPosition": 248}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzUzMjkyMTYw", "url": "https://github.com/apache/netbeans/pull/1918#pullrequestreview-353292160", "createdAt": "2020-02-04T20:51:55Z", "commit": {"oid": "0e0d715c8271cda6867e5acb26dca7452195941b"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNFQyMDo1MTo1NVrOFljCXw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNFQyMDo1MTo1NVrOFljCXw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDkxNTY3OQ==", "bodyText": "Probably better use UIManager.getFont(\"Label.font\") instead of new JLabel().getFont().", "url": "https://github.com/apache/netbeans/pull/1918#discussion_r374915679", "createdAt": "2020-02-04T20:51:55Z", "author": {"login": "DevCharly"}, "path": "platform/openide.actions/src/org/openide/actions/HeapView.java", "diffHunk": "@@ -350,60 +148,39 @@ public HeapView() {\n         setToolTipText(NbBundle.getMessage(GarbageCollectAction.class, \"CTL_GC\"));\n         updateUI();\n     }\n-    \n+\n     /**\n-     * Overriden to return true, GCComponent paints in its entire bounds in\n-     * an opaque manner.\n+     * Overridden to return true, GCComponent paints in its entire bounds in an\n+     * opaque manner.\n      */\n-    @Override public boolean isOpaque() {\n+    @Override\n+    public boolean isOpaque() {\n         return true;\n     }\n-    \n+\n     /**\n      * Updates the look and feel for this component.\n      */\n-    @Override public void updateUI() {\n-        Font f = new JLabel().getFont();\n-        f = new Font(f.getName(), Font.BOLD, f.getSize());\n+    @Override\n+    public void updateUI() {\n+        Font f = new JLabel().getFont().deriveFont(Font.BOLD);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0e0d715c8271cda6867e5acb26dca7452195941b"}, "originalPosition": 392}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f7136ca96c0a40f7ad86e897ba51d455c6feb39c", "author": {"user": {"login": "pedro-w", "name": "Peter Hull"}}, "url": "https://github.com/apache/netbeans/commit/f7136ca96c0a40f7ad86e897ba51d455c6feb39c", "committedDate": "2020-02-05T10:25:36Z", "message": "Make changes identified in code review"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f45c592ba8d5189812c194acc23eb5be47d28c6d", "author": {"user": {"login": "pedro-w", "name": "Peter Hull"}}, "url": "https://github.com/apache/netbeans/commit/f45c592ba8d5189812c194acc23eb5be47d28c6d", "committedDate": "2020-02-05T11:15:18Z", "message": "Update keys for LAF properties\n\nRenamed background1 to background.\nRenamed maxtick.color to chart.\nRemoved unused properties.\nAdded a class comment to list the properties."}}]}}}, "rateLimit": {"limit": 5000, "remaining": 153, "cost": 1, "resetAt": "2021-10-28T17:48:14Z"}}}