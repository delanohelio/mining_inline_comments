{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzk2MTA0Nzk1", "number": 2055, "reviewThreads": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQwOTowMjoyM1rODzn4eQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQwOTowMjoyM1rODzn4eQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU1NDU3NDAxOnYy", "diffSide": "RIGHT", "path": "java/debugger.jpda/src/org/netbeans/modules/debugger/jpda/breakpoints/LineBreakpointImpl.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQwOTowMjoyM1rOGIKdWA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOFQxMDo0MTozNlrOGNN5IQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTIxMzE0NA==", "bodyText": "It's better to use Comparator.comparingLong", "url": "https://github.com/apache/netbeans/pull/2055#discussion_r411213144", "createdAt": "2020-04-20T09:02:23Z", "author": {"login": "entlicher"}, "path": "java/debugger.jpda/src/org/netbeans/modules/debugger/jpda/breakpoints/LineBreakpointImpl.java", "diffHunk": "@@ -337,32 +343,35 @@ protected void classLoaded (List<ReferenceType> referenceTypes) {\n                     continue;\n                 }\n                 // Submit the breakpoint for the lowest location on the line only:\n-                Location location = locations.get(0);\n-                com.sun.jdi.Method m0 = location.method();\n-                for (int li = 1; li < locations.size(); li++) {\n-                    Location l = locations.get(li);\n-                    if (l.codeIndex() < location.codeIndex()) {\n-                        if (l.method().equals(m0)) {\n-                            // Assure that we're still in the same method\n-                            location = l;\n-                        }\n-                    }\n-                }\n+                /* If location contains multiple event breakpoint for the same line \n+                (e.g lambda expression along with any function calling \n+                map(n -> foo(\n+                        boo(n)))) \n+                then take the lowest location from each type of event*/\n+                Collection<Location> lowestLocationList = locations\n+                        .stream()\n+                        .collect(groupingBy(loc->loc.method().toString(),\n+                                LinkedHashMap::new,\n+                                collectingAndThen(minBy(Comparator.comparingDouble(Location::codeIndex)), ", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4004978c79eb78532ea14d5923f4796a1e31a47b"}, "originalPosition": 54}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTMyMzM3MA==", "bodyText": "comments addressed.", "url": "https://github.com/apache/netbeans/pull/2055#discussion_r411323370", "createdAt": "2020-04-20T12:06:05Z", "author": {"login": "singh-akhilesh"}, "path": "java/debugger.jpda/src/org/netbeans/modules/debugger/jpda/breakpoints/LineBreakpointImpl.java", "diffHunk": "@@ -337,32 +343,35 @@ protected void classLoaded (List<ReferenceType> referenceTypes) {\n                     continue;\n                 }\n                 // Submit the breakpoint for the lowest location on the line only:\n-                Location location = locations.get(0);\n-                com.sun.jdi.Method m0 = location.method();\n-                for (int li = 1; li < locations.size(); li++) {\n-                    Location l = locations.get(li);\n-                    if (l.codeIndex() < location.codeIndex()) {\n-                        if (l.method().equals(m0)) {\n-                            // Assure that we're still in the same method\n-                            location = l;\n-                        }\n-                    }\n-                }\n+                /* If location contains multiple event breakpoint for the same line \n+                (e.g lambda expression along with any function calling \n+                map(n -> foo(\n+                        boo(n)))) \n+                then take the lowest location from each type of event*/\n+                Collection<Location> lowestLocationList = locations\n+                        .stream()\n+                        .collect(groupingBy(loc->loc.method().toString(),\n+                                LinkedHashMap::new,\n+                                collectingAndThen(minBy(Comparator.comparingDouble(Location::codeIndex)), ", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTIxMzE0NA=="}, "originalCommit": {"oid": "4004978c79eb78532ea14d5923f4796a1e31a47b"}, "originalPosition": 54}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjUxMjI4OQ==", "bodyText": "Please squash the commits before merging", "url": "https://github.com/apache/netbeans/pull/2055#discussion_r416512289", "createdAt": "2020-04-28T10:41:36Z", "author": {"login": "arusinha"}, "path": "java/debugger.jpda/src/org/netbeans/modules/debugger/jpda/breakpoints/LineBreakpointImpl.java", "diffHunk": "@@ -337,32 +343,35 @@ protected void classLoaded (List<ReferenceType> referenceTypes) {\n                     continue;\n                 }\n                 // Submit the breakpoint for the lowest location on the line only:\n-                Location location = locations.get(0);\n-                com.sun.jdi.Method m0 = location.method();\n-                for (int li = 1; li < locations.size(); li++) {\n-                    Location l = locations.get(li);\n-                    if (l.codeIndex() < location.codeIndex()) {\n-                        if (l.method().equals(m0)) {\n-                            // Assure that we're still in the same method\n-                            location = l;\n-                        }\n-                    }\n-                }\n+                /* If location contains multiple event breakpoint for the same line \n+                (e.g lambda expression along with any function calling \n+                map(n -> foo(\n+                        boo(n)))) \n+                then take the lowest location from each type of event*/\n+                Collection<Location> lowestLocationList = locations\n+                        .stream()\n+                        .collect(groupingBy(loc->loc.method().toString(),\n+                                LinkedHashMap::new,\n+                                collectingAndThen(minBy(Comparator.comparingDouble(Location::codeIndex)), ", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTIxMzE0NA=="}, "originalCommit": {"oid": "4004978c79eb78532ea14d5923f4796a1e31a47b"}, "originalPosition": 54}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 617, "cost": 1, "resetAt": "2021-11-12T11:18:39Z"}}}