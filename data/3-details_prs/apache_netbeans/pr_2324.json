{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDcyMDMzNzc4", "number": 2324, "title": "Adding support for workspace/symbol to both the LSP client and Java LSP server.", "bodyText": "\u2026SP server.\nNeeds to eagerly start the servers (so that they can provide outputs).", "createdAt": "2020-08-22T20:00:29Z", "url": "https://github.com/apache/netbeans/pull/2324", "merged": true, "mergeCommit": {"oid": "c954f48dbad0e69b162036f0ce72ae3aaa6a8002"}, "closed": true, "closedAt": "2020-11-17T21:16:34Z", "author": {"login": "jlahoda"}, "timelineItems": {"totalCount": 36, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdBTs1yAH2gAyNDcyMDMzNzc4OjE0MmI1OTM2OTE2YjMwMjcyOTVhZDg4OWYyMzI3NzBiMDA4NzBmZjQ=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdj0CbZAFqTU0NjA2OTM4Mw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "142b5936916b3027295ad889f232770b00870ff4", "author": {"user": {"login": "jlahoda", "name": "Jan Lahoda"}}, "url": "https://github.com/apache/netbeans/commit/142b5936916b3027295ad889f232770b00870ff4", "committedDate": "2020-08-22T06:48:20Z", "message": "Adding support for workspace/symbol to both the LSP client and Java LSP server.\nNeeds to eagerly start the servers (so that they can provide outputs)."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "38f9ea82f9c1bee769ce34c47c5efc7b8002f761", "author": {"user": {"login": "jlahoda", "name": "Jan Lahoda"}}, "url": "https://github.com/apache/netbeans/commit/38f9ea82f9c1bee769ce34c47c5efc7b8002f761", "committedDate": "2020-08-22T19:59:54Z", "message": "Removing unnecessary import."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDcyOTYwMDEw", "url": "https://github.com/apache/netbeans/pull/2324#pullrequestreview-472960010", "createdAt": "2020-08-22T20:21:12Z", "commit": {"oid": "38f9ea82f9c1bee769ce34c47c5efc7b8002f761"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMlQyMDoyMToxMlrOHFH7sQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMlQyMDoyMToxMlrOHFH7sQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTEzNDg5Nw==", "bodyText": "Jackpot:\nwarning: Passing possible null to not-null argument", "url": "https://github.com/apache/netbeans/pull/2324#discussion_r475134897", "createdAt": "2020-08-22T20:21:12Z", "author": {"login": "jlahoda-jackpot"}, "path": "java/java.lsp.server/src/org/netbeans/modules/java/lsp/server/workspace/WorkspaceServiceImpl.java", "diffHunk": "@@ -18,23 +18,215 @@\n  */\n package org.netbeans.modules.java.lsp.server.workspace;\n \n+import com.sun.source.util.TreePath;\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import javax.lang.model.element.Element;\n+import javax.lang.model.element.ElementKind;\n+import javax.lang.model.element.TypeElement;\n import org.eclipse.lsp4j.DidChangeConfigurationParams;\n import org.eclipse.lsp4j.DidChangeWatchedFilesParams;\n+import org.eclipse.lsp4j.Location;\n import org.eclipse.lsp4j.SymbolInformation;\n import org.eclipse.lsp4j.WorkspaceSymbolParams;\n import org.eclipse.lsp4j.services.WorkspaceService;\n+import org.netbeans.api.annotations.common.NonNull;\n+import org.netbeans.api.annotations.common.NullAllowed;\n+import org.netbeans.api.java.source.ClasspathInfo;\n+import org.netbeans.api.java.source.CompilationInfo;\n+import org.netbeans.api.java.source.ElementHandle;\n+import org.netbeans.api.java.source.JavaSource;\n+import org.netbeans.api.java.source.JavaSource.Phase;\n+import org.netbeans.api.java.source.SourceUtils;\n+import org.netbeans.modules.java.lsp.server.Utils;\n+import org.netbeans.modules.java.source.ui.JavaSymbolProvider;\n+import org.netbeans.modules.java.source.ui.JavaSymbolProvider.ResultHandler;\n+import org.netbeans.modules.java.source.usages.ClassIndexImpl;\n+import org.netbeans.modules.parsing.lucene.support.Queries;\n+import org.netbeans.spi.jumpto.type.SearchType;\n+import org.openide.filesystems.FileObject;\n+import org.openide.util.Pair;\n+import org.openide.util.RequestProcessor;\n \n /**\n  *\n  * @author lahvac\n  */\n public class WorkspaceServiceImpl implements WorkspaceService {\n \n+    private static final RequestProcessor WORKER = new RequestProcessor(WorkspaceServiceImpl.class.getName(), 1, false, false);\n+\n     @Override\n-    public CompletableFuture<List<? extends SymbolInformation>> symbol(WorkspaceSymbolParams arg0) {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    public CompletableFuture<List<? extends SymbolInformation>> symbol(WorkspaceSymbolParams params) {\n+        String query = params.getQuery();\n+        if (query.isEmpty()) {\n+            //cannot query \"all\":\n+            return CompletableFuture.completedFuture(Collections.emptyList());\n+        }\n+        System.err.println(\"query=\" + query);\n+        boolean exact = false;\n+        if (query.endsWith(\" \")) {\n+            query = query.substring(0, query.length() - 1);\n+            exact = true;\n+        }\n+        String queryFin = query;\n+        boolean exactFin = exact;\n+        AtomicBoolean cancel = new AtomicBoolean();\n+        CompletableFuture<List<? extends SymbolInformation>> result = new CompletableFuture<List<? extends SymbolInformation>>() {\n+            @Override\n+            public boolean cancel(boolean mayInterruptIfRunning) {\n+                cancel.set(mayInterruptIfRunning);\n+                return super.cancel(mayInterruptIfRunning);\n+            }\n+        };\n+        WORKER.post(() -> {\n+            try {\n+                List<SymbolInformation> symbols = new ArrayList<>();\n+                ResultHandler handler = new ResultHandler() {\n+                    @Override\n+                    public void setHighlightText(String text) {\n+                    }\n+\n+                    private Map<ElementHandle<TypeElement>, List<String>> type2Idents;\n+\n+                    @Override\n+                    public void runRoot(FileObject root, ClassIndexImpl ci, Exec exec) throws IOException, InterruptedException {\n+                        ClasspathInfo cpInfo = ClasspathInfo.create(root);\n+                        try {\n+                            type2Idents = new HashMap<>();\n+                            exec.run();\n+                            Map<FileObject, Map<ElementHandle<TypeElement>, List<String>>> sources = new HashMap<>();\n+                            for (Entry<ElementHandle<TypeElement>, List<String>> e : type2Idents.entrySet()) {\n+                                FileObject sourceFile = SourceUtils.getFile(e.getKey(), cpInfo);\n+                                sources.computeIfAbsent(sourceFile, s -> new HashMap<>())\n+                                       .put(e.getKey(), e.getValue());\n+                            }\n+                            if (!sources.isEmpty()) {\n+                                JavaSource.create(cpInfo, sources.keySet())\n+                                          .runUserActionTask(cc -> {\n+                                              if (Phase.ELEMENTS_RESOLVED.compareTo(cc.toPhase(Phase.ELEMENTS_RESOLVED))> 0) {\n+                                                  return ;\n+                                              }\n+                                              for (Entry<ElementHandle<TypeElement>, List<String>> e : sources.get(cc.getFileObject()).entrySet()) {\n+                                                  TypeElement te = e.getKey().resolve(cc);\n+\n+                                                  for (String ident : e.getValue()) {\n+                                                      if (ident.equals(getSimpleName(te, null, false))) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "38f9ea82f9c1bee769ce34c47c5efc7b8002f761"}, "originalPosition": 106}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDcyOTYwMDEy", "url": "https://github.com/apache/netbeans/pull/2324#pullrequestreview-472960012", "createdAt": "2020-08-22T20:21:13Z", "commit": {"oid": "38f9ea82f9c1bee769ce34c47c5efc7b8002f761"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMlQyMDoyMToxM1rOHFH7sw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMlQyMDoyMToxM1rOHFH7sw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTEzNDg5OQ==", "bodyText": "Jackpot:\nwarning: Can use functional operations", "url": "https://github.com/apache/netbeans/pull/2324#discussion_r475134899", "createdAt": "2020-08-22T20:21:13Z", "author": {"login": "jlahoda-jackpot"}, "path": "java/java.lsp.server/src/org/netbeans/modules/java/lsp/server/workspace/WorkspaceServiceImpl.java", "diffHunk": "@@ -18,23 +18,215 @@\n  */\n package org.netbeans.modules.java.lsp.server.workspace;\n \n+import com.sun.source.util.TreePath;\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import javax.lang.model.element.Element;\n+import javax.lang.model.element.ElementKind;\n+import javax.lang.model.element.TypeElement;\n import org.eclipse.lsp4j.DidChangeConfigurationParams;\n import org.eclipse.lsp4j.DidChangeWatchedFilesParams;\n+import org.eclipse.lsp4j.Location;\n import org.eclipse.lsp4j.SymbolInformation;\n import org.eclipse.lsp4j.WorkspaceSymbolParams;\n import org.eclipse.lsp4j.services.WorkspaceService;\n+import org.netbeans.api.annotations.common.NonNull;\n+import org.netbeans.api.annotations.common.NullAllowed;\n+import org.netbeans.api.java.source.ClasspathInfo;\n+import org.netbeans.api.java.source.CompilationInfo;\n+import org.netbeans.api.java.source.ElementHandle;\n+import org.netbeans.api.java.source.JavaSource;\n+import org.netbeans.api.java.source.JavaSource.Phase;\n+import org.netbeans.api.java.source.SourceUtils;\n+import org.netbeans.modules.java.lsp.server.Utils;\n+import org.netbeans.modules.java.source.ui.JavaSymbolProvider;\n+import org.netbeans.modules.java.source.ui.JavaSymbolProvider.ResultHandler;\n+import org.netbeans.modules.java.source.usages.ClassIndexImpl;\n+import org.netbeans.modules.parsing.lucene.support.Queries;\n+import org.netbeans.spi.jumpto.type.SearchType;\n+import org.openide.filesystems.FileObject;\n+import org.openide.util.Pair;\n+import org.openide.util.RequestProcessor;\n \n /**\n  *\n  * @author lahvac\n  */\n public class WorkspaceServiceImpl implements WorkspaceService {\n \n+    private static final RequestProcessor WORKER = new RequestProcessor(WorkspaceServiceImpl.class.getName(), 1, false, false);\n+\n     @Override\n-    public CompletableFuture<List<? extends SymbolInformation>> symbol(WorkspaceSymbolParams arg0) {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    public CompletableFuture<List<? extends SymbolInformation>> symbol(WorkspaceSymbolParams params) {\n+        String query = params.getQuery();\n+        if (query.isEmpty()) {\n+            //cannot query \"all\":\n+            return CompletableFuture.completedFuture(Collections.emptyList());\n+        }\n+        System.err.println(\"query=\" + query);\n+        boolean exact = false;\n+        if (query.endsWith(\" \")) {\n+            query = query.substring(0, query.length() - 1);\n+            exact = true;\n+        }\n+        String queryFin = query;\n+        boolean exactFin = exact;\n+        AtomicBoolean cancel = new AtomicBoolean();\n+        CompletableFuture<List<? extends SymbolInformation>> result = new CompletableFuture<List<? extends SymbolInformation>>() {\n+            @Override\n+            public boolean cancel(boolean mayInterruptIfRunning) {\n+                cancel.set(mayInterruptIfRunning);\n+                return super.cancel(mayInterruptIfRunning);\n+            }\n+        };\n+        WORKER.post(() -> {\n+            try {\n+                List<SymbolInformation> symbols = new ArrayList<>();\n+                ResultHandler handler = new ResultHandler() {\n+                    @Override\n+                    public void setHighlightText(String text) {\n+                    }\n+\n+                    private Map<ElementHandle<TypeElement>, List<String>> type2Idents;\n+\n+                    @Override\n+                    public void runRoot(FileObject root, ClassIndexImpl ci, Exec exec) throws IOException, InterruptedException {\n+                        ClasspathInfo cpInfo = ClasspathInfo.create(root);\n+                        try {\n+                            type2Idents = new HashMap<>();\n+                            exec.run();\n+                            Map<FileObject, Map<ElementHandle<TypeElement>, List<String>>> sources = new HashMap<>();\n+                            for (Entry<ElementHandle<TypeElement>, List<String>> e : type2Idents.entrySet()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "38f9ea82f9c1bee769ce34c47c5efc7b8002f761"}, "originalPosition": 91}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDcyOTYwMDEz", "url": "https://github.com/apache/netbeans/pull/2324#pullrequestreview-472960013", "createdAt": "2020-08-22T20:21:15Z", "commit": {"oid": "38f9ea82f9c1bee769ce34c47c5efc7b8002f761"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMlQyMDoyMToxNVrOHFH7tQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMlQyMDoyMToxNVrOHFH7tQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTEzNDkwMQ==", "bodyText": "Jackpot:\nwarning: Can use functional operations", "url": "https://github.com/apache/netbeans/pull/2324#discussion_r475134901", "createdAt": "2020-08-22T20:21:15Z", "author": {"login": "jlahoda-jackpot"}, "path": "java/java.lsp.server/src/org/netbeans/modules/java/lsp/server/workspace/WorkspaceServiceImpl.java", "diffHunk": "@@ -18,23 +18,215 @@\n  */\n package org.netbeans.modules.java.lsp.server.workspace;\n \n+import com.sun.source.util.TreePath;\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import javax.lang.model.element.Element;\n+import javax.lang.model.element.ElementKind;\n+import javax.lang.model.element.TypeElement;\n import org.eclipse.lsp4j.DidChangeConfigurationParams;\n import org.eclipse.lsp4j.DidChangeWatchedFilesParams;\n+import org.eclipse.lsp4j.Location;\n import org.eclipse.lsp4j.SymbolInformation;\n import org.eclipse.lsp4j.WorkspaceSymbolParams;\n import org.eclipse.lsp4j.services.WorkspaceService;\n+import org.netbeans.api.annotations.common.NonNull;\n+import org.netbeans.api.annotations.common.NullAllowed;\n+import org.netbeans.api.java.source.ClasspathInfo;\n+import org.netbeans.api.java.source.CompilationInfo;\n+import org.netbeans.api.java.source.ElementHandle;\n+import org.netbeans.api.java.source.JavaSource;\n+import org.netbeans.api.java.source.JavaSource.Phase;\n+import org.netbeans.api.java.source.SourceUtils;\n+import org.netbeans.modules.java.lsp.server.Utils;\n+import org.netbeans.modules.java.source.ui.JavaSymbolProvider;\n+import org.netbeans.modules.java.source.ui.JavaSymbolProvider.ResultHandler;\n+import org.netbeans.modules.java.source.usages.ClassIndexImpl;\n+import org.netbeans.modules.parsing.lucene.support.Queries;\n+import org.netbeans.spi.jumpto.type.SearchType;\n+import org.openide.filesystems.FileObject;\n+import org.openide.util.Pair;\n+import org.openide.util.RequestProcessor;\n \n /**\n  *\n  * @author lahvac\n  */\n public class WorkspaceServiceImpl implements WorkspaceService {\n \n+    private static final RequestProcessor WORKER = new RequestProcessor(WorkspaceServiceImpl.class.getName(), 1, false, false);\n+\n     @Override\n-    public CompletableFuture<List<? extends SymbolInformation>> symbol(WorkspaceSymbolParams arg0) {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    public CompletableFuture<List<? extends SymbolInformation>> symbol(WorkspaceSymbolParams params) {\n+        String query = params.getQuery();\n+        if (query.isEmpty()) {\n+            //cannot query \"all\":\n+            return CompletableFuture.completedFuture(Collections.emptyList());\n+        }\n+        System.err.println(\"query=\" + query);\n+        boolean exact = false;\n+        if (query.endsWith(\" \")) {\n+            query = query.substring(0, query.length() - 1);\n+            exact = true;\n+        }\n+        String queryFin = query;\n+        boolean exactFin = exact;\n+        AtomicBoolean cancel = new AtomicBoolean();\n+        CompletableFuture<List<? extends SymbolInformation>> result = new CompletableFuture<List<? extends SymbolInformation>>() {\n+            @Override\n+            public boolean cancel(boolean mayInterruptIfRunning) {\n+                cancel.set(mayInterruptIfRunning);\n+                return super.cancel(mayInterruptIfRunning);\n+            }\n+        };\n+        WORKER.post(() -> {\n+            try {\n+                List<SymbolInformation> symbols = new ArrayList<>();\n+                ResultHandler handler = new ResultHandler() {\n+                    @Override\n+                    public void setHighlightText(String text) {\n+                    }\n+\n+                    private Map<ElementHandle<TypeElement>, List<String>> type2Idents;\n+\n+                    @Override\n+                    public void runRoot(FileObject root, ClassIndexImpl ci, Exec exec) throws IOException, InterruptedException {\n+                        ClasspathInfo cpInfo = ClasspathInfo.create(root);\n+                        try {\n+                            type2Idents = new HashMap<>();\n+                            exec.run();\n+                            Map<FileObject, Map<ElementHandle<TypeElement>, List<String>>> sources = new HashMap<>();\n+                            for (Entry<ElementHandle<TypeElement>, List<String>> e : type2Idents.entrySet()) {\n+                                FileObject sourceFile = SourceUtils.getFile(e.getKey(), cpInfo);\n+                                sources.computeIfAbsent(sourceFile, s -> new HashMap<>())\n+                                       .put(e.getKey(), e.getValue());\n+                            }\n+                            if (!sources.isEmpty()) {\n+                                JavaSource.create(cpInfo, sources.keySet())\n+                                          .runUserActionTask(cc -> {\n+                                              if (Phase.ELEMENTS_RESOLVED.compareTo(cc.toPhase(Phase.ELEMENTS_RESOLVED))> 0) {\n+                                                  return ;\n+                                              }\n+                                              for (Entry<ElementHandle<TypeElement>, List<String>> e : sources.get(cc.getFileObject()).entrySet()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "38f9ea82f9c1bee769ce34c47c5efc7b8002f761"}, "originalPosition": 102}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDcyOTYwMDE1", "url": "https://github.com/apache/netbeans/pull/2324#pullrequestreview-472960015", "createdAt": "2020-08-22T20:21:17Z", "commit": {"oid": "38f9ea82f9c1bee769ce34c47c5efc7b8002f761"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMlQyMDoyMToxN1rOHFH7uA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMlQyMDoyMToxN1rOHFH7uA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTEzNDkwNA==", "bodyText": "Jackpot:\nwarning: Can use functional operations", "url": "https://github.com/apache/netbeans/pull/2324#discussion_r475134904", "createdAt": "2020-08-22T20:21:17Z", "author": {"login": "jlahoda-jackpot"}, "path": "java/java.lsp.server/src/org/netbeans/modules/java/lsp/server/workspace/WorkspaceServiceImpl.java", "diffHunk": "@@ -18,23 +18,215 @@\n  */\n package org.netbeans.modules.java.lsp.server.workspace;\n \n+import com.sun.source.util.TreePath;\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import javax.lang.model.element.Element;\n+import javax.lang.model.element.ElementKind;\n+import javax.lang.model.element.TypeElement;\n import org.eclipse.lsp4j.DidChangeConfigurationParams;\n import org.eclipse.lsp4j.DidChangeWatchedFilesParams;\n+import org.eclipse.lsp4j.Location;\n import org.eclipse.lsp4j.SymbolInformation;\n import org.eclipse.lsp4j.WorkspaceSymbolParams;\n import org.eclipse.lsp4j.services.WorkspaceService;\n+import org.netbeans.api.annotations.common.NonNull;\n+import org.netbeans.api.annotations.common.NullAllowed;\n+import org.netbeans.api.java.source.ClasspathInfo;\n+import org.netbeans.api.java.source.CompilationInfo;\n+import org.netbeans.api.java.source.ElementHandle;\n+import org.netbeans.api.java.source.JavaSource;\n+import org.netbeans.api.java.source.JavaSource.Phase;\n+import org.netbeans.api.java.source.SourceUtils;\n+import org.netbeans.modules.java.lsp.server.Utils;\n+import org.netbeans.modules.java.source.ui.JavaSymbolProvider;\n+import org.netbeans.modules.java.source.ui.JavaSymbolProvider.ResultHandler;\n+import org.netbeans.modules.java.source.usages.ClassIndexImpl;\n+import org.netbeans.modules.parsing.lucene.support.Queries;\n+import org.netbeans.spi.jumpto.type.SearchType;\n+import org.openide.filesystems.FileObject;\n+import org.openide.util.Pair;\n+import org.openide.util.RequestProcessor;\n \n /**\n  *\n  * @author lahvac\n  */\n public class WorkspaceServiceImpl implements WorkspaceService {\n \n+    private static final RequestProcessor WORKER = new RequestProcessor(WorkspaceServiceImpl.class.getName(), 1, false, false);\n+\n     @Override\n-    public CompletableFuture<List<? extends SymbolInformation>> symbol(WorkspaceSymbolParams arg0) {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    public CompletableFuture<List<? extends SymbolInformation>> symbol(WorkspaceSymbolParams params) {\n+        String query = params.getQuery();\n+        if (query.isEmpty()) {\n+            //cannot query \"all\":\n+            return CompletableFuture.completedFuture(Collections.emptyList());\n+        }\n+        System.err.println(\"query=\" + query);\n+        boolean exact = false;\n+        if (query.endsWith(\" \")) {\n+            query = query.substring(0, query.length() - 1);\n+            exact = true;\n+        }\n+        String queryFin = query;\n+        boolean exactFin = exact;\n+        AtomicBoolean cancel = new AtomicBoolean();\n+        CompletableFuture<List<? extends SymbolInformation>> result = new CompletableFuture<List<? extends SymbolInformation>>() {\n+            @Override\n+            public boolean cancel(boolean mayInterruptIfRunning) {\n+                cancel.set(mayInterruptIfRunning);\n+                return super.cancel(mayInterruptIfRunning);\n+            }\n+        };\n+        WORKER.post(() -> {\n+            try {\n+                List<SymbolInformation> symbols = new ArrayList<>();\n+                ResultHandler handler = new ResultHandler() {\n+                    @Override\n+                    public void setHighlightText(String text) {\n+                    }\n+\n+                    private Map<ElementHandle<TypeElement>, List<String>> type2Idents;\n+\n+                    @Override\n+                    public void runRoot(FileObject root, ClassIndexImpl ci, Exec exec) throws IOException, InterruptedException {\n+                        ClasspathInfo cpInfo = ClasspathInfo.create(root);\n+                        try {\n+                            type2Idents = new HashMap<>();\n+                            exec.run();\n+                            Map<FileObject, Map<ElementHandle<TypeElement>, List<String>>> sources = new HashMap<>();\n+                            for (Entry<ElementHandle<TypeElement>, List<String>> e : type2Idents.entrySet()) {\n+                                FileObject sourceFile = SourceUtils.getFile(e.getKey(), cpInfo);\n+                                sources.computeIfAbsent(sourceFile, s -> new HashMap<>())\n+                                       .put(e.getKey(), e.getValue());\n+                            }\n+                            if (!sources.isEmpty()) {\n+                                JavaSource.create(cpInfo, sources.keySet())\n+                                          .runUserActionTask(cc -> {\n+                                              if (Phase.ELEMENTS_RESOLVED.compareTo(cc.toPhase(Phase.ELEMENTS_RESOLVED))> 0) {\n+                                                  return ;\n+                                              }\n+                                              for (Entry<ElementHandle<TypeElement>, List<String>> e : sources.get(cc.getFileObject()).entrySet()) {\n+                                                  TypeElement te = e.getKey().resolve(cc);\n+\n+                                                  for (String ident : e.getValue()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "38f9ea82f9c1bee769ce34c47c5efc7b8002f761"}, "originalPosition": 105}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDcyOTYwMDE3", "url": "https://github.com/apache/netbeans/pull/2324#pullrequestreview-472960017", "createdAt": "2020-08-22T20:21:18Z", "commit": {"oid": "38f9ea82f9c1bee769ce34c47c5efc7b8002f761"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMlQyMDoyMToxOFrOHFH7uw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMlQyMDoyMToxOFrOHFH7uw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTEzNDkwNw==", "bodyText": "Jackpot:\nwarning: Can use functional operations", "url": "https://github.com/apache/netbeans/pull/2324#discussion_r475134907", "createdAt": "2020-08-22T20:21:18Z", "author": {"login": "jlahoda-jackpot"}, "path": "java/java.lsp.server/src/org/netbeans/modules/java/lsp/server/workspace/WorkspaceServiceImpl.java", "diffHunk": "@@ -18,23 +18,215 @@\n  */\n package org.netbeans.modules.java.lsp.server.workspace;\n \n+import com.sun.source.util.TreePath;\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import javax.lang.model.element.Element;\n+import javax.lang.model.element.ElementKind;\n+import javax.lang.model.element.TypeElement;\n import org.eclipse.lsp4j.DidChangeConfigurationParams;\n import org.eclipse.lsp4j.DidChangeWatchedFilesParams;\n+import org.eclipse.lsp4j.Location;\n import org.eclipse.lsp4j.SymbolInformation;\n import org.eclipse.lsp4j.WorkspaceSymbolParams;\n import org.eclipse.lsp4j.services.WorkspaceService;\n+import org.netbeans.api.annotations.common.NonNull;\n+import org.netbeans.api.annotations.common.NullAllowed;\n+import org.netbeans.api.java.source.ClasspathInfo;\n+import org.netbeans.api.java.source.CompilationInfo;\n+import org.netbeans.api.java.source.ElementHandle;\n+import org.netbeans.api.java.source.JavaSource;\n+import org.netbeans.api.java.source.JavaSource.Phase;\n+import org.netbeans.api.java.source.SourceUtils;\n+import org.netbeans.modules.java.lsp.server.Utils;\n+import org.netbeans.modules.java.source.ui.JavaSymbolProvider;\n+import org.netbeans.modules.java.source.ui.JavaSymbolProvider.ResultHandler;\n+import org.netbeans.modules.java.source.usages.ClassIndexImpl;\n+import org.netbeans.modules.parsing.lucene.support.Queries;\n+import org.netbeans.spi.jumpto.type.SearchType;\n+import org.openide.filesystems.FileObject;\n+import org.openide.util.Pair;\n+import org.openide.util.RequestProcessor;\n \n /**\n  *\n  * @author lahvac\n  */\n public class WorkspaceServiceImpl implements WorkspaceService {\n \n+    private static final RequestProcessor WORKER = new RequestProcessor(WorkspaceServiceImpl.class.getName(), 1, false, false);\n+\n     @Override\n-    public CompletableFuture<List<? extends SymbolInformation>> symbol(WorkspaceSymbolParams arg0) {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    public CompletableFuture<List<? extends SymbolInformation>> symbol(WorkspaceSymbolParams params) {\n+        String query = params.getQuery();\n+        if (query.isEmpty()) {\n+            //cannot query \"all\":\n+            return CompletableFuture.completedFuture(Collections.emptyList());\n+        }\n+        System.err.println(\"query=\" + query);\n+        boolean exact = false;\n+        if (query.endsWith(\" \")) {\n+            query = query.substring(0, query.length() - 1);\n+            exact = true;\n+        }\n+        String queryFin = query;\n+        boolean exactFin = exact;\n+        AtomicBoolean cancel = new AtomicBoolean();\n+        CompletableFuture<List<? extends SymbolInformation>> result = new CompletableFuture<List<? extends SymbolInformation>>() {\n+            @Override\n+            public boolean cancel(boolean mayInterruptIfRunning) {\n+                cancel.set(mayInterruptIfRunning);\n+                return super.cancel(mayInterruptIfRunning);\n+            }\n+        };\n+        WORKER.post(() -> {\n+            try {\n+                List<SymbolInformation> symbols = new ArrayList<>();\n+                ResultHandler handler = new ResultHandler() {\n+                    @Override\n+                    public void setHighlightText(String text) {\n+                    }\n+\n+                    private Map<ElementHandle<TypeElement>, List<String>> type2Idents;\n+\n+                    @Override\n+                    public void runRoot(FileObject root, ClassIndexImpl ci, Exec exec) throws IOException, InterruptedException {\n+                        ClasspathInfo cpInfo = ClasspathInfo.create(root);\n+                        try {\n+                            type2Idents = new HashMap<>();\n+                            exec.run();\n+                            Map<FileObject, Map<ElementHandle<TypeElement>, List<String>>> sources = new HashMap<>();\n+                            for (Entry<ElementHandle<TypeElement>, List<String>> e : type2Idents.entrySet()) {\n+                                FileObject sourceFile = SourceUtils.getFile(e.getKey(), cpInfo);\n+                                sources.computeIfAbsent(sourceFile, s -> new HashMap<>())\n+                                       .put(e.getKey(), e.getValue());\n+                            }\n+                            if (!sources.isEmpty()) {\n+                                JavaSource.create(cpInfo, sources.keySet())\n+                                          .runUserActionTask(cc -> {\n+                                              if (Phase.ELEMENTS_RESOLVED.compareTo(cc.toPhase(Phase.ELEMENTS_RESOLVED))> 0) {\n+                                                  return ;\n+                                              }\n+                                              for (Entry<ElementHandle<TypeElement>, List<String>> e : sources.get(cc.getFileObject()).entrySet()) {\n+                                                  TypeElement te = e.getKey().resolve(cc);\n+\n+                                                  for (String ident : e.getValue()) {\n+                                                      if (ident.equals(getSimpleName(te, null, false))) {\n+                                                          TreePath path = cc.getTrees().getPath(te);\n+\n+                                                          if (path != null) {\n+                                                              final String symbolName = te.getSimpleName().toString();\n+                                                              final ElementKind kind = te.getKind();\n+                                                              SymbolInformation symbol = new SymbolInformation(symbolName, Utils.elementKind2SymbolKind(kind), tree2Location(cc, path), te.getQualifiedName().toString());\n+\n+                                                              symbol.setDeprecated(false);\n+                                                              symbols.add(symbol);\n+                                                          }\n+                                                      }\n+                                                      for (Element ne : te.getEnclosedElements()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "38f9ea82f9c1bee769ce34c47c5efc7b8002f761"}, "originalPosition": 118}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDcyOTYwMDI1", "url": "https://github.com/apache/netbeans/pull/2324#pullrequestreview-472960025", "createdAt": "2020-08-22T20:21:30Z", "commit": {"oid": "38f9ea82f9c1bee769ce34c47c5efc7b8002f761"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMlQyMDoyMTozMFrOHFH7yw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMlQyMDoyMTozMFrOHFH7yw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTEzNDkyMw==", "bodyText": "Jackpot:\nwarning: Dereferencing possible null pointer", "url": "https://github.com/apache/netbeans/pull/2324#discussion_r475134923", "createdAt": "2020-08-22T20:21:30Z", "author": {"login": "jlahoda-jackpot"}, "path": "java/java.lsp.server/src/org/netbeans/modules/java/lsp/server/workspace/WorkspaceServiceImpl.java", "diffHunk": "@@ -18,23 +18,215 @@\n  */\n package org.netbeans.modules.java.lsp.server.workspace;\n \n+import com.sun.source.util.TreePath;\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import javax.lang.model.element.Element;\n+import javax.lang.model.element.ElementKind;\n+import javax.lang.model.element.TypeElement;\n import org.eclipse.lsp4j.DidChangeConfigurationParams;\n import org.eclipse.lsp4j.DidChangeWatchedFilesParams;\n+import org.eclipse.lsp4j.Location;\n import org.eclipse.lsp4j.SymbolInformation;\n import org.eclipse.lsp4j.WorkspaceSymbolParams;\n import org.eclipse.lsp4j.services.WorkspaceService;\n+import org.netbeans.api.annotations.common.NonNull;\n+import org.netbeans.api.annotations.common.NullAllowed;\n+import org.netbeans.api.java.source.ClasspathInfo;\n+import org.netbeans.api.java.source.CompilationInfo;\n+import org.netbeans.api.java.source.ElementHandle;\n+import org.netbeans.api.java.source.JavaSource;\n+import org.netbeans.api.java.source.JavaSource.Phase;\n+import org.netbeans.api.java.source.SourceUtils;\n+import org.netbeans.modules.java.lsp.server.Utils;\n+import org.netbeans.modules.java.source.ui.JavaSymbolProvider;\n+import org.netbeans.modules.java.source.ui.JavaSymbolProvider.ResultHandler;\n+import org.netbeans.modules.java.source.usages.ClassIndexImpl;\n+import org.netbeans.modules.parsing.lucene.support.Queries;\n+import org.netbeans.spi.jumpto.type.SearchType;\n+import org.openide.filesystems.FileObject;\n+import org.openide.util.Pair;\n+import org.openide.util.RequestProcessor;\n \n /**\n  *\n  * @author lahvac\n  */\n public class WorkspaceServiceImpl implements WorkspaceService {\n \n+    private static final RequestProcessor WORKER = new RequestProcessor(WorkspaceServiceImpl.class.getName(), 1, false, false);\n+\n     @Override\n-    public CompletableFuture<List<? extends SymbolInformation>> symbol(WorkspaceSymbolParams arg0) {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    public CompletableFuture<List<? extends SymbolInformation>> symbol(WorkspaceSymbolParams params) {\n+        String query = params.getQuery();\n+        if (query.isEmpty()) {\n+            //cannot query \"all\":\n+            return CompletableFuture.completedFuture(Collections.emptyList());\n+        }\n+        System.err.println(\"query=\" + query);\n+        boolean exact = false;\n+        if (query.endsWith(\" \")) {\n+            query = query.substring(0, query.length() - 1);\n+            exact = true;\n+        }\n+        String queryFin = query;\n+        boolean exactFin = exact;\n+        AtomicBoolean cancel = new AtomicBoolean();\n+        CompletableFuture<List<? extends SymbolInformation>> result = new CompletableFuture<List<? extends SymbolInformation>>() {\n+            @Override\n+            public boolean cancel(boolean mayInterruptIfRunning) {\n+                cancel.set(mayInterruptIfRunning);\n+                return super.cancel(mayInterruptIfRunning);\n+            }\n+        };\n+        WORKER.post(() -> {\n+            try {\n+                List<SymbolInformation> symbols = new ArrayList<>();\n+                ResultHandler handler = new ResultHandler() {\n+                    @Override\n+                    public void setHighlightText(String text) {\n+                    }\n+\n+                    private Map<ElementHandle<TypeElement>, List<String>> type2Idents;\n+\n+                    @Override\n+                    public void runRoot(FileObject root, ClassIndexImpl ci, Exec exec) throws IOException, InterruptedException {\n+                        ClasspathInfo cpInfo = ClasspathInfo.create(root);\n+                        try {\n+                            type2Idents = new HashMap<>();\n+                            exec.run();\n+                            Map<FileObject, Map<ElementHandle<TypeElement>, List<String>>> sources = new HashMap<>();\n+                            for (Entry<ElementHandle<TypeElement>, List<String>> e : type2Idents.entrySet()) {\n+                                FileObject sourceFile = SourceUtils.getFile(e.getKey(), cpInfo);\n+                                sources.computeIfAbsent(sourceFile, s -> new HashMap<>())\n+                                       .put(e.getKey(), e.getValue());\n+                            }\n+                            if (!sources.isEmpty()) {\n+                                JavaSource.create(cpInfo, sources.keySet())\n+                                          .runUserActionTask(cc -> {\n+                                              if (Phase.ELEMENTS_RESOLVED.compareTo(cc.toPhase(Phase.ELEMENTS_RESOLVED))> 0) {\n+                                                  return ;\n+                                              }\n+                                              for (Entry<ElementHandle<TypeElement>, List<String>> e : sources.get(cc.getFileObject()).entrySet()) {\n+                                                  TypeElement te = e.getKey().resolve(cc);\n+\n+                                                  for (String ident : e.getValue()) {\n+                                                      if (ident.equals(getSimpleName(te, null, false))) {\n+                                                          TreePath path = cc.getTrees().getPath(te);\n+\n+                                                          if (path != null) {\n+                                                              final String symbolName = te.getSimpleName().toString();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "38f9ea82f9c1bee769ce34c47c5efc7b8002f761"}, "originalPosition": 110}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDcyOTYwMDI2", "url": "https://github.com/apache/netbeans/pull/2324#pullrequestreview-472960026", "createdAt": "2020-08-22T20:21:31Z", "commit": {"oid": "38f9ea82f9c1bee769ce34c47c5efc7b8002f761"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMlQyMDoyMTozMVrOHFH7zQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMlQyMDoyMTozMVrOHFH7zQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTEzNDkyNQ==", "bodyText": "Jackpot:\nwarning: Dereferencing possible null pointer", "url": "https://github.com/apache/netbeans/pull/2324#discussion_r475134925", "createdAt": "2020-08-22T20:21:31Z", "author": {"login": "jlahoda-jackpot"}, "path": "java/java.lsp.server/src/org/netbeans/modules/java/lsp/server/workspace/WorkspaceServiceImpl.java", "diffHunk": "@@ -18,23 +18,215 @@\n  */\n package org.netbeans.modules.java.lsp.server.workspace;\n \n+import com.sun.source.util.TreePath;\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import javax.lang.model.element.Element;\n+import javax.lang.model.element.ElementKind;\n+import javax.lang.model.element.TypeElement;\n import org.eclipse.lsp4j.DidChangeConfigurationParams;\n import org.eclipse.lsp4j.DidChangeWatchedFilesParams;\n+import org.eclipse.lsp4j.Location;\n import org.eclipse.lsp4j.SymbolInformation;\n import org.eclipse.lsp4j.WorkspaceSymbolParams;\n import org.eclipse.lsp4j.services.WorkspaceService;\n+import org.netbeans.api.annotations.common.NonNull;\n+import org.netbeans.api.annotations.common.NullAllowed;\n+import org.netbeans.api.java.source.ClasspathInfo;\n+import org.netbeans.api.java.source.CompilationInfo;\n+import org.netbeans.api.java.source.ElementHandle;\n+import org.netbeans.api.java.source.JavaSource;\n+import org.netbeans.api.java.source.JavaSource.Phase;\n+import org.netbeans.api.java.source.SourceUtils;\n+import org.netbeans.modules.java.lsp.server.Utils;\n+import org.netbeans.modules.java.source.ui.JavaSymbolProvider;\n+import org.netbeans.modules.java.source.ui.JavaSymbolProvider.ResultHandler;\n+import org.netbeans.modules.java.source.usages.ClassIndexImpl;\n+import org.netbeans.modules.parsing.lucene.support.Queries;\n+import org.netbeans.spi.jumpto.type.SearchType;\n+import org.openide.filesystems.FileObject;\n+import org.openide.util.Pair;\n+import org.openide.util.RequestProcessor;\n \n /**\n  *\n  * @author lahvac\n  */\n public class WorkspaceServiceImpl implements WorkspaceService {\n \n+    private static final RequestProcessor WORKER = new RequestProcessor(WorkspaceServiceImpl.class.getName(), 1, false, false);\n+\n     @Override\n-    public CompletableFuture<List<? extends SymbolInformation>> symbol(WorkspaceSymbolParams arg0) {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    public CompletableFuture<List<? extends SymbolInformation>> symbol(WorkspaceSymbolParams params) {\n+        String query = params.getQuery();\n+        if (query.isEmpty()) {\n+            //cannot query \"all\":\n+            return CompletableFuture.completedFuture(Collections.emptyList());\n+        }\n+        System.err.println(\"query=\" + query);\n+        boolean exact = false;\n+        if (query.endsWith(\" \")) {\n+            query = query.substring(0, query.length() - 1);\n+            exact = true;\n+        }\n+        String queryFin = query;\n+        boolean exactFin = exact;\n+        AtomicBoolean cancel = new AtomicBoolean();\n+        CompletableFuture<List<? extends SymbolInformation>> result = new CompletableFuture<List<? extends SymbolInformation>>() {\n+            @Override\n+            public boolean cancel(boolean mayInterruptIfRunning) {\n+                cancel.set(mayInterruptIfRunning);\n+                return super.cancel(mayInterruptIfRunning);\n+            }\n+        };\n+        WORKER.post(() -> {\n+            try {\n+                List<SymbolInformation> symbols = new ArrayList<>();\n+                ResultHandler handler = new ResultHandler() {\n+                    @Override\n+                    public void setHighlightText(String text) {\n+                    }\n+\n+                    private Map<ElementHandle<TypeElement>, List<String>> type2Idents;\n+\n+                    @Override\n+                    public void runRoot(FileObject root, ClassIndexImpl ci, Exec exec) throws IOException, InterruptedException {\n+                        ClasspathInfo cpInfo = ClasspathInfo.create(root);\n+                        try {\n+                            type2Idents = new HashMap<>();\n+                            exec.run();\n+                            Map<FileObject, Map<ElementHandle<TypeElement>, List<String>>> sources = new HashMap<>();\n+                            for (Entry<ElementHandle<TypeElement>, List<String>> e : type2Idents.entrySet()) {\n+                                FileObject sourceFile = SourceUtils.getFile(e.getKey(), cpInfo);\n+                                sources.computeIfAbsent(sourceFile, s -> new HashMap<>())\n+                                       .put(e.getKey(), e.getValue());\n+                            }\n+                            if (!sources.isEmpty()) {\n+                                JavaSource.create(cpInfo, sources.keySet())\n+                                          .runUserActionTask(cc -> {\n+                                              if (Phase.ELEMENTS_RESOLVED.compareTo(cc.toPhase(Phase.ELEMENTS_RESOLVED))> 0) {\n+                                                  return ;\n+                                              }\n+                                              for (Entry<ElementHandle<TypeElement>, List<String>> e : sources.get(cc.getFileObject()).entrySet()) {\n+                                                  TypeElement te = e.getKey().resolve(cc);\n+\n+                                                  for (String ident : e.getValue()) {\n+                                                      if (ident.equals(getSimpleName(te, null, false))) {\n+                                                          TreePath path = cc.getTrees().getPath(te);\n+\n+                                                          if (path != null) {\n+                                                              final String symbolName = te.getSimpleName().toString();\n+                                                              final ElementKind kind = te.getKind();\n+                                                              SymbolInformation symbol = new SymbolInformation(symbolName, Utils.elementKind2SymbolKind(kind), tree2Location(cc, path), te.getQualifiedName().toString());\n+\n+                                                              symbol.setDeprecated(false);\n+                                                              symbols.add(symbol);\n+                                                          }\n+                                                      }\n+                                                      for (Element ne : te.getEnclosedElements()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "38f9ea82f9c1bee769ce34c47c5efc7b8002f761"}, "originalPosition": 118}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDcyOTYwMDI5", "url": "https://github.com/apache/netbeans/pull/2324#pullrequestreview-472960029", "createdAt": "2020-08-22T20:21:34Z", "commit": {"oid": "38f9ea82f9c1bee769ce34c47c5efc7b8002f761"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMlQyMDoyMTozNFrOHFH70A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMlQyMDoyMTozNFrOHFH70A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTEzNDkyOA==", "bodyText": "Jackpot:\nwarning: Unused Import", "url": "https://github.com/apache/netbeans/pull/2324#discussion_r475134928", "createdAt": "2020-08-22T20:21:34Z", "author": {"login": "jlahoda-jackpot"}, "path": "java/java.lsp.server/src/org/netbeans/modules/java/lsp/server/Utils.java", "diffHunk": "@@ -0,0 +1,215 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.netbeans.modules.java.lsp.server;\n+\n+import com.sun.source.tree.CompilationUnitTree;\n+import com.sun.source.tree.LineMap;\n+import com.sun.source.tree.Tree;\n+import com.sun.source.util.TreePath;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "38f9ea82f9c1bee769ce34c47c5efc7b8002f761"}, "originalPosition": 24}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDcyOTYwMDMx", "url": "https://github.com/apache/netbeans/pull/2324#pullrequestreview-472960031", "createdAt": "2020-08-22T20:21:38Z", "commit": {"oid": "38f9ea82f9c1bee769ce34c47c5efc7b8002f761"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMlQyMDoyMTozOFrOHFH70w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMlQyMDoyMTozOFrOHFH70w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTEzNDkzMQ==", "bodyText": "Jackpot:\nwarning: toString is never used", "url": "https://github.com/apache/netbeans/pull/2324#discussion_r475134931", "createdAt": "2020-08-22T20:21:38Z", "author": {"login": "jlahoda-jackpot"}, "path": "java/java.lsp.server/test/unit/src/org/netbeans/modules/java/lsp/server/ServerTest.java", "diffHunk": "@@ -848,6 +869,71 @@ public void logMessage(MessageParams arg0) {\n         assertEquals(2, codeActions.size());\n     }\n \n+    public void testWorkspaceSymbols() throws Exception {\n+        File src = new File(getWorkDir(), \"Test.java\");\n+        src.getParentFile().mkdirs();\n+        try (Writer w = new FileWriter(new File(src.getParentFile(), \".test-project\"))) {}\n+        String code = \"public class Test {\\n\" +\n+                      \"    public static class TestNested {}\\n\" +\n+                      \"    public static void testMethod() {}\\n\" +\n+                      \"}\\n\";\n+        try (Writer w = new FileWriter(src)) {\n+            w.write(code);\n+        }\n+        CountDownLatch indexingComplete = new CountDownLatch(1);\n+        Launcher<LanguageServer> serverLauncher = LSPLauncher.createClientLauncher(new LanguageClient() {\n+            @Override\n+            public void telemetryEvent(Object arg0) {\n+                throw new UnsupportedOperationException(\"Not supported yet.\");\n+            }\n+\n+            @Override\n+            public void publishDiagnostics(PublishDiagnosticsParams params) {\n+                throw new UnsupportedOperationException(\"Not supported yet.\");\n+            }\n+\n+            @Override\n+            public void showMessage(MessageParams params) {\n+                if (Server.INDEXING_COMPLETED.equals(params.getMessage())) {\n+                    indexingComplete.countDown();\n+                } else {\n+                    throw new UnsupportedOperationException(\"Unexpected message.\");\n+                }\n+            }\n+\n+            @Override\n+            public CompletableFuture<MessageActionItem> showMessageRequest(ShowMessageRequestParams arg0) {\n+                throw new UnsupportedOperationException(\"Not supported yet.\");\n+            }\n+\n+            @Override\n+            public void logMessage(MessageParams arg0) {\n+                throw new UnsupportedOperationException(\"Not supported yet.\");\n+            }\n+        }, client.getInputStream(), client.getOutputStream());\n+        serverLauncher.startListening();\n+        LanguageServer server = serverLauncher.getRemoteProxy();\n+        InitializeParams initParams = new InitializeParams();\n+        initParams.setRootUri(getWorkDir().toURI().toString());\n+        InitializeResult result = server.initialize(initParams).get();\n+        indexingComplete.await();\n+        List<? extends SymbolInformation> symbols = server.getWorkspaceService().symbol(new WorkspaceSymbolParams(\"Tes\")).get();\n+        List<String> actual = symbols.stream().map(si -> si.getKind() + \":\" + si.getName() + \":\" + si.getContainerName() + \":\" + si.getDeprecated() + \":\" + toString(si.getLocation())).collect(Collectors.toList());\n+        assertEquals(Arrays.asList(\"Class:Test:Test:false:Test.java:0:0-3:1\",\n+                                   \"Constructor:():Test:false:Test.java:0:7-0:7\",\n+                                   \"Method:():Test:false:Test.java:2:4-2:38\",\n+                                   \"Class:TestNested:Test.TestNested:false:Test.java:1:4-1:37\",\n+                                   \"Constructor:():Test.TestNested:false:Test.java:1:18-1:18\"),\n+                     actual);\n+    }\n+\n+    private String toString(Location location) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "38f9ea82f9c1bee769ce34c47c5efc7b8002f761"}, "originalPosition": 122}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDcyOTYwMDQy", "url": "https://github.com/apache/netbeans/pull/2324#pullrequestreview-472960042", "createdAt": "2020-08-22T20:21:50Z", "commit": {"oid": "38f9ea82f9c1bee769ce34c47c5efc7b8002f761"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMlQyMDoyMTo1MFrOHFH77A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMlQyMDoyMTo1MFrOHFH77A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTEzNDk1Ng==", "bodyText": "Jackpot:\nwarning: Variable w is never read", "url": "https://github.com/apache/netbeans/pull/2324#discussion_r475134956", "createdAt": "2020-08-22T20:21:50Z", "author": {"login": "jlahoda-jackpot"}, "path": "java/java.lsp.server/test/unit/src/org/netbeans/modules/java/lsp/server/ServerTest.java", "diffHunk": "@@ -848,6 +869,71 @@ public void logMessage(MessageParams arg0) {\n         assertEquals(2, codeActions.size());\n     }\n \n+    public void testWorkspaceSymbols() throws Exception {\n+        File src = new File(getWorkDir(), \"Test.java\");\n+        src.getParentFile().mkdirs();\n+        try (Writer w = new FileWriter(new File(src.getParentFile(), \".test-project\"))) {}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "38f9ea82f9c1bee769ce34c47c5efc7b8002f761"}, "originalPosition": 67}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDcyOTYwMDQ0", "url": "https://github.com/apache/netbeans/pull/2324#pullrequestreview-472960044", "createdAt": "2020-08-22T20:21:51Z", "commit": {"oid": "38f9ea82f9c1bee769ce34c47c5efc7b8002f761"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMlQyMDoyMTo1MlrOHFH77g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMlQyMDoyMTo1MlrOHFH77g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTEzNDk1OA==", "bodyText": "Jackpot:\nwarning: Variable result is never read", "url": "https://github.com/apache/netbeans/pull/2324#discussion_r475134958", "createdAt": "2020-08-22T20:21:52Z", "author": {"login": "jlahoda-jackpot"}, "path": "java/java.lsp.server/test/unit/src/org/netbeans/modules/java/lsp/server/ServerTest.java", "diffHunk": "@@ -848,6 +869,71 @@ public void logMessage(MessageParams arg0) {\n         assertEquals(2, codeActions.size());\n     }\n \n+    public void testWorkspaceSymbols() throws Exception {\n+        File src = new File(getWorkDir(), \"Test.java\");\n+        src.getParentFile().mkdirs();\n+        try (Writer w = new FileWriter(new File(src.getParentFile(), \".test-project\"))) {}\n+        String code = \"public class Test {\\n\" +\n+                      \"    public static class TestNested {}\\n\" +\n+                      \"    public static void testMethod() {}\\n\" +\n+                      \"}\\n\";\n+        try (Writer w = new FileWriter(src)) {\n+            w.write(code);\n+        }\n+        CountDownLatch indexingComplete = new CountDownLatch(1);\n+        Launcher<LanguageServer> serverLauncher = LSPLauncher.createClientLauncher(new LanguageClient() {\n+            @Override\n+            public void telemetryEvent(Object arg0) {\n+                throw new UnsupportedOperationException(\"Not supported yet.\");\n+            }\n+\n+            @Override\n+            public void publishDiagnostics(PublishDiagnosticsParams params) {\n+                throw new UnsupportedOperationException(\"Not supported yet.\");\n+            }\n+\n+            @Override\n+            public void showMessage(MessageParams params) {\n+                if (Server.INDEXING_COMPLETED.equals(params.getMessage())) {\n+                    indexingComplete.countDown();\n+                } else {\n+                    throw new UnsupportedOperationException(\"Unexpected message.\");\n+                }\n+            }\n+\n+            @Override\n+            public CompletableFuture<MessageActionItem> showMessageRequest(ShowMessageRequestParams arg0) {\n+                throw new UnsupportedOperationException(\"Not supported yet.\");\n+            }\n+\n+            @Override\n+            public void logMessage(MessageParams arg0) {\n+                throw new UnsupportedOperationException(\"Not supported yet.\");\n+            }\n+        }, client.getInputStream(), client.getOutputStream());\n+        serverLauncher.startListening();\n+        LanguageServer server = serverLauncher.getRemoteProxy();\n+        InitializeParams initParams = new InitializeParams();\n+        initParams.setRootUri(getWorkDir().toURI().toString());\n+        InitializeResult result = server.initialize(initParams).get();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "38f9ea82f9c1bee769ce34c47c5efc7b8002f761"}, "originalPosition": 110}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDcyOTYwMDQ2", "url": "https://github.com/apache/netbeans/pull/2324#pullrequestreview-472960046", "createdAt": "2020-08-22T20:21:53Z", "commit": {"oid": "38f9ea82f9c1bee769ce34c47c5efc7b8002f761"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMlQyMDoyMTo1M1rOHFH78A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMlQyMDoyMTo1M1rOHFH78A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTEzNDk2MA==", "bodyText": "Jackpot:\nwarning: Use Utilities API for URI/File conversion", "url": "https://github.com/apache/netbeans/pull/2324#discussion_r475134960", "createdAt": "2020-08-22T20:21:53Z", "author": {"login": "jlahoda-jackpot"}, "path": "java/java.lsp.server/test/unit/src/org/netbeans/modules/java/lsp/server/ServerTest.java", "diffHunk": "@@ -848,6 +869,71 @@ public void logMessage(MessageParams arg0) {\n         assertEquals(2, codeActions.size());\n     }\n \n+    public void testWorkspaceSymbols() throws Exception {\n+        File src = new File(getWorkDir(), \"Test.java\");\n+        src.getParentFile().mkdirs();\n+        try (Writer w = new FileWriter(new File(src.getParentFile(), \".test-project\"))) {}\n+        String code = \"public class Test {\\n\" +\n+                      \"    public static class TestNested {}\\n\" +\n+                      \"    public static void testMethod() {}\\n\" +\n+                      \"}\\n\";\n+        try (Writer w = new FileWriter(src)) {\n+            w.write(code);\n+        }\n+        CountDownLatch indexingComplete = new CountDownLatch(1);\n+        Launcher<LanguageServer> serverLauncher = LSPLauncher.createClientLauncher(new LanguageClient() {\n+            @Override\n+            public void telemetryEvent(Object arg0) {\n+                throw new UnsupportedOperationException(\"Not supported yet.\");\n+            }\n+\n+            @Override\n+            public void publishDiagnostics(PublishDiagnosticsParams params) {\n+                throw new UnsupportedOperationException(\"Not supported yet.\");\n+            }\n+\n+            @Override\n+            public void showMessage(MessageParams params) {\n+                if (Server.INDEXING_COMPLETED.equals(params.getMessage())) {\n+                    indexingComplete.countDown();\n+                } else {\n+                    throw new UnsupportedOperationException(\"Unexpected message.\");\n+                }\n+            }\n+\n+            @Override\n+            public CompletableFuture<MessageActionItem> showMessageRequest(ShowMessageRequestParams arg0) {\n+                throw new UnsupportedOperationException(\"Not supported yet.\");\n+            }\n+\n+            @Override\n+            public void logMessage(MessageParams arg0) {\n+                throw new UnsupportedOperationException(\"Not supported yet.\");\n+            }\n+        }, client.getInputStream(), client.getOutputStream());\n+        serverLauncher.startListening();\n+        LanguageServer server = serverLauncher.getRemoteProxy();\n+        InitializeParams initParams = new InitializeParams();\n+        initParams.setRootUri(getWorkDir().toURI().toString());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "38f9ea82f9c1bee769ce34c47c5efc7b8002f761"}, "originalPosition": 109}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDcyOTYwMDU0", "url": "https://github.com/apache/netbeans/pull/2324#pullrequestreview-472960054", "createdAt": "2020-08-22T20:21:55Z", "commit": {"oid": "38f9ea82f9c1bee769ce34c47c5efc7b8002f761"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMlQyMDoyMTo1NVrOHFH79Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMlQyMDoyMTo1NVrOHFH79Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTEzNDk2NQ==", "bodyText": "Jackpot:\nwarning: Can use functional operations", "url": "https://github.com/apache/netbeans/pull/2324#discussion_r475134965", "createdAt": "2020-08-22T20:21:55Z", "author": {"login": "jlahoda-jackpot"}, "path": "java/java.sourceui/src/org/netbeans/modules/java/source/ui/JavaSymbolProvider.java", "diffHunk": "@@ -117,145 +119,187 @@ public void computeSymbolNames(final Context context, final Result result) {\n             final Cache cache = scanInProgress ?\n                 Cache.create(textToSearch, st) :\n                 null;\n-            String prefix = null;\n-            final int dotIndex = textToSearch.lastIndexOf('.'); //NOI18N\n-            if (dotIndex > 0 && dotIndex != textToSearch.length()-1) {\n-                prefix = textToSearch.substring(0, dotIndex);\n-                textToSearch = textToSearch.substring(dotIndex+1);\n-            }\n-            final String textToHighLight = textToSearch;\n-            ClassIndex.NameKind _kind;\n-            boolean _caseSensitive;\n-            switch (st) {\n-                case PREFIX:\n-                    _kind = ClassIndex.NameKind.PREFIX;\n-                    _caseSensitive = true;\n-                    break;\n-                case REGEXP:\n-                    _kind = ClassIndex.NameKind.REGEXP;\n-                    textToSearch = NameMatcherFactory.wildcardsToRegexp(\n-                            removeNonJavaChars(textToSearch),\n-                            true);\n-                    _caseSensitive = true;\n-                    break;\n-                case CAMEL_CASE:\n-                    _kind = ClassIndex.NameKind.CAMEL_CASE;\n-                    _caseSensitive = true;\n-                    break;\n-                case CASE_INSENSITIVE_CAMEL_CASE:\n-                    _kind = ClassIndex.NameKind.CAMEL_CASE_INSENSITIVE;\n-                    _caseSensitive = false;\n-                    break;\n-                case EXACT_NAME:\n-                    _kind = ClassIndex.NameKind.SIMPLE_NAME;\n-                    _caseSensitive = true;\n-                    break;\n-                case CASE_INSENSITIVE_PREFIX:\n-                    _kind = ClassIndex.NameKind.CASE_INSENSITIVE_PREFIX;\n-                    _caseSensitive = false;\n-                    break;\n-                case CASE_INSENSITIVE_EXACT_NAME:\n-                    _kind = ClassIndex.NameKind.CASE_INSENSITIVE_REGEXP;\n-                    _caseSensitive = false;\n-                    break;\n-                case CASE_INSENSITIVE_REGEXP:\n-                    _kind = ClassIndex.NameKind.CASE_INSENSITIVE_REGEXP;\n-                    textToSearch = NameMatcherFactory.wildcardsToRegexp(\n-                            removeNonJavaChars(textToSearch),\n-                            true);\n-                    _caseSensitive = false;\n-                    break;\n-                default:\n-                    throw new IllegalArgumentException();\n-            }\n-            final String ident = textToSearch;\n-            final ClassIndex.NameKind kind = _kind;\n-            final boolean caseSensitive = _caseSensitive;\n-            final Pair<NameMatcher,Boolean> restriction;\n-            if (prefix != null) {\n-                restriction = compileName(prefix,caseSensitive);\n-                result.setHighlightText(textToHighLight);\n-            } else {\n-                restriction = null;\n-            }\n-            try {\n-                final ClassIndexManager manager = ClassIndexManager.getDefault();\n-\n-                Collection<FileObject> roots = QuerySupport.findRoots(\n-                        (Project)null,\n-                        Collections.singleton(ClassPath.SOURCE),\n-                        Collections.<String>emptySet(),\n-                        Collections.<String>emptySet());\n-\n-                final Set<URL> rootUrls = new HashSet<>();\n-                for(FileObject root : roots) {\n-                    if (canceled) {\n-                        return;\n+            doComputeSymbols(st, textToSearch, new ResultHandler() {\n+                private FileObject root;\n+                private ProjectInformation projectInfo;\n+                private ClassIndexImpl ci;\n+                @Override\n+                public void setHighlightText(String text) {\n+                    result.setHighlightText(text);\n+                }\n+\n+                @Override\n+                public void runRoot(FileObject root, ClassIndexImpl ci, Exec exec) throws IOException, InterruptedException {\n+                    try {\n+                        Project project = FileOwnerQuery.getOwner(root);\n+\n+                        this.root = root;\n+                        this.projectInfo = project == null ?\n+                                null :\n+                                project.getLookup().lookup(ProjectInformation.class);   //Intentionally does not use ProjectUtils.getInformation() it does project icon annotation which is expensive\n+                        this.ci = ci;\n+                        exec.run();\n+                    } finally {\n+                        this.root = null;\n+                        this.projectInfo = null;\n+                        this.ci = null;\n                     }\n-                    rootUrls.add(root.toURL());\n                 }\n \n-                if (LOGGER.isLoggable(Level.FINE)) {\n-                    LOGGER.log(Level.FINE, \"Querying following roots:\"); //NOI18N\n-                    for (URL url : rootUrls) {\n-                        LOGGER.log(Level.FINE, \"  {0}\", url); //NOI18N\n+                @Override\n+                public void handleResult(ElementHandle<TypeElement> owner, String ident, boolean caseSensitive) {\n+                    final AsyncJavaSymbolDescriptor d = new AsyncJavaSymbolDescriptor(\n+                            projectInfo,\n+                            root,\n+                            ci,\n+                            owner,\n+                            ident,\n+                            caseSensitive);\n+                    result.addResult(d);\n+                    if (cache != null) {\n+                        cache.offer(d);\n                     }\n-                    LOGGER.log(Level.FINE, \"-------------------------\"); //NOI18N\n                 }\n-                //Perform all queries in single op\n-                IndexManager.priorityAccess(new IndexManager.Action<Void>() {\n-                    @Override\n-                    public Void run() throws IOException, InterruptedException {\n-                        for (URL url : rootUrls) {\n-                            if (canceled) {\n-                                return null;\n-                            }\n-                            final FileObject root = URLMapper.findFileObject(url);\n-                            if (root == null) {\n-                                continue;\n-                            }\n-\n-                            final Project project = FileOwnerQuery.getOwner(root);\n-                            final ProjectInformation projectInfo = project == null ?\n-                                    null :\n-                                    project.getLookup().lookup(ProjectInformation.class);   //Intentionally does not use ProjectUtils.getInformation() it does project icon annotation which is expensive\n-                            final ClassIndexImpl impl = manager.getUsagesQuery(root.toURL(), true);\n-                            if (impl != null) {\n+            }, true, canceled);\n+        } finally {\n+            clearCancel();\n+        }\n+    }\n+\n+    public static void doComputeSymbols(SearchType st, String textToSearch, ResultHandler handler, boolean async, AtomicBoolean canceled) {\n+        String prefix = null;\n+        final int dotIndex = textToSearch.lastIndexOf('.'); //NOI18N\n+        if (dotIndex > 0 && dotIndex != textToSearch.length()-1) {\n+            prefix = textToSearch.substring(0, dotIndex);\n+            textToSearch = textToSearch.substring(dotIndex+1);\n+        }\n+        final String textToHighLight = textToSearch;\n+        ClassIndex.NameKind _kind;\n+        boolean _caseSensitive;\n+        switch (st) {\n+            case PREFIX:\n+                _kind = ClassIndex.NameKind.PREFIX;\n+                _caseSensitive = true;\n+                break;\n+            case REGEXP:\n+                _kind = ClassIndex.NameKind.REGEXP;\n+                textToSearch = NameMatcherFactory.wildcardsToRegexp(\n+                        removeNonJavaChars(textToSearch),\n+                        true);\n+                _caseSensitive = true;\n+                break;\n+            case CAMEL_CASE:\n+                _kind = ClassIndex.NameKind.CAMEL_CASE;\n+                _caseSensitive = true;\n+                break;\n+            case CASE_INSENSITIVE_CAMEL_CASE:\n+                _kind = ClassIndex.NameKind.CAMEL_CASE_INSENSITIVE;\n+                _caseSensitive = false;\n+                break;\n+            case EXACT_NAME:\n+                _kind = ClassIndex.NameKind.SIMPLE_NAME;\n+                _caseSensitive = true;\n+                break;\n+            case CASE_INSENSITIVE_PREFIX:\n+                _kind = ClassIndex.NameKind.CASE_INSENSITIVE_PREFIX;\n+                _caseSensitive = false;\n+                break;\n+            case CASE_INSENSITIVE_EXACT_NAME:\n+                _kind = ClassIndex.NameKind.CASE_INSENSITIVE_REGEXP;\n+                _caseSensitive = false;\n+                break;\n+            case CASE_INSENSITIVE_REGEXP:\n+                _kind = ClassIndex.NameKind.CASE_INSENSITIVE_REGEXP;\n+                textToSearch = NameMatcherFactory.wildcardsToRegexp(\n+                        removeNonJavaChars(textToSearch),\n+                        true);\n+                _caseSensitive = false;\n+                break;\n+            default:\n+                throw new IllegalArgumentException();\n+        }\n+        final String ident = textToSearch;\n+        final ClassIndex.NameKind kind = _kind;\n+        final boolean caseSensitive = _caseSensitive;\n+        final Pair<NameMatcher,Boolean> restriction;\n+        if (prefix != null) {\n+            restriction = compileName(prefix,caseSensitive);\n+            handler.setHighlightText(textToHighLight);\n+        } else {\n+            restriction = null;\n+        }\n+        try {\n+            final ClassIndexManager manager = ClassIndexManager.getDefault();\n+\n+            Collection<FileObject> roots = QuerySupport.findRoots(\n+                    (Project)null,\n+                    Collections.singleton(ClassPath.SOURCE),\n+                    Collections.<String>emptySet(),\n+                    Collections.<String>emptySet());\n+\n+            final Set<URL> rootUrls = new HashSet<>();\n+            for(FileObject root : roots) {\n+                if (canceled.get()) {\n+                    return;\n+                }\n+                rootUrls.add(root.toURL());\n+            }\n+\n+            if (LOGGER.isLoggable(Level.FINE)) {\n+                LOGGER.log(Level.FINE, \"Querying following roots:\"); //NOI18N\n+                for (URL url : rootUrls) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "38f9ea82f9c1bee769ce34c47c5efc7b8002f761"}, "originalPosition": 249}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDcyOTYwMDU3", "url": "https://github.com/apache/netbeans/pull/2324#pullrequestreview-472960057", "createdAt": "2020-08-22T20:21:57Z", "commit": {"oid": "38f9ea82f9c1bee769ce34c47c5efc7b8002f761"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMlQyMDoyMTo1N1rOHFH8AA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMlQyMDoyMTo1N1rOHFH8AA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTEzNDk3Ng==", "bodyText": "Jackpot:\nwarning: Unused Import", "url": "https://github.com/apache/netbeans/pull/2324#discussion_r475134976", "createdAt": "2020-08-22T20:21:57Z", "author": {"login": "jlahoda-jackpot"}, "path": "java/java.sourceui/src/org/netbeans/modules/java/source/ui/JavaSymbolProvider.java", "diffHunk": "@@ -29,6 +29,8 @@\n import java.util.List;\n import java.util.Map;\n import java.util.Set;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.function.Consumer;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "38f9ea82f9c1bee769ce34c47c5efc7b8002f761"}, "originalPosition": 5}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDcyOTYwMDYx", "url": "https://github.com/apache/netbeans/pull/2324#pullrequestreview-472960061", "createdAt": "2020-08-22T20:21:59Z", "commit": {"oid": "38f9ea82f9c1bee769ce34c47c5efc7b8002f761"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMlQyMDoyMTo1OVrOHFH8Ag==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMlQyMDoyMTo1OVrOHFH8Ag==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTEzNDk3OA==", "bodyText": "Jackpot:\nwarning: This anonymous inner class creation can be turned into a lambda expression.", "url": "https://github.com/apache/netbeans/pull/2324#discussion_r475134978", "createdAt": "2020-08-22T20:21:59Z", "author": {"login": "jlahoda-jackpot"}, "path": "java/java.sourceui/src/org/netbeans/modules/java/source/ui/JavaSymbolProvider.java", "diffHunk": "@@ -117,145 +119,187 @@ public void computeSymbolNames(final Context context, final Result result) {\n             final Cache cache = scanInProgress ?\n                 Cache.create(textToSearch, st) :\n                 null;\n-            String prefix = null;\n-            final int dotIndex = textToSearch.lastIndexOf('.'); //NOI18N\n-            if (dotIndex > 0 && dotIndex != textToSearch.length()-1) {\n-                prefix = textToSearch.substring(0, dotIndex);\n-                textToSearch = textToSearch.substring(dotIndex+1);\n-            }\n-            final String textToHighLight = textToSearch;\n-            ClassIndex.NameKind _kind;\n-            boolean _caseSensitive;\n-            switch (st) {\n-                case PREFIX:\n-                    _kind = ClassIndex.NameKind.PREFIX;\n-                    _caseSensitive = true;\n-                    break;\n-                case REGEXP:\n-                    _kind = ClassIndex.NameKind.REGEXP;\n-                    textToSearch = NameMatcherFactory.wildcardsToRegexp(\n-                            removeNonJavaChars(textToSearch),\n-                            true);\n-                    _caseSensitive = true;\n-                    break;\n-                case CAMEL_CASE:\n-                    _kind = ClassIndex.NameKind.CAMEL_CASE;\n-                    _caseSensitive = true;\n-                    break;\n-                case CASE_INSENSITIVE_CAMEL_CASE:\n-                    _kind = ClassIndex.NameKind.CAMEL_CASE_INSENSITIVE;\n-                    _caseSensitive = false;\n-                    break;\n-                case EXACT_NAME:\n-                    _kind = ClassIndex.NameKind.SIMPLE_NAME;\n-                    _caseSensitive = true;\n-                    break;\n-                case CASE_INSENSITIVE_PREFIX:\n-                    _kind = ClassIndex.NameKind.CASE_INSENSITIVE_PREFIX;\n-                    _caseSensitive = false;\n-                    break;\n-                case CASE_INSENSITIVE_EXACT_NAME:\n-                    _kind = ClassIndex.NameKind.CASE_INSENSITIVE_REGEXP;\n-                    _caseSensitive = false;\n-                    break;\n-                case CASE_INSENSITIVE_REGEXP:\n-                    _kind = ClassIndex.NameKind.CASE_INSENSITIVE_REGEXP;\n-                    textToSearch = NameMatcherFactory.wildcardsToRegexp(\n-                            removeNonJavaChars(textToSearch),\n-                            true);\n-                    _caseSensitive = false;\n-                    break;\n-                default:\n-                    throw new IllegalArgumentException();\n-            }\n-            final String ident = textToSearch;\n-            final ClassIndex.NameKind kind = _kind;\n-            final boolean caseSensitive = _caseSensitive;\n-            final Pair<NameMatcher,Boolean> restriction;\n-            if (prefix != null) {\n-                restriction = compileName(prefix,caseSensitive);\n-                result.setHighlightText(textToHighLight);\n-            } else {\n-                restriction = null;\n-            }\n-            try {\n-                final ClassIndexManager manager = ClassIndexManager.getDefault();\n-\n-                Collection<FileObject> roots = QuerySupport.findRoots(\n-                        (Project)null,\n-                        Collections.singleton(ClassPath.SOURCE),\n-                        Collections.<String>emptySet(),\n-                        Collections.<String>emptySet());\n-\n-                final Set<URL> rootUrls = new HashSet<>();\n-                for(FileObject root : roots) {\n-                    if (canceled) {\n-                        return;\n+            doComputeSymbols(st, textToSearch, new ResultHandler() {\n+                private FileObject root;\n+                private ProjectInformation projectInfo;\n+                private ClassIndexImpl ci;\n+                @Override\n+                public void setHighlightText(String text) {\n+                    result.setHighlightText(text);\n+                }\n+\n+                @Override\n+                public void runRoot(FileObject root, ClassIndexImpl ci, Exec exec) throws IOException, InterruptedException {\n+                    try {\n+                        Project project = FileOwnerQuery.getOwner(root);\n+\n+                        this.root = root;\n+                        this.projectInfo = project == null ?\n+                                null :\n+                                project.getLookup().lookup(ProjectInformation.class);   //Intentionally does not use ProjectUtils.getInformation() it does project icon annotation which is expensive\n+                        this.ci = ci;\n+                        exec.run();\n+                    } finally {\n+                        this.root = null;\n+                        this.projectInfo = null;\n+                        this.ci = null;\n                     }\n-                    rootUrls.add(root.toURL());\n                 }\n \n-                if (LOGGER.isLoggable(Level.FINE)) {\n-                    LOGGER.log(Level.FINE, \"Querying following roots:\"); //NOI18N\n-                    for (URL url : rootUrls) {\n-                        LOGGER.log(Level.FINE, \"  {0}\", url); //NOI18N\n+                @Override\n+                public void handleResult(ElementHandle<TypeElement> owner, String ident, boolean caseSensitive) {\n+                    final AsyncJavaSymbolDescriptor d = new AsyncJavaSymbolDescriptor(\n+                            projectInfo,\n+                            root,\n+                            ci,\n+                            owner,\n+                            ident,\n+                            caseSensitive);\n+                    result.addResult(d);\n+                    if (cache != null) {\n+                        cache.offer(d);\n                     }\n-                    LOGGER.log(Level.FINE, \"-------------------------\"); //NOI18N\n                 }\n-                //Perform all queries in single op\n-                IndexManager.priorityAccess(new IndexManager.Action<Void>() {\n-                    @Override\n-                    public Void run() throws IOException, InterruptedException {\n-                        for (URL url : rootUrls) {\n-                            if (canceled) {\n-                                return null;\n-                            }\n-                            final FileObject root = URLMapper.findFileObject(url);\n-                            if (root == null) {\n-                                continue;\n-                            }\n-\n-                            final Project project = FileOwnerQuery.getOwner(root);\n-                            final ProjectInformation projectInfo = project == null ?\n-                                    null :\n-                                    project.getLookup().lookup(ProjectInformation.class);   //Intentionally does not use ProjectUtils.getInformation() it does project icon annotation which is expensive\n-                            final ClassIndexImpl impl = manager.getUsagesQuery(root.toURL(), true);\n-                            if (impl != null) {\n+            }, true, canceled);\n+        } finally {\n+            clearCancel();\n+        }\n+    }\n+\n+    public static void doComputeSymbols(SearchType st, String textToSearch, ResultHandler handler, boolean async, AtomicBoolean canceled) {\n+        String prefix = null;\n+        final int dotIndex = textToSearch.lastIndexOf('.'); //NOI18N\n+        if (dotIndex > 0 && dotIndex != textToSearch.length()-1) {\n+            prefix = textToSearch.substring(0, dotIndex);\n+            textToSearch = textToSearch.substring(dotIndex+1);\n+        }\n+        final String textToHighLight = textToSearch;\n+        ClassIndex.NameKind _kind;\n+        boolean _caseSensitive;\n+        switch (st) {\n+            case PREFIX:\n+                _kind = ClassIndex.NameKind.PREFIX;\n+                _caseSensitive = true;\n+                break;\n+            case REGEXP:\n+                _kind = ClassIndex.NameKind.REGEXP;\n+                textToSearch = NameMatcherFactory.wildcardsToRegexp(\n+                        removeNonJavaChars(textToSearch),\n+                        true);\n+                _caseSensitive = true;\n+                break;\n+            case CAMEL_CASE:\n+                _kind = ClassIndex.NameKind.CAMEL_CASE;\n+                _caseSensitive = true;\n+                break;\n+            case CASE_INSENSITIVE_CAMEL_CASE:\n+                _kind = ClassIndex.NameKind.CAMEL_CASE_INSENSITIVE;\n+                _caseSensitive = false;\n+                break;\n+            case EXACT_NAME:\n+                _kind = ClassIndex.NameKind.SIMPLE_NAME;\n+                _caseSensitive = true;\n+                break;\n+            case CASE_INSENSITIVE_PREFIX:\n+                _kind = ClassIndex.NameKind.CASE_INSENSITIVE_PREFIX;\n+                _caseSensitive = false;\n+                break;\n+            case CASE_INSENSITIVE_EXACT_NAME:\n+                _kind = ClassIndex.NameKind.CASE_INSENSITIVE_REGEXP;\n+                _caseSensitive = false;\n+                break;\n+            case CASE_INSENSITIVE_REGEXP:\n+                _kind = ClassIndex.NameKind.CASE_INSENSITIVE_REGEXP;\n+                textToSearch = NameMatcherFactory.wildcardsToRegexp(\n+                        removeNonJavaChars(textToSearch),\n+                        true);\n+                _caseSensitive = false;\n+                break;\n+            default:\n+                throw new IllegalArgumentException();\n+        }\n+        final String ident = textToSearch;\n+        final ClassIndex.NameKind kind = _kind;\n+        final boolean caseSensitive = _caseSensitive;\n+        final Pair<NameMatcher,Boolean> restriction;\n+        if (prefix != null) {\n+            restriction = compileName(prefix,caseSensitive);\n+            handler.setHighlightText(textToHighLight);\n+        } else {\n+            restriction = null;\n+        }\n+        try {\n+            final ClassIndexManager manager = ClassIndexManager.getDefault();\n+\n+            Collection<FileObject> roots = QuerySupport.findRoots(\n+                    (Project)null,\n+                    Collections.singleton(ClassPath.SOURCE),\n+                    Collections.<String>emptySet(),\n+                    Collections.<String>emptySet());\n+\n+            final Set<URL> rootUrls = new HashSet<>();\n+            for(FileObject root : roots) {\n+                if (canceled.get()) {\n+                    return;\n+                }\n+                rootUrls.add(root.toURL());\n+            }\n+\n+            if (LOGGER.isLoggable(Level.FINE)) {\n+                LOGGER.log(Level.FINE, \"Querying following roots:\"); //NOI18N\n+                for (URL url : rootUrls) {\n+                    LOGGER.log(Level.FINE, \"  {0}\", url); //NOI18N\n+                }\n+                LOGGER.log(Level.FINE, \"-------------------------\"); //NOI18N\n+            }\n+            //Perform all queries in single op\n+            IndexManager.priorityAccess(new IndexManager.Action<Void>() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "38f9ea82f9c1bee769ce34c47c5efc7b8002f761"}, "originalPosition": 255}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDcyOTYwMDY5", "url": "https://github.com/apache/netbeans/pull/2324#pullrequestreview-472960069", "createdAt": "2020-08-22T20:22:10Z", "commit": {"oid": "38f9ea82f9c1bee769ce34c47c5efc7b8002f761"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMlQyMDoyMjoxMFrOHFH8Dg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMlQyMDoyMjoxMFrOHFH8Dg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTEzNDk5MA==", "bodyText": "Jackpot:\nwarning: Use ProjectUtils API", "url": "https://github.com/apache/netbeans/pull/2324#discussion_r475134990", "createdAt": "2020-08-22T20:22:10Z", "author": {"login": "jlahoda-jackpot"}, "path": "java/java.sourceui/src/org/netbeans/modules/java/source/ui/JavaSymbolProvider.java", "diffHunk": "@@ -117,145 +119,187 @@ public void computeSymbolNames(final Context context, final Result result) {\n             final Cache cache = scanInProgress ?\n                 Cache.create(textToSearch, st) :\n                 null;\n-            String prefix = null;\n-            final int dotIndex = textToSearch.lastIndexOf('.'); //NOI18N\n-            if (dotIndex > 0 && dotIndex != textToSearch.length()-1) {\n-                prefix = textToSearch.substring(0, dotIndex);\n-                textToSearch = textToSearch.substring(dotIndex+1);\n-            }\n-            final String textToHighLight = textToSearch;\n-            ClassIndex.NameKind _kind;\n-            boolean _caseSensitive;\n-            switch (st) {\n-                case PREFIX:\n-                    _kind = ClassIndex.NameKind.PREFIX;\n-                    _caseSensitive = true;\n-                    break;\n-                case REGEXP:\n-                    _kind = ClassIndex.NameKind.REGEXP;\n-                    textToSearch = NameMatcherFactory.wildcardsToRegexp(\n-                            removeNonJavaChars(textToSearch),\n-                            true);\n-                    _caseSensitive = true;\n-                    break;\n-                case CAMEL_CASE:\n-                    _kind = ClassIndex.NameKind.CAMEL_CASE;\n-                    _caseSensitive = true;\n-                    break;\n-                case CASE_INSENSITIVE_CAMEL_CASE:\n-                    _kind = ClassIndex.NameKind.CAMEL_CASE_INSENSITIVE;\n-                    _caseSensitive = false;\n-                    break;\n-                case EXACT_NAME:\n-                    _kind = ClassIndex.NameKind.SIMPLE_NAME;\n-                    _caseSensitive = true;\n-                    break;\n-                case CASE_INSENSITIVE_PREFIX:\n-                    _kind = ClassIndex.NameKind.CASE_INSENSITIVE_PREFIX;\n-                    _caseSensitive = false;\n-                    break;\n-                case CASE_INSENSITIVE_EXACT_NAME:\n-                    _kind = ClassIndex.NameKind.CASE_INSENSITIVE_REGEXP;\n-                    _caseSensitive = false;\n-                    break;\n-                case CASE_INSENSITIVE_REGEXP:\n-                    _kind = ClassIndex.NameKind.CASE_INSENSITIVE_REGEXP;\n-                    textToSearch = NameMatcherFactory.wildcardsToRegexp(\n-                            removeNonJavaChars(textToSearch),\n-                            true);\n-                    _caseSensitive = false;\n-                    break;\n-                default:\n-                    throw new IllegalArgumentException();\n-            }\n-            final String ident = textToSearch;\n-            final ClassIndex.NameKind kind = _kind;\n-            final boolean caseSensitive = _caseSensitive;\n-            final Pair<NameMatcher,Boolean> restriction;\n-            if (prefix != null) {\n-                restriction = compileName(prefix,caseSensitive);\n-                result.setHighlightText(textToHighLight);\n-            } else {\n-                restriction = null;\n-            }\n-            try {\n-                final ClassIndexManager manager = ClassIndexManager.getDefault();\n-\n-                Collection<FileObject> roots = QuerySupport.findRoots(\n-                        (Project)null,\n-                        Collections.singleton(ClassPath.SOURCE),\n-                        Collections.<String>emptySet(),\n-                        Collections.<String>emptySet());\n-\n-                final Set<URL> rootUrls = new HashSet<>();\n-                for(FileObject root : roots) {\n-                    if (canceled) {\n-                        return;\n+            doComputeSymbols(st, textToSearch, new ResultHandler() {\n+                private FileObject root;\n+                private ProjectInformation projectInfo;\n+                private ClassIndexImpl ci;\n+                @Override\n+                public void setHighlightText(String text) {\n+                    result.setHighlightText(text);\n+                }\n+\n+                @Override\n+                public void runRoot(FileObject root, ClassIndexImpl ci, Exec exec) throws IOException, InterruptedException {\n+                    try {\n+                        Project project = FileOwnerQuery.getOwner(root);\n+\n+                        this.root = root;\n+                        this.projectInfo = project == null ?\n+                                null :\n+                                project.getLookup().lookup(ProjectInformation.class);   //Intentionally does not use ProjectUtils.getInformation() it does project icon annotation which is expensive", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "38f9ea82f9c1bee769ce34c47c5efc7b8002f761"}, "originalPosition": 113}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDcyOTYwMDcz", "url": "https://github.com/apache/netbeans/pull/2324#pullrequestreview-472960073", "createdAt": "2020-08-22T20:22:12Z", "commit": {"oid": "38f9ea82f9c1bee769ce34c47c5efc7b8002f761"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMlQyMDoyMjoxMlrOHFH8Fw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMlQyMDoyMjoxMlrOHFH8Fw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTEzNDk5OQ==", "bodyText": "Jackpot:\nwarning: Unnecessary return statement", "url": "https://github.com/apache/netbeans/pull/2324#discussion_r475134999", "createdAt": "2020-08-22T20:22:12Z", "author": {"login": "jlahoda-jackpot"}, "path": "java/java.sourceui/src/org/netbeans/modules/java/source/ui/JavaSymbolProvider.java", "diffHunk": "@@ -117,145 +119,187 @@ public void computeSymbolNames(final Context context, final Result result) {\n             final Cache cache = scanInProgress ?\n                 Cache.create(textToSearch, st) :\n                 null;\n-            String prefix = null;\n-            final int dotIndex = textToSearch.lastIndexOf('.'); //NOI18N\n-            if (dotIndex > 0 && dotIndex != textToSearch.length()-1) {\n-                prefix = textToSearch.substring(0, dotIndex);\n-                textToSearch = textToSearch.substring(dotIndex+1);\n-            }\n-            final String textToHighLight = textToSearch;\n-            ClassIndex.NameKind _kind;\n-            boolean _caseSensitive;\n-            switch (st) {\n-                case PREFIX:\n-                    _kind = ClassIndex.NameKind.PREFIX;\n-                    _caseSensitive = true;\n-                    break;\n-                case REGEXP:\n-                    _kind = ClassIndex.NameKind.REGEXP;\n-                    textToSearch = NameMatcherFactory.wildcardsToRegexp(\n-                            removeNonJavaChars(textToSearch),\n-                            true);\n-                    _caseSensitive = true;\n-                    break;\n-                case CAMEL_CASE:\n-                    _kind = ClassIndex.NameKind.CAMEL_CASE;\n-                    _caseSensitive = true;\n-                    break;\n-                case CASE_INSENSITIVE_CAMEL_CASE:\n-                    _kind = ClassIndex.NameKind.CAMEL_CASE_INSENSITIVE;\n-                    _caseSensitive = false;\n-                    break;\n-                case EXACT_NAME:\n-                    _kind = ClassIndex.NameKind.SIMPLE_NAME;\n-                    _caseSensitive = true;\n-                    break;\n-                case CASE_INSENSITIVE_PREFIX:\n-                    _kind = ClassIndex.NameKind.CASE_INSENSITIVE_PREFIX;\n-                    _caseSensitive = false;\n-                    break;\n-                case CASE_INSENSITIVE_EXACT_NAME:\n-                    _kind = ClassIndex.NameKind.CASE_INSENSITIVE_REGEXP;\n-                    _caseSensitive = false;\n-                    break;\n-                case CASE_INSENSITIVE_REGEXP:\n-                    _kind = ClassIndex.NameKind.CASE_INSENSITIVE_REGEXP;\n-                    textToSearch = NameMatcherFactory.wildcardsToRegexp(\n-                            removeNonJavaChars(textToSearch),\n-                            true);\n-                    _caseSensitive = false;\n-                    break;\n-                default:\n-                    throw new IllegalArgumentException();\n-            }\n-            final String ident = textToSearch;\n-            final ClassIndex.NameKind kind = _kind;\n-            final boolean caseSensitive = _caseSensitive;\n-            final Pair<NameMatcher,Boolean> restriction;\n-            if (prefix != null) {\n-                restriction = compileName(prefix,caseSensitive);\n-                result.setHighlightText(textToHighLight);\n-            } else {\n-                restriction = null;\n-            }\n-            try {\n-                final ClassIndexManager manager = ClassIndexManager.getDefault();\n-\n-                Collection<FileObject> roots = QuerySupport.findRoots(\n-                        (Project)null,\n-                        Collections.singleton(ClassPath.SOURCE),\n-                        Collections.<String>emptySet(),\n-                        Collections.<String>emptySet());\n-\n-                final Set<URL> rootUrls = new HashSet<>();\n-                for(FileObject root : roots) {\n-                    if (canceled) {\n-                        return;\n+            doComputeSymbols(st, textToSearch, new ResultHandler() {\n+                private FileObject root;\n+                private ProjectInformation projectInfo;\n+                private ClassIndexImpl ci;\n+                @Override\n+                public void setHighlightText(String text) {\n+                    result.setHighlightText(text);\n+                }\n+\n+                @Override\n+                public void runRoot(FileObject root, ClassIndexImpl ci, Exec exec) throws IOException, InterruptedException {\n+                    try {\n+                        Project project = FileOwnerQuery.getOwner(root);\n+\n+                        this.root = root;\n+                        this.projectInfo = project == null ?\n+                                null :\n+                                project.getLookup().lookup(ProjectInformation.class);   //Intentionally does not use ProjectUtils.getInformation() it does project icon annotation which is expensive\n+                        this.ci = ci;\n+                        exec.run();\n+                    } finally {\n+                        this.root = null;\n+                        this.projectInfo = null;\n+                        this.ci = null;\n                     }\n-                    rootUrls.add(root.toURL());\n                 }\n \n-                if (LOGGER.isLoggable(Level.FINE)) {\n-                    LOGGER.log(Level.FINE, \"Querying following roots:\"); //NOI18N\n-                    for (URL url : rootUrls) {\n-                        LOGGER.log(Level.FINE, \"  {0}\", url); //NOI18N\n+                @Override\n+                public void handleResult(ElementHandle<TypeElement> owner, String ident, boolean caseSensitive) {\n+                    final AsyncJavaSymbolDescriptor d = new AsyncJavaSymbolDescriptor(\n+                            projectInfo,\n+                            root,\n+                            ci,\n+                            owner,\n+                            ident,\n+                            caseSensitive);\n+                    result.addResult(d);\n+                    if (cache != null) {\n+                        cache.offer(d);\n                     }\n-                    LOGGER.log(Level.FINE, \"-------------------------\"); //NOI18N\n                 }\n-                //Perform all queries in single op\n-                IndexManager.priorityAccess(new IndexManager.Action<Void>() {\n-                    @Override\n-                    public Void run() throws IOException, InterruptedException {\n-                        for (URL url : rootUrls) {\n-                            if (canceled) {\n-                                return null;\n-                            }\n-                            final FileObject root = URLMapper.findFileObject(url);\n-                            if (root == null) {\n-                                continue;\n-                            }\n-\n-                            final Project project = FileOwnerQuery.getOwner(root);\n-                            final ProjectInformation projectInfo = project == null ?\n-                                    null :\n-                                    project.getLookup().lookup(ProjectInformation.class);   //Intentionally does not use ProjectUtils.getInformation() it does project icon annotation which is expensive\n-                            final ClassIndexImpl impl = manager.getUsagesQuery(root.toURL(), true);\n-                            if (impl != null) {\n+            }, true, canceled);\n+        } finally {\n+            clearCancel();\n+        }\n+    }\n+\n+    public static void doComputeSymbols(SearchType st, String textToSearch, ResultHandler handler, boolean async, AtomicBoolean canceled) {\n+        String prefix = null;\n+        final int dotIndex = textToSearch.lastIndexOf('.'); //NOI18N\n+        if (dotIndex > 0 && dotIndex != textToSearch.length()-1) {\n+            prefix = textToSearch.substring(0, dotIndex);\n+            textToSearch = textToSearch.substring(dotIndex+1);\n+        }\n+        final String textToHighLight = textToSearch;\n+        ClassIndex.NameKind _kind;\n+        boolean _caseSensitive;\n+        switch (st) {\n+            case PREFIX:\n+                _kind = ClassIndex.NameKind.PREFIX;\n+                _caseSensitive = true;\n+                break;\n+            case REGEXP:\n+                _kind = ClassIndex.NameKind.REGEXP;\n+                textToSearch = NameMatcherFactory.wildcardsToRegexp(\n+                        removeNonJavaChars(textToSearch),\n+                        true);\n+                _caseSensitive = true;\n+                break;\n+            case CAMEL_CASE:\n+                _kind = ClassIndex.NameKind.CAMEL_CASE;\n+                _caseSensitive = true;\n+                break;\n+            case CASE_INSENSITIVE_CAMEL_CASE:\n+                _kind = ClassIndex.NameKind.CAMEL_CASE_INSENSITIVE;\n+                _caseSensitive = false;\n+                break;\n+            case EXACT_NAME:\n+                _kind = ClassIndex.NameKind.SIMPLE_NAME;\n+                _caseSensitive = true;\n+                break;\n+            case CASE_INSENSITIVE_PREFIX:\n+                _kind = ClassIndex.NameKind.CASE_INSENSITIVE_PREFIX;\n+                _caseSensitive = false;\n+                break;\n+            case CASE_INSENSITIVE_EXACT_NAME:\n+                _kind = ClassIndex.NameKind.CASE_INSENSITIVE_REGEXP;\n+                _caseSensitive = false;\n+                break;\n+            case CASE_INSENSITIVE_REGEXP:\n+                _kind = ClassIndex.NameKind.CASE_INSENSITIVE_REGEXP;\n+                textToSearch = NameMatcherFactory.wildcardsToRegexp(\n+                        removeNonJavaChars(textToSearch),\n+                        true);\n+                _caseSensitive = false;\n+                break;\n+            default:\n+                throw new IllegalArgumentException();\n+        }\n+        final String ident = textToSearch;\n+        final ClassIndex.NameKind kind = _kind;\n+        final boolean caseSensitive = _caseSensitive;\n+        final Pair<NameMatcher,Boolean> restriction;\n+        if (prefix != null) {\n+            restriction = compileName(prefix,caseSensitive);\n+            handler.setHighlightText(textToHighLight);\n+        } else {\n+            restriction = null;\n+        }\n+        try {\n+            final ClassIndexManager manager = ClassIndexManager.getDefault();\n+\n+            Collection<FileObject> roots = QuerySupport.findRoots(\n+                    (Project)null,\n+                    Collections.singleton(ClassPath.SOURCE),\n+                    Collections.<String>emptySet(),\n+                    Collections.<String>emptySet());\n+\n+            final Set<URL> rootUrls = new HashSet<>();\n+            for(FileObject root : roots) {\n+                if (canceled.get()) {\n+                    return;\n+                }\n+                rootUrls.add(root.toURL());\n+            }\n+\n+            if (LOGGER.isLoggable(Level.FINE)) {\n+                LOGGER.log(Level.FINE, \"Querying following roots:\"); //NOI18N\n+                for (URL url : rootUrls) {\n+                    LOGGER.log(Level.FINE, \"  {0}\", url); //NOI18N\n+                }\n+                LOGGER.log(Level.FINE, \"-------------------------\"); //NOI18N\n+            }\n+            //Perform all queries in single op\n+            IndexManager.priorityAccess(new IndexManager.Action<Void>() {\n+                @Override\n+                public Void run() throws IOException, InterruptedException {\n+                    for (URL url : rootUrls) {\n+                        if (canceled.get()) {\n+                            return null;\n+                        }\n+                        final FileObject root = URLMapper.findFileObject(url);\n+                        if (root == null) {\n+                            continue;\n+                        }\n+\n+                        final ClassIndexImpl impl = manager.getUsagesQuery(root.toURL(), true);\n+                        if (impl != null) {\n+                            handler.runRoot(root, impl, () -> {\n                                 final Map<ElementHandle<TypeElement>,Set<String>> r = new HashMap<>();\n                                 impl.getDeclaredElements(ident, kind, DocumentUtil.typeElementConvertor(),r);\n                                 if (!r.isEmpty()) {\n                                     for (final Map.Entry<ElementHandle<TypeElement>,Set<String>> p : r.entrySet()) {\n                                         final ElementHandle<TypeElement> owner = p.getKey();\n                                         for (String symbol : p.getValue()) {\n                                             if (matchesRestrictions(owner.getQualifiedName(), symbol, restriction, caseSensitive)) {\n-                                                final AsyncJavaSymbolDescriptor d = new AsyncJavaSymbolDescriptor(\n-                                                        projectInfo,\n-                                                        root,\n-                                                        impl,\n-                                                        owner,\n-                                                        symbol,\n-                                                        caseSensitive);\n-                                                result.addResult(d);\n-                                                if (cache != null) {\n-                                                    cache.offer(d);\n-                                                }\n+                                                handler.handleResult(owner, symbol, caseSensitive);\n                                             }\n                                         }\n                                     }\n                                 }\n-                            }\n+                            });\n                         }\n-                        return null;\n                     }\n-                });\n-            } catch (IOException ioe) {\n-                Exceptions.printStackTrace(ioe);\n-            }\n-            catch (InterruptedException ie) {\n-                return;\n-            }\n-        } finally {\n-            clearCancel();\n+                    return null;\n+                }\n+            });\n+        } catch (IOException ioe) {\n+            Exceptions.printStackTrace(ioe);\n+        }\n+        catch (InterruptedException ie) {\n+            return;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "38f9ea82f9c1bee769ce34c47c5efc7b8002f761"}, "originalPosition": 314}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDcyOTYwMDc2", "url": "https://github.com/apache/netbeans/pull/2324#pullrequestreview-472960076", "createdAt": "2020-08-22T20:22:14Z", "commit": {"oid": "38f9ea82f9c1bee769ce34c47c5efc7b8002f761"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMlQyMDoyMjoxNFrOHFH8Hw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMlQyMDoyMjoxNFrOHFH8Hw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTEzNTAwNw==", "bodyText": "Jackpot:\nwarning: Field prj2Server can be final", "url": "https://github.com/apache/netbeans/pull/2324#discussion_r475135007", "createdAt": "2020-08-22T20:22:14Z", "author": {"login": "jlahoda-jackpot"}, "path": "cpplite/cpplite.editor/src/org/netbeans/modules/cpplite/editor/lsp/LanguageServerImpl.java", "diffHunk": "@@ -64,9 +64,10 @@\n })\n public class LanguageServerImpl implements LanguageServerProvider {\n \n+    private static final boolean DEBUG = Boolean.getBoolean(\"cpplite.lsp.debug\");\n     private static final Logger LOG = Logger.getLogger(LanguageServerImpl.class.getName());\n \n-    private Map<Project, LanguageServerDescription> prj2Server = new HashMap<>();\n+    private static Map<Project, LanguageServerDescription> prj2Server = new HashMap<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "38f9ea82f9c1bee769ce34c47c5efc7b8002f761"}, "originalPosition": 8}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDcyOTYwMDc4", "url": "https://github.com/apache/netbeans/pull/2324#pullrequestreview-472960078", "createdAt": "2020-08-22T20:22:16Z", "commit": {"oid": "38f9ea82f9c1bee769ce34c47c5efc7b8002f761"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMlQyMDoyMjoxNlrOHFH8IQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMlQyMDoyMjoxNlrOHFH8IQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTEzNTAwOQ==", "bodyText": "Jackpot:\nwarning: Variable requiresCustomFiltering is never read", "url": "https://github.com/apache/netbeans/pull/2324#discussion_r475135009", "createdAt": "2020-08-22T20:22:16Z", "author": {"login": "jlahoda-jackpot"}, "path": "ide/jumpto/src/org/netbeans/spi/jumpto/symbol/SymbolProvider.java", "diffHunk": "@@ -198,6 +198,7 @@ public void setSymbolProvider(SymbolDescriptor desc, SymbolProvider provider) {\n         private boolean dirty;\n         private boolean highlightTextAlreadySet;\n         private int retry;\n+        private boolean requiresCustomFiltering;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "38f9ea82f9c1bee769ce34c47c5efc7b8002f761"}, "originalPosition": 4}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDcyOTYwMDgz", "url": "https://github.com/apache/netbeans/pull/2324#pullrequestreview-472960083", "createdAt": "2020-08-22T20:22:19Z", "commit": {"oid": "38f9ea82f9c1bee769ce34c47c5efc7b8002f761"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMlQyMDoyMjoxOVrOHFH8JQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMlQyMDoyMjoxOVrOHFH8JQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTEzNTAxMw==", "bodyText": "Jackpot:\nwarning: Add @OverRide Annotation", "url": "https://github.com/apache/netbeans/pull/2324#discussion_r475135013", "createdAt": "2020-08-22T20:22:19Z", "author": {"login": "jlahoda-jackpot"}, "path": "ide/lsp.client/src/org/netbeans/modules/lsp/client/bindings/TypeProviderImpl.java", "diffHunk": "@@ -0,0 +1,126 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.netbeans.modules.lsp.client.bindings;\n+\n+import java.util.EnumSet;\n+import java.util.Set;\n+import javax.swing.Icon;\n+import org.eclipse.lsp4j.SymbolInformation;\n+import org.eclipse.lsp4j.SymbolKind;\n+import org.netbeans.spi.jumpto.type.TypeDescriptor;\n+import org.netbeans.spi.jumpto.type.TypeProvider;\n+import org.openide.filesystems.FileObject;\n+import org.openide.util.NbBundle.Messages;\n+import org.openide.util.lookup.ServiceProvider;\n+\n+/**\n+ *\n+ * @author lahvac\n+ */\n+@ServiceProvider(service=TypeProvider.class)\n+public class TypeProviderImpl extends BaseSymbolProvider implements TypeProvider {\n+\n+    private static final Set<SymbolKind> TYPE_KINDS = EnumSet.of(\n+            SymbolKind.Class, SymbolKind.Enum, SymbolKind.Interface,\n+            SymbolKind.Struct\n+    );\n+\n+    @Override\n+    @Messages(\"DN_TypeProviderImpl=Language Server Type Provider\")\n+    public String getDisplayName() {\n+        return Bundle.DN_TypeProviderImpl();\n+    }\n+\n+    @Override\n+    public void computeTypeNames(Context context, Result result) {\n+        computeSymbolNames(context.getSearchType(),\n+                           context.getText(),\n+                           (info, simpleName) -> {\n+                               if (TYPE_KINDS.contains(info.getKind())) {\n+                                   result.addResult(new TypeDescriptorImpl(info, simpleName));\n+                               }\n+                           });\n+    }\n+\n+    public static class TypeDescriptorImpl extends TypeDescriptor implements BaseSymbolDescriptor {\n+\n+        private final SymbolInformation info;\n+        private final String simpleName;\n+\n+        public TypeDescriptorImpl(SymbolInformation info, String simpleName) {\n+            this.info = info;\n+            this.simpleName = simpleName;\n+        }\n+\n+        public SymbolInformation getInfo() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "38f9ea82f9c1bee769ce34c47c5efc7b8002f761"}, "originalPosition": 71}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDcyOTYwMDk3", "url": "https://github.com/apache/netbeans/pull/2324#pullrequestreview-472960097", "createdAt": "2020-08-22T20:22:33Z", "commit": {"oid": "38f9ea82f9c1bee769ce34c47c5efc7b8002f761"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMlQyMDoyMjozM1rOHFH8Ow==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMlQyMDoyMjozM1rOHFH8Ow==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTEzNTAzNQ==", "bodyText": "Jackpot:\nwarning: Can use functional operations", "url": "https://github.com/apache/netbeans/pull/2324#discussion_r475135035", "createdAt": "2020-08-22T20:22:33Z", "author": {"login": "jlahoda-jackpot"}, "path": "ide/lsp.client/src/org/netbeans/modules/lsp/client/bindings/CustomIndexerImpl.java", "diffHunk": "@@ -0,0 +1,143 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.netbeans.modules.lsp.client.bindings;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.util.HashSet;\n+import java.util.Set;\n+import java.util.function.Consumer;\n+import org.netbeans.api.editor.mimelookup.MimeRegistration;\n+import org.netbeans.api.project.FileOwnerQuery;\n+import org.netbeans.api.project.Project;\n+import org.netbeans.modules.lsp.client.LSPBindings;\n+import org.netbeans.modules.parsing.spi.indexing.Context;\n+import org.netbeans.modules.parsing.spi.indexing.CustomIndexer;\n+import org.netbeans.modules.parsing.spi.indexing.CustomIndexerFactory;\n+import org.netbeans.modules.parsing.spi.indexing.Indexable;\n+import org.openide.filesystems.FileObject;\n+import org.openide.filesystems.FileUtil;\n+import org.openide.util.EditableProperties;\n+import org.openide.util.Exceptions;\n+import org.openide.util.RequestProcessor;\n+\n+/**\n+ *\n+ * @author lahvac\n+ */\n+public class CustomIndexerImpl extends CustomIndexer {\n+\n+    private static final RequestProcessor WORKER = new RequestProcessor(CustomIndexerImpl.class.getName(), 1, false, false);\n+\n+    @Override\n+    protected void index(Iterable<? extends Indexable> files, Context context) {\n+        handleStoredFiles(context, props -> {\n+            FileObject root = context.getRoot();\n+            for (Indexable i : files) {\n+                FileObject file = root.getFileObject(i.getRelativePath());\n+                if (file != null) {\n+                    props.setProperty(i.getRelativePath(), FileUtil.getMIMEType(file));\n+                }\n+            }\n+\n+            Set<String> mimeTypes = new HashSet<>(props.values());\n+            System.err.println(\"mimeTypes=\" + mimeTypes);\n+            Project prj = FileOwnerQuery.getOwner(root);\n+\n+            if (prj != null) {\n+                WORKER.post(() -> {\n+                    for (String mimeType : mimeTypes) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "38f9ea82f9c1bee769ce34c47c5efc7b8002f761"}, "originalPosition": 66}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDcyOTYwMTAy", "url": "https://github.com/apache/netbeans/pull/2324#pullrequestreview-472960102", "createdAt": "2020-08-22T20:22:35Z", "commit": {"oid": "38f9ea82f9c1bee769ce34c47c5efc7b8002f761"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMlQyMDoyMjozNlrOHFH8Rw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMlQyMDoyMjozNlrOHFH8Rw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTEzNTA0Nw==", "bodyText": "Jackpot:\nwarning: Add @OverRide Annotation", "url": "https://github.com/apache/netbeans/pull/2324#discussion_r475135047", "createdAt": "2020-08-22T20:22:36Z", "author": {"login": "jlahoda-jackpot"}, "path": "ide/lsp.client/src/org/netbeans/modules/lsp/client/bindings/SymbolProviderImpl.java", "diffHunk": "@@ -0,0 +1,107 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.netbeans.modules.lsp.client.bindings;\n+\n+import javax.swing.Icon;\n+import org.eclipse.lsp4j.SymbolInformation;\n+import org.netbeans.spi.jumpto.symbol.SymbolDescriptor;\n+import org.netbeans.spi.jumpto.symbol.SymbolProvider;\n+import org.openide.filesystems.FileObject;\n+import org.openide.util.NbBundle.Messages;\n+import org.openide.util.lookup.ServiceProvider;\n+\n+/**\n+ *\n+ * @author lahvac\n+ */\n+@ServiceProvider(service=SymbolProvider.class)\n+public class SymbolProviderImpl extends BaseSymbolProvider implements SymbolProvider {\n+\n+    @Override\n+    @Messages(\"DN_getDisplayName=Language Server Symbol Provider\")\n+    public String getDisplayName() {\n+        return Bundle.DN_Symbols();\n+    }\n+\n+    @Override\n+    public void computeSymbolNames(Context context, Result result) {\n+        computeSymbolNames(context.getSearchType(), context.getText(), (info, simpleName) -> result.addResult(new SymbolDescriptorImpl(info, simpleName)));\n+    }\n+\n+    public static class SymbolDescriptorImpl extends SymbolDescriptor implements BaseSymbolDescriptor {\n+\n+        private final SymbolInformation info;\n+        private final String simpleName;\n+\n+        public SymbolDescriptorImpl(SymbolInformation info, String simpleName) {\n+            this.info = info;\n+            this.simpleName = simpleName;\n+        }\n+\n+        public SymbolInformation getInfo() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "38f9ea82f9c1bee769ce34c47c5efc7b8002f761"}, "originalPosition": 57}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c4da1314cf2b1d0fe35bfbac857436a6eadc40bc", "author": {"user": {"login": "jlahoda", "name": "Jan Lahoda"}}, "url": "https://github.com/apache/netbeans/commit/c4da1314cf2b1d0fe35bfbac857436a6eadc40bc", "committedDate": "2020-09-16T05:48:47Z", "message": "Fixing issues found by Jackpot."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "63465789eb24005fed6b624ebbc46e413caa5df4", "author": {"user": {"login": "jlahoda", "name": "Jan Lahoda"}}, "url": "https://github.com/apache/netbeans/commit/63465789eb24005fed6b624ebbc46e413caa5df4", "committedDate": "2020-09-16T20:05:24Z", "message": "Merge branch 'master' into workspace/symbol"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "25b7c3ad8238775ba19f51dbd4174c9a2e4266a8", "author": {"user": {"login": "jlahoda", "name": "Jan Lahoda"}}, "url": "https://github.com/apache/netbeans/commit/25b7c3ad8238775ba19f51dbd4174c9a2e4266a8", "committedDate": "2020-09-17T05:34:10Z", "message": "Fixing problems in merge."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9ce48689f69425a41589aa95b58a7d641cca16de", "author": {"user": {"login": "jlahoda", "name": "Jan Lahoda"}}, "url": "https://github.com/apache/netbeans/commit/9ce48689f69425a41589aa95b58a7d641cca16de", "committedDate": "2020-10-15T05:47:09Z", "message": "Merging master into workspace/symbol."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "48f32eb7d79074465559e5a4ce016a486c98c113", "author": {"user": {"login": "jlahoda", "name": "Jan Lahoda"}}, "url": "https://github.com/apache/netbeans/commit/48f32eb7d79074465559e5a4ce016a486c98c113", "committedDate": "2020-10-16T05:20:53Z", "message": "Fixing dependencies."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE2MTY1MTAw", "url": "https://github.com/apache/netbeans/pull/2324#pullrequestreview-516165100", "createdAt": "2020-10-24T06:52:04Z", "commit": {"oid": "48f32eb7d79074465559e5a4ce016a486c98c113"}, "state": "APPROVED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNFQwNjo1MjowNVrOHnpEXw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNFQwNjo1Njo1NlrOHnpF3A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTMyOTM3NQ==", "bodyText": "Using Logger would be more standard. See Logging in NetBeans document.", "url": "https://github.com/apache/netbeans/pull/2324#discussion_r511329375", "createdAt": "2020-10-24T06:52:05Z", "author": {"login": "JaroslavTulach"}, "path": "cpplite/cpplite.editor/src/org/netbeans/modules/cpplite/editor/lsp/LanguageServerImpl.java", "diffHunk": "@@ -64,9 +64,10 @@\n })\n public class LanguageServerImpl implements LanguageServerProvider {\n \n+    private static final boolean DEBUG = Boolean.getBoolean(\"cpplite.lsp.debug\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "48f32eb7d79074465559e5a4ce016a486c98c113"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTMyOTU2NA==", "bodyText": "I see. This is the way to specify client capabilities! CCing @sdedic.", "url": "https://github.com/apache/netbeans/pull/2324#discussion_r511329564", "createdAt": "2020-10-24T06:54:32Z", "author": {"login": "JaroslavTulach"}, "path": "ide/lsp.client/src/org/netbeans/modules/lsp/client/LSPBindings.java", "diffHunk": "@@ -232,6 +250,8 @@ private static InitializeResult initServer(Process p, LanguageServer server, Fil\n        wcc.setWorkspaceEdit(new WorkspaceEditCapabilities());\n        wcc.getWorkspaceEdit().setDocumentChanges(true);\n        wcc.getWorkspaceEdit().setResourceOperations(Arrays.asList(ResourceOperationKind.Create, ResourceOperationKind.Delete, ResourceOperationKind.Rename));\n+       SymbolCapabilities sc = new SymbolCapabilities(new SymbolKindCapabilities(Arrays.asList(SymbolKind.values())));\n+       wcc.setSymbol(sc);\n        initParams.setCapabilities(new ClientCapabilities(wcc, tdcc, null));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "48f32eb7d79074465559e5a4ce016a486c98c113"}, "originalPosition": 124}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTMyOTc1Ng==", "bodyText": "I'd slightly prefer to open up the module to public to adding yet another friend.\nIn any case, you have to do proper versioning. Increase the module spec version and make the new friend request that version. See the friend dependencies essay.", "url": "https://github.com/apache/netbeans/pull/2324#discussion_r511329756", "createdAt": "2020-10-24T06:56:56Z", "author": {"login": "JaroslavTulach"}, "path": "ide/parsing.lucene/nbproject/project.xml", "diffHunk": "@@ -85,6 +85,7 @@\n             </test-dependencies>\n             <friend-packages>\n                 <friend>org.netbeans.modules.cnd.indexing</friend>\n+                <friend>org.netbeans.modules.java.lsp.server</friend>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "48f32eb7d79074465559e5a4ce016a486c98c113"}, "originalPosition": 4}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8db982b4378a52e2eef9a1d6ded6ea30f6106feb", "author": {"user": {"login": "jlahoda", "name": "Jan Lahoda"}}, "url": "https://github.com/apache/netbeans/commit/8db982b4378a52e2eef9a1d6ded6ea30f6106feb", "committedDate": "2020-10-24T12:00:38Z", "message": "Merging master into workspace/symbol."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "bc3b774488639391dabb8eb3eccbbcba92e18ed1", "author": {"user": {"login": "jlahoda", "name": "Jan Lahoda"}}, "url": "https://github.com/apache/netbeans/commit/bc3b774488639391dabb8eb3eccbbcba92e18ed1", "committedDate": "2020-10-24T12:06:15Z", "message": "Incrementing spec versions, as suggested."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "903433f01b1578cde184f6ea85f3c651e42b7e5f", "author": {"user": {"login": "jlahoda", "name": "Jan Lahoda"}}, "url": "https://github.com/apache/netbeans/commit/903433f01b1578cde184f6ea85f3c651e42b7e5f", "committedDate": "2020-10-24T19:17:34Z", "message": "Using Loggers instead of a system property."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "46b35977d414ccc8ef00a9261c84d88f0bdcc0be", "author": {"user": {"login": "jlahoda", "name": "Jan Lahoda"}}, "url": "https://github.com/apache/netbeans/commit/46b35977d414ccc8ef00a9261c84d88f0bdcc0be", "committedDate": "2020-11-17T07:04:05Z", "message": "Merging master into workspace/symbol"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d5f6e0b2bd161ead5a40381c9db28b415eb361d6", "author": {"user": {"login": "jlahoda", "name": "Jan Lahoda"}}, "url": "https://github.com/apache/netbeans/commit/d5f6e0b2bd161ead5a40381c9db28b415eb361d6", "committedDate": "2020-11-17T07:05:25Z", "message": "Cleanup."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ2MDY5Mzgz", "url": "https://github.com/apache/netbeans/pull/2324#pullrequestreview-546069383", "createdAt": "2020-12-07T11:42:17Z", "commit": {"oid": "d5f6e0b2bd161ead5a40381c9db28b415eb361d6"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wN1QxMTo0MjoxN1rOIAiyQQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wN1QxMTo0MjoxN1rOIAiyQQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzQ0MDgzMw==", "bodyText": "@jlahoda We get this in an output window when we run a module.  What is this for?\nmimeTypes=[text/xml, text/x-properties, text/plain, text/x-diff, content/unknown, text/x-php5]\nmimeTypes=[text/xml, text/x-properties, text/plain, text/x-diff, content/unknown, text/x-php5]\nmimeTypes=[text/xml, text/x-properties, text/plain, text/x-diff, content/unknown, text/x-php5]\nmimeTypes=[text/xml, text/x-properties, text/plain, text/x-diff, content/unknown, text/x-php5]\nmimeTypes=[text/xml, text/x-properties, text/plain, text/x-diff, content/unknown, text/x-php5]\nmimeTypes=[text/xml, text/x-properties, text/plain, text/x-diff, content/unknown, text/x-php5]\nmimeTypes=[text/xml, text/x-properties, text/plain, text/x-diff, content/unknown, text/x-php5]\nINFO [org.netbeans.modules.bugtracking.BugtrackingManager]: Loading stored repositories took 47 millis.\nmimeTypes=[text/xml, text/x-properties, text/plain, text/x-diff, content/unknown, text/x-php5]\nmimeTypes=[text/xml, text/x-properties, text/plain, text/x-diff, content/unknown, text/x-php5]\nmimeTypes=[text/xml, text/x-properties, text/plain, text/x-diff, content/unknown, text/x-php5]\nmimeTypes=[text/xml, text/x-properties, text/plain, text/x-diff, content/unknown, text/x-php5]", "url": "https://github.com/apache/netbeans/pull/2324#discussion_r537440833", "createdAt": "2020-12-07T11:42:17Z", "author": {"login": "junichi11"}, "path": "ide/lsp.client/src/org/netbeans/modules/lsp/client/bindings/CustomIndexerImpl.java", "diffHunk": "@@ -0,0 +1,143 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.netbeans.modules.lsp.client.bindings;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.util.HashSet;\n+import java.util.Set;\n+import java.util.function.Consumer;\n+import org.netbeans.api.editor.mimelookup.MimeRegistration;\n+import org.netbeans.api.project.FileOwnerQuery;\n+import org.netbeans.api.project.Project;\n+import org.netbeans.modules.lsp.client.LSPBindings;\n+import org.netbeans.modules.parsing.spi.indexing.Context;\n+import org.netbeans.modules.parsing.spi.indexing.CustomIndexer;\n+import org.netbeans.modules.parsing.spi.indexing.CustomIndexerFactory;\n+import org.netbeans.modules.parsing.spi.indexing.Indexable;\n+import org.openide.filesystems.FileObject;\n+import org.openide.filesystems.FileUtil;\n+import org.openide.util.EditableProperties;\n+import org.openide.util.Exceptions;\n+import org.openide.util.RequestProcessor;\n+\n+/**\n+ *\n+ * @author lahvac\n+ */\n+public class CustomIndexerImpl extends CustomIndexer {\n+\n+    private static final RequestProcessor WORKER = new RequestProcessor(CustomIndexerImpl.class.getName(), 1, false, false);\n+\n+    @Override\n+    protected void index(Iterable<? extends Indexable> files, Context context) {\n+        handleStoredFiles(context, props -> {\n+            FileObject root = context.getRoot();\n+            for (Indexable i : files) {\n+                FileObject file = root.getFileObject(i.getRelativePath());\n+                if (file != null) {\n+                    props.setProperty(i.getRelativePath(), FileUtil.getMIMEType(file));\n+                }\n+            }\n+\n+            Set<String> mimeTypes = new HashSet<>(props.values());\n+            System.err.println(\"mimeTypes=\" + mimeTypes);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d5f6e0b2bd161ead5a40381c9db28b415eb361d6"}, "originalPosition": 61}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3997, "cost": 1, "resetAt": "2021-10-28T18:00:02Z"}}}