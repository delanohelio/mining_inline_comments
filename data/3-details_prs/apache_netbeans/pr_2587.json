{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTM3MTE1MTI5", "number": 2587, "title": "Existing CodeGenerators exposed as CodeActions via LSP.", "bodyText": "Following actions are provided:\n\nGenerate Constructor\nGenerate Getters/Setters\nGenerate equals() and hashCode()\nGenerate toString()\nGenerate Delegate Methods\nGenerate Override/Implement Method\nGenerate Logger", "createdAt": "2020-12-11T16:30:36Z", "url": "https://github.com/apache/netbeans/pull/2587", "merged": true, "mergeCommit": {"oid": "b6104f59cea7350169f9d0737350bc71225b1e6c"}, "closed": true, "closedAt": "2020-12-15T18:00:42Z", "author": {"login": "dbalek"}, "timelineItems": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdlIoaggH2gAyNTM3MTE1MTI5OmMzMjE4NjJmMDJhZDY2NjMxM2JhMzU0MzM1MzkxNTBhOTYyYzVkZGY=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdmbhkyAH2gAyNTM3MTE1MTI5OjExZDBhMzgyZGJiYWU0OTBjNmYxOGM0M2I1Y2UyNDM5NDJiNTA5MDc=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "c321862f02ad666313ba35433539150a962c5ddf", "author": {"user": {"login": "dbalek", "name": "Dusan Balek"}}, "url": "https://github.com/apache/netbeans/commit/c321862f02ad666313ba35433539150a962c5ddf", "committedDate": "2020-12-11T14:15:49Z", "message": "Exisitng CodeGenerators exposed as CodeActions via LSP."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTUxMDQzMTIw", "url": "https://github.com/apache/netbeans/pull/2587#pullrequestreview-551043120", "createdAt": "2020-12-14T04:56:35Z", "commit": {"oid": "c321862f02ad666313ba35433539150a962c5ddf"}, "state": "APPROVED", "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNFQwNDo1NjozNVrOIE_3ww==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNFQwNToxMDo0N1rOIFAHYw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjExMTY4Mw==", "bodyText": "Great. This is the UI interaction I was dreaming of.", "url": "https://github.com/apache/netbeans/pull/2587#discussion_r542111683", "createdAt": "2020-12-14T04:56:35Z", "author": {"login": "JaroslavTulach"}, "path": "java/java.lsp.server/src/org/netbeans/modules/java/lsp/server/protocol/NbCodeLanguageClient.java", "diffHunk": "@@ -40,7 +43,25 @@\n      */\n     @JsonNotification(\"window/showStatusBarMessage\")\n     public void showStatusBarMessage(@NonNull ShowStatusMessageParams params);\n-    \n+\n+    /**\n+     * Shows a selection list allowing multiple selections.\n+     *\n+     * @param params input parameters\n+     * @return selected items\n+     */\n+    @JsonRequest(\"window/showQuickPick\")\n+    public CompletableFuture<List<QuickPickItem>> showQuickPick(@NonNull ShowQuickPickParams params);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c321862f02ad666313ba35433539150a962c5ddf"}, "originalPosition": 25}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjExMjY1Ng==", "bodyText": "What happens when the dialog is cancelled? I guess here it returns undefined. How does that look on the Java side?", "url": "https://github.com/apache/netbeans/pull/2587#discussion_r542112656", "createdAt": "2020-12-14T05:00:07Z", "author": {"login": "JaroslavTulach"}, "path": "java/java.lsp.server/vscode/src/extension.ts", "diffHunk": "@@ -442,6 +418,13 @@ function doActivateWithJDK(specifiedJDK: string | null, context: ExtensionContex\n             commands.executeCommand('setContext', 'nbJavaLSReady', true);\n             c.onNotification(StatusMessageRequest.type, showStatusBarMessage);\n             c.onNotification(LogMessageNotification.type, (param) => handleLog(log, param.message));\n+            c.onRequest(QuickPickRequest.type, async param => {\n+                const selected = await window.showQuickPick(param.items, { placeHolder: param.placeHolder, canPickMany: param.canPickMany });\n+                return selected ? Array.isArray(selected) ? selected : [selected] : undefined;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c321862f02ad666313ba35433539150a962c5ddf"}, "originalPosition": 46}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjExMzMyOA==", "bodyText": "A lot of registrations is removed. However I assume they are somehow added back, right?", "url": "https://github.com/apache/netbeans/pull/2587#discussion_r542113328", "createdAt": "2020-12-14T05:02:33Z", "author": {"login": "JaroslavTulach"}, "path": "java/java.lsp.server/vscode/package.json", "diffHunk": "@@ -140,21 +140,6 @@\n \t\t\t\t\"title\": \"Compile Workspace\",\n \t\t\t\t\"category\": \"Java\"\n \t\t\t},\n-\t\t\t{\n-\t\t\t\t\"command\": \"java.generate.getters.menu\",", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c321862f02ad666313ba35433539150a962c5ddf"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjExNDEwOQ==", "bodyText": "I guess this is the place that instructs VSCode to show the code generator actions.", "url": "https://github.com/apache/netbeans/pull/2587#discussion_r542114109", "createdAt": "2020-12-14T05:05:29Z", "author": {"login": "JaroslavTulach"}, "path": "java/java.lsp.server/src/org/netbeans/modules/java/lsp/server/protocol/TextDocumentServiceImpl.java", "diffHunk": "@@ -1063,20 +1044,10 @@ protected void performRewrite(JavaFix.TransformationContext ctx) throws Exceptio\n         try {\n             js.runUserActionTask(cc -> {\n                 cc.toPhase(JavaSource.Phase.RESOLVED);\n-\n-                Pair<Set<VariableElement>, Set<VariableElement>> pair = GetterSetterGenerator.findMissingGettersSetters(cc, params.getRange(), false);\n-                boolean missingGetters = !pair.first().isEmpty();\n-                boolean missingSetters = !pair.second().isEmpty();\n-                String uri = toUri(cc.getFileObject());\n-\n-                if (missingGetters) {\n-                    result.add(Either.forRight(createCodeGeneratorAction(Bundle.DN_GenerateGetters(), Server.GENERATE_GETTERS, uri, params.getRange())));\n-                }\n-                if (missingSetters) {\n-                    result.add(Either.forRight(createCodeGeneratorAction(Bundle.DN_GenerateSetters(), Server.GENERATE_SETTERS, uri, params.getRange())));\n-                }\n-                if (missingGetters && missingSetters) {\n-                    result.add(Either.forRight(createCodeGeneratorAction(Bundle.DN_GenerateGettersSetters(), Server.GENERATE_GETTERS_SETTERS, uri, params.getRange())));\n+                for (CodeGenerator codeGenerator : Server.CODE_GENERATORS) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c321862f02ad666313ba35433539150a962c5ddf"}, "originalPosition": 70}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjExNTY4Mw==", "bodyText": "Using jar:file URLs is quite frequent and it would ge good to get it working more properly. There is a URLMapper in the file system API where one can request EXTERNAL URL. Wouldn't it be better to get it working for jar:file?", "url": "https://github.com/apache/netbeans/pull/2587#discussion_r542115683", "createdAt": "2020-12-14T05:10:47Z", "author": {"login": "JaroslavTulach"}, "path": "java/java.lsp.server/src/org/netbeans/modules/java/lsp/server/protocol/CodeGenerator.java", "diffHunk": "@@ -0,0 +1,312 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.netbeans.modules.java.lsp.server.protocol;\n+\n+import com.sun.source.tree.LineMap;\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.io.UncheckedIOException;\n+import java.net.MalformedURLException;\n+import java.net.URI;\n+import java.nio.file.Files;\n+import java.util.Arrays;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Properties;\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+import javax.lang.model.element.Element;\n+import javax.lang.model.element.ElementKind;\n+import javax.lang.model.element.ExecutableElement;\n+import javax.lang.model.element.TypeElement;\n+import javax.lang.model.element.TypeParameterElement;\n+import javax.lang.model.element.VariableElement;\n+import javax.lang.model.type.ArrayType;\n+import javax.lang.model.type.TypeKind;\n+import javax.lang.model.type.TypeMirror;\n+import org.eclipse.lsp4j.CodeAction;\n+import org.eclipse.lsp4j.CodeActionParams;\n+import org.eclipse.lsp4j.Command;\n+import org.eclipse.lsp4j.Position;\n+import org.eclipse.xtext.xbase.lib.Pure;\n+import org.netbeans.api.java.source.CompilationInfo;\n+import org.netbeans.api.java.source.ElementHandle;\n+import org.netbeans.modules.editor.java.Utilities;\n+import org.netbeans.modules.java.source.ElementHandleAccessor;\n+import org.openide.filesystems.FileObject;\n+import org.openide.filesystems.FileUtil;\n+import org.openide.filesystems.URLMapper;\n+import org.openide.modules.Places;\n+import org.openide.util.Exceptions;\n+\n+/**\n+ *\n+ * @author Dusan Balek\n+ */\n+public abstract class CodeGenerator {\n+\n+    public static final String CODE_GENERATOR_KIND = \"source.generate\";\n+    protected static final String ERROR = \"<error>\"; //NOI18N\n+\n+    public abstract List<CodeAction> getCodeActions(CompilationInfo info, CodeActionParams params);\n+\n+    public abstract Set<String> getCommands();\n+\n+    public abstract CompletableFuture<Object> processCommand(NbCodeLanguageClient client, String command, List<Object> arguments);\n+\n+    protected static int getOffset(CompilationInfo info, Position pos) {\n+        LineMap lm = info.getCompilationUnit().getLineMap();\n+        return (int) lm.getPosition(pos.getLine() + 1, pos.getCharacter() + 1);\n+    }\n+\n+    protected static CodeAction createCodeAction(String name, String kind, String command, Object... args) {\n+        CodeAction action = new CodeAction(name);\n+        action.setKind(kind);\n+        action.setCommand(new Command(name, command, Arrays.asList(args)));\n+        return action;\n+    }\n+\n+    protected static String toUri(FileObject file) {\n+        if (FileUtil.isArchiveArtifact(file)) {\n+            //VS code cannot open jar:file: URLs, workaround:", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c321862f02ad666313ba35433539150a962c5ddf"}, "originalPosition": 92}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4165983e6b010879475ed67961486fe3b278e364", "author": {"user": {"login": "dbalek", "name": "Dusan Balek"}}, "url": "https://github.com/apache/netbeans/commit/4165983e6b010879475ed67961486fe3b278e364", "committedDate": "2020-12-15T08:44:28Z", "message": "Using Utils.toUri() in CodeGenerators."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTUyMjY1MjA4", "url": "https://github.com/apache/netbeans/pull/2587#pullrequestreview-552265208", "createdAt": "2020-12-15T09:38:11Z", "commit": {"oid": "4165983e6b010879475ed67961486fe3b278e364"}, "state": "COMMENTED", "comments": {"totalCount": 20, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNVQwOTozODoxMlrOIGBnIQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNVQxMDozMTo0NFrOIGD99Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzE4ODc2OQ==", "bodyText": "Nitpick: isn't fieldType.getKind() == TypeKind.ERROR better ?\nQuestin (self-edu): what type field types are not primitive+array or DECLARED ?", "url": "https://github.com/apache/netbeans/pull/2587#discussion_r543188769", "createdAt": "2020-12-15T09:38:12Z", "author": {"login": "sdedic"}, "path": "java/java.lsp.server/src/org/netbeans/modules/java/lsp/server/protocol/DelegateMethodGenerator.java", "diffHunk": "@@ -0,0 +1,210 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.netbeans.modules.java.lsp.server.protocol;\n+\n+import com.google.gson.Gson;\n+import com.sun.source.tree.Scope;\n+import com.sun.source.util.TreePath;\n+import com.sun.source.util.Trees;\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.stream.Collectors;\n+import javax.lang.model.element.Element;\n+import javax.lang.model.element.ElementKind;\n+import javax.lang.model.element.ExecutableElement;\n+import javax.lang.model.element.Modifier;\n+import javax.lang.model.element.TypeElement;\n+import javax.lang.model.element.VariableElement;\n+import javax.lang.model.type.DeclaredType;\n+import javax.lang.model.type.TypeKind;\n+import javax.lang.model.type.TypeMirror;\n+import javax.lang.model.util.ElementFilter;\n+import javax.lang.model.util.Elements;\n+import org.eclipse.lsp4j.ApplyWorkspaceEditParams;\n+import org.eclipse.lsp4j.CodeAction;\n+import org.eclipse.lsp4j.CodeActionKind;\n+import org.eclipse.lsp4j.CodeActionParams;\n+import org.eclipse.lsp4j.MessageParams;\n+import org.eclipse.lsp4j.MessageType;\n+import org.eclipse.lsp4j.TextEdit;\n+import org.eclipse.lsp4j.WorkspaceEdit;\n+import org.netbeans.api.java.source.CompilationInfo;\n+import org.netbeans.api.java.source.ElementUtilities;\n+import org.netbeans.api.java.source.JavaSource;\n+import org.netbeans.api.java.source.TreeUtilities;\n+import org.netbeans.modules.java.lsp.server.Utils;\n+import org.openide.filesystems.FileObject;\n+import org.openide.util.NbBundle;\n+\n+/**\n+ *\n+ * @author Dusan Balek\n+ */\n+public final class DelegateMethodGenerator extends CodeGenerator {\n+\n+    public static final String GENERATE_DELEGATE_METHOD =  \"java.generate.delegateMethod\";\n+\n+    private final Set<String> commands = Collections.singleton(GENERATE_DELEGATE_METHOD);\n+    private final Gson gson = new Gson();\n+\n+    DelegateMethodGenerator() {\n+    }\n+\n+    @Override\n+    @NbBundle.Messages({\n+        \"DN_GenerateDelegateMethod=Generate Delegate Method...\",\n+    })\n+    public List<CodeAction> getCodeActions(CompilationInfo info, CodeActionParams params) {\n+        List<String> only = params.getContext().getOnly();\n+        if (only == null || !only.contains(CodeActionKind.Source)) {\n+            return Collections.emptyList();\n+        }\n+        int offset = getOffset(info, params.getRange().getStart());\n+        TreePath tp = info.getTreeUtilities().pathFor(offset);\n+        tp = info.getTreeUtilities().getPathElementOfKind(TreeUtilities.CLASS_TREE_KINDS, tp);\n+        if (tp == null) {\n+            return Collections.emptyList();\n+        }\n+        TypeElement typeElement = (TypeElement) info.getTrees().getElement(tp);\n+        if (typeElement == null || !typeElement.getKind().isClass()) {\n+            return Collections.emptyList();\n+        }\n+        Elements elements = info.getElements();\n+        Trees trees = info.getTrees();\n+        Scope scope = trees.getScope(tp);\n+        List<QuickPickItem> fields = new ArrayList<>();\n+        TypeElement cls;\n+        while (scope != null && (cls = scope.getEnclosingClass()) != null) {\n+            DeclaredType type = (DeclaredType) cls.asType();\n+            for (VariableElement field : ElementFilter.fieldsIn(elements.getAllMembers(cls))) {\n+                TypeMirror fieldType = field.asType();\n+                if (!ERROR.contentEquals(field.getSimpleName()) && !fieldType.getKind().isPrimitive() && fieldType.getKind() != TypeKind.ARRAY", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4165983e6b010879475ed67961486fe3b278e364"}, "originalPosition": 102}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzE4ODgyMQ==", "bodyText": "Q: shouldn't the server log a message, if client sends malformed msg (too few arguments) ?", "url": "https://github.com/apache/netbeans/pull/2587#discussion_r543188821", "createdAt": "2020-12-15T09:38:17Z", "author": {"login": "sdedic"}, "path": "java/java.lsp.server/src/org/netbeans/modules/java/lsp/server/protocol/DelegateMethodGenerator.java", "diffHunk": "@@ -0,0 +1,210 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.netbeans.modules.java.lsp.server.protocol;\n+\n+import com.google.gson.Gson;\n+import com.sun.source.tree.Scope;\n+import com.sun.source.util.TreePath;\n+import com.sun.source.util.Trees;\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.stream.Collectors;\n+import javax.lang.model.element.Element;\n+import javax.lang.model.element.ElementKind;\n+import javax.lang.model.element.ExecutableElement;\n+import javax.lang.model.element.Modifier;\n+import javax.lang.model.element.TypeElement;\n+import javax.lang.model.element.VariableElement;\n+import javax.lang.model.type.DeclaredType;\n+import javax.lang.model.type.TypeKind;\n+import javax.lang.model.type.TypeMirror;\n+import javax.lang.model.util.ElementFilter;\n+import javax.lang.model.util.Elements;\n+import org.eclipse.lsp4j.ApplyWorkspaceEditParams;\n+import org.eclipse.lsp4j.CodeAction;\n+import org.eclipse.lsp4j.CodeActionKind;\n+import org.eclipse.lsp4j.CodeActionParams;\n+import org.eclipse.lsp4j.MessageParams;\n+import org.eclipse.lsp4j.MessageType;\n+import org.eclipse.lsp4j.TextEdit;\n+import org.eclipse.lsp4j.WorkspaceEdit;\n+import org.netbeans.api.java.source.CompilationInfo;\n+import org.netbeans.api.java.source.ElementUtilities;\n+import org.netbeans.api.java.source.JavaSource;\n+import org.netbeans.api.java.source.TreeUtilities;\n+import org.netbeans.modules.java.lsp.server.Utils;\n+import org.openide.filesystems.FileObject;\n+import org.openide.util.NbBundle;\n+\n+/**\n+ *\n+ * @author Dusan Balek\n+ */\n+public final class DelegateMethodGenerator extends CodeGenerator {\n+\n+    public static final String GENERATE_DELEGATE_METHOD =  \"java.generate.delegateMethod\";\n+\n+    private final Set<String> commands = Collections.singleton(GENERATE_DELEGATE_METHOD);\n+    private final Gson gson = new Gson();\n+\n+    DelegateMethodGenerator() {\n+    }\n+\n+    @Override\n+    @NbBundle.Messages({\n+        \"DN_GenerateDelegateMethod=Generate Delegate Method...\",\n+    })\n+    public List<CodeAction> getCodeActions(CompilationInfo info, CodeActionParams params) {\n+        List<String> only = params.getContext().getOnly();\n+        if (only == null || !only.contains(CodeActionKind.Source)) {\n+            return Collections.emptyList();\n+        }\n+        int offset = getOffset(info, params.getRange().getStart());\n+        TreePath tp = info.getTreeUtilities().pathFor(offset);\n+        tp = info.getTreeUtilities().getPathElementOfKind(TreeUtilities.CLASS_TREE_KINDS, tp);\n+        if (tp == null) {\n+            return Collections.emptyList();\n+        }\n+        TypeElement typeElement = (TypeElement) info.getTrees().getElement(tp);\n+        if (typeElement == null || !typeElement.getKind().isClass()) {\n+            return Collections.emptyList();\n+        }\n+        Elements elements = info.getElements();\n+        Trees trees = info.getTrees();\n+        Scope scope = trees.getScope(tp);\n+        List<QuickPickItem> fields = new ArrayList<>();\n+        TypeElement cls;\n+        while (scope != null && (cls = scope.getEnclosingClass()) != null) {\n+            DeclaredType type = (DeclaredType) cls.asType();\n+            for (VariableElement field : ElementFilter.fieldsIn(elements.getAllMembers(cls))) {\n+                TypeMirror fieldType = field.asType();\n+                if (!ERROR.contentEquals(field.getSimpleName()) && !fieldType.getKind().isPrimitive() && fieldType.getKind() != TypeKind.ARRAY\n+                        && (fieldType.getKind() != TypeKind.DECLARED || ((DeclaredType)fieldType).asElement() != cls) && trees.isAccessible(scope, field, type)) {\n+                    QuickPickItem item = new QuickPickItem(createLabel(info, field));\n+                    item.setUserData(new ElementData(field));\n+                    fields.add(item);\n+                }\n+            }\n+            scope = scope.getEnclosingScope();\n+        }\n+        if (fields.isEmpty()) {\n+            return Collections.emptyList();\n+        }\n+        String uri = Utils.toUri(info.getFileObject());\n+        QuickPickItem typeItem = new QuickPickItem(createLabel(info, typeElement));\n+        typeItem.setUserData(new ElementData(typeElement));\n+        return Collections.singletonList(createCodeAction(Bundle.DN_GenerateDelegateMethod(), CODE_GENERATOR_KIND, GENERATE_DELEGATE_METHOD, uri, offset, typeItem, fields));\n+    }\n+\n+    @Override\n+    public Set<String> getCommands() {\n+        return commands;\n+    }\n+\n+    @Override\n+    @NbBundle.Messages({\n+        \"DN_SelectDelegateMethodField=Select target field to generate delegates for\",\n+    })\n+    public CompletableFuture<Object> processCommand(NbCodeLanguageClient client, String command, List<Object> arguments) {\n+        if (arguments.size() > 3) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4165983e6b010879475ed67961486fe3b278e364"}, "originalPosition": 130}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzE4ODg0NQ==", "bodyText": "Check for null.", "url": "https://github.com/apache/netbeans/pull/2587#discussion_r543188845", "createdAt": "2020-12-15T09:38:20Z", "author": {"login": "sdedic"}, "path": "java/java.lsp.server/src/org/netbeans/modules/java/lsp/server/protocol/DelegateMethodGenerator.java", "diffHunk": "@@ -0,0 +1,210 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.netbeans.modules.java.lsp.server.protocol;\n+\n+import com.google.gson.Gson;\n+import com.sun.source.tree.Scope;\n+import com.sun.source.util.TreePath;\n+import com.sun.source.util.Trees;\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.stream.Collectors;\n+import javax.lang.model.element.Element;\n+import javax.lang.model.element.ElementKind;\n+import javax.lang.model.element.ExecutableElement;\n+import javax.lang.model.element.Modifier;\n+import javax.lang.model.element.TypeElement;\n+import javax.lang.model.element.VariableElement;\n+import javax.lang.model.type.DeclaredType;\n+import javax.lang.model.type.TypeKind;\n+import javax.lang.model.type.TypeMirror;\n+import javax.lang.model.util.ElementFilter;\n+import javax.lang.model.util.Elements;\n+import org.eclipse.lsp4j.ApplyWorkspaceEditParams;\n+import org.eclipse.lsp4j.CodeAction;\n+import org.eclipse.lsp4j.CodeActionKind;\n+import org.eclipse.lsp4j.CodeActionParams;\n+import org.eclipse.lsp4j.MessageParams;\n+import org.eclipse.lsp4j.MessageType;\n+import org.eclipse.lsp4j.TextEdit;\n+import org.eclipse.lsp4j.WorkspaceEdit;\n+import org.netbeans.api.java.source.CompilationInfo;\n+import org.netbeans.api.java.source.ElementUtilities;\n+import org.netbeans.api.java.source.JavaSource;\n+import org.netbeans.api.java.source.TreeUtilities;\n+import org.netbeans.modules.java.lsp.server.Utils;\n+import org.openide.filesystems.FileObject;\n+import org.openide.util.NbBundle;\n+\n+/**\n+ *\n+ * @author Dusan Balek\n+ */\n+public final class DelegateMethodGenerator extends CodeGenerator {\n+\n+    public static final String GENERATE_DELEGATE_METHOD =  \"java.generate.delegateMethod\";\n+\n+    private final Set<String> commands = Collections.singleton(GENERATE_DELEGATE_METHOD);\n+    private final Gson gson = new Gson();\n+\n+    DelegateMethodGenerator() {\n+    }\n+\n+    @Override\n+    @NbBundle.Messages({\n+        \"DN_GenerateDelegateMethod=Generate Delegate Method...\",\n+    })\n+    public List<CodeAction> getCodeActions(CompilationInfo info, CodeActionParams params) {\n+        List<String> only = params.getContext().getOnly();\n+        if (only == null || !only.contains(CodeActionKind.Source)) {\n+            return Collections.emptyList();\n+        }\n+        int offset = getOffset(info, params.getRange().getStart());\n+        TreePath tp = info.getTreeUtilities().pathFor(offset);\n+        tp = info.getTreeUtilities().getPathElementOfKind(TreeUtilities.CLASS_TREE_KINDS, tp);\n+        if (tp == null) {\n+            return Collections.emptyList();\n+        }\n+        TypeElement typeElement = (TypeElement) info.getTrees().getElement(tp);\n+        if (typeElement == null || !typeElement.getKind().isClass()) {\n+            return Collections.emptyList();\n+        }\n+        Elements elements = info.getElements();\n+        Trees trees = info.getTrees();\n+        Scope scope = trees.getScope(tp);\n+        List<QuickPickItem> fields = new ArrayList<>();\n+        TypeElement cls;\n+        while (scope != null && (cls = scope.getEnclosingClass()) != null) {\n+            DeclaredType type = (DeclaredType) cls.asType();\n+            for (VariableElement field : ElementFilter.fieldsIn(elements.getAllMembers(cls))) {\n+                TypeMirror fieldType = field.asType();\n+                if (!ERROR.contentEquals(field.getSimpleName()) && !fieldType.getKind().isPrimitive() && fieldType.getKind() != TypeKind.ARRAY\n+                        && (fieldType.getKind() != TypeKind.DECLARED || ((DeclaredType)fieldType).asElement() != cls) && trees.isAccessible(scope, field, type)) {\n+                    QuickPickItem item = new QuickPickItem(createLabel(info, field));\n+                    item.setUserData(new ElementData(field));\n+                    fields.add(item);\n+                }\n+            }\n+            scope = scope.getEnclosingScope();\n+        }\n+        if (fields.isEmpty()) {\n+            return Collections.emptyList();\n+        }\n+        String uri = Utils.toUri(info.getFileObject());\n+        QuickPickItem typeItem = new QuickPickItem(createLabel(info, typeElement));\n+        typeItem.setUserData(new ElementData(typeElement));\n+        return Collections.singletonList(createCodeAction(Bundle.DN_GenerateDelegateMethod(), CODE_GENERATOR_KIND, GENERATE_DELEGATE_METHOD, uri, offset, typeItem, fields));\n+    }\n+\n+    @Override\n+    public Set<String> getCommands() {\n+        return commands;\n+    }\n+\n+    @Override\n+    @NbBundle.Messages({\n+        \"DN_SelectDelegateMethodField=Select target field to generate delegates for\",\n+    })\n+    public CompletableFuture<Object> processCommand(NbCodeLanguageClient client, String command, List<Object> arguments) {\n+        if (arguments.size() > 3) {\n+            String uri = gson.fromJson(gson.toJson(arguments.get(0)), String.class);\n+            int offset = gson.fromJson(gson.toJson(arguments.get(1)), Integer.class);\n+            QuickPickItem type = gson.fromJson(gson.toJson(arguments.get(2)), QuickPickItem.class);\n+            List<QuickPickItem> fields = Arrays.asList(gson.fromJson(gson.toJson(arguments.get(3)), QuickPickItem[].class));\n+            if (fields.size() == 1) {\n+                selectMethods(client, uri, offset, type, fields.get(0));\n+            } else {\n+                client.showQuickPick(new ShowQuickPickParams(Bundle.DN_SelectDelegateMethodField(), false, fields)).thenAccept(selected -> {\n+                    if (selected != null && !selected.isEmpty()) {\n+                        selectMethods(client, uri, offset, type, selected.get(0));\n+                    }\n+                });\n+            }\n+        }\n+        return CompletableFuture.completedFuture(true);\n+    }\n+\n+    @NbBundle.Messages({\n+        \"DN_SelectDelegateMethods=Select methods to generate delegates for\",\n+    })\n+    private void selectMethods(NbCodeLanguageClient client, String uri, int offset, QuickPickItem type, QuickPickItem selectedField) {\n+        try {\n+            FileObject file = Utils.fromUri(uri);\n+            JavaSource js = JavaSource.forFileObject(file);\n+            js.runUserActionTask(info -> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4165983e6b010879475ed67961486fe3b278e364"}, "originalPosition": 155}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzE4ODg5NQ==", "bodyText": "Check origin / field for != null", "url": "https://github.com/apache/netbeans/pull/2587#discussion_r543188895", "createdAt": "2020-12-15T09:38:25Z", "author": {"login": "sdedic"}, "path": "java/java.lsp.server/src/org/netbeans/modules/java/lsp/server/protocol/DelegateMethodGenerator.java", "diffHunk": "@@ -0,0 +1,210 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.netbeans.modules.java.lsp.server.protocol;\n+\n+import com.google.gson.Gson;\n+import com.sun.source.tree.Scope;\n+import com.sun.source.util.TreePath;\n+import com.sun.source.util.Trees;\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.stream.Collectors;\n+import javax.lang.model.element.Element;\n+import javax.lang.model.element.ElementKind;\n+import javax.lang.model.element.ExecutableElement;\n+import javax.lang.model.element.Modifier;\n+import javax.lang.model.element.TypeElement;\n+import javax.lang.model.element.VariableElement;\n+import javax.lang.model.type.DeclaredType;\n+import javax.lang.model.type.TypeKind;\n+import javax.lang.model.type.TypeMirror;\n+import javax.lang.model.util.ElementFilter;\n+import javax.lang.model.util.Elements;\n+import org.eclipse.lsp4j.ApplyWorkspaceEditParams;\n+import org.eclipse.lsp4j.CodeAction;\n+import org.eclipse.lsp4j.CodeActionKind;\n+import org.eclipse.lsp4j.CodeActionParams;\n+import org.eclipse.lsp4j.MessageParams;\n+import org.eclipse.lsp4j.MessageType;\n+import org.eclipse.lsp4j.TextEdit;\n+import org.eclipse.lsp4j.WorkspaceEdit;\n+import org.netbeans.api.java.source.CompilationInfo;\n+import org.netbeans.api.java.source.ElementUtilities;\n+import org.netbeans.api.java.source.JavaSource;\n+import org.netbeans.api.java.source.TreeUtilities;\n+import org.netbeans.modules.java.lsp.server.Utils;\n+import org.openide.filesystems.FileObject;\n+import org.openide.util.NbBundle;\n+\n+/**\n+ *\n+ * @author Dusan Balek\n+ */\n+public final class DelegateMethodGenerator extends CodeGenerator {\n+\n+    public static final String GENERATE_DELEGATE_METHOD =  \"java.generate.delegateMethod\";\n+\n+    private final Set<String> commands = Collections.singleton(GENERATE_DELEGATE_METHOD);\n+    private final Gson gson = new Gson();\n+\n+    DelegateMethodGenerator() {\n+    }\n+\n+    @Override\n+    @NbBundle.Messages({\n+        \"DN_GenerateDelegateMethod=Generate Delegate Method...\",\n+    })\n+    public List<CodeAction> getCodeActions(CompilationInfo info, CodeActionParams params) {\n+        List<String> only = params.getContext().getOnly();\n+        if (only == null || !only.contains(CodeActionKind.Source)) {\n+            return Collections.emptyList();\n+        }\n+        int offset = getOffset(info, params.getRange().getStart());\n+        TreePath tp = info.getTreeUtilities().pathFor(offset);\n+        tp = info.getTreeUtilities().getPathElementOfKind(TreeUtilities.CLASS_TREE_KINDS, tp);\n+        if (tp == null) {\n+            return Collections.emptyList();\n+        }\n+        TypeElement typeElement = (TypeElement) info.getTrees().getElement(tp);\n+        if (typeElement == null || !typeElement.getKind().isClass()) {\n+            return Collections.emptyList();\n+        }\n+        Elements elements = info.getElements();\n+        Trees trees = info.getTrees();\n+        Scope scope = trees.getScope(tp);\n+        List<QuickPickItem> fields = new ArrayList<>();\n+        TypeElement cls;\n+        while (scope != null && (cls = scope.getEnclosingClass()) != null) {\n+            DeclaredType type = (DeclaredType) cls.asType();\n+            for (VariableElement field : ElementFilter.fieldsIn(elements.getAllMembers(cls))) {\n+                TypeMirror fieldType = field.asType();\n+                if (!ERROR.contentEquals(field.getSimpleName()) && !fieldType.getKind().isPrimitive() && fieldType.getKind() != TypeKind.ARRAY\n+                        && (fieldType.getKind() != TypeKind.DECLARED || ((DeclaredType)fieldType).asElement() != cls) && trees.isAccessible(scope, field, type)) {\n+                    QuickPickItem item = new QuickPickItem(createLabel(info, field));\n+                    item.setUserData(new ElementData(field));\n+                    fields.add(item);\n+                }\n+            }\n+            scope = scope.getEnclosingScope();\n+        }\n+        if (fields.isEmpty()) {\n+            return Collections.emptyList();\n+        }\n+        String uri = Utils.toUri(info.getFileObject());\n+        QuickPickItem typeItem = new QuickPickItem(createLabel(info, typeElement));\n+        typeItem.setUserData(new ElementData(typeElement));\n+        return Collections.singletonList(createCodeAction(Bundle.DN_GenerateDelegateMethod(), CODE_GENERATOR_KIND, GENERATE_DELEGATE_METHOD, uri, offset, typeItem, fields));\n+    }\n+\n+    @Override\n+    public Set<String> getCommands() {\n+        return commands;\n+    }\n+\n+    @Override\n+    @NbBundle.Messages({\n+        \"DN_SelectDelegateMethodField=Select target field to generate delegates for\",\n+    })\n+    public CompletableFuture<Object> processCommand(NbCodeLanguageClient client, String command, List<Object> arguments) {\n+        if (arguments.size() > 3) {\n+            String uri = gson.fromJson(gson.toJson(arguments.get(0)), String.class);\n+            int offset = gson.fromJson(gson.toJson(arguments.get(1)), Integer.class);\n+            QuickPickItem type = gson.fromJson(gson.toJson(arguments.get(2)), QuickPickItem.class);\n+            List<QuickPickItem> fields = Arrays.asList(gson.fromJson(gson.toJson(arguments.get(3)), QuickPickItem[].class));\n+            if (fields.size() == 1) {\n+                selectMethods(client, uri, offset, type, fields.get(0));\n+            } else {\n+                client.showQuickPick(new ShowQuickPickParams(Bundle.DN_SelectDelegateMethodField(), false, fields)).thenAccept(selected -> {\n+                    if (selected != null && !selected.isEmpty()) {\n+                        selectMethods(client, uri, offset, type, selected.get(0));\n+                    }\n+                });\n+            }\n+        }\n+        return CompletableFuture.completedFuture(true);\n+    }\n+\n+    @NbBundle.Messages({\n+        \"DN_SelectDelegateMethods=Select methods to generate delegates for\",\n+    })\n+    private void selectMethods(NbCodeLanguageClient client, String uri, int offset, QuickPickItem type, QuickPickItem selectedField) {\n+        try {\n+            FileObject file = Utils.fromUri(uri);\n+            JavaSource js = JavaSource.forFileObject(file);\n+            js.runUserActionTask(info -> {\n+                info.toPhase(JavaSource.Phase.RESOLVED);\n+                TypeElement origin = (TypeElement) gson.fromJson(gson.toJson(type.getUserData()), ElementData.class).resolve(info);\n+                VariableElement field = (VariableElement) gson.fromJson(gson.toJson(selectedField.getUserData()), ElementData.class).resolve(info);\n+                final ElementUtilities eu = info.getElementUtilities();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4165983e6b010879475ed67961486fe3b278e364"}, "originalPosition": 159}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzE4ODk0Ng==", "bodyText": "Nitpick: add braces or indent :)", "url": "https://github.com/apache/netbeans/pull/2587#discussion_r543188946", "createdAt": "2020-12-15T09:38:29Z", "author": {"login": "sdedic"}, "path": "java/java.lsp.server/src/org/netbeans/modules/java/lsp/server/protocol/DelegateMethodGenerator.java", "diffHunk": "@@ -0,0 +1,210 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.netbeans.modules.java.lsp.server.protocol;\n+\n+import com.google.gson.Gson;\n+import com.sun.source.tree.Scope;\n+import com.sun.source.util.TreePath;\n+import com.sun.source.util.Trees;\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.stream.Collectors;\n+import javax.lang.model.element.Element;\n+import javax.lang.model.element.ElementKind;\n+import javax.lang.model.element.ExecutableElement;\n+import javax.lang.model.element.Modifier;\n+import javax.lang.model.element.TypeElement;\n+import javax.lang.model.element.VariableElement;\n+import javax.lang.model.type.DeclaredType;\n+import javax.lang.model.type.TypeKind;\n+import javax.lang.model.type.TypeMirror;\n+import javax.lang.model.util.ElementFilter;\n+import javax.lang.model.util.Elements;\n+import org.eclipse.lsp4j.ApplyWorkspaceEditParams;\n+import org.eclipse.lsp4j.CodeAction;\n+import org.eclipse.lsp4j.CodeActionKind;\n+import org.eclipse.lsp4j.CodeActionParams;\n+import org.eclipse.lsp4j.MessageParams;\n+import org.eclipse.lsp4j.MessageType;\n+import org.eclipse.lsp4j.TextEdit;\n+import org.eclipse.lsp4j.WorkspaceEdit;\n+import org.netbeans.api.java.source.CompilationInfo;\n+import org.netbeans.api.java.source.ElementUtilities;\n+import org.netbeans.api.java.source.JavaSource;\n+import org.netbeans.api.java.source.TreeUtilities;\n+import org.netbeans.modules.java.lsp.server.Utils;\n+import org.openide.filesystems.FileObject;\n+import org.openide.util.NbBundle;\n+\n+/**\n+ *\n+ * @author Dusan Balek\n+ */\n+public final class DelegateMethodGenerator extends CodeGenerator {\n+\n+    public static final String GENERATE_DELEGATE_METHOD =  \"java.generate.delegateMethod\";\n+\n+    private final Set<String> commands = Collections.singleton(GENERATE_DELEGATE_METHOD);\n+    private final Gson gson = new Gson();\n+\n+    DelegateMethodGenerator() {\n+    }\n+\n+    @Override\n+    @NbBundle.Messages({\n+        \"DN_GenerateDelegateMethod=Generate Delegate Method...\",\n+    })\n+    public List<CodeAction> getCodeActions(CompilationInfo info, CodeActionParams params) {\n+        List<String> only = params.getContext().getOnly();\n+        if (only == null || !only.contains(CodeActionKind.Source)) {\n+            return Collections.emptyList();\n+        }\n+        int offset = getOffset(info, params.getRange().getStart());\n+        TreePath tp = info.getTreeUtilities().pathFor(offset);\n+        tp = info.getTreeUtilities().getPathElementOfKind(TreeUtilities.CLASS_TREE_KINDS, tp);\n+        if (tp == null) {\n+            return Collections.emptyList();\n+        }\n+        TypeElement typeElement = (TypeElement) info.getTrees().getElement(tp);\n+        if (typeElement == null || !typeElement.getKind().isClass()) {\n+            return Collections.emptyList();\n+        }\n+        Elements elements = info.getElements();\n+        Trees trees = info.getTrees();\n+        Scope scope = trees.getScope(tp);\n+        List<QuickPickItem> fields = new ArrayList<>();\n+        TypeElement cls;\n+        while (scope != null && (cls = scope.getEnclosingClass()) != null) {\n+            DeclaredType type = (DeclaredType) cls.asType();\n+            for (VariableElement field : ElementFilter.fieldsIn(elements.getAllMembers(cls))) {\n+                TypeMirror fieldType = field.asType();\n+                if (!ERROR.contentEquals(field.getSimpleName()) && !fieldType.getKind().isPrimitive() && fieldType.getKind() != TypeKind.ARRAY\n+                        && (fieldType.getKind() != TypeKind.DECLARED || ((DeclaredType)fieldType).asElement() != cls) && trees.isAccessible(scope, field, type)) {\n+                    QuickPickItem item = new QuickPickItem(createLabel(info, field));\n+                    item.setUserData(new ElementData(field));\n+                    fields.add(item);\n+                }\n+            }\n+            scope = scope.getEnclosingScope();\n+        }\n+        if (fields.isEmpty()) {\n+            return Collections.emptyList();\n+        }\n+        String uri = Utils.toUri(info.getFileObject());\n+        QuickPickItem typeItem = new QuickPickItem(createLabel(info, typeElement));\n+        typeItem.setUserData(new ElementData(typeElement));\n+        return Collections.singletonList(createCodeAction(Bundle.DN_GenerateDelegateMethod(), CODE_GENERATOR_KIND, GENERATE_DELEGATE_METHOD, uri, offset, typeItem, fields));\n+    }\n+\n+    @Override\n+    public Set<String> getCommands() {\n+        return commands;\n+    }\n+\n+    @Override\n+    @NbBundle.Messages({\n+        \"DN_SelectDelegateMethodField=Select target field to generate delegates for\",\n+    })\n+    public CompletableFuture<Object> processCommand(NbCodeLanguageClient client, String command, List<Object> arguments) {\n+        if (arguments.size() > 3) {\n+            String uri = gson.fromJson(gson.toJson(arguments.get(0)), String.class);\n+            int offset = gson.fromJson(gson.toJson(arguments.get(1)), Integer.class);\n+            QuickPickItem type = gson.fromJson(gson.toJson(arguments.get(2)), QuickPickItem.class);\n+            List<QuickPickItem> fields = Arrays.asList(gson.fromJson(gson.toJson(arguments.get(3)), QuickPickItem[].class));\n+            if (fields.size() == 1) {\n+                selectMethods(client, uri, offset, type, fields.get(0));\n+            } else {\n+                client.showQuickPick(new ShowQuickPickParams(Bundle.DN_SelectDelegateMethodField(), false, fields)).thenAccept(selected -> {\n+                    if (selected != null && !selected.isEmpty()) {\n+                        selectMethods(client, uri, offset, type, selected.get(0));\n+                    }\n+                });\n+            }\n+        }\n+        return CompletableFuture.completedFuture(true);\n+    }\n+\n+    @NbBundle.Messages({\n+        \"DN_SelectDelegateMethods=Select methods to generate delegates for\",\n+    })\n+    private void selectMethods(NbCodeLanguageClient client, String uri, int offset, QuickPickItem type, QuickPickItem selectedField) {\n+        try {\n+            FileObject file = Utils.fromUri(uri);\n+            JavaSource js = JavaSource.forFileObject(file);\n+            js.runUserActionTask(info -> {\n+                info.toPhase(JavaSource.Phase.RESOLVED);\n+                TypeElement origin = (TypeElement) gson.fromJson(gson.toJson(type.getUserData()), ElementData.class).resolve(info);\n+                VariableElement field = (VariableElement) gson.fromJson(gson.toJson(selectedField.getUserData()), ElementData.class).resolve(info);\n+                final ElementUtilities eu = info.getElementUtilities();\n+                final Trees trees = info.getTrees();\n+                final Scope scope = info.getTreeUtilities().scopeFor(offset);\n+                ElementUtilities.ElementAcceptor acceptor = new ElementUtilities.ElementAcceptor() {\n+                    @Override\n+                    public boolean accept(Element e, TypeMirror type) {\n+                        if (e.getKind() == ElementKind.METHOD && trees.isAccessible(scope, e, (DeclaredType)type)) {\n+                            Element impl = eu.getImplementationOf((ExecutableElement)e, origin);\n+                            return impl == null || (!impl.getModifiers().contains(Modifier.FINAL) && impl.getEnclosingElement() != origin);\n+                        }\n+                        return false;\n+                    }\n+                };\n+                List<QuickPickItem> methods = new ArrayList<>();\n+                for (ExecutableElement method : ElementFilter.methodsIn(eu.getMembers(field.asType(), acceptor))) {\n+                    QuickPickItem item = new QuickPickItem(String.format(\"%s.%s\", field.getSimpleName().toString(), createLabel(info, method)));\n+                    item.setUserData(new ElementData(method));\n+                    methods.add(item);\n+                }\n+                client.showQuickPick(new ShowQuickPickParams(Bundle.DN_SelectDelegateMethods(), true, methods)).thenAccept(selected -> {\n+                    if (selected != null && !selected.isEmpty())", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4165983e6b010879475ed67961486fe3b278e364"}, "originalPosition": 179}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzE4OTAwOQ==", "bodyText": "Consider if TextEdit + error handling for generate could be centralized for all CodeGenerators.", "url": "https://github.com/apache/netbeans/pull/2587#discussion_r543189009", "createdAt": "2020-12-15T09:38:33Z", "author": {"login": "sdedic"}, "path": "java/java.lsp.server/src/org/netbeans/modules/java/lsp/server/protocol/DelegateMethodGenerator.java", "diffHunk": "@@ -0,0 +1,210 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.netbeans.modules.java.lsp.server.protocol;\n+\n+import com.google.gson.Gson;\n+import com.sun.source.tree.Scope;\n+import com.sun.source.util.TreePath;\n+import com.sun.source.util.Trees;\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.stream.Collectors;\n+import javax.lang.model.element.Element;\n+import javax.lang.model.element.ElementKind;\n+import javax.lang.model.element.ExecutableElement;\n+import javax.lang.model.element.Modifier;\n+import javax.lang.model.element.TypeElement;\n+import javax.lang.model.element.VariableElement;\n+import javax.lang.model.type.DeclaredType;\n+import javax.lang.model.type.TypeKind;\n+import javax.lang.model.type.TypeMirror;\n+import javax.lang.model.util.ElementFilter;\n+import javax.lang.model.util.Elements;\n+import org.eclipse.lsp4j.ApplyWorkspaceEditParams;\n+import org.eclipse.lsp4j.CodeAction;\n+import org.eclipse.lsp4j.CodeActionKind;\n+import org.eclipse.lsp4j.CodeActionParams;\n+import org.eclipse.lsp4j.MessageParams;\n+import org.eclipse.lsp4j.MessageType;\n+import org.eclipse.lsp4j.TextEdit;\n+import org.eclipse.lsp4j.WorkspaceEdit;\n+import org.netbeans.api.java.source.CompilationInfo;\n+import org.netbeans.api.java.source.ElementUtilities;\n+import org.netbeans.api.java.source.JavaSource;\n+import org.netbeans.api.java.source.TreeUtilities;\n+import org.netbeans.modules.java.lsp.server.Utils;\n+import org.openide.filesystems.FileObject;\n+import org.openide.util.NbBundle;\n+\n+/**\n+ *\n+ * @author Dusan Balek\n+ */\n+public final class DelegateMethodGenerator extends CodeGenerator {\n+\n+    public static final String GENERATE_DELEGATE_METHOD =  \"java.generate.delegateMethod\";\n+\n+    private final Set<String> commands = Collections.singleton(GENERATE_DELEGATE_METHOD);\n+    private final Gson gson = new Gson();\n+\n+    DelegateMethodGenerator() {\n+    }\n+\n+    @Override\n+    @NbBundle.Messages({\n+        \"DN_GenerateDelegateMethod=Generate Delegate Method...\",\n+    })\n+    public List<CodeAction> getCodeActions(CompilationInfo info, CodeActionParams params) {\n+        List<String> only = params.getContext().getOnly();\n+        if (only == null || !only.contains(CodeActionKind.Source)) {\n+            return Collections.emptyList();\n+        }\n+        int offset = getOffset(info, params.getRange().getStart());\n+        TreePath tp = info.getTreeUtilities().pathFor(offset);\n+        tp = info.getTreeUtilities().getPathElementOfKind(TreeUtilities.CLASS_TREE_KINDS, tp);\n+        if (tp == null) {\n+            return Collections.emptyList();\n+        }\n+        TypeElement typeElement = (TypeElement) info.getTrees().getElement(tp);\n+        if (typeElement == null || !typeElement.getKind().isClass()) {\n+            return Collections.emptyList();\n+        }\n+        Elements elements = info.getElements();\n+        Trees trees = info.getTrees();\n+        Scope scope = trees.getScope(tp);\n+        List<QuickPickItem> fields = new ArrayList<>();\n+        TypeElement cls;\n+        while (scope != null && (cls = scope.getEnclosingClass()) != null) {\n+            DeclaredType type = (DeclaredType) cls.asType();\n+            for (VariableElement field : ElementFilter.fieldsIn(elements.getAllMembers(cls))) {\n+                TypeMirror fieldType = field.asType();\n+                if (!ERROR.contentEquals(field.getSimpleName()) && !fieldType.getKind().isPrimitive() && fieldType.getKind() != TypeKind.ARRAY\n+                        && (fieldType.getKind() != TypeKind.DECLARED || ((DeclaredType)fieldType).asElement() != cls) && trees.isAccessible(scope, field, type)) {\n+                    QuickPickItem item = new QuickPickItem(createLabel(info, field));\n+                    item.setUserData(new ElementData(field));\n+                    fields.add(item);\n+                }\n+            }\n+            scope = scope.getEnclosingScope();\n+        }\n+        if (fields.isEmpty()) {\n+            return Collections.emptyList();\n+        }\n+        String uri = Utils.toUri(info.getFileObject());\n+        QuickPickItem typeItem = new QuickPickItem(createLabel(info, typeElement));\n+        typeItem.setUserData(new ElementData(typeElement));\n+        return Collections.singletonList(createCodeAction(Bundle.DN_GenerateDelegateMethod(), CODE_GENERATOR_KIND, GENERATE_DELEGATE_METHOD, uri, offset, typeItem, fields));\n+    }\n+\n+    @Override\n+    public Set<String> getCommands() {\n+        return commands;\n+    }\n+\n+    @Override\n+    @NbBundle.Messages({\n+        \"DN_SelectDelegateMethodField=Select target field to generate delegates for\",\n+    })\n+    public CompletableFuture<Object> processCommand(NbCodeLanguageClient client, String command, List<Object> arguments) {\n+        if (arguments.size() > 3) {\n+            String uri = gson.fromJson(gson.toJson(arguments.get(0)), String.class);\n+            int offset = gson.fromJson(gson.toJson(arguments.get(1)), Integer.class);\n+            QuickPickItem type = gson.fromJson(gson.toJson(arguments.get(2)), QuickPickItem.class);\n+            List<QuickPickItem> fields = Arrays.asList(gson.fromJson(gson.toJson(arguments.get(3)), QuickPickItem[].class));\n+            if (fields.size() == 1) {\n+                selectMethods(client, uri, offset, type, fields.get(0));\n+            } else {\n+                client.showQuickPick(new ShowQuickPickParams(Bundle.DN_SelectDelegateMethodField(), false, fields)).thenAccept(selected -> {\n+                    if (selected != null && !selected.isEmpty()) {\n+                        selectMethods(client, uri, offset, type, selected.get(0));\n+                    }\n+                });\n+            }\n+        }\n+        return CompletableFuture.completedFuture(true);\n+    }\n+\n+    @NbBundle.Messages({\n+        \"DN_SelectDelegateMethods=Select methods to generate delegates for\",\n+    })\n+    private void selectMethods(NbCodeLanguageClient client, String uri, int offset, QuickPickItem type, QuickPickItem selectedField) {\n+        try {\n+            FileObject file = Utils.fromUri(uri);\n+            JavaSource js = JavaSource.forFileObject(file);\n+            js.runUserActionTask(info -> {\n+                info.toPhase(JavaSource.Phase.RESOLVED);\n+                TypeElement origin = (TypeElement) gson.fromJson(gson.toJson(type.getUserData()), ElementData.class).resolve(info);\n+                VariableElement field = (VariableElement) gson.fromJson(gson.toJson(selectedField.getUserData()), ElementData.class).resolve(info);\n+                final ElementUtilities eu = info.getElementUtilities();\n+                final Trees trees = info.getTrees();\n+                final Scope scope = info.getTreeUtilities().scopeFor(offset);\n+                ElementUtilities.ElementAcceptor acceptor = new ElementUtilities.ElementAcceptor() {\n+                    @Override\n+                    public boolean accept(Element e, TypeMirror type) {\n+                        if (e.getKind() == ElementKind.METHOD && trees.isAccessible(scope, e, (DeclaredType)type)) {\n+                            Element impl = eu.getImplementationOf((ExecutableElement)e, origin);\n+                            return impl == null || (!impl.getModifiers().contains(Modifier.FINAL) && impl.getEnclosingElement() != origin);\n+                        }\n+                        return false;\n+                    }\n+                };\n+                List<QuickPickItem> methods = new ArrayList<>();\n+                for (ExecutableElement method : ElementFilter.methodsIn(eu.getMembers(field.asType(), acceptor))) {\n+                    QuickPickItem item = new QuickPickItem(String.format(\"%s.%s\", field.getSimpleName().toString(), createLabel(info, method)));\n+                    item.setUserData(new ElementData(method));\n+                    methods.add(item);\n+                }\n+                client.showQuickPick(new ShowQuickPickParams(Bundle.DN_SelectDelegateMethods(), true, methods)).thenAccept(selected -> {\n+                    if (selected != null && !selected.isEmpty())\n+                    generate(client, uri, offset, selectedField, selected);\n+                });\n+            }, true);\n+        } catch (IOException | IllegalArgumentException ex) {\n+            client.logMessage(new MessageParams(MessageType.Error, ex.getLocalizedMessage()));\n+        }\n+    }\n+\n+    private void generate(NbCodeLanguageClient client, String uri, int offset, QuickPickItem selectedField, List<QuickPickItem> selectedMethods) {\n+        try {\n+            FileObject file = Utils.fromUri(uri);\n+            JavaSource js = JavaSource.forFileObject(file);\n+            List<TextEdit> edits = TextDocumentServiceImpl.modify2TextEdits(js, wc -> {\n+                wc.toPhase(JavaSource.Phase.RESOLVED);\n+                TreePath tp = wc.getTreeUtilities().pathFor(offset);\n+                tp = wc.getTreeUtilities().getPathElementOfKind(TreeUtilities.CLASS_TREE_KINDS, tp);\n+                if (tp != null) {\n+                    VariableElement field = (VariableElement) gson.fromJson(gson.toJson(selectedField.getUserData()), ElementData.class).resolve(wc);\n+                    List<ExecutableElement> methods = selectedMethods.stream().map(item -> {\n+                        ElementData data = gson.fromJson(gson.toJson(item.getUserData()), ElementData.class);\n+                        return (ExecutableElement)data.resolve(wc);\n+                    }).collect(Collectors.toList());\n+                    org.netbeans.modules.java.editor.codegen.DelegateMethodGenerator.generateDelegatingMethods(wc, tp, field, methods, -1);\n+                }\n+            });\n+            client.applyEdit(new ApplyWorkspaceEditParams(new WorkspaceEdit(Collections.singletonMap(uri, edits))));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4165983e6b010879475ed67961486fe3b278e364"}, "originalPosition": 205}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzE4OTE1Nw==", "bodyText": "Nitpick: the TypeMirror may be erroneous (TypeKind.ERROR)", "url": "https://github.com/apache/netbeans/pull/2587#discussion_r543189157", "createdAt": "2020-12-15T09:38:47Z", "author": {"login": "sdedic"}, "path": "java/java.lsp.server/src/org/netbeans/modules/java/lsp/server/protocol/CodeGenerator.java", "diffHunk": "@@ -0,0 +1,215 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.netbeans.modules.java.lsp.server.protocol;\n+\n+import com.sun.source.tree.LineMap;\n+import java.util.Arrays;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+import javax.lang.model.element.Element;\n+import javax.lang.model.element.ElementKind;\n+import javax.lang.model.element.ExecutableElement;\n+import javax.lang.model.element.TypeElement;\n+import javax.lang.model.element.TypeParameterElement;\n+import javax.lang.model.element.VariableElement;\n+import javax.lang.model.type.ArrayType;\n+import javax.lang.model.type.TypeKind;\n+import javax.lang.model.type.TypeMirror;\n+import org.eclipse.lsp4j.CodeAction;\n+import org.eclipse.lsp4j.CodeActionParams;\n+import org.eclipse.lsp4j.Command;\n+import org.eclipse.lsp4j.Position;\n+import org.eclipse.xtext.xbase.lib.Pure;\n+import org.netbeans.api.java.source.CompilationInfo;\n+import org.netbeans.api.java.source.ElementHandle;\n+import org.netbeans.modules.editor.java.Utilities;\n+import org.netbeans.modules.java.source.ElementHandleAccessor;\n+\n+/**\n+ *\n+ * @author Dusan Balek\n+ */\n+public abstract class CodeGenerator {\n+\n+    public static final String CODE_GENERATOR_KIND = \"source.generate\";\n+    protected static final String ERROR = \"<error>\"; //NOI18N\n+\n+    public abstract List<CodeAction> getCodeActions(CompilationInfo info, CodeActionParams params);\n+\n+    public abstract Set<String> getCommands();\n+\n+    public abstract CompletableFuture<Object> processCommand(NbCodeLanguageClient client, String command, List<Object> arguments);\n+\n+    protected static int getOffset(CompilationInfo info, Position pos) {\n+        LineMap lm = info.getCompilationUnit().getLineMap();\n+        return (int) lm.getPosition(pos.getLine() + 1, pos.getCharacter() + 1);\n+    }\n+\n+    protected static CodeAction createCodeAction(String name, String kind, String command, Object... args) {\n+        CodeAction action = new CodeAction(name);\n+        action.setKind(kind);\n+        action.setCommand(new Command(name, command, Arrays.asList(args)));\n+        return action;\n+    }\n+\n+    protected static String createLabel(CompilationInfo info, TypeElement e) {\n+        StringBuilder sb = new StringBuilder();\n+        sb.append(e.getSimpleName());\n+        List<? extends TypeParameterElement> typeParams = e.getTypeParameters();\n+        if (typeParams != null && !typeParams.isEmpty()) {\n+            sb.append(\"<\"); // NOI18N\n+            for(Iterator<? extends TypeParameterElement> it = typeParams.iterator(); it.hasNext();) {\n+                TypeParameterElement tp = it.next();\n+                sb.append(tp.getSimpleName());\n+                List<? extends TypeMirror> bounds = tp.getBounds();\n+                if (!bounds.isEmpty()) {\n+                    if (bounds.size() > 1 || !\"java.lang.Object\".equals(bounds.get(0).toString())) { // NOI18N\n+                        sb.append(\" extends \"); // NOI18N\n+                        for (Iterator<? extends TypeMirror> bIt = bounds.iterator(); bIt.hasNext();) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4165983e6b010879475ed67961486fe3b278e364"}, "originalPosition": 87}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzE4OTI1NQ==", "bodyText": "the branches seem to have the same effect; just ElementKind.ENUM with  exactly 1 constructor is skipped. OK ?", "url": "https://github.com/apache/netbeans/pull/2587#discussion_r543189255", "createdAt": "2020-12-15T09:38:55Z", "author": {"login": "sdedic"}, "path": "java/java.lsp.server/src/org/netbeans/modules/java/lsp/server/protocol/ConstructorGenerator.java", "diffHunk": "@@ -0,0 +1,210 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.netbeans.modules.java.lsp.server.protocol;\n+\n+import com.google.gson.Gson;\n+import com.sun.source.util.TreePath;\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.stream.Collectors;\n+import javax.lang.model.element.ElementKind;\n+import javax.lang.model.element.ExecutableElement;\n+import javax.lang.model.element.Modifier;\n+import javax.lang.model.element.NestingKind;\n+import javax.lang.model.element.PackageElement;\n+import javax.lang.model.element.TypeElement;\n+import javax.lang.model.element.VariableElement;\n+import javax.lang.model.type.DeclaredType;\n+import javax.lang.model.type.TypeKind;\n+import javax.lang.model.type.TypeMirror;\n+import javax.lang.model.util.ElementFilter;\n+import javax.lang.model.util.Elements;\n+import org.eclipse.lsp4j.ApplyWorkspaceEditParams;\n+import org.eclipse.lsp4j.CodeAction;\n+import org.eclipse.lsp4j.CodeActionKind;\n+import org.eclipse.lsp4j.CodeActionParams;\n+import org.eclipse.lsp4j.MessageParams;\n+import org.eclipse.lsp4j.MessageType;\n+import org.eclipse.lsp4j.TextEdit;\n+import org.eclipse.lsp4j.WorkspaceEdit;\n+import org.netbeans.api.java.source.CompilationInfo;\n+import org.netbeans.api.java.source.JavaSource;\n+import org.netbeans.api.java.source.TreeUtilities;\n+import org.netbeans.modules.java.editor.codegen.GeneratorUtils;\n+import org.netbeans.modules.java.lsp.server.Utils;\n+import org.openide.filesystems.FileObject;\n+import org.openide.util.NbBundle;\n+\n+/**\n+ *\n+ * @author Dusan Balek\n+ */\n+public final class ConstructorGenerator extends CodeGenerator {\n+\n+    public static final String GENERATE_CONSTRUCTOR =  \"java.generate.constructor\";\n+\n+    private final Set<String> commands = Collections.singleton(GENERATE_CONSTRUCTOR);\n+    private final Gson gson = new Gson();\n+\n+    ConstructorGenerator() {\n+    }\n+\n+    @Override\n+    @NbBundle.Messages({\n+        \"DN_GenerateConstructor=Generate Constructor...\",\n+    })\n+    public List<CodeAction> getCodeActions(CompilationInfo info, CodeActionParams params) {\n+        List<String> only = params.getContext().getOnly();\n+        if (only == null || !only.contains(CodeActionKind.Source)) {\n+            return Collections.emptyList();\n+        }\n+        int offset = getOffset(info, params.getRange().getStart());\n+        TreePath tp = info.getTreeUtilities().pathFor(offset);\n+        tp = info.getTreeUtilities().getPathElementOfKind(TreeUtilities.CLASS_TREE_KINDS, tp);\n+        if (tp == null) {\n+            return Collections.emptyList();\n+        }\n+        TypeElement typeElement = (TypeElement) info.getTrees().getElement(tp);\n+        if (typeElement == null || !typeElement.getKind().isClass() || NestingKind.ANONYMOUS.equals(typeElement.getNestingKind())) {\n+            return Collections.emptyList();\n+        }\n+        final Set<? extends VariableElement> uninitializedFields = info.getTreeUtilities().getUninitializedFields(tp);\n+        final List<ExecutableElement> inheritedConstructors = new ArrayList<>();\n+        TypeMirror superClassType = typeElement.getSuperclass();\n+        if (superClassType.getKind() == TypeKind.DECLARED) {\n+            TypeElement superClass = (TypeElement) ((DeclaredType) superClassType).asElement();\n+            Elements elements = info.getElements();\n+            for (ExecutableElement executableElement : ElementFilter.constructorsIn(superClass.getEnclosedElements())) {\n+                PackageElement currentPackage = elements.getPackageOf(typeElement);\n+                PackageElement ctorPackage = elements.getPackageOf(executableElement);\n+                Set<Modifier> ctorMods = executableElement.getModifiers();\n+                if ((currentPackage != ctorPackage && !(ctorMods.contains(Modifier.PUBLIC) || ctorMods.contains(Modifier.PROTECTED)))\n+                        || ctorMods.contains(Modifier.PRIVATE)) {\n+                    continue;\n+                }\n+                inheritedConstructors.add(executableElement);\n+            }\n+        }\n+        List<QuickPickItem> constructors = null;\n+        if (typeElement.getKind() != ElementKind.ENUM && inheritedConstructors.size() == 1) {\n+            QuickPickItem item = new QuickPickItem(createLabel(info, inheritedConstructors.get(0)));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4165983e6b010879475ed67961486fe3b278e364"}, "originalPosition": 111}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzE4OTMxOA==", "bodyText": "Question: wouldn't it be more appropriate to return Future that describes command's completion (= the actual code generation termination) to the client ? This way it could be possible to reliably chain commands from the client.", "url": "https://github.com/apache/netbeans/pull/2587#discussion_r543189318", "createdAt": "2020-12-15T09:39:00Z", "author": {"login": "sdedic"}, "path": "java/java.lsp.server/src/org/netbeans/modules/java/lsp/server/protocol/ConstructorGenerator.java", "diffHunk": "@@ -0,0 +1,210 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.netbeans.modules.java.lsp.server.protocol;\n+\n+import com.google.gson.Gson;\n+import com.sun.source.util.TreePath;\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.stream.Collectors;\n+import javax.lang.model.element.ElementKind;\n+import javax.lang.model.element.ExecutableElement;\n+import javax.lang.model.element.Modifier;\n+import javax.lang.model.element.NestingKind;\n+import javax.lang.model.element.PackageElement;\n+import javax.lang.model.element.TypeElement;\n+import javax.lang.model.element.VariableElement;\n+import javax.lang.model.type.DeclaredType;\n+import javax.lang.model.type.TypeKind;\n+import javax.lang.model.type.TypeMirror;\n+import javax.lang.model.util.ElementFilter;\n+import javax.lang.model.util.Elements;\n+import org.eclipse.lsp4j.ApplyWorkspaceEditParams;\n+import org.eclipse.lsp4j.CodeAction;\n+import org.eclipse.lsp4j.CodeActionKind;\n+import org.eclipse.lsp4j.CodeActionParams;\n+import org.eclipse.lsp4j.MessageParams;\n+import org.eclipse.lsp4j.MessageType;\n+import org.eclipse.lsp4j.TextEdit;\n+import org.eclipse.lsp4j.WorkspaceEdit;\n+import org.netbeans.api.java.source.CompilationInfo;\n+import org.netbeans.api.java.source.JavaSource;\n+import org.netbeans.api.java.source.TreeUtilities;\n+import org.netbeans.modules.java.editor.codegen.GeneratorUtils;\n+import org.netbeans.modules.java.lsp.server.Utils;\n+import org.openide.filesystems.FileObject;\n+import org.openide.util.NbBundle;\n+\n+/**\n+ *\n+ * @author Dusan Balek\n+ */\n+public final class ConstructorGenerator extends CodeGenerator {\n+\n+    public static final String GENERATE_CONSTRUCTOR =  \"java.generate.constructor\";\n+\n+    private final Set<String> commands = Collections.singleton(GENERATE_CONSTRUCTOR);\n+    private final Gson gson = new Gson();\n+\n+    ConstructorGenerator() {\n+    }\n+\n+    @Override\n+    @NbBundle.Messages({\n+        \"DN_GenerateConstructor=Generate Constructor...\",\n+    })\n+    public List<CodeAction> getCodeActions(CompilationInfo info, CodeActionParams params) {\n+        List<String> only = params.getContext().getOnly();\n+        if (only == null || !only.contains(CodeActionKind.Source)) {\n+            return Collections.emptyList();\n+        }\n+        int offset = getOffset(info, params.getRange().getStart());\n+        TreePath tp = info.getTreeUtilities().pathFor(offset);\n+        tp = info.getTreeUtilities().getPathElementOfKind(TreeUtilities.CLASS_TREE_KINDS, tp);\n+        if (tp == null) {\n+            return Collections.emptyList();\n+        }\n+        TypeElement typeElement = (TypeElement) info.getTrees().getElement(tp);\n+        if (typeElement == null || !typeElement.getKind().isClass() || NestingKind.ANONYMOUS.equals(typeElement.getNestingKind())) {\n+            return Collections.emptyList();\n+        }\n+        final Set<? extends VariableElement> uninitializedFields = info.getTreeUtilities().getUninitializedFields(tp);\n+        final List<ExecutableElement> inheritedConstructors = new ArrayList<>();\n+        TypeMirror superClassType = typeElement.getSuperclass();\n+        if (superClassType.getKind() == TypeKind.DECLARED) {\n+            TypeElement superClass = (TypeElement) ((DeclaredType) superClassType).asElement();\n+            Elements elements = info.getElements();\n+            for (ExecutableElement executableElement : ElementFilter.constructorsIn(superClass.getEnclosedElements())) {\n+                PackageElement currentPackage = elements.getPackageOf(typeElement);\n+                PackageElement ctorPackage = elements.getPackageOf(executableElement);\n+                Set<Modifier> ctorMods = executableElement.getModifiers();\n+                if ((currentPackage != ctorPackage && !(ctorMods.contains(Modifier.PUBLIC) || ctorMods.contains(Modifier.PROTECTED)))\n+                        || ctorMods.contains(Modifier.PRIVATE)) {\n+                    continue;\n+                }\n+                inheritedConstructors.add(executableElement);\n+            }\n+        }\n+        List<QuickPickItem> constructors = null;\n+        if (typeElement.getKind() != ElementKind.ENUM && inheritedConstructors.size() == 1) {\n+            QuickPickItem item = new QuickPickItem(createLabel(info, inheritedConstructors.get(0)));\n+            item.setUserData(new ElementData(inheritedConstructors.get(0)));\n+            constructors = Collections.singletonList(item);\n+        } else if (inheritedConstructors.size() > 1) {\n+            constructors = new ArrayList<>(inheritedConstructors.size());\n+            for (ExecutableElement constructorElement : inheritedConstructors) {\n+                QuickPickItem item = new QuickPickItem(createLabel(info, constructorElement));\n+                item.setUserData(new ElementData(constructorElement));\n+                constructors.add(item);\n+            }\n+        }\n+        List<QuickPickItem> fields = null;\n+        if (!uninitializedFields.isEmpty()) {\n+            fields = new ArrayList<>();\n+            for (VariableElement variableElement : uninitializedFields) {\n+                QuickPickItem item = new QuickPickItem(createLabel(info, variableElement));\n+                item.setUserData(new ElementData(variableElement));\n+                fields.add(item);\n+            }\n+        }\n+        if (constructors == null && fields == null) {\n+            return Collections.emptyList();\n+        }\n+        String uri = Utils.toUri(info.getFileObject());\n+        return Collections.singletonList(createCodeAction(Bundle.DN_GenerateConstructor(), CODE_GENERATOR_KIND, GENERATE_CONSTRUCTOR, uri, offset, constructors, fields));\n+    }\n+\n+    @Override\n+    public Set<String> getCommands() {\n+        return commands;\n+    }\n+\n+    @Override\n+    @NbBundle.Messages({\n+        \"DN_SelectSuperConstructor=Select super constructor\",\n+    })\n+    public CompletableFuture<Object> processCommand(NbCodeLanguageClient client, String command, List<Object> arguments) {\n+        if (arguments.size() > 3) {\n+            String uri = gson.fromJson(gson.toJson(arguments.get(0)), String.class);\n+            int offset = gson.fromJson(gson.toJson(arguments.get(1)), Integer.class);\n+            List<QuickPickItem> constructors = Arrays.asList(gson.fromJson(gson.toJson(arguments.get(2)), QuickPickItem[].class));\n+            List<QuickPickItem> fields = Arrays.asList(gson.fromJson(gson.toJson(arguments.get(3)), QuickPickItem[].class));\n+            if (constructors.size() < 2 && fields.isEmpty()) {\n+                generate(client, uri, offset, constructors, fields);\n+            } else {\n+                if (constructors.size() > 1) {\n+                    client.showQuickPick(new ShowQuickPickParams(Bundle.DN_SelectSuperConstructor(), true, constructors)).thenAccept(selected -> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4165983e6b010879475ed67961486fe3b278e364"}, "originalPosition": 157}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzE4OTM4Nw==", "bodyText": "possibly check js for null", "url": "https://github.com/apache/netbeans/pull/2587#discussion_r543189387", "createdAt": "2020-12-15T09:39:05Z", "author": {"login": "sdedic"}, "path": "java/java.lsp.server/src/org/netbeans/modules/java/lsp/server/protocol/ConstructorGenerator.java", "diffHunk": "@@ -0,0 +1,210 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.netbeans.modules.java.lsp.server.protocol;\n+\n+import com.google.gson.Gson;\n+import com.sun.source.util.TreePath;\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.stream.Collectors;\n+import javax.lang.model.element.ElementKind;\n+import javax.lang.model.element.ExecutableElement;\n+import javax.lang.model.element.Modifier;\n+import javax.lang.model.element.NestingKind;\n+import javax.lang.model.element.PackageElement;\n+import javax.lang.model.element.TypeElement;\n+import javax.lang.model.element.VariableElement;\n+import javax.lang.model.type.DeclaredType;\n+import javax.lang.model.type.TypeKind;\n+import javax.lang.model.type.TypeMirror;\n+import javax.lang.model.util.ElementFilter;\n+import javax.lang.model.util.Elements;\n+import org.eclipse.lsp4j.ApplyWorkspaceEditParams;\n+import org.eclipse.lsp4j.CodeAction;\n+import org.eclipse.lsp4j.CodeActionKind;\n+import org.eclipse.lsp4j.CodeActionParams;\n+import org.eclipse.lsp4j.MessageParams;\n+import org.eclipse.lsp4j.MessageType;\n+import org.eclipse.lsp4j.TextEdit;\n+import org.eclipse.lsp4j.WorkspaceEdit;\n+import org.netbeans.api.java.source.CompilationInfo;\n+import org.netbeans.api.java.source.JavaSource;\n+import org.netbeans.api.java.source.TreeUtilities;\n+import org.netbeans.modules.java.editor.codegen.GeneratorUtils;\n+import org.netbeans.modules.java.lsp.server.Utils;\n+import org.openide.filesystems.FileObject;\n+import org.openide.util.NbBundle;\n+\n+/**\n+ *\n+ * @author Dusan Balek\n+ */\n+public final class ConstructorGenerator extends CodeGenerator {\n+\n+    public static final String GENERATE_CONSTRUCTOR =  \"java.generate.constructor\";\n+\n+    private final Set<String> commands = Collections.singleton(GENERATE_CONSTRUCTOR);\n+    private final Gson gson = new Gson();\n+\n+    ConstructorGenerator() {\n+    }\n+\n+    @Override\n+    @NbBundle.Messages({\n+        \"DN_GenerateConstructor=Generate Constructor...\",\n+    })\n+    public List<CodeAction> getCodeActions(CompilationInfo info, CodeActionParams params) {\n+        List<String> only = params.getContext().getOnly();\n+        if (only == null || !only.contains(CodeActionKind.Source)) {\n+            return Collections.emptyList();\n+        }\n+        int offset = getOffset(info, params.getRange().getStart());\n+        TreePath tp = info.getTreeUtilities().pathFor(offset);\n+        tp = info.getTreeUtilities().getPathElementOfKind(TreeUtilities.CLASS_TREE_KINDS, tp);\n+        if (tp == null) {\n+            return Collections.emptyList();\n+        }\n+        TypeElement typeElement = (TypeElement) info.getTrees().getElement(tp);\n+        if (typeElement == null || !typeElement.getKind().isClass() || NestingKind.ANONYMOUS.equals(typeElement.getNestingKind())) {\n+            return Collections.emptyList();\n+        }\n+        final Set<? extends VariableElement> uninitializedFields = info.getTreeUtilities().getUninitializedFields(tp);\n+        final List<ExecutableElement> inheritedConstructors = new ArrayList<>();\n+        TypeMirror superClassType = typeElement.getSuperclass();\n+        if (superClassType.getKind() == TypeKind.DECLARED) {\n+            TypeElement superClass = (TypeElement) ((DeclaredType) superClassType).asElement();\n+            Elements elements = info.getElements();\n+            for (ExecutableElement executableElement : ElementFilter.constructorsIn(superClass.getEnclosedElements())) {\n+                PackageElement currentPackage = elements.getPackageOf(typeElement);\n+                PackageElement ctorPackage = elements.getPackageOf(executableElement);\n+                Set<Modifier> ctorMods = executableElement.getModifiers();\n+                if ((currentPackage != ctorPackage && !(ctorMods.contains(Modifier.PUBLIC) || ctorMods.contains(Modifier.PROTECTED)))\n+                        || ctorMods.contains(Modifier.PRIVATE)) {\n+                    continue;\n+                }\n+                inheritedConstructors.add(executableElement);\n+            }\n+        }\n+        List<QuickPickItem> constructors = null;\n+        if (typeElement.getKind() != ElementKind.ENUM && inheritedConstructors.size() == 1) {\n+            QuickPickItem item = new QuickPickItem(createLabel(info, inheritedConstructors.get(0)));\n+            item.setUserData(new ElementData(inheritedConstructors.get(0)));\n+            constructors = Collections.singletonList(item);\n+        } else if (inheritedConstructors.size() > 1) {\n+            constructors = new ArrayList<>(inheritedConstructors.size());\n+            for (ExecutableElement constructorElement : inheritedConstructors) {\n+                QuickPickItem item = new QuickPickItem(createLabel(info, constructorElement));\n+                item.setUserData(new ElementData(constructorElement));\n+                constructors.add(item);\n+            }\n+        }\n+        List<QuickPickItem> fields = null;\n+        if (!uninitializedFields.isEmpty()) {\n+            fields = new ArrayList<>();\n+            for (VariableElement variableElement : uninitializedFields) {\n+                QuickPickItem item = new QuickPickItem(createLabel(info, variableElement));\n+                item.setUserData(new ElementData(variableElement));\n+                fields.add(item);\n+            }\n+        }\n+        if (constructors == null && fields == null) {\n+            return Collections.emptyList();\n+        }\n+        String uri = Utils.toUri(info.getFileObject());\n+        return Collections.singletonList(createCodeAction(Bundle.DN_GenerateConstructor(), CODE_GENERATOR_KIND, GENERATE_CONSTRUCTOR, uri, offset, constructors, fields));\n+    }\n+\n+    @Override\n+    public Set<String> getCommands() {\n+        return commands;\n+    }\n+\n+    @Override\n+    @NbBundle.Messages({\n+        \"DN_SelectSuperConstructor=Select super constructor\",\n+    })\n+    public CompletableFuture<Object> processCommand(NbCodeLanguageClient client, String command, List<Object> arguments) {\n+        if (arguments.size() > 3) {\n+            String uri = gson.fromJson(gson.toJson(arguments.get(0)), String.class);\n+            int offset = gson.fromJson(gson.toJson(arguments.get(1)), Integer.class);\n+            List<QuickPickItem> constructors = Arrays.asList(gson.fromJson(gson.toJson(arguments.get(2)), QuickPickItem[].class));\n+            List<QuickPickItem> fields = Arrays.asList(gson.fromJson(gson.toJson(arguments.get(3)), QuickPickItem[].class));\n+            if (constructors.size() < 2 && fields.isEmpty()) {\n+                generate(client, uri, offset, constructors, fields);\n+            } else {\n+                if (constructors.size() > 1) {\n+                    client.showQuickPick(new ShowQuickPickParams(Bundle.DN_SelectSuperConstructor(), true, constructors)).thenAccept(selected -> {\n+                        if (selected != null) {\n+                            selectFields(client, uri, offset, selected, fields);\n+                        }\n+                    });\n+                } else {\n+                    selectFields(client, uri, offset, constructors, fields);\n+                }\n+            }\n+        }\n+        return CompletableFuture.completedFuture(true);\n+    }\n+\n+    @NbBundle.Messages({\n+        \"DN_SelectConstructorFields=Select fields to be initialized by constructor\",\n+    })\n+    private void selectFields(NbCodeLanguageClient client, String uri, int offset, List<QuickPickItem> constructors, List<QuickPickItem> fields) {\n+        if (!fields.isEmpty()) {\n+            client.showQuickPick(new ShowQuickPickParams(Bundle.DN_SelectConstructorFields(), true, fields)).thenAccept(selected -> {\n+                if (selected != null) {\n+                    generate(client, uri, offset, constructors, selected);\n+                }\n+            });\n+        } else {\n+            generate(client, uri, offset, constructors, fields);\n+        }\n+    }\n+\n+    private void generate(NbCodeLanguageClient client, String uri, int offset, List<QuickPickItem> constructors, List<QuickPickItem> fields) {\n+        try {\n+            FileObject file = Utils.fromUri(uri);\n+            JavaSource js = JavaSource.forFileObject(file);\n+            List<TextEdit> edits = TextDocumentServiceImpl.modify2TextEdits(js, wc -> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4165983e6b010879475ed67961486fe3b278e364"}, "originalPosition": 189}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzE4OTQxNg==", "bodyText": "Maybe filter for null result of Handle.resolve, generateConstructors does not accept null list members.", "url": "https://github.com/apache/netbeans/pull/2587#discussion_r543189416", "createdAt": "2020-12-15T09:39:08Z", "author": {"login": "sdedic"}, "path": "java/java.lsp.server/src/org/netbeans/modules/java/lsp/server/protocol/ConstructorGenerator.java", "diffHunk": "@@ -0,0 +1,210 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.netbeans.modules.java.lsp.server.protocol;\n+\n+import com.google.gson.Gson;\n+import com.sun.source.util.TreePath;\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.stream.Collectors;\n+import javax.lang.model.element.ElementKind;\n+import javax.lang.model.element.ExecutableElement;\n+import javax.lang.model.element.Modifier;\n+import javax.lang.model.element.NestingKind;\n+import javax.lang.model.element.PackageElement;\n+import javax.lang.model.element.TypeElement;\n+import javax.lang.model.element.VariableElement;\n+import javax.lang.model.type.DeclaredType;\n+import javax.lang.model.type.TypeKind;\n+import javax.lang.model.type.TypeMirror;\n+import javax.lang.model.util.ElementFilter;\n+import javax.lang.model.util.Elements;\n+import org.eclipse.lsp4j.ApplyWorkspaceEditParams;\n+import org.eclipse.lsp4j.CodeAction;\n+import org.eclipse.lsp4j.CodeActionKind;\n+import org.eclipse.lsp4j.CodeActionParams;\n+import org.eclipse.lsp4j.MessageParams;\n+import org.eclipse.lsp4j.MessageType;\n+import org.eclipse.lsp4j.TextEdit;\n+import org.eclipse.lsp4j.WorkspaceEdit;\n+import org.netbeans.api.java.source.CompilationInfo;\n+import org.netbeans.api.java.source.JavaSource;\n+import org.netbeans.api.java.source.TreeUtilities;\n+import org.netbeans.modules.java.editor.codegen.GeneratorUtils;\n+import org.netbeans.modules.java.lsp.server.Utils;\n+import org.openide.filesystems.FileObject;\n+import org.openide.util.NbBundle;\n+\n+/**\n+ *\n+ * @author Dusan Balek\n+ */\n+public final class ConstructorGenerator extends CodeGenerator {\n+\n+    public static final String GENERATE_CONSTRUCTOR =  \"java.generate.constructor\";\n+\n+    private final Set<String> commands = Collections.singleton(GENERATE_CONSTRUCTOR);\n+    private final Gson gson = new Gson();\n+\n+    ConstructorGenerator() {\n+    }\n+\n+    @Override\n+    @NbBundle.Messages({\n+        \"DN_GenerateConstructor=Generate Constructor...\",\n+    })\n+    public List<CodeAction> getCodeActions(CompilationInfo info, CodeActionParams params) {\n+        List<String> only = params.getContext().getOnly();\n+        if (only == null || !only.contains(CodeActionKind.Source)) {\n+            return Collections.emptyList();\n+        }\n+        int offset = getOffset(info, params.getRange().getStart());\n+        TreePath tp = info.getTreeUtilities().pathFor(offset);\n+        tp = info.getTreeUtilities().getPathElementOfKind(TreeUtilities.CLASS_TREE_KINDS, tp);\n+        if (tp == null) {\n+            return Collections.emptyList();\n+        }\n+        TypeElement typeElement = (TypeElement) info.getTrees().getElement(tp);\n+        if (typeElement == null || !typeElement.getKind().isClass() || NestingKind.ANONYMOUS.equals(typeElement.getNestingKind())) {\n+            return Collections.emptyList();\n+        }\n+        final Set<? extends VariableElement> uninitializedFields = info.getTreeUtilities().getUninitializedFields(tp);\n+        final List<ExecutableElement> inheritedConstructors = new ArrayList<>();\n+        TypeMirror superClassType = typeElement.getSuperclass();\n+        if (superClassType.getKind() == TypeKind.DECLARED) {\n+            TypeElement superClass = (TypeElement) ((DeclaredType) superClassType).asElement();\n+            Elements elements = info.getElements();\n+            for (ExecutableElement executableElement : ElementFilter.constructorsIn(superClass.getEnclosedElements())) {\n+                PackageElement currentPackage = elements.getPackageOf(typeElement);\n+                PackageElement ctorPackage = elements.getPackageOf(executableElement);\n+                Set<Modifier> ctorMods = executableElement.getModifiers();\n+                if ((currentPackage != ctorPackage && !(ctorMods.contains(Modifier.PUBLIC) || ctorMods.contains(Modifier.PROTECTED)))\n+                        || ctorMods.contains(Modifier.PRIVATE)) {\n+                    continue;\n+                }\n+                inheritedConstructors.add(executableElement);\n+            }\n+        }\n+        List<QuickPickItem> constructors = null;\n+        if (typeElement.getKind() != ElementKind.ENUM && inheritedConstructors.size() == 1) {\n+            QuickPickItem item = new QuickPickItem(createLabel(info, inheritedConstructors.get(0)));\n+            item.setUserData(new ElementData(inheritedConstructors.get(0)));\n+            constructors = Collections.singletonList(item);\n+        } else if (inheritedConstructors.size() > 1) {\n+            constructors = new ArrayList<>(inheritedConstructors.size());\n+            for (ExecutableElement constructorElement : inheritedConstructors) {\n+                QuickPickItem item = new QuickPickItem(createLabel(info, constructorElement));\n+                item.setUserData(new ElementData(constructorElement));\n+                constructors.add(item);\n+            }\n+        }\n+        List<QuickPickItem> fields = null;\n+        if (!uninitializedFields.isEmpty()) {\n+            fields = new ArrayList<>();\n+            for (VariableElement variableElement : uninitializedFields) {\n+                QuickPickItem item = new QuickPickItem(createLabel(info, variableElement));\n+                item.setUserData(new ElementData(variableElement));\n+                fields.add(item);\n+            }\n+        }\n+        if (constructors == null && fields == null) {\n+            return Collections.emptyList();\n+        }\n+        String uri = Utils.toUri(info.getFileObject());\n+        return Collections.singletonList(createCodeAction(Bundle.DN_GenerateConstructor(), CODE_GENERATOR_KIND, GENERATE_CONSTRUCTOR, uri, offset, constructors, fields));\n+    }\n+\n+    @Override\n+    public Set<String> getCommands() {\n+        return commands;\n+    }\n+\n+    @Override\n+    @NbBundle.Messages({\n+        \"DN_SelectSuperConstructor=Select super constructor\",\n+    })\n+    public CompletableFuture<Object> processCommand(NbCodeLanguageClient client, String command, List<Object> arguments) {\n+        if (arguments.size() > 3) {\n+            String uri = gson.fromJson(gson.toJson(arguments.get(0)), String.class);\n+            int offset = gson.fromJson(gson.toJson(arguments.get(1)), Integer.class);\n+            List<QuickPickItem> constructors = Arrays.asList(gson.fromJson(gson.toJson(arguments.get(2)), QuickPickItem[].class));\n+            List<QuickPickItem> fields = Arrays.asList(gson.fromJson(gson.toJson(arguments.get(3)), QuickPickItem[].class));\n+            if (constructors.size() < 2 && fields.isEmpty()) {\n+                generate(client, uri, offset, constructors, fields);\n+            } else {\n+                if (constructors.size() > 1) {\n+                    client.showQuickPick(new ShowQuickPickParams(Bundle.DN_SelectSuperConstructor(), true, constructors)).thenAccept(selected -> {\n+                        if (selected != null) {\n+                            selectFields(client, uri, offset, selected, fields);\n+                        }\n+                    });\n+                } else {\n+                    selectFields(client, uri, offset, constructors, fields);\n+                }\n+            }\n+        }\n+        return CompletableFuture.completedFuture(true);\n+    }\n+\n+    @NbBundle.Messages({\n+        \"DN_SelectConstructorFields=Select fields to be initialized by constructor\",\n+    })\n+    private void selectFields(NbCodeLanguageClient client, String uri, int offset, List<QuickPickItem> constructors, List<QuickPickItem> fields) {\n+        if (!fields.isEmpty()) {\n+            client.showQuickPick(new ShowQuickPickParams(Bundle.DN_SelectConstructorFields(), true, fields)).thenAccept(selected -> {\n+                if (selected != null) {\n+                    generate(client, uri, offset, constructors, selected);\n+                }\n+            });\n+        } else {\n+            generate(client, uri, offset, constructors, fields);\n+        }\n+    }\n+\n+    private void generate(NbCodeLanguageClient client, String uri, int offset, List<QuickPickItem> constructors, List<QuickPickItem> fields) {\n+        try {\n+            FileObject file = Utils.fromUri(uri);\n+            JavaSource js = JavaSource.forFileObject(file);\n+            List<TextEdit> edits = TextDocumentServiceImpl.modify2TextEdits(js, wc -> {\n+                wc.toPhase(JavaSource.Phase.RESOLVED);\n+                TreePath tp = wc.getTreeUtilities().pathFor(offset);\n+                tp = wc.getTreeUtilities().getPathElementOfKind(TreeUtilities.CLASS_TREE_KINDS, tp);\n+                if (tp != null) {\n+                    List<ExecutableElement> selectedConstructors = constructors.stream().map(item -> {\n+                        ElementData data = gson.fromJson(gson.toJson(item.getUserData()), ElementData.class);\n+                        return (ExecutableElement)data.resolve(wc);\n+                    }).collect(Collectors.toList());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4165983e6b010879475ed67961486fe3b278e364"}, "originalPosition": 197}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzE5NDE4Mg==", "bodyText": "Nitpick: document msg parameters.", "url": "https://github.com/apache/netbeans/pull/2587#discussion_r543194182", "createdAt": "2020-12-15T09:45:40Z", "author": {"login": "sdedic"}, "path": "java/java.lsp.server/src/org/netbeans/modules/java/lsp/server/protocol/GetterSetterGenerator.java", "diffHunk": "@@ -18,58 +18,175 @@\n  */\n package org.netbeans.modules.java.lsp.server.protocol;\n \n+import com.google.gson.Gson;\n import com.sun.source.tree.ClassTree;\n-import com.sun.source.tree.LineMap;\n import com.sun.source.tree.Tree;\n import com.sun.source.util.TreePath;\n import java.io.IOException;\n-import java.net.MalformedURLException;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n import java.util.Collections;\n import java.util.HashSet;\n import java.util.LinkedHashSet;\n import java.util.List;\n import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.stream.Collectors;\n import javax.lang.model.element.Modifier;\n import javax.lang.model.element.TypeElement;\n import javax.lang.model.element.VariableElement;\n import javax.lang.model.util.ElementFilter;\n import org.eclipse.lsp4j.ApplyWorkspaceEditParams;\n-import org.eclipse.lsp4j.Position;\n+import org.eclipse.lsp4j.CodeAction;\n+import org.eclipse.lsp4j.CodeActionKind;\n+import org.eclipse.lsp4j.CodeActionParams;\n+import org.eclipse.lsp4j.MessageParams;\n+import org.eclipse.lsp4j.MessageType;\n import org.eclipse.lsp4j.Range;\n import org.eclipse.lsp4j.TextEdit;\n import org.eclipse.lsp4j.WorkspaceEdit;\n-import org.eclipse.lsp4j.services.LanguageClient;\n import org.netbeans.api.java.source.CodeStyle;\n import org.netbeans.api.java.source.CompilationInfo;\n import org.netbeans.api.java.source.ElementUtilities;\n import org.netbeans.api.java.source.JavaSource;\n import org.netbeans.api.java.source.TreeUtilities;\n import org.netbeans.modules.java.editor.codegen.GeneratorUtils;\n-import static org.netbeans.modules.java.lsp.server.protocol.TextDocumentServiceImpl.fromUri;\n+import org.netbeans.modules.java.lsp.server.Utils;\n import org.openide.filesystems.FileObject;\n+import org.openide.util.NbBundle;\n import org.openide.util.Pair;\n \n /**\n  *\n  * @author lahvac\n  */\n-public class GetterSetterGenerator {\n+public final class GetterSetterGenerator extends CodeGenerator {\n \n-    private static final String ERROR = \"<error>\"; //NOI18N\n+    public static final String GENERATE_GETTERS =  \"java.generate.getters\";\n+    public static final String GENERATE_SETTERS =  \"java.generate.setters\";\n+    public static final String GENERATE_GETTERS_SETTERS =  \"java.generate.getters.setters\";\n \n-    public static Pair<Set<VariableElement>, Set<VariableElement>> findMissingGettersSetters(CompilationInfo info, Range range, boolean all) {\n-        TreePath tp = info.getTreeUtilities().pathFor(getOffset(info, range.getStart()));\n+    private final Set<String> commands = Collections.unmodifiableSet(new HashSet(Arrays.asList(GENERATE_GETTERS, GENERATE_SETTERS, GENERATE_GETTERS_SETTERS)));\n+    private final Gson gson = new Gson();\n+\n+    GetterSetterGenerator() {\n+    }\n \n-        while (tp != null && !TreeUtilities.CLASS_TREE_KINDS.contains(tp.getLeaf().getKind())) {\n-            tp = tp.getParentPath();\n+    @Override\n+    @NbBundle.Messages({\n+        \"DN_GenerateGetters=Generate Getters...\",\n+        \"DN_GenerateSetters=Generate Setters...\",\n+        \"DN_GenerateGettersSetters=Generate Getters and Setters...\",\n+        \"DN_GenerateGetterFor=Generate Getter for \\\"{0}\\\"\",", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4165983e6b010879475ed67961486fe3b278e364"}, "originalPosition": 74}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzE5Njc3MA==", "bodyText": "pair.first() may become empty after retainAll", "url": "https://github.com/apache/netbeans/pull/2587#discussion_r543196770", "createdAt": "2020-12-15T09:49:16Z", "author": {"login": "sdedic"}, "path": "java/java.lsp.server/src/org/netbeans/modules/java/lsp/server/protocol/GetterSetterGenerator.java", "diffHunk": "@@ -18,58 +18,175 @@\n  */\n package org.netbeans.modules.java.lsp.server.protocol;\n \n+import com.google.gson.Gson;\n import com.sun.source.tree.ClassTree;\n-import com.sun.source.tree.LineMap;\n import com.sun.source.tree.Tree;\n import com.sun.source.util.TreePath;\n import java.io.IOException;\n-import java.net.MalformedURLException;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n import java.util.Collections;\n import java.util.HashSet;\n import java.util.LinkedHashSet;\n import java.util.List;\n import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.stream.Collectors;\n import javax.lang.model.element.Modifier;\n import javax.lang.model.element.TypeElement;\n import javax.lang.model.element.VariableElement;\n import javax.lang.model.util.ElementFilter;\n import org.eclipse.lsp4j.ApplyWorkspaceEditParams;\n-import org.eclipse.lsp4j.Position;\n+import org.eclipse.lsp4j.CodeAction;\n+import org.eclipse.lsp4j.CodeActionKind;\n+import org.eclipse.lsp4j.CodeActionParams;\n+import org.eclipse.lsp4j.MessageParams;\n+import org.eclipse.lsp4j.MessageType;\n import org.eclipse.lsp4j.Range;\n import org.eclipse.lsp4j.TextEdit;\n import org.eclipse.lsp4j.WorkspaceEdit;\n-import org.eclipse.lsp4j.services.LanguageClient;\n import org.netbeans.api.java.source.CodeStyle;\n import org.netbeans.api.java.source.CompilationInfo;\n import org.netbeans.api.java.source.ElementUtilities;\n import org.netbeans.api.java.source.JavaSource;\n import org.netbeans.api.java.source.TreeUtilities;\n import org.netbeans.modules.java.editor.codegen.GeneratorUtils;\n-import static org.netbeans.modules.java.lsp.server.protocol.TextDocumentServiceImpl.fromUri;\n+import org.netbeans.modules.java.lsp.server.Utils;\n import org.openide.filesystems.FileObject;\n+import org.openide.util.NbBundle;\n import org.openide.util.Pair;\n \n /**\n  *\n  * @author lahvac\n  */\n-public class GetterSetterGenerator {\n+public final class GetterSetterGenerator extends CodeGenerator {\n \n-    private static final String ERROR = \"<error>\"; //NOI18N\n+    public static final String GENERATE_GETTERS =  \"java.generate.getters\";\n+    public static final String GENERATE_SETTERS =  \"java.generate.setters\";\n+    public static final String GENERATE_GETTERS_SETTERS =  \"java.generate.getters.setters\";\n \n-    public static Pair<Set<VariableElement>, Set<VariableElement>> findMissingGettersSetters(CompilationInfo info, Range range, boolean all) {\n-        TreePath tp = info.getTreeUtilities().pathFor(getOffset(info, range.getStart()));\n+    private final Set<String> commands = Collections.unmodifiableSet(new HashSet(Arrays.asList(GENERATE_GETTERS, GENERATE_SETTERS, GENERATE_GETTERS_SETTERS)));\n+    private final Gson gson = new Gson();\n+\n+    GetterSetterGenerator() {\n+    }\n \n-        while (tp != null && !TreeUtilities.CLASS_TREE_KINDS.contains(tp.getLeaf().getKind())) {\n-            tp = tp.getParentPath();\n+    @Override\n+    @NbBundle.Messages({\n+        \"DN_GenerateGetters=Generate Getters...\",\n+        \"DN_GenerateSetters=Generate Setters...\",\n+        \"DN_GenerateGettersSetters=Generate Getters and Setters...\",\n+        \"DN_GenerateGetterFor=Generate Getter for \\\"{0}\\\"\",\n+        \"DN_GenerateSetterFor=Generate Setter for \\\"{0}\\\"\",\n+        \"DN_GenerateGetterSetterFor=Generate Getter and Setter for \\\"{0}\\\"\",\n+    })\n+    public List<CodeAction> getCodeActions(CompilationInfo info, CodeActionParams params) {\n+        List<String> only = params.getContext().getOnly();\n+        boolean all = only != null && only.contains(CodeActionKind.Source);\n+        Pair<Set<VariableElement>, Set<VariableElement>> pair = findMissingGettersSetters(info, params.getRange(), all);\n+        boolean missingGetters = !pair.first().isEmpty();\n+        boolean missingSetters = !pair.second().isEmpty();\n+        String uri = Utils.toUri(info.getFileObject());\n+        int offset = getOffset(info, params.getRange().getStart());\n+        List<CodeAction> result = new ArrayList<>();\n+        if (missingGetters) {\n+            String name = pair.first().size() == 1 ? Bundle.DN_GenerateGetterFor(pair.first().iterator().next().getSimpleName().toString()) : Bundle.DN_GenerateGetters();\n+            result.add(createCodeAction(name, all ? CODE_GENERATOR_KIND : CodeActionKind.QuickFix, GENERATE_GETTERS, uri, offset, all, pair.first().stream().map(variableElement -> {\n+                QuickPickItem item = new QuickPickItem(createLabel(info, variableElement));\n+                item.setUserData(new ElementData(variableElement));\n+                return item;\n+            }).collect(Collectors.toList())));\n+        }\n+        if (missingSetters) {\n+            String name = pair.second().size() == 1 ? Bundle.DN_GenerateSetterFor(pair.second().iterator().next().getSimpleName().toString()) : Bundle.DN_GenerateSetters();\n+            result.add(createCodeAction(name, all ? CODE_GENERATOR_KIND : CodeActionKind.QuickFix, GENERATE_SETTERS, uri, offset, all, pair.second().stream().map(variableElement -> {\n+                QuickPickItem item = new QuickPickItem(createLabel(info, variableElement));\n+                item.setUserData(new ElementData(variableElement));\n+                return item;\n+            }).collect(Collectors.toList())));\n         }\n+        if (missingGetters && missingSetters) {\n+            pair.first().retainAll(pair.second());\n+            String name = pair.first().size() == 1 ? Bundle.DN_GenerateGetterSetterFor(pair.first().iterator().next().getSimpleName().toString()) : Bundle.DN_GenerateGettersSetters();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4165983e6b010879475ed67961486fe3b278e364"}, "originalPosition": 105}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzIwNTY5NQ==", "bodyText": "The other generators bailed out if only != null, but did not contain CodeActionKind.Source; this seem to process all eligible fields later in processCommand. Right now just QuickFix is declared (in addition to Source), but better check explicitly so it own't break when the set of CodeActionKinds expand later.", "url": "https://github.com/apache/netbeans/pull/2587#discussion_r543205695", "createdAt": "2020-12-15T10:01:21Z", "author": {"login": "sdedic"}, "path": "java/java.lsp.server/src/org/netbeans/modules/java/lsp/server/protocol/GetterSetterGenerator.java", "diffHunk": "@@ -18,58 +18,175 @@\n  */\n package org.netbeans.modules.java.lsp.server.protocol;\n \n+import com.google.gson.Gson;\n import com.sun.source.tree.ClassTree;\n-import com.sun.source.tree.LineMap;\n import com.sun.source.tree.Tree;\n import com.sun.source.util.TreePath;\n import java.io.IOException;\n-import java.net.MalformedURLException;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n import java.util.Collections;\n import java.util.HashSet;\n import java.util.LinkedHashSet;\n import java.util.List;\n import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.stream.Collectors;\n import javax.lang.model.element.Modifier;\n import javax.lang.model.element.TypeElement;\n import javax.lang.model.element.VariableElement;\n import javax.lang.model.util.ElementFilter;\n import org.eclipse.lsp4j.ApplyWorkspaceEditParams;\n-import org.eclipse.lsp4j.Position;\n+import org.eclipse.lsp4j.CodeAction;\n+import org.eclipse.lsp4j.CodeActionKind;\n+import org.eclipse.lsp4j.CodeActionParams;\n+import org.eclipse.lsp4j.MessageParams;\n+import org.eclipse.lsp4j.MessageType;\n import org.eclipse.lsp4j.Range;\n import org.eclipse.lsp4j.TextEdit;\n import org.eclipse.lsp4j.WorkspaceEdit;\n-import org.eclipse.lsp4j.services.LanguageClient;\n import org.netbeans.api.java.source.CodeStyle;\n import org.netbeans.api.java.source.CompilationInfo;\n import org.netbeans.api.java.source.ElementUtilities;\n import org.netbeans.api.java.source.JavaSource;\n import org.netbeans.api.java.source.TreeUtilities;\n import org.netbeans.modules.java.editor.codegen.GeneratorUtils;\n-import static org.netbeans.modules.java.lsp.server.protocol.TextDocumentServiceImpl.fromUri;\n+import org.netbeans.modules.java.lsp.server.Utils;\n import org.openide.filesystems.FileObject;\n+import org.openide.util.NbBundle;\n import org.openide.util.Pair;\n \n /**\n  *\n  * @author lahvac\n  */\n-public class GetterSetterGenerator {\n+public final class GetterSetterGenerator extends CodeGenerator {\n \n-    private static final String ERROR = \"<error>\"; //NOI18N\n+    public static final String GENERATE_GETTERS =  \"java.generate.getters\";\n+    public static final String GENERATE_SETTERS =  \"java.generate.setters\";\n+    public static final String GENERATE_GETTERS_SETTERS =  \"java.generate.getters.setters\";\n \n-    public static Pair<Set<VariableElement>, Set<VariableElement>> findMissingGettersSetters(CompilationInfo info, Range range, boolean all) {\n-        TreePath tp = info.getTreeUtilities().pathFor(getOffset(info, range.getStart()));\n+    private final Set<String> commands = Collections.unmodifiableSet(new HashSet(Arrays.asList(GENERATE_GETTERS, GENERATE_SETTERS, GENERATE_GETTERS_SETTERS)));\n+    private final Gson gson = new Gson();\n+\n+    GetterSetterGenerator() {\n+    }\n \n-        while (tp != null && !TreeUtilities.CLASS_TREE_KINDS.contains(tp.getLeaf().getKind())) {\n-            tp = tp.getParentPath();\n+    @Override\n+    @NbBundle.Messages({\n+        \"DN_GenerateGetters=Generate Getters...\",\n+        \"DN_GenerateSetters=Generate Setters...\",\n+        \"DN_GenerateGettersSetters=Generate Getters and Setters...\",\n+        \"DN_GenerateGetterFor=Generate Getter for \\\"{0}\\\"\",\n+        \"DN_GenerateSetterFor=Generate Setter for \\\"{0}\\\"\",\n+        \"DN_GenerateGetterSetterFor=Generate Getter and Setter for \\\"{0}\\\"\",\n+    })\n+    public List<CodeAction> getCodeActions(CompilationInfo info, CodeActionParams params) {\n+        List<String> only = params.getContext().getOnly();\n+        boolean all = only != null && only.contains(CodeActionKind.Source);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4165983e6b010879475ed67961486fe3b278e364"}, "originalPosition": 80}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzIwNzc1Mw==", "bodyText": "I'd check the field's type TypeMirror for not being erroneous. Strange things may happen when generating incomplete types into getter / setter declartions.", "url": "https://github.com/apache/netbeans/pull/2587#discussion_r543207753", "createdAt": "2020-12-15T10:04:14Z", "author": {"login": "sdedic"}, "path": "java/java.lsp.server/src/org/netbeans/modules/java/lsp/server/protocol/GetterSetterGenerator.java", "diffHunk": "@@ -18,58 +18,175 @@\n  */\n package org.netbeans.modules.java.lsp.server.protocol;\n \n+import com.google.gson.Gson;\n import com.sun.source.tree.ClassTree;\n-import com.sun.source.tree.LineMap;\n import com.sun.source.tree.Tree;\n import com.sun.source.util.TreePath;\n import java.io.IOException;\n-import java.net.MalformedURLException;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n import java.util.Collections;\n import java.util.HashSet;\n import java.util.LinkedHashSet;\n import java.util.List;\n import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.stream.Collectors;\n import javax.lang.model.element.Modifier;\n import javax.lang.model.element.TypeElement;\n import javax.lang.model.element.VariableElement;\n import javax.lang.model.util.ElementFilter;\n import org.eclipse.lsp4j.ApplyWorkspaceEditParams;\n-import org.eclipse.lsp4j.Position;\n+import org.eclipse.lsp4j.CodeAction;\n+import org.eclipse.lsp4j.CodeActionKind;\n+import org.eclipse.lsp4j.CodeActionParams;\n+import org.eclipse.lsp4j.MessageParams;\n+import org.eclipse.lsp4j.MessageType;\n import org.eclipse.lsp4j.Range;\n import org.eclipse.lsp4j.TextEdit;\n import org.eclipse.lsp4j.WorkspaceEdit;\n-import org.eclipse.lsp4j.services.LanguageClient;\n import org.netbeans.api.java.source.CodeStyle;\n import org.netbeans.api.java.source.CompilationInfo;\n import org.netbeans.api.java.source.ElementUtilities;\n import org.netbeans.api.java.source.JavaSource;\n import org.netbeans.api.java.source.TreeUtilities;\n import org.netbeans.modules.java.editor.codegen.GeneratorUtils;\n-import static org.netbeans.modules.java.lsp.server.protocol.TextDocumentServiceImpl.fromUri;\n+import org.netbeans.modules.java.lsp.server.Utils;\n import org.openide.filesystems.FileObject;\n+import org.openide.util.NbBundle;\n import org.openide.util.Pair;\n \n /**\n  *\n  * @author lahvac\n  */\n-public class GetterSetterGenerator {\n+public final class GetterSetterGenerator extends CodeGenerator {\n \n-    private static final String ERROR = \"<error>\"; //NOI18N\n+    public static final String GENERATE_GETTERS =  \"java.generate.getters\";\n+    public static final String GENERATE_SETTERS =  \"java.generate.setters\";\n+    public static final String GENERATE_GETTERS_SETTERS =  \"java.generate.getters.setters\";\n \n-    public static Pair<Set<VariableElement>, Set<VariableElement>> findMissingGettersSetters(CompilationInfo info, Range range, boolean all) {\n-        TreePath tp = info.getTreeUtilities().pathFor(getOffset(info, range.getStart()));\n+    private final Set<String> commands = Collections.unmodifiableSet(new HashSet(Arrays.asList(GENERATE_GETTERS, GENERATE_SETTERS, GENERATE_GETTERS_SETTERS)));\n+    private final Gson gson = new Gson();\n+\n+    GetterSetterGenerator() {\n+    }\n \n-        while (tp != null && !TreeUtilities.CLASS_TREE_KINDS.contains(tp.getLeaf().getKind())) {\n-            tp = tp.getParentPath();\n+    @Override\n+    @NbBundle.Messages({\n+        \"DN_GenerateGetters=Generate Getters...\",\n+        \"DN_GenerateSetters=Generate Setters...\",\n+        \"DN_GenerateGettersSetters=Generate Getters and Setters...\",\n+        \"DN_GenerateGetterFor=Generate Getter for \\\"{0}\\\"\",\n+        \"DN_GenerateSetterFor=Generate Setter for \\\"{0}\\\"\",\n+        \"DN_GenerateGetterSetterFor=Generate Getter and Setter for \\\"{0}\\\"\",\n+    })\n+    public List<CodeAction> getCodeActions(CompilationInfo info, CodeActionParams params) {\n+        List<String> only = params.getContext().getOnly();\n+        boolean all = only != null && only.contains(CodeActionKind.Source);\n+        Pair<Set<VariableElement>, Set<VariableElement>> pair = findMissingGettersSetters(info, params.getRange(), all);\n+        boolean missingGetters = !pair.first().isEmpty();\n+        boolean missingSetters = !pair.second().isEmpty();\n+        String uri = Utils.toUri(info.getFileObject());\n+        int offset = getOffset(info, params.getRange().getStart());\n+        List<CodeAction> result = new ArrayList<>();\n+        if (missingGetters) {\n+            String name = pair.first().size() == 1 ? Bundle.DN_GenerateGetterFor(pair.first().iterator().next().getSimpleName().toString()) : Bundle.DN_GenerateGetters();\n+            result.add(createCodeAction(name, all ? CODE_GENERATOR_KIND : CodeActionKind.QuickFix, GENERATE_GETTERS, uri, offset, all, pair.first().stream().map(variableElement -> {\n+                QuickPickItem item = new QuickPickItem(createLabel(info, variableElement));\n+                item.setUserData(new ElementData(variableElement));\n+                return item;\n+            }).collect(Collectors.toList())));\n+        }\n+        if (missingSetters) {\n+            String name = pair.second().size() == 1 ? Bundle.DN_GenerateSetterFor(pair.second().iterator().next().getSimpleName().toString()) : Bundle.DN_GenerateSetters();\n+            result.add(createCodeAction(name, all ? CODE_GENERATOR_KIND : CodeActionKind.QuickFix, GENERATE_SETTERS, uri, offset, all, pair.second().stream().map(variableElement -> {\n+                QuickPickItem item = new QuickPickItem(createLabel(info, variableElement));\n+                item.setUserData(new ElementData(variableElement));\n+                return item;\n+            }).collect(Collectors.toList())));\n         }\n+        if (missingGetters && missingSetters) {\n+            pair.first().retainAll(pair.second());\n+            String name = pair.first().size() == 1 ? Bundle.DN_GenerateGetterSetterFor(pair.first().iterator().next().getSimpleName().toString()) : Bundle.DN_GenerateGettersSetters();\n+            result.add(createCodeAction(name, all ? CODE_GENERATOR_KIND : CodeActionKind.QuickFix, GENERATE_GETTERS_SETTERS, uri, offset, all, pair.first().stream().map(variableElement -> {\n+                QuickPickItem item = new QuickPickItem(createLabel(info, variableElement));\n+                item.setUserData(new ElementData(variableElement));\n+                return item;\n+            }).collect(Collectors.toList())));\n+        }\n+        return result;\n+    }\n+\n+    @Override\n+    public Set<String> getCommands() {\n+        return commands;\n+    }\n \n+    @Override\n+    @NbBundle.Messages({\n+        \"DN_SelectGetters=Select fields to generate getters for\",\n+        \"DN_SelectSetters=Select fields to generate setters for\",\n+        \"DN_SelectGettersSetters=Select fields to generate getters and setters for\",\n+    })\n+    public CompletableFuture<Object> processCommand(NbCodeLanguageClient client, String command, List<Object> arguments) {\n+        if (arguments.size() > 3) {\n+            String uri = gson.fromJson(gson.toJson(arguments.get(0)), String.class);\n+            int offset = gson.fromJson(gson.toJson(arguments.get(1)), Integer.class);\n+            boolean all = gson.fromJson(gson.toJson(arguments.get(2)), boolean.class);\n+            List<QuickPickItem> fields = Arrays.asList(gson.fromJson(gson.toJson(arguments.get(3)), QuickPickItem[].class));\n+            int kind;\n+            String text;\n+            switch (command) {\n+                case GENERATE_GETTERS: kind = GeneratorUtils.GETTERS_ONLY; text = Bundle.DN_SelectGetters(); break;\n+                case GENERATE_SETTERS: kind = GeneratorUtils.SETTERS_ONLY; text = Bundle.DN_SelectSetters(); break;\n+                default: kind = 0; text = Bundle.DN_SelectGettersSetters(); break;\n+            }\n+            if (all && fields.size() > 1) {\n+                client.showQuickPick(new ShowQuickPickParams(text, true, fields)).thenAccept(selected -> {\n+                    if (selected != null) {\n+                        generate(client, kind, uri, offset, selected);\n+                    }\n+                });\n+            } else {\n+                generate(client, kind, uri, offset, fields);\n+            }\n+        }\n+        return CompletableFuture.completedFuture(true);\n+    }\n+\n+    private void generate(NbCodeLanguageClient client, int kind, String uri, int offset, List<QuickPickItem> fields) throws IllegalArgumentException {\n+        try {\n+            FileObject file = Utils.fromUri(uri);\n+            JavaSource js = JavaSource.forFileObject(file);\n+            List<TextEdit> edits = TextDocumentServiceImpl.modify2TextEdits(js, wc -> {\n+                wc.toPhase(JavaSource.Phase.RESOLVED);\n+                if (!fields.isEmpty()) {\n+                    TreePath tp = wc.getTreeUtilities().pathFor(offset);\n+                    tp = wc.getTreeUtilities().getPathElementOfKind(TreeUtilities.CLASS_TREE_KINDS, tp);\n+                    if (tp != null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4165983e6b010879475ed67961486fe3b278e364"}, "originalPosition": 161}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzIxNTUzMw==", "bodyText": "&& !selected.isEmpty()", "url": "https://github.com/apache/netbeans/pull/2587#discussion_r543215533", "createdAt": "2020-12-15T10:15:08Z", "author": {"login": "sdedic"}, "path": "java/java.lsp.server/src/org/netbeans/modules/java/lsp/server/protocol/ImplementOverrideMethodGenerator.java", "diffHunk": "@@ -0,0 +1,178 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.netbeans.modules.java.lsp.server.protocol;\n+\n+import com.google.gson.Gson;\n+import com.sun.source.util.TreePath;\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.stream.Collectors;\n+import javax.lang.model.SourceVersion;\n+import javax.lang.model.element.Element;\n+import javax.lang.model.element.ElementKind;\n+import javax.lang.model.element.ExecutableElement;\n+import javax.lang.model.element.Modifier;\n+import javax.lang.model.element.TypeElement;\n+import org.eclipse.lsp4j.ApplyWorkspaceEditParams;\n+import org.eclipse.lsp4j.CodeAction;\n+import org.eclipse.lsp4j.CodeActionKind;\n+import org.eclipse.lsp4j.CodeActionParams;\n+import org.eclipse.lsp4j.MessageParams;\n+import org.eclipse.lsp4j.MessageType;\n+import org.eclipse.lsp4j.TextEdit;\n+import org.eclipse.lsp4j.WorkspaceEdit;\n+import org.netbeans.api.java.source.CompilationInfo;\n+import org.netbeans.api.java.source.ElementUtilities;\n+import org.netbeans.api.java.source.JavaSource;\n+import org.netbeans.api.java.source.TreeUtilities;\n+import org.netbeans.modules.java.editor.codegen.GeneratorUtils;\n+import org.netbeans.modules.java.lsp.server.Utils;\n+import org.openide.filesystems.FileObject;\n+import org.openide.util.NbBundle;\n+\n+/**\n+ *\n+ * @author Dusan Balek\n+ */\n+public final class ImplementOverrideMethodGenerator extends CodeGenerator {\n+\n+    public static final String GENERATE_IMPLEMENT_METHOD =  \"java.generate.implementMethod\";\n+    public static final String GENERATE_OVERRIDE_METHOD =  \"java.generate.overrideMethod\";\n+\n+    private final Set<String> commands = Collections.unmodifiableSet(new HashSet<>(Arrays.asList(GENERATE_IMPLEMENT_METHOD, GENERATE_OVERRIDE_METHOD)));\n+    private final Gson gson = new Gson();\n+\n+    ImplementOverrideMethodGenerator() {\n+    }\n+\n+    @Override\n+    @NbBundle.Messages({\n+        \"DN_GenerateImplementMethod=Generate Implement Method...\",\n+        \"DN_GenerateOverrideMethod=Generate Override Method...\",\n+        \"DN_From=(from {0})\",\n+    })\n+    public List<CodeAction> getCodeActions(CompilationInfo info, CodeActionParams params) {\n+        List<String> only = params.getContext().getOnly();\n+        if (only == null || !only.contains(CodeActionKind.Source)) {\n+            return Collections.emptyList();\n+        }\n+        int offset = getOffset(info, params.getRange().getStart());\n+        TreePath tp = info.getTreeUtilities().pathFor(offset);\n+        tp = info.getTreeUtilities().getPathElementOfKind(TreeUtilities.CLASS_TREE_KINDS, tp);\n+        if (tp == null) {\n+            return Collections.emptyList();\n+        }\n+        TypeElement typeElement = (TypeElement) info.getTrees().getElement(tp);\n+        if (typeElement == null || typeElement.getKind() == ElementKind.ANNOTATION_TYPE) {\n+            return Collections.emptyList();\n+        }\n+        List<CodeAction> result = new ArrayList<>();\n+        String uri = Utils.toUri(info.getFileObject());\n+        ElementUtilities eu = info.getElementUtilities();\n+        if (typeElement.getKind().isClass() || typeElement.getKind().isInterface() && SourceVersion.RELEASE_8.compareTo(info.getSourceVersion()) <= 0) {\n+            List<QuickPickItem> implementMethods = new ArrayList<>();\n+            for (ExecutableElement method : eu.findUnimplementedMethods(typeElement, true)) {\n+                boolean mustImplement = !method.getModifiers().contains(Modifier.DEFAULT);\n+                Element enclosingElement = method.getEnclosingElement();\n+                String enclosingTypeName = enclosingElement.getKind().isClass() || enclosingElement.getKind().isInterface() ? Bundle.DN_From(((TypeElement)enclosingElement).getQualifiedName().toString()) : null;\n+                implementMethods.add(new QuickPickItem(createLabel(info, method), enclosingTypeName, null, mustImplement, new ElementData(method)));\n+            }\n+            if (!implementMethods.isEmpty()) {\n+                result.add(createCodeAction(Bundle.DN_GenerateImplementMethod(), CODE_GENERATOR_KIND, GENERATE_IMPLEMENT_METHOD, uri, offset, implementMethods));\n+            }\n+        }\n+        if (typeElement.getKind().isClass() || typeElement.getKind().isInterface()) {\n+            List<QuickPickItem> overrideMethods = new ArrayList<>();\n+            for (ExecutableElement method : eu.findOverridableMethods(typeElement)) {\n+                Element enclosingElement = method.getEnclosingElement();\n+                String enclosingTypeName = enclosingElement.getKind().isClass() || enclosingElement.getKind().isInterface() ? Bundle.DN_From(((TypeElement) enclosingElement).getQualifiedName().toString()) : null;\n+                QuickPickItem item = new QuickPickItem(createLabel(info, method));\n+                if (enclosingTypeName != null) {\n+                    item.setDescription(enclosingTypeName);\n+                }\n+                item.setUserData(new ElementData(method));\n+                overrideMethods.add(item);\n+            }\n+            if (!overrideMethods.isEmpty()) {\n+                result.add(createCodeAction(Bundle.DN_GenerateOverrideMethod(), CODE_GENERATOR_KIND, GENERATE_OVERRIDE_METHOD, uri, offset, overrideMethods));\n+            }\n+        }\n+        return result;\n+    }\n+\n+    @Override\n+    public Set<String> getCommands() {\n+        return commands;\n+    }\n+\n+    @Override\n+    @NbBundle.Messages({\n+        \"DN_SelectImplementMethod=Select methods to implement\",\n+        \"DN_SelectOverrideMethod=Select methods to override\",\n+    })\n+    public CompletableFuture<Object> processCommand(NbCodeLanguageClient client, String command, List<Object> arguments) {\n+        if (arguments.size() > 2) {\n+            String uri = gson.fromJson(gson.toJson(arguments.get(0)), String.class);\n+            int offset = gson.fromJson(gson.toJson(arguments.get(1)), Integer.class);\n+            List<QuickPickItem> methods = Arrays.asList(gson.fromJson(gson.toJson(arguments.get(2)), QuickPickItem[].class));\n+            String text = command == GENERATE_IMPLEMENT_METHOD ? Bundle.DN_SelectImplementMethod() : Bundle.DN_SelectOverrideMethod();\n+            boolean isImplement = command == GENERATE_IMPLEMENT_METHOD;\n+            client.showQuickPick(new ShowQuickPickParams(text, true, methods)).thenAccept(selected -> {\n+                if (selected != null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4165983e6b010879475ed67961486fe3b278e364"}, "originalPosition": 143}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzIxOTM3MQ==", "bodyText": "I am not sure what GenreratorUtils.generateMethodOverrides does when overriding method in the interface type for Java < 8, where default modified is not allowed.", "url": "https://github.com/apache/netbeans/pull/2587#discussion_r543219371", "createdAt": "2020-12-15T10:20:42Z", "author": {"login": "sdedic"}, "path": "java/java.lsp.server/src/org/netbeans/modules/java/lsp/server/protocol/ImplementOverrideMethodGenerator.java", "diffHunk": "@@ -0,0 +1,178 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.netbeans.modules.java.lsp.server.protocol;\n+\n+import com.google.gson.Gson;\n+import com.sun.source.util.TreePath;\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.stream.Collectors;\n+import javax.lang.model.SourceVersion;\n+import javax.lang.model.element.Element;\n+import javax.lang.model.element.ElementKind;\n+import javax.lang.model.element.ExecutableElement;\n+import javax.lang.model.element.Modifier;\n+import javax.lang.model.element.TypeElement;\n+import org.eclipse.lsp4j.ApplyWorkspaceEditParams;\n+import org.eclipse.lsp4j.CodeAction;\n+import org.eclipse.lsp4j.CodeActionKind;\n+import org.eclipse.lsp4j.CodeActionParams;\n+import org.eclipse.lsp4j.MessageParams;\n+import org.eclipse.lsp4j.MessageType;\n+import org.eclipse.lsp4j.TextEdit;\n+import org.eclipse.lsp4j.WorkspaceEdit;\n+import org.netbeans.api.java.source.CompilationInfo;\n+import org.netbeans.api.java.source.ElementUtilities;\n+import org.netbeans.api.java.source.JavaSource;\n+import org.netbeans.api.java.source.TreeUtilities;\n+import org.netbeans.modules.java.editor.codegen.GeneratorUtils;\n+import org.netbeans.modules.java.lsp.server.Utils;\n+import org.openide.filesystems.FileObject;\n+import org.openide.util.NbBundle;\n+\n+/**\n+ *\n+ * @author Dusan Balek\n+ */\n+public final class ImplementOverrideMethodGenerator extends CodeGenerator {\n+\n+    public static final String GENERATE_IMPLEMENT_METHOD =  \"java.generate.implementMethod\";\n+    public static final String GENERATE_OVERRIDE_METHOD =  \"java.generate.overrideMethod\";\n+\n+    private final Set<String> commands = Collections.unmodifiableSet(new HashSet<>(Arrays.asList(GENERATE_IMPLEMENT_METHOD, GENERATE_OVERRIDE_METHOD)));\n+    private final Gson gson = new Gson();\n+\n+    ImplementOverrideMethodGenerator() {\n+    }\n+\n+    @Override\n+    @NbBundle.Messages({\n+        \"DN_GenerateImplementMethod=Generate Implement Method...\",\n+        \"DN_GenerateOverrideMethod=Generate Override Method...\",\n+        \"DN_From=(from {0})\",\n+    })\n+    public List<CodeAction> getCodeActions(CompilationInfo info, CodeActionParams params) {\n+        List<String> only = params.getContext().getOnly();\n+        if (only == null || !only.contains(CodeActionKind.Source)) {\n+            return Collections.emptyList();\n+        }\n+        int offset = getOffset(info, params.getRange().getStart());\n+        TreePath tp = info.getTreeUtilities().pathFor(offset);\n+        tp = info.getTreeUtilities().getPathElementOfKind(TreeUtilities.CLASS_TREE_KINDS, tp);\n+        if (tp == null) {\n+            return Collections.emptyList();\n+        }\n+        TypeElement typeElement = (TypeElement) info.getTrees().getElement(tp);\n+        if (typeElement == null || typeElement.getKind() == ElementKind.ANNOTATION_TYPE) {\n+            return Collections.emptyList();\n+        }\n+        List<CodeAction> result = new ArrayList<>();\n+        String uri = Utils.toUri(info.getFileObject());\n+        ElementUtilities eu = info.getElementUtilities();\n+        if (typeElement.getKind().isClass() || typeElement.getKind().isInterface() && SourceVersion.RELEASE_8.compareTo(info.getSourceVersion()) <= 0) {\n+            List<QuickPickItem> implementMethods = new ArrayList<>();\n+            for (ExecutableElement method : eu.findUnimplementedMethods(typeElement, true)) {\n+                boolean mustImplement = !method.getModifiers().contains(Modifier.DEFAULT);\n+                Element enclosingElement = method.getEnclosingElement();\n+                String enclosingTypeName = enclosingElement.getKind().isClass() || enclosingElement.getKind().isInterface() ? Bundle.DN_From(((TypeElement)enclosingElement).getQualifiedName().toString()) : null;\n+                implementMethods.add(new QuickPickItem(createLabel(info, method), enclosingTypeName, null, mustImplement, new ElementData(method)));\n+            }\n+            if (!implementMethods.isEmpty()) {\n+                result.add(createCodeAction(Bundle.DN_GenerateImplementMethod(), CODE_GENERATOR_KIND, GENERATE_IMPLEMENT_METHOD, uri, offset, implementMethods));\n+            }\n+        }\n+        if (typeElement.getKind().isClass() || typeElement.getKind().isInterface()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4165983e6b010879475ed67961486fe3b278e364"}, "originalPosition": 106}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzIyMTgxMg==", "bodyText": "This may suggest to create Logger, even if one is present, but not resolved (i.e. missing import).", "url": "https://github.com/apache/netbeans/pull/2587#discussion_r543221812", "createdAt": "2020-12-15T10:24:02Z", "author": {"login": "sdedic"}, "path": "java/java.lsp.server/src/org/netbeans/modules/java/lsp/server/protocol/LoggerGenerator.java", "diffHunk": "@@ -0,0 +1,135 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.netbeans.modules.java.lsp.server.protocol;\n+\n+import com.google.gson.Gson;\n+import com.sun.source.tree.ClassTree;\n+import com.sun.source.tree.VariableTree;\n+import com.sun.source.util.TreePath;\n+import java.io.IOException;\n+import java.util.Collections;\n+import java.util.EnumSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.logging.Logger;\n+import javax.lang.model.element.Modifier;\n+import javax.lang.model.element.TypeElement;\n+import javax.lang.model.element.VariableElement;\n+import javax.lang.model.type.DeclaredType;\n+import javax.lang.model.type.TypeKind;\n+import javax.lang.model.type.TypeMirror;\n+import javax.lang.model.util.ElementFilter;\n+import org.eclipse.lsp4j.ApplyWorkspaceEditParams;\n+import org.eclipse.lsp4j.CodeAction;\n+import org.eclipse.lsp4j.CodeActionKind;\n+import org.eclipse.lsp4j.CodeActionParams;\n+import org.eclipse.lsp4j.MessageParams;\n+import org.eclipse.lsp4j.MessageType;\n+import org.eclipse.lsp4j.TextEdit;\n+import org.eclipse.lsp4j.WorkspaceEdit;\n+import org.netbeans.api.java.source.CompilationInfo;\n+import org.netbeans.api.java.source.GeneratorUtilities;\n+import org.netbeans.api.java.source.JavaSource;\n+import org.netbeans.api.java.source.TreeUtilities;\n+import org.netbeans.modules.java.lsp.server.Utils;\n+import org.openide.filesystems.FileObject;\n+import org.openide.util.NbBundle;\n+\n+/**\n+ *\n+ * @author Dusan Balek\n+ */\n+public final class LoggerGenerator extends CodeGenerator {\n+\n+    public static final String GENERATE_LOGGER =  \"java.generate.logger\";\n+\n+    private final Set<String> commands = Collections.singleton(GENERATE_LOGGER);\n+    private final Gson gson = new Gson();\n+\n+    LoggerGenerator() {\n+    }\n+\n+    @Override\n+    @NbBundle.Messages({\n+        \"DN_GenerateLogger=Generate Logger...\",\n+    })\n+    public List<CodeAction> getCodeActions(CompilationInfo info, CodeActionParams params) {\n+        List<String> only = params.getContext().getOnly();\n+        if (only == null || !only.contains(CodeActionKind.Source)) {\n+            return Collections.emptyList();\n+        }\n+        int offset = getOffset(info, params.getRange().getStart());\n+        TreePath tp = info.getTreeUtilities().pathFor(offset);\n+        tp = info.getTreeUtilities().getPathElementOfKind(TreeUtilities.CLASS_TREE_KINDS, tp);\n+        if (tp == null) {\n+            return Collections.emptyList();\n+        }\n+        TypeElement typeElement = (TypeElement) info.getTrees().getElement(tp);\n+        if (typeElement == null || !typeElement.getKind().isClass()) {\n+            return Collections.emptyList();\n+        }\n+        for (VariableElement ve : ElementFilter.fieldsIn(typeElement.getEnclosedElements())) {\n+            TypeMirror type = ve.asType();\n+            if (type.getKind() == TypeKind.DECLARED && ((TypeElement)((DeclaredType)type).asElement()).getQualifiedName().contentEquals(Logger.class.getName())) {\n+                return Collections.emptyList();\n+            }\n+        }\n+        String uri = Utils.toUri(info.getFileObject());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4165983e6b010879475ed67961486fe3b278e364"}, "originalPosition": 94}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzIyMzU0MQ==", "bodyText": "Maybe check for value to be a valid identifier ?", "url": "https://github.com/apache/netbeans/pull/2587#discussion_r543223541", "createdAt": "2020-12-15T10:26:20Z", "author": {"login": "sdedic"}, "path": "java/java.lsp.server/src/org/netbeans/modules/java/lsp/server/protocol/LoggerGenerator.java", "diffHunk": "@@ -0,0 +1,135 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.netbeans.modules.java.lsp.server.protocol;\n+\n+import com.google.gson.Gson;\n+import com.sun.source.tree.ClassTree;\n+import com.sun.source.tree.VariableTree;\n+import com.sun.source.util.TreePath;\n+import java.io.IOException;\n+import java.util.Collections;\n+import java.util.EnumSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.logging.Logger;\n+import javax.lang.model.element.Modifier;\n+import javax.lang.model.element.TypeElement;\n+import javax.lang.model.element.VariableElement;\n+import javax.lang.model.type.DeclaredType;\n+import javax.lang.model.type.TypeKind;\n+import javax.lang.model.type.TypeMirror;\n+import javax.lang.model.util.ElementFilter;\n+import org.eclipse.lsp4j.ApplyWorkspaceEditParams;\n+import org.eclipse.lsp4j.CodeAction;\n+import org.eclipse.lsp4j.CodeActionKind;\n+import org.eclipse.lsp4j.CodeActionParams;\n+import org.eclipse.lsp4j.MessageParams;\n+import org.eclipse.lsp4j.MessageType;\n+import org.eclipse.lsp4j.TextEdit;\n+import org.eclipse.lsp4j.WorkspaceEdit;\n+import org.netbeans.api.java.source.CompilationInfo;\n+import org.netbeans.api.java.source.GeneratorUtilities;\n+import org.netbeans.api.java.source.JavaSource;\n+import org.netbeans.api.java.source.TreeUtilities;\n+import org.netbeans.modules.java.lsp.server.Utils;\n+import org.openide.filesystems.FileObject;\n+import org.openide.util.NbBundle;\n+\n+/**\n+ *\n+ * @author Dusan Balek\n+ */\n+public final class LoggerGenerator extends CodeGenerator {\n+\n+    public static final String GENERATE_LOGGER =  \"java.generate.logger\";\n+\n+    private final Set<String> commands = Collections.singleton(GENERATE_LOGGER);\n+    private final Gson gson = new Gson();\n+\n+    LoggerGenerator() {\n+    }\n+\n+    @Override\n+    @NbBundle.Messages({\n+        \"DN_GenerateLogger=Generate Logger...\",\n+    })\n+    public List<CodeAction> getCodeActions(CompilationInfo info, CodeActionParams params) {\n+        List<String> only = params.getContext().getOnly();\n+        if (only == null || !only.contains(CodeActionKind.Source)) {\n+            return Collections.emptyList();\n+        }\n+        int offset = getOffset(info, params.getRange().getStart());\n+        TreePath tp = info.getTreeUtilities().pathFor(offset);\n+        tp = info.getTreeUtilities().getPathElementOfKind(TreeUtilities.CLASS_TREE_KINDS, tp);\n+        if (tp == null) {\n+            return Collections.emptyList();\n+        }\n+        TypeElement typeElement = (TypeElement) info.getTrees().getElement(tp);\n+        if (typeElement == null || !typeElement.getKind().isClass()) {\n+            return Collections.emptyList();\n+        }\n+        for (VariableElement ve : ElementFilter.fieldsIn(typeElement.getEnclosedElements())) {\n+            TypeMirror type = ve.asType();\n+            if (type.getKind() == TypeKind.DECLARED && ((TypeElement)((DeclaredType)type).asElement()).getQualifiedName().contentEquals(Logger.class.getName())) {\n+                return Collections.emptyList();\n+            }\n+        }\n+        String uri = Utils.toUri(info.getFileObject());\n+        return Collections.singletonList(createCodeAction(Bundle.DN_GenerateLogger(), CODE_GENERATOR_KIND, GENERATE_LOGGER, uri, offset));\n+    }\n+\n+    @Override\n+    public Set<String> getCommands() {\n+        return commands;\n+    }\n+\n+    @Override\n+    @NbBundle.Messages({\n+        \"DN_SelectLoggerName=Logger field name\",\n+    })\n+    public CompletableFuture<Object> processCommand(NbCodeLanguageClient client, String command, List<Object> arguments) {\n+        if (arguments.size() > 1) {\n+            String uri = gson.fromJson(gson.toJson(arguments.get(0)), String.class);\n+            int offset = gson.fromJson(gson.toJson(arguments.get(1)), Integer.class);\n+            client.showInputBox(new ShowInputBoxParams(Bundle.DN_SelectLoggerName(), \"LOG\")).thenAccept(value -> {\n+                if (value != null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4165983e6b010879475ed67961486fe3b278e364"}, "originalPosition": 112}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzIyNzM4MQ==", "bodyText": "We should invent some 'registration', i.e. using @ServiceProvider, when expanding code gens next time.", "url": "https://github.com/apache/netbeans/pull/2587#discussion_r543227381", "createdAt": "2020-12-15T10:31:44Z", "author": {"login": "sdedic"}, "path": "java/java.lsp.server/src/org/netbeans/modules/java/lsp/server/protocol/Server.java", "diffHunk": "@@ -332,12 +338,19 @@ protected LanguageClient client() {\n     \n     public static final String JAVA_BUILD_WORKSPACE =  \"java.build.workspace\";\n     public static final String GRAALVM_PAUSE_SCRIPT =  \"graalvm.pause.script\";\n-    public static final String GENERATE_GETTERS =  \"java.generate.getters\";\n-    public static final String GENERATE_SETTERS =  \"java.generate.setters\";\n-    public static final String GENERATE_GETTERS_SETTERS =  \"java.generate.getters.setters\";\n     static final String INDEXING_COMPLETED = \"Indexing completed.\";\n     static final String NO_JAVA_SUPPORT = \"Cannot initialize Java support on JDK \";\n-    \n+\n+    static final CodeGenerator[] CODE_GENERATORS = new CodeGenerator[] {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4165983e6b010879475ed67961486fe3b278e364"}, "originalPosition": 39}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTUyNTI5MTU3", "url": "https://github.com/apache/netbeans/pull/2587#pullrequestreview-552529157", "createdAt": "2020-12-15T14:42:37Z", "commit": {"oid": "4165983e6b010879475ed67961486fe3b278e364"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "11d0a382dbbae490c6f18c43b5ce243942b50907", "author": {"user": {"login": "dbalek", "name": "Dusan Balek"}}, "url": "https://github.com/apache/netbeans/commit/11d0a382dbbae490c6f18c43b5ce243942b50907", "committedDate": "2020-12-15T14:50:28Z", "message": "CodeGenerators modified bas on review."}}]}}}, "rateLimit": {"limit": 5000, "remaining": 403, "cost": 1, "resetAt": "2021-10-28T17:48:14Z"}}}