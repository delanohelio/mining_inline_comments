{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDk5OTA0MjAw", "number": 2427, "title": "Maven branding configuration API and robustness improvement", "bodyText": "I am helping to build an application on top of the NetBeans Platform and Java support (both Maven and Gradle) which has a completely different UI.\nThe default behavior of \"reusing output tabs\" in Maven doesn't suite my use-case. I'd prefer each Maven execution to request new tab. Also the \"compile on save\" behavior is problematic - my application doesn't have the project configuration options to turn it on/off (yet), so it is safer to just disable it altogether: this is made possible (via branding) in bac26b5\nThe other problem is related to debugging (and I have witnessed it in NetBeans from time to time): When you launch a debugging, but the Maven script execution fails, the system continues to listen for the debuggee to attach. If you just fix the problem and try to debug again, it doesn't work - the previous \"listening\" has to be stopped by the \"Finish Debugging\" action. Quite annoying even in NetBeans. Moreover, my application doesn't have the \"Finish Debugging\" action at all. I want to solve it by 68d7ceb - if the above situation is detected, the previous \"listening\" on the same Maven project is cancelled and new one started automatically.", "createdAt": "2020-10-08T12:59:21Z", "url": "https://github.com/apache/netbeans/pull/2427", "merged": true, "mergeCommit": {"oid": "ee29071950217d15b03601321f0718013a6138e6"}, "closed": true, "closedAt": "2020-10-09T04:38:22Z", "author": {"login": "JaroslavTulach"}, "timelineItems": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdQg8vkAH2gAyNDk5OTA0MjAwOmJhYzI2YjUyYjA1ZjVjZTgzZjM0Y2QxMDhlZTYxY2U2ZGEwNjA4ZTc=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdQmryxgFqTUwNTA5NzM1NA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "bac26b52b05f5ce83f34cd108ee61ce6da0608e7", "author": {"user": {"login": "JaroslavTulach", "name": "Jaroslav Tulach"}}, "url": "https://github.com/apache/netbeans/commit/bac26b52b05f5ce83f34cd108ee61ce6da0608e7", "committedDate": "2020-10-08T12:43:20Z", "message": "Branding API to configure default value for output reuse and CoS"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "68d7ceb99534a092d1bbee0240da02f813926347", "author": {"user": {"login": "JaroslavTulach", "name": "Jaroslav Tulach"}}, "url": "https://github.com/apache/netbeans/commit/68d7ceb99534a092d1bbee0240da02f813926347", "committedDate": "2020-10-08T12:46:38Z", "message": "Keep one Maven JPDAStart instance per project and kill previous launch when new one is requested"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA0NzY2MjQ4", "url": "https://github.com/apache/netbeans/pull/2427#pullrequestreview-504766248", "createdAt": "2020-10-08T13:12:27Z", "commit": {"oid": "68d7ceb99534a092d1bbee0240da02f813926347"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA0NzU5NjM2", "url": "https://github.com/apache/netbeans/pull/2427#pullrequestreview-504759636", "createdAt": "2020-10-08T13:05:13Z", "commit": {"oid": "68d7ceb99534a092d1bbee0240da02f813926347"}, "state": "COMMENTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOFQxMzowNToxM1rOHedjaQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOFQxMzoxMzowM1rOHed4AA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTcwMzUyOQ==", "bodyText": "Nitpick - typo: \"node\".", "url": "https://github.com/apache/netbeans/pull/2427#discussion_r501703529", "createdAt": "2020-10-08T13:05:13Z", "author": {"login": "sdedic"}, "path": "java/maven/arch.xml", "diffHunk": "@@ -169,6 +169,25 @@\n           in case reparsing starts too soon (wasting CPU) or too late (impeding editing).\n       </api>\n   </p>\n+  \n+  <p>\n+      <api category=\"devel\" group=\"branding\" name=\"DEFAULT_REUSE_OUTPUT\" type=\"export\">\n+          Brand the <code>DEFAULT_REUSE_OUTPUT</code> key in a \n+          <code>org.netbeans.modules.maven.options.Bundle</code> file\n+          with one of the values <code>true</code> or <code>false</code>\n+          to specify the default behavior of reusing output by your application.\n+          Use <code>never</code> value, if the reuse shall never be done,\n+          regardless of the settings value.\n+      </api> \n+      <api category=\"devel\" group=\"branding\" name=\"DEFAULT_COMPILE_ON_SAVE\" type=\"export\">\n+          Brand the <code>DEFAULT_COMPILE_ON_SAVE</code> key in a \n+          <code>org.netbeans.modules.maven.api.execute.Bundle</code> file\n+          with one of the values <code>all</code> or <code>node</code>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "68d7ceb99534a092d1bbee0240da02f813926347"}, "originalPosition": 17}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTcwNzExMw==", "bodyText": "May need some synchronization/flush when assigning to the shared field.", "url": "https://github.com/apache/netbeans/pull/2427#discussion_r501707113", "createdAt": "2020-10-08T13:10:32Z", "author": {"login": "sdedic"}, "path": "java/maven/src/org/netbeans/modules/maven/debug/MavenJPDAStart.java", "diffHunk": "@@ -69,139 +72,126 @@\n     private ClassPath additionalSourcePath;\n     \n     \n-    private final Object[] lock = new Object[2];\n-    \n-    private Project project;\n-    private final String actionName;\n-    private final InputOutput io;\n+    private final Project project;\n+    private Future<?> lastFuture;\n+\n+    private MavenJPDAStart(Project p) {\n+        this.project = p;\n+    }\n \n-    JPDAStart(InputOutput inputOutput, String actionName) {\n-        io = inputOutput;\n-        this.actionName = actionName;\n+    /** Create and place into Project's Lookup.\n+     * @param p the project to associate this start with\n+     * @return new instance of the start infrastructure\n+     */\n+    public static MavenJPDAStart create(Project p) {\n+        return new MavenJPDAStart(p);\n     }\n     \n     /**\n      * returns the port/address that the debugger listens to..\n      */\n-    public String execute(Project project) throws Throwable {\n-        this.project = project;\n-        io.getOut().println(\"JPDA Listening Start...\"); //NOI18N\n-//            getLog().debug(\"Entering synch lock\"); //NOI18N\n-        synchronized (lock) {\n-//                getLog().debug(\"Entered synch lock\"); //NOI18N\n-            RP.post(this);\n-//                    getLog().debug(\"Entering wait\"); //NOI18N\n-            lock.wait();\n-//                    getLog().debug(\"Wait finished\"); //NOI18N\n-            if (lock[1] != null) {\n-                throw ((Throwable) lock[1]); //NOI18N\n+    public String execute(InputOutput io) throws Throwable {\n+        Future<?> prev = lastFuture;\n+        if (prev != null && !prev.isDone()) {\n+            io.getOut().print(\"Cancelling previous JPDA listening...\"); //NOI18N\n+            if (prev.cancel(true)) {\n+                io.getOut().println(\"done\"); //NOI18N\n+            } else {\n+                io.getOut().println(\"failed\"); //NOI18N\n             }\n         }\n-        return (String)lock[0];\n+        io.getOut().println(\"JPDA Listening Start...\"); //NOI18N\n+        Future<String> future = RP.submit(() -> {\n+            return startDebugger(io);\n+        });\n+        lastFuture = future;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "68d7ceb99534a092d1bbee0240da02f813926347"}, "originalPosition": 88}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTcwODgwMA==", "bodyText": "Flush the lastFuture to other threads, next execute will run in other than RP.", "url": "https://github.com/apache/netbeans/pull/2427#discussion_r501708800", "createdAt": "2020-10-08T13:13:03Z", "author": {"login": "sdedic"}, "path": "java/maven/src/org/netbeans/modules/maven/debug/MavenJPDAStart.java", "diffHunk": "@@ -69,139 +72,126 @@\n     private ClassPath additionalSourcePath;\n     \n     \n-    private final Object[] lock = new Object[2];\n-    \n-    private Project project;\n-    private final String actionName;\n-    private final InputOutput io;\n+    private final Project project;\n+    private Future<?> lastFuture;\n+\n+    private MavenJPDAStart(Project p) {\n+        this.project = p;\n+    }\n \n-    JPDAStart(InputOutput inputOutput, String actionName) {\n-        io = inputOutput;\n-        this.actionName = actionName;\n+    /** Create and place into Project's Lookup.\n+     * @param p the project to associate this start with\n+     * @return new instance of the start infrastructure\n+     */\n+    public static MavenJPDAStart create(Project p) {\n+        return new MavenJPDAStart(p);\n     }\n     \n     /**\n      * returns the port/address that the debugger listens to..\n      */\n-    public String execute(Project project) throws Throwable {\n-        this.project = project;\n-        io.getOut().println(\"JPDA Listening Start...\"); //NOI18N\n-//            getLog().debug(\"Entering synch lock\"); //NOI18N\n-        synchronized (lock) {\n-//                getLog().debug(\"Entered synch lock\"); //NOI18N\n-            RP.post(this);\n-//                    getLog().debug(\"Entering wait\"); //NOI18N\n-            lock.wait();\n-//                    getLog().debug(\"Wait finished\"); //NOI18N\n-            if (lock[1] != null) {\n-                throw ((Throwable) lock[1]); //NOI18N\n+    public String execute(InputOutput io) throws Throwable {\n+        Future<?> prev = lastFuture;\n+        if (prev != null && !prev.isDone()) {\n+            io.getOut().print(\"Cancelling previous JPDA listening...\"); //NOI18N\n+            if (prev.cancel(true)) {\n+                io.getOut().println(\"done\"); //NOI18N\n+            } else {\n+                io.getOut().println(\"failed\"); //NOI18N\n             }\n         }\n-        return (String)lock[0];\n+        io.getOut().println(\"JPDA Listening Start...\"); //NOI18N\n+        Future<String> future = RP.submit(() -> {\n+            return startDebugger(io);\n+        });\n+        lastFuture = future;\n+        return future.get();\n     }\n     \n-    @Override\n-    public void run() {\n-        synchronized (lock) {\n-            \n-            try {\n-                \n-                ListeningConnector lc = null;\n-                Iterator i = Bootstrap.virtualMachineManager().\n-                        listeningConnectors().iterator();\n-                for (; i.hasNext();) {\n-                    lc = (ListeningConnector) i.next();\n-                    Transport t = lc.transport();\n-                    if (t != null && t.name().equals(getTransport())) {\n-                        break;\n-                    }\n-                }\n-                if (lc == null) {\n-                    throw new RuntimeException\n-                            (\"No trasports named \" + getTransport() + \" found!\"); //NOI18N\n-                }\n-                // TODO: revisit later when http://developer.java.sun.com/developer/bugParade/bugs/4932074.html gets integrated into JDK\n-                // This code parses the address string \"HOST:PORT\" to extract PORT and then point debugee to localhost:PORT\n-                // This is NOT a clean solution to the problem but it SHOULD work in 99% cases\n-                final Map args = lc.defaultArguments();\n-                String address = lc.startListening(args);\n-                try {\n-                    int port = Integer.parseInt(address.substring(address.indexOf(':') + 1));\n+    private String startDebugger(InputOutput io) throws IOException, IllegalConnectorArgumentsException {\n+        String portOrAddress;\n+        ListeningConnector lc = null;\n+        Iterator i = Bootstrap.virtualMachineManager().\n+                listeningConnectors().iterator();\n+        for (; i.hasNext();) {\n+            lc = (ListeningConnector) i.next();\n+            Transport t = lc.transport();\n+            if (t != null && t.name().equals(getTransport())) {\n+                break;\n+            }\n+        }\n+        if (lc == null) {\n+            throw new RuntimeException\n+                    (\"No trasports named \" + getTransport() + \" found!\"); //NOI18N\n+        }\n+        // TODO: revisit later when http://developer.java.sun.com/developer/bugParade/bugs/4932074.html gets integrated into JDK\n+        // This code parses the address string \"HOST:PORT\" to extract PORT and then point debugee to localhost:PORT\n+        // This is NOT a clean solution to the problem but it SHOULD work in 99% cases\n+        final Map args = lc.defaultArguments();\n+        String address = lc.startListening(args);\n+        try {\n+            int port = Integer.parseInt(address.substring(address.indexOf(':') + 1));\n //                    getProject ().setNewProperty (getAddressProperty (), \"localhost:\" + port);\n-                    Connector.IntegerArgument portArg = (Connector.IntegerArgument) args.get(\"port\"); //NOI18N\n-                    portArg.setValue(port);\n-                    lock[0] = Integer.toString(port);\n-                } catch (NumberFormatException e) {\n-                    // this address format is not known, use default\n+            Connector.IntegerArgument portArg = (Connector.IntegerArgument) args.get(\"port\"); //NOI18N\n+            portArg.setValue(port);\n+            portOrAddress = Integer.toString(port);\n+        } catch (NumberFormatException e) {\n+            // this address format is not known, use default\n //                    getProject ().setNewProperty (getAddressProperty (), address);\n-                    lock[0] = address;\n-                }\n-                io.getOut().println(\"JPDA Address: \" + address); //NOI18N\n-                io.getOut().println(\"Port:\" + lock[0]); //NOI18N\n-                \n-                ClassPath sourcePath = Utils.createSourcePath(project);\n-                if (getAdditionalSourcePath() != null) {\n-                    sourcePath = ClassPathSupport.createProxyClassPath(sourcePath, getAdditionalSourcePath());\n-                }\n-                ClassPath jdkSourcePath = Utils.createJDKSourcePath(project);\n-                \n-                if (getStopClassName() != null && getStopClassName().length() > 0) {\n-                    final MethodBreakpoint b = getStopMethod() != null ? Utils.createBreakpoint(getStopClassName(), getStopMethod()) : Utils.createBreakpoint(getStopClassName());\n-                    final Listener list = new Listener(b);\n-                    b.addPropertyChangeListener(MethodBreakpoint.PROP_VALIDITY, new PropertyChangeListener() {\n-                        @Override\n-                        public void propertyChange(PropertyChangeEvent pce) {\n-                            if (Breakpoint.VALIDITY.INVALID.equals(b.getValidity()) && getStopMethod() != null) {\n-                                //when the original method with method is not available (maybe defined in parent class?), replace it with a class breakpoint\n-                                DebuggerManager.getDebuggerManager().removeBreakpoint(b);\n-                                MethodBreakpoint b2 = Utils.createBreakpoint(getStopClassName());\n-                                list.replaceBreakpoint(b2);\n-                            }\n-                        }\n-                    });\n-                    DebuggerManager.getDebuggerManager().addDebuggerListener(\n-                            DebuggerManager.PROP_DEBUGGER_ENGINES,\n-                            list);\n-                }\n-                \n-                final Map properties = new HashMap();\n-                properties.put(\"sourcepath\", sourcePath); //NOI18N\n-                properties.put(\"name\", getName()); //NOI18N\n-                properties.put(\"jdksources\", jdkSourcePath); //NOI18N\n-                properties.put(\"baseDir\", FileUtil.toFile(project.getProjectDirectory())); // NOI18N\n-                if (RunUtils.isCompileOnSaveEnabled(project)) {\n-                    properties.put (\"listeningCP\", \"sourcepath\"); // NOI18N\n-                }\n-                \n-                final ListeningConnector flc = lc;\n-                RP.post(new Runnable() {\n+            portOrAddress = address;\n+        }\n+        io.getOut().println(\"JPDA Address: \" + address); //NOI18N\n+        io.getOut().println(\"Port:\" + portOrAddress); //NOI18N\n+\n+        ClassPath sourcePath = Utils.createSourcePath(project);\n+        if (getAdditionalSourcePath() != null) {\n+            sourcePath = ClassPathSupport.createProxyClassPath(sourcePath, getAdditionalSourcePath());\n+        }\n+        ClassPath jdkSourcePath = Utils.createJDKSourcePath(project);\n \n-                    @Override\n-                    public void run() {\n-                        try {\n-                            JPDADebugger.startListening(flc, args,\n-                                                        new Object[]{properties, project});\n-                        }\n-                        catch (DebuggerStartException ex) {\n-                            io.getErr().println(\"Debugger Start Error.\"); //NOI18N\n-                            Logger.getLogger(JPDAStart.class.getName()).log(Level.INFO, \"Debugger Start Error.\", ex);\n-                        }\n+        if (getStopClassName() != null && getStopClassName().length() > 0) {\n+            final MethodBreakpoint b = getStopMethod() != null ? Utils.createBreakpoint(getStopClassName(), getStopMethod()) : Utils.createBreakpoint(getStopClassName());\n+            final Listener list = new Listener(b);\n+            b.addPropertyChangeListener(MethodBreakpoint.PROP_VALIDITY, new PropertyChangeListener() {\n+                @Override\n+                public void propertyChange(PropertyChangeEvent pce) {\n+                    if (Breakpoint.VALIDITY.INVALID.equals(b.getValidity()) && getStopMethod() != null) {\n+                        //when the original method with method is not available (maybe defined in parent class?), replace it with a class breakpoint\n+                        DebuggerManager.getDebuggerManager().removeBreakpoint(b);\n+                        MethodBreakpoint b2 = Utils.createBreakpoint(getStopClassName());\n+                        list.replaceBreakpoint(b2);\n                     }\n-                });\n-            } catch (java.io.IOException ioex) {\n-                io.getErr().println(\"IO Error:\"); //NOI18N\n-//                org.openide.ErrorManager.getDefault().notify(ioex);\n-                lock[1] = ioex;\n-            } catch (com.sun.jdi.connect.IllegalConnectorArgumentsException icaex) {\n-                io.getErr().println(\"Illegal Connector\"); //NOI18N\n-                lock[1] = icaex;\n-            } finally {\n-                lock.notify();\n-            }\n+                }\n+            });\n+            DebuggerManager.getDebuggerManager().addDebuggerListener(\n+                    DebuggerManager.PROP_DEBUGGER_ENGINES,\n+                    list);\n         }\n+\n+        final Map properties = new HashMap();\n+        properties.put(\"sourcepath\", sourcePath); //NOI18N\n+        properties.put(\"name\", getName()); //NOI18N\n+        properties.put(\"jdksources\", jdkSourcePath); //NOI18N\n+        properties.put(\"baseDir\", FileUtil.toFile(project.getProjectDirectory())); // NOI18N\n+        if (RunUtils.isCompileOnSaveEnabled(project)) {\n+            properties.put (\"listeningCP\", \"sourcepath\"); // NOI18N\n+        }\n+\n+        final ListeningConnector flc = lc;\n         \n+        lastFuture = RP.submit(() -> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "68d7ceb99534a092d1bbee0240da02f813926347"}, "originalPosition": 257}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "869353cb9efa09a0fad0ecb7deb398b3085b166c", "author": {"user": {"login": "JaroslavTulach", "name": "Jaroslav Tulach"}}, "url": "https://github.com/apache/netbeans/commit/869353cb9efa09a0fad0ecb7deb398b3085b166c", "committedDate": "2020-10-08T17:15:40Z", "message": "Fixing a typo"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0e6accddeec3dd288298c805fab54f2d553a884f", "author": {"user": {"login": "JaroslavTulach", "name": "Jaroslav Tulach"}}, "url": "https://github.com/apache/netbeans/commit/0e6accddeec3dd288298c805fab54f2d553a884f", "committedDate": "2020-10-08T17:16:51Z", "message": "Make the among the threads shared field volatile"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA1MDk3MzU0", "url": "https://github.com/apache/netbeans/pull/2427#pullrequestreview-505097354", "createdAt": "2020-10-08T19:24:15Z", "commit": {"oid": "0e6accddeec3dd288298c805fab54f2d553a884f"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 444, "cost": 1, "resetAt": "2021-10-28T17:48:14Z"}}}