{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTAxMTE4MDU4", "number": 2444, "title": "[NETBEANS-3588] Code Templates not working in Java Editor in for loops", "bodyText": "Solve the problem of code templates not working in loops in the Java editor.\nSee issue: https://issues.apache.org/jira/browse/NETBEANS-3588", "createdAt": "2020-10-11T10:52:05Z", "url": "https://github.com/apache/netbeans/pull/2444", "merged": true, "mergeCommit": {"oid": "2ae34a203f54b2243a3839a99e8acd538141b48b"}, "closed": true, "closedAt": "2020-10-23T01:08:22Z", "author": {"login": "arsadykov"}, "timelineItems": {"totalCount": 9, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdRuoQUgBqjM4NjUwOTk2OTA=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdVL_XogFqTUxNTIxNjEwOQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "37dc8af1a6aed136ae26180a78a1d8314043967c", "author": {"user": {"login": "arsadykov", "name": "Arthur Sadykov"}}, "url": "https://github.com/apache/netbeans/commit/37dc8af1a6aed136ae26180a78a1d8314043967c", "committedDate": "2020-10-11T10:41:15Z", "message": "[NETBEANS-3588] Code Templates not working in Java Editor in for loops"}, "afterCommit": {"oid": "3ae2bf61ad379ce28276b84e545f32dbae048f78", "author": {"user": {"login": "arsadykov", "name": "Arthur Sadykov"}}, "url": "https://github.com/apache/netbeans/commit/3ae2bf61ad379ce28276b84e545f32dbae048f78", "committedDate": "2020-10-12T06:55:07Z", "message": "[NETBEANS-3588] Code Templates not working in Java Editor in for loops"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA4OTcyOTI4", "url": "https://github.com/apache/netbeans/pull/2444#pullrequestreview-508972928", "createdAt": "2020-10-15T05:50:56Z", "commit": {"oid": "3ae2bf61ad379ce28276b84e545f32dbae048f78"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNVQwNTo1Mjo1NFrOHhxwUw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNVQwNTo1NTo0NlrOHhx0Rg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTE4MDI0Mw==", "bodyText": "CompilationInfo.getTokenHierarchy() is, as far as I know, based on an immutable copy of the Document's content. No need to Document.render.", "url": "https://github.com/apache/netbeans/pull/2444#discussion_r505180243", "createdAt": "2020-10-15T05:52:54Z", "author": {"login": "jlahoda"}, "path": "java/java.editor/src/org/netbeans/modules/editor/java/JavaCodeTemplateFilter.java", "diffHunk": "@@ -72,88 +73,125 @@ private JavaCodeTemplateFilter(JTextComponent component, int offset) {\n             final Source source = Source.create(component.getDocument());\n             if (source != null) {\n                 final AtomicBoolean cancel = new AtomicBoolean();\n-                ProgressUtils.runOffEventDispatchThread(new Runnable() {\n-                    @Override\n-                    public void run() {\n-                        try {\n-                            ParserManager.parse(Collections.singleton(source), new UserTask() {\n-                                @Override\n-                                public void run(ResultIterator resultIterator) throws Exception {\n-                                    if (cancel.get()) {\n-                                        return;\n+                BaseProgressUtils.runOffEventDispatchThread(() -> {\n+                    try {\n+                        ParserManager.parse(Collections.singleton(source), new UserTask() {\n+                            @Override\n+                            public void run(ResultIterator resultIterator) throws Exception {\n+                                if (cancel.get()) {\n+                                    return;\n+                                }\n+                                Parser.Result result = resultIterator.getParserResult(startOffset);\n+                                CompilationController controller = result != null ? CompilationController.get(result) : null;\n+                                if (controller != null && Phase.PARSED.compareTo(controller.toPhase(Phase.PARSED)) <= 0) {\n+                                    TreeUtilities tu = controller.getTreeUtilities();\n+                                    int eo = endOffset;\n+                                    int so = startOffset;\n+                                    if (so >= 0) {\n+                                        so = result.getSnapshot().getEmbeddedOffset(startOffset);\n                                     }\n-                                    Parser.Result result = resultIterator.getParserResult(startOffset);\n-                                    CompilationController controller = result != null ? CompilationController.get(result) : null;\n-                                    if (controller != null && Phase.PARSED.compareTo(controller.toPhase(Phase.PARSED)) <= 0) {\n-                                        TreeUtilities tu = controller.getTreeUtilities();\n-                                        int eo = endOffset;\n-                                        int so = startOffset;\n-                                        if (so >= 0) {\n-                                            so = result.getSnapshot().getEmbeddedOffset(startOffset);\n-                                        }\n-                                        if (endOffset >= 0) {\n-                                            eo = result.getSnapshot().getEmbeddedOffset(endOffset);\n-                                            TokenSequence<JavaTokenId> ts = SourceUtils.getJavaTokenSequence(controller.getTokenHierarchy(), so);\n-                                            int delta = ts.move(so);\n+                                    if (endOffset >= 0) {\n+                                        eo = result.getSnapshot().getEmbeddedOffset(endOffset);\n+                                        TokenSequence<JavaTokenId> ts = SourceUtils.getJavaTokenSequence(controller.getTokenHierarchy(), so);\n+                                        int delta = ts.move(so);\n+                                        if (delta == 0 || ts.moveNext() && ts.token().id() == JavaTokenId.WHITESPACE) {\n+                                            delta = ts.move(eo);\n                                             if (delta == 0 || ts.moveNext() && ts.token().id() == JavaTokenId.WHITESPACE) {\n-                                                delta = ts.move(eo);\n-                                                if (delta == 0 || ts.moveNext() && ts.token().id() == JavaTokenId.WHITESPACE) {\n-                                                    String selectedText = controller.getText().substring(so, eo).trim();\n-                                                    SourcePositions[] sp = new SourcePositions[1];\n-                                                    ExpressionTree expr = selectedText.length() > 0 ? tu.parseExpression(selectedText, sp) : null;\n-                                                    if (expr != null && expr.getKind() != Tree.Kind.IDENTIFIER && !Utilities.containErrors(expr) && sp[0].getEndPosition(null, expr) >= selectedText.length()) {\n-                                                        stringCtx = EXPRESSION;\n-                                                    }\n+                                                String selectedText = controller.getText().substring(so, eo).trim();\n+                                                SourcePositions[] sp = new SourcePositions[1];\n+                                                ExpressionTree expr = selectedText.length() > 0 ? tu.parseExpression(selectedText, sp) : null;\n+                                                if (expr != null && expr.getKind() != Tree.Kind.IDENTIFIER && !Utilities.containErrors(expr) && sp[0].getEndPosition(null, expr) >= selectedText.length()) {\n+                                                    stringCtx = EXPRESSION;\n                                                 }\n                                             }\n                                         }\n-                                        Tree tree = tu.pathFor(so).getLeaf();\n-                                        if (eo >= 0 && so != eo) {\n-                                            if (tu.pathFor(eo).getLeaf() != tree) {\n-                                                return;\n-                                            }\n+                                    }\n+                                    Tree tree = tu.pathFor(so).getLeaf();\n+                                    if (eo >= 0 && so != eo) {\n+                                        if (tu.pathFor(eo).getLeaf() != tree) {\n+                                            return;\n                                         }\n-                                        treeKindCtx = tree.getKind();\n-                                        switch (treeKindCtx) {\n-                                            case CASE:\n-                                                if (so < controller.getTrees().getSourcePositions().getEndPosition(controller.getCompilationUnit(), ((CaseTree)tree).getExpression())) {\n-                                                    treeKindCtx = null;\n-                                                }\n-                                                break;\n-                                            case CLASS:\n-                                                SourcePositions sp = controller.getTrees().getSourcePositions();\n-                                                int startPos = (int)sp.getEndPosition(controller.getCompilationUnit(), ((ClassTree)tree).getModifiers());\n-                                                if (startPos <= 0) {\n-                                                    startPos = (int)sp.getStartPosition(controller.getCompilationUnit(), tree);\n-                                                }\n-                                                String headerText = controller.getText().substring(startPos, so);\n-                                                int idx = headerText.indexOf('{'); //NOI18N\n-                                                if (idx < 0) {\n-                                                    treeKindCtx = null;\n-                                                    stringCtx = CLASS_HEADER;\n-                                                }\n-                                                break;\n-                                            case FOR_LOOP:\n-                                            case ENHANCED_FOR_LOOP:\n-                                            case WHILE_LOOP:\n-                                                sp = controller.getTrees().getSourcePositions();\n+                                    }\n+                                    treeKindCtx = tree.getKind();\n+                                    switch (treeKindCtx) {\n+                                        case CASE:\n+                                            if (so < controller.getTrees().getSourcePositions().getEndPosition(controller.getCompilationUnit(), ((CaseTree)tree).getExpression())) {\n+                                                treeKindCtx = null;\n+                                            }\n+                                            break;\n+                                        case CLASS:\n+                                            SourcePositions sp = controller.getTrees().getSourcePositions();\n+                                            int startPos = (int)sp.getEndPosition(controller.getCompilationUnit(), ((ClassTree)tree).getModifiers());\n+                                            if (startPos <= 0) {\n                                                 startPos = (int)sp.getStartPosition(controller.getCompilationUnit(), tree);\n-                                                String text = controller.getText().substring(startPos, so);\n-                                                if (!text.trim().endsWith(\")\")) {\n-                                                    treeKindCtx = null;\n+                                            }\n+                                            String headerText = controller.getText().substring(startPos, so);\n+                                            int idx = headerText.indexOf('{'); //NOI18N\n+                                            if (idx < 0) {\n+                                                treeKindCtx = null;\n+                                                stringCtx = CLASS_HEADER;\n+                                            }\n+                                            break;\n+                                        case FOR_LOOP:\n+                                        case ENHANCED_FOR_LOOP:\n+                                            if (!isRightParenthesisOfLoopPresent(component, controller)) {\n+                                                 treeKindCtx = null;\n+                                            }\n+                                            break;\n+                                        case PARENTHESIZED:\n+                                            if (isPartOfWhileLoop(component, controller)) {\n+                                                if (!isRightParenthesisOfLoopPresent(component, controller)) {\n+                                                        treeKindCtx = null;\n                                                 }\n-                                        }\n+                                            }\n+                                            break;\n                                     }\n                                 }\n-                            });\n-                        } catch (ParseException ex) {\n-                            Exceptions.printStackTrace(ex);\n-                        }\n+                            }\n+                        });\n+                    } catch (ParseException ex) {\n+                        Exceptions.printStackTrace(ex);\n                     }\n                 }, NbBundle.getMessage(JavaCodeTemplateProcessor.class, \"JCT-init\"), cancel, false); //NOI18N\n             }\n         }\n     }\n+    \n+    private boolean isPartOfWhileLoop(JTextComponent component, CompilationController controller) {\n+        TreeUtilities treeUtilities = controller.getTreeUtilities();\n+        TreePath currentPath = treeUtilities.pathFor(component.getCaretPosition());\n+        TreePath parentPath = treeUtilities.getPathElementOfKind(Tree.Kind.WHILE_LOOP, currentPath);\n+        return parentPath != null;\n+    }\n+    \n+    private boolean isRightParenthesisOfLoopPresent(JTextComponent component, CompilationController controller) {\n+        AtomicBoolean result = new AtomicBoolean(true);\n+        Document document = component.getDocument();\n+        document.render(() -> {\n+            TokenHierarchy<?> tokenHierarchy = controller.getTokenHierarchy();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3ae2bf61ad379ce28276b84e545f32dbae048f78"}, "originalPosition": 208}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTE4MTI1NA==", "bodyText": "This code runs outside of the AWT event dispatch thread, so calling getCaretPosition() seems somewhat dangerous. There are various offsets available inside the task, is there some that could be used. For example \"so\" looks like a potential candidate?", "url": "https://github.com/apache/netbeans/pull/2444#discussion_r505181254", "createdAt": "2020-10-15T05:55:46Z", "author": {"login": "jlahoda"}, "path": "java/java.editor/src/org/netbeans/modules/editor/java/JavaCodeTemplateFilter.java", "diffHunk": "@@ -72,88 +73,125 @@ private JavaCodeTemplateFilter(JTextComponent component, int offset) {\n             final Source source = Source.create(component.getDocument());\n             if (source != null) {\n                 final AtomicBoolean cancel = new AtomicBoolean();\n-                ProgressUtils.runOffEventDispatchThread(new Runnable() {\n-                    @Override\n-                    public void run() {\n-                        try {\n-                            ParserManager.parse(Collections.singleton(source), new UserTask() {\n-                                @Override\n-                                public void run(ResultIterator resultIterator) throws Exception {\n-                                    if (cancel.get()) {\n-                                        return;\n+                BaseProgressUtils.runOffEventDispatchThread(() -> {\n+                    try {\n+                        ParserManager.parse(Collections.singleton(source), new UserTask() {\n+                            @Override\n+                            public void run(ResultIterator resultIterator) throws Exception {\n+                                if (cancel.get()) {\n+                                    return;\n+                                }\n+                                Parser.Result result = resultIterator.getParserResult(startOffset);\n+                                CompilationController controller = result != null ? CompilationController.get(result) : null;\n+                                if (controller != null && Phase.PARSED.compareTo(controller.toPhase(Phase.PARSED)) <= 0) {\n+                                    TreeUtilities tu = controller.getTreeUtilities();\n+                                    int eo = endOffset;\n+                                    int so = startOffset;\n+                                    if (so >= 0) {\n+                                        so = result.getSnapshot().getEmbeddedOffset(startOffset);\n                                     }\n-                                    Parser.Result result = resultIterator.getParserResult(startOffset);\n-                                    CompilationController controller = result != null ? CompilationController.get(result) : null;\n-                                    if (controller != null && Phase.PARSED.compareTo(controller.toPhase(Phase.PARSED)) <= 0) {\n-                                        TreeUtilities tu = controller.getTreeUtilities();\n-                                        int eo = endOffset;\n-                                        int so = startOffset;\n-                                        if (so >= 0) {\n-                                            so = result.getSnapshot().getEmbeddedOffset(startOffset);\n-                                        }\n-                                        if (endOffset >= 0) {\n-                                            eo = result.getSnapshot().getEmbeddedOffset(endOffset);\n-                                            TokenSequence<JavaTokenId> ts = SourceUtils.getJavaTokenSequence(controller.getTokenHierarchy(), so);\n-                                            int delta = ts.move(so);\n+                                    if (endOffset >= 0) {\n+                                        eo = result.getSnapshot().getEmbeddedOffset(endOffset);\n+                                        TokenSequence<JavaTokenId> ts = SourceUtils.getJavaTokenSequence(controller.getTokenHierarchy(), so);\n+                                        int delta = ts.move(so);\n+                                        if (delta == 0 || ts.moveNext() && ts.token().id() == JavaTokenId.WHITESPACE) {\n+                                            delta = ts.move(eo);\n                                             if (delta == 0 || ts.moveNext() && ts.token().id() == JavaTokenId.WHITESPACE) {\n-                                                delta = ts.move(eo);\n-                                                if (delta == 0 || ts.moveNext() && ts.token().id() == JavaTokenId.WHITESPACE) {\n-                                                    String selectedText = controller.getText().substring(so, eo).trim();\n-                                                    SourcePositions[] sp = new SourcePositions[1];\n-                                                    ExpressionTree expr = selectedText.length() > 0 ? tu.parseExpression(selectedText, sp) : null;\n-                                                    if (expr != null && expr.getKind() != Tree.Kind.IDENTIFIER && !Utilities.containErrors(expr) && sp[0].getEndPosition(null, expr) >= selectedText.length()) {\n-                                                        stringCtx = EXPRESSION;\n-                                                    }\n+                                                String selectedText = controller.getText().substring(so, eo).trim();\n+                                                SourcePositions[] sp = new SourcePositions[1];\n+                                                ExpressionTree expr = selectedText.length() > 0 ? tu.parseExpression(selectedText, sp) : null;\n+                                                if (expr != null && expr.getKind() != Tree.Kind.IDENTIFIER && !Utilities.containErrors(expr) && sp[0].getEndPosition(null, expr) >= selectedText.length()) {\n+                                                    stringCtx = EXPRESSION;\n                                                 }\n                                             }\n                                         }\n-                                        Tree tree = tu.pathFor(so).getLeaf();\n-                                        if (eo >= 0 && so != eo) {\n-                                            if (tu.pathFor(eo).getLeaf() != tree) {\n-                                                return;\n-                                            }\n+                                    }\n+                                    Tree tree = tu.pathFor(so).getLeaf();\n+                                    if (eo >= 0 && so != eo) {\n+                                        if (tu.pathFor(eo).getLeaf() != tree) {\n+                                            return;\n                                         }\n-                                        treeKindCtx = tree.getKind();\n-                                        switch (treeKindCtx) {\n-                                            case CASE:\n-                                                if (so < controller.getTrees().getSourcePositions().getEndPosition(controller.getCompilationUnit(), ((CaseTree)tree).getExpression())) {\n-                                                    treeKindCtx = null;\n-                                                }\n-                                                break;\n-                                            case CLASS:\n-                                                SourcePositions sp = controller.getTrees().getSourcePositions();\n-                                                int startPos = (int)sp.getEndPosition(controller.getCompilationUnit(), ((ClassTree)tree).getModifiers());\n-                                                if (startPos <= 0) {\n-                                                    startPos = (int)sp.getStartPosition(controller.getCompilationUnit(), tree);\n-                                                }\n-                                                String headerText = controller.getText().substring(startPos, so);\n-                                                int idx = headerText.indexOf('{'); //NOI18N\n-                                                if (idx < 0) {\n-                                                    treeKindCtx = null;\n-                                                    stringCtx = CLASS_HEADER;\n-                                                }\n-                                                break;\n-                                            case FOR_LOOP:\n-                                            case ENHANCED_FOR_LOOP:\n-                                            case WHILE_LOOP:\n-                                                sp = controller.getTrees().getSourcePositions();\n+                                    }\n+                                    treeKindCtx = tree.getKind();\n+                                    switch (treeKindCtx) {\n+                                        case CASE:\n+                                            if (so < controller.getTrees().getSourcePositions().getEndPosition(controller.getCompilationUnit(), ((CaseTree)tree).getExpression())) {\n+                                                treeKindCtx = null;\n+                                            }\n+                                            break;\n+                                        case CLASS:\n+                                            SourcePositions sp = controller.getTrees().getSourcePositions();\n+                                            int startPos = (int)sp.getEndPosition(controller.getCompilationUnit(), ((ClassTree)tree).getModifiers());\n+                                            if (startPos <= 0) {\n                                                 startPos = (int)sp.getStartPosition(controller.getCompilationUnit(), tree);\n-                                                String text = controller.getText().substring(startPos, so);\n-                                                if (!text.trim().endsWith(\")\")) {\n-                                                    treeKindCtx = null;\n+                                            }\n+                                            String headerText = controller.getText().substring(startPos, so);\n+                                            int idx = headerText.indexOf('{'); //NOI18N\n+                                            if (idx < 0) {\n+                                                treeKindCtx = null;\n+                                                stringCtx = CLASS_HEADER;\n+                                            }\n+                                            break;\n+                                        case FOR_LOOP:\n+                                        case ENHANCED_FOR_LOOP:\n+                                            if (!isRightParenthesisOfLoopPresent(component, controller)) {\n+                                                 treeKindCtx = null;\n+                                            }\n+                                            break;\n+                                        case PARENTHESIZED:\n+                                            if (isPartOfWhileLoop(component, controller)) {\n+                                                if (!isRightParenthesisOfLoopPresent(component, controller)) {\n+                                                        treeKindCtx = null;\n                                                 }\n-                                        }\n+                                            }\n+                                            break;\n                                     }\n                                 }\n-                            });\n-                        } catch (ParseException ex) {\n-                            Exceptions.printStackTrace(ex);\n-                        }\n+                            }\n+                        });\n+                    } catch (ParseException ex) {\n+                        Exceptions.printStackTrace(ex);\n                     }\n                 }, NbBundle.getMessage(JavaCodeTemplateProcessor.class, \"JCT-init\"), cancel, false); //NOI18N\n             }\n         }\n     }\n+    \n+    private boolean isPartOfWhileLoop(JTextComponent component, CompilationController controller) {\n+        TreeUtilities treeUtilities = controller.getTreeUtilities();\n+        TreePath currentPath = treeUtilities.pathFor(component.getCaretPosition());\n+        TreePath parentPath = treeUtilities.getPathElementOfKind(Tree.Kind.WHILE_LOOP, currentPath);\n+        return parentPath != null;\n+    }\n+    \n+    private boolean isRightParenthesisOfLoopPresent(JTextComponent component, CompilationController controller) {\n+        AtomicBoolean result = new AtomicBoolean(true);\n+        Document document = component.getDocument();\n+        document.render(() -> {\n+            TokenHierarchy<?> tokenHierarchy = controller.getTokenHierarchy();\n+            TokenSequence<?> tokenSequence = tokenHierarchy.tokenSequence();\n+            tokenSequence.move(component.getCaretPosition());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3ae2bf61ad379ce28276b84e545f32dbae048f78"}, "originalPosition": 210}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "3ae2bf61ad379ce28276b84e545f32dbae048f78", "author": {"user": {"login": "arsadykov", "name": "Arthur Sadykov"}}, "url": "https://github.com/apache/netbeans/commit/3ae2bf61ad379ce28276b84e545f32dbae048f78", "committedDate": "2020-10-12T06:55:07Z", "message": "[NETBEANS-3588] Code Templates not working in Java Editor in for loops"}, "afterCommit": {"oid": "35bb857cc697e5f322c43ab2c02ba0f570df448f", "author": {"user": {"login": "arsadykov", "name": "Arthur Sadykov"}}, "url": "https://github.com/apache/netbeans/commit/35bb857cc697e5f322c43ab2c02ba0f570df448f", "committedDate": "2020-10-16T11:45:50Z", "message": "[NETBEANS-3588] Code Templates not working in Java Editor in for loops"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTEzNzU1MzQ0", "url": "https://github.com/apache/netbeans/pull/2444#pullrequestreview-513755344", "createdAt": "2020-10-21T14:32:12Z", "commit": {"oid": "35bb857cc697e5f322c43ab2c02ba0f570df448f"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "35bb857cc697e5f322c43ab2c02ba0f570df448f", "author": {"user": {"login": "arsadykov", "name": "Arthur Sadykov"}}, "url": "https://github.com/apache/netbeans/commit/35bb857cc697e5f322c43ab2c02ba0f570df448f", "committedDate": "2020-10-16T11:45:50Z", "message": "[NETBEANS-3588] Code Templates not working in Java Editor in for loops"}, "afterCommit": {"oid": "c1f511403f45ae9d5ca84c463bd6f87127f6d522", "author": {"user": {"login": "arsadykov", "name": "Arthur Sadykov"}}, "url": "https://github.com/apache/netbeans/commit/c1f511403f45ae9d5ca84c463bd6f87127f6d522", "committedDate": "2020-10-22T20:26:33Z", "message": "[NETBEANS-3588] Code Templates not working in Java Editor in for loops"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c3265e84b7ed436c63c8108690fa1a508f700299", "author": {"user": {"login": "arsadykov", "name": "Arthur Sadykov"}}, "url": "https://github.com/apache/netbeans/commit/c3265e84b7ed436c63c8108690fa1a508f700299", "committedDate": "2020-10-22T22:20:51Z", "message": "[NETBEANS-3588] Code Templates not working in Java Editor in for loops"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5dacf0b8f64f134dbb367f1407f2ebd255456899", "author": {"user": {"login": "arsadykov", "name": "Arthur Sadykov"}}, "url": "https://github.com/apache/netbeans/commit/5dacf0b8f64f134dbb367f1407f2ebd255456899", "committedDate": "2020-10-22T22:20:51Z", "message": "[NETBEANS-3588] Code Templates not working in Java Editor in for loops"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "c1f511403f45ae9d5ca84c463bd6f87127f6d522", "author": {"user": {"login": "arsadykov", "name": "Arthur Sadykov"}}, "url": "https://github.com/apache/netbeans/commit/c1f511403f45ae9d5ca84c463bd6f87127f6d522", "committedDate": "2020-10-22T20:26:33Z", "message": "[NETBEANS-3588] Code Templates not working in Java Editor in for loops"}, "afterCommit": {"oid": "5dacf0b8f64f134dbb367f1407f2ebd255456899", "author": {"user": {"login": "arsadykov", "name": "Arthur Sadykov"}}, "url": "https://github.com/apache/netbeans/commit/5dacf0b8f64f134dbb367f1407f2ebd255456899", "committedDate": "2020-10-22T22:20:51Z", "message": "[NETBEANS-3588] Code Templates not working in Java Editor in for loops"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE1MjE2MTA5", "url": "https://github.com/apache/netbeans/pull/2444#pullrequestreview-515216109", "createdAt": "2020-10-23T01:07:49Z", "commit": {"oid": "5dacf0b8f64f134dbb367f1407f2ebd255456899"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 462, "cost": 1, "resetAt": "2021-10-28T17:48:14Z"}}}