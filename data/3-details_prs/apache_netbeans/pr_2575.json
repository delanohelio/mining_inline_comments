{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTMxNjA3NDMw", "number": 2575, "title": "Open GraalVM sources out of the box", "bodyText": "The GraalVM sources use a fine tuned build system called mx (shorthand of MaXine). The mx command seems to work fine for the special purposes of building own enhanced JVM and it looks like it is going to stay. The goal of this PR is to establish a solid infrastructure to make sure the Apache NetBeans IDE as well as products based on top of it (let's name IGV and VSNetBeans) understand the suite.py metadata files and can use the mx command to build and run/debug unit tests.\nThe mx build system integrates with various IDEs via mx ideinit command. That command generates essential metadata for Eclipse, IntelliJ as well as NetBeans. However the NetBeans solution is based on Ant scripts. It has some limitations and moreover the Apache NetBeans project decided to focus on Maven (and Gradle) rather than promoting the old fashioned Ant based projects. As such, I'd like to deprecate the mx netbeansinit command in mx and rather propose all NetBeans users to switch to native mx projects support proposed by this PR.\nThe mx build system isn't in wide spread use (however it is used by independent groups like at the Postdam university for its unique features allowing to easily extend the JVM). Providing support for such exotic build system may seem unnecessary, but there are reasons to do it. We already have support for OpenJDK projects, which is also kind of special as well. As far as I know there were no problems with it. It fully builds on the modular architecture of NetBeans and comes as a single module. Moreover it gives NetBeans a fantatic story for OpenJDK developers. I'd like to repeat the same with the mx projects support - a single, isolated module causing no harm, handy (out of the box) for those who use mx as their build system. Acceptable?\nThe PR isn't ready to be merged right now, I still need to find out what to do with the tests. Still, I wanted to bring this idea to your attention. If we agree this code is \"integratable\" I'll polish the code and tests to comply with the Apache requirements.\nPS: My hope is that the approach of this PR is found acceptable for Apache NetBeans project. If that happens the code of this module is going to be more easily approachable to other people building NetBeans and together we can improve experience of NetBeans users even when working with other projects (I dream about improved compile on save capability, better API for external execution & co.).", "createdAt": "2020-12-03T08:41:55Z", "url": "https://github.com/apache/netbeans/pull/2575", "merged": true, "mergeCommit": {"oid": "38b64eae50187bd468a92870216fff19b4ab88bb"}, "closed": true, "closedAt": "2020-12-17T04:37:07Z", "author": {"login": "JaroslavTulach"}, "timelineItems": {"totalCount": 24, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdgWsABgH2gAyNTMxNjA3NDMwOjM0MzM5ZDQ1ZjNlN2Y0ZDlmYjg0NTI0ZTFkZTBiZGQ4NzY4YjAxOWU=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdmwkOVABqjQxMjAyNzIzMTQ=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "34339d45f3e7f4d9fb84524e1de0bdd8768b019e", "author": {"user": {"login": "JaroslavTulach", "name": "Jaroslav Tulach"}}, "url": "https://github.com/apache/netbeans/commit/34339d45f3e7f4d9fb84524e1de0bdd8768b019e", "committedDate": "2020-11-26T17:48:47Z", "message": "Support for mx based projects"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ0MTc0ODcx", "url": "https://github.com/apache/netbeans/pull/2575#pullrequestreview-544174871", "createdAt": "2020-12-03T16:56:07Z", "commit": {"oid": "34339d45f3e7f4d9fb84524e1de0bdd8768b019e"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "dd51e1d98a089fcaecf940d42a74fa9824ee3a0c", "author": {"user": {"login": "JaroslavTulach", "name": "Jaroslav Tulach"}}, "url": "https://github.com/apache/netbeans/commit/dd51e1d98a089fcaecf940d42a74fa9824ee3a0c", "committedDate": "2020-12-05T18:24:20Z", "message": "Include the java.mx.project module in the tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "548a1bfb088fcfe6bbac655aab32f5ce7cb1e13a", "author": {"user": {"login": "JaroslavTulach", "name": "Jaroslav Tulach"}}, "url": "https://github.com/apache/netbeans/commit/548a1bfb088fcfe6bbac655aab32f5ce7cb1e13a", "committedDate": "2020-12-05T18:25:20Z", "message": "Parsing is tested by the integration tests extensively"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "977d1ebe416b5fa144d72319268ddec157617f89", "author": {"user": {"login": "JaroslavTulach", "name": "Jaroslav Tulach"}}, "url": "https://github.com/apache/netbeans/commit/977d1ebe416b5fa144d72319268ddec157617f89", "committedDate": "2020-12-05T18:27:13Z", "message": "Integration test to verify behavior on vm-20.3.0 snapshot"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "929536e7925b3b0ca97c44c33b710ff9718f0b54", "author": {"user": {"login": "JaroslavTulach", "name": "Jaroslav Tulach"}}, "url": "https://github.com/apache/netbeans/commit/929536e7925b3b0ca97c44c33b710ff9718f0b54", "committedDate": "2020-12-06T04:25:42Z", "message": "More detailed project description"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "352681f5080ae66bd0b82e63536aeb0473ba04fa", "author": {"user": {"login": "JaroslavTulach", "name": "Jaroslav Tulach"}}, "url": "https://github.com/apache/netbeans/commit/352681f5080ae66bd0b82e63536aeb0473ba04fa", "committedDate": "2020-12-06T04:27:26Z", "message": "Adding header to the formatting setting"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f1fadbb07f51c560f2e47f4846e15eee1704a260", "author": {"user": {"login": "JaroslavTulach", "name": "Jaroslav Tulach"}}, "url": "https://github.com/apache/netbeans/commit/f1fadbb07f51c560f2e47f4846e15eee1704a260", "committedDate": "2020-12-06T05:40:14Z", "message": "Reconstructing the core libraries with factory methods"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e91f719a198fcf451a3251ca8c58d998638faae0", "author": {"user": {"login": "JaroslavTulach", "name": "Jaroslav Tulach"}}, "url": "https://github.com/apache/netbeans/commit/e91f719a198fcf451a3251ca8c58d998638faae0", "committedDate": "2020-12-06T06:32:33Z", "message": "Support for mx.*/suite.py pattern in ergonomics"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9987cbff8bb7a1244aa03bfb9624e378f92e8036", "author": {"user": {"login": "JaroslavTulach", "name": "Jaroslav Tulach"}}, "url": "https://github.com/apache/netbeans/commit/9987cbff8bb7a1244aa03bfb9624e378f92e8036", "committedDate": "2020-12-06T08:15:12Z", "message": "Disabling check of Truffle suite due to frequent out of memory erros from javac"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "21a2744fdd0de199cff1cdca7143f5498c4a4bdc", "author": {"user": {"login": "JaroslavTulach", "name": "Jaroslav Tulach"}}, "url": "https://github.com/apache/netbeans/commit/21a2744fdd0de199cff1cdca7143f5498c4a4bdc", "committedDate": "2020-12-06T08:15:40Z", "message": "Up-to-date with current master"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ1NzAzMzYw", "url": "https://github.com/apache/netbeans/pull/2575#pullrequestreview-545703360", "createdAt": "2020-12-06T13:01:59Z", "commit": {"oid": "21a2744fdd0de199cff1cdca7143f5498c4a4bdc"}, "state": "APPROVED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNlQxMzowMjowMFrOIAJ-ww==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNlQxMzowNDozOFrOIAKAxA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzAzNDQzNQ==", "bodyText": "I wonder - can we parse this at runtime from something? Like, maybe, mx/suite.py? It feels weird to have this information hardcoded.", "url": "https://github.com/apache/netbeans/pull/2575#discussion_r537034435", "createdAt": "2020-12-06T13:02:00Z", "author": {"login": "jlahoda"}, "path": "java/java.mx.project/src/org/netbeans/modules/java/mx/project/CoreSuite.java", "diffHunk": "@@ -0,0 +1,732 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.netbeans.modules.java.mx.project;\n+\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import org.netbeans.modules.java.mx.project.suitepy.MxDistribution;\n+import org.netbeans.modules.java.mx.project.suitepy.MxImports;\n+import org.netbeans.modules.java.mx.project.suitepy.MxLibrary;\n+import org.netbeans.modules.java.mx.project.suitepy.MxLibrary.Arch;\n+import org.netbeans.modules.java.mx.project.suitepy.MxProject;\n+import org.netbeans.modules.java.mx.project.suitepy.MxSuite;\n+\n+final class CoreSuite {\n+    private static final class MapOf<K,V> {\n+        private final Map<K,V> map = new HashMap<>();\n+\n+        MapOf<K, V> of(K k, V v) {\n+            map.put(k, v);\n+            return this;\n+        }\n+\n+\n+        Map<K,V> build() {\n+            return map;\n+        }\n+    }\n+\n+    private static <K,V> MapOf<K,V> mapOf(Class<K> keyClass, Class<V> valueClass) {\n+        return new MapOf<>();\n+    }\n+\n+    private static MxSuite createMxSuite(\n+        String defaultLicense,\n+        Map<String, MxDistribution> distributions,\n+        MxImports imports,\n+        Map<String, MxLibrary> jdkLibraries,\n+        Map<String, MxLibrary> libraries,\n+        String mxversion,\n+        String name,\n+        Map<String, MxProject> projects\n+    ) {\n+        return new MxSuite() {\n+            @Override\n+            public String mxversion() {\n+                return mxversion;\n+            }\n+\n+            @Override\n+            public String name() {\n+                return name;\n+            }\n+\n+            @Override\n+            public String defaultLicense() {\n+                return defaultLicense;\n+            }\n+\n+            @Override\n+            public Map<String, MxLibrary> libraries() {\n+                return libraries;\n+            }\n+\n+            @Override\n+            public Map<String, MxLibrary> jdklibraries() {\n+                return jdkLibraries;\n+            }\n+\n+            @Override\n+            public MxImports imports() {\n+                return imports;\n+            }\n+\n+            @Override\n+            public Map<String, MxProject> projects() {\n+                return projects;\n+            }\n+\n+            @Override\n+            public Map<String, MxDistribution> distributions() {\n+                return distributions;\n+            }\n+        };\n+    }\n+\n+    private static MxDistribution createMxDistribution(\n+        List<String> dependencies,\n+        List<String> distDependencies,\n+        List<String> exclude,\n+        List<String> strip\n+    ) {\n+        return new MxDistribution() {\n+            @Override\n+            public List<String> dependencies() {\n+                return dependencies;\n+            }\n+\n+            @Override\n+            public List<String> distDependencies() {\n+                return distDependencies;\n+            }\n+\n+            @Override\n+            public List<String> exclude() {\n+                return exclude;\n+            }\n+\n+            @Override\n+            public List<String> strip() {\n+                return strip;\n+            }\n+        };\n+    }\n+\n+    private static MxProject createMxProject(\n+        List<String> annotationProcessors,\n+        List<String> dependencies,\n+        String dir,\n+        String javaCompliance,\n+        List<String> sourceDirs,\n+        String subDir\n+    ) {\n+        return new MxProject() {\n+            @Override\n+            public String dir() {\n+                return dir;\n+            }\n+\n+            @Override\n+            public String subDir() {\n+                return subDir;\n+            }\n+\n+            @Override\n+            public List<String> sourceDirs() {\n+                return sourceDirs;\n+            }\n+\n+            @Override\n+            public List<String> dependencies() {\n+                return dependencies;\n+            }\n+\n+            @Override\n+            public List<String> annotationProcessors() {\n+                return annotationProcessors;\n+            }\n+\n+            @Override\n+            public String javaCompliance() {\n+                return javaCompliance;\n+            }\n+        };\n+    }\n+\n+    private static MxLibrary createMxLibrary(\n+        List<String> dependencies,\n+        Map<String, MxLibrary.Arch> osArch,\n+        String path,\n+        String sha1,\n+        List<String> urls\n+    ) {\n+        return new MxLibrary() {\n+            @Override\n+            public String sha1() {\n+                return sha1;\n+            }\n+\n+            @Override\n+            public List<String> urls() {\n+                return urls;\n+            }\n+\n+            @Override\n+            public Map<String, MxLibrary.Arch> os_arch() {\n+                return osArch;\n+            }\n+\n+            @Override\n+            public List<String> dependencies() {\n+                return dependencies;\n+            }\n+\n+            @Override\n+            public String path() {\n+                return path;\n+            }\n+\n+        };\n+    }\n+\n+    private static MxLibrary.Arch createArch(MxLibrary amd64) {\n+        return new MxLibrary.Arch() {\n+            @Override\n+            public MxLibrary amd64() {\n+                return amd64;\n+            }\n+        };\n+    }\n+\n+    static final MxSuite CORE_5_279_0;\n+    static {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "21a2744fdd0de199cff1cdca7143f5498c4a4bdc"}, "originalPosition": 221}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzAzNDk0OA==", "bodyText": "What is the specific use of this file? Is it better to have it hardcoded, or read the version from mx?", "url": "https://github.com/apache/netbeans/pull/2575#discussion_r537034948", "createdAt": "2020-12-06T13:04:38Z", "author": {"login": "jlahoda"}, "path": "java/java.mx.project/release/org.eclipse.jdt.core.prefs", "diffHunk": "@@ -0,0 +1,442 @@\n+# Licensed to the Apache Software Foundation (ASF) under one", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "21a2744fdd0de199cff1cdca7143f5498c4a4bdc"}, "originalPosition": 1}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ2OTMyNzAw", "url": "https://github.com/apache/netbeans/pull/2575#pullrequestreview-546932700", "createdAt": "2020-12-08T09:23:29Z", "commit": {"oid": "21a2744fdd0de199cff1cdca7143f5498c4a4bdc"}, "state": "COMMENTED", "comments": {"totalCount": 11, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOFQwOToyMzoyOVrOIBPYDg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOFQwOToyNDo0NFrOIBPb2Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODE3MTQwNg==", "bodyText": "This seems to assume mx is on the IDE process'  PATH. Shouldn't it be configurable in Tools | Options, similar to maven/ant, especially when NB does not distribute mx ? If reasonable, I recommend to track it as JIRA enhancement.", "url": "https://github.com/apache/netbeans/pull/2575#discussion_r538171406", "createdAt": "2020-12-08T09:23:29Z", "author": {"login": "sdedic"}, "path": "java/java.mx.project/src/org/netbeans/modules/java/mx/project/SuiteActionProvider.java", "diffHunk": "@@ -0,0 +1,245 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.netbeans.modules.java.mx.project;\n+\n+import java.awt.Toolkit;\n+import java.io.File;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.concurrent.Future;\n+import org.netbeans.api.actions.Openable;\n+import org.netbeans.api.debugger.*;\n+import org.netbeans.api.debugger.jpda.ListeningDICookie;\n+import org.netbeans.api.extexecution.ExecutionDescriptor;\n+import org.netbeans.api.extexecution.ExecutionService;\n+import org.netbeans.api.extexecution.base.ProcessBuilder;\n+import org.netbeans.api.extexecution.print.ConvertedLine;\n+import org.netbeans.spi.project.ActionProvider;\n+import org.netbeans.spi.project.SingleMethod;\n+import org.openide.LifecycleManager;\n+import org.openide.cookies.LineCookie;\n+import org.openide.filesystems.FileObject;\n+import org.openide.filesystems.FileUtil;\n+import org.openide.text.Line;\n+import org.openide.util.Lookup;\n+import org.openide.util.NbBundle;\n+import org.openide.util.RequestProcessor;\n+import org.openide.windows.OutputEvent;\n+import org.openide.windows.OutputListener;\n+\n+final class SuiteActionProvider implements ActionProvider {\n+    private final SuiteProject prj;\n+\n+    SuiteActionProvider(SuiteProject prj) {\n+        this.prj = prj;\n+    }\n+\n+    @Override\n+    public String[] getSupportedActions() {\n+        return new String[] {\n+            ActionProvider.COMMAND_CLEAN,\n+            ActionProvider.COMMAND_BUILD,\n+            ActionProvider.COMMAND_COMPILE_SINGLE,\n+            ActionProvider.COMMAND_REBUILD,\n+            ActionProvider.COMMAND_TEST_SINGLE,\n+            ActionProvider.COMMAND_RUN_SINGLE,\n+            ActionProvider.COMMAND_DEBUG_TEST_SINGLE,\n+            ActionProvider.COMMAND_DEBUG_SINGLE,\n+            SingleMethod.COMMAND_DEBUG_SINGLE_METHOD,\n+            SingleMethod.COMMAND_RUN_SINGLE_METHOD,\n+        };\n+    }\n+\n+    @NbBundle.Messages({\n+        \"MSG_Clean=mx clean {0}\",\n+        \"MSG_Build=mx build {0}\",\n+        \"MSG_BuildOnly=mx build {0} --only {1}\",\n+        \"MSG_Rebuild=mx rebuild {0}\",\n+        \"MSG_Unittest=mx unittest {0}\",\n+    })\n+    @Override\n+    public void invokeAction(String action, Lookup context) throws IllegalArgumentException {\n+        FileObject fo = context.lookup(FileObject.class);\n+        String testSuffix = \"\";\n+        switch (action) {\n+            case ActionProvider.COMMAND_CLEAN:\n+                runMx(Bundle.MSG_Clean(prj.getName()), \"clean\"); // NOI18N\n+                break;\n+            case ActionProvider.COMMAND_BUILD:\n+                runMx(Bundle.MSG_Build(prj.getName()), \"build\"); // NOI18N\n+                break;\n+            case ActionProvider.COMMAND_REBUILD:\n+                runMx(Bundle.MSG_Rebuild(prj.getName()), \"build\"); // NOI18N\n+                break;\n+            case ActionProvider.COMMAND_COMPILE_SINGLE: {\n+                SuiteSources.Group grp = prj.getSources().findGroup(fo);\n+                if (grp == null) {\n+                    Toolkit.getDefaultToolkit().beep();\n+                    return;\n+                }\n+                final String name = grp.getDisplayName();\n+                runMx(Bundle.MSG_BuildOnly(prj.getName(), name), \"build\", \"--only\", name); // NOI18N\n+                break;\n+            }\n+            case SingleMethod.COMMAND_RUN_SINGLE_METHOD: {\n+                SingleMethod m = context.lookup(SingleMethod.class);\n+                if (m != null && fo == null) {\n+                    fo = m.getFile();\n+                    testSuffix = \"#\" + m.getMethodName();\n+                }\n+                // fallthrough\n+            }\n+            case ActionProvider.COMMAND_TEST_SINGLE:\n+            case ActionProvider.COMMAND_RUN_SINGLE:\n+                if (fo == null) {\n+                    Toolkit.getDefaultToolkit().beep();\n+                    return;\n+                }\n+                runMx(Bundle.MSG_Unittest(fo.getName()), \"unittest\", fo.getName() + testSuffix); // NOI18N\n+                break;\n+            case SingleMethod.COMMAND_DEBUG_SINGLE_METHOD: {\n+                SingleMethod m = context.lookup(SingleMethod.class);\n+                if (m != null && fo == null) {\n+                    fo = m.getFile();\n+                    testSuffix = \"#\" + m.getMethodName();\n+                }\n+                // fallthrough\n+            }\n+            case ActionProvider.COMMAND_DEBUG_TEST_SINGLE:\n+            case ActionProvider.COMMAND_DEBUG_SINGLE:\n+                if (fo == null) {\n+                    Toolkit.getDefaultToolkit().beep();\n+                    return;\n+                }\n+                ListeningDICookie ldic = ListeningDICookie.create(-1);\n+                Object obj = ldic.getArgs().get(\"port\"); // NOI18N\n+                DebuggerInfo di = DebuggerInfo.create(ListeningDICookie.ID, ldic);\n+                DebuggerEngine[] engines = { null };\n+                RequestProcessor.getDefault().post(() -> {\n+                    DebuggerEngine[] engs = DebuggerManager.getDebuggerManager().startDebugging(di);\n+                    engines[0] = engs[0];\n+                });\n+                int port = ldic.getPortNumber();\n+                runMx(Bundle.MSG_Unittest(fo.getName()), \"--attach\", \"\" + port, \"unittest\", fo.getName() + testSuffix); // NOI18N\n+                break;\n+            default:\n+                throw new UnsupportedOperationException(action);\n+        }\n+    }\n+\n+    private boolean runMx(String taskName, String... args) {\n+        final File suiteDir = FileUtil.toFile(prj.getProjectDirectory());\n+        if (!suiteDir.isDirectory()) {\n+            Toolkit.getDefaultToolkit().beep();\n+            return true;\n+        }\n+        LifecycleManager.getDefault().saveAll();\n+        ExecutionDescriptor descriptor = new ExecutionDescriptor()\n+                .frontWindow(true).controllable(true)\n+                .errConvertorFactory(() -> {\n+                    return (String line) -> {\n+                        String[] segments = line.split(\":\");\n+                        if (segments.length > 2) {\n+                            File src = new File(segments[0]);\n+                            if (src.exists()) {\n+                                int lineNumber = parseLineNumber(segments) - 1;\n+                                return Collections.singletonList(ConvertedLine.forText(line, new OutputListener() {\n+                                    @Override\n+                                    public void outputLineSelected(OutputEvent ev) {\n+                                        openLine(Line.ShowOpenType.NONE, Line.ShowVisibilityType.FRONT);\n+                                    }\n+\n+                                    @Override\n+                                    public void outputLineAction(OutputEvent ev) {\n+                                        openLine(Line.ShowOpenType.OPEN, Line.ShowVisibilityType.FOCUS);\n+                                    }\n+\n+                                    private boolean openLine(final Line.ShowOpenType openType, final Line.ShowVisibilityType visibilityType) throws IndexOutOfBoundsException {\n+                                        FileObject fo = FileUtil.toFileObject(src);\n+                                        if (fo != null) {\n+                                            Lookup lkp = fo.getLookup();\n+                                            final LineCookie lines = lkp.lookup(LineCookie.class);\n+                                            if (lines != null) {\n+                                                Line open = lines.getLineSet().getOriginal(lineNumber);\n+                                                if (open != null) {\n+                                                    open.show(openType, visibilityType);\n+                                                    return true;\n+                                                }\n+                                            }\n+                                            Openable open = lkp.lookup(Openable.class);\n+                                            if (open != null) {\n+                                                open.open();\n+                                            } else {\n+                                                Toolkit.getDefaultToolkit().beep();\n+                                            }\n+                                        }\n+                                        return false;\n+                                    }\n+\n+                                    @Override\n+                                    public void outputLineCleared(OutputEvent ev) {\n+                                    }\n+                                }));\n+                            }\n+                        }\n+                        return null;\n+                    };\n+                });\n+        ProcessBuilder processBuilder = ProcessBuilder.getLocal();\n+        processBuilder.setWorkingDirectory(suiteDir.getPath());\n+        processBuilder.setExecutable(\"mx\"); // NOI18N", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "21a2744fdd0de199cff1cdca7143f5498c4a4bdc"}, "originalPosition": 206}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODE3MTUzMA==", "bodyText": "Maybe this exclusion is worth a comment in source; why the exclusion is needed.", "url": "https://github.com/apache/netbeans/pull/2575#discussion_r538171530", "createdAt": "2020-12-08T09:23:39Z", "author": {"login": "sdedic"}, "path": "java/java.mx.project/src/org/netbeans/modules/java/mx/project/SuiteClassPathProvider.java", "diffHunk": "@@ -0,0 +1,100 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.netbeans.modules.java.mx.project;\n+\n+import java.net.URL;\n+import java.util.ArrayList;\n+import java.util.List;\n+import org.netbeans.api.java.classpath.ClassPath;\n+import org.netbeans.api.java.classpath.GlobalPathRegistry;\n+import org.netbeans.api.java.classpath.JavaClassPathConstants;\n+import org.netbeans.api.java.platform.JavaPlatformManager;\n+import org.netbeans.api.java.queries.AnnotationProcessingQuery.Result;\n+import org.netbeans.spi.java.classpath.ClassPathProvider;\n+import org.netbeans.spi.java.classpath.support.ClassPathSupport;\n+import org.netbeans.spi.java.queries.AnnotationProcessingQueryImplementation;\n+import org.netbeans.spi.project.ui.ProjectOpenedHook;\n+import org.openide.filesystems.FileObject;\n+\n+final class SuiteClassPathProvider extends ProjectOpenedHook implements ClassPathProvider, AnnotationProcessingQueryImplementation {\n+    private final SuiteProject project;\n+    private final ClassPath bootCP;\n+\n+    public SuiteClassPathProvider(SuiteProject project) {\n+        this.project = project;\n+        List<ClassPath.Entry> entries = JavaPlatformManager.getDefault().getDefaultPlatform().getBootstrapLibraries().entries();\n+        List<URL> roots = new ArrayList<>();\n+        for (ClassPath.Entry entry : entries) {\n+            URL root = entry.getURL();\n+            if (root.getPath().contains(\"/graal-sdk.jar\")) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "21a2744fdd0de199cff1cdca7143f5498c4a4bdc"}, "originalPosition": 45}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODE3MTU3OQ==", "bodyText": "I am not sure about this fixed bootclasspath, as there may be different JAVA_HOME defined in ~/.mx/env or mx.{projectname}/env", "url": "https://github.com/apache/netbeans/pull/2575#discussion_r538171579", "createdAt": "2020-12-08T09:23:42Z", "author": {"login": "sdedic"}, "path": "java/java.mx.project/src/org/netbeans/modules/java/mx/project/SuiteClassPathProvider.java", "diffHunk": "@@ -0,0 +1,100 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.netbeans.modules.java.mx.project;\n+\n+import java.net.URL;\n+import java.util.ArrayList;\n+import java.util.List;\n+import org.netbeans.api.java.classpath.ClassPath;\n+import org.netbeans.api.java.classpath.GlobalPathRegistry;\n+import org.netbeans.api.java.classpath.JavaClassPathConstants;\n+import org.netbeans.api.java.platform.JavaPlatformManager;\n+import org.netbeans.api.java.queries.AnnotationProcessingQuery.Result;\n+import org.netbeans.spi.java.classpath.ClassPathProvider;\n+import org.netbeans.spi.java.classpath.support.ClassPathSupport;\n+import org.netbeans.spi.java.queries.AnnotationProcessingQueryImplementation;\n+import org.netbeans.spi.project.ui.ProjectOpenedHook;\n+import org.openide.filesystems.FileObject;\n+\n+final class SuiteClassPathProvider extends ProjectOpenedHook implements ClassPathProvider, AnnotationProcessingQueryImplementation {\n+    private final SuiteProject project;\n+    private final ClassPath bootCP;\n+\n+    public SuiteClassPathProvider(SuiteProject project) {\n+        this.project = project;\n+        List<ClassPath.Entry> entries = JavaPlatformManager.getDefault().getDefaultPlatform().getBootstrapLibraries().entries();\n+        List<URL> roots = new ArrayList<>();\n+        for (ClassPath.Entry entry : entries) {\n+            URL root = entry.getURL();\n+            if (root.getPath().contains(\"/graal-sdk.jar\")) {\n+                continue;\n+            }\n+            if (root.getPath().contains(\"/graaljs-scriptengine.jar\")) {\n+                continue;\n+            }\n+            if (root.getPath().contains(\"/graal-sdk.src.zip\")) {\n+                continue;\n+            }\n+            roots.add(entry.getURL());\n+        }\n+        this.bootCP = ClassPathSupport.createClassPath(roots.toArray(new URL[0]));\n+    }\n+\n+    @Override\n+    public ClassPath findClassPath(FileObject file, String type) {\n+        SuiteSources.Group g = project.getSources().findGroup(file);\n+        if (g == null) {\n+            return null;\n+        }\n+        if (ClassPath.BOOT.equals(type)) {\n+            return bootCP;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "21a2744fdd0de199cff1cdca7143f5498c4a4bdc"}, "originalPosition": 66}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODE3MTc5Mg==", "bodyText": "Silly question, but why just the 1st group ?", "url": "https://github.com/apache/netbeans/pull/2575#discussion_r538171792", "createdAt": "2020-12-08T09:23:59Z", "author": {"login": "sdedic"}, "path": "java/java.mx.project/src/org/netbeans/modules/java/mx/project/SuiteSources.java", "diffHunk": "@@ -0,0 +1,1195 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.netbeans.modules.java.mx.project;\n+\n+import java.beans.PropertyChangeListener;\n+import java.beans.PropertyChangeSupport;\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.IOException;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.EnumSet;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.LinkedHashMap;\n+import java.util.LinkedHashSet;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Properties;\n+import java.util.Set;\n+import java.util.TreeSet;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import javax.swing.Icon;\n+import javax.swing.event.ChangeListener;\n+import org.netbeans.modules.java.mx.project.suitepy.MxDistribution;\n+import org.netbeans.modules.java.mx.project.suitepy.MxImports;\n+import org.netbeans.modules.java.mx.project.suitepy.MxLibrary;\n+import org.netbeans.modules.java.mx.project.suitepy.MxProject;\n+import org.netbeans.modules.java.mx.project.suitepy.MxSuite;\n+import org.netbeans.api.java.classpath.ClassPath;\n+import org.netbeans.api.java.queries.AnnotationProcessingQuery;\n+import org.netbeans.api.java.queries.SourceForBinaryQuery;\n+import org.netbeans.api.project.Project;\n+import org.netbeans.api.project.ProjectManager;\n+import org.netbeans.api.project.SourceGroup;\n+import org.netbeans.api.project.Sources;\n+import org.netbeans.spi.java.classpath.ClassPathFactory;\n+import org.netbeans.spi.java.classpath.ClassPathImplementation;\n+import org.netbeans.spi.java.classpath.FlaggedClassPathImplementation;\n+import org.netbeans.spi.java.classpath.PathResourceImplementation;\n+import org.netbeans.spi.java.classpath.support.ClassPathSupport;\n+import org.netbeans.spi.java.queries.BinaryForSourceQueryImplementation2;\n+import org.netbeans.spi.java.queries.SourceForBinaryQueryImplementation2;\n+import org.openide.filesystems.FileObject;\n+import org.openide.filesystems.FileUtil;\n+import org.openide.filesystems.URLMapper;\n+import org.openide.util.Exceptions;\n+import org.openide.util.Utilities;\n+import java.util.stream.Collectors;\n+import org.netbeans.api.java.queries.SourceLevelQuery;\n+import org.netbeans.spi.java.queries.MultipleRootsUnitTestForSourceQueryImplementation;\n+import org.netbeans.spi.java.queries.SourceLevelQueryImplementation2;\n+import org.netbeans.spi.project.SubprojectProvider;\n+\n+final class SuiteSources implements Sources,\n+                BinaryForSourceQueryImplementation2<SuiteSources.Group>, SourceForBinaryQueryImplementation2,\n+                SourceLevelQueryImplementation2, SubprojectProvider, MultipleRootsUnitTestForSourceQueryImplementation {\n+    private static final Logger LOG = Logger.getLogger(SuiteSources.class.getName());\n+    private static final SuiteSources CORE;\n+\n+    static {\n+        MxSuite coreSuite = CoreSuite.CORE_5_279_0;\n+        CORE = new SuiteSources(null, null, coreSuite);\n+    }\n+\n+    private final MxSuite suite;\n+    private final List<Group> groups;\n+    private final List<Library> libraries;\n+    private final List<Dist> distributions;\n+    private final FileObject dir;\n+    /**\n+     * non-null if the dependencies haven't yet been properly initialized\n+     */\n+    private Map<String, Dep> transitiveDeps;\n+    /**\n+     * avoid GC of imported projects\n+     */\n+    private final SuiteProject prj;\n+    private final Map<String, SuiteSources> imported;\n+\n+    SuiteSources(SuiteProject owner, FileObject dir, MxSuite suite) {\n+        final Map<String, Dep> fillDeps = new HashMap<>();\n+        this.prj = owner;\n+        this.dir = dir;\n+        this.groups = findGroups(fillDeps, suite, dir);\n+        this.libraries = findLibraries(fillDeps, suite);\n+        this.imported = findImportedSuites(dir, suite, fillDeps);\n+        this.distributions = findDistributions(suite, this.libraries, this.groups, fillDeps);\n+        this.suite = suite;\n+        this.transitiveDeps = fillDeps;\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return \"MxSources[\" + (dir == null ? \"mx\" : dir.toURI()) + \"]\";\n+    }\n+\n+    private List<Group> findGroups(Map<String, Dep> fillDeps, MxSuite s, FileObject dir) {\n+        List<Group> arr = new ArrayList<>();\n+        for (Map.Entry<String, MxProject> entry : s.projects().entrySet()) {\n+            String name = entry.getKey();\n+            MxProject mxPrj = entry.getValue();\n+            FileObject prjDir = findPrjDir(dir, name, mxPrj);\n+            if (prjDir == null) {\n+                fillDeps.put(name, new Group(name, mxPrj, null, null, null, name, name));\n+                continue;\n+            }\n+            String prevName = null;\n+            Group firstGroup = null;\n+            String binPrefix;\n+            if (mxPrj.subDir() == null) {\n+                binPrefix = \"mxbuild/\";\n+            } else {\n+                binPrefix = \"mxbuild/\" + mxPrj.subDir() + \"/\";\n+            }\n+            for (String rel : mxPrj.sourceDirs()) {\n+                FileObject srcDir = prjDir.getFileObject(rel);\n+                FileObject binDir = getSubDir(dir, binPrefix + name + \"/bin\");\n+                FileObject srcGenDir = getSubDir(dir, binPrefix + name + \"/src_gen\");\n+                if (srcDir != null && binDir != null) {\n+                    String prgName = name + \"-\" + rel;\n+                    String displayName;\n+                    if (prevName == null) {\n+                        displayName = name;\n+                    } else {\n+                        displayName = name + \"[\" + rel + \"]\";\n+                    }\n+                    Group g = new Group(name, mxPrj, srcDir, srcGenDir, binDir, prgName, displayName);\n+                    arr.add(g);\n+                    if (firstGroup == null) {\n+                        firstGroup = g;\n+                    }\n+                    prevName = displayName;\n+                }\n+            }\n+            if (firstGroup != null) {\n+                fillDeps.put(name, firstGroup);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "21a2744fdd0de199cff1cdca7143f5498c4a4bdc"}, "originalPosition": 160}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODE3MTgzNw==", "bodyText": "Is the 2-level parent limit hardocded in mx as well ?", "url": "https://github.com/apache/netbeans/pull/2575#discussion_r538171837", "createdAt": "2020-12-08T09:24:03Z", "author": {"login": "sdedic"}, "path": "java/java.mx.project/src/org/netbeans/modules/java/mx/project/SuiteSources.java", "diffHunk": "@@ -0,0 +1,1195 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.netbeans.modules.java.mx.project;\n+\n+import java.beans.PropertyChangeListener;\n+import java.beans.PropertyChangeSupport;\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.IOException;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.EnumSet;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.LinkedHashMap;\n+import java.util.LinkedHashSet;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Properties;\n+import java.util.Set;\n+import java.util.TreeSet;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import javax.swing.Icon;\n+import javax.swing.event.ChangeListener;\n+import org.netbeans.modules.java.mx.project.suitepy.MxDistribution;\n+import org.netbeans.modules.java.mx.project.suitepy.MxImports;\n+import org.netbeans.modules.java.mx.project.suitepy.MxLibrary;\n+import org.netbeans.modules.java.mx.project.suitepy.MxProject;\n+import org.netbeans.modules.java.mx.project.suitepy.MxSuite;\n+import org.netbeans.api.java.classpath.ClassPath;\n+import org.netbeans.api.java.queries.AnnotationProcessingQuery;\n+import org.netbeans.api.java.queries.SourceForBinaryQuery;\n+import org.netbeans.api.project.Project;\n+import org.netbeans.api.project.ProjectManager;\n+import org.netbeans.api.project.SourceGroup;\n+import org.netbeans.api.project.Sources;\n+import org.netbeans.spi.java.classpath.ClassPathFactory;\n+import org.netbeans.spi.java.classpath.ClassPathImplementation;\n+import org.netbeans.spi.java.classpath.FlaggedClassPathImplementation;\n+import org.netbeans.spi.java.classpath.PathResourceImplementation;\n+import org.netbeans.spi.java.classpath.support.ClassPathSupport;\n+import org.netbeans.spi.java.queries.BinaryForSourceQueryImplementation2;\n+import org.netbeans.spi.java.queries.SourceForBinaryQueryImplementation2;\n+import org.openide.filesystems.FileObject;\n+import org.openide.filesystems.FileUtil;\n+import org.openide.filesystems.URLMapper;\n+import org.openide.util.Exceptions;\n+import org.openide.util.Utilities;\n+import java.util.stream.Collectors;\n+import org.netbeans.api.java.queries.SourceLevelQuery;\n+import org.netbeans.spi.java.queries.MultipleRootsUnitTestForSourceQueryImplementation;\n+import org.netbeans.spi.java.queries.SourceLevelQueryImplementation2;\n+import org.netbeans.spi.project.SubprojectProvider;\n+\n+final class SuiteSources implements Sources,\n+                BinaryForSourceQueryImplementation2<SuiteSources.Group>, SourceForBinaryQueryImplementation2,\n+                SourceLevelQueryImplementation2, SubprojectProvider, MultipleRootsUnitTestForSourceQueryImplementation {\n+    private static final Logger LOG = Logger.getLogger(SuiteSources.class.getName());\n+    private static final SuiteSources CORE;\n+\n+    static {\n+        MxSuite coreSuite = CoreSuite.CORE_5_279_0;\n+        CORE = new SuiteSources(null, null, coreSuite);\n+    }\n+\n+    private final MxSuite suite;\n+    private final List<Group> groups;\n+    private final List<Library> libraries;\n+    private final List<Dist> distributions;\n+    private final FileObject dir;\n+    /**\n+     * non-null if the dependencies haven't yet been properly initialized\n+     */\n+    private Map<String, Dep> transitiveDeps;\n+    /**\n+     * avoid GC of imported projects\n+     */\n+    private final SuiteProject prj;\n+    private final Map<String, SuiteSources> imported;\n+\n+    SuiteSources(SuiteProject owner, FileObject dir, MxSuite suite) {\n+        final Map<String, Dep> fillDeps = new HashMap<>();\n+        this.prj = owner;\n+        this.dir = dir;\n+        this.groups = findGroups(fillDeps, suite, dir);\n+        this.libraries = findLibraries(fillDeps, suite);\n+        this.imported = findImportedSuites(dir, suite, fillDeps);\n+        this.distributions = findDistributions(suite, this.libraries, this.groups, fillDeps);\n+        this.suite = suite;\n+        this.transitiveDeps = fillDeps;\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return \"MxSources[\" + (dir == null ? \"mx\" : dir.toURI()) + \"]\";\n+    }\n+\n+    private List<Group> findGroups(Map<String, Dep> fillDeps, MxSuite s, FileObject dir) {\n+        List<Group> arr = new ArrayList<>();\n+        for (Map.Entry<String, MxProject> entry : s.projects().entrySet()) {\n+            String name = entry.getKey();\n+            MxProject mxPrj = entry.getValue();\n+            FileObject prjDir = findPrjDir(dir, name, mxPrj);\n+            if (prjDir == null) {\n+                fillDeps.put(name, new Group(name, mxPrj, null, null, null, name, name));\n+                continue;\n+            }\n+            String prevName = null;\n+            Group firstGroup = null;\n+            String binPrefix;\n+            if (mxPrj.subDir() == null) {\n+                binPrefix = \"mxbuild/\";\n+            } else {\n+                binPrefix = \"mxbuild/\" + mxPrj.subDir() + \"/\";\n+            }\n+            for (String rel : mxPrj.sourceDirs()) {\n+                FileObject srcDir = prjDir.getFileObject(rel);\n+                FileObject binDir = getSubDir(dir, binPrefix + name + \"/bin\");\n+                FileObject srcGenDir = getSubDir(dir, binPrefix + name + \"/src_gen\");\n+                if (srcDir != null && binDir != null) {\n+                    String prgName = name + \"-\" + rel;\n+                    String displayName;\n+                    if (prevName == null) {\n+                        displayName = name;\n+                    } else {\n+                        displayName = name + \"[\" + rel + \"]\";\n+                    }\n+                    Group g = new Group(name, mxPrj, srcDir, srcGenDir, binDir, prgName, displayName);\n+                    arr.add(g);\n+                    if (firstGroup == null) {\n+                        firstGroup = g;\n+                    }\n+                    prevName = displayName;\n+                }\n+            }\n+            if (firstGroup != null) {\n+                fillDeps.put(name, firstGroup);\n+            }\n+        }\n+        return arr;\n+    }\n+\n+    private static FileObject getSubDir(FileObject dir, String relPath) {\n+        FileObject subDir = dir.getFileObject(relPath);\n+        if (subDir == null) {\n+            try {\n+                subDir = FileUtil.createFolder(dir, relPath);\n+            } catch (IOException ex) {\n+                Exceptions.printStackTrace(ex);\n+            }\n+        }\n+        return subDir;\n+    }\n+\n+    private List<Library> findLibraries(Map<String, Dep> fillDeps, MxSuite suite) {\n+        final Map<String, MxLibrary> allLibraries = new HashMap<>();\n+        registerLibs(allLibraries, null, suite.libraries());\n+\n+        List<Library> arr = new ArrayList<>();\n+        for (Map.Entry<String, MxLibrary> entry : allLibraries.entrySet()) {\n+            final Library library = new Library(entry.getKey(), entry.getValue());\n+            arr.add(library);\n+            fillDeps.put(library.getName(), library);\n+        }\n+        for (Map.Entry<String, MxLibrary> entry : suite.jdklibraries().entrySet()) {\n+            final JdkLibrary library = new JdkLibrary(entry.getKey(), entry.getValue());\n+            arr.add(library);\n+            fillDeps.put(library.getName(), library);\n+        }\n+        return arr;\n+    }\n+\n+    private static Map<String, SuiteSources> findImportedSuites(FileObject dir, MxSuite s, Map<String, Dep> fillDeps) {\n+        if (dir == null) {\n+            return Collections.emptyMap();\n+        }\n+        CORE.registerDeps(\"mx\", fillDeps);\n+        final MxImports imports = s.imports();\n+        if (imports != null) {\n+            Map<String, SuiteSources> imported = new LinkedHashMap<>();\n+            for (MxImports.Suite imp : imports.suites()) {\n+                SuiteSources impSources = findSuiteSources(dir, imp);\n+                final String suiteName = imp.name();\n+                if (impSources == null) {\n+                    LOG.log(Level.INFO, \"cannot find imported suite: {0}\", suiteName);\n+                    continue;\n+                }\n+                imported.put(suiteName, impSources);\n+                impSources.registerDeps(suiteName, fillDeps);\n+            }\n+            return imported;\n+        }\n+        return Collections.emptyMap();\n+    }\n+\n+    private List<Dist> findDistributions(MxSuite s, List<Library> libraries, List<Group> groups, Map<String, Dep> fillDeps) {\n+        List<Dist> dists = new ArrayList<>();\n+        for (Map.Entry<String, MxDistribution> entry : s.distributions().entrySet()) {\n+            Dist d = new Dist(entry.getKey(), entry.getValue());\n+            dists.add(d);\n+            fillDeps.put(d.getName(), d);\n+        }\n+        return dists;\n+    }\n+\n+    final synchronized void computeTransitiveDeps() {\n+        Map<String, Dep> collectedDeps = this.transitiveDeps;\n+        if (collectedDeps == null) {\n+            return;\n+        }\n+        this.transitiveDeps = null;\n+        for (Library l : this.libraries) {\n+            transitiveDeps(l, collectedDeps);\n+        }\n+        for (Group g : this.groups) {\n+            transitiveDeps(g, collectedDeps);\n+        }\n+        for (Dist d : this.distributions) {\n+            transitiveDeps(d, collectedDeps);\n+        }\n+        for (Group g : groups) {\n+            g.computeClassPath(collectedDeps);\n+        }\n+        for (Dist d : this.distributions) {\n+            d.computeSourceRoots(collectedDeps);\n+        }\n+    }\n+\n+    private static SuiteSources findSuiteSources(FileObject dir, MxImports.Suite imp) throws IllegalArgumentException {\n+        SuiteSources sources = findSuiteSources(dir.getParent(), imp.name());\n+        if (sources != null) {\n+            return sources;\n+        }\n+        if (imp.subdir()) {\n+            for (FileObject subDir : dir.getParent().getChildren()) {\n+                sources = findSuiteSources(subDir, imp.name());\n+                if (sources != null) {\n+                    return sources;\n+                }\n+            }\n+            for (FileObject subDir : dir.getParent().getParent().getChildren()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "21a2744fdd0de199cff1cdca7143f5498c4a4bdc"}, "originalPosition": 264}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODE3MTk0Ng==", "bodyText": "no unit tests reported ?", "url": "https://github.com/apache/netbeans/pull/2575#discussion_r538171946", "createdAt": "2020-12-08T09:24:12Z", "author": {"login": "sdedic"}, "path": "java/java.mx.project/src/org/netbeans/modules/java/mx/project/SuiteSources.java", "diffHunk": "@@ -0,0 +1,1195 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.netbeans.modules.java.mx.project;\n+\n+import java.beans.PropertyChangeListener;\n+import java.beans.PropertyChangeSupport;\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.IOException;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.EnumSet;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.LinkedHashMap;\n+import java.util.LinkedHashSet;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Properties;\n+import java.util.Set;\n+import java.util.TreeSet;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import javax.swing.Icon;\n+import javax.swing.event.ChangeListener;\n+import org.netbeans.modules.java.mx.project.suitepy.MxDistribution;\n+import org.netbeans.modules.java.mx.project.suitepy.MxImports;\n+import org.netbeans.modules.java.mx.project.suitepy.MxLibrary;\n+import org.netbeans.modules.java.mx.project.suitepy.MxProject;\n+import org.netbeans.modules.java.mx.project.suitepy.MxSuite;\n+import org.netbeans.api.java.classpath.ClassPath;\n+import org.netbeans.api.java.queries.AnnotationProcessingQuery;\n+import org.netbeans.api.java.queries.SourceForBinaryQuery;\n+import org.netbeans.api.project.Project;\n+import org.netbeans.api.project.ProjectManager;\n+import org.netbeans.api.project.SourceGroup;\n+import org.netbeans.api.project.Sources;\n+import org.netbeans.spi.java.classpath.ClassPathFactory;\n+import org.netbeans.spi.java.classpath.ClassPathImplementation;\n+import org.netbeans.spi.java.classpath.FlaggedClassPathImplementation;\n+import org.netbeans.spi.java.classpath.PathResourceImplementation;\n+import org.netbeans.spi.java.classpath.support.ClassPathSupport;\n+import org.netbeans.spi.java.queries.BinaryForSourceQueryImplementation2;\n+import org.netbeans.spi.java.queries.SourceForBinaryQueryImplementation2;\n+import org.openide.filesystems.FileObject;\n+import org.openide.filesystems.FileUtil;\n+import org.openide.filesystems.URLMapper;\n+import org.openide.util.Exceptions;\n+import org.openide.util.Utilities;\n+import java.util.stream.Collectors;\n+import org.netbeans.api.java.queries.SourceLevelQuery;\n+import org.netbeans.spi.java.queries.MultipleRootsUnitTestForSourceQueryImplementation;\n+import org.netbeans.spi.java.queries.SourceLevelQueryImplementation2;\n+import org.netbeans.spi.project.SubprojectProvider;\n+\n+final class SuiteSources implements Sources,\n+                BinaryForSourceQueryImplementation2<SuiteSources.Group>, SourceForBinaryQueryImplementation2,\n+                SourceLevelQueryImplementation2, SubprojectProvider, MultipleRootsUnitTestForSourceQueryImplementation {\n+    private static final Logger LOG = Logger.getLogger(SuiteSources.class.getName());\n+    private static final SuiteSources CORE;\n+\n+    static {\n+        MxSuite coreSuite = CoreSuite.CORE_5_279_0;\n+        CORE = new SuiteSources(null, null, coreSuite);\n+    }\n+\n+    private final MxSuite suite;\n+    private final List<Group> groups;\n+    private final List<Library> libraries;\n+    private final List<Dist> distributions;\n+    private final FileObject dir;\n+    /**\n+     * non-null if the dependencies haven't yet been properly initialized\n+     */\n+    private Map<String, Dep> transitiveDeps;\n+    /**\n+     * avoid GC of imported projects\n+     */\n+    private final SuiteProject prj;\n+    private final Map<String, SuiteSources> imported;\n+\n+    SuiteSources(SuiteProject owner, FileObject dir, MxSuite suite) {\n+        final Map<String, Dep> fillDeps = new HashMap<>();\n+        this.prj = owner;\n+        this.dir = dir;\n+        this.groups = findGroups(fillDeps, suite, dir);\n+        this.libraries = findLibraries(fillDeps, suite);\n+        this.imported = findImportedSuites(dir, suite, fillDeps);\n+        this.distributions = findDistributions(suite, this.libraries, this.groups, fillDeps);\n+        this.suite = suite;\n+        this.transitiveDeps = fillDeps;\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return \"MxSources[\" + (dir == null ? \"mx\" : dir.toURI()) + \"]\";\n+    }\n+\n+    private List<Group> findGroups(Map<String, Dep> fillDeps, MxSuite s, FileObject dir) {\n+        List<Group> arr = new ArrayList<>();\n+        for (Map.Entry<String, MxProject> entry : s.projects().entrySet()) {\n+            String name = entry.getKey();\n+            MxProject mxPrj = entry.getValue();\n+            FileObject prjDir = findPrjDir(dir, name, mxPrj);\n+            if (prjDir == null) {\n+                fillDeps.put(name, new Group(name, mxPrj, null, null, null, name, name));\n+                continue;\n+            }\n+            String prevName = null;\n+            Group firstGroup = null;\n+            String binPrefix;\n+            if (mxPrj.subDir() == null) {\n+                binPrefix = \"mxbuild/\";\n+            } else {\n+                binPrefix = \"mxbuild/\" + mxPrj.subDir() + \"/\";\n+            }\n+            for (String rel : mxPrj.sourceDirs()) {\n+                FileObject srcDir = prjDir.getFileObject(rel);\n+                FileObject binDir = getSubDir(dir, binPrefix + name + \"/bin\");\n+                FileObject srcGenDir = getSubDir(dir, binPrefix + name + \"/src_gen\");\n+                if (srcDir != null && binDir != null) {\n+                    String prgName = name + \"-\" + rel;\n+                    String displayName;\n+                    if (prevName == null) {\n+                        displayName = name;\n+                    } else {\n+                        displayName = name + \"[\" + rel + \"]\";\n+                    }\n+                    Group g = new Group(name, mxPrj, srcDir, srcGenDir, binDir, prgName, displayName);\n+                    arr.add(g);\n+                    if (firstGroup == null) {\n+                        firstGroup = g;\n+                    }\n+                    prevName = displayName;\n+                }\n+            }\n+            if (firstGroup != null) {\n+                fillDeps.put(name, firstGroup);\n+            }\n+        }\n+        return arr;\n+    }\n+\n+    private static FileObject getSubDir(FileObject dir, String relPath) {\n+        FileObject subDir = dir.getFileObject(relPath);\n+        if (subDir == null) {\n+            try {\n+                subDir = FileUtil.createFolder(dir, relPath);\n+            } catch (IOException ex) {\n+                Exceptions.printStackTrace(ex);\n+            }\n+        }\n+        return subDir;\n+    }\n+\n+    private List<Library> findLibraries(Map<String, Dep> fillDeps, MxSuite suite) {\n+        final Map<String, MxLibrary> allLibraries = new HashMap<>();\n+        registerLibs(allLibraries, null, suite.libraries());\n+\n+        List<Library> arr = new ArrayList<>();\n+        for (Map.Entry<String, MxLibrary> entry : allLibraries.entrySet()) {\n+            final Library library = new Library(entry.getKey(), entry.getValue());\n+            arr.add(library);\n+            fillDeps.put(library.getName(), library);\n+        }\n+        for (Map.Entry<String, MxLibrary> entry : suite.jdklibraries().entrySet()) {\n+            final JdkLibrary library = new JdkLibrary(entry.getKey(), entry.getValue());\n+            arr.add(library);\n+            fillDeps.put(library.getName(), library);\n+        }\n+        return arr;\n+    }\n+\n+    private static Map<String, SuiteSources> findImportedSuites(FileObject dir, MxSuite s, Map<String, Dep> fillDeps) {\n+        if (dir == null) {\n+            return Collections.emptyMap();\n+        }\n+        CORE.registerDeps(\"mx\", fillDeps);\n+        final MxImports imports = s.imports();\n+        if (imports != null) {\n+            Map<String, SuiteSources> imported = new LinkedHashMap<>();\n+            for (MxImports.Suite imp : imports.suites()) {\n+                SuiteSources impSources = findSuiteSources(dir, imp);\n+                final String suiteName = imp.name();\n+                if (impSources == null) {\n+                    LOG.log(Level.INFO, \"cannot find imported suite: {0}\", suiteName);\n+                    continue;\n+                }\n+                imported.put(suiteName, impSources);\n+                impSources.registerDeps(suiteName, fillDeps);\n+            }\n+            return imported;\n+        }\n+        return Collections.emptyMap();\n+    }\n+\n+    private List<Dist> findDistributions(MxSuite s, List<Library> libraries, List<Group> groups, Map<String, Dep> fillDeps) {\n+        List<Dist> dists = new ArrayList<>();\n+        for (Map.Entry<String, MxDistribution> entry : s.distributions().entrySet()) {\n+            Dist d = new Dist(entry.getKey(), entry.getValue());\n+            dists.add(d);\n+            fillDeps.put(d.getName(), d);\n+        }\n+        return dists;\n+    }\n+\n+    final synchronized void computeTransitiveDeps() {\n+        Map<String, Dep> collectedDeps = this.transitiveDeps;\n+        if (collectedDeps == null) {\n+            return;\n+        }\n+        this.transitiveDeps = null;\n+        for (Library l : this.libraries) {\n+            transitiveDeps(l, collectedDeps);\n+        }\n+        for (Group g : this.groups) {\n+            transitiveDeps(g, collectedDeps);\n+        }\n+        for (Dist d : this.distributions) {\n+            transitiveDeps(d, collectedDeps);\n+        }\n+        for (Group g : groups) {\n+            g.computeClassPath(collectedDeps);\n+        }\n+        for (Dist d : this.distributions) {\n+            d.computeSourceRoots(collectedDeps);\n+        }\n+    }\n+\n+    private static SuiteSources findSuiteSources(FileObject dir, MxImports.Suite imp) throws IllegalArgumentException {\n+        SuiteSources sources = findSuiteSources(dir.getParent(), imp.name());\n+        if (sources != null) {\n+            return sources;\n+        }\n+        if (imp.subdir()) {\n+            for (FileObject subDir : dir.getParent().getChildren()) {\n+                sources = findSuiteSources(subDir, imp.name());\n+                if (sources != null) {\n+                    return sources;\n+                }\n+            }\n+            for (FileObject subDir : dir.getParent().getParent().getChildren()) {\n+                sources = findSuiteSources(subDir, imp.name());\n+                if (sources != null) {\n+                    return sources;\n+                }\n+            }\n+        }\n+        return null;\n+    }\n+\n+    private static SuiteSources findSuiteSources(FileObject root, String name) throws IllegalArgumentException {\n+        FileObject impDir = root.getFileObject(name);\n+        if (impDir != null) {\n+            try {\n+                Project impPrj = ProjectManager.getDefault().findProject(impDir);\n+                return impPrj == null ? null : impPrj.getLookup().lookup(SuiteSources.class);\n+            } catch (IOException ex) {\n+                Exceptions.printStackTrace(ex);\n+            }\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    public SourceGroup[] getSourceGroups(String string) {\n+        return groups();\n+    }\n+\n+    Group[] groups() {\n+        return groups.toArray(new Group[0]);\n+    }\n+\n+    Group findGroup(FileObject fo) {\n+        for (Group g : groups) {\n+            if (g.contains(fo)) {\n+                return g;\n+            }\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    public void addChangeListener(ChangeListener cl) {\n+    }\n+\n+    @Override\n+    public void removeChangeListener(ChangeListener cl) {\n+    }\n+\n+    private static FileObject findPrjDir(FileObject dir, String prjName, MxProject prj) {\n+        if (dir == null) {\n+            return null;\n+        }\n+        if (prj.dir() != null) {\n+            return dir.getFileObject(prj.dir());\n+        }\n+        if (prj.subDir() != null) {\n+            dir = dir.getFileObject(prj.subDir());\n+            if (dir == null) {\n+                return null;\n+            }\n+        }\n+        return dir.getFileObject(prjName);\n+    }\n+\n+    private Collection<Dep> transitiveDeps(Dep current, Map<String, Dep> fill) {\n+        current.owner().computeTransitiveDeps();\n+        final Collection<Dep> currentAllDeps = current.allDeps();\n+        if (currentAllDeps == Collections.<Dep>emptySet()) {\n+            throw new IllegalStateException(\"Cyclic dep on \" + current.getName());\n+        } else if (currentAllDeps != null) {\n+            return currentAllDeps;\n+        }\n+        current.setAllDeps(Collections.emptySet());\n+        TreeSet<Dep> computing = new TreeSet<>();\n+        computing.add(current);\n+        for (String depName : current.depNames()) {\n+            Dep dep = fill.get(depName);\n+            if (dep == null) {\n+                int colon = depName.lastIndexOf(':');\n+                dep = fill.get(depName.substring(colon + 1));\n+                if (dep == null) {\n+                    LOG.log(Level.INFO, \"dep not found: {0}\", depName);\n+                    continue;\n+                }\n+            }\n+            Collection<Dep> allDeps = transitiveDeps(dep, fill);\n+            computing.addAll(allDeps);\n+        }\n+        current.setAllDeps(computing);\n+        return computing;\n+    }\n+\n+    private static void registerLibs(Map<String, MxLibrary> collect, String prefix, Map<String, MxLibrary> libraries) {\n+        for (Map.Entry<String, MxLibrary> entry : libraries.entrySet()) {\n+            String key = entry.getKey();\n+            MxLibrary lib = entry.getValue();\n+            if (prefix == null) {\n+                collect.put(key, lib);\n+            } else {\n+                collect.put(prefix + \":\" + key, lib);\n+            }\n+        }\n+    }\n+\n+    private void registerDeps(String prefix, Map<String, Dep> fillDeps) {\n+        for (Library library : libraries) {\n+            fillDeps.put(prefix + \":\" + library.getName(), library);\n+        }\n+        for (Dist d : distributions) {\n+            fillDeps.put(prefix + \":\" + d.getName(), d);\n+        }\n+        for (Map.Entry<String, SuiteSources> s : imported.entrySet()) {\n+            s.getValue().registerDeps(s.getKey(), fillDeps);\n+        }\n+    }\n+\n+    @Override\n+    public Group findBinaryRoots2(URL url) {\n+        final FileObject srcFo = URLMapper.findFileObject(url);\n+        for (Group group : this.groups) {\n+            if (group.contains(srcFo)) {\n+                return group;\n+            }\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    public URL[] computeRoots(Group group) {\n+        if (group.binDir != null) {\n+            return new URL[] { group.binDir.toURL() };\n+        } else {\n+            return new URL[0];\n+        }\n+    }\n+\n+    @Override\n+    public boolean computePreferBinaries(Group result) {\n+        return true;\n+    }\n+\n+    @Override\n+    public void computeChangeListener(Group result, boolean bln, ChangeListener cl) {\n+    }\n+\n+    @Override\n+    public SourceForBinaryQueryImplementation2.Result findSourceRoots2(URL url) {\n+        this.computeTransitiveDeps();\n+        for (Dist dist : this.distributions) {\n+            URL jar;\n+            try {\n+                jar = dist.getJarRoot();\n+                if (jar == null) {\n+                    continue;\n+                }\n+            } catch (MalformedURLException ok) {\n+                continue;\n+            }\n+            if (jar.equals(url)) {\n+                List<FileObject> roots = new ArrayList<>();\n+                for (Group d : dist.getContributingGroups()) {\n+                    roots.add(d.srcDir);\n+                    roots.add(d.srcGenDir);\n+                }\n+                return new ImmutableResult(roots.toArray(new FileObject[roots.size()]));\n+            }\n+        }\n+        for (Group group : this.groups) {\n+            if (group.binDir != null && group.binDir.toURL().equals(url)) {\n+                return new ImmutableResult(group.srcDir, group.srcGenDir);\n+            }\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    public SourceForBinaryQuery.Result findSourceRoots(URL url) {\n+        return findSourceRoots2(url);\n+    }\n+\n+    final Iterable<File> jdks() {\n+        Set<File> jdks = new LinkedHashSet<>();\n+        String home = System.getProperty(\"user.home\");\n+        if (home != null) {\n+            File userEnv = new File(new File(new File(home), \".mx\"), \"env\");\n+            findJdksInEnv(jdks, userEnv);\n+        }\n+        FileObject suiteEnv = dir.getFileObject(\"mx.\" + dir.getNameExt() + \"/env\");\n+        if (suiteEnv != null) {\n+            findJdksInEnv(jdks, FileUtil.toFile(suiteEnv));\n+        }\n+\n+        String javaHomeEnv = System.getenv(\"JAVA_HOME\");\n+        if (javaHomeEnv != null) {\n+            jdks.add(new File(javaHomeEnv));\n+        }\n+        String javaHomeProp = System.getProperty(\"java.home\");\n+        if (javaHomeProp != null) {\n+            jdks.add(new File(javaHomeProp));\n+        }\n+        return jdks;\n+    }\n+\n+    private void findJdksInEnv(Set<File> jdks, File env) {\n+        if (env == null || !env.isFile()) {\n+            return;\n+        }\n+        try (final FileInputStream is = new FileInputStream(env)) {\n+            Properties p = new Properties();\n+            p.load(is);\n+\n+            String javaHome = p.getProperty(\"JAVA_HOME\");\n+            if (javaHome != null) {\n+                jdks.add(new File(javaHome));\n+            }\n+\n+            String extraJavaHomes = p.getProperty(\"EXTRA_JAVA_HOMES\");\n+            if (extraJavaHomes != null) {\n+                for (String extraHome : extraJavaHomes.split(File.pathSeparator)) {\n+                    jdks.add(new File(extraHome));\n+                }\n+            }\n+        } catch (IOException ex) {\n+            Exceptions.printStackTrace(ex);\n+        }\n+    }\n+\n+    @Override\n+    public SourceLevelQueryImplementation2.Result getSourceLevel(FileObject fo) {\n+        Group g = findGroup(fo);\n+        if (g == null) {\n+            return null;\n+        }\n+        return new SourceLevelQueryImplementation2.Result2() {\n+            @Override\n+            public SourceLevelQuery.Profile getProfile() {\n+                return SourceLevelQuery.Profile.DEFAULT;\n+            }\n+\n+            @Override\n+            public String getSourceLevel() {\n+                return g.getCompliance().getSourceLevel();\n+            }\n+\n+            @Override\n+            public void addChangeListener(ChangeListener cl) {\n+            }\n+\n+            @Override\n+            public void removeChangeListener(ChangeListener cl) {\n+            }\n+        };\n+    }\n+\n+    @Override\n+    public Set<? extends Project> getSubprojects() {\n+        Set<Project> prjs = new HashSet<>();\n+        for (SuiteSources imp : imported.values()) {\n+            prjs.add(imp.prj);\n+        }\n+        return prjs;\n+    }\n+\n+    @Override\n+    public URL[] findUnitTests(FileObject fo) {\n+        return new URL[0];", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "21a2744fdd0de199cff1cdca7143f5498c4a4bdc"}, "originalPosition": 530}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODE3MjA4Nw==", "bodyText": "Maybe an useless parameter", "url": "https://github.com/apache/netbeans/pull/2575#discussion_r538172087", "createdAt": "2020-12-08T09:24:22Z", "author": {"login": "sdedic"}, "path": "java/java.mx.project/src/org/netbeans/modules/java/mx/project/SuiteSources.java", "diffHunk": "@@ -0,0 +1,1195 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.netbeans.modules.java.mx.project;\n+\n+import java.beans.PropertyChangeListener;\n+import java.beans.PropertyChangeSupport;\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.IOException;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.EnumSet;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.LinkedHashMap;\n+import java.util.LinkedHashSet;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Properties;\n+import java.util.Set;\n+import java.util.TreeSet;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import javax.swing.Icon;\n+import javax.swing.event.ChangeListener;\n+import org.netbeans.modules.java.mx.project.suitepy.MxDistribution;\n+import org.netbeans.modules.java.mx.project.suitepy.MxImports;\n+import org.netbeans.modules.java.mx.project.suitepy.MxLibrary;\n+import org.netbeans.modules.java.mx.project.suitepy.MxProject;\n+import org.netbeans.modules.java.mx.project.suitepy.MxSuite;\n+import org.netbeans.api.java.classpath.ClassPath;\n+import org.netbeans.api.java.queries.AnnotationProcessingQuery;\n+import org.netbeans.api.java.queries.SourceForBinaryQuery;\n+import org.netbeans.api.project.Project;\n+import org.netbeans.api.project.ProjectManager;\n+import org.netbeans.api.project.SourceGroup;\n+import org.netbeans.api.project.Sources;\n+import org.netbeans.spi.java.classpath.ClassPathFactory;\n+import org.netbeans.spi.java.classpath.ClassPathImplementation;\n+import org.netbeans.spi.java.classpath.FlaggedClassPathImplementation;\n+import org.netbeans.spi.java.classpath.PathResourceImplementation;\n+import org.netbeans.spi.java.classpath.support.ClassPathSupport;\n+import org.netbeans.spi.java.queries.BinaryForSourceQueryImplementation2;\n+import org.netbeans.spi.java.queries.SourceForBinaryQueryImplementation2;\n+import org.openide.filesystems.FileObject;\n+import org.openide.filesystems.FileUtil;\n+import org.openide.filesystems.URLMapper;\n+import org.openide.util.Exceptions;\n+import org.openide.util.Utilities;\n+import java.util.stream.Collectors;\n+import org.netbeans.api.java.queries.SourceLevelQuery;\n+import org.netbeans.spi.java.queries.MultipleRootsUnitTestForSourceQueryImplementation;\n+import org.netbeans.spi.java.queries.SourceLevelQueryImplementation2;\n+import org.netbeans.spi.project.SubprojectProvider;\n+\n+final class SuiteSources implements Sources,\n+                BinaryForSourceQueryImplementation2<SuiteSources.Group>, SourceForBinaryQueryImplementation2,\n+                SourceLevelQueryImplementation2, SubprojectProvider, MultipleRootsUnitTestForSourceQueryImplementation {\n+    private static final Logger LOG = Logger.getLogger(SuiteSources.class.getName());\n+    private static final SuiteSources CORE;\n+\n+    static {\n+        MxSuite coreSuite = CoreSuite.CORE_5_279_0;\n+        CORE = new SuiteSources(null, null, coreSuite);\n+    }\n+\n+    private final MxSuite suite;\n+    private final List<Group> groups;\n+    private final List<Library> libraries;\n+    private final List<Dist> distributions;\n+    private final FileObject dir;\n+    /**\n+     * non-null if the dependencies haven't yet been properly initialized\n+     */\n+    private Map<String, Dep> transitiveDeps;\n+    /**\n+     * avoid GC of imported projects\n+     */\n+    private final SuiteProject prj;\n+    private final Map<String, SuiteSources> imported;\n+\n+    SuiteSources(SuiteProject owner, FileObject dir, MxSuite suite) {\n+        final Map<String, Dep> fillDeps = new HashMap<>();\n+        this.prj = owner;\n+        this.dir = dir;\n+        this.groups = findGroups(fillDeps, suite, dir);\n+        this.libraries = findLibraries(fillDeps, suite);\n+        this.imported = findImportedSuites(dir, suite, fillDeps);\n+        this.distributions = findDistributions(suite, this.libraries, this.groups, fillDeps);\n+        this.suite = suite;\n+        this.transitiveDeps = fillDeps;\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return \"MxSources[\" + (dir == null ? \"mx\" : dir.toURI()) + \"]\";\n+    }\n+\n+    private List<Group> findGroups(Map<String, Dep> fillDeps, MxSuite s, FileObject dir) {\n+        List<Group> arr = new ArrayList<>();\n+        for (Map.Entry<String, MxProject> entry : s.projects().entrySet()) {\n+            String name = entry.getKey();\n+            MxProject mxPrj = entry.getValue();\n+            FileObject prjDir = findPrjDir(dir, name, mxPrj);\n+            if (prjDir == null) {\n+                fillDeps.put(name, new Group(name, mxPrj, null, null, null, name, name));\n+                continue;\n+            }\n+            String prevName = null;\n+            Group firstGroup = null;\n+            String binPrefix;\n+            if (mxPrj.subDir() == null) {\n+                binPrefix = \"mxbuild/\";\n+            } else {\n+                binPrefix = \"mxbuild/\" + mxPrj.subDir() + \"/\";\n+            }\n+            for (String rel : mxPrj.sourceDirs()) {\n+                FileObject srcDir = prjDir.getFileObject(rel);\n+                FileObject binDir = getSubDir(dir, binPrefix + name + \"/bin\");\n+                FileObject srcGenDir = getSubDir(dir, binPrefix + name + \"/src_gen\");\n+                if (srcDir != null && binDir != null) {\n+                    String prgName = name + \"-\" + rel;\n+                    String displayName;\n+                    if (prevName == null) {\n+                        displayName = name;\n+                    } else {\n+                        displayName = name + \"[\" + rel + \"]\";\n+                    }\n+                    Group g = new Group(name, mxPrj, srcDir, srcGenDir, binDir, prgName, displayName);\n+                    arr.add(g);\n+                    if (firstGroup == null) {\n+                        firstGroup = g;\n+                    }\n+                    prevName = displayName;\n+                }\n+            }\n+            if (firstGroup != null) {\n+                fillDeps.put(name, firstGroup);\n+            }\n+        }\n+        return arr;\n+    }\n+\n+    private static FileObject getSubDir(FileObject dir, String relPath) {\n+        FileObject subDir = dir.getFileObject(relPath);\n+        if (subDir == null) {\n+            try {\n+                subDir = FileUtil.createFolder(dir, relPath);\n+            } catch (IOException ex) {\n+                Exceptions.printStackTrace(ex);\n+            }\n+        }\n+        return subDir;\n+    }\n+\n+    private List<Library> findLibraries(Map<String, Dep> fillDeps, MxSuite suite) {\n+        final Map<String, MxLibrary> allLibraries = new HashMap<>();\n+        registerLibs(allLibraries, null, suite.libraries());\n+\n+        List<Library> arr = new ArrayList<>();\n+        for (Map.Entry<String, MxLibrary> entry : allLibraries.entrySet()) {\n+            final Library library = new Library(entry.getKey(), entry.getValue());\n+            arr.add(library);\n+            fillDeps.put(library.getName(), library);\n+        }\n+        for (Map.Entry<String, MxLibrary> entry : suite.jdklibraries().entrySet()) {\n+            final JdkLibrary library = new JdkLibrary(entry.getKey(), entry.getValue());\n+            arr.add(library);\n+            fillDeps.put(library.getName(), library);\n+        }\n+        return arr;\n+    }\n+\n+    private static Map<String, SuiteSources> findImportedSuites(FileObject dir, MxSuite s, Map<String, Dep> fillDeps) {\n+        if (dir == null) {\n+            return Collections.emptyMap();\n+        }\n+        CORE.registerDeps(\"mx\", fillDeps);\n+        final MxImports imports = s.imports();\n+        if (imports != null) {\n+            Map<String, SuiteSources> imported = new LinkedHashMap<>();\n+            for (MxImports.Suite imp : imports.suites()) {\n+                SuiteSources impSources = findSuiteSources(dir, imp);\n+                final String suiteName = imp.name();\n+                if (impSources == null) {\n+                    LOG.log(Level.INFO, \"cannot find imported suite: {0}\", suiteName);\n+                    continue;\n+                }\n+                imported.put(suiteName, impSources);\n+                impSources.registerDeps(suiteName, fillDeps);\n+            }\n+            return imported;\n+        }\n+        return Collections.emptyMap();\n+    }\n+\n+    private List<Dist> findDistributions(MxSuite s, List<Library> libraries, List<Group> groups, Map<String, Dep> fillDeps) {\n+        List<Dist> dists = new ArrayList<>();\n+        for (Map.Entry<String, MxDistribution> entry : s.distributions().entrySet()) {\n+            Dist d = new Dist(entry.getKey(), entry.getValue());\n+            dists.add(d);\n+            fillDeps.put(d.getName(), d);\n+        }\n+        return dists;\n+    }\n+\n+    final synchronized void computeTransitiveDeps() {\n+        Map<String, Dep> collectedDeps = this.transitiveDeps;\n+        if (collectedDeps == null) {\n+            return;\n+        }\n+        this.transitiveDeps = null;\n+        for (Library l : this.libraries) {\n+            transitiveDeps(l, collectedDeps);\n+        }\n+        for (Group g : this.groups) {\n+            transitiveDeps(g, collectedDeps);\n+        }\n+        for (Dist d : this.distributions) {\n+            transitiveDeps(d, collectedDeps);\n+        }\n+        for (Group g : groups) {\n+            g.computeClassPath(collectedDeps);\n+        }\n+        for (Dist d : this.distributions) {\n+            d.computeSourceRoots(collectedDeps);\n+        }\n+    }\n+\n+    private static SuiteSources findSuiteSources(FileObject dir, MxImports.Suite imp) throws IllegalArgumentException {\n+        SuiteSources sources = findSuiteSources(dir.getParent(), imp.name());\n+        if (sources != null) {\n+            return sources;\n+        }\n+        if (imp.subdir()) {\n+            for (FileObject subDir : dir.getParent().getChildren()) {\n+                sources = findSuiteSources(subDir, imp.name());\n+                if (sources != null) {\n+                    return sources;\n+                }\n+            }\n+            for (FileObject subDir : dir.getParent().getParent().getChildren()) {\n+                sources = findSuiteSources(subDir, imp.name());\n+                if (sources != null) {\n+                    return sources;\n+                }\n+            }\n+        }\n+        return null;\n+    }\n+\n+    private static SuiteSources findSuiteSources(FileObject root, String name) throws IllegalArgumentException {\n+        FileObject impDir = root.getFileObject(name);\n+        if (impDir != null) {\n+            try {\n+                Project impPrj = ProjectManager.getDefault().findProject(impDir);\n+                return impPrj == null ? null : impPrj.getLookup().lookup(SuiteSources.class);\n+            } catch (IOException ex) {\n+                Exceptions.printStackTrace(ex);\n+            }\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    public SourceGroup[] getSourceGroups(String string) {\n+        return groups();\n+    }\n+\n+    Group[] groups() {\n+        return groups.toArray(new Group[0]);\n+    }\n+\n+    Group findGroup(FileObject fo) {\n+        for (Group g : groups) {\n+            if (g.contains(fo)) {\n+                return g;\n+            }\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    public void addChangeListener(ChangeListener cl) {\n+    }\n+\n+    @Override\n+    public void removeChangeListener(ChangeListener cl) {\n+    }\n+\n+    private static FileObject findPrjDir(FileObject dir, String prjName, MxProject prj) {\n+        if (dir == null) {\n+            return null;\n+        }\n+        if (prj.dir() != null) {\n+            return dir.getFileObject(prj.dir());\n+        }\n+        if (prj.subDir() != null) {\n+            dir = dir.getFileObject(prj.subDir());\n+            if (dir == null) {\n+                return null;\n+            }\n+        }\n+        return dir.getFileObject(prjName);\n+    }\n+\n+    private Collection<Dep> transitiveDeps(Dep current, Map<String, Dep> fill) {\n+        current.owner().computeTransitiveDeps();\n+        final Collection<Dep> currentAllDeps = current.allDeps();\n+        if (currentAllDeps == Collections.<Dep>emptySet()) {\n+            throw new IllegalStateException(\"Cyclic dep on \" + current.getName());\n+        } else if (currentAllDeps != null) {\n+            return currentAllDeps;\n+        }\n+        current.setAllDeps(Collections.emptySet());\n+        TreeSet<Dep> computing = new TreeSet<>();\n+        computing.add(current);\n+        for (String depName : current.depNames()) {\n+            Dep dep = fill.get(depName);\n+            if (dep == null) {\n+                int colon = depName.lastIndexOf(':');\n+                dep = fill.get(depName.substring(colon + 1));\n+                if (dep == null) {\n+                    LOG.log(Level.INFO, \"dep not found: {0}\", depName);\n+                    continue;\n+                }\n+            }\n+            Collection<Dep> allDeps = transitiveDeps(dep, fill);\n+            computing.addAll(allDeps);\n+        }\n+        current.setAllDeps(computing);\n+        return computing;\n+    }\n+\n+    private static void registerLibs(Map<String, MxLibrary> collect, String prefix, Map<String, MxLibrary> libraries) {\n+        for (Map.Entry<String, MxLibrary> entry : libraries.entrySet()) {\n+            String key = entry.getKey();\n+            MxLibrary lib = entry.getValue();\n+            if (prefix == null) {\n+                collect.put(key, lib);\n+            } else {\n+                collect.put(prefix + \":\" + key, lib);\n+            }\n+        }\n+    }\n+\n+    private void registerDeps(String prefix, Map<String, Dep> fillDeps) {\n+        for (Library library : libraries) {\n+            fillDeps.put(prefix + \":\" + library.getName(), library);\n+        }\n+        for (Dist d : distributions) {\n+            fillDeps.put(prefix + \":\" + d.getName(), d);\n+        }\n+        for (Map.Entry<String, SuiteSources> s : imported.entrySet()) {\n+            s.getValue().registerDeps(s.getKey(), fillDeps);\n+        }\n+    }\n+\n+    @Override\n+    public Group findBinaryRoots2(URL url) {\n+        final FileObject srcFo = URLMapper.findFileObject(url);\n+        for (Group group : this.groups) {\n+            if (group.contains(srcFo)) {\n+                return group;\n+            }\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    public URL[] computeRoots(Group group) {\n+        if (group.binDir != null) {\n+            return new URL[] { group.binDir.toURL() };\n+        } else {\n+            return new URL[0];\n+        }\n+    }\n+\n+    @Override\n+    public boolean computePreferBinaries(Group result) {\n+        return true;\n+    }\n+\n+    @Override\n+    public void computeChangeListener(Group result, boolean bln, ChangeListener cl) {\n+    }\n+\n+    @Override\n+    public SourceForBinaryQueryImplementation2.Result findSourceRoots2(URL url) {\n+        this.computeTransitiveDeps();\n+        for (Dist dist : this.distributions) {\n+            URL jar;\n+            try {\n+                jar = dist.getJarRoot();\n+                if (jar == null) {\n+                    continue;\n+                }\n+            } catch (MalformedURLException ok) {\n+                continue;\n+            }\n+            if (jar.equals(url)) {\n+                List<FileObject> roots = new ArrayList<>();\n+                for (Group d : dist.getContributingGroups()) {\n+                    roots.add(d.srcDir);\n+                    roots.add(d.srcGenDir);\n+                }\n+                return new ImmutableResult(roots.toArray(new FileObject[roots.size()]));\n+            }\n+        }\n+        for (Group group : this.groups) {\n+            if (group.binDir != null && group.binDir.toURL().equals(url)) {\n+                return new ImmutableResult(group.srcDir, group.srcGenDir);\n+            }\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    public SourceForBinaryQuery.Result findSourceRoots(URL url) {\n+        return findSourceRoots2(url);\n+    }\n+\n+    final Iterable<File> jdks() {\n+        Set<File> jdks = new LinkedHashSet<>();\n+        String home = System.getProperty(\"user.home\");\n+        if (home != null) {\n+            File userEnv = new File(new File(new File(home), \".mx\"), \"env\");\n+            findJdksInEnv(jdks, userEnv);\n+        }\n+        FileObject suiteEnv = dir.getFileObject(\"mx.\" + dir.getNameExt() + \"/env\");\n+        if (suiteEnv != null) {\n+            findJdksInEnv(jdks, FileUtil.toFile(suiteEnv));\n+        }\n+\n+        String javaHomeEnv = System.getenv(\"JAVA_HOME\");\n+        if (javaHomeEnv != null) {\n+            jdks.add(new File(javaHomeEnv));\n+        }\n+        String javaHomeProp = System.getProperty(\"java.home\");\n+        if (javaHomeProp != null) {\n+            jdks.add(new File(javaHomeProp));\n+        }\n+        return jdks;\n+    }\n+\n+    private void findJdksInEnv(Set<File> jdks, File env) {\n+        if (env == null || !env.isFile()) {\n+            return;\n+        }\n+        try (final FileInputStream is = new FileInputStream(env)) {\n+            Properties p = new Properties();\n+            p.load(is);\n+\n+            String javaHome = p.getProperty(\"JAVA_HOME\");\n+            if (javaHome != null) {\n+                jdks.add(new File(javaHome));\n+            }\n+\n+            String extraJavaHomes = p.getProperty(\"EXTRA_JAVA_HOMES\");\n+            if (extraJavaHomes != null) {\n+                for (String extraHome : extraJavaHomes.split(File.pathSeparator)) {\n+                    jdks.add(new File(extraHome));\n+                }\n+            }\n+        } catch (IOException ex) {\n+            Exceptions.printStackTrace(ex);\n+        }\n+    }\n+\n+    @Override\n+    public SourceLevelQueryImplementation2.Result getSourceLevel(FileObject fo) {\n+        Group g = findGroup(fo);\n+        if (g == null) {\n+            return null;\n+        }\n+        return new SourceLevelQueryImplementation2.Result2() {\n+            @Override\n+            public SourceLevelQuery.Profile getProfile() {\n+                return SourceLevelQuery.Profile.DEFAULT;\n+            }\n+\n+            @Override\n+            public String getSourceLevel() {\n+                return g.getCompliance().getSourceLevel();\n+            }\n+\n+            @Override\n+            public void addChangeListener(ChangeListener cl) {\n+            }\n+\n+            @Override\n+            public void removeChangeListener(ChangeListener cl) {\n+            }\n+        };\n+    }\n+\n+    @Override\n+    public Set<? extends Project> getSubprojects() {\n+        Set<Project> prjs = new HashSet<>();\n+        for (SuiteSources imp : imported.values()) {\n+            prjs.add(imp.prj);\n+        }\n+        return prjs;\n+    }\n+\n+    @Override\n+    public URL[] findUnitTests(FileObject fo) {\n+        return new URL[0];\n+    }\n+\n+    @Override\n+    public URL[] findSources(FileObject fo) {\n+        Group g = findGroup(fo);\n+        return g == null ? new URL[0] : new URL[] { g.getRootFolder().toURL() };\n+    }\n+\n+    static interface Dep extends Comparable<Dep> {\n+        String getName();\n+\n+        Collection<String> depNames();\n+\n+        Collection<Dep> allDeps();\n+\n+        void setAllDeps(Collection<Dep> set);\n+\n+        @Override\n+        public default int compareTo(Dep o) {\n+            return getName().compareTo(o.getName());\n+        }\n+\n+        SuiteSources owner();\n+    }\n+\n+    final class Dist implements Dep, FlaggedClassPathImplementation {\n+        final String name;\n+        final MxDistribution dist;\n+        Collection<Dep> allDeps;\n+        private final PropertyChangeSupport support = new PropertyChangeSupport(this);\n+        private Boolean exists;\n+        private Collection<Group> groups;\n+\n+        public Dist(String name, MxDistribution dist) {\n+            this.name = name;\n+            this.dist = dist;\n+        }\n+\n+        @Override\n+        public Collection<String> depNames() {\n+            Set<String> deps = new TreeSet<>();\n+            deps.addAll(dist.distDependencies());\n+            deps.addAll(dist.exclude());\n+            return deps;\n+        }\n+\n+        @Override\n+        public Collection<Dep> allDeps() {\n+            return this.allDeps;\n+        }\n+\n+        @Override\n+        public void setAllDeps(Collection<Dep> set) {\n+            this.allDeps = set;\n+        }\n+\n+        @Override\n+        public String getName() {\n+            return this.name;\n+        }\n+\n+        @Override\n+        public Set<ClassPath.Flag> getFlags() {\n+            return exists ? Collections.emptySet() : Collections.singleton(ClassPath.Flag.INCOMPLETE);\n+        }\n+\n+        private FileObject getJar(boolean ignore) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "21a2744fdd0de199cff1cdca7143f5498c4a4bdc"}, "originalPosition": 597}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODE3MjE2Mg==", "bodyText": "processTransDeps computes transitive deps on d.owner(), isn't it computed 2nd time here for all deps not just those used in classpath construction ?", "url": "https://github.com/apache/netbeans/pull/2575#discussion_r538172162", "createdAt": "2020-12-08T09:24:29Z", "author": {"login": "sdedic"}, "path": "java/java.mx.project/src/org/netbeans/modules/java/mx/project/SuiteSources.java", "diffHunk": "@@ -0,0 +1,1195 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.netbeans.modules.java.mx.project;\n+\n+import java.beans.PropertyChangeListener;\n+import java.beans.PropertyChangeSupport;\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.IOException;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.EnumSet;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.LinkedHashMap;\n+import java.util.LinkedHashSet;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Properties;\n+import java.util.Set;\n+import java.util.TreeSet;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import javax.swing.Icon;\n+import javax.swing.event.ChangeListener;\n+import org.netbeans.modules.java.mx.project.suitepy.MxDistribution;\n+import org.netbeans.modules.java.mx.project.suitepy.MxImports;\n+import org.netbeans.modules.java.mx.project.suitepy.MxLibrary;\n+import org.netbeans.modules.java.mx.project.suitepy.MxProject;\n+import org.netbeans.modules.java.mx.project.suitepy.MxSuite;\n+import org.netbeans.api.java.classpath.ClassPath;\n+import org.netbeans.api.java.queries.AnnotationProcessingQuery;\n+import org.netbeans.api.java.queries.SourceForBinaryQuery;\n+import org.netbeans.api.project.Project;\n+import org.netbeans.api.project.ProjectManager;\n+import org.netbeans.api.project.SourceGroup;\n+import org.netbeans.api.project.Sources;\n+import org.netbeans.spi.java.classpath.ClassPathFactory;\n+import org.netbeans.spi.java.classpath.ClassPathImplementation;\n+import org.netbeans.spi.java.classpath.FlaggedClassPathImplementation;\n+import org.netbeans.spi.java.classpath.PathResourceImplementation;\n+import org.netbeans.spi.java.classpath.support.ClassPathSupport;\n+import org.netbeans.spi.java.queries.BinaryForSourceQueryImplementation2;\n+import org.netbeans.spi.java.queries.SourceForBinaryQueryImplementation2;\n+import org.openide.filesystems.FileObject;\n+import org.openide.filesystems.FileUtil;\n+import org.openide.filesystems.URLMapper;\n+import org.openide.util.Exceptions;\n+import org.openide.util.Utilities;\n+import java.util.stream.Collectors;\n+import org.netbeans.api.java.queries.SourceLevelQuery;\n+import org.netbeans.spi.java.queries.MultipleRootsUnitTestForSourceQueryImplementation;\n+import org.netbeans.spi.java.queries.SourceLevelQueryImplementation2;\n+import org.netbeans.spi.project.SubprojectProvider;\n+\n+final class SuiteSources implements Sources,\n+                BinaryForSourceQueryImplementation2<SuiteSources.Group>, SourceForBinaryQueryImplementation2,\n+                SourceLevelQueryImplementation2, SubprojectProvider, MultipleRootsUnitTestForSourceQueryImplementation {\n+    private static final Logger LOG = Logger.getLogger(SuiteSources.class.getName());\n+    private static final SuiteSources CORE;\n+\n+    static {\n+        MxSuite coreSuite = CoreSuite.CORE_5_279_0;\n+        CORE = new SuiteSources(null, null, coreSuite);\n+    }\n+\n+    private final MxSuite suite;\n+    private final List<Group> groups;\n+    private final List<Library> libraries;\n+    private final List<Dist> distributions;\n+    private final FileObject dir;\n+    /**\n+     * non-null if the dependencies haven't yet been properly initialized\n+     */\n+    private Map<String, Dep> transitiveDeps;\n+    /**\n+     * avoid GC of imported projects\n+     */\n+    private final SuiteProject prj;\n+    private final Map<String, SuiteSources> imported;\n+\n+    SuiteSources(SuiteProject owner, FileObject dir, MxSuite suite) {\n+        final Map<String, Dep> fillDeps = new HashMap<>();\n+        this.prj = owner;\n+        this.dir = dir;\n+        this.groups = findGroups(fillDeps, suite, dir);\n+        this.libraries = findLibraries(fillDeps, suite);\n+        this.imported = findImportedSuites(dir, suite, fillDeps);\n+        this.distributions = findDistributions(suite, this.libraries, this.groups, fillDeps);\n+        this.suite = suite;\n+        this.transitiveDeps = fillDeps;\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return \"MxSources[\" + (dir == null ? \"mx\" : dir.toURI()) + \"]\";\n+    }\n+\n+    private List<Group> findGroups(Map<String, Dep> fillDeps, MxSuite s, FileObject dir) {\n+        List<Group> arr = new ArrayList<>();\n+        for (Map.Entry<String, MxProject> entry : s.projects().entrySet()) {\n+            String name = entry.getKey();\n+            MxProject mxPrj = entry.getValue();\n+            FileObject prjDir = findPrjDir(dir, name, mxPrj);\n+            if (prjDir == null) {\n+                fillDeps.put(name, new Group(name, mxPrj, null, null, null, name, name));\n+                continue;\n+            }\n+            String prevName = null;\n+            Group firstGroup = null;\n+            String binPrefix;\n+            if (mxPrj.subDir() == null) {\n+                binPrefix = \"mxbuild/\";\n+            } else {\n+                binPrefix = \"mxbuild/\" + mxPrj.subDir() + \"/\";\n+            }\n+            for (String rel : mxPrj.sourceDirs()) {\n+                FileObject srcDir = prjDir.getFileObject(rel);\n+                FileObject binDir = getSubDir(dir, binPrefix + name + \"/bin\");\n+                FileObject srcGenDir = getSubDir(dir, binPrefix + name + \"/src_gen\");\n+                if (srcDir != null && binDir != null) {\n+                    String prgName = name + \"-\" + rel;\n+                    String displayName;\n+                    if (prevName == null) {\n+                        displayName = name;\n+                    } else {\n+                        displayName = name + \"[\" + rel + \"]\";\n+                    }\n+                    Group g = new Group(name, mxPrj, srcDir, srcGenDir, binDir, prgName, displayName);\n+                    arr.add(g);\n+                    if (firstGroup == null) {\n+                        firstGroup = g;\n+                    }\n+                    prevName = displayName;\n+                }\n+            }\n+            if (firstGroup != null) {\n+                fillDeps.put(name, firstGroup);\n+            }\n+        }\n+        return arr;\n+    }\n+\n+    private static FileObject getSubDir(FileObject dir, String relPath) {\n+        FileObject subDir = dir.getFileObject(relPath);\n+        if (subDir == null) {\n+            try {\n+                subDir = FileUtil.createFolder(dir, relPath);\n+            } catch (IOException ex) {\n+                Exceptions.printStackTrace(ex);\n+            }\n+        }\n+        return subDir;\n+    }\n+\n+    private List<Library> findLibraries(Map<String, Dep> fillDeps, MxSuite suite) {\n+        final Map<String, MxLibrary> allLibraries = new HashMap<>();\n+        registerLibs(allLibraries, null, suite.libraries());\n+\n+        List<Library> arr = new ArrayList<>();\n+        for (Map.Entry<String, MxLibrary> entry : allLibraries.entrySet()) {\n+            final Library library = new Library(entry.getKey(), entry.getValue());\n+            arr.add(library);\n+            fillDeps.put(library.getName(), library);\n+        }\n+        for (Map.Entry<String, MxLibrary> entry : suite.jdklibraries().entrySet()) {\n+            final JdkLibrary library = new JdkLibrary(entry.getKey(), entry.getValue());\n+            arr.add(library);\n+            fillDeps.put(library.getName(), library);\n+        }\n+        return arr;\n+    }\n+\n+    private static Map<String, SuiteSources> findImportedSuites(FileObject dir, MxSuite s, Map<String, Dep> fillDeps) {\n+        if (dir == null) {\n+            return Collections.emptyMap();\n+        }\n+        CORE.registerDeps(\"mx\", fillDeps);\n+        final MxImports imports = s.imports();\n+        if (imports != null) {\n+            Map<String, SuiteSources> imported = new LinkedHashMap<>();\n+            for (MxImports.Suite imp : imports.suites()) {\n+                SuiteSources impSources = findSuiteSources(dir, imp);\n+                final String suiteName = imp.name();\n+                if (impSources == null) {\n+                    LOG.log(Level.INFO, \"cannot find imported suite: {0}\", suiteName);\n+                    continue;\n+                }\n+                imported.put(suiteName, impSources);\n+                impSources.registerDeps(suiteName, fillDeps);\n+            }\n+            return imported;\n+        }\n+        return Collections.emptyMap();\n+    }\n+\n+    private List<Dist> findDistributions(MxSuite s, List<Library> libraries, List<Group> groups, Map<String, Dep> fillDeps) {\n+        List<Dist> dists = new ArrayList<>();\n+        for (Map.Entry<String, MxDistribution> entry : s.distributions().entrySet()) {\n+            Dist d = new Dist(entry.getKey(), entry.getValue());\n+            dists.add(d);\n+            fillDeps.put(d.getName(), d);\n+        }\n+        return dists;\n+    }\n+\n+    final synchronized void computeTransitiveDeps() {\n+        Map<String, Dep> collectedDeps = this.transitiveDeps;\n+        if (collectedDeps == null) {\n+            return;\n+        }\n+        this.transitiveDeps = null;\n+        for (Library l : this.libraries) {\n+            transitiveDeps(l, collectedDeps);\n+        }\n+        for (Group g : this.groups) {\n+            transitiveDeps(g, collectedDeps);\n+        }\n+        for (Dist d : this.distributions) {\n+            transitiveDeps(d, collectedDeps);\n+        }\n+        for (Group g : groups) {\n+            g.computeClassPath(collectedDeps);\n+        }\n+        for (Dist d : this.distributions) {\n+            d.computeSourceRoots(collectedDeps);\n+        }\n+    }\n+\n+    private static SuiteSources findSuiteSources(FileObject dir, MxImports.Suite imp) throws IllegalArgumentException {\n+        SuiteSources sources = findSuiteSources(dir.getParent(), imp.name());\n+        if (sources != null) {\n+            return sources;\n+        }\n+        if (imp.subdir()) {\n+            for (FileObject subDir : dir.getParent().getChildren()) {\n+                sources = findSuiteSources(subDir, imp.name());\n+                if (sources != null) {\n+                    return sources;\n+                }\n+            }\n+            for (FileObject subDir : dir.getParent().getParent().getChildren()) {\n+                sources = findSuiteSources(subDir, imp.name());\n+                if (sources != null) {\n+                    return sources;\n+                }\n+            }\n+        }\n+        return null;\n+    }\n+\n+    private static SuiteSources findSuiteSources(FileObject root, String name) throws IllegalArgumentException {\n+        FileObject impDir = root.getFileObject(name);\n+        if (impDir != null) {\n+            try {\n+                Project impPrj = ProjectManager.getDefault().findProject(impDir);\n+                return impPrj == null ? null : impPrj.getLookup().lookup(SuiteSources.class);\n+            } catch (IOException ex) {\n+                Exceptions.printStackTrace(ex);\n+            }\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    public SourceGroup[] getSourceGroups(String string) {\n+        return groups();\n+    }\n+\n+    Group[] groups() {\n+        return groups.toArray(new Group[0]);\n+    }\n+\n+    Group findGroup(FileObject fo) {\n+        for (Group g : groups) {\n+            if (g.contains(fo)) {\n+                return g;\n+            }\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    public void addChangeListener(ChangeListener cl) {\n+    }\n+\n+    @Override\n+    public void removeChangeListener(ChangeListener cl) {\n+    }\n+\n+    private static FileObject findPrjDir(FileObject dir, String prjName, MxProject prj) {\n+        if (dir == null) {\n+            return null;\n+        }\n+        if (prj.dir() != null) {\n+            return dir.getFileObject(prj.dir());\n+        }\n+        if (prj.subDir() != null) {\n+            dir = dir.getFileObject(prj.subDir());\n+            if (dir == null) {\n+                return null;\n+            }\n+        }\n+        return dir.getFileObject(prjName);\n+    }\n+\n+    private Collection<Dep> transitiveDeps(Dep current, Map<String, Dep> fill) {\n+        current.owner().computeTransitiveDeps();\n+        final Collection<Dep> currentAllDeps = current.allDeps();\n+        if (currentAllDeps == Collections.<Dep>emptySet()) {\n+            throw new IllegalStateException(\"Cyclic dep on \" + current.getName());\n+        } else if (currentAllDeps != null) {\n+            return currentAllDeps;\n+        }\n+        current.setAllDeps(Collections.emptySet());\n+        TreeSet<Dep> computing = new TreeSet<>();\n+        computing.add(current);\n+        for (String depName : current.depNames()) {\n+            Dep dep = fill.get(depName);\n+            if (dep == null) {\n+                int colon = depName.lastIndexOf(':');\n+                dep = fill.get(depName.substring(colon + 1));\n+                if (dep == null) {\n+                    LOG.log(Level.INFO, \"dep not found: {0}\", depName);\n+                    continue;\n+                }\n+            }\n+            Collection<Dep> allDeps = transitiveDeps(dep, fill);\n+            computing.addAll(allDeps);\n+        }\n+        current.setAllDeps(computing);\n+        return computing;\n+    }\n+\n+    private static void registerLibs(Map<String, MxLibrary> collect, String prefix, Map<String, MxLibrary> libraries) {\n+        for (Map.Entry<String, MxLibrary> entry : libraries.entrySet()) {\n+            String key = entry.getKey();\n+            MxLibrary lib = entry.getValue();\n+            if (prefix == null) {\n+                collect.put(key, lib);\n+            } else {\n+                collect.put(prefix + \":\" + key, lib);\n+            }\n+        }\n+    }\n+\n+    private void registerDeps(String prefix, Map<String, Dep> fillDeps) {\n+        for (Library library : libraries) {\n+            fillDeps.put(prefix + \":\" + library.getName(), library);\n+        }\n+        for (Dist d : distributions) {\n+            fillDeps.put(prefix + \":\" + d.getName(), d);\n+        }\n+        for (Map.Entry<String, SuiteSources> s : imported.entrySet()) {\n+            s.getValue().registerDeps(s.getKey(), fillDeps);\n+        }\n+    }\n+\n+    @Override\n+    public Group findBinaryRoots2(URL url) {\n+        final FileObject srcFo = URLMapper.findFileObject(url);\n+        for (Group group : this.groups) {\n+            if (group.contains(srcFo)) {\n+                return group;\n+            }\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    public URL[] computeRoots(Group group) {\n+        if (group.binDir != null) {\n+            return new URL[] { group.binDir.toURL() };\n+        } else {\n+            return new URL[0];\n+        }\n+    }\n+\n+    @Override\n+    public boolean computePreferBinaries(Group result) {\n+        return true;\n+    }\n+\n+    @Override\n+    public void computeChangeListener(Group result, boolean bln, ChangeListener cl) {\n+    }\n+\n+    @Override\n+    public SourceForBinaryQueryImplementation2.Result findSourceRoots2(URL url) {\n+        this.computeTransitiveDeps();\n+        for (Dist dist : this.distributions) {\n+            URL jar;\n+            try {\n+                jar = dist.getJarRoot();\n+                if (jar == null) {\n+                    continue;\n+                }\n+            } catch (MalformedURLException ok) {\n+                continue;\n+            }\n+            if (jar.equals(url)) {\n+                List<FileObject> roots = new ArrayList<>();\n+                for (Group d : dist.getContributingGroups()) {\n+                    roots.add(d.srcDir);\n+                    roots.add(d.srcGenDir);\n+                }\n+                return new ImmutableResult(roots.toArray(new FileObject[roots.size()]));\n+            }\n+        }\n+        for (Group group : this.groups) {\n+            if (group.binDir != null && group.binDir.toURL().equals(url)) {\n+                return new ImmutableResult(group.srcDir, group.srcGenDir);\n+            }\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    public SourceForBinaryQuery.Result findSourceRoots(URL url) {\n+        return findSourceRoots2(url);\n+    }\n+\n+    final Iterable<File> jdks() {\n+        Set<File> jdks = new LinkedHashSet<>();\n+        String home = System.getProperty(\"user.home\");\n+        if (home != null) {\n+            File userEnv = new File(new File(new File(home), \".mx\"), \"env\");\n+            findJdksInEnv(jdks, userEnv);\n+        }\n+        FileObject suiteEnv = dir.getFileObject(\"mx.\" + dir.getNameExt() + \"/env\");\n+        if (suiteEnv != null) {\n+            findJdksInEnv(jdks, FileUtil.toFile(suiteEnv));\n+        }\n+\n+        String javaHomeEnv = System.getenv(\"JAVA_HOME\");\n+        if (javaHomeEnv != null) {\n+            jdks.add(new File(javaHomeEnv));\n+        }\n+        String javaHomeProp = System.getProperty(\"java.home\");\n+        if (javaHomeProp != null) {\n+            jdks.add(new File(javaHomeProp));\n+        }\n+        return jdks;\n+    }\n+\n+    private void findJdksInEnv(Set<File> jdks, File env) {\n+        if (env == null || !env.isFile()) {\n+            return;\n+        }\n+        try (final FileInputStream is = new FileInputStream(env)) {\n+            Properties p = new Properties();\n+            p.load(is);\n+\n+            String javaHome = p.getProperty(\"JAVA_HOME\");\n+            if (javaHome != null) {\n+                jdks.add(new File(javaHome));\n+            }\n+\n+            String extraJavaHomes = p.getProperty(\"EXTRA_JAVA_HOMES\");\n+            if (extraJavaHomes != null) {\n+                for (String extraHome : extraJavaHomes.split(File.pathSeparator)) {\n+                    jdks.add(new File(extraHome));\n+                }\n+            }\n+        } catch (IOException ex) {\n+            Exceptions.printStackTrace(ex);\n+        }\n+    }\n+\n+    @Override\n+    public SourceLevelQueryImplementation2.Result getSourceLevel(FileObject fo) {\n+        Group g = findGroup(fo);\n+        if (g == null) {\n+            return null;\n+        }\n+        return new SourceLevelQueryImplementation2.Result2() {\n+            @Override\n+            public SourceLevelQuery.Profile getProfile() {\n+                return SourceLevelQuery.Profile.DEFAULT;\n+            }\n+\n+            @Override\n+            public String getSourceLevel() {\n+                return g.getCompliance().getSourceLevel();\n+            }\n+\n+            @Override\n+            public void addChangeListener(ChangeListener cl) {\n+            }\n+\n+            @Override\n+            public void removeChangeListener(ChangeListener cl) {\n+            }\n+        };\n+    }\n+\n+    @Override\n+    public Set<? extends Project> getSubprojects() {\n+        Set<Project> prjs = new HashSet<>();\n+        for (SuiteSources imp : imported.values()) {\n+            prjs.add(imp.prj);\n+        }\n+        return prjs;\n+    }\n+\n+    @Override\n+    public URL[] findUnitTests(FileObject fo) {\n+        return new URL[0];\n+    }\n+\n+    @Override\n+    public URL[] findSources(FileObject fo) {\n+        Group g = findGroup(fo);\n+        return g == null ? new URL[0] : new URL[] { g.getRootFolder().toURL() };\n+    }\n+\n+    static interface Dep extends Comparable<Dep> {\n+        String getName();\n+\n+        Collection<String> depNames();\n+\n+        Collection<Dep> allDeps();\n+\n+        void setAllDeps(Collection<Dep> set);\n+\n+        @Override\n+        public default int compareTo(Dep o) {\n+            return getName().compareTo(o.getName());\n+        }\n+\n+        SuiteSources owner();\n+    }\n+\n+    final class Dist implements Dep, FlaggedClassPathImplementation {\n+        final String name;\n+        final MxDistribution dist;\n+        Collection<Dep> allDeps;\n+        private final PropertyChangeSupport support = new PropertyChangeSupport(this);\n+        private Boolean exists;\n+        private Collection<Group> groups;\n+\n+        public Dist(String name, MxDistribution dist) {\n+            this.name = name;\n+            this.dist = dist;\n+        }\n+\n+        @Override\n+        public Collection<String> depNames() {\n+            Set<String> deps = new TreeSet<>();\n+            deps.addAll(dist.distDependencies());\n+            deps.addAll(dist.exclude());\n+            return deps;\n+        }\n+\n+        @Override\n+        public Collection<Dep> allDeps() {\n+            return this.allDeps;\n+        }\n+\n+        @Override\n+        public void setAllDeps(Collection<Dep> set) {\n+            this.allDeps = set;\n+        }\n+\n+        @Override\n+        public String getName() {\n+            return this.name;\n+        }\n+\n+        @Override\n+        public Set<ClassPath.Flag> getFlags() {\n+            return exists ? Collections.emptySet() : Collections.singleton(ClassPath.Flag.INCOMPLETE);\n+        }\n+\n+        private FileObject getJar(boolean ignore) {\n+            if (SuiteSources.this.dir == null) {\n+                return null;\n+            }\n+            FileObject dists = SuiteSources.this.dir.getFileObject(\"mxbuild/dists\");\n+            if (dists == null) {\n+                return null;\n+            }\n+            List<FileObject> dist = Arrays.stream(dists.getChildren()).filter((fo) -> fo.isFolder() && fo.getName().startsWith(\"jdk\")).collect(Collectors.toList());\n+            dist.sort((fo1, fo2) -> fo2.getName().compareTo(fo1.getName()));\n+            for (FileObject jdkDir : dist) {\n+                FileObject jar = jdkDir.getFileObject(name.toLowerCase().replace(\"_\", \"-\") + \".jar\");\n+                if (jar != null) {\n+                    return jar;\n+                }\n+            }\n+            FileObject jar = dists.getFileObject(name.toLowerCase().replace(\"_\", \"-\") + \".jar\");\n+            if (jar != null) {\n+                return jar;\n+            }\n+            return null;\n+        }\n+\n+        @Override\n+        public List<? extends PathResourceImplementation> getResources() {\n+            computeTransitiveDeps();\n+            FileObject jar = getJar(exists == null);\n+            final boolean existsNow = jar != null && jar.isData();\n+            if (exists == null) {\n+                exists = existsNow;\n+            } else {\n+                if (exists != existsNow) {\n+                    exists = existsNow;\n+                    support.firePropertyChange(PROP_FLAGS, !exists, (boolean) exists);\n+                }\n+            }\n+            if (jar != null) {\n+                PathResourceImplementation res;\n+                try {\n+                    res = ClassPathSupport.createResource(getJarRoot());\n+                    return Collections.singletonList(res);\n+                } catch (MalformedURLException ex) {\n+                    // OK\n+                }\n+            }\n+            return Collections.emptyList();\n+        }\n+\n+        private URL getJarRoot() throws MalformedURLException {\n+            FileObject jar = getJar(true);\n+            if (jar != null) {\n+                return new URL(\"jar:\" + jar.toURL() + \"!/\");\n+            } else {\n+                return null;\n+            }\n+        }\n+\n+        @Override\n+        public void addPropertyChangeListener(PropertyChangeListener pl) {\n+            support.addPropertyChangeListener(pl);\n+        }\n+\n+        @Override\n+        public void removePropertyChangeListener(PropertyChangeListener pl) {\n+            support.removePropertyChangeListener(pl);\n+        }\n+\n+        @Override\n+        public SuiteSources owner() {\n+            return SuiteSources.this;\n+        }\n+\n+        private void computeSourceRoots(Map<String, Dep> collectedDeps) {\n+            if (groups != null) {\n+                return;\n+            }\n+            Set<Group> contributingGroups = new LinkedHashSet<>();\n+            for (String d : this.dist.dependencies()) {\n+                Dep dep = collectedDeps.get(d);\n+                if (dep == null || dep.allDeps() == null) {\n+                    continue;\n+                }\n+                for (Dep d2 : dep.allDeps()) {\n+                    if (d2 instanceof Group) {\n+                        contributingGroups.add((Group) d2);\n+                    }\n+                }\n+            }\n+            for (String d : this.dist.distDependencies()) {\n+                final Dep anyDep = collectedDeps.get(d);\n+                if (anyDep instanceof Dist) {\n+                    Dist dep = (Dist) anyDep;\n+                    dep.computeSourceRoots(collectedDeps);\n+                    contributingGroups.removeAll(dep.getContributingGroups());\n+                }\n+            }\n+            groups = contributingGroups;\n+        }\n+\n+        public Collection<Group> getContributingGroups() {\n+            return groups;\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return \"Dist[name=\" + name + \"]\";\n+        }\n+    }\n+\n+    final class Group implements SourceGroup, Dep, AnnotationProcessingQuery.Result,\n+            Compliance.Provider {\n+        private final String mxName;\n+        private final MxProject mxPrj;\n+        private final FileObject srcDir;\n+        private final FileObject srcGenDir;\n+        private final FileObject binDir;\n+        private final String name;\n+        private final String displayName;\n+        private final Compliance compliance;\n+        private ClassPath sourceCP;\n+        private ClassPath cp;\n+        private ClassPath processorPath;\n+        private Collection<Dep> allDeps;\n+\n+        Group(String mxName, MxProject mxPrj, FileObject srcDir, FileObject srcGenDir, FileObject binDir, String name, String displayName) {\n+            this.mxName = mxName;\n+            this.mxPrj = mxPrj;\n+            this.srcDir = srcDir;\n+            this.srcGenDir = srcGenDir;\n+            this.binDir = binDir;\n+            this.name = name;\n+            this.displayName = displayName;\n+            this.compliance = Compliance.parse(mxPrj.javaCompliance());\n+        }\n+\n+        @Override\n+        public FileObject getRootFolder() {\n+            return srcDir;\n+        }\n+\n+        @Override\n+        public String getName() {\n+            return name;\n+        }\n+\n+        @Override\n+        public String getDisplayName() {\n+            return displayName;\n+        }\n+\n+        @Override\n+        public Icon getIcon(boolean opened) {\n+            return null;\n+        }\n+\n+        @Override\n+        public Compliance getCompliance() {\n+            return compliance;\n+        }\n+\n+        @Override\n+        public boolean contains(FileObject file) {\n+            if (file == srcDir || file == srcGenDir || FileUtil.isParentOf(srcDir, file) || (srcGenDir != null && FileUtil.isParentOf(srcGenDir, file))) {\n+                return true;\n+            }\n+            return false;\n+        }\n+\n+        @Override\n+        public void addPropertyChangeListener(PropertyChangeListener l) {\n+        }\n+\n+        @Override\n+        public void removePropertyChangeListener(PropertyChangeListener l) {\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return \"SuiteSources.Group[name=\" + name + \",rootFolder=\" + srcDir + \"]\"; // NOI18N\n+        }\n+\n+        ClassPath getSourceCP() {\n+            computeTransitiveDeps();\n+            return sourceCP;\n+        }\n+\n+        ClassPath getCP() {\n+            computeTransitiveDeps();\n+            return cp;\n+        }\n+\n+        @Override\n+        public Collection<String> depNames() {\n+            return mxPrj.dependencies();\n+        }\n+\n+        @Override\n+        public void setAllDeps(Collection<Dep> set) {\n+            allDeps = set;\n+        }\n+\n+        @Override\n+        public Collection<Dep> allDeps() {\n+            return allDeps;\n+        }\n+\n+        private void computeClassPath(Map<String, Dep> transDeps) {\n+            for (Dep d : transDeps.values()) {\n+                d.owner().computeTransitiveDeps();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "21a2744fdd0de199cff1cdca7143f5498c4a4bdc"}, "originalPosition": 805}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODE3MjI1MQ==", "bodyText": "Uh :) I meant mx already supports aarch64, maybe even i386 ?", "url": "https://github.com/apache/netbeans/pull/2575#discussion_r538172251", "createdAt": "2020-12-08T09:24:35Z", "author": {"login": "sdedic"}, "path": "java/java.mx.project/src/org/netbeans/modules/java/mx/project/SuiteSources.java", "diffHunk": "@@ -0,0 +1,1195 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.netbeans.modules.java.mx.project;\n+\n+import java.beans.PropertyChangeListener;\n+import java.beans.PropertyChangeSupport;\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.IOException;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.EnumSet;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.LinkedHashMap;\n+import java.util.LinkedHashSet;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Properties;\n+import java.util.Set;\n+import java.util.TreeSet;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import javax.swing.Icon;\n+import javax.swing.event.ChangeListener;\n+import org.netbeans.modules.java.mx.project.suitepy.MxDistribution;\n+import org.netbeans.modules.java.mx.project.suitepy.MxImports;\n+import org.netbeans.modules.java.mx.project.suitepy.MxLibrary;\n+import org.netbeans.modules.java.mx.project.suitepy.MxProject;\n+import org.netbeans.modules.java.mx.project.suitepy.MxSuite;\n+import org.netbeans.api.java.classpath.ClassPath;\n+import org.netbeans.api.java.queries.AnnotationProcessingQuery;\n+import org.netbeans.api.java.queries.SourceForBinaryQuery;\n+import org.netbeans.api.project.Project;\n+import org.netbeans.api.project.ProjectManager;\n+import org.netbeans.api.project.SourceGroup;\n+import org.netbeans.api.project.Sources;\n+import org.netbeans.spi.java.classpath.ClassPathFactory;\n+import org.netbeans.spi.java.classpath.ClassPathImplementation;\n+import org.netbeans.spi.java.classpath.FlaggedClassPathImplementation;\n+import org.netbeans.spi.java.classpath.PathResourceImplementation;\n+import org.netbeans.spi.java.classpath.support.ClassPathSupport;\n+import org.netbeans.spi.java.queries.BinaryForSourceQueryImplementation2;\n+import org.netbeans.spi.java.queries.SourceForBinaryQueryImplementation2;\n+import org.openide.filesystems.FileObject;\n+import org.openide.filesystems.FileUtil;\n+import org.openide.filesystems.URLMapper;\n+import org.openide.util.Exceptions;\n+import org.openide.util.Utilities;\n+import java.util.stream.Collectors;\n+import org.netbeans.api.java.queries.SourceLevelQuery;\n+import org.netbeans.spi.java.queries.MultipleRootsUnitTestForSourceQueryImplementation;\n+import org.netbeans.spi.java.queries.SourceLevelQueryImplementation2;\n+import org.netbeans.spi.project.SubprojectProvider;\n+\n+final class SuiteSources implements Sources,\n+                BinaryForSourceQueryImplementation2<SuiteSources.Group>, SourceForBinaryQueryImplementation2,\n+                SourceLevelQueryImplementation2, SubprojectProvider, MultipleRootsUnitTestForSourceQueryImplementation {\n+    private static final Logger LOG = Logger.getLogger(SuiteSources.class.getName());\n+    private static final SuiteSources CORE;\n+\n+    static {\n+        MxSuite coreSuite = CoreSuite.CORE_5_279_0;\n+        CORE = new SuiteSources(null, null, coreSuite);\n+    }\n+\n+    private final MxSuite suite;\n+    private final List<Group> groups;\n+    private final List<Library> libraries;\n+    private final List<Dist> distributions;\n+    private final FileObject dir;\n+    /**\n+     * non-null if the dependencies haven't yet been properly initialized\n+     */\n+    private Map<String, Dep> transitiveDeps;\n+    /**\n+     * avoid GC of imported projects\n+     */\n+    private final SuiteProject prj;\n+    private final Map<String, SuiteSources> imported;\n+\n+    SuiteSources(SuiteProject owner, FileObject dir, MxSuite suite) {\n+        final Map<String, Dep> fillDeps = new HashMap<>();\n+        this.prj = owner;\n+        this.dir = dir;\n+        this.groups = findGroups(fillDeps, suite, dir);\n+        this.libraries = findLibraries(fillDeps, suite);\n+        this.imported = findImportedSuites(dir, suite, fillDeps);\n+        this.distributions = findDistributions(suite, this.libraries, this.groups, fillDeps);\n+        this.suite = suite;\n+        this.transitiveDeps = fillDeps;\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return \"MxSources[\" + (dir == null ? \"mx\" : dir.toURI()) + \"]\";\n+    }\n+\n+    private List<Group> findGroups(Map<String, Dep> fillDeps, MxSuite s, FileObject dir) {\n+        List<Group> arr = new ArrayList<>();\n+        for (Map.Entry<String, MxProject> entry : s.projects().entrySet()) {\n+            String name = entry.getKey();\n+            MxProject mxPrj = entry.getValue();\n+            FileObject prjDir = findPrjDir(dir, name, mxPrj);\n+            if (prjDir == null) {\n+                fillDeps.put(name, new Group(name, mxPrj, null, null, null, name, name));\n+                continue;\n+            }\n+            String prevName = null;\n+            Group firstGroup = null;\n+            String binPrefix;\n+            if (mxPrj.subDir() == null) {\n+                binPrefix = \"mxbuild/\";\n+            } else {\n+                binPrefix = \"mxbuild/\" + mxPrj.subDir() + \"/\";\n+            }\n+            for (String rel : mxPrj.sourceDirs()) {\n+                FileObject srcDir = prjDir.getFileObject(rel);\n+                FileObject binDir = getSubDir(dir, binPrefix + name + \"/bin\");\n+                FileObject srcGenDir = getSubDir(dir, binPrefix + name + \"/src_gen\");\n+                if (srcDir != null && binDir != null) {\n+                    String prgName = name + \"-\" + rel;\n+                    String displayName;\n+                    if (prevName == null) {\n+                        displayName = name;\n+                    } else {\n+                        displayName = name + \"[\" + rel + \"]\";\n+                    }\n+                    Group g = new Group(name, mxPrj, srcDir, srcGenDir, binDir, prgName, displayName);\n+                    arr.add(g);\n+                    if (firstGroup == null) {\n+                        firstGroup = g;\n+                    }\n+                    prevName = displayName;\n+                }\n+            }\n+            if (firstGroup != null) {\n+                fillDeps.put(name, firstGroup);\n+            }\n+        }\n+        return arr;\n+    }\n+\n+    private static FileObject getSubDir(FileObject dir, String relPath) {\n+        FileObject subDir = dir.getFileObject(relPath);\n+        if (subDir == null) {\n+            try {\n+                subDir = FileUtil.createFolder(dir, relPath);\n+            } catch (IOException ex) {\n+                Exceptions.printStackTrace(ex);\n+            }\n+        }\n+        return subDir;\n+    }\n+\n+    private List<Library> findLibraries(Map<String, Dep> fillDeps, MxSuite suite) {\n+        final Map<String, MxLibrary> allLibraries = new HashMap<>();\n+        registerLibs(allLibraries, null, suite.libraries());\n+\n+        List<Library> arr = new ArrayList<>();\n+        for (Map.Entry<String, MxLibrary> entry : allLibraries.entrySet()) {\n+            final Library library = new Library(entry.getKey(), entry.getValue());\n+            arr.add(library);\n+            fillDeps.put(library.getName(), library);\n+        }\n+        for (Map.Entry<String, MxLibrary> entry : suite.jdklibraries().entrySet()) {\n+            final JdkLibrary library = new JdkLibrary(entry.getKey(), entry.getValue());\n+            arr.add(library);\n+            fillDeps.put(library.getName(), library);\n+        }\n+        return arr;\n+    }\n+\n+    private static Map<String, SuiteSources> findImportedSuites(FileObject dir, MxSuite s, Map<String, Dep> fillDeps) {\n+        if (dir == null) {\n+            return Collections.emptyMap();\n+        }\n+        CORE.registerDeps(\"mx\", fillDeps);\n+        final MxImports imports = s.imports();\n+        if (imports != null) {\n+            Map<String, SuiteSources> imported = new LinkedHashMap<>();\n+            for (MxImports.Suite imp : imports.suites()) {\n+                SuiteSources impSources = findSuiteSources(dir, imp);\n+                final String suiteName = imp.name();\n+                if (impSources == null) {\n+                    LOG.log(Level.INFO, \"cannot find imported suite: {0}\", suiteName);\n+                    continue;\n+                }\n+                imported.put(suiteName, impSources);\n+                impSources.registerDeps(suiteName, fillDeps);\n+            }\n+            return imported;\n+        }\n+        return Collections.emptyMap();\n+    }\n+\n+    private List<Dist> findDistributions(MxSuite s, List<Library> libraries, List<Group> groups, Map<String, Dep> fillDeps) {\n+        List<Dist> dists = new ArrayList<>();\n+        for (Map.Entry<String, MxDistribution> entry : s.distributions().entrySet()) {\n+            Dist d = new Dist(entry.getKey(), entry.getValue());\n+            dists.add(d);\n+            fillDeps.put(d.getName(), d);\n+        }\n+        return dists;\n+    }\n+\n+    final synchronized void computeTransitiveDeps() {\n+        Map<String, Dep> collectedDeps = this.transitiveDeps;\n+        if (collectedDeps == null) {\n+            return;\n+        }\n+        this.transitiveDeps = null;\n+        for (Library l : this.libraries) {\n+            transitiveDeps(l, collectedDeps);\n+        }\n+        for (Group g : this.groups) {\n+            transitiveDeps(g, collectedDeps);\n+        }\n+        for (Dist d : this.distributions) {\n+            transitiveDeps(d, collectedDeps);\n+        }\n+        for (Group g : groups) {\n+            g.computeClassPath(collectedDeps);\n+        }\n+        for (Dist d : this.distributions) {\n+            d.computeSourceRoots(collectedDeps);\n+        }\n+    }\n+\n+    private static SuiteSources findSuiteSources(FileObject dir, MxImports.Suite imp) throws IllegalArgumentException {\n+        SuiteSources sources = findSuiteSources(dir.getParent(), imp.name());\n+        if (sources != null) {\n+            return sources;\n+        }\n+        if (imp.subdir()) {\n+            for (FileObject subDir : dir.getParent().getChildren()) {\n+                sources = findSuiteSources(subDir, imp.name());\n+                if (sources != null) {\n+                    return sources;\n+                }\n+            }\n+            for (FileObject subDir : dir.getParent().getParent().getChildren()) {\n+                sources = findSuiteSources(subDir, imp.name());\n+                if (sources != null) {\n+                    return sources;\n+                }\n+            }\n+        }\n+        return null;\n+    }\n+\n+    private static SuiteSources findSuiteSources(FileObject root, String name) throws IllegalArgumentException {\n+        FileObject impDir = root.getFileObject(name);\n+        if (impDir != null) {\n+            try {\n+                Project impPrj = ProjectManager.getDefault().findProject(impDir);\n+                return impPrj == null ? null : impPrj.getLookup().lookup(SuiteSources.class);\n+            } catch (IOException ex) {\n+                Exceptions.printStackTrace(ex);\n+            }\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    public SourceGroup[] getSourceGroups(String string) {\n+        return groups();\n+    }\n+\n+    Group[] groups() {\n+        return groups.toArray(new Group[0]);\n+    }\n+\n+    Group findGroup(FileObject fo) {\n+        for (Group g : groups) {\n+            if (g.contains(fo)) {\n+                return g;\n+            }\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    public void addChangeListener(ChangeListener cl) {\n+    }\n+\n+    @Override\n+    public void removeChangeListener(ChangeListener cl) {\n+    }\n+\n+    private static FileObject findPrjDir(FileObject dir, String prjName, MxProject prj) {\n+        if (dir == null) {\n+            return null;\n+        }\n+        if (prj.dir() != null) {\n+            return dir.getFileObject(prj.dir());\n+        }\n+        if (prj.subDir() != null) {\n+            dir = dir.getFileObject(prj.subDir());\n+            if (dir == null) {\n+                return null;\n+            }\n+        }\n+        return dir.getFileObject(prjName);\n+    }\n+\n+    private Collection<Dep> transitiveDeps(Dep current, Map<String, Dep> fill) {\n+        current.owner().computeTransitiveDeps();\n+        final Collection<Dep> currentAllDeps = current.allDeps();\n+        if (currentAllDeps == Collections.<Dep>emptySet()) {\n+            throw new IllegalStateException(\"Cyclic dep on \" + current.getName());\n+        } else if (currentAllDeps != null) {\n+            return currentAllDeps;\n+        }\n+        current.setAllDeps(Collections.emptySet());\n+        TreeSet<Dep> computing = new TreeSet<>();\n+        computing.add(current);\n+        for (String depName : current.depNames()) {\n+            Dep dep = fill.get(depName);\n+            if (dep == null) {\n+                int colon = depName.lastIndexOf(':');\n+                dep = fill.get(depName.substring(colon + 1));\n+                if (dep == null) {\n+                    LOG.log(Level.INFO, \"dep not found: {0}\", depName);\n+                    continue;\n+                }\n+            }\n+            Collection<Dep> allDeps = transitiveDeps(dep, fill);\n+            computing.addAll(allDeps);\n+        }\n+        current.setAllDeps(computing);\n+        return computing;\n+    }\n+\n+    private static void registerLibs(Map<String, MxLibrary> collect, String prefix, Map<String, MxLibrary> libraries) {\n+        for (Map.Entry<String, MxLibrary> entry : libraries.entrySet()) {\n+            String key = entry.getKey();\n+            MxLibrary lib = entry.getValue();\n+            if (prefix == null) {\n+                collect.put(key, lib);\n+            } else {\n+                collect.put(prefix + \":\" + key, lib);\n+            }\n+        }\n+    }\n+\n+    private void registerDeps(String prefix, Map<String, Dep> fillDeps) {\n+        for (Library library : libraries) {\n+            fillDeps.put(prefix + \":\" + library.getName(), library);\n+        }\n+        for (Dist d : distributions) {\n+            fillDeps.put(prefix + \":\" + d.getName(), d);\n+        }\n+        for (Map.Entry<String, SuiteSources> s : imported.entrySet()) {\n+            s.getValue().registerDeps(s.getKey(), fillDeps);\n+        }\n+    }\n+\n+    @Override\n+    public Group findBinaryRoots2(URL url) {\n+        final FileObject srcFo = URLMapper.findFileObject(url);\n+        for (Group group : this.groups) {\n+            if (group.contains(srcFo)) {\n+                return group;\n+            }\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    public URL[] computeRoots(Group group) {\n+        if (group.binDir != null) {\n+            return new URL[] { group.binDir.toURL() };\n+        } else {\n+            return new URL[0];\n+        }\n+    }\n+\n+    @Override\n+    public boolean computePreferBinaries(Group result) {\n+        return true;\n+    }\n+\n+    @Override\n+    public void computeChangeListener(Group result, boolean bln, ChangeListener cl) {\n+    }\n+\n+    @Override\n+    public SourceForBinaryQueryImplementation2.Result findSourceRoots2(URL url) {\n+        this.computeTransitiveDeps();\n+        for (Dist dist : this.distributions) {\n+            URL jar;\n+            try {\n+                jar = dist.getJarRoot();\n+                if (jar == null) {\n+                    continue;\n+                }\n+            } catch (MalformedURLException ok) {\n+                continue;\n+            }\n+            if (jar.equals(url)) {\n+                List<FileObject> roots = new ArrayList<>();\n+                for (Group d : dist.getContributingGroups()) {\n+                    roots.add(d.srcDir);\n+                    roots.add(d.srcGenDir);\n+                }\n+                return new ImmutableResult(roots.toArray(new FileObject[roots.size()]));\n+            }\n+        }\n+        for (Group group : this.groups) {\n+            if (group.binDir != null && group.binDir.toURL().equals(url)) {\n+                return new ImmutableResult(group.srcDir, group.srcGenDir);\n+            }\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    public SourceForBinaryQuery.Result findSourceRoots(URL url) {\n+        return findSourceRoots2(url);\n+    }\n+\n+    final Iterable<File> jdks() {\n+        Set<File> jdks = new LinkedHashSet<>();\n+        String home = System.getProperty(\"user.home\");\n+        if (home != null) {\n+            File userEnv = new File(new File(new File(home), \".mx\"), \"env\");\n+            findJdksInEnv(jdks, userEnv);\n+        }\n+        FileObject suiteEnv = dir.getFileObject(\"mx.\" + dir.getNameExt() + \"/env\");\n+        if (suiteEnv != null) {\n+            findJdksInEnv(jdks, FileUtil.toFile(suiteEnv));\n+        }\n+\n+        String javaHomeEnv = System.getenv(\"JAVA_HOME\");\n+        if (javaHomeEnv != null) {\n+            jdks.add(new File(javaHomeEnv));\n+        }\n+        String javaHomeProp = System.getProperty(\"java.home\");\n+        if (javaHomeProp != null) {\n+            jdks.add(new File(javaHomeProp));\n+        }\n+        return jdks;\n+    }\n+\n+    private void findJdksInEnv(Set<File> jdks, File env) {\n+        if (env == null || !env.isFile()) {\n+            return;\n+        }\n+        try (final FileInputStream is = new FileInputStream(env)) {\n+            Properties p = new Properties();\n+            p.load(is);\n+\n+            String javaHome = p.getProperty(\"JAVA_HOME\");\n+            if (javaHome != null) {\n+                jdks.add(new File(javaHome));\n+            }\n+\n+            String extraJavaHomes = p.getProperty(\"EXTRA_JAVA_HOMES\");\n+            if (extraJavaHomes != null) {\n+                for (String extraHome : extraJavaHomes.split(File.pathSeparator)) {\n+                    jdks.add(new File(extraHome));\n+                }\n+            }\n+        } catch (IOException ex) {\n+            Exceptions.printStackTrace(ex);\n+        }\n+    }\n+\n+    @Override\n+    public SourceLevelQueryImplementation2.Result getSourceLevel(FileObject fo) {\n+        Group g = findGroup(fo);\n+        if (g == null) {\n+            return null;\n+        }\n+        return new SourceLevelQueryImplementation2.Result2() {\n+            @Override\n+            public SourceLevelQuery.Profile getProfile() {\n+                return SourceLevelQuery.Profile.DEFAULT;\n+            }\n+\n+            @Override\n+            public String getSourceLevel() {\n+                return g.getCompliance().getSourceLevel();\n+            }\n+\n+            @Override\n+            public void addChangeListener(ChangeListener cl) {\n+            }\n+\n+            @Override\n+            public void removeChangeListener(ChangeListener cl) {\n+            }\n+        };\n+    }\n+\n+    @Override\n+    public Set<? extends Project> getSubprojects() {\n+        Set<Project> prjs = new HashSet<>();\n+        for (SuiteSources imp : imported.values()) {\n+            prjs.add(imp.prj);\n+        }\n+        return prjs;\n+    }\n+\n+    @Override\n+    public URL[] findUnitTests(FileObject fo) {\n+        return new URL[0];\n+    }\n+\n+    @Override\n+    public URL[] findSources(FileObject fo) {\n+        Group g = findGroup(fo);\n+        return g == null ? new URL[0] : new URL[] { g.getRootFolder().toURL() };\n+    }\n+\n+    static interface Dep extends Comparable<Dep> {\n+        String getName();\n+\n+        Collection<String> depNames();\n+\n+        Collection<Dep> allDeps();\n+\n+        void setAllDeps(Collection<Dep> set);\n+\n+        @Override\n+        public default int compareTo(Dep o) {\n+            return getName().compareTo(o.getName());\n+        }\n+\n+        SuiteSources owner();\n+    }\n+\n+    final class Dist implements Dep, FlaggedClassPathImplementation {\n+        final String name;\n+        final MxDistribution dist;\n+        Collection<Dep> allDeps;\n+        private final PropertyChangeSupport support = new PropertyChangeSupport(this);\n+        private Boolean exists;\n+        private Collection<Group> groups;\n+\n+        public Dist(String name, MxDistribution dist) {\n+            this.name = name;\n+            this.dist = dist;\n+        }\n+\n+        @Override\n+        public Collection<String> depNames() {\n+            Set<String> deps = new TreeSet<>();\n+            deps.addAll(dist.distDependencies());\n+            deps.addAll(dist.exclude());\n+            return deps;\n+        }\n+\n+        @Override\n+        public Collection<Dep> allDeps() {\n+            return this.allDeps;\n+        }\n+\n+        @Override\n+        public void setAllDeps(Collection<Dep> set) {\n+            this.allDeps = set;\n+        }\n+\n+        @Override\n+        public String getName() {\n+            return this.name;\n+        }\n+\n+        @Override\n+        public Set<ClassPath.Flag> getFlags() {\n+            return exists ? Collections.emptySet() : Collections.singleton(ClassPath.Flag.INCOMPLETE);\n+        }\n+\n+        private FileObject getJar(boolean ignore) {\n+            if (SuiteSources.this.dir == null) {\n+                return null;\n+            }\n+            FileObject dists = SuiteSources.this.dir.getFileObject(\"mxbuild/dists\");\n+            if (dists == null) {\n+                return null;\n+            }\n+            List<FileObject> dist = Arrays.stream(dists.getChildren()).filter((fo) -> fo.isFolder() && fo.getName().startsWith(\"jdk\")).collect(Collectors.toList());\n+            dist.sort((fo1, fo2) -> fo2.getName().compareTo(fo1.getName()));\n+            for (FileObject jdkDir : dist) {\n+                FileObject jar = jdkDir.getFileObject(name.toLowerCase().replace(\"_\", \"-\") + \".jar\");\n+                if (jar != null) {\n+                    return jar;\n+                }\n+            }\n+            FileObject jar = dists.getFileObject(name.toLowerCase().replace(\"_\", \"-\") + \".jar\");\n+            if (jar != null) {\n+                return jar;\n+            }\n+            return null;\n+        }\n+\n+        @Override\n+        public List<? extends PathResourceImplementation> getResources() {\n+            computeTransitiveDeps();\n+            FileObject jar = getJar(exists == null);\n+            final boolean existsNow = jar != null && jar.isData();\n+            if (exists == null) {\n+                exists = existsNow;\n+            } else {\n+                if (exists != existsNow) {\n+                    exists = existsNow;\n+                    support.firePropertyChange(PROP_FLAGS, !exists, (boolean) exists);\n+                }\n+            }\n+            if (jar != null) {\n+                PathResourceImplementation res;\n+                try {\n+                    res = ClassPathSupport.createResource(getJarRoot());\n+                    return Collections.singletonList(res);\n+                } catch (MalformedURLException ex) {\n+                    // OK\n+                }\n+            }\n+            return Collections.emptyList();\n+        }\n+\n+        private URL getJarRoot() throws MalformedURLException {\n+            FileObject jar = getJar(true);\n+            if (jar != null) {\n+                return new URL(\"jar:\" + jar.toURL() + \"!/\");\n+            } else {\n+                return null;\n+            }\n+        }\n+\n+        @Override\n+        public void addPropertyChangeListener(PropertyChangeListener pl) {\n+            support.addPropertyChangeListener(pl);\n+        }\n+\n+        @Override\n+        public void removePropertyChangeListener(PropertyChangeListener pl) {\n+            support.removePropertyChangeListener(pl);\n+        }\n+\n+        @Override\n+        public SuiteSources owner() {\n+            return SuiteSources.this;\n+        }\n+\n+        private void computeSourceRoots(Map<String, Dep> collectedDeps) {\n+            if (groups != null) {\n+                return;\n+            }\n+            Set<Group> contributingGroups = new LinkedHashSet<>();\n+            for (String d : this.dist.dependencies()) {\n+                Dep dep = collectedDeps.get(d);\n+                if (dep == null || dep.allDeps() == null) {\n+                    continue;\n+                }\n+                for (Dep d2 : dep.allDeps()) {\n+                    if (d2 instanceof Group) {\n+                        contributingGroups.add((Group) d2);\n+                    }\n+                }\n+            }\n+            for (String d : this.dist.distDependencies()) {\n+                final Dep anyDep = collectedDeps.get(d);\n+                if (anyDep instanceof Dist) {\n+                    Dist dep = (Dist) anyDep;\n+                    dep.computeSourceRoots(collectedDeps);\n+                    contributingGroups.removeAll(dep.getContributingGroups());\n+                }\n+            }\n+            groups = contributingGroups;\n+        }\n+\n+        public Collection<Group> getContributingGroups() {\n+            return groups;\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return \"Dist[name=\" + name + \"]\";\n+        }\n+    }\n+\n+    final class Group implements SourceGroup, Dep, AnnotationProcessingQuery.Result,\n+            Compliance.Provider {\n+        private final String mxName;\n+        private final MxProject mxPrj;\n+        private final FileObject srcDir;\n+        private final FileObject srcGenDir;\n+        private final FileObject binDir;\n+        private final String name;\n+        private final String displayName;\n+        private final Compliance compliance;\n+        private ClassPath sourceCP;\n+        private ClassPath cp;\n+        private ClassPath processorPath;\n+        private Collection<Dep> allDeps;\n+\n+        Group(String mxName, MxProject mxPrj, FileObject srcDir, FileObject srcGenDir, FileObject binDir, String name, String displayName) {\n+            this.mxName = mxName;\n+            this.mxPrj = mxPrj;\n+            this.srcDir = srcDir;\n+            this.srcGenDir = srcGenDir;\n+            this.binDir = binDir;\n+            this.name = name;\n+            this.displayName = displayName;\n+            this.compliance = Compliance.parse(mxPrj.javaCompliance());\n+        }\n+\n+        @Override\n+        public FileObject getRootFolder() {\n+            return srcDir;\n+        }\n+\n+        @Override\n+        public String getName() {\n+            return name;\n+        }\n+\n+        @Override\n+        public String getDisplayName() {\n+            return displayName;\n+        }\n+\n+        @Override\n+        public Icon getIcon(boolean opened) {\n+            return null;\n+        }\n+\n+        @Override\n+        public Compliance getCompliance() {\n+            return compliance;\n+        }\n+\n+        @Override\n+        public boolean contains(FileObject file) {\n+            if (file == srcDir || file == srcGenDir || FileUtil.isParentOf(srcDir, file) || (srcGenDir != null && FileUtil.isParentOf(srcGenDir, file))) {\n+                return true;\n+            }\n+            return false;\n+        }\n+\n+        @Override\n+        public void addPropertyChangeListener(PropertyChangeListener l) {\n+        }\n+\n+        @Override\n+        public void removePropertyChangeListener(PropertyChangeListener l) {\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return \"SuiteSources.Group[name=\" + name + \",rootFolder=\" + srcDir + \"]\"; // NOI18N\n+        }\n+\n+        ClassPath getSourceCP() {\n+            computeTransitiveDeps();\n+            return sourceCP;\n+        }\n+\n+        ClassPath getCP() {\n+            computeTransitiveDeps();\n+            return cp;\n+        }\n+\n+        @Override\n+        public Collection<String> depNames() {\n+            return mxPrj.dependencies();\n+        }\n+\n+        @Override\n+        public void setAllDeps(Collection<Dep> set) {\n+            allDeps = set;\n+        }\n+\n+        @Override\n+        public Collection<Dep> allDeps() {\n+            return allDeps;\n+        }\n+\n+        private void computeClassPath(Map<String, Dep> transDeps) {\n+            for (Dep d : transDeps.values()) {\n+                d.owner().computeTransitiveDeps();\n+            }\n+\n+            List<Group> arr = new ArrayList<>();\n+            List<ClassPathImplementation> libs = new ArrayList<>();\n+            processTransDep(transDeps.get(mxName), arr, libs);\n+            cp = composeClassPath(arr, libs);\n+            List<FileObject> roots = new ArrayList<>();\n+            if (srcDir != null) {\n+                roots.add(srcDir);\n+            }\n+            if (srcGenDir != null) {\n+                roots.add(srcGenDir);\n+            }\n+            sourceCP = ClassPathSupport.createClassPath(roots.toArray(new FileObject[roots.size()]));\n+\n+            if (mxPrj.annotationProcessors().isEmpty()) {\n+                processorPath = null;\n+            } else {\n+                List<Group> groups = new ArrayList<>();\n+                List<ClassPathImplementation> jars = new ArrayList<>();\n+                for (String dep : mxPrj.annotationProcessors()) {\n+                    processTransDep(transDeps.get(dep), groups, jars);\n+                }\n+                processorPath = composeClassPath(groups, jars);\n+            }\n+        }\n+\n+        private void processTransDep(Dep dep, List<Group> addGroups, List<ClassPathImplementation> addJars) {\n+            if (dep != null) {\n+                dep.owner().computeTransitiveDeps();\n+                for (Dep d : dep.allDeps()) {\n+                    if (d == this) {\n+                        continue;\n+                    }\n+                    d.owner().computeTransitiveDeps();\n+                    if (d instanceof Group) {\n+                        addGroups.add((Group) d);\n+                    } else if (d instanceof ClassPathImplementation) {\n+                        addJars.add((ClassPathImplementation) d);\n+                    }\n+                }\n+            }\n+        }\n+\n+        private ClassPath composeClassPath(List<Group> arr, List<ClassPathImplementation> libs) {\n+            Set<FileObject> roots = new LinkedHashSet<>();\n+            final int depsCount = arr.size();\n+            for (int i = 0; i < depsCount; i++) {\n+                final Group g = arr.get(i);\n+                if (g.binDir != null) {\n+                    roots.add(g.binDir);\n+                }\n+            }\n+            ClassPath prjCp = ClassPathSupport.createClassPath(roots.toArray(new FileObject[0]));\n+            if (!libs.isEmpty()) {\n+                if (libs.size() == 1) {\n+                    prjCp = ClassPathSupport.createProxyClassPath(prjCp,\n+                                                                  ClassPathFactory.createClassPath(libs.get(0))\n+                    );\n+                } else {\n+                    prjCp = ClassPathSupport.createProxyClassPath(prjCp,\n+                                                                  ClassPathFactory.createClassPath(\n+                                                                                  ClassPathSupport.createProxyClassPathImplementation(\n+                                                                                                  libs.toArray(new ClassPathImplementation[0])\n+                                                                                  )\n+                                                                  )\n+                    );\n+                }\n+            }\n+            return prjCp;\n+        }\n+\n+        ClassPath getProcessorCP() {\n+            computeTransitiveDeps();\n+            return processorPath;\n+        }\n+\n+        @Override\n+        public Set<? extends AnnotationProcessingQuery.Trigger> annotationProcessingEnabled() {\n+            return EnumSet.of(AnnotationProcessingQuery.Trigger.ON_SCAN, AnnotationProcessingQuery.Trigger.IN_EDITOR);\n+        }\n+\n+        @Override\n+        public Iterable<? extends String> annotationProcessorsToRun() {\n+            return null;\n+        }\n+\n+        @Override\n+        public URL sourceOutputDirectory() {\n+            return srcGenDir == null ? null : srcGenDir.toURL();\n+        }\n+\n+        @Override\n+        public Map<? extends String, ? extends String> processorOptions() {\n+            return Collections.emptyMap();\n+        }\n+\n+        @Override\n+        public void addChangeListener(ChangeListener l) {\n+        }\n+\n+        @Override\n+        public void removeChangeListener(ChangeListener l) {\n+        }\n+\n+        @Override\n+        public SuiteSources owner() {\n+            return SuiteSources.this;\n+        }\n+    }\n+\n+    private class Library implements FlaggedClassPathImplementation, Dep {\n+        final MxLibrary lib;\n+        final PropertyChangeSupport support = new PropertyChangeSupport(this);\n+        final String libName;\n+        Collection<Dep> allDeps;\n+        Boolean exists;\n+\n+        Library(String libName, MxLibrary lib) {\n+            this.libName = libName;\n+            this.lib = getOSSLibrary(lib);\n+        }\n+\n+        final MxLibrary getOSSLibrary(MxLibrary lib) {\n+            if (lib.sha1() == null && !lib.os_arch().isEmpty()) {\n+                Map<String, MxLibrary.Arch> os_dep_libs = lib.os_arch();\n+                String os = System.getProperty(\"os.name\").toLowerCase();\n+                for (Map.Entry<String, MxLibrary.Arch> entry : os_dep_libs.entrySet()) {\n+                    if (os.contains(entry.getKey())) {\n+                        return entry.getValue().amd64();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "21a2744fdd0de199cff1cdca7143f5498c4a4bdc"}, "originalPosition": 935}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODE3MjMyMw==", "bodyText": "better check exists != null as well", "url": "https://github.com/apache/netbeans/pull/2575#discussion_r538172323", "createdAt": "2020-12-08T09:24:40Z", "author": {"login": "sdedic"}, "path": "java/java.mx.project/src/org/netbeans/modules/java/mx/project/SuiteSources.java", "diffHunk": "@@ -0,0 +1,1195 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.netbeans.modules.java.mx.project;\n+\n+import java.beans.PropertyChangeListener;\n+import java.beans.PropertyChangeSupport;\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.IOException;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.EnumSet;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.LinkedHashMap;\n+import java.util.LinkedHashSet;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Properties;\n+import java.util.Set;\n+import java.util.TreeSet;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import javax.swing.Icon;\n+import javax.swing.event.ChangeListener;\n+import org.netbeans.modules.java.mx.project.suitepy.MxDistribution;\n+import org.netbeans.modules.java.mx.project.suitepy.MxImports;\n+import org.netbeans.modules.java.mx.project.suitepy.MxLibrary;\n+import org.netbeans.modules.java.mx.project.suitepy.MxProject;\n+import org.netbeans.modules.java.mx.project.suitepy.MxSuite;\n+import org.netbeans.api.java.classpath.ClassPath;\n+import org.netbeans.api.java.queries.AnnotationProcessingQuery;\n+import org.netbeans.api.java.queries.SourceForBinaryQuery;\n+import org.netbeans.api.project.Project;\n+import org.netbeans.api.project.ProjectManager;\n+import org.netbeans.api.project.SourceGroup;\n+import org.netbeans.api.project.Sources;\n+import org.netbeans.spi.java.classpath.ClassPathFactory;\n+import org.netbeans.spi.java.classpath.ClassPathImplementation;\n+import org.netbeans.spi.java.classpath.FlaggedClassPathImplementation;\n+import org.netbeans.spi.java.classpath.PathResourceImplementation;\n+import org.netbeans.spi.java.classpath.support.ClassPathSupport;\n+import org.netbeans.spi.java.queries.BinaryForSourceQueryImplementation2;\n+import org.netbeans.spi.java.queries.SourceForBinaryQueryImplementation2;\n+import org.openide.filesystems.FileObject;\n+import org.openide.filesystems.FileUtil;\n+import org.openide.filesystems.URLMapper;\n+import org.openide.util.Exceptions;\n+import org.openide.util.Utilities;\n+import java.util.stream.Collectors;\n+import org.netbeans.api.java.queries.SourceLevelQuery;\n+import org.netbeans.spi.java.queries.MultipleRootsUnitTestForSourceQueryImplementation;\n+import org.netbeans.spi.java.queries.SourceLevelQueryImplementation2;\n+import org.netbeans.spi.project.SubprojectProvider;\n+\n+final class SuiteSources implements Sources,\n+                BinaryForSourceQueryImplementation2<SuiteSources.Group>, SourceForBinaryQueryImplementation2,\n+                SourceLevelQueryImplementation2, SubprojectProvider, MultipleRootsUnitTestForSourceQueryImplementation {\n+    private static final Logger LOG = Logger.getLogger(SuiteSources.class.getName());\n+    private static final SuiteSources CORE;\n+\n+    static {\n+        MxSuite coreSuite = CoreSuite.CORE_5_279_0;\n+        CORE = new SuiteSources(null, null, coreSuite);\n+    }\n+\n+    private final MxSuite suite;\n+    private final List<Group> groups;\n+    private final List<Library> libraries;\n+    private final List<Dist> distributions;\n+    private final FileObject dir;\n+    /**\n+     * non-null if the dependencies haven't yet been properly initialized\n+     */\n+    private Map<String, Dep> transitiveDeps;\n+    /**\n+     * avoid GC of imported projects\n+     */\n+    private final SuiteProject prj;\n+    private final Map<String, SuiteSources> imported;\n+\n+    SuiteSources(SuiteProject owner, FileObject dir, MxSuite suite) {\n+        final Map<String, Dep> fillDeps = new HashMap<>();\n+        this.prj = owner;\n+        this.dir = dir;\n+        this.groups = findGroups(fillDeps, suite, dir);\n+        this.libraries = findLibraries(fillDeps, suite);\n+        this.imported = findImportedSuites(dir, suite, fillDeps);\n+        this.distributions = findDistributions(suite, this.libraries, this.groups, fillDeps);\n+        this.suite = suite;\n+        this.transitiveDeps = fillDeps;\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return \"MxSources[\" + (dir == null ? \"mx\" : dir.toURI()) + \"]\";\n+    }\n+\n+    private List<Group> findGroups(Map<String, Dep> fillDeps, MxSuite s, FileObject dir) {\n+        List<Group> arr = new ArrayList<>();\n+        for (Map.Entry<String, MxProject> entry : s.projects().entrySet()) {\n+            String name = entry.getKey();\n+            MxProject mxPrj = entry.getValue();\n+            FileObject prjDir = findPrjDir(dir, name, mxPrj);\n+            if (prjDir == null) {\n+                fillDeps.put(name, new Group(name, mxPrj, null, null, null, name, name));\n+                continue;\n+            }\n+            String prevName = null;\n+            Group firstGroup = null;\n+            String binPrefix;\n+            if (mxPrj.subDir() == null) {\n+                binPrefix = \"mxbuild/\";\n+            } else {\n+                binPrefix = \"mxbuild/\" + mxPrj.subDir() + \"/\";\n+            }\n+            for (String rel : mxPrj.sourceDirs()) {\n+                FileObject srcDir = prjDir.getFileObject(rel);\n+                FileObject binDir = getSubDir(dir, binPrefix + name + \"/bin\");\n+                FileObject srcGenDir = getSubDir(dir, binPrefix + name + \"/src_gen\");\n+                if (srcDir != null && binDir != null) {\n+                    String prgName = name + \"-\" + rel;\n+                    String displayName;\n+                    if (prevName == null) {\n+                        displayName = name;\n+                    } else {\n+                        displayName = name + \"[\" + rel + \"]\";\n+                    }\n+                    Group g = new Group(name, mxPrj, srcDir, srcGenDir, binDir, prgName, displayName);\n+                    arr.add(g);\n+                    if (firstGroup == null) {\n+                        firstGroup = g;\n+                    }\n+                    prevName = displayName;\n+                }\n+            }\n+            if (firstGroup != null) {\n+                fillDeps.put(name, firstGroup);\n+            }\n+        }\n+        return arr;\n+    }\n+\n+    private static FileObject getSubDir(FileObject dir, String relPath) {\n+        FileObject subDir = dir.getFileObject(relPath);\n+        if (subDir == null) {\n+            try {\n+                subDir = FileUtil.createFolder(dir, relPath);\n+            } catch (IOException ex) {\n+                Exceptions.printStackTrace(ex);\n+            }\n+        }\n+        return subDir;\n+    }\n+\n+    private List<Library> findLibraries(Map<String, Dep> fillDeps, MxSuite suite) {\n+        final Map<String, MxLibrary> allLibraries = new HashMap<>();\n+        registerLibs(allLibraries, null, suite.libraries());\n+\n+        List<Library> arr = new ArrayList<>();\n+        for (Map.Entry<String, MxLibrary> entry : allLibraries.entrySet()) {\n+            final Library library = new Library(entry.getKey(), entry.getValue());\n+            arr.add(library);\n+            fillDeps.put(library.getName(), library);\n+        }\n+        for (Map.Entry<String, MxLibrary> entry : suite.jdklibraries().entrySet()) {\n+            final JdkLibrary library = new JdkLibrary(entry.getKey(), entry.getValue());\n+            arr.add(library);\n+            fillDeps.put(library.getName(), library);\n+        }\n+        return arr;\n+    }\n+\n+    private static Map<String, SuiteSources> findImportedSuites(FileObject dir, MxSuite s, Map<String, Dep> fillDeps) {\n+        if (dir == null) {\n+            return Collections.emptyMap();\n+        }\n+        CORE.registerDeps(\"mx\", fillDeps);\n+        final MxImports imports = s.imports();\n+        if (imports != null) {\n+            Map<String, SuiteSources> imported = new LinkedHashMap<>();\n+            for (MxImports.Suite imp : imports.suites()) {\n+                SuiteSources impSources = findSuiteSources(dir, imp);\n+                final String suiteName = imp.name();\n+                if (impSources == null) {\n+                    LOG.log(Level.INFO, \"cannot find imported suite: {0}\", suiteName);\n+                    continue;\n+                }\n+                imported.put(suiteName, impSources);\n+                impSources.registerDeps(suiteName, fillDeps);\n+            }\n+            return imported;\n+        }\n+        return Collections.emptyMap();\n+    }\n+\n+    private List<Dist> findDistributions(MxSuite s, List<Library> libraries, List<Group> groups, Map<String, Dep> fillDeps) {\n+        List<Dist> dists = new ArrayList<>();\n+        for (Map.Entry<String, MxDistribution> entry : s.distributions().entrySet()) {\n+            Dist d = new Dist(entry.getKey(), entry.getValue());\n+            dists.add(d);\n+            fillDeps.put(d.getName(), d);\n+        }\n+        return dists;\n+    }\n+\n+    final synchronized void computeTransitiveDeps() {\n+        Map<String, Dep> collectedDeps = this.transitiveDeps;\n+        if (collectedDeps == null) {\n+            return;\n+        }\n+        this.transitiveDeps = null;\n+        for (Library l : this.libraries) {\n+            transitiveDeps(l, collectedDeps);\n+        }\n+        for (Group g : this.groups) {\n+            transitiveDeps(g, collectedDeps);\n+        }\n+        for (Dist d : this.distributions) {\n+            transitiveDeps(d, collectedDeps);\n+        }\n+        for (Group g : groups) {\n+            g.computeClassPath(collectedDeps);\n+        }\n+        for (Dist d : this.distributions) {\n+            d.computeSourceRoots(collectedDeps);\n+        }\n+    }\n+\n+    private static SuiteSources findSuiteSources(FileObject dir, MxImports.Suite imp) throws IllegalArgumentException {\n+        SuiteSources sources = findSuiteSources(dir.getParent(), imp.name());\n+        if (sources != null) {\n+            return sources;\n+        }\n+        if (imp.subdir()) {\n+            for (FileObject subDir : dir.getParent().getChildren()) {\n+                sources = findSuiteSources(subDir, imp.name());\n+                if (sources != null) {\n+                    return sources;\n+                }\n+            }\n+            for (FileObject subDir : dir.getParent().getParent().getChildren()) {\n+                sources = findSuiteSources(subDir, imp.name());\n+                if (sources != null) {\n+                    return sources;\n+                }\n+            }\n+        }\n+        return null;\n+    }\n+\n+    private static SuiteSources findSuiteSources(FileObject root, String name) throws IllegalArgumentException {\n+        FileObject impDir = root.getFileObject(name);\n+        if (impDir != null) {\n+            try {\n+                Project impPrj = ProjectManager.getDefault().findProject(impDir);\n+                return impPrj == null ? null : impPrj.getLookup().lookup(SuiteSources.class);\n+            } catch (IOException ex) {\n+                Exceptions.printStackTrace(ex);\n+            }\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    public SourceGroup[] getSourceGroups(String string) {\n+        return groups();\n+    }\n+\n+    Group[] groups() {\n+        return groups.toArray(new Group[0]);\n+    }\n+\n+    Group findGroup(FileObject fo) {\n+        for (Group g : groups) {\n+            if (g.contains(fo)) {\n+                return g;\n+            }\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    public void addChangeListener(ChangeListener cl) {\n+    }\n+\n+    @Override\n+    public void removeChangeListener(ChangeListener cl) {\n+    }\n+\n+    private static FileObject findPrjDir(FileObject dir, String prjName, MxProject prj) {\n+        if (dir == null) {\n+            return null;\n+        }\n+        if (prj.dir() != null) {\n+            return dir.getFileObject(prj.dir());\n+        }\n+        if (prj.subDir() != null) {\n+            dir = dir.getFileObject(prj.subDir());\n+            if (dir == null) {\n+                return null;\n+            }\n+        }\n+        return dir.getFileObject(prjName);\n+    }\n+\n+    private Collection<Dep> transitiveDeps(Dep current, Map<String, Dep> fill) {\n+        current.owner().computeTransitiveDeps();\n+        final Collection<Dep> currentAllDeps = current.allDeps();\n+        if (currentAllDeps == Collections.<Dep>emptySet()) {\n+            throw new IllegalStateException(\"Cyclic dep on \" + current.getName());\n+        } else if (currentAllDeps != null) {\n+            return currentAllDeps;\n+        }\n+        current.setAllDeps(Collections.emptySet());\n+        TreeSet<Dep> computing = new TreeSet<>();\n+        computing.add(current);\n+        for (String depName : current.depNames()) {\n+            Dep dep = fill.get(depName);\n+            if (dep == null) {\n+                int colon = depName.lastIndexOf(':');\n+                dep = fill.get(depName.substring(colon + 1));\n+                if (dep == null) {\n+                    LOG.log(Level.INFO, \"dep not found: {0}\", depName);\n+                    continue;\n+                }\n+            }\n+            Collection<Dep> allDeps = transitiveDeps(dep, fill);\n+            computing.addAll(allDeps);\n+        }\n+        current.setAllDeps(computing);\n+        return computing;\n+    }\n+\n+    private static void registerLibs(Map<String, MxLibrary> collect, String prefix, Map<String, MxLibrary> libraries) {\n+        for (Map.Entry<String, MxLibrary> entry : libraries.entrySet()) {\n+            String key = entry.getKey();\n+            MxLibrary lib = entry.getValue();\n+            if (prefix == null) {\n+                collect.put(key, lib);\n+            } else {\n+                collect.put(prefix + \":\" + key, lib);\n+            }\n+        }\n+    }\n+\n+    private void registerDeps(String prefix, Map<String, Dep> fillDeps) {\n+        for (Library library : libraries) {\n+            fillDeps.put(prefix + \":\" + library.getName(), library);\n+        }\n+        for (Dist d : distributions) {\n+            fillDeps.put(prefix + \":\" + d.getName(), d);\n+        }\n+        for (Map.Entry<String, SuiteSources> s : imported.entrySet()) {\n+            s.getValue().registerDeps(s.getKey(), fillDeps);\n+        }\n+    }\n+\n+    @Override\n+    public Group findBinaryRoots2(URL url) {\n+        final FileObject srcFo = URLMapper.findFileObject(url);\n+        for (Group group : this.groups) {\n+            if (group.contains(srcFo)) {\n+                return group;\n+            }\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    public URL[] computeRoots(Group group) {\n+        if (group.binDir != null) {\n+            return new URL[] { group.binDir.toURL() };\n+        } else {\n+            return new URL[0];\n+        }\n+    }\n+\n+    @Override\n+    public boolean computePreferBinaries(Group result) {\n+        return true;\n+    }\n+\n+    @Override\n+    public void computeChangeListener(Group result, boolean bln, ChangeListener cl) {\n+    }\n+\n+    @Override\n+    public SourceForBinaryQueryImplementation2.Result findSourceRoots2(URL url) {\n+        this.computeTransitiveDeps();\n+        for (Dist dist : this.distributions) {\n+            URL jar;\n+            try {\n+                jar = dist.getJarRoot();\n+                if (jar == null) {\n+                    continue;\n+                }\n+            } catch (MalformedURLException ok) {\n+                continue;\n+            }\n+            if (jar.equals(url)) {\n+                List<FileObject> roots = new ArrayList<>();\n+                for (Group d : dist.getContributingGroups()) {\n+                    roots.add(d.srcDir);\n+                    roots.add(d.srcGenDir);\n+                }\n+                return new ImmutableResult(roots.toArray(new FileObject[roots.size()]));\n+            }\n+        }\n+        for (Group group : this.groups) {\n+            if (group.binDir != null && group.binDir.toURL().equals(url)) {\n+                return new ImmutableResult(group.srcDir, group.srcGenDir);\n+            }\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    public SourceForBinaryQuery.Result findSourceRoots(URL url) {\n+        return findSourceRoots2(url);\n+    }\n+\n+    final Iterable<File> jdks() {\n+        Set<File> jdks = new LinkedHashSet<>();\n+        String home = System.getProperty(\"user.home\");\n+        if (home != null) {\n+            File userEnv = new File(new File(new File(home), \".mx\"), \"env\");\n+            findJdksInEnv(jdks, userEnv);\n+        }\n+        FileObject suiteEnv = dir.getFileObject(\"mx.\" + dir.getNameExt() + \"/env\");\n+        if (suiteEnv != null) {\n+            findJdksInEnv(jdks, FileUtil.toFile(suiteEnv));\n+        }\n+\n+        String javaHomeEnv = System.getenv(\"JAVA_HOME\");\n+        if (javaHomeEnv != null) {\n+            jdks.add(new File(javaHomeEnv));\n+        }\n+        String javaHomeProp = System.getProperty(\"java.home\");\n+        if (javaHomeProp != null) {\n+            jdks.add(new File(javaHomeProp));\n+        }\n+        return jdks;\n+    }\n+\n+    private void findJdksInEnv(Set<File> jdks, File env) {\n+        if (env == null || !env.isFile()) {\n+            return;\n+        }\n+        try (final FileInputStream is = new FileInputStream(env)) {\n+            Properties p = new Properties();\n+            p.load(is);\n+\n+            String javaHome = p.getProperty(\"JAVA_HOME\");\n+            if (javaHome != null) {\n+                jdks.add(new File(javaHome));\n+            }\n+\n+            String extraJavaHomes = p.getProperty(\"EXTRA_JAVA_HOMES\");\n+            if (extraJavaHomes != null) {\n+                for (String extraHome : extraJavaHomes.split(File.pathSeparator)) {\n+                    jdks.add(new File(extraHome));\n+                }\n+            }\n+        } catch (IOException ex) {\n+            Exceptions.printStackTrace(ex);\n+        }\n+    }\n+\n+    @Override\n+    public SourceLevelQueryImplementation2.Result getSourceLevel(FileObject fo) {\n+        Group g = findGroup(fo);\n+        if (g == null) {\n+            return null;\n+        }\n+        return new SourceLevelQueryImplementation2.Result2() {\n+            @Override\n+            public SourceLevelQuery.Profile getProfile() {\n+                return SourceLevelQuery.Profile.DEFAULT;\n+            }\n+\n+            @Override\n+            public String getSourceLevel() {\n+                return g.getCompliance().getSourceLevel();\n+            }\n+\n+            @Override\n+            public void addChangeListener(ChangeListener cl) {\n+            }\n+\n+            @Override\n+            public void removeChangeListener(ChangeListener cl) {\n+            }\n+        };\n+    }\n+\n+    @Override\n+    public Set<? extends Project> getSubprojects() {\n+        Set<Project> prjs = new HashSet<>();\n+        for (SuiteSources imp : imported.values()) {\n+            prjs.add(imp.prj);\n+        }\n+        return prjs;\n+    }\n+\n+    @Override\n+    public URL[] findUnitTests(FileObject fo) {\n+        return new URL[0];\n+    }\n+\n+    @Override\n+    public URL[] findSources(FileObject fo) {\n+        Group g = findGroup(fo);\n+        return g == null ? new URL[0] : new URL[] { g.getRootFolder().toURL() };\n+    }\n+\n+    static interface Dep extends Comparable<Dep> {\n+        String getName();\n+\n+        Collection<String> depNames();\n+\n+        Collection<Dep> allDeps();\n+\n+        void setAllDeps(Collection<Dep> set);\n+\n+        @Override\n+        public default int compareTo(Dep o) {\n+            return getName().compareTo(o.getName());\n+        }\n+\n+        SuiteSources owner();\n+    }\n+\n+    final class Dist implements Dep, FlaggedClassPathImplementation {\n+        final String name;\n+        final MxDistribution dist;\n+        Collection<Dep> allDeps;\n+        private final PropertyChangeSupport support = new PropertyChangeSupport(this);\n+        private Boolean exists;\n+        private Collection<Group> groups;\n+\n+        public Dist(String name, MxDistribution dist) {\n+            this.name = name;\n+            this.dist = dist;\n+        }\n+\n+        @Override\n+        public Collection<String> depNames() {\n+            Set<String> deps = new TreeSet<>();\n+            deps.addAll(dist.distDependencies());\n+            deps.addAll(dist.exclude());\n+            return deps;\n+        }\n+\n+        @Override\n+        public Collection<Dep> allDeps() {\n+            return this.allDeps;\n+        }\n+\n+        @Override\n+        public void setAllDeps(Collection<Dep> set) {\n+            this.allDeps = set;\n+        }\n+\n+        @Override\n+        public String getName() {\n+            return this.name;\n+        }\n+\n+        @Override\n+        public Set<ClassPath.Flag> getFlags() {\n+            return exists ? Collections.emptySet() : Collections.singleton(ClassPath.Flag.INCOMPLETE);\n+        }\n+\n+        private FileObject getJar(boolean ignore) {\n+            if (SuiteSources.this.dir == null) {\n+                return null;\n+            }\n+            FileObject dists = SuiteSources.this.dir.getFileObject(\"mxbuild/dists\");\n+            if (dists == null) {\n+                return null;\n+            }\n+            List<FileObject> dist = Arrays.stream(dists.getChildren()).filter((fo) -> fo.isFolder() && fo.getName().startsWith(\"jdk\")).collect(Collectors.toList());\n+            dist.sort((fo1, fo2) -> fo2.getName().compareTo(fo1.getName()));\n+            for (FileObject jdkDir : dist) {\n+                FileObject jar = jdkDir.getFileObject(name.toLowerCase().replace(\"_\", \"-\") + \".jar\");\n+                if (jar != null) {\n+                    return jar;\n+                }\n+            }\n+            FileObject jar = dists.getFileObject(name.toLowerCase().replace(\"_\", \"-\") + \".jar\");\n+            if (jar != null) {\n+                return jar;\n+            }\n+            return null;\n+        }\n+\n+        @Override\n+        public List<? extends PathResourceImplementation> getResources() {\n+            computeTransitiveDeps();\n+            FileObject jar = getJar(exists == null);\n+            final boolean existsNow = jar != null && jar.isData();\n+            if (exists == null) {\n+                exists = existsNow;\n+            } else {\n+                if (exists != existsNow) {\n+                    exists = existsNow;\n+                    support.firePropertyChange(PROP_FLAGS, !exists, (boolean) exists);\n+                }\n+            }\n+            if (jar != null) {\n+                PathResourceImplementation res;\n+                try {\n+                    res = ClassPathSupport.createResource(getJarRoot());\n+                    return Collections.singletonList(res);\n+                } catch (MalformedURLException ex) {\n+                    // OK\n+                }\n+            }\n+            return Collections.emptyList();\n+        }\n+\n+        private URL getJarRoot() throws MalformedURLException {\n+            FileObject jar = getJar(true);\n+            if (jar != null) {\n+                return new URL(\"jar:\" + jar.toURL() + \"!/\");\n+            } else {\n+                return null;\n+            }\n+        }\n+\n+        @Override\n+        public void addPropertyChangeListener(PropertyChangeListener pl) {\n+            support.addPropertyChangeListener(pl);\n+        }\n+\n+        @Override\n+        public void removePropertyChangeListener(PropertyChangeListener pl) {\n+            support.removePropertyChangeListener(pl);\n+        }\n+\n+        @Override\n+        public SuiteSources owner() {\n+            return SuiteSources.this;\n+        }\n+\n+        private void computeSourceRoots(Map<String, Dep> collectedDeps) {\n+            if (groups != null) {\n+                return;\n+            }\n+            Set<Group> contributingGroups = new LinkedHashSet<>();\n+            for (String d : this.dist.dependencies()) {\n+                Dep dep = collectedDeps.get(d);\n+                if (dep == null || dep.allDeps() == null) {\n+                    continue;\n+                }\n+                for (Dep d2 : dep.allDeps()) {\n+                    if (d2 instanceof Group) {\n+                        contributingGroups.add((Group) d2);\n+                    }\n+                }\n+            }\n+            for (String d : this.dist.distDependencies()) {\n+                final Dep anyDep = collectedDeps.get(d);\n+                if (anyDep instanceof Dist) {\n+                    Dist dep = (Dist) anyDep;\n+                    dep.computeSourceRoots(collectedDeps);\n+                    contributingGroups.removeAll(dep.getContributingGroups());\n+                }\n+            }\n+            groups = contributingGroups;\n+        }\n+\n+        public Collection<Group> getContributingGroups() {\n+            return groups;\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return \"Dist[name=\" + name + \"]\";\n+        }\n+    }\n+\n+    final class Group implements SourceGroup, Dep, AnnotationProcessingQuery.Result,\n+            Compliance.Provider {\n+        private final String mxName;\n+        private final MxProject mxPrj;\n+        private final FileObject srcDir;\n+        private final FileObject srcGenDir;\n+        private final FileObject binDir;\n+        private final String name;\n+        private final String displayName;\n+        private final Compliance compliance;\n+        private ClassPath sourceCP;\n+        private ClassPath cp;\n+        private ClassPath processorPath;\n+        private Collection<Dep> allDeps;\n+\n+        Group(String mxName, MxProject mxPrj, FileObject srcDir, FileObject srcGenDir, FileObject binDir, String name, String displayName) {\n+            this.mxName = mxName;\n+            this.mxPrj = mxPrj;\n+            this.srcDir = srcDir;\n+            this.srcGenDir = srcGenDir;\n+            this.binDir = binDir;\n+            this.name = name;\n+            this.displayName = displayName;\n+            this.compliance = Compliance.parse(mxPrj.javaCompliance());\n+        }\n+\n+        @Override\n+        public FileObject getRootFolder() {\n+            return srcDir;\n+        }\n+\n+        @Override\n+        public String getName() {\n+            return name;\n+        }\n+\n+        @Override\n+        public String getDisplayName() {\n+            return displayName;\n+        }\n+\n+        @Override\n+        public Icon getIcon(boolean opened) {\n+            return null;\n+        }\n+\n+        @Override\n+        public Compliance getCompliance() {\n+            return compliance;\n+        }\n+\n+        @Override\n+        public boolean contains(FileObject file) {\n+            if (file == srcDir || file == srcGenDir || FileUtil.isParentOf(srcDir, file) || (srcGenDir != null && FileUtil.isParentOf(srcGenDir, file))) {\n+                return true;\n+            }\n+            return false;\n+        }\n+\n+        @Override\n+        public void addPropertyChangeListener(PropertyChangeListener l) {\n+        }\n+\n+        @Override\n+        public void removePropertyChangeListener(PropertyChangeListener l) {\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return \"SuiteSources.Group[name=\" + name + \",rootFolder=\" + srcDir + \"]\"; // NOI18N\n+        }\n+\n+        ClassPath getSourceCP() {\n+            computeTransitiveDeps();\n+            return sourceCP;\n+        }\n+\n+        ClassPath getCP() {\n+            computeTransitiveDeps();\n+            return cp;\n+        }\n+\n+        @Override\n+        public Collection<String> depNames() {\n+            return mxPrj.dependencies();\n+        }\n+\n+        @Override\n+        public void setAllDeps(Collection<Dep> set) {\n+            allDeps = set;\n+        }\n+\n+        @Override\n+        public Collection<Dep> allDeps() {\n+            return allDeps;\n+        }\n+\n+        private void computeClassPath(Map<String, Dep> transDeps) {\n+            for (Dep d : transDeps.values()) {\n+                d.owner().computeTransitiveDeps();\n+            }\n+\n+            List<Group> arr = new ArrayList<>();\n+            List<ClassPathImplementation> libs = new ArrayList<>();\n+            processTransDep(transDeps.get(mxName), arr, libs);\n+            cp = composeClassPath(arr, libs);\n+            List<FileObject> roots = new ArrayList<>();\n+            if (srcDir != null) {\n+                roots.add(srcDir);\n+            }\n+            if (srcGenDir != null) {\n+                roots.add(srcGenDir);\n+            }\n+            sourceCP = ClassPathSupport.createClassPath(roots.toArray(new FileObject[roots.size()]));\n+\n+            if (mxPrj.annotationProcessors().isEmpty()) {\n+                processorPath = null;\n+            } else {\n+                List<Group> groups = new ArrayList<>();\n+                List<ClassPathImplementation> jars = new ArrayList<>();\n+                for (String dep : mxPrj.annotationProcessors()) {\n+                    processTransDep(transDeps.get(dep), groups, jars);\n+                }\n+                processorPath = composeClassPath(groups, jars);\n+            }\n+        }\n+\n+        private void processTransDep(Dep dep, List<Group> addGroups, List<ClassPathImplementation> addJars) {\n+            if (dep != null) {\n+                dep.owner().computeTransitiveDeps();\n+                for (Dep d : dep.allDeps()) {\n+                    if (d == this) {\n+                        continue;\n+                    }\n+                    d.owner().computeTransitiveDeps();\n+                    if (d instanceof Group) {\n+                        addGroups.add((Group) d);\n+                    } else if (d instanceof ClassPathImplementation) {\n+                        addJars.add((ClassPathImplementation) d);\n+                    }\n+                }\n+            }\n+        }\n+\n+        private ClassPath composeClassPath(List<Group> arr, List<ClassPathImplementation> libs) {\n+            Set<FileObject> roots = new LinkedHashSet<>();\n+            final int depsCount = arr.size();\n+            for (int i = 0; i < depsCount; i++) {\n+                final Group g = arr.get(i);\n+                if (g.binDir != null) {\n+                    roots.add(g.binDir);\n+                }\n+            }\n+            ClassPath prjCp = ClassPathSupport.createClassPath(roots.toArray(new FileObject[0]));\n+            if (!libs.isEmpty()) {\n+                if (libs.size() == 1) {\n+                    prjCp = ClassPathSupport.createProxyClassPath(prjCp,\n+                                                                  ClassPathFactory.createClassPath(libs.get(0))\n+                    );\n+                } else {\n+                    prjCp = ClassPathSupport.createProxyClassPath(prjCp,\n+                                                                  ClassPathFactory.createClassPath(\n+                                                                                  ClassPathSupport.createProxyClassPathImplementation(\n+                                                                                                  libs.toArray(new ClassPathImplementation[0])\n+                                                                                  )\n+                                                                  )\n+                    );\n+                }\n+            }\n+            return prjCp;\n+        }\n+\n+        ClassPath getProcessorCP() {\n+            computeTransitiveDeps();\n+            return processorPath;\n+        }\n+\n+        @Override\n+        public Set<? extends AnnotationProcessingQuery.Trigger> annotationProcessingEnabled() {\n+            return EnumSet.of(AnnotationProcessingQuery.Trigger.ON_SCAN, AnnotationProcessingQuery.Trigger.IN_EDITOR);\n+        }\n+\n+        @Override\n+        public Iterable<? extends String> annotationProcessorsToRun() {\n+            return null;\n+        }\n+\n+        @Override\n+        public URL sourceOutputDirectory() {\n+            return srcGenDir == null ? null : srcGenDir.toURL();\n+        }\n+\n+        @Override\n+        public Map<? extends String, ? extends String> processorOptions() {\n+            return Collections.emptyMap();\n+        }\n+\n+        @Override\n+        public void addChangeListener(ChangeListener l) {\n+        }\n+\n+        @Override\n+        public void removeChangeListener(ChangeListener l) {\n+        }\n+\n+        @Override\n+        public SuiteSources owner() {\n+            return SuiteSources.this;\n+        }\n+    }\n+\n+    private class Library implements FlaggedClassPathImplementation, Dep {\n+        final MxLibrary lib;\n+        final PropertyChangeSupport support = new PropertyChangeSupport(this);\n+        final String libName;\n+        Collection<Dep> allDeps;\n+        Boolean exists;\n+\n+        Library(String libName, MxLibrary lib) {\n+            this.libName = libName;\n+            this.lib = getOSSLibrary(lib);\n+        }\n+\n+        final MxLibrary getOSSLibrary(MxLibrary lib) {\n+            if (lib.sha1() == null && !lib.os_arch().isEmpty()) {\n+                Map<String, MxLibrary.Arch> os_dep_libs = lib.os_arch();\n+                String os = System.getProperty(\"os.name\").toLowerCase();\n+                for (Map.Entry<String, MxLibrary.Arch> entry : os_dep_libs.entrySet()) {\n+                    if (os.contains(entry.getKey())) {\n+                        return entry.getValue().amd64();\n+                    }\n+                }\n+            }\n+            return lib;\n+        }\n+\n+        File getJar(boolean dumpIfMissing) {\n+            File mxCache;\n+            String cache = System.getenv(\"MX_CACHE_DIR\");\n+            if (cache != null) {\n+                mxCache = new File(cache);\n+            } else {\n+                mxCache = new File(new File(new File(System.getProperty(\"user.home\")), \".mx\"), \"cache\");\n+            }\n+            int prefix = libName.indexOf(':');\n+            final String simpleName = libName.substring(prefix + 1);\n+\n+            File simpleJar = new File(mxCache, simpleName + \"_\" + lib.sha1() + \".jar\");\n+            if (simpleJar.exists()) {\n+                return simpleJar;\n+            }\n+            File dir = new File(mxCache, simpleName + \"_\" + lib.sha1());\n+            File jar = new File(dir, simpleName.replace('_', '-').toLowerCase(Locale.ENGLISH) + \".jar\");\n+\n+            if (dumpIfMissing && !jar.exists()) {\n+                for (File f = jar;; f = f.getParentFile()) {\n+                    if (!f.exists()) {\n+                        LOG.log(Level.WARNING, \"{0} does not exist\", f);\n+                    } else {\n+                        StringBuilder sb = new StringBuilder();\n+                        sb.append(f).append(\" exists:\\n\");\n+                        String[] kids = f.list();\n+                        if (kids != null) {\n+                            for (String n : kids) {\n+                                sb.append(\"  \").append(n).append(\"\\n\");\n+                            }\n+                        }\n+                        LOG.log(Level.INFO, sb.toString());\n+                        break;\n+                    }\n+                }\n+            }\n+            return jar;\n+        }\n+\n+        @Override\n+        public String getName() {\n+            return libName;\n+        }\n+\n+        @Override\n+        public Collection<String> depNames() {\n+            return lib.dependencies();\n+        }\n+\n+        @Override\n+        public Collection<Dep> allDeps() {\n+            return allDeps;\n+        }\n+\n+        @Override\n+        public void setAllDeps(Collection<Dep> set) {\n+            this.allDeps = set;\n+        }\n+\n+        @Override\n+        public Set<ClassPath.Flag> getFlags() {\n+            return exists ? Collections.emptySet() : Collections.singleton(ClassPath.Flag.INCOMPLETE);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "21a2744fdd0de199cff1cdca7143f5498c4a4bdc"}, "originalPosition": 1003}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODE3MjM3Nw==", "bodyText": "Can be somehow shared with Library implementation ?", "url": "https://github.com/apache/netbeans/pull/2575#discussion_r538172377", "createdAt": "2020-12-08T09:24:44Z", "author": {"login": "sdedic"}, "path": "java/java.mx.project/src/org/netbeans/modules/java/mx/project/SuiteSources.java", "diffHunk": "@@ -0,0 +1,1195 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.netbeans.modules.java.mx.project;\n+\n+import java.beans.PropertyChangeListener;\n+import java.beans.PropertyChangeSupport;\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.IOException;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.EnumSet;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.LinkedHashMap;\n+import java.util.LinkedHashSet;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Properties;\n+import java.util.Set;\n+import java.util.TreeSet;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import javax.swing.Icon;\n+import javax.swing.event.ChangeListener;\n+import org.netbeans.modules.java.mx.project.suitepy.MxDistribution;\n+import org.netbeans.modules.java.mx.project.suitepy.MxImports;\n+import org.netbeans.modules.java.mx.project.suitepy.MxLibrary;\n+import org.netbeans.modules.java.mx.project.suitepy.MxProject;\n+import org.netbeans.modules.java.mx.project.suitepy.MxSuite;\n+import org.netbeans.api.java.classpath.ClassPath;\n+import org.netbeans.api.java.queries.AnnotationProcessingQuery;\n+import org.netbeans.api.java.queries.SourceForBinaryQuery;\n+import org.netbeans.api.project.Project;\n+import org.netbeans.api.project.ProjectManager;\n+import org.netbeans.api.project.SourceGroup;\n+import org.netbeans.api.project.Sources;\n+import org.netbeans.spi.java.classpath.ClassPathFactory;\n+import org.netbeans.spi.java.classpath.ClassPathImplementation;\n+import org.netbeans.spi.java.classpath.FlaggedClassPathImplementation;\n+import org.netbeans.spi.java.classpath.PathResourceImplementation;\n+import org.netbeans.spi.java.classpath.support.ClassPathSupport;\n+import org.netbeans.spi.java.queries.BinaryForSourceQueryImplementation2;\n+import org.netbeans.spi.java.queries.SourceForBinaryQueryImplementation2;\n+import org.openide.filesystems.FileObject;\n+import org.openide.filesystems.FileUtil;\n+import org.openide.filesystems.URLMapper;\n+import org.openide.util.Exceptions;\n+import org.openide.util.Utilities;\n+import java.util.stream.Collectors;\n+import org.netbeans.api.java.queries.SourceLevelQuery;\n+import org.netbeans.spi.java.queries.MultipleRootsUnitTestForSourceQueryImplementation;\n+import org.netbeans.spi.java.queries.SourceLevelQueryImplementation2;\n+import org.netbeans.spi.project.SubprojectProvider;\n+\n+final class SuiteSources implements Sources,\n+                BinaryForSourceQueryImplementation2<SuiteSources.Group>, SourceForBinaryQueryImplementation2,\n+                SourceLevelQueryImplementation2, SubprojectProvider, MultipleRootsUnitTestForSourceQueryImplementation {\n+    private static final Logger LOG = Logger.getLogger(SuiteSources.class.getName());\n+    private static final SuiteSources CORE;\n+\n+    static {\n+        MxSuite coreSuite = CoreSuite.CORE_5_279_0;\n+        CORE = new SuiteSources(null, null, coreSuite);\n+    }\n+\n+    private final MxSuite suite;\n+    private final List<Group> groups;\n+    private final List<Library> libraries;\n+    private final List<Dist> distributions;\n+    private final FileObject dir;\n+    /**\n+     * non-null if the dependencies haven't yet been properly initialized\n+     */\n+    private Map<String, Dep> transitiveDeps;\n+    /**\n+     * avoid GC of imported projects\n+     */\n+    private final SuiteProject prj;\n+    private final Map<String, SuiteSources> imported;\n+\n+    SuiteSources(SuiteProject owner, FileObject dir, MxSuite suite) {\n+        final Map<String, Dep> fillDeps = new HashMap<>();\n+        this.prj = owner;\n+        this.dir = dir;\n+        this.groups = findGroups(fillDeps, suite, dir);\n+        this.libraries = findLibraries(fillDeps, suite);\n+        this.imported = findImportedSuites(dir, suite, fillDeps);\n+        this.distributions = findDistributions(suite, this.libraries, this.groups, fillDeps);\n+        this.suite = suite;\n+        this.transitiveDeps = fillDeps;\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return \"MxSources[\" + (dir == null ? \"mx\" : dir.toURI()) + \"]\";\n+    }\n+\n+    private List<Group> findGroups(Map<String, Dep> fillDeps, MxSuite s, FileObject dir) {\n+        List<Group> arr = new ArrayList<>();\n+        for (Map.Entry<String, MxProject> entry : s.projects().entrySet()) {\n+            String name = entry.getKey();\n+            MxProject mxPrj = entry.getValue();\n+            FileObject prjDir = findPrjDir(dir, name, mxPrj);\n+            if (prjDir == null) {\n+                fillDeps.put(name, new Group(name, mxPrj, null, null, null, name, name));\n+                continue;\n+            }\n+            String prevName = null;\n+            Group firstGroup = null;\n+            String binPrefix;\n+            if (mxPrj.subDir() == null) {\n+                binPrefix = \"mxbuild/\";\n+            } else {\n+                binPrefix = \"mxbuild/\" + mxPrj.subDir() + \"/\";\n+            }\n+            for (String rel : mxPrj.sourceDirs()) {\n+                FileObject srcDir = prjDir.getFileObject(rel);\n+                FileObject binDir = getSubDir(dir, binPrefix + name + \"/bin\");\n+                FileObject srcGenDir = getSubDir(dir, binPrefix + name + \"/src_gen\");\n+                if (srcDir != null && binDir != null) {\n+                    String prgName = name + \"-\" + rel;\n+                    String displayName;\n+                    if (prevName == null) {\n+                        displayName = name;\n+                    } else {\n+                        displayName = name + \"[\" + rel + \"]\";\n+                    }\n+                    Group g = new Group(name, mxPrj, srcDir, srcGenDir, binDir, prgName, displayName);\n+                    arr.add(g);\n+                    if (firstGroup == null) {\n+                        firstGroup = g;\n+                    }\n+                    prevName = displayName;\n+                }\n+            }\n+            if (firstGroup != null) {\n+                fillDeps.put(name, firstGroup);\n+            }\n+        }\n+        return arr;\n+    }\n+\n+    private static FileObject getSubDir(FileObject dir, String relPath) {\n+        FileObject subDir = dir.getFileObject(relPath);\n+        if (subDir == null) {\n+            try {\n+                subDir = FileUtil.createFolder(dir, relPath);\n+            } catch (IOException ex) {\n+                Exceptions.printStackTrace(ex);\n+            }\n+        }\n+        return subDir;\n+    }\n+\n+    private List<Library> findLibraries(Map<String, Dep> fillDeps, MxSuite suite) {\n+        final Map<String, MxLibrary> allLibraries = new HashMap<>();\n+        registerLibs(allLibraries, null, suite.libraries());\n+\n+        List<Library> arr = new ArrayList<>();\n+        for (Map.Entry<String, MxLibrary> entry : allLibraries.entrySet()) {\n+            final Library library = new Library(entry.getKey(), entry.getValue());\n+            arr.add(library);\n+            fillDeps.put(library.getName(), library);\n+        }\n+        for (Map.Entry<String, MxLibrary> entry : suite.jdklibraries().entrySet()) {\n+            final JdkLibrary library = new JdkLibrary(entry.getKey(), entry.getValue());\n+            arr.add(library);\n+            fillDeps.put(library.getName(), library);\n+        }\n+        return arr;\n+    }\n+\n+    private static Map<String, SuiteSources> findImportedSuites(FileObject dir, MxSuite s, Map<String, Dep> fillDeps) {\n+        if (dir == null) {\n+            return Collections.emptyMap();\n+        }\n+        CORE.registerDeps(\"mx\", fillDeps);\n+        final MxImports imports = s.imports();\n+        if (imports != null) {\n+            Map<String, SuiteSources> imported = new LinkedHashMap<>();\n+            for (MxImports.Suite imp : imports.suites()) {\n+                SuiteSources impSources = findSuiteSources(dir, imp);\n+                final String suiteName = imp.name();\n+                if (impSources == null) {\n+                    LOG.log(Level.INFO, \"cannot find imported suite: {0}\", suiteName);\n+                    continue;\n+                }\n+                imported.put(suiteName, impSources);\n+                impSources.registerDeps(suiteName, fillDeps);\n+            }\n+            return imported;\n+        }\n+        return Collections.emptyMap();\n+    }\n+\n+    private List<Dist> findDistributions(MxSuite s, List<Library> libraries, List<Group> groups, Map<String, Dep> fillDeps) {\n+        List<Dist> dists = new ArrayList<>();\n+        for (Map.Entry<String, MxDistribution> entry : s.distributions().entrySet()) {\n+            Dist d = new Dist(entry.getKey(), entry.getValue());\n+            dists.add(d);\n+            fillDeps.put(d.getName(), d);\n+        }\n+        return dists;\n+    }\n+\n+    final synchronized void computeTransitiveDeps() {\n+        Map<String, Dep> collectedDeps = this.transitiveDeps;\n+        if (collectedDeps == null) {\n+            return;\n+        }\n+        this.transitiveDeps = null;\n+        for (Library l : this.libraries) {\n+            transitiveDeps(l, collectedDeps);\n+        }\n+        for (Group g : this.groups) {\n+            transitiveDeps(g, collectedDeps);\n+        }\n+        for (Dist d : this.distributions) {\n+            transitiveDeps(d, collectedDeps);\n+        }\n+        for (Group g : groups) {\n+            g.computeClassPath(collectedDeps);\n+        }\n+        for (Dist d : this.distributions) {\n+            d.computeSourceRoots(collectedDeps);\n+        }\n+    }\n+\n+    private static SuiteSources findSuiteSources(FileObject dir, MxImports.Suite imp) throws IllegalArgumentException {\n+        SuiteSources sources = findSuiteSources(dir.getParent(), imp.name());\n+        if (sources != null) {\n+            return sources;\n+        }\n+        if (imp.subdir()) {\n+            for (FileObject subDir : dir.getParent().getChildren()) {\n+                sources = findSuiteSources(subDir, imp.name());\n+                if (sources != null) {\n+                    return sources;\n+                }\n+            }\n+            for (FileObject subDir : dir.getParent().getParent().getChildren()) {\n+                sources = findSuiteSources(subDir, imp.name());\n+                if (sources != null) {\n+                    return sources;\n+                }\n+            }\n+        }\n+        return null;\n+    }\n+\n+    private static SuiteSources findSuiteSources(FileObject root, String name) throws IllegalArgumentException {\n+        FileObject impDir = root.getFileObject(name);\n+        if (impDir != null) {\n+            try {\n+                Project impPrj = ProjectManager.getDefault().findProject(impDir);\n+                return impPrj == null ? null : impPrj.getLookup().lookup(SuiteSources.class);\n+            } catch (IOException ex) {\n+                Exceptions.printStackTrace(ex);\n+            }\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    public SourceGroup[] getSourceGroups(String string) {\n+        return groups();\n+    }\n+\n+    Group[] groups() {\n+        return groups.toArray(new Group[0]);\n+    }\n+\n+    Group findGroup(FileObject fo) {\n+        for (Group g : groups) {\n+            if (g.contains(fo)) {\n+                return g;\n+            }\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    public void addChangeListener(ChangeListener cl) {\n+    }\n+\n+    @Override\n+    public void removeChangeListener(ChangeListener cl) {\n+    }\n+\n+    private static FileObject findPrjDir(FileObject dir, String prjName, MxProject prj) {\n+        if (dir == null) {\n+            return null;\n+        }\n+        if (prj.dir() != null) {\n+            return dir.getFileObject(prj.dir());\n+        }\n+        if (prj.subDir() != null) {\n+            dir = dir.getFileObject(prj.subDir());\n+            if (dir == null) {\n+                return null;\n+            }\n+        }\n+        return dir.getFileObject(prjName);\n+    }\n+\n+    private Collection<Dep> transitiveDeps(Dep current, Map<String, Dep> fill) {\n+        current.owner().computeTransitiveDeps();\n+        final Collection<Dep> currentAllDeps = current.allDeps();\n+        if (currentAllDeps == Collections.<Dep>emptySet()) {\n+            throw new IllegalStateException(\"Cyclic dep on \" + current.getName());\n+        } else if (currentAllDeps != null) {\n+            return currentAllDeps;\n+        }\n+        current.setAllDeps(Collections.emptySet());\n+        TreeSet<Dep> computing = new TreeSet<>();\n+        computing.add(current);\n+        for (String depName : current.depNames()) {\n+            Dep dep = fill.get(depName);\n+            if (dep == null) {\n+                int colon = depName.lastIndexOf(':');\n+                dep = fill.get(depName.substring(colon + 1));\n+                if (dep == null) {\n+                    LOG.log(Level.INFO, \"dep not found: {0}\", depName);\n+                    continue;\n+                }\n+            }\n+            Collection<Dep> allDeps = transitiveDeps(dep, fill);\n+            computing.addAll(allDeps);\n+        }\n+        current.setAllDeps(computing);\n+        return computing;\n+    }\n+\n+    private static void registerLibs(Map<String, MxLibrary> collect, String prefix, Map<String, MxLibrary> libraries) {\n+        for (Map.Entry<String, MxLibrary> entry : libraries.entrySet()) {\n+            String key = entry.getKey();\n+            MxLibrary lib = entry.getValue();\n+            if (prefix == null) {\n+                collect.put(key, lib);\n+            } else {\n+                collect.put(prefix + \":\" + key, lib);\n+            }\n+        }\n+    }\n+\n+    private void registerDeps(String prefix, Map<String, Dep> fillDeps) {\n+        for (Library library : libraries) {\n+            fillDeps.put(prefix + \":\" + library.getName(), library);\n+        }\n+        for (Dist d : distributions) {\n+            fillDeps.put(prefix + \":\" + d.getName(), d);\n+        }\n+        for (Map.Entry<String, SuiteSources> s : imported.entrySet()) {\n+            s.getValue().registerDeps(s.getKey(), fillDeps);\n+        }\n+    }\n+\n+    @Override\n+    public Group findBinaryRoots2(URL url) {\n+        final FileObject srcFo = URLMapper.findFileObject(url);\n+        for (Group group : this.groups) {\n+            if (group.contains(srcFo)) {\n+                return group;\n+            }\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    public URL[] computeRoots(Group group) {\n+        if (group.binDir != null) {\n+            return new URL[] { group.binDir.toURL() };\n+        } else {\n+            return new URL[0];\n+        }\n+    }\n+\n+    @Override\n+    public boolean computePreferBinaries(Group result) {\n+        return true;\n+    }\n+\n+    @Override\n+    public void computeChangeListener(Group result, boolean bln, ChangeListener cl) {\n+    }\n+\n+    @Override\n+    public SourceForBinaryQueryImplementation2.Result findSourceRoots2(URL url) {\n+        this.computeTransitiveDeps();\n+        for (Dist dist : this.distributions) {\n+            URL jar;\n+            try {\n+                jar = dist.getJarRoot();\n+                if (jar == null) {\n+                    continue;\n+                }\n+            } catch (MalformedURLException ok) {\n+                continue;\n+            }\n+            if (jar.equals(url)) {\n+                List<FileObject> roots = new ArrayList<>();\n+                for (Group d : dist.getContributingGroups()) {\n+                    roots.add(d.srcDir);\n+                    roots.add(d.srcGenDir);\n+                }\n+                return new ImmutableResult(roots.toArray(new FileObject[roots.size()]));\n+            }\n+        }\n+        for (Group group : this.groups) {\n+            if (group.binDir != null && group.binDir.toURL().equals(url)) {\n+                return new ImmutableResult(group.srcDir, group.srcGenDir);\n+            }\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    public SourceForBinaryQuery.Result findSourceRoots(URL url) {\n+        return findSourceRoots2(url);\n+    }\n+\n+    final Iterable<File> jdks() {\n+        Set<File> jdks = new LinkedHashSet<>();\n+        String home = System.getProperty(\"user.home\");\n+        if (home != null) {\n+            File userEnv = new File(new File(new File(home), \".mx\"), \"env\");\n+            findJdksInEnv(jdks, userEnv);\n+        }\n+        FileObject suiteEnv = dir.getFileObject(\"mx.\" + dir.getNameExt() + \"/env\");\n+        if (suiteEnv != null) {\n+            findJdksInEnv(jdks, FileUtil.toFile(suiteEnv));\n+        }\n+\n+        String javaHomeEnv = System.getenv(\"JAVA_HOME\");\n+        if (javaHomeEnv != null) {\n+            jdks.add(new File(javaHomeEnv));\n+        }\n+        String javaHomeProp = System.getProperty(\"java.home\");\n+        if (javaHomeProp != null) {\n+            jdks.add(new File(javaHomeProp));\n+        }\n+        return jdks;\n+    }\n+\n+    private void findJdksInEnv(Set<File> jdks, File env) {\n+        if (env == null || !env.isFile()) {\n+            return;\n+        }\n+        try (final FileInputStream is = new FileInputStream(env)) {\n+            Properties p = new Properties();\n+            p.load(is);\n+\n+            String javaHome = p.getProperty(\"JAVA_HOME\");\n+            if (javaHome != null) {\n+                jdks.add(new File(javaHome));\n+            }\n+\n+            String extraJavaHomes = p.getProperty(\"EXTRA_JAVA_HOMES\");\n+            if (extraJavaHomes != null) {\n+                for (String extraHome : extraJavaHomes.split(File.pathSeparator)) {\n+                    jdks.add(new File(extraHome));\n+                }\n+            }\n+        } catch (IOException ex) {\n+            Exceptions.printStackTrace(ex);\n+        }\n+    }\n+\n+    @Override\n+    public SourceLevelQueryImplementation2.Result getSourceLevel(FileObject fo) {\n+        Group g = findGroup(fo);\n+        if (g == null) {\n+            return null;\n+        }\n+        return new SourceLevelQueryImplementation2.Result2() {\n+            @Override\n+            public SourceLevelQuery.Profile getProfile() {\n+                return SourceLevelQuery.Profile.DEFAULT;\n+            }\n+\n+            @Override\n+            public String getSourceLevel() {\n+                return g.getCompliance().getSourceLevel();\n+            }\n+\n+            @Override\n+            public void addChangeListener(ChangeListener cl) {\n+            }\n+\n+            @Override\n+            public void removeChangeListener(ChangeListener cl) {\n+            }\n+        };\n+    }\n+\n+    @Override\n+    public Set<? extends Project> getSubprojects() {\n+        Set<Project> prjs = new HashSet<>();\n+        for (SuiteSources imp : imported.values()) {\n+            prjs.add(imp.prj);\n+        }\n+        return prjs;\n+    }\n+\n+    @Override\n+    public URL[] findUnitTests(FileObject fo) {\n+        return new URL[0];\n+    }\n+\n+    @Override\n+    public URL[] findSources(FileObject fo) {\n+        Group g = findGroup(fo);\n+        return g == null ? new URL[0] : new URL[] { g.getRootFolder().toURL() };\n+    }\n+\n+    static interface Dep extends Comparable<Dep> {\n+        String getName();\n+\n+        Collection<String> depNames();\n+\n+        Collection<Dep> allDeps();\n+\n+        void setAllDeps(Collection<Dep> set);\n+\n+        @Override\n+        public default int compareTo(Dep o) {\n+            return getName().compareTo(o.getName());\n+        }\n+\n+        SuiteSources owner();\n+    }\n+\n+    final class Dist implements Dep, FlaggedClassPathImplementation {\n+        final String name;\n+        final MxDistribution dist;\n+        Collection<Dep> allDeps;\n+        private final PropertyChangeSupport support = new PropertyChangeSupport(this);\n+        private Boolean exists;\n+        private Collection<Group> groups;\n+\n+        public Dist(String name, MxDistribution dist) {\n+            this.name = name;\n+            this.dist = dist;\n+        }\n+\n+        @Override\n+        public Collection<String> depNames() {\n+            Set<String> deps = new TreeSet<>();\n+            deps.addAll(dist.distDependencies());\n+            deps.addAll(dist.exclude());\n+            return deps;\n+        }\n+\n+        @Override\n+        public Collection<Dep> allDeps() {\n+            return this.allDeps;\n+        }\n+\n+        @Override\n+        public void setAllDeps(Collection<Dep> set) {\n+            this.allDeps = set;\n+        }\n+\n+        @Override\n+        public String getName() {\n+            return this.name;\n+        }\n+\n+        @Override\n+        public Set<ClassPath.Flag> getFlags() {\n+            return exists ? Collections.emptySet() : Collections.singleton(ClassPath.Flag.INCOMPLETE);\n+        }\n+\n+        private FileObject getJar(boolean ignore) {\n+            if (SuiteSources.this.dir == null) {\n+                return null;\n+            }\n+            FileObject dists = SuiteSources.this.dir.getFileObject(\"mxbuild/dists\");\n+            if (dists == null) {\n+                return null;\n+            }\n+            List<FileObject> dist = Arrays.stream(dists.getChildren()).filter((fo) -> fo.isFolder() && fo.getName().startsWith(\"jdk\")).collect(Collectors.toList());\n+            dist.sort((fo1, fo2) -> fo2.getName().compareTo(fo1.getName()));\n+            for (FileObject jdkDir : dist) {\n+                FileObject jar = jdkDir.getFileObject(name.toLowerCase().replace(\"_\", \"-\") + \".jar\");\n+                if (jar != null) {\n+                    return jar;\n+                }\n+            }\n+            FileObject jar = dists.getFileObject(name.toLowerCase().replace(\"_\", \"-\") + \".jar\");\n+            if (jar != null) {\n+                return jar;\n+            }\n+            return null;\n+        }\n+\n+        @Override\n+        public List<? extends PathResourceImplementation> getResources() {\n+            computeTransitiveDeps();\n+            FileObject jar = getJar(exists == null);\n+            final boolean existsNow = jar != null && jar.isData();\n+            if (exists == null) {\n+                exists = existsNow;\n+            } else {\n+                if (exists != existsNow) {\n+                    exists = existsNow;\n+                    support.firePropertyChange(PROP_FLAGS, !exists, (boolean) exists);\n+                }\n+            }\n+            if (jar != null) {\n+                PathResourceImplementation res;\n+                try {\n+                    res = ClassPathSupport.createResource(getJarRoot());\n+                    return Collections.singletonList(res);\n+                } catch (MalformedURLException ex) {\n+                    // OK\n+                }\n+            }\n+            return Collections.emptyList();\n+        }\n+\n+        private URL getJarRoot() throws MalformedURLException {\n+            FileObject jar = getJar(true);\n+            if (jar != null) {\n+                return new URL(\"jar:\" + jar.toURL() + \"!/\");\n+            } else {\n+                return null;\n+            }\n+        }\n+\n+        @Override\n+        public void addPropertyChangeListener(PropertyChangeListener pl) {\n+            support.addPropertyChangeListener(pl);\n+        }\n+\n+        @Override\n+        public void removePropertyChangeListener(PropertyChangeListener pl) {\n+            support.removePropertyChangeListener(pl);\n+        }\n+\n+        @Override\n+        public SuiteSources owner() {\n+            return SuiteSources.this;\n+        }\n+\n+        private void computeSourceRoots(Map<String, Dep> collectedDeps) {\n+            if (groups != null) {\n+                return;\n+            }\n+            Set<Group> contributingGroups = new LinkedHashSet<>();\n+            for (String d : this.dist.dependencies()) {\n+                Dep dep = collectedDeps.get(d);\n+                if (dep == null || dep.allDeps() == null) {\n+                    continue;\n+                }\n+                for (Dep d2 : dep.allDeps()) {\n+                    if (d2 instanceof Group) {\n+                        contributingGroups.add((Group) d2);\n+                    }\n+                }\n+            }\n+            for (String d : this.dist.distDependencies()) {\n+                final Dep anyDep = collectedDeps.get(d);\n+                if (anyDep instanceof Dist) {\n+                    Dist dep = (Dist) anyDep;\n+                    dep.computeSourceRoots(collectedDeps);\n+                    contributingGroups.removeAll(dep.getContributingGroups());\n+                }\n+            }\n+            groups = contributingGroups;\n+        }\n+\n+        public Collection<Group> getContributingGroups() {\n+            return groups;\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return \"Dist[name=\" + name + \"]\";\n+        }\n+    }\n+\n+    final class Group implements SourceGroup, Dep, AnnotationProcessingQuery.Result,\n+            Compliance.Provider {\n+        private final String mxName;\n+        private final MxProject mxPrj;\n+        private final FileObject srcDir;\n+        private final FileObject srcGenDir;\n+        private final FileObject binDir;\n+        private final String name;\n+        private final String displayName;\n+        private final Compliance compliance;\n+        private ClassPath sourceCP;\n+        private ClassPath cp;\n+        private ClassPath processorPath;\n+        private Collection<Dep> allDeps;\n+\n+        Group(String mxName, MxProject mxPrj, FileObject srcDir, FileObject srcGenDir, FileObject binDir, String name, String displayName) {\n+            this.mxName = mxName;\n+            this.mxPrj = mxPrj;\n+            this.srcDir = srcDir;\n+            this.srcGenDir = srcGenDir;\n+            this.binDir = binDir;\n+            this.name = name;\n+            this.displayName = displayName;\n+            this.compliance = Compliance.parse(mxPrj.javaCompliance());\n+        }\n+\n+        @Override\n+        public FileObject getRootFolder() {\n+            return srcDir;\n+        }\n+\n+        @Override\n+        public String getName() {\n+            return name;\n+        }\n+\n+        @Override\n+        public String getDisplayName() {\n+            return displayName;\n+        }\n+\n+        @Override\n+        public Icon getIcon(boolean opened) {\n+            return null;\n+        }\n+\n+        @Override\n+        public Compliance getCompliance() {\n+            return compliance;\n+        }\n+\n+        @Override\n+        public boolean contains(FileObject file) {\n+            if (file == srcDir || file == srcGenDir || FileUtil.isParentOf(srcDir, file) || (srcGenDir != null && FileUtil.isParentOf(srcGenDir, file))) {\n+                return true;\n+            }\n+            return false;\n+        }\n+\n+        @Override\n+        public void addPropertyChangeListener(PropertyChangeListener l) {\n+        }\n+\n+        @Override\n+        public void removePropertyChangeListener(PropertyChangeListener l) {\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return \"SuiteSources.Group[name=\" + name + \",rootFolder=\" + srcDir + \"]\"; // NOI18N\n+        }\n+\n+        ClassPath getSourceCP() {\n+            computeTransitiveDeps();\n+            return sourceCP;\n+        }\n+\n+        ClassPath getCP() {\n+            computeTransitiveDeps();\n+            return cp;\n+        }\n+\n+        @Override\n+        public Collection<String> depNames() {\n+            return mxPrj.dependencies();\n+        }\n+\n+        @Override\n+        public void setAllDeps(Collection<Dep> set) {\n+            allDeps = set;\n+        }\n+\n+        @Override\n+        public Collection<Dep> allDeps() {\n+            return allDeps;\n+        }\n+\n+        private void computeClassPath(Map<String, Dep> transDeps) {\n+            for (Dep d : transDeps.values()) {\n+                d.owner().computeTransitiveDeps();\n+            }\n+\n+            List<Group> arr = new ArrayList<>();\n+            List<ClassPathImplementation> libs = new ArrayList<>();\n+            processTransDep(transDeps.get(mxName), arr, libs);\n+            cp = composeClassPath(arr, libs);\n+            List<FileObject> roots = new ArrayList<>();\n+            if (srcDir != null) {\n+                roots.add(srcDir);\n+            }\n+            if (srcGenDir != null) {\n+                roots.add(srcGenDir);\n+            }\n+            sourceCP = ClassPathSupport.createClassPath(roots.toArray(new FileObject[roots.size()]));\n+\n+            if (mxPrj.annotationProcessors().isEmpty()) {\n+                processorPath = null;\n+            } else {\n+                List<Group> groups = new ArrayList<>();\n+                List<ClassPathImplementation> jars = new ArrayList<>();\n+                for (String dep : mxPrj.annotationProcessors()) {\n+                    processTransDep(transDeps.get(dep), groups, jars);\n+                }\n+                processorPath = composeClassPath(groups, jars);\n+            }\n+        }\n+\n+        private void processTransDep(Dep dep, List<Group> addGroups, List<ClassPathImplementation> addJars) {\n+            if (dep != null) {\n+                dep.owner().computeTransitiveDeps();\n+                for (Dep d : dep.allDeps()) {\n+                    if (d == this) {\n+                        continue;\n+                    }\n+                    d.owner().computeTransitiveDeps();\n+                    if (d instanceof Group) {\n+                        addGroups.add((Group) d);\n+                    } else if (d instanceof ClassPathImplementation) {\n+                        addJars.add((ClassPathImplementation) d);\n+                    }\n+                }\n+            }\n+        }\n+\n+        private ClassPath composeClassPath(List<Group> arr, List<ClassPathImplementation> libs) {\n+            Set<FileObject> roots = new LinkedHashSet<>();\n+            final int depsCount = arr.size();\n+            for (int i = 0; i < depsCount; i++) {\n+                final Group g = arr.get(i);\n+                if (g.binDir != null) {\n+                    roots.add(g.binDir);\n+                }\n+            }\n+            ClassPath prjCp = ClassPathSupport.createClassPath(roots.toArray(new FileObject[0]));\n+            if (!libs.isEmpty()) {\n+                if (libs.size() == 1) {\n+                    prjCp = ClassPathSupport.createProxyClassPath(prjCp,\n+                                                                  ClassPathFactory.createClassPath(libs.get(0))\n+                    );\n+                } else {\n+                    prjCp = ClassPathSupport.createProxyClassPath(prjCp,\n+                                                                  ClassPathFactory.createClassPath(\n+                                                                                  ClassPathSupport.createProxyClassPathImplementation(\n+                                                                                                  libs.toArray(new ClassPathImplementation[0])\n+                                                                                  )\n+                                                                  )\n+                    );\n+                }\n+            }\n+            return prjCp;\n+        }\n+\n+        ClassPath getProcessorCP() {\n+            computeTransitiveDeps();\n+            return processorPath;\n+        }\n+\n+        @Override\n+        public Set<? extends AnnotationProcessingQuery.Trigger> annotationProcessingEnabled() {\n+            return EnumSet.of(AnnotationProcessingQuery.Trigger.ON_SCAN, AnnotationProcessingQuery.Trigger.IN_EDITOR);\n+        }\n+\n+        @Override\n+        public Iterable<? extends String> annotationProcessorsToRun() {\n+            return null;\n+        }\n+\n+        @Override\n+        public URL sourceOutputDirectory() {\n+            return srcGenDir == null ? null : srcGenDir.toURL();\n+        }\n+\n+        @Override\n+        public Map<? extends String, ? extends String> processorOptions() {\n+            return Collections.emptyMap();\n+        }\n+\n+        @Override\n+        public void addChangeListener(ChangeListener l) {\n+        }\n+\n+        @Override\n+        public void removeChangeListener(ChangeListener l) {\n+        }\n+\n+        @Override\n+        public SuiteSources owner() {\n+            return SuiteSources.this;\n+        }\n+    }\n+\n+    private class Library implements FlaggedClassPathImplementation, Dep {\n+        final MxLibrary lib;\n+        final PropertyChangeSupport support = new PropertyChangeSupport(this);\n+        final String libName;\n+        Collection<Dep> allDeps;\n+        Boolean exists;\n+\n+        Library(String libName, MxLibrary lib) {\n+            this.libName = libName;\n+            this.lib = getOSSLibrary(lib);\n+        }\n+\n+        final MxLibrary getOSSLibrary(MxLibrary lib) {\n+            if (lib.sha1() == null && !lib.os_arch().isEmpty()) {\n+                Map<String, MxLibrary.Arch> os_dep_libs = lib.os_arch();\n+                String os = System.getProperty(\"os.name\").toLowerCase();\n+                for (Map.Entry<String, MxLibrary.Arch> entry : os_dep_libs.entrySet()) {\n+                    if (os.contains(entry.getKey())) {\n+                        return entry.getValue().amd64();\n+                    }\n+                }\n+            }\n+            return lib;\n+        }\n+\n+        File getJar(boolean dumpIfMissing) {\n+            File mxCache;\n+            String cache = System.getenv(\"MX_CACHE_DIR\");\n+            if (cache != null) {\n+                mxCache = new File(cache);\n+            } else {\n+                mxCache = new File(new File(new File(System.getProperty(\"user.home\")), \".mx\"), \"cache\");\n+            }\n+            int prefix = libName.indexOf(':');\n+            final String simpleName = libName.substring(prefix + 1);\n+\n+            File simpleJar = new File(mxCache, simpleName + \"_\" + lib.sha1() + \".jar\");\n+            if (simpleJar.exists()) {\n+                return simpleJar;\n+            }\n+            File dir = new File(mxCache, simpleName + \"_\" + lib.sha1());\n+            File jar = new File(dir, simpleName.replace('_', '-').toLowerCase(Locale.ENGLISH) + \".jar\");\n+\n+            if (dumpIfMissing && !jar.exists()) {\n+                for (File f = jar;; f = f.getParentFile()) {\n+                    if (!f.exists()) {\n+                        LOG.log(Level.WARNING, \"{0} does not exist\", f);\n+                    } else {\n+                        StringBuilder sb = new StringBuilder();\n+                        sb.append(f).append(\" exists:\\n\");\n+                        String[] kids = f.list();\n+                        if (kids != null) {\n+                            for (String n : kids) {\n+                                sb.append(\"  \").append(n).append(\"\\n\");\n+                            }\n+                        }\n+                        LOG.log(Level.INFO, sb.toString());\n+                        break;\n+                    }\n+                }\n+            }\n+            return jar;\n+        }\n+\n+        @Override\n+        public String getName() {\n+            return libName;\n+        }\n+\n+        @Override\n+        public Collection<String> depNames() {\n+            return lib.dependencies();\n+        }\n+\n+        @Override\n+        public Collection<Dep> allDeps() {\n+            return allDeps;\n+        }\n+\n+        @Override\n+        public void setAllDeps(Collection<Dep> set) {\n+            this.allDeps = set;\n+        }\n+\n+        @Override\n+        public Set<ClassPath.Flag> getFlags() {\n+            return exists ? Collections.emptySet() : Collections.singleton(ClassPath.Flag.INCOMPLETE);\n+        }\n+\n+        @Override\n+        public List<? extends PathResourceImplementation> getResources() {\n+            File jar = getJar(exists == null);\n+            if (exists == null) {\n+                exists = jar.exists();\n+            } else {\n+                if (exists != jar.exists()) {\n+                    exists = jar.exists();\n+                    support.firePropertyChange(PROP_FLAGS, !exists, (boolean) exists);\n+                }\n+            }\n+            PathResourceImplementation res;\n+            try {\n+                res = ClassPathSupport.createResource(new URL(\"jar:\" + Utilities.toURI(jar).toURL() + \"!/\"));\n+                return Collections.singletonList(res);\n+            } catch (MalformedURLException ex) {\n+                return Collections.emptyList();\n+            }\n+        }\n+\n+        @Override\n+        public void addPropertyChangeListener(PropertyChangeListener pl) {\n+            support.addPropertyChangeListener(pl);\n+        }\n+\n+        @Override\n+        public void removePropertyChangeListener(PropertyChangeListener pl) {\n+            support.removePropertyChangeListener(pl);\n+        }\n+\n+        @Override\n+        public SuiteSources owner() {\n+            return SuiteSources.this;\n+        }\n+    }\n+\n+    private class JdkLibrary extends Library {\n+        JdkLibrary(String libName, MxLibrary lib) {\n+            super(libName, lib);\n+        }\n+\n+        @Override\n+        File getJar(boolean dumpIfMissing) {\n+            File first = null;\n+            for (File jdk : jdks()) {\n+                File jre = new File(jdk, \"jre\");\n+                File jrePath = new File(jre, lib.path().replace('/', File.separatorChar));\n+                if (jrePath.exists()) {\n+                    return jrePath;\n+                }\n+\n+                if (first == null) {\n+                    first = jrePath;\n+                }\n+\n+                File jdkPath = new File(jdk, lib.path().replace('/', File.separatorChar));\n+\n+                if (jdkPath.exists()) {\n+                    return jdkPath;\n+                }\n+\n+            }\n+\n+            if (dumpIfMissing) {\n+                for (File jdk : jdks()) {\n+                    File libPath = new File(jdk, lib.path().replace('/', File.separatorChar));\n+                    if (!libPath.exists()) {\n+                        LOG.log(Level.WARNING, \"{0} does not exist\", libPath);\n+                    } else {\n+                        StringBuilder sb = new StringBuilder();\n+                        sb.append(libPath).append(\" exists:\\n\");\n+                        String[] kids = libPath.list();\n+                        if (kids != null) {\n+                            for (String n : kids) {\n+                                sb.append(\"  \").append(n).append(\"\\n\");\n+                            }\n+                        }\n+                        LOG.log(Level.INFO, sb.toString());\n+                        break;\n+                    }\n+                }\n+            }\n+            return first;\n+        }\n+\n+        @Override\n+        public String getName() {\n+            return libName;\n+        }\n+\n+        @Override\n+        public Collection<String> depNames() {\n+            return lib.dependencies();\n+        }\n+\n+        @Override\n+        public Collection<Dep> allDeps() {\n+            return allDeps;\n+        }\n+\n+        @Override\n+        public void setAllDeps(Collection<Dep> set) {\n+            this.allDeps = set;\n+        }\n+\n+        @Override\n+        public Set<ClassPath.Flag> getFlags() {\n+            return exists ? Collections.emptySet() : Collections.singleton(ClassPath.Flag.INCOMPLETE);\n+        }\n+\n+        @Override\n+        public List<? extends PathResourceImplementation> getResources() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "21a2744fdd0de199cff1cdca7143f5498c4a4bdc"}, "originalPosition": 1117}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "de87e99441f604bec03c35a18f0f84f4c2b008e7", "author": {"user": {"login": "JaroslavTulach", "name": "Jaroslav Tulach"}}, "url": "https://github.com/apache/netbeans/commit/de87e99441f604bec03c35a18f0f84f4c2b008e7", "committedDate": "2020-12-09T16:44:44Z", "message": "Merge origin/master' into EatingOwnFoodInitialPhase"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3933d300360c5990a08131d529269e52e719146c", "author": {"user": {"login": "JaroslavTulach", "name": "Jaroslav Tulach"}}, "url": "https://github.com/apache/netbeans/commit/3933d300360c5990a08131d529269e52e719146c", "committedDate": "2020-12-16T08:07:39Z", "message": "Removing unused argument and treating warnings as errors"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b69f4669e34f7790c956f290fbd4bb10bbb6c10d", "author": {"user": {"login": "JaroslavTulach", "name": "Jaroslav Tulach"}}, "url": "https://github.com/apache/netbeans/commit/b69f4669e34f7790c956f290fbd4bb10bbb6c10d", "committedDate": "2020-12-16T08:08:07Z", "message": "Up to date with master"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9e9567e47292c114f32c804e06fef4cc47c43e44", "author": {"user": {"login": "JaroslavTulach", "name": "Jaroslav Tulach"}}, "url": "https://github.com/apache/netbeans/commit/9e9567e47292c114f32c804e06fef4cc47c43e44", "committedDate": "2020-12-16T08:27:01Z", "message": "exists could be null"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5b589ee5930f13d86dd1bc66e8f326eb8c64f396", "author": {"user": {"login": "JaroslavTulach", "name": "Jaroslav Tulach"}}, "url": "https://github.com/apache/netbeans/commit/5b589ee5930f13d86dd1bc66e8f326eb8c64f396", "committedDate": "2020-12-16T08:34:41Z", "message": "Naming to indicate transitiveDeps are always processed just once"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "af12108a52897ee2d793f3ac57ac4c3fcf71a9cd", "author": {"user": {"login": "JaroslavTulach", "name": "Jaroslav Tulach"}}, "url": "https://github.com/apache/netbeans/commit/af12108a52897ee2d793f3ac57ac4c3fcf71a9cd", "committedDate": "2020-12-16T08:56:35Z", "message": "Sharing the FLAGS implementation between all three element types"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTUzNTM5MDE3", "url": "https://github.com/apache/netbeans/pull/2575#pullrequestreview-553539017", "createdAt": "2020-12-16T10:15:08Z", "commit": {"oid": "af12108a52897ee2d793f3ac57ac4c3fcf71a9cd"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNlQxMDoxNTowOFrOIG91IQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNlQxMDoxNTowOFrOIG91IQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDE3NTM5Mw==", "bodyText": "Alas, this test seems to randomly fail.", "url": "https://github.com/apache/netbeans/pull/2575#discussion_r544175393", "createdAt": "2020-12-16T10:15:08Z", "author": {"login": "JaroslavTulach"}, "path": "java/java.mx.project/test/unit/src/org/netbeans/modules/java/mx/project/SuiteCheck.java", "diffHunk": "@@ -0,0 +1,257 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.netbeans.modules.java.mx.project;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.net.URISyntaxException;\n+import java.net.URL;\n+import java.util.Arrays;\n+import java.util.Enumeration;\n+import java.util.Locale;\n+import java.util.logging.Handler;\n+import java.util.logging.Level;\n+import java.util.logging.LogManager;\n+import java.util.logging.Logger;\n+import javax.tools.Diagnostic;\n+import static junit.framework.TestCase.assertEquals;\n+import static junit.framework.TestCase.assertNotNull;\n+import static junit.framework.TestCase.assertSame;\n+import static junit.framework.TestCase.assertTrue;\n+import static junit.framework.TestCase.fail;\n+import org.netbeans.modules.java.mx.project.suitepy.MxSuite;\n+import org.junit.Assume;\n+import org.netbeans.api.java.classpath.ClassPath;\n+import org.netbeans.api.java.classpath.JavaClassPathConstants;\n+import org.netbeans.api.java.queries.BinaryForSourceQuery;\n+import org.netbeans.api.java.queries.SourceForBinaryQuery;\n+import org.netbeans.api.java.source.CompilationController;\n+import org.netbeans.api.java.source.JavaSource;\n+import org.netbeans.api.project.FileOwnerQuery;\n+import org.netbeans.api.project.Project;\n+import org.netbeans.api.project.ProjectManager;\n+import org.netbeans.api.project.ProjectUtils;\n+import org.netbeans.api.project.SourceGroup;\n+import org.netbeans.api.project.Sources;\n+import org.netbeans.api.project.ui.OpenProjects;\n+import org.netbeans.junit.NbTestCase;\n+import org.netbeans.modules.parsing.api.indexing.IndexingManager;\n+import org.openide.filesystems.FileObject;\n+import org.openide.filesystems.FileUtil;\n+import org.openide.util.Utilities;\n+\n+abstract class SuiteCheck extends NbTestCase {\n+    SuiteCheck(String name) {\n+        super(name);\n+        log(Level.INFO, \"Test created by %s classloader\", getClass().getClassLoader());\n+    }\n+\n+    @Override\n+    protected void setUp() throws Exception {\n+        log(Level.INFO, \"setUp - init\");\n+        super.setUp();\n+        final Logger tooVerboseLogger = Logger.getLogger(\"org.netbeans.core.startup.InstalledFileLocatorImpl\");\n+        tooVerboseLogger.setUseParentHandlers(false);\n+        try {\n+            MxSuite.parse(null);\n+        } catch (LinkageError err) {\n+            Assume.assumeNoException(\"Cannot initialize Polyglot API, are you using GraalVM?\", err);\n+        }\n+        log(Level.INFO, \"setUp - exit\");\n+    }\n+\n+    @Override\n+    protected void tearDown() throws Exception {\n+        Enumeration<String> en = LogManager.getLogManager().getLoggerNames();\n+        while (en.hasMoreElements()) {\n+            String n = en.nextElement();\n+            Logger l = LogManager.getLogManager().getLogger(n);\n+            boolean first = true;\n+            if (l == null || l.getHandlers() == null) {\n+                continue;\n+            }\n+            for (Handler h : l.getHandlers()) {\n+                if (first) {\n+                    System.err.println(\"cleaning logger '\" + n + \"'\");\n+                    first = false;\n+                }\n+                System.err.println(\"  removing handler: \" + h);\n+                l.removeHandler(h);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    protected int timeOut() {\n+        return 1_200_000;\n+    }\n+\n+    protected final void verifyNoErrorsInSuite(final String suiteName, String... onlySourceGroups) throws IllegalArgumentException, IOException, URISyntaxException {\n+        long begin = System.currentTimeMillis();\n+        File sibling = findSuite(suiteName);\n+\n+        FileObject fo = FileUtil.toFileObject(sibling);\n+        assertNotNull(\"project directory found\", fo);\n+\n+        log(Level.INFO, \"Recognizing project %s\", fo);\n+        long now = System.currentTimeMillis();\n+        Project p = ProjectManager.getDefault().findProject(fo);\n+        long took = System.currentTimeMillis() - now;\n+        assertNotNull(\"project found\", p);\n+        log(Level.INFO, \"Project found %s in %d ms\", p, took);\n+        assertEquals(\"It is suite project: \" + p, \"SuiteProject\", p.getClass().getSimpleName());\n+        OpenProjects.getDefault().open(new Project[]{p}, false);\n+\n+        StringBuilder errors = new StringBuilder();\n+        FileObject[] errornous = { null };\n+        Sources src = ProjectUtils.getSources(p);\n+        int cnt = 0;\n+        for (SourceGroup sourceGroup : src.getSourceGroups(\"java\")) {\n+            if (sourceGroup instanceof Compliance.Provider) {\n+                Compliance c = ((Compliance.Provider) sourceGroup).getCompliance();\n+                if (!c.includes(8)) {\n+                    log(Level.INFO, \"Skipping check of %s with compliance %s\", sourceGroup, c);\n+                    continue;\n+                }\n+            }\n+            FOUND: if (onlySourceGroups.length > 0) {\n+                for (String gName : onlySourceGroups) {\n+                    if (sourceGroup.getDisplayName().equals(gName)) {\n+                        cnt++;\n+                        break FOUND;\n+                    }\n+                }\n+                // not found\n+                continue;\n+            }\n+            assertSourcesNoError(p, errornous, errors, sourceGroup.getRootFolder(), begin);\n+        }\n+        assertCompilationErrors(errors, errornous);\n+\n+        assertEquals(\"Exactly as many source groups tested as requested\", onlySourceGroups.length, cnt);\n+    }\n+\n+    protected final File findSuite(String suite) throws URISyntaxException {\n+        File location = getDataDir();\n+        while (location != null) {\n+            File graal = new File(location, \"graal\");\n+            File suiteDir = new File(graal, suite);\n+            if (suiteDir.isDirectory()) {\n+                return suiteDir;\n+            }\n+            location = location.getParentFile();\n+        }\n+        fail(\"Cannot find truffle next to \" + getDataDir());\n+        return null;\n+    }\n+\n+    private void assertSourcesNoError(Project project, FileObject[] errornous, StringBuilder errors, FileObject dir, long begin) throws IOException {\n+        long now = System.currentTimeMillis();\n+        log(Level.INFO, \"assertSourcesNoError for %s\", dir);\n+        IndexingManager.getDefault().refreshIndexAndWait(dir.toURL(), null, false);\n+        log(Level.INFO, \"      refresh done       %s\", dir);\n+        Enumeration<? extends FileObject> en = dir.getChildren(true);\n+        int nonJavaCount = 0;\n+        int javaCount = 0;\n+        while (en.hasMoreElements()) {\n+            FileObject fo = en.nextElement();\n+            if (fo.isFolder()) {\n+                continue;\n+            }\n+            Project prj = FileOwnerQuery.getOwner(fo);\n+            assertSame(\"FileOwnerQuery returns the right project\", project, prj);\n+            if (!fo.hasExt(\"java\")) {\n+                nonJavaCount++;\n+                continue;\n+            }\n+            JavaSource source = JavaSource.forFileObject(fo);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "af12108a52897ee2d793f3ac57ac4c3fcf71a9cd"}, "originalPosition": 183}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTUzNTM5Nzkz", "url": "https://github.com/apache/netbeans/pull/2575#pullrequestreview-553539793", "createdAt": "2020-12-16T10:16:06Z", "commit": {"oid": "af12108a52897ee2d793f3ac57ac4c3fcf71a9cd"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNlQxMDoxNjowN1rOIG93vA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNlQxMDoxNjowN1rOIG93vA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDE3NjA2MA==", "bodyText": "Is there a better way to verify project sources are fine from a NetBeans Java Source support perspective?", "url": "https://github.com/apache/netbeans/pull/2575#discussion_r544176060", "createdAt": "2020-12-16T10:16:07Z", "author": {"login": "JaroslavTulach"}, "path": "java/java.mx.project/test/unit/src/org/netbeans/modules/java/mx/project/SuiteCheck.java", "diffHunk": "@@ -0,0 +1,257 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.netbeans.modules.java.mx.project;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.net.URISyntaxException;\n+import java.net.URL;\n+import java.util.Arrays;\n+import java.util.Enumeration;\n+import java.util.Locale;\n+import java.util.logging.Handler;\n+import java.util.logging.Level;\n+import java.util.logging.LogManager;\n+import java.util.logging.Logger;\n+import javax.tools.Diagnostic;\n+import static junit.framework.TestCase.assertEquals;\n+import static junit.framework.TestCase.assertNotNull;\n+import static junit.framework.TestCase.assertSame;\n+import static junit.framework.TestCase.assertTrue;\n+import static junit.framework.TestCase.fail;\n+import org.netbeans.modules.java.mx.project.suitepy.MxSuite;\n+import org.junit.Assume;\n+import org.netbeans.api.java.classpath.ClassPath;\n+import org.netbeans.api.java.classpath.JavaClassPathConstants;\n+import org.netbeans.api.java.queries.BinaryForSourceQuery;\n+import org.netbeans.api.java.queries.SourceForBinaryQuery;\n+import org.netbeans.api.java.source.CompilationController;\n+import org.netbeans.api.java.source.JavaSource;\n+import org.netbeans.api.project.FileOwnerQuery;\n+import org.netbeans.api.project.Project;\n+import org.netbeans.api.project.ProjectManager;\n+import org.netbeans.api.project.ProjectUtils;\n+import org.netbeans.api.project.SourceGroup;\n+import org.netbeans.api.project.Sources;\n+import org.netbeans.api.project.ui.OpenProjects;\n+import org.netbeans.junit.NbTestCase;\n+import org.netbeans.modules.parsing.api.indexing.IndexingManager;\n+import org.openide.filesystems.FileObject;\n+import org.openide.filesystems.FileUtil;\n+import org.openide.util.Utilities;\n+\n+abstract class SuiteCheck extends NbTestCase {\n+    SuiteCheck(String name) {\n+        super(name);\n+        log(Level.INFO, \"Test created by %s classloader\", getClass().getClassLoader());\n+    }\n+\n+    @Override\n+    protected void setUp() throws Exception {\n+        log(Level.INFO, \"setUp - init\");\n+        super.setUp();\n+        final Logger tooVerboseLogger = Logger.getLogger(\"org.netbeans.core.startup.InstalledFileLocatorImpl\");\n+        tooVerboseLogger.setUseParentHandlers(false);\n+        try {\n+            MxSuite.parse(null);\n+        } catch (LinkageError err) {\n+            Assume.assumeNoException(\"Cannot initialize Polyglot API, are you using GraalVM?\", err);\n+        }\n+        log(Level.INFO, \"setUp - exit\");\n+    }\n+\n+    @Override\n+    protected void tearDown() throws Exception {\n+        Enumeration<String> en = LogManager.getLogManager().getLoggerNames();\n+        while (en.hasMoreElements()) {\n+            String n = en.nextElement();\n+            Logger l = LogManager.getLogManager().getLogger(n);\n+            boolean first = true;\n+            if (l == null || l.getHandlers() == null) {\n+                continue;\n+            }\n+            for (Handler h : l.getHandlers()) {\n+                if (first) {\n+                    System.err.println(\"cleaning logger '\" + n + \"'\");\n+                    first = false;\n+                }\n+                System.err.println(\"  removing handler: \" + h);\n+                l.removeHandler(h);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    protected int timeOut() {\n+        return 1_200_000;\n+    }\n+\n+    protected final void verifyNoErrorsInSuite(final String suiteName, String... onlySourceGroups) throws IllegalArgumentException, IOException, URISyntaxException {\n+        long begin = System.currentTimeMillis();\n+        File sibling = findSuite(suiteName);\n+\n+        FileObject fo = FileUtil.toFileObject(sibling);\n+        assertNotNull(\"project directory found\", fo);\n+\n+        log(Level.INFO, \"Recognizing project %s\", fo);\n+        long now = System.currentTimeMillis();\n+        Project p = ProjectManager.getDefault().findProject(fo);\n+        long took = System.currentTimeMillis() - now;\n+        assertNotNull(\"project found\", p);\n+        log(Level.INFO, \"Project found %s in %d ms\", p, took);\n+        assertEquals(\"It is suite project: \" + p, \"SuiteProject\", p.getClass().getSimpleName());\n+        OpenProjects.getDefault().open(new Project[]{p}, false);\n+\n+        StringBuilder errors = new StringBuilder();\n+        FileObject[] errornous = { null };\n+        Sources src = ProjectUtils.getSources(p);\n+        int cnt = 0;\n+        for (SourceGroup sourceGroup : src.getSourceGroups(\"java\")) {\n+            if (sourceGroup instanceof Compliance.Provider) {\n+                Compliance c = ((Compliance.Provider) sourceGroup).getCompliance();\n+                if (!c.includes(8)) {\n+                    log(Level.INFO, \"Skipping check of %s with compliance %s\", sourceGroup, c);\n+                    continue;\n+                }\n+            }\n+            FOUND: if (onlySourceGroups.length > 0) {\n+                for (String gName : onlySourceGroups) {\n+                    if (sourceGroup.getDisplayName().equals(gName)) {\n+                        cnt++;\n+                        break FOUND;\n+                    }\n+                }\n+                // not found\n+                continue;\n+            }\n+            assertSourcesNoError(p, errornous, errors, sourceGroup.getRootFolder(), begin);\n+        }\n+        assertCompilationErrors(errors, errornous);\n+\n+        assertEquals(\"Exactly as many source groups tested as requested\", onlySourceGroups.length, cnt);\n+    }\n+\n+    protected final File findSuite(String suite) throws URISyntaxException {\n+        File location = getDataDir();\n+        while (location != null) {\n+            File graal = new File(location, \"graal\");\n+            File suiteDir = new File(graal, suite);\n+            if (suiteDir.isDirectory()) {\n+                return suiteDir;\n+            }\n+            location = location.getParentFile();\n+        }\n+        fail(\"Cannot find truffle next to \" + getDataDir());\n+        return null;\n+    }\n+\n+    private void assertSourcesNoError(Project project, FileObject[] errornous, StringBuilder errors, FileObject dir, long begin) throws IOException {\n+        long now = System.currentTimeMillis();\n+        log(Level.INFO, \"assertSourcesNoError for %s\", dir);\n+        IndexingManager.getDefault().refreshIndexAndWait(dir.toURL(), null, false);\n+        log(Level.INFO, \"      refresh done       %s\", dir);\n+        Enumeration<? extends FileObject> en = dir.getChildren(true);\n+        int nonJavaCount = 0;\n+        int javaCount = 0;\n+        while (en.hasMoreElements()) {\n+            FileObject fo = en.nextElement();\n+            if (fo.isFolder()) {\n+                continue;\n+            }\n+            Project prj = FileOwnerQuery.getOwner(fo);\n+            assertSame(\"FileOwnerQuery returns the right project\", project, prj);\n+            if (!fo.hasExt(\"java\")) {\n+                nonJavaCount++;\n+                continue;\n+            }\n+            JavaSource source = JavaSource.forFileObject(fo);\n+            if (source == null) {\n+                fail(\"No source for \" + fo);\n+            }\n+            javaCount++;\n+            BinaryForSourceQuery.Result res = BinaryForSourceQuery.findBinaryRoots(dir.toURL());\n+            assertEquals(\"There is one binary root: \" + Arrays.toString(res.getRoots()), 1, res.getRoots().length);\n+            OK: for (URL root : res.getRoots()) {\n+                SourceForBinaryQuery.Result2 res2 = SourceForBinaryQuery.findSourceRoots2(root);\n+                assertTrue(\"Has to prefer sources\", res2.preferSources());\n+                for (FileObject src : res2.getRoots()) {\n+                    if (src.equals(dir)) {\n+                        break OK;\n+                    }\n+                }\n+                fail(\"Expecting to find \" + dir + \" among:\\n\" + Arrays.toString(res2.getRoots()));\n+            }\n+            source.runUserActionTask((CompilationController p) -> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "af12108a52897ee2d793f3ac57ac4c3fcf71a9cd"}, "originalPosition": 200}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "289038bd4fceec29d4fea9e333aa391e16ffc02d", "author": {"user": {"login": "JaroslavTulach", "name": "Jaroslav Tulach"}}, "url": "https://github.com/apache/netbeans/commit/289038bd4fceec29d4fea9e333aa391e16ffc02d", "committedDate": "2020-12-16T10:23:17Z", "message": "Retry the java.mx.project tests"}, "afterCommit": {"oid": "4cbe7aa0ff86c37ed162dae14072c26ec25bd100", "author": {"user": {"login": "JaroslavTulach", "name": "Jaroslav Tulach"}}, "url": "https://github.com/apache/netbeans/commit/4cbe7aa0ff86c37ed162dae14072c26ec25bd100", "committedDate": "2020-12-16T13:05:33Z", "message": "Download essential libraries into ~/.mx/cache"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "80e5ea1e884a34df23062095cf60624600cb14d7", "author": {"user": {"login": "JaroslavTulach", "name": "Jaroslav Tulach"}}, "url": "https://github.com/apache/netbeans/commit/80e5ea1e884a34df23062095cf60624600cb14d7", "committedDate": "2020-12-16T15:21:09Z", "message": "Download essential libraries into ~/.mx/cache"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "4cbe7aa0ff86c37ed162dae14072c26ec25bd100", "author": {"user": {"login": "JaroslavTulach", "name": "Jaroslav Tulach"}}, "url": "https://github.com/apache/netbeans/commit/4cbe7aa0ff86c37ed162dae14072c26ec25bd100", "committedDate": "2020-12-16T13:05:33Z", "message": "Download essential libraries into ~/.mx/cache"}, "afterCommit": {"oid": "80e5ea1e884a34df23062095cf60624600cb14d7", "author": {"user": {"login": "JaroslavTulach", "name": "Jaroslav Tulach"}}, "url": "https://github.com/apache/netbeans/commit/80e5ea1e884a34df23062095cf60624600cb14d7", "committedDate": "2020-12-16T15:21:09Z", "message": "Download essential libraries into ~/.mx/cache"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 387, "cost": 1, "resetAt": "2021-10-28T17:48:14Z"}}}