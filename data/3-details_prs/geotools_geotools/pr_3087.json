{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDU1NzE4ODcz", "number": 3087, "title": "[GEOT-6386] Implement Polyconic spherical case", "bodyText": "This PR addresses GEOT-6386 by incorporating Spherical cases into the Polyconic projection implementation.\nChecklist\n\nReviewing is a process done by project maintainers, mostly on a volunteer basis. We try to keep the overhead as small as possible and appreciate if you help us to do so by completing the following items. Feel free to ask in a comment if you have troubles with any of them.\n\nFor all pull requests:\n\n Confirm you have read the contribution guidelines\n You have sent a Contribution Licence Agreement (CLA) as necessary (not required for small changes, e.g., fixing typos in documentation)\n Make sure the first PR targets the master branch, eventual backports will be managed later. This can be ignored if the PR is fixing an issue that only happens in a specific branch, but not in newer ones.\n The changes are not breaking the build in downstream projects using SNAPSHOT dependencies, GeoWebCache and GeoServer (there is an automatic PR check verifying this, check this when it turns green).\n\nThe following are required only for core and extension modules (they are welcomed, but not required, for unsupported modules):\n\n There is an issue in Jira describing the bug/task/new feature (a notable exemptions is, changes not visible to end users). The ticket is for the GeoTools project, if the issue was found elsewhere it's a good practice to link to the origin ticket/issue.\n The pull request contains changes related to a single objective. If multiple focuses cannot be avoided, each one is in its own commit and has a separate ticket describing it.\n PR for bug fixes and small new features are presented as a single commit\n Commit message(s) must be in the form \"[GEOT-XYZW] Title of the Jira ticket\"\n New unit tests have been added covering the changes\n This PR passes all existing unit tests (test results will be reported by travis-ci after opening this PR)\n This PR passes the QA checks (QA checks results will be reported by travis-ci after opening this PR)\n Documentation has been updated accordingly.\n\nSubmitting the PR does not require you to check all items, but by the time it gets merged, they should be either satisfied or inapplicable.", "createdAt": "2020-07-23T13:45:33Z", "url": "https://github.com/geotools/geotools/pull/3087", "merged": true, "mergeCommit": {"oid": "ceae6bf61c9213daf2b63ca61f84f179cc80a0fe"}, "closed": true, "closedAt": "2020-08-24T09:48:40Z", "author": {"login": "turingtestfail"}, "timelineItems": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABc3voVvgH2gAyNDU1NzE4ODczOjlkM2ZkZmExNTc0ZGFmYTM3ZTVkYTFkZDU4Y2RjNmYxNzhlMTFlODA=", "endCursor": "Y3Vyc29yOnYyOpPPAAABc7ZVrRgH2gAyNDU1NzE4ODczOmVkNzk3ZGI1MTQ2Y2JhMjhhYzJjYjYyZTEwZmI1YmU0OGY5ZjUxMjk=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "9d3fdfa1574dafa37e5da1dd58cdc6f178e11e80", "author": {"user": {"login": "jmiller-self", "name": "Joseph Miller"}}, "url": "https://github.com/geotools/geotools/commit/9d3fdfa1574dafa37e5da1dd58cdc6f178e11e80", "committedDate": "2020-07-23T13:41:31Z", "message": "[GEOT-6386] Implement Polyconic spherical case\n\nGEOT-6386 unit tests for spherical polyconic\n\nGEOT-6386 Polyconic Sphere QA Cleanup\n\nGEOT-6386 unit tests for spherical polyconic\n\nGEOT-6386 Polyconic Sphere QA Cleanup"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU5OTMyMTEx", "url": "https://github.com/geotools/geotools/pull/3087#pullrequestreview-459932111", "createdAt": "2020-08-03T10:51:32Z", "commit": {"oid": "9d3fdfa1574dafa37e5da1dd58cdc6f178e11e80"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wM1QxMDo1MTozMlrOG60_9Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wM1QxMDo1MTo0MFrOG61AJA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDMzODkzMw==", "bodyText": "Inefficient and incoherent with the implemented interface, ptDst should be used when present. When reprojecting lots of points, the machinery passes a single target point to avoid excessive object allocation.", "url": "https://github.com/geotools/geotools/pull/3087#discussion_r464338933", "createdAt": "2020-08-03T10:51:32Z", "author": {"login": "aaime"}, "path": "modules/library/referencing/src/main/java/org/geotools/referencing/operation/projection/Polyconic.java", "diffHunk": "@@ -74,133 +73,212 @@\n     /** Difference allowed in iterative computations. */\n     private static final double ITERATION_TOLERANCE = 1E-12;\n \n-    /**\n-     * Meridian distance at the {@code latitudeOfOrigin}. Used for calculations for the ellipsoid.\n-     */\n-    private final double ml0;\n+    public abstract static class Abstract extends MapProjection {\n+        /**\n+         * Meridian distance at the {@code latitudeOfOrigin}. Used for calculations for the\n+         * ellipsoid.\n+         */\n+        protected final double ml0;\n+        /**\n+         * Constructs a new map projection from the supplied parameters.\n+         *\n+         * @param parameters The parameter values in standard units.\n+         * @throws ParameterNotFoundException if a mandatory parameter is missing.\n+         */\n+        protected Abstract(final ParameterValueGroup parameters) throws ParameterNotFoundException {\n \n-    /**\n-     * Constructs a new map projection from the supplied parameters.\n-     *\n-     * @param parameters The parameter values in standard units.\n-     * @throws ParameterNotFoundException if a mandatory parameter is missing.\n-     */\n-    protected Polyconic(final ParameterValueGroup parameters) throws ParameterNotFoundException {\n-        super(parameters);\n+            super(parameters);\n \n-        //  Compute constants\n-        ml0 = mlfn(latitudeOfOrigin, sin(latitudeOfOrigin), cos(latitudeOfOrigin));\n-    }\n+            //  Compute constants\n+            ml0 = mlfn(latitudeOfOrigin, sin(latitudeOfOrigin), cos(latitudeOfOrigin));\n+        }\n \n-    /** {@inheritDoc} */\n-    public ParameterDescriptorGroup getParameterDescriptors() {\n-        return Provider.PARAMETERS;\n-    }\n+        /** {@inheritDoc} */\n+        public ParameterDescriptorGroup getParameterDescriptors() {\n+            return Provider.PARAMETERS;\n+        }\n \n-    /**\n-     * Transforms the specified (<var>&lambda;</var>,<var>&phi;</var>) coordinates (units in\n-     * radians) and stores the result in {@code ptDst} (linear distance on a unit sphere).\n-     */\n-    protected Point2D transformNormalized(double lam, double phi, final Point2D ptDst)\n-            throws ProjectionException {\n-        double ms, sp, cp, x, y;\n+        @Override\n+        protected double getToleranceForAssertions(double longitude, double latitude) {\n+            if (abs(longitude - centralMeridian) / 2 + abs(latitude - latitudeOfOrigin) > 10) {\n+                // When far from the valid area, use a larger tolerance.\n+                return 0.1;\n+            }\n+            return super.getToleranceForAssertions(longitude, latitude);\n+        }\n \n-        if (abs(phi) <= EPSILON) {\n-            x = lam;\n-            y = -ml0;\n-        } else {\n-            sp = sin(phi);\n-            ms = abs(cp = cos(phi)) > EPSILON ? msfn(sp, cp) / sp : 0.;\n-            lam *= sp;\n-            x = ms * sin(lam);\n-            y = (mlfn(phi, sp, cp) - ml0) + ms * (1. - cos(lam));\n+        /** Returns a hash value for this projection. */\n+        @Override\n+        public int hashCode() {\n+            final long code = Double.doubleToLongBits(ml0);\n+            return ((int) code ^ (int) (code >>> 32)) + 37 * super.hashCode();\n         }\n \n-        if (ptDst != null) {\n-            ptDst.setLocation(x, y);\n-            return ptDst;\n+        /** Compares the specified object with this map projection for equality. */\n+        @Override\n+        public boolean equals(final Object object) {\n+            if (object == this) {\n+                // Slight optimization\n+                return true;\n+            }\n+            if (super.equals(object)) {\n+                final Abstract that = (Abstract) object;\n+                return equals(this.ml0, that.ml0);\n+            }\n+            return false;\n         }\n-        return new Point2D.Double(x, y);\n     }\n \n-    /**\n-     * Transforms the specified (<var>x</var>,<var>y</var>) coordinates and stores the result in\n-     * {@code ptDst}.\n-     */\n-    protected Point2D inverseTransformNormalized(double x, double y, final Point2D ptDst)\n-            throws ProjectionException {\n-        double lam, phi;\n-\n-        y += ml0;\n-        if (abs(y) <= EPSILON) {\n-            lam = x;\n-            phi = 0.;\n-        } else {\n-            final double r = y * y + x * x;\n-            phi = y;\n-            int i = 0;\n-            for (; i <= MAXIMUM_ITERATIONS; i++) {\n-                final double sp = sin(phi);\n-                final double cp = cos(phi);\n-                if (abs(cp) < ITERATION_TOLERANCE)\n-                    throw new ProjectionException(ErrorKeys.NO_CONVERGENCE);\n+    /** Ellipsoidal Polyconic projection. */\n+    @SuppressWarnings(\"serial\")\n+    public static class Ellipsoidal extends Abstract {\n+        /**\n+         * Constructor.\n+         *\n+         * @param parameters the parameters that define this projection\n+         * @throws ParameterNotFoundException\n+         */\n+        protected Ellipsoidal(ParameterValueGroup parameters) throws ParameterNotFoundException {\n+            super(parameters);\n+        }\n+        /**\n+         * Transforms the specified (<var>&lambda;</var>,<var>&phi;</var>) coordinates (units in\n+         * radians) and stores the result in {@code ptDst} (linear distance on a unit sphere).\n+         */\n+        protected Point2D transformNormalized(double lam, double phi, final Point2D ptDst)\n+                throws ProjectionException {\n+            double ms, sp, cp, x, y;\n \n-                final double s2ph = sp * cp;\n-                double mlp = sqrt(1. - excentricitySquared * sp * sp);\n-                final double c = sp * mlp / cp;\n-                final double ml = mlfn(phi, sp, cp);\n-                final double mlb = ml * ml + r;\n-                mlp = (1. - excentricitySquared) / (mlp * mlp * mlp);\n-                final double dPhi =\n-                        (ml + ml + c * mlb - 2. * y * (c * ml + 1.))\n-                                / (excentricitySquared * s2ph * (mlb - 2. * y * ml) / c\n-                                        + 2. * (y - ml) * (c * mlp - 1. / s2ph)\n-                                        - mlp\n-                                        - mlp);\n-                if (abs(dPhi) <= ITERATION_TOLERANCE) break;\n+            if (abs(phi) <= EPSILON) {\n+                x = lam;\n+                y = -ml0;\n+            } else {\n+                sp = sin(phi);\n+                ms = abs(cp = cos(phi)) > EPSILON ? msfn(sp, cp) / sp : 0.;\n+                lam *= sp;\n+                x = ms * sin(lam);\n+                y = (mlfn(phi, sp, cp) - ml0) + ms * (1. - cos(lam));\n+            }\n \n-                phi += dPhi;\n+            if (ptDst != null) {\n+                ptDst.setLocation(x, y);\n+                return ptDst;\n             }\n-            if (i > MAXIMUM_ITERATIONS) throw new ProjectionException(ErrorKeys.NO_CONVERGENCE);\n-            final double c = sin(phi);\n-            lam = asin(x * tan(phi) * sqrt(1. - excentricitySquared * c * c)) / sin(phi);\n+            return new Point2D.Double(x, y);\n         }\n \n-        if (ptDst != null) {\n-            ptDst.setLocation(lam, phi);\n-            return ptDst;\n-        }\n-        return new Point2D.Double(lam, phi);\n-    }\n+        /**\n+         * Transforms the specified (<var>x</var>,<var>y</var>) coordinates and stores the result in\n+         * {@code ptDst}.\n+         */\n+        protected Point2D inverseTransformNormalized(double x, double y, final Point2D ptDst)\n+                throws ProjectionException {\n+            double lam, phi;\n+\n+            y += ml0;\n+            if (abs(y) <= EPSILON) {\n+                lam = x;\n+                phi = 0.;\n+            } else {\n+                final double r = y * y + x * x;\n+                phi = y;\n+                int i = 0;\n+                for (; i <= MAXIMUM_ITERATIONS; i++) {\n+                    final double sp = sin(phi);\n+                    final double cp = cos(phi);\n+                    if (abs(cp) < ITERATION_TOLERANCE)\n+                        throw new ProjectionException(ErrorKeys.NO_CONVERGENCE);\n+\n+                    final double s2ph = sp * cp;\n+                    double mlp = sqrt(1. - excentricitySquared * sp * sp);\n+                    final double c = sp * mlp / cp;\n+                    final double ml = mlfn(phi, sp, cp);\n+                    final double mlb = ml * ml + r;\n+                    mlp = (1. - excentricitySquared) / (mlp * mlp * mlp);\n+                    final double dPhi =\n+                            (ml + ml + c * mlb - 2. * y * (c * ml + 1.))\n+                                    / (excentricitySquared * s2ph * (mlb - 2. * y * ml) / c\n+                                            + 2. * (y - ml) * (c * mlp - 1. / s2ph)\n+                                            - mlp\n+                                            - mlp);\n+                    if (abs(dPhi) <= ITERATION_TOLERANCE) break;\n \n-    @Override\n-    protected double getToleranceForAssertions(double longitude, double latitude) {\n-        if (abs(longitude - centralMeridian) / 2 + abs(latitude - latitudeOfOrigin) > 10) {\n-            // When far from the valid area, use a larger tolerance.\n-            return 0.1;\n+                    phi += dPhi;\n+                }\n+                if (i > MAXIMUM_ITERATIONS) throw new ProjectionException(ErrorKeys.NO_CONVERGENCE);\n+                final double c = sin(phi);\n+                lam = asin(x * tan(phi) * sqrt(1. - excentricitySquared * c * c)) / sin(phi);\n+            }\n+\n+            if (ptDst != null) {\n+                ptDst.setLocation(lam, phi);\n+                return ptDst;\n+            }\n+            return new Point2D.Double(lam, phi);\n         }\n-        return super.getToleranceForAssertions(longitude, latitude);\n     }\n \n-    /** Returns a hash value for this projection. */\n-    @Override\n-    public int hashCode() {\n-        final long code = Double.doubleToLongBits(ml0);\n-        return ((int) code ^ (int) (code >>> 32)) + 37 * super.hashCode();\n-    }\n+    /** Ellipsoidal Polyconic projection. */\n+    @SuppressWarnings(\"serial\")\n+    public static class Spherical extends Abstract {\n \n-    /** Compares the specified object with this map projection for equality. */\n-    @Override\n-    public boolean equals(final Object object) {\n-        if (object == this) {\n-            // Slight optimization\n-            return true;\n+        /**\n+         * Constructs a new map projection from the supplied parameters.\n+         *\n+         * @param parameters The parameter values in standard units.\n+         * @throws ParameterNotFoundException if a mandatory parameter is missing.\n+         */\n+        protected Spherical(ParameterValueGroup parameters) throws ParameterNotFoundException {\n+            super(parameters);\n         }\n-        if (super.equals(object)) {\n-            final Polyconic that = (Polyconic) object;\n-            return equals(this.ml0, that.ml0);\n+\n+        @Override\n+        protected Point2D inverseTransformNormalized(double x, double y, Point2D ptDst)\n+                throws ProjectionException {\n+            double lam, phi;\n+            if (abs(y = latitudeOfOrigin + y) <= EPSILON) {\n+                lam = x;\n+                phi = 0.;\n+            } else {\n+                phi = y;\n+                double B = x * x + y * y;\n+                int i = MAXIMUM_ITERATIONS;\n+                while (true) {\n+                    double tp = tan(phi);\n+                    double dphi =\n+                            (y * (phi * tp + 1.) - phi - .5 * (phi * phi + B) * tp)\n+                                    / ((phi - y) / tp - 1.);\n+                    phi -= dphi;\n+                    if (!(abs(dphi) > ITERATION_TOLERANCE)) break;\n+                    --i;\n+                    if (i == 0) {\n+                        throw new ProjectionException(ErrorKeys.NO_CONVERGENCE);\n+                    }\n+                }\n+                lam = asin(x * tan(phi)) / sin(phi);\n+            }\n+            return new Point2D.Double(lam, phi);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9d3fdfa1574dafa37e5da1dd58cdc6f178e11e80"}, "originalPosition": 309}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDMzODk4MA==", "bodyText": "Same as above.", "url": "https://github.com/geotools/geotools/pull/3087#discussion_r464338980", "createdAt": "2020-08-03T10:51:40Z", "author": {"login": "aaime"}, "path": "modules/library/referencing/src/main/java/org/geotools/referencing/operation/projection/Polyconic.java", "diffHunk": "@@ -74,133 +73,212 @@\n     /** Difference allowed in iterative computations. */\n     private static final double ITERATION_TOLERANCE = 1E-12;\n \n-    /**\n-     * Meridian distance at the {@code latitudeOfOrigin}. Used for calculations for the ellipsoid.\n-     */\n-    private final double ml0;\n+    public abstract static class Abstract extends MapProjection {\n+        /**\n+         * Meridian distance at the {@code latitudeOfOrigin}. Used for calculations for the\n+         * ellipsoid.\n+         */\n+        protected final double ml0;\n+        /**\n+         * Constructs a new map projection from the supplied parameters.\n+         *\n+         * @param parameters The parameter values in standard units.\n+         * @throws ParameterNotFoundException if a mandatory parameter is missing.\n+         */\n+        protected Abstract(final ParameterValueGroup parameters) throws ParameterNotFoundException {\n \n-    /**\n-     * Constructs a new map projection from the supplied parameters.\n-     *\n-     * @param parameters The parameter values in standard units.\n-     * @throws ParameterNotFoundException if a mandatory parameter is missing.\n-     */\n-    protected Polyconic(final ParameterValueGroup parameters) throws ParameterNotFoundException {\n-        super(parameters);\n+            super(parameters);\n \n-        //  Compute constants\n-        ml0 = mlfn(latitudeOfOrigin, sin(latitudeOfOrigin), cos(latitudeOfOrigin));\n-    }\n+            //  Compute constants\n+            ml0 = mlfn(latitudeOfOrigin, sin(latitudeOfOrigin), cos(latitudeOfOrigin));\n+        }\n \n-    /** {@inheritDoc} */\n-    public ParameterDescriptorGroup getParameterDescriptors() {\n-        return Provider.PARAMETERS;\n-    }\n+        /** {@inheritDoc} */\n+        public ParameterDescriptorGroup getParameterDescriptors() {\n+            return Provider.PARAMETERS;\n+        }\n \n-    /**\n-     * Transforms the specified (<var>&lambda;</var>,<var>&phi;</var>) coordinates (units in\n-     * radians) and stores the result in {@code ptDst} (linear distance on a unit sphere).\n-     */\n-    protected Point2D transformNormalized(double lam, double phi, final Point2D ptDst)\n-            throws ProjectionException {\n-        double ms, sp, cp, x, y;\n+        @Override\n+        protected double getToleranceForAssertions(double longitude, double latitude) {\n+            if (abs(longitude - centralMeridian) / 2 + abs(latitude - latitudeOfOrigin) > 10) {\n+                // When far from the valid area, use a larger tolerance.\n+                return 0.1;\n+            }\n+            return super.getToleranceForAssertions(longitude, latitude);\n+        }\n \n-        if (abs(phi) <= EPSILON) {\n-            x = lam;\n-            y = -ml0;\n-        } else {\n-            sp = sin(phi);\n-            ms = abs(cp = cos(phi)) > EPSILON ? msfn(sp, cp) / sp : 0.;\n-            lam *= sp;\n-            x = ms * sin(lam);\n-            y = (mlfn(phi, sp, cp) - ml0) + ms * (1. - cos(lam));\n+        /** Returns a hash value for this projection. */\n+        @Override\n+        public int hashCode() {\n+            final long code = Double.doubleToLongBits(ml0);\n+            return ((int) code ^ (int) (code >>> 32)) + 37 * super.hashCode();\n         }\n \n-        if (ptDst != null) {\n-            ptDst.setLocation(x, y);\n-            return ptDst;\n+        /** Compares the specified object with this map projection for equality. */\n+        @Override\n+        public boolean equals(final Object object) {\n+            if (object == this) {\n+                // Slight optimization\n+                return true;\n+            }\n+            if (super.equals(object)) {\n+                final Abstract that = (Abstract) object;\n+                return equals(this.ml0, that.ml0);\n+            }\n+            return false;\n         }\n-        return new Point2D.Double(x, y);\n     }\n \n-    /**\n-     * Transforms the specified (<var>x</var>,<var>y</var>) coordinates and stores the result in\n-     * {@code ptDst}.\n-     */\n-    protected Point2D inverseTransformNormalized(double x, double y, final Point2D ptDst)\n-            throws ProjectionException {\n-        double lam, phi;\n-\n-        y += ml0;\n-        if (abs(y) <= EPSILON) {\n-            lam = x;\n-            phi = 0.;\n-        } else {\n-            final double r = y * y + x * x;\n-            phi = y;\n-            int i = 0;\n-            for (; i <= MAXIMUM_ITERATIONS; i++) {\n-                final double sp = sin(phi);\n-                final double cp = cos(phi);\n-                if (abs(cp) < ITERATION_TOLERANCE)\n-                    throw new ProjectionException(ErrorKeys.NO_CONVERGENCE);\n+    /** Ellipsoidal Polyconic projection. */\n+    @SuppressWarnings(\"serial\")\n+    public static class Ellipsoidal extends Abstract {\n+        /**\n+         * Constructor.\n+         *\n+         * @param parameters the parameters that define this projection\n+         * @throws ParameterNotFoundException\n+         */\n+        protected Ellipsoidal(ParameterValueGroup parameters) throws ParameterNotFoundException {\n+            super(parameters);\n+        }\n+        /**\n+         * Transforms the specified (<var>&lambda;</var>,<var>&phi;</var>) coordinates (units in\n+         * radians) and stores the result in {@code ptDst} (linear distance on a unit sphere).\n+         */\n+        protected Point2D transformNormalized(double lam, double phi, final Point2D ptDst)\n+                throws ProjectionException {\n+            double ms, sp, cp, x, y;\n \n-                final double s2ph = sp * cp;\n-                double mlp = sqrt(1. - excentricitySquared * sp * sp);\n-                final double c = sp * mlp / cp;\n-                final double ml = mlfn(phi, sp, cp);\n-                final double mlb = ml * ml + r;\n-                mlp = (1. - excentricitySquared) / (mlp * mlp * mlp);\n-                final double dPhi =\n-                        (ml + ml + c * mlb - 2. * y * (c * ml + 1.))\n-                                / (excentricitySquared * s2ph * (mlb - 2. * y * ml) / c\n-                                        + 2. * (y - ml) * (c * mlp - 1. / s2ph)\n-                                        - mlp\n-                                        - mlp);\n-                if (abs(dPhi) <= ITERATION_TOLERANCE) break;\n+            if (abs(phi) <= EPSILON) {\n+                x = lam;\n+                y = -ml0;\n+            } else {\n+                sp = sin(phi);\n+                ms = abs(cp = cos(phi)) > EPSILON ? msfn(sp, cp) / sp : 0.;\n+                lam *= sp;\n+                x = ms * sin(lam);\n+                y = (mlfn(phi, sp, cp) - ml0) + ms * (1. - cos(lam));\n+            }\n \n-                phi += dPhi;\n+            if (ptDst != null) {\n+                ptDst.setLocation(x, y);\n+                return ptDst;\n             }\n-            if (i > MAXIMUM_ITERATIONS) throw new ProjectionException(ErrorKeys.NO_CONVERGENCE);\n-            final double c = sin(phi);\n-            lam = asin(x * tan(phi) * sqrt(1. - excentricitySquared * c * c)) / sin(phi);\n+            return new Point2D.Double(x, y);\n         }\n \n-        if (ptDst != null) {\n-            ptDst.setLocation(lam, phi);\n-            return ptDst;\n-        }\n-        return new Point2D.Double(lam, phi);\n-    }\n+        /**\n+         * Transforms the specified (<var>x</var>,<var>y</var>) coordinates and stores the result in\n+         * {@code ptDst}.\n+         */\n+        protected Point2D inverseTransformNormalized(double x, double y, final Point2D ptDst)\n+                throws ProjectionException {\n+            double lam, phi;\n+\n+            y += ml0;\n+            if (abs(y) <= EPSILON) {\n+                lam = x;\n+                phi = 0.;\n+            } else {\n+                final double r = y * y + x * x;\n+                phi = y;\n+                int i = 0;\n+                for (; i <= MAXIMUM_ITERATIONS; i++) {\n+                    final double sp = sin(phi);\n+                    final double cp = cos(phi);\n+                    if (abs(cp) < ITERATION_TOLERANCE)\n+                        throw new ProjectionException(ErrorKeys.NO_CONVERGENCE);\n+\n+                    final double s2ph = sp * cp;\n+                    double mlp = sqrt(1. - excentricitySquared * sp * sp);\n+                    final double c = sp * mlp / cp;\n+                    final double ml = mlfn(phi, sp, cp);\n+                    final double mlb = ml * ml + r;\n+                    mlp = (1. - excentricitySquared) / (mlp * mlp * mlp);\n+                    final double dPhi =\n+                            (ml + ml + c * mlb - 2. * y * (c * ml + 1.))\n+                                    / (excentricitySquared * s2ph * (mlb - 2. * y * ml) / c\n+                                            + 2. * (y - ml) * (c * mlp - 1. / s2ph)\n+                                            - mlp\n+                                            - mlp);\n+                    if (abs(dPhi) <= ITERATION_TOLERANCE) break;\n \n-    @Override\n-    protected double getToleranceForAssertions(double longitude, double latitude) {\n-        if (abs(longitude - centralMeridian) / 2 + abs(latitude - latitudeOfOrigin) > 10) {\n-            // When far from the valid area, use a larger tolerance.\n-            return 0.1;\n+                    phi += dPhi;\n+                }\n+                if (i > MAXIMUM_ITERATIONS) throw new ProjectionException(ErrorKeys.NO_CONVERGENCE);\n+                final double c = sin(phi);\n+                lam = asin(x * tan(phi) * sqrt(1. - excentricitySquared * c * c)) / sin(phi);\n+            }\n+\n+            if (ptDst != null) {\n+                ptDst.setLocation(lam, phi);\n+                return ptDst;\n+            }\n+            return new Point2D.Double(lam, phi);\n         }\n-        return super.getToleranceForAssertions(longitude, latitude);\n     }\n \n-    /** Returns a hash value for this projection. */\n-    @Override\n-    public int hashCode() {\n-        final long code = Double.doubleToLongBits(ml0);\n-        return ((int) code ^ (int) (code >>> 32)) + 37 * super.hashCode();\n-    }\n+    /** Ellipsoidal Polyconic projection. */\n+    @SuppressWarnings(\"serial\")\n+    public static class Spherical extends Abstract {\n \n-    /** Compares the specified object with this map projection for equality. */\n-    @Override\n-    public boolean equals(final Object object) {\n-        if (object == this) {\n-            // Slight optimization\n-            return true;\n+        /**\n+         * Constructs a new map projection from the supplied parameters.\n+         *\n+         * @param parameters The parameter values in standard units.\n+         * @throws ParameterNotFoundException if a mandatory parameter is missing.\n+         */\n+        protected Spherical(ParameterValueGroup parameters) throws ParameterNotFoundException {\n+            super(parameters);\n         }\n-        if (super.equals(object)) {\n-            final Polyconic that = (Polyconic) object;\n-            return equals(this.ml0, that.ml0);\n+\n+        @Override\n+        protected Point2D inverseTransformNormalized(double x, double y, Point2D ptDst)\n+                throws ProjectionException {\n+            double lam, phi;\n+            if (abs(y = latitudeOfOrigin + y) <= EPSILON) {\n+                lam = x;\n+                phi = 0.;\n+            } else {\n+                phi = y;\n+                double B = x * x + y * y;\n+                int i = MAXIMUM_ITERATIONS;\n+                while (true) {\n+                    double tp = tan(phi);\n+                    double dphi =\n+                            (y * (phi * tp + 1.) - phi - .5 * (phi * phi + B) * tp)\n+                                    / ((phi - y) / tp - 1.);\n+                    phi -= dphi;\n+                    if (!(abs(dphi) > ITERATION_TOLERANCE)) break;\n+                    --i;\n+                    if (i == 0) {\n+                        throw new ProjectionException(ErrorKeys.NO_CONVERGENCE);\n+                    }\n+                }\n+                lam = asin(x * tan(phi)) / sin(phi);\n+            }\n+            return new Point2D.Double(lam, phi);\n+        }\n+\n+        @Override\n+        protected Point2D transformNormalized(double lam, double phi, Point2D ptDst)\n+                throws ProjectionException {\n+            double x, y;\n+            if (abs(phi) <= EPSILON) {\n+                x = lam;\n+                y = ml0;\n+            } else {\n+                double cot = 1. / tan(phi);\n+                double E = lam * sin(phi);\n+                x = sin(E) * cot;\n+                y = phi - latitudeOfOrigin + cot * (1. - cos(E));\n+            }\n+            if (ptDst != null) {\n+                ptDst.setLocation(x, y);\n+                return ptDst;\n+            }\n+            return new Point2D.Double(x, y);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9d3fdfa1574dafa37e5da1dd58cdc6f178e11e80"}, "originalPosition": 329}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ed797db5146cba28ac2cb62e10fb5be48f9f5129", "author": {"user": {"login": "jmiller-self", "name": "Joseph Miller"}}, "url": "https://github.com/geotools/geotools/commit/ed797db5146cba28ac2cb62e10fb5be48f9f5129", "committedDate": "2020-08-03T21:58:55Z", "message": "addressed PR comment about returning ptDst"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3119, "cost": 1, "resetAt": "2021-11-01T14:20:25Z"}}}