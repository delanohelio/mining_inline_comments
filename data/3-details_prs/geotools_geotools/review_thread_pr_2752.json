{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzYzMTU0Nzg5", "number": 2752, "reviewThreads": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNlQwOTo0Mzo0NFrODYcW5Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNlQwOTo1NToyNFrODYclSg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI2OTU3MDI5OnYy", "diffSide": "RIGHT", "path": "modules/library/coverage/src/main/java/org/geotools/coverage/processing/operation/Mosaic.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNlQwOTo0Mzo0NFrOFeTZqQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNlQwOTo0Mzo0NFrOFeTZqQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzMxOTQ2NQ==", "bodyText": "Good catch, ROI.add does not modify the current ROI, it builds a new one.", "url": "https://github.com/geotools/geotools/pull/2752#discussion_r367319465", "createdAt": "2020-01-16T09:43:44Z", "author": {"login": "aaime"}, "path": "modules/library/coverage/src/main/java/org/geotools/coverage/processing/operation/Mosaic.java", "diffHunk": "@@ -972,15 +972,16 @@ protected RenderedImage createRenderedImage(\n                 } else if (rois[i] == null) {\n                     // no ROI, the image is full\n                     RenderedImage ri = sources[i].getRenderedImage();\n-                    finalROI.add(\n-                            new ROIShape(\n-                                    new Rectangle2D.Double(\n-                                            ri.getMinX(),\n-                                            ri.getMinY(),\n-                                            ri.getWidth(),\n-                                            ri.getHeight())));\n+                    finalROI =", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0453c5f934afeff74078b792522dac4db4e876bb"}, "originalPosition": 11}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI2OTU3NjUzOnYy", "diffSide": "RIGHT", "path": "modules/library/main/src/main/java/org/geotools/renderer/crs/ProjectionHandler.java", "isResolved": false, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNlQwOTo0NTo0OVrOFeTdbg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNlQxMTozMzo1MFrOFeWdRw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzMyMDQzMA==", "bodyText": "Confused, any reason not to use a fullCircles and avoid the divisions later?", "url": "https://github.com/geotools/geotools/pull/2752#discussion_r367320430", "createdAt": "2020-01-16T09:45:49Z", "author": {"login": "aaime"}, "path": "modules/library/main/src/main/java/org/geotools/renderer/crs/ProjectionHandler.java", "diffHunk": "@@ -343,29 +306,132 @@ private void addTransformedEnvelope(ReferencedEnvelope re, List<ReferencedEnvelo\n         // have no idea at all) we don't actually split, but add elements\n         List<ReferencedEnvelope> envelopes = new ArrayList<ReferencedEnvelope>();\n         envelopes.add(re);\n-        if (re.getMinX() < -180) {\n-            envelopes.add(\n-                    new ReferencedEnvelope(\n-                            re.getMinX() + 360,\n-                            Math.min(re.getMaxX() + 360, 180),\n-                            re.getMinY(),\n-                            re.getMaxY(),\n-                            re.getCoordinateReferenceSystem()));\n-        }\n-        if (re.getMaxX() > 180) {\n-            envelopes.add(\n-                    new ReferencedEnvelope(\n-                            Math.max(re.getMinX() - 360, -180),\n-                            re.getMaxX() - 360,\n-                            re.getMinY(),\n-                            re.getMaxY(),\n-                            re.getCoordinateReferenceSystem()));\n-        }\n+        adjustEnvelope(re, envelopes, false);\n         mergeEnvelopes(envelopes);\n         reprojectEnvelopes(sourceCRS, envelopes);\n         return envelopes.stream().filter(e -> e != null).collect(Collectors.toList());\n     }\n \n+    /**\n+     * Adjust the envelope by taking into account dateline wrapping as well as multiple spans of the\n+     * whole world extent. When transform flag is true, the envelopes will be transformed before\n+     * being returned\n+     */\n+    private void adjustEnvelope(\n+            ReferencedEnvelope re, List<ReferencedEnvelope> envelopes, boolean transform)\n+            throws TransformException, FactoryException {\n+        CoordinateReferenceSystem crs = re.getCoordinateReferenceSystem();\n+        boolean isLatLon = CRS.getAxisOrder(crs) == CRS.AxisOrder.NORTH_EAST;\n+        double minX = isLatLon ? re.getMinY() : re.getMinX();\n+        double maxX = isLatLon ? re.getMaxY() : re.getMaxX();\n+        double minY = isLatLon ? re.getMinX() : re.getMinY();\n+        double maxY = isLatLon ? re.getMaxX() : re.getMaxY();\n+        double extent = maxX - minX;\n+        List<ReferencedEnvelope> envelopesToBeAdded = new ArrayList<>();\n+        if (extent > 360) {\n+            // at least one whole world use case -> requested data covers the full world:\n+            // let's set a -180,180 bbox.\n+            // the wrapping projectionHandler and the gridCoverageReaders\n+            // will do proper clones / intersections afterwards\n+            minX = -180;\n+            maxX = 180;\n+            // Create a whole world envelope taking into account latLon/lonLat\n+            ReferencedEnvelope envelope =\n+                    new ReferencedEnvelope(\n+                            isLatLon ? minY : minX,\n+                            isLatLon ? maxY : maxX,\n+                            isLatLon ? minX : minY,\n+                            isLatLon ? maxX : maxY,\n+                            crs);\n+            envelopesToBeAdded.add(envelope);\n+        } else {\n+            // let's do some adjustments to \"shift\" the request around -180, 180 interval:\n+            // we basically add or subtract 360\u00b0 N times\n+            // 1) let's count how many halfCircles (a 180\u00b0 span) we are away from the zero\n+\n+            // 2) add/subtract 360\u00b0 N times to move forward/backward the request, also\n+            // keeping into account whether we are crossing the dateline or not\n+            // (halfCircles % 2)\n+\n+            // 3) add/subtract the original extent to get the other value of the interval\n+            // in order to move the whole window (Note that the extent won't be > 360\u00b0\n+            // since we are inside the \"else\")\n+\n+            int halfCircles = 0;\n+            if (minX < -180) {\n+                halfCircles = (int) ((Math.abs(minX) / 180));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0453c5f934afeff74078b792522dac4db4e876bb"}, "originalPosition": 139}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzMyOTgyOA==", "bodyText": "I'm using the halfCircles for the (halfCircles % 2) part which introduces an eventual +1 when the number of halfCircles is odd.", "url": "https://github.com/geotools/geotools/pull/2752#discussion_r367329828", "createdAt": "2020-01-16T10:04:41Z", "author": {"login": "dromagnoli"}, "path": "modules/library/main/src/main/java/org/geotools/renderer/crs/ProjectionHandler.java", "diffHunk": "@@ -343,29 +306,132 @@ private void addTransformedEnvelope(ReferencedEnvelope re, List<ReferencedEnvelo\n         // have no idea at all) we don't actually split, but add elements\n         List<ReferencedEnvelope> envelopes = new ArrayList<ReferencedEnvelope>();\n         envelopes.add(re);\n-        if (re.getMinX() < -180) {\n-            envelopes.add(\n-                    new ReferencedEnvelope(\n-                            re.getMinX() + 360,\n-                            Math.min(re.getMaxX() + 360, 180),\n-                            re.getMinY(),\n-                            re.getMaxY(),\n-                            re.getCoordinateReferenceSystem()));\n-        }\n-        if (re.getMaxX() > 180) {\n-            envelopes.add(\n-                    new ReferencedEnvelope(\n-                            Math.max(re.getMinX() - 360, -180),\n-                            re.getMaxX() - 360,\n-                            re.getMinY(),\n-                            re.getMaxY(),\n-                            re.getCoordinateReferenceSystem()));\n-        }\n+        adjustEnvelope(re, envelopes, false);\n         mergeEnvelopes(envelopes);\n         reprojectEnvelopes(sourceCRS, envelopes);\n         return envelopes.stream().filter(e -> e != null).collect(Collectors.toList());\n     }\n \n+    /**\n+     * Adjust the envelope by taking into account dateline wrapping as well as multiple spans of the\n+     * whole world extent. When transform flag is true, the envelopes will be transformed before\n+     * being returned\n+     */\n+    private void adjustEnvelope(\n+            ReferencedEnvelope re, List<ReferencedEnvelope> envelopes, boolean transform)\n+            throws TransformException, FactoryException {\n+        CoordinateReferenceSystem crs = re.getCoordinateReferenceSystem();\n+        boolean isLatLon = CRS.getAxisOrder(crs) == CRS.AxisOrder.NORTH_EAST;\n+        double minX = isLatLon ? re.getMinY() : re.getMinX();\n+        double maxX = isLatLon ? re.getMaxY() : re.getMaxX();\n+        double minY = isLatLon ? re.getMinX() : re.getMinY();\n+        double maxY = isLatLon ? re.getMaxX() : re.getMaxY();\n+        double extent = maxX - minX;\n+        List<ReferencedEnvelope> envelopesToBeAdded = new ArrayList<>();\n+        if (extent > 360) {\n+            // at least one whole world use case -> requested data covers the full world:\n+            // let's set a -180,180 bbox.\n+            // the wrapping projectionHandler and the gridCoverageReaders\n+            // will do proper clones / intersections afterwards\n+            minX = -180;\n+            maxX = 180;\n+            // Create a whole world envelope taking into account latLon/lonLat\n+            ReferencedEnvelope envelope =\n+                    new ReferencedEnvelope(\n+                            isLatLon ? minY : minX,\n+                            isLatLon ? maxY : maxX,\n+                            isLatLon ? minX : minY,\n+                            isLatLon ? maxX : maxY,\n+                            crs);\n+            envelopesToBeAdded.add(envelope);\n+        } else {\n+            // let's do some adjustments to \"shift\" the request around -180, 180 interval:\n+            // we basically add or subtract 360\u00b0 N times\n+            // 1) let's count how many halfCircles (a 180\u00b0 span) we are away from the zero\n+\n+            // 2) add/subtract 360\u00b0 N times to move forward/backward the request, also\n+            // keeping into account whether we are crossing the dateline or not\n+            // (halfCircles % 2)\n+\n+            // 3) add/subtract the original extent to get the other value of the interval\n+            // in order to move the whole window (Note that the extent won't be > 360\u00b0\n+            // since we are inside the \"else\")\n+\n+            int halfCircles = 0;\n+            if (minX < -180) {\n+                halfCircles = (int) ((Math.abs(minX) / 180));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzMyMDQzMA=="}, "originalCommit": {"oid": "0453c5f934afeff74078b792522dac4db4e876bb"}, "originalPosition": 139}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzM2NzYyNg==", "bodyText": "Cool, could you add comments to explain this better then? For next time someone looks at the code.", "url": "https://github.com/geotools/geotools/pull/2752#discussion_r367367626", "createdAt": "2020-01-16T11:29:09Z", "author": {"login": "aaime"}, "path": "modules/library/main/src/main/java/org/geotools/renderer/crs/ProjectionHandler.java", "diffHunk": "@@ -343,29 +306,132 @@ private void addTransformedEnvelope(ReferencedEnvelope re, List<ReferencedEnvelo\n         // have no idea at all) we don't actually split, but add elements\n         List<ReferencedEnvelope> envelopes = new ArrayList<ReferencedEnvelope>();\n         envelopes.add(re);\n-        if (re.getMinX() < -180) {\n-            envelopes.add(\n-                    new ReferencedEnvelope(\n-                            re.getMinX() + 360,\n-                            Math.min(re.getMaxX() + 360, 180),\n-                            re.getMinY(),\n-                            re.getMaxY(),\n-                            re.getCoordinateReferenceSystem()));\n-        }\n-        if (re.getMaxX() > 180) {\n-            envelopes.add(\n-                    new ReferencedEnvelope(\n-                            Math.max(re.getMinX() - 360, -180),\n-                            re.getMaxX() - 360,\n-                            re.getMinY(),\n-                            re.getMaxY(),\n-                            re.getCoordinateReferenceSystem()));\n-        }\n+        adjustEnvelope(re, envelopes, false);\n         mergeEnvelopes(envelopes);\n         reprojectEnvelopes(sourceCRS, envelopes);\n         return envelopes.stream().filter(e -> e != null).collect(Collectors.toList());\n     }\n \n+    /**\n+     * Adjust the envelope by taking into account dateline wrapping as well as multiple spans of the\n+     * whole world extent. When transform flag is true, the envelopes will be transformed before\n+     * being returned\n+     */\n+    private void adjustEnvelope(\n+            ReferencedEnvelope re, List<ReferencedEnvelope> envelopes, boolean transform)\n+            throws TransformException, FactoryException {\n+        CoordinateReferenceSystem crs = re.getCoordinateReferenceSystem();\n+        boolean isLatLon = CRS.getAxisOrder(crs) == CRS.AxisOrder.NORTH_EAST;\n+        double minX = isLatLon ? re.getMinY() : re.getMinX();\n+        double maxX = isLatLon ? re.getMaxY() : re.getMaxX();\n+        double minY = isLatLon ? re.getMinX() : re.getMinY();\n+        double maxY = isLatLon ? re.getMaxX() : re.getMaxY();\n+        double extent = maxX - minX;\n+        List<ReferencedEnvelope> envelopesToBeAdded = new ArrayList<>();\n+        if (extent > 360) {\n+            // at least one whole world use case -> requested data covers the full world:\n+            // let's set a -180,180 bbox.\n+            // the wrapping projectionHandler and the gridCoverageReaders\n+            // will do proper clones / intersections afterwards\n+            minX = -180;\n+            maxX = 180;\n+            // Create a whole world envelope taking into account latLon/lonLat\n+            ReferencedEnvelope envelope =\n+                    new ReferencedEnvelope(\n+                            isLatLon ? minY : minX,\n+                            isLatLon ? maxY : maxX,\n+                            isLatLon ? minX : minY,\n+                            isLatLon ? maxX : maxY,\n+                            crs);\n+            envelopesToBeAdded.add(envelope);\n+        } else {\n+            // let's do some adjustments to \"shift\" the request around -180, 180 interval:\n+            // we basically add or subtract 360\u00b0 N times\n+            // 1) let's count how many halfCircles (a 180\u00b0 span) we are away from the zero\n+\n+            // 2) add/subtract 360\u00b0 N times to move forward/backward the request, also\n+            // keeping into account whether we are crossing the dateline or not\n+            // (halfCircles % 2)\n+\n+            // 3) add/subtract the original extent to get the other value of the interval\n+            // in order to move the whole window (Note that the extent won't be > 360\u00b0\n+            // since we are inside the \"else\")\n+\n+            int halfCircles = 0;\n+            if (minX < -180) {\n+                halfCircles = (int) ((Math.abs(minX) / 180));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzMyMDQzMA=="}, "originalCommit": {"oid": "0453c5f934afeff74078b792522dac4db4e876bb"}, "originalPosition": 139}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzM2OTU0Mw==", "bodyText": "Yep. point 2) of the comment was reporting that. I'm going to explain it better", "url": "https://github.com/geotools/geotools/pull/2752#discussion_r367369543", "createdAt": "2020-01-16T11:33:50Z", "author": {"login": "dromagnoli"}, "path": "modules/library/main/src/main/java/org/geotools/renderer/crs/ProjectionHandler.java", "diffHunk": "@@ -343,29 +306,132 @@ private void addTransformedEnvelope(ReferencedEnvelope re, List<ReferencedEnvelo\n         // have no idea at all) we don't actually split, but add elements\n         List<ReferencedEnvelope> envelopes = new ArrayList<ReferencedEnvelope>();\n         envelopes.add(re);\n-        if (re.getMinX() < -180) {\n-            envelopes.add(\n-                    new ReferencedEnvelope(\n-                            re.getMinX() + 360,\n-                            Math.min(re.getMaxX() + 360, 180),\n-                            re.getMinY(),\n-                            re.getMaxY(),\n-                            re.getCoordinateReferenceSystem()));\n-        }\n-        if (re.getMaxX() > 180) {\n-            envelopes.add(\n-                    new ReferencedEnvelope(\n-                            Math.max(re.getMinX() - 360, -180),\n-                            re.getMaxX() - 360,\n-                            re.getMinY(),\n-                            re.getMaxY(),\n-                            re.getCoordinateReferenceSystem()));\n-        }\n+        adjustEnvelope(re, envelopes, false);\n         mergeEnvelopes(envelopes);\n         reprojectEnvelopes(sourceCRS, envelopes);\n         return envelopes.stream().filter(e -> e != null).collect(Collectors.toList());\n     }\n \n+    /**\n+     * Adjust the envelope by taking into account dateline wrapping as well as multiple spans of the\n+     * whole world extent. When transform flag is true, the envelopes will be transformed before\n+     * being returned\n+     */\n+    private void adjustEnvelope(\n+            ReferencedEnvelope re, List<ReferencedEnvelope> envelopes, boolean transform)\n+            throws TransformException, FactoryException {\n+        CoordinateReferenceSystem crs = re.getCoordinateReferenceSystem();\n+        boolean isLatLon = CRS.getAxisOrder(crs) == CRS.AxisOrder.NORTH_EAST;\n+        double minX = isLatLon ? re.getMinY() : re.getMinX();\n+        double maxX = isLatLon ? re.getMaxY() : re.getMaxX();\n+        double minY = isLatLon ? re.getMinX() : re.getMinY();\n+        double maxY = isLatLon ? re.getMaxX() : re.getMaxY();\n+        double extent = maxX - minX;\n+        List<ReferencedEnvelope> envelopesToBeAdded = new ArrayList<>();\n+        if (extent > 360) {\n+            // at least one whole world use case -> requested data covers the full world:\n+            // let's set a -180,180 bbox.\n+            // the wrapping projectionHandler and the gridCoverageReaders\n+            // will do proper clones / intersections afterwards\n+            minX = -180;\n+            maxX = 180;\n+            // Create a whole world envelope taking into account latLon/lonLat\n+            ReferencedEnvelope envelope =\n+                    new ReferencedEnvelope(\n+                            isLatLon ? minY : minX,\n+                            isLatLon ? maxY : maxX,\n+                            isLatLon ? minX : minY,\n+                            isLatLon ? maxX : maxY,\n+                            crs);\n+            envelopesToBeAdded.add(envelope);\n+        } else {\n+            // let's do some adjustments to \"shift\" the request around -180, 180 interval:\n+            // we basically add or subtract 360\u00b0 N times\n+            // 1) let's count how many halfCircles (a 180\u00b0 span) we are away from the zero\n+\n+            // 2) add/subtract 360\u00b0 N times to move forward/backward the request, also\n+            // keeping into account whether we are crossing the dateline or not\n+            // (halfCircles % 2)\n+\n+            // 3) add/subtract the original extent to get the other value of the interval\n+            // in order to move the whole window (Note that the extent won't be > 360\u00b0\n+            // since we are inside the \"else\")\n+\n+            int halfCircles = 0;\n+            if (minX < -180) {\n+                halfCircles = (int) ((Math.abs(minX) / 180));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzMyMDQzMA=="}, "originalCommit": {"oid": "0453c5f934afeff74078b792522dac4db4e876bb"}, "originalPosition": 139}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI2OTU4MTQ3OnYy", "diffSide": "RIGHT", "path": "modules/library/main/src/main/java/org/geotools/renderer/crs/ProjectionHandler.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNlQwOTo0NzoyNlrOFeTgXw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNlQxMToyOToyMlrOFeWWGQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzMyMTE4Mw==", "bodyText": "Isn't this triggering every time (maxX - minX) > 180? Doesn't mean the dateline has been crossed though.", "url": "https://github.com/geotools/geotools/pull/2752#discussion_r367321183", "createdAt": "2020-01-16T09:47:26Z", "author": {"login": "aaime"}, "path": "modules/library/main/src/main/java/org/geotools/renderer/crs/ProjectionHandler.java", "diffHunk": "@@ -343,29 +306,132 @@ private void addTransformedEnvelope(ReferencedEnvelope re, List<ReferencedEnvelo\n         // have no idea at all) we don't actually split, but add elements\n         List<ReferencedEnvelope> envelopes = new ArrayList<ReferencedEnvelope>();\n         envelopes.add(re);\n-        if (re.getMinX() < -180) {\n-            envelopes.add(\n-                    new ReferencedEnvelope(\n-                            re.getMinX() + 360,\n-                            Math.min(re.getMaxX() + 360, 180),\n-                            re.getMinY(),\n-                            re.getMaxY(),\n-                            re.getCoordinateReferenceSystem()));\n-        }\n-        if (re.getMaxX() > 180) {\n-            envelopes.add(\n-                    new ReferencedEnvelope(\n-                            Math.max(re.getMinX() - 360, -180),\n-                            re.getMaxX() - 360,\n-                            re.getMinY(),\n-                            re.getMaxY(),\n-                            re.getCoordinateReferenceSystem()));\n-        }\n+        adjustEnvelope(re, envelopes, false);\n         mergeEnvelopes(envelopes);\n         reprojectEnvelopes(sourceCRS, envelopes);\n         return envelopes.stream().filter(e -> e != null).collect(Collectors.toList());\n     }\n \n+    /**\n+     * Adjust the envelope by taking into account dateline wrapping as well as multiple spans of the\n+     * whole world extent. When transform flag is true, the envelopes will be transformed before\n+     * being returned\n+     */\n+    private void adjustEnvelope(\n+            ReferencedEnvelope re, List<ReferencedEnvelope> envelopes, boolean transform)\n+            throws TransformException, FactoryException {\n+        CoordinateReferenceSystem crs = re.getCoordinateReferenceSystem();\n+        boolean isLatLon = CRS.getAxisOrder(crs) == CRS.AxisOrder.NORTH_EAST;\n+        double minX = isLatLon ? re.getMinY() : re.getMinX();\n+        double maxX = isLatLon ? re.getMaxY() : re.getMaxX();\n+        double minY = isLatLon ? re.getMinX() : re.getMinY();\n+        double maxY = isLatLon ? re.getMaxX() : re.getMaxY();\n+        double extent = maxX - minX;\n+        List<ReferencedEnvelope> envelopesToBeAdded = new ArrayList<>();\n+        if (extent > 360) {\n+            // at least one whole world use case -> requested data covers the full world:\n+            // let's set a -180,180 bbox.\n+            // the wrapping projectionHandler and the gridCoverageReaders\n+            // will do proper clones / intersections afterwards\n+            minX = -180;\n+            maxX = 180;\n+            // Create a whole world envelope taking into account latLon/lonLat\n+            ReferencedEnvelope envelope =\n+                    new ReferencedEnvelope(\n+                            isLatLon ? minY : minX,\n+                            isLatLon ? maxY : maxX,\n+                            isLatLon ? minX : minY,\n+                            isLatLon ? maxX : maxY,\n+                            crs);\n+            envelopesToBeAdded.add(envelope);\n+        } else {\n+            // let's do some adjustments to \"shift\" the request around -180, 180 interval:\n+            // we basically add or subtract 360\u00b0 N times\n+            // 1) let's count how many halfCircles (a 180\u00b0 span) we are away from the zero\n+\n+            // 2) add/subtract 360\u00b0 N times to move forward/backward the request, also\n+            // keeping into account whether we are crossing the dateline or not\n+            // (halfCircles % 2)\n+\n+            // 3) add/subtract the original extent to get the other value of the interval\n+            // in order to move the whole window (Note that the extent won't be > 360\u00b0\n+            // since we are inside the \"else\")\n+\n+            int halfCircles = 0;\n+            if (minX < -180) {\n+                halfCircles = (int) ((Math.abs(minX) / 180));\n+                minX += (360 * ((halfCircles / 2) + (halfCircles % 2)));\n+                maxX = minX + extent;\n+            } else if (minX > 180) {\n+                halfCircles = (int) (minX / 180);\n+                minX -= (360 * ((halfCircles / 2) + (halfCircles % 2)));\n+                maxX = minX + extent;\n+            } else if (maxX < -180) {\n+                halfCircles = (int) (Math.abs(maxX) / 180);\n+                maxX += (360 * ((halfCircles / 2) + (halfCircles % 2)));\n+                minX = maxX - extent;\n+            } else if (maxX > 180) {\n+                halfCircles = (int) (Math.abs(maxX) / 180);\n+                maxX -= (360 * ((halfCircles / 2) + (halfCircles % 2)));\n+                minX = maxX - extent;\n+            }\n+\n+            if ((int) (minX / 180) < (int) (maxX / 180)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0453c5f934afeff74078b792522dac4db4e876bb"}, "originalPosition": 156}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzMzNjk3OQ==", "bodyText": "I will double check but I don't think so.\nWe are already excluding at least that maxX - minX > 360 (we are in the else) and we have already shifted the values to be in the range -180, 180 plus some extent adjustment.\na case like [-91, 91] will be 0 < 0 not triggering.\na case like [-1, 181] will be 0 < 1 triggering.\na case like [-181, 1] will be -1 < 0 triggering.\nI think it should work but let me know if I have missed some cases here.", "url": "https://github.com/geotools/geotools/pull/2752#discussion_r367336979", "createdAt": "2020-01-16T10:19:12Z", "author": {"login": "dromagnoli"}, "path": "modules/library/main/src/main/java/org/geotools/renderer/crs/ProjectionHandler.java", "diffHunk": "@@ -343,29 +306,132 @@ private void addTransformedEnvelope(ReferencedEnvelope re, List<ReferencedEnvelo\n         // have no idea at all) we don't actually split, but add elements\n         List<ReferencedEnvelope> envelopes = new ArrayList<ReferencedEnvelope>();\n         envelopes.add(re);\n-        if (re.getMinX() < -180) {\n-            envelopes.add(\n-                    new ReferencedEnvelope(\n-                            re.getMinX() + 360,\n-                            Math.min(re.getMaxX() + 360, 180),\n-                            re.getMinY(),\n-                            re.getMaxY(),\n-                            re.getCoordinateReferenceSystem()));\n-        }\n-        if (re.getMaxX() > 180) {\n-            envelopes.add(\n-                    new ReferencedEnvelope(\n-                            Math.max(re.getMinX() - 360, -180),\n-                            re.getMaxX() - 360,\n-                            re.getMinY(),\n-                            re.getMaxY(),\n-                            re.getCoordinateReferenceSystem()));\n-        }\n+        adjustEnvelope(re, envelopes, false);\n         mergeEnvelopes(envelopes);\n         reprojectEnvelopes(sourceCRS, envelopes);\n         return envelopes.stream().filter(e -> e != null).collect(Collectors.toList());\n     }\n \n+    /**\n+     * Adjust the envelope by taking into account dateline wrapping as well as multiple spans of the\n+     * whole world extent. When transform flag is true, the envelopes will be transformed before\n+     * being returned\n+     */\n+    private void adjustEnvelope(\n+            ReferencedEnvelope re, List<ReferencedEnvelope> envelopes, boolean transform)\n+            throws TransformException, FactoryException {\n+        CoordinateReferenceSystem crs = re.getCoordinateReferenceSystem();\n+        boolean isLatLon = CRS.getAxisOrder(crs) == CRS.AxisOrder.NORTH_EAST;\n+        double minX = isLatLon ? re.getMinY() : re.getMinX();\n+        double maxX = isLatLon ? re.getMaxY() : re.getMaxX();\n+        double minY = isLatLon ? re.getMinX() : re.getMinY();\n+        double maxY = isLatLon ? re.getMaxX() : re.getMaxY();\n+        double extent = maxX - minX;\n+        List<ReferencedEnvelope> envelopesToBeAdded = new ArrayList<>();\n+        if (extent > 360) {\n+            // at least one whole world use case -> requested data covers the full world:\n+            // let's set a -180,180 bbox.\n+            // the wrapping projectionHandler and the gridCoverageReaders\n+            // will do proper clones / intersections afterwards\n+            minX = -180;\n+            maxX = 180;\n+            // Create a whole world envelope taking into account latLon/lonLat\n+            ReferencedEnvelope envelope =\n+                    new ReferencedEnvelope(\n+                            isLatLon ? minY : minX,\n+                            isLatLon ? maxY : maxX,\n+                            isLatLon ? minX : minY,\n+                            isLatLon ? maxX : maxY,\n+                            crs);\n+            envelopesToBeAdded.add(envelope);\n+        } else {\n+            // let's do some adjustments to \"shift\" the request around -180, 180 interval:\n+            // we basically add or subtract 360\u00b0 N times\n+            // 1) let's count how many halfCircles (a 180\u00b0 span) we are away from the zero\n+\n+            // 2) add/subtract 360\u00b0 N times to move forward/backward the request, also\n+            // keeping into account whether we are crossing the dateline or not\n+            // (halfCircles % 2)\n+\n+            // 3) add/subtract the original extent to get the other value of the interval\n+            // in order to move the whole window (Note that the extent won't be > 360\u00b0\n+            // since we are inside the \"else\")\n+\n+            int halfCircles = 0;\n+            if (minX < -180) {\n+                halfCircles = (int) ((Math.abs(minX) / 180));\n+                minX += (360 * ((halfCircles / 2) + (halfCircles % 2)));\n+                maxX = minX + extent;\n+            } else if (minX > 180) {\n+                halfCircles = (int) (minX / 180);\n+                minX -= (360 * ((halfCircles / 2) + (halfCircles % 2)));\n+                maxX = minX + extent;\n+            } else if (maxX < -180) {\n+                halfCircles = (int) (Math.abs(maxX) / 180);\n+                maxX += (360 * ((halfCircles / 2) + (halfCircles % 2)));\n+                minX = maxX - extent;\n+            } else if (maxX > 180) {\n+                halfCircles = (int) (Math.abs(maxX) / 180);\n+                maxX -= (360 * ((halfCircles / 2) + (halfCircles % 2)));\n+                minX = maxX - extent;\n+            }\n+\n+            if ((int) (minX / 180) < (int) (maxX / 180)) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzMyMTE4Mw=="}, "originalCommit": {"oid": "0453c5f934afeff74078b792522dac4db4e876bb"}, "originalPosition": 156}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzM2NzcwNQ==", "bodyText": "Same as above, add comments.", "url": "https://github.com/geotools/geotools/pull/2752#discussion_r367367705", "createdAt": "2020-01-16T11:29:22Z", "author": {"login": "aaime"}, "path": "modules/library/main/src/main/java/org/geotools/renderer/crs/ProjectionHandler.java", "diffHunk": "@@ -343,29 +306,132 @@ private void addTransformedEnvelope(ReferencedEnvelope re, List<ReferencedEnvelo\n         // have no idea at all) we don't actually split, but add elements\n         List<ReferencedEnvelope> envelopes = new ArrayList<ReferencedEnvelope>();\n         envelopes.add(re);\n-        if (re.getMinX() < -180) {\n-            envelopes.add(\n-                    new ReferencedEnvelope(\n-                            re.getMinX() + 360,\n-                            Math.min(re.getMaxX() + 360, 180),\n-                            re.getMinY(),\n-                            re.getMaxY(),\n-                            re.getCoordinateReferenceSystem()));\n-        }\n-        if (re.getMaxX() > 180) {\n-            envelopes.add(\n-                    new ReferencedEnvelope(\n-                            Math.max(re.getMinX() - 360, -180),\n-                            re.getMaxX() - 360,\n-                            re.getMinY(),\n-                            re.getMaxY(),\n-                            re.getCoordinateReferenceSystem()));\n-        }\n+        adjustEnvelope(re, envelopes, false);\n         mergeEnvelopes(envelopes);\n         reprojectEnvelopes(sourceCRS, envelopes);\n         return envelopes.stream().filter(e -> e != null).collect(Collectors.toList());\n     }\n \n+    /**\n+     * Adjust the envelope by taking into account dateline wrapping as well as multiple spans of the\n+     * whole world extent. When transform flag is true, the envelopes will be transformed before\n+     * being returned\n+     */\n+    private void adjustEnvelope(\n+            ReferencedEnvelope re, List<ReferencedEnvelope> envelopes, boolean transform)\n+            throws TransformException, FactoryException {\n+        CoordinateReferenceSystem crs = re.getCoordinateReferenceSystem();\n+        boolean isLatLon = CRS.getAxisOrder(crs) == CRS.AxisOrder.NORTH_EAST;\n+        double minX = isLatLon ? re.getMinY() : re.getMinX();\n+        double maxX = isLatLon ? re.getMaxY() : re.getMaxX();\n+        double minY = isLatLon ? re.getMinX() : re.getMinY();\n+        double maxY = isLatLon ? re.getMaxX() : re.getMaxY();\n+        double extent = maxX - minX;\n+        List<ReferencedEnvelope> envelopesToBeAdded = new ArrayList<>();\n+        if (extent > 360) {\n+            // at least one whole world use case -> requested data covers the full world:\n+            // let's set a -180,180 bbox.\n+            // the wrapping projectionHandler and the gridCoverageReaders\n+            // will do proper clones / intersections afterwards\n+            minX = -180;\n+            maxX = 180;\n+            // Create a whole world envelope taking into account latLon/lonLat\n+            ReferencedEnvelope envelope =\n+                    new ReferencedEnvelope(\n+                            isLatLon ? minY : minX,\n+                            isLatLon ? maxY : maxX,\n+                            isLatLon ? minX : minY,\n+                            isLatLon ? maxX : maxY,\n+                            crs);\n+            envelopesToBeAdded.add(envelope);\n+        } else {\n+            // let's do some adjustments to \"shift\" the request around -180, 180 interval:\n+            // we basically add or subtract 360\u00b0 N times\n+            // 1) let's count how many halfCircles (a 180\u00b0 span) we are away from the zero\n+\n+            // 2) add/subtract 360\u00b0 N times to move forward/backward the request, also\n+            // keeping into account whether we are crossing the dateline or not\n+            // (halfCircles % 2)\n+\n+            // 3) add/subtract the original extent to get the other value of the interval\n+            // in order to move the whole window (Note that the extent won't be > 360\u00b0\n+            // since we are inside the \"else\")\n+\n+            int halfCircles = 0;\n+            if (minX < -180) {\n+                halfCircles = (int) ((Math.abs(minX) / 180));\n+                minX += (360 * ((halfCircles / 2) + (halfCircles % 2)));\n+                maxX = minX + extent;\n+            } else if (minX > 180) {\n+                halfCircles = (int) (minX / 180);\n+                minX -= (360 * ((halfCircles / 2) + (halfCircles % 2)));\n+                maxX = minX + extent;\n+            } else if (maxX < -180) {\n+                halfCircles = (int) (Math.abs(maxX) / 180);\n+                maxX += (360 * ((halfCircles / 2) + (halfCircles % 2)));\n+                minX = maxX - extent;\n+            } else if (maxX > 180) {\n+                halfCircles = (int) (Math.abs(maxX) / 180);\n+                maxX -= (360 * ((halfCircles / 2) + (halfCircles % 2)));\n+                minX = maxX - extent;\n+            }\n+\n+            if ((int) (minX / 180) < (int) (maxX / 180)) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzMyMTE4Mw=="}, "originalCommit": {"oid": "0453c5f934afeff74078b792522dac4db4e876bb"}, "originalPosition": 156}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI2OTU5NzEyOnYy", "diffSide": "RIGHT", "path": "modules/library/render/src/main/java/org/geotools/renderer/lite/StreamingRenderer.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNlQwOTo1MjoxNFrOFeTp2Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNlQxMDoyMzo1MFrOFeUm4Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzMyMzYwOQ==", "bodyText": "Uh, this is going vertical (format wise)... could you use a \"convert anonymous to inner\" and move this block to its own inner class?", "url": "https://github.com/geotools/geotools/pull/2752#discussion_r367323609", "createdAt": "2020-01-16T09:52:14Z", "author": {"login": "aaime"}, "path": "modules/library/render/src/main/java/org/geotools/renderer/lite/StreamingRenderer.java", "diffHunk": "@@ -2326,18 +2325,49 @@ protected GridCoverage2D readCoverage(\n                                 GridGeometry2D readGG)\n                                 throws IOException {\n                             Interpolation interpolation = getRenderingInterpolation(layer);\n-                            GridCoverageReaderHelper helper;\n+                            RenderingHints interpolationHints =\n+                                    new RenderingHints(JAI.KEY_INTERPOLATION, interpolation);\n+                            final GridCoverageRenderer gcr;\n                             try {\n-                                helper =\n-                                        new GridCoverageReaderHelper(\n+                                // Use the original screenSize", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0453c5f934afeff74078b792522dac4db4e876bb"}, "originalPosition": 32}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzMzOTIzMw==", "bodyText": "roger", "url": "https://github.com/geotools/geotools/pull/2752#discussion_r367339233", "createdAt": "2020-01-16T10:23:50Z", "author": {"login": "dromagnoli"}, "path": "modules/library/render/src/main/java/org/geotools/renderer/lite/StreamingRenderer.java", "diffHunk": "@@ -2326,18 +2325,49 @@ protected GridCoverage2D readCoverage(\n                                 GridGeometry2D readGG)\n                                 throws IOException {\n                             Interpolation interpolation = getRenderingInterpolation(layer);\n-                            GridCoverageReaderHelper helper;\n+                            RenderingHints interpolationHints =\n+                                    new RenderingHints(JAI.KEY_INTERPOLATION, interpolation);\n+                            final GridCoverageRenderer gcr;\n                             try {\n-                                helper =\n-                                        new GridCoverageReaderHelper(\n+                                // Use the original screenSize", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzMyMzYwOQ=="}, "originalCommit": {"oid": "0453c5f934afeff74078b792522dac4db4e876bb"}, "originalPosition": 32}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI2OTU5ODQ4OnYy", "diffSide": "RIGHT", "path": "modules/library/render/src/main/java/org/geotools/renderer/lite/StreamingRenderer.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNlQwOTo1MjozOFrOFeTqnA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNlQxMToyNjoyNFrOFeWRJQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzMyMzgwNA==", "bodyText": "Is this actually true if the advanced projection handling is off though?", "url": "https://github.com/geotools/geotools/pull/2752#discussion_r367323804", "createdAt": "2020-01-16T09:52:38Z", "author": {"login": "aaime"}, "path": "modules/library/render/src/main/java/org/geotools/renderer/lite/StreamingRenderer.java", "diffHunk": "@@ -2326,18 +2325,49 @@ protected GridCoverage2D readCoverage(\n                                 GridGeometry2D readGG)\n                                 throws IOException {\n                             Interpolation interpolation = getRenderingInterpolation(layer);\n-                            GridCoverageReaderHelper helper;\n+                            RenderingHints interpolationHints =\n+                                    new RenderingHints(JAI.KEY_INTERPOLATION, interpolation);\n+                            final GridCoverageRenderer gcr;\n                             try {\n-                                helper =\n-                                        new GridCoverageReaderHelper(\n+                                // Use the original screenSize\n+                                // the GridCoverageRenderer will take care of eventual gutter or", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0453c5f934afeff74078b792522dac4db4e876bb"}, "originalPosition": 33}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzM2NjQzNw==", "bodyText": "I have found another place where it's raising issues... backing to the original gridgeometry usage", "url": "https://github.com/geotools/geotools/pull/2752#discussion_r367366437", "createdAt": "2020-01-16T11:26:24Z", "author": {"login": "dromagnoli"}, "path": "modules/library/render/src/main/java/org/geotools/renderer/lite/StreamingRenderer.java", "diffHunk": "@@ -2326,18 +2325,49 @@ protected GridCoverage2D readCoverage(\n                                 GridGeometry2D readGG)\n                                 throws IOException {\n                             Interpolation interpolation = getRenderingInterpolation(layer);\n-                            GridCoverageReaderHelper helper;\n+                            RenderingHints interpolationHints =\n+                                    new RenderingHints(JAI.KEY_INTERPOLATION, interpolation);\n+                            final GridCoverageRenderer gcr;\n                             try {\n-                                helper =\n-                                        new GridCoverageReaderHelper(\n+                                // Use the original screenSize\n+                                // the GridCoverageRenderer will take care of eventual gutter or", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzMyMzgwNA=="}, "originalCommit": {"oid": "0453c5f934afeff74078b792522dac4db4e876bb"}, "originalPosition": 33}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI2OTYwNzE0OnYy", "diffSide": "RIGHT", "path": "modules/library/main/src/main/java/org/geotools/renderer/crs/ProjectionHandler.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNlQwOTo1NToyNFrOFeTv5g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNlQxMToyNzowNVrOFeWSPQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzMyNTE1OA==", "bodyText": "Could you add a good set of tests inside ProjectionHandlerTest covering all the possible cases handled here?", "url": "https://github.com/geotools/geotools/pull/2752#discussion_r367325158", "createdAt": "2020-01-16T09:55:24Z", "author": {"login": "aaime"}, "path": "modules/library/main/src/main/java/org/geotools/renderer/crs/ProjectionHandler.java", "diffHunk": "@@ -343,29 +306,132 @@ private void addTransformedEnvelope(ReferencedEnvelope re, List<ReferencedEnvelo\n         // have no idea at all) we don't actually split, but add elements\n         List<ReferencedEnvelope> envelopes = new ArrayList<ReferencedEnvelope>();\n         envelopes.add(re);\n-        if (re.getMinX() < -180) {\n-            envelopes.add(\n-                    new ReferencedEnvelope(\n-                            re.getMinX() + 360,\n-                            Math.min(re.getMaxX() + 360, 180),\n-                            re.getMinY(),\n-                            re.getMaxY(),\n-                            re.getCoordinateReferenceSystem()));\n-        }\n-        if (re.getMaxX() > 180) {\n-            envelopes.add(\n-                    new ReferencedEnvelope(\n-                            Math.max(re.getMinX() - 360, -180),\n-                            re.getMaxX() - 360,\n-                            re.getMinY(),\n-                            re.getMaxY(),\n-                            re.getCoordinateReferenceSystem()));\n-        }\n+        adjustEnvelope(re, envelopes, false);\n         mergeEnvelopes(envelopes);\n         reprojectEnvelopes(sourceCRS, envelopes);\n         return envelopes.stream().filter(e -> e != null).collect(Collectors.toList());\n     }\n \n+    /**\n+     * Adjust the envelope by taking into account dateline wrapping as well as multiple spans of the\n+     * whole world extent. When transform flag is true, the envelopes will be transformed before\n+     * being returned\n+     */\n+    private void adjustEnvelope(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0453c5f934afeff74078b792522dac4db4e876bb"}, "originalPosition": 97}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzM2NjcxNw==", "bodyText": "will do.", "url": "https://github.com/geotools/geotools/pull/2752#discussion_r367366717", "createdAt": "2020-01-16T11:27:05Z", "author": {"login": "dromagnoli"}, "path": "modules/library/main/src/main/java/org/geotools/renderer/crs/ProjectionHandler.java", "diffHunk": "@@ -343,29 +306,132 @@ private void addTransformedEnvelope(ReferencedEnvelope re, List<ReferencedEnvelo\n         // have no idea at all) we don't actually split, but add elements\n         List<ReferencedEnvelope> envelopes = new ArrayList<ReferencedEnvelope>();\n         envelopes.add(re);\n-        if (re.getMinX() < -180) {\n-            envelopes.add(\n-                    new ReferencedEnvelope(\n-                            re.getMinX() + 360,\n-                            Math.min(re.getMaxX() + 360, 180),\n-                            re.getMinY(),\n-                            re.getMaxY(),\n-                            re.getCoordinateReferenceSystem()));\n-        }\n-        if (re.getMaxX() > 180) {\n-            envelopes.add(\n-                    new ReferencedEnvelope(\n-                            Math.max(re.getMinX() - 360, -180),\n-                            re.getMaxX() - 360,\n-                            re.getMinY(),\n-                            re.getMaxY(),\n-                            re.getCoordinateReferenceSystem()));\n-        }\n+        adjustEnvelope(re, envelopes, false);\n         mergeEnvelopes(envelopes);\n         reprojectEnvelopes(sourceCRS, envelopes);\n         return envelopes.stream().filter(e -> e != null).collect(Collectors.toList());\n     }\n \n+    /**\n+     * Adjust the envelope by taking into account dateline wrapping as well as multiple spans of the\n+     * whole world extent. When transform flag is true, the envelopes will be transformed before\n+     * being returned\n+     */\n+    private void adjustEnvelope(", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzMyNTE1OA=="}, "originalCommit": {"oid": "0453c5f934afeff74078b792522dac4db4e876bb"}, "originalPosition": 97}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3703, "cost": 1, "resetAt": "2021-11-12T19:05:54Z"}}}