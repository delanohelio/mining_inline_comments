{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTA4Mzk3NTQ4", "number": 3187, "title": "[GEOT-6726] Add new FilteringVectorProcess", "bodyText": "This pr adds a new vector rendering transformation allowing to define features' groups and to return for each one, only one feature having the MIN/MAX value of the attribute defined by the client.\nJira ticket https://osgeo-org.atlassian.net/browse/GEOT-6726\nChecklist\n\nReviewing is a process done by project maintainers, mostly on a volunteer basis. We try to keep the overhead as small as possible and appreciate if you help us to do so by completing the following items. Feel free to ask in a comment if you have troubles with any of them.\n\nFor all pull requests:\n\n Confirm you have read the contribution guidelines\n You have sent a Contribution Licence Agreement (CLA) as necessary (not required for small changes, e.g., fixing typos in documentation)\n Make sure the first PR targets the master branch, eventual backports will be managed later. This can be ignored if the PR is fixing an issue that only happens in a specific branch, but not in newer ones.\n The changes are not breaking the build in downstream projects using SNAPSHOT dependencies, GeoWebCache and GeoServer (there is an automatic PR check verifying this, check this when it turns green).\n\nThe following are required only for core and extension modules (they are welcomed, but not required, for unsupported modules):\n\n There is an issue in Jira describing the bug/task/new feature (a notable exemptions is, changes not visible to end users). The ticket is for the GeoTools project, if the issue was found elsewhere it's a good practice to link to the origin ticket/issue.\n The pull request contains changes related to a single objective. If multiple focuses cannot be avoided, each one is in its own commit and has a separate ticket describing it.\n PR for bug fixes and small new features are presented as a single commit\n Commit message(s) must be in the form \"[GEOT-XYZW] Title of the Jira ticket\"\n New unit tests have been added covering the changes\n This PR passes all existing unit tests (test results will be reported by travis-ci after opening this PR)\n This PR passes the QA checks (QA checks results will be reported by travis-ci after opening this PR)\n Documentation has been updated accordingly.\n\nSubmitting the PR does not require you to check all items, but by the time it gets merged, they should be either satisfied or inapplicable.", "createdAt": "2020-10-22T15:58:50Z", "url": "https://github.com/geotools/geotools/pull/3187", "merged": true, "mergeCommit": {"oid": "54eb1fff69c9c9da9407d4c57f88b1d8de4558b1"}, "closed": true, "closedAt": "2020-10-30T14:34:55Z", "author": {"login": "taba90"}, "timelineItems": {"totalCount": 9, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdVQVx_gBqjM5MTIyNjg2NjA=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdXnul-gFqTUyMDcyNzQxMA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "5a2d2219dbebbc2f809d508fb9d9af7b4bc144ae", "author": {"user": {"login": "taba90", "name": null}}, "url": "https://github.com/geotools/geotools/commit/5a2d2219dbebbc2f809d508fb9d9af7b4bc144ae", "committedDate": "2020-10-22T15:56:27Z", "message": "[GEOT-6726] Add new FilteringVectorProcess"}, "afterCommit": {"oid": "5efd106ed909fc97db2dc5c828a059ad25fb5ad6", "author": {"user": {"login": "taba90", "name": null}}, "url": "https://github.com/geotools/geotools/commit/5efd106ed909fc97db2dc5c828a059ad25fb5ad6", "committedDate": "2020-10-23T06:11:25Z", "message": "[GEOT-6726] Add new FilteringVectorProcess"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE2OTExMDg2", "url": "https://github.com/geotools/geotools/pull/3187#pullrequestreview-516911086", "createdAt": "2020-10-26T15:41:32Z", "commit": {"oid": "5efd106ed909fc97db2dc5c828a059ad25fb5ad6"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNlQxNTo0MTozMlrOHoVt1g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNlQxNTo1NzoxMVrOHoWeOA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjA2MDg4Ng==", "bodyText": "Tad too generic, it's not just filtering, it's more like \"choosing a particular feature in a group\". \"Group candidate selection\" maybe?", "url": "https://github.com/geotools/geotools/pull/3187#discussion_r512060886", "createdAt": "2020-10-26T15:41:32Z", "author": {"login": "aaime"}, "path": "docs/user/unsupported/process/process-feature.rst", "diffHunk": "@@ -59,4 +59,22 @@ This is a very flexible process which can be used to:\n      description: String   description                    description: String\n                            area=area( the_geom)           area: Double\n                            text=concatenate(name,'-',id)  text: String\n- \n+\n+\n+\n+Filtering Features", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5efd106ed909fc97db2dc5c828a059ad25fb5ad6"}, "originalPosition": 8}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjA2MTgwNw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            Filters a FeatureCollection according to the aggregate operation chosen (MIN or MAX) and the groups defined through attribute names: given a collection of features for each group defined only the feature having the MIN or MAX value for the chosen attribute will be included in the final output.\n          \n          \n            \n            Filters a FeatureCollection according to the aggregate operation chosen (MIN or MAX) and the groups defined through attribute names. Given a feature collection, groups according to the defined grouping attributes, and returns the feature having the MIN or MAX value for the chosen attribute. One feature will be chosen for each group.", "url": "https://github.com/geotools/geotools/pull/3187#discussion_r512061807", "createdAt": "2020-10-26T15:42:46Z", "author": {"login": "aaime"}, "path": "docs/user/unsupported/process/process-feature.rst", "diffHunk": "@@ -59,4 +59,22 @@ This is a very flexible process which can be used to:\n      description: String   description                    description: String\n                            area=area( the_geom)           area: Double\n                            text=concatenate(name,'-',id)  text: String\n- \n+\n+\n+\n+Filtering Features\n+^^^^^^^^^^^^^^^^^^\n+\n+Filters a FeatureCollection according to the aggregate operation chosen (MIN or MAX) and the groups defined through attribute names: given a collection of features for each group defined only the feature having the MIN or MAX value for the chosen attribute will be included in the final output.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5efd106ed909fc97db2dc5c828a059ad25fb5ad6"}, "originalPosition": 11}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjA2MzU3Mw==", "bodyText": "A database in general can group over nulls, it's just a different value. IMHO this should not be hard-coded, but part of the filtering done in the SLD. If this is a hard requirement, it needs to be clearly documented, as it goes against normal practice (TBH, I would consider this behavior a bug).\nFor reference: https://learnsql.com/blog/null-values-group-clause/", "url": "https://github.com/geotools/geotools/pull/3187#discussion_r512063573", "createdAt": "2020-10-26T15:45:00Z", "author": {"login": "aaime"}, "path": "modules/unsupported/process-feature/src/main/java/org/geotools/process/vector/FilteringVectorProcess.java", "diffHunk": "@@ -0,0 +1,423 @@\n+/*\n+ *    GeoTools - The Open Source Java GIS Toolkit\n+ *    http://geotools.org\n+ *\n+ *    (C) 2020, Open Source Geospatial Foundation (OSGeo)\n+ *\n+ *    This library is free software; you can redistribute it and/or\n+ *    modify it under the terms of the GNU Lesser General Public\n+ *    License as published by the Free Software Foundation;\n+ *    version 2.1 of the License.\n+ *\n+ *    This library is distributed in the hope that it will be useful,\n+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+ *    Lesser General Public License for more details.\n+ */\n+package org.geotools.process.vector;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.NoSuchElementException;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+import org.apache.commons.lang3.ArrayUtils;\n+import org.geotools.data.Query;\n+import org.geotools.factory.CommonFactoryFinder;\n+import org.geotools.feature.FeatureCollection;\n+import org.geotools.feature.FeatureIterator;\n+import org.geotools.feature.collection.DecoratingFeatureCollection;\n+import org.geotools.feature.collection.DecoratingFeatureIterator;\n+import org.geotools.feature.collection.PushBackFeatureIterator;\n+import org.geotools.feature.type.Types;\n+import org.geotools.filter.AttributeExpressionImpl;\n+import org.geotools.filter.SortByImpl;\n+import org.geotools.metadata.i18n.ErrorKeys;\n+import org.geotools.metadata.i18n.Errors;\n+import org.geotools.process.ProcessException;\n+import org.geotools.process.factory.DescribeParameter;\n+import org.geotools.process.factory.DescribeProcess;\n+import org.geotools.util.factory.GeoTools;\n+import org.opengis.coverage.grid.GridGeometry;\n+import org.opengis.feature.Feature;\n+import org.opengis.feature.type.FeatureType;\n+import org.opengis.filter.Filter;\n+import org.opengis.filter.FilterFactory2;\n+import org.opengis.filter.expression.PropertyName;\n+import org.opengis.filter.sort.SortBy;\n+import org.opengis.filter.sort.SortOrder;\n+import org.xml.sax.helpers.NamespaceSupport;\n+\n+@DescribeProcess(\n+    title = \"Filtering Features\",\n+    description =\n+            \"Given a collection of features for each group defined only the feature having the MIN or MAX value for the chosen attribute will be included in the final output\"\n+)\n+public class FilteringVectorProcess implements VectorProcess {\n+\n+    protected FilterFactory2 ff = CommonFactoryFinder.getFilterFactory2(GeoTools.getDefaultHints());\n+\n+    public FeatureCollection execute(\n+            @DescribeParameter(name = \"data\", description = \"Input feature collection\")\n+                    FeatureCollection features,\n+            @DescribeParameter(\n+                        name = \"aggregation\",\n+                        description =\n+                                \"The aggregate operation to be computed, it can be MAX or MIN\",\n+                        min = 1\n+                    )\n+                    String aggregation,\n+            @DescribeParameter(\n+                        name = \"operationAttribute\",\n+                        description =\n+                                \"The feature's attribute to be used to compute the aggregation\",\n+                        min = 1\n+                    )\n+                    String operationAttribute,\n+            @DescribeParameter(\n+                        name = \"groupingAttributes\",\n+                        description =\n+                                \"The feature's attributes defining groups for which perform the filtering based on the aggregation operation and the operation attribute.\"\n+                                        + \"Consistent results are guaranteed only if the vector process is fed with features already sorted  by these attributes\",\n+                        min = 1\n+                    )\n+                    List<String> groupingAttributes) {\n+        try {\n+            if (features == null) {\n+                throw new ProcessException(Errors.format(ErrorKeys.NULL_ARGUMENT_$1, \"features\"));\n+            }\n+            if (operationAttribute == null) {\n+                throw new ProcessException(\n+                        Errors.format(ErrorKeys.NULL_ARGUMENT_$1, \"operationAttribute\"));\n+            }\n+            if (groupingAttributes == null || groupingAttributes.size() == 0) {\n+                throw new ProcessException(\n+                        Errors.format(ErrorKeys.NULL_ARGUMENT_$1, \"groupingAttributes\"));\n+            }\n+            if (aggregation == null) {\n+                throw new ProcessException(\n+                        Errors.format(ErrorKeys.NULL_ARGUMENT_$1, \"aggregation\"));\n+            }\n+            Operations op = Operations.valueOf(aggregation);\n+            FeatureType schema = features.getSchema();\n+            NamespaceSupport ns = declareNamespaces(schema);\n+            List<PropertyName> groupingPn =\n+                    groupingAttributes\n+                            .stream()\n+                            .map(\n+                                    g ->\n+                                            validatePropertyName(\n+                                                    new AttributeExpressionImpl(g, ns), schema))\n+                            .collect(Collectors.toList());\n+            PropertyName opValue =\n+                    validatePropertyName(ff.property(operationAttribute, ns), schema);\n+            return new GroupingFeatureCollection(features, groupingPn, opValue, op);\n+        } catch (IllegalArgumentException e) {\n+            throw new ProcessException(\n+                    Errors.format(ErrorKeys.BAD_PARAMETER_$2, \"aggregation\", aggregation));\n+        }\n+    }\n+\n+    public Query invertQuery(\n+            @DescribeParameter(\n+                        name = \"operationAttribute\",\n+                        description =\n+                                \"The feature's attribute to be used to compute the aggregation\",\n+                        min = 1\n+                    )\n+                    String operationAttribute,\n+            @DescribeParameter(\n+                        name = \"groupingAttributes\",\n+                        description =\n+                                \"The feature's attributes defining groups for which perform the filtering based on the aggregation operation and the operation attribute.\"\n+                                        + \"Consistent results are guaranteed only if the vector process is fed with features already sorted  by these attributes\",\n+                        min = 1\n+                    )\n+                    List<String> groupingAttributes,\n+            Query targetQuery,\n+            GridGeometry gridGeometry) {\n+\n+        // optimize the query adding the needed property name to it\n+\n+        List<PropertyName> properties = targetQuery.getProperties();\n+        SortBy[] sorts = targetQuery.getSortBy();\n+\n+        Query q = targetQuery != null ? new Query(targetQuery) : new Query();\n+        // add the sortBy if not present\n+        SortBy[] sortBy = buildNewSortBy(sorts, groupingAttributes);\n+        q.setSortBy(sortBy);\n+\n+        // produces new PropertyName to add to the query\n+        List<PropertyName> propertiesToAdd =\n+                Stream.of(sortBy).map(s -> s.getPropertyName()).collect(Collectors.toList());\n+        propertiesToAdd.add(ff.property(operationAttribute));\n+\n+        // eventually merge with existing ones\n+        List<PropertyName> pns = getNewProperties(propertiesToAdd, properties);\n+        q.setProperties(pns);\n+\n+        // features with null values for groupingAttributes and operationAttribute", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5efd106ed909fc97db2dc5c828a059ad25fb5ad6"}, "originalPosition": 165}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjA2NzQ4NQ==", "bodyText": "Same as above, null is a valid grouping value, in general.", "url": "https://github.com/geotools/geotools/pull/3187#discussion_r512067485", "createdAt": "2020-10-26T15:49:55Z", "author": {"login": "aaime"}, "path": "modules/unsupported/process-feature/src/main/java/org/geotools/process/vector/FilteringVectorProcess.java", "diffHunk": "@@ -0,0 +1,423 @@\n+/*\n+ *    GeoTools - The Open Source Java GIS Toolkit\n+ *    http://geotools.org\n+ *\n+ *    (C) 2020, Open Source Geospatial Foundation (OSGeo)\n+ *\n+ *    This library is free software; you can redistribute it and/or\n+ *    modify it under the terms of the GNU Lesser General Public\n+ *    License as published by the Free Software Foundation;\n+ *    version 2.1 of the License.\n+ *\n+ *    This library is distributed in the hope that it will be useful,\n+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+ *    Lesser General Public License for more details.\n+ */\n+package org.geotools.process.vector;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.NoSuchElementException;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+import org.apache.commons.lang3.ArrayUtils;\n+import org.geotools.data.Query;\n+import org.geotools.factory.CommonFactoryFinder;\n+import org.geotools.feature.FeatureCollection;\n+import org.geotools.feature.FeatureIterator;\n+import org.geotools.feature.collection.DecoratingFeatureCollection;\n+import org.geotools.feature.collection.DecoratingFeatureIterator;\n+import org.geotools.feature.collection.PushBackFeatureIterator;\n+import org.geotools.feature.type.Types;\n+import org.geotools.filter.AttributeExpressionImpl;\n+import org.geotools.filter.SortByImpl;\n+import org.geotools.metadata.i18n.ErrorKeys;\n+import org.geotools.metadata.i18n.Errors;\n+import org.geotools.process.ProcessException;\n+import org.geotools.process.factory.DescribeParameter;\n+import org.geotools.process.factory.DescribeProcess;\n+import org.geotools.util.factory.GeoTools;\n+import org.opengis.coverage.grid.GridGeometry;\n+import org.opengis.feature.Feature;\n+import org.opengis.feature.type.FeatureType;\n+import org.opengis.filter.Filter;\n+import org.opengis.filter.FilterFactory2;\n+import org.opengis.filter.expression.PropertyName;\n+import org.opengis.filter.sort.SortBy;\n+import org.opengis.filter.sort.SortOrder;\n+import org.xml.sax.helpers.NamespaceSupport;\n+\n+@DescribeProcess(\n+    title = \"Filtering Features\",\n+    description =\n+            \"Given a collection of features for each group defined only the feature having the MIN or MAX value for the chosen attribute will be included in the final output\"\n+)\n+public class FilteringVectorProcess implements VectorProcess {\n+\n+    protected FilterFactory2 ff = CommonFactoryFinder.getFilterFactory2(GeoTools.getDefaultHints());\n+\n+    public FeatureCollection execute(\n+            @DescribeParameter(name = \"data\", description = \"Input feature collection\")\n+                    FeatureCollection features,\n+            @DescribeParameter(\n+                        name = \"aggregation\",\n+                        description =\n+                                \"The aggregate operation to be computed, it can be MAX or MIN\",\n+                        min = 1\n+                    )\n+                    String aggregation,\n+            @DescribeParameter(\n+                        name = \"operationAttribute\",\n+                        description =\n+                                \"The feature's attribute to be used to compute the aggregation\",\n+                        min = 1\n+                    )\n+                    String operationAttribute,\n+            @DescribeParameter(\n+                        name = \"groupingAttributes\",\n+                        description =\n+                                \"The feature's attributes defining groups for which perform the filtering based on the aggregation operation and the operation attribute.\"\n+                                        + \"Consistent results are guaranteed only if the vector process is fed with features already sorted  by these attributes\",\n+                        min = 1\n+                    )\n+                    List<String> groupingAttributes) {\n+        try {\n+            if (features == null) {\n+                throw new ProcessException(Errors.format(ErrorKeys.NULL_ARGUMENT_$1, \"features\"));\n+            }\n+            if (operationAttribute == null) {\n+                throw new ProcessException(\n+                        Errors.format(ErrorKeys.NULL_ARGUMENT_$1, \"operationAttribute\"));\n+            }\n+            if (groupingAttributes == null || groupingAttributes.size() == 0) {\n+                throw new ProcessException(\n+                        Errors.format(ErrorKeys.NULL_ARGUMENT_$1, \"groupingAttributes\"));\n+            }\n+            if (aggregation == null) {\n+                throw new ProcessException(\n+                        Errors.format(ErrorKeys.NULL_ARGUMENT_$1, \"aggregation\"));\n+            }\n+            Operations op = Operations.valueOf(aggregation);\n+            FeatureType schema = features.getSchema();\n+            NamespaceSupport ns = declareNamespaces(schema);\n+            List<PropertyName> groupingPn =\n+                    groupingAttributes\n+                            .stream()\n+                            .map(\n+                                    g ->\n+                                            validatePropertyName(\n+                                                    new AttributeExpressionImpl(g, ns), schema))\n+                            .collect(Collectors.toList());\n+            PropertyName opValue =\n+                    validatePropertyName(ff.property(operationAttribute, ns), schema);\n+            return new GroupingFeatureCollection(features, groupingPn, opValue, op);\n+        } catch (IllegalArgumentException e) {\n+            throw new ProcessException(\n+                    Errors.format(ErrorKeys.BAD_PARAMETER_$2, \"aggregation\", aggregation));\n+        }\n+    }\n+\n+    public Query invertQuery(\n+            @DescribeParameter(\n+                        name = \"operationAttribute\",\n+                        description =\n+                                \"The feature's attribute to be used to compute the aggregation\",\n+                        min = 1\n+                    )\n+                    String operationAttribute,\n+            @DescribeParameter(\n+                        name = \"groupingAttributes\",\n+                        description =\n+                                \"The feature's attributes defining groups for which perform the filtering based on the aggregation operation and the operation attribute.\"\n+                                        + \"Consistent results are guaranteed only if the vector process is fed with features already sorted  by these attributes\",\n+                        min = 1\n+                    )\n+                    List<String> groupingAttributes,\n+            Query targetQuery,\n+            GridGeometry gridGeometry) {\n+\n+        // optimize the query adding the needed property name to it\n+\n+        List<PropertyName> properties = targetQuery.getProperties();\n+        SortBy[] sorts = targetQuery.getSortBy();\n+\n+        Query q = targetQuery != null ? new Query(targetQuery) : new Query();\n+        // add the sortBy if not present\n+        SortBy[] sortBy = buildNewSortBy(sorts, groupingAttributes);\n+        q.setSortBy(sortBy);\n+\n+        // produces new PropertyName to add to the query\n+        List<PropertyName> propertiesToAdd =\n+                Stream.of(sortBy).map(s -> s.getPropertyName()).collect(Collectors.toList());\n+        propertiesToAdd.add(ff.property(operationAttribute));\n+\n+        // eventually merge with existing ones\n+        List<PropertyName> pns = getNewProperties(propertiesToAdd, properties);\n+        q.setProperties(pns);\n+\n+        // features with null values for groupingAttributes and operationAttribute\n+        // will not be rendered. Adding not null filters to delegate to the db.\n+        List<Filter> filters = new ArrayList<>();\n+        for (PropertyName pn : propertiesToAdd) {\n+            filters.add(ff.not(ff.isNull(pn)));\n+        }\n+        Filter original = q.getFilter();\n+        if (original != null && !original.equals(Filter.INCLUDE)) filters.add(q.getFilter());\n+        q.setFilter(ff.and(filters));\n+        return q;\n+    }\n+\n+    private SortBy[] buildNewSortBy(SortBy[] sorts, List<String> groupingAttributes) {\n+        // eventually creates new SortBy and add them to the array\n+        List<SortBy> newSorts = new ArrayList<>(groupingAttributes.size());\n+        List<PropertyName> properties =\n+                groupingAttributes.stream().map(s -> ff.property(s)).collect(Collectors.toList());\n+        for (int i = 0; i < properties.size(); i++) {\n+            PropertyName pn = properties.get(i);\n+            if (!sortByAlreadyExists(sorts, pn))\n+                newSorts.add(new SortByImpl(pn, SortOrder.ASCENDING));\n+        }\n+        if (newSorts.size() > 0) {\n+            if (sorts == null) return newSorts.toArray(new SortBy[newSorts.size()]);\n+            else return ArrayUtils.addAll(sorts, newSorts.toArray(new SortBy[newSorts.size()]));\n+        }\n+        return sorts;\n+    }\n+\n+    private List<PropertyName> getNewProperties(\n+            List<PropertyName> toAdd, List<PropertyName> originalProperties) {\n+        Set<PropertyName> properties = new HashSet<>();\n+        if (originalProperties != null) {\n+            properties.addAll(originalProperties);\n+        }\n+        if (toAdd != null) {\n+            properties.addAll(toAdd);\n+        }\n+        return new ArrayList<>(properties);\n+    }\n+\n+    private boolean sortByAlreadyExists(SortBy[] sorts, PropertyName pn) {\n+        if (sorts == null) return false;\n+        for (SortBy s : sorts) {\n+            // just checking the property name. In the context of the rendering\n+            // transformation the sortBy order doesn't matter\n+            if (s.getPropertyName().equals(pn)) {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    private PropertyName validatePropertyName(PropertyName pn, FeatureType schema) {\n+        // checks propertyName against the schema\n+        if (pn.evaluate(schema) == null)\n+            throw new ProcessException(\n+                    \"Unable to resolve \" + pn.getPropertyName() + \" against the FeatureType\");\n+        return pn;\n+    }\n+\n+    private NamespaceSupport declareNamespaces(FeatureType type) {\n+        // retrieves Namespaces for complex features\n+        NamespaceSupport namespaceSupport = null;\n+        Map namespaces = (Map) type.getUserData().get(Types.DECLARED_NAMESPACES_MAP);\n+        if (namespaces != null) {\n+            namespaceSupport = new NamespaceSupport();\n+            for (Iterator it = namespaces.entrySet().iterator(); it.hasNext(); ) {\n+                Map.Entry entry = (Map.Entry) it.next();\n+                String prefix = (String) entry.getKey();\n+                String namespace = (String) entry.getValue();\n+                namespaceSupport.declarePrefix(prefix, namespace);\n+            }\n+        }\n+        return namespaceSupport;\n+    }\n+\n+    /**\n+     * A FeatureCollection wrapper to filter out features according to the aggregation parameter and\n+     * the groups defined by the groupingAttributes\n+     */\n+    static class GroupingFeatureCollection\n+            extends DecoratingFeatureCollection<FeatureType, Feature> {\n+\n+        List<PropertyName> groupingAttributes;\n+\n+        PropertyName operationAttribute;\n+\n+        Operations aggregation;\n+\n+        public GroupingFeatureCollection(\n+                FeatureCollection<FeatureType, Feature> delegate,\n+                List<PropertyName> groupingAttributes,\n+                PropertyName operationAttribute,\n+                Operations aggregation) {\n+            super(delegate);\n+            this.groupingAttributes = groupingAttributes;\n+            this.operationAttribute = operationAttribute;\n+            this.aggregation = aggregation;\n+        }\n+\n+        @Override\n+        public FeatureIterator<Feature> features() {\n+            return new GroupingFeatureIterator(\n+                    new PushBackFeatureIterator(delegate.features()),\n+                    groupingAttributes,\n+                    operationAttribute,\n+                    aggregation);\n+        }\n+    }\n+\n+    /**\n+     * A FeatureIterator wrapper to filter out features according to the aggregation parameter and\n+     * the groups defined by the groupingAttributes\n+     */\n+    static class GroupingFeatureIterator extends DecoratingFeatureIterator<Feature> {\n+\n+        private List<PropertyName> groupByAttributes;\n+\n+        private PropertyName operationAttribute;\n+\n+        private Operations aggregation;\n+\n+        private Feature next;\n+\n+        /**\n+         * Wrap the provided FeatureIterator.\n+         *\n+         * @param iterator Iterator to be used as a delegate.\n+         */\n+        public GroupingFeatureIterator(\n+                PushBackFeatureIterator iterator,\n+                List<PropertyName> groupByAttributes,\n+                PropertyName operationValue,\n+                Operations aggregation) {\n+            super(iterator);\n+            this.groupByAttributes = groupByAttributes;\n+            this.operationAttribute = operationValue;\n+            this.aggregation = aggregation;\n+        }\n+\n+        @Override\n+        public boolean hasNext() {\n+            List<Object> groupingValues = new ArrayList<>(groupByAttributes.size());\n+            Map<Object, Feature> beingFiltered = new HashMap<>();\n+            List<Double> valuesToCompare = new ArrayList<>();\n+            while (super.hasNext()) {\n+                Feature f = super.next();\n+                if (beingFiltered.size() == 0) {\n+                    // no features in the list this is the first of the group\n+                    // takes the values to check the following features if belong to the same group\n+                    // features with null values are skipped\n+                    if (addGroupingValues(groupingValues, f))\n+                        addDoubleValueFromFeature(f, valuesToCompare, beingFiltered);\n+                } else {\n+                    // is the feature in the group?\n+                    if (featureComparison(groupingValues, f)) {\n+                        addDoubleValueFromFeature(f, valuesToCompare, beingFiltered);\n+                    } else {\n+                        ((PushBackFeatureIterator) delegate).pushBack();\n+                        break;\n+                    }\n+                }\n+            }\n+            next = doFiltering(beingFiltered, valuesToCompare);\n+            return next != null;\n+        }\n+\n+        private Feature doFiltering(\n+                Map<Object, Feature> beingFiltered, List<Double> beingEvaluated) {\n+            Object key;\n+            // searches the min or max inside the values list and retrieve the feature\n+            // to be returned from the Map.\n+            if (beingFiltered.size() > 0 && beingEvaluated.size() > 0) {\n+                if (this.aggregation.equals(Operations.MIN)) key = computeMin(beingEvaluated);\n+                else key = computeMax(beingEvaluated);\n+\n+                return beingFiltered.get(key);\n+            } else {\n+                return null;\n+            }\n+        }\n+\n+        private Number computeMin(List<Double> beingEvaluated) {\n+            return Collections.min(beingEvaluated);\n+        }\n+\n+        private Number computeMax(List<Double> beingEvaluated) {\n+            return Collections.max(beingEvaluated);\n+        }\n+\n+        private boolean featureComparison(List<Object> groupingValues, Feature f) {\n+            List<Object> toCompareValues = new ArrayList<>(groupingValues.size());\n+            for (PropertyName p : groupByAttributes) {\n+                toCompareValues.add(p.evaluate(f));\n+            }\n+            if (groupingValues.size() > 0 && groupingValues.equals(toCompareValues)) return true;\n+            return false;\n+        }\n+\n+        private boolean addGroupingValues(List<Object> groupingValues, Feature f) {\n+            for (PropertyName p : groupByAttributes) {\n+                Object result = p.evaluate(f);\n+                if (result != null) groupingValues.add(p.evaluate(f));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5efd106ed909fc97db2dc5c828a059ad25fb5ad6"}, "originalPosition": 368}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjA3MDUxOQ==", "bodyText": "This is not really adding the values to the list, it's more like gathering them. Seems also dangerous, I see no cleaning happening, if a feature is skipped for any reason, the groupingValues would keep on accumulating?\nIMHO better to have this method return a feature list of values, or null if they are not found.", "url": "https://github.com/geotools/geotools/pull/3187#discussion_r512070519", "createdAt": "2020-10-26T15:53:45Z", "author": {"login": "aaime"}, "path": "modules/unsupported/process-feature/src/main/java/org/geotools/process/vector/FilteringVectorProcess.java", "diffHunk": "@@ -0,0 +1,423 @@\n+/*\n+ *    GeoTools - The Open Source Java GIS Toolkit\n+ *    http://geotools.org\n+ *\n+ *    (C) 2020, Open Source Geospatial Foundation (OSGeo)\n+ *\n+ *    This library is free software; you can redistribute it and/or\n+ *    modify it under the terms of the GNU Lesser General Public\n+ *    License as published by the Free Software Foundation;\n+ *    version 2.1 of the License.\n+ *\n+ *    This library is distributed in the hope that it will be useful,\n+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+ *    Lesser General Public License for more details.\n+ */\n+package org.geotools.process.vector;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.NoSuchElementException;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+import org.apache.commons.lang3.ArrayUtils;\n+import org.geotools.data.Query;\n+import org.geotools.factory.CommonFactoryFinder;\n+import org.geotools.feature.FeatureCollection;\n+import org.geotools.feature.FeatureIterator;\n+import org.geotools.feature.collection.DecoratingFeatureCollection;\n+import org.geotools.feature.collection.DecoratingFeatureIterator;\n+import org.geotools.feature.collection.PushBackFeatureIterator;\n+import org.geotools.feature.type.Types;\n+import org.geotools.filter.AttributeExpressionImpl;\n+import org.geotools.filter.SortByImpl;\n+import org.geotools.metadata.i18n.ErrorKeys;\n+import org.geotools.metadata.i18n.Errors;\n+import org.geotools.process.ProcessException;\n+import org.geotools.process.factory.DescribeParameter;\n+import org.geotools.process.factory.DescribeProcess;\n+import org.geotools.util.factory.GeoTools;\n+import org.opengis.coverage.grid.GridGeometry;\n+import org.opengis.feature.Feature;\n+import org.opengis.feature.type.FeatureType;\n+import org.opengis.filter.Filter;\n+import org.opengis.filter.FilterFactory2;\n+import org.opengis.filter.expression.PropertyName;\n+import org.opengis.filter.sort.SortBy;\n+import org.opengis.filter.sort.SortOrder;\n+import org.xml.sax.helpers.NamespaceSupport;\n+\n+@DescribeProcess(\n+    title = \"Filtering Features\",\n+    description =\n+            \"Given a collection of features for each group defined only the feature having the MIN or MAX value for the chosen attribute will be included in the final output\"\n+)\n+public class FilteringVectorProcess implements VectorProcess {\n+\n+    protected FilterFactory2 ff = CommonFactoryFinder.getFilterFactory2(GeoTools.getDefaultHints());\n+\n+    public FeatureCollection execute(\n+            @DescribeParameter(name = \"data\", description = \"Input feature collection\")\n+                    FeatureCollection features,\n+            @DescribeParameter(\n+                        name = \"aggregation\",\n+                        description =\n+                                \"The aggregate operation to be computed, it can be MAX or MIN\",\n+                        min = 1\n+                    )\n+                    String aggregation,\n+            @DescribeParameter(\n+                        name = \"operationAttribute\",\n+                        description =\n+                                \"The feature's attribute to be used to compute the aggregation\",\n+                        min = 1\n+                    )\n+                    String operationAttribute,\n+            @DescribeParameter(\n+                        name = \"groupingAttributes\",\n+                        description =\n+                                \"The feature's attributes defining groups for which perform the filtering based on the aggregation operation and the operation attribute.\"\n+                                        + \"Consistent results are guaranteed only if the vector process is fed with features already sorted  by these attributes\",\n+                        min = 1\n+                    )\n+                    List<String> groupingAttributes) {\n+        try {\n+            if (features == null) {\n+                throw new ProcessException(Errors.format(ErrorKeys.NULL_ARGUMENT_$1, \"features\"));\n+            }\n+            if (operationAttribute == null) {\n+                throw new ProcessException(\n+                        Errors.format(ErrorKeys.NULL_ARGUMENT_$1, \"operationAttribute\"));\n+            }\n+            if (groupingAttributes == null || groupingAttributes.size() == 0) {\n+                throw new ProcessException(\n+                        Errors.format(ErrorKeys.NULL_ARGUMENT_$1, \"groupingAttributes\"));\n+            }\n+            if (aggregation == null) {\n+                throw new ProcessException(\n+                        Errors.format(ErrorKeys.NULL_ARGUMENT_$1, \"aggregation\"));\n+            }\n+            Operations op = Operations.valueOf(aggregation);\n+            FeatureType schema = features.getSchema();\n+            NamespaceSupport ns = declareNamespaces(schema);\n+            List<PropertyName> groupingPn =\n+                    groupingAttributes\n+                            .stream()\n+                            .map(\n+                                    g ->\n+                                            validatePropertyName(\n+                                                    new AttributeExpressionImpl(g, ns), schema))\n+                            .collect(Collectors.toList());\n+            PropertyName opValue =\n+                    validatePropertyName(ff.property(operationAttribute, ns), schema);\n+            return new GroupingFeatureCollection(features, groupingPn, opValue, op);\n+        } catch (IllegalArgumentException e) {\n+            throw new ProcessException(\n+                    Errors.format(ErrorKeys.BAD_PARAMETER_$2, \"aggregation\", aggregation));\n+        }\n+    }\n+\n+    public Query invertQuery(\n+            @DescribeParameter(\n+                        name = \"operationAttribute\",\n+                        description =\n+                                \"The feature's attribute to be used to compute the aggregation\",\n+                        min = 1\n+                    )\n+                    String operationAttribute,\n+            @DescribeParameter(\n+                        name = \"groupingAttributes\",\n+                        description =\n+                                \"The feature's attributes defining groups for which perform the filtering based on the aggregation operation and the operation attribute.\"\n+                                        + \"Consistent results are guaranteed only if the vector process is fed with features already sorted  by these attributes\",\n+                        min = 1\n+                    )\n+                    List<String> groupingAttributes,\n+            Query targetQuery,\n+            GridGeometry gridGeometry) {\n+\n+        // optimize the query adding the needed property name to it\n+\n+        List<PropertyName> properties = targetQuery.getProperties();\n+        SortBy[] sorts = targetQuery.getSortBy();\n+\n+        Query q = targetQuery != null ? new Query(targetQuery) : new Query();\n+        // add the sortBy if not present\n+        SortBy[] sortBy = buildNewSortBy(sorts, groupingAttributes);\n+        q.setSortBy(sortBy);\n+\n+        // produces new PropertyName to add to the query\n+        List<PropertyName> propertiesToAdd =\n+                Stream.of(sortBy).map(s -> s.getPropertyName()).collect(Collectors.toList());\n+        propertiesToAdd.add(ff.property(operationAttribute));\n+\n+        // eventually merge with existing ones\n+        List<PropertyName> pns = getNewProperties(propertiesToAdd, properties);\n+        q.setProperties(pns);\n+\n+        // features with null values for groupingAttributes and operationAttribute\n+        // will not be rendered. Adding not null filters to delegate to the db.\n+        List<Filter> filters = new ArrayList<>();\n+        for (PropertyName pn : propertiesToAdd) {\n+            filters.add(ff.not(ff.isNull(pn)));\n+        }\n+        Filter original = q.getFilter();\n+        if (original != null && !original.equals(Filter.INCLUDE)) filters.add(q.getFilter());\n+        q.setFilter(ff.and(filters));\n+        return q;\n+    }\n+\n+    private SortBy[] buildNewSortBy(SortBy[] sorts, List<String> groupingAttributes) {\n+        // eventually creates new SortBy and add them to the array\n+        List<SortBy> newSorts = new ArrayList<>(groupingAttributes.size());\n+        List<PropertyName> properties =\n+                groupingAttributes.stream().map(s -> ff.property(s)).collect(Collectors.toList());\n+        for (int i = 0; i < properties.size(); i++) {\n+            PropertyName pn = properties.get(i);\n+            if (!sortByAlreadyExists(sorts, pn))\n+                newSorts.add(new SortByImpl(pn, SortOrder.ASCENDING));\n+        }\n+        if (newSorts.size() > 0) {\n+            if (sorts == null) return newSorts.toArray(new SortBy[newSorts.size()]);\n+            else return ArrayUtils.addAll(sorts, newSorts.toArray(new SortBy[newSorts.size()]));\n+        }\n+        return sorts;\n+    }\n+\n+    private List<PropertyName> getNewProperties(\n+            List<PropertyName> toAdd, List<PropertyName> originalProperties) {\n+        Set<PropertyName> properties = new HashSet<>();\n+        if (originalProperties != null) {\n+            properties.addAll(originalProperties);\n+        }\n+        if (toAdd != null) {\n+            properties.addAll(toAdd);\n+        }\n+        return new ArrayList<>(properties);\n+    }\n+\n+    private boolean sortByAlreadyExists(SortBy[] sorts, PropertyName pn) {\n+        if (sorts == null) return false;\n+        for (SortBy s : sorts) {\n+            // just checking the property name. In the context of the rendering\n+            // transformation the sortBy order doesn't matter\n+            if (s.getPropertyName().equals(pn)) {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    private PropertyName validatePropertyName(PropertyName pn, FeatureType schema) {\n+        // checks propertyName against the schema\n+        if (pn.evaluate(schema) == null)\n+            throw new ProcessException(\n+                    \"Unable to resolve \" + pn.getPropertyName() + \" against the FeatureType\");\n+        return pn;\n+    }\n+\n+    private NamespaceSupport declareNamespaces(FeatureType type) {\n+        // retrieves Namespaces for complex features\n+        NamespaceSupport namespaceSupport = null;\n+        Map namespaces = (Map) type.getUserData().get(Types.DECLARED_NAMESPACES_MAP);\n+        if (namespaces != null) {\n+            namespaceSupport = new NamespaceSupport();\n+            for (Iterator it = namespaces.entrySet().iterator(); it.hasNext(); ) {\n+                Map.Entry entry = (Map.Entry) it.next();\n+                String prefix = (String) entry.getKey();\n+                String namespace = (String) entry.getValue();\n+                namespaceSupport.declarePrefix(prefix, namespace);\n+            }\n+        }\n+        return namespaceSupport;\n+    }\n+\n+    /**\n+     * A FeatureCollection wrapper to filter out features according to the aggregation parameter and\n+     * the groups defined by the groupingAttributes\n+     */\n+    static class GroupingFeatureCollection\n+            extends DecoratingFeatureCollection<FeatureType, Feature> {\n+\n+        List<PropertyName> groupingAttributes;\n+\n+        PropertyName operationAttribute;\n+\n+        Operations aggregation;\n+\n+        public GroupingFeatureCollection(\n+                FeatureCollection<FeatureType, Feature> delegate,\n+                List<PropertyName> groupingAttributes,\n+                PropertyName operationAttribute,\n+                Operations aggregation) {\n+            super(delegate);\n+            this.groupingAttributes = groupingAttributes;\n+            this.operationAttribute = operationAttribute;\n+            this.aggregation = aggregation;\n+        }\n+\n+        @Override\n+        public FeatureIterator<Feature> features() {\n+            return new GroupingFeatureIterator(\n+                    new PushBackFeatureIterator(delegate.features()),\n+                    groupingAttributes,\n+                    operationAttribute,\n+                    aggregation);\n+        }\n+    }\n+\n+    /**\n+     * A FeatureIterator wrapper to filter out features according to the aggregation parameter and\n+     * the groups defined by the groupingAttributes\n+     */\n+    static class GroupingFeatureIterator extends DecoratingFeatureIterator<Feature> {\n+\n+        private List<PropertyName> groupByAttributes;\n+\n+        private PropertyName operationAttribute;\n+\n+        private Operations aggregation;\n+\n+        private Feature next;\n+\n+        /**\n+         * Wrap the provided FeatureIterator.\n+         *\n+         * @param iterator Iterator to be used as a delegate.\n+         */\n+        public GroupingFeatureIterator(\n+                PushBackFeatureIterator iterator,\n+                List<PropertyName> groupByAttributes,\n+                PropertyName operationValue,\n+                Operations aggregation) {\n+            super(iterator);\n+            this.groupByAttributes = groupByAttributes;\n+            this.operationAttribute = operationValue;\n+            this.aggregation = aggregation;\n+        }\n+\n+        @Override\n+        public boolean hasNext() {\n+            List<Object> groupingValues = new ArrayList<>(groupByAttributes.size());\n+            Map<Object, Feature> beingFiltered = new HashMap<>();\n+            List<Double> valuesToCompare = new ArrayList<>();\n+            while (super.hasNext()) {\n+                Feature f = super.next();\n+                if (beingFiltered.size() == 0) {\n+                    // no features in the list this is the first of the group\n+                    // takes the values to check the following features if belong to the same group\n+                    // features with null values are skipped\n+                    if (addGroupingValues(groupingValues, f))\n+                        addDoubleValueFromFeature(f, valuesToCompare, beingFiltered);\n+                } else {\n+                    // is the feature in the group?\n+                    if (featureComparison(groupingValues, f)) {\n+                        addDoubleValueFromFeature(f, valuesToCompare, beingFiltered);\n+                    } else {\n+                        ((PushBackFeatureIterator) delegate).pushBack();\n+                        break;\n+                    }\n+                }\n+            }\n+            next = doFiltering(beingFiltered, valuesToCompare);\n+            return next != null;\n+        }\n+\n+        private Feature doFiltering(\n+                Map<Object, Feature> beingFiltered, List<Double> beingEvaluated) {\n+            Object key;\n+            // searches the min or max inside the values list and retrieve the feature\n+            // to be returned from the Map.\n+            if (beingFiltered.size() > 0 && beingEvaluated.size() > 0) {\n+                if (this.aggregation.equals(Operations.MIN)) key = computeMin(beingEvaluated);\n+                else key = computeMax(beingEvaluated);\n+\n+                return beingFiltered.get(key);\n+            } else {\n+                return null;\n+            }\n+        }\n+\n+        private Number computeMin(List<Double> beingEvaluated) {\n+            return Collections.min(beingEvaluated);\n+        }\n+\n+        private Number computeMax(List<Double> beingEvaluated) {\n+            return Collections.max(beingEvaluated);\n+        }\n+\n+        private boolean featureComparison(List<Object> groupingValues, Feature f) {\n+            List<Object> toCompareValues = new ArrayList<>(groupingValues.size());\n+            for (PropertyName p : groupByAttributes) {\n+                toCompareValues.add(p.evaluate(f));\n+            }\n+            if (groupingValues.size() > 0 && groupingValues.equals(toCompareValues)) return true;\n+            return false;\n+        }\n+\n+        private boolean addGroupingValues(List<Object> groupingValues, Feature f) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5efd106ed909fc97db2dc5c828a059ad25fb5ad6"}, "originalPosition": 365}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjA3MTE1NQ==", "bodyText": "Why do they need to be doubles? Any object supporting equals would work as a grouping mechanism here.", "url": "https://github.com/geotools/geotools/pull/3187#discussion_r512071155", "createdAt": "2020-10-26T15:54:36Z", "author": {"login": "aaime"}, "path": "modules/unsupported/process-feature/src/main/java/org/geotools/process/vector/FilteringVectorProcess.java", "diffHunk": "@@ -0,0 +1,423 @@\n+/*\n+ *    GeoTools - The Open Source Java GIS Toolkit\n+ *    http://geotools.org\n+ *\n+ *    (C) 2020, Open Source Geospatial Foundation (OSGeo)\n+ *\n+ *    This library is free software; you can redistribute it and/or\n+ *    modify it under the terms of the GNU Lesser General Public\n+ *    License as published by the Free Software Foundation;\n+ *    version 2.1 of the License.\n+ *\n+ *    This library is distributed in the hope that it will be useful,\n+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+ *    Lesser General Public License for more details.\n+ */\n+package org.geotools.process.vector;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.NoSuchElementException;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+import org.apache.commons.lang3.ArrayUtils;\n+import org.geotools.data.Query;\n+import org.geotools.factory.CommonFactoryFinder;\n+import org.geotools.feature.FeatureCollection;\n+import org.geotools.feature.FeatureIterator;\n+import org.geotools.feature.collection.DecoratingFeatureCollection;\n+import org.geotools.feature.collection.DecoratingFeatureIterator;\n+import org.geotools.feature.collection.PushBackFeatureIterator;\n+import org.geotools.feature.type.Types;\n+import org.geotools.filter.AttributeExpressionImpl;\n+import org.geotools.filter.SortByImpl;\n+import org.geotools.metadata.i18n.ErrorKeys;\n+import org.geotools.metadata.i18n.Errors;\n+import org.geotools.process.ProcessException;\n+import org.geotools.process.factory.DescribeParameter;\n+import org.geotools.process.factory.DescribeProcess;\n+import org.geotools.util.factory.GeoTools;\n+import org.opengis.coverage.grid.GridGeometry;\n+import org.opengis.feature.Feature;\n+import org.opengis.feature.type.FeatureType;\n+import org.opengis.filter.Filter;\n+import org.opengis.filter.FilterFactory2;\n+import org.opengis.filter.expression.PropertyName;\n+import org.opengis.filter.sort.SortBy;\n+import org.opengis.filter.sort.SortOrder;\n+import org.xml.sax.helpers.NamespaceSupport;\n+\n+@DescribeProcess(\n+    title = \"Filtering Features\",\n+    description =\n+            \"Given a collection of features for each group defined only the feature having the MIN or MAX value for the chosen attribute will be included in the final output\"\n+)\n+public class FilteringVectorProcess implements VectorProcess {\n+\n+    protected FilterFactory2 ff = CommonFactoryFinder.getFilterFactory2(GeoTools.getDefaultHints());\n+\n+    public FeatureCollection execute(\n+            @DescribeParameter(name = \"data\", description = \"Input feature collection\")\n+                    FeatureCollection features,\n+            @DescribeParameter(\n+                        name = \"aggregation\",\n+                        description =\n+                                \"The aggregate operation to be computed, it can be MAX or MIN\",\n+                        min = 1\n+                    )\n+                    String aggregation,\n+            @DescribeParameter(\n+                        name = \"operationAttribute\",\n+                        description =\n+                                \"The feature's attribute to be used to compute the aggregation\",\n+                        min = 1\n+                    )\n+                    String operationAttribute,\n+            @DescribeParameter(\n+                        name = \"groupingAttributes\",\n+                        description =\n+                                \"The feature's attributes defining groups for which perform the filtering based on the aggregation operation and the operation attribute.\"\n+                                        + \"Consistent results are guaranteed only if the vector process is fed with features already sorted  by these attributes\",\n+                        min = 1\n+                    )\n+                    List<String> groupingAttributes) {\n+        try {\n+            if (features == null) {\n+                throw new ProcessException(Errors.format(ErrorKeys.NULL_ARGUMENT_$1, \"features\"));\n+            }\n+            if (operationAttribute == null) {\n+                throw new ProcessException(\n+                        Errors.format(ErrorKeys.NULL_ARGUMENT_$1, \"operationAttribute\"));\n+            }\n+            if (groupingAttributes == null || groupingAttributes.size() == 0) {\n+                throw new ProcessException(\n+                        Errors.format(ErrorKeys.NULL_ARGUMENT_$1, \"groupingAttributes\"));\n+            }\n+            if (aggregation == null) {\n+                throw new ProcessException(\n+                        Errors.format(ErrorKeys.NULL_ARGUMENT_$1, \"aggregation\"));\n+            }\n+            Operations op = Operations.valueOf(aggregation);\n+            FeatureType schema = features.getSchema();\n+            NamespaceSupport ns = declareNamespaces(schema);\n+            List<PropertyName> groupingPn =\n+                    groupingAttributes\n+                            .stream()\n+                            .map(\n+                                    g ->\n+                                            validatePropertyName(\n+                                                    new AttributeExpressionImpl(g, ns), schema))\n+                            .collect(Collectors.toList());\n+            PropertyName opValue =\n+                    validatePropertyName(ff.property(operationAttribute, ns), schema);\n+            return new GroupingFeatureCollection(features, groupingPn, opValue, op);\n+        } catch (IllegalArgumentException e) {\n+            throw new ProcessException(\n+                    Errors.format(ErrorKeys.BAD_PARAMETER_$2, \"aggregation\", aggregation));\n+        }\n+    }\n+\n+    public Query invertQuery(\n+            @DescribeParameter(\n+                        name = \"operationAttribute\",\n+                        description =\n+                                \"The feature's attribute to be used to compute the aggregation\",\n+                        min = 1\n+                    )\n+                    String operationAttribute,\n+            @DescribeParameter(\n+                        name = \"groupingAttributes\",\n+                        description =\n+                                \"The feature's attributes defining groups for which perform the filtering based on the aggregation operation and the operation attribute.\"\n+                                        + \"Consistent results are guaranteed only if the vector process is fed with features already sorted  by these attributes\",\n+                        min = 1\n+                    )\n+                    List<String> groupingAttributes,\n+            Query targetQuery,\n+            GridGeometry gridGeometry) {\n+\n+        // optimize the query adding the needed property name to it\n+\n+        List<PropertyName> properties = targetQuery.getProperties();\n+        SortBy[] sorts = targetQuery.getSortBy();\n+\n+        Query q = targetQuery != null ? new Query(targetQuery) : new Query();\n+        // add the sortBy if not present\n+        SortBy[] sortBy = buildNewSortBy(sorts, groupingAttributes);\n+        q.setSortBy(sortBy);\n+\n+        // produces new PropertyName to add to the query\n+        List<PropertyName> propertiesToAdd =\n+                Stream.of(sortBy).map(s -> s.getPropertyName()).collect(Collectors.toList());\n+        propertiesToAdd.add(ff.property(operationAttribute));\n+\n+        // eventually merge with existing ones\n+        List<PropertyName> pns = getNewProperties(propertiesToAdd, properties);\n+        q.setProperties(pns);\n+\n+        // features with null values for groupingAttributes and operationAttribute\n+        // will not be rendered. Adding not null filters to delegate to the db.\n+        List<Filter> filters = new ArrayList<>();\n+        for (PropertyName pn : propertiesToAdd) {\n+            filters.add(ff.not(ff.isNull(pn)));\n+        }\n+        Filter original = q.getFilter();\n+        if (original != null && !original.equals(Filter.INCLUDE)) filters.add(q.getFilter());\n+        q.setFilter(ff.and(filters));\n+        return q;\n+    }\n+\n+    private SortBy[] buildNewSortBy(SortBy[] sorts, List<String> groupingAttributes) {\n+        // eventually creates new SortBy and add them to the array\n+        List<SortBy> newSorts = new ArrayList<>(groupingAttributes.size());\n+        List<PropertyName> properties =\n+                groupingAttributes.stream().map(s -> ff.property(s)).collect(Collectors.toList());\n+        for (int i = 0; i < properties.size(); i++) {\n+            PropertyName pn = properties.get(i);\n+            if (!sortByAlreadyExists(sorts, pn))\n+                newSorts.add(new SortByImpl(pn, SortOrder.ASCENDING));\n+        }\n+        if (newSorts.size() > 0) {\n+            if (sorts == null) return newSorts.toArray(new SortBy[newSorts.size()]);\n+            else return ArrayUtils.addAll(sorts, newSorts.toArray(new SortBy[newSorts.size()]));\n+        }\n+        return sorts;\n+    }\n+\n+    private List<PropertyName> getNewProperties(\n+            List<PropertyName> toAdd, List<PropertyName> originalProperties) {\n+        Set<PropertyName> properties = new HashSet<>();\n+        if (originalProperties != null) {\n+            properties.addAll(originalProperties);\n+        }\n+        if (toAdd != null) {\n+            properties.addAll(toAdd);\n+        }\n+        return new ArrayList<>(properties);\n+    }\n+\n+    private boolean sortByAlreadyExists(SortBy[] sorts, PropertyName pn) {\n+        if (sorts == null) return false;\n+        for (SortBy s : sorts) {\n+            // just checking the property name. In the context of the rendering\n+            // transformation the sortBy order doesn't matter\n+            if (s.getPropertyName().equals(pn)) {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    private PropertyName validatePropertyName(PropertyName pn, FeatureType schema) {\n+        // checks propertyName against the schema\n+        if (pn.evaluate(schema) == null)\n+            throw new ProcessException(\n+                    \"Unable to resolve \" + pn.getPropertyName() + \" against the FeatureType\");\n+        return pn;\n+    }\n+\n+    private NamespaceSupport declareNamespaces(FeatureType type) {\n+        // retrieves Namespaces for complex features\n+        NamespaceSupport namespaceSupport = null;\n+        Map namespaces = (Map) type.getUserData().get(Types.DECLARED_NAMESPACES_MAP);\n+        if (namespaces != null) {\n+            namespaceSupport = new NamespaceSupport();\n+            for (Iterator it = namespaces.entrySet().iterator(); it.hasNext(); ) {\n+                Map.Entry entry = (Map.Entry) it.next();\n+                String prefix = (String) entry.getKey();\n+                String namespace = (String) entry.getValue();\n+                namespaceSupport.declarePrefix(prefix, namespace);\n+            }\n+        }\n+        return namespaceSupport;\n+    }\n+\n+    /**\n+     * A FeatureCollection wrapper to filter out features according to the aggregation parameter and\n+     * the groups defined by the groupingAttributes\n+     */\n+    static class GroupingFeatureCollection\n+            extends DecoratingFeatureCollection<FeatureType, Feature> {\n+\n+        List<PropertyName> groupingAttributes;\n+\n+        PropertyName operationAttribute;\n+\n+        Operations aggregation;\n+\n+        public GroupingFeatureCollection(\n+                FeatureCollection<FeatureType, Feature> delegate,\n+                List<PropertyName> groupingAttributes,\n+                PropertyName operationAttribute,\n+                Operations aggregation) {\n+            super(delegate);\n+            this.groupingAttributes = groupingAttributes;\n+            this.operationAttribute = operationAttribute;\n+            this.aggregation = aggregation;\n+        }\n+\n+        @Override\n+        public FeatureIterator<Feature> features() {\n+            return new GroupingFeatureIterator(\n+                    new PushBackFeatureIterator(delegate.features()),\n+                    groupingAttributes,\n+                    operationAttribute,\n+                    aggregation);\n+        }\n+    }\n+\n+    /**\n+     * A FeatureIterator wrapper to filter out features according to the aggregation parameter and\n+     * the groups defined by the groupingAttributes\n+     */\n+    static class GroupingFeatureIterator extends DecoratingFeatureIterator<Feature> {\n+\n+        private List<PropertyName> groupByAttributes;\n+\n+        private PropertyName operationAttribute;\n+\n+        private Operations aggregation;\n+\n+        private Feature next;\n+\n+        /**\n+         * Wrap the provided FeatureIterator.\n+         *\n+         * @param iterator Iterator to be used as a delegate.\n+         */\n+        public GroupingFeatureIterator(\n+                PushBackFeatureIterator iterator,\n+                List<PropertyName> groupByAttributes,\n+                PropertyName operationValue,\n+                Operations aggregation) {\n+            super(iterator);\n+            this.groupByAttributes = groupByAttributes;\n+            this.operationAttribute = operationValue;\n+            this.aggregation = aggregation;\n+        }\n+\n+        @Override\n+        public boolean hasNext() {\n+            List<Object> groupingValues = new ArrayList<>(groupByAttributes.size());\n+            Map<Object, Feature> beingFiltered = new HashMap<>();\n+            List<Double> valuesToCompare = new ArrayList<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5efd106ed909fc97db2dc5c828a059ad25fb5ad6"}, "originalPosition": 310}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjA3MTc0Ng==", "bodyText": "Why in the world is that? Any Comparable will do no?", "url": "https://github.com/geotools/geotools/pull/3187#discussion_r512071746", "createdAt": "2020-10-26T15:55:15Z", "author": {"login": "aaime"}, "path": "modules/unsupported/process-feature/src/main/java/org/geotools/process/vector/FilteringVectorProcess.java", "diffHunk": "@@ -0,0 +1,423 @@\n+/*\n+ *    GeoTools - The Open Source Java GIS Toolkit\n+ *    http://geotools.org\n+ *\n+ *    (C) 2020, Open Source Geospatial Foundation (OSGeo)\n+ *\n+ *    This library is free software; you can redistribute it and/or\n+ *    modify it under the terms of the GNU Lesser General Public\n+ *    License as published by the Free Software Foundation;\n+ *    version 2.1 of the License.\n+ *\n+ *    This library is distributed in the hope that it will be useful,\n+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+ *    Lesser General Public License for more details.\n+ */\n+package org.geotools.process.vector;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.NoSuchElementException;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+import org.apache.commons.lang3.ArrayUtils;\n+import org.geotools.data.Query;\n+import org.geotools.factory.CommonFactoryFinder;\n+import org.geotools.feature.FeatureCollection;\n+import org.geotools.feature.FeatureIterator;\n+import org.geotools.feature.collection.DecoratingFeatureCollection;\n+import org.geotools.feature.collection.DecoratingFeatureIterator;\n+import org.geotools.feature.collection.PushBackFeatureIterator;\n+import org.geotools.feature.type.Types;\n+import org.geotools.filter.AttributeExpressionImpl;\n+import org.geotools.filter.SortByImpl;\n+import org.geotools.metadata.i18n.ErrorKeys;\n+import org.geotools.metadata.i18n.Errors;\n+import org.geotools.process.ProcessException;\n+import org.geotools.process.factory.DescribeParameter;\n+import org.geotools.process.factory.DescribeProcess;\n+import org.geotools.util.factory.GeoTools;\n+import org.opengis.coverage.grid.GridGeometry;\n+import org.opengis.feature.Feature;\n+import org.opengis.feature.type.FeatureType;\n+import org.opengis.filter.Filter;\n+import org.opengis.filter.FilterFactory2;\n+import org.opengis.filter.expression.PropertyName;\n+import org.opengis.filter.sort.SortBy;\n+import org.opengis.filter.sort.SortOrder;\n+import org.xml.sax.helpers.NamespaceSupport;\n+\n+@DescribeProcess(\n+    title = \"Filtering Features\",\n+    description =\n+            \"Given a collection of features for each group defined only the feature having the MIN or MAX value for the chosen attribute will be included in the final output\"\n+)\n+public class FilteringVectorProcess implements VectorProcess {\n+\n+    protected FilterFactory2 ff = CommonFactoryFinder.getFilterFactory2(GeoTools.getDefaultHints());\n+\n+    public FeatureCollection execute(\n+            @DescribeParameter(name = \"data\", description = \"Input feature collection\")\n+                    FeatureCollection features,\n+            @DescribeParameter(\n+                        name = \"aggregation\",\n+                        description =\n+                                \"The aggregate operation to be computed, it can be MAX or MIN\",\n+                        min = 1\n+                    )\n+                    String aggregation,\n+            @DescribeParameter(\n+                        name = \"operationAttribute\",\n+                        description =\n+                                \"The feature's attribute to be used to compute the aggregation\",\n+                        min = 1\n+                    )\n+                    String operationAttribute,\n+            @DescribeParameter(\n+                        name = \"groupingAttributes\",\n+                        description =\n+                                \"The feature's attributes defining groups for which perform the filtering based on the aggregation operation and the operation attribute.\"\n+                                        + \"Consistent results are guaranteed only if the vector process is fed with features already sorted  by these attributes\",\n+                        min = 1\n+                    )\n+                    List<String> groupingAttributes) {\n+        try {\n+            if (features == null) {\n+                throw new ProcessException(Errors.format(ErrorKeys.NULL_ARGUMENT_$1, \"features\"));\n+            }\n+            if (operationAttribute == null) {\n+                throw new ProcessException(\n+                        Errors.format(ErrorKeys.NULL_ARGUMENT_$1, \"operationAttribute\"));\n+            }\n+            if (groupingAttributes == null || groupingAttributes.size() == 0) {\n+                throw new ProcessException(\n+                        Errors.format(ErrorKeys.NULL_ARGUMENT_$1, \"groupingAttributes\"));\n+            }\n+            if (aggregation == null) {\n+                throw new ProcessException(\n+                        Errors.format(ErrorKeys.NULL_ARGUMENT_$1, \"aggregation\"));\n+            }\n+            Operations op = Operations.valueOf(aggregation);\n+            FeatureType schema = features.getSchema();\n+            NamespaceSupport ns = declareNamespaces(schema);\n+            List<PropertyName> groupingPn =\n+                    groupingAttributes\n+                            .stream()\n+                            .map(\n+                                    g ->\n+                                            validatePropertyName(\n+                                                    new AttributeExpressionImpl(g, ns), schema))\n+                            .collect(Collectors.toList());\n+            PropertyName opValue =\n+                    validatePropertyName(ff.property(operationAttribute, ns), schema);\n+            return new GroupingFeatureCollection(features, groupingPn, opValue, op);\n+        } catch (IllegalArgumentException e) {\n+            throw new ProcessException(\n+                    Errors.format(ErrorKeys.BAD_PARAMETER_$2, \"aggregation\", aggregation));\n+        }\n+    }\n+\n+    public Query invertQuery(\n+            @DescribeParameter(\n+                        name = \"operationAttribute\",\n+                        description =\n+                                \"The feature's attribute to be used to compute the aggregation\",\n+                        min = 1\n+                    )\n+                    String operationAttribute,\n+            @DescribeParameter(\n+                        name = \"groupingAttributes\",\n+                        description =\n+                                \"The feature's attributes defining groups for which perform the filtering based on the aggregation operation and the operation attribute.\"\n+                                        + \"Consistent results are guaranteed only if the vector process is fed with features already sorted  by these attributes\",\n+                        min = 1\n+                    )\n+                    List<String> groupingAttributes,\n+            Query targetQuery,\n+            GridGeometry gridGeometry) {\n+\n+        // optimize the query adding the needed property name to it\n+\n+        List<PropertyName> properties = targetQuery.getProperties();\n+        SortBy[] sorts = targetQuery.getSortBy();\n+\n+        Query q = targetQuery != null ? new Query(targetQuery) : new Query();\n+        // add the sortBy if not present\n+        SortBy[] sortBy = buildNewSortBy(sorts, groupingAttributes);\n+        q.setSortBy(sortBy);\n+\n+        // produces new PropertyName to add to the query\n+        List<PropertyName> propertiesToAdd =\n+                Stream.of(sortBy).map(s -> s.getPropertyName()).collect(Collectors.toList());\n+        propertiesToAdd.add(ff.property(operationAttribute));\n+\n+        // eventually merge with existing ones\n+        List<PropertyName> pns = getNewProperties(propertiesToAdd, properties);\n+        q.setProperties(pns);\n+\n+        // features with null values for groupingAttributes and operationAttribute\n+        // will not be rendered. Adding not null filters to delegate to the db.\n+        List<Filter> filters = new ArrayList<>();\n+        for (PropertyName pn : propertiesToAdd) {\n+            filters.add(ff.not(ff.isNull(pn)));\n+        }\n+        Filter original = q.getFilter();\n+        if (original != null && !original.equals(Filter.INCLUDE)) filters.add(q.getFilter());\n+        q.setFilter(ff.and(filters));\n+        return q;\n+    }\n+\n+    private SortBy[] buildNewSortBy(SortBy[] sorts, List<String> groupingAttributes) {\n+        // eventually creates new SortBy and add them to the array\n+        List<SortBy> newSorts = new ArrayList<>(groupingAttributes.size());\n+        List<PropertyName> properties =\n+                groupingAttributes.stream().map(s -> ff.property(s)).collect(Collectors.toList());\n+        for (int i = 0; i < properties.size(); i++) {\n+            PropertyName pn = properties.get(i);\n+            if (!sortByAlreadyExists(sorts, pn))\n+                newSorts.add(new SortByImpl(pn, SortOrder.ASCENDING));\n+        }\n+        if (newSorts.size() > 0) {\n+            if (sorts == null) return newSorts.toArray(new SortBy[newSorts.size()]);\n+            else return ArrayUtils.addAll(sorts, newSorts.toArray(new SortBy[newSorts.size()]));\n+        }\n+        return sorts;\n+    }\n+\n+    private List<PropertyName> getNewProperties(\n+            List<PropertyName> toAdd, List<PropertyName> originalProperties) {\n+        Set<PropertyName> properties = new HashSet<>();\n+        if (originalProperties != null) {\n+            properties.addAll(originalProperties);\n+        }\n+        if (toAdd != null) {\n+            properties.addAll(toAdd);\n+        }\n+        return new ArrayList<>(properties);\n+    }\n+\n+    private boolean sortByAlreadyExists(SortBy[] sorts, PropertyName pn) {\n+        if (sorts == null) return false;\n+        for (SortBy s : sorts) {\n+            // just checking the property name. In the context of the rendering\n+            // transformation the sortBy order doesn't matter\n+            if (s.getPropertyName().equals(pn)) {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    private PropertyName validatePropertyName(PropertyName pn, FeatureType schema) {\n+        // checks propertyName against the schema\n+        if (pn.evaluate(schema) == null)\n+            throw new ProcessException(\n+                    \"Unable to resolve \" + pn.getPropertyName() + \" against the FeatureType\");\n+        return pn;\n+    }\n+\n+    private NamespaceSupport declareNamespaces(FeatureType type) {\n+        // retrieves Namespaces for complex features\n+        NamespaceSupport namespaceSupport = null;\n+        Map namespaces = (Map) type.getUserData().get(Types.DECLARED_NAMESPACES_MAP);\n+        if (namespaces != null) {\n+            namespaceSupport = new NamespaceSupport();\n+            for (Iterator it = namespaces.entrySet().iterator(); it.hasNext(); ) {\n+                Map.Entry entry = (Map.Entry) it.next();\n+                String prefix = (String) entry.getKey();\n+                String namespace = (String) entry.getValue();\n+                namespaceSupport.declarePrefix(prefix, namespace);\n+            }\n+        }\n+        return namespaceSupport;\n+    }\n+\n+    /**\n+     * A FeatureCollection wrapper to filter out features according to the aggregation parameter and\n+     * the groups defined by the groupingAttributes\n+     */\n+    static class GroupingFeatureCollection\n+            extends DecoratingFeatureCollection<FeatureType, Feature> {\n+\n+        List<PropertyName> groupingAttributes;\n+\n+        PropertyName operationAttribute;\n+\n+        Operations aggregation;\n+\n+        public GroupingFeatureCollection(\n+                FeatureCollection<FeatureType, Feature> delegate,\n+                List<PropertyName> groupingAttributes,\n+                PropertyName operationAttribute,\n+                Operations aggregation) {\n+            super(delegate);\n+            this.groupingAttributes = groupingAttributes;\n+            this.operationAttribute = operationAttribute;\n+            this.aggregation = aggregation;\n+        }\n+\n+        @Override\n+        public FeatureIterator<Feature> features() {\n+            return new GroupingFeatureIterator(\n+                    new PushBackFeatureIterator(delegate.features()),\n+                    groupingAttributes,\n+                    operationAttribute,\n+                    aggregation);\n+        }\n+    }\n+\n+    /**\n+     * A FeatureIterator wrapper to filter out features according to the aggregation parameter and\n+     * the groups defined by the groupingAttributes\n+     */\n+    static class GroupingFeatureIterator extends DecoratingFeatureIterator<Feature> {\n+\n+        private List<PropertyName> groupByAttributes;\n+\n+        private PropertyName operationAttribute;\n+\n+        private Operations aggregation;\n+\n+        private Feature next;\n+\n+        /**\n+         * Wrap the provided FeatureIterator.\n+         *\n+         * @param iterator Iterator to be used as a delegate.\n+         */\n+        public GroupingFeatureIterator(\n+                PushBackFeatureIterator iterator,\n+                List<PropertyName> groupByAttributes,\n+                PropertyName operationValue,\n+                Operations aggregation) {\n+            super(iterator);\n+            this.groupByAttributes = groupByAttributes;\n+            this.operationAttribute = operationValue;\n+            this.aggregation = aggregation;\n+        }\n+\n+        @Override\n+        public boolean hasNext() {\n+            List<Object> groupingValues = new ArrayList<>(groupByAttributes.size());\n+            Map<Object, Feature> beingFiltered = new HashMap<>();\n+            List<Double> valuesToCompare = new ArrayList<>();\n+            while (super.hasNext()) {\n+                Feature f = super.next();\n+                if (beingFiltered.size() == 0) {\n+                    // no features in the list this is the first of the group\n+                    // takes the values to check the following features if belong to the same group\n+                    // features with null values are skipped\n+                    if (addGroupingValues(groupingValues, f))\n+                        addDoubleValueFromFeature(f, valuesToCompare, beingFiltered);\n+                } else {\n+                    // is the feature in the group?\n+                    if (featureComparison(groupingValues, f)) {\n+                        addDoubleValueFromFeature(f, valuesToCompare, beingFiltered);\n+                    } else {\n+                        ((PushBackFeatureIterator) delegate).pushBack();\n+                        break;\n+                    }\n+                }\n+            }\n+            next = doFiltering(beingFiltered, valuesToCompare);\n+            return next != null;\n+        }\n+\n+        private Feature doFiltering(\n+                Map<Object, Feature> beingFiltered, List<Double> beingEvaluated) {\n+            Object key;\n+            // searches the min or max inside the values list and retrieve the feature\n+            // to be returned from the Map.\n+            if (beingFiltered.size() > 0 && beingEvaluated.size() > 0) {\n+                if (this.aggregation.equals(Operations.MIN)) key = computeMin(beingEvaluated);\n+                else key = computeMax(beingEvaluated);\n+\n+                return beingFiltered.get(key);\n+            } else {\n+                return null;\n+            }\n+        }\n+\n+        private Number computeMin(List<Double> beingEvaluated) {\n+            return Collections.min(beingEvaluated);\n+        }\n+\n+        private Number computeMax(List<Double> beingEvaluated) {\n+            return Collections.max(beingEvaluated);\n+        }\n+\n+        private boolean featureComparison(List<Object> groupingValues, Feature f) {\n+            List<Object> toCompareValues = new ArrayList<>(groupingValues.size());\n+            for (PropertyName p : groupByAttributes) {\n+                toCompareValues.add(p.evaluate(f));\n+            }\n+            if (groupingValues.size() > 0 && groupingValues.equals(toCompareValues)) return true;\n+            return false;\n+        }\n+\n+        private boolean addGroupingValues(List<Object> groupingValues, Feature f) {\n+            for (PropertyName p : groupByAttributes) {\n+                Object result = p.evaluate(f);\n+                if (result != null) groupingValues.add(p.evaluate(f));\n+            }\n+            if (groupingValues.isEmpty() || groupingValues.size() < groupByAttributes.size())\n+                return false;\n+            return true;\n+        }\n+\n+        private void addDoubleValueFromFeature(\n+                Feature f, List<Double> valuesToCompare, Map<Object, Feature> beingFiltered) {\n+            Object result = this.operationAttribute.evaluate(f, Number.class);\n+            if (result instanceof Number) {\n+                Double value = ((Number) result).doubleValue();\n+                valuesToCompare.add(value);\n+                beingFiltered.put(value, f);\n+\n+            } else {\n+                if (result != null)\n+                    // not a numeric value. Throwing exception\n+                    throw new ProcessException(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5efd106ed909fc97db2dc5c828a059ad25fb5ad6"}, "originalPosition": 386}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjA3MzI3Mg==", "bodyText": "Accumulating features in memory like this is dangerous, could lead to OOM if the groups are large, if all the operations needed are min and max, just keep track of the current value and current feature, and replace if the new feature is \"better\" than the old one. No need to keep the entire list. Then the method could be renamed to something like \"updateSelection\" or something like that.", "url": "https://github.com/geotools/geotools/pull/3187#discussion_r512073272", "createdAt": "2020-10-26T15:57:11Z", "author": {"login": "aaime"}, "path": "modules/unsupported/process-feature/src/main/java/org/geotools/process/vector/FilteringVectorProcess.java", "diffHunk": "@@ -0,0 +1,423 @@\n+/*\n+ *    GeoTools - The Open Source Java GIS Toolkit\n+ *    http://geotools.org\n+ *\n+ *    (C) 2020, Open Source Geospatial Foundation (OSGeo)\n+ *\n+ *    This library is free software; you can redistribute it and/or\n+ *    modify it under the terms of the GNU Lesser General Public\n+ *    License as published by the Free Software Foundation;\n+ *    version 2.1 of the License.\n+ *\n+ *    This library is distributed in the hope that it will be useful,\n+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+ *    Lesser General Public License for more details.\n+ */\n+package org.geotools.process.vector;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.NoSuchElementException;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+import org.apache.commons.lang3.ArrayUtils;\n+import org.geotools.data.Query;\n+import org.geotools.factory.CommonFactoryFinder;\n+import org.geotools.feature.FeatureCollection;\n+import org.geotools.feature.FeatureIterator;\n+import org.geotools.feature.collection.DecoratingFeatureCollection;\n+import org.geotools.feature.collection.DecoratingFeatureIterator;\n+import org.geotools.feature.collection.PushBackFeatureIterator;\n+import org.geotools.feature.type.Types;\n+import org.geotools.filter.AttributeExpressionImpl;\n+import org.geotools.filter.SortByImpl;\n+import org.geotools.metadata.i18n.ErrorKeys;\n+import org.geotools.metadata.i18n.Errors;\n+import org.geotools.process.ProcessException;\n+import org.geotools.process.factory.DescribeParameter;\n+import org.geotools.process.factory.DescribeProcess;\n+import org.geotools.util.factory.GeoTools;\n+import org.opengis.coverage.grid.GridGeometry;\n+import org.opengis.feature.Feature;\n+import org.opengis.feature.type.FeatureType;\n+import org.opengis.filter.Filter;\n+import org.opengis.filter.FilterFactory2;\n+import org.opengis.filter.expression.PropertyName;\n+import org.opengis.filter.sort.SortBy;\n+import org.opengis.filter.sort.SortOrder;\n+import org.xml.sax.helpers.NamespaceSupport;\n+\n+@DescribeProcess(\n+    title = \"Filtering Features\",\n+    description =\n+            \"Given a collection of features for each group defined only the feature having the MIN or MAX value for the chosen attribute will be included in the final output\"\n+)\n+public class FilteringVectorProcess implements VectorProcess {\n+\n+    protected FilterFactory2 ff = CommonFactoryFinder.getFilterFactory2(GeoTools.getDefaultHints());\n+\n+    public FeatureCollection execute(\n+            @DescribeParameter(name = \"data\", description = \"Input feature collection\")\n+                    FeatureCollection features,\n+            @DescribeParameter(\n+                        name = \"aggregation\",\n+                        description =\n+                                \"The aggregate operation to be computed, it can be MAX or MIN\",\n+                        min = 1\n+                    )\n+                    String aggregation,\n+            @DescribeParameter(\n+                        name = \"operationAttribute\",\n+                        description =\n+                                \"The feature's attribute to be used to compute the aggregation\",\n+                        min = 1\n+                    )\n+                    String operationAttribute,\n+            @DescribeParameter(\n+                        name = \"groupingAttributes\",\n+                        description =\n+                                \"The feature's attributes defining groups for which perform the filtering based on the aggregation operation and the operation attribute.\"\n+                                        + \"Consistent results are guaranteed only if the vector process is fed with features already sorted  by these attributes\",\n+                        min = 1\n+                    )\n+                    List<String> groupingAttributes) {\n+        try {\n+            if (features == null) {\n+                throw new ProcessException(Errors.format(ErrorKeys.NULL_ARGUMENT_$1, \"features\"));\n+            }\n+            if (operationAttribute == null) {\n+                throw new ProcessException(\n+                        Errors.format(ErrorKeys.NULL_ARGUMENT_$1, \"operationAttribute\"));\n+            }\n+            if (groupingAttributes == null || groupingAttributes.size() == 0) {\n+                throw new ProcessException(\n+                        Errors.format(ErrorKeys.NULL_ARGUMENT_$1, \"groupingAttributes\"));\n+            }\n+            if (aggregation == null) {\n+                throw new ProcessException(\n+                        Errors.format(ErrorKeys.NULL_ARGUMENT_$1, \"aggregation\"));\n+            }\n+            Operations op = Operations.valueOf(aggregation);\n+            FeatureType schema = features.getSchema();\n+            NamespaceSupport ns = declareNamespaces(schema);\n+            List<PropertyName> groupingPn =\n+                    groupingAttributes\n+                            .stream()\n+                            .map(\n+                                    g ->\n+                                            validatePropertyName(\n+                                                    new AttributeExpressionImpl(g, ns), schema))\n+                            .collect(Collectors.toList());\n+            PropertyName opValue =\n+                    validatePropertyName(ff.property(operationAttribute, ns), schema);\n+            return new GroupingFeatureCollection(features, groupingPn, opValue, op);\n+        } catch (IllegalArgumentException e) {\n+            throw new ProcessException(\n+                    Errors.format(ErrorKeys.BAD_PARAMETER_$2, \"aggregation\", aggregation));\n+        }\n+    }\n+\n+    public Query invertQuery(\n+            @DescribeParameter(\n+                        name = \"operationAttribute\",\n+                        description =\n+                                \"The feature's attribute to be used to compute the aggregation\",\n+                        min = 1\n+                    )\n+                    String operationAttribute,\n+            @DescribeParameter(\n+                        name = \"groupingAttributes\",\n+                        description =\n+                                \"The feature's attributes defining groups for which perform the filtering based on the aggregation operation and the operation attribute.\"\n+                                        + \"Consistent results are guaranteed only if the vector process is fed with features already sorted  by these attributes\",\n+                        min = 1\n+                    )\n+                    List<String> groupingAttributes,\n+            Query targetQuery,\n+            GridGeometry gridGeometry) {\n+\n+        // optimize the query adding the needed property name to it\n+\n+        List<PropertyName> properties = targetQuery.getProperties();\n+        SortBy[] sorts = targetQuery.getSortBy();\n+\n+        Query q = targetQuery != null ? new Query(targetQuery) : new Query();\n+        // add the sortBy if not present\n+        SortBy[] sortBy = buildNewSortBy(sorts, groupingAttributes);\n+        q.setSortBy(sortBy);\n+\n+        // produces new PropertyName to add to the query\n+        List<PropertyName> propertiesToAdd =\n+                Stream.of(sortBy).map(s -> s.getPropertyName()).collect(Collectors.toList());\n+        propertiesToAdd.add(ff.property(operationAttribute));\n+\n+        // eventually merge with existing ones\n+        List<PropertyName> pns = getNewProperties(propertiesToAdd, properties);\n+        q.setProperties(pns);\n+\n+        // features with null values for groupingAttributes and operationAttribute\n+        // will not be rendered. Adding not null filters to delegate to the db.\n+        List<Filter> filters = new ArrayList<>();\n+        for (PropertyName pn : propertiesToAdd) {\n+            filters.add(ff.not(ff.isNull(pn)));\n+        }\n+        Filter original = q.getFilter();\n+        if (original != null && !original.equals(Filter.INCLUDE)) filters.add(q.getFilter());\n+        q.setFilter(ff.and(filters));\n+        return q;\n+    }\n+\n+    private SortBy[] buildNewSortBy(SortBy[] sorts, List<String> groupingAttributes) {\n+        // eventually creates new SortBy and add them to the array\n+        List<SortBy> newSorts = new ArrayList<>(groupingAttributes.size());\n+        List<PropertyName> properties =\n+                groupingAttributes.stream().map(s -> ff.property(s)).collect(Collectors.toList());\n+        for (int i = 0; i < properties.size(); i++) {\n+            PropertyName pn = properties.get(i);\n+            if (!sortByAlreadyExists(sorts, pn))\n+                newSorts.add(new SortByImpl(pn, SortOrder.ASCENDING));\n+        }\n+        if (newSorts.size() > 0) {\n+            if (sorts == null) return newSorts.toArray(new SortBy[newSorts.size()]);\n+            else return ArrayUtils.addAll(sorts, newSorts.toArray(new SortBy[newSorts.size()]));\n+        }\n+        return sorts;\n+    }\n+\n+    private List<PropertyName> getNewProperties(\n+            List<PropertyName> toAdd, List<PropertyName> originalProperties) {\n+        Set<PropertyName> properties = new HashSet<>();\n+        if (originalProperties != null) {\n+            properties.addAll(originalProperties);\n+        }\n+        if (toAdd != null) {\n+            properties.addAll(toAdd);\n+        }\n+        return new ArrayList<>(properties);\n+    }\n+\n+    private boolean sortByAlreadyExists(SortBy[] sorts, PropertyName pn) {\n+        if (sorts == null) return false;\n+        for (SortBy s : sorts) {\n+            // just checking the property name. In the context of the rendering\n+            // transformation the sortBy order doesn't matter\n+            if (s.getPropertyName().equals(pn)) {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    private PropertyName validatePropertyName(PropertyName pn, FeatureType schema) {\n+        // checks propertyName against the schema\n+        if (pn.evaluate(schema) == null)\n+            throw new ProcessException(\n+                    \"Unable to resolve \" + pn.getPropertyName() + \" against the FeatureType\");\n+        return pn;\n+    }\n+\n+    private NamespaceSupport declareNamespaces(FeatureType type) {\n+        // retrieves Namespaces for complex features\n+        NamespaceSupport namespaceSupport = null;\n+        Map namespaces = (Map) type.getUserData().get(Types.DECLARED_NAMESPACES_MAP);\n+        if (namespaces != null) {\n+            namespaceSupport = new NamespaceSupport();\n+            for (Iterator it = namespaces.entrySet().iterator(); it.hasNext(); ) {\n+                Map.Entry entry = (Map.Entry) it.next();\n+                String prefix = (String) entry.getKey();\n+                String namespace = (String) entry.getValue();\n+                namespaceSupport.declarePrefix(prefix, namespace);\n+            }\n+        }\n+        return namespaceSupport;\n+    }\n+\n+    /**\n+     * A FeatureCollection wrapper to filter out features according to the aggregation parameter and\n+     * the groups defined by the groupingAttributes\n+     */\n+    static class GroupingFeatureCollection\n+            extends DecoratingFeatureCollection<FeatureType, Feature> {\n+\n+        List<PropertyName> groupingAttributes;\n+\n+        PropertyName operationAttribute;\n+\n+        Operations aggregation;\n+\n+        public GroupingFeatureCollection(\n+                FeatureCollection<FeatureType, Feature> delegate,\n+                List<PropertyName> groupingAttributes,\n+                PropertyName operationAttribute,\n+                Operations aggregation) {\n+            super(delegate);\n+            this.groupingAttributes = groupingAttributes;\n+            this.operationAttribute = operationAttribute;\n+            this.aggregation = aggregation;\n+        }\n+\n+        @Override\n+        public FeatureIterator<Feature> features() {\n+            return new GroupingFeatureIterator(\n+                    new PushBackFeatureIterator(delegate.features()),\n+                    groupingAttributes,\n+                    operationAttribute,\n+                    aggregation);\n+        }\n+    }\n+\n+    /**\n+     * A FeatureIterator wrapper to filter out features according to the aggregation parameter and\n+     * the groups defined by the groupingAttributes\n+     */\n+    static class GroupingFeatureIterator extends DecoratingFeatureIterator<Feature> {\n+\n+        private List<PropertyName> groupByAttributes;\n+\n+        private PropertyName operationAttribute;\n+\n+        private Operations aggregation;\n+\n+        private Feature next;\n+\n+        /**\n+         * Wrap the provided FeatureIterator.\n+         *\n+         * @param iterator Iterator to be used as a delegate.\n+         */\n+        public GroupingFeatureIterator(\n+                PushBackFeatureIterator iterator,\n+                List<PropertyName> groupByAttributes,\n+                PropertyName operationValue,\n+                Operations aggregation) {\n+            super(iterator);\n+            this.groupByAttributes = groupByAttributes;\n+            this.operationAttribute = operationValue;\n+            this.aggregation = aggregation;\n+        }\n+\n+        @Override\n+        public boolean hasNext() {\n+            List<Object> groupingValues = new ArrayList<>(groupByAttributes.size());\n+            Map<Object, Feature> beingFiltered = new HashMap<>();\n+            List<Double> valuesToCompare = new ArrayList<>();\n+            while (super.hasNext()) {\n+                Feature f = super.next();\n+                if (beingFiltered.size() == 0) {\n+                    // no features in the list this is the first of the group\n+                    // takes the values to check the following features if belong to the same group\n+                    // features with null values are skipped\n+                    if (addGroupingValues(groupingValues, f))\n+                        addDoubleValueFromFeature(f, valuesToCompare, beingFiltered);\n+                } else {\n+                    // is the feature in the group?\n+                    if (featureComparison(groupingValues, f)) {\n+                        addDoubleValueFromFeature(f, valuesToCompare, beingFiltered);\n+                    } else {\n+                        ((PushBackFeatureIterator) delegate).pushBack();\n+                        break;\n+                    }\n+                }\n+            }\n+            next = doFiltering(beingFiltered, valuesToCompare);\n+            return next != null;\n+        }\n+\n+        private Feature doFiltering(\n+                Map<Object, Feature> beingFiltered, List<Double> beingEvaluated) {\n+            Object key;\n+            // searches the min or max inside the values list and retrieve the feature\n+            // to be returned from the Map.\n+            if (beingFiltered.size() > 0 && beingEvaluated.size() > 0) {\n+                if (this.aggregation.equals(Operations.MIN)) key = computeMin(beingEvaluated);\n+                else key = computeMax(beingEvaluated);\n+\n+                return beingFiltered.get(key);\n+            } else {\n+                return null;\n+            }\n+        }\n+\n+        private Number computeMin(List<Double> beingEvaluated) {\n+            return Collections.min(beingEvaluated);\n+        }\n+\n+        private Number computeMax(List<Double> beingEvaluated) {\n+            return Collections.max(beingEvaluated);\n+        }\n+\n+        private boolean featureComparison(List<Object> groupingValues, Feature f) {\n+            List<Object> toCompareValues = new ArrayList<>(groupingValues.size());\n+            for (PropertyName p : groupByAttributes) {\n+                toCompareValues.add(p.evaluate(f));\n+            }\n+            if (groupingValues.size() > 0 && groupingValues.equals(toCompareValues)) return true;\n+            return false;\n+        }\n+\n+        private boolean addGroupingValues(List<Object> groupingValues, Feature f) {\n+            for (PropertyName p : groupByAttributes) {\n+                Object result = p.evaluate(f);\n+                if (result != null) groupingValues.add(p.evaluate(f));\n+            }\n+            if (groupingValues.isEmpty() || groupingValues.size() < groupByAttributes.size())\n+                return false;\n+            return true;\n+        }\n+\n+        private void addDoubleValueFromFeature(\n+                Feature f, List<Double> valuesToCompare, Map<Object, Feature> beingFiltered) {\n+            Object result = this.operationAttribute.evaluate(f, Number.class);\n+            if (result instanceof Number) {\n+                Double value = ((Number) result).doubleValue();\n+                valuesToCompare.add(value);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5efd106ed909fc97db2dc5c828a059ad25fb5ad6"}, "originalPosition": 380}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "434db10738df37342b291be761ba43eeac3063f1", "author": {"user": {"login": "taba90", "name": null}}, "url": "https://github.com/geotools/geotools/commit/434db10738df37342b291be761ba43eeac3063f1", "committedDate": "2020-10-27T08:17:49Z", "message": "[GEOT-6726] Add new FilteringVectorProcess"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "5efd106ed909fc97db2dc5c828a059ad25fb5ad6", "author": {"user": {"login": "taba90", "name": null}}, "url": "https://github.com/geotools/geotools/commit/5efd106ed909fc97db2dc5c828a059ad25fb5ad6", "committedDate": "2020-10-23T06:11:25Z", "message": "[GEOT-6726] Add new FilteringVectorProcess"}, "afterCommit": {"oid": "081a7799f446543993e8f39c42f87a72ea77297a", "author": {"user": {"login": "taba90", "name": null}}, "url": "https://github.com/geotools/geotools/commit/081a7799f446543993e8f39c42f87a72ea77297a", "committedDate": "2020-10-28T07:07:26Z", "message": "reviewer's feedback applied"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "081a7799f446543993e8f39c42f87a72ea77297a", "author": {"user": {"login": "taba90", "name": null}}, "url": "https://github.com/geotools/geotools/commit/081a7799f446543993e8f39c42f87a72ea77297a", "committedDate": "2020-10-28T07:07:26Z", "message": "reviewer's feedback applied"}, "afterCommit": {"oid": "15042b3e25d75e20aab7a719069662e17068229c", "author": {"user": {"login": "taba90", "name": null}}, "url": "https://github.com/geotools/geotools/commit/15042b3e25d75e20aab7a719069662e17068229c", "committedDate": "2020-10-28T07:23:03Z", "message": "reviewer's feedback applied"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "15042b3e25d75e20aab7a719069662e17068229c", "author": {"user": {"login": "taba90", "name": null}}, "url": "https://github.com/geotools/geotools/commit/15042b3e25d75e20aab7a719069662e17068229c", "committedDate": "2020-10-28T07:23:03Z", "message": "reviewer's feedback applied"}, "afterCommit": {"oid": "cd137a1df27f21960236b0ad298eb6c1c9284af0", "author": {"user": {"login": "taba90", "name": null}}, "url": "https://github.com/geotools/geotools/commit/cd137a1df27f21960236b0ad298eb6c1c9284af0", "committedDate": "2020-10-30T11:18:11Z", "message": "reviewer's feedback applied"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2467f3f9429e0d7aa1448bb9ba5cf86d59dd4695", "author": {"user": {"login": "taba90", "name": null}}, "url": "https://github.com/geotools/geotools/commit/2467f3f9429e0d7aa1448bb9ba5cf86d59dd4695", "committedDate": "2020-10-30T11:25:34Z", "message": "reviewer's feedback applied"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "cd137a1df27f21960236b0ad298eb6c1c9284af0", "author": {"user": {"login": "taba90", "name": null}}, "url": "https://github.com/geotools/geotools/commit/cd137a1df27f21960236b0ad298eb6c1c9284af0", "committedDate": "2020-10-30T11:18:11Z", "message": "reviewer's feedback applied"}, "afterCommit": {"oid": "2467f3f9429e0d7aa1448bb9ba5cf86d59dd4695", "author": {"user": {"login": "taba90", "name": null}}, "url": "https://github.com/geotools/geotools/commit/2467f3f9429e0d7aa1448bb9ba5cf86d59dd4695", "committedDate": "2020-10-30T11:25:34Z", "message": "reviewer's feedback applied"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIwNzI3NDEw", "url": "https://github.com/geotools/geotools/pull/3187#pullrequestreview-520727410", "createdAt": "2020-10-30T14:34:41Z", "commit": {"oid": "2467f3f9429e0d7aa1448bb9ba5cf86d59dd4695"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3046, "cost": 1, "resetAt": "2021-11-01T14:20:25Z"}}}