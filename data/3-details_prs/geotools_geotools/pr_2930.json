{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDE3MTE2Nzc1", "number": 2930, "title": "Support mbstyle filter expressions [GEOT-6589] ", "bodyText": "The filter support used by GeoTools has been moved to \"Legacy - Other filter\":\nfilter: [\">\", \"scalerank\", 2]\n\nThis has been replaced with the use of expressions:\nfilter: [\">\", [\"get\",\"scalerank\"], 2]\n\nThis means we can no longer use style examples available online.\nSee https://osgeo-org.atlassian.net/browse/GEOT-6589 for details.\nChecklist\nFor all pull requests:\n\n Confirm you have read the contribution guidelines\n You have sent a Contribution Licence Agreement (CLA) as necessary (not required for small changes, e.g., fixing typos in documentation)\n Make sure the first PR targets the master branch, eventual backports will be managed later. This can be ignored if the PR is fixing an issue that only happens in a specific branch, but not in newer ones.\n The changes are not breaking the build in downstream projects using SNAPSHOT dependencies, GeoWebCache and GeoServer.\n\nThe following are required only for core and extension modules (they are welcomed, but not required, for unsupported modules):\n\n There is an issue https://osgeo-org.atlassian.net/browse/GEOT-6589\n The pull request contains changes related to a single objective. If multiple focuses cannot be avoided, each one is in its own commit and has a separate ticket describing it.\n PR for bug fixes and small new features are presented as a single commit: use squash changes when merging\n Commit message must be in the form \"[GEOT-XYZW] Title of the Jira ticket\": use squash changes when merging\n New unit tests have been added covering the changes\n This PR passes all existing unit tests (test results will be reported by travis-ci after opening this PR)\n This PR passes the QA checks (QA checks results will be reported by travis-ci after opening this PR)\n Documentation has been updated accordingly.\n\nSubmitting the PR does not require you to check all items, but by the time it gets merged, they should be either satisfied or inapplicable.", "createdAt": "2020-05-13T04:59:27Z", "url": "https://github.com/geotools/geotools/pull/2930", "merged": true, "mergeCommit": {"oid": "e3bb86bc55006eddc380e242014a0aa6e36bd4d9"}, "closed": true, "closedAt": "2020-07-15T06:37:22Z", "author": {"login": "jodygarnett"}, "timelineItems": {"totalCount": 25, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcgx2GfAFqTQxMDU5MzA5MA==", "endCursor": "Y3Vyc29yOnYyOpPPAAABc1EMSzgH2gAyNDE3MTE2Nzc1OjdlZDdjN2RmYzc1MjkxMmY4MTg5NzQwMjM3OGZkMjAxZDA5ZTAzYzc=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDEwNTkzMDkw", "url": "https://github.com/geotools/geotools/pull/2930#pullrequestreview-410593090", "createdAt": "2020-05-13T05:16:06Z", "commit": {"oid": "922db222c01f88dd4f7b5e32e4d588b7109073ef"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xM1QwNToxNjowNlrOGUhurA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xM1QwNToxNjowNlrOGUhurA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDE3NzMyNA==", "bodyText": "@vickdw I was going to ask for your input here, this is my first looking into how expressions have been implemented and I wanted to take a consistent approach before changing anything substantially.\nThe above is based on the MBDecision.decisionNotEqual() which calls parse.string(json,1) as shown above. If I understand correctly the string method is willing to convert any literals (strings, numbers, booleans) to a string so we end up with a string equality check only. Rather than a numeric != numeric equality check.\nDoes this match with your understanding?", "url": "https://github.com/geotools/geotools/pull/2930#discussion_r424177324", "createdAt": "2020-05-13T05:16:06Z", "author": {"login": "jodygarnett"}, "path": "modules/extension/mbstyle/src/main/java/org/geotools/mbstyle/parse/MBFilter.java", "diffHunk": "@@ -460,4 +468,59 @@ public Filter filter() {\n             throw new MBFormatException(\"Unsupported filter \" + json);\n         }\n     }\n+\n+    /**\n+     * Returns true if the input values are equal, false otherwise. The inputs must be numbers,\n+     * strings, or booleans, and both of the same type. Examples: [\"==\", number, number]: boolean\n+     * [\"==\", string, string]: boolean [\"==\", boolean, boolean]: boolean [\"==\", null, null]: boolean\n+     *\n+     * @return equal to expression\n+     */\n+    private Filter filterEqualTo(JSONArray array) {\n+        if (array.size() != 3) {\n+            throwUnexpectedArgumentCount(\"==\", 2);\n+        }\n+        final FilterFactory2 ff = parse.getFilterFactory();\n+        if (parse.isString(array, 1)) { // legacy filter syntax\n+            String key = parse.get(array, 1);\n+            Object value = parse.value(array, 2);\n+            return ff.equal(ff.property(key), ff.literal(value), false);\n+        } else {\n+            Expression expression1 = parse.string(array, 1);\n+            Expression expression2 = parse.string(array, 2);\n+            return ff.equal(expression1, expression2, false);\n+        }\n+    }\n+\n+    /**\n+     * Returns true if the input values are not equal, false otherwise. The inputs must be numbers,\n+     * strings, or booleans, and both of the same type. Examples:[\"!=\", number, number]: boolean\n+     * [\"!=\", string, string]: boolean [\"!=\", boolean, boolean]: boolean [\"!=\", null, null]: boolean\n+     *\n+     * @return Not equals expression\n+     */\n+    private Filter filterNotEqual(JSONArray array) {\n+        if (array.size() != 3) {\n+            throwUnexpectedArgumentCount(\"!=\", 2);\n+        }\n+        final FilterFactory2 ff = parse.getFilterFactory();\n+        if (parse.isString(array, 1)) { // legacy filter syntax\n+            String key = parse.get(json, 1);\n+            Object value = parse.value(json, 2);\n+            return ff.notEqual(ff.property(key), ff.literal(value), false);\n+        } else {\n+            // get the comparables\n+            Expression expression1 = parse.string(json, 1);\n+            Expression expression2 = parse.string(json, 2);\n+            return ff.notEqual(expression1, expression2);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "922db222c01f88dd4f7b5e32e4d588b7109073ef"}, "originalPosition": 85}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDEwNTkzNjYx", "url": "https://github.com/geotools/geotools/pull/2930#pullrequestreview-410593661", "createdAt": "2020-05-13T05:18:01Z", "commit": {"oid": "922db222c01f88dd4f7b5e32e4d588b7109073ef"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xM1QwNToxODowMVrOGUhwdA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xM1QwNToxODowMVrOGUhwdA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDE3Nzc4MA==", "bodyText": "This blind conversion to a string incorrectly resulted in correctly generated Expressions being represented as strings. I suspect it should be removed!", "url": "https://github.com/geotools/geotools/pull/2930#discussion_r424177780", "createdAt": "2020-05-13T05:18:01Z", "author": {"login": "jodygarnett"}, "path": "modules/extension/mbstyle/src/main/java/org/geotools/mbstyle/parse/MBObjectParser.java", "diffHunk": "@@ -332,9 +332,10 @@ public String get(JSONArray json, int index) {\n         }\n         if (index < json.size() && json.get(index) instanceof String) {\n             return (String) json.get(index);\n-        }\n-        if (index < json.size() && json.get(index) instanceof JSONArray) {\n-            return MBExpression.transformExpression((JSONArray) json.get(index)).toString();\n+            //        }\n+            //        if (index < json.size() && json.get(index) instanceof JSONArray) {\n+            //            return MBExpression.transformExpression((JSONArray)\n+            // json.get(index)).toString();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "922db222c01f88dd4f7b5e32e4d588b7109073ef"}, "originalPosition": 10}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDEyMDAwODQw", "url": "https://github.com/geotools/geotools/pull/2930#pullrequestreview-412000840", "createdAt": "2020-05-14T16:54:48Z", "commit": {"oid": "2d382cee2cbc0a0c38146db31a11f48cfb7f65af"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNFQxNjo1NDo0OFrOGVlkBA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNFQxNjo1NDo0OFrOGVlkBA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTI4ODcwOA==", "bodyText": "could you put some comments in the code here (maybe an example)?  it's hard to determine what all the json.size() == X mean.\nAlso, I think get requires one argument - [\"get\", \"propName\"]", "url": "https://github.com/geotools/geotools/pull/2930#discussion_r425288708", "createdAt": "2020-05-14T16:54:48Z", "author": {"login": "davidblasby"}, "path": "modules/extension/mbstyle/src/main/java/org/geotools/mbstyle/expression/MBLookup.java", "diffHunk": "@@ -56,16 +56,22 @@ public Expression lookupAt() {\n     public Expression lookupGet() {\n         if (json.size() == 2 || json.size() == 3) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2d382cee2cbc0a0c38146db31a11f48cfb7f65af"}, "originalPosition": 2}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDEyMDAyMzc3", "url": "https://github.com/geotools/geotools/pull/2930#pullrequestreview-412002377", "createdAt": "2020-05-14T16:56:42Z", "commit": {"oid": "2d382cee2cbc0a0c38146db31a11f48cfb7f65af"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNFQxNjo1Njo0MlrOGVlo3A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNFQxNjo1Njo0MlrOGVlo3A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTI4OTk0OA==", "bodyText": "looks like there is a lot of copy-and-paste code here and all the other functions.  They're all the same except the last line.", "url": "https://github.com/geotools/geotools/pull/2930#discussion_r425289948", "createdAt": "2020-05-14T16:56:42Z", "author": {"login": "davidblasby"}, "path": "modules/extension/mbstyle/src/main/java/org/geotools/mbstyle/parse/MBFilter.java", "diffHunk": "@@ -460,4 +464,116 @@ public Filter filter() {\n             throw new MBFormatException(\"Unsupported filter \" + json);\n         }\n     }\n+\n+    /**\n+     * Returns true if the input values are equal, false otherwise. The inputs must be numbers,\n+     * strings, or booleans, and both of the same type. Examples: [\"==\", number, number]: boolean\n+     * [\"==\", string, string]: boolean [\"==\", boolean, boolean]: boolean [\"==\", null, null]: boolean\n+     *\n+     * @return equal to expression\n+     */\n+    private Filter filterEqualTo(JSONArray array) {\n+        if (array.size() != 3) {\n+            throwUnexpectedArgumentCount(\"==\", 2);\n+        }\n+        if (parse.isString(array, 1)) { // legacy filter syntax\n+            String key = parse.get(array, 1);\n+            Object value = parse.value(array, 2);\n+            return ff.equal(ff.property(key), ff.literal(value), false);\n+        } else {\n+            Expression expression1 = parse.string(array, 1);\n+            Expression expression2 = parse.string(array, 2);\n+            return ff.equal(expression1, expression2, false);\n+        }\n+    }\n+\n+    /**\n+     * Returns true if the input values are not equal, false otherwise. The inputs must be numbers,\n+     * strings, or booleans, and both of the same type. Examples:[\"!=\", number, number]: boolean\n+     * [\"!=\", string, string]: boolean [\"!=\", boolean, boolean]: boolean [\"!=\", null, null]: boolean\n+     *\n+     * @return Not equals expression\n+     */\n+    private Filter filterNotEqual(JSONArray array) {\n+        if (array.size() != 3) {\n+            throwUnexpectedArgumentCount(\"!=\", 2);\n+        }\n+        if (parse.isString(array, 1)) { // legacy filter syntax\n+            String key = parse.get(json, 1);\n+            Object value = parse.value(json, 2); // legacy filter restricted to literals\n+            return ff.notEqual(ff.property(key), ff.literal(value), false);\n+        } else {\n+            Expression expression1 = parse.string(json, 1);\n+            Expression expression2 = parse.string(json, 2);\n+            return ff.notEqual(expression1, expression2);\n+        }\n+    }\n+\n+    private Filter filterLessOrEqual(JSONArray array) {\n+        if (json.size() != 3) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2d382cee2cbc0a0c38146db31a11f48cfb7f65af"}, "originalPosition": 186}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE2NTQzMDE2", "url": "https://github.com/geotools/geotools/pull/2930#pullrequestreview-416543016", "createdAt": "2020-05-21T22:47:17Z", "commit": {"oid": "ae26dd5d30806fbfa83bb76f36daa01adc6c60c7"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 9, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMVQyMjo0NzoxOFrOGZFYEg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMVQyMzoyODo0MlrOGZGGtw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODk1NTY2Ng==", "bodyText": "You've managed to make the grammar worse here, either fix the tense in the rest of the comment or revert", "url": "https://github.com/geotools/geotools/pull/2930#discussion_r428955666", "createdAt": "2020-05-21T22:47:18Z", "author": {"login": "tbarsballe"}, "path": "modules/extension/mbstyle/src/main/java/org/geotools/mbstyle/parse/MBFilter.java", "diffHunk": "@@ -151,7 +183,7 @@ public MBFilter(JSONArray json, MBObjectParser parse, SemanticType semanticType)\n     /**\n      * Utility method to convert json to set of {@link SemanticType}.\n      *\n-     * <p>This method recursively calls itself to handle all and any operators.\n+     * <p>This method is recursively calls itself to handle all and any operators.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ae26dd5d30806fbfa83bb76f36daa01adc6c60c7"}, "originalPosition": 74}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODk1NzE3NQ==", "bodyText": "This doc could distinguish better between GeoTools Filters and Expressions, and Mapbox Filter Functions and Expressions. It is also unclear from this document whether or not gt-mbstyle still supports using the old syntax, or it is just included for posterity (and there's enough changes from the body of this class that I can't tell from looking at the code either - does the old syntax still function or has it actually been removed now?)", "url": "https://github.com/geotools/geotools/pull/2930#discussion_r428957175", "createdAt": "2020-05-21T22:52:20Z", "author": {"login": "tbarsballe"}, "path": "modules/extension/mbstyle/src/main/java/org/geotools/mbstyle/parse/MBFilter.java", "diffHunk": "@@ -38,7 +39,34 @@\n  *\n  * <p>This wrapper and {@link MBFunction} are a matched set handling dynamic data.\n  *\n- * <h2>About MapBox Filter</h2>\n+ * <h2>Expression: Decision</h2>\n+ *\n+ * <p>Implementation Note:The value for any filter may be specified as an expression. The result type of an expression in\n+ * the filter property must be boolean. See {@link org.geotools.mbstyle.expression.MBExpression} for details.\n+ *\n+ * <p>The expressions in this section can be used to add conditional logic to your styles. For example, the 'case' expression\n+ * provides \"if/then/else\" logic, and 'match' allows you to map specific values of an input expression to different\n+ * output expressions.\n+ * <ul>\n+ *     <li><code>[\"!\", boolean]: boolean</code></li>\n+ *     <li><code>[\"!=\", value, value]: boolean</code></li>\n+ *     <li><code>&lt;/code></li>\n+ *     <li><code>&lt;=</code></li>\n+ *     <li><code>==</code></li>\n+ *     <li><code>&gt;</code></li>\n+ *     <li><code>&gt;=</code></li>\n+ *     <li><code>all</code></li>\n+ *     <li><code>any</code></li>\n+ *     <li><code>case</code></li>\n+ *     <li><code>coalesce</code></li>\n+ *     <li><code>match</code></li>\n+ *     <li><code>within</code></li>\n+ * </ul>\n+ *\n+ * <h2>Filter Other</h2>\n+ *\n+ * <p>Implementation Note: In previous versions of the style specification, filters were defined using the deprecated\n+ * syntax documented here.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ae26dd5d30806fbfa83bb76f36daa01adc6c60c7"}, "originalPosition": 40}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODk1OTM1MA==", "bodyText": "Shouldn't this say \"Unsupported expression\" now, as the error message is from the perspective of the mapbox style?", "url": "https://github.com/geotools/geotools/pull/2930#discussion_r428959350", "createdAt": "2020-05-21T22:59:17Z", "author": {"login": "tbarsballe"}, "path": "modules/extension/mbstyle/src/main/java/org/geotools/mbstyle/parse/MBFilter.java", "diffHunk": "@@ -378,86 +377,269 @@ public Filter filter() {\n         } else if (\"has\".equals(operator)) {\n             String key = parse.get(json, 1);\n             return ff.not(ff.isNull(ff.property(key)));\n-            // Comparison Filters\n-        } else if (\"==\".equals(operator)) {\n-            String key = parse.get(json, 1);\n-            Object value = parse.value(json, 2);\n-            return ff.equal(ff.property(key), ff.literal(value), false);\n+        }\n+        // Comparison Filters\n+        else if (\"==\".equals(operator)) {\n+            return filterEqualTo(json);\n         } else if (\"!=\".equals(operator)) {\n-            String key = parse.get(json, 1);\n-            Object value = parse.value(json, 2);\n-            return ff.notEqual(ff.property(key), ff.literal(value), false);\n+            return filterNotEqual(json);\n         } else if (\">\".equals(operator)) {\n-            String key = parse.get(json, 1);\n-            Object value = parse.value(json, 2);\n-            return ff.greater(ff.property(key), ff.literal(value), false);\n+            return filterGreater(json);\n         } else if (\">=\".equals(operator)) {\n-            String key = parse.get(json, 1);\n-            Object value = parse.value(json, 2);\n-            return ff.greaterOrEqual(ff.property(key), ff.literal(value), false);\n+            return filterGreaterOrEqual(json);\n         } else if (\"<\".equals(operator)) {\n-            String key = parse.get(json, 1);\n-            Object value = parse.value(json, 2);\n-            return ff.less(ff.property(key), ff.literal(value), false);\n+            return filterLess(json);\n         } else if (\"<=\".equals(operator)) {\n-            String key = parse.get(json, 1);\n-            Object value = parse.value(json, 2);\n-            return ff.lessOrEqual(ff.property(key), ff.literal(value), false);\n-            // Set Membership Filters\n-        } else if (\"in\".equals(operator)) {\n-            String key = parse.get(json, 1);\n-            Expression[] args = new Expression[json.size() - 1];\n-            args[0] = ff.property(key);\n-            for (int i = 1; i < args.length; i++) {\n-                Object value = parse.value(json, i + 1);\n-                args[i] = ff.literal(value);\n-            }\n-            Function in = ff.function(\"in\", args);\n-            return ff.equals(in, ff.literal(true));\n+            return filterLessOrEqual(json);\n+        }\n+        // Set Membership Filters\n+        else if (\"in\".equals(operator)) {\n+            return filterIn(json, true);\n         } else if (\"!in\".equals(operator)) {\n-            String key = parse.get(json, 1);\n-            Expression[] args = new Expression[json.size() - 1];\n-            args[0] = ff.property(key);\n-            for (int i = 1; i < args.length; i++) {\n-                Object value = parse.value(json, i + 1);\n-                args[i] = ff.literal(value);\n-            }\n-            Function in = ff.function(\"in\", args);\n-            return ff.equals(in, ff.literal(false));\n-            // Combining Filters\n-        } else if (\"all\".equals(operator)) {\n-            List<Filter> all = new ArrayList<>();\n-            for (int i = 1; i < json.size(); i++) {\n-                MBFilter mbFilter = new MBFilter((JSONArray) json.get(i));\n+            return filterIn(json, false);\n+        }\n+        // Combining Filters\n+        else if (\"all\".equals(operator)) {\n+            return filterAll(json);\n+        } else if (\"any\".equals(operator)) {\n+            return filterAny(json);\n+        } else if (\"none\".equals(operator)) {\n+            return filterNone(json);\n+        }\n+        // MBExpression filters\n+        else if (\"case\".equals(operator)) {\n+            Expression caseExpr = MBExpression.transformExpression(json);\n+            return ff.equals(caseExpr, ff.literal(true));\n+        } else if (\"coalesce\".equals(operator)) {\n+            Expression coalesce = MBExpression.transformExpression(json);\n+            return ff.equals(coalesce, ff.literal(true));\n+        } else if (\"match\".equals(operator)) {\n+            Expression match = MBExpression.transformExpression(json);\n+            return ff.equals(match, ff.literal(true));\n+        } else if (\"within\".equals(operator)) {\n+            Expression within = MBExpression.transformExpression(json);\n+            return ff.equals(within, ff.literal(true));\n+        } else {\n+            throw new MBFormatException(\"Unsupported filter \" + json);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ae26dd5d30806fbfa83bb76f36daa01adc6c60c7"}, "originalPosition": 423}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODk2MTA0Ng==", "bodyText": "\"value2\" instead of \"value1\"?", "url": "https://github.com/geotools/geotools/pull/2930#discussion_r428961046", "createdAt": "2020-05-21T23:05:04Z", "author": {"login": "tbarsballe"}, "path": "modules/extension/mbstyle/src/main/java/org/geotools/mbstyle/parse/MBFilter.java", "diffHunk": "@@ -378,86 +377,269 @@ public Filter filter() {\n         } else if (\"has\".equals(operator)) {\n             String key = parse.get(json, 1);\n             return ff.not(ff.isNull(ff.property(key)));\n-            // Comparison Filters\n-        } else if (\"==\".equals(operator)) {\n-            String key = parse.get(json, 1);\n-            Object value = parse.value(json, 2);\n-            return ff.equal(ff.property(key), ff.literal(value), false);\n+        }\n+        // Comparison Filters\n+        else if (\"==\".equals(operator)) {\n+            return filterEqualTo(json);\n         } else if (\"!=\".equals(operator)) {\n-            String key = parse.get(json, 1);\n-            Object value = parse.value(json, 2);\n-            return ff.notEqual(ff.property(key), ff.literal(value), false);\n+            return filterNotEqual(json);\n         } else if (\">\".equals(operator)) {\n-            String key = parse.get(json, 1);\n-            Object value = parse.value(json, 2);\n-            return ff.greater(ff.property(key), ff.literal(value), false);\n+            return filterGreater(json);\n         } else if (\">=\".equals(operator)) {\n-            String key = parse.get(json, 1);\n-            Object value = parse.value(json, 2);\n-            return ff.greaterOrEqual(ff.property(key), ff.literal(value), false);\n+            return filterGreaterOrEqual(json);\n         } else if (\"<\".equals(operator)) {\n-            String key = parse.get(json, 1);\n-            Object value = parse.value(json, 2);\n-            return ff.less(ff.property(key), ff.literal(value), false);\n+            return filterLess(json);\n         } else if (\"<=\".equals(operator)) {\n-            String key = parse.get(json, 1);\n-            Object value = parse.value(json, 2);\n-            return ff.lessOrEqual(ff.property(key), ff.literal(value), false);\n-            // Set Membership Filters\n-        } else if (\"in\".equals(operator)) {\n-            String key = parse.get(json, 1);\n-            Expression[] args = new Expression[json.size() - 1];\n-            args[0] = ff.property(key);\n-            for (int i = 1; i < args.length; i++) {\n-                Object value = parse.value(json, i + 1);\n-                args[i] = ff.literal(value);\n-            }\n-            Function in = ff.function(\"in\", args);\n-            return ff.equals(in, ff.literal(true));\n+            return filterLessOrEqual(json);\n+        }\n+        // Set Membership Filters\n+        else if (\"in\".equals(operator)) {\n+            return filterIn(json, true);\n         } else if (\"!in\".equals(operator)) {\n-            String key = parse.get(json, 1);\n-            Expression[] args = new Expression[json.size() - 1];\n-            args[0] = ff.property(key);\n-            for (int i = 1; i < args.length; i++) {\n-                Object value = parse.value(json, i + 1);\n-                args[i] = ff.literal(value);\n-            }\n-            Function in = ff.function(\"in\", args);\n-            return ff.equals(in, ff.literal(false));\n-            // Combining Filters\n-        } else if (\"all\".equals(operator)) {\n-            List<Filter> all = new ArrayList<>();\n-            for (int i = 1; i < json.size(); i++) {\n-                MBFilter mbFilter = new MBFilter((JSONArray) json.get(i));\n+            return filterIn(json, false);\n+        }\n+        // Combining Filters\n+        else if (\"all\".equals(operator)) {\n+            return filterAll(json);\n+        } else if (\"any\".equals(operator)) {\n+            return filterAny(json);\n+        } else if (\"none\".equals(operator)) {\n+            return filterNone(json);\n+        }\n+        // MBExpression filters\n+        else if (\"case\".equals(operator)) {\n+            Expression caseExpr = MBExpression.transformExpression(json);\n+            return ff.equals(caseExpr, ff.literal(true));\n+        } else if (\"coalesce\".equals(operator)) {\n+            Expression coalesce = MBExpression.transformExpression(json);\n+            return ff.equals(coalesce, ff.literal(true));\n+        } else if (\"match\".equals(operator)) {\n+            Expression match = MBExpression.transformExpression(json);\n+            return ff.equals(match, ff.literal(true));\n+        } else if (\"within\".equals(operator)) {\n+            Expression within = MBExpression.transformExpression(json);\n+            return ff.equals(within, ff.literal(true));\n+        } else {\n+            throw new MBFormatException(\"Unsupported filter \" + json);\n+        }\n+    }\n+\n+    private Filter filterNone(JSONArray array) {\n+        List<Filter> none = new ArrayList<>();\n+        for (int i = 1; i < array.size(); i++) {\n+            if (parse.isArray(array, i)) {\n+                // using not here so we can short circuit the and filter below\n+                MBFilter mbFilter = new MBFilter((JSONArray) array.get(i));\n                 Filter filter = mbFilter.filter();\n                 if (filter != Filter.INCLUDE) {\n-                    all.add(filter);\n+                    none.add(ff.not(filter));\n                 }\n+            } else {\n+                throw new MBFormatException(\n+                        \"None filter does not support: \\\"\" + json.get(i) + \"\\\"\");\n             }\n-            return ff.and(all);\n-        } else if (\"any\".equals(operator)) {\n-            List<Filter> any = new ArrayList<>();\n-            for (int i = 1; i < json.size(); i++) {\n-                MBFilter mbFilter = new MBFilter((JSONArray) json.get(i));\n+        }\n+        return ff.and(none);\n+    }\n+\n+    private Filter filterAny(JSONArray array) {\n+        List<Filter> any = new ArrayList<>();\n+        for (int i = 1; i < array.size(); i++) {\n+            if (parse.isArray(array, i)) {\n+                MBFilter mbFilter = new MBFilter((JSONArray) array.get(i));\n                 Filter filter = mbFilter.filter();\n                 if (filter != Filter.INCLUDE) {\n                     any.add(filter);\n                 }\n+            } else {\n+                throw new MBFormatException(\"Any filter does not support: \\\"\" + json.get(i) + \"\\\"\");\n             }\n-            return ff.or(any);\n-        } else if (\"none\".equals(operator)) {\n-            List<Filter> none = new ArrayList<>();\n-            for (int i = 1; i < json.size(); i++) {\n-                // using not here so we can short circuit the and filter below\n-                MBFilter mbFilter = new MBFilter((JSONArray) json.get(i));\n+        }\n+        return ff.or(any);\n+    }\n+\n+    private Filter filterAll(JSONArray array) {\n+        List<Filter> all = new ArrayList<>();\n+        for (int i = 1; i < array.size(); i++) {\n+            if (parse.isArray(array, i)) {\n+                MBFilter mbFilter = new MBFilter((JSONArray) array.get(i));\n                 Filter filter = mbFilter.filter();\n                 if (filter != Filter.INCLUDE) {\n-                    none.add(ff.not(filter));\n+                    all.add(filter);\n                 }\n+            } else {\n+                throw new MBFormatException(\"All filter does not support: \\\"\" + json.get(i) + \"\\\"\");\n             }\n-            return ff.and(none);\n+        }\n+        return ff.and(all);\n+    }\n+\n+    private Filter filterIn(JSONArray array, boolean in) {\n+        String key = parse.get(array, 1);\n+        Expression[] args = new Expression[array.size() - 1];\n+        args[0] = ff.property(key);\n+        for (int i = 1; i < args.length; i++) {\n+            Expression expression = parse.string(array, i + 1);\n+            args[i] = expression;\n+        }\n+        Function function = ff.function(\"in\", args);\n+        return ff.equals(function, ff.literal(in));\n+    }\n+\n+    private Filter filterByFeatureIdentifier(JSONArray array, String operator) {\n+        Set<FeatureId> fids = new HashSet<>();\n+        for (Object value : array.subList(2, array.size())) {\n+            if (value instanceof String) {\n+                String fid = (String) value;\n+                fids.add(ff.featureId(fid));\n+            }\n+        }\n+        if (\"has\".equals(operator) || \"in\".equals(operator)) {\n+            return ff.id(fids);\n+        } else if (\"!has\".equals(operator) || \"!in\".equals(operator)) {\n+            return ff.not(ff.id(fids));\n         } else {\n-            throw new MBFormatException(\"Unsupported filter \" + json);\n+            throw new UnsupportedOperationException(\"$id \\\"\" + operator + \"\\\" not valid\");\n+        }\n+    }\n+\n+    private Filter filterByGeometryType(JSONArray json, String operator) {\n+        List<Filter> typeFilters = new ArrayList<>();\n+        List<?> types = json.subList(2, json.size());\n+        for (Object type : types) {\n+            Filter typeFilter = null;\n+            if (type instanceof String) {\n+                typeFilter = translateType((String) type);\n+            }\n+            if (typeFilter == null) {\n+                throw new MBFormatException(\n+                        \"\\\"$type\\\" limited to Point, LineString, Polygon: \" + type);\n+            }\n+            typeFilters.add(typeFilter);\n+        }\n+        if (\"==\".equals(operator)) {\n+            if (typeFilters.size() != 1) {\n+                throw new MBFormatException(\n+                        \"[\\\"==\\\",\\\"$type\\\", ...] limited one geometry type, to test more than one use \\\"in\\\" operator.\");\n+            }\n+            return typeFilters.get(0);\n+        } else if (\"!=\".equals(operator)) {\n+            if (typeFilters.size() != 1) {\n+                throw new MBFormatException(\n+                        \"[\\\"!=\\\",\\\"$type\\\", ...] limited one geometry type, to test more than one use \\\"!in\\\" operator.\");\n+            }\n+            return ff.not(typeFilters.get(0));\n+        } else if (\"in\".equals(operator)) {\n+            return ff.or(typeFilters);\n+        } else if (\"!in\".equals(operator)) {\n+            return ff.not(ff.or(typeFilters));\n+        } else {\n+            throw new MBFormatException(\"Unsupported $type operator \\\"\" + json + \"\\\"\");\n+        }\n+    }\n+\n+    /**\n+     * Returns true if the input values are equal, false otherwise. The inputs must be numbers,\n+     * strings, or booleans, and both of the same type. Examples: [\"==\", number, number]: boolean\n+     * [\"==\", string, string]: boolean [\"==\", boolean, boolean]: boolean [\"==\", null, null]: boolean\n+     *\n+     * @return equal to expression\n+     */\n+    private Filter filterEqualTo(JSONArray array) {\n+        if (array.size() != 3) {\n+            throwUnexpectedArgumentCount(\"==\", 2);\n+        }\n+        Expression expression1 = comparisonExpression1(array);\n+        Expression expression2 = comparisonExpression2(array);\n+        return ff.equals(expression1, expression2);\n+    }\n+\n+    /**\n+     * Returns true if the input values are not equal, false otherwise. The inputs must be numbers,\n+     * strings, or booleans, and both of the same type. Examples:[\"!=\", number, number]: boolean\n+     * [\"!=\", string, string]: boolean [\"!=\", boolean, boolean]: boolean [\"!=\", null, null]: boolean\n+     *\n+     * @return Not equals expression\n+     */\n+    private Filter filterNotEqual(JSONArray array) {\n+        if (array.size() != 3) {\n+            throwUnexpectedArgumentCount(\"!=\", 2);\n+        }\n+        Expression expression1 = comparisonExpression1(array);\n+        Expression expression2 = comparisonExpression2(array);\n+        return ff.notEqual(expression1, expression2);\n+    }\n+\n+    private Filter filterLessOrEqual(JSONArray array) {\n+        if (json.size() != 3) {\n+            throwUnexpectedArgumentCount(\"<=\", 2);\n+        }\n+        Expression expression1 = comparisonExpression1(array);\n+        Expression expression2 = comparisonExpression2(array);\n+        return ff.lessOrEqual(expression1, expression2);\n+    }\n+\n+    private Filter filterLess(JSONArray array) {\n+        if (json.size() != 3) {\n+            throwUnexpectedArgumentCount(\"<\", 2);\n+        }\n+        Expression expression1 = comparisonExpression1(array);\n+        Expression expression2 = comparisonExpression2(array);\n+        return ff.less(expression1, expression2);\n+    }\n+\n+    private Filter filterGreaterOrEqual(JSONArray array) {\n+        if (json.size() != 3) {\n+            throwUnexpectedArgumentCount(\">=\", 2);\n+        }\n+        Expression expression1 = comparisonExpression1(array);\n+        Expression expression2 = comparisonExpression2(array);\n+        return ff.greaterOrEqual(expression1, expression2);\n+    }\n+\n+    private Filter filterGreater(JSONArray array) {\n+        if (json.size() != 3) {\n+            throwUnexpectedArgumentCount(\">\", 2);\n+        }\n+        Expression expression1 = comparisonExpression1(array);\n+        Expression expression2 = comparisonExpression2(array);\n+        return ff.greater(expression1, expression2);\n+    }\n+\n+    private void throwUnexpectedArgumentCount(String expression, int argCount)\n+            throws MBFormatException {\n+        throw new MBFormatException(\n+                String.format(\n+                        \"Expression \\\"%s\\\" should have exactly %d argument(s)\",\n+                        expression, argCount));\n+    }\n+\n+    /**\n+     * Comparison value1 defined as an expression (or legacy key reference).\n+     *\n+     * @param array JSON filter definition\n+     * @return Expression for comparison\n+     */\n+    private Expression comparisonExpression1(JSONArray array) {\n+        if (parse.isString(array, 1)) { // legacy filter syntax\n+            String key = parse.get(array, 1);\n+            return ff.property(key);\n+        } else {\n+            return parse.string(array, 1);\n+        }\n+    }\n+    /**\n+     * Comparison value1 defined as an expression (or legacy literal reference).", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ae26dd5d30806fbfa83bb76f36daa01adc6c60c7"}, "originalPosition": 647}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODk2MjAzMw==", "bodyText": "\"property expressions\" is not a term referenced anywhere in the MBStyle spec (I think the term you are looking for is data expressions - https://docs.mapbox.com/mapbox-gl-js/style-spec/expressions/#data-expressions ), and you've referred to them as just \"expressions\" elsewhere.\nPlease stick with a consistent name. The distinction between GeoTools Expressions and MapBox expressions is already confusing enough without making up terms.", "url": "https://github.com/geotools/geotools/pull/2930#discussion_r428962033", "createdAt": "2020-05-21T23:08:37Z", "author": {"login": "tbarsballe"}, "path": "modules/extension/mbstyle/src/main/java/org/geotools/mbstyle/parse/MBFunction.java", "diffHunk": "@@ -35,7 +35,10 @@\n import org.opengis.filter.expression.Function;\n \n /**\n- * MBFunction json wrapper, allowing conversion to a GeoTools Expression.\n+ * MBFunction json wrapper, allowing conversion of function to a GeoTools Expression.\n+ *\n+ * <p>As of MapBox Style Specification v0.41.0, property expressions are the preferred approach for", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ae26dd5d30806fbfa83bb76f36daa01adc6c60c7"}, "originalPosition": 7}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODk2Mjg4Mw==", "bodyText": "\"... not a supported\" what? This error message seems worse then before.", "url": "https://github.com/geotools/geotools/pull/2930#discussion_r428962883", "createdAt": "2020-05-21T23:11:19Z", "author": {"login": "tbarsballe"}, "path": "modules/extension/mbstyle/src/main/java/org/geotools/mbstyle/parse/MBObjectParser.java", "diffHunk": "@@ -1145,11 +1150,20 @@ public Expression string(JSONArray json, int index) {\n             MBFunction function = new MBFunction(this, (JSONObject) obj);\n             return function.function(String.class);\n         } else if (obj instanceof JSONArray) {\n-            if (((JSONArray) obj).get(0) instanceof String\n-                    && MBExpression.canCreate(((JSONArray) obj).get(0).toString())) {\n-                return MBExpression.transformExpression((JSONArray) obj);\n+            JSONArray array = (JSONArray) obj;\n+            if (isString(array, 0)) {\n+                String expressionName = get(array, 0);\n+                if (MBExpression.canCreate(expressionName)) {\n+                    return MBExpression.transformExpression(array);\n+                } else {\n+                    throw new MBFormatException(\n+                            context\n+                                    + \" string unavailable: expression' \"\n+                                    + expressionName\n+                                    + \"' not supported.\");\n+                }\n             } else {\n-                throw new MBFormatException(context + \" string from JSONArray not supported\");\n+                throw new MBFormatException(context + \" string from JSONArray not a supported\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ae26dd5d30806fbfa83bb76f36daa01adc6c60c7"}, "originalPosition": 46}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODk2Mzc4OA==", "bodyText": "This doesn't add anything - why do both this method and isDefined(JSONObject json, String propertyName) exist (I see you've overloaded isDefined below, but why didn't you just overload this method instead)?", "url": "https://github.com/geotools/geotools/pull/2930#discussion_r428963788", "createdAt": "2020-05-21T23:14:33Z", "author": {"login": "tbarsballe"}, "path": "modules/extension/mbstyle/src/main/java/org/geotools/mbstyle/parse/MBObjectParser.java", "diffHunk": "@@ -1426,9 +1440,74 @@ public Displacement displacement(JSONObject json, String tag, Displacement fallb\n         }\n     }\n \n-    /** @return True if the layer has the provided property explicitly provided, False otherwise. */\n+    //\n+    // structure checks\n+    //\n+    /** @return True if json has the provided property explicitly provided, False otherwise. */\n     public boolean isPropertyDefined(JSONObject json, String propertyName)\n             throws MBFormatException {\n+        return isDefined(json, propertyName);\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ae26dd5d30806fbfa83bb76f36daa01adc6c60c7"}, "originalPosition": 62}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODk2NDg0NQ==", "bodyText": "All the int index versions of the is___ methods would benefit from a modified javadoc - arrays don't have properties, they have indices. Something like\n/** @return True if array has a value at the provided index, False otherwise. */\n\nWould make more sense", "url": "https://github.com/geotools/geotools/pull/2930#discussion_r428964845", "createdAt": "2020-05-21T23:18:27Z", "author": {"login": "tbarsballe"}, "path": "modules/extension/mbstyle/src/main/java/org/geotools/mbstyle/parse/MBObjectParser.java", "diffHunk": "@@ -1426,9 +1440,74 @@ public Displacement displacement(JSONObject json, String tag, Displacement fallb\n         }\n     }\n \n-    /** @return True if the layer has the provided property explicitly provided, False otherwise. */\n+    //\n+    // structure checks\n+    //\n+    /** @return True if json has the provided property explicitly provided, False otherwise. */\n     public boolean isPropertyDefined(JSONObject json, String propertyName)\n             throws MBFormatException {\n+        return isDefined(json, propertyName);\n+    }\n+    /** @return True if json has the property explicitly provided, False otherwise. */\n+    public boolean isDefined(JSONObject json, String propertyName) throws MBFormatException {\n         return json.containsKey(propertyName) && json.get(propertyName) != null;\n     }\n+    /** @return True if array has the property explicitly provided, False otherwise. */\n+    public boolean isDefined(JSONArray json, int index) throws MBFormatException {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ae26dd5d30806fbfa83bb76f36daa01adc6c60c7"}, "originalPosition": 68}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODk2NzYwNw==", "bodyText": "This change isn't much of an improvement, as either could be true.\nGiven that GT doesn't necessarily support the full set of expressions, this distinction is relevant, because the invalid and not supported have different fixes - and invalid expression is user error (most likely a misspelling), and should be simple to fix, whereas an expression that is not supported means they need to upgrade (or wait for) a version of geotools that supports the expression.\nUnfortunately I don't think there's much we can do about this - even if we maintained a list of expressions that GT didn't yet support, it would inevitably become outdated. Perhaps a more descriptive error message? Something like:\nExpression \\\"\" + name + \"\\\" invalid. It may be misspelled or not supported by this implementation\"", "url": "https://github.com/geotools/geotools/pull/2930#discussion_r428967607", "createdAt": "2020-05-21T23:28:42Z", "author": {"login": "tbarsballe"}, "path": "modules/extension/mbstyle/src/main/java/org/geotools/mbstyle/expression/MBExpression.java", "diffHunk": "@@ -151,24 +162,25 @@ public static MBExpression create(JSONArray json) {\n             } else if (zoom.contains(name)) {\n                 return new MBZoom(json);\n             } else {\n-                throw new MBFormatException(\"Expression \\\"\" + name + \"\\\" invalid.\");\n+                throw new MBFormatException(\"Expression \\\"\" + name + \"\\\" not supported.\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ae26dd5d30806fbfa83bb76f36daa01adc6c60c7"}, "originalPosition": 32}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "ae26dd5d30806fbfa83bb76f36daa01adc6c60c7", "author": {"user": {"login": "jodygarnett", "name": "Jody Garnett"}}, "url": "https://github.com/geotools/geotools/commit/ae26dd5d30806fbfa83bb76f36daa01adc6c60c7", "committedDate": "2020-05-18T22:27:16Z", "message": "Address feedback\n\nSigned-off-by: Jody Garnett <jody.garnett@gmail.com>"}, "afterCommit": {"oid": "cc24b65bb30889788a85e384a95019cd88ddb9fa", "author": {"user": {"login": "jodygarnett", "name": "Jody Garnett"}}, "url": "https://github.com/geotools/geotools/commit/cc24b65bb30889788a85e384a95019cd88ddb9fa", "committedDate": "2020-05-30T00:36:06Z", "message": "Address feedback\n\nSigned-off-by: Jody Garnett <jody.garnett@gmail.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIxOTgxODIw", "url": "https://github.com/geotools/geotools/pull/2930#pullrequestreview-421981820", "createdAt": "2020-06-01T16:10:59Z", "commit": {"oid": "28adb9374b48562bedaea7a2081c4b242e9f7634"}, "state": "APPROVED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMVQxNjoxMDo1OVrOGdQ3eQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMVQxNjoxNjoxNVrOGdRCAg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzMzODIzMw==", "bodyText": "\"data expessions are\"", "url": "https://github.com/geotools/geotools/pull/2930#discussion_r433338233", "createdAt": "2020-06-01T16:10:59Z", "author": {"login": "tbarsballe"}, "path": "modules/extension/mbstyle/src/main/java/org/geotools/mbstyle/parse/MBFunction.java", "diffHunk": "@@ -37,8 +37,8 @@\n /**\n  * MBFunction json wrapper, allowing conversion of function to a GeoTools Expression.\n  *\n- * <p>As of MapBox Style Specification v0.41.0, property expressions are the preferred approach for\n- * dynamically styling features.\n+ * <p>As of v0.41.0, data expressions is the preferred method for styling features based on zoom", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "28adb9374b48562bedaea7a2081c4b242e9f7634"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzM0MDkzMA==", "bodyText": "Pretty sure splitting the closing brace from the else violates the style guide (although Travis CI seems happy with it, so I guess not?). Not really important either way.", "url": "https://github.com/geotools/geotools/pull/2930#discussion_r433340930", "createdAt": "2020-06-01T16:16:15Z", "author": {"login": "tbarsballe"}, "path": "modules/extension/mbstyle/src/main/java/org/geotools/mbstyle/expression/MBLookup.java", "diffHunk": "@@ -56,22 +56,26 @@ public Expression lookupAt() {\n     public Expression lookupGet() {\n         if (json.size() == 2 || json.size() == 3) {\n             if (json.size() == 2) {\n+                // Example: [\"get\", \"propertyName\"]\n                 if (parse.isString(json, 1)) {\n                     String propertyName = parse.get(json, 1);\n                     return ff.property(propertyName);\n-                } else {\n+                }\n+                // Example: [\"get\", key]\n+                else {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "28adb9374b48562bedaea7a2081c4b242e9f7634"}, "originalPosition": 11}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "66db64fdc5aeefcadfc4d7ecbacb9dc0b4f81576", "author": {"user": {"login": "jodygarnett", "name": "Jody Garnett"}}, "url": "https://github.com/geotools/geotools/commit/66db64fdc5aeefcadfc4d7ecbacb9dc0b4f81576", "committedDate": "2020-07-14T21:05:36Z", "message": "Additional MBObjectParser methods to check json object and array structure\n\nThis prevents code breaking out their own instance of checks\n\nSigned-off-by: Jody Garnett <jody.garnett@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ac35e8868fddcc200b7048497f96dbc77a77c8d8", "author": {"user": {"login": "jodygarnett", "name": "Jody Garnett"}}, "url": "https://github.com/geotools/geotools/commit/ac35e8868fddcc200b7048497f96dbc77a77c8d8", "committedDate": "2020-07-14T21:05:36Z", "message": "MBExpression transformExpression incorrectly used to generate string\n\nSigned-off-by: Jody Garnett <jody.garnett@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d864e0dc46a6666048eab4f5946a09354d8b6782", "author": {"user": {"login": "jodygarnett", "name": "Jody Garnett"}}, "url": "https://github.com/geotools/geotools/commit/d864e0dc46a6666048eab4f5946a09354d8b6782", "committedDate": "2020-07-14T21:05:36Z", "message": "Document Function stop approach as deprecated\n\nSigned-off-by: Jody Garnett <jody.garnett@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7d099b39f9f27458c8f91a078fd48a0713fece9e", "author": {"user": {"login": "jodygarnett", "name": "Jody Garnett"}}, "url": "https://github.com/geotools/geotools/commit/7d099b39f9f27458c8f91a078fd48a0713fece9e", "committedDate": "2020-07-14T21:05:36Z", "message": "Experiment to show how MBFilter can support use of expressions\n\nThe deprecated syntax is preserved, and documented, for backwards compatibility.\n\nSigned-off-by: Jody Garnett <jody.garnett@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9c0267a95ab980448a7a7c672039e87acc9b2a6e", "author": {"user": {"login": "jodygarnett", "name": "Jody Garnett"}}, "url": "https://github.com/geotools/geotools/commit/9c0267a95ab980448a7a7c672039e87acc9b2a6e", "committedDate": "2020-07-14T21:05:36Z", "message": "Cleanup to confirm existing tests still pass\n\nSigned-off-by: Jody Garnett <jody.garnett@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "501e9bd48f3e72d6f930bbd7774e32e7f928cb92", "author": {"user": {"login": "jodygarnett", "name": "Jody Garnett"}}, "url": "https://github.com/geotools/geotools/commit/501e9bd48f3e72d6f930bbd7774e32e7f928cb92", "committedDate": "2020-07-14T21:05:37Z", "message": "document support for filter expressions\n\nSigned-off-by: Jody Garnett <jody.garnett@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4746e7cf2aa0d257b4c45491a4eab4e3ce76afe1", "author": {"user": {"login": "jodygarnett", "name": "Jody Garnett"}}, "url": "https://github.com/geotools/geotools/commit/4746e7cf2aa0d257b4c45491a4eab4e3ce76afe1", "committedDate": "2020-07-14T21:05:37Z", "message": "Generate PropertyName when literal key supplied\n\nSigned-off-by: Jody Garnett <jody.garnett@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ac0f153faa99add803424747b4fddc142d80f352", "author": {"user": {"login": "jodygarnett", "name": "Jody Garnett"}}, "url": "https://github.com/geotools/geotools/commit/ac0f153faa99add803424747b4fddc142d80f352", "committedDate": "2020-07-14T21:05:37Z", "message": "confirm filter expressions work\n\nSigned-off-by: Jody Garnett <jody.garnett@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5fc3ba1398bb2bd0847b1b4e1c68f277ff41fb1f", "author": {"user": {"login": "jodygarnett", "name": "Jody Garnett"}}, "url": "https://github.com/geotools/geotools/commit/5fc3ba1398bb2bd0847b1b4e1c68f277ff41fb1f", "committedDate": "2020-07-14T21:05:37Z", "message": "improve notification if expression not supported\n\nSigned-off-by: Jody Garnett <jody.garnett@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "062ff1103b0d4dbd73b32d73dcdcfb7e78136dca", "author": {"user": {"login": "jodygarnett", "name": "Jody Garnett"}}, "url": "https://github.com/geotools/geotools/commit/062ff1103b0d4dbd73b32d73dcdcfb7e78136dca", "committedDate": "2020-07-14T21:05:37Z", "message": "Test case now reporting the correct PropertyName reference\n\nSigned-off-by: Jody Garnett <jody.garnett@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "79eddf2949582978e69068c6f33f6c9efa810be8", "author": {"user": {"login": "jodygarnett", "name": "Jody Garnett"}}, "url": "https://github.com/geotools/geotools/commit/79eddf2949582978e69068c6f33f6c9efa810be8", "committedDate": "2020-07-14T21:05:37Z", "message": "refactor into private methods\n\nSigned-off-by: Jody Garnett <jody.garnett@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8a607884335b7f6399329e0c15378cd2be12b0a2", "author": {"user": {"login": "jodygarnett", "name": "Jody Garnett"}}, "url": "https://github.com/geotools/geotools/commit/8a607884335b7f6399329e0c15378cd2be12b0a2", "committedDate": "2020-07-14T21:05:37Z", "message": "A better null pointer exception message when generating ECQL\n\nSigned-off-by: Jody Garnett <jody.garnett@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0981769fa07e445f31599be43e6ddf4ee11dfb7e", "author": {"user": {"login": "jodygarnett", "name": "Jody Garnett"}}, "url": "https://github.com/geotools/geotools/commit/0981769fa07e445f31599be43e6ddf4ee11dfb7e", "committedDate": "2020-07-14T21:05:37Z", "message": "Test that delegating to MBExpression is working as expected\n\nSigned-off-by: Jody Garnett <jody.garnett@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5c55d4834bf99900d7b35fb7bea1755aec1558d9", "author": {"user": {"login": "jodygarnett", "name": "Jody Garnett"}}, "url": "https://github.com/geotools/geotools/commit/5c55d4834bf99900d7b35fb7bea1755aec1558d9", "committedDate": "2020-07-14T21:05:37Z", "message": "Avoid deprecation warnings\n\nSigned-off-by: Jody Garnett <jody.garnett@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2dd047cec1eb8c3b8d157f04751bc8c488287242", "author": {"user": {"login": "jodygarnett", "name": "Jody Garnett"}}, "url": "https://github.com/geotools/geotools/commit/2dd047cec1eb8c3b8d157f04751bc8c488287242", "committedDate": "2020-07-14T21:05:37Z", "message": "Address feedback\n\nSigned-off-by: Jody Garnett <jody.garnett@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0e8e489ce9fe2e94161e9a4bfcc92f21d4d41134", "author": {"user": {"login": "jodygarnett", "name": "Jody Garnett"}}, "url": "https://github.com/geotools/geotools/commit/0e8e489ce9fe2e94161e9a4bfcc92f21d4d41134", "committedDate": "2020-07-14T21:05:37Z", "message": "Revise based on feedback\n\nSigned-off-by: Jody Garnett <jody.garnett@gmail.com>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "28adb9374b48562bedaea7a2081c4b242e9f7634", "author": {"user": {"login": "jodygarnett", "name": "Jody Garnett"}}, "url": "https://github.com/geotools/geotools/commit/28adb9374b48562bedaea7a2081c4b242e9f7634", "committedDate": "2020-05-30T03:42:17Z", "message": "Revise based on feedback\n\nSigned-off-by: Jody Garnett <jody.garnett@gmail.com>"}, "afterCommit": {"oid": "0e8e489ce9fe2e94161e9a4bfcc92f21d4d41134", "author": {"user": {"login": "jodygarnett", "name": "Jody Garnett"}}, "url": "https://github.com/geotools/geotools/commit/0e8e489ce9fe2e94161e9a4bfcc92f21d4d41134", "committedDate": "2020-07-14T21:05:37Z", "message": "Revise based on feedback\n\nSigned-off-by: Jody Garnett <jody.garnett@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7ed7c7dfc752912f81897402378fd201d09e03c7", "author": {"user": {"login": "jodygarnett", "name": "Jody Garnett"}}, "url": "https://github.com/geotools/geotools/commit/7ed7c7dfc752912f81897402378fd201d09e03c7", "committedDate": "2020-07-15T05:57:07Z", "message": "update based on feedback\n\nSigned-off-by: Jody Garnett <jody.garnett@gmail.com>"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2858, "cost": 1, "resetAt": "2021-11-01T14:20:25Z"}}}