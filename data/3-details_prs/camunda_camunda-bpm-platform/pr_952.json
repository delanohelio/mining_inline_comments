{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDc3NzAwNzkz", "number": 952, "title": "[CAM-12382] chore(optimize): add new historic incident endpoint", "bodyText": "related to #CAM-12382", "createdAt": "2020-09-02T09:44:54Z", "url": "https://github.com/camunda/camunda-bpm-platform/pull/952", "merged": true, "mergeCommit": {"oid": "9eb286145c7af43deca03813b17ff912a6f53ef1"}, "closed": true, "closedAt": "2020-09-09T14:49:58Z", "author": {"login": "JoHeinem"}, "timelineItems": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdE4yhcAH2gAyNDc3NzAwNzkzOmU2MjZjZTkzYjEzMDdhYWQyYjE4ODIxYjRmOWU5NGZhNTExNDQ4Y2Y=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdHNYIrAFqTQ4NTA5MTM3Mg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "e626ce93b1307aad2b18821b4f9e94fa511448cf", "author": {"user": null}, "url": "https://github.com/camunda/camunda-bpm-platform/commit/e626ce93b1307aad2b18821b4f9e94fa511448cf", "committedDate": "2020-09-02T09:42:48Z", "message": "chore(optimize): add new historic incident endpoint\n\nrelated to #CAM-12382"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDgzNjM0ODQ2", "url": "https://github.com/camunda/camunda-bpm-platform/pull/952#pullrequestreview-483634846", "createdAt": "2020-09-07T15:33:21Z", "commit": {"oid": "e626ce93b1307aad2b18821b4f9e94fa511448cf"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 10, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wN1QxNTozMzoyMlrOHODPjg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wN1QxNjowMTowN1rOHOD5cA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDQ5NTI0Ng==", "bodyText": "You can consider asserting all of the result properties to ensure that they are all mapped to JSON.", "url": "https://github.com/camunda/camunda-bpm-platform/pull/952#discussion_r484495246", "createdAt": "2020-09-07T15:33:22Z", "author": {"login": "ThorbenLindhauer"}, "path": "engine-rest/engine-rest/src/test/java/org/camunda/bpm/engine/rest/optimize/OptimizeCompletedHistoricIncidentRestServiceTest.java", "diffHunk": "@@ -0,0 +1,166 @@\n+/*\n+ * Copyright Camunda Services GmbH and/or licensed to Camunda Services GmbH\n+ * under one or more contributor license agreements. See the NOTICE file\n+ * distributed with this work for additional information regarding copyright\n+ * ownership. Camunda licenses this file to you under the Apache License,\n+ * Version 2.0; you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.camunda.bpm.engine.rest.optimize;\n+\n+import io.restassured.response.Response;\n+import org.camunda.bpm.engine.ProcessEngine;\n+import org.camunda.bpm.engine.impl.OptimizeService;\n+import org.camunda.bpm.engine.impl.cfg.ProcessEngineConfigurationImpl;\n+import org.camunda.bpm.engine.impl.persistence.entity.HistoricIncidentEntity;\n+import org.camunda.bpm.engine.rest.AbstractRestServiceTest;\n+import org.camunda.bpm.engine.rest.helper.MockProvider;\n+import org.camunda.bpm.engine.rest.util.container.TestContainerRule;\n+import org.junit.Before;\n+import org.junit.ClassRule;\n+import org.junit.Test;\n+\n+import javax.ws.rs.core.MediaType;\n+import javax.ws.rs.core.Response.Status;\n+import java.util.Collections;\n+import java.util.Date;\n+\n+import static io.restassured.RestAssured.given;\n+import static io.restassured.path.json.JsonPath.from;\n+import static org.camunda.bpm.engine.rest.util.DateTimeUtils.DATE_FORMAT_WITH_TIMEZONE;\n+import static org.junit.Assert.assertEquals;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.verifyNoMoreInteractions;\n+import static org.mockito.Mockito.when;\n+\n+public class OptimizeCompletedHistoricIncidentRestServiceTest extends AbstractRestServiceTest {\n+\n+  public static final String OPTIMIZE_COMPLETED_HISTORIC_INCIDENT_PATH =\n+    TEST_RESOURCE_ROOT_PATH + \"/optimize/incident/completed\";\n+\n+  protected OptimizeService mockedOptimizeService;\n+  protected ProcessEngine namedProcessEngine;\n+\n+  @ClassRule\n+  public static TestContainerRule rule = new TestContainerRule();\n+\n+  @Before\n+  public void setUpRuntimeData() {\n+    mockedOptimizeService = mock(OptimizeService.class);\n+    ProcessEngineConfigurationImpl mockedConfig = mock(ProcessEngineConfigurationImpl.class);\n+\n+    namedProcessEngine = getProcessEngine(MockProvider.EXAMPLE_PROCESS_ENGINE_NAME);\n+    when(namedProcessEngine.getProcessEngineConfiguration()).thenReturn(mockedConfig);\n+    when(mockedConfig.getOptimizeService()).thenReturn(mockedOptimizeService);\n+  }\n+\n+  @Test\n+  public void testNoQueryParameters() {\n+    given()\n+    .then()\n+      .expect()\n+        .statusCode(Status.OK.getStatusCode())\n+        .contentType(MediaType.APPLICATION_JSON)\n+    .when()\n+      .get(OPTIMIZE_COMPLETED_HISTORIC_INCIDENT_PATH);\n+\n+    verify(mockedOptimizeService).getCompletedHistoricIncidents(null, null, Integer.MAX_VALUE);\n+    verifyNoMoreInteractions(mockedOptimizeService);\n+  }\n+\n+  @Test\n+  public void testFinishedAfterQueryParameter() {\n+    Date now = new Date();\n+    given()\n+      .queryParam(\"finishedAfter\", DATE_FORMAT_WITH_TIMEZONE.format(now))\n+    .then()\n+      .expect()\n+        .statusCode(Status.OK.getStatusCode())\n+        .contentType(MediaType.APPLICATION_JSON)\n+    .when()\n+      .get(OPTIMIZE_COMPLETED_HISTORIC_INCIDENT_PATH);\n+\n+    verify(mockedOptimizeService).getCompletedHistoricIncidents(now, null, Integer.MAX_VALUE);\n+    verifyNoMoreInteractions(mockedOptimizeService);\n+  }\n+\n+  @Test\n+  public void testFinishedAtQueryParameter() {\n+    Date now = new Date();\n+    given()\n+      .queryParam(\"finishedAt\", DATE_FORMAT_WITH_TIMEZONE.format(now))\n+    .then()\n+      .expect()\n+        .statusCode(Status.OK.getStatusCode())\n+        .contentType(MediaType.APPLICATION_JSON)\n+    .when()\n+      .get(OPTIMIZE_COMPLETED_HISTORIC_INCIDENT_PATH);\n+\n+    verify(mockedOptimizeService).getCompletedHistoricIncidents(null, now, Integer.MAX_VALUE);\n+    verifyNoMoreInteractions(mockedOptimizeService);\n+  }\n+\n+  @Test\n+  public void testMaxResultsQueryParameter() {\n+    given()\n+      .queryParam(\"maxResults\", 10)\n+    .then()\n+      .expect()\n+        .statusCode(Status.OK.getStatusCode())\n+        .contentType(MediaType.APPLICATION_JSON)\n+    .when()\n+      .get(OPTIMIZE_COMPLETED_HISTORIC_INCIDENT_PATH);\n+\n+    verify(mockedOptimizeService).getCompletedHistoricIncidents(null, null, 10);\n+    verifyNoMoreInteractions(mockedOptimizeService);\n+  }\n+\n+  @Test\n+  public void testQueryParameterCombination() {\n+    Date now = new Date();\n+    given()\n+      .queryParam(\"finishedAfter\", DATE_FORMAT_WITH_TIMEZONE.format(now))\n+      .queryParam(\"finishedAt\", DATE_FORMAT_WITH_TIMEZONE.format(now))\n+      .queryParam(\"maxResults\", 10)\n+    .then()\n+      .expect()\n+        .statusCode(Status.OK.getStatusCode())\n+        .contentType(MediaType.APPLICATION_JSON)\n+    .when()\n+      .get(OPTIMIZE_COMPLETED_HISTORIC_INCIDENT_PATH);\n+\n+    verify(mockedOptimizeService).getCompletedHistoricIncidents(now, now, 10);\n+    verifyNoMoreInteractions(mockedOptimizeService);\n+  }\n+\n+  @Test\n+  public void testPresenceOfProcessInstanceIdProperty() {\n+    final HistoricIncidentEntity mock = mock(HistoricIncidentEntity.class);\n+    when(mock.getProcessInstanceId()).thenReturn(MockProvider.EXAMPLE_PROCESS_INSTANCE_ID);\n+    when(mockedOptimizeService.getCompletedHistoricIncidents(null, null, Integer.MAX_VALUE))\n+      .thenReturn(Collections.singletonList(mock));\n+\n+    final Response response = given()\n+      .then()\n+        .expect()\n+          .statusCode(Status.OK.getStatusCode())\n+          .contentType(MediaType.APPLICATION_JSON)\n+      .when()\n+        .get(OPTIMIZE_COMPLETED_HISTORIC_INCIDENT_PATH);\n+\n+    String content = response.asString();\n+    String processInstanceId = from(content).getString(\"[0].processInstanceId\");\n+\n+    assertEquals(MockProvider.EXAMPLE_PROCESS_INSTANCE_ID, processInstanceId);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e626ce93b1307aad2b18821b4f9e94fa511448cf"}, "originalPosition": 163}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDQ5NTQzNw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              public static final String OPTIMIZE_COMPLETED_HISTORIC_INCIDENT_PATH =\n          \n          \n            \n              public static final String OPTIMIZE_OPEN_HISTORIC_INCIDENT_PATH =\n          \n      \n    \n    \n  \n\nand also rename the usages.", "url": "https://github.com/camunda/camunda-bpm-platform/pull/952#discussion_r484495437", "createdAt": "2020-09-07T15:33:53Z", "author": {"login": "ThorbenLindhauer"}, "path": "engine-rest/engine-rest/src/test/java/org/camunda/bpm/engine/rest/optimize/OptimizeOpenHistoricIncidentRestServiceTest.java", "diffHunk": "@@ -0,0 +1,166 @@\n+/*\n+ * Copyright Camunda Services GmbH and/or licensed to Camunda Services GmbH\n+ * under one or more contributor license agreements. See the NOTICE file\n+ * distributed with this work for additional information regarding copyright\n+ * ownership. Camunda licenses this file to you under the Apache License,\n+ * Version 2.0; you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.camunda.bpm.engine.rest.optimize;\n+\n+import io.restassured.response.Response;\n+import org.camunda.bpm.engine.ProcessEngine;\n+import org.camunda.bpm.engine.impl.OptimizeService;\n+import org.camunda.bpm.engine.impl.cfg.ProcessEngineConfigurationImpl;\n+import org.camunda.bpm.engine.impl.persistence.entity.HistoricIncidentEntity;\n+import org.camunda.bpm.engine.rest.AbstractRestServiceTest;\n+import org.camunda.bpm.engine.rest.helper.MockProvider;\n+import org.camunda.bpm.engine.rest.util.container.TestContainerRule;\n+import org.junit.Before;\n+import org.junit.ClassRule;\n+import org.junit.Test;\n+\n+import javax.ws.rs.core.MediaType;\n+import javax.ws.rs.core.Response.Status;\n+import java.util.Collections;\n+import java.util.Date;\n+\n+import static io.restassured.RestAssured.given;\n+import static io.restassured.path.json.JsonPath.from;\n+import static org.camunda.bpm.engine.rest.util.DateTimeUtils.DATE_FORMAT_WITH_TIMEZONE;\n+import static org.junit.Assert.assertEquals;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.verifyNoMoreInteractions;\n+import static org.mockito.Mockito.when;\n+\n+public class OptimizeOpenHistoricIncidentRestServiceTest extends AbstractRestServiceTest {\n+\n+  public static final String OPTIMIZE_COMPLETED_HISTORIC_INCIDENT_PATH =", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e626ce93b1307aad2b18821b4f9e94fa511448cf"}, "originalPosition": 47}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDQ5NTY2Ng==", "bodyText": "Same here, it could make sense to assert all properties.", "url": "https://github.com/camunda/camunda-bpm-platform/pull/952#discussion_r484495666", "createdAt": "2020-09-07T15:34:27Z", "author": {"login": "ThorbenLindhauer"}, "path": "engine-rest/engine-rest/src/test/java/org/camunda/bpm/engine/rest/optimize/OptimizeOpenHistoricIncidentRestServiceTest.java", "diffHunk": "@@ -0,0 +1,166 @@\n+/*\n+ * Copyright Camunda Services GmbH and/or licensed to Camunda Services GmbH\n+ * under one or more contributor license agreements. See the NOTICE file\n+ * distributed with this work for additional information regarding copyright\n+ * ownership. Camunda licenses this file to you under the Apache License,\n+ * Version 2.0; you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.camunda.bpm.engine.rest.optimize;\n+\n+import io.restassured.response.Response;\n+import org.camunda.bpm.engine.ProcessEngine;\n+import org.camunda.bpm.engine.impl.OptimizeService;\n+import org.camunda.bpm.engine.impl.cfg.ProcessEngineConfigurationImpl;\n+import org.camunda.bpm.engine.impl.persistence.entity.HistoricIncidentEntity;\n+import org.camunda.bpm.engine.rest.AbstractRestServiceTest;\n+import org.camunda.bpm.engine.rest.helper.MockProvider;\n+import org.camunda.bpm.engine.rest.util.container.TestContainerRule;\n+import org.junit.Before;\n+import org.junit.ClassRule;\n+import org.junit.Test;\n+\n+import javax.ws.rs.core.MediaType;\n+import javax.ws.rs.core.Response.Status;\n+import java.util.Collections;\n+import java.util.Date;\n+\n+import static io.restassured.RestAssured.given;\n+import static io.restassured.path.json.JsonPath.from;\n+import static org.camunda.bpm.engine.rest.util.DateTimeUtils.DATE_FORMAT_WITH_TIMEZONE;\n+import static org.junit.Assert.assertEquals;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.verifyNoMoreInteractions;\n+import static org.mockito.Mockito.when;\n+\n+public class OptimizeOpenHistoricIncidentRestServiceTest extends AbstractRestServiceTest {\n+\n+  public static final String OPTIMIZE_COMPLETED_HISTORIC_INCIDENT_PATH =\n+    TEST_RESOURCE_ROOT_PATH + \"/optimize/incident/open\";\n+\n+  protected OptimizeService mockedOptimizeService;\n+  protected ProcessEngine namedProcessEngine;\n+\n+  @ClassRule\n+  public static TestContainerRule rule = new TestContainerRule();\n+\n+  @Before\n+  public void setUpRuntimeData() {\n+    mockedOptimizeService = mock(OptimizeService.class);\n+    ProcessEngineConfigurationImpl mockedConfig = mock(ProcessEngineConfigurationImpl.class);\n+\n+    namedProcessEngine = getProcessEngine(MockProvider.EXAMPLE_PROCESS_ENGINE_NAME);\n+    when(namedProcessEngine.getProcessEngineConfiguration()).thenReturn(mockedConfig);\n+    when(mockedConfig.getOptimizeService()).thenReturn(mockedOptimizeService);\n+  }\n+\n+  @Test\n+  public void testNoQueryParameters() {\n+    given()\n+    .then()\n+      .expect()\n+        .statusCode(Status.OK.getStatusCode())\n+        .contentType(MediaType.APPLICATION_JSON)\n+    .when()\n+      .get(OPTIMIZE_COMPLETED_HISTORIC_INCIDENT_PATH);\n+\n+    verify(mockedOptimizeService).getOpenHistoricIncidents(null, null, Integer.MAX_VALUE);\n+    verifyNoMoreInteractions(mockedOptimizeService);\n+  }\n+\n+  @Test\n+  public void testCreatedAfterQueryParameter() {\n+    Date now = new Date();\n+    given()\n+      .queryParam(\"createdAfter\", DATE_FORMAT_WITH_TIMEZONE.format(now))\n+    .then()\n+      .expect()\n+        .statusCode(Status.OK.getStatusCode())\n+        .contentType(MediaType.APPLICATION_JSON)\n+    .when()\n+      .get(OPTIMIZE_COMPLETED_HISTORIC_INCIDENT_PATH);\n+\n+    verify(mockedOptimizeService).getOpenHistoricIncidents(now, null, Integer.MAX_VALUE);\n+    verifyNoMoreInteractions(mockedOptimizeService);\n+  }\n+\n+  @Test\n+  public void testCreatedAtQueryParameter() {\n+    Date now = new Date();\n+    given()\n+      .queryParam(\"createdAt\", DATE_FORMAT_WITH_TIMEZONE.format(now))\n+    .then()\n+      .expect()\n+        .statusCode(Status.OK.getStatusCode())\n+        .contentType(MediaType.APPLICATION_JSON)\n+    .when()\n+      .get(OPTIMIZE_COMPLETED_HISTORIC_INCIDENT_PATH);\n+\n+    verify(mockedOptimizeService).getOpenHistoricIncidents(null, now, Integer.MAX_VALUE);\n+    verifyNoMoreInteractions(mockedOptimizeService);\n+  }\n+\n+  @Test\n+  public void testMaxResultsQueryParameter() {\n+    given()\n+      .queryParam(\"maxResults\", 10)\n+    .then()\n+      .expect()\n+        .statusCode(Status.OK.getStatusCode())\n+        .contentType(MediaType.APPLICATION_JSON)\n+    .when()\n+      .get(OPTIMIZE_COMPLETED_HISTORIC_INCIDENT_PATH);\n+\n+    verify(mockedOptimizeService).getOpenHistoricIncidents(null, null, 10);\n+    verifyNoMoreInteractions(mockedOptimizeService);\n+  }\n+\n+  @Test\n+  public void testQueryParameterCombination() {\n+    Date now = new Date();\n+    given()\n+      .queryParam(\"createdAfter\", DATE_FORMAT_WITH_TIMEZONE.format(now))\n+      .queryParam(\"createdAt\", DATE_FORMAT_WITH_TIMEZONE.format(now))\n+      .queryParam(\"maxResults\", 10)\n+    .then()\n+      .expect()\n+        .statusCode(Status.OK.getStatusCode())\n+        .contentType(MediaType.APPLICATION_JSON)\n+    .when()\n+      .get(OPTIMIZE_COMPLETED_HISTORIC_INCIDENT_PATH);\n+\n+    verify(mockedOptimizeService).getOpenHistoricIncidents(now, now, 10);\n+    verifyNoMoreInteractions(mockedOptimizeService);\n+  }\n+\n+  @Test\n+  public void testPresenceOfProcessInstanceIdProperty() {\n+    final HistoricIncidentEntity mock = mock(HistoricIncidentEntity.class);\n+    when(mock.getProcessInstanceId()).thenReturn(MockProvider.EXAMPLE_PROCESS_INSTANCE_ID);\n+    when(mockedOptimizeService.getOpenHistoricIncidents(null, null, Integer.MAX_VALUE))\n+      .thenReturn(Collections.singletonList(mock));\n+\n+    final Response response = given()\n+      .then()\n+        .expect()\n+          .statusCode(Status.OK.getStatusCode())\n+          .contentType(MediaType.APPLICATION_JSON)\n+      .when()\n+        .get(OPTIMIZE_COMPLETED_HISTORIC_INCIDENT_PATH);\n+\n+    String content = response.asString();\n+    String processInstanceId = from(content).getString(\"[0].processInstanceId\");\n+\n+    assertEquals(MockProvider.EXAMPLE_PROCESS_INSTANCE_ID, processInstanceId);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e626ce93b1307aad2b18821b4f9e94fa511448cf"}, "originalPosition": 163}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDUwMDAyOA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                testRule.executeAvailableJobs();\n          \n          \n            \n                runtimeService.setVariable(failingProcessInstance.getId(), \"fail\", false);\n          \n          \n            \n                String jobId = managementService.createJobQuery().singleResult().getId();\n          \n          \n            \n                managementService.setJobRetries(jobId, 1);\n          \n          \n            \n                // create open incident\n          \n          \n            \n                runtimeService.startProcessInstanceByKey(FAILING_PROCESS);\n          \n          \n            \n                testRule.executeAvailableJobs();\n          \n          \n            \n                String jobId = managementService.createJobQuery().singleResult().getId();\n          \n          \n            \n                managementService.setJobRetries(jobId, 0); // creates incident\n          \n          \n            \n                managementService.setJobRetries(jobId, 1); // resolves incident\n          \n          \n            \n                managementService.setJobRetries(jobId, 0); // creates second incident\n          \n      \n    \n    \n  \n\nThis is a bit more straightforward for creating the incidents.", "url": "https://github.com/camunda/camunda-bpm-platform/pull/952#discussion_r484500028", "createdAt": "2020-09-07T15:45:22Z", "author": {"login": "ThorbenLindhauer"}, "path": "engine/src/test/java/org/camunda/bpm/engine/test/api/authorization/optimize/OptimizeServiceAuthorizationTest.java", "diffHunk": "@@ -357,6 +327,16 @@ private void generateTestData() {\n     decisionService.evaluateDecisionById(decision.getId())\n       .variables(Variables.createVariables().putValue(\"input1\", \"a\")).evaluate();\n \n+    // create completed incident data\n+    final ProcessInstance failingProcessInstance = runtimeService.startProcessInstanceByKey(FAILING_PROCESS);\n+    testRule.executeAvailableJobs();\n+    runtimeService.setVariable(failingProcessInstance.getId(), \"fail\", false);\n+    String jobId = managementService.createJobQuery().singleResult().getId();\n+    managementService.setJobRetries(jobId, 1);\n+    // create open incident\n+    runtimeService.startProcessInstanceByKey(FAILING_PROCESS);\n+    testRule.executeAvailableJobs();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e626ce93b1307aad2b18821b4f9e94fa511448cf"}, "originalPosition": 156}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDUwMDcyNA==", "bodyText": "Same here, we can just set the job retries to 0 which is a little more efficient than executing the retries.", "url": "https://github.com/camunda/camunda-bpm-platform/pull/952#discussion_r484500724", "createdAt": "2020-09-07T15:47:10Z", "author": {"login": "ThorbenLindhauer"}, "path": "engine/src/test/java/org/camunda/bpm/engine/test/api/optimize/GetCompletedHistoricIncidentsForOptimizeTest.java", "diffHunk": "@@ -0,0 +1,278 @@\n+/*\n+ * Copyright Camunda Services GmbH and/or licensed to Camunda Services GmbH\n+ * under one or more contributor license agreements. See the NOTICE file\n+ * distributed with this work for additional information regarding copyright\n+ * ownership. Camunda licenses this file to you under the Apache License,\n+ * Version 2.0; you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.camunda.bpm.engine.test.api.optimize;\n+\n+import org.camunda.bpm.engine.AuthorizationService;\n+import org.camunda.bpm.engine.IdentityService;\n+import org.camunda.bpm.engine.ManagementService;\n+import org.camunda.bpm.engine.ProcessEngineConfiguration;\n+import org.camunda.bpm.engine.RuntimeService;\n+import org.camunda.bpm.engine.authorization.Authorization;\n+import org.camunda.bpm.engine.identity.Group;\n+import org.camunda.bpm.engine.identity.User;\n+import org.camunda.bpm.engine.impl.OptimizeService;\n+import org.camunda.bpm.engine.impl.cfg.ProcessEngineConfigurationImpl;\n+import org.camunda.bpm.engine.impl.persistence.entity.HistoricIncidentEntity;\n+import org.camunda.bpm.engine.impl.util.ClockUtil;\n+import org.camunda.bpm.engine.runtime.ProcessInstance;\n+import org.camunda.bpm.engine.test.ProcessEngineRule;\n+import org.camunda.bpm.engine.test.RequiredHistoryLevel;\n+import org.camunda.bpm.engine.test.api.runtime.FailingDelegate;\n+import org.camunda.bpm.engine.test.util.ProcessEngineTestRule;\n+import org.camunda.bpm.engine.test.util.ProvidedProcessEngineRule;\n+import org.camunda.bpm.model.bpmn.Bpmn;\n+import org.camunda.bpm.model.bpmn.BpmnModelInstance;\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.RuleChain;\n+\n+import java.util.Date;\n+import java.util.List;\n+\n+import static org.hamcrest.CoreMatchers.is;\n+import static org.hamcrest.CoreMatchers.notNullValue;\n+import static org.hamcrest.CoreMatchers.nullValue;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+\n+\n+@RequiredHistoryLevel(ProcessEngineConfiguration.HISTORY_FULL)\n+public class GetCompletedHistoricIncidentsForOptimizeTest {\n+\n+  private static final String PROCESS_DEFINITION_KEY = \"oneFailingServiceTaskProcess\";\n+  private static final BpmnModelInstance FAILING_SERVICE_TASK_MODEL =\n+    Bpmn.createExecutableProcess(PROCESS_DEFINITION_KEY)\n+      .startEvent(\"start\")\n+      .serviceTask(\"task\")\n+        .camundaAsyncBefore()\n+        .camundaClass(FailingDelegate.class.getName())\n+      .endEvent(\"end\")\n+      .done();\n+\n+  public ProcessEngineRule engineRule = new ProvidedProcessEngineRule();\n+  protected ProcessEngineTestRule testHelper = new ProcessEngineTestRule(engineRule);\n+\n+  @Rule\n+  public RuleChain ruleChain = RuleChain.outerRule(engineRule).around(testHelper);\n+\n+  private OptimizeService optimizeService;\n+  private IdentityService identityService;\n+  private RuntimeService runtimeService;\n+  private AuthorizationService authorizationService;\n+  private ManagementService managementService;\n+\n+  @Before\n+  public void init() {\n+    ProcessEngineConfigurationImpl config =\n+      engineRule.getProcessEngineConfiguration();\n+    optimizeService = config.getOptimizeService();\n+    identityService = engineRule.getIdentityService();\n+    runtimeService = engineRule.getRuntimeService();\n+    authorizationService = engineRule.getAuthorizationService();\n+    managementService = engineRule.getManagementService();\n+  }\n+\n+  @After\n+  public void cleanUp() {\n+    for (User user : identityService.createUserQuery().list()) {\n+      identityService.deleteUser(user.getId());\n+    }\n+    for (Group group : identityService.createGroupQuery().list()) {\n+      identityService.deleteGroup(group.getId());\n+    }\n+    for (Authorization authorization : authorizationService.createAuthorizationQuery().list()) {\n+      authorizationService.deleteAuthorization(authorization.getId());\n+    }\n+    ClockUtil.reset();\n+  }\n+\n+  @Test\n+  public void getCompletedHistoricIncidents() {\n+     // given\n+    testHelper.deploy(FAILING_SERVICE_TASK_MODEL);\n+    final ProcessInstance processInstance = startProcessInstanceAndFailWithIncident();\n+    retryAndSucceed(processInstance);\n+\n+    // when\n+    List<HistoricIncidentEntity> completedIncidents =\n+      optimizeService.getCompletedHistoricIncidents(pastDate(), null, 10);\n+\n+    // then\n+    assertThat(completedIncidents.size(), is(1));\n+    assertThatInstanceHasAllImportantInformation(completedIncidents.get(0));\n+  }\n+\n+  @Test\n+  public void fishedAfterParameterWorks() {\n+     // given\n+    testHelper.deploy(FAILING_SERVICE_TASK_MODEL);\n+    Date now = new Date();\n+    ClockUtil.setCurrentTime(now);\n+    final ProcessInstance processInstance = startProcessInstanceAndFailWithIncident();\n+    retryAndSucceed(processInstance);\n+    Date nowPlus2Seconds = new Date(now.getTime() + 2000L);\n+    ClockUtil.setCurrentTime(nowPlus2Seconds);\n+    final ProcessInstance processInstance2 = startProcessInstanceAndFailWithIncident();\n+    retryAndSucceed(processInstance2);\n+\n+    // when\n+    List<HistoricIncidentEntity> completedIncidents =\n+      optimizeService.getCompletedHistoricIncidents(now, null, 10);\n+\n+    // then\n+    assertThat(completedIncidents.size(), is(1));\n+  }\n+\n+  @Test\n+  public void fishedAtParameterWorks() {\n+     // given\n+    testHelper.deploy(FAILING_SERVICE_TASK_MODEL);\n+    Date now = new Date();\n+    ClockUtil.setCurrentTime(now);\n+    final ProcessInstance processInstance = startProcessInstanceAndFailWithIncident();\n+    retryAndSucceed(processInstance);\n+    Date nowPlus2Seconds = new Date(now.getTime() + 2000L);\n+    ClockUtil.setCurrentTime(nowPlus2Seconds);\n+    final ProcessInstance processInstance2 = startProcessInstanceAndFailWithIncident();\n+    retryAndSucceed(processInstance2);\n+\n+    // when\n+    List<HistoricIncidentEntity> completedIncidents =\n+      optimizeService.getCompletedHistoricIncidents(null, now, 10);\n+\n+    // then\n+    assertThat(completedIncidents.size(), is(1));\n+    assertThat(completedIncidents.get(0).getProcessInstanceId(), is(processInstance.getId()));\n+  }\n+\n+  @Test\n+  public void fishedAfterAndFinishedAtParameterWorks() {\n+     // given\n+    testHelper.deploy(FAILING_SERVICE_TASK_MODEL);\n+    Date now = new Date();\n+    ClockUtil.setCurrentTime(now);\n+    final ProcessInstance processInstance = startProcessInstanceAndFailWithIncident();\n+    retryAndSucceed(processInstance);\n+    Date nowPlus2Seconds = new Date(now.getTime() + 2000L);\n+    ClockUtil.setCurrentTime(nowPlus2Seconds);\n+    final ProcessInstance processInstance2 = startProcessInstanceAndFailWithIncident();\n+    retryAndSucceed(processInstance2);\n+\n+    // when\n+    List<HistoricIncidentEntity> completedIncidents =\n+      optimizeService.getCompletedHistoricIncidents(now, now, 10);\n+\n+    // then\n+    assertThat(completedIncidents.size(), is(0));\n+  }\n+\n+  @Test\n+  public void maxResultsParameterWorks() {\n+     // given\n+    testHelper.deploy(FAILING_SERVICE_TASK_MODEL);\n+    for (int i = 0; i < 5; i++) {\n+      final ProcessInstance processInstance = startProcessInstanceAndFailWithIncident();\n+      retryAndSucceed(processInstance);\n+    }\n+\n+    // when\n+    List<HistoricIncidentEntity> completedIncidents =\n+      optimizeService.getCompletedHistoricIncidents(pastDate(), null, 3);\n+\n+    // then\n+    assertThat(completedIncidents.size(), is(3));\n+  }\n+\n+  @Test\n+  public void resultIsSortedByEndTime() {\n+     // given\n+    testHelper.deploy(FAILING_SERVICE_TASK_MODEL);\n+    Date now = new Date();\n+    Date nowPlus1Second = new Date(now.getTime() + 1000L);\n+    ClockUtil.setCurrentTime(nowPlus1Second);\n+    ProcessInstance processInstance1 = startProcessInstanceAndFailWithIncident();\n+    retryAndSucceed(processInstance1);\n+    Date nowPlus2Seconds = new Date(now.getTime() + 2000L);\n+    ClockUtil.setCurrentTime(nowPlus2Seconds);\n+    final ProcessInstance processInstance2 = startProcessInstanceAndFailWithIncident();\n+    retryAndSucceed(processInstance2);\n+    Date nowPlus4Seconds = new Date(nowPlus2Seconds.getTime() + 2000L);\n+    ClockUtil.setCurrentTime(nowPlus4Seconds);\n+    final ProcessInstance processInstance3 = startProcessInstanceAndFailWithIncident();\n+    retryAndSucceed(processInstance3);\n+\n+    // when\n+    List<HistoricIncidentEntity> completedIncidents =\n+      optimizeService.getCompletedHistoricIncidents(now, null, 10);\n+\n+    // then\n+    assertThat(completedIncidents.size(), is(3));\n+    assertThat(completedIncidents.get(0).getProcessInstanceId(), is(processInstance1.getId()));\n+    assertThat(completedIncidents.get(1).getProcessInstanceId(), is(processInstance2.getId()));\n+    assertThat(completedIncidents.get(2).getProcessInstanceId(), is(processInstance3.getId()));\n+  }\n+\n+  @Test\n+  public void fetchOnlyCompletedIncidents() {\n+    // given\n+    testHelper.deploy(FAILING_SERVICE_TASK_MODEL);\n+    final ProcessInstance processInstance = startProcessInstanceAndFailWithIncident();\n+    retryAndSucceed(processInstance);\n+    startProcessInstanceAndFailWithIncident();\n+\n+    // when\n+    List<HistoricIncidentEntity> completedIncidents =\n+      optimizeService.getCompletedHistoricIncidents(pastDate(), null, 10);\n+\n+    // then\n+    assertThat(completedIncidents.size(), is(1));\n+    assertThat(completedIncidents.get(0).getProcessInstanceId(), is(processInstance.getId()));\n+  }\n+\n+  private Date pastDate() {\n+    return new Date(2L);\n+  }\n+\n+  protected void createUser(String userId) {\n+    User user = identityService.newUser(userId);\n+    identityService.saveUser(user);\n+  }\n+\n+  private void assertThatInstanceHasAllImportantInformation(HistoricIncidentEntity historicIncidentEntity) {\n+    assertThat(historicIncidentEntity, notNullValue());\n+    assertThat(historicIncidentEntity.getId(), notNullValue());\n+    assertThat(historicIncidentEntity.getProcessDefinitionKey(), is(PROCESS_DEFINITION_KEY));\n+    assertThat(historicIncidentEntity.getProcessDefinitionVersion(), nullValue());\n+    assertThat(historicIncidentEntity.getProcessDefinitionId(), notNullValue());\n+    assertThat(historicIncidentEntity.getCreateTime(), notNullValue());\n+    assertThat(historicIncidentEntity.getEndTime(), notNullValue());\n+  }\n+\n+  private void retryAndSucceed(final ProcessInstance processInstance) {\n+    runtimeService.setVariable(processInstance.getId(), \"fail\", false);\n+    String jobId = managementService.createJobQuery().singleResult().getId();\n+    managementService.setJobRetries(jobId, 1);\n+  }\n+\n+  private ProcessInstance startProcessInstanceAndFailWithIncident() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e626ce93b1307aad2b18821b4f9e94fa511448cf"}, "originalPosition": 272}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDUwNDIyNg==", "bodyText": "This test case can be merged with getCompletedHistoricIncidents.", "url": "https://github.com/camunda/camunda-bpm-platform/pull/952#discussion_r484504226", "createdAt": "2020-09-07T15:56:17Z", "author": {"login": "ThorbenLindhauer"}, "path": "engine/src/test/java/org/camunda/bpm/engine/test/api/optimize/GetCompletedHistoricIncidentsForOptimizeTest.java", "diffHunk": "@@ -0,0 +1,278 @@\n+/*\n+ * Copyright Camunda Services GmbH and/or licensed to Camunda Services GmbH\n+ * under one or more contributor license agreements. See the NOTICE file\n+ * distributed with this work for additional information regarding copyright\n+ * ownership. Camunda licenses this file to you under the Apache License,\n+ * Version 2.0; you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.camunda.bpm.engine.test.api.optimize;\n+\n+import org.camunda.bpm.engine.AuthorizationService;\n+import org.camunda.bpm.engine.IdentityService;\n+import org.camunda.bpm.engine.ManagementService;\n+import org.camunda.bpm.engine.ProcessEngineConfiguration;\n+import org.camunda.bpm.engine.RuntimeService;\n+import org.camunda.bpm.engine.authorization.Authorization;\n+import org.camunda.bpm.engine.identity.Group;\n+import org.camunda.bpm.engine.identity.User;\n+import org.camunda.bpm.engine.impl.OptimizeService;\n+import org.camunda.bpm.engine.impl.cfg.ProcessEngineConfigurationImpl;\n+import org.camunda.bpm.engine.impl.persistence.entity.HistoricIncidentEntity;\n+import org.camunda.bpm.engine.impl.util.ClockUtil;\n+import org.camunda.bpm.engine.runtime.ProcessInstance;\n+import org.camunda.bpm.engine.test.ProcessEngineRule;\n+import org.camunda.bpm.engine.test.RequiredHistoryLevel;\n+import org.camunda.bpm.engine.test.api.runtime.FailingDelegate;\n+import org.camunda.bpm.engine.test.util.ProcessEngineTestRule;\n+import org.camunda.bpm.engine.test.util.ProvidedProcessEngineRule;\n+import org.camunda.bpm.model.bpmn.Bpmn;\n+import org.camunda.bpm.model.bpmn.BpmnModelInstance;\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.RuleChain;\n+\n+import java.util.Date;\n+import java.util.List;\n+\n+import static org.hamcrest.CoreMatchers.is;\n+import static org.hamcrest.CoreMatchers.notNullValue;\n+import static org.hamcrest.CoreMatchers.nullValue;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+\n+\n+@RequiredHistoryLevel(ProcessEngineConfiguration.HISTORY_FULL)\n+public class GetCompletedHistoricIncidentsForOptimizeTest {\n+\n+  private static final String PROCESS_DEFINITION_KEY = \"oneFailingServiceTaskProcess\";\n+  private static final BpmnModelInstance FAILING_SERVICE_TASK_MODEL =\n+    Bpmn.createExecutableProcess(PROCESS_DEFINITION_KEY)\n+      .startEvent(\"start\")\n+      .serviceTask(\"task\")\n+        .camundaAsyncBefore()\n+        .camundaClass(FailingDelegate.class.getName())\n+      .endEvent(\"end\")\n+      .done();\n+\n+  public ProcessEngineRule engineRule = new ProvidedProcessEngineRule();\n+  protected ProcessEngineTestRule testHelper = new ProcessEngineTestRule(engineRule);\n+\n+  @Rule\n+  public RuleChain ruleChain = RuleChain.outerRule(engineRule).around(testHelper);\n+\n+  private OptimizeService optimizeService;\n+  private IdentityService identityService;\n+  private RuntimeService runtimeService;\n+  private AuthorizationService authorizationService;\n+  private ManagementService managementService;\n+\n+  @Before\n+  public void init() {\n+    ProcessEngineConfigurationImpl config =\n+      engineRule.getProcessEngineConfiguration();\n+    optimizeService = config.getOptimizeService();\n+    identityService = engineRule.getIdentityService();\n+    runtimeService = engineRule.getRuntimeService();\n+    authorizationService = engineRule.getAuthorizationService();\n+    managementService = engineRule.getManagementService();\n+  }\n+\n+  @After\n+  public void cleanUp() {\n+    for (User user : identityService.createUserQuery().list()) {\n+      identityService.deleteUser(user.getId());\n+    }\n+    for (Group group : identityService.createGroupQuery().list()) {\n+      identityService.deleteGroup(group.getId());\n+    }\n+    for (Authorization authorization : authorizationService.createAuthorizationQuery().list()) {\n+      authorizationService.deleteAuthorization(authorization.getId());\n+    }\n+    ClockUtil.reset();\n+  }\n+\n+  @Test\n+  public void getCompletedHistoricIncidents() {\n+     // given\n+    testHelper.deploy(FAILING_SERVICE_TASK_MODEL);\n+    final ProcessInstance processInstance = startProcessInstanceAndFailWithIncident();\n+    retryAndSucceed(processInstance);\n+\n+    // when\n+    List<HistoricIncidentEntity> completedIncidents =\n+      optimizeService.getCompletedHistoricIncidents(pastDate(), null, 10);\n+\n+    // then\n+    assertThat(completedIncidents.size(), is(1));\n+    assertThatInstanceHasAllImportantInformation(completedIncidents.get(0));\n+  }\n+\n+  @Test\n+  public void fishedAfterParameterWorks() {\n+     // given\n+    testHelper.deploy(FAILING_SERVICE_TASK_MODEL);\n+    Date now = new Date();\n+    ClockUtil.setCurrentTime(now);\n+    final ProcessInstance processInstance = startProcessInstanceAndFailWithIncident();\n+    retryAndSucceed(processInstance);\n+    Date nowPlus2Seconds = new Date(now.getTime() + 2000L);\n+    ClockUtil.setCurrentTime(nowPlus2Seconds);\n+    final ProcessInstance processInstance2 = startProcessInstanceAndFailWithIncident();\n+    retryAndSucceed(processInstance2);\n+\n+    // when\n+    List<HistoricIncidentEntity> completedIncidents =\n+      optimizeService.getCompletedHistoricIncidents(now, null, 10);\n+\n+    // then\n+    assertThat(completedIncidents.size(), is(1));\n+  }\n+\n+  @Test\n+  public void fishedAtParameterWorks() {\n+     // given\n+    testHelper.deploy(FAILING_SERVICE_TASK_MODEL);\n+    Date now = new Date();\n+    ClockUtil.setCurrentTime(now);\n+    final ProcessInstance processInstance = startProcessInstanceAndFailWithIncident();\n+    retryAndSucceed(processInstance);\n+    Date nowPlus2Seconds = new Date(now.getTime() + 2000L);\n+    ClockUtil.setCurrentTime(nowPlus2Seconds);\n+    final ProcessInstance processInstance2 = startProcessInstanceAndFailWithIncident();\n+    retryAndSucceed(processInstance2);\n+\n+    // when\n+    List<HistoricIncidentEntity> completedIncidents =\n+      optimizeService.getCompletedHistoricIncidents(null, now, 10);\n+\n+    // then\n+    assertThat(completedIncidents.size(), is(1));\n+    assertThat(completedIncidents.get(0).getProcessInstanceId(), is(processInstance.getId()));\n+  }\n+\n+  @Test\n+  public void fishedAfterAndFinishedAtParameterWorks() {\n+     // given\n+    testHelper.deploy(FAILING_SERVICE_TASK_MODEL);\n+    Date now = new Date();\n+    ClockUtil.setCurrentTime(now);\n+    final ProcessInstance processInstance = startProcessInstanceAndFailWithIncident();\n+    retryAndSucceed(processInstance);\n+    Date nowPlus2Seconds = new Date(now.getTime() + 2000L);\n+    ClockUtil.setCurrentTime(nowPlus2Seconds);\n+    final ProcessInstance processInstance2 = startProcessInstanceAndFailWithIncident();\n+    retryAndSucceed(processInstance2);\n+\n+    // when\n+    List<HistoricIncidentEntity> completedIncidents =\n+      optimizeService.getCompletedHistoricIncidents(now, now, 10);\n+\n+    // then\n+    assertThat(completedIncidents.size(), is(0));\n+  }\n+\n+  @Test\n+  public void maxResultsParameterWorks() {\n+     // given\n+    testHelper.deploy(FAILING_SERVICE_TASK_MODEL);\n+    for (int i = 0; i < 5; i++) {\n+      final ProcessInstance processInstance = startProcessInstanceAndFailWithIncident();\n+      retryAndSucceed(processInstance);\n+    }\n+\n+    // when\n+    List<HistoricIncidentEntity> completedIncidents =\n+      optimizeService.getCompletedHistoricIncidents(pastDate(), null, 3);\n+\n+    // then\n+    assertThat(completedIncidents.size(), is(3));\n+  }\n+\n+  @Test\n+  public void resultIsSortedByEndTime() {\n+     // given\n+    testHelper.deploy(FAILING_SERVICE_TASK_MODEL);\n+    Date now = new Date();\n+    Date nowPlus1Second = new Date(now.getTime() + 1000L);\n+    ClockUtil.setCurrentTime(nowPlus1Second);\n+    ProcessInstance processInstance1 = startProcessInstanceAndFailWithIncident();\n+    retryAndSucceed(processInstance1);\n+    Date nowPlus2Seconds = new Date(now.getTime() + 2000L);\n+    ClockUtil.setCurrentTime(nowPlus2Seconds);\n+    final ProcessInstance processInstance2 = startProcessInstanceAndFailWithIncident();\n+    retryAndSucceed(processInstance2);\n+    Date nowPlus4Seconds = new Date(nowPlus2Seconds.getTime() + 2000L);\n+    ClockUtil.setCurrentTime(nowPlus4Seconds);\n+    final ProcessInstance processInstance3 = startProcessInstanceAndFailWithIncident();\n+    retryAndSucceed(processInstance3);\n+\n+    // when\n+    List<HistoricIncidentEntity> completedIncidents =\n+      optimizeService.getCompletedHistoricIncidents(now, null, 10);\n+\n+    // then\n+    assertThat(completedIncidents.size(), is(3));\n+    assertThat(completedIncidents.get(0).getProcessInstanceId(), is(processInstance1.getId()));\n+    assertThat(completedIncidents.get(1).getProcessInstanceId(), is(processInstance2.getId()));\n+    assertThat(completedIncidents.get(2).getProcessInstanceId(), is(processInstance3.getId()));\n+  }\n+\n+  @Test\n+  public void fetchOnlyCompletedIncidents() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e626ce93b1307aad2b18821b4f9e94fa511448cf"}, "originalPosition": 231}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDUwNDc4NQ==", "bodyText": "I recommend to assert the process instance id here as the test would otherwise also succeed if finishedAfter was implemented as = or <=.", "url": "https://github.com/camunda/camunda-bpm-platform/pull/952#discussion_r484504785", "createdAt": "2020-09-07T15:57:39Z", "author": {"login": "ThorbenLindhauer"}, "path": "engine/src/test/java/org/camunda/bpm/engine/test/api/optimize/GetCompletedHistoricIncidentsForOptimizeTest.java", "diffHunk": "@@ -0,0 +1,278 @@\n+/*\n+ * Copyright Camunda Services GmbH and/or licensed to Camunda Services GmbH\n+ * under one or more contributor license agreements. See the NOTICE file\n+ * distributed with this work for additional information regarding copyright\n+ * ownership. Camunda licenses this file to you under the Apache License,\n+ * Version 2.0; you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.camunda.bpm.engine.test.api.optimize;\n+\n+import org.camunda.bpm.engine.AuthorizationService;\n+import org.camunda.bpm.engine.IdentityService;\n+import org.camunda.bpm.engine.ManagementService;\n+import org.camunda.bpm.engine.ProcessEngineConfiguration;\n+import org.camunda.bpm.engine.RuntimeService;\n+import org.camunda.bpm.engine.authorization.Authorization;\n+import org.camunda.bpm.engine.identity.Group;\n+import org.camunda.bpm.engine.identity.User;\n+import org.camunda.bpm.engine.impl.OptimizeService;\n+import org.camunda.bpm.engine.impl.cfg.ProcessEngineConfigurationImpl;\n+import org.camunda.bpm.engine.impl.persistence.entity.HistoricIncidentEntity;\n+import org.camunda.bpm.engine.impl.util.ClockUtil;\n+import org.camunda.bpm.engine.runtime.ProcessInstance;\n+import org.camunda.bpm.engine.test.ProcessEngineRule;\n+import org.camunda.bpm.engine.test.RequiredHistoryLevel;\n+import org.camunda.bpm.engine.test.api.runtime.FailingDelegate;\n+import org.camunda.bpm.engine.test.util.ProcessEngineTestRule;\n+import org.camunda.bpm.engine.test.util.ProvidedProcessEngineRule;\n+import org.camunda.bpm.model.bpmn.Bpmn;\n+import org.camunda.bpm.model.bpmn.BpmnModelInstance;\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.RuleChain;\n+\n+import java.util.Date;\n+import java.util.List;\n+\n+import static org.hamcrest.CoreMatchers.is;\n+import static org.hamcrest.CoreMatchers.notNullValue;\n+import static org.hamcrest.CoreMatchers.nullValue;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+\n+\n+@RequiredHistoryLevel(ProcessEngineConfiguration.HISTORY_FULL)\n+public class GetCompletedHistoricIncidentsForOptimizeTest {\n+\n+  private static final String PROCESS_DEFINITION_KEY = \"oneFailingServiceTaskProcess\";\n+  private static final BpmnModelInstance FAILING_SERVICE_TASK_MODEL =\n+    Bpmn.createExecutableProcess(PROCESS_DEFINITION_KEY)\n+      .startEvent(\"start\")\n+      .serviceTask(\"task\")\n+        .camundaAsyncBefore()\n+        .camundaClass(FailingDelegate.class.getName())\n+      .endEvent(\"end\")\n+      .done();\n+\n+  public ProcessEngineRule engineRule = new ProvidedProcessEngineRule();\n+  protected ProcessEngineTestRule testHelper = new ProcessEngineTestRule(engineRule);\n+\n+  @Rule\n+  public RuleChain ruleChain = RuleChain.outerRule(engineRule).around(testHelper);\n+\n+  private OptimizeService optimizeService;\n+  private IdentityService identityService;\n+  private RuntimeService runtimeService;\n+  private AuthorizationService authorizationService;\n+  private ManagementService managementService;\n+\n+  @Before\n+  public void init() {\n+    ProcessEngineConfigurationImpl config =\n+      engineRule.getProcessEngineConfiguration();\n+    optimizeService = config.getOptimizeService();\n+    identityService = engineRule.getIdentityService();\n+    runtimeService = engineRule.getRuntimeService();\n+    authorizationService = engineRule.getAuthorizationService();\n+    managementService = engineRule.getManagementService();\n+  }\n+\n+  @After\n+  public void cleanUp() {\n+    for (User user : identityService.createUserQuery().list()) {\n+      identityService.deleteUser(user.getId());\n+    }\n+    for (Group group : identityService.createGroupQuery().list()) {\n+      identityService.deleteGroup(group.getId());\n+    }\n+    for (Authorization authorization : authorizationService.createAuthorizationQuery().list()) {\n+      authorizationService.deleteAuthorization(authorization.getId());\n+    }\n+    ClockUtil.reset();\n+  }\n+\n+  @Test\n+  public void getCompletedHistoricIncidents() {\n+     // given\n+    testHelper.deploy(FAILING_SERVICE_TASK_MODEL);\n+    final ProcessInstance processInstance = startProcessInstanceAndFailWithIncident();\n+    retryAndSucceed(processInstance);\n+\n+    // when\n+    List<HistoricIncidentEntity> completedIncidents =\n+      optimizeService.getCompletedHistoricIncidents(pastDate(), null, 10);\n+\n+    // then\n+    assertThat(completedIncidents.size(), is(1));\n+    assertThatInstanceHasAllImportantInformation(completedIncidents.get(0));\n+  }\n+\n+  @Test\n+  public void fishedAfterParameterWorks() {\n+     // given\n+    testHelper.deploy(FAILING_SERVICE_TASK_MODEL);\n+    Date now = new Date();\n+    ClockUtil.setCurrentTime(now);\n+    final ProcessInstance processInstance = startProcessInstanceAndFailWithIncident();\n+    retryAndSucceed(processInstance);\n+    Date nowPlus2Seconds = new Date(now.getTime() + 2000L);\n+    ClockUtil.setCurrentTime(nowPlus2Seconds);\n+    final ProcessInstance processInstance2 = startProcessInstanceAndFailWithIncident();\n+    retryAndSucceed(processInstance2);\n+\n+    // when\n+    List<HistoricIncidentEntity> completedIncidents =\n+      optimizeService.getCompletedHistoricIncidents(now, null, 10);\n+\n+    // then\n+    assertThat(completedIncidents.size(), is(1));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e626ce93b1307aad2b18821b4f9e94fa511448cf"}, "originalPosition": 138}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDUwNTAyMA==", "bodyText": "This is hard to read. Can we structure this block a bit better with some new lines?", "url": "https://github.com/camunda/camunda-bpm-platform/pull/952#discussion_r484505020", "createdAt": "2020-09-07T15:58:19Z", "author": {"login": "ThorbenLindhauer"}, "path": "engine/src/test/java/org/camunda/bpm/engine/test/api/optimize/GetCompletedHistoricIncidentsForOptimizeTest.java", "diffHunk": "@@ -0,0 +1,278 @@\n+/*\n+ * Copyright Camunda Services GmbH and/or licensed to Camunda Services GmbH\n+ * under one or more contributor license agreements. See the NOTICE file\n+ * distributed with this work for additional information regarding copyright\n+ * ownership. Camunda licenses this file to you under the Apache License,\n+ * Version 2.0; you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.camunda.bpm.engine.test.api.optimize;\n+\n+import org.camunda.bpm.engine.AuthorizationService;\n+import org.camunda.bpm.engine.IdentityService;\n+import org.camunda.bpm.engine.ManagementService;\n+import org.camunda.bpm.engine.ProcessEngineConfiguration;\n+import org.camunda.bpm.engine.RuntimeService;\n+import org.camunda.bpm.engine.authorization.Authorization;\n+import org.camunda.bpm.engine.identity.Group;\n+import org.camunda.bpm.engine.identity.User;\n+import org.camunda.bpm.engine.impl.OptimizeService;\n+import org.camunda.bpm.engine.impl.cfg.ProcessEngineConfigurationImpl;\n+import org.camunda.bpm.engine.impl.persistence.entity.HistoricIncidentEntity;\n+import org.camunda.bpm.engine.impl.util.ClockUtil;\n+import org.camunda.bpm.engine.runtime.ProcessInstance;\n+import org.camunda.bpm.engine.test.ProcessEngineRule;\n+import org.camunda.bpm.engine.test.RequiredHistoryLevel;\n+import org.camunda.bpm.engine.test.api.runtime.FailingDelegate;\n+import org.camunda.bpm.engine.test.util.ProcessEngineTestRule;\n+import org.camunda.bpm.engine.test.util.ProvidedProcessEngineRule;\n+import org.camunda.bpm.model.bpmn.Bpmn;\n+import org.camunda.bpm.model.bpmn.BpmnModelInstance;\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.RuleChain;\n+\n+import java.util.Date;\n+import java.util.List;\n+\n+import static org.hamcrest.CoreMatchers.is;\n+import static org.hamcrest.CoreMatchers.notNullValue;\n+import static org.hamcrest.CoreMatchers.nullValue;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+\n+\n+@RequiredHistoryLevel(ProcessEngineConfiguration.HISTORY_FULL)\n+public class GetCompletedHistoricIncidentsForOptimizeTest {\n+\n+  private static final String PROCESS_DEFINITION_KEY = \"oneFailingServiceTaskProcess\";\n+  private static final BpmnModelInstance FAILING_SERVICE_TASK_MODEL =\n+    Bpmn.createExecutableProcess(PROCESS_DEFINITION_KEY)\n+      .startEvent(\"start\")\n+      .serviceTask(\"task\")\n+        .camundaAsyncBefore()\n+        .camundaClass(FailingDelegate.class.getName())\n+      .endEvent(\"end\")\n+      .done();\n+\n+  public ProcessEngineRule engineRule = new ProvidedProcessEngineRule();\n+  protected ProcessEngineTestRule testHelper = new ProcessEngineTestRule(engineRule);\n+\n+  @Rule\n+  public RuleChain ruleChain = RuleChain.outerRule(engineRule).around(testHelper);\n+\n+  private OptimizeService optimizeService;\n+  private IdentityService identityService;\n+  private RuntimeService runtimeService;\n+  private AuthorizationService authorizationService;\n+  private ManagementService managementService;\n+\n+  @Before\n+  public void init() {\n+    ProcessEngineConfigurationImpl config =\n+      engineRule.getProcessEngineConfiguration();\n+    optimizeService = config.getOptimizeService();\n+    identityService = engineRule.getIdentityService();\n+    runtimeService = engineRule.getRuntimeService();\n+    authorizationService = engineRule.getAuthorizationService();\n+    managementService = engineRule.getManagementService();\n+  }\n+\n+  @After\n+  public void cleanUp() {\n+    for (User user : identityService.createUserQuery().list()) {\n+      identityService.deleteUser(user.getId());\n+    }\n+    for (Group group : identityService.createGroupQuery().list()) {\n+      identityService.deleteGroup(group.getId());\n+    }\n+    for (Authorization authorization : authorizationService.createAuthorizationQuery().list()) {\n+      authorizationService.deleteAuthorization(authorization.getId());\n+    }\n+    ClockUtil.reset();\n+  }\n+\n+  @Test\n+  public void getCompletedHistoricIncidents() {\n+     // given\n+    testHelper.deploy(FAILING_SERVICE_TASK_MODEL);\n+    final ProcessInstance processInstance = startProcessInstanceAndFailWithIncident();\n+    retryAndSucceed(processInstance);\n+\n+    // when\n+    List<HistoricIncidentEntity> completedIncidents =\n+      optimizeService.getCompletedHistoricIncidents(pastDate(), null, 10);\n+\n+    // then\n+    assertThat(completedIncidents.size(), is(1));\n+    assertThatInstanceHasAllImportantInformation(completedIncidents.get(0));\n+  }\n+\n+  @Test\n+  public void fishedAfterParameterWorks() {\n+     // given\n+    testHelper.deploy(FAILING_SERVICE_TASK_MODEL);\n+    Date now = new Date();\n+    ClockUtil.setCurrentTime(now);\n+    final ProcessInstance processInstance = startProcessInstanceAndFailWithIncident();\n+    retryAndSucceed(processInstance);\n+    Date nowPlus2Seconds = new Date(now.getTime() + 2000L);\n+    ClockUtil.setCurrentTime(nowPlus2Seconds);\n+    final ProcessInstance processInstance2 = startProcessInstanceAndFailWithIncident();\n+    retryAndSucceed(processInstance2);\n+\n+    // when\n+    List<HistoricIncidentEntity> completedIncidents =\n+      optimizeService.getCompletedHistoricIncidents(now, null, 10);\n+\n+    // then\n+    assertThat(completedIncidents.size(), is(1));\n+  }\n+\n+  @Test\n+  public void fishedAtParameterWorks() {\n+     // given\n+    testHelper.deploy(FAILING_SERVICE_TASK_MODEL);\n+    Date now = new Date();\n+    ClockUtil.setCurrentTime(now);\n+    final ProcessInstance processInstance = startProcessInstanceAndFailWithIncident();\n+    retryAndSucceed(processInstance);\n+    Date nowPlus2Seconds = new Date(now.getTime() + 2000L);\n+    ClockUtil.setCurrentTime(nowPlus2Seconds);\n+    final ProcessInstance processInstance2 = startProcessInstanceAndFailWithIncident();\n+    retryAndSucceed(processInstance2);\n+\n+    // when\n+    List<HistoricIncidentEntity> completedIncidents =\n+      optimizeService.getCompletedHistoricIncidents(null, now, 10);\n+\n+    // then\n+    assertThat(completedIncidents.size(), is(1));\n+    assertThat(completedIncidents.get(0).getProcessInstanceId(), is(processInstance.getId()));\n+  }\n+\n+  @Test\n+  public void fishedAfterAndFinishedAtParameterWorks() {\n+     // given\n+    testHelper.deploy(FAILING_SERVICE_TASK_MODEL);\n+    Date now = new Date();\n+    ClockUtil.setCurrentTime(now);\n+    final ProcessInstance processInstance = startProcessInstanceAndFailWithIncident();\n+    retryAndSucceed(processInstance);\n+    Date nowPlus2Seconds = new Date(now.getTime() + 2000L);\n+    ClockUtil.setCurrentTime(nowPlus2Seconds);\n+    final ProcessInstance processInstance2 = startProcessInstanceAndFailWithIncident();\n+    retryAndSucceed(processInstance2);\n+\n+    // when\n+    List<HistoricIncidentEntity> completedIncidents =\n+      optimizeService.getCompletedHistoricIncidents(now, now, 10);\n+\n+    // then\n+    assertThat(completedIncidents.size(), is(0));\n+  }\n+\n+  @Test\n+  public void maxResultsParameterWorks() {\n+     // given\n+    testHelper.deploy(FAILING_SERVICE_TASK_MODEL);\n+    for (int i = 0; i < 5; i++) {\n+      final ProcessInstance processInstance = startProcessInstanceAndFailWithIncident();\n+      retryAndSucceed(processInstance);\n+    }\n+\n+    // when\n+    List<HistoricIncidentEntity> completedIncidents =\n+      optimizeService.getCompletedHistoricIncidents(pastDate(), null, 3);\n+\n+    // then\n+    assertThat(completedIncidents.size(), is(3));\n+  }\n+\n+  @Test\n+  public void resultIsSortedByEndTime() {\n+     // given\n+    testHelper.deploy(FAILING_SERVICE_TASK_MODEL);\n+    Date now = new Date();\n+    Date nowPlus1Second = new Date(now.getTime() + 1000L);\n+    ClockUtil.setCurrentTime(nowPlus1Second);\n+    ProcessInstance processInstance1 = startProcessInstanceAndFailWithIncident();\n+    retryAndSucceed(processInstance1);\n+    Date nowPlus2Seconds = new Date(now.getTime() + 2000L);\n+    ClockUtil.setCurrentTime(nowPlus2Seconds);\n+    final ProcessInstance processInstance2 = startProcessInstanceAndFailWithIncident();\n+    retryAndSucceed(processInstance2);\n+    Date nowPlus4Seconds = new Date(nowPlus2Seconds.getTime() + 2000L);\n+    ClockUtil.setCurrentTime(nowPlus4Seconds);\n+    final ProcessInstance processInstance3 = startProcessInstanceAndFailWithIncident();\n+    retryAndSucceed(processInstance3);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e626ce93b1307aad2b18821b4f9e94fa511448cf"}, "originalPosition": 217}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDUwNTM4NQ==", "bodyText": "Let's remove all the user-, group- and authorization-related code from this class as it is not needed.", "url": "https://github.com/camunda/camunda-bpm-platform/pull/952#discussion_r484505385", "createdAt": "2020-09-07T15:59:20Z", "author": {"login": "ThorbenLindhauer"}, "path": "engine/src/test/java/org/camunda/bpm/engine/test/api/optimize/GetCompletedHistoricIncidentsForOptimizeTest.java", "diffHunk": "@@ -0,0 +1,278 @@\n+/*\n+ * Copyright Camunda Services GmbH and/or licensed to Camunda Services GmbH\n+ * under one or more contributor license agreements. See the NOTICE file\n+ * distributed with this work for additional information regarding copyright\n+ * ownership. Camunda licenses this file to you under the Apache License,\n+ * Version 2.0; you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.camunda.bpm.engine.test.api.optimize;\n+\n+import org.camunda.bpm.engine.AuthorizationService;\n+import org.camunda.bpm.engine.IdentityService;\n+import org.camunda.bpm.engine.ManagementService;\n+import org.camunda.bpm.engine.ProcessEngineConfiguration;\n+import org.camunda.bpm.engine.RuntimeService;\n+import org.camunda.bpm.engine.authorization.Authorization;\n+import org.camunda.bpm.engine.identity.Group;\n+import org.camunda.bpm.engine.identity.User;\n+import org.camunda.bpm.engine.impl.OptimizeService;\n+import org.camunda.bpm.engine.impl.cfg.ProcessEngineConfigurationImpl;\n+import org.camunda.bpm.engine.impl.persistence.entity.HistoricIncidentEntity;\n+import org.camunda.bpm.engine.impl.util.ClockUtil;\n+import org.camunda.bpm.engine.runtime.ProcessInstance;\n+import org.camunda.bpm.engine.test.ProcessEngineRule;\n+import org.camunda.bpm.engine.test.RequiredHistoryLevel;\n+import org.camunda.bpm.engine.test.api.runtime.FailingDelegate;\n+import org.camunda.bpm.engine.test.util.ProcessEngineTestRule;\n+import org.camunda.bpm.engine.test.util.ProvidedProcessEngineRule;\n+import org.camunda.bpm.model.bpmn.Bpmn;\n+import org.camunda.bpm.model.bpmn.BpmnModelInstance;\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.RuleChain;\n+\n+import java.util.Date;\n+import java.util.List;\n+\n+import static org.hamcrest.CoreMatchers.is;\n+import static org.hamcrest.CoreMatchers.notNullValue;\n+import static org.hamcrest.CoreMatchers.nullValue;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+\n+\n+@RequiredHistoryLevel(ProcessEngineConfiguration.HISTORY_FULL)\n+public class GetCompletedHistoricIncidentsForOptimizeTest {\n+\n+  private static final String PROCESS_DEFINITION_KEY = \"oneFailingServiceTaskProcess\";\n+  private static final BpmnModelInstance FAILING_SERVICE_TASK_MODEL =\n+    Bpmn.createExecutableProcess(PROCESS_DEFINITION_KEY)\n+      .startEvent(\"start\")\n+      .serviceTask(\"task\")\n+        .camundaAsyncBefore()\n+        .camundaClass(FailingDelegate.class.getName())\n+      .endEvent(\"end\")\n+      .done();\n+\n+  public ProcessEngineRule engineRule = new ProvidedProcessEngineRule();\n+  protected ProcessEngineTestRule testHelper = new ProcessEngineTestRule(engineRule);\n+\n+  @Rule\n+  public RuleChain ruleChain = RuleChain.outerRule(engineRule).around(testHelper);\n+\n+  private OptimizeService optimizeService;\n+  private IdentityService identityService;\n+  private RuntimeService runtimeService;\n+  private AuthorizationService authorizationService;\n+  private ManagementService managementService;\n+\n+  @Before\n+  public void init() {\n+    ProcessEngineConfigurationImpl config =\n+      engineRule.getProcessEngineConfiguration();\n+    optimizeService = config.getOptimizeService();\n+    identityService = engineRule.getIdentityService();\n+    runtimeService = engineRule.getRuntimeService();\n+    authorizationService = engineRule.getAuthorizationService();\n+    managementService = engineRule.getManagementService();\n+  }\n+\n+  @After\n+  public void cleanUp() {\n+    for (User user : identityService.createUserQuery().list()) {\n+      identityService.deleteUser(user.getId());\n+    }\n+    for (Group group : identityService.createGroupQuery().list()) {\n+      identityService.deleteGroup(group.getId());\n+    }\n+    for (Authorization authorization : authorizationService.createAuthorizationQuery().list()) {\n+      authorizationService.deleteAuthorization(authorization.getId());\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e626ce93b1307aad2b18821b4f9e94fa511448cf"}, "originalPosition": 100}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDUwNTk2OA==", "bodyText": "Most of the review hints for GetCompletedHistoricIncidentsForOptimizeTest  apply here as well. Please make any changes in both classes.", "url": "https://github.com/camunda/camunda-bpm-platform/pull/952#discussion_r484505968", "createdAt": "2020-09-07T16:01:07Z", "author": {"login": "ThorbenLindhauer"}, "path": "engine/src/test/java/org/camunda/bpm/engine/test/api/optimize/GetOpenHistoricIncidentsForOptimizeTest.java", "diffHunk": "@@ -0,0 +1,267 @@\n+/*\n+ * Copyright Camunda Services GmbH and/or licensed to Camunda Services GmbH\n+ * under one or more contributor license agreements. See the NOTICE file\n+ * distributed with this work for additional information regarding copyright\n+ * ownership. Camunda licenses this file to you under the Apache License,\n+ * Version 2.0; you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.camunda.bpm.engine.test.api.optimize;\n+\n+import org.camunda.bpm.engine.AuthorizationService;\n+import org.camunda.bpm.engine.IdentityService;\n+import org.camunda.bpm.engine.ManagementService;\n+import org.camunda.bpm.engine.ProcessEngineConfiguration;\n+import org.camunda.bpm.engine.RuntimeService;\n+import org.camunda.bpm.engine.authorization.Authorization;\n+import org.camunda.bpm.engine.identity.Group;\n+import org.camunda.bpm.engine.identity.User;\n+import org.camunda.bpm.engine.impl.OptimizeService;\n+import org.camunda.bpm.engine.impl.cfg.ProcessEngineConfigurationImpl;\n+import org.camunda.bpm.engine.impl.persistence.entity.HistoricIncidentEntity;\n+import org.camunda.bpm.engine.impl.util.ClockUtil;\n+import org.camunda.bpm.engine.runtime.ProcessInstance;\n+import org.camunda.bpm.engine.test.ProcessEngineRule;\n+import org.camunda.bpm.engine.test.RequiredHistoryLevel;\n+import org.camunda.bpm.engine.test.api.runtime.FailingDelegate;\n+import org.camunda.bpm.engine.test.util.ProcessEngineTestRule;\n+import org.camunda.bpm.engine.test.util.ProvidedProcessEngineRule;\n+import org.camunda.bpm.model.bpmn.Bpmn;\n+import org.camunda.bpm.model.bpmn.BpmnModelInstance;\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.RuleChain;\n+\n+import java.util.Date;\n+import java.util.List;\n+\n+import static org.hamcrest.CoreMatchers.is;\n+import static org.hamcrest.CoreMatchers.notNullValue;\n+import static org.hamcrest.CoreMatchers.nullValue;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+\n+\n+@RequiredHistoryLevel(ProcessEngineConfiguration.HISTORY_FULL)\n+public class GetOpenHistoricIncidentsForOptimizeTest {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e626ce93b1307aad2b18821b4f9e94fa511448cf"}, "originalPosition": 55}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5312bc6997bf3ec0811b419e4864416c01e3b3b8", "author": {"user": null}, "url": "https://github.com/camunda/camunda-bpm-platform/commit/5312bc6997bf3ec0811b419e4864416c01e3b3b8", "committedDate": "2020-09-09T13:25:50Z", "message": "implement review hints"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDg1MDkxMzcy", "url": "https://github.com/camunda/camunda-bpm-platform/pull/952#pullrequestreview-485091372", "createdAt": "2020-09-09T14:49:50Z", "commit": {"oid": "5312bc6997bf3ec0811b419e4864416c01e3b3b8"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2182, "cost": 1, "resetAt": "2021-11-01T13:07:16Z"}}}