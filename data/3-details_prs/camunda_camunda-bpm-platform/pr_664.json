{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzc2MjI0NzEz", "number": 664, "title": "CAM-11346: feat(feel): port spin feel integration from  scala to java", "bodyText": "Port the Spin Integration for the Scala FEEL Engine from Scala to Java;\nMerge the FEEL Spin Integration module with the Spin Process Engine Plugin module;\nPort Scala tests to JUnit and add additional integration tests to assert SPI functionality and correct Process/DMN Engine integration.\n\nRelated to CAM-11346", "createdAt": "2020-02-17T16:27:30Z", "url": "https://github.com/camunda/camunda-bpm-platform/pull/664", "merged": true, "mergeCommit": {"oid": "75bf3a4ed2a54ed0ea7bb8b24341e3e00d40a16b"}, "closed": true, "closedAt": "2020-02-20T10:09:34Z", "author": {"login": "koevskinikola"}, "timelineItems": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcF1SgQgFqTM2MDUxNDA2NQ==", "endCursor": "Y3Vyc29yOnYyOpPPAAABcF44k3gBqjMwNTIzMjY4NjQ=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzYwNTE0MDY1", "url": "https://github.com/camunda/camunda-bpm-platform/pull/664#pullrequestreview-360514065", "createdAt": "2020-02-18T17:04:05Z", "commit": {"oid": "04109966910e194930c7e375dc0bb0a36615924d"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 9, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xOFQxNzowNDowNVrOFrKvyA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xOFQxNzoxMzoxN1rOFrLFgw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDgwOTE2MA==", "bodyText": "We cannot use unprefixed scala classes due to shading => use camundajar.impl.scala... instead", "url": "https://github.com/camunda/camunda-bpm-platform/pull/664#discussion_r380809160", "createdAt": "2020-02-18T17:04:05Z", "author": {"login": "tasso94"}, "path": "engine-plugins/spin-plugin/src/main/java/org/camunda/spin/plugin/impl/feel/integration/CamundaSpinValueMapper.java", "diffHunk": "@@ -0,0 +1,144 @@\n+/*\n+ * Copyright Camunda Services GmbH and/or licensed to Camunda Services GmbH\n+ * under one or more contributor license agreements. See the NOTICE file\n+ * distributed with this work for additional information regarding copyright\n+ * ownership. Camunda licenses this file to you under the Apache License,\n+ * Version 2.0; you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.camunda.spin.plugin.impl.feel.integration;\n+\n+import static java.util.stream.Collectors.groupingBy;\n+import static java.util.stream.Collectors.mapping;\n+import static java.util.stream.Collectors.toList;\n+import static java.util.stream.Collectors.toMap;\n+import static scala.jdk.CollectionConverters.ListHasAsScala;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "04109966910e194930c7e375dc0bb0a36615924d"}, "originalPosition": 23}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDgxMDg3Mw==", "bodyText": "Lines of code must not exceed 100 characters", "url": "https://github.com/camunda/camunda-bpm-platform/pull/664#discussion_r380810873", "createdAt": "2020-02-18T17:06:49Z", "author": {"login": "tasso94"}, "path": "engine-plugins/spin-plugin/src/main/java/org/camunda/spin/plugin/impl/feel/integration/CamundaSpinValueMapper.java", "diffHunk": "@@ -0,0 +1,144 @@\n+/*\n+ * Copyright Camunda Services GmbH and/or licensed to Camunda Services GmbH\n+ * under one or more contributor license agreements. See the NOTICE file\n+ * distributed with this work for additional information regarding copyright\n+ * ownership. Camunda licenses this file to you under the Apache License,\n+ * Version 2.0; you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.camunda.spin.plugin.impl.feel.integration;\n+\n+import static java.util.stream.Collectors.groupingBy;\n+import static java.util.stream.Collectors.mapping;\n+import static java.util.stream.Collectors.toList;\n+import static java.util.stream.Collectors.toMap;\n+import static scala.jdk.CollectionConverters.ListHasAsScala;\n+\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.function.Function;\n+\n+import org.camunda.feel.impl.spi.JavaCustomValueMapper;\n+import org.camunda.feel.interpreter.impl.Val;\n+import org.camunda.feel.interpreter.impl.ValList;\n+import org.camunda.feel.interpreter.impl.ValString;\n+import org.camunda.spin.json.SpinJsonNode;\n+import org.camunda.spin.xml.SpinXmlAttribute;\n+import org.camunda.spin.xml.SpinXmlElement;\n+import org.camunda.spin.xml.SpinXmlNode;\n+\n+\n+public class CamundaSpinValueMapper extends JavaCustomValueMapper {\n+\n+  @Override\n+  public Optional<Val> toValue(Object x, Function<Object, Val> innerValueMapper) {\n+    if (x instanceof SpinJsonNode) {\n+      SpinJsonNode node = (SpinJsonNode) x;\n+      return Optional.of(this.spinJsonToVal(node, innerValueMapper));\n+\n+    } else if (x instanceof SpinXmlElement) {\n+      SpinXmlElement element = (SpinXmlElement) x;\n+      return Optional.of(this.spinXmlToVal(element, innerValueMapper));\n+\n+    } else {\n+      return Optional.empty();\n+\n+    }\n+  }\n+\n+  @Override\n+  public Optional<Object> unpackValue(Val value, Function<Val, Object> innerValueMapper) {\n+    return Optional.empty();\n+  }\n+\n+  @Override\n+  public int priority() {\n+    return 30;\n+  }\n+\n+  protected Val spinJsonToVal(SpinJsonNode node, Function<Object, Val> innerValueMapper) {\n+    if (node.isObject()) {\n+      Map pairs = node.fieldNames().stream()\n+        .collect(toMap(field -> field, field -> spinJsonToVal(node.prop(field), innerValueMapper)));\n+      return innerValueMapper.apply(pairs);\n+\n+    } else if (node.isArray()) {\n+      List<Val> values = node.elements().stream().map(e -> spinJsonToVal(e, innerValueMapper)).collect(toList());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "04109966910e194930c7e375dc0bb0a36615924d"}, "originalPosition": 77}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDgxMTA4Nw==", "bodyText": "Lines of code must not exceed 100 characters", "url": "https://github.com/camunda/camunda-bpm-platform/pull/664#discussion_r380811087", "createdAt": "2020-02-18T17:07:12Z", "author": {"login": "tasso94"}, "path": "engine-plugins/spin-plugin/src/main/java/org/camunda/spin/plugin/impl/feel/integration/CamundaSpinValueMapper.java", "diffHunk": "@@ -0,0 +1,144 @@\n+/*\n+ * Copyright Camunda Services GmbH and/or licensed to Camunda Services GmbH\n+ * under one or more contributor license agreements. See the NOTICE file\n+ * distributed with this work for additional information regarding copyright\n+ * ownership. Camunda licenses this file to you under the Apache License,\n+ * Version 2.0; you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.camunda.spin.plugin.impl.feel.integration;\n+\n+import static java.util.stream.Collectors.groupingBy;\n+import static java.util.stream.Collectors.mapping;\n+import static java.util.stream.Collectors.toList;\n+import static java.util.stream.Collectors.toMap;\n+import static scala.jdk.CollectionConverters.ListHasAsScala;\n+\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.function.Function;\n+\n+import org.camunda.feel.impl.spi.JavaCustomValueMapper;\n+import org.camunda.feel.interpreter.impl.Val;\n+import org.camunda.feel.interpreter.impl.ValList;\n+import org.camunda.feel.interpreter.impl.ValString;\n+import org.camunda.spin.json.SpinJsonNode;\n+import org.camunda.spin.xml.SpinXmlAttribute;\n+import org.camunda.spin.xml.SpinXmlElement;\n+import org.camunda.spin.xml.SpinXmlNode;\n+\n+\n+public class CamundaSpinValueMapper extends JavaCustomValueMapper {\n+\n+  @Override\n+  public Optional<Val> toValue(Object x, Function<Object, Val> innerValueMapper) {\n+    if (x instanceof SpinJsonNode) {\n+      SpinJsonNode node = (SpinJsonNode) x;\n+      return Optional.of(this.spinJsonToVal(node, innerValueMapper));\n+\n+    } else if (x instanceof SpinXmlElement) {\n+      SpinXmlElement element = (SpinXmlElement) x;\n+      return Optional.of(this.spinXmlToVal(element, innerValueMapper));\n+\n+    } else {\n+      return Optional.empty();\n+\n+    }\n+  }\n+\n+  @Override\n+  public Optional<Object> unpackValue(Val value, Function<Val, Object> innerValueMapper) {\n+    return Optional.empty();\n+  }\n+\n+  @Override\n+  public int priority() {\n+    return 30;\n+  }\n+\n+  protected Val spinJsonToVal(SpinJsonNode node, Function<Object, Val> innerValueMapper) {\n+    if (node.isObject()) {\n+      Map pairs = node.fieldNames().stream()\n+        .collect(toMap(field -> field, field -> spinJsonToVal(node.prop(field), innerValueMapper)));\n+      return innerValueMapper.apply(pairs);\n+\n+    } else if (node.isArray()) {\n+      List<Val> values = node.elements().stream().map(e -> spinJsonToVal(e, innerValueMapper)).collect(toList());\n+      return new ValList(ListHasAsScala(values).asScala().toList());\n+\n+    } else if (node.isNull()) {\n+      return innerValueMapper.apply(null);\n+\n+    } else {\n+      return innerValueMapper.apply(node.value());\n+\n+    }\n+  }\n+\n+  protected Val spinXmlToVal(SpinXmlElement element, Function<Object, Val> innerValueMapper) {\n+    String name = nodeName(element);\n+    Val value = spinXmlElementToVal(element, innerValueMapper);\n+    Map<String, Object> map = Collections.singletonMap(name, value);\n+\n+    return innerValueMapper.apply(map);\n+  }\n+\n+  protected Val spinXmlElementToVal(final SpinXmlElement e, Function<Object, Val> innerValueMapper) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "04109966910e194930c7e375dc0bb0a36615924d"}, "originalPosition": 97}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDgxMTE5NA==", "bodyText": "Lines of code must not exceed 100 characters", "url": "https://github.com/camunda/camunda-bpm-platform/pull/664#discussion_r380811194", "createdAt": "2020-02-18T17:07:23Z", "author": {"login": "tasso94"}, "path": "engine-plugins/spin-plugin/src/main/java/org/camunda/spin/plugin/impl/feel/integration/CamundaSpinValueMapper.java", "diffHunk": "@@ -0,0 +1,144 @@\n+/*\n+ * Copyright Camunda Services GmbH and/or licensed to Camunda Services GmbH\n+ * under one or more contributor license agreements. See the NOTICE file\n+ * distributed with this work for additional information regarding copyright\n+ * ownership. Camunda licenses this file to you under the Apache License,\n+ * Version 2.0; you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.camunda.spin.plugin.impl.feel.integration;\n+\n+import static java.util.stream.Collectors.groupingBy;\n+import static java.util.stream.Collectors.mapping;\n+import static java.util.stream.Collectors.toList;\n+import static java.util.stream.Collectors.toMap;\n+import static scala.jdk.CollectionConverters.ListHasAsScala;\n+\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.function.Function;\n+\n+import org.camunda.feel.impl.spi.JavaCustomValueMapper;\n+import org.camunda.feel.interpreter.impl.Val;\n+import org.camunda.feel.interpreter.impl.ValList;\n+import org.camunda.feel.interpreter.impl.ValString;\n+import org.camunda.spin.json.SpinJsonNode;\n+import org.camunda.spin.xml.SpinXmlAttribute;\n+import org.camunda.spin.xml.SpinXmlElement;\n+import org.camunda.spin.xml.SpinXmlNode;\n+\n+\n+public class CamundaSpinValueMapper extends JavaCustomValueMapper {\n+\n+  @Override\n+  public Optional<Val> toValue(Object x, Function<Object, Val> innerValueMapper) {\n+    if (x instanceof SpinJsonNode) {\n+      SpinJsonNode node = (SpinJsonNode) x;\n+      return Optional.of(this.spinJsonToVal(node, innerValueMapper));\n+\n+    } else if (x instanceof SpinXmlElement) {\n+      SpinXmlElement element = (SpinXmlElement) x;\n+      return Optional.of(this.spinXmlToVal(element, innerValueMapper));\n+\n+    } else {\n+      return Optional.empty();\n+\n+    }\n+  }\n+\n+  @Override\n+  public Optional<Object> unpackValue(Val value, Function<Val, Object> innerValueMapper) {\n+    return Optional.empty();\n+  }\n+\n+  @Override\n+  public int priority() {\n+    return 30;\n+  }\n+\n+  protected Val spinJsonToVal(SpinJsonNode node, Function<Object, Val> innerValueMapper) {\n+    if (node.isObject()) {\n+      Map pairs = node.fieldNames().stream()\n+        .collect(toMap(field -> field, field -> spinJsonToVal(node.prop(field), innerValueMapper)));\n+      return innerValueMapper.apply(pairs);\n+\n+    } else if (node.isArray()) {\n+      List<Val> values = node.elements().stream().map(e -> spinJsonToVal(e, innerValueMapper)).collect(toList());\n+      return new ValList(ListHasAsScala(values).asScala().toList());\n+\n+    } else if (node.isNull()) {\n+      return innerValueMapper.apply(null);\n+\n+    } else {\n+      return innerValueMapper.apply(node.value());\n+\n+    }\n+  }\n+\n+  protected Val spinXmlToVal(SpinXmlElement element, Function<Object, Val> innerValueMapper) {\n+    String name = nodeName(element);\n+    Val value = spinXmlElementToVal(element, innerValueMapper);\n+    Map<String, Object> map = Collections.singletonMap(name, value);\n+\n+    return innerValueMapper.apply(map);\n+  }\n+\n+  protected Val spinXmlElementToVal(final SpinXmlElement e, Function<Object, Val> innerValueMapper) {\n+    Map<String, Object> membersMap = new HashMap<>();\n+    String content = e.textContent().trim();\n+    if (!content.isEmpty()) {\n+      membersMap.put(\"$content\", new ValString(content));\n+    }\n+\n+    Map<String, ValString> attributes = e.attrs().stream().collect(toMap(attr -> spinXmlAttributeToKey(attr), attr -> new ValString(attr.value())));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "04109966910e194930c7e375dc0bb0a36615924d"}, "originalPosition": 104}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDgxMTc5Nw==", "bodyText": "Isn't this::spinXmlAttributeToKey much more shorter and readable?", "url": "https://github.com/camunda/camunda-bpm-platform/pull/664#discussion_r380811797", "createdAt": "2020-02-18T17:08:21Z", "author": {"login": "tasso94"}, "path": "engine-plugins/spin-plugin/src/main/java/org/camunda/spin/plugin/impl/feel/integration/CamundaSpinValueMapper.java", "diffHunk": "@@ -0,0 +1,144 @@\n+/*\n+ * Copyright Camunda Services GmbH and/or licensed to Camunda Services GmbH\n+ * under one or more contributor license agreements. See the NOTICE file\n+ * distributed with this work for additional information regarding copyright\n+ * ownership. Camunda licenses this file to you under the Apache License,\n+ * Version 2.0; you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.camunda.spin.plugin.impl.feel.integration;\n+\n+import static java.util.stream.Collectors.groupingBy;\n+import static java.util.stream.Collectors.mapping;\n+import static java.util.stream.Collectors.toList;\n+import static java.util.stream.Collectors.toMap;\n+import static scala.jdk.CollectionConverters.ListHasAsScala;\n+\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.function.Function;\n+\n+import org.camunda.feel.impl.spi.JavaCustomValueMapper;\n+import org.camunda.feel.interpreter.impl.Val;\n+import org.camunda.feel.interpreter.impl.ValList;\n+import org.camunda.feel.interpreter.impl.ValString;\n+import org.camunda.spin.json.SpinJsonNode;\n+import org.camunda.spin.xml.SpinXmlAttribute;\n+import org.camunda.spin.xml.SpinXmlElement;\n+import org.camunda.spin.xml.SpinXmlNode;\n+\n+\n+public class CamundaSpinValueMapper extends JavaCustomValueMapper {\n+\n+  @Override\n+  public Optional<Val> toValue(Object x, Function<Object, Val> innerValueMapper) {\n+    if (x instanceof SpinJsonNode) {\n+      SpinJsonNode node = (SpinJsonNode) x;\n+      return Optional.of(this.spinJsonToVal(node, innerValueMapper));\n+\n+    } else if (x instanceof SpinXmlElement) {\n+      SpinXmlElement element = (SpinXmlElement) x;\n+      return Optional.of(this.spinXmlToVal(element, innerValueMapper));\n+\n+    } else {\n+      return Optional.empty();\n+\n+    }\n+  }\n+\n+  @Override\n+  public Optional<Object> unpackValue(Val value, Function<Val, Object> innerValueMapper) {\n+    return Optional.empty();\n+  }\n+\n+  @Override\n+  public int priority() {\n+    return 30;\n+  }\n+\n+  protected Val spinJsonToVal(SpinJsonNode node, Function<Object, Val> innerValueMapper) {\n+    if (node.isObject()) {\n+      Map pairs = node.fieldNames().stream()\n+        .collect(toMap(field -> field, field -> spinJsonToVal(node.prop(field), innerValueMapper)));\n+      return innerValueMapper.apply(pairs);\n+\n+    } else if (node.isArray()) {\n+      List<Val> values = node.elements().stream().map(e -> spinJsonToVal(e, innerValueMapper)).collect(toList());\n+      return new ValList(ListHasAsScala(values).asScala().toList());\n+\n+    } else if (node.isNull()) {\n+      return innerValueMapper.apply(null);\n+\n+    } else {\n+      return innerValueMapper.apply(node.value());\n+\n+    }\n+  }\n+\n+  protected Val spinXmlToVal(SpinXmlElement element, Function<Object, Val> innerValueMapper) {\n+    String name = nodeName(element);\n+    Val value = spinXmlElementToVal(element, innerValueMapper);\n+    Map<String, Object> map = Collections.singletonMap(name, value);\n+\n+    return innerValueMapper.apply(map);\n+  }\n+\n+  protected Val spinXmlElementToVal(final SpinXmlElement e, Function<Object, Val> innerValueMapper) {\n+    Map<String, Object> membersMap = new HashMap<>();\n+    String content = e.textContent().trim();\n+    if (!content.isEmpty()) {\n+      membersMap.put(\"$content\", new ValString(content));\n+    }\n+\n+    Map<String, ValString> attributes = e.attrs().stream().collect(toMap(attr -> spinXmlAttributeToKey(attr), attr -> new ValString(attr.value())));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDgxMTE5NA=="}, "originalCommit": {"oid": "04109966910e194930c7e375dc0bb0a36615924d"}, "originalPosition": 104}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDgxMjEzMg==", "bodyText": "Isn't this::nodeName much more shorter and readable?", "url": "https://github.com/camunda/camunda-bpm-platform/pull/664#discussion_r380812132", "createdAt": "2020-02-18T17:08:56Z", "author": {"login": "tasso94"}, "path": "engine-plugins/spin-plugin/src/main/java/org/camunda/spin/plugin/impl/feel/integration/CamundaSpinValueMapper.java", "diffHunk": "@@ -0,0 +1,144 @@\n+/*\n+ * Copyright Camunda Services GmbH and/or licensed to Camunda Services GmbH\n+ * under one or more contributor license agreements. See the NOTICE file\n+ * distributed with this work for additional information regarding copyright\n+ * ownership. Camunda licenses this file to you under the Apache License,\n+ * Version 2.0; you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.camunda.spin.plugin.impl.feel.integration;\n+\n+import static java.util.stream.Collectors.groupingBy;\n+import static java.util.stream.Collectors.mapping;\n+import static java.util.stream.Collectors.toList;\n+import static java.util.stream.Collectors.toMap;\n+import static scala.jdk.CollectionConverters.ListHasAsScala;\n+\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.function.Function;\n+\n+import org.camunda.feel.impl.spi.JavaCustomValueMapper;\n+import org.camunda.feel.interpreter.impl.Val;\n+import org.camunda.feel.interpreter.impl.ValList;\n+import org.camunda.feel.interpreter.impl.ValString;\n+import org.camunda.spin.json.SpinJsonNode;\n+import org.camunda.spin.xml.SpinXmlAttribute;\n+import org.camunda.spin.xml.SpinXmlElement;\n+import org.camunda.spin.xml.SpinXmlNode;\n+\n+\n+public class CamundaSpinValueMapper extends JavaCustomValueMapper {\n+\n+  @Override\n+  public Optional<Val> toValue(Object x, Function<Object, Val> innerValueMapper) {\n+    if (x instanceof SpinJsonNode) {\n+      SpinJsonNode node = (SpinJsonNode) x;\n+      return Optional.of(this.spinJsonToVal(node, innerValueMapper));\n+\n+    } else if (x instanceof SpinXmlElement) {\n+      SpinXmlElement element = (SpinXmlElement) x;\n+      return Optional.of(this.spinXmlToVal(element, innerValueMapper));\n+\n+    } else {\n+      return Optional.empty();\n+\n+    }\n+  }\n+\n+  @Override\n+  public Optional<Object> unpackValue(Val value, Function<Val, Object> innerValueMapper) {\n+    return Optional.empty();\n+  }\n+\n+  @Override\n+  public int priority() {\n+    return 30;\n+  }\n+\n+  protected Val spinJsonToVal(SpinJsonNode node, Function<Object, Val> innerValueMapper) {\n+    if (node.isObject()) {\n+      Map pairs = node.fieldNames().stream()\n+        .collect(toMap(field -> field, field -> spinJsonToVal(node.prop(field), innerValueMapper)));\n+      return innerValueMapper.apply(pairs);\n+\n+    } else if (node.isArray()) {\n+      List<Val> values = node.elements().stream().map(e -> spinJsonToVal(e, innerValueMapper)).collect(toList());\n+      return new ValList(ListHasAsScala(values).asScala().toList());\n+\n+    } else if (node.isNull()) {\n+      return innerValueMapper.apply(null);\n+\n+    } else {\n+      return innerValueMapper.apply(node.value());\n+\n+    }\n+  }\n+\n+  protected Val spinXmlToVal(SpinXmlElement element, Function<Object, Val> innerValueMapper) {\n+    String name = nodeName(element);\n+    Val value = spinXmlElementToVal(element, innerValueMapper);\n+    Map<String, Object> map = Collections.singletonMap(name, value);\n+\n+    return innerValueMapper.apply(map);\n+  }\n+\n+  protected Val spinXmlElementToVal(final SpinXmlElement e, Function<Object, Val> innerValueMapper) {\n+    Map<String, Object> membersMap = new HashMap<>();\n+    String content = e.textContent().trim();\n+    if (!content.isEmpty()) {\n+      membersMap.put(\"$content\", new ValString(content));\n+    }\n+\n+    Map<String, ValString> attributes = e.attrs().stream().collect(toMap(attr -> spinXmlAttributeToKey(attr), attr -> new ValString(attr.value())));\n+    if (!attributes.isEmpty()) {\n+      membersMap.putAll(attributes);\n+    }\n+\n+    Map<String, Val> childrenMap = e.childElements().stream()\n+     .collect(\n+       groupingBy(\n+         el -> nodeName(el),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "04109966910e194930c7e375dc0bb0a36615924d"}, "originalPosition": 112}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDgxMjQzMw==", "bodyText": "Isn't Map.Entry::getKey much more shorter and readable?", "url": "https://github.com/camunda/camunda-bpm-platform/pull/664#discussion_r380812433", "createdAt": "2020-02-18T17:09:28Z", "author": {"login": "tasso94"}, "path": "engine-plugins/spin-plugin/src/main/java/org/camunda/spin/plugin/impl/feel/integration/CamundaSpinValueMapper.java", "diffHunk": "@@ -0,0 +1,144 @@\n+/*\n+ * Copyright Camunda Services GmbH and/or licensed to Camunda Services GmbH\n+ * under one or more contributor license agreements. See the NOTICE file\n+ * distributed with this work for additional information regarding copyright\n+ * ownership. Camunda licenses this file to you under the Apache License,\n+ * Version 2.0; you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.camunda.spin.plugin.impl.feel.integration;\n+\n+import static java.util.stream.Collectors.groupingBy;\n+import static java.util.stream.Collectors.mapping;\n+import static java.util.stream.Collectors.toList;\n+import static java.util.stream.Collectors.toMap;\n+import static scala.jdk.CollectionConverters.ListHasAsScala;\n+\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.function.Function;\n+\n+import org.camunda.feel.impl.spi.JavaCustomValueMapper;\n+import org.camunda.feel.interpreter.impl.Val;\n+import org.camunda.feel.interpreter.impl.ValList;\n+import org.camunda.feel.interpreter.impl.ValString;\n+import org.camunda.spin.json.SpinJsonNode;\n+import org.camunda.spin.xml.SpinXmlAttribute;\n+import org.camunda.spin.xml.SpinXmlElement;\n+import org.camunda.spin.xml.SpinXmlNode;\n+\n+\n+public class CamundaSpinValueMapper extends JavaCustomValueMapper {\n+\n+  @Override\n+  public Optional<Val> toValue(Object x, Function<Object, Val> innerValueMapper) {\n+    if (x instanceof SpinJsonNode) {\n+      SpinJsonNode node = (SpinJsonNode) x;\n+      return Optional.of(this.spinJsonToVal(node, innerValueMapper));\n+\n+    } else if (x instanceof SpinXmlElement) {\n+      SpinXmlElement element = (SpinXmlElement) x;\n+      return Optional.of(this.spinXmlToVal(element, innerValueMapper));\n+\n+    } else {\n+      return Optional.empty();\n+\n+    }\n+  }\n+\n+  @Override\n+  public Optional<Object> unpackValue(Val value, Function<Val, Object> innerValueMapper) {\n+    return Optional.empty();\n+  }\n+\n+  @Override\n+  public int priority() {\n+    return 30;\n+  }\n+\n+  protected Val spinJsonToVal(SpinJsonNode node, Function<Object, Val> innerValueMapper) {\n+    if (node.isObject()) {\n+      Map pairs = node.fieldNames().stream()\n+        .collect(toMap(field -> field, field -> spinJsonToVal(node.prop(field), innerValueMapper)));\n+      return innerValueMapper.apply(pairs);\n+\n+    } else if (node.isArray()) {\n+      List<Val> values = node.elements().stream().map(e -> spinJsonToVal(e, innerValueMapper)).collect(toList());\n+      return new ValList(ListHasAsScala(values).asScala().toList());\n+\n+    } else if (node.isNull()) {\n+      return innerValueMapper.apply(null);\n+\n+    } else {\n+      return innerValueMapper.apply(node.value());\n+\n+    }\n+  }\n+\n+  protected Val spinXmlToVal(SpinXmlElement element, Function<Object, Val> innerValueMapper) {\n+    String name = nodeName(element);\n+    Val value = spinXmlElementToVal(element, innerValueMapper);\n+    Map<String, Object> map = Collections.singletonMap(name, value);\n+\n+    return innerValueMapper.apply(map);\n+  }\n+\n+  protected Val spinXmlElementToVal(final SpinXmlElement e, Function<Object, Val> innerValueMapper) {\n+    Map<String, Object> membersMap = new HashMap<>();\n+    String content = e.textContent().trim();\n+    if (!content.isEmpty()) {\n+      membersMap.put(\"$content\", new ValString(content));\n+    }\n+\n+    Map<String, ValString> attributes = e.attrs().stream().collect(toMap(attr -> spinXmlAttributeToKey(attr), attr -> new ValString(attr.value())));\n+    if (!attributes.isEmpty()) {\n+      membersMap.putAll(attributes);\n+    }\n+\n+    Map<String, Val> childrenMap = e.childElements().stream()\n+     .collect(\n+       groupingBy(\n+         el -> nodeName(el),\n+         mapping(el -> spinXmlElementToVal(el, innerValueMapper), toList())\n+                 ))\n+     .entrySet().stream()\n+       .collect(toMap(entry -> entry.getKey(), entry -> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "04109966910e194930c7e375dc0bb0a36615924d"}, "originalPosition": 116}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDgxMjcwNw==", "bodyText": "We cannot use unprefixed scala classes due to shading => use camundajar.impl.scala... instead", "url": "https://github.com/camunda/camunda-bpm-platform/pull/664#discussion_r380812707", "createdAt": "2020-02-18T17:09:56Z", "author": {"login": "tasso94"}, "path": "engine-plugins/spin-plugin/src/main/java/org/camunda/spin/plugin/impl/feel/integration/CamundaSpinValueMapper.java", "diffHunk": "@@ -0,0 +1,144 @@\n+/*\n+ * Copyright Camunda Services GmbH and/or licensed to Camunda Services GmbH\n+ * under one or more contributor license agreements. See the NOTICE file\n+ * distributed with this work for additional information regarding copyright\n+ * ownership. Camunda licenses this file to you under the Apache License,\n+ * Version 2.0; you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.camunda.spin.plugin.impl.feel.integration;\n+\n+import static java.util.stream.Collectors.groupingBy;\n+import static java.util.stream.Collectors.mapping;\n+import static java.util.stream.Collectors.toList;\n+import static java.util.stream.Collectors.toMap;\n+import static scala.jdk.CollectionConverters.ListHasAsScala;\n+\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.function.Function;\n+\n+import org.camunda.feel.impl.spi.JavaCustomValueMapper;\n+import org.camunda.feel.interpreter.impl.Val;\n+import org.camunda.feel.interpreter.impl.ValList;\n+import org.camunda.feel.interpreter.impl.ValString;\n+import org.camunda.spin.json.SpinJsonNode;\n+import org.camunda.spin.xml.SpinXmlAttribute;\n+import org.camunda.spin.xml.SpinXmlElement;\n+import org.camunda.spin.xml.SpinXmlNode;\n+\n+\n+public class CamundaSpinValueMapper extends JavaCustomValueMapper {\n+\n+  @Override\n+  public Optional<Val> toValue(Object x, Function<Object, Val> innerValueMapper) {\n+    if (x instanceof SpinJsonNode) {\n+      SpinJsonNode node = (SpinJsonNode) x;\n+      return Optional.of(this.spinJsonToVal(node, innerValueMapper));\n+\n+    } else if (x instanceof SpinXmlElement) {\n+      SpinXmlElement element = (SpinXmlElement) x;\n+      return Optional.of(this.spinXmlToVal(element, innerValueMapper));\n+\n+    } else {\n+      return Optional.empty();\n+\n+    }\n+  }\n+\n+  @Override\n+  public Optional<Object> unpackValue(Val value, Function<Val, Object> innerValueMapper) {\n+    return Optional.empty();\n+  }\n+\n+  @Override\n+  public int priority() {\n+    return 30;\n+  }\n+\n+  protected Val spinJsonToVal(SpinJsonNode node, Function<Object, Val> innerValueMapper) {\n+    if (node.isObject()) {\n+      Map pairs = node.fieldNames().stream()\n+        .collect(toMap(field -> field, field -> spinJsonToVal(node.prop(field), innerValueMapper)));\n+      return innerValueMapper.apply(pairs);\n+\n+    } else if (node.isArray()) {\n+      List<Val> values = node.elements().stream().map(e -> spinJsonToVal(e, innerValueMapper)).collect(toList());\n+      return new ValList(ListHasAsScala(values).asScala().toList());\n+\n+    } else if (node.isNull()) {\n+      return innerValueMapper.apply(null);\n+\n+    } else {\n+      return innerValueMapper.apply(node.value());\n+\n+    }\n+  }\n+\n+  protected Val spinXmlToVal(SpinXmlElement element, Function<Object, Val> innerValueMapper) {\n+    String name = nodeName(element);\n+    Val value = spinXmlElementToVal(element, innerValueMapper);\n+    Map<String, Object> map = Collections.singletonMap(name, value);\n+\n+    return innerValueMapper.apply(map);\n+  }\n+\n+  protected Val spinXmlElementToVal(final SpinXmlElement e, Function<Object, Val> innerValueMapper) {\n+    Map<String, Object> membersMap = new HashMap<>();\n+    String content = e.textContent().trim();\n+    if (!content.isEmpty()) {\n+      membersMap.put(\"$content\", new ValString(content));\n+    }\n+\n+    Map<String, ValString> attributes = e.attrs().stream().collect(toMap(attr -> spinXmlAttributeToKey(attr), attr -> new ValString(attr.value())));\n+    if (!attributes.isEmpty()) {\n+      membersMap.putAll(attributes);\n+    }\n+\n+    Map<String, Val> childrenMap = e.childElements().stream()\n+     .collect(\n+       groupingBy(\n+         el -> nodeName(el),\n+         mapping(el -> spinXmlElementToVal(el, innerValueMapper), toList())\n+                 ))\n+     .entrySet().stream()\n+       .collect(toMap(entry -> entry.getKey(), entry -> {\n+         List<Val> valList = entry.getValue();\n+         if (!valList.isEmpty() && valList.size() > 1) {\n+           scala.collection.immutable.List<Val> vals = ListHasAsScala(valList).asScala().toList();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "04109966910e194930c7e375dc0bb0a36615924d"}, "originalPosition": 119}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDgxNDcyMw==", "bodyText": "Can we change the name of the class to SpinValueMapper?", "url": "https://github.com/camunda/camunda-bpm-platform/pull/664#discussion_r380814723", "createdAt": "2020-02-18T17:13:17Z", "author": {"login": "tasso94"}, "path": "engine-plugins/spin-plugin/src/main/java/org/camunda/spin/plugin/impl/feel/integration/CamundaSpinValueMapper.java", "diffHunk": "@@ -0,0 +1,144 @@\n+/*\n+ * Copyright Camunda Services GmbH and/or licensed to Camunda Services GmbH\n+ * under one or more contributor license agreements. See the NOTICE file\n+ * distributed with this work for additional information regarding copyright\n+ * ownership. Camunda licenses this file to you under the Apache License,\n+ * Version 2.0; you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.camunda.spin.plugin.impl.feel.integration;\n+\n+import static java.util.stream.Collectors.groupingBy;\n+import static java.util.stream.Collectors.mapping;\n+import static java.util.stream.Collectors.toList;\n+import static java.util.stream.Collectors.toMap;\n+import static scala.jdk.CollectionConverters.ListHasAsScala;\n+\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.function.Function;\n+\n+import org.camunda.feel.impl.spi.JavaCustomValueMapper;\n+import org.camunda.feel.interpreter.impl.Val;\n+import org.camunda.feel.interpreter.impl.ValList;\n+import org.camunda.feel.interpreter.impl.ValString;\n+import org.camunda.spin.json.SpinJsonNode;\n+import org.camunda.spin.xml.SpinXmlAttribute;\n+import org.camunda.spin.xml.SpinXmlElement;\n+import org.camunda.spin.xml.SpinXmlNode;\n+\n+\n+public class CamundaSpinValueMapper extends JavaCustomValueMapper {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "04109966910e194930c7e375dc0bb0a36615924d"}, "originalPosition": 42}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2c020117145d020575eba409d3fb320f2b0eb394", "author": {"user": {"login": "koevskinikola", "name": "Nikola Koevski"}}, "url": "https://github.com/camunda/camunda-bpm-platform/commit/2c020117145d020575eba409d3fb320f2b0eb394", "committedDate": "2020-02-19T16:11:42Z", "message": "feat(feel): port spin feel integration from  scala to java\n\n* Port the Spin Integration for the Scala FEEL Engine from Scala to Java;\n* Merge the FEEL Spin Integration module with the Spin Process Engine Plugin module;\n* Port Scala tests to JUnit and add additional integration tests to assert SPI functionality and correct Process/DMN Engine integration.\n\nRelated to CAM-11346"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "04109966910e194930c7e375dc0bb0a36615924d", "author": {"user": {"login": "koevskinikola", "name": "Nikola Koevski"}}, "url": "https://github.com/camunda/camunda-bpm-platform/commit/04109966910e194930c7e375dc0bb0a36615924d", "committedDate": "2020-02-17T16:23:52Z", "message": "feat(feel): port spin feel integration from  scala to java\n\n* Port the Spin Integration for the Scala FEEL Engine from Scala to Java;\n* Merge the FEEL Spin Integration module with the Spin Process Engine Plugin module;\n* Port Scala tests to JUnit and add additional integration tests to assert SPI functionality and correct Process/DMN Engine integration.\n\nRelated to CAM-11346"}, "afterCommit": {"oid": "2c020117145d020575eba409d3fb320f2b0eb394", "author": {"user": {"login": "koevskinikola", "name": "Nikola Koevski"}}, "url": "https://github.com/camunda/camunda-bpm-platform/commit/2c020117145d020575eba409d3fb320f2b0eb394", "committedDate": "2020-02-19T16:11:42Z", "message": "feat(feel): port spin feel integration from  scala to java\n\n* Port the Spin Integration for the Scala FEEL Engine from Scala to Java;\n* Merge the FEEL Spin Integration module with the Spin Process Engine Plugin module;\n* Port Scala tests to JUnit and add additional integration tests to assert SPI functionality and correct Process/DMN Engine integration.\n\nRelated to CAM-11346"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1914, "cost": 1, "resetAt": "2021-11-01T13:07:16Z"}}}