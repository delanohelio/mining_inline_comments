{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzc2MjI0NzEz", "number": 664, "reviewThreads": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xOFQxNzowNDowNVrODgxxwg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xOFQxNzoxMzoxN1rODgx_oQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM1Njk2NTc4OnYy", "diffSide": "RIGHT", "path": "engine-plugins/spin-plugin/src/main/java/org/camunda/spin/plugin/impl/feel/integration/CamundaSpinValueMapper.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xOFQxNzowNDowNVrOFrKvyA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xOVQxMjozMToxNFrOFrmVfQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDgwOTE2MA==", "bodyText": "We cannot use unprefixed scala classes due to shading => use camundajar.impl.scala... instead", "url": "https://github.com/camunda/camunda-bpm-platform/pull/664#discussion_r380809160", "createdAt": "2020-02-18T17:04:05Z", "author": {"login": "tasso94"}, "path": "engine-plugins/spin-plugin/src/main/java/org/camunda/spin/plugin/impl/feel/integration/CamundaSpinValueMapper.java", "diffHunk": "@@ -0,0 +1,144 @@\n+/*\n+ * Copyright Camunda Services GmbH and/or licensed to Camunda Services GmbH\n+ * under one or more contributor license agreements. See the NOTICE file\n+ * distributed with this work for additional information regarding copyright\n+ * ownership. Camunda licenses this file to you under the Apache License,\n+ * Version 2.0; you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.camunda.spin.plugin.impl.feel.integration;\n+\n+import static java.util.stream.Collectors.groupingBy;\n+import static java.util.stream.Collectors.mapping;\n+import static java.util.stream.Collectors.toList;\n+import static java.util.stream.Collectors.toMap;\n+import static scala.jdk.CollectionConverters.ListHasAsScala;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "04109966910e194930c7e375dc0bb0a36615924d"}, "originalPosition": 23}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTI2MTE4MQ==", "bodyText": "I'm using the converter only once, and I can do the same thing with the innerValueMapper, so I'll refactor the code like that and not use a Scala import.", "url": "https://github.com/camunda/camunda-bpm-platform/pull/664#discussion_r381261181", "createdAt": "2020-02-19T12:31:14Z", "author": {"login": "koevskinikola"}, "path": "engine-plugins/spin-plugin/src/main/java/org/camunda/spin/plugin/impl/feel/integration/CamundaSpinValueMapper.java", "diffHunk": "@@ -0,0 +1,144 @@\n+/*\n+ * Copyright Camunda Services GmbH and/or licensed to Camunda Services GmbH\n+ * under one or more contributor license agreements. See the NOTICE file\n+ * distributed with this work for additional information regarding copyright\n+ * ownership. Camunda licenses this file to you under the Apache License,\n+ * Version 2.0; you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.camunda.spin.plugin.impl.feel.integration;\n+\n+import static java.util.stream.Collectors.groupingBy;\n+import static java.util.stream.Collectors.mapping;\n+import static java.util.stream.Collectors.toList;\n+import static java.util.stream.Collectors.toMap;\n+import static scala.jdk.CollectionConverters.ListHasAsScala;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDgwOTE2MA=="}, "originalCommit": {"oid": "04109966910e194930c7e375dc0bb0a36615924d"}, "originalPosition": 23}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM1Njk3Njk5OnYy", "diffSide": "RIGHT", "path": "engine-plugins/spin-plugin/src/main/java/org/camunda/spin/plugin/impl/feel/integration/CamundaSpinValueMapper.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xOFQxNzowNjo0OVrOFrK2eQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xOFQxNzowNjo0OVrOFrK2eQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDgxMDg3Mw==", "bodyText": "Lines of code must not exceed 100 characters", "url": "https://github.com/camunda/camunda-bpm-platform/pull/664#discussion_r380810873", "createdAt": "2020-02-18T17:06:49Z", "author": {"login": "tasso94"}, "path": "engine-plugins/spin-plugin/src/main/java/org/camunda/spin/plugin/impl/feel/integration/CamundaSpinValueMapper.java", "diffHunk": "@@ -0,0 +1,144 @@\n+/*\n+ * Copyright Camunda Services GmbH and/or licensed to Camunda Services GmbH\n+ * under one or more contributor license agreements. See the NOTICE file\n+ * distributed with this work for additional information regarding copyright\n+ * ownership. Camunda licenses this file to you under the Apache License,\n+ * Version 2.0; you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.camunda.spin.plugin.impl.feel.integration;\n+\n+import static java.util.stream.Collectors.groupingBy;\n+import static java.util.stream.Collectors.mapping;\n+import static java.util.stream.Collectors.toList;\n+import static java.util.stream.Collectors.toMap;\n+import static scala.jdk.CollectionConverters.ListHasAsScala;\n+\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.function.Function;\n+\n+import org.camunda.feel.impl.spi.JavaCustomValueMapper;\n+import org.camunda.feel.interpreter.impl.Val;\n+import org.camunda.feel.interpreter.impl.ValList;\n+import org.camunda.feel.interpreter.impl.ValString;\n+import org.camunda.spin.json.SpinJsonNode;\n+import org.camunda.spin.xml.SpinXmlAttribute;\n+import org.camunda.spin.xml.SpinXmlElement;\n+import org.camunda.spin.xml.SpinXmlNode;\n+\n+\n+public class CamundaSpinValueMapper extends JavaCustomValueMapper {\n+\n+  @Override\n+  public Optional<Val> toValue(Object x, Function<Object, Val> innerValueMapper) {\n+    if (x instanceof SpinJsonNode) {\n+      SpinJsonNode node = (SpinJsonNode) x;\n+      return Optional.of(this.spinJsonToVal(node, innerValueMapper));\n+\n+    } else if (x instanceof SpinXmlElement) {\n+      SpinXmlElement element = (SpinXmlElement) x;\n+      return Optional.of(this.spinXmlToVal(element, innerValueMapper));\n+\n+    } else {\n+      return Optional.empty();\n+\n+    }\n+  }\n+\n+  @Override\n+  public Optional<Object> unpackValue(Val value, Function<Val, Object> innerValueMapper) {\n+    return Optional.empty();\n+  }\n+\n+  @Override\n+  public int priority() {\n+    return 30;\n+  }\n+\n+  protected Val spinJsonToVal(SpinJsonNode node, Function<Object, Val> innerValueMapper) {\n+    if (node.isObject()) {\n+      Map pairs = node.fieldNames().stream()\n+        .collect(toMap(field -> field, field -> spinJsonToVal(node.prop(field), innerValueMapper)));\n+      return innerValueMapper.apply(pairs);\n+\n+    } else if (node.isArray()) {\n+      List<Val> values = node.elements().stream().map(e -> spinJsonToVal(e, innerValueMapper)).collect(toList());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "04109966910e194930c7e375dc0bb0a36615924d"}, "originalPosition": 77}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM1Njk3ODUwOnYy", "diffSide": "RIGHT", "path": "engine-plugins/spin-plugin/src/main/java/org/camunda/spin/plugin/impl/feel/integration/CamundaSpinValueMapper.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xOFQxNzowNzoxMlrOFrK3Tw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xOFQxNzowNzoxMlrOFrK3Tw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDgxMTA4Nw==", "bodyText": "Lines of code must not exceed 100 characters", "url": "https://github.com/camunda/camunda-bpm-platform/pull/664#discussion_r380811087", "createdAt": "2020-02-18T17:07:12Z", "author": {"login": "tasso94"}, "path": "engine-plugins/spin-plugin/src/main/java/org/camunda/spin/plugin/impl/feel/integration/CamundaSpinValueMapper.java", "diffHunk": "@@ -0,0 +1,144 @@\n+/*\n+ * Copyright Camunda Services GmbH and/or licensed to Camunda Services GmbH\n+ * under one or more contributor license agreements. See the NOTICE file\n+ * distributed with this work for additional information regarding copyright\n+ * ownership. Camunda licenses this file to you under the Apache License,\n+ * Version 2.0; you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.camunda.spin.plugin.impl.feel.integration;\n+\n+import static java.util.stream.Collectors.groupingBy;\n+import static java.util.stream.Collectors.mapping;\n+import static java.util.stream.Collectors.toList;\n+import static java.util.stream.Collectors.toMap;\n+import static scala.jdk.CollectionConverters.ListHasAsScala;\n+\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.function.Function;\n+\n+import org.camunda.feel.impl.spi.JavaCustomValueMapper;\n+import org.camunda.feel.interpreter.impl.Val;\n+import org.camunda.feel.interpreter.impl.ValList;\n+import org.camunda.feel.interpreter.impl.ValString;\n+import org.camunda.spin.json.SpinJsonNode;\n+import org.camunda.spin.xml.SpinXmlAttribute;\n+import org.camunda.spin.xml.SpinXmlElement;\n+import org.camunda.spin.xml.SpinXmlNode;\n+\n+\n+public class CamundaSpinValueMapper extends JavaCustomValueMapper {\n+\n+  @Override\n+  public Optional<Val> toValue(Object x, Function<Object, Val> innerValueMapper) {\n+    if (x instanceof SpinJsonNode) {\n+      SpinJsonNode node = (SpinJsonNode) x;\n+      return Optional.of(this.spinJsonToVal(node, innerValueMapper));\n+\n+    } else if (x instanceof SpinXmlElement) {\n+      SpinXmlElement element = (SpinXmlElement) x;\n+      return Optional.of(this.spinXmlToVal(element, innerValueMapper));\n+\n+    } else {\n+      return Optional.empty();\n+\n+    }\n+  }\n+\n+  @Override\n+  public Optional<Object> unpackValue(Val value, Function<Val, Object> innerValueMapper) {\n+    return Optional.empty();\n+  }\n+\n+  @Override\n+  public int priority() {\n+    return 30;\n+  }\n+\n+  protected Val spinJsonToVal(SpinJsonNode node, Function<Object, Val> innerValueMapper) {\n+    if (node.isObject()) {\n+      Map pairs = node.fieldNames().stream()\n+        .collect(toMap(field -> field, field -> spinJsonToVal(node.prop(field), innerValueMapper)));\n+      return innerValueMapper.apply(pairs);\n+\n+    } else if (node.isArray()) {\n+      List<Val> values = node.elements().stream().map(e -> spinJsonToVal(e, innerValueMapper)).collect(toList());\n+      return new ValList(ListHasAsScala(values).asScala().toList());\n+\n+    } else if (node.isNull()) {\n+      return innerValueMapper.apply(null);\n+\n+    } else {\n+      return innerValueMapper.apply(node.value());\n+\n+    }\n+  }\n+\n+  protected Val spinXmlToVal(SpinXmlElement element, Function<Object, Val> innerValueMapper) {\n+    String name = nodeName(element);\n+    Val value = spinXmlElementToVal(element, innerValueMapper);\n+    Map<String, Object> map = Collections.singletonMap(name, value);\n+\n+    return innerValueMapper.apply(map);\n+  }\n+\n+  protected Val spinXmlElementToVal(final SpinXmlElement e, Function<Object, Val> innerValueMapper) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "04109966910e194930c7e375dc0bb0a36615924d"}, "originalPosition": 97}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM1Njk3OTI0OnYy", "diffSide": "RIGHT", "path": "engine-plugins/spin-plugin/src/main/java/org/camunda/spin/plugin/impl/feel/integration/CamundaSpinValueMapper.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xOFQxNzowNzoyM1rOFrK3ug==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xOVQxMjozNTo0MVrOFrmczA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDgxMTE5NA==", "bodyText": "Lines of code must not exceed 100 characters", "url": "https://github.com/camunda/camunda-bpm-platform/pull/664#discussion_r380811194", "createdAt": "2020-02-18T17:07:23Z", "author": {"login": "tasso94"}, "path": "engine-plugins/spin-plugin/src/main/java/org/camunda/spin/plugin/impl/feel/integration/CamundaSpinValueMapper.java", "diffHunk": "@@ -0,0 +1,144 @@\n+/*\n+ * Copyright Camunda Services GmbH and/or licensed to Camunda Services GmbH\n+ * under one or more contributor license agreements. See the NOTICE file\n+ * distributed with this work for additional information regarding copyright\n+ * ownership. Camunda licenses this file to you under the Apache License,\n+ * Version 2.0; you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.camunda.spin.plugin.impl.feel.integration;\n+\n+import static java.util.stream.Collectors.groupingBy;\n+import static java.util.stream.Collectors.mapping;\n+import static java.util.stream.Collectors.toList;\n+import static java.util.stream.Collectors.toMap;\n+import static scala.jdk.CollectionConverters.ListHasAsScala;\n+\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.function.Function;\n+\n+import org.camunda.feel.impl.spi.JavaCustomValueMapper;\n+import org.camunda.feel.interpreter.impl.Val;\n+import org.camunda.feel.interpreter.impl.ValList;\n+import org.camunda.feel.interpreter.impl.ValString;\n+import org.camunda.spin.json.SpinJsonNode;\n+import org.camunda.spin.xml.SpinXmlAttribute;\n+import org.camunda.spin.xml.SpinXmlElement;\n+import org.camunda.spin.xml.SpinXmlNode;\n+\n+\n+public class CamundaSpinValueMapper extends JavaCustomValueMapper {\n+\n+  @Override\n+  public Optional<Val> toValue(Object x, Function<Object, Val> innerValueMapper) {\n+    if (x instanceof SpinJsonNode) {\n+      SpinJsonNode node = (SpinJsonNode) x;\n+      return Optional.of(this.spinJsonToVal(node, innerValueMapper));\n+\n+    } else if (x instanceof SpinXmlElement) {\n+      SpinXmlElement element = (SpinXmlElement) x;\n+      return Optional.of(this.spinXmlToVal(element, innerValueMapper));\n+\n+    } else {\n+      return Optional.empty();\n+\n+    }\n+  }\n+\n+  @Override\n+  public Optional<Object> unpackValue(Val value, Function<Val, Object> innerValueMapper) {\n+    return Optional.empty();\n+  }\n+\n+  @Override\n+  public int priority() {\n+    return 30;\n+  }\n+\n+  protected Val spinJsonToVal(SpinJsonNode node, Function<Object, Val> innerValueMapper) {\n+    if (node.isObject()) {\n+      Map pairs = node.fieldNames().stream()\n+        .collect(toMap(field -> field, field -> spinJsonToVal(node.prop(field), innerValueMapper)));\n+      return innerValueMapper.apply(pairs);\n+\n+    } else if (node.isArray()) {\n+      List<Val> values = node.elements().stream().map(e -> spinJsonToVal(e, innerValueMapper)).collect(toList());\n+      return new ValList(ListHasAsScala(values).asScala().toList());\n+\n+    } else if (node.isNull()) {\n+      return innerValueMapper.apply(null);\n+\n+    } else {\n+      return innerValueMapper.apply(node.value());\n+\n+    }\n+  }\n+\n+  protected Val spinXmlToVal(SpinXmlElement element, Function<Object, Val> innerValueMapper) {\n+    String name = nodeName(element);\n+    Val value = spinXmlElementToVal(element, innerValueMapper);\n+    Map<String, Object> map = Collections.singletonMap(name, value);\n+\n+    return innerValueMapper.apply(map);\n+  }\n+\n+  protected Val spinXmlElementToVal(final SpinXmlElement e, Function<Object, Val> innerValueMapper) {\n+    Map<String, Object> membersMap = new HashMap<>();\n+    String content = e.textContent().trim();\n+    if (!content.isEmpty()) {\n+      membersMap.put(\"$content\", new ValString(content));\n+    }\n+\n+    Map<String, ValString> attributes = e.attrs().stream().collect(toMap(attr -> spinXmlAttributeToKey(attr), attr -> new ValString(attr.value())));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "04109966910e194930c7e375dc0bb0a36615924d"}, "originalPosition": 104}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDgxMTc5Nw==", "bodyText": "Isn't this::spinXmlAttributeToKey much more shorter and readable?", "url": "https://github.com/camunda/camunda-bpm-platform/pull/664#discussion_r380811797", "createdAt": "2020-02-18T17:08:21Z", "author": {"login": "tasso94"}, "path": "engine-plugins/spin-plugin/src/main/java/org/camunda/spin/plugin/impl/feel/integration/CamundaSpinValueMapper.java", "diffHunk": "@@ -0,0 +1,144 @@\n+/*\n+ * Copyright Camunda Services GmbH and/or licensed to Camunda Services GmbH\n+ * under one or more contributor license agreements. See the NOTICE file\n+ * distributed with this work for additional information regarding copyright\n+ * ownership. Camunda licenses this file to you under the Apache License,\n+ * Version 2.0; you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.camunda.spin.plugin.impl.feel.integration;\n+\n+import static java.util.stream.Collectors.groupingBy;\n+import static java.util.stream.Collectors.mapping;\n+import static java.util.stream.Collectors.toList;\n+import static java.util.stream.Collectors.toMap;\n+import static scala.jdk.CollectionConverters.ListHasAsScala;\n+\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.function.Function;\n+\n+import org.camunda.feel.impl.spi.JavaCustomValueMapper;\n+import org.camunda.feel.interpreter.impl.Val;\n+import org.camunda.feel.interpreter.impl.ValList;\n+import org.camunda.feel.interpreter.impl.ValString;\n+import org.camunda.spin.json.SpinJsonNode;\n+import org.camunda.spin.xml.SpinXmlAttribute;\n+import org.camunda.spin.xml.SpinXmlElement;\n+import org.camunda.spin.xml.SpinXmlNode;\n+\n+\n+public class CamundaSpinValueMapper extends JavaCustomValueMapper {\n+\n+  @Override\n+  public Optional<Val> toValue(Object x, Function<Object, Val> innerValueMapper) {\n+    if (x instanceof SpinJsonNode) {\n+      SpinJsonNode node = (SpinJsonNode) x;\n+      return Optional.of(this.spinJsonToVal(node, innerValueMapper));\n+\n+    } else if (x instanceof SpinXmlElement) {\n+      SpinXmlElement element = (SpinXmlElement) x;\n+      return Optional.of(this.spinXmlToVal(element, innerValueMapper));\n+\n+    } else {\n+      return Optional.empty();\n+\n+    }\n+  }\n+\n+  @Override\n+  public Optional<Object> unpackValue(Val value, Function<Val, Object> innerValueMapper) {\n+    return Optional.empty();\n+  }\n+\n+  @Override\n+  public int priority() {\n+    return 30;\n+  }\n+\n+  protected Val spinJsonToVal(SpinJsonNode node, Function<Object, Val> innerValueMapper) {\n+    if (node.isObject()) {\n+      Map pairs = node.fieldNames().stream()\n+        .collect(toMap(field -> field, field -> spinJsonToVal(node.prop(field), innerValueMapper)));\n+      return innerValueMapper.apply(pairs);\n+\n+    } else if (node.isArray()) {\n+      List<Val> values = node.elements().stream().map(e -> spinJsonToVal(e, innerValueMapper)).collect(toList());\n+      return new ValList(ListHasAsScala(values).asScala().toList());\n+\n+    } else if (node.isNull()) {\n+      return innerValueMapper.apply(null);\n+\n+    } else {\n+      return innerValueMapper.apply(node.value());\n+\n+    }\n+  }\n+\n+  protected Val spinXmlToVal(SpinXmlElement element, Function<Object, Val> innerValueMapper) {\n+    String name = nodeName(element);\n+    Val value = spinXmlElementToVal(element, innerValueMapper);\n+    Map<String, Object> map = Collections.singletonMap(name, value);\n+\n+    return innerValueMapper.apply(map);\n+  }\n+\n+  protected Val spinXmlElementToVal(final SpinXmlElement e, Function<Object, Val> innerValueMapper) {\n+    Map<String, Object> membersMap = new HashMap<>();\n+    String content = e.textContent().trim();\n+    if (!content.isEmpty()) {\n+      membersMap.put(\"$content\", new ValString(content));\n+    }\n+\n+    Map<String, ValString> attributes = e.attrs().stream().collect(toMap(attr -> spinXmlAttributeToKey(attr), attr -> new ValString(attr.value())));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDgxMTE5NA=="}, "originalCommit": {"oid": "04109966910e194930c7e375dc0bb0a36615924d"}, "originalPosition": 104}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTI2MzA1Mg==", "bodyText": "Yes, you're right, nice catch!", "url": "https://github.com/camunda/camunda-bpm-platform/pull/664#discussion_r381263052", "createdAt": "2020-02-19T12:35:41Z", "author": {"login": "koevskinikola"}, "path": "engine-plugins/spin-plugin/src/main/java/org/camunda/spin/plugin/impl/feel/integration/CamundaSpinValueMapper.java", "diffHunk": "@@ -0,0 +1,144 @@\n+/*\n+ * Copyright Camunda Services GmbH and/or licensed to Camunda Services GmbH\n+ * under one or more contributor license agreements. See the NOTICE file\n+ * distributed with this work for additional information regarding copyright\n+ * ownership. Camunda licenses this file to you under the Apache License,\n+ * Version 2.0; you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.camunda.spin.plugin.impl.feel.integration;\n+\n+import static java.util.stream.Collectors.groupingBy;\n+import static java.util.stream.Collectors.mapping;\n+import static java.util.stream.Collectors.toList;\n+import static java.util.stream.Collectors.toMap;\n+import static scala.jdk.CollectionConverters.ListHasAsScala;\n+\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.function.Function;\n+\n+import org.camunda.feel.impl.spi.JavaCustomValueMapper;\n+import org.camunda.feel.interpreter.impl.Val;\n+import org.camunda.feel.interpreter.impl.ValList;\n+import org.camunda.feel.interpreter.impl.ValString;\n+import org.camunda.spin.json.SpinJsonNode;\n+import org.camunda.spin.xml.SpinXmlAttribute;\n+import org.camunda.spin.xml.SpinXmlElement;\n+import org.camunda.spin.xml.SpinXmlNode;\n+\n+\n+public class CamundaSpinValueMapper extends JavaCustomValueMapper {\n+\n+  @Override\n+  public Optional<Val> toValue(Object x, Function<Object, Val> innerValueMapper) {\n+    if (x instanceof SpinJsonNode) {\n+      SpinJsonNode node = (SpinJsonNode) x;\n+      return Optional.of(this.spinJsonToVal(node, innerValueMapper));\n+\n+    } else if (x instanceof SpinXmlElement) {\n+      SpinXmlElement element = (SpinXmlElement) x;\n+      return Optional.of(this.spinXmlToVal(element, innerValueMapper));\n+\n+    } else {\n+      return Optional.empty();\n+\n+    }\n+  }\n+\n+  @Override\n+  public Optional<Object> unpackValue(Val value, Function<Val, Object> innerValueMapper) {\n+    return Optional.empty();\n+  }\n+\n+  @Override\n+  public int priority() {\n+    return 30;\n+  }\n+\n+  protected Val spinJsonToVal(SpinJsonNode node, Function<Object, Val> innerValueMapper) {\n+    if (node.isObject()) {\n+      Map pairs = node.fieldNames().stream()\n+        .collect(toMap(field -> field, field -> spinJsonToVal(node.prop(field), innerValueMapper)));\n+      return innerValueMapper.apply(pairs);\n+\n+    } else if (node.isArray()) {\n+      List<Val> values = node.elements().stream().map(e -> spinJsonToVal(e, innerValueMapper)).collect(toList());\n+      return new ValList(ListHasAsScala(values).asScala().toList());\n+\n+    } else if (node.isNull()) {\n+      return innerValueMapper.apply(null);\n+\n+    } else {\n+      return innerValueMapper.apply(node.value());\n+\n+    }\n+  }\n+\n+  protected Val spinXmlToVal(SpinXmlElement element, Function<Object, Val> innerValueMapper) {\n+    String name = nodeName(element);\n+    Val value = spinXmlElementToVal(element, innerValueMapper);\n+    Map<String, Object> map = Collections.singletonMap(name, value);\n+\n+    return innerValueMapper.apply(map);\n+  }\n+\n+  protected Val spinXmlElementToVal(final SpinXmlElement e, Function<Object, Val> innerValueMapper) {\n+    Map<String, Object> membersMap = new HashMap<>();\n+    String content = e.textContent().trim();\n+    if (!content.isEmpty()) {\n+      membersMap.put(\"$content\", new ValString(content));\n+    }\n+\n+    Map<String, ValString> attributes = e.attrs().stream().collect(toMap(attr -> spinXmlAttributeToKey(attr), attr -> new ValString(attr.value())));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDgxMTE5NA=="}, "originalCommit": {"oid": "04109966910e194930c7e375dc0bb0a36615924d"}, "originalPosition": 104}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM1Njk4NTI0OnYy", "diffSide": "RIGHT", "path": "engine-plugins/spin-plugin/src/main/java/org/camunda/spin/plugin/impl/feel/integration/CamundaSpinValueMapper.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xOFQxNzowODo1NlrOFrK7ZA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xOFQxNzowODo1NlrOFrK7ZA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDgxMjEzMg==", "bodyText": "Isn't this::nodeName much more shorter and readable?", "url": "https://github.com/camunda/camunda-bpm-platform/pull/664#discussion_r380812132", "createdAt": "2020-02-18T17:08:56Z", "author": {"login": "tasso94"}, "path": "engine-plugins/spin-plugin/src/main/java/org/camunda/spin/plugin/impl/feel/integration/CamundaSpinValueMapper.java", "diffHunk": "@@ -0,0 +1,144 @@\n+/*\n+ * Copyright Camunda Services GmbH and/or licensed to Camunda Services GmbH\n+ * under one or more contributor license agreements. See the NOTICE file\n+ * distributed with this work for additional information regarding copyright\n+ * ownership. Camunda licenses this file to you under the Apache License,\n+ * Version 2.0; you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.camunda.spin.plugin.impl.feel.integration;\n+\n+import static java.util.stream.Collectors.groupingBy;\n+import static java.util.stream.Collectors.mapping;\n+import static java.util.stream.Collectors.toList;\n+import static java.util.stream.Collectors.toMap;\n+import static scala.jdk.CollectionConverters.ListHasAsScala;\n+\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.function.Function;\n+\n+import org.camunda.feel.impl.spi.JavaCustomValueMapper;\n+import org.camunda.feel.interpreter.impl.Val;\n+import org.camunda.feel.interpreter.impl.ValList;\n+import org.camunda.feel.interpreter.impl.ValString;\n+import org.camunda.spin.json.SpinJsonNode;\n+import org.camunda.spin.xml.SpinXmlAttribute;\n+import org.camunda.spin.xml.SpinXmlElement;\n+import org.camunda.spin.xml.SpinXmlNode;\n+\n+\n+public class CamundaSpinValueMapper extends JavaCustomValueMapper {\n+\n+  @Override\n+  public Optional<Val> toValue(Object x, Function<Object, Val> innerValueMapper) {\n+    if (x instanceof SpinJsonNode) {\n+      SpinJsonNode node = (SpinJsonNode) x;\n+      return Optional.of(this.spinJsonToVal(node, innerValueMapper));\n+\n+    } else if (x instanceof SpinXmlElement) {\n+      SpinXmlElement element = (SpinXmlElement) x;\n+      return Optional.of(this.spinXmlToVal(element, innerValueMapper));\n+\n+    } else {\n+      return Optional.empty();\n+\n+    }\n+  }\n+\n+  @Override\n+  public Optional<Object> unpackValue(Val value, Function<Val, Object> innerValueMapper) {\n+    return Optional.empty();\n+  }\n+\n+  @Override\n+  public int priority() {\n+    return 30;\n+  }\n+\n+  protected Val spinJsonToVal(SpinJsonNode node, Function<Object, Val> innerValueMapper) {\n+    if (node.isObject()) {\n+      Map pairs = node.fieldNames().stream()\n+        .collect(toMap(field -> field, field -> spinJsonToVal(node.prop(field), innerValueMapper)));\n+      return innerValueMapper.apply(pairs);\n+\n+    } else if (node.isArray()) {\n+      List<Val> values = node.elements().stream().map(e -> spinJsonToVal(e, innerValueMapper)).collect(toList());\n+      return new ValList(ListHasAsScala(values).asScala().toList());\n+\n+    } else if (node.isNull()) {\n+      return innerValueMapper.apply(null);\n+\n+    } else {\n+      return innerValueMapper.apply(node.value());\n+\n+    }\n+  }\n+\n+  protected Val spinXmlToVal(SpinXmlElement element, Function<Object, Val> innerValueMapper) {\n+    String name = nodeName(element);\n+    Val value = spinXmlElementToVal(element, innerValueMapper);\n+    Map<String, Object> map = Collections.singletonMap(name, value);\n+\n+    return innerValueMapper.apply(map);\n+  }\n+\n+  protected Val spinXmlElementToVal(final SpinXmlElement e, Function<Object, Val> innerValueMapper) {\n+    Map<String, Object> membersMap = new HashMap<>();\n+    String content = e.textContent().trim();\n+    if (!content.isEmpty()) {\n+      membersMap.put(\"$content\", new ValString(content));\n+    }\n+\n+    Map<String, ValString> attributes = e.attrs().stream().collect(toMap(attr -> spinXmlAttributeToKey(attr), attr -> new ValString(attr.value())));\n+    if (!attributes.isEmpty()) {\n+      membersMap.putAll(attributes);\n+    }\n+\n+    Map<String, Val> childrenMap = e.childElements().stream()\n+     .collect(\n+       groupingBy(\n+         el -> nodeName(el),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "04109966910e194930c7e375dc0bb0a36615924d"}, "originalPosition": 112}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM1Njk4NzA0OnYy", "diffSide": "RIGHT", "path": "engine-plugins/spin-plugin/src/main/java/org/camunda/spin/plugin/impl/feel/integration/CamundaSpinValueMapper.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xOFQxNzowOToyOFrOFrK8kQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xOVQxMjo0NjowOFrOFrmvGA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDgxMjQzMw==", "bodyText": "Isn't Map.Entry::getKey much more shorter and readable?", "url": "https://github.com/camunda/camunda-bpm-platform/pull/664#discussion_r380812433", "createdAt": "2020-02-18T17:09:28Z", "author": {"login": "tasso94"}, "path": "engine-plugins/spin-plugin/src/main/java/org/camunda/spin/plugin/impl/feel/integration/CamundaSpinValueMapper.java", "diffHunk": "@@ -0,0 +1,144 @@\n+/*\n+ * Copyright Camunda Services GmbH and/or licensed to Camunda Services GmbH\n+ * under one or more contributor license agreements. See the NOTICE file\n+ * distributed with this work for additional information regarding copyright\n+ * ownership. Camunda licenses this file to you under the Apache License,\n+ * Version 2.0; you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.camunda.spin.plugin.impl.feel.integration;\n+\n+import static java.util.stream.Collectors.groupingBy;\n+import static java.util.stream.Collectors.mapping;\n+import static java.util.stream.Collectors.toList;\n+import static java.util.stream.Collectors.toMap;\n+import static scala.jdk.CollectionConverters.ListHasAsScala;\n+\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.function.Function;\n+\n+import org.camunda.feel.impl.spi.JavaCustomValueMapper;\n+import org.camunda.feel.interpreter.impl.Val;\n+import org.camunda.feel.interpreter.impl.ValList;\n+import org.camunda.feel.interpreter.impl.ValString;\n+import org.camunda.spin.json.SpinJsonNode;\n+import org.camunda.spin.xml.SpinXmlAttribute;\n+import org.camunda.spin.xml.SpinXmlElement;\n+import org.camunda.spin.xml.SpinXmlNode;\n+\n+\n+public class CamundaSpinValueMapper extends JavaCustomValueMapper {\n+\n+  @Override\n+  public Optional<Val> toValue(Object x, Function<Object, Val> innerValueMapper) {\n+    if (x instanceof SpinJsonNode) {\n+      SpinJsonNode node = (SpinJsonNode) x;\n+      return Optional.of(this.spinJsonToVal(node, innerValueMapper));\n+\n+    } else if (x instanceof SpinXmlElement) {\n+      SpinXmlElement element = (SpinXmlElement) x;\n+      return Optional.of(this.spinXmlToVal(element, innerValueMapper));\n+\n+    } else {\n+      return Optional.empty();\n+\n+    }\n+  }\n+\n+  @Override\n+  public Optional<Object> unpackValue(Val value, Function<Val, Object> innerValueMapper) {\n+    return Optional.empty();\n+  }\n+\n+  @Override\n+  public int priority() {\n+    return 30;\n+  }\n+\n+  protected Val spinJsonToVal(SpinJsonNode node, Function<Object, Val> innerValueMapper) {\n+    if (node.isObject()) {\n+      Map pairs = node.fieldNames().stream()\n+        .collect(toMap(field -> field, field -> spinJsonToVal(node.prop(field), innerValueMapper)));\n+      return innerValueMapper.apply(pairs);\n+\n+    } else if (node.isArray()) {\n+      List<Val> values = node.elements().stream().map(e -> spinJsonToVal(e, innerValueMapper)).collect(toList());\n+      return new ValList(ListHasAsScala(values).asScala().toList());\n+\n+    } else if (node.isNull()) {\n+      return innerValueMapper.apply(null);\n+\n+    } else {\n+      return innerValueMapper.apply(node.value());\n+\n+    }\n+  }\n+\n+  protected Val spinXmlToVal(SpinXmlElement element, Function<Object, Val> innerValueMapper) {\n+    String name = nodeName(element);\n+    Val value = spinXmlElementToVal(element, innerValueMapper);\n+    Map<String, Object> map = Collections.singletonMap(name, value);\n+\n+    return innerValueMapper.apply(map);\n+  }\n+\n+  protected Val spinXmlElementToVal(final SpinXmlElement e, Function<Object, Val> innerValueMapper) {\n+    Map<String, Object> membersMap = new HashMap<>();\n+    String content = e.textContent().trim();\n+    if (!content.isEmpty()) {\n+      membersMap.put(\"$content\", new ValString(content));\n+    }\n+\n+    Map<String, ValString> attributes = e.attrs().stream().collect(toMap(attr -> spinXmlAttributeToKey(attr), attr -> new ValString(attr.value())));\n+    if (!attributes.isEmpty()) {\n+      membersMap.putAll(attributes);\n+    }\n+\n+    Map<String, Val> childrenMap = e.childElements().stream()\n+     .collect(\n+       groupingBy(\n+         el -> nodeName(el),\n+         mapping(el -> spinXmlElementToVal(el, innerValueMapper), toList())\n+                 ))\n+     .entrySet().stream()\n+       .collect(toMap(entry -> entry.getKey(), entry -> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "04109966910e194930c7e375dc0bb0a36615924d"}, "originalPosition": 116}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTI2NzczNg==", "bodyText": "Good catch, thanks! I keep forgetting about method references, I'll be more careful next time.", "url": "https://github.com/camunda/camunda-bpm-platform/pull/664#discussion_r381267736", "createdAt": "2020-02-19T12:46:08Z", "author": {"login": "koevskinikola"}, "path": "engine-plugins/spin-plugin/src/main/java/org/camunda/spin/plugin/impl/feel/integration/CamundaSpinValueMapper.java", "diffHunk": "@@ -0,0 +1,144 @@\n+/*\n+ * Copyright Camunda Services GmbH and/or licensed to Camunda Services GmbH\n+ * under one or more contributor license agreements. See the NOTICE file\n+ * distributed with this work for additional information regarding copyright\n+ * ownership. Camunda licenses this file to you under the Apache License,\n+ * Version 2.0; you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.camunda.spin.plugin.impl.feel.integration;\n+\n+import static java.util.stream.Collectors.groupingBy;\n+import static java.util.stream.Collectors.mapping;\n+import static java.util.stream.Collectors.toList;\n+import static java.util.stream.Collectors.toMap;\n+import static scala.jdk.CollectionConverters.ListHasAsScala;\n+\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.function.Function;\n+\n+import org.camunda.feel.impl.spi.JavaCustomValueMapper;\n+import org.camunda.feel.interpreter.impl.Val;\n+import org.camunda.feel.interpreter.impl.ValList;\n+import org.camunda.feel.interpreter.impl.ValString;\n+import org.camunda.spin.json.SpinJsonNode;\n+import org.camunda.spin.xml.SpinXmlAttribute;\n+import org.camunda.spin.xml.SpinXmlElement;\n+import org.camunda.spin.xml.SpinXmlNode;\n+\n+\n+public class CamundaSpinValueMapper extends JavaCustomValueMapper {\n+\n+  @Override\n+  public Optional<Val> toValue(Object x, Function<Object, Val> innerValueMapper) {\n+    if (x instanceof SpinJsonNode) {\n+      SpinJsonNode node = (SpinJsonNode) x;\n+      return Optional.of(this.spinJsonToVal(node, innerValueMapper));\n+\n+    } else if (x instanceof SpinXmlElement) {\n+      SpinXmlElement element = (SpinXmlElement) x;\n+      return Optional.of(this.spinXmlToVal(element, innerValueMapper));\n+\n+    } else {\n+      return Optional.empty();\n+\n+    }\n+  }\n+\n+  @Override\n+  public Optional<Object> unpackValue(Val value, Function<Val, Object> innerValueMapper) {\n+    return Optional.empty();\n+  }\n+\n+  @Override\n+  public int priority() {\n+    return 30;\n+  }\n+\n+  protected Val spinJsonToVal(SpinJsonNode node, Function<Object, Val> innerValueMapper) {\n+    if (node.isObject()) {\n+      Map pairs = node.fieldNames().stream()\n+        .collect(toMap(field -> field, field -> spinJsonToVal(node.prop(field), innerValueMapper)));\n+      return innerValueMapper.apply(pairs);\n+\n+    } else if (node.isArray()) {\n+      List<Val> values = node.elements().stream().map(e -> spinJsonToVal(e, innerValueMapper)).collect(toList());\n+      return new ValList(ListHasAsScala(values).asScala().toList());\n+\n+    } else if (node.isNull()) {\n+      return innerValueMapper.apply(null);\n+\n+    } else {\n+      return innerValueMapper.apply(node.value());\n+\n+    }\n+  }\n+\n+  protected Val spinXmlToVal(SpinXmlElement element, Function<Object, Val> innerValueMapper) {\n+    String name = nodeName(element);\n+    Val value = spinXmlElementToVal(element, innerValueMapper);\n+    Map<String, Object> map = Collections.singletonMap(name, value);\n+\n+    return innerValueMapper.apply(map);\n+  }\n+\n+  protected Val spinXmlElementToVal(final SpinXmlElement e, Function<Object, Val> innerValueMapper) {\n+    Map<String, Object> membersMap = new HashMap<>();\n+    String content = e.textContent().trim();\n+    if (!content.isEmpty()) {\n+      membersMap.put(\"$content\", new ValString(content));\n+    }\n+\n+    Map<String, ValString> attributes = e.attrs().stream().collect(toMap(attr -> spinXmlAttributeToKey(attr), attr -> new ValString(attr.value())));\n+    if (!attributes.isEmpty()) {\n+      membersMap.putAll(attributes);\n+    }\n+\n+    Map<String, Val> childrenMap = e.childElements().stream()\n+     .collect(\n+       groupingBy(\n+         el -> nodeName(el),\n+         mapping(el -> spinXmlElementToVal(el, innerValueMapper), toList())\n+                 ))\n+     .entrySet().stream()\n+       .collect(toMap(entry -> entry.getKey(), entry -> {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDgxMjQzMw=="}, "originalCommit": {"oid": "04109966910e194930c7e375dc0bb0a36615924d"}, "originalPosition": 116}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM1Njk4ODc5OnYy", "diffSide": "RIGHT", "path": "engine-plugins/spin-plugin/src/main/java/org/camunda/spin/plugin/impl/feel/integration/CamundaSpinValueMapper.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xOFQxNzowOTo1NlrOFrK9ow==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xOVQxMjo0OToxOVrOFrm0kg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDgxMjcwNw==", "bodyText": "We cannot use unprefixed scala classes due to shading => use camundajar.impl.scala... instead", "url": "https://github.com/camunda/camunda-bpm-platform/pull/664#discussion_r380812707", "createdAt": "2020-02-18T17:09:56Z", "author": {"login": "tasso94"}, "path": "engine-plugins/spin-plugin/src/main/java/org/camunda/spin/plugin/impl/feel/integration/CamundaSpinValueMapper.java", "diffHunk": "@@ -0,0 +1,144 @@\n+/*\n+ * Copyright Camunda Services GmbH and/or licensed to Camunda Services GmbH\n+ * under one or more contributor license agreements. See the NOTICE file\n+ * distributed with this work for additional information regarding copyright\n+ * ownership. Camunda licenses this file to you under the Apache License,\n+ * Version 2.0; you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.camunda.spin.plugin.impl.feel.integration;\n+\n+import static java.util.stream.Collectors.groupingBy;\n+import static java.util.stream.Collectors.mapping;\n+import static java.util.stream.Collectors.toList;\n+import static java.util.stream.Collectors.toMap;\n+import static scala.jdk.CollectionConverters.ListHasAsScala;\n+\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.function.Function;\n+\n+import org.camunda.feel.impl.spi.JavaCustomValueMapper;\n+import org.camunda.feel.interpreter.impl.Val;\n+import org.camunda.feel.interpreter.impl.ValList;\n+import org.camunda.feel.interpreter.impl.ValString;\n+import org.camunda.spin.json.SpinJsonNode;\n+import org.camunda.spin.xml.SpinXmlAttribute;\n+import org.camunda.spin.xml.SpinXmlElement;\n+import org.camunda.spin.xml.SpinXmlNode;\n+\n+\n+public class CamundaSpinValueMapper extends JavaCustomValueMapper {\n+\n+  @Override\n+  public Optional<Val> toValue(Object x, Function<Object, Val> innerValueMapper) {\n+    if (x instanceof SpinJsonNode) {\n+      SpinJsonNode node = (SpinJsonNode) x;\n+      return Optional.of(this.spinJsonToVal(node, innerValueMapper));\n+\n+    } else if (x instanceof SpinXmlElement) {\n+      SpinXmlElement element = (SpinXmlElement) x;\n+      return Optional.of(this.spinXmlToVal(element, innerValueMapper));\n+\n+    } else {\n+      return Optional.empty();\n+\n+    }\n+  }\n+\n+  @Override\n+  public Optional<Object> unpackValue(Val value, Function<Val, Object> innerValueMapper) {\n+    return Optional.empty();\n+  }\n+\n+  @Override\n+  public int priority() {\n+    return 30;\n+  }\n+\n+  protected Val spinJsonToVal(SpinJsonNode node, Function<Object, Val> innerValueMapper) {\n+    if (node.isObject()) {\n+      Map pairs = node.fieldNames().stream()\n+        .collect(toMap(field -> field, field -> spinJsonToVal(node.prop(field), innerValueMapper)));\n+      return innerValueMapper.apply(pairs);\n+\n+    } else if (node.isArray()) {\n+      List<Val> values = node.elements().stream().map(e -> spinJsonToVal(e, innerValueMapper)).collect(toList());\n+      return new ValList(ListHasAsScala(values).asScala().toList());\n+\n+    } else if (node.isNull()) {\n+      return innerValueMapper.apply(null);\n+\n+    } else {\n+      return innerValueMapper.apply(node.value());\n+\n+    }\n+  }\n+\n+  protected Val spinXmlToVal(SpinXmlElement element, Function<Object, Val> innerValueMapper) {\n+    String name = nodeName(element);\n+    Val value = spinXmlElementToVal(element, innerValueMapper);\n+    Map<String, Object> map = Collections.singletonMap(name, value);\n+\n+    return innerValueMapper.apply(map);\n+  }\n+\n+  protected Val spinXmlElementToVal(final SpinXmlElement e, Function<Object, Val> innerValueMapper) {\n+    Map<String, Object> membersMap = new HashMap<>();\n+    String content = e.textContent().trim();\n+    if (!content.isEmpty()) {\n+      membersMap.put(\"$content\", new ValString(content));\n+    }\n+\n+    Map<String, ValString> attributes = e.attrs().stream().collect(toMap(attr -> spinXmlAttributeToKey(attr), attr -> new ValString(attr.value())));\n+    if (!attributes.isEmpty()) {\n+      membersMap.putAll(attributes);\n+    }\n+\n+    Map<String, Val> childrenMap = e.childElements().stream()\n+     .collect(\n+       groupingBy(\n+         el -> nodeName(el),\n+         mapping(el -> spinXmlElementToVal(el, innerValueMapper), toList())\n+                 ))\n+     .entrySet().stream()\n+       .collect(toMap(entry -> entry.getKey(), entry -> {\n+         List<Val> valList = entry.getValue();\n+         if (!valList.isEmpty() && valList.size() > 1) {\n+           scala.collection.immutable.List<Val> vals = ListHasAsScala(valList).asScala().toList();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "04109966910e194930c7e375dc0bb0a36615924d"}, "originalPosition": 119}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTI2OTEzOA==", "bodyText": "Yes, as I mentioned here, I'll refactor the code, so that the import is not needed.", "url": "https://github.com/camunda/camunda-bpm-platform/pull/664#discussion_r381269138", "createdAt": "2020-02-19T12:49:19Z", "author": {"login": "koevskinikola"}, "path": "engine-plugins/spin-plugin/src/main/java/org/camunda/spin/plugin/impl/feel/integration/CamundaSpinValueMapper.java", "diffHunk": "@@ -0,0 +1,144 @@\n+/*\n+ * Copyright Camunda Services GmbH and/or licensed to Camunda Services GmbH\n+ * under one or more contributor license agreements. See the NOTICE file\n+ * distributed with this work for additional information regarding copyright\n+ * ownership. Camunda licenses this file to you under the Apache License,\n+ * Version 2.0; you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.camunda.spin.plugin.impl.feel.integration;\n+\n+import static java.util.stream.Collectors.groupingBy;\n+import static java.util.stream.Collectors.mapping;\n+import static java.util.stream.Collectors.toList;\n+import static java.util.stream.Collectors.toMap;\n+import static scala.jdk.CollectionConverters.ListHasAsScala;\n+\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.function.Function;\n+\n+import org.camunda.feel.impl.spi.JavaCustomValueMapper;\n+import org.camunda.feel.interpreter.impl.Val;\n+import org.camunda.feel.interpreter.impl.ValList;\n+import org.camunda.feel.interpreter.impl.ValString;\n+import org.camunda.spin.json.SpinJsonNode;\n+import org.camunda.spin.xml.SpinXmlAttribute;\n+import org.camunda.spin.xml.SpinXmlElement;\n+import org.camunda.spin.xml.SpinXmlNode;\n+\n+\n+public class CamundaSpinValueMapper extends JavaCustomValueMapper {\n+\n+  @Override\n+  public Optional<Val> toValue(Object x, Function<Object, Val> innerValueMapper) {\n+    if (x instanceof SpinJsonNode) {\n+      SpinJsonNode node = (SpinJsonNode) x;\n+      return Optional.of(this.spinJsonToVal(node, innerValueMapper));\n+\n+    } else if (x instanceof SpinXmlElement) {\n+      SpinXmlElement element = (SpinXmlElement) x;\n+      return Optional.of(this.spinXmlToVal(element, innerValueMapper));\n+\n+    } else {\n+      return Optional.empty();\n+\n+    }\n+  }\n+\n+  @Override\n+  public Optional<Object> unpackValue(Val value, Function<Val, Object> innerValueMapper) {\n+    return Optional.empty();\n+  }\n+\n+  @Override\n+  public int priority() {\n+    return 30;\n+  }\n+\n+  protected Val spinJsonToVal(SpinJsonNode node, Function<Object, Val> innerValueMapper) {\n+    if (node.isObject()) {\n+      Map pairs = node.fieldNames().stream()\n+        .collect(toMap(field -> field, field -> spinJsonToVal(node.prop(field), innerValueMapper)));\n+      return innerValueMapper.apply(pairs);\n+\n+    } else if (node.isArray()) {\n+      List<Val> values = node.elements().stream().map(e -> spinJsonToVal(e, innerValueMapper)).collect(toList());\n+      return new ValList(ListHasAsScala(values).asScala().toList());\n+\n+    } else if (node.isNull()) {\n+      return innerValueMapper.apply(null);\n+\n+    } else {\n+      return innerValueMapper.apply(node.value());\n+\n+    }\n+  }\n+\n+  protected Val spinXmlToVal(SpinXmlElement element, Function<Object, Val> innerValueMapper) {\n+    String name = nodeName(element);\n+    Val value = spinXmlElementToVal(element, innerValueMapper);\n+    Map<String, Object> map = Collections.singletonMap(name, value);\n+\n+    return innerValueMapper.apply(map);\n+  }\n+\n+  protected Val spinXmlElementToVal(final SpinXmlElement e, Function<Object, Val> innerValueMapper) {\n+    Map<String, Object> membersMap = new HashMap<>();\n+    String content = e.textContent().trim();\n+    if (!content.isEmpty()) {\n+      membersMap.put(\"$content\", new ValString(content));\n+    }\n+\n+    Map<String, ValString> attributes = e.attrs().stream().collect(toMap(attr -> spinXmlAttributeToKey(attr), attr -> new ValString(attr.value())));\n+    if (!attributes.isEmpty()) {\n+      membersMap.putAll(attributes);\n+    }\n+\n+    Map<String, Val> childrenMap = e.childElements().stream()\n+     .collect(\n+       groupingBy(\n+         el -> nodeName(el),\n+         mapping(el -> spinXmlElementToVal(el, innerValueMapper), toList())\n+                 ))\n+     .entrySet().stream()\n+       .collect(toMap(entry -> entry.getKey(), entry -> {\n+         List<Val> valList = entry.getValue();\n+         if (!valList.isEmpty() && valList.size() > 1) {\n+           scala.collection.immutable.List<Val> vals = ListHasAsScala(valList).asScala().toList();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDgxMjcwNw=="}, "originalCommit": {"oid": "04109966910e194930c7e375dc0bb0a36615924d"}, "originalPosition": 119}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM1NzAwMTI5OnYy", "diffSide": "RIGHT", "path": "engine-plugins/spin-plugin/src/main/java/org/camunda/spin/plugin/impl/feel/integration/CamundaSpinValueMapper.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xOFQxNzoxMzoxN1rOFrLFgw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xOVQxMjoyOTo1M1rOFrmSxQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDgxNDcyMw==", "bodyText": "Can we change the name of the class to SpinValueMapper?", "url": "https://github.com/camunda/camunda-bpm-platform/pull/664#discussion_r380814723", "createdAt": "2020-02-18T17:13:17Z", "author": {"login": "tasso94"}, "path": "engine-plugins/spin-plugin/src/main/java/org/camunda/spin/plugin/impl/feel/integration/CamundaSpinValueMapper.java", "diffHunk": "@@ -0,0 +1,144 @@\n+/*\n+ * Copyright Camunda Services GmbH and/or licensed to Camunda Services GmbH\n+ * under one or more contributor license agreements. See the NOTICE file\n+ * distributed with this work for additional information regarding copyright\n+ * ownership. Camunda licenses this file to you under the Apache License,\n+ * Version 2.0; you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.camunda.spin.plugin.impl.feel.integration;\n+\n+import static java.util.stream.Collectors.groupingBy;\n+import static java.util.stream.Collectors.mapping;\n+import static java.util.stream.Collectors.toList;\n+import static java.util.stream.Collectors.toMap;\n+import static scala.jdk.CollectionConverters.ListHasAsScala;\n+\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.function.Function;\n+\n+import org.camunda.feel.impl.spi.JavaCustomValueMapper;\n+import org.camunda.feel.interpreter.impl.Val;\n+import org.camunda.feel.interpreter.impl.ValList;\n+import org.camunda.feel.interpreter.impl.ValString;\n+import org.camunda.spin.json.SpinJsonNode;\n+import org.camunda.spin.xml.SpinXmlAttribute;\n+import org.camunda.spin.xml.SpinXmlElement;\n+import org.camunda.spin.xml.SpinXmlNode;\n+\n+\n+public class CamundaSpinValueMapper extends JavaCustomValueMapper {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "04109966910e194930c7e375dc0bb0a36615924d"}, "originalPosition": 42}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTI2MDQ4NQ==", "bodyText": "Sure, makes more sense without the prefix.", "url": "https://github.com/camunda/camunda-bpm-platform/pull/664#discussion_r381260485", "createdAt": "2020-02-19T12:29:53Z", "author": {"login": "koevskinikola"}, "path": "engine-plugins/spin-plugin/src/main/java/org/camunda/spin/plugin/impl/feel/integration/CamundaSpinValueMapper.java", "diffHunk": "@@ -0,0 +1,144 @@\n+/*\n+ * Copyright Camunda Services GmbH and/or licensed to Camunda Services GmbH\n+ * under one or more contributor license agreements. See the NOTICE file\n+ * distributed with this work for additional information regarding copyright\n+ * ownership. Camunda licenses this file to you under the Apache License,\n+ * Version 2.0; you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.camunda.spin.plugin.impl.feel.integration;\n+\n+import static java.util.stream.Collectors.groupingBy;\n+import static java.util.stream.Collectors.mapping;\n+import static java.util.stream.Collectors.toList;\n+import static java.util.stream.Collectors.toMap;\n+import static scala.jdk.CollectionConverters.ListHasAsScala;\n+\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.function.Function;\n+\n+import org.camunda.feel.impl.spi.JavaCustomValueMapper;\n+import org.camunda.feel.interpreter.impl.Val;\n+import org.camunda.feel.interpreter.impl.ValList;\n+import org.camunda.feel.interpreter.impl.ValString;\n+import org.camunda.spin.json.SpinJsonNode;\n+import org.camunda.spin.xml.SpinXmlAttribute;\n+import org.camunda.spin.xml.SpinXmlElement;\n+import org.camunda.spin.xml.SpinXmlNode;\n+\n+\n+public class CamundaSpinValueMapper extends JavaCustomValueMapper {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDgxNDcyMw=="}, "originalCommit": {"oid": "04109966910e194930c7e375dc0bb0a36615924d"}, "originalPosition": 42}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4646, "cost": 1, "resetAt": "2021-11-12T18:49:56Z"}}}