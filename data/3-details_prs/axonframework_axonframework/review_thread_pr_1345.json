{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzc0MzkxNzMw", "number": 1345, "reviewThreads": {"totalCount": 21, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xNVQxOTo0NTo1N1rODgLJ7w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xNVQyMToyNzoxN1rODgLZ8g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM1MDYzNzkxOnYy", "diffSide": "RIGHT", "path": "axon-server-connector/src/main/java/org/axonframework/axonserver/connector/command/AxonServerCommandBus.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xNVQxOTo0NTo1N1rOFqQU0w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xN1QwOTowNDoyM1rOFqcwNw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTg1MTk4Nw==", "bodyText": "Suggestion: rename to ifShuttingDown, similar to Optional's ifPresent(...) method.", "url": "https://github.com/AxonFramework/AxonFramework/pull/1345#discussion_r379851987", "createdAt": "2020-02-15T19:45:57Z", "author": {"login": "abuijze"}, "path": "axon-server-connector/src/main/java/org/axonframework/axonserver/connector/command/AxonServerCommandBus.java", "diffHunk": "@@ -276,6 +283,10 @@ private void unsubscribe() {\n \n     private <C, R> void doDispatch(CommandMessage<C> commandMessage,\n                                    CommandCallback<? super C, ? super R> commandCallback) {\n+        shutdownLatch.isShuttingDown(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2ef829cce30a13105fe9c1d1398f2e0141393a13"}, "originalPosition": 71}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDA1NTYwNw==", "bodyText": "Good call, will do.", "url": "https://github.com/AxonFramework/AxonFramework/pull/1345#discussion_r380055607", "createdAt": "2020-02-17T09:04:23Z", "author": {"login": "smcvb"}, "path": "axon-server-connector/src/main/java/org/axonframework/axonserver/connector/command/AxonServerCommandBus.java", "diffHunk": "@@ -276,6 +283,10 @@ private void unsubscribe() {\n \n     private <C, R> void doDispatch(CommandMessage<C> commandMessage,\n                                    CommandCallback<? super C, ? super R> commandCallback) {\n+        shutdownLatch.isShuttingDown(", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTg1MTk4Nw=="}, "originalCommit": {"oid": "2ef829cce30a13105fe9c1d1398f2e0141393a13"}, "originalPosition": 71}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM1MDYzOTI3OnYy", "diffSide": "RIGHT", "path": "axon-server-connector/src/main/java/org/axonframework/axonserver/connector/command/AxonServerCommandBus.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xNVQxOTo0OTo0M1rOFqQVig==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xN1QwOToxMDozOFrOFqc7gQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTg1MjE3MA==", "bodyText": "the names increment and decrement don't seem to make much sense when reading the code. What about names like registerActivityStart, and finishActivityEnd? They're not perfect (open to better suggestions), but make more sense in the context of a shutdown latch.", "url": "https://github.com/AxonFramework/AxonFramework/pull/1345#discussion_r379852170", "createdAt": "2020-02-15T19:49:43Z", "author": {"login": "abuijze"}, "path": "axon-server-connector/src/main/java/org/axonframework/axonserver/connector/command/AxonServerCommandBus.java", "diffHunk": "@@ -325,9 +337,11 @@ public void onCompleted() {\n                                                   ErrorCode.COMMAND_DISPATCH_ERROR.convert(errorMessage))\n                                           );\n                                       }\n+                                      shutdownLatch.decrement();\n                                   }\n                               }\n                     );\n+            shutdownLatch.increment();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2ef829cce30a13105fe9c1d1398f2e0141393a13"}, "originalPosition": 94}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTg1MjI5Nw==", "bodyText": "Also, the increment may possibly be invoked before the decrement in this setup. Make sure increment is called before. The thing above that could cause trouble is acquiring the channel. I suggest moving that to a separate line, 'increment' therafter and then call the stub.\nTo be really safe (even without moving the channel acquisition), you can wrap the code in a try-catch, and have the catch decrement and rethrow.", "url": "https://github.com/AxonFramework/AxonFramework/pull/1345#discussion_r379852297", "createdAt": "2020-02-15T19:52:10Z", "author": {"login": "abuijze"}, "path": "axon-server-connector/src/main/java/org/axonframework/axonserver/connector/command/AxonServerCommandBus.java", "diffHunk": "@@ -325,9 +337,11 @@ public void onCompleted() {\n                                                   ErrorCode.COMMAND_DISPATCH_ERROR.convert(errorMessage))\n                                           );\n                                       }\n+                                      shutdownLatch.decrement();\n                                   }\n                               }\n                     );\n+            shutdownLatch.increment();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTg1MjE3MA=="}, "originalCommit": {"oid": "2ef829cce30a13105fe9c1d1398f2e0141393a13"}, "originalPosition": 94}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDA1ODQ5Nw==", "bodyText": "Already was in doubt about the method naming; personally I was playing with \"operation\" rather than \"activity\". Renamed the methods to registerOperation and deregisterOperation.\nAnd good call on the point in time when calling increment/registerOperation. Moved this to before try statement. Also added deregister in the catch block.", "url": "https://github.com/AxonFramework/AxonFramework/pull/1345#discussion_r380058497", "createdAt": "2020-02-17T09:10:38Z", "author": {"login": "smcvb"}, "path": "axon-server-connector/src/main/java/org/axonframework/axonserver/connector/command/AxonServerCommandBus.java", "diffHunk": "@@ -325,9 +337,11 @@ public void onCompleted() {\n                                                   ErrorCode.COMMAND_DISPATCH_ERROR.convert(errorMessage))\n                                           );\n                                       }\n+                                      shutdownLatch.decrement();\n                                   }\n                               }\n                     );\n+            shutdownLatch.increment();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTg1MjE3MA=="}, "originalCommit": {"oid": "2ef829cce30a13105fe9c1d1398f2e0141393a13"}, "originalPosition": 94}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM1MDY0MTI1OnYy", "diffSide": "RIGHT", "path": "axon-server-connector/src/main/java/org/axonframework/axonserver/connector/command/AxonServerCommandBus.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xNVQxOTo1NDoyMVrOFqQWhw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xNVQxOTo1NDoyMVrOFqQWhw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTg1MjQyMw==", "bodyText": "Rename suggestion: 'initiateShutdown'. await is misleading, because it doesn't really wait (which is a good thing).", "url": "https://github.com/AxonFramework/AxonFramework/pull/1345#discussion_r379852423", "createdAt": "2020-02-15T19:54:21Z", "author": {"login": "abuijze"}, "path": "axon-server-connector/src/main/java/org/axonframework/axonserver/connector/command/AxonServerCommandBus.java", "diffHunk": "@@ -359,19 +373,33 @@ public Registration registerHandlerInterceptor(\n         return localSegment.registerHandlerInterceptor(handlerInterceptor);\n     }\n \n+    @Override\n+    public Registration registerDispatchInterceptor(\n+            MessageDispatchInterceptor<? super CommandMessage<?>> dispatchInterceptor) {\n+        return dispatchInterceptors.registerDispatchInterceptor(dispatchInterceptor);\n+    }\n+\n     /**\n-     * Disconnect the command bus from the Axon Server.\n+     * Disconnect the command bus for receiving commands from Axon Server, by unsubscribing all registered command\n+     * handlers. After this the connection will be closed, waiting until all command processing tasks have been\n+     * resolved. This shutdown operation is performed in the {@link Phase#INBOUND_COMMAND_OR_QUERY_CONNECTOR} phase.\n      */\n+    @ShutdownHandler(phase = Phase.INBOUND_COMMAND_OR_QUERY_CONNECTOR)\n     public void disconnect() {\n-        if (commandProcessor != null) {\n-            commandProcessor.disconnect();\n-        }\n+        commandProcessor.unsubscribeAndRemoveAll();\n+        commandProcessor.disconnect();\n     }\n \n-    @Override\n-    public Registration registerDispatchInterceptor(\n-            MessageDispatchInterceptor<? super CommandMessage<?>> dispatchInterceptor) {\n-        return dispatchInterceptors.registerDispatchInterceptor(dispatchInterceptor);\n+    /**\n+     * Shutdown the command bus asynchronously for dispatching commands to Axon Server. This process will wait for\n+     * dispatched commands which have not received a response yet. This shutdown operation is performed in the {@link\n+     * Phase#OUTBOUND_COMMAND_OR_QUERY_CONNECTORS} phase.\n+     *\n+     * @return a completable future which is resolved once all command dispatching activities are completed\n+     */\n+    @ShutdownHandler(phase = Phase.OUTBOUND_COMMAND_OR_QUERY_CONNECTORS)\n+    public CompletableFuture<Void> shutdownDispatching() {\n+        return shutdownLatch.await();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2ef829cce30a13105fe9c1d1398f2e0141393a13"}, "originalPosition": 145}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM1MDY0MzQzOnYy", "diffSide": "RIGHT", "path": "axon-server-connector/src/main/java/org/axonframework/axonserver/connector/command/AxonServerCommandBus.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xNVQxOTo1OToyMVrOFqQXoQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xN1QwOToxNToxOFrOFqdEMg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTg1MjcwNQ==", "bodyText": "I suppose this is where only an unsubscribe should happen, just disconnecting the remote source, but leaving the internal state intact. The actual \"removal\" (=local unsubscription) can actually wait till the next phase (OUTBOUND_COMMAND_OR_QUERY_CONNECTORS in this case). This would allow for commands already in transit to still be processed, rather than cutting those off.", "url": "https://github.com/AxonFramework/AxonFramework/pull/1345#discussion_r379852705", "createdAt": "2020-02-15T19:59:21Z", "author": {"login": "abuijze"}, "path": "axon-server-connector/src/main/java/org/axonframework/axonserver/connector/command/AxonServerCommandBus.java", "diffHunk": "@@ -359,19 +373,33 @@ public Registration registerHandlerInterceptor(\n         return localSegment.registerHandlerInterceptor(handlerInterceptor);\n     }\n \n+    @Override\n+    public Registration registerDispatchInterceptor(\n+            MessageDispatchInterceptor<? super CommandMessage<?>> dispatchInterceptor) {\n+        return dispatchInterceptors.registerDispatchInterceptor(dispatchInterceptor);\n+    }\n+\n     /**\n-     * Disconnect the command bus from the Axon Server.\n+     * Disconnect the command bus for receiving commands from Axon Server, by unsubscribing all registered command\n+     * handlers. After this the connection will be closed, waiting until all command processing tasks have been\n+     * resolved. This shutdown operation is performed in the {@link Phase#INBOUND_COMMAND_OR_QUERY_CONNECTOR} phase.\n      */\n+    @ShutdownHandler(phase = Phase.INBOUND_COMMAND_OR_QUERY_CONNECTOR)\n     public void disconnect() {\n-        if (commandProcessor != null) {\n-            commandProcessor.disconnect();\n-        }\n+        commandProcessor.unsubscribeAndRemoveAll();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2ef829cce30a13105fe9c1d1398f2e0141393a13"}, "originalPosition": 128}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDA2MDcyMg==", "bodyText": "Agreed, that should be just a tad safer, although I'd expect the ExecutorService's shutdown approach in the CommandProcessor to be kind for tasks still in progress. I've added a CommandProcessor#removeLocalSubscriptions method to be called on the AxonServerCommandBus#shutdownDispatching method and replaced unsubscribeAndRemoveAll for unsubscribeAll.", "url": "https://github.com/AxonFramework/AxonFramework/pull/1345#discussion_r380060722", "createdAt": "2020-02-17T09:15:18Z", "author": {"login": "smcvb"}, "path": "axon-server-connector/src/main/java/org/axonframework/axonserver/connector/command/AxonServerCommandBus.java", "diffHunk": "@@ -359,19 +373,33 @@ public Registration registerHandlerInterceptor(\n         return localSegment.registerHandlerInterceptor(handlerInterceptor);\n     }\n \n+    @Override\n+    public Registration registerDispatchInterceptor(\n+            MessageDispatchInterceptor<? super CommandMessage<?>> dispatchInterceptor) {\n+        return dispatchInterceptors.registerDispatchInterceptor(dispatchInterceptor);\n+    }\n+\n     /**\n-     * Disconnect the command bus from the Axon Server.\n+     * Disconnect the command bus for receiving commands from Axon Server, by unsubscribing all registered command\n+     * handlers. After this the connection will be closed, waiting until all command processing tasks have been\n+     * resolved. This shutdown operation is performed in the {@link Phase#INBOUND_COMMAND_OR_QUERY_CONNECTOR} phase.\n      */\n+    @ShutdownHandler(phase = Phase.INBOUND_COMMAND_OR_QUERY_CONNECTOR)\n     public void disconnect() {\n-        if (commandProcessor != null) {\n-            commandProcessor.disconnect();\n-        }\n+        commandProcessor.unsubscribeAndRemoveAll();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTg1MjcwNQ=="}, "originalCommit": {"oid": "2ef829cce30a13105fe9c1d1398f2e0141393a13"}, "originalPosition": 128}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM1MDY0NDIzOnYy", "diffSide": "RIGHT", "path": "axon-server-connector/src/main/java/org/axonframework/axonserver/connector/command/AxonServerCommandBus.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xNVQyMDowMToyM1rOFqQYCQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xN1QwOToxNTo0NlrOFqdE-g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTg1MjgwOQ==", "bodyText": "Might be my math skills, but 5 + 20 != 35 ;-)", "url": "https://github.com/AxonFramework/AxonFramework/pull/1345#discussion_r379852809", "createdAt": "2020-02-15T20:01:23Z", "author": {"login": "abuijze"}, "path": "axon-server-connector/src/main/java/org/axonframework/axonserver/connector/command/AxonServerCommandBus.java", "diffHunk": "@@ -832,8 +859,22 @@ void disconnect() {\n             if (subscriberStreamObserver != null) {\n                 subscriberStreamObserver.onCompleted();\n             }\n-            running = false;\n+\n             commandExecutor.shutdown();\n+            try {\n+                if (!commandExecutor.awaitTermination(5, TimeUnit.SECONDS)) {\n+                    logger.warn(\"Awaited Command Bus termination for 5 seconds. Wait period extended by 30 seconds.\");\n+                }\n+                if (!commandExecutor.awaitTermination(20, TimeUnit.SECONDS)) {\n+                    logger.warn(\"Awaited Command Bus termination for 35 seconds. Will shutdown forcefully.\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2ef829cce30a13105fe9c1d1398f2e0141393a13"}, "originalPosition": 222}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDA2MDkyMg==", "bodyText": "Might be a typo \ud83d\ude48\nThanks for spotting it.", "url": "https://github.com/AxonFramework/AxonFramework/pull/1345#discussion_r380060922", "createdAt": "2020-02-17T09:15:46Z", "author": {"login": "smcvb"}, "path": "axon-server-connector/src/main/java/org/axonframework/axonserver/connector/command/AxonServerCommandBus.java", "diffHunk": "@@ -832,8 +859,22 @@ void disconnect() {\n             if (subscriberStreamObserver != null) {\n                 subscriberStreamObserver.onCompleted();\n             }\n-            running = false;\n+\n             commandExecutor.shutdown();\n+            try {\n+                if (!commandExecutor.awaitTermination(5, TimeUnit.SECONDS)) {\n+                    logger.warn(\"Awaited Command Bus termination for 5 seconds. Wait period extended by 30 seconds.\");\n+                }\n+                if (!commandExecutor.awaitTermination(20, TimeUnit.SECONDS)) {\n+                    logger.warn(\"Awaited Command Bus termination for 35 seconds. Will shutdown forcefully.\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTg1MjgwOQ=="}, "originalCommit": {"oid": "2ef829cce30a13105fe9c1d1398f2e0141393a13"}, "originalPosition": 222}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM1MDY0OTY1OnYy", "diffSide": "RIGHT", "path": "axon-server-connector/src/main/java/org/axonframework/axonserver/connector/query/AxonServerQueryBus.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xNVQyMDoxNDowM1rOFqQauQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xN1QwOToyOToxNlrOFqdgzw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTg1MzQ5Nw==", "bodyText": "Make sure increment is guaranteed to be invoked before decrement.", "url": "https://github.com/AxonFramework/AxonFramework/pull/1345#discussion_r379853497", "createdAt": "2020-02-15T20:14:03Z", "author": {"login": "abuijze"}, "path": "axon-server-connector/src/main/java/org/axonframework/axonserver/connector/query/AxonServerQueryBus.java", "diffHunk": "@@ -324,48 +328,53 @@ private void onApplicationDisconnected(String context) {\n                                @Override\n                                public void onNext(QueryResponse queryResponse) {\n                                    logger.debug(\"Received query response [{}]\", queryResponse);\n-                                   completableFuture.complete(serializer.deserializeResponse(queryResponse, queryMessage.getResponseType()));\n+                                   queryTransaction.complete(\n+                                           serializer.deserializeResponse(queryResponse, queryMessage.getResponseType())\n+                                   );\n                                }\n \n                                @Override\n                                public void onError(Throwable throwable) {\n-                                   if (logger.isDebugEnabled()) {\n-                                       logger.debug(\"Received error while waiting for first response\", throwable);\n-                                   }\n-                                   completableFuture.completeExceptionally(\n+                                   logger.debug(\"Received error while waiting for first response\", throwable);\n+                                   queryTransaction.completeExceptionally(\n                                            ErrorCode.QUERY_DISPATCH_ERROR.convert(\n                                                    configuration.getClientId(), throwable\n                                            )\n                                    );\n+                                   shutdownLatch.decrement();\n                                }\n \n                                @Override\n                                public void onCompleted() {\n-                                   if (completableFuture.isDone()) {\n-                                       return;\n+                                   if (!queryTransaction.isDone()) {\n+                                       queryTransaction.completeExceptionally(\n+                                               ErrorCode.QUERY_DISPATCH_ERROR.convert(\n+                                                       ErrorMessage.newBuilder()\n+                                                                   .setMessage(\"No result from query executor\")\n+                                                                   .build()\n+                                               )\n+                                       );\n                                    }\n-\n-                                   completableFuture.completeExceptionally(\n-                                           ErrorCode.QUERY_DISPATCH_ERROR.convert(\n-                                                   ErrorMessage.newBuilder()\n-                                                               .setMessage(\"No result from query executor\")\n-                                                               .build()\n-                                           ));\n+                                   shutdownLatch.decrement();\n                                }\n                            });\n+            shutdownLatch.increment();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2ef829cce30a13105fe9c1d1398f2e0141393a13"}, "originalPosition": 121}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDA2ODA0Nw==", "bodyText": "Good point. Made a similar change as you suggested in the AxonServerCommandBus: increment prior to entering try-catch block, decrement on onError, onCompleted and in the catch.", "url": "https://github.com/AxonFramework/AxonFramework/pull/1345#discussion_r380068047", "createdAt": "2020-02-17T09:29:16Z", "author": {"login": "smcvb"}, "path": "axon-server-connector/src/main/java/org/axonframework/axonserver/connector/query/AxonServerQueryBus.java", "diffHunk": "@@ -324,48 +328,53 @@ private void onApplicationDisconnected(String context) {\n                                @Override\n                                public void onNext(QueryResponse queryResponse) {\n                                    logger.debug(\"Received query response [{}]\", queryResponse);\n-                                   completableFuture.complete(serializer.deserializeResponse(queryResponse, queryMessage.getResponseType()));\n+                                   queryTransaction.complete(\n+                                           serializer.deserializeResponse(queryResponse, queryMessage.getResponseType())\n+                                   );\n                                }\n \n                                @Override\n                                public void onError(Throwable throwable) {\n-                                   if (logger.isDebugEnabled()) {\n-                                       logger.debug(\"Received error while waiting for first response\", throwable);\n-                                   }\n-                                   completableFuture.completeExceptionally(\n+                                   logger.debug(\"Received error while waiting for first response\", throwable);\n+                                   queryTransaction.completeExceptionally(\n                                            ErrorCode.QUERY_DISPATCH_ERROR.convert(\n                                                    configuration.getClientId(), throwable\n                                            )\n                                    );\n+                                   shutdownLatch.decrement();\n                                }\n \n                                @Override\n                                public void onCompleted() {\n-                                   if (completableFuture.isDone()) {\n-                                       return;\n+                                   if (!queryTransaction.isDone()) {\n+                                       queryTransaction.completeExceptionally(\n+                                               ErrorCode.QUERY_DISPATCH_ERROR.convert(\n+                                                       ErrorMessage.newBuilder()\n+                                                                   .setMessage(\"No result from query executor\")\n+                                                                   .build()\n+                                               )\n+                                       );\n                                    }\n-\n-                                   completableFuture.completeExceptionally(\n-                                           ErrorCode.QUERY_DISPATCH_ERROR.convert(\n-                                                   ErrorMessage.newBuilder()\n-                                                               .setMessage(\"No result from query executor\")\n-                                                               .build()\n-                                           ));\n+                                   shutdownLatch.decrement();\n                                }\n                            });\n+            shutdownLatch.increment();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTg1MzQ5Nw=="}, "originalCommit": {"oid": "2ef829cce30a13105fe9c1d1398f2e0141393a13"}, "originalPosition": 121}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM1MDY0OTgzOnYy", "diffSide": "RIGHT", "path": "axon-server-connector/src/main/java/org/axonframework/axonserver/connector/query/AxonServerQueryBus.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xNVQyMDoxNDo1NlrOFqQa1A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xN1QwOTozMDowNlrOFqdilw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTg1MzUyNA==", "bodyText": "Suggestion: assertRunning or assertNotShuttingDown", "url": "https://github.com/AxonFramework/AxonFramework/pull/1345#discussion_r379853524", "createdAt": "2020-02-15T20:14:56Z", "author": {"login": "abuijze"}, "path": "axon-server-connector/src/main/java/org/axonframework/axonserver/connector/query/AxonServerQueryBus.java", "diffHunk": "@@ -324,48 +328,53 @@ private void onApplicationDisconnected(String context) {\n                                @Override\n                                public void onNext(QueryResponse queryResponse) {\n                                    logger.debug(\"Received query response [{}]\", queryResponse);\n-                                   completableFuture.complete(serializer.deserializeResponse(queryResponse, queryMessage.getResponseType()));\n+                                   queryTransaction.complete(\n+                                           serializer.deserializeResponse(queryResponse, queryMessage.getResponseType())\n+                                   );\n                                }\n \n                                @Override\n                                public void onError(Throwable throwable) {\n-                                   if (logger.isDebugEnabled()) {\n-                                       logger.debug(\"Received error while waiting for first response\", throwable);\n-                                   }\n-                                   completableFuture.completeExceptionally(\n+                                   logger.debug(\"Received error while waiting for first response\", throwable);\n+                                   queryTransaction.completeExceptionally(\n                                            ErrorCode.QUERY_DISPATCH_ERROR.convert(\n                                                    configuration.getClientId(), throwable\n                                            )\n                                    );\n+                                   shutdownLatch.decrement();\n                                }\n \n                                @Override\n                                public void onCompleted() {\n-                                   if (completableFuture.isDone()) {\n-                                       return;\n+                                   if (!queryTransaction.isDone()) {\n+                                       queryTransaction.completeExceptionally(\n+                                               ErrorCode.QUERY_DISPATCH_ERROR.convert(\n+                                                       ErrorMessage.newBuilder()\n+                                                                   .setMessage(\"No result from query executor\")\n+                                                                   .build()\n+                                               )\n+                                       );\n                                    }\n-\n-                                   completableFuture.completeExceptionally(\n-                                           ErrorCode.QUERY_DISPATCH_ERROR.convert(\n-                                                   ErrorMessage.newBuilder()\n-                                                               .setMessage(\"No result from query executor\")\n-                                                               .build()\n-                                           ));\n+                                   shutdownLatch.decrement();\n                                }\n                            });\n+            shutdownLatch.increment();\n         } catch (Exception e) {\n             logger.debug(\"There was a problem issuing a query {}.\", interceptedQuery, e);\n-            completableFuture.completeExceptionally(\n+            queryTransaction.completeExceptionally(\n                     ErrorCode.QUERY_DISPATCH_ERROR.convert(configuration.getClientId(), e)\n             );\n         }\n-        return completableFuture;\n+\n+        return queryTransaction;\n     }\n \n     @Override\n     public <Q, R> Stream<QueryResponseMessage<R>> scatterGather(QueryMessage<Q, R> queryMessage,\n                                                                 long timeout,\n                                                                 TimeUnit timeUnit) {\n+        validateShutdown(\"scatter-gather queries\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2ef829cce30a13105fe9c1d1398f2e0141393a13"}, "originalPosition": 138}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDA2ODUwMw==", "bodyText": "Changed to assertActive(String).", "url": "https://github.com/AxonFramework/AxonFramework/pull/1345#discussion_r380068503", "createdAt": "2020-02-17T09:30:06Z", "author": {"login": "smcvb"}, "path": "axon-server-connector/src/main/java/org/axonframework/axonserver/connector/query/AxonServerQueryBus.java", "diffHunk": "@@ -324,48 +328,53 @@ private void onApplicationDisconnected(String context) {\n                                @Override\n                                public void onNext(QueryResponse queryResponse) {\n                                    logger.debug(\"Received query response [{}]\", queryResponse);\n-                                   completableFuture.complete(serializer.deserializeResponse(queryResponse, queryMessage.getResponseType()));\n+                                   queryTransaction.complete(\n+                                           serializer.deserializeResponse(queryResponse, queryMessage.getResponseType())\n+                                   );\n                                }\n \n                                @Override\n                                public void onError(Throwable throwable) {\n-                                   if (logger.isDebugEnabled()) {\n-                                       logger.debug(\"Received error while waiting for first response\", throwable);\n-                                   }\n-                                   completableFuture.completeExceptionally(\n+                                   logger.debug(\"Received error while waiting for first response\", throwable);\n+                                   queryTransaction.completeExceptionally(\n                                            ErrorCode.QUERY_DISPATCH_ERROR.convert(\n                                                    configuration.getClientId(), throwable\n                                            )\n                                    );\n+                                   shutdownLatch.decrement();\n                                }\n \n                                @Override\n                                public void onCompleted() {\n-                                   if (completableFuture.isDone()) {\n-                                       return;\n+                                   if (!queryTransaction.isDone()) {\n+                                       queryTransaction.completeExceptionally(\n+                                               ErrorCode.QUERY_DISPATCH_ERROR.convert(\n+                                                       ErrorMessage.newBuilder()\n+                                                                   .setMessage(\"No result from query executor\")\n+                                                                   .build()\n+                                               )\n+                                       );\n                                    }\n-\n-                                   completableFuture.completeExceptionally(\n-                                           ErrorCode.QUERY_DISPATCH_ERROR.convert(\n-                                                   ErrorMessage.newBuilder()\n-                                                               .setMessage(\"No result from query executor\")\n-                                                               .build()\n-                                           ));\n+                                   shutdownLatch.decrement();\n                                }\n                            });\n+            shutdownLatch.increment();\n         } catch (Exception e) {\n             logger.debug(\"There was a problem issuing a query {}.\", interceptedQuery, e);\n-            completableFuture.completeExceptionally(\n+            queryTransaction.completeExceptionally(\n                     ErrorCode.QUERY_DISPATCH_ERROR.convert(configuration.getClientId(), e)\n             );\n         }\n-        return completableFuture;\n+\n+        return queryTransaction;\n     }\n \n     @Override\n     public <Q, R> Stream<QueryResponseMessage<R>> scatterGather(QueryMessage<Q, R> queryMessage,\n                                                                 long timeout,\n                                                                 TimeUnit timeUnit) {\n+        validateShutdown(\"scatter-gather queries\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTg1MzUyNA=="}, "originalCommit": {"oid": "2ef829cce30a13105fe9c1d1398f2e0141393a13"}, "originalPosition": 138}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM1MDY0OTk3OnYy", "diffSide": "RIGHT", "path": "axon-server-connector/src/main/java/org/axonframework/axonserver/connector/query/AxonServerQueryBus.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xNVQyMDoxNTo0MFrOFqQa8A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xNVQyMDoxNTo0MFrOFqQa8A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTg1MzU1Mg==", "bodyText": "Same: ensure incrementing before decrementing", "url": "https://github.com/AxonFramework/AxonFramework/pull/1345#discussion_r379853552", "createdAt": "2020-02-15T20:15:40Z", "author": {"login": "abuijze"}, "path": "axon-server-connector/src/main/java/org/axonframework/axonserver/connector/query/AxonServerQueryBus.java", "diffHunk": "@@ -395,17 +406,19 @@ public void onNext(QueryResponse queryResponse) {\n                            @Override\n                            public void onError(Throwable throwable) {\n                                if (!isDeadlineExceeded(throwable)) {\n-                                   logger.info(\"Received error while waiting for responses\",\n-                                               throwable);\n+                                   logger.info(\"Received error while waiting for responses\", throwable);\n                                }\n                                resultSpliterator.cancel(throwable);\n+                               shutdownLatch.decrement();\n                            }\n \n                            @Override\n                            public void onCompleted() {\n                                resultSpliterator.cancel(null);\n+                               shutdownLatch.decrement();\n                            }\n                        });\n+        shutdownLatch.increment();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2ef829cce30a13105fe9c1d1398f2e0141393a13"}, "originalPosition": 172}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM1MDY1MDI1OnYy", "diffSide": "RIGHT", "path": "axon-server-connector/src/main/java/org/axonframework/axonserver/connector/query/AxonServerQueryBus.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xNVQyMDoxNjozMVrOFqQbGQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xNVQyMDoxNjozMVrOFqQbGQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTg1MzU5Mw==", "bodyText": "25 or 35?", "url": "https://github.com/AxonFramework/AxonFramework/pull/1345#discussion_r379853593", "createdAt": "2020-02-15T20:16:31Z", "author": {"login": "abuijze"}, "path": "axon-server-connector/src/main/java/org/axonframework/axonserver/connector/query/AxonServerQueryBus.java", "diffHunk": "@@ -720,33 +783,24 @@ public void unsubscribe(String queryName, Type responseType, String componentNam\n             }\n         }\n \n-        private void clearOutboundStream() {\n-            StreamObserver<QueryProviderOutbound> out = outboundStreamObserver;\n-            if (out != null) {\n-                outboundStreamObserver = null;\n-                try {\n-                    subscribedQueries.forEach((queryDefinition, handlerSet) -> out.onNext(\n-                            QueryProviderOutbound.newBuilder()\n-                                                 .setUnsubscribe(buildQuerySubscription(queryDefinition, 1))\n-                                                 .build()\n-                    ));\n-                    out.onCompleted();\n-                } catch (Exception e) {\n-                    // This exception is ignored\n-                }\n-            }\n-        }\n-\n         void disconnect() {\n             running = false;\n-            clearOutboundStream();\n+\n             queryExecutor.shutdown();\n             try {\n-                queryExecutor.awaitTermination(5, TimeUnit.SECONDS);\n+                if (!queryExecutor.awaitTermination(5, TimeUnit.SECONDS)) {\n+                    logger.warn(\"Awaited Query Bus termination for 5 seconds. Wait period extended by 30 seconds.\");\n+                }\n+                if (!queryExecutor.awaitTermination(20, TimeUnit.SECONDS)) {\n+                    logger.warn(\"Awaited Query Bus termination for 35 seconds. Will shutdown forcefully.\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2ef829cce30a13105fe9c1d1398f2e0141393a13"}, "originalPosition": 313}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM1MDY1MDQ5OnYy", "diffSide": "RIGHT", "path": "axon-server-connector/src/main/java/org/axonframework/axonserver/connector/query/AxonServerQueryBus.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xNVQyMDoxNjo0MVrOFqQbNA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xN1QwOTozMjoxMFrOFqdmtw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTg1MzYyMA==", "bodyText": "30 or 20?", "url": "https://github.com/AxonFramework/AxonFramework/pull/1345#discussion_r379853620", "createdAt": "2020-02-15T20:16:41Z", "author": {"login": "abuijze"}, "path": "axon-server-connector/src/main/java/org/axonframework/axonserver/connector/query/AxonServerQueryBus.java", "diffHunk": "@@ -720,33 +783,24 @@ public void unsubscribe(String queryName, Type responseType, String componentNam\n             }\n         }\n \n-        private void clearOutboundStream() {\n-            StreamObserver<QueryProviderOutbound> out = outboundStreamObserver;\n-            if (out != null) {\n-                outboundStreamObserver = null;\n-                try {\n-                    subscribedQueries.forEach((queryDefinition, handlerSet) -> out.onNext(\n-                            QueryProviderOutbound.newBuilder()\n-                                                 .setUnsubscribe(buildQuerySubscription(queryDefinition, 1))\n-                                                 .build()\n-                    ));\n-                    out.onCompleted();\n-                } catch (Exception e) {\n-                    // This exception is ignored\n-                }\n-            }\n-        }\n-\n         void disconnect() {\n             running = false;\n-            clearOutboundStream();\n+\n             queryExecutor.shutdown();\n             try {\n-                queryExecutor.awaitTermination(5, TimeUnit.SECONDS);\n+                if (!queryExecutor.awaitTermination(5, TimeUnit.SECONDS)) {\n+                    logger.warn(\"Awaited Query Bus termination for 5 seconds. Wait period extended by 30 seconds.\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2ef829cce30a13105fe9c1d1398f2e0141393a13"}, "originalPosition": 310}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDA2OTU1OQ==", "bodyText": "The second awaitTermination should use 30 - typo from my end which has been resolved.", "url": "https://github.com/AxonFramework/AxonFramework/pull/1345#discussion_r380069559", "createdAt": "2020-02-17T09:32:10Z", "author": {"login": "smcvb"}, "path": "axon-server-connector/src/main/java/org/axonframework/axonserver/connector/query/AxonServerQueryBus.java", "diffHunk": "@@ -720,33 +783,24 @@ public void unsubscribe(String queryName, Type responseType, String componentNam\n             }\n         }\n \n-        private void clearOutboundStream() {\n-            StreamObserver<QueryProviderOutbound> out = outboundStreamObserver;\n-            if (out != null) {\n-                outboundStreamObserver = null;\n-                try {\n-                    subscribedQueries.forEach((queryDefinition, handlerSet) -> out.onNext(\n-                            QueryProviderOutbound.newBuilder()\n-                                                 .setUnsubscribe(buildQuerySubscription(queryDefinition, 1))\n-                                                 .build()\n-                    ));\n-                    out.onCompleted();\n-                } catch (Exception e) {\n-                    // This exception is ignored\n-                }\n-            }\n-        }\n-\n         void disconnect() {\n             running = false;\n-            clearOutboundStream();\n+\n             queryExecutor.shutdown();\n             try {\n-                queryExecutor.awaitTermination(5, TimeUnit.SECONDS);\n+                if (!queryExecutor.awaitTermination(5, TimeUnit.SECONDS)) {\n+                    logger.warn(\"Awaited Query Bus termination for 5 seconds. Wait period extended by 30 seconds.\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTg1MzYyMA=="}, "originalCommit": {"oid": "2ef829cce30a13105fe9c1d1398f2e0141393a13"}, "originalPosition": 310}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM1MDY2NDU1OnYy", "diffSide": "RIGHT", "path": "messaging/src/main/java/org/axonframework/commandhandling/distributed/CommandBusConnector.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xNVQyMDo1MTo0OVrOFqQiEg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xN1QwOTozNjo1OVrOFqdv_g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTg1NTM3OA==", "bodyText": "Consider renaming this method. Something like disconnect, initiateShutdown", "url": "https://github.com/AxonFramework/AxonFramework/pull/1345#discussion_r379855378", "createdAt": "2020-02-15T20:51:49Z", "author": {"login": "abuijze"}, "path": "messaging/src/main/java/org/axonframework/commandhandling/distributed/CommandBusConnector.java", "diffHunk": "@@ -96,4 +97,13 @@\n     default Optional<CommandBus> localSegment() {\n         return Optional.empty();\n     }\n+\n+    /**\n+     * Stops sending new commands.\n+     *\n+     * @return a Completable Future indicating that all previously sent commands are completed\n+     */\n+    default CompletableFuture<Void> stopSendingCommands() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2ef829cce30a13105fe9c1d1398f2e0141393a13"}, "originalPosition": 18}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDA3MTkzNA==", "bodyText": "Renamed to initiateShutdown", "url": "https://github.com/AxonFramework/AxonFramework/pull/1345#discussion_r380071934", "createdAt": "2020-02-17T09:36:59Z", "author": {"login": "smcvb"}, "path": "messaging/src/main/java/org/axonframework/commandhandling/distributed/CommandBusConnector.java", "diffHunk": "@@ -96,4 +97,13 @@\n     default Optional<CommandBus> localSegment() {\n         return Optional.empty();\n     }\n+\n+    /**\n+     * Stops sending new commands.\n+     *\n+     * @return a Completable Future indicating that all previously sent commands are completed\n+     */\n+    default CompletableFuture<Void> stopSendingCommands() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTg1NTM3OA=="}, "originalCommit": {"oid": "2ef829cce30a13105fe9c1d1398f2e0141393a13"}, "originalPosition": 18}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM1MDY2NjQ5OnYy", "diffSide": "RIGHT", "path": "messaging/src/main/java/org/axonframework/commandhandling/distributed/DistributedCommandBus.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xNVQyMDo1Nzo0NFrOFqQjGQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xN1QwOTo0MDozM1rOFqd3kA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTg1NTY0MQ==", "bodyText": "Suggest renaming to disconnect. Why is a \"stopSending\" (= outbound) annotated with a phase for INBOUND?", "url": "https://github.com/AxonFramework/AxonFramework/pull/1345#discussion_r379855641", "createdAt": "2020-02-15T20:57:44Z", "author": {"login": "abuijze"}, "path": "messaging/src/main/java/org/axonframework/commandhandling/distributed/DistributedCommandBus.java", "diffHunk": "@@ -101,6 +104,24 @@ protected DistributedCommandBus(Builder builder) {\n         this.defaultCommandCallback = builder.defaultCommandCallback;\n     }\n \n+    /**\n+     * Shutdown handler that unsubscribes all command handlers subscribed via this Distributed Command Bus.\n+     */\n+    @ShutdownHandler(phase = Phase.OUTBOUND_COMMAND_OR_QUERY_CONNECTORS)\n+    public void unsubscribeCommandHandlers() {\n+        commandRouter.updateMembership(loadFactor, DenyAll.INSTANCE);\n+    }\n+\n+    /**\n+     * Shutdown handler that stops sending new commands.\n+     *\n+     * @return a Completable Future indicating that all previously sent commands are completed\n+     */\n+    @ShutdownHandler(phase = Phase.INBOUND_COMMAND_OR_QUERY_CONNECTOR)\n+    public CompletableFuture<Void> stopSendingCommands() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2ef829cce30a13105fe9c1d1398f2e0141393a13"}, "originalPosition": 35}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDA3Mzg3Mg==", "bodyText": "Renamed to shutdownDispatching, thus mirroring the AxonServerCommandBus' equivalent phase.\nAnd you're right on the phases, they've been accidentally switched. This method should be called in phase OUTBOUND_COMMAND_OR_QUERY_CONNECTORS.", "url": "https://github.com/AxonFramework/AxonFramework/pull/1345#discussion_r380073872", "createdAt": "2020-02-17T09:40:33Z", "author": {"login": "smcvb"}, "path": "messaging/src/main/java/org/axonframework/commandhandling/distributed/DistributedCommandBus.java", "diffHunk": "@@ -101,6 +104,24 @@ protected DistributedCommandBus(Builder builder) {\n         this.defaultCommandCallback = builder.defaultCommandCallback;\n     }\n \n+    /**\n+     * Shutdown handler that unsubscribes all command handlers subscribed via this Distributed Command Bus.\n+     */\n+    @ShutdownHandler(phase = Phase.OUTBOUND_COMMAND_OR_QUERY_CONNECTORS)\n+    public void unsubscribeCommandHandlers() {\n+        commandRouter.updateMembership(loadFactor, DenyAll.INSTANCE);\n+    }\n+\n+    /**\n+     * Shutdown handler that stops sending new commands.\n+     *\n+     * @return a Completable Future indicating that all previously sent commands are completed\n+     */\n+    @ShutdownHandler(phase = Phase.INBOUND_COMMAND_OR_QUERY_CONNECTOR)\n+    public CompletableFuture<Void> stopSendingCommands() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTg1NTY0MQ=="}, "originalCommit": {"oid": "2ef829cce30a13105fe9c1d1398f2e0141393a13"}, "originalPosition": 35}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM1MDY2OTYyOnYy", "diffSide": "RIGHT", "path": "messaging/src/main/java/org/axonframework/lifecycle/Phase.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xNVQyMTowNTozNVrOFqQkow==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xN1QwOTo1ODozOFrOFqef8w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTg1NjAzNQ==", "bodyText": "I suggest creating two different fields for Commands and Queries, even though they have the same value.", "url": "https://github.com/AxonFramework/AxonFramework/pull/1345#discussion_r379856035", "createdAt": "2020-02-15T21:05:35Z", "author": {"login": "abuijze"}, "path": "messaging/src/main/java/org/axonframework/lifecycle/Phase.java", "diffHunk": "@@ -0,0 +1,66 @@\n+/*\n+ * Copyright (c) 2010-2020. Axon Framework\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.axonframework.lifecycle;\n+\n+/**\n+ * Utility class containing constants which can be used as input for the {@link StartHandler} and {@link\n+ * ShutdownHandler} annotations.\n+ *\n+ * @author Steven van Beelen\n+ * @see StartHandler\n+ * @see ShutdownHandler\n+ * @since 4.3\n+ */\n+public abstract class Phase {\n+\n+    private Phase() {\n+        // Utility class\n+    }\n+\n+    /**\n+     * Phase to start or shutdown all external connections.\n+     */\n+    public static final int EXTERNAL_CONNECTIONS = Integer.MIN_VALUE >> 4;\n+    /**\n+     * Phase to register or cancel the registration of any local message handler.\n+     */\n+    public static final int LOCAL_MESSAGE_HANDLER_REGISTRATIONS = 0;\n+    /**\n+     * Phase to start or shutdown inbound command and/or query connectors. It is targeted towards connectors which\n+     * receive commands and/or queries from external applications.\n+     */\n+    public static final int INBOUND_COMMAND_OR_QUERY_CONNECTOR = 0;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2ef829cce30a13105fe9c1d1398f2e0141393a13"}, "originalPosition": 46}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDA4NDIxMQ==", "bodyText": "Fair point, added those.", "url": "https://github.com/AxonFramework/AxonFramework/pull/1345#discussion_r380084211", "createdAt": "2020-02-17T09:58:38Z", "author": {"login": "smcvb"}, "path": "messaging/src/main/java/org/axonframework/lifecycle/Phase.java", "diffHunk": "@@ -0,0 +1,66 @@\n+/*\n+ * Copyright (c) 2010-2020. Axon Framework\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.axonframework.lifecycle;\n+\n+/**\n+ * Utility class containing constants which can be used as input for the {@link StartHandler} and {@link\n+ * ShutdownHandler} annotations.\n+ *\n+ * @author Steven van Beelen\n+ * @see StartHandler\n+ * @see ShutdownHandler\n+ * @since 4.3\n+ */\n+public abstract class Phase {\n+\n+    private Phase() {\n+        // Utility class\n+    }\n+\n+    /**\n+     * Phase to start or shutdown all external connections.\n+     */\n+    public static final int EXTERNAL_CONNECTIONS = Integer.MIN_VALUE >> 4;\n+    /**\n+     * Phase to register or cancel the registration of any local message handler.\n+     */\n+    public static final int LOCAL_MESSAGE_HANDLER_REGISTRATIONS = 0;\n+    /**\n+     * Phase to start or shutdown inbound command and/or query connectors. It is targeted towards connectors which\n+     * receive commands and/or queries from external applications.\n+     */\n+    public static final int INBOUND_COMMAND_OR_QUERY_CONNECTOR = 0;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTg1NjAzNQ=="}, "originalCommit": {"oid": "2ef829cce30a13105fe9c1d1398f2e0141393a13"}, "originalPosition": 46}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM1MDY3MTE4OnYy", "diffSide": "RIGHT", "path": "messaging/src/main/java/org/axonframework/lifecycle/ShutdownLatch.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xNVQyMTowOTowOVrOFqQlbg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xNVQyMTowOTowOVrOFqQlbg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTg1NjIzOA==", "bodyText": "This field needs to be volatile, to be thread-safe", "url": "https://github.com/AxonFramework/AxonFramework/pull/1345#discussion_r379856238", "createdAt": "2020-02-15T21:09:09Z", "author": {"login": "abuijze"}, "path": "messaging/src/main/java/org/axonframework/lifecycle/ShutdownLatch.java", "diffHunk": "@@ -0,0 +1,98 @@\n+package org.axonframework.lifecycle;\n+\n+import java.time.Duration;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.function.Supplier;\n+\n+/**\n+ * A latch implementation to be used in shutdown scenarios. Operations to wait for can be added by invoking {@link\n+ * #increment()}. An added operation should always be removed through {@link #decrement()} once it has completed, as\n+ * {@link #await()} will otherwise block indefinitely. If the latch is waited on through {@link #await()}, new\n+ * operations can no longer be added.\n+ *\n+ * @author Steven van Beelen\n+ * @since 4.3\n+ */\n+public class ShutdownLatch {\n+\n+    private final AtomicInteger operationCounter = new AtomicInteger(0);\n+    private CompletableFuture<Void> latch;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2ef829cce30a13105fe9c1d1398f2e0141393a13"}, "originalPosition": 23}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM1MDY3MjI2OnYy", "diffSide": "RIGHT", "path": "messaging/src/main/java/org/axonframework/lifecycle/ShutdownLatch.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xNVQyMToxMjowNVrOFqQl_A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xN1QxMDowNToxOFrOFqeuhA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTg1NjM4MA==", "bodyText": "To make this method completely safe in its usage, it's best if this method returns a \"handle\" that can be closed to indicate that a certain workload has been finished. The method signature could look like:\npublic ActivityHandle registerActivity(). ActivityHandler would have a single method: void end().\nThis implementation of ActivtyHandle.end() could also verify that it wasn't invoked more than once. Decrementing the counter more than incrementing it can be problematic.", "url": "https://github.com/AxonFramework/AxonFramework/pull/1345#discussion_r379856380", "createdAt": "2020-02-15T21:12:05Z", "author": {"login": "abuijze"}, "path": "messaging/src/main/java/org/axonframework/lifecycle/ShutdownLatch.java", "diffHunk": "@@ -0,0 +1,98 @@\n+package org.axonframework.lifecycle;\n+\n+import java.time.Duration;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.function.Supplier;\n+\n+/**\n+ * A latch implementation to be used in shutdown scenarios. Operations to wait for can be added by invoking {@link\n+ * #increment()}. An added operation should always be removed through {@link #decrement()} once it has completed, as\n+ * {@link #await()} will otherwise block indefinitely. If the latch is waited on through {@link #await()}, new\n+ * operations can no longer be added.\n+ *\n+ * @author Steven van Beelen\n+ * @since 4.3\n+ */\n+public class ShutdownLatch {\n+\n+    private final AtomicInteger operationCounter = new AtomicInteger(0);\n+    private CompletableFuture<Void> latch;\n+\n+    /**\n+     * Add an operation this latch should wait on before opening up. If this operation is called whilst {@link #await()}\n+     * is already called an {@link IllegalStateException} will be thrown.\n+     *\n+     * @throws IllegalStateException if {@link #await()} has been called prior to invoking this method\n+     */\n+    public void increment() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2ef829cce30a13105fe9c1d1398f2e0141393a13"}, "originalPosition": 31}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDA4Nzk0MA==", "bodyText": "Brilliant idea to make this even safer. Gonna do something like this.", "url": "https://github.com/AxonFramework/AxonFramework/pull/1345#discussion_r380087940", "createdAt": "2020-02-17T10:05:18Z", "author": {"login": "smcvb"}, "path": "messaging/src/main/java/org/axonframework/lifecycle/ShutdownLatch.java", "diffHunk": "@@ -0,0 +1,98 @@\n+package org.axonframework.lifecycle;\n+\n+import java.time.Duration;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.function.Supplier;\n+\n+/**\n+ * A latch implementation to be used in shutdown scenarios. Operations to wait for can be added by invoking {@link\n+ * #increment()}. An added operation should always be removed through {@link #decrement()} once it has completed, as\n+ * {@link #await()} will otherwise block indefinitely. If the latch is waited on through {@link #await()}, new\n+ * operations can no longer be added.\n+ *\n+ * @author Steven van Beelen\n+ * @since 4.3\n+ */\n+public class ShutdownLatch {\n+\n+    private final AtomicInteger operationCounter = new AtomicInteger(0);\n+    private CompletableFuture<Void> latch;\n+\n+    /**\n+     * Add an operation this latch should wait on before opening up. If this operation is called whilst {@link #await()}\n+     * is already called an {@link IllegalStateException} will be thrown.\n+     *\n+     * @throws IllegalStateException if {@link #await()} has been called prior to invoking this method\n+     */\n+    public void increment() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTg1NjM4MA=="}, "originalCommit": {"oid": "2ef829cce30a13105fe9c1d1398f2e0141393a13"}, "originalPosition": 31}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM1MDY3MzAyOnYy", "diffSide": "RIGHT", "path": "messaging/src/main/java/org/axonframework/lifecycle/ShutdownLatch.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xNVQyMToxMzo0OFrOFqQmVA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xNVQyMToxMzo0OFrOFqQmVA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTg1NjQ2OA==", "bodyText": "This message won't mean much to people who are not familiar with the implementation details. Consider throwing a \"ShutdownInProgressException\" and/or change the message to \"Cannot start activity. Shutdown in progress.\"", "url": "https://github.com/AxonFramework/AxonFramework/pull/1345#discussion_r379856468", "createdAt": "2020-02-15T21:13:48Z", "author": {"login": "abuijze"}, "path": "messaging/src/main/java/org/axonframework/lifecycle/ShutdownLatch.java", "diffHunk": "@@ -0,0 +1,98 @@\n+package org.axonframework.lifecycle;\n+\n+import java.time.Duration;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.function.Supplier;\n+\n+/**\n+ * A latch implementation to be used in shutdown scenarios. Operations to wait for can be added by invoking {@link\n+ * #increment()}. An added operation should always be removed through {@link #decrement()} once it has completed, as\n+ * {@link #await()} will otherwise block indefinitely. If the latch is waited on through {@link #await()}, new\n+ * operations can no longer be added.\n+ *\n+ * @author Steven van Beelen\n+ * @since 4.3\n+ */\n+public class ShutdownLatch {\n+\n+    private final AtomicInteger operationCounter = new AtomicInteger(0);\n+    private CompletableFuture<Void> latch;\n+\n+    /**\n+     * Add an operation this latch should wait on before opening up. If this operation is called whilst {@link #await()}\n+     * is already called an {@link IllegalStateException} will be thrown.\n+     *\n+     * @throws IllegalStateException if {@link #await()} has been called prior to invoking this method\n+     */\n+    public void increment() {\n+        if (isShuttingDown()) {\n+            throw new IllegalStateException(\"No new operations can be added, since this latched is waited for.\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2ef829cce30a13105fe9c1d1398f2e0141393a13"}, "originalPosition": 33}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM1MDY3MzI3OnYy", "diffSide": "RIGHT", "path": "messaging/src/main/java/org/axonframework/lifecycle/ShutdownLatch.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xNVQyMToxNDoyOFrOFqQmeQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xNVQyMToxNDoyOFrOFqQmeQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTg1NjUwNQ==", "bodyText": "See above. Consider moving this method to a \"Handle\".", "url": "https://github.com/AxonFramework/AxonFramework/pull/1345#discussion_r379856505", "createdAt": "2020-02-15T21:14:28Z", "author": {"login": "abuijze"}, "path": "messaging/src/main/java/org/axonframework/lifecycle/ShutdownLatch.java", "diffHunk": "@@ -0,0 +1,98 @@\n+package org.axonframework.lifecycle;\n+\n+import java.time.Duration;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.function.Supplier;\n+\n+/**\n+ * A latch implementation to be used in shutdown scenarios. Operations to wait for can be added by invoking {@link\n+ * #increment()}. An added operation should always be removed through {@link #decrement()} once it has completed, as\n+ * {@link #await()} will otherwise block indefinitely. If the latch is waited on through {@link #await()}, new\n+ * operations can no longer be added.\n+ *\n+ * @author Steven van Beelen\n+ * @since 4.3\n+ */\n+public class ShutdownLatch {\n+\n+    private final AtomicInteger operationCounter = new AtomicInteger(0);\n+    private CompletableFuture<Void> latch;\n+\n+    /**\n+     * Add an operation this latch should wait on before opening up. If this operation is called whilst {@link #await()}\n+     * is already called an {@link IllegalStateException} will be thrown.\n+     *\n+     * @throws IllegalStateException if {@link #await()} has been called prior to invoking this method\n+     */\n+    public void increment() {\n+        if (isShuttingDown()) {\n+            throw new IllegalStateException(\"No new operations can be added, since this latched is waited for.\");\n+        }\n+        operationCounter.incrementAndGet();\n+    }\n+\n+    /**\n+     * Remove an operation this latch waits on. This method should be invoked once the added operations has ended. This\n+     * method will complete the latch if {@link #await()} has been invoked abd all operations are removed.\n+     */\n+    public void decrement() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2ef829cce30a13105fe9c1d1398f2e0141393a13"}, "originalPosition": 42}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM1MDY3MzkwOnYy", "diffSide": "RIGHT", "path": "messaging/src/main/java/org/axonframework/lifecycle/ShutdownLatch.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xNVQyMToxNTo1M1rOFqQmyA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xNVQyMToxNTo1M1rOFqQmyA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTg1NjU4NA==", "bodyText": "This effectively initiates the shutdown process. Consider renaming to initiateShutdown", "url": "https://github.com/AxonFramework/AxonFramework/pull/1345#discussion_r379856584", "createdAt": "2020-02-15T21:15:53Z", "author": {"login": "abuijze"}, "path": "messaging/src/main/java/org/axonframework/lifecycle/ShutdownLatch.java", "diffHunk": "@@ -0,0 +1,98 @@\n+package org.axonframework.lifecycle;\n+\n+import java.time.Duration;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.function.Supplier;\n+\n+/**\n+ * A latch implementation to be used in shutdown scenarios. Operations to wait for can be added by invoking {@link\n+ * #increment()}. An added operation should always be removed through {@link #decrement()} once it has completed, as\n+ * {@link #await()} will otherwise block indefinitely. If the latch is waited on through {@link #await()}, new\n+ * operations can no longer be added.\n+ *\n+ * @author Steven van Beelen\n+ * @since 4.3\n+ */\n+public class ShutdownLatch {\n+\n+    private final AtomicInteger operationCounter = new AtomicInteger(0);\n+    private CompletableFuture<Void> latch;\n+\n+    /**\n+     * Add an operation this latch should wait on before opening up. If this operation is called whilst {@link #await()}\n+     * is already called an {@link IllegalStateException} will be thrown.\n+     *\n+     * @throws IllegalStateException if {@link #await()} has been called prior to invoking this method\n+     */\n+    public void increment() {\n+        if (isShuttingDown()) {\n+            throw new IllegalStateException(\"No new operations can be added, since this latched is waited for.\");\n+        }\n+        operationCounter.incrementAndGet();\n+    }\n+\n+    /**\n+     * Remove an operation this latch waits on. This method should be invoked once the added operations has ended. This\n+     * method will complete the latch if {@link #await()} has been invoked abd all operations are removed.\n+     */\n+    public void decrement() {\n+        if (operationCounter.decrementAndGet() <= 0 && isShuttingDown()) {\n+            latch.complete(null);\n+        }\n+    }\n+\n+    /**\n+     * Check whether this {@link ShutdownLatch} is waited on. The exception retrieved from the {@code exceptionSupplier}\n+     * will be thrown if this latch is shutting down.\n+     *\n+     * @param exceptionSupplier a {@link Supplier} of a {@link RuntimeException} to throw if this latch is waited on\n+     */\n+    public void isShuttingDown(Supplier<RuntimeException> exceptionSupplier) {\n+        if (isShuttingDown()) {\n+            throw exceptionSupplier.get();\n+        }\n+    }\n+\n+    /**\n+     * Check whether this {@link ShutdownLatch} is waited on.\n+     *\n+     * @return {@code true} if the latch is waited on, {@code false} otherwise\n+     */\n+    public boolean isShuttingDown() {\n+        return latch != null;\n+    }\n+\n+    /**\n+     * Wait for this latch to complete all the operations given to it through {@link #increment()}.\n+     *\n+     * @return a {@link CompletableFuture} which completes once all operations are done\n+     */\n+    public CompletableFuture<Void> await() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2ef829cce30a13105fe9c1d1398f2e0141393a13"}, "originalPosition": 74}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM1MDY3NDcwOnYy", "diffSide": "RIGHT", "path": "messaging/src/main/java/org/axonframework/lifecycle/ShutdownLatch.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xNVQyMToxNzoxNFrOFqQnIQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xN1QxMTo0MzozMlrOFqhluA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTg1NjY3Mw==", "bodyText": "Why is this necessary? Components already have the \"freedom\" to wait for the CompletableFuture to complete with a timeout.", "url": "https://github.com/AxonFramework/AxonFramework/pull/1345#discussion_r379856673", "createdAt": "2020-02-15T21:17:14Z", "author": {"login": "abuijze"}, "path": "messaging/src/main/java/org/axonframework/lifecycle/ShutdownLatch.java", "diffHunk": "@@ -0,0 +1,98 @@\n+package org.axonframework.lifecycle;\n+\n+import java.time.Duration;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.function.Supplier;\n+\n+/**\n+ * A latch implementation to be used in shutdown scenarios. Operations to wait for can be added by invoking {@link\n+ * #increment()}. An added operation should always be removed through {@link #decrement()} once it has completed, as\n+ * {@link #await()} will otherwise block indefinitely. If the latch is waited on through {@link #await()}, new\n+ * operations can no longer be added.\n+ *\n+ * @author Steven van Beelen\n+ * @since 4.3\n+ */\n+public class ShutdownLatch {\n+\n+    private final AtomicInteger operationCounter = new AtomicInteger(0);\n+    private CompletableFuture<Void> latch;\n+\n+    /**\n+     * Add an operation this latch should wait on before opening up. If this operation is called whilst {@link #await()}\n+     * is already called an {@link IllegalStateException} will be thrown.\n+     *\n+     * @throws IllegalStateException if {@link #await()} has been called prior to invoking this method\n+     */\n+    public void increment() {\n+        if (isShuttingDown()) {\n+            throw new IllegalStateException(\"No new operations can be added, since this latched is waited for.\");\n+        }\n+        operationCounter.incrementAndGet();\n+    }\n+\n+    /**\n+     * Remove an operation this latch waits on. This method should be invoked once the added operations has ended. This\n+     * method will complete the latch if {@link #await()} has been invoked abd all operations are removed.\n+     */\n+    public void decrement() {\n+        if (operationCounter.decrementAndGet() <= 0 && isShuttingDown()) {\n+            latch.complete(null);\n+        }\n+    }\n+\n+    /**\n+     * Check whether this {@link ShutdownLatch} is waited on. The exception retrieved from the {@code exceptionSupplier}\n+     * will be thrown if this latch is shutting down.\n+     *\n+     * @param exceptionSupplier a {@link Supplier} of a {@link RuntimeException} to throw if this latch is waited on\n+     */\n+    public void isShuttingDown(Supplier<RuntimeException> exceptionSupplier) {\n+        if (isShuttingDown()) {\n+            throw exceptionSupplier.get();\n+        }\n+    }\n+\n+    /**\n+     * Check whether this {@link ShutdownLatch} is waited on.\n+     *\n+     * @return {@code true} if the latch is waited on, {@code false} otherwise\n+     */\n+    public boolean isShuttingDown() {\n+        return latch != null;\n+    }\n+\n+    /**\n+     * Wait for this latch to complete all the operations given to it through {@link #increment()}.\n+     *\n+     * @return a {@link CompletableFuture} which completes once all operations are done\n+     */\n+    public CompletableFuture<Void> await() {\n+        latch = new CompletableFuture<>();\n+        return latch;\n+    }\n+\n+    /**\n+     * Wait for this latch to complete all the operations given to it through {@link #increment()}. If the given {@code\n+     * duration} has passed the returned {@link CompletableFuture} will be completed exceptionally.\n+     *\n+     * @param duration the time to wait for this latch to complete\n+     * @return a {@link CompletableFuture} which completes successfully once all operations are done or exceptionally\n+     * after the given {@code duration}\n+     */\n+    public CompletableFuture<Void> await(Duration duration) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2ef829cce30a13105fe9c1d1398f2e0141393a13"}, "originalPosition": 87}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDA3MzIzMA==", "bodyText": "If we for some reason want to have a duration on this method, it should be blocking. But I agree that we probably don't need this one.", "url": "https://github.com/AxonFramework/AxonFramework/pull/1345#discussion_r380073230", "createdAt": "2020-02-17T09:39:22Z", "author": {"login": "m1l4n54v1c"}, "path": "messaging/src/main/java/org/axonframework/lifecycle/ShutdownLatch.java", "diffHunk": "@@ -0,0 +1,98 @@\n+package org.axonframework.lifecycle;\n+\n+import java.time.Duration;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.function.Supplier;\n+\n+/**\n+ * A latch implementation to be used in shutdown scenarios. Operations to wait for can be added by invoking {@link\n+ * #increment()}. An added operation should always be removed through {@link #decrement()} once it has completed, as\n+ * {@link #await()} will otherwise block indefinitely. If the latch is waited on through {@link #await()}, new\n+ * operations can no longer be added.\n+ *\n+ * @author Steven van Beelen\n+ * @since 4.3\n+ */\n+public class ShutdownLatch {\n+\n+    private final AtomicInteger operationCounter = new AtomicInteger(0);\n+    private CompletableFuture<Void> latch;\n+\n+    /**\n+     * Add an operation this latch should wait on before opening up. If this operation is called whilst {@link #await()}\n+     * is already called an {@link IllegalStateException} will be thrown.\n+     *\n+     * @throws IllegalStateException if {@link #await()} has been called prior to invoking this method\n+     */\n+    public void increment() {\n+        if (isShuttingDown()) {\n+            throw new IllegalStateException(\"No new operations can be added, since this latched is waited for.\");\n+        }\n+        operationCounter.incrementAndGet();\n+    }\n+\n+    /**\n+     * Remove an operation this latch waits on. This method should be invoked once the added operations has ended. This\n+     * method will complete the latch if {@link #await()} has been invoked abd all operations are removed.\n+     */\n+    public void decrement() {\n+        if (operationCounter.decrementAndGet() <= 0 && isShuttingDown()) {\n+            latch.complete(null);\n+        }\n+    }\n+\n+    /**\n+     * Check whether this {@link ShutdownLatch} is waited on. The exception retrieved from the {@code exceptionSupplier}\n+     * will be thrown if this latch is shutting down.\n+     *\n+     * @param exceptionSupplier a {@link Supplier} of a {@link RuntimeException} to throw if this latch is waited on\n+     */\n+    public void isShuttingDown(Supplier<RuntimeException> exceptionSupplier) {\n+        if (isShuttingDown()) {\n+            throw exceptionSupplier.get();\n+        }\n+    }\n+\n+    /**\n+     * Check whether this {@link ShutdownLatch} is waited on.\n+     *\n+     * @return {@code true} if the latch is waited on, {@code false} otherwise\n+     */\n+    public boolean isShuttingDown() {\n+        return latch != null;\n+    }\n+\n+    /**\n+     * Wait for this latch to complete all the operations given to it through {@link #increment()}.\n+     *\n+     * @return a {@link CompletableFuture} which completes once all operations are done\n+     */\n+    public CompletableFuture<Void> await() {\n+        latch = new CompletableFuture<>();\n+        return latch;\n+    }\n+\n+    /**\n+     * Wait for this latch to complete all the operations given to it through {@link #increment()}. If the given {@code\n+     * duration} has passed the returned {@link CompletableFuture} will be completed exceptionally.\n+     *\n+     * @param duration the time to wait for this latch to complete\n+     * @return a {@link CompletableFuture} which completes successfully once all operations are done or exceptionally\n+     * after the given {@code duration}\n+     */\n+    public CompletableFuture<Void> await(Duration duration) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTg1NjY3Mw=="}, "originalCommit": {"oid": "2ef829cce30a13105fe9c1d1398f2e0141393a13"}, "originalPosition": 87}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDEzNDg0MA==", "bodyText": "It's not used, no. Felt nice to include. Let's call this premature optimization, which I'll drop in favor of conciseness.", "url": "https://github.com/AxonFramework/AxonFramework/pull/1345#discussion_r380134840", "createdAt": "2020-02-17T11:43:32Z", "author": {"login": "smcvb"}, "path": "messaging/src/main/java/org/axonframework/lifecycle/ShutdownLatch.java", "diffHunk": "@@ -0,0 +1,98 @@\n+package org.axonframework.lifecycle;\n+\n+import java.time.Duration;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.function.Supplier;\n+\n+/**\n+ * A latch implementation to be used in shutdown scenarios. Operations to wait for can be added by invoking {@link\n+ * #increment()}. An added operation should always be removed through {@link #decrement()} once it has completed, as\n+ * {@link #await()} will otherwise block indefinitely. If the latch is waited on through {@link #await()}, new\n+ * operations can no longer be added.\n+ *\n+ * @author Steven van Beelen\n+ * @since 4.3\n+ */\n+public class ShutdownLatch {\n+\n+    private final AtomicInteger operationCounter = new AtomicInteger(0);\n+    private CompletableFuture<Void> latch;\n+\n+    /**\n+     * Add an operation this latch should wait on before opening up. If this operation is called whilst {@link #await()}\n+     * is already called an {@link IllegalStateException} will be thrown.\n+     *\n+     * @throws IllegalStateException if {@link #await()} has been called prior to invoking this method\n+     */\n+    public void increment() {\n+        if (isShuttingDown()) {\n+            throw new IllegalStateException(\"No new operations can be added, since this latched is waited for.\");\n+        }\n+        operationCounter.incrementAndGet();\n+    }\n+\n+    /**\n+     * Remove an operation this latch waits on. This method should be invoked once the added operations has ended. This\n+     * method will complete the latch if {@link #await()} has been invoked abd all operations are removed.\n+     */\n+    public void decrement() {\n+        if (operationCounter.decrementAndGet() <= 0 && isShuttingDown()) {\n+            latch.complete(null);\n+        }\n+    }\n+\n+    /**\n+     * Check whether this {@link ShutdownLatch} is waited on. The exception retrieved from the {@code exceptionSupplier}\n+     * will be thrown if this latch is shutting down.\n+     *\n+     * @param exceptionSupplier a {@link Supplier} of a {@link RuntimeException} to throw if this latch is waited on\n+     */\n+    public void isShuttingDown(Supplier<RuntimeException> exceptionSupplier) {\n+        if (isShuttingDown()) {\n+            throw exceptionSupplier.get();\n+        }\n+    }\n+\n+    /**\n+     * Check whether this {@link ShutdownLatch} is waited on.\n+     *\n+     * @return {@code true} if the latch is waited on, {@code false} otherwise\n+     */\n+    public boolean isShuttingDown() {\n+        return latch != null;\n+    }\n+\n+    /**\n+     * Wait for this latch to complete all the operations given to it through {@link #increment()}.\n+     *\n+     * @return a {@link CompletableFuture} which completes once all operations are done\n+     */\n+    public CompletableFuture<Void> await() {\n+        latch = new CompletableFuture<>();\n+        return latch;\n+    }\n+\n+    /**\n+     * Wait for this latch to complete all the operations given to it through {@link #increment()}. If the given {@code\n+     * duration} has passed the returned {@link CompletableFuture} will be completed exceptionally.\n+     *\n+     * @param duration the time to wait for this latch to complete\n+     * @return a {@link CompletableFuture} which completes successfully once all operations are done or exceptionally\n+     * after the given {@code duration}\n+     */\n+    public CompletableFuture<Void> await(Duration duration) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTg1NjY3Mw=="}, "originalCommit": {"oid": "2ef829cce30a13105fe9c1d1398f2e0141393a13"}, "originalPosition": 87}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM1MDY3NTY0OnYy", "diffSide": "RIGHT", "path": "messaging/src/main/java/org/axonframework/messaging/annotation/ParameterResolverFactory.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xNVQyMToxOTo0OFrOFqQnnw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xN1QxMjozNDozNVrOFqi7Fg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTg1Njc5OQ==", "bodyText": "Strictly speaking, this is a backward-incompatible change...", "url": "https://github.com/AxonFramework/AxonFramework/pull/1345#discussion_r379856799", "createdAt": "2020-02-15T21:19:48Z", "author": {"login": "abuijze"}, "path": "messaging/src/main/java/org/axonframework/messaging/annotation/ParameterResolverFactory.java", "diffHunk": "@@ -52,5 +52,5 @@\n      * @param parameterIndex The index of the parameter to return a ParameterResolver for\n      * @return a suitable ParameterResolver, or {@code null} if none is found\n      */\n-    ParameterResolver createInstance(Executable executable, Parameter[] parameters, int parameterIndex);\n+    ParameterResolver<?> createInstance(Executable executable, Parameter[] parameters, int parameterIndex);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2ef829cce30a13105fe9c1d1398f2e0141393a13"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDE1NjY5NA==", "bodyText": "Of course...I'll place this \"warning inducing issue\" back in then.", "url": "https://github.com/AxonFramework/AxonFramework/pull/1345#discussion_r380156694", "createdAt": "2020-02-17T12:34:35Z", "author": {"login": "smcvb"}, "path": "messaging/src/main/java/org/axonframework/messaging/annotation/ParameterResolverFactory.java", "diffHunk": "@@ -52,5 +52,5 @@\n      * @param parameterIndex The index of the parameter to return a ParameterResolver for\n      * @return a suitable ParameterResolver, or {@code null} if none is found\n      */\n-    ParameterResolver createInstance(Executable executable, Parameter[] parameters, int parameterIndex);\n+    ParameterResolver<?> createInstance(Executable executable, Parameter[] parameters, int parameterIndex);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTg1Njc5OQ=="}, "originalCommit": {"oid": "2ef829cce30a13105fe9c1d1398f2e0141393a13"}, "originalPosition": 12}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM1MDY3ODkwOnYy", "diffSide": "LEFT", "path": "spring/src/main/java/org/axonframework/spring/config/EventHandlerRegistrar.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xNVQyMToyNzoxN1rOFqQpNw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xN1QxMjozODowN1rOFqjBAg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTg1NzIwNw==", "bodyText": "These methods were the reason this class implements SmartLifecycle. If this isn't necessary anymore, the SmartLifecycle methods can also be removed.", "url": "https://github.com/AxonFramework/AxonFramework/pull/1345#discussion_r379857207", "createdAt": "2020-02-15T21:27:17Z", "author": {"login": "abuijze"}, "path": "spring/src/main/java/org/axonframework/spring/config/EventHandlerRegistrar.java", "diffHunk": "@@ -84,13 +87,11 @@ public void stop(Runnable callback) {\n \n     @Override\n     public void start() {\n-        eventProcessingConfiguration.start();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2ef829cce30a13105fe9c1d1398f2e0141393a13"}, "originalPosition": 43}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDE1ODIxMA==", "bodyText": "Good point. I'll remove the SmartLifecycle implementation details from this class.", "url": "https://github.com/AxonFramework/AxonFramework/pull/1345#discussion_r380158210", "createdAt": "2020-02-17T12:38:07Z", "author": {"login": "smcvb"}, "path": "spring/src/main/java/org/axonframework/spring/config/EventHandlerRegistrar.java", "diffHunk": "@@ -84,13 +87,11 @@ public void stop(Runnable callback) {\n \n     @Override\n     public void start() {\n-        eventProcessingConfiguration.start();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTg1NzIwNw=="}, "originalCommit": {"oid": "2ef829cce30a13105fe9c1d1398f2e0141393a13"}, "originalPosition": 43}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3337, "cost": 1, "resetAt": "2021-11-12T11:18:39Z"}}}