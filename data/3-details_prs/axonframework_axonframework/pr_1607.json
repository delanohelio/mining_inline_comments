{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTIxNzM3MzM1", "number": 1607, "title": "[#1604] Create head token if tokenAt has no result", "bodyText": "The documentation of the StreamableMessageSource#createTokenAt(Instant) states the following:\n/**\n * Creates a token that tracks all events after given {@code dateTime}. If there is an event exactly at the given\n * {@code dateTime}, it will be tracked too.\n *\n * @param dateTime The date and time for determining criteria how the tracking token should be created. A tracking\n *                 token should point at very first event before this date and time.\n * @return a tracking token at the given {@code dateTime}, if there aren't events matching this criteria {@code\n * null} is returned\n * @throws UnsupportedOperationException if the implementation does not support the creation of time-based tokens\n */\n\nAs noted on the @param dateTime line, a create tracking token should point at the very first event before this date and time.\nIf the provided dateTime is a timestamp after the last event in the event store however, the JPA, JDBC and InMemory implementations of the EventStorageEngine defaulted to a null. Thus, a tail token.\nThis discrepancy between the implementation and the documentation is resolved in this PR, as such resolving #1604\nAs a side note, warnings have been removed from the MultiStreamableMessageSourceTest.", "createdAt": "2020-11-16T15:27:06Z", "url": "https://github.com/AxonFramework/AxonFramework/pull/1607", "merged": true, "mergeCommit": {"oid": "de430e1c59f28f4032a12cfd78c0720582f10319"}, "closed": true, "closedAt": "2020-11-20T12:45:51Z", "author": {"login": "smcvb"}, "timelineItems": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABddEx_qAH2gAyNTIxNzM3MzM1OmI1MzM3ZjdmMTVmZDk5ZmUxNjU5MGQyOTE1YTk1NGE0YThhNDY5ZjM=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdeUppKgH2gAyNTIxNzM3MzM1OjUwZDU5MDk0NDE0YWJkZjI1MTBkMDk4ODU1MzVjNTg5ZmE1MWJlMjU=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "b5337f7f15fd99fe16590d2915a954a4a8a469f3", "author": {"user": {"login": "smcvb", "name": "Steven van Beelen"}}, "url": "https://github.com/AxonFramework/AxonFramework/commit/b5337f7f15fd99fe16590d2915a954a4a8a469f3", "committedDate": "2020-11-16T13:15:16Z", "message": "Revert to head token in absence of results\n\nIf no result is found on the createTokenAt, we assume the dateTime is\nafter the last event in the store. In that scenario we should default to\n the token at the last event in the store. If the assumption is\n incorrect, that would typically mean there are no events in the store\n anyhow, hence meaning the result of \"the last event in the store\"\n equals the original result.\n\n#1604"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "37b8ac1c75468c5b636fc9072c93a529e73c91b0", "author": {"user": {"login": "smcvb", "name": "Steven van Beelen"}}, "url": "https://github.com/AxonFramework/AxonFramework/commit/37b8ac1c75468c5b636fc9072c93a529e73c91b0", "committedDate": "2020-11-16T15:20:26Z", "message": "Fix tests\n\nThe MultiStreamableMessageSourceTest assumed null tokens on several\nspots when using createTokenAt, whilst this behaviour is changed towards\n a head token if the timestamp is greater than the most recent event\n\n#1604"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "66034fe34834390c9f6ccaa5e745d0e4826edf7d", "author": {"user": {"login": "smcvb", "name": "Steven van Beelen"}}, "url": "https://github.com/AxonFramework/AxonFramework/commit/66034fe34834390c9f6ccaa5e745d0e4826edf7d", "committedDate": "2020-11-16T15:27:25Z", "message": "Adjust indentation\n\nAdjust indentation\n\n#1604"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "343d2e8e30493421d8c2f0b5d2574d9f63ee85d5", "author": {"user": {"login": "smcvb", "name": "Steven van Beelen"}}, "url": "https://github.com/AxonFramework/AxonFramework/commit/343d2e8e30493421d8c2f0b5d2574d9f63ee85d5", "committedDate": "2020-11-17T08:00:54Z", "message": "Add test case validating token timestamp before first event\n\nIf the provided timestamp is before the first event in the store, it\nshould return the position of the first event. Validating this behaviour\n should be included in the test cases.\n\n#1604"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTMyMTk5Mjk1", "url": "https://github.com/AxonFramework/AxonFramework/pull/1607#pullrequestreview-532199295", "createdAt": "2020-11-17T10:00:36Z", "commit": {"oid": "343d2e8e30493421d8c2f0b5d2574d9f63ee85d5"}, "state": "APPROVED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xN1QxMDowMDozNlrOH0tLDA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xN1QxMDoyMTozOVrOH0uADQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTAyODEwOA==", "bodyText": "I feel like the method should include the word index somewhere. And since you created this for head, we can have something similar for tail as we are doing almost the same thing at createTailToken - to have it consistent.", "url": "https://github.com/AxonFramework/AxonFramework/pull/1607#discussion_r525028108", "createdAt": "2020-11-17T10:00:36Z", "author": {"login": "lfgcampos"}, "path": "eventsourcing/src/main/java/org/axonframework/eventsourcing/eventstore/jdbc/JdbcEventStorageEngine.java", "diffHunk": "@@ -418,37 +431,40 @@ public TrackingToken createTailToken() {\n                 resultSet -> nextAndExtract(resultSet, 1, Long.class),\n                 e -> new EventStoreException(\"Failed to get tail token\", e)\n         ));\n-        return Optional.ofNullable(index)\n-                       .map(seq -> GapAwareTrackingToken.newInstance(seq, Collections.emptySet()))\n-                       .orElse(null);\n+        return createToken(index);\n     }\n \n     @Override\n     public TrackingToken createHeadToken() {\n+        return createToken(mostRecentToken());\n+    }\n+\n+    @Override\n+    public TrackingToken createTokenAt(Instant dateTime) {\n         Long index = transactionManager.fetchInTransaction(() -> executeQuery(\n+                getConnection(),\n+                connection -> createTokenAt(connection, dateTime),\n+                resultSet -> nextAndExtract(resultSet, 1, Long.class),\n+                e -> new EventStoreException(format(\"Failed to get token at [%s]\", dateTime), e)\n+        ));\n+        return index != null ? createToken(index) : createToken(mostRecentToken());\n+    }\n+\n+    private Long mostRecentToken() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "343d2e8e30493421d8c2f0b5d2574d9f63ee85d5"}, "originalPosition": 53}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTAzNjk2OA==", "bodyText": "nit: silly line break here", "url": "https://github.com/AxonFramework/AxonFramework/pull/1607#discussion_r525036968", "createdAt": "2020-11-17T10:14:22Z", "author": {"login": "lfgcampos"}, "path": "eventsourcing/src/test/java/org/axonframework/eventsourcing/MultiStreamableMessageSourceTest.java", "diffHunk": "@@ -257,74 +257,103 @@ void peekWithMultipleStreams() throws InterruptedException {\n         singleEventStream.close();\n     }\n \n+    /**\n+     * Create a timestamp a bit prior to {@link Instant#now()}. This can for example be used on {@link\n+     * StreamableMessageSource#createTokenAt(Instant)} right after the insertion of some events, so that the created\n+     * token will take in these new events. Simply using {@link Instant#now()} allows for a window of opportunity which\n+     * misses these recent events.\n+     *\n+     * @return a timestamp a bit prior to {@link Instant#now()}\n+     */\n+    private static Instant recentTimeStamp() {\n+        return Instant.now().minusMillis(1000);\n+    }\n+\n     @Test\n     void createTailToken() {\n-        EventMessage pubToStreamA = GenericEventMessage.asEventMessage(\"Event1\");\n+        EventMessage<?> pubToStreamA = GenericEventMessage.asEventMessage(\"Event1\");\n         eventStoreA.publish(pubToStreamA);\n \n-        EventMessage pubToStreamB = GenericEventMessage.asEventMessage(\"Event2\");\n+        EventMessage<?> pubToStreamB = GenericEventMessage.asEventMessage(\"Event2\");\n         eventStoreB.publish(pubToStreamB);\n \n         MultiSourceTrackingToken tailToken = testSubject.createTailToken();\n \n-        assertEquals(-1L, tailToken.getTokenForStream(\"eventStoreA\").position().getAsLong());\n-        assertEquals(-1L, tailToken.getTokenForStream(\"eventStoreB\").position().getAsLong());\n+        OptionalLong storeAPosition = tailToken.getTokenForStream(\"eventStoreA\").position();\n+        assertTrue(storeAPosition.isPresent());\n+        assertEquals(-1L, storeAPosition.getAsLong());\n+        OptionalLong storeBPosition = tailToken.getTokenForStream(\"eventStoreB\").position();\n+        assertTrue(storeBPosition.isPresent());\n+        assertEquals(-1L, storeBPosition.getAsLong());\n     }\n \n     @Test\n     void createHeadToken() {\n-        EventMessage pubToStreamA = GenericEventMessage.asEventMessage(\"Event1\");\n+        EventMessage<?> pubToStreamA = GenericEventMessage.asEventMessage(\"Event1\");\n         eventStoreA.publish(pubToStreamA);\n \n-        EventMessage pubToStreamB = GenericEventMessage.asEventMessage(\"Event2\");\n+        EventMessage<?> pubToStreamB = GenericEventMessage.asEventMessage(\"Event2\");\n         eventStoreB.publish(pubToStreamB);\n         eventStoreB.publish(pubToStreamB);\n \n         MultiSourceTrackingToken headToken = testSubject.createHeadToken();\n \n-        assertEquals(0L, headToken.getTokenForStream(\"eventStoreA\").position().getAsLong());\n-        assertEquals(1L, headToken.getTokenForStream(\"eventStoreB\").position().getAsLong());\n+        OptionalLong storeAPosition = headToken.getTokenForStream(\"eventStoreA\").position();\n+        assertTrue(storeAPosition.isPresent());\n+        assertEquals(0L, storeAPosition.getAsLong());\n+        OptionalLong storeBPosition = headToken.getTokenForStream(\"eventStoreB\").position();\n+        assertTrue(storeBPosition.isPresent());\n+        assertEquals(1L, storeBPosition.getAsLong());\n     }\n \n     @Test\n     void createTokenAt() throws InterruptedException {\n-        EventMessage pubToStreamA = GenericEventMessage.asEventMessage(\"Event1\");\n+        EventMessage<?> pubToStreamA = GenericEventMessage.asEventMessage(\"Event1\");\n         eventStoreA.publish(pubToStreamA);\n         eventStoreA.publish(pubToStreamA);\n \n         Thread.sleep(20);\n \n-        EventMessage pubToStreamB = GenericEventMessage.asEventMessage(\"Event2\");\n+        EventMessage<?> pubToStreamB = GenericEventMessage.asEventMessage(\"Event2\");\n         eventStoreB.publish(pubToStreamB);\n \n-        MultiSourceTrackingToken createdAtToken = testSubject.createTokenAt(Instant.now().minus(10, ChronoUnit.MILLIS));\n-        //token should track events in eventStoreB and skip those in eventStoreA\n-        assertNull(createdAtToken.getTokenForStream(\"eventStoreA\"));\n-        assertEquals(-1L, createdAtToken.getTokenForStream(\"eventStoreB\").position().getAsLong());\n+        // Token should track events in eventStoreB and skip those in eventStoreA\n+        MultiSourceTrackingToken createdAtToken = testSubject.createTokenAt(Instant.now().minusMillis(10));\n+\n+        // storeA's token resembles an storeA head token since the create token at timestamp is after all its events\n+        assertEquals(eventStoreA.createHeadToken(), createdAtToken.getTokenForStream(\"eventStoreA\"));\n+        OptionalLong storeBPosition = createdAtToken.getTokenForStream(\"eventStoreB\").position();\n+        assertTrue(storeBPosition.isPresent());\n+        assertEquals(-1L, storeBPosition.getAsLong());\n     }\n \n     @Test\n     void createTokenSince() throws InterruptedException {\n-        EventMessage pubToStreamA = GenericEventMessage.asEventMessage(\"Event1\");\n+        EventMessage<?> pubToStreamA = GenericEventMessage.asEventMessage(\"Event1\");\n         eventStoreA.publish(pubToStreamA);\n         eventStoreA.publish(pubToStreamA);\n \n         Thread.sleep(20);\n \n-        EventMessage pubToStreamB = GenericEventMessage.asEventMessage(\"Event2\");\n+        EventMessage<?> pubToStreamB = GenericEventMessage.asEventMessage(\"Event2\");\n         eventStoreB.publish(pubToStreamB);\n \n+        // Token should track events in eventStoreB and skip those in eventStoreA\n         MultiSourceTrackingToken createdSinceToken = testSubject.createTokenSince(Duration.ofMillis(10));\n-        //token should track events in eventStoreB and skip those in eventStoreA\n-        assertNull(createdSinceToken.getTokenForStream(\"eventStoreA\"));\n-        assertEquals(-1L, createdSinceToken.getTokenForStream(\"eventStoreB\").position().getAsLong());\n+\n+        // storeA's token resembles an storeA head token since the create token at timestamp is after all its events\n+        assertEquals(eventStoreA.createHeadToken(), createdSinceToken.getTokenForStream(\"eventStoreA\"));\n+        OptionalLong storeBPosition = createdSinceToken.getTokenForStream(\"eventStoreB\").position();\n+        assertTrue(storeBPosition.isPresent());\n+        assertEquals(-1L, storeBPosition.getAsLong());\n     }\n \n     @Test\n     void configuredDifferentComparator() throws InterruptedException {\n         Comparator<Map.Entry<String, TrackedEventMessage<?>>> eventStoreAPriority =\n-                Comparator.comparing((Map.Entry<String, TrackedEventMessage<?>> e) -> !e.getKey().equals(\"eventStoreA\")).\n-                        thenComparing(e -> e.getValue().getTimestamp());\n+                Comparator.comparing((Map.Entry<String, TrackedEventMessage<?>> e) -> !e.getKey().equals(\"eventStoreA\"))\n+                          .", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "343d2e8e30493421d8c2f0b5d2574d9f63ee85d5"}, "originalPosition": 287}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTA0MTY3Nw==", "bodyText": "Same comment here, about having the word index somewhere.", "url": "https://github.com/AxonFramework/AxonFramework/pull/1607#discussion_r525041677", "createdAt": "2020-11-17T10:21:39Z", "author": {"login": "lfgcampos"}, "path": "eventsourcing/src/main/java/org/axonframework/eventsourcing/eventstore/jpa/JpaEventStorageEngine.java", "diffHunk": "@@ -325,27 +325,37 @@ public TrackingToken createTailToken() {\n \n     @Override\n     public TrackingToken createHeadToken() {\n-        List<Long> results = entityManager().createQuery(\n-                \"SELECT MAX(e.globalIndex) FROM \" + domainEventEntryEntityName() + \" e\", Long.class\n-        ).getResultList();\n-        return createToken(results);\n+        return createToken(mostRecentToken());\n     }\n \n     @Override\n     public TrackingToken createTokenAt(Instant dateTime) {\n-        List<Long> results = entityManager().createQuery(\n-                \"SELECT MIN(e.globalIndex) - 1 FROM \" + domainEventEntryEntityName()\n-                        + \" e WHERE e.timeStamp >= :dateTime\", Long.class\n-        ).setParameter(\"dateTime\", formatInstant(dateTime))\n-                                            .getResultList();\n-        return createToken(results);\n+        List<Long> results = entityManager()\n+                .createQuery(\n+                        \"SELECT MIN(e.globalIndex) - 1 FROM \" + domainEventEntryEntityName() + \" e \"\n+                                + \"WHERE e.timeStamp >= :dateTime\", Long.class\n+                )\n+                .setParameter(\"dateTime\", formatInstant(dateTime))\n+                .getResultList();\n+\n+        return noTokenFound(results) ? createToken(mostRecentToken()) : createToken(results);\n+    }\n+\n+    private List<Long> mostRecentToken() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "343d2e8e30493421d8c2f0b5d2574d9f63ee85d5"}, "originalPosition": 30}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9d4ba3a5e76e2e41aa8a451db7dc0f0c5910c7a5", "author": {"user": {"login": "smcvb", "name": "Steven van Beelen"}}, "url": "https://github.com/AxonFramework/AxonFramework/commit/9d4ba3a5e76e2e41aa8a451db7dc0f0c5910c7a5", "committedDate": "2020-11-17T11:03:58Z", "message": "Process review comments\n\n- Rename method to clarify it generates an index.\n- Adjust indentation"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTM1Mjg3MzU2", "url": "https://github.com/AxonFramework/AxonFramework/pull/1607#pullrequestreview-535287356", "createdAt": "2020-11-20T10:03:06Z", "commit": {"oid": "9d4ba3a5e76e2e41aa8a451db7dc0f0c5910c7a5"}, "state": "DISMISSED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yMFQxMDowMzowNlrOH3JE9g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yMFQxMDowMzowNlrOH3JE9g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzU4MjQ1NA==", "bodyText": "This construct causes \"createHeadToken\" to be called upon each call of \"createTokenAt\". That may be an expensive operation. Please use orElseGet(this::createHeadToken) instead.", "url": "https://github.com/AxonFramework/AxonFramework/pull/1607#discussion_r527582454", "createdAt": "2020-11-20T10:03:06Z", "author": {"login": "abuijze"}, "path": "eventsourcing/src/main/java/org/axonframework/eventsourcing/eventstore/inmemory/InMemoryEventStorageEngine.java", "diffHunk": "@@ -153,7 +153,8 @@ public TrackingToken createTokenAt(Instant dateTime) {\n                      .map(TrackedEventMessage::trackingToken)\n                      .map(tt -> (GlobalSequenceTrackingToken) tt)\n                      .map(tt -> new GlobalSequenceTrackingToken(tt.getGlobalIndex() - 1))\n-                     .orElse(null);\n+                     .map(tt -> (TrackingToken) tt)\n+                     .orElse(createHeadToken());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9d4ba3a5e76e2e41aa8a451db7dc0f0c5910c7a5"}, "originalPosition": 6}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "50d59094414abdf2510d09885535c589fa51be25", "author": {"user": {"login": "smcvb", "name": "Steven van Beelen"}}, "url": "https://github.com/AxonFramework/AxonFramework/commit/50d59094414abdf2510d09885535c589fa51be25", "committedDate": "2020-11-20T10:18:33Z", "message": "Do orElseGet i.o. orElse\n\nDo orElseGet to not always invoke createHeadToken on the createTokenAt\nmethod\n\n#1604"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2032, "cost": 1, "resetAt": "2021-11-01T11:59:11Z"}}}