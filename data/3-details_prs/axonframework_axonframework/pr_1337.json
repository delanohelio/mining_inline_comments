{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzcxMjQyODU2", "number": 1337, "title": "Reactive gateways.", "bodyText": "This PR introduces reactive gateways for command and queries.", "createdAt": "2020-02-05T08:28:49Z", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337", "merged": true, "mergeCommit": {"oid": "dfa54e5ec50f6ffae24610d6b7099a4c3337d91c"}, "closed": true, "closedAt": "2020-07-30T08:37:08Z", "author": {"login": "m1l4n54v1c"}, "timelineItems": {"totalCount": 122, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABc2yUTEgH2gAyMzcxMjQyODU2OmU5NTI5ZDE2ZjI1NzllM2JmZDA2NjkyMjg3YjliNWJkNzA0ODM2ZWU=", "endCursor": "Y3Vyc29yOnYyOpPPAAABc57dixAFqTQ1ODE5NzQwOQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "e9529d16f2579e3bfd06692287b9b5bd704836ee", "author": {"user": {"login": "m1l4n54v1c", "name": "Milan Savic"}}, "url": "https://github.com/AxonFramework/AxonFramework/commit/e9529d16f2579e3bfd06692287b9b5bd704836ee", "committedDate": "2020-07-20T14:15:25Z", "message": "Update messaging/src/main/java/org/axonframework/queryhandling/ReactorQueryGateway.java\n\nCo-authored-by: Steven van Beelen <steven.vanbeelen@axoniq.io>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1b1ea09fbd5c85fd9a6459d1b495185afef407c4", "author": {"user": {"login": "m1l4n54v1c", "name": "Milan Savic"}}, "url": "https://github.com/AxonFramework/AxonFramework/commit/1b1ea09fbd5c85fd9a6459d1b495185afef407c4", "committedDate": "2020-07-20T14:20:48Z", "message": "Update messaging/src/main/java/org/axonframework/queryhandling/ReactorQueryGateway.java\n\nCo-authored-by: Steven van Beelen <steven.vanbeelen@axoniq.io>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8ff710175ca33182f5a5bad48c32834a3f21f422", "author": {"user": {"login": "m1l4n54v1c", "name": "Milan Savic"}}, "url": "https://github.com/AxonFramework/AxonFramework/commit/8ff710175ca33182f5a5bad48c32834a3f21f422", "committedDate": "2020-07-20T14:26:45Z", "message": "Update messaging/src/main/java/org/axonframework/queryhandling/ReactorQueryGateway.java\n\nCo-authored-by: Steven van Beelen <steven.vanbeelen@axoniq.io>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ab0a931650e7642efc146e4088d9373aebc30c94", "author": {"user": {"login": "m1l4n54v1c", "name": "Milan Savic"}}, "url": "https://github.com/AxonFramework/AxonFramework/commit/ab0a931650e7642efc146e4088d9373aebc30c94", "committedDate": "2020-07-20T14:33:31Z", "message": "Update messaging/src/main/java/org/axonframework/queryhandling/ReactorQueryGateway.java\n\nCo-authored-by: Steven van Beelen <steven.vanbeelen@axoniq.io>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3d7566d67f94507f1b1f65d87414b456509b331b", "author": {"user": {"login": "m1l4n54v1c", "name": "Milan Savic"}}, "url": "https://github.com/AxonFramework/AxonFramework/commit/3d7566d67f94507f1b1f65d87414b456509b331b", "committedDate": "2020-07-20T14:34:45Z", "message": "Update messaging/src/main/java/org/axonframework/queryhandling/ReactorQueryGateway.java\n\nCo-authored-by: Steven van Beelen <steven.vanbeelen@axoniq.io>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "dd624ab3d84bb0d317f7af75b9d19505fd302bfe", "author": {"user": {"login": "m1l4n54v1c", "name": "Milan Savic"}}, "url": "https://github.com/AxonFramework/AxonFramework/commit/dd624ab3d84bb0d317f7af75b9d19505fd302bfe", "committedDate": "2020-07-20T14:35:30Z", "message": "Update messaging/src/main/java/org/axonframework/queryhandling/ReactorQueryGateway.java\n\nCo-authored-by: Steven van Beelen <steven.vanbeelen@axoniq.io>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a0ad8eb226c2f912a67415c91577814ac5907d16", "author": {"user": {"login": "m1l4n54v1c", "name": "Milan Savic"}}, "url": "https://github.com/AxonFramework/AxonFramework/commit/a0ad8eb226c2f912a67415c91577814ac5907d16", "committedDate": "2020-07-20T14:36:29Z", "message": "Update messaging/src/main/java/org/axonframework/queryhandling/ReactorQueryGateway.java\n\nCo-authored-by: Steven van Beelen <steven.vanbeelen@axoniq.io>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a405b511d9d26bacc42f8d2c437a834b4f0fd5c4", "author": {"user": {"login": "m1l4n54v1c", "name": "Milan Savic"}}, "url": "https://github.com/AxonFramework/AxonFramework/commit/a405b511d9d26bacc42f8d2c437a834b4f0fd5c4", "committedDate": "2020-07-20T15:07:33Z", "message": "Update messaging/src/main/java/org/axonframework/queryhandling/DefaultReactorQueryGateway.java\n\nCo-authored-by: Steven van Beelen <steven.vanbeelen@axoniq.io>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1a306018939b35904b579aeaa3b541a3c09e456d", "author": {"user": {"login": "m1l4n54v1c", "name": "Milan Savic"}}, "url": "https://github.com/AxonFramework/AxonFramework/commit/1a306018939b35904b579aeaa3b541a3c09e456d", "committedDate": "2020-07-20T15:13:51Z", "message": "Update messaging/src/main/java/org/axonframework/queryhandling/DefaultReactorQueryGateway.java\n\nCo-authored-by: Stefan An\u0111elkovi\u0107 <6233783+sandjelkovic@users.noreply.github.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5af6d40e0e6c54f5e8a7554c3f6956c4088219a4", "author": {"user": {"login": "m1l4n54v1c", "name": "Milan Savic"}}, "url": "https://github.com/AxonFramework/AxonFramework/commit/5af6d40e0e6c54f5e8a7554c3f6956c4088219a4", "committedDate": "2020-07-20T15:14:09Z", "message": "Update messaging/src/main/java/org/axonframework/queryhandling/ReactorQueryGateway.java\n\nCo-authored-by: Stefan An\u0111elkovi\u0107 <6233783+sandjelkovic@users.noreply.github.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b1184583fc50ca0b0ae81bdefc41b0a3772aa8f4", "author": {"user": {"login": "m1l4n54v1c", "name": "Milan Savic"}}, "url": "https://github.com/AxonFramework/AxonFramework/commit/b1184583fc50ca0b0ae81bdefc41b0a3772aa8f4", "committedDate": "2020-07-20T15:32:38Z", "message": "Processed review remarks."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0ad8abeb10df75f098d632f917dcb6715588e8aa", "author": {"user": {"login": "m1l4n54v1c", "name": "Milan Savic"}}, "url": "https://github.com/AxonFramework/AxonFramework/commit/0ad8abeb10df75f098d632f917dcb6715588e8aa", "committedDate": "2020-07-20T15:33:15Z", "message": "Merge branch 'master' into reactive-gateways"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "65a12c975a900e96412a6b2f2c5fa222cbcb07a1", "author": {"user": {"login": "m1l4n54v1c", "name": "Milan Savic"}}, "url": "https://github.com/AxonFramework/AxonFramework/commit/65a12c975a900e96412a6b2f2c5fa222cbcb07a1", "committedDate": "2020-07-21T09:39:19Z", "message": "Use Function.identity instead of creating new mono."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDUyNDkzOTg0", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#pullrequestreview-452493984", "createdAt": "2020-07-21T14:07:35Z", "commit": {"oid": "65a12c975a900e96412a6b2f2c5fa222cbcb07a1"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "bc60a808690d5b1eb3d6d80581ed59892813643d", "author": {"user": {"login": "m1l4n54v1c", "name": "Milan Savic"}}, "url": "https://github.com/AxonFramework/AxonFramework/commit/bc60a808690d5b1eb3d6d80581ed59892813643d", "committedDate": "2020-07-27T09:57:05Z", "message": "Merge branch 'master' into reactive-gateways"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9d2da7ff7507791063c95d39681098c708145c94", "author": {"user": {"login": "m1l4n54v1c", "name": "Milan Savic"}}, "url": "https://github.com/AxonFramework/AxonFramework/commit/9d2da7ff7507791063c95d39681098c708145c94", "committedDate": "2020-07-27T11:14:07Z", "message": "Adjusted indentation and JavaDoc."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU2Mzc5Nzky", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#pullrequestreview-456379792", "createdAt": "2020-07-28T07:42:48Z", "commit": {"oid": "9d2da7ff7507791063c95d39681098c708145c94"}, "state": "APPROVED", "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOFQwNzo0Mjo0OFrOG4AiaQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOFQwNzo1OToxMFrOG4BG4w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTM4MjI0OQ==", "bodyText": "Shouldn't these two be private final?", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r461382249", "createdAt": "2020-07-28T07:42:48Z", "author": {"login": "smcvb"}, "path": "messaging/src/main/java/org/axonframework/commandhandling/callbacks/ReactorCallback.java", "diffHunk": "@@ -0,0 +1,60 @@\n+/*\n+ * Copyright (c) 2010-2018. Axon Framework\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.axonframework.commandhandling.callbacks;\n+\n+import org.axonframework.commandhandling.CommandCallback;\n+import org.axonframework.commandhandling.CommandMessage;\n+import org.axonframework.commandhandling.CommandResultMessage;\n+import reactor.core.CoreSubscriber;\n+import reactor.core.publisher.EmitterProcessor;\n+import reactor.core.publisher.FluxSink;\n+import reactor.core.publisher.Mono;\n+\n+/**\n+ * Command Handler Callback that allows the dispatching thread to wait for the result of the callback, using the\n+ * Project Reactor mechanisms. This callback allows the caller to synchronize calls when an asynchronous command bus is\n+ * being used.\n+ *\n+ * @author Stefan Dragisic\n+ * @since 4.4\n+ *\n+ * @see CommandCallback\n+ * @see org.axonframework.commandhandling.CommandBus\n+ */\n+\n+public class ReactorCallback<C, R> extends Mono<CommandResultMessage<? extends R>> implements CommandCallback<C, R> {\n+\n+    EmitterProcessor<CommandResultMessage<? extends R>> commandResultMessageEmitter = EmitterProcessor.create(1);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9d2da7ff7507791063c95d39681098c708145c94"}, "originalPosition": 41}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTM4MjM1NA==", "bodyText": "Unintended empty line here.", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r461382354", "createdAt": "2020-07-28T07:43:01Z", "author": {"login": "smcvb"}, "path": "messaging/src/main/java/org/axonframework/commandhandling/callbacks/ReactorCallback.java", "diffHunk": "@@ -0,0 +1,60 @@\n+/*\n+ * Copyright (c) 2010-2018. Axon Framework\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.axonframework.commandhandling.callbacks;\n+\n+import org.axonframework.commandhandling.CommandCallback;\n+import org.axonframework.commandhandling.CommandMessage;\n+import org.axonframework.commandhandling.CommandResultMessage;\n+import reactor.core.CoreSubscriber;\n+import reactor.core.publisher.EmitterProcessor;\n+import reactor.core.publisher.FluxSink;\n+import reactor.core.publisher.Mono;\n+\n+/**\n+ * Command Handler Callback that allows the dispatching thread to wait for the result of the callback, using the\n+ * Project Reactor mechanisms. This callback allows the caller to synchronize calls when an asynchronous command bus is\n+ * being used.\n+ *\n+ * @author Stefan Dragisic\n+ * @since 4.4\n+ *\n+ * @see CommandCallback\n+ * @see org.axonframework.commandhandling.CommandBus\n+ */\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9d2da7ff7507791063c95d39681098c708145c94"}, "originalPosition": 38}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTM4Njc4NA==", "bodyText": "Sad to see this hasn't been discussed or altered, but just resolved ;-)", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r461386784", "createdAt": "2020-07-28T07:50:46Z", "author": {"login": "smcvb"}, "path": "messaging/src/main/java/org/axonframework/queryhandling/DefaultReactorQueryGateway.java", "diffHunk": "@@ -0,0 +1,318 @@\n+/*\n+ * Copyright (c) 2010-2020. Axon Framework\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.axonframework.queryhandling;\n+\n+import org.axonframework.commandhandling.CommandResultMessage;\n+import org.axonframework.common.AxonConfigurationException;\n+import org.axonframework.common.Registration;\n+import org.axonframework.messaging.ResultMessage;\n+import org.axonframework.messaging.reactive.ReactorMessageDispatchInterceptor;\n+import org.axonframework.messaging.reactive.ReactorResultHandlerInterceptor;\n+import org.axonframework.messaging.responsetypes.ResponseType;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Mono;\n+import reactor.util.function.Tuple2;\n+\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.concurrent.CopyOnWriteArrayList;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Function;\n+\n+import static java.util.Arrays.asList;\n+import static org.axonframework.common.BuilderUtils.assertNonNull;\n+import static org.axonframework.messaging.GenericMessage.asMessage;\n+\n+/**\n+ * Implementation of the {@link ReactorQueryGateway} that uses Project Reactor to achieve reactiveness.\n+ *\n+ * @author Milan Savic\n+ * @since 4.4\n+ */\n+public class DefaultReactorQueryGateway implements ReactorQueryGateway {\n+\n+    private final List<ReactorMessageDispatchInterceptor<QueryMessage<?, ?>>> dispatchInterceptors;\n+    private final List<ReactorResultHandlerInterceptor<QueryMessage<?, ?>, ResultMessage<?>>> resultInterceptors;\n+\n+    private final QueryBus queryBus;\n+\n+    /**\n+     * Creates an instance of {@link DefaultReactorQueryGateway} based on the fields contained in the {@link\n+     * Builder}.\n+     * <p>\n+     * Will assert that the {@link QueryBus} is not {@code null} and throws an {@link AxonConfigurationException} if\n+     * it is.\n+     * </p>\n+     *\n+     * @param builder the {@link Builder} used to instantiated a {@link DefaultReactorQueryGateway} instance\n+     */\n+    protected DefaultReactorQueryGateway(Builder builder) {\n+        builder.validate();\n+        this.queryBus = builder.queryBus;\n+        this.dispatchInterceptors = builder.dispatchInterceptors;\n+        this.resultInterceptors = builder.resultInterceptors;\n+    }\n+\n+    /**\n+     * Instantiate a Builder to be able to create a {@link DefaultReactorQueryGateway}.\n+     * <p>\n+     * The {@code dispatchInterceptors} are defaulted to an empty list.\n+     * The {@code resultHandlerInterceptors} are defaulted to an empty list.\n+     * The {@link QueryBus} is a <b>hard requirement</b> and as such should be provided.\n+     * </p>\n+     *\n+     * @return a Builder to be able to create a {@link DefaultReactorQueryGateway}\n+     */\n+    public static Builder builder() {\n+        return new Builder();\n+    }\n+\n+    @Override\n+    public Registration registerDispatchInterceptor(\n+            ReactorMessageDispatchInterceptor<QueryMessage<?, ?>> interceptor) {\n+        dispatchInterceptors.add(interceptor);\n+        return () -> dispatchInterceptors.remove(interceptor);\n+    }\n+\n+    @Override\n+    public Registration registerResultHandlerInterceptor(\n+            ReactorResultHandlerInterceptor<QueryMessage<?, ?>, ResultMessage<?>> interceptor) {\n+        resultInterceptors.add(interceptor);\n+        return () -> resultInterceptors.remove(interceptor);\n+    }\n+\n+    @Override\n+    public <R, Q> Mono<R> query(String queryName, Q query, ResponseType<R> responseType) {\n+        return Mono.<QueryMessage<?, ?>>fromCallable(() -> new GenericQueryMessage<>(asMessage(query),\n+                                                                                     queryName,\n+                                                                                     responseType))\n+                .transform(this::processDispatchInterceptors)\n+                .flatMap(this::dispatchQuery)\n+                .flatMapMany(this::processResultsInterceptors)\n+                .<R>transform(this::getPayload)\n+                .next();\n+    }\n+\n+    @Override\n+    public <R, Q> Flux<R> scatterGather(String queryName, Q query, ResponseType<R> responseType, long timeout,\n+                                        TimeUnit timeUnit) {\n+        return Mono.<QueryMessage<?, ?>>fromCallable(() -> new GenericQueryMessage<>(asMessage(query),\n+                                                                                     queryName,\n+                                                                                     responseType))\n+                .transform(this::processDispatchInterceptors)\n+                .flatMap(q -> dispatchScatterGatherQuery(q, timeout, timeUnit))\n+                .flatMapMany(this::processResultsInterceptors)\n+                .transform(this::getPayload);\n+    }\n+\n+    @Override\n+    public <Q, I, U> Mono<SubscriptionQueryResult<I, U>> subscriptionQuery(String queryName, Q query,\n+                                                                           ResponseType<I> initialResponseType,\n+                                                                           ResponseType<U> updateResponseType,\n+                                                                           SubscriptionQueryBackpressure backpressure,\n+                                                                           int updateBufferSize) {\n+\n+        //noinspection unchecked\n+        return Mono.<QueryMessage<?, ?>>fromCallable(() -> new GenericSubscriptionQueryMessage<>(query,\n+                                                                                                 initialResponseType,\n+                                                                                                 updateResponseType))\n+                .transform(this::processDispatchInterceptors)\n+                .map(isq -> (SubscriptionQueryMessage<Q, U, I>) isq)\n+                .flatMap(isq -> dispatchSubscriptionQuery(isq, backpressure, updateBufferSize))\n+                .flatMap(processSubscriptionQueryResult());\n+    }\n+\n+\n+    private Mono<Tuple2<QueryMessage<?, ?>, Flux<ResultMessage<?>>>> dispatchQuery(QueryMessage<?, ?> queryMessage) {\n+        Flux<ResultMessage<?>> results = Flux\n+                .defer(() -> Mono.fromFuture(queryBus.query(queryMessage)));\n+\n+        return Mono.<QueryMessage<?, ?>>just(queryMessage)\n+                .zipWith(Mono.just(results));\n+    }\n+\n+    private Mono<Tuple2<QueryMessage<?, ?>, Flux<ResultMessage<?>>>> dispatchScatterGatherQuery(\n+            QueryMessage<?, ?> queryMessage, long timeout, TimeUnit timeUnit) {\n+        Flux<ResultMessage<?>> results = Flux\n+                .defer(() -> Flux.fromStream(queryBus.scatterGather(queryMessage,\n+                                                                    timeout,\n+                                                                    timeUnit)));\n+\n+        return Mono.<QueryMessage<?, ?>>just(queryMessage)\n+                .zipWith(Mono.just(results));\n+    }\n+\n+    private <Q, I, U> Mono<Tuple2<QueryMessage<Q, I>, Mono<SubscriptionQueryResult<QueryResponseMessage<I>, SubscriptionQueryUpdateMessage<U>>>>> dispatchSubscriptionQuery(\n+            SubscriptionQueryMessage<Q, I, U> queryMessage, SubscriptionQueryBackpressure backpressure,\n+            int updateBufferSize) {\n+        Mono<SubscriptionQueryResult<QueryResponseMessage<I>, SubscriptionQueryUpdateMessage<U>>> result = Mono\n+                .fromCallable(() -> queryBus.subscriptionQuery(queryMessage, backpressure, updateBufferSize));\n+        return Mono.<QueryMessage<Q, I>>just(queryMessage)\n+                .zipWith(Mono.just(result));\n+    }\n+\n+    private Mono<QueryMessage<?, ?>> processDispatchInterceptors(Mono<QueryMessage<?, ?>> queryMessageMono) {\n+        return Flux.fromIterable(dispatchInterceptors)\n+                   .reduce(queryMessageMono, (queryMessage, interceptor) -> interceptor.intercept(queryMessage))\n+                   .flatMap(Mono::from);\n+    }\n+\n+    private Flux<ResultMessage<?>> processResultsInterceptors(\n+            Tuple2<QueryMessage<?, ?>, Flux<ResultMessage<?>>> queryWithResponses) {\n+        QueryMessage<?, ?> queryMessage = queryWithResponses.getT1();\n+        Flux<ResultMessage<?>> queryResultMessage = queryWithResponses.getT2();\n+\n+        return Flux.fromIterable(resultInterceptors)\n+                   .reduce(queryResultMessage,\n+                           (result, interceptor) -> interceptor.intercept(queryMessage, result))\n+                   .flatMapMany(it -> it);\n+    }\n+\n+    private <Q, I, U> Function<Tuple2<QueryMessage<Q, U>,\n+            Mono<SubscriptionQueryResult<QueryResponseMessage<U>, SubscriptionQueryUpdateMessage<I>>>>,\n+            Mono<SubscriptionQueryResult<I, U>>> processSubscriptionQueryResult() {\n+\n+        return messageWithResult -> messageWithResult.getT2().map(sqr -> {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjgxNDE5MA=="}, "originalCommit": {"oid": "98865ab1427e4d879301c1bf542842eccc8aa3c3"}, "originalPosition": 189}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTM4NzEwMg==", "bodyText": "Sad to see this hasn't been discussed or altered, but just resolved ;-)", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r461387102", "createdAt": "2020-07-28T07:51:20Z", "author": {"login": "smcvb"}, "path": "messaging/src/main/java/org/axonframework/queryhandling/DefaultReactorQueryGateway.java", "diffHunk": "@@ -0,0 +1,318 @@\n+/*\n+ * Copyright (c) 2010-2020. Axon Framework\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.axonframework.queryhandling;\n+\n+import org.axonframework.commandhandling.CommandResultMessage;\n+import org.axonframework.common.AxonConfigurationException;\n+import org.axonframework.common.Registration;\n+import org.axonframework.messaging.ResultMessage;\n+import org.axonframework.messaging.reactive.ReactorMessageDispatchInterceptor;\n+import org.axonframework.messaging.reactive.ReactorResultHandlerInterceptor;\n+import org.axonframework.messaging.responsetypes.ResponseType;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Mono;\n+import reactor.util.function.Tuple2;\n+\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.concurrent.CopyOnWriteArrayList;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Function;\n+\n+import static java.util.Arrays.asList;\n+import static org.axonframework.common.BuilderUtils.assertNonNull;\n+import static org.axonframework.messaging.GenericMessage.asMessage;\n+\n+/**\n+ * Implementation of the {@link ReactorQueryGateway} that uses Project Reactor to achieve reactiveness.\n+ *\n+ * @author Milan Savic\n+ * @since 4.4\n+ */\n+public class DefaultReactorQueryGateway implements ReactorQueryGateway {\n+\n+    private final List<ReactorMessageDispatchInterceptor<QueryMessage<?, ?>>> dispatchInterceptors;\n+    private final List<ReactorResultHandlerInterceptor<QueryMessage<?, ?>, ResultMessage<?>>> resultInterceptors;\n+\n+    private final QueryBus queryBus;\n+\n+    /**\n+     * Creates an instance of {@link DefaultReactorQueryGateway} based on the fields contained in the {@link\n+     * Builder}.\n+     * <p>\n+     * Will assert that the {@link QueryBus} is not {@code null} and throws an {@link AxonConfigurationException} if\n+     * it is.\n+     * </p>\n+     *\n+     * @param builder the {@link Builder} used to instantiated a {@link DefaultReactorQueryGateway} instance\n+     */\n+    protected DefaultReactorQueryGateway(Builder builder) {\n+        builder.validate();\n+        this.queryBus = builder.queryBus;\n+        this.dispatchInterceptors = builder.dispatchInterceptors;\n+        this.resultInterceptors = builder.resultInterceptors;\n+    }\n+\n+    /**\n+     * Instantiate a Builder to be able to create a {@link DefaultReactorQueryGateway}.\n+     * <p>\n+     * The {@code dispatchInterceptors} are defaulted to an empty list.\n+     * The {@code resultHandlerInterceptors} are defaulted to an empty list.\n+     * The {@link QueryBus} is a <b>hard requirement</b> and as such should be provided.\n+     * </p>\n+     *\n+     * @return a Builder to be able to create a {@link DefaultReactorQueryGateway}\n+     */\n+    public static Builder builder() {\n+        return new Builder();\n+    }\n+\n+    @Override\n+    public Registration registerDispatchInterceptor(\n+            ReactorMessageDispatchInterceptor<QueryMessage<?, ?>> interceptor) {\n+        dispatchInterceptors.add(interceptor);\n+        return () -> dispatchInterceptors.remove(interceptor);\n+    }\n+\n+    @Override\n+    public Registration registerResultHandlerInterceptor(\n+            ReactorResultHandlerInterceptor<QueryMessage<?, ?>, ResultMessage<?>> interceptor) {\n+        resultInterceptors.add(interceptor);\n+        return () -> resultInterceptors.remove(interceptor);\n+    }\n+\n+    @Override\n+    public <R, Q> Mono<R> query(String queryName, Q query, ResponseType<R> responseType) {\n+        return Mono.<QueryMessage<?, ?>>fromCallable(() -> new GenericQueryMessage<>(asMessage(query),\n+                                                                                     queryName,\n+                                                                                     responseType))\n+                .transform(this::processDispatchInterceptors)\n+                .flatMap(this::dispatchQuery)\n+                .flatMapMany(this::processResultsInterceptors)\n+                .<R>transform(this::getPayload)\n+                .next();\n+    }\n+\n+    @Override\n+    public <R, Q> Flux<R> scatterGather(String queryName, Q query, ResponseType<R> responseType, long timeout,\n+                                        TimeUnit timeUnit) {\n+        return Mono.<QueryMessage<?, ?>>fromCallable(() -> new GenericQueryMessage<>(asMessage(query),\n+                                                                                     queryName,\n+                                                                                     responseType))\n+                .transform(this::processDispatchInterceptors)\n+                .flatMap(q -> dispatchScatterGatherQuery(q, timeout, timeUnit))\n+                .flatMapMany(this::processResultsInterceptors)\n+                .transform(this::getPayload);\n+    }\n+\n+    @Override\n+    public <Q, I, U> Mono<SubscriptionQueryResult<I, U>> subscriptionQuery(String queryName, Q query,\n+                                                                           ResponseType<I> initialResponseType,\n+                                                                           ResponseType<U> updateResponseType,\n+                                                                           SubscriptionQueryBackpressure backpressure,\n+                                                                           int updateBufferSize) {\n+\n+        //noinspection unchecked\n+        return Mono.<QueryMessage<?, ?>>fromCallable(() -> new GenericSubscriptionQueryMessage<>(query,\n+                                                                                                 initialResponseType,\n+                                                                                                 updateResponseType))\n+                .transform(this::processDispatchInterceptors)\n+                .map(isq -> (SubscriptionQueryMessage<Q, U, I>) isq)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjgxMjIwMQ=="}, "originalCommit": {"oid": "98865ab1427e4d879301c1bf542842eccc8aa3c3"}, "originalPosition": 134}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTM5MTU4Nw==", "bodyText": "My intention was to change this to q to mirror the emit calls. But as stated, this is definitely a nit.", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r461391587", "createdAt": "2020-07-28T07:59:10Z", "author": {"login": "smcvb"}, "path": "messaging/src/test/java/org/axonframework/queryhandling/DefaultReactorQueryGatewayTest.java", "diffHunk": "@@ -0,0 +1,780 @@\n+/*\n+ * Copyright (c) 2010-2020. Axon Framework\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.axonframework.queryhandling;\n+\n+import org.axonframework.common.Registration;\n+import org.axonframework.messaging.MessageHandler;\n+import org.axonframework.messaging.ResultMessage;\n+import org.axonframework.messaging.responsetypes.ResponseTypes;\n+import org.junit.jupiter.api.*;\n+import org.junit.jupiter.api.extension.*;\n+import org.mockito.junit.jupiter.*;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Hooks;\n+import reactor.core.publisher.Mono;\n+import reactor.test.StepVerifier;\n+import reactor.util.context.Context;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+\n+import static org.axonframework.common.ReflectionUtils.methodOf;\n+import static org.junit.jupiter.api.Assertions.*;\n+import static org.mockito.Mockito.*;\n+\n+/**\n+ * Tests for {@link DefaultReactorQueryGateway}.\n+ *\n+ * @author Milan Savic\n+ */\n+@ExtendWith(MockitoExtension.class)\n+class DefaultReactorQueryGatewayTest {\n+\n+    private DefaultReactorQueryGateway reactiveQueryGateway;\n+    private QueryUpdateEmitter queryUpdateEmitter;\n+    private MessageHandler<QueryMessage<?, Object>> queryMessageHandler1;\n+    private MessageHandler<QueryMessage<?, Object>> queryMessageHandler2;\n+    private MessageHandler<QueryMessage<?, Object>> queryMessageHandler3;\n+    private SimpleQueryBus queryBus;\n+\n+    @BeforeEach\n+    void setUp() throws NoSuchMethodException {\n+        Hooks.enableContextLossTracking();\n+        Hooks.onOperatorDebug();\n+\n+        queryBus = spy(SimpleQueryBus.builder().build());\n+\n+        queryUpdateEmitter = queryBus.queryUpdateEmitter();\n+        AtomicInteger count = new AtomicInteger();\n+        queryMessageHandler1 = spy(new MessageHandler<QueryMessage<?, Object>>() {\n+\n+            @Override\n+            public Object handle(QueryMessage<?, Object> message) {\n+                if (\"backpressure\".equals(message.getPayload())) {\n+                    return count.incrementAndGet();\n+                }\n+                return \"handled\";\n+            }\n+        });\n+        queryMessageHandler2 = spy(new MessageHandler<QueryMessage<?, Object>>() {\n+            @Override\n+            public Object handle(QueryMessage<?, Object> message) {\n+                if (\"backpressure\".equals(message.getPayload())) {\n+                    return count.incrementAndGet();\n+                }\n+                return \"handled\";\n+            }\n+        });\n+\n+        queryMessageHandler3 = spy(new MessageHandler<QueryMessage<?, Object>>() {\n+            @Override\n+            public Object handle(QueryMessage<?, Object> message) {\n+                throw new RuntimeException();\n+            }\n+        });\n+\n+        queryBus.subscribe(String.class.getName(), String.class, queryMessageHandler1);\n+        queryBus.subscribe(String.class.getName(), String.class, queryMessageHandler2);\n+        queryBus.subscribe(Integer.class.getName(), Integer.class, queryMessageHandler3);\n+\n+        queryBus.subscribe(Boolean.class.getName(),\n+                           String.class,\n+                           message -> \"\" + message.getMetaData().getOrDefault(\"key1\", \"\")\n+                                   + message.getMetaData().getOrDefault(\"key2\", \"\"));\n+\n+        queryBus.subscribe(Long.class.getName(), String.class, message -> null);\n+\n+        queryBus.subscribe(Double.class.getName(),\n+                           methodOf(this.getClass(), \"stringListQueryHandler\").getGenericReturnType(),\n+                           message -> Arrays.asList(\"value1\", \"value2\", \"value3\"));\n+\n+        reactiveQueryGateway = DefaultReactorQueryGateway.builder()\n+                                                         .queryBus(queryBus)\n+                                                         .build();\n+    }\n+\n+    @SuppressWarnings(\"unused\") // Used by 'testSubscriptionQueryMany()' to generate query handler response type\n+    public List<String> stringListQueryHandler() {\n+        return new ArrayList<>();\n+    }\n+\n+    @Test\n+    void testQuery() throws Exception {\n+\n+        Mono<String> result = reactiveQueryGateway.query(\"criteria\", String.class);\n+        verifyZeroInteractions(queryMessageHandler1);\n+        verifyZeroInteractions(queryMessageHandler2);\n+        StepVerifier.create(result)\n+                    .expectNext(\"handled\")\n+                    .verifyComplete();\n+        verify(queryMessageHandler1).handle(any());\n+    }\n+\n+    @Test\n+    void testQueryWithContext() throws Exception {\n+        Context context = Context.of(\"k1\", \"v1\");\n+\n+        Mono<String> result = reactiveQueryGateway.query(\"criteria\", String.class).subscriberContext(context);\n+\n+        verifyZeroInteractions(queryMessageHandler1);\n+        verifyZeroInteractions(queryMessageHandler2);\n+        StepVerifier.create(result)\n+                    .expectNext(\"handled\")\n+                    .expectAccessibleContext()\n+                    .containsOnly(context)\n+                    .then()\n+                    .verifyComplete();\n+        verify(queryMessageHandler1).handle(any());\n+    }\n+\n+    @Test\n+    void testMultipleQueries() throws Exception {\n+        Flux<QueryMessage<?, ?>> queries = Flux.fromIterable(Arrays.asList(\n+                new GenericQueryMessage<>(\"query1\", ResponseTypes.instanceOf(String.class)),\n+                new GenericQueryMessage<>(4, ResponseTypes.instanceOf(Integer.class)),\n+                new GenericQueryMessage<>(\"query2\", ResponseTypes.instanceOf(String.class)),\n+                new GenericQueryMessage<>(5, ResponseTypes.instanceOf(Integer.class)),\n+                new GenericQueryMessage<>(true, ResponseTypes.instanceOf(String.class))));\n+\n+        Flux<Object> result = reactiveQueryGateway.query(queries);\n+        verifyZeroInteractions(queryMessageHandler1);\n+        verifyZeroInteractions(queryMessageHandler2);\n+\n+        List<Throwable> exceptions = new ArrayList<>(2);\n+        StepVerifier.create(result.onErrorContinue((t, o) -> exceptions.add(t)))\n+                    .expectNext(\"handled\", \"handled\", \"\")\n+                    .verifyComplete();\n+\n+        assertEquals(2, exceptions.size());\n+        assertTrue(exceptions.get(0) instanceof RuntimeException);\n+        assertTrue(exceptions.get(1) instanceof RuntimeException);\n+        verify(queryMessageHandler1, times(2)).handle(any());\n+    }\n+\n+    @Test\n+    void testMultipleQueriesOrdering() throws Exception {\n+        int numberOfQueries = 10_000;\n+        Flux<QueryMessage<?, ?>> queries = Flux\n+                .fromStream(IntStream.range(0, numberOfQueries)\n+                                     .mapToObj(i -> new GenericQueryMessage<>(\"backpressure\",\n+                                                                              ResponseTypes.instanceOf(String.class))));\n+        List<Integer> expectedResults = IntStream.range(1, numberOfQueries + 1)\n+                                                 .boxed()\n+                                                 .collect(Collectors.toList());\n+        Flux<Object> result = reactiveQueryGateway.query(queries);\n+        StepVerifier.create(result)\n+                    .expectNext(expectedResults.toArray(new Integer[0]))\n+                    .verifyComplete();\n+        verify(queryMessageHandler1, times(numberOfQueries)).handle(any());\n+    }\n+\n+    @Test\n+    void testQueryReturningNull() {\n+        assertNull(reactiveQueryGateway.query(0L, String.class).block());\n+        StepVerifier.create(reactiveQueryGateway.query(0L, String.class))\n+                    .expectComplete()\n+                    .verify();\n+    }\n+\n+    @Test\n+    void testQueryWithDispatchInterceptor() {\n+        reactiveQueryGateway\n+                .registerDispatchInterceptor(queryMono -> queryMono\n+                        .map(query -> query.andMetaData(Collections.singletonMap(\"key1\", \"value1\"))));\n+        Registration registration2 = reactiveQueryGateway\n+                .registerDispatchInterceptor(queryMono -> queryMono\n+                        .map(query -> query.andMetaData(Collections.singletonMap(\"key2\", \"value2\"))));\n+\n+        StepVerifier.create(reactiveQueryGateway.query(true, String.class))\n+                    .expectNext(\"value1value2\")\n+                    .verifyComplete();\n+\n+        registration2.cancel();\n+\n+        StepVerifier.create(reactiveQueryGateway.query(true, String.class))\n+                    .expectNext(\"value1\")\n+                    .verifyComplete();\n+    }\n+\n+    @Test\n+    void testQueryWithDispatchInterceptorWithContext() {\n+        Context context = Context.of(\"security\", true);\n+\n+        reactiveQueryGateway\n+                .registerDispatchInterceptor(queryMono -> queryMono\n+                        .filterWhen(v -> Mono.subscriberContext()\n+                                             .filter(ctx -> ctx.hasKey(\"security\"))\n+                                             .map(ctx -> ctx.get(\"security\")))\n+                        .map(query -> query.andMetaData(Collections.singletonMap(\"key1\", \"value1\"))));\n+\n+        StepVerifier.create(reactiveQueryGateway.query(true, String.class).subscriberContext(context))\n+                    .expectNext(\"value1\")\n+                    .expectAccessibleContext()\n+                    .containsOnly(context)\n+                    .then()\n+                    .verifyComplete();\n+    }\n+\n+    @Test\n+    void testQueryWithResultInterceptorAlterResult() throws Exception {\n+        reactiveQueryGateway.registerResultHandlerInterceptor((q, results) -> results\n+                .map(it -> new GenericQueryResponseMessage<>(\"handled-modified\")));\n+\n+        Mono<String> result = reactiveQueryGateway.query(\"criteria\", String.class);\n+        verifyZeroInteractions(queryMessageHandler1);\n+        verifyZeroInteractions(queryMessageHandler2);\n+        StepVerifier.create(result)\n+                    .expectNext(\"handled-modified\")\n+                    .verifyComplete();\n+        verify(queryMessageHandler1).handle(any());\n+    }\n+\n+    @Test\n+    void testQueryWithResultInterceptorFilterResult() throws Exception {\n+        reactiveQueryGateway.registerResultHandlerInterceptor((q, results) -> results\n+                .filter(it -> !it.getPayload().equals(\"handled\")));\n+\n+        Mono<String> result = reactiveQueryGateway.query(\"criteria\", String.class);\n+        verifyZeroInteractions(queryMessageHandler1);\n+        verifyZeroInteractions(queryMessageHandler2);\n+        StepVerifier.create(result)\n+                    .expectComplete()\n+                    .verify();\n+        verify(queryMessageHandler1).handle(any());\n+    }\n+\n+    @Test\n+    void testQueryWithDispatchInterceptorThrowingAnException() {\n+        reactiveQueryGateway\n+                .registerDispatchInterceptor(queryMono -> {\n+                    throw new RuntimeException();\n+                });\n+        StepVerifier.create(reactiveQueryGateway.query(true, String.class))\n+                    .verifyError(RuntimeException.class);\n+    }\n+\n+    @Test\n+    void testQueryWithDispatchInterceptorReturningErrorMono() {\n+        reactiveQueryGateway\n+                .registerDispatchInterceptor(queryMono -> Mono.error(new RuntimeException()));\n+        StepVerifier.create(reactiveQueryGateway.query(true, String.class))\n+                    .verifyError(RuntimeException.class);\n+    }\n+\n+    @Test\n+    void testQueryFails() {\n+        StepVerifier.create(reactiveQueryGateway.query(5, Integer.class))\n+                    .verifyError(RuntimeException.class);\n+    }\n+\n+    @Test\n+    void testQueryFailsWithRetry() throws Exception {\n+\n+        Mono<Integer> query = reactiveQueryGateway.query(5, Integer.class).retry(5);\n+\n+        StepVerifier.create(query)\n+                    .verifyError(RuntimeException.class);\n+\n+        verify(queryMessageHandler3, times(6)).handle(any());\n+    }\n+\n+\n+    @Test\n+    void testScatterGather() throws Exception {\n+        Flux<String> result = reactiveQueryGateway.scatterGather(\"criteria\",\n+                                                                 ResponseTypes.instanceOf(String.class),\n+                                                                 1,\n+                                                                 TimeUnit.SECONDS);\n+        verifyZeroInteractions(queryMessageHandler1);\n+        verifyZeroInteractions(queryMessageHandler2);\n+        StepVerifier.create(result)\n+                    .expectNext(\"handled\", \"handled\")\n+                    .verifyComplete();\n+        verify(queryMessageHandler1).handle(any());\n+        verify(queryMessageHandler2).handle(any());\n+    }\n+\n+    @Test\n+    void testMultipleScatterGather() throws Exception {\n+        Flux<QueryMessage<?, ?>> queries = Flux.fromIterable(Arrays.asList(\n+                new GenericQueryMessage<>(\"query1\", ResponseTypes.instanceOf(String.class)),\n+                new GenericQueryMessage<>(4, ResponseTypes.instanceOf(Integer.class)),\n+                new GenericQueryMessage<>(\"query2\", ResponseTypes.instanceOf(String.class)),\n+                new GenericQueryMessage<>(5, ResponseTypes.instanceOf(Integer.class)),\n+                new GenericQueryMessage<>(true, ResponseTypes.instanceOf(String.class))));\n+\n+        Flux<Object> result = reactiveQueryGateway.scatterGather(queries, 1, TimeUnit.SECONDS);\n+        verifyZeroInteractions(queryMessageHandler1);\n+        verifyZeroInteractions(queryMessageHandler2);\n+\n+        StepVerifier.create(result)\n+                    .expectNext(\"handled\", \"handled\", \"handled\", \"handled\", \"\")\n+                    .verifyComplete();\n+\n+        verify(queryMessageHandler1, times(2)).handle(any());\n+        verify(queryMessageHandler2, times(2)).handle(any());\n+    }\n+\n+    @Test\n+    void testMultipleScatterGatherOrdering() throws Exception {\n+        int numberOfQueries = 10_000;\n+        Flux<QueryMessage<?, ?>> queries = Flux\n+                .fromStream(IntStream.range(0, numberOfQueries)\n+                                     .mapToObj(i -> new GenericQueryMessage<>(\"backpressure\",\n+                                                                              ResponseTypes.instanceOf(String.class))));\n+        List<Integer> expectedResults = IntStream.range(1, 2 * numberOfQueries + 1)\n+                                                 .boxed()\n+                                                 .collect(Collectors.toList());\n+        Flux<Object> result = reactiveQueryGateway.scatterGather(queries, 1, TimeUnit.SECONDS);\n+        StepVerifier.create(result)\n+                    .expectNext(expectedResults.toArray(new Integer[0]))\n+                    .verifyComplete();\n+        verify(queryMessageHandler1, times(numberOfQueries)).handle(any());\n+        verify(queryMessageHandler2, times(numberOfQueries)).handle(any());\n+    }\n+\n+    @Test\n+    void testScatterGatherReturningNull() {\n+        assertNull(reactiveQueryGateway.scatterGather(0L, ResponseTypes.instanceOf(String.class), 1, TimeUnit.SECONDS)\n+                                       .blockFirst());\n+        StepVerifier.create(reactiveQueryGateway\n+                                    .scatterGather(0L, ResponseTypes.instanceOf(String.class), 1, TimeUnit.SECONDS))\n+                    .expectNext()\n+                    .verifyComplete();\n+    }\n+\n+    @Test\n+    void testScatterGatherWithDispatchInterceptor() {\n+        reactiveQueryGateway\n+                .registerDispatchInterceptor(queryMono -> queryMono\n+                        .map(query -> query.andMetaData(Collections.singletonMap(\"key1\", \"value1\"))));\n+        Registration registration2 = reactiveQueryGateway\n+                .registerDispatchInterceptor(queryMono -> queryMono\n+                        .map(query -> query.andMetaData(Collections.singletonMap(\"key2\", \"value2\"))));\n+\n+        StepVerifier.create(reactiveQueryGateway\n+                                    .scatterGather(true, ResponseTypes.instanceOf(String.class), 1, TimeUnit.SECONDS))\n+                    .expectNext(\"value1value2\")\n+                    .verifyComplete();\n+\n+        registration2.cancel();\n+\n+        StepVerifier.create(reactiveQueryGateway.query(true, String.class))\n+                    .expectNext(\"value1\")\n+                    .verifyComplete();\n+    }\n+\n+    @Test\n+    void testScatterGatherWithResultIntercept() throws Exception {\n+        reactiveQueryGateway\n+                .registerResultHandlerInterceptor(\n+                        (query, results) -> results\n+                                .map(it -> new GenericQueryResponseMessage<>(\"handled-modified\"))\n+                );\n+\n+        Flux<QueryMessage<?, ?>> queries = Flux.fromIterable(Arrays.asList(\n+                new GenericQueryMessage<>(\"query1\", ResponseTypes.instanceOf(String.class)),\n+                new GenericQueryMessage<>(4, ResponseTypes.instanceOf(Integer.class)),\n+                new GenericQueryMessage<>(\"query2\", ResponseTypes.instanceOf(String.class)),\n+                new GenericQueryMessage<>(5, ResponseTypes.instanceOf(Integer.class)),\n+                new GenericQueryMessage<>(true, ResponseTypes.instanceOf(String.class))));\n+\n+        Flux<Object> result = reactiveQueryGateway.scatterGather(queries, 1, TimeUnit.SECONDS);\n+        verifyZeroInteractions(queryMessageHandler1);\n+        verifyZeroInteractions(queryMessageHandler2);\n+\n+        StepVerifier.create(result)\n+                    .expectNext(\"handled-modified\",\n+                                \"handled-modified\",\n+                                \"handled-modified\",\n+                                \"handled-modified\",\n+                                \"handled-modified\")\n+                    .verifyComplete();\n+\n+        verify(queryMessageHandler1, times(2)).handle(any());\n+        verify(queryMessageHandler2, times(2)).handle(any());\n+    }\n+\n+    @Test\n+    void testQueryWithResultInterceptorModifyResultBasedOnQuery() throws Exception {\n+        reactiveQueryGateway.registerDispatchInterceptor(q -> q.map(it ->\n+                                                                            it.andMetaData(Collections.singletonMap(\n+                                                                                    \"block\",\n+                                                                                    it.getPayload() instanceof Boolean)\n+                                                                            )));\n+        reactiveQueryGateway\n+                .registerResultHandlerInterceptor((q, results) -> results\n+                        .filter(it -> !((boolean) q.getMetaData().get(\"block\")))\n+                );\n+\n+        Flux<QueryMessage<?, ?>> queries = Flux.fromIterable(Arrays.asList(\n+                new GenericQueryMessage<>(\"query1\", ResponseTypes.instanceOf(String.class)),\n+                new GenericQueryMessage<>(4, ResponseTypes.instanceOf(Integer.class)),\n+                new GenericQueryMessage<>(\"query2\", ResponseTypes.instanceOf(String.class)),\n+                new GenericQueryMessage<>(5, ResponseTypes.instanceOf(Integer.class)),\n+                new GenericQueryMessage<>(Boolean.TRUE, ResponseTypes.instanceOf(String.class))));\n+\n+        Flux<Object> result = reactiveQueryGateway.scatterGather(queries, 1, TimeUnit.SECONDS);\n+        verifyZeroInteractions(queryMessageHandler1);\n+        verifyZeroInteractions(queryMessageHandler2);\n+\n+        StepVerifier.create(result)\n+                    .expectNext(\"handled\", \"handled\", \"handled\", \"handled\")\n+                    .verifyComplete();\n+\n+        verify(queryMessageHandler1, times(2)).handle(any());\n+        verify(queryMessageHandler2, times(2)).handle(any());\n+    }\n+\n+    @Test\n+    void testScatterGatherWithResultInterceptReplacedWithError() throws Exception {\n+        reactiveQueryGateway\n+                .registerResultHandlerInterceptor(\n+                        (query, results) -> results.flatMap(r -> {\n+                            if (r.getPayload().equals(\"\")) {\n+                                return Flux.<ResultMessage<?>>error(new RuntimeException(\"no empty strings allowed\"));\n+                            } else {\n+                                return Flux.just(r);\n+                            }\n+                        })\n+                );\n+\n+        Flux<QueryMessage<?, ?>> queries = Flux.fromIterable(Arrays.asList(\n+                new GenericQueryMessage<>(\"query1\", ResponseTypes.instanceOf(String.class)),\n+                new GenericQueryMessage<>(4, ResponseTypes.instanceOf(Integer.class)),\n+                new GenericQueryMessage<>(\"query2\", ResponseTypes.instanceOf(String.class)),\n+                new GenericQueryMessage<>(5, ResponseTypes.instanceOf(Integer.class)),\n+                new GenericQueryMessage<>(true, ResponseTypes.instanceOf(String.class))));\n+\n+        Flux<Object> result = reactiveQueryGateway.scatterGather(queries, 1, TimeUnit.SECONDS);\n+        verifyZeroInteractions(queryMessageHandler1);\n+        verifyZeroInteractions(queryMessageHandler2);\n+\n+        StepVerifier.create(result)\n+                    .expectNext(\"handled\", \"handled\", \"handled\", \"handled\")\n+                    .expectError(RuntimeException.class)\n+                    .verify();\n+\n+        verify(queryMessageHandler1, times(2)).handle(any());\n+        verify(queryMessageHandler2, times(2)).handle(any());\n+    }\n+\n+    @Test\n+    void testScatterGatherWithDispatchInterceptorThrowingAnException() {\n+        reactiveQueryGateway\n+                .registerDispatchInterceptor(queryMono -> {\n+                    throw new RuntimeException();\n+                });\n+        StepVerifier.create(reactiveQueryGateway\n+                                    .scatterGather(true, ResponseTypes.instanceOf(String.class), 1, TimeUnit.SECONDS))\n+                    .verifyError(RuntimeException.class);\n+    }\n+\n+    @Test\n+    void testScatterGatherWithDispatchInterceptorReturningErrorMono() {\n+        reactiveQueryGateway\n+                .registerDispatchInterceptor(queryMono -> Mono.error(new RuntimeException()));\n+        StepVerifier.create(reactiveQueryGateway\n+                                    .scatterGather(true, ResponseTypes.instanceOf(String.class), 1, TimeUnit.SECONDS))\n+                    .verifyError(RuntimeException.class);\n+    }\n+\n+    @Test\n+    void testScatterGatherFails() {\n+        StepVerifier.create(reactiveQueryGateway.scatterGather(6,\n+                                                               ResponseTypes.instanceOf(Integer.class),\n+                                                               1,\n+                                                               TimeUnit.SECONDS))\n+                    .expectNextCount(0)\n+                    .verifyComplete();\n+    }\n+\n+    @Test\n+    void testScatterGatherFailsWithRetry() throws Exception {\n+        doThrow(new RuntimeException(\":(\")).when(queryBus).scatterGather(any(), anyLong(), any());\n+\n+        Flux<Integer> query = reactiveQueryGateway.scatterGather(6,\n+                                                                 ResponseTypes.instanceOf(Integer.class),\n+                                                                 1,\n+                                                                 TimeUnit.SECONDS).retry(5);\n+\n+        StepVerifier.create(query)\n+                    .verifyError();\n+\n+\n+        verify(queryBus, times(6)).scatterGather(any(), anyLong(), any());\n+    }\n+\n+\n+    @Test\n+    void testSubscriptionQuery() throws Exception {\n+        Mono<SubscriptionQueryResult<String, String>> monoResult = reactiveQueryGateway.subscriptionQuery(\"criteria\",\n+                                                                                                          String.class,\n+                                                                                                          String.class);\n+        verifyZeroInteractions(queryMessageHandler1);\n+        verifyZeroInteractions(queryMessageHandler2);\n+\n+        SubscriptionQueryResult<String, String> result = monoResult.block();\n+        assertNotNull(result);\n+        StepVerifier.create(result.initialResult())\n+                    .expectNext(\"handled\")\n+                    .verifyComplete();\n+        StepVerifier.create(result.updates()\n+                                  .doOnSubscribe(s -> {\n+                                      queryUpdateEmitter.emit(String.class, q -> true, \"update\");\n+                                      queryUpdateEmitter.complete(String.class, q -> true);\n+                                  }))\n+                    .expectNext(\"update\")\n+                    .verifyComplete();\n+        verify(queryMessageHandler1).handle(any());\n+    }\n+\n+    @Test\n+    void testMultipleSubscriptionQueries() throws Exception {\n+        Flux<SubscriptionQueryMessage<?, ?, ?>> queries = Flux.fromIterable(Arrays.asList(\n+                new GenericSubscriptionQueryMessage<>(\"query1\",\n+                                                      ResponseTypes.instanceOf(String.class),\n+                                                      ResponseTypes.instanceOf(String.class)),\n+                new GenericSubscriptionQueryMessage<>(4,\n+                                                      ResponseTypes.instanceOf(Integer.class),\n+                                                      ResponseTypes.instanceOf(String.class))));\n+\n+        Flux<SubscriptionQueryResult<?, ?>> result = reactiveQueryGateway.subscriptionQuery(queries);\n+        verifyZeroInteractions(queryMessageHandler1);\n+        verifyZeroInteractions(queryMessageHandler2);\n+        List<Mono<Object>> initialResults = new ArrayList<>(2);\n+        //noinspection unchecked\n+        result.subscribe(sqr -> initialResults.add((Mono<Object>) sqr.initialResult()));\n+        assertEquals(2, initialResults.size());\n+        StepVerifier.create(initialResults.get(0))\n+                    .expectNext(\"handled\")\n+                    .verifyComplete();\n+        StepVerifier.create(initialResults.get(1))\n+                    .verifyError(RuntimeException.class);\n+\n+        verify(queryMessageHandler1).handle(any());\n+    }\n+\n+    @Test\n+    void testMultipleSubscriptionQueriesOrdering() throws Exception {\n+        int numberOfQueries = 10_000;\n+        Flux<SubscriptionQueryMessage<?, ?, ?>> queries = Flux\n+                .fromStream(IntStream.range(0, numberOfQueries)\n+                                     .mapToObj(i -> new GenericSubscriptionQueryMessage<>(\"backpressure\",\n+                                                                                          ResponseTypes\n+                                                                                                  .instanceOf(String.class),\n+                                                                                          ResponseTypes\n+                                                                                                  .instanceOf(String.class))));\n+        List<Integer> expectedResults = IntStream.range(1, numberOfQueries + 1)\n+                                                 .boxed()\n+                                                 .collect(Collectors.toList());\n+        Flux<SubscriptionQueryResult<?, ?>> result = reactiveQueryGateway.subscriptionQuery(queries);\n+        List<Mono<Object>> initialResults = new ArrayList<>(numberOfQueries);\n+        //noinspection unchecked\n+        result.subscribe(sqr -> initialResults.add((Mono<Object>) sqr.initialResult()));\n+        assertEquals(numberOfQueries, initialResults.size());\n+        for (int i = 0; i < numberOfQueries; i++) {\n+            StepVerifier.create(initialResults.get(i))\n+                        .expectNext(expectedResults.get(i))\n+                        .verifyComplete();\n+        }\n+\n+        verify(queryMessageHandler1, times(numberOfQueries)).handle(any());\n+    }\n+\n+    @Test\n+    void testSubscriptionQueryReturningNull() {\n+        SubscriptionQueryResult<String, String> result = reactiveQueryGateway.subscriptionQuery(0L,\n+                                                                                                String.class,\n+                                                                                                String.class)\n+                                                                             .block();\n+        assertNotNull(result);\n+        assertNull(result.initialResult().block());\n+        StepVerifier.create(result.initialResult())\n+                    .expectNext()\n+                    .verifyComplete();\n+        StepVerifier.create(result.updates()\n+                                  .doOnSubscribe(s -> {\n+                                      queryUpdateEmitter.emit(Long.class, q -> true, (String) null);\n+                                      queryUpdateEmitter.complete(Long.class, q -> true);\n+                                  }))\n+                    .expectNext()\n+                    .verifyComplete();\n+    }\n+\n+    @Test\n+    void testSubscriptionQueryWithDispatchInterceptor() {\n+        reactiveQueryGateway\n+                .registerDispatchInterceptor(queryMono -> queryMono\n+                        .map(query -> query.andMetaData(Collections.singletonMap(\"key1\", \"value1\"))));\n+        Registration registration2 = reactiveQueryGateway\n+                .registerDispatchInterceptor(queryMono -> queryMono\n+                        .map(query -> query.andMetaData(Collections.singletonMap(\"key2\", \"value2\"))));\n+\n+        Mono<SubscriptionQueryResult<String, String>> monoResult = reactiveQueryGateway\n+                .subscriptionQuery(true, String.class, String.class);\n+        SubscriptionQueryResult<String, String> result = monoResult.block();\n+        assertNotNull(result);\n+        StepVerifier.create(result.initialResult())\n+                    .expectNext(\"value1value2\")\n+                    .verifyComplete();\n+\n+        registration2.cancel();\n+\n+        monoResult = reactiveQueryGateway.subscriptionQuery(true, String.class, String.class);\n+        result = monoResult.block();\n+        assertNotNull(result);\n+        StepVerifier.create(result.initialResult())\n+                    .expectNext(\"value1\")\n+                    .verifyComplete();\n+    }\n+\n+    @Test\n+    void testSubscriptionQueryWithDispatchInterceptorThrowingAnException() {\n+        reactiveQueryGateway\n+                .registerDispatchInterceptor(queryMono -> {\n+                    throw new RuntimeException();\n+                });\n+        StepVerifier.create(reactiveQueryGateway.subscriptionQuery(true, String.class, String.class))\n+                    .verifyError(RuntimeException.class);\n+    }\n+\n+    @Test\n+    void testSubscriptionQueryWithDispatchInterceptorReturningErrorMono() {\n+        reactiveQueryGateway\n+                .registerDispatchInterceptor(queryMono -> Mono.error(new RuntimeException()));\n+        StepVerifier.create(reactiveQueryGateway.subscriptionQuery(true, String.class, String.class))\n+                    .verifyError(RuntimeException.class);\n+    }\n+\n+    @Test\n+    void testSubscriptionQueryFails() {\n+        Mono<SubscriptionQueryResult<Integer, Integer>> monoResult = reactiveQueryGateway.subscriptionQuery(6,\n+                                                                                                            Integer.class,\n+                                                                                                            Integer.class);\n+        SubscriptionQueryResult<Integer, Integer> result = monoResult.block();\n+        assertNotNull(result);\n+        StepVerifier.create(result.initialResult())\n+                    .verifyError(RuntimeException.class);\n+    }\n+\n+    @Test\n+    void testSubscriptionQueryFailsRetryInitialDispatchQuery() throws Exception {\n+\n+        doThrow(new RuntimeException(\":(\")).when(queryBus).subscriptionQuery(any(), any(), anyInt());\n+\n+        Mono<SubscriptionQueryResult<Integer, Integer>> monoResult = reactiveQueryGateway.subscriptionQuery(6,\n+                                                                                                            Integer.class,\n+                                                                                                            Integer.class)\n+                                                                                         .retry(5);\n+\n+        StepVerifier.create(monoResult)\n+                    .verifyError(RuntimeException.class);\n+\n+        verify(queryBus, times(6)).subscriptionQuery(any(), any(), anyInt());\n+    }\n+\n+    @Test\n+    void testSubscriptionQueryFailsRetryInitialResult() throws Exception {\n+        Mono<SubscriptionQueryResult<Integer, Integer>> monoResult = reactiveQueryGateway.subscriptionQuery(6,\n+                                                                                                            Integer.class,\n+                                                                                                            Integer.class);\n+\n+        SubscriptionQueryResult<Integer, Integer> result = monoResult.block();\n+        assertNotNull(result);\n+        StepVerifier.create(result.initialResult().retry(5))\n+                    .verifyError(RuntimeException.class);\n+\n+        verify(queryMessageHandler3, times(6)).handle(any());\n+    }\n+\n+    @Test\n+    void testSubscriptionQuerySingleInitialResultAndUpdates() {\n+        Flux<String> result = reactiveQueryGateway.subscriptionQuery(\"6\", String.class);\n+        CountDownLatch countDownLatch = new CountDownLatch(1);\n+\n+        ScheduledExecutorService executorService = Executors.newSingleThreadScheduledExecutor();\n+        executorService.execute(() -> {\n+            try {\n+                countDownLatch.await();\n+            } catch (InterruptedException e) {\n+                fail(e.getMessage());\n+            }\n+            queryUpdateEmitter.emit(String.class, q -> true, \"1\");\n+            queryUpdateEmitter.emit(String.class, q -> true, \"2\");\n+            queryUpdateEmitter.emit(String.class, q -> true, \"3\");\n+            queryUpdateEmitter.emit(String.class, q -> true, \"4\");\n+            queryUpdateEmitter.emit(String.class, q -> true, \"5\");\n+            queryUpdateEmitter.complete(String.class, p -> true);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjgzMDY0MA=="}, "originalCommit": {"oid": "98865ab1427e4d879301c1bf542842eccc8aa3c3"}, "originalPosition": 731}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7d36c4a3a85516d49314330e0f894bb3b3ea39aa", "author": {"user": {"login": "m1l4n54v1c", "name": "Milan Savic"}}, "url": "https://github.com/AxonFramework/AxonFramework/commit/7d36c4a3a85516d49314330e0f894bb3b3ea39aa", "committedDate": "2020-07-28T13:18:17Z", "message": "Cleaning the code."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "30ba00c255b5a867f13c792cd330dde0bb30cc9d", "author": {"user": {"login": "m1l4n54v1c", "name": "Milan Savic"}}, "url": "https://github.com/AxonFramework/AxonFramework/commit/30ba00c255b5a867f13c792cd330dde0bb30cc9d", "committedDate": "2020-07-29T08:30:22Z", "message": "Removed Reactor Gateways in favor of moving them to the reactor extension."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e1a8cd318493dbd00e6f43bed14e57fe130f765d", "author": {"user": {"login": "m1l4n54v1c", "name": "Milan Savic"}}, "url": "https://github.com/AxonFramework/AxonFramework/commit/e1a8cd318493dbd00e6f43bed14e57fe130f765d", "committedDate": "2020-07-29T08:31:08Z", "message": "Merge branch 'master' into reactive-gateways"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5123436deb1d76db21ab0d14d251e7c0de6001ed", "author": {"user": {"login": "m1l4n54v1c", "name": "Milan Savic"}}, "url": "https://github.com/AxonFramework/AxonFramework/commit/5123436deb1d76db21ab0d14d251e7c0de6001ed", "committedDate": "2020-07-29T08:47:07Z", "message": "Removed unnecessary dependency."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU4MTk3NDA5", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#pullrequestreview-458197409", "createdAt": "2020-07-30T08:36:26Z", "commit": {"oid": "5123436deb1d76db21ab0d14d251e7c0de6001ed"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4aca9b0d41cac83c1df6992d5e9dd337ec52010b", "author": {"user": {"login": "m1l4n54v1c", "name": "Milan Savic"}}, "url": "https://github.com/AxonFramework/AxonFramework/commit/4aca9b0d41cac83c1df6992d5e9dd337ec52010b", "committedDate": "2020-02-05T08:19:42Z", "message": "Reactive gateways."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d6548cde5c65c7e904684da54b903b93110f095f", "author": {"user": {"login": "m1l4n54v1c", "name": "Milan Savic"}}, "url": "https://github.com/AxonFramework/AxonFramework/commit/d6548cde5c65c7e904684da54b903b93110f095f", "committedDate": "2020-02-05T08:29:47Z", "message": "Removed unused logger in DefaultReactiveCommandGateway."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzUzODEwMTAy", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#pullrequestreview-353810102", "createdAt": "2020-02-05T15:32:01Z", "commit": {"oid": "d6548cde5c65c7e904684da54b903b93110f095f"}, "state": "APPROVED", "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNVQxNTozMjowMVrOFl8Mng==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNVQxNTozNDoyMVrOFl8SXw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTMyNzkwMg==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * <b>Note</b>: Any {@code null} results, on the initial result or the updates, wil lbe filtered out by the\n          \n          \n            \n                 * <b>Note</b>: Any {@code null} results, on the initial result or the updates, will be filtered out by the", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r375327902", "createdAt": "2020-02-05T15:32:01Z", "author": {"login": "corradom"}, "path": "messaging/src/main/java/org/axonframework/queryhandling/ReactiveQueryGateway.java", "diffHunk": "@@ -0,0 +1,280 @@\n+/*\n+ * Copyright (c) 2010-2020. Axon Framework\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.axonframework.queryhandling;\n+\n+import org.axonframework.messaging.responsetypes.ResponseType;\n+import org.axonframework.messaging.responsetypes.ResponseTypes;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Mono;\n+import reactor.util.concurrent.Queues;\n+\n+import java.util.concurrent.TimeUnit;\n+\n+/**\n+ * Variation of {@link QueryGateway}. Provides support for reactive return types such as {@link Mono} and {@link Flux}\n+ * from Project Reactor.\n+ *\n+ * @author Milan Savic\n+ * @since 4.4\n+ */\n+public interface ReactiveQueryGateway {\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus}, expecting a response with the given {@code responseType}\n+     * from a single source. The query name will be derived from the provided {@code query}. Execution may be\n+     * asynchronous, depending on the QueryBus implementation.\n+     *\n+     * @param query        The {@code query} to be sent\n+     * @param responseType A {@link Class} describing the desired response type\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(Q query, Class<R> responseType) {\n+        return query(query.getClass().getName(), query, responseType);\n+    }\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus}, expecting a response with the given {@code responseType}\n+     * from a single source. Execution may be asynchronous, depending on the QueryBus implementation.\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(String queryName, Q query, Class<R> responseType) {\n+        return query(queryName, query, ResponseTypes.instanceOf(responseType));\n+    }\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from a single source. The query name will be derived from the provided {@code query}. Execution may be\n+     * asynchronous, depending on the QueryBus implementation.\n+     *\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(Q query, ResponseType<R> responseType) {\n+        return query(query.getClass().getName(), query, responseType);\n+    }\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from a single source. Execution may be asynchronous, depending on the QueryBus implementation.\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    <R, Q> Mono<R> query(String queryName, Q query, ResponseType<R> responseType);\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from several sources. The flux is completed when a {@code timeout} occurs or when all results are received. The\n+     * query name will be derived from the provided {@code query}. Execution may be asynchronous, depending on the\n+     * QueryBus implementation.\n+     *\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param timeout      A timeout of {@code long} for the query\n+     * @param timeUnit     The selected {@link TimeUnit} for the given {@code timeout}\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A flux of results\n+     */\n+    default <R, Q> Flux<R> scatterGather(Q query, ResponseType<R> responseType, long timeout, TimeUnit timeUnit) {\n+        return scatterGather(query.getClass().getName(), query, responseType, timeout, timeUnit);\n+    }\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from several sources. The flux is completed when a {@code timeout} occurs or when all results are received.\n+     * Execution may be asynchronous, depending on the QueryBus implementation.\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param timeout      A timeout of {@code long} for the query\n+     * @param timeUnit     The selected {@link TimeUnit} for the given {@code timeout}\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A flux of results.\n+     */\n+    <R, Q> Flux<R> scatterGather(String queryName, Q query, ResponseType<R> responseType, long timeout,\n+                                 TimeUnit timeUnit);\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus} and returns result containing initial response and\n+     * incremental updates (received at the moment the query is sent, until it is cancelled by the caller or closed by\n+     * the emitting side).\n+     * <p>\n+     * <b>Note</b>: Any {@code null} results, on the initial result or the updates, wil lbe filtered out by the\n+     * QueryGateway. If you require the {@code null} to be returned for the initial and update results, we suggest using\n+     * the {@link QueryBus} instead.\n+     *\n+     * @param query               The {@code query} to be sent\n+     * @param initialResponseType The initial response type used for this query\n+     * @param updateResponseType  The update response type used for this query\n+     * @param <Q>                 The type of the query\n+     * @param <I>                 The type of the initial response\n+     * @param <U>                 The type of the incremental update\n+     * @return registration which can be used to cancel receiving updates\n+     *\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage)\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage, SubscriptionQueryBackpressure, int)\n+     */\n+    default <Q, I, U> SubscriptionQueryResult<I, U> subscriptionQuery(Q query, Class<I> initialResponseType,\n+                                                                      Class<U> updateResponseType) {\n+        return subscriptionQuery(query.getClass().getName(),\n+                                 query,\n+                                 initialResponseType,\n+                                 updateResponseType);\n+    }\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus} and returns result containing initial response and\n+     * incremental updates (received at the moment the query is sent, until it is cancelled by the caller or closed by\n+     * the emitting side).\n+     * <p>\n+     * <b>Note</b>: Any {@code null} results, on the initial result or the updates, wil lbe filtered out by the", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d6548cde5c65c7e904684da54b903b93110f095f"}, "originalPosition": 162}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTMyODM5OQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * <b>Note</b>: Any {@code null} results, on the initial result or the updates, wil lbe filtered out by the\n          \n          \n            \n                 * <b>Note</b>: Any {@code null} results, on the initial result or the updates, will be filtered out by the", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r375328399", "createdAt": "2020-02-05T15:32:48Z", "author": {"login": "corradom"}, "path": "messaging/src/main/java/org/axonframework/queryhandling/ReactiveQueryGateway.java", "diffHunk": "@@ -0,0 +1,280 @@\n+/*\n+ * Copyright (c) 2010-2020. Axon Framework\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.axonframework.queryhandling;\n+\n+import org.axonframework.messaging.responsetypes.ResponseType;\n+import org.axonframework.messaging.responsetypes.ResponseTypes;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Mono;\n+import reactor.util.concurrent.Queues;\n+\n+import java.util.concurrent.TimeUnit;\n+\n+/**\n+ * Variation of {@link QueryGateway}. Provides support for reactive return types such as {@link Mono} and {@link Flux}\n+ * from Project Reactor.\n+ *\n+ * @author Milan Savic\n+ * @since 4.4\n+ */\n+public interface ReactiveQueryGateway {\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus}, expecting a response with the given {@code responseType}\n+     * from a single source. The query name will be derived from the provided {@code query}. Execution may be\n+     * asynchronous, depending on the QueryBus implementation.\n+     *\n+     * @param query        The {@code query} to be sent\n+     * @param responseType A {@link Class} describing the desired response type\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(Q query, Class<R> responseType) {\n+        return query(query.getClass().getName(), query, responseType);\n+    }\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus}, expecting a response with the given {@code responseType}\n+     * from a single source. Execution may be asynchronous, depending on the QueryBus implementation.\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(String queryName, Q query, Class<R> responseType) {\n+        return query(queryName, query, ResponseTypes.instanceOf(responseType));\n+    }\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from a single source. The query name will be derived from the provided {@code query}. Execution may be\n+     * asynchronous, depending on the QueryBus implementation.\n+     *\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(Q query, ResponseType<R> responseType) {\n+        return query(query.getClass().getName(), query, responseType);\n+    }\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from a single source. Execution may be asynchronous, depending on the QueryBus implementation.\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    <R, Q> Mono<R> query(String queryName, Q query, ResponseType<R> responseType);\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from several sources. The flux is completed when a {@code timeout} occurs or when all results are received. The\n+     * query name will be derived from the provided {@code query}. Execution may be asynchronous, depending on the\n+     * QueryBus implementation.\n+     *\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param timeout      A timeout of {@code long} for the query\n+     * @param timeUnit     The selected {@link TimeUnit} for the given {@code timeout}\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A flux of results\n+     */\n+    default <R, Q> Flux<R> scatterGather(Q query, ResponseType<R> responseType, long timeout, TimeUnit timeUnit) {\n+        return scatterGather(query.getClass().getName(), query, responseType, timeout, timeUnit);\n+    }\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from several sources. The flux is completed when a {@code timeout} occurs or when all results are received.\n+     * Execution may be asynchronous, depending on the QueryBus implementation.\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param timeout      A timeout of {@code long} for the query\n+     * @param timeUnit     The selected {@link TimeUnit} for the given {@code timeout}\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A flux of results.\n+     */\n+    <R, Q> Flux<R> scatterGather(String queryName, Q query, ResponseType<R> responseType, long timeout,\n+                                 TimeUnit timeUnit);\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus} and returns result containing initial response and\n+     * incremental updates (received at the moment the query is sent, until it is cancelled by the caller or closed by\n+     * the emitting side).\n+     * <p>\n+     * <b>Note</b>: Any {@code null} results, on the initial result or the updates, wil lbe filtered out by the", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d6548cde5c65c7e904684da54b903b93110f095f"}, "originalPosition": 134}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTMyOTEzNw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * <b>Note</b>: Any {@code null} results, on the initial result or the updates, wil lbe filtered out by the\n          \n          \n            \n                 * <b>Note</b>: Any {@code null} results, on the initial result or the updates, will be filtered out by the", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r375329137", "createdAt": "2020-02-05T15:33:59Z", "author": {"login": "corradom"}, "path": "messaging/src/main/java/org/axonframework/queryhandling/ReactiveQueryGateway.java", "diffHunk": "@@ -0,0 +1,280 @@\n+/*\n+ * Copyright (c) 2010-2020. Axon Framework\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.axonframework.queryhandling;\n+\n+import org.axonframework.messaging.responsetypes.ResponseType;\n+import org.axonframework.messaging.responsetypes.ResponseTypes;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Mono;\n+import reactor.util.concurrent.Queues;\n+\n+import java.util.concurrent.TimeUnit;\n+\n+/**\n+ * Variation of {@link QueryGateway}. Provides support for reactive return types such as {@link Mono} and {@link Flux}\n+ * from Project Reactor.\n+ *\n+ * @author Milan Savic\n+ * @since 4.4\n+ */\n+public interface ReactiveQueryGateway {\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus}, expecting a response with the given {@code responseType}\n+     * from a single source. The query name will be derived from the provided {@code query}. Execution may be\n+     * asynchronous, depending on the QueryBus implementation.\n+     *\n+     * @param query        The {@code query} to be sent\n+     * @param responseType A {@link Class} describing the desired response type\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(Q query, Class<R> responseType) {\n+        return query(query.getClass().getName(), query, responseType);\n+    }\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus}, expecting a response with the given {@code responseType}\n+     * from a single source. Execution may be asynchronous, depending on the QueryBus implementation.\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(String queryName, Q query, Class<R> responseType) {\n+        return query(queryName, query, ResponseTypes.instanceOf(responseType));\n+    }\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from a single source. The query name will be derived from the provided {@code query}. Execution may be\n+     * asynchronous, depending on the QueryBus implementation.\n+     *\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(Q query, ResponseType<R> responseType) {\n+        return query(query.getClass().getName(), query, responseType);\n+    }\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from a single source. Execution may be asynchronous, depending on the QueryBus implementation.\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    <R, Q> Mono<R> query(String queryName, Q query, ResponseType<R> responseType);\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from several sources. The flux is completed when a {@code timeout} occurs or when all results are received. The\n+     * query name will be derived from the provided {@code query}. Execution may be asynchronous, depending on the\n+     * QueryBus implementation.\n+     *\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param timeout      A timeout of {@code long} for the query\n+     * @param timeUnit     The selected {@link TimeUnit} for the given {@code timeout}\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A flux of results\n+     */\n+    default <R, Q> Flux<R> scatterGather(Q query, ResponseType<R> responseType, long timeout, TimeUnit timeUnit) {\n+        return scatterGather(query.getClass().getName(), query, responseType, timeout, timeUnit);\n+    }\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from several sources. The flux is completed when a {@code timeout} occurs or when all results are received.\n+     * Execution may be asynchronous, depending on the QueryBus implementation.\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param timeout      A timeout of {@code long} for the query\n+     * @param timeUnit     The selected {@link TimeUnit} for the given {@code timeout}\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A flux of results.\n+     */\n+    <R, Q> Flux<R> scatterGather(String queryName, Q query, ResponseType<R> responseType, long timeout,\n+                                 TimeUnit timeUnit);\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus} and returns result containing initial response and\n+     * incremental updates (received at the moment the query is sent, until it is cancelled by the caller or closed by\n+     * the emitting side).\n+     * <p>\n+     * <b>Note</b>: Any {@code null} results, on the initial result or the updates, wil lbe filtered out by the\n+     * QueryGateway. If you require the {@code null} to be returned for the initial and update results, we suggest using\n+     * the {@link QueryBus} instead.\n+     *\n+     * @param query               The {@code query} to be sent\n+     * @param initialResponseType The initial response type used for this query\n+     * @param updateResponseType  The update response type used for this query\n+     * @param <Q>                 The type of the query\n+     * @param <I>                 The type of the initial response\n+     * @param <U>                 The type of the incremental update\n+     * @return registration which can be used to cancel receiving updates\n+     *\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage)\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage, SubscriptionQueryBackpressure, int)\n+     */\n+    default <Q, I, U> SubscriptionQueryResult<I, U> subscriptionQuery(Q query, Class<I> initialResponseType,\n+                                                                      Class<U> updateResponseType) {\n+        return subscriptionQuery(query.getClass().getName(),\n+                                 query,\n+                                 initialResponseType,\n+                                 updateResponseType);\n+    }\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus} and returns result containing initial response and\n+     * incremental updates (received at the moment the query is sent, until it is cancelled by the caller or closed by\n+     * the emitting side).\n+     * <p>\n+     * <b>Note</b>: Any {@code null} results, on the initial result or the updates, wil lbe filtered out by the\n+     * QueryGateway. If you require the {@code null} to be returned for the initial and update results, we suggest using\n+     * the {@link QueryBus} instead.\n+     *\n+     * @param queryName           A {@link String} describing query to be executed\n+     * @param query               The {@code query} to be sent\n+     * @param initialResponseType The initial response type used for this query\n+     * @param updateResponseType  The update response type used for this query\n+     * @param <Q>                 The type of the query\n+     * @param <I>                 The type of the initial response\n+     * @param <U>                 The type of the incremental update\n+     * @return registration which can be used to cancel receiving updates\n+     *\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage)\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage, SubscriptionQueryBackpressure, int)\n+     */\n+    default <Q, I, U> SubscriptionQueryResult<I, U> subscriptionQuery(String queryName, Q query,\n+                                                                      Class<I> initialResponseType,\n+                                                                      Class<U> updateResponseType) {\n+        return subscriptionQuery(queryName,\n+                                 query,\n+                                 ResponseTypes.instanceOf(initialResponseType),\n+                                 ResponseTypes.instanceOf(updateResponseType),\n+                                 SubscriptionQueryBackpressure.defaultBackpressure());\n+    }\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus} and returns result containing initial response and\n+     * incremental updates (received at the moment the query is sent, until it is cancelled by the caller or closed by\n+     * the emitting side).\n+     * <p>\n+     * <b>Note</b>: Any {@code null} results, on the initial result or the updates, wil lbe filtered out by the", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d6548cde5c65c7e904684da54b903b93110f095f"}, "originalPosition": 193}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTMyOTI1Mg==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * <b>Note</b>: Any {@code null} results, on the initial result or the updates, wil lbe filtered out by the\n          \n          \n            \n                 * <b>Note</b>: Any {@code null} results, on the initial result or the updates, will be filtered out by the", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r375329252", "createdAt": "2020-02-05T15:34:08Z", "author": {"login": "corradom"}, "path": "messaging/src/main/java/org/axonframework/queryhandling/ReactiveQueryGateway.java", "diffHunk": "@@ -0,0 +1,280 @@\n+/*\n+ * Copyright (c) 2010-2020. Axon Framework\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.axonframework.queryhandling;\n+\n+import org.axonframework.messaging.responsetypes.ResponseType;\n+import org.axonframework.messaging.responsetypes.ResponseTypes;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Mono;\n+import reactor.util.concurrent.Queues;\n+\n+import java.util.concurrent.TimeUnit;\n+\n+/**\n+ * Variation of {@link QueryGateway}. Provides support for reactive return types such as {@link Mono} and {@link Flux}\n+ * from Project Reactor.\n+ *\n+ * @author Milan Savic\n+ * @since 4.4\n+ */\n+public interface ReactiveQueryGateway {\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus}, expecting a response with the given {@code responseType}\n+     * from a single source. The query name will be derived from the provided {@code query}. Execution may be\n+     * asynchronous, depending on the QueryBus implementation.\n+     *\n+     * @param query        The {@code query} to be sent\n+     * @param responseType A {@link Class} describing the desired response type\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(Q query, Class<R> responseType) {\n+        return query(query.getClass().getName(), query, responseType);\n+    }\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus}, expecting a response with the given {@code responseType}\n+     * from a single source. Execution may be asynchronous, depending on the QueryBus implementation.\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(String queryName, Q query, Class<R> responseType) {\n+        return query(queryName, query, ResponseTypes.instanceOf(responseType));\n+    }\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from a single source. The query name will be derived from the provided {@code query}. Execution may be\n+     * asynchronous, depending on the QueryBus implementation.\n+     *\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(Q query, ResponseType<R> responseType) {\n+        return query(query.getClass().getName(), query, responseType);\n+    }\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from a single source. Execution may be asynchronous, depending on the QueryBus implementation.\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    <R, Q> Mono<R> query(String queryName, Q query, ResponseType<R> responseType);\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from several sources. The flux is completed when a {@code timeout} occurs or when all results are received. The\n+     * query name will be derived from the provided {@code query}. Execution may be asynchronous, depending on the\n+     * QueryBus implementation.\n+     *\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param timeout      A timeout of {@code long} for the query\n+     * @param timeUnit     The selected {@link TimeUnit} for the given {@code timeout}\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A flux of results\n+     */\n+    default <R, Q> Flux<R> scatterGather(Q query, ResponseType<R> responseType, long timeout, TimeUnit timeUnit) {\n+        return scatterGather(query.getClass().getName(), query, responseType, timeout, timeUnit);\n+    }\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from several sources. The flux is completed when a {@code timeout} occurs or when all results are received.\n+     * Execution may be asynchronous, depending on the QueryBus implementation.\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param timeout      A timeout of {@code long} for the query\n+     * @param timeUnit     The selected {@link TimeUnit} for the given {@code timeout}\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A flux of results.\n+     */\n+    <R, Q> Flux<R> scatterGather(String queryName, Q query, ResponseType<R> responseType, long timeout,\n+                                 TimeUnit timeUnit);\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus} and returns result containing initial response and\n+     * incremental updates (received at the moment the query is sent, until it is cancelled by the caller or closed by\n+     * the emitting side).\n+     * <p>\n+     * <b>Note</b>: Any {@code null} results, on the initial result or the updates, wil lbe filtered out by the\n+     * QueryGateway. If you require the {@code null} to be returned for the initial and update results, we suggest using\n+     * the {@link QueryBus} instead.\n+     *\n+     * @param query               The {@code query} to be sent\n+     * @param initialResponseType The initial response type used for this query\n+     * @param updateResponseType  The update response type used for this query\n+     * @param <Q>                 The type of the query\n+     * @param <I>                 The type of the initial response\n+     * @param <U>                 The type of the incremental update\n+     * @return registration which can be used to cancel receiving updates\n+     *\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage)\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage, SubscriptionQueryBackpressure, int)\n+     */\n+    default <Q, I, U> SubscriptionQueryResult<I, U> subscriptionQuery(Q query, Class<I> initialResponseType,\n+                                                                      Class<U> updateResponseType) {\n+        return subscriptionQuery(query.getClass().getName(),\n+                                 query,\n+                                 initialResponseType,\n+                                 updateResponseType);\n+    }\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus} and returns result containing initial response and\n+     * incremental updates (received at the moment the query is sent, until it is cancelled by the caller or closed by\n+     * the emitting side).\n+     * <p>\n+     * <b>Note</b>: Any {@code null} results, on the initial result or the updates, wil lbe filtered out by the\n+     * QueryGateway. If you require the {@code null} to be returned for the initial and update results, we suggest using\n+     * the {@link QueryBus} instead.\n+     *\n+     * @param queryName           A {@link String} describing query to be executed\n+     * @param query               The {@code query} to be sent\n+     * @param initialResponseType The initial response type used for this query\n+     * @param updateResponseType  The update response type used for this query\n+     * @param <Q>                 The type of the query\n+     * @param <I>                 The type of the initial response\n+     * @param <U>                 The type of the incremental update\n+     * @return registration which can be used to cancel receiving updates\n+     *\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage)\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage, SubscriptionQueryBackpressure, int)\n+     */\n+    default <Q, I, U> SubscriptionQueryResult<I, U> subscriptionQuery(String queryName, Q query,\n+                                                                      Class<I> initialResponseType,\n+                                                                      Class<U> updateResponseType) {\n+        return subscriptionQuery(queryName,\n+                                 query,\n+                                 ResponseTypes.instanceOf(initialResponseType),\n+                                 ResponseTypes.instanceOf(updateResponseType),\n+                                 SubscriptionQueryBackpressure.defaultBackpressure());\n+    }\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus} and returns result containing initial response and\n+     * incremental updates (received at the moment the query is sent, until it is cancelled by the caller or closed by\n+     * the emitting side).\n+     * <p>\n+     * <b>Note</b>: Any {@code null} results, on the initial result or the updates, wil lbe filtered out by the\n+     * QueryGateway. If you require the {@code null} to be returned for the initial and update results, we suggest using\n+     * the {@link QueryBus} instead.\n+     *\n+     * @param query               The {@code query} to be sent\n+     * @param initialResponseType The initial response type used for this query\n+     * @param updateResponseType  The update response type used for this query\n+     * @param <Q>                 The type of the query\n+     * @param <I>                 The type of the initial response\n+     * @param <U>                 The type of the incremental update\n+     * @return registration which can be used to cancel receiving updates\n+     *\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage)\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage, SubscriptionQueryBackpressure, int)\n+     */\n+    default <Q, I, U> SubscriptionQueryResult<I, U> subscriptionQuery(Q query, ResponseType<I> initialResponseType,\n+                                                                      ResponseType<U> updateResponseType) {\n+        return subscriptionQuery(query.getClass().getName(),\n+                                 query,\n+                                 initialResponseType,\n+                                 updateResponseType,\n+                                 SubscriptionQueryBackpressure.defaultBackpressure());\n+    }\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus} and returns result containing initial response and\n+     * incremental updates (received at the moment the query is sent, until it is cancelled by the caller or closed by\n+     * the emitting side).\n+     * <p>\n+     * <b>Note</b>: Any {@code null} results, on the initial result or the updates, wil lbe filtered out by the", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d6548cde5c65c7e904684da54b903b93110f095f"}, "originalPosition": 222}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTMyOTM3NQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * <b>Note</b>: Any {@code null} results, on the initial result or the updates, wil lbe filtered out by the\n          \n          \n            \n                 * <b>Note</b>: Any {@code null} results, on the initial result or the updates, will be filtered out by the", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r375329375", "createdAt": "2020-02-05T15:34:21Z", "author": {"login": "corradom"}, "path": "messaging/src/main/java/org/axonframework/queryhandling/ReactiveQueryGateway.java", "diffHunk": "@@ -0,0 +1,280 @@\n+/*\n+ * Copyright (c) 2010-2020. Axon Framework\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.axonframework.queryhandling;\n+\n+import org.axonframework.messaging.responsetypes.ResponseType;\n+import org.axonframework.messaging.responsetypes.ResponseTypes;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Mono;\n+import reactor.util.concurrent.Queues;\n+\n+import java.util.concurrent.TimeUnit;\n+\n+/**\n+ * Variation of {@link QueryGateway}. Provides support for reactive return types such as {@link Mono} and {@link Flux}\n+ * from Project Reactor.\n+ *\n+ * @author Milan Savic\n+ * @since 4.4\n+ */\n+public interface ReactiveQueryGateway {\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus}, expecting a response with the given {@code responseType}\n+     * from a single source. The query name will be derived from the provided {@code query}. Execution may be\n+     * asynchronous, depending on the QueryBus implementation.\n+     *\n+     * @param query        The {@code query} to be sent\n+     * @param responseType A {@link Class} describing the desired response type\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(Q query, Class<R> responseType) {\n+        return query(query.getClass().getName(), query, responseType);\n+    }\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus}, expecting a response with the given {@code responseType}\n+     * from a single source. Execution may be asynchronous, depending on the QueryBus implementation.\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(String queryName, Q query, Class<R> responseType) {\n+        return query(queryName, query, ResponseTypes.instanceOf(responseType));\n+    }\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from a single source. The query name will be derived from the provided {@code query}. Execution may be\n+     * asynchronous, depending on the QueryBus implementation.\n+     *\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(Q query, ResponseType<R> responseType) {\n+        return query(query.getClass().getName(), query, responseType);\n+    }\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from a single source. Execution may be asynchronous, depending on the QueryBus implementation.\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    <R, Q> Mono<R> query(String queryName, Q query, ResponseType<R> responseType);\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from several sources. The flux is completed when a {@code timeout} occurs or when all results are received. The\n+     * query name will be derived from the provided {@code query}. Execution may be asynchronous, depending on the\n+     * QueryBus implementation.\n+     *\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param timeout      A timeout of {@code long} for the query\n+     * @param timeUnit     The selected {@link TimeUnit} for the given {@code timeout}\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A flux of results\n+     */\n+    default <R, Q> Flux<R> scatterGather(Q query, ResponseType<R> responseType, long timeout, TimeUnit timeUnit) {\n+        return scatterGather(query.getClass().getName(), query, responseType, timeout, timeUnit);\n+    }\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from several sources. The flux is completed when a {@code timeout} occurs or when all results are received.\n+     * Execution may be asynchronous, depending on the QueryBus implementation.\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param timeout      A timeout of {@code long} for the query\n+     * @param timeUnit     The selected {@link TimeUnit} for the given {@code timeout}\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A flux of results.\n+     */\n+    <R, Q> Flux<R> scatterGather(String queryName, Q query, ResponseType<R> responseType, long timeout,\n+                                 TimeUnit timeUnit);\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus} and returns result containing initial response and\n+     * incremental updates (received at the moment the query is sent, until it is cancelled by the caller or closed by\n+     * the emitting side).\n+     * <p>\n+     * <b>Note</b>: Any {@code null} results, on the initial result or the updates, wil lbe filtered out by the\n+     * QueryGateway. If you require the {@code null} to be returned for the initial and update results, we suggest using\n+     * the {@link QueryBus} instead.\n+     *\n+     * @param query               The {@code query} to be sent\n+     * @param initialResponseType The initial response type used for this query\n+     * @param updateResponseType  The update response type used for this query\n+     * @param <Q>                 The type of the query\n+     * @param <I>                 The type of the initial response\n+     * @param <U>                 The type of the incremental update\n+     * @return registration which can be used to cancel receiving updates\n+     *\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage)\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage, SubscriptionQueryBackpressure, int)\n+     */\n+    default <Q, I, U> SubscriptionQueryResult<I, U> subscriptionQuery(Q query, Class<I> initialResponseType,\n+                                                                      Class<U> updateResponseType) {\n+        return subscriptionQuery(query.getClass().getName(),\n+                                 query,\n+                                 initialResponseType,\n+                                 updateResponseType);\n+    }\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus} and returns result containing initial response and\n+     * incremental updates (received at the moment the query is sent, until it is cancelled by the caller or closed by\n+     * the emitting side).\n+     * <p>\n+     * <b>Note</b>: Any {@code null} results, on the initial result or the updates, wil lbe filtered out by the\n+     * QueryGateway. If you require the {@code null} to be returned for the initial and update results, we suggest using\n+     * the {@link QueryBus} instead.\n+     *\n+     * @param queryName           A {@link String} describing query to be executed\n+     * @param query               The {@code query} to be sent\n+     * @param initialResponseType The initial response type used for this query\n+     * @param updateResponseType  The update response type used for this query\n+     * @param <Q>                 The type of the query\n+     * @param <I>                 The type of the initial response\n+     * @param <U>                 The type of the incremental update\n+     * @return registration which can be used to cancel receiving updates\n+     *\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage)\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage, SubscriptionQueryBackpressure, int)\n+     */\n+    default <Q, I, U> SubscriptionQueryResult<I, U> subscriptionQuery(String queryName, Q query,\n+                                                                      Class<I> initialResponseType,\n+                                                                      Class<U> updateResponseType) {\n+        return subscriptionQuery(queryName,\n+                                 query,\n+                                 ResponseTypes.instanceOf(initialResponseType),\n+                                 ResponseTypes.instanceOf(updateResponseType),\n+                                 SubscriptionQueryBackpressure.defaultBackpressure());\n+    }\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus} and returns result containing initial response and\n+     * incremental updates (received at the moment the query is sent, until it is cancelled by the caller or closed by\n+     * the emitting side).\n+     * <p>\n+     * <b>Note</b>: Any {@code null} results, on the initial result or the updates, wil lbe filtered out by the\n+     * QueryGateway. If you require the {@code null} to be returned for the initial and update results, we suggest using\n+     * the {@link QueryBus} instead.\n+     *\n+     * @param query               The {@code query} to be sent\n+     * @param initialResponseType The initial response type used for this query\n+     * @param updateResponseType  The update response type used for this query\n+     * @param <Q>                 The type of the query\n+     * @param <I>                 The type of the initial response\n+     * @param <U>                 The type of the incremental update\n+     * @return registration which can be used to cancel receiving updates\n+     *\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage)\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage, SubscriptionQueryBackpressure, int)\n+     */\n+    default <Q, I, U> SubscriptionQueryResult<I, U> subscriptionQuery(Q query, ResponseType<I> initialResponseType,\n+                                                                      ResponseType<U> updateResponseType) {\n+        return subscriptionQuery(query.getClass().getName(),\n+                                 query,\n+                                 initialResponseType,\n+                                 updateResponseType,\n+                                 SubscriptionQueryBackpressure.defaultBackpressure());\n+    }\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus} and returns result containing initial response and\n+     * incremental updates (received at the moment the query is sent, until it is cancelled by the caller or closed by\n+     * the emitting side).\n+     * <p>\n+     * <b>Note</b>: Any {@code null} results, on the initial result or the updates, wil lbe filtered out by the\n+     * QueryGateway. If you require the {@code null} to be returned for the initial and update results, we suggest using\n+     * the {@link QueryBus} instead.\n+     *\n+     * @param queryName           A {@link String} describing query to be executed\n+     * @param query               The {@code query} to be sent\n+     * @param initialResponseType The initial response type used for this query\n+     * @param updateResponseType  The update response type used for this query\n+     * @param backpressure        The backpressure mechanism to deal with producing of incremental updates\n+     * @param <Q>                 The type of the query\n+     * @param <I>                 The type of the initial response\n+     * @param <U>                 The type of the incremental update\n+     * @return registration which can be used to cancel receiving updates\n+     *\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage)\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage, SubscriptionQueryBackpressure, int)\n+     */\n+    default <Q, I, U> SubscriptionQueryResult<I, U> subscriptionQuery(String queryName, Q query,\n+                                                                      ResponseType<I> initialResponseType,\n+                                                                      ResponseType<U> updateResponseType,\n+                                                                      SubscriptionQueryBackpressure backpressure) {\n+        return subscriptionQuery(queryName,\n+                                 query,\n+                                 initialResponseType,\n+                                 updateResponseType,\n+                                 backpressure,\n+                                 Queues.SMALL_BUFFER_SIZE);\n+    }\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus} and returns result containing initial response and\n+     * incremental updates (received at the moment the query is sent, until it is cancelled by the caller or closed by\n+     * the emitting side).\n+     * <p>\n+     * <b>Note</b>: Any {@code null} results, on the initial result or the updates, wil lbe filtered out by the", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d6548cde5c65c7e904684da54b903b93110f095f"}, "originalPosition": 256}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "18b22249c9b7b982a95a7cd19c2394c866ca6173", "author": {"user": {"login": "m1l4n54v1c", "name": "Milan Savic"}}, "url": "https://github.com/AxonFramework/AxonFramework/commit/18b22249c9b7b982a95a7cd19c2394c866ca6173", "committedDate": "2020-02-05T16:26:00Z", "message": "Update messaging/src/main/java/org/axonframework/queryhandling/ReactiveQueryGateway.java\n\nCo-Authored-By: Corrado Musumeci <corradom@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "15b576656e62e5987075d3fc6a92aa0b3021199c", "author": {"user": {"login": "m1l4n54v1c", "name": "Milan Savic"}}, "url": "https://github.com/AxonFramework/AxonFramework/commit/15b576656e62e5987075d3fc6a92aa0b3021199c", "committedDate": "2020-02-05T16:26:14Z", "message": "Update messaging/src/main/java/org/axonframework/queryhandling/ReactiveQueryGateway.java\n\nCo-Authored-By: Corrado Musumeci <corradom@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "06d836a29c60eba807b0f9fdfb09fcba947f167a", "author": {"user": {"login": "m1l4n54v1c", "name": "Milan Savic"}}, "url": "https://github.com/AxonFramework/AxonFramework/commit/06d836a29c60eba807b0f9fdfb09fcba947f167a", "committedDate": "2020-02-05T16:26:27Z", "message": "Update messaging/src/main/java/org/axonframework/queryhandling/ReactiveQueryGateway.java\n\nCo-Authored-By: Corrado Musumeci <corradom@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f160ccee6bc9c135ba1deb8c550ebbc19b98c0fc", "author": {"user": {"login": "m1l4n54v1c", "name": "Milan Savic"}}, "url": "https://github.com/AxonFramework/AxonFramework/commit/f160ccee6bc9c135ba1deb8c550ebbc19b98c0fc", "committedDate": "2020-02-05T16:26:37Z", "message": "Update messaging/src/main/java/org/axonframework/queryhandling/ReactiveQueryGateway.java\n\nCo-Authored-By: Corrado Musumeci <corradom@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2a580c5b7ec6bb2cf8ba5eb17b32a52b3c3fb67f", "author": {"user": {"login": "m1l4n54v1c", "name": "Milan Savic"}}, "url": "https://github.com/AxonFramework/AxonFramework/commit/2a580c5b7ec6bb2cf8ba5eb17b32a52b3c3fb67f", "committedDate": "2020-02-05T16:26:49Z", "message": "Update messaging/src/main/java/org/axonframework/queryhandling/ReactiveQueryGateway.java\n\nCo-Authored-By: Corrado Musumeci <corradom@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e168420e5f05562c09216b8b56e2d370415f9bc4", "author": {"user": {"login": "m1l4n54v1c", "name": "Milan Savic"}}, "url": "https://github.com/AxonFramework/AxonFramework/commit/e168420e5f05562c09216b8b56e2d370415f9bc4", "committedDate": "2020-02-18T12:47:39Z", "message": "Merge branch 'master' into reactive-gateways"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "513e6bcd2db50b4252b12fb83870fd1d76d175ea", "author": {"user": {"login": "m1l4n54v1c", "name": "Milan Savic"}}, "url": "https://github.com/AxonFramework/AxonFramework/commit/513e6bcd2db50b4252b12fb83870fd1d76d175ea", "committedDate": "2020-02-19T09:42:45Z", "message": "Merge branch 'master' into reactive-gateways"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3b2e0cf173d4ecf02c70abee2d3e85955624eb03", "author": {"user": {"login": "m1l4n54v1c", "name": "Milan Savic"}}, "url": "https://github.com/AxonFramework/AxonFramework/commit/3b2e0cf173d4ecf02c70abee2d3e85955624eb03", "committedDate": "2020-02-25T10:22:52Z", "message": "Added ReactiveMessageDispatchInterceptor to the ReactiveCommandGateway."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "dc34c277cfacbc1364d67c5ed5b26105833b2169", "author": {"user": {"login": "m1l4n54v1c", "name": "Milan Savic"}}, "url": "https://github.com/AxonFramework/AxonFramework/commit/dc34c277cfacbc1364d67c5ed5b26105833b2169", "committedDate": "2020-02-26T15:01:44Z", "message": "Added ReactiveMessageDispatchInterceptor to the ReactiveQueryGateway."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "dd4db9d5244fd7c0614ed21b0aa4a7fd9ec97000", "author": {"user": {"login": "m1l4n54v1c", "name": "Milan Savic"}}, "url": "https://github.com/AxonFramework/AxonFramework/commit/dd4db9d5244fd7c0614ed21b0aa4a7fd9ec97000", "committedDate": "2020-02-26T15:55:00Z", "message": "Added builders to ReactiveCommandGateway and ReactiveQueryGateway."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3253ff7e66e6230d258f3b680193b689d66774a0", "author": {"user": {"login": "m1l4n54v1c", "name": "Milan Savic"}}, "url": "https://github.com/AxonFramework/AxonFramework/commit/3253ff7e66e6230d258f3b680193b689d66774a0", "committedDate": "2020-02-26T16:18:33Z", "message": "Added RetryScheduler to ReactiveCommandGateway."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY1NTgzODUz", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#pullrequestreview-365583853", "createdAt": "2020-02-27T10:50:32Z", "commit": {"oid": "3253ff7e66e6230d258f3b680193b689d66774a0"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yN1QxMDo1MDozMlrOFvNoaA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yN1QxMDo1MDozMlrOFvNoaA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTA1MDcyOA==", "bodyText": "Is there a use case where a retryScheduler is needed and Mono's out of the box retry mechanism isn't enough? If so, documentation for each use case would be great.", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r385050728", "createdAt": "2020-02-27T10:50:32Z", "author": {"login": "sandjelkovic"}, "path": "messaging/src/main/java/org/axonframework/commandhandling/gateway/DefaultReactiveCommandGateway.java", "diffHunk": "@@ -0,0 +1,207 @@\n+/*\n+ * Copyright (c) 2010-2020. Axon Framework\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.axonframework.commandhandling.gateway;\n+\n+import org.axonframework.commandhandling.CommandBus;\n+import org.axonframework.commandhandling.CommandCallback;\n+import org.axonframework.commandhandling.CommandMessage;\n+import org.axonframework.commandhandling.GenericCommandMessage;\n+import org.axonframework.common.AxonConfigurationException;\n+import org.axonframework.common.Registration;\n+import org.axonframework.messaging.ReactiveMessageDispatchInterceptor;\n+import reactor.core.publisher.Mono;\n+\n+import java.util.List;\n+import java.util.concurrent.CopyOnWriteArrayList;\n+\n+import static java.util.Arrays.asList;\n+import static org.axonframework.common.BuilderUtils.assertNonNull;\n+\n+/**\n+ * Default implementation of {@link ReactiveCommandGateway}.\n+ *\n+ * @author Milan Savic\n+ * @since 4.4\n+ */\n+public class DefaultReactiveCommandGateway implements ReactiveCommandGateway {\n+\n+    private final CommandBus commandBus;\n+    private final RetryScheduler retryScheduler;\n+    private final List<ReactiveMessageDispatchInterceptor<CommandMessage<?>>> dispatchInterceptors;\n+\n+    /**\n+     * Creates an instance of {@link DefaultReactiveCommandGateway} based on the fields contained in the {@link\n+     * Builder}.\n+     * <p>\n+     * Will assert that the {@link CommandBus} is not {@code null} and throws an {@link AxonConfigurationException} if\n+     * it is.\n+     * </p>\n+     *\n+     * @param builder the {@link Builder} used to instantiated a {@link DefaultReactiveCommandGateway} instance\n+     */\n+    protected DefaultReactiveCommandGateway(Builder builder) {\n+        builder.validate();\n+        this.commandBus = builder.commandBus;\n+        this.retryScheduler = builder.retryScheduler;\n+        this.dispatchInterceptors = builder.dispatchInterceptors;\n+    }\n+\n+    /**\n+     * Instantiate a Builder to be able to create a {@link DefaultReactiveCommandGateway}.\n+     * <p>\n+     * The {@code dispatchInterceptors} are defaulted to an empty list.\n+     * The {@link CommandBus} is a <b>hard requirements</b> and as such should be provided.\n+     * </p>\n+     *\n+     * @return a Builder to be able to create a {@link DefaultReactiveCommandGateway}\n+     */\n+    public static Builder builder() {\n+        return new Builder();\n+    }\n+\n+    @Override\n+    public <R> Mono<R> send(Mono<Object> command) {\n+        return processInterceptors(command.map(GenericCommandMessage::asCommandMessage))\n+                .flatMap(commandMessage -> Mono.create(\n+                        sink -> {\n+                            CommandCallback<Object, R> commandCallback = (cm, result) -> {\n+                                try {\n+                                    if (result.isExceptional()) {\n+                                        sink.error(result.exceptionResult());\n+                                    } else {\n+                                        sink.success(result.getPayload());\n+                                    }\n+                                } catch (Exception e) {\n+                                    sink.error(e);\n+                                }\n+                            };\n+                            if (retryScheduler != null) {\n+                                commandCallback = new RetryingCallback<>(commandCallback, retryScheduler, commandBus);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3253ff7e66e6230d258f3b680193b689d66774a0"}, "originalPosition": 93}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b99c7becfa3aa1db87fe222b2e6403a61df059aa", "author": {"user": {"login": "m1l4n54v1c", "name": "Milan Savic"}}, "url": "https://github.com/AxonFramework/AxonFramework/commit/b99c7becfa3aa1db87fe222b2e6403a61df059aa", "committedDate": "2020-02-27T14:07:20Z", "message": "Handling null query results."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "261c2a4e0bab1400d4318aa6586474e063e270a0", "author": {"user": {"login": "m1l4n54v1c", "name": "Milan Savic"}}, "url": "https://github.com/AxonFramework/AxonFramework/commit/261c2a4e0bab1400d4318aa6586474e063e270a0", "committedDate": "2020-02-27T15:05:15Z", "message": "Handle the case when scatter gather query throws an exception."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c4511e81820de8d15c641e1c3038f4b688e29b51", "author": {"user": {"login": "m1l4n54v1c", "name": "Milan Savic"}}, "url": "https://github.com/AxonFramework/AxonFramework/commit/c4511e81820de8d15c641e1c3038f4b688e29b51", "committedDate": "2020-02-27T15:09:28Z", "message": "Merge branch 'master' into reactive-gateways"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzc5NDExNzAy", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#pullrequestreview-379411702", "createdAt": "2020-03-23T13:10:03Z", "commit": {"oid": "c4511e81820de8d15c641e1c3038f4b688e29b51"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 27, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yM1QxMzoxMDowM1rOF6En1g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yM1QxNDozMTowNFrOF6ID2g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjQzNzQ2Mg==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * The given {@code command} is wrapped as the payload of the CommandMessage that is eventually posted on the\n          \n          \n            \n                 * Command Bus, unless Command already implements {@link Message}. In that case, a\n          \n          \n            \n                 * CommandMessage is constructed from that message's payload and MetaData.\n          \n          \n            \n                 * The given {@code command} is wrapped as the payload of a {@link CommandMessage} that is eventually posted on the\n          \n          \n            \n                 * {@link CommandBus}, unless the {@code command} already implements {@link Message}. In that case, a\n          \n          \n            \n                 * {@code CommandMessage} is constructed from that message's payload and {@link MetaData}.", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r396437462", "createdAt": "2020-03-23T13:10:03Z", "author": {"login": "smcvb"}, "path": "messaging/src/main/java/org/axonframework/commandhandling/gateway/ReactiveCommandGateway.java", "diffHunk": "@@ -0,0 +1,55 @@\n+/*\n+ * Copyright (c) 2010-2020. Axon Framework\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.axonframework.commandhandling.gateway;\n+\n+import org.axonframework.messaging.Message;\n+import reactor.core.publisher.Mono;\n+\n+/**\n+ * Variation of {@link CommandGateway}. Provides support for reactive return type such as {@link Mono} from Project\n+ * Reactor.\n+ *\n+ * @author Milan Savic\n+ * @since 4.4\n+ */\n+public interface ReactiveCommandGateway {\n+\n+    /**\n+     * Sends the given {@code command} once the caller subscribes to the command result. Returns immediately.\n+     * <p/>\n+     * The given {@code command} is wrapped as the payload of the CommandMessage that is eventually posted on the\n+     * Command Bus, unless Command already implements {@link Message}. In that case, a\n+     * CommandMessage is constructed from that message's payload and MetaData.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c4511e81820de8d15c641e1c3038f4b688e29b51"}, "originalPosition": 36}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjQzOTk0Ng==", "bodyText": "Wouldn't hurt to add @FunctionalInterface here I think. Or, would that auto-magically be populated from the Supplier interface this interface extends?", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r396439946", "createdAt": "2020-03-23T13:13:56Z", "author": {"login": "smcvb"}, "path": "messaging/src/main/java/org/axonframework/messaging/ReactiveMessageDispatchInterceptor.java", "diffHunk": "@@ -0,0 +1,44 @@\n+/*\n+ * Copyright (c) 2010-2020. Axon Framework\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.axonframework.messaging;\n+\n+import reactor.core.publisher.Mono;\n+\n+import java.util.function.Function;\n+import java.util.function.Supplier;\n+\n+/**\n+ * Interceptor that allows messages to be intercepted and modified before they are dispatched. Implementations are\n+ * required to provide a function that modifies a {@link Mono} of a message and returns a modified/new {@link Mono} to\n+ * be passed down the interceptor chain or to be sent. This way we provide a reactive way to intercept messages.\n+ *\n+ * @param <T> the message type this interceptor can process\n+ * @author Milan Savic\n+ * @since 4.4\n+ */", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c4511e81820de8d15c641e1c3038f4b688e29b51"}, "originalPosition": 32}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjQ0MDQzMQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             * required to provide a function that modifies a {@link Mono} of a message and returns a modified/new {@link Mono} to\n          \n          \n            \n             * be passed down the interceptor chain or to be sent. This way we provide a reactive way to intercept messages.\n          \n          \n            \n             * required to provide a function that modifies a {@link Mono} of a message and returns a modified/new {@code Mono} to\n          \n          \n            \n             * be passed down the interceptor chain or to be dispatched. This way we provide a reactive approach to intercepting messages.", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r396440431", "createdAt": "2020-03-23T13:14:45Z", "author": {"login": "smcvb"}, "path": "messaging/src/main/java/org/axonframework/messaging/ReactiveMessageDispatchInterceptor.java", "diffHunk": "@@ -0,0 +1,44 @@\n+/*\n+ * Copyright (c) 2010-2020. Axon Framework\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.axonframework.messaging;\n+\n+import reactor.core.publisher.Mono;\n+\n+import java.util.function.Function;\n+import java.util.function.Supplier;\n+\n+/**\n+ * Interceptor that allows messages to be intercepted and modified before they are dispatched. Implementations are\n+ * required to provide a function that modifies a {@link Mono} of a message and returns a modified/new {@link Mono} to\n+ * be passed down the interceptor chain or to be sent. This way we provide a reactive way to intercept messages.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c4511e81820de8d15c641e1c3038f4b688e29b51"}, "originalPosition": 27}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjQ0NzYxNA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * Sends given {@code query} over the {@link QueryBus}, expecting a response with the given {@code responseType}\n          \n          \n            \n                 * from a single source. The query name will be derived from the provided {@code query}. Execution may be\n          \n          \n            \n                 * asynchronous, depending on the QueryBus implementation.\n          \n          \n            \n                 * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n          \n          \n            \n                 * Mono}</b></p>\n          \n          \n            \n                 * Sends the given {@code query} over the {@link QueryBus}, expecting a response with the given {@code responseType}\n          \n          \n            \n                 * from a single source. The query name will be derived from the provided {@code query}. Execution may be\n          \n          \n            \n                 * asynchronous, depending on the {@code QueryBus} implementation.\n          \n          \n            \n                 * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n          \n          \n            \n                 * Mono}</b></p>", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r396447614", "createdAt": "2020-03-23T13:25:42Z", "author": {"login": "smcvb"}, "path": "messaging/src/main/java/org/axonframework/queryhandling/ReactiveQueryGateway.java", "diffHunk": "@@ -0,0 +1,386 @@\n+/*\n+ * Copyright (c) 2010-2020. Axon Framework\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.axonframework.queryhandling;\n+\n+import org.axonframework.messaging.responsetypes.ResponseType;\n+import org.axonframework.messaging.responsetypes.ResponseTypes;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Mono;\n+import reactor.util.concurrent.Queues;\n+\n+import java.util.concurrent.TimeUnit;\n+\n+/**\n+ * Variation of {@link QueryGateway}. Provides support for reactive return types such as {@link Mono} and {@link Flux}\n+ * from Project Reactor.\n+ *\n+ * @author Milan Savic\n+ * @since 4.4\n+ */\n+public interface ReactiveQueryGateway {\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus}, expecting a response with the given {@code responseType}\n+     * from a single source. The query name will be derived from the provided {@code query}. Execution may be\n+     * asynchronous, depending on the QueryBus implementation.\n+     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c4511e81820de8d15c641e1c3038f4b688e29b51"}, "originalPosition": 41}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjQ0ODI1OQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * Sends given {@code query} over the {@link QueryBus}, expecting a response with the given {@code responseType}\n          \n          \n            \n                 * from a single source. Execution may be asynchronous, depending on the QueryBus implementation.\n          \n          \n            \n                 * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n          \n          \n            \n                 * Mono}</b></p>\n          \n          \n            \n                 * Sends the given {@code query} over the {@link QueryBus}, expecting a response with the given {@code responseType}\n          \n          \n            \n                 * from a single source. Execution may be asynchronous, depending on the {@code QueryBus} implementation.\n          \n          \n            \n                 * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n          \n          \n            \n                 * Mono}</b></p>", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r396448259", "createdAt": "2020-03-23T13:26:44Z", "author": {"login": "smcvb"}, "path": "messaging/src/main/java/org/axonframework/queryhandling/ReactiveQueryGateway.java", "diffHunk": "@@ -0,0 +1,386 @@\n+/*\n+ * Copyright (c) 2010-2020. Axon Framework\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.axonframework.queryhandling;\n+\n+import org.axonframework.messaging.responsetypes.ResponseType;\n+import org.axonframework.messaging.responsetypes.ResponseTypes;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Mono;\n+import reactor.util.concurrent.Queues;\n+\n+import java.util.concurrent.TimeUnit;\n+\n+/**\n+ * Variation of {@link QueryGateway}. Provides support for reactive return types such as {@link Mono} and {@link Flux}\n+ * from Project Reactor.\n+ *\n+ * @author Milan Savic\n+ * @since 4.4\n+ */\n+public interface ReactiveQueryGateway {\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus}, expecting a response with the given {@code responseType}\n+     * from a single source. The query name will be derived from the provided {@code query}. Execution may be\n+     * asynchronous, depending on the QueryBus implementation.\n+     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param query        The {@code query} to be sent\n+     * @param responseType A {@link Class} describing the desired response type\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(Q query, Class<R> responseType) {\n+        return query(query.getClass().getName(), query, responseType);\n+    }\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus}, expecting a response with the given {@code responseType}\n+     * from a single source. Execution may be asynchronous, depending on the QueryBus implementation.\n+     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c4511e81820de8d15c641e1c3038f4b688e29b51"}, "originalPosition": 57}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjQ0ODY3OQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * Sends given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n          \n          \n            \n                 * from a single source. The query name will be derived from the provided {@code query}. Execution may be\n          \n          \n            \n                 * asynchronous, depending on the QueryBus implementation.\n          \n          \n            \n                 * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n          \n          \n            \n                 * Mono}</b></p>\n          \n          \n            \n                 * Sends the given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n          \n          \n            \n                 * from a single source. The query name will be derived from the provided {@code query}. Execution may be\n          \n          \n            \n                 * asynchronous, depending on the {@code QueryBus} implementation.\n          \n          \n            \n                 * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n          \n          \n            \n                 * Mono}</b></p>", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r396448679", "createdAt": "2020-03-23T13:27:28Z", "author": {"login": "smcvb"}, "path": "messaging/src/main/java/org/axonframework/queryhandling/ReactiveQueryGateway.java", "diffHunk": "@@ -0,0 +1,386 @@\n+/*\n+ * Copyright (c) 2010-2020. Axon Framework\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.axonframework.queryhandling;\n+\n+import org.axonframework.messaging.responsetypes.ResponseType;\n+import org.axonframework.messaging.responsetypes.ResponseTypes;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Mono;\n+import reactor.util.concurrent.Queues;\n+\n+import java.util.concurrent.TimeUnit;\n+\n+/**\n+ * Variation of {@link QueryGateway}. Provides support for reactive return types such as {@link Mono} and {@link Flux}\n+ * from Project Reactor.\n+ *\n+ * @author Milan Savic\n+ * @since 4.4\n+ */\n+public interface ReactiveQueryGateway {\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus}, expecting a response with the given {@code responseType}\n+     * from a single source. The query name will be derived from the provided {@code query}. Execution may be\n+     * asynchronous, depending on the QueryBus implementation.\n+     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param query        The {@code query} to be sent\n+     * @param responseType A {@link Class} describing the desired response type\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(Q query, Class<R> responseType) {\n+        return query(query.getClass().getName(), query, responseType);\n+    }\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus}, expecting a response with the given {@code responseType}\n+     * from a single source. Execution may be asynchronous, depending on the QueryBus implementation.\n+     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(String queryName, Q query, Class<R> responseType) {\n+        return query(queryName, query, ResponseTypes.instanceOf(responseType));\n+    }\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from a single source. The query name will be derived from the provided {@code query}. Execution may be\n+     * asynchronous, depending on the QueryBus implementation.\n+     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c4511e81820de8d15c641e1c3038f4b688e29b51"}, "originalPosition": 75}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjQ0OTEyMA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * Sends given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n          \n          \n            \n                 * from a single source. Execution may be asynchronous, depending on the QueryBus implementation.\n          \n          \n            \n                 * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n          \n          \n            \n                 * Mono}</b></p>\n          \n          \n            \n                 * Sends the given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n          \n          \n            \n                 * from a single source. Execution may be asynchronous, depending on the {@code QueryBus} implementation.\n          \n          \n            \n                 * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n          \n          \n            \n                 * Mono}</b></p>", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r396449120", "createdAt": "2020-03-23T13:28:05Z", "author": {"login": "smcvb"}, "path": "messaging/src/main/java/org/axonframework/queryhandling/ReactiveQueryGateway.java", "diffHunk": "@@ -0,0 +1,386 @@\n+/*\n+ * Copyright (c) 2010-2020. Axon Framework\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.axonframework.queryhandling;\n+\n+import org.axonframework.messaging.responsetypes.ResponseType;\n+import org.axonframework.messaging.responsetypes.ResponseTypes;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Mono;\n+import reactor.util.concurrent.Queues;\n+\n+import java.util.concurrent.TimeUnit;\n+\n+/**\n+ * Variation of {@link QueryGateway}. Provides support for reactive return types such as {@link Mono} and {@link Flux}\n+ * from Project Reactor.\n+ *\n+ * @author Milan Savic\n+ * @since 4.4\n+ */\n+public interface ReactiveQueryGateway {\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus}, expecting a response with the given {@code responseType}\n+     * from a single source. The query name will be derived from the provided {@code query}. Execution may be\n+     * asynchronous, depending on the QueryBus implementation.\n+     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param query        The {@code query} to be sent\n+     * @param responseType A {@link Class} describing the desired response type\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(Q query, Class<R> responseType) {\n+        return query(query.getClass().getName(), query, responseType);\n+    }\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus}, expecting a response with the given {@code responseType}\n+     * from a single source. Execution may be asynchronous, depending on the QueryBus implementation.\n+     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(String queryName, Q query, Class<R> responseType) {\n+        return query(queryName, query, ResponseTypes.instanceOf(responseType));\n+    }\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from a single source. The query name will be derived from the provided {@code query}. Execution may be\n+     * asynchronous, depending on the QueryBus implementation.\n+     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(Q query, ResponseType<R> responseType) {\n+        return query(query.getClass().getName(), query, responseType);\n+    }\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from a single source. Execution may be asynchronous, depending on the QueryBus implementation.\n+     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c4511e81820de8d15c641e1c3038f4b688e29b51"}, "originalPosition": 91}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjQ0OTc2Mg==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * Sends given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n          \n          \n            \n                 * from a single source. Execution may be asynchronous, depending on the QueryBus implementation.\n          \n          \n            \n                 * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n          \n          \n            \n                 * Mono}</b></p>\n          \n          \n            \n                 * Sends the given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n          \n          \n            \n                 * from a single source. Execution may be asynchronous, depending on the {@code QueryBus} implementation.\n          \n          \n            \n                 * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n          \n          \n            \n                 * Mono}</b></p>", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r396449762", "createdAt": "2020-03-23T13:28:58Z", "author": {"login": "smcvb"}, "path": "messaging/src/main/java/org/axonframework/queryhandling/ReactiveQueryGateway.java", "diffHunk": "@@ -0,0 +1,386 @@\n+/*\n+ * Copyright (c) 2010-2020. Axon Framework\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.axonframework.queryhandling;\n+\n+import org.axonframework.messaging.responsetypes.ResponseType;\n+import org.axonframework.messaging.responsetypes.ResponseTypes;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Mono;\n+import reactor.util.concurrent.Queues;\n+\n+import java.util.concurrent.TimeUnit;\n+\n+/**\n+ * Variation of {@link QueryGateway}. Provides support for reactive return types such as {@link Mono} and {@link Flux}\n+ * from Project Reactor.\n+ *\n+ * @author Milan Savic\n+ * @since 4.4\n+ */\n+public interface ReactiveQueryGateway {\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus}, expecting a response with the given {@code responseType}\n+     * from a single source. The query name will be derived from the provided {@code query}. Execution may be\n+     * asynchronous, depending on the QueryBus implementation.\n+     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param query        The {@code query} to be sent\n+     * @param responseType A {@link Class} describing the desired response type\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(Q query, Class<R> responseType) {\n+        return query(query.getClass().getName(), query, responseType);\n+    }\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus}, expecting a response with the given {@code responseType}\n+     * from a single source. Execution may be asynchronous, depending on the QueryBus implementation.\n+     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(String queryName, Q query, Class<R> responseType) {\n+        return query(queryName, query, ResponseTypes.instanceOf(responseType));\n+    }\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from a single source. The query name will be derived from the provided {@code query}. Execution may be\n+     * asynchronous, depending on the QueryBus implementation.\n+     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(Q query, ResponseType<R> responseType) {\n+        return query(query.getClass().getName(), query, responseType);\n+    }\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from a single source. Execution may be asynchronous, depending on the QueryBus implementation.\n+     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(String queryName, Q query, ResponseType<R> responseType) {\n+        return query(queryName, Mono.just(query), responseType);\n+    }\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from a single source. Execution may be asynchronous, depending on the QueryBus implementation.\n+     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c4511e81820de8d15c641e1c3038f4b688e29b51"}, "originalPosition": 108}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjQ1MTI5MQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * Sends given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n          \n          \n            \n                 * from several sources. The flux is completed when a {@code timeout} occurs or when all results are received. The\n          \n          \n            \n                 * query name will be derived from the provided {@code query}. Execution may be asynchronous, depending on the\n          \n          \n            \n                 * QueryBus implementation.\n          \n          \n            \n                 * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n          \n          \n            \n                 * Mono}</b></p>\n          \n          \n            \n                 * <b>Note</b>: Any {@code null} results will be filtered out by the QueryGateway. If you require the {@code null}\n          \n          \n            \n                 * to be returned, we suggest using {@link QueryBus} instead.\n          \n          \n            \n                 * Sends the given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n          \n          \n            \n                 * from several sources. The returned {@link Flux} is completed when a {@code timeout} occurs or when all possible results are received. The\n          \n          \n            \n                 * query name will be derived from the provided {@code query}. Execution may be asynchronous, depending on the\n          \n          \n            \n                 * {@code QueryBus} implementation.\n          \n          \n            \n                 * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n          \n          \n            \n                 * Mono}</b></p>\n          \n          \n            \n                 * <b>Note</b>: Any {@code null} results will be filtered out by the {@link ReactiveQueryGateway}. If you require the {@code null}\n          \n          \n            \n                 * to be returned, we suggest using {@code QueryBus} instead.", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r396451291", "createdAt": "2020-03-23T13:31:13Z", "author": {"login": "smcvb"}, "path": "messaging/src/main/java/org/axonframework/queryhandling/ReactiveQueryGateway.java", "diffHunk": "@@ -0,0 +1,386 @@\n+/*\n+ * Copyright (c) 2010-2020. Axon Framework\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.axonframework.queryhandling;\n+\n+import org.axonframework.messaging.responsetypes.ResponseType;\n+import org.axonframework.messaging.responsetypes.ResponseTypes;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Mono;\n+import reactor.util.concurrent.Queues;\n+\n+import java.util.concurrent.TimeUnit;\n+\n+/**\n+ * Variation of {@link QueryGateway}. Provides support for reactive return types such as {@link Mono} and {@link Flux}\n+ * from Project Reactor.\n+ *\n+ * @author Milan Savic\n+ * @since 4.4\n+ */\n+public interface ReactiveQueryGateway {\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus}, expecting a response with the given {@code responseType}\n+     * from a single source. The query name will be derived from the provided {@code query}. Execution may be\n+     * asynchronous, depending on the QueryBus implementation.\n+     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param query        The {@code query} to be sent\n+     * @param responseType A {@link Class} describing the desired response type\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(Q query, Class<R> responseType) {\n+        return query(query.getClass().getName(), query, responseType);\n+    }\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus}, expecting a response with the given {@code responseType}\n+     * from a single source. Execution may be asynchronous, depending on the QueryBus implementation.\n+     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(String queryName, Q query, Class<R> responseType) {\n+        return query(queryName, query, ResponseTypes.instanceOf(responseType));\n+    }\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from a single source. The query name will be derived from the provided {@code query}. Execution may be\n+     * asynchronous, depending on the QueryBus implementation.\n+     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(Q query, ResponseType<R> responseType) {\n+        return query(query.getClass().getName(), query, responseType);\n+    }\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from a single source. Execution may be asynchronous, depending on the QueryBus implementation.\n+     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(String queryName, Q query, ResponseType<R> responseType) {\n+        return query(queryName, Mono.just(query), responseType);\n+    }\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from a single source. Execution may be asynchronous, depending on the QueryBus implementation.\n+     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        a {@link Mono} which is resolved once the caller subscribes to the query result\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    <R, Q> Mono<R> query(String queryName, Mono<Q> query, ResponseType<R> responseType);\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from several sources. The flux is completed when a {@code timeout} occurs or when all results are received. The\n+     * query name will be derived from the provided {@code query}. Execution may be asynchronous, depending on the\n+     * QueryBus implementation.\n+     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     * <b>Note</b>: Any {@code null} results will be filtered out by the QueryGateway. If you require the {@code null}\n+     * to be returned, we suggest using {@link QueryBus} instead.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c4511e81820de8d15c641e1c3038f4b688e29b51"}, "originalPosition": 127}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjQ1Mjc1MA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * @return A flux of results\n          \n          \n            \n                 * @return A {@link Flux} containing the query results as dictated by the given {@code responseType}", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r396452750", "createdAt": "2020-03-23T13:33:25Z", "author": {"login": "smcvb"}, "path": "messaging/src/main/java/org/axonframework/queryhandling/ReactiveQueryGateway.java", "diffHunk": "@@ -0,0 +1,386 @@\n+/*\n+ * Copyright (c) 2010-2020. Axon Framework\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.axonframework.queryhandling;\n+\n+import org.axonframework.messaging.responsetypes.ResponseType;\n+import org.axonframework.messaging.responsetypes.ResponseTypes;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Mono;\n+import reactor.util.concurrent.Queues;\n+\n+import java.util.concurrent.TimeUnit;\n+\n+/**\n+ * Variation of {@link QueryGateway}. Provides support for reactive return types such as {@link Mono} and {@link Flux}\n+ * from Project Reactor.\n+ *\n+ * @author Milan Savic\n+ * @since 4.4\n+ */\n+public interface ReactiveQueryGateway {\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus}, expecting a response with the given {@code responseType}\n+     * from a single source. The query name will be derived from the provided {@code query}. Execution may be\n+     * asynchronous, depending on the QueryBus implementation.\n+     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param query        The {@code query} to be sent\n+     * @param responseType A {@link Class} describing the desired response type\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(Q query, Class<R> responseType) {\n+        return query(query.getClass().getName(), query, responseType);\n+    }\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus}, expecting a response with the given {@code responseType}\n+     * from a single source. Execution may be asynchronous, depending on the QueryBus implementation.\n+     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(String queryName, Q query, Class<R> responseType) {\n+        return query(queryName, query, ResponseTypes.instanceOf(responseType));\n+    }\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from a single source. The query name will be derived from the provided {@code query}. Execution may be\n+     * asynchronous, depending on the QueryBus implementation.\n+     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(Q query, ResponseType<R> responseType) {\n+        return query(query.getClass().getName(), query, responseType);\n+    }\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from a single source. Execution may be asynchronous, depending on the QueryBus implementation.\n+     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(String queryName, Q query, ResponseType<R> responseType) {\n+        return query(queryName, Mono.just(query), responseType);\n+    }\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from a single source. Execution may be asynchronous, depending on the QueryBus implementation.\n+     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        a {@link Mono} which is resolved once the caller subscribes to the query result\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    <R, Q> Mono<R> query(String queryName, Mono<Q> query, ResponseType<R> responseType);\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from several sources. The flux is completed when a {@code timeout} occurs or when all results are received. The\n+     * query name will be derived from the provided {@code query}. Execution may be asynchronous, depending on the\n+     * QueryBus implementation.\n+     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     * <b>Note</b>: Any {@code null} results will be filtered out by the QueryGateway. If you require the {@code null}\n+     * to be returned, we suggest using {@link QueryBus} instead.\n+     *\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param timeout      A timeout of {@code long} for the query\n+     * @param timeUnit     The selected {@link TimeUnit} for the given {@code timeout}\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A flux of results", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c4511e81820de8d15c641e1c3038f4b688e29b51"}, "originalPosition": 135}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjQ1MzEzOQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * @return A flux of results.\n          \n          \n            \n                 * @return A {@link Flux} containing the query results as dictated by the given {@code responseType}", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r396453139", "createdAt": "2020-03-23T13:33:59Z", "author": {"login": "smcvb"}, "path": "messaging/src/main/java/org/axonframework/queryhandling/ReactiveQueryGateway.java", "diffHunk": "@@ -0,0 +1,386 @@\n+/*\n+ * Copyright (c) 2010-2020. Axon Framework\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.axonframework.queryhandling;\n+\n+import org.axonframework.messaging.responsetypes.ResponseType;\n+import org.axonframework.messaging.responsetypes.ResponseTypes;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Mono;\n+import reactor.util.concurrent.Queues;\n+\n+import java.util.concurrent.TimeUnit;\n+\n+/**\n+ * Variation of {@link QueryGateway}. Provides support for reactive return types such as {@link Mono} and {@link Flux}\n+ * from Project Reactor.\n+ *\n+ * @author Milan Savic\n+ * @since 4.4\n+ */\n+public interface ReactiveQueryGateway {\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus}, expecting a response with the given {@code responseType}\n+     * from a single source. The query name will be derived from the provided {@code query}. Execution may be\n+     * asynchronous, depending on the QueryBus implementation.\n+     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param query        The {@code query} to be sent\n+     * @param responseType A {@link Class} describing the desired response type\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(Q query, Class<R> responseType) {\n+        return query(query.getClass().getName(), query, responseType);\n+    }\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus}, expecting a response with the given {@code responseType}\n+     * from a single source. Execution may be asynchronous, depending on the QueryBus implementation.\n+     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(String queryName, Q query, Class<R> responseType) {\n+        return query(queryName, query, ResponseTypes.instanceOf(responseType));\n+    }\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from a single source. The query name will be derived from the provided {@code query}. Execution may be\n+     * asynchronous, depending on the QueryBus implementation.\n+     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(Q query, ResponseType<R> responseType) {\n+        return query(query.getClass().getName(), query, responseType);\n+    }\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from a single source. Execution may be asynchronous, depending on the QueryBus implementation.\n+     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(String queryName, Q query, ResponseType<R> responseType) {\n+        return query(queryName, Mono.just(query), responseType);\n+    }\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from a single source. Execution may be asynchronous, depending on the QueryBus implementation.\n+     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        a {@link Mono} which is resolved once the caller subscribes to the query result\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    <R, Q> Mono<R> query(String queryName, Mono<Q> query, ResponseType<R> responseType);\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from several sources. The flux is completed when a {@code timeout} occurs or when all results are received. The\n+     * query name will be derived from the provided {@code query}. Execution may be asynchronous, depending on the\n+     * QueryBus implementation.\n+     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     * <b>Note</b>: Any {@code null} results will be filtered out by the QueryGateway. If you require the {@code null}\n+     * to be returned, we suggest using {@link QueryBus} instead.\n+     *\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param timeout      A timeout of {@code long} for the query\n+     * @param timeUnit     The selected {@link TimeUnit} for the given {@code timeout}\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A flux of results\n+     */\n+    default <R, Q> Flux<R> scatterGather(Q query, ResponseType<R> responseType, long timeout, TimeUnit timeUnit) {\n+        return scatterGather(query.getClass().getName(), query, responseType, timeout, timeUnit);\n+    }\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from several sources. The flux is completed when a {@code timeout} occurs or when all results are received.\n+     * Execution may be asynchronous, depending on the QueryBus implementation.\n+     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     * <b>Note</b>: Any {@code null} results will be filtered out by the QueryGateway. If you require the {@code null}\n+     * to be returned, we suggest using {@link QueryBus} instead.\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param timeout      A timeout of {@code long} for the query\n+     * @param timeUnit     The selected {@link TimeUnit} for the given {@code timeout}\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A flux of results.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c4511e81820de8d15c641e1c3038f4b688e29b51"}, "originalPosition": 157}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjQ1MzI1OA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * @return A flux of results.\n          \n          \n            \n                 * @return A {@link Flux} containing the query results as dictated by the given {@code responseType}", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r396453258", "createdAt": "2020-03-23T13:34:10Z", "author": {"login": "smcvb"}, "path": "messaging/src/main/java/org/axonframework/queryhandling/ReactiveQueryGateway.java", "diffHunk": "@@ -0,0 +1,386 @@\n+/*\n+ * Copyright (c) 2010-2020. Axon Framework\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.axonframework.queryhandling;\n+\n+import org.axonframework.messaging.responsetypes.ResponseType;\n+import org.axonframework.messaging.responsetypes.ResponseTypes;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Mono;\n+import reactor.util.concurrent.Queues;\n+\n+import java.util.concurrent.TimeUnit;\n+\n+/**\n+ * Variation of {@link QueryGateway}. Provides support for reactive return types such as {@link Mono} and {@link Flux}\n+ * from Project Reactor.\n+ *\n+ * @author Milan Savic\n+ * @since 4.4\n+ */\n+public interface ReactiveQueryGateway {\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus}, expecting a response with the given {@code responseType}\n+     * from a single source. The query name will be derived from the provided {@code query}. Execution may be\n+     * asynchronous, depending on the QueryBus implementation.\n+     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param query        The {@code query} to be sent\n+     * @param responseType A {@link Class} describing the desired response type\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(Q query, Class<R> responseType) {\n+        return query(query.getClass().getName(), query, responseType);\n+    }\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus}, expecting a response with the given {@code responseType}\n+     * from a single source. Execution may be asynchronous, depending on the QueryBus implementation.\n+     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(String queryName, Q query, Class<R> responseType) {\n+        return query(queryName, query, ResponseTypes.instanceOf(responseType));\n+    }\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from a single source. The query name will be derived from the provided {@code query}. Execution may be\n+     * asynchronous, depending on the QueryBus implementation.\n+     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(Q query, ResponseType<R> responseType) {\n+        return query(query.getClass().getName(), query, responseType);\n+    }\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from a single source. Execution may be asynchronous, depending on the QueryBus implementation.\n+     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(String queryName, Q query, ResponseType<R> responseType) {\n+        return query(queryName, Mono.just(query), responseType);\n+    }\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from a single source. Execution may be asynchronous, depending on the QueryBus implementation.\n+     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        a {@link Mono} which is resolved once the caller subscribes to the query result\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    <R, Q> Mono<R> query(String queryName, Mono<Q> query, ResponseType<R> responseType);\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from several sources. The flux is completed when a {@code timeout} occurs or when all results are received. The\n+     * query name will be derived from the provided {@code query}. Execution may be asynchronous, depending on the\n+     * QueryBus implementation.\n+     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     * <b>Note</b>: Any {@code null} results will be filtered out by the QueryGateway. If you require the {@code null}\n+     * to be returned, we suggest using {@link QueryBus} instead.\n+     *\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param timeout      A timeout of {@code long} for the query\n+     * @param timeUnit     The selected {@link TimeUnit} for the given {@code timeout}\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A flux of results\n+     */\n+    default <R, Q> Flux<R> scatterGather(Q query, ResponseType<R> responseType, long timeout, TimeUnit timeUnit) {\n+        return scatterGather(query.getClass().getName(), query, responseType, timeout, timeUnit);\n+    }\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from several sources. The flux is completed when a {@code timeout} occurs or when all results are received.\n+     * Execution may be asynchronous, depending on the QueryBus implementation.\n+     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     * <b>Note</b>: Any {@code null} results will be filtered out by the QueryGateway. If you require the {@code null}\n+     * to be returned, we suggest using {@link QueryBus} instead.\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param timeout      A timeout of {@code long} for the query\n+     * @param timeUnit     The selected {@link TimeUnit} for the given {@code timeout}\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A flux of results.\n+     */\n+    default <R, Q> Flux<R> scatterGather(String queryName, Q query, ResponseType<R> responseType, long timeout,\n+                                         TimeUnit timeUnit) {\n+        return scatterGather(queryName, Mono.just(query), responseType, timeout, timeUnit);\n+    }\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from several sources. The flux is completed when a {@code timeout} occurs or when all results are received.\n+     * Execution may be asynchronous, depending on the QueryBus implementation.\n+     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     * <b>Note</b>: Any {@code null} results will be filtered out by the QueryGateway. If you require the {@code null}\n+     * to be returned, we suggest using {@link QueryBus} instead.\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        a {@link Mono} which is resolved once the caller subscribes to the query result\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param timeout      A timeout of {@code long} for the query\n+     * @param timeUnit     The selected {@link TimeUnit} for the given {@code timeout}\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A flux of results.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c4511e81820de8d15c641e1c3038f4b688e29b51"}, "originalPosition": 180}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjQ1NDI3MQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * Sends given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n          \n          \n            \n                 * from several sources. The flux is completed when a {@code timeout} occurs or when all results are received.\n          \n          \n            \n                 * Execution may be asynchronous, depending on the QueryBus implementation.\n          \n          \n            \n                 * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n          \n          \n            \n                 * Mono}</b></p>\n          \n          \n            \n                 * <b>Note</b>: Any {@code null} results will be filtered out by the QueryGateway. If you require the {@code null}\n          \n          \n            \n                 * to be returned, we suggest using {@link QueryBus} instead.\n          \n          \n            \n                 * Sends the given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n          \n          \n            \n                 * from several sources. The returned {@link Flux} is completed when a {@code timeout} occurs or when all results are received.\n          \n          \n            \n                 * Execution may be asynchronous, depending on the {@code QueryBus} implementation.\n          \n          \n            \n                 * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n          \n          \n            \n                 * Mono}</b></p>\n          \n          \n            \n                 * <b>Note</b>: Any {@code null} results will be filtered out by the {@link ReactiveQueryGateway}. If you require the {@code null}\n          \n          \n            \n                 * to be returned, we suggest using {@code QueryBus} instead.", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r396454271", "createdAt": "2020-03-23T13:35:39Z", "author": {"login": "smcvb"}, "path": "messaging/src/main/java/org/axonframework/queryhandling/ReactiveQueryGateway.java", "diffHunk": "@@ -0,0 +1,386 @@\n+/*\n+ * Copyright (c) 2010-2020. Axon Framework\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.axonframework.queryhandling;\n+\n+import org.axonframework.messaging.responsetypes.ResponseType;\n+import org.axonframework.messaging.responsetypes.ResponseTypes;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Mono;\n+import reactor.util.concurrent.Queues;\n+\n+import java.util.concurrent.TimeUnit;\n+\n+/**\n+ * Variation of {@link QueryGateway}. Provides support for reactive return types such as {@link Mono} and {@link Flux}\n+ * from Project Reactor.\n+ *\n+ * @author Milan Savic\n+ * @since 4.4\n+ */\n+public interface ReactiveQueryGateway {\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus}, expecting a response with the given {@code responseType}\n+     * from a single source. The query name will be derived from the provided {@code query}. Execution may be\n+     * asynchronous, depending on the QueryBus implementation.\n+     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param query        The {@code query} to be sent\n+     * @param responseType A {@link Class} describing the desired response type\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(Q query, Class<R> responseType) {\n+        return query(query.getClass().getName(), query, responseType);\n+    }\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus}, expecting a response with the given {@code responseType}\n+     * from a single source. Execution may be asynchronous, depending on the QueryBus implementation.\n+     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(String queryName, Q query, Class<R> responseType) {\n+        return query(queryName, query, ResponseTypes.instanceOf(responseType));\n+    }\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from a single source. The query name will be derived from the provided {@code query}. Execution may be\n+     * asynchronous, depending on the QueryBus implementation.\n+     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(Q query, ResponseType<R> responseType) {\n+        return query(query.getClass().getName(), query, responseType);\n+    }\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from a single source. Execution may be asynchronous, depending on the QueryBus implementation.\n+     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(String queryName, Q query, ResponseType<R> responseType) {\n+        return query(queryName, Mono.just(query), responseType);\n+    }\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from a single source. Execution may be asynchronous, depending on the QueryBus implementation.\n+     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        a {@link Mono} which is resolved once the caller subscribes to the query result\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    <R, Q> Mono<R> query(String queryName, Mono<Q> query, ResponseType<R> responseType);\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from several sources. The flux is completed when a {@code timeout} occurs or when all results are received. The\n+     * query name will be derived from the provided {@code query}. Execution may be asynchronous, depending on the\n+     * QueryBus implementation.\n+     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     * <b>Note</b>: Any {@code null} results will be filtered out by the QueryGateway. If you require the {@code null}\n+     * to be returned, we suggest using {@link QueryBus} instead.\n+     *\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param timeout      A timeout of {@code long} for the query\n+     * @param timeUnit     The selected {@link TimeUnit} for the given {@code timeout}\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A flux of results\n+     */\n+    default <R, Q> Flux<R> scatterGather(Q query, ResponseType<R> responseType, long timeout, TimeUnit timeUnit) {\n+        return scatterGather(query.getClass().getName(), query, responseType, timeout, timeUnit);\n+    }\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from several sources. The flux is completed when a {@code timeout} occurs or when all results are received.\n+     * Execution may be asynchronous, depending on the QueryBus implementation.\n+     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     * <b>Note</b>: Any {@code null} results will be filtered out by the QueryGateway. If you require the {@code null}\n+     * to be returned, we suggest using {@link QueryBus} instead.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c4511e81820de8d15c641e1c3038f4b688e29b51"}, "originalPosition": 148}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjQ1NTcwOA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * Sends given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n          \n          \n            \n                 * from several sources. The flux is completed when a {@code timeout} occurs or when all results are received.\n          \n          \n            \n                 * Execution may be asynchronous, depending on the QueryBus implementation.\n          \n          \n            \n                 * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n          \n          \n            \n                 * Mono}</b></p>\n          \n          \n            \n                 * <b>Note</b>: Any {@code null} results will be filtered out by the QueryGateway. If you require the {@code null}\n          \n          \n            \n                 * to be returned, we suggest using {@link QueryBus} instead.\n          \n          \n            \n                 * Sends the given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n          \n          \n            \n                 * from several sources. The returned {@link Flux} is completed when a {@code timeout} occurs or when all results are received.\n          \n          \n            \n                 * Execution may be asynchronous, depending on the {@code QueryBus} implementation.\n          \n          \n            \n                 * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n          \n          \n            \n                 * Mono}</b></p>\n          \n          \n            \n                 * <b>Note</b>: Any {@code null} results will be filtered out by the {@link ReactiveQueryGateway}. If you require the {@code null}\n          \n          \n            \n                 * to be returned, we suggest using {@code QueryBus} instead.", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r396455708", "createdAt": "2020-03-23T13:37:47Z", "author": {"login": "smcvb"}, "path": "messaging/src/main/java/org/axonframework/queryhandling/ReactiveQueryGateway.java", "diffHunk": "@@ -0,0 +1,386 @@\n+/*\n+ * Copyright (c) 2010-2020. Axon Framework\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.axonframework.queryhandling;\n+\n+import org.axonframework.messaging.responsetypes.ResponseType;\n+import org.axonframework.messaging.responsetypes.ResponseTypes;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Mono;\n+import reactor.util.concurrent.Queues;\n+\n+import java.util.concurrent.TimeUnit;\n+\n+/**\n+ * Variation of {@link QueryGateway}. Provides support for reactive return types such as {@link Mono} and {@link Flux}\n+ * from Project Reactor.\n+ *\n+ * @author Milan Savic\n+ * @since 4.4\n+ */\n+public interface ReactiveQueryGateway {\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus}, expecting a response with the given {@code responseType}\n+     * from a single source. The query name will be derived from the provided {@code query}. Execution may be\n+     * asynchronous, depending on the QueryBus implementation.\n+     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param query        The {@code query} to be sent\n+     * @param responseType A {@link Class} describing the desired response type\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(Q query, Class<R> responseType) {\n+        return query(query.getClass().getName(), query, responseType);\n+    }\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus}, expecting a response with the given {@code responseType}\n+     * from a single source. Execution may be asynchronous, depending on the QueryBus implementation.\n+     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(String queryName, Q query, Class<R> responseType) {\n+        return query(queryName, query, ResponseTypes.instanceOf(responseType));\n+    }\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from a single source. The query name will be derived from the provided {@code query}. Execution may be\n+     * asynchronous, depending on the QueryBus implementation.\n+     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(Q query, ResponseType<R> responseType) {\n+        return query(query.getClass().getName(), query, responseType);\n+    }\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from a single source. Execution may be asynchronous, depending on the QueryBus implementation.\n+     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(String queryName, Q query, ResponseType<R> responseType) {\n+        return query(queryName, Mono.just(query), responseType);\n+    }\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from a single source. Execution may be asynchronous, depending on the QueryBus implementation.\n+     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        a {@link Mono} which is resolved once the caller subscribes to the query result\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    <R, Q> Mono<R> query(String queryName, Mono<Q> query, ResponseType<R> responseType);\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from several sources. The flux is completed when a {@code timeout} occurs or when all results are received. The\n+     * query name will be derived from the provided {@code query}. Execution may be asynchronous, depending on the\n+     * QueryBus implementation.\n+     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     * <b>Note</b>: Any {@code null} results will be filtered out by the QueryGateway. If you require the {@code null}\n+     * to be returned, we suggest using {@link QueryBus} instead.\n+     *\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param timeout      A timeout of {@code long} for the query\n+     * @param timeUnit     The selected {@link TimeUnit} for the given {@code timeout}\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A flux of results\n+     */\n+    default <R, Q> Flux<R> scatterGather(Q query, ResponseType<R> responseType, long timeout, TimeUnit timeUnit) {\n+        return scatterGather(query.getClass().getName(), query, responseType, timeout, timeUnit);\n+    }\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from several sources. The flux is completed when a {@code timeout} occurs or when all results are received.\n+     * Execution may be asynchronous, depending on the QueryBus implementation.\n+     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     * <b>Note</b>: Any {@code null} results will be filtered out by the QueryGateway. If you require the {@code null}\n+     * to be returned, we suggest using {@link QueryBus} instead.\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param timeout      A timeout of {@code long} for the query\n+     * @param timeUnit     The selected {@link TimeUnit} for the given {@code timeout}\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A flux of results.\n+     */\n+    default <R, Q> Flux<R> scatterGather(String queryName, Q query, ResponseType<R> responseType, long timeout,\n+                                         TimeUnit timeUnit) {\n+        return scatterGather(queryName, Mono.just(query), responseType, timeout, timeUnit);\n+    }\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from several sources. The flux is completed when a {@code timeout} occurs or when all results are received.\n+     * Execution may be asynchronous, depending on the QueryBus implementation.\n+     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     * <b>Note</b>: Any {@code null} results will be filtered out by the QueryGateway. If you require the {@code null}\n+     * to be returned, we suggest using {@link QueryBus} instead.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c4511e81820de8d15c641e1c3038f4b688e29b51"}, "originalPosition": 171}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjQ2NjAzMA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * Sends given {@code query} over the {@link QueryBus} and returns result containing initial response and\n          \n          \n            \n                 * incremental updates (received at the moment the query is sent, until it is cancelled by the caller or closed by\n          \n          \n            \n                 * the emitting side).\n          \n          \n            \n                 * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n          \n          \n            \n                 * Mono}</b></p>\n          \n          \n            \n                 * <p>\n          \n          \n            \n                 * <b>Note</b>: Any {@code null} results, on the initial result or the updates, will be filtered out by the\n          \n          \n            \n                 * QueryGateway. If you require the {@code null} to be returned for the initial and update results, we suggest using\n          \n          \n            \n                 * the {@link QueryBus} instead.\n          \n          \n            \n                 * Sends the given {@code query} over the {@link QueryBus} and returns result containing initial response and\n          \n          \n            \n                 * incremental updates (received at the moment the query is sent, until it is cancelled by the caller or closed by\n          \n          \n            \n                 * the emitting side).\n          \n          \n            \n                 * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n          \n          \n            \n                 * Mono}</b></p>\n          \n          \n            \n                 * <p>\n          \n          \n            \n                 * <b>Note</b>: Any {@code null} results, on the initial result or the updates, will be filtered out by the\n          \n          \n            \n                 * {@link ReactiveQueryGateway}. If you require the {@code null} to be returned for the initial and update results, we suggest using\n          \n          \n            \n                 * the {@code QueryBus} instead.", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r396466030", "createdAt": "2020-03-23T13:52:34Z", "author": {"login": "smcvb"}, "path": "messaging/src/main/java/org/axonframework/queryhandling/ReactiveQueryGateway.java", "diffHunk": "@@ -0,0 +1,386 @@\n+/*\n+ * Copyright (c) 2010-2020. Axon Framework\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.axonframework.queryhandling;\n+\n+import org.axonframework.messaging.responsetypes.ResponseType;\n+import org.axonframework.messaging.responsetypes.ResponseTypes;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Mono;\n+import reactor.util.concurrent.Queues;\n+\n+import java.util.concurrent.TimeUnit;\n+\n+/**\n+ * Variation of {@link QueryGateway}. Provides support for reactive return types such as {@link Mono} and {@link Flux}\n+ * from Project Reactor.\n+ *\n+ * @author Milan Savic\n+ * @since 4.4\n+ */\n+public interface ReactiveQueryGateway {\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus}, expecting a response with the given {@code responseType}\n+     * from a single source. The query name will be derived from the provided {@code query}. Execution may be\n+     * asynchronous, depending on the QueryBus implementation.\n+     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param query        The {@code query} to be sent\n+     * @param responseType A {@link Class} describing the desired response type\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(Q query, Class<R> responseType) {\n+        return query(query.getClass().getName(), query, responseType);\n+    }\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus}, expecting a response with the given {@code responseType}\n+     * from a single source. Execution may be asynchronous, depending on the QueryBus implementation.\n+     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(String queryName, Q query, Class<R> responseType) {\n+        return query(queryName, query, ResponseTypes.instanceOf(responseType));\n+    }\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from a single source. The query name will be derived from the provided {@code query}. Execution may be\n+     * asynchronous, depending on the QueryBus implementation.\n+     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(Q query, ResponseType<R> responseType) {\n+        return query(query.getClass().getName(), query, responseType);\n+    }\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from a single source. Execution may be asynchronous, depending on the QueryBus implementation.\n+     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(String queryName, Q query, ResponseType<R> responseType) {\n+        return query(queryName, Mono.just(query), responseType);\n+    }\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from a single source. Execution may be asynchronous, depending on the QueryBus implementation.\n+     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        a {@link Mono} which is resolved once the caller subscribes to the query result\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    <R, Q> Mono<R> query(String queryName, Mono<Q> query, ResponseType<R> responseType);\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from several sources. The flux is completed when a {@code timeout} occurs or when all results are received. The\n+     * query name will be derived from the provided {@code query}. Execution may be asynchronous, depending on the\n+     * QueryBus implementation.\n+     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     * <b>Note</b>: Any {@code null} results will be filtered out by the QueryGateway. If you require the {@code null}\n+     * to be returned, we suggest using {@link QueryBus} instead.\n+     *\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param timeout      A timeout of {@code long} for the query\n+     * @param timeUnit     The selected {@link TimeUnit} for the given {@code timeout}\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A flux of results\n+     */\n+    default <R, Q> Flux<R> scatterGather(Q query, ResponseType<R> responseType, long timeout, TimeUnit timeUnit) {\n+        return scatterGather(query.getClass().getName(), query, responseType, timeout, timeUnit);\n+    }\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from several sources. The flux is completed when a {@code timeout} occurs or when all results are received.\n+     * Execution may be asynchronous, depending on the QueryBus implementation.\n+     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     * <b>Note</b>: Any {@code null} results will be filtered out by the QueryGateway. If you require the {@code null}\n+     * to be returned, we suggest using {@link QueryBus} instead.\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param timeout      A timeout of {@code long} for the query\n+     * @param timeUnit     The selected {@link TimeUnit} for the given {@code timeout}\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A flux of results.\n+     */\n+    default <R, Q> Flux<R> scatterGather(String queryName, Q query, ResponseType<R> responseType, long timeout,\n+                                         TimeUnit timeUnit) {\n+        return scatterGather(queryName, Mono.just(query), responseType, timeout, timeUnit);\n+    }\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from several sources. The flux is completed when a {@code timeout} occurs or when all results are received.\n+     * Execution may be asynchronous, depending on the QueryBus implementation.\n+     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     * <b>Note</b>: Any {@code null} results will be filtered out by the QueryGateway. If you require the {@code null}\n+     * to be returned, we suggest using {@link QueryBus} instead.\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        a {@link Mono} which is resolved once the caller subscribes to the query result\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param timeout      A timeout of {@code long} for the query\n+     * @param timeUnit     The selected {@link TimeUnit} for the given {@code timeout}\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A flux of results.\n+     */\n+    <R, Q> Flux<R> scatterGather(String queryName, Mono<Q> query, ResponseType<R> responseType, long timeout,\n+                                 TimeUnit timeUnit);\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus} and returns result containing initial response and\n+     * incremental updates (received at the moment the query is sent, until it is cancelled by the caller or closed by\n+     * the emitting side).\n+     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     * <p>\n+     * <b>Note</b>: Any {@code null} results, on the initial result or the updates, will be filtered out by the\n+     * QueryGateway. If you require the {@code null} to be returned for the initial and update results, we suggest using\n+     * the {@link QueryBus} instead.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c4511e81820de8d15c641e1c3038f4b688e29b51"}, "originalPosition": 194}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjQ2NzA5MA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * Sends given {@code query} over the {@link QueryBus} and returns result containing initial response and\n          \n          \n            \n                 * incremental updates (received at the moment the query is sent, until it is cancelled by the caller or closed by\n          \n          \n            \n                 * the emitting side).\n          \n          \n            \n                 * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n          \n          \n            \n                 * Mono}</b></p>\n          \n          \n            \n                 * <p>\n          \n          \n            \n                 * <b>Note</b>: Any {@code null} results, on the initial result or the updates, will be filtered out by the\n          \n          \n            \n                 * QueryGateway. If you require the {@code null} to be returned for the initial and update results, we suggest using\n          \n          \n            \n                 * the {@link QueryBus} instead.\n          \n          \n            \n                 * Sends the given {@code query} over the {@link QueryBus} and returns result containing initial response and\n          \n          \n            \n                 * incremental updates (received at the moment the query is sent, until it is cancelled by the caller or closed by\n          \n          \n            \n                 * the emitting side).\n          \n          \n            \n                 * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n          \n          \n            \n                 * Mono}</b></p>\n          \n          \n            \n                 * <p>\n          \n          \n            \n                 * <b>Note</b>: Any {@code null} results, on the initial result or the updates, will be filtered out by the\n          \n          \n            \n                 * {@link ReactiveQueryGateway}. If you require the {@code null} to be returned for the initial and update results, we suggest using\n          \n          \n            \n                 * the {@code QueryBus} instead.", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r396467090", "createdAt": "2020-03-23T13:54:02Z", "author": {"login": "smcvb"}, "path": "messaging/src/main/java/org/axonframework/queryhandling/ReactiveQueryGateway.java", "diffHunk": "@@ -0,0 +1,386 @@\n+/*\n+ * Copyright (c) 2010-2020. Axon Framework\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.axonframework.queryhandling;\n+\n+import org.axonframework.messaging.responsetypes.ResponseType;\n+import org.axonframework.messaging.responsetypes.ResponseTypes;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Mono;\n+import reactor.util.concurrent.Queues;\n+\n+import java.util.concurrent.TimeUnit;\n+\n+/**\n+ * Variation of {@link QueryGateway}. Provides support for reactive return types such as {@link Mono} and {@link Flux}\n+ * from Project Reactor.\n+ *\n+ * @author Milan Savic\n+ * @since 4.4\n+ */\n+public interface ReactiveQueryGateway {\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus}, expecting a response with the given {@code responseType}\n+     * from a single source. The query name will be derived from the provided {@code query}. Execution may be\n+     * asynchronous, depending on the QueryBus implementation.\n+     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param query        The {@code query} to be sent\n+     * @param responseType A {@link Class} describing the desired response type\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(Q query, Class<R> responseType) {\n+        return query(query.getClass().getName(), query, responseType);\n+    }\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus}, expecting a response with the given {@code responseType}\n+     * from a single source. Execution may be asynchronous, depending on the QueryBus implementation.\n+     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(String queryName, Q query, Class<R> responseType) {\n+        return query(queryName, query, ResponseTypes.instanceOf(responseType));\n+    }\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from a single source. The query name will be derived from the provided {@code query}. Execution may be\n+     * asynchronous, depending on the QueryBus implementation.\n+     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(Q query, ResponseType<R> responseType) {\n+        return query(query.getClass().getName(), query, responseType);\n+    }\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from a single source. Execution may be asynchronous, depending on the QueryBus implementation.\n+     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(String queryName, Q query, ResponseType<R> responseType) {\n+        return query(queryName, Mono.just(query), responseType);\n+    }\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from a single source. Execution may be asynchronous, depending on the QueryBus implementation.\n+     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        a {@link Mono} which is resolved once the caller subscribes to the query result\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    <R, Q> Mono<R> query(String queryName, Mono<Q> query, ResponseType<R> responseType);\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from several sources. The flux is completed when a {@code timeout} occurs or when all results are received. The\n+     * query name will be derived from the provided {@code query}. Execution may be asynchronous, depending on the\n+     * QueryBus implementation.\n+     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     * <b>Note</b>: Any {@code null} results will be filtered out by the QueryGateway. If you require the {@code null}\n+     * to be returned, we suggest using {@link QueryBus} instead.\n+     *\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param timeout      A timeout of {@code long} for the query\n+     * @param timeUnit     The selected {@link TimeUnit} for the given {@code timeout}\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A flux of results\n+     */\n+    default <R, Q> Flux<R> scatterGather(Q query, ResponseType<R> responseType, long timeout, TimeUnit timeUnit) {\n+        return scatterGather(query.getClass().getName(), query, responseType, timeout, timeUnit);\n+    }\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from several sources. The flux is completed when a {@code timeout} occurs or when all results are received.\n+     * Execution may be asynchronous, depending on the QueryBus implementation.\n+     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     * <b>Note</b>: Any {@code null} results will be filtered out by the QueryGateway. If you require the {@code null}\n+     * to be returned, we suggest using {@link QueryBus} instead.\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param timeout      A timeout of {@code long} for the query\n+     * @param timeUnit     The selected {@link TimeUnit} for the given {@code timeout}\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A flux of results.\n+     */\n+    default <R, Q> Flux<R> scatterGather(String queryName, Q query, ResponseType<R> responseType, long timeout,\n+                                         TimeUnit timeUnit) {\n+        return scatterGather(queryName, Mono.just(query), responseType, timeout, timeUnit);\n+    }\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from several sources. The flux is completed when a {@code timeout} occurs or when all results are received.\n+     * Execution may be asynchronous, depending on the QueryBus implementation.\n+     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     * <b>Note</b>: Any {@code null} results will be filtered out by the QueryGateway. If you require the {@code null}\n+     * to be returned, we suggest using {@link QueryBus} instead.\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        a {@link Mono} which is resolved once the caller subscribes to the query result\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param timeout      A timeout of {@code long} for the query\n+     * @param timeUnit     The selected {@link TimeUnit} for the given {@code timeout}\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A flux of results.\n+     */\n+    <R, Q> Flux<R> scatterGather(String queryName, Mono<Q> query, ResponseType<R> responseType, long timeout,\n+                                 TimeUnit timeUnit);\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus} and returns result containing initial response and\n+     * incremental updates (received at the moment the query is sent, until it is cancelled by the caller or closed by\n+     * the emitting side).\n+     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     * <p>\n+     * <b>Note</b>: Any {@code null} results, on the initial result or the updates, will be filtered out by the\n+     * QueryGateway. If you require the {@code null} to be returned for the initial and update results, we suggest using\n+     * the {@link QueryBus} instead.\n+     *\n+     * @param query               The {@code query} to be sent\n+     * @param initialResponseType The initial response type used for this query\n+     * @param updateResponseType  The update response type used for this query\n+     * @param <Q>                 The type of the query\n+     * @param <I>                 The type of the initial response\n+     * @param <U>                 The type of the incremental update\n+     * @return registration which can be used to cancel receiving updates\n+     *\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage)\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage, SubscriptionQueryBackpressure, int)\n+     */\n+    default <Q, I, U> Mono<SubscriptionQueryResult<I, U>> subscriptionQuery(Q query, Class<I> initialResponseType,\n+                                                                            Class<U> updateResponseType) {\n+        return subscriptionQuery(query.getClass().getName(),\n+                                 query,\n+                                 initialResponseType,\n+                                 updateResponseType);\n+    }\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus} and returns result containing initial response and\n+     * incremental updates (received at the moment the query is sent, until it is cancelled by the caller or closed by\n+     * the emitting side).\n+     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     * <p>\n+     * <b>Note</b>: Any {@code null} results, on the initial result or the updates, will be filtered out by the\n+     * QueryGateway. If you require the {@code null} to be returned for the initial and update results, we suggest using\n+     * the {@link QueryBus} instead.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c4511e81820de8d15c641e1c3038f4b688e29b51"}, "originalPosition": 224}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjQ2NzY4NQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * Sends given {@code query} over the {@link QueryBus} and returns result containing initial response and\n          \n          \n            \n                 * incremental updates (received at the moment the query is sent, until it is cancelled by the caller or closed by\n          \n          \n            \n                 * the emitting side).\n          \n          \n            \n                 * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n          \n          \n            \n                 * Mono}</b></p>\n          \n          \n            \n                 * <p>\n          \n          \n            \n                 * <b>Note</b>: Any {@code null} results, on the initial result or the updates, will be filtered out by the\n          \n          \n            \n                 * QueryGateway. If you require the {@code null} to be returned for the initial and update results, we suggest using\n          \n          \n            \n                 * the {@link QueryBus} instead.\n          \n          \n            \n                 * Sends the given {@code query} over the {@link QueryBus} and returns result containing initial response and\n          \n          \n            \n                 * incremental updates (received at the moment the query is sent, until it is cancelled by the caller or closed by\n          \n          \n            \n                 * the emitting side).\n          \n          \n            \n                 * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n          \n          \n            \n                 * Mono}</b></p>\n          \n          \n            \n                 * <p>\n          \n          \n            \n                 * <b>Note</b>: Any {@code null} results, on the initial result or the updates, will be filtered out by the\n          \n          \n            \n                 * {@link ReactiveQueryGateway}. If you require the {@code null} to be returned for the initial and update results, we suggest using\n          \n          \n            \n                 * the {@code QueryBus} instead.", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r396467685", "createdAt": "2020-03-23T13:54:50Z", "author": {"login": "smcvb"}, "path": "messaging/src/main/java/org/axonframework/queryhandling/ReactiveQueryGateway.java", "diffHunk": "@@ -0,0 +1,386 @@\n+/*\n+ * Copyright (c) 2010-2020. Axon Framework\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.axonframework.queryhandling;\n+\n+import org.axonframework.messaging.responsetypes.ResponseType;\n+import org.axonframework.messaging.responsetypes.ResponseTypes;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Mono;\n+import reactor.util.concurrent.Queues;\n+\n+import java.util.concurrent.TimeUnit;\n+\n+/**\n+ * Variation of {@link QueryGateway}. Provides support for reactive return types such as {@link Mono} and {@link Flux}\n+ * from Project Reactor.\n+ *\n+ * @author Milan Savic\n+ * @since 4.4\n+ */\n+public interface ReactiveQueryGateway {\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus}, expecting a response with the given {@code responseType}\n+     * from a single source. The query name will be derived from the provided {@code query}. Execution may be\n+     * asynchronous, depending on the QueryBus implementation.\n+     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param query        The {@code query} to be sent\n+     * @param responseType A {@link Class} describing the desired response type\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(Q query, Class<R> responseType) {\n+        return query(query.getClass().getName(), query, responseType);\n+    }\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus}, expecting a response with the given {@code responseType}\n+     * from a single source. Execution may be asynchronous, depending on the QueryBus implementation.\n+     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(String queryName, Q query, Class<R> responseType) {\n+        return query(queryName, query, ResponseTypes.instanceOf(responseType));\n+    }\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from a single source. The query name will be derived from the provided {@code query}. Execution may be\n+     * asynchronous, depending on the QueryBus implementation.\n+     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(Q query, ResponseType<R> responseType) {\n+        return query(query.getClass().getName(), query, responseType);\n+    }\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from a single source. Execution may be asynchronous, depending on the QueryBus implementation.\n+     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(String queryName, Q query, ResponseType<R> responseType) {\n+        return query(queryName, Mono.just(query), responseType);\n+    }\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from a single source. Execution may be asynchronous, depending on the QueryBus implementation.\n+     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        a {@link Mono} which is resolved once the caller subscribes to the query result\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    <R, Q> Mono<R> query(String queryName, Mono<Q> query, ResponseType<R> responseType);\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from several sources. The flux is completed when a {@code timeout} occurs or when all results are received. The\n+     * query name will be derived from the provided {@code query}. Execution may be asynchronous, depending on the\n+     * QueryBus implementation.\n+     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     * <b>Note</b>: Any {@code null} results will be filtered out by the QueryGateway. If you require the {@code null}\n+     * to be returned, we suggest using {@link QueryBus} instead.\n+     *\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param timeout      A timeout of {@code long} for the query\n+     * @param timeUnit     The selected {@link TimeUnit} for the given {@code timeout}\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A flux of results\n+     */\n+    default <R, Q> Flux<R> scatterGather(Q query, ResponseType<R> responseType, long timeout, TimeUnit timeUnit) {\n+        return scatterGather(query.getClass().getName(), query, responseType, timeout, timeUnit);\n+    }\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from several sources. The flux is completed when a {@code timeout} occurs or when all results are received.\n+     * Execution may be asynchronous, depending on the QueryBus implementation.\n+     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     * <b>Note</b>: Any {@code null} results will be filtered out by the QueryGateway. If you require the {@code null}\n+     * to be returned, we suggest using {@link QueryBus} instead.\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param timeout      A timeout of {@code long} for the query\n+     * @param timeUnit     The selected {@link TimeUnit} for the given {@code timeout}\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A flux of results.\n+     */\n+    default <R, Q> Flux<R> scatterGather(String queryName, Q query, ResponseType<R> responseType, long timeout,\n+                                         TimeUnit timeUnit) {\n+        return scatterGather(queryName, Mono.just(query), responseType, timeout, timeUnit);\n+    }\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from several sources. The flux is completed when a {@code timeout} occurs or when all results are received.\n+     * Execution may be asynchronous, depending on the QueryBus implementation.\n+     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     * <b>Note</b>: Any {@code null} results will be filtered out by the QueryGateway. If you require the {@code null}\n+     * to be returned, we suggest using {@link QueryBus} instead.\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        a {@link Mono} which is resolved once the caller subscribes to the query result\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param timeout      A timeout of {@code long} for the query\n+     * @param timeUnit     The selected {@link TimeUnit} for the given {@code timeout}\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A flux of results.\n+     */\n+    <R, Q> Flux<R> scatterGather(String queryName, Mono<Q> query, ResponseType<R> responseType, long timeout,\n+                                 TimeUnit timeUnit);\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus} and returns result containing initial response and\n+     * incremental updates (received at the moment the query is sent, until it is cancelled by the caller or closed by\n+     * the emitting side).\n+     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     * <p>\n+     * <b>Note</b>: Any {@code null} results, on the initial result or the updates, will be filtered out by the\n+     * QueryGateway. If you require the {@code null} to be returned for the initial and update results, we suggest using\n+     * the {@link QueryBus} instead.\n+     *\n+     * @param query               The {@code query} to be sent\n+     * @param initialResponseType The initial response type used for this query\n+     * @param updateResponseType  The update response type used for this query\n+     * @param <Q>                 The type of the query\n+     * @param <I>                 The type of the initial response\n+     * @param <U>                 The type of the incremental update\n+     * @return registration which can be used to cancel receiving updates\n+     *\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage)\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage, SubscriptionQueryBackpressure, int)\n+     */\n+    default <Q, I, U> Mono<SubscriptionQueryResult<I, U>> subscriptionQuery(Q query, Class<I> initialResponseType,\n+                                                                            Class<U> updateResponseType) {\n+        return subscriptionQuery(query.getClass().getName(),\n+                                 query,\n+                                 initialResponseType,\n+                                 updateResponseType);\n+    }\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus} and returns result containing initial response and\n+     * incremental updates (received at the moment the query is sent, until it is cancelled by the caller or closed by\n+     * the emitting side).\n+     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     * <p>\n+     * <b>Note</b>: Any {@code null} results, on the initial result or the updates, will be filtered out by the\n+     * QueryGateway. If you require the {@code null} to be returned for the initial and update results, we suggest using\n+     * the {@link QueryBus} instead.\n+     *\n+     * @param queryName           A {@link String} describing query to be executed\n+     * @param query               The {@code query} to be sent\n+     * @param initialResponseType The initial response type used for this query\n+     * @param updateResponseType  The update response type used for this query\n+     * @param <Q>                 The type of the query\n+     * @param <I>                 The type of the initial response\n+     * @param <U>                 The type of the incremental update\n+     * @return registration which can be used to cancel receiving updates\n+     *\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage)\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage, SubscriptionQueryBackpressure, int)\n+     */\n+    default <Q, I, U> Mono<SubscriptionQueryResult<I, U>> subscriptionQuery(String queryName, Q query,\n+                                                                            Class<I> initialResponseType,\n+                                                                            Class<U> updateResponseType) {\n+        return subscriptionQuery(queryName,\n+                                 query,\n+                                 ResponseTypes.instanceOf(initialResponseType),\n+                                 ResponseTypes.instanceOf(updateResponseType),\n+                                 SubscriptionQueryBackpressure.defaultBackpressure());\n+    }\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus} and returns result containing initial response and\n+     * incremental updates (received at the moment the query is sent, until it is cancelled by the caller or closed by\n+     * the emitting side).\n+     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     * <p>\n+     * <b>Note</b>: Any {@code null} results, on the initial result or the updates, will be filtered out by the\n+     * QueryGateway. If you require the {@code null} to be returned for the initial and update results, we suggest using\n+     * the {@link QueryBus} instead.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c4511e81820de8d15c641e1c3038f4b688e29b51"}, "originalPosition": 257}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjQ3MTE5NQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * Sends given {@code query} over the {@link QueryBus} and returns result containing initial response and\n          \n          \n            \n                 * incremental updates (received at the moment the query is sent, until it is cancelled by the caller or closed by\n          \n          \n            \n                 * the emitting side).\n          \n          \n            \n                 * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n          \n          \n            \n                 * Mono}</b></p>\n          \n          \n            \n                 * <p>\n          \n          \n            \n                 * <b>Note</b>: Any {@code null} results, on the initial result or the updates, will be filtered out by the\n          \n          \n            \n                 * QueryGateway. If you require the {@code null} to be returned for the initial and update results, we suggest using\n          \n          \n            \n                 * the {@link QueryBus} instead.\n          \n          \n            \n                 * Sends the given {@code query} over the {@link QueryBus} and returns result containing initial response and\n          \n          \n            \n                 * incremental updates (received at the moment the query is sent, until it is cancelled by the caller or closed by\n          \n          \n            \n                 * the emitting side).\n          \n          \n            \n                 * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n          \n          \n            \n                 * Mono}</b></p>\n          \n          \n            \n                 * <p>\n          \n          \n            \n                 * <b>Note</b>: Any {@code null} results, on the initial result or the updates, will be filtered out by the\n          \n          \n            \n                 * {@link ReactiveQueryGateway}. If you require the {@code null} to be returned for the initial and update results, we suggest using\n          \n          \n            \n                 * the {@code QueryBus} instead.", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r396471195", "createdAt": "2020-03-23T13:59:38Z", "author": {"login": "smcvb"}, "path": "messaging/src/main/java/org/axonframework/queryhandling/ReactiveQueryGateway.java", "diffHunk": "@@ -0,0 +1,386 @@\n+/*\n+ * Copyright (c) 2010-2020. Axon Framework\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.axonframework.queryhandling;\n+\n+import org.axonframework.messaging.responsetypes.ResponseType;\n+import org.axonframework.messaging.responsetypes.ResponseTypes;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Mono;\n+import reactor.util.concurrent.Queues;\n+\n+import java.util.concurrent.TimeUnit;\n+\n+/**\n+ * Variation of {@link QueryGateway}. Provides support for reactive return types such as {@link Mono} and {@link Flux}\n+ * from Project Reactor.\n+ *\n+ * @author Milan Savic\n+ * @since 4.4\n+ */\n+public interface ReactiveQueryGateway {\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus}, expecting a response with the given {@code responseType}\n+     * from a single source. The query name will be derived from the provided {@code query}. Execution may be\n+     * asynchronous, depending on the QueryBus implementation.\n+     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param query        The {@code query} to be sent\n+     * @param responseType A {@link Class} describing the desired response type\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(Q query, Class<R> responseType) {\n+        return query(query.getClass().getName(), query, responseType);\n+    }\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus}, expecting a response with the given {@code responseType}\n+     * from a single source. Execution may be asynchronous, depending on the QueryBus implementation.\n+     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(String queryName, Q query, Class<R> responseType) {\n+        return query(queryName, query, ResponseTypes.instanceOf(responseType));\n+    }\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from a single source. The query name will be derived from the provided {@code query}. Execution may be\n+     * asynchronous, depending on the QueryBus implementation.\n+     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(Q query, ResponseType<R> responseType) {\n+        return query(query.getClass().getName(), query, responseType);\n+    }\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from a single source. Execution may be asynchronous, depending on the QueryBus implementation.\n+     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(String queryName, Q query, ResponseType<R> responseType) {\n+        return query(queryName, Mono.just(query), responseType);\n+    }\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from a single source. Execution may be asynchronous, depending on the QueryBus implementation.\n+     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        a {@link Mono} which is resolved once the caller subscribes to the query result\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    <R, Q> Mono<R> query(String queryName, Mono<Q> query, ResponseType<R> responseType);\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from several sources. The flux is completed when a {@code timeout} occurs or when all results are received. The\n+     * query name will be derived from the provided {@code query}. Execution may be asynchronous, depending on the\n+     * QueryBus implementation.\n+     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     * <b>Note</b>: Any {@code null} results will be filtered out by the QueryGateway. If you require the {@code null}\n+     * to be returned, we suggest using {@link QueryBus} instead.\n+     *\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param timeout      A timeout of {@code long} for the query\n+     * @param timeUnit     The selected {@link TimeUnit} for the given {@code timeout}\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A flux of results\n+     */\n+    default <R, Q> Flux<R> scatterGather(Q query, ResponseType<R> responseType, long timeout, TimeUnit timeUnit) {\n+        return scatterGather(query.getClass().getName(), query, responseType, timeout, timeUnit);\n+    }\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from several sources. The flux is completed when a {@code timeout} occurs or when all results are received.\n+     * Execution may be asynchronous, depending on the QueryBus implementation.\n+     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     * <b>Note</b>: Any {@code null} results will be filtered out by the QueryGateway. If you require the {@code null}\n+     * to be returned, we suggest using {@link QueryBus} instead.\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param timeout      A timeout of {@code long} for the query\n+     * @param timeUnit     The selected {@link TimeUnit} for the given {@code timeout}\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A flux of results.\n+     */\n+    default <R, Q> Flux<R> scatterGather(String queryName, Q query, ResponseType<R> responseType, long timeout,\n+                                         TimeUnit timeUnit) {\n+        return scatterGather(queryName, Mono.just(query), responseType, timeout, timeUnit);\n+    }\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from several sources. The flux is completed when a {@code timeout} occurs or when all results are received.\n+     * Execution may be asynchronous, depending on the QueryBus implementation.\n+     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     * <b>Note</b>: Any {@code null} results will be filtered out by the QueryGateway. If you require the {@code null}\n+     * to be returned, we suggest using {@link QueryBus} instead.\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        a {@link Mono} which is resolved once the caller subscribes to the query result\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param timeout      A timeout of {@code long} for the query\n+     * @param timeUnit     The selected {@link TimeUnit} for the given {@code timeout}\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A flux of results.\n+     */\n+    <R, Q> Flux<R> scatterGather(String queryName, Mono<Q> query, ResponseType<R> responseType, long timeout,\n+                                 TimeUnit timeUnit);\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus} and returns result containing initial response and\n+     * incremental updates (received at the moment the query is sent, until it is cancelled by the caller or closed by\n+     * the emitting side).\n+     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     * <p>\n+     * <b>Note</b>: Any {@code null} results, on the initial result or the updates, will be filtered out by the\n+     * QueryGateway. If you require the {@code null} to be returned for the initial and update results, we suggest using\n+     * the {@link QueryBus} instead.\n+     *\n+     * @param query               The {@code query} to be sent\n+     * @param initialResponseType The initial response type used for this query\n+     * @param updateResponseType  The update response type used for this query\n+     * @param <Q>                 The type of the query\n+     * @param <I>                 The type of the initial response\n+     * @param <U>                 The type of the incremental update\n+     * @return registration which can be used to cancel receiving updates\n+     *\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage)\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage, SubscriptionQueryBackpressure, int)\n+     */\n+    default <Q, I, U> Mono<SubscriptionQueryResult<I, U>> subscriptionQuery(Q query, Class<I> initialResponseType,\n+                                                                            Class<U> updateResponseType) {\n+        return subscriptionQuery(query.getClass().getName(),\n+                                 query,\n+                                 initialResponseType,\n+                                 updateResponseType);\n+    }\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus} and returns result containing initial response and\n+     * incremental updates (received at the moment the query is sent, until it is cancelled by the caller or closed by\n+     * the emitting side).\n+     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     * <p>\n+     * <b>Note</b>: Any {@code null} results, on the initial result or the updates, will be filtered out by the\n+     * QueryGateway. If you require the {@code null} to be returned for the initial and update results, we suggest using\n+     * the {@link QueryBus} instead.\n+     *\n+     * @param queryName           A {@link String} describing query to be executed\n+     * @param query               The {@code query} to be sent\n+     * @param initialResponseType The initial response type used for this query\n+     * @param updateResponseType  The update response type used for this query\n+     * @param <Q>                 The type of the query\n+     * @param <I>                 The type of the initial response\n+     * @param <U>                 The type of the incremental update\n+     * @return registration which can be used to cancel receiving updates\n+     *\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage)\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage, SubscriptionQueryBackpressure, int)\n+     */\n+    default <Q, I, U> Mono<SubscriptionQueryResult<I, U>> subscriptionQuery(String queryName, Q query,\n+                                                                            Class<I> initialResponseType,\n+                                                                            Class<U> updateResponseType) {\n+        return subscriptionQuery(queryName,\n+                                 query,\n+                                 ResponseTypes.instanceOf(initialResponseType),\n+                                 ResponseTypes.instanceOf(updateResponseType),\n+                                 SubscriptionQueryBackpressure.defaultBackpressure());\n+    }\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus} and returns result containing initial response and\n+     * incremental updates (received at the moment the query is sent, until it is cancelled by the caller or closed by\n+     * the emitting side).\n+     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     * <p>\n+     * <b>Note</b>: Any {@code null} results, on the initial result or the updates, will be filtered out by the\n+     * QueryGateway. If you require the {@code null} to be returned for the initial and update results, we suggest using\n+     * the {@link QueryBus} instead.\n+     *\n+     * @param query               The {@code query} to be sent\n+     * @param initialResponseType The initial response type used for this query\n+     * @param updateResponseType  The update response type used for this query\n+     * @param <Q>                 The type of the query\n+     * @param <I>                 The type of the initial response\n+     * @param <U>                 The type of the incremental update\n+     * @return registration which can be used to cancel receiving updates\n+     *\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage)\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage, SubscriptionQueryBackpressure, int)\n+     */\n+    default <Q, I, U> Mono<SubscriptionQueryResult<I, U>> subscriptionQuery(Q query,\n+                                                                            ResponseType<I> initialResponseType,\n+                                                                            ResponseType<U> updateResponseType) {\n+        return subscriptionQuery(query.getClass().getName(),\n+                                 query,\n+                                 initialResponseType,\n+                                 updateResponseType,\n+                                 SubscriptionQueryBackpressure.defaultBackpressure());\n+    }\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus} and returns result containing initial response and\n+     * incremental updates (received at the moment the query is sent, until it is cancelled by the caller or closed by\n+     * the emitting side).\n+     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     * <p>\n+     * <b>Note</b>: Any {@code null} results, on the initial result or the updates, will be filtered out by the\n+     * QueryGateway. If you require the {@code null} to be returned for the initial and update results, we suggest using\n+     * the {@link QueryBus} instead.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c4511e81820de8d15c641e1c3038f4b688e29b51"}, "originalPosition": 289}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjQ3MTk5Nw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * Sends given {@code query} over the {@link QueryBus} and returns result containing initial response and\n          \n          \n            \n                 * incremental updates (received at the moment the query is sent, until it is cancelled by the caller or closed by\n          \n          \n            \n                 * the emitting side).\n          \n          \n            \n                 * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n          \n          \n            \n                 * Mono}</b></p>\n          \n          \n            \n                 * <p>\n          \n          \n            \n                 * <b>Note</b>: Any {@code null} results, on the initial result or the updates, will be filtered out by the\n          \n          \n            \n                 * QueryGateway. If you require the {@code null} to be returned for the initial and update results, we suggest using\n          \n          \n            \n                 * the {@link QueryBus} instead.\n          \n          \n            \n                 * Sends thegiven {@code query} over the {@link QueryBus} and returns result containing initial response and\n          \n          \n            \n                 * incremental updates (received at the moment the query is sent, until it is cancelled by the caller or closed by\n          \n          \n            \n                 * the emitting side).\n          \n          \n            \n                 * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n          \n          \n            \n                 * Mono}</b></p>\n          \n          \n            \n                 * <p>\n          \n          \n            \n                 * <b>Note</b>: Any {@code null} results, on the initial result or the updates, will be filtered out by the\n          \n          \n            \n                 * {@link ReactiveQueryGateway}. If you require the {@code null} to be returned for the initial and update results, we suggest using\n          \n          \n            \n                 * the {@code QueryBus} instead.", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r396471997", "createdAt": "2020-03-23T14:00:47Z", "author": {"login": "smcvb"}, "path": "messaging/src/main/java/org/axonframework/queryhandling/ReactiveQueryGateway.java", "diffHunk": "@@ -0,0 +1,386 @@\n+/*\n+ * Copyright (c) 2010-2020. Axon Framework\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.axonframework.queryhandling;\n+\n+import org.axonframework.messaging.responsetypes.ResponseType;\n+import org.axonframework.messaging.responsetypes.ResponseTypes;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Mono;\n+import reactor.util.concurrent.Queues;\n+\n+import java.util.concurrent.TimeUnit;\n+\n+/**\n+ * Variation of {@link QueryGateway}. Provides support for reactive return types such as {@link Mono} and {@link Flux}\n+ * from Project Reactor.\n+ *\n+ * @author Milan Savic\n+ * @since 4.4\n+ */\n+public interface ReactiveQueryGateway {\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus}, expecting a response with the given {@code responseType}\n+     * from a single source. The query name will be derived from the provided {@code query}. Execution may be\n+     * asynchronous, depending on the QueryBus implementation.\n+     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param query        The {@code query} to be sent\n+     * @param responseType A {@link Class} describing the desired response type\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(Q query, Class<R> responseType) {\n+        return query(query.getClass().getName(), query, responseType);\n+    }\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus}, expecting a response with the given {@code responseType}\n+     * from a single source. Execution may be asynchronous, depending on the QueryBus implementation.\n+     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(String queryName, Q query, Class<R> responseType) {\n+        return query(queryName, query, ResponseTypes.instanceOf(responseType));\n+    }\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from a single source. The query name will be derived from the provided {@code query}. Execution may be\n+     * asynchronous, depending on the QueryBus implementation.\n+     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(Q query, ResponseType<R> responseType) {\n+        return query(query.getClass().getName(), query, responseType);\n+    }\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from a single source. Execution may be asynchronous, depending on the QueryBus implementation.\n+     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(String queryName, Q query, ResponseType<R> responseType) {\n+        return query(queryName, Mono.just(query), responseType);\n+    }\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from a single source. Execution may be asynchronous, depending on the QueryBus implementation.\n+     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        a {@link Mono} which is resolved once the caller subscribes to the query result\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    <R, Q> Mono<R> query(String queryName, Mono<Q> query, ResponseType<R> responseType);\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from several sources. The flux is completed when a {@code timeout} occurs or when all results are received. The\n+     * query name will be derived from the provided {@code query}. Execution may be asynchronous, depending on the\n+     * QueryBus implementation.\n+     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     * <b>Note</b>: Any {@code null} results will be filtered out by the QueryGateway. If you require the {@code null}\n+     * to be returned, we suggest using {@link QueryBus} instead.\n+     *\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param timeout      A timeout of {@code long} for the query\n+     * @param timeUnit     The selected {@link TimeUnit} for the given {@code timeout}\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A flux of results\n+     */\n+    default <R, Q> Flux<R> scatterGather(Q query, ResponseType<R> responseType, long timeout, TimeUnit timeUnit) {\n+        return scatterGather(query.getClass().getName(), query, responseType, timeout, timeUnit);\n+    }\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from several sources. The flux is completed when a {@code timeout} occurs or when all results are received.\n+     * Execution may be asynchronous, depending on the QueryBus implementation.\n+     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     * <b>Note</b>: Any {@code null} results will be filtered out by the QueryGateway. If you require the {@code null}\n+     * to be returned, we suggest using {@link QueryBus} instead.\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param timeout      A timeout of {@code long} for the query\n+     * @param timeUnit     The selected {@link TimeUnit} for the given {@code timeout}\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A flux of results.\n+     */\n+    default <R, Q> Flux<R> scatterGather(String queryName, Q query, ResponseType<R> responseType, long timeout,\n+                                         TimeUnit timeUnit) {\n+        return scatterGather(queryName, Mono.just(query), responseType, timeout, timeUnit);\n+    }\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from several sources. The flux is completed when a {@code timeout} occurs or when all results are received.\n+     * Execution may be asynchronous, depending on the QueryBus implementation.\n+     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     * <b>Note</b>: Any {@code null} results will be filtered out by the QueryGateway. If you require the {@code null}\n+     * to be returned, we suggest using {@link QueryBus} instead.\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        a {@link Mono} which is resolved once the caller subscribes to the query result\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param timeout      A timeout of {@code long} for the query\n+     * @param timeUnit     The selected {@link TimeUnit} for the given {@code timeout}\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A flux of results.\n+     */\n+    <R, Q> Flux<R> scatterGather(String queryName, Mono<Q> query, ResponseType<R> responseType, long timeout,\n+                                 TimeUnit timeUnit);\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus} and returns result containing initial response and\n+     * incremental updates (received at the moment the query is sent, until it is cancelled by the caller or closed by\n+     * the emitting side).\n+     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     * <p>\n+     * <b>Note</b>: Any {@code null} results, on the initial result or the updates, will be filtered out by the\n+     * QueryGateway. If you require the {@code null} to be returned for the initial and update results, we suggest using\n+     * the {@link QueryBus} instead.\n+     *\n+     * @param query               The {@code query} to be sent\n+     * @param initialResponseType The initial response type used for this query\n+     * @param updateResponseType  The update response type used for this query\n+     * @param <Q>                 The type of the query\n+     * @param <I>                 The type of the initial response\n+     * @param <U>                 The type of the incremental update\n+     * @return registration which can be used to cancel receiving updates\n+     *\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage)\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage, SubscriptionQueryBackpressure, int)\n+     */\n+    default <Q, I, U> Mono<SubscriptionQueryResult<I, U>> subscriptionQuery(Q query, Class<I> initialResponseType,\n+                                                                            Class<U> updateResponseType) {\n+        return subscriptionQuery(query.getClass().getName(),\n+                                 query,\n+                                 initialResponseType,\n+                                 updateResponseType);\n+    }\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus} and returns result containing initial response and\n+     * incremental updates (received at the moment the query is sent, until it is cancelled by the caller or closed by\n+     * the emitting side).\n+     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     * <p>\n+     * <b>Note</b>: Any {@code null} results, on the initial result or the updates, will be filtered out by the\n+     * QueryGateway. If you require the {@code null} to be returned for the initial and update results, we suggest using\n+     * the {@link QueryBus} instead.\n+     *\n+     * @param queryName           A {@link String} describing query to be executed\n+     * @param query               The {@code query} to be sent\n+     * @param initialResponseType The initial response type used for this query\n+     * @param updateResponseType  The update response type used for this query\n+     * @param <Q>                 The type of the query\n+     * @param <I>                 The type of the initial response\n+     * @param <U>                 The type of the incremental update\n+     * @return registration which can be used to cancel receiving updates\n+     *\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage)\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage, SubscriptionQueryBackpressure, int)\n+     */\n+    default <Q, I, U> Mono<SubscriptionQueryResult<I, U>> subscriptionQuery(String queryName, Q query,\n+                                                                            Class<I> initialResponseType,\n+                                                                            Class<U> updateResponseType) {\n+        return subscriptionQuery(queryName,\n+                                 query,\n+                                 ResponseTypes.instanceOf(initialResponseType),\n+                                 ResponseTypes.instanceOf(updateResponseType),\n+                                 SubscriptionQueryBackpressure.defaultBackpressure());\n+    }\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus} and returns result containing initial response and\n+     * incremental updates (received at the moment the query is sent, until it is cancelled by the caller or closed by\n+     * the emitting side).\n+     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     * <p>\n+     * <b>Note</b>: Any {@code null} results, on the initial result or the updates, will be filtered out by the\n+     * QueryGateway. If you require the {@code null} to be returned for the initial and update results, we suggest using\n+     * the {@link QueryBus} instead.\n+     *\n+     * @param query               The {@code query} to be sent\n+     * @param initialResponseType The initial response type used for this query\n+     * @param updateResponseType  The update response type used for this query\n+     * @param <Q>                 The type of the query\n+     * @param <I>                 The type of the initial response\n+     * @param <U>                 The type of the incremental update\n+     * @return registration which can be used to cancel receiving updates\n+     *\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage)\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage, SubscriptionQueryBackpressure, int)\n+     */\n+    default <Q, I, U> Mono<SubscriptionQueryResult<I, U>> subscriptionQuery(Q query,\n+                                                                            ResponseType<I> initialResponseType,\n+                                                                            ResponseType<U> updateResponseType) {\n+        return subscriptionQuery(query.getClass().getName(),\n+                                 query,\n+                                 initialResponseType,\n+                                 updateResponseType,\n+                                 SubscriptionQueryBackpressure.defaultBackpressure());\n+    }\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus} and returns result containing initial response and\n+     * incremental updates (received at the moment the query is sent, until it is cancelled by the caller or closed by\n+     * the emitting side).\n+     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     * <p>\n+     * <b>Note</b>: Any {@code null} results, on the initial result or the updates, will be filtered out by the\n+     * QueryGateway. If you require the {@code null} to be returned for the initial and update results, we suggest using\n+     * the {@link QueryBus} instead.\n+     *\n+     * @param queryName           A {@link String} describing query to be executed\n+     * @param query               The {@code query} to be sent\n+     * @param initialResponseType The initial response type used for this query\n+     * @param updateResponseType  The update response type used for this query\n+     * @param backpressure        The backpressure mechanism to deal with producing of incremental updates\n+     * @param <Q>                 The type of the query\n+     * @param <I>                 The type of the initial response\n+     * @param <U>                 The type of the incremental update\n+     * @return registration which can be used to cancel receiving updates\n+     *\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage)\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage, SubscriptionQueryBackpressure, int)\n+     */\n+    default <Q, I, U> Mono<SubscriptionQueryResult<I, U>> subscriptionQuery(String queryName, Q query,\n+                                                                            ResponseType<I> initialResponseType,\n+                                                                            ResponseType<U> updateResponseType,\n+                                                                            SubscriptionQueryBackpressure backpressure) {\n+        return subscriptionQuery(queryName,\n+                                 query,\n+                                 initialResponseType,\n+                                 updateResponseType,\n+                                 backpressure,\n+                                 Queues.SMALL_BUFFER_SIZE);\n+    }\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus} and returns result containing initial response and\n+     * incremental updates (received at the moment the query is sent, until it is cancelled by the caller or closed by\n+     * the emitting side).\n+     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     * <p>\n+     * <b>Note</b>: Any {@code null} results, on the initial result or the updates, will be filtered out by the\n+     * QueryGateway. If you require the {@code null} to be returned for the initial and update results, we suggest using\n+     * the {@link QueryBus} instead.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c4511e81820de8d15c641e1c3038f4b688e29b51"}, "originalPosition": 325}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjQ3NjgyOQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * Sends given {@code query} over the {@link QueryBus} and returns result containing initial response and\n          \n          \n            \n                 * incremental updates (received at the moment the query is sent, until it is cancelled by the caller or closed by\n          \n          \n            \n                 * the emitting side).\n          \n          \n            \n                 * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n          \n          \n            \n                 * Mono}</b></p>\n          \n          \n            \n                 * <p>\n          \n          \n            \n                 * <b>Note</b>: Any {@code null} results, on the initial result or the updates, will be filtered out by the\n          \n          \n            \n                 * QueryGateway. If you require the {@code null} to be returned for the initial and update results, we suggest using\n          \n          \n            \n                 * the {@link QueryBus} instead.\n          \n          \n            \n                 * Sends the given {@code query} over the {@link QueryBus} and returns result containing initial response and\n          \n          \n            \n                 * incremental updates (received at the moment the query is sent, until it is cancelled by the caller or closed by\n          \n          \n            \n                 * the emitting side).\n          \n          \n            \n                 * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n          \n          \n            \n                 * Mono}</b></p>\n          \n          \n            \n                 * <p>\n          \n          \n            \n                 * <b>Note</b>: Any {@code null} results, on the initial result or the updates, will be filtered out by the\n          \n          \n            \n                 * {@link ReactiveQueryGateway}. If you require the {@code null} to be returned for the initial and update results, we suggest using\n          \n          \n            \n                 * the {@code QueryBus} instead.", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r396476829", "createdAt": "2020-03-23T14:07:56Z", "author": {"login": "smcvb"}, "path": "messaging/src/main/java/org/axonframework/queryhandling/ReactiveQueryGateway.java", "diffHunk": "@@ -0,0 +1,386 @@\n+/*\n+ * Copyright (c) 2010-2020. Axon Framework\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.axonframework.queryhandling;\n+\n+import org.axonframework.messaging.responsetypes.ResponseType;\n+import org.axonframework.messaging.responsetypes.ResponseTypes;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Mono;\n+import reactor.util.concurrent.Queues;\n+\n+import java.util.concurrent.TimeUnit;\n+\n+/**\n+ * Variation of {@link QueryGateway}. Provides support for reactive return types such as {@link Mono} and {@link Flux}\n+ * from Project Reactor.\n+ *\n+ * @author Milan Savic\n+ * @since 4.4\n+ */\n+public interface ReactiveQueryGateway {\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus}, expecting a response with the given {@code responseType}\n+     * from a single source. The query name will be derived from the provided {@code query}. Execution may be\n+     * asynchronous, depending on the QueryBus implementation.\n+     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param query        The {@code query} to be sent\n+     * @param responseType A {@link Class} describing the desired response type\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(Q query, Class<R> responseType) {\n+        return query(query.getClass().getName(), query, responseType);\n+    }\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus}, expecting a response with the given {@code responseType}\n+     * from a single source. Execution may be asynchronous, depending on the QueryBus implementation.\n+     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(String queryName, Q query, Class<R> responseType) {\n+        return query(queryName, query, ResponseTypes.instanceOf(responseType));\n+    }\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from a single source. The query name will be derived from the provided {@code query}. Execution may be\n+     * asynchronous, depending on the QueryBus implementation.\n+     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(Q query, ResponseType<R> responseType) {\n+        return query(query.getClass().getName(), query, responseType);\n+    }\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from a single source. Execution may be asynchronous, depending on the QueryBus implementation.\n+     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(String queryName, Q query, ResponseType<R> responseType) {\n+        return query(queryName, Mono.just(query), responseType);\n+    }\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from a single source. Execution may be asynchronous, depending on the QueryBus implementation.\n+     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        a {@link Mono} which is resolved once the caller subscribes to the query result\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    <R, Q> Mono<R> query(String queryName, Mono<Q> query, ResponseType<R> responseType);\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from several sources. The flux is completed when a {@code timeout} occurs or when all results are received. The\n+     * query name will be derived from the provided {@code query}. Execution may be asynchronous, depending on the\n+     * QueryBus implementation.\n+     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     * <b>Note</b>: Any {@code null} results will be filtered out by the QueryGateway. If you require the {@code null}\n+     * to be returned, we suggest using {@link QueryBus} instead.\n+     *\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param timeout      A timeout of {@code long} for the query\n+     * @param timeUnit     The selected {@link TimeUnit} for the given {@code timeout}\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A flux of results\n+     */\n+    default <R, Q> Flux<R> scatterGather(Q query, ResponseType<R> responseType, long timeout, TimeUnit timeUnit) {\n+        return scatterGather(query.getClass().getName(), query, responseType, timeout, timeUnit);\n+    }\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from several sources. The flux is completed when a {@code timeout} occurs or when all results are received.\n+     * Execution may be asynchronous, depending on the QueryBus implementation.\n+     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     * <b>Note</b>: Any {@code null} results will be filtered out by the QueryGateway. If you require the {@code null}\n+     * to be returned, we suggest using {@link QueryBus} instead.\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param timeout      A timeout of {@code long} for the query\n+     * @param timeUnit     The selected {@link TimeUnit} for the given {@code timeout}\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A flux of results.\n+     */\n+    default <R, Q> Flux<R> scatterGather(String queryName, Q query, ResponseType<R> responseType, long timeout,\n+                                         TimeUnit timeUnit) {\n+        return scatterGather(queryName, Mono.just(query), responseType, timeout, timeUnit);\n+    }\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from several sources. The flux is completed when a {@code timeout} occurs or when all results are received.\n+     * Execution may be asynchronous, depending on the QueryBus implementation.\n+     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     * <b>Note</b>: Any {@code null} results will be filtered out by the QueryGateway. If you require the {@code null}\n+     * to be returned, we suggest using {@link QueryBus} instead.\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        a {@link Mono} which is resolved once the caller subscribes to the query result\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param timeout      A timeout of {@code long} for the query\n+     * @param timeUnit     The selected {@link TimeUnit} for the given {@code timeout}\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A flux of results.\n+     */\n+    <R, Q> Flux<R> scatterGather(String queryName, Mono<Q> query, ResponseType<R> responseType, long timeout,\n+                                 TimeUnit timeUnit);\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus} and returns result containing initial response and\n+     * incremental updates (received at the moment the query is sent, until it is cancelled by the caller or closed by\n+     * the emitting side).\n+     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     * <p>\n+     * <b>Note</b>: Any {@code null} results, on the initial result or the updates, will be filtered out by the\n+     * QueryGateway. If you require the {@code null} to be returned for the initial and update results, we suggest using\n+     * the {@link QueryBus} instead.\n+     *\n+     * @param query               The {@code query} to be sent\n+     * @param initialResponseType The initial response type used for this query\n+     * @param updateResponseType  The update response type used for this query\n+     * @param <Q>                 The type of the query\n+     * @param <I>                 The type of the initial response\n+     * @param <U>                 The type of the incremental update\n+     * @return registration which can be used to cancel receiving updates\n+     *\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage)\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage, SubscriptionQueryBackpressure, int)\n+     */\n+    default <Q, I, U> Mono<SubscriptionQueryResult<I, U>> subscriptionQuery(Q query, Class<I> initialResponseType,\n+                                                                            Class<U> updateResponseType) {\n+        return subscriptionQuery(query.getClass().getName(),\n+                                 query,\n+                                 initialResponseType,\n+                                 updateResponseType);\n+    }\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus} and returns result containing initial response and\n+     * incremental updates (received at the moment the query is sent, until it is cancelled by the caller or closed by\n+     * the emitting side).\n+     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     * <p>\n+     * <b>Note</b>: Any {@code null} results, on the initial result or the updates, will be filtered out by the\n+     * QueryGateway. If you require the {@code null} to be returned for the initial and update results, we suggest using\n+     * the {@link QueryBus} instead.\n+     *\n+     * @param queryName           A {@link String} describing query to be executed\n+     * @param query               The {@code query} to be sent\n+     * @param initialResponseType The initial response type used for this query\n+     * @param updateResponseType  The update response type used for this query\n+     * @param <Q>                 The type of the query\n+     * @param <I>                 The type of the initial response\n+     * @param <U>                 The type of the incremental update\n+     * @return registration which can be used to cancel receiving updates\n+     *\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage)\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage, SubscriptionQueryBackpressure, int)\n+     */\n+    default <Q, I, U> Mono<SubscriptionQueryResult<I, U>> subscriptionQuery(String queryName, Q query,\n+                                                                            Class<I> initialResponseType,\n+                                                                            Class<U> updateResponseType) {\n+        return subscriptionQuery(queryName,\n+                                 query,\n+                                 ResponseTypes.instanceOf(initialResponseType),\n+                                 ResponseTypes.instanceOf(updateResponseType),\n+                                 SubscriptionQueryBackpressure.defaultBackpressure());\n+    }\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus} and returns result containing initial response and\n+     * incremental updates (received at the moment the query is sent, until it is cancelled by the caller or closed by\n+     * the emitting side).\n+     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     * <p>\n+     * <b>Note</b>: Any {@code null} results, on the initial result or the updates, will be filtered out by the\n+     * QueryGateway. If you require the {@code null} to be returned for the initial and update results, we suggest using\n+     * the {@link QueryBus} instead.\n+     *\n+     * @param query               The {@code query} to be sent\n+     * @param initialResponseType The initial response type used for this query\n+     * @param updateResponseType  The update response type used for this query\n+     * @param <Q>                 The type of the query\n+     * @param <I>                 The type of the initial response\n+     * @param <U>                 The type of the incremental update\n+     * @return registration which can be used to cancel receiving updates\n+     *\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage)\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage, SubscriptionQueryBackpressure, int)\n+     */\n+    default <Q, I, U> Mono<SubscriptionQueryResult<I, U>> subscriptionQuery(Q query,\n+                                                                            ResponseType<I> initialResponseType,\n+                                                                            ResponseType<U> updateResponseType) {\n+        return subscriptionQuery(query.getClass().getName(),\n+                                 query,\n+                                 initialResponseType,\n+                                 updateResponseType,\n+                                 SubscriptionQueryBackpressure.defaultBackpressure());\n+    }\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus} and returns result containing initial response and\n+     * incremental updates (received at the moment the query is sent, until it is cancelled by the caller or closed by\n+     * the emitting side).\n+     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     * <p>\n+     * <b>Note</b>: Any {@code null} results, on the initial result or the updates, will be filtered out by the\n+     * QueryGateway. If you require the {@code null} to be returned for the initial and update results, we suggest using\n+     * the {@link QueryBus} instead.\n+     *\n+     * @param queryName           A {@link String} describing query to be executed\n+     * @param query               The {@code query} to be sent\n+     * @param initialResponseType The initial response type used for this query\n+     * @param updateResponseType  The update response type used for this query\n+     * @param backpressure        The backpressure mechanism to deal with producing of incremental updates\n+     * @param <Q>                 The type of the query\n+     * @param <I>                 The type of the initial response\n+     * @param <U>                 The type of the incremental update\n+     * @return registration which can be used to cancel receiving updates\n+     *\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage)\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage, SubscriptionQueryBackpressure, int)\n+     */\n+    default <Q, I, U> Mono<SubscriptionQueryResult<I, U>> subscriptionQuery(String queryName, Q query,\n+                                                                            ResponseType<I> initialResponseType,\n+                                                                            ResponseType<U> updateResponseType,\n+                                                                            SubscriptionQueryBackpressure backpressure) {\n+        return subscriptionQuery(queryName,\n+                                 query,\n+                                 initialResponseType,\n+                                 updateResponseType,\n+                                 backpressure,\n+                                 Queues.SMALL_BUFFER_SIZE);\n+    }\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus} and returns result containing initial response and\n+     * incremental updates (received at the moment the query is sent, until it is cancelled by the caller or closed by\n+     * the emitting side).\n+     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     * <p>\n+     * <b>Note</b>: Any {@code null} results, on the initial result or the updates, will be filtered out by the\n+     * QueryGateway. If you require the {@code null} to be returned for the initial and update results, we suggest using\n+     * the {@link QueryBus} instead.\n+     *\n+     * @param queryName           A {@link String} describing query to be executed\n+     * @param query               The {@code query} to be sent\n+     * @param initialResponseType The initial response type used for this query\n+     * @param updateResponseType  The update response type used for this query\n+     * @param backpressure        The backpressure mechanism to deal with producing of incremental updates\n+     * @param updateBufferSize    The size of buffer which accumulates updates before subscription to the {@code} flux\n+     *                            is made\n+     * @param <Q>                 The type of the query\n+     * @param <I>                 The type of the initial response\n+     * @param <U>                 The type of the incremental update\n+     * @return registration which can be used to cancel receiving updates\n+     *\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage)\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage, SubscriptionQueryBackpressure, int)\n+     */\n+    default <Q, I, U> Mono<SubscriptionQueryResult<I, U>> subscriptionQuery(String queryName, Q query,\n+                                                                            ResponseType<I> initialResponseType,\n+                                                                            ResponseType<U> updateResponseType,\n+                                                                            SubscriptionQueryBackpressure backpressure,\n+                                                                            int updateBufferSize) {\n+        return subscriptionQuery(queryName,\n+                                 Mono.just(query),\n+                                 initialResponseType,\n+                                 updateResponseType,\n+                                 backpressure,\n+                                 updateBufferSize);\n+    }\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus} and returns result containing initial response and\n+     * incremental updates (received at the moment the query is sent, until it is cancelled by the caller or closed by\n+     * the emitting side).\n+     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     * <p>\n+     * <b>Note</b>: Any {@code null} results, on the initial result or the updates, will be filtered out by the\n+     * QueryGateway. If you require the {@code null} to be returned for the initial and update results, we suggest using\n+     * the {@link QueryBus} instead.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c4511e81820de8d15c641e1c3038f4b688e29b51"}, "originalPosition": 364}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjQ3NzQyNA==", "bodyText": "I am missing tests which verify these beans are created.", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r396477424", "createdAt": "2020-03-23T14:08:47Z", "author": {"login": "smcvb"}, "path": "spring-boot-autoconfigure/src/main/java/org/axonframework/springboot/autoconfig/AxonAutoConfiguration.java", "diffHunk": "@@ -202,6 +205,24 @@ public QueryGateway queryGateway(QueryBus queryBus) {\n         return DefaultQueryGateway.builder().queryBus(queryBus).build();\n     }\n \n+    @Bean", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c4511e81820de8d15c641e1c3038f4b688e29b51"}, "originalPosition": 21}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjQ3OTQwNw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             * Default implementation of {@link ReactiveCommandGateway}.\n          \n          \n            \n             * Default implementation of the {@link ReactiveCommandGateway}.", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r396479407", "createdAt": "2020-03-23T14:11:36Z", "author": {"login": "smcvb"}, "path": "messaging/src/main/java/org/axonframework/commandhandling/gateway/DefaultReactiveCommandGateway.java", "diffHunk": "@@ -0,0 +1,207 @@\n+/*\n+ * Copyright (c) 2010-2020. Axon Framework\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.axonframework.commandhandling.gateway;\n+\n+import org.axonframework.commandhandling.CommandBus;\n+import org.axonframework.commandhandling.CommandCallback;\n+import org.axonframework.commandhandling.CommandMessage;\n+import org.axonframework.commandhandling.GenericCommandMessage;\n+import org.axonframework.common.AxonConfigurationException;\n+import org.axonframework.common.Registration;\n+import org.axonframework.messaging.ReactiveMessageDispatchInterceptor;\n+import reactor.core.publisher.Mono;\n+\n+import java.util.List;\n+import java.util.concurrent.CopyOnWriteArrayList;\n+\n+import static java.util.Arrays.asList;\n+import static org.axonframework.common.BuilderUtils.assertNonNull;\n+\n+/**\n+ * Default implementation of {@link ReactiveCommandGateway}.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c4511e81820de8d15c641e1c3038f4b688e29b51"}, "originalPosition": 35}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjQ4NDA2NA==", "bodyText": "Would it make sense to introduce a ReactiveMessageDispatchInterceptorSupport implementation which this interface extends? I feel it does, but might be suited for a follow up issue.", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r396484064", "createdAt": "2020-03-23T14:18:00Z", "author": {"login": "smcvb"}, "path": "messaging/src/main/java/org/axonframework/commandhandling/gateway/ReactiveCommandGateway.java", "diffHunk": "@@ -0,0 +1,55 @@\n+/*\n+ * Copyright (c) 2010-2020. Axon Framework\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.axonframework.commandhandling.gateway;\n+\n+import org.axonframework.messaging.Message;\n+import reactor.core.publisher.Mono;\n+\n+/**\n+ * Variation of {@link CommandGateway}. Provides support for reactive return type such as {@link Mono} from Project\n+ * Reactor.\n+ *\n+ * @author Milan Savic\n+ * @since 4.4\n+ */\n+public interface ReactiveCommandGateway {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c4511e81820de8d15c641e1c3038f4b688e29b51"}, "originalPosition": 29}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjQ4NDcwMw==", "bodyText": "Would there be a way to reuse the existing MessageDispatchInterceptor implementations as a ReactiveMessageDispatchInterceptor?", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r396484703", "createdAt": "2020-03-23T14:18:50Z", "author": {"login": "smcvb"}, "path": "messaging/src/main/java/org/axonframework/messaging/ReactiveMessageDispatchInterceptor.java", "diffHunk": "@@ -0,0 +1,44 @@\n+/*\n+ * Copyright (c) 2010-2020. Axon Framework\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.axonframework.messaging;\n+\n+import reactor.core.publisher.Mono;\n+\n+import java.util.function.Function;\n+import java.util.function.Supplier;\n+\n+/**\n+ * Interceptor that allows messages to be intercepted and modified before they are dispatched. Implementations are\n+ * required to provide a function that modifies a {@link Mono} of a message and returns a modified/new {@link Mono} to\n+ * be passed down the interceptor chain or to be sent. This way we provide a reactive way to intercept messages.\n+ *\n+ * @param <T> the message type this interceptor can process\n+ * @author Milan Savic\n+ * @since 4.4\n+ */\n+public interface ReactiveMessageDispatchInterceptor<T extends Message<?>> extends Supplier<Function<Mono<T>, Mono<T>>> {\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c4511e81820de8d15c641e1c3038f4b688e29b51"}, "originalPosition": 34}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjQ4NTYzMw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             * Default implementation of {@link ReactiveQueryGateway}.\n          \n          \n            \n             * Default implementation of the {@link ReactiveQueryGateway}.", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r396485633", "createdAt": "2020-03-23T14:20:08Z", "author": {"login": "smcvb"}, "path": "messaging/src/main/java/org/axonframework/queryhandling/DefaultReactiveQueryGateway.java", "diffHunk": "@@ -0,0 +1,244 @@\n+/*\n+ * Copyright (c) 2010-2020. Axon Framework\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.axonframework.queryhandling;\n+\n+import org.axonframework.common.AxonConfigurationException;\n+import org.axonframework.common.Registration;\n+import org.axonframework.messaging.IllegalPayloadAccessException;\n+import org.axonframework.messaging.Message;\n+import org.axonframework.messaging.ReactiveMessageDispatchInterceptor;\n+import org.axonframework.messaging.responsetypes.ResponseType;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Mono;\n+\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.concurrent.CopyOnWriteArrayList;\n+import java.util.concurrent.TimeUnit;\n+\n+import static java.util.Arrays.asList;\n+import static org.axonframework.common.BuilderUtils.assertNonNull;\n+\n+/**\n+ * Default implementation of {@link ReactiveQueryGateway}.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c4511e81820de8d15c641e1c3038f4b688e29b51"}, "originalPosition": 37}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjQ4NzgzMw==", "bodyText": "Thought: I've personally been moving away from method-level warning suppression towards line/statement suppression. Reasoning behind this is that developers can now accidentally add unintended stuff they do not want to suppress. What do you think?", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r396487833", "createdAt": "2020-03-23T14:22:55Z", "author": {"login": "smcvb"}, "path": "messaging/src/main/java/org/axonframework/queryhandling/DefaultReactiveQueryGateway.java", "diffHunk": "@@ -0,0 +1,244 @@\n+/*\n+ * Copyright (c) 2010-2020. Axon Framework\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.axonframework.queryhandling;\n+\n+import org.axonframework.common.AxonConfigurationException;\n+import org.axonframework.common.Registration;\n+import org.axonframework.messaging.IllegalPayloadAccessException;\n+import org.axonframework.messaging.Message;\n+import org.axonframework.messaging.ReactiveMessageDispatchInterceptor;\n+import org.axonframework.messaging.responsetypes.ResponseType;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Mono;\n+\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.concurrent.CopyOnWriteArrayList;\n+import java.util.concurrent.TimeUnit;\n+\n+import static java.util.Arrays.asList;\n+import static org.axonframework.common.BuilderUtils.assertNonNull;\n+\n+/**\n+ * Default implementation of {@link ReactiveQueryGateway}.\n+ *\n+ * @author Milan Savic\n+ * @since 4.4\n+ */\n+public class DefaultReactiveQueryGateway implements ReactiveQueryGateway {\n+\n+    private final List<ReactiveMessageDispatchInterceptor<QueryMessage<?, ?>>> dispatchInterceptors;\n+\n+    private final QueryBus queryBus;\n+\n+    /**\n+     * Creates an instance of {@link DefaultReactiveQueryGateway} based on the fields contained in the {@link\n+     * Builder}.\n+     * <p>\n+     * Will assert that the {@link QueryBus} is not {@code null} and throws an {@link AxonConfigurationException} if\n+     * it is.\n+     * </p>\n+     *\n+     * @param builder the {@link Builder} used to instantiated a {@link DefaultReactiveQueryGateway} instance\n+     */\n+    protected DefaultReactiveQueryGateway(Builder builder) {\n+        builder.validate();\n+        this.queryBus = builder.queryBus;\n+        this.dispatchInterceptors = builder.dispatchInterceptors;\n+    }\n+\n+    /**\n+     * Instantiate a Builder to be able to create a {@link DefaultReactiveQueryGateway}.\n+     * <p>\n+     * The {@code dispatchInterceptors} are defaulted to an empty list.\n+     * The {@link QueryBus} is a <b>hard requirements</b> and as such should be provided.\n+     * </p>\n+     *\n+     * @return a Builder to be able to create a {@link DefaultReactiveQueryGateway}\n+     */\n+    public static Builder builder() {\n+        return new Builder();\n+    }\n+\n+    /**\n+     * Registers a {@link ReactiveMessageDispatchInterceptor} within this reactive gateway.\n+     *\n+     * @param interceptor intercepts a query message\n+     * @return a registration which can be used to unregister this {@code interceptor}\n+     */\n+    public Registration registerQueryDispatchInterceptor(\n+            ReactiveMessageDispatchInterceptor<QueryMessage<?, ?>> interceptor) {\n+        dispatchInterceptors.add(interceptor);\n+        return () -> dispatchInterceptors.remove(interceptor);\n+    }\n+\n+    private Mono<QueryMessage<?, ?>> processInterceptors(Mono<QueryMessage<?, ?>> queryMessage) {\n+        Mono<QueryMessage<?, ?>> message = queryMessage;\n+        for (ReactiveMessageDispatchInterceptor<QueryMessage<?, ?>> dispatchInterceptor : dispatchInterceptors) {\n+            try {\n+                message = dispatchInterceptor.intercept(message);\n+            } catch (Throwable t) {\n+                return Mono.error(t);\n+            }\n+        }\n+        return message;\n+    }\n+\n+    @Override\n+    @SuppressWarnings(\"unchecked\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c4511e81820de8d15c641e1c3038f4b688e29b51"}, "originalPosition": 102}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjQ5Mzc4Ng==", "bodyText": "With the move to JUnit 5, all test classes have been made package-private.", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r396493786", "createdAt": "2020-03-23T14:31:04Z", "author": {"login": "smcvb"}, "path": "messaging/src/test/java/org/axonframework/commandhandling/gateway/DefaultReactiveCommandGatewayTest.java", "diffHunk": "@@ -0,0 +1,121 @@\n+/*\n+ * Copyright (c) 2010-2020. Axon Framework\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.axonframework.commandhandling.gateway;\n+\n+import org.axonframework.commandhandling.CommandBus;\n+import org.axonframework.commandhandling.CommandMessage;\n+import org.axonframework.commandhandling.SimpleCommandBus;\n+import org.axonframework.common.Registration;\n+import org.axonframework.messaging.MessageHandler;\n+import org.junit.jupiter.api.*;\n+import reactor.core.publisher.Mono;\n+import reactor.test.StepVerifier;\n+\n+import java.util.Collections;\n+\n+import static org.mockito.Mockito.*;\n+\n+/**\n+ * Tests for {@link ReactiveCommandGateway}.\n+ *\n+ * @author Milan Savic\n+ */\n+public class DefaultReactiveCommandGatewayTest {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c4511e81820de8d15c641e1c3038f4b688e29b51"}, "originalPosition": 37}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e8a4f1bd0acc921094c78fddc86bef78628ac343", "author": {"user": {"login": "m1l4n54v1c", "name": "Milan Savic"}}, "url": "https://github.com/AxonFramework/AxonFramework/commit/e8a4f1bd0acc921094c78fddc86bef78628ac343", "committedDate": "2020-03-27T15:15:58Z", "message": "Update messaging/src/main/java/org/axonframework/commandhandling/gateway/ReactiveCommandGateway.java\n\nCo-Authored-By: Steven van Beelen <steven.vanbeelen@axoniq.io>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "76806ce0f2f7a717f1431a7e913b39d1f251c125", "author": {"user": {"login": "m1l4n54v1c", "name": "Milan Savic"}}, "url": "https://github.com/AxonFramework/AxonFramework/commit/76806ce0f2f7a717f1431a7e913b39d1f251c125", "committedDate": "2020-03-27T15:19:44Z", "message": "Update messaging/src/main/java/org/axonframework/messaging/ReactiveMessageDispatchInterceptor.java\n\nCo-Authored-By: Steven van Beelen <steven.vanbeelen@axoniq.io>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "61533b20534a7d79b90733b40f251b0f66b9285a", "author": {"user": {"login": "m1l4n54v1c", "name": "Milan Savic"}}, "url": "https://github.com/AxonFramework/AxonFramework/commit/61533b20534a7d79b90733b40f251b0f66b9285a", "committedDate": "2020-03-27T15:19:58Z", "message": "Update messaging/src/main/java/org/axonframework/queryhandling/ReactiveQueryGateway.java\n\nCo-Authored-By: Steven van Beelen <steven.vanbeelen@axoniq.io>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3d8f37c6eeb845170d89fd326bd0e685ea740683", "author": {"user": {"login": "m1l4n54v1c", "name": "Milan Savic"}}, "url": "https://github.com/AxonFramework/AxonFramework/commit/3d8f37c6eeb845170d89fd326bd0e685ea740683", "committedDate": "2020-03-27T15:20:11Z", "message": "Update messaging/src/main/java/org/axonframework/queryhandling/ReactiveQueryGateway.java\n\nCo-Authored-By: Steven van Beelen <steven.vanbeelen@axoniq.io>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "30abd74032e15fa788c91d08a76e22d4b317423e", "author": {"user": {"login": "m1l4n54v1c", "name": "Milan Savic"}}, "url": "https://github.com/AxonFramework/AxonFramework/commit/30abd74032e15fa788c91d08a76e22d4b317423e", "committedDate": "2020-03-27T15:20:40Z", "message": "Update messaging/src/main/java/org/axonframework/queryhandling/ReactiveQueryGateway.java\n\nCo-Authored-By: Steven van Beelen <steven.vanbeelen@axoniq.io>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c7753be1e5af6b8484f2051a0e346cbb5cc24e26", "author": {"user": {"login": "m1l4n54v1c", "name": "Milan Savic"}}, "url": "https://github.com/AxonFramework/AxonFramework/commit/c7753be1e5af6b8484f2051a0e346cbb5cc24e26", "committedDate": "2020-03-27T15:21:12Z", "message": "Update messaging/src/main/java/org/axonframework/queryhandling/ReactiveQueryGateway.java\n\nCo-Authored-By: Steven van Beelen <steven.vanbeelen@axoniq.io>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "65c54ea2ec8d6f80ffca28231a49c0b50d5137c3", "author": {"user": {"login": "m1l4n54v1c", "name": "Milan Savic"}}, "url": "https://github.com/AxonFramework/AxonFramework/commit/65c54ea2ec8d6f80ffca28231a49c0b50d5137c3", "committedDate": "2020-03-27T15:37:59Z", "message": "Update messaging/src/main/java/org/axonframework/queryhandling/DefaultReactiveQueryGateway.java\n\nCo-Authored-By: Steven van Beelen <steven.vanbeelen@axoniq.io>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "431f9c80cfa5e5f36dec0bcedfbaa90f85cb947c", "author": {"user": {"login": "m1l4n54v1c", "name": "Milan Savic"}}, "url": "https://github.com/AxonFramework/AxonFramework/commit/431f9c80cfa5e5f36dec0bcedfbaa90f85cb947c", "committedDate": "2020-03-27T15:59:04Z", "message": "Update messaging/src/main/java/org/axonframework/queryhandling/ReactiveQueryGateway.java\n\nCo-Authored-By: Steven van Beelen <steven.vanbeelen@axoniq.io>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f7447abd7be8613991e5f486acf2a5fff68eb906", "author": {"user": {"login": "m1l4n54v1c", "name": "Milan Savic"}}, "url": "https://github.com/AxonFramework/AxonFramework/commit/f7447abd7be8613991e5f486acf2a5fff68eb906", "committedDate": "2020-03-27T15:59:35Z", "message": "Update messaging/src/main/java/org/axonframework/queryhandling/ReactiveQueryGateway.java\n\nCo-Authored-By: Steven van Beelen <steven.vanbeelen@axoniq.io>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ab2068c09f24b5b13bd733c34670903b9cab438e", "author": {"user": {"login": "m1l4n54v1c", "name": "Milan Savic"}}, "url": "https://github.com/AxonFramework/AxonFramework/commit/ab2068c09f24b5b13bd733c34670903b9cab438e", "committedDate": "2020-03-27T16:00:31Z", "message": "Update messaging/src/main/java/org/axonframework/queryhandling/ReactiveQueryGateway.java\n\nCo-Authored-By: Steven van Beelen <steven.vanbeelen@axoniq.io>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "90c187bbd7121e2c39581e8d3d949ae40f03cf2b", "author": {"user": {"login": "m1l4n54v1c", "name": "Milan Savic"}}, "url": "https://github.com/AxonFramework/AxonFramework/commit/90c187bbd7121e2c39581e8d3d949ae40f03cf2b", "committedDate": "2020-03-27T16:00:55Z", "message": "Update messaging/src/main/java/org/axonframework/queryhandling/ReactiveQueryGateway.java\n\nCo-Authored-By: Steven van Beelen <steven.vanbeelen@axoniq.io>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "23cf99fde1c11b633fca11dbfa845effb4221a0a", "author": {"user": {"login": "m1l4n54v1c", "name": "Milan Savic"}}, "url": "https://github.com/AxonFramework/AxonFramework/commit/23cf99fde1c11b633fca11dbfa845effb4221a0a", "committedDate": "2020-03-27T16:02:13Z", "message": "Update messaging/src/main/java/org/axonframework/queryhandling/ReactiveQueryGateway.java\n\nCo-Authored-By: Steven van Beelen <steven.vanbeelen@axoniq.io>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5a6c286c20bbee8606ec38bd65745df8e894bf19", "author": {"user": {"login": "m1l4n54v1c", "name": "Milan Savic"}}, "url": "https://github.com/AxonFramework/AxonFramework/commit/5a6c286c20bbee8606ec38bd65745df8e894bf19", "committedDate": "2020-03-27T16:02:31Z", "message": "Update messaging/src/main/java/org/axonframework/queryhandling/ReactiveQueryGateway.java\n\nCo-Authored-By: Steven van Beelen <steven.vanbeelen@axoniq.io>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "09b2cbbd40734404e90b15b156173528616eb1c6", "author": {"user": {"login": "m1l4n54v1c", "name": "Milan Savic"}}, "url": "https://github.com/AxonFramework/AxonFramework/commit/09b2cbbd40734404e90b15b156173528616eb1c6", "committedDate": "2020-03-27T16:03:02Z", "message": "Update messaging/src/main/java/org/axonframework/queryhandling/ReactiveQueryGateway.java\n\nCo-Authored-By: Steven van Beelen <steven.vanbeelen@axoniq.io>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f7e0229d07511ba15613e0d8a1700bb74fa154d9", "author": {"user": {"login": "m1l4n54v1c", "name": "Milan Savic"}}, "url": "https://github.com/AxonFramework/AxonFramework/commit/f7e0229d07511ba15613e0d8a1700bb74fa154d9", "committedDate": "2020-03-27T16:03:34Z", "message": "Update messaging/src/main/java/org/axonframework/queryhandling/ReactiveQueryGateway.java\n\nCo-Authored-By: Steven van Beelen <steven.vanbeelen@axoniq.io>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e7874eda9eef72539f8f6205fe5f4daf12837f76", "author": {"user": {"login": "m1l4n54v1c", "name": "Milan Savic"}}, "url": "https://github.com/AxonFramework/AxonFramework/commit/e7874eda9eef72539f8f6205fe5f4daf12837f76", "committedDate": "2020-03-27T16:08:24Z", "message": "Update messaging/src/main/java/org/axonframework/queryhandling/ReactiveQueryGateway.java\n\nCo-Authored-By: Steven van Beelen <steven.vanbeelen@axoniq.io>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "00546f0d9851a60cf41315cec8d8d846f886465a", "author": {"user": {"login": "m1l4n54v1c", "name": "Milan Savic"}}, "url": "https://github.com/AxonFramework/AxonFramework/commit/00546f0d9851a60cf41315cec8d8d846f886465a", "committedDate": "2020-03-27T16:09:08Z", "message": "Update messaging/src/main/java/org/axonframework/queryhandling/ReactiveQueryGateway.java\n\nCo-Authored-By: Steven van Beelen <steven.vanbeelen@axoniq.io>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "073798ea757fbd6d934e99b6d34c4cfaa6e246ea", "author": {"user": {"login": "m1l4n54v1c", "name": "Milan Savic"}}, "url": "https://github.com/AxonFramework/AxonFramework/commit/073798ea757fbd6d934e99b6d34c4cfaa6e246ea", "committedDate": "2020-03-27T16:09:30Z", "message": "Update messaging/src/main/java/org/axonframework/queryhandling/ReactiveQueryGateway.java\n\nCo-Authored-By: Steven van Beelen <steven.vanbeelen@axoniq.io>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "571a1b8fca3258310d83783170fe29109349864d", "author": {"user": {"login": "m1l4n54v1c", "name": "Milan Savic"}}, "url": "https://github.com/AxonFramework/AxonFramework/commit/571a1b8fca3258310d83783170fe29109349864d", "committedDate": "2020-03-27T16:10:21Z", "message": "Update messaging/src/main/java/org/axonframework/queryhandling/ReactiveQueryGateway.java\n\nCo-Authored-By: Steven van Beelen <steven.vanbeelen@axoniq.io>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "aed059d8c015a032831dd6f823c66adc402ae0db", "author": {"user": {"login": "m1l4n54v1c", "name": "Milan Savic"}}, "url": "https://github.com/AxonFramework/AxonFramework/commit/aed059d8c015a032831dd6f823c66adc402ae0db", "committedDate": "2020-03-27T16:11:16Z", "message": "Update messaging/src/main/java/org/axonframework/queryhandling/ReactiveQueryGateway.java\n\nCo-Authored-By: Steven van Beelen <steven.vanbeelen@axoniq.io>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6579c13c23c460d07a169539b877250ade1b5004", "author": {"user": {"login": "m1l4n54v1c", "name": "Milan Savic"}}, "url": "https://github.com/AxonFramework/AxonFramework/commit/6579c13c23c460d07a169539b877250ade1b5004", "committedDate": "2020-03-27T16:11:45Z", "message": "Update messaging/src/main/java/org/axonframework/commandhandling/gateway/DefaultReactiveCommandGateway.java\n\nCo-Authored-By: Steven van Beelen <steven.vanbeelen@axoniq.io>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e3760cdbb3f94d0f80b56f8bbff571857c605194", "author": {"user": {"login": "m1l4n54v1c", "name": "Milan Savic"}}, "url": "https://github.com/AxonFramework/AxonFramework/commit/e3760cdbb3f94d0f80b56f8bbff571857c605194", "committedDate": "2020-04-01T09:03:37Z", "message": "Code review remarks."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1c189880a72b9b745b3dec904f64a029cbf7fce8", "author": {"user": {"login": "m1l4n54v1c", "name": "Milan Savic"}}, "url": "https://github.com/AxonFramework/AxonFramework/commit/1c189880a72b9b745b3dec904f64a029cbf7fce8", "committedDate": "2020-04-02T07:53:33Z", "message": "Introduced ReactiveMessageDispatchInterceptorSupport."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3d12250dbd32f20a5486e67c65db919e36b30370", "author": {"user": {"login": "m1l4n54v1c", "name": "Milan Savic"}}, "url": "https://github.com/AxonFramework/AxonFramework/commit/3d12250dbd32f20a5486e67c65db919e36b30370", "committedDate": "2020-04-04T11:01:23Z", "message": "Formatted code."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d85b4f18074f957a2039ac08fdfb6e5a86d919f5", "author": {"user": {"login": "m1l4n54v1c", "name": "Milan Savic"}}, "url": "https://github.com/AxonFramework/AxonFramework/commit/d85b4f18074f957a2039ac08fdfb6e5a86d919f5", "committedDate": "2020-04-06T11:28:35Z", "message": "SimpleQueryBus - report errors as QueryResponseMessage (but keep errorHandler reporting for backwards compatibility)\nDefaultReactiveQueryGateway - react on these errors and report them on fluxSink.error"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg4MzEyNDk3", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#pullrequestreview-388312497", "createdAt": "2020-04-06T14:35:09Z", "commit": {"oid": "d85b4f18074f957a2039ac08fdfb6e5a86d919f5"}, "state": "COMMENTED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNlQxNDozNTowOVrOGBazjg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNlQxNDo0NDowMFrOGBbN7A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDE0MDk0Mg==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             * Interface marking components capable of registering Reactive Dispatch Interceptors. Generally, these are Messaging\n          \n          \n            \n             * Interface marking components capable of registering a {@link ReactiveMessageDispatchInterceptor}. Generally, these are messaging", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r404140942", "createdAt": "2020-04-06T14:35:09Z", "author": {"login": "smcvb"}, "path": "messaging/src/main/java/org/axonframework/messaging/ReactiveMessageDispatchInterceptorSupport.java", "diffHunk": "@@ -0,0 +1,39 @@\n+/*\n+ * Copyright (c) 2010-2020. Axon Framework\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.axonframework.messaging;\n+\n+import org.axonframework.common.Registration;\n+\n+/**\n+ * Interface marking components capable of registering Reactive Dispatch Interceptors. Generally, these are Messaging", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d85b4f18074f957a2039ac08fdfb6e5a86d919f5"}, "originalPosition": 22}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDE0MTUyMw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * Register the given Reactive Dispatch Interceptor. After registration, the interceptor will be invoked for each\n          \n          \n            \n                 * Message dispatched on the messaging component that it was registered to.\n          \n          \n            \n                 *\n          \n          \n            \n                 * @param interceptor The reactive interceptor to register\n          \n          \n            \n                 * @return a Registration, which may be used to remove the unregister the interceptor\n          \n          \n            \n                 * Register the given {@link ReactiveMessageDispatchInterceptor}. After registration, the interceptor will be invoked for each\n          \n          \n            \n                 * message dispatched on the messaging component that it was registered to.\n          \n          \n            \n                 *\n          \n          \n            \n                 * @param interceptor The reactive interceptor to register\n          \n          \n            \n                 * @return a Registration, which may be used to unregister the interceptor", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r404141523", "createdAt": "2020-04-06T14:35:58Z", "author": {"login": "smcvb"}, "path": "messaging/src/main/java/org/axonframework/messaging/ReactiveMessageDispatchInterceptorSupport.java", "diffHunk": "@@ -0,0 +1,39 @@\n+/*\n+ * Copyright (c) 2010-2020. Axon Framework\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.axonframework.messaging;\n+\n+import org.axonframework.common.Registration;\n+\n+/**\n+ * Interface marking components capable of registering Reactive Dispatch Interceptors. Generally, these are Messaging\n+ * components injected into the sending end of the communication.\n+ *\n+ * @param <T>\n+ * @author Milan Savic\n+ * @since 4.4\n+ */\n+public interface ReactiveMessageDispatchInterceptorSupport<T extends Message<?>> {\n+\n+    /**\n+     * Register the given Reactive Dispatch Interceptor. After registration, the interceptor will be invoked for each\n+     * Message dispatched on the messaging component that it was registered to.\n+     *\n+     * @param interceptor The reactive interceptor to register\n+     * @return a Registration, which may be used to remove the unregister the interceptor", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d85b4f18074f957a2039ac08fdfb6e5a86d919f5"}, "originalPosition": 36}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDE0NTExOQ==", "bodyText": "This change makes it so that the javadoc of the QueryBus#scatterGather method is no longer incorrect, as it states:\n\nIf no handlers are available to provide a result, or when all available handlers throw an exception while attempting to do so, the returned Stream is empty.\n\nWith these, exceptions are also reported. Sounds fine to me, but the documentation should be correct on the matter.", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r404145119", "createdAt": "2020-04-06T14:40:38Z", "author": {"login": "smcvb"}, "path": "messaging/src/main/java/org/axonframework/queryhandling/SimpleQueryBus.java", "diffHunk": "@@ -198,16 +198,22 @@ private boolean unsubscribe(String queryName,\n                                    interceptAndInvoke(DefaultUnitOfWork.startAndGet(interceptedQuery),\n                                                       handler);\n                            QueryResponseMessage<R> response = null;\n+                           //noinspection unchecked", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d85b4f18074f957a2039ac08fdfb6e5a86d919f5"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDE0NzY5Mg==", "bodyText": "Additionally, this change will make it so that users of the DefaultQueryGateway now experience IllegalPayloadAccessException when going through the stream of results.\nThis occurs because the GenericResultMessage#getPayload will throw this in case of an exception. Is that desired?", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r404147692", "createdAt": "2020-04-06T14:44:00Z", "author": {"login": "smcvb"}, "path": "messaging/src/main/java/org/axonframework/queryhandling/SimpleQueryBus.java", "diffHunk": "@@ -198,16 +198,22 @@ private boolean unsubscribe(String queryName,\n                                    interceptAndInvoke(DefaultUnitOfWork.startAndGet(interceptedQuery),\n                                                       handler);\n                            QueryResponseMessage<R> response = null;\n+                           //noinspection unchecked", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDE0NTExOQ=="}, "originalCommit": {"oid": "d85b4f18074f957a2039ac08fdfb6e5a86d919f5"}, "originalPosition": 4}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3020030bdbf6e5bf940f50a404b3bf8f84b8ac07", "author": {"user": {"login": "m1l4n54v1c", "name": "Milan Savic"}}, "url": "https://github.com/AxonFramework/AxonFramework/commit/3020030bdbf6e5bf940f50a404b3bf8f84b8ac07", "committedDate": "2020-04-09T07:21:56Z", "message": "Added Flux<Result> dispatch(Publisher<?> data) to reactive gateways."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5a100cbfea9f16409bec9ca7a4ecb730f74c4fd0", "author": {"user": {"login": "m1l4n54v1c", "name": "Milan Savic"}}, "url": "https://github.com/AxonFramework/AxonFramework/commit/5a100cbfea9f16409bec9ca7a4ecb730f74c4fd0", "committedDate": "2020-04-09T07:24:07Z", "message": "Update messaging/src/main/java/org/axonframework/messaging/ReactiveMessageDispatchInterceptorSupport.java\n\nCo-Authored-By: Steven van Beelen <steven.vanbeelen@axoniq.io>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3f86798e78dc96b2ee2d844411e786300d3e5144", "author": {"user": {"login": "m1l4n54v1c", "name": "Milan Savic"}}, "url": "https://github.com/AxonFramework/AxonFramework/commit/3f86798e78dc96b2ee2d844411e786300d3e5144", "committedDate": "2020-04-09T07:36:30Z", "message": "Merge remote-tracking branch 'origin/reactive-gateways' into reactive-gateways"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "fed248c8e117f0334af95f899d86d3007752c065", "author": {"user": {"login": "m1l4n54v1c", "name": "Milan Savic"}}, "url": "https://github.com/AxonFramework/AxonFramework/commit/fed248c8e117f0334af95f899d86d3007752c065", "committedDate": "2020-04-10T11:52:55Z", "message": "Rolled back error reporting for scatter-gather queries."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzkyNjg2ODA4", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#pullrequestreview-392686808", "createdAt": "2020-04-14T07:56:49Z", "commit": {"oid": "fed248c8e117f0334af95f899d86d3007752c065"}, "state": "APPROVED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNFQwNzo1Njo1MFrOGFCkYw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNFQwNzo1Njo1MFrOGFCkYw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzkzODE0Nw==", "bodyText": "At this stage, it's still zero because the Flux/Publisher hasn't begun publishing yet, right? That only starts as soon as you push the result through the StepVerifier(?).", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r407938147", "createdAt": "2020-04-14T07:56:50Z", "author": {"login": "smcvb"}, "path": "messaging/src/test/java/org/axonframework/commandhandling/gateway/DefaultReactiveCommandGatewayTest.java", "diffHunk": "@@ -0,0 +1,168 @@\n+/*\n+ * Copyright (c) 2010-2020. Axon Framework\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.axonframework.commandhandling.gateway;\n+\n+import org.axonframework.commandhandling.AsynchronousCommandBus;\n+import org.axonframework.commandhandling.CommandBus;\n+import org.axonframework.commandhandling.CommandMessage;\n+import org.axonframework.common.Registration;\n+import org.axonframework.messaging.MessageHandler;\n+import org.junit.jupiter.api.*;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Mono;\n+import reactor.test.StepVerifier;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.stream.IntStream;\n+\n+import static java.util.stream.Collectors.toList;\n+import static org.junit.jupiter.api.Assertions.*;\n+import static org.mockito.Mockito.*;\n+\n+/**\n+ * Tests for {@link ReactiveCommandGateway}.\n+ *\n+ * @author Milan Savic\n+ */\n+class DefaultReactiveCommandGatewayTest {\n+\n+    private DefaultReactiveCommandGateway reactiveCommandGateway;\n+    private MessageHandler<CommandMessage<?>> commandMessageHandler;\n+    private RetryScheduler mockRetryScheduler;\n+\n+    @BeforeEach\n+    void setUp() {\n+        CommandBus commandBus = AsynchronousCommandBus.builder().build();\n+        mockRetryScheduler = mock(RetryScheduler.class);\n+        commandMessageHandler = spy(new MessageHandler<CommandMessage<?>>() {\n+\n+            private final AtomicInteger count = new AtomicInteger();\n+\n+            @Override\n+            public Object handle(CommandMessage<?> message) {\n+                if (\"backpressure\".equals(message.getPayload())) {\n+                    return count.incrementAndGet();\n+                }\n+                return \"handled\";\n+            }\n+        });\n+        commandBus.subscribe(String.class.getName(), commandMessageHandler);\n+        commandBus.subscribe(Integer.class.getName(), message -> {\n+            throw new RuntimeException();\n+        });\n+        commandBus.subscribe(Boolean.class.getName(),\n+                             message -> \"\" + message.getMetaData().getOrDefault(\"key1\", \"\")\n+                                     + message.getMetaData().getOrDefault(\"key2\", \"\"));\n+        reactiveCommandGateway = DefaultReactiveCommandGateway.builder()\n+                                                              .commandBus(commandBus)\n+                                                              .retryScheduler(mockRetryScheduler)\n+                                                              .build();\n+    }\n+\n+    @Test\n+    void testSend() throws Exception {\n+        Mono<String> result = reactiveCommandGateway.send(\"command\");\n+        verifyZeroInteractions(commandMessageHandler);\n+        StepVerifier.create(result)\n+                    .expectNext(\"handled\")\n+                    .verifyComplete();\n+        verify(commandMessageHandler).handle(any());\n+        verifyZeroInteractions(mockRetryScheduler);\n+    }\n+\n+    @Test\n+    void testSendAll() throws Exception {\n+        Flux<Object> commands = Flux.fromIterable(Arrays.asList(\"command1\", 4, \"command2\", 5, true));\n+\n+        Flux<Object> result = reactiveCommandGateway.sendAll(commands);\n+        verifyZeroInteractions(commandMessageHandler);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fed248c8e117f0334af95f899d86d3007752c065"}, "originalPosition": 96}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "458600ec7c51f894a998d38906b60087fe1ccc7a", "author": {"user": {"login": "idugalic", "name": "Ivan Dugalic"}}, "url": "https://github.com/AxonFramework/AxonFramework/commit/458600ec7c51f894a998d38906b60087fe1ccc7a", "committedDate": "2020-04-17T20:45:25Z", "message": "Merge remote-tracking branch 'origin/master' into reactive-gateways"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk4OTQ5NTQ2", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#pullrequestreview-398949546", "createdAt": "2020-04-23T10:04:40Z", "commit": {"oid": "c4511e81820de8d15c641e1c3038f4b688e29b51"}, "state": "DISMISSED", "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yM1QxMDowNDo0MFrOGKhVSA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yM1QxMDoxMzoyN1rOGKhsIw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzY4NTA2NA==", "bodyText": "Can we then at least make sure that existing DispatchInterceptors can be used in the reactive gateway? By means of a wrapper, perhaps?", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r413685064", "createdAt": "2020-04-23T10:04:40Z", "author": {"login": "abuijze"}, "path": "messaging/src/main/java/org/axonframework/messaging/ReactiveMessageDispatchInterceptor.java", "diffHunk": "@@ -0,0 +1,44 @@\n+/*\n+ * Copyright (c) 2010-2020. Axon Framework\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.axonframework.messaging;\n+\n+import reactor.core.publisher.Mono;\n+\n+import java.util.function.Function;\n+import java.util.function.Supplier;\n+\n+/**\n+ * Interceptor that allows messages to be intercepted and modified before they are dispatched. Implementations are\n+ * required to provide a function that modifies a {@link Mono} of a message and returns a modified/new {@link Mono} to\n+ * be passed down the interceptor chain or to be sent. This way we provide a reactive way to intercept messages.\n+ *\n+ * @param <T> the message type this interceptor can process\n+ * @author Milan Savic\n+ * @since 4.4\n+ */\n+public interface ReactiveMessageDispatchInterceptor<T extends Message<?>> extends Supplier<Function<Mono<T>, Mono<T>>> {\n+", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjQ4NDcwMw=="}, "originalCommit": {"oid": "c4511e81820de8d15c641e1c3038f4b688e29b51"}, "originalPosition": 34}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzY4NzAyOA==", "bodyText": "Is this the DefaultReactiveCommandGateway or a ReactorReactiveCommandGateway? The implementation \"assumption\" this makes, is that you use Project Reactor, right?", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r413687028", "createdAt": "2020-04-23T10:07:33Z", "author": {"login": "abuijze"}, "path": "messaging/src/main/java/org/axonframework/commandhandling/gateway/DefaultReactiveCommandGateway.java", "diffHunk": "@@ -0,0 +1,201 @@\n+/*\n+ * Copyright (c) 2010-2020. Axon Framework\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.axonframework.commandhandling.gateway;\n+\n+import org.axonframework.commandhandling.CommandBus;\n+import org.axonframework.commandhandling.CommandCallback;\n+import org.axonframework.commandhandling.CommandMessage;\n+import org.axonframework.commandhandling.GenericCommandMessage;\n+import org.axonframework.common.AxonConfigurationException;\n+import org.axonframework.common.Registration;\n+import org.axonframework.messaging.ReactiveMessageDispatchInterceptor;\n+import reactor.core.publisher.Mono;\n+\n+import java.util.List;\n+import java.util.concurrent.CopyOnWriteArrayList;\n+\n+import static java.util.Arrays.asList;\n+import static org.axonframework.common.BuilderUtils.assertNonNull;\n+\n+/**\n+ * Default implementation of the {@link ReactiveCommandGateway}.\n+ *\n+ * @author Milan Savic\n+ * @since 4.4\n+ */\n+public class DefaultReactiveCommandGateway implements ReactiveCommandGateway {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "458600ec7c51f894a998d38906b60087fe1ccc7a"}, "originalPosition": 40}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzY4NzI4OQ==", "bodyText": "That's also something that's worth mentioning in the class level Javadoc", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r413687289", "createdAt": "2020-04-23T10:07:59Z", "author": {"login": "abuijze"}, "path": "messaging/src/main/java/org/axonframework/commandhandling/gateway/DefaultReactiveCommandGateway.java", "diffHunk": "@@ -0,0 +1,201 @@\n+/*\n+ * Copyright (c) 2010-2020. Axon Framework\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.axonframework.commandhandling.gateway;\n+\n+import org.axonframework.commandhandling.CommandBus;\n+import org.axonframework.commandhandling.CommandCallback;\n+import org.axonframework.commandhandling.CommandMessage;\n+import org.axonframework.commandhandling.GenericCommandMessage;\n+import org.axonframework.common.AxonConfigurationException;\n+import org.axonframework.common.Registration;\n+import org.axonframework.messaging.ReactiveMessageDispatchInterceptor;\n+import reactor.core.publisher.Mono;\n+\n+import java.util.List;\n+import java.util.concurrent.CopyOnWriteArrayList;\n+\n+import static java.util.Arrays.asList;\n+import static org.axonframework.common.BuilderUtils.assertNonNull;\n+\n+/**\n+ * Default implementation of the {@link ReactiveCommandGateway}.\n+ *\n+ * @author Milan Savic\n+ * @since 4.4\n+ */\n+public class DefaultReactiveCommandGateway implements ReactiveCommandGateway {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzY4NzAyOA=="}, "originalCommit": {"oid": "458600ec7c51f894a998d38906b60087fe1ccc7a"}, "originalPosition": 40}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzY4OTkwMQ==", "bodyText": "Please also have it implement MessageDispatchInterceptorSupport. Preferably, I'd like the Reactive implementations to show more compatibility by extending the MessageDispatchInterceptorSupport. The reactive impl could do an instanceof check to see if implementations are already reactive. If not, it could wrap them with a reactive wrapper implementation.", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r413689901", "createdAt": "2020-04-23T10:11:55Z", "author": {"login": "abuijze"}, "path": "messaging/src/main/java/org/axonframework/commandhandling/gateway/ReactiveCommandGateway.java", "diffHunk": "@@ -0,0 +1,67 @@\n+/*\n+ * Copyright (c) 2010-2020. Axon Framework\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.axonframework.commandhandling.gateway;\n+\n+import org.axonframework.commandhandling.CommandBus;\n+import org.axonframework.commandhandling.CommandMessage;\n+import org.axonframework.messaging.Message;\n+import org.axonframework.messaging.MetaData;\n+import org.axonframework.messaging.ReactiveMessageDispatchInterceptorSupport;\n+import org.reactivestreams.Publisher;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Mono;\n+\n+import java.util.function.Function;\n+\n+/**\n+ * Variation of {@link CommandGateway}. Provides support for reactive return type such as {@link Mono} from Project\n+ * Reactor.\n+ *\n+ * @author Milan Savic\n+ * @since 4.4\n+ */\n+public interface ReactiveCommandGateway extends ReactiveMessageDispatchInterceptorSupport<CommandMessage<?>> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "458600ec7c51f894a998d38906b60087fe1ccc7a"}, "originalPosition": 37}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzY5MDIxNQ==", "bodyText": "I actually think it is possible, generics wise....", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r413690215", "createdAt": "2020-04-23T10:12:23Z", "author": {"login": "abuijze"}, "path": "messaging/src/main/java/org/axonframework/messaging/ReactiveMessageDispatchInterceptor.java", "diffHunk": "@@ -0,0 +1,44 @@\n+/*\n+ * Copyright (c) 2010-2020. Axon Framework\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.axonframework.messaging;\n+\n+import reactor.core.publisher.Mono;\n+\n+import java.util.function.Function;\n+import java.util.function.Supplier;\n+\n+/**\n+ * Interceptor that allows messages to be intercepted and modified before they are dispatched. Implementations are\n+ * required to provide a function that modifies a {@link Mono} of a message and returns a modified/new {@link Mono} to\n+ * be passed down the interceptor chain or to be sent. This way we provide a reactive way to intercept messages.\n+ *\n+ * @param <T> the message type this interceptor can process\n+ * @author Milan Savic\n+ * @since 4.4\n+ */\n+public interface ReactiveMessageDispatchInterceptor<T extends Message<?>> extends Supplier<Function<Mono<T>, Mono<T>>> {\n+", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjQ4NDcwMw=="}, "originalCommit": {"oid": "c4511e81820de8d15c641e1c3038f4b688e29b51"}, "originalPosition": 34}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzY5MDkxNQ==", "bodyText": "Why does it need to be a Supplier of a Function, and not just the Function itself?", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r413690915", "createdAt": "2020-04-23T10:13:27Z", "author": {"login": "abuijze"}, "path": "messaging/src/main/java/org/axonframework/messaging/ReactiveMessageDispatchInterceptor.java", "diffHunk": "@@ -0,0 +1,45 @@\n+/*\n+ * Copyright (c) 2010-2020. Axon Framework\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.axonframework.messaging;\n+\n+import reactor.core.publisher.Mono;\n+\n+import java.util.function.Function;\n+import java.util.function.Supplier;\n+\n+/**\n+ * Interceptor that allows messages to be intercepted and modified before they are dispatched. Implementations are\n+ * required to provide a function that modifies a {@link Mono} of a message and returns a modified/new {@code Mono} to\n+ * be passed down the interceptor chain or to be dispatched. This way we provide a reactive approach to intercepting messages.\n+ *\n+ * @param <T> the message type this interceptor can process\n+ * @author Milan Savic\n+ * @since 4.4\n+ */\n+@FunctionalInterface\n+public interface ReactiveMessageDispatchInterceptor<T extends Message<?>> extends Supplier<Function<Mono<T>, Mono<T>>> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "458600ec7c51f894a998d38906b60087fe1ccc7a"}, "originalPosition": 34}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7f459636344b73ed8abc6abe001ad00e56bec648", "author": {"user": {"login": "m1l4n54v1c", "name": "Milan Savic"}}, "url": "https://github.com/AxonFramework/AxonFramework/commit/7f459636344b73ed8abc6abe001ad00e56bec648", "committedDate": "2020-04-27T10:09:36Z", "message": "Merge branch 'master' into reactive-gateways"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e6b06990aac973cb69ccbced6027101bc383b4db", "author": {"user": {"login": "m1l4n54v1c", "name": "Milan Savic"}}, "url": "https://github.com/AxonFramework/AxonFramework/commit/e6b06990aac973cb69ccbced6027101bc383b4db", "committedDate": "2020-04-27T10:22:59Z", "message": "Update messaging/src/main/java/org/axonframework/messaging/ReactiveMessageDispatchInterceptorSupport.java\n\nCo-Authored-By: Steven van Beelen <steven.vanbeelen@axoniq.io>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e643ca6834cb7ccc9aa6bc3b5a3d52844da17ebd", "author": {"user": {"login": "m1l4n54v1c", "name": "Milan Savic"}}, "url": "https://github.com/AxonFramework/AxonFramework/commit/e643ca6834cb7ccc9aa6bc3b5a3d52844da17ebd", "committedDate": "2020-04-27T10:30:52Z", "message": "Merge remote-tracking branch 'origin/reactive-gateways' into reactive-gateways"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "344d60e342ea50d792092f7c1ee148c719f3f9bf", "author": {"user": {"login": "m1l4n54v1c", "name": "Milan Savic"}}, "url": "https://github.com/AxonFramework/AxonFramework/commit/344d60e342ea50d792092f7c1ee148c719f3f9bf", "committedDate": "2020-04-27T11:36:31Z", "message": "Renamed DefaultReactiveGateways to ReactorGateways."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "775aaaeda23e86c844b10afb84f1903964f8a37a", "author": {"user": {"login": "stefanvozd", "name": "Stefan Dragisic"}}, "url": "https://github.com/AxonFramework/AxonFramework/commit/775aaaeda23e86c844b10afb84f1903964f8a37a", "committedDate": "2020-05-22T15:54:18Z", "message": "Reactive publisher callback"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "899aace41640212b7ae5df13a3f54971aa047107", "author": {"user": {"login": "saratry", "name": "sara pellegrini"}}, "url": "https://github.com/AxonFramework/AxonFramework/commit/899aace41640212b7ae5df13a3f54971aa047107", "committedDate": "2020-05-25T10:51:47Z", "message": "Introduce new API for reactive interceptors."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "68e814e1659371bc50a2baa23da33fc64983603d", "author": {"user": {"login": "saratry", "name": "sara pellegrini"}}, "url": "https://github.com/AxonFramework/AxonFramework/commit/68e814e1659371bc50a2baa23da33fc64983603d", "committedDate": "2020-05-27T10:34:09Z", "message": "First partial implementation for ReactorCommandGateway new API."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b9da29b9c6ed669493331a468aa9ce6d0a17daf9", "author": {"user": {"login": "stefanvozd", "name": "Stefan Dragisic"}}, "url": "https://github.com/AxonFramework/AxonFramework/commit/b9da29b9c6ed669493331a468aa9ce6d0a17daf9", "committedDate": "2020-05-27T16:09:19Z", "message": "Reactive query implementation, few improvements and renaming's"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ec2e8ff341a2c5a3f107e001ff6468082846e6e6", "author": {"user": {"login": "stefanvozd", "name": "Stefan Dragisic"}}, "url": "https://github.com/AxonFramework/AxonFramework/commit/ec2e8ff341a2c5a3f107e001ff6468082846e6e6", "committedDate": "2020-06-04T12:01:22Z", "message": "Reactive scatter gather implementation"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b23bfb078148eca09942e726f55b512f038eab22", "author": {"user": {"login": "stefanvozd", "name": "Stefan Dragisic"}}, "url": "https://github.com/AxonFramework/AxonFramework/commit/b23bfb078148eca09942e726f55b512f038eab22", "committedDate": "2020-06-12T12:14:49Z", "message": "Reactive Gateways - subscription queries, clean up, tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "71aa01c568702d0d68fbcdc9afbdb07e628d10cd", "author": {"user": {"login": "stefanvozd", "name": "Stefan Dragisic"}}, "url": "https://github.com/AxonFramework/AxonFramework/commit/71aa01c568702d0d68fbcdc9afbdb07e628d10cd", "committedDate": "2020-06-12T12:28:15Z", "message": "Remove system.out"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1a196932f6cde9f0bee19b8609d5edb93937162b", "author": {"user": {"login": "m1l4n54v1c", "name": "Milan Savic"}}, "url": "https://github.com/AxonFramework/AxonFramework/commit/1a196932f6cde9f0bee19b8609d5edb93937162b", "committedDate": "2020-06-15T09:43:29Z", "message": "Adjusted GenericSubscriptionQueryUpdateMessage to implement ResultMessage."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a659f518ce181f9cb959506778752a0902c919a9", "author": {"user": {"login": "m1l4n54v1c", "name": "Milan Savic"}}, "url": "https://github.com/AxonFramework/AxonFramework/commit/a659f518ce181f9cb959506778752a0902c919a9", "committedDate": "2020-06-15T09:44:39Z", "message": "Merge branch 'master' into reactive-gateways"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "64817afe5233f7790aa5e0483dd92f5f41d6635d", "author": {"user": {"login": "m1l4n54v1c", "name": "Milan Savic"}}, "url": "https://github.com/AxonFramework/AxonFramework/commit/64817afe5233f7790aa5e0483dd92f5f41d6635d", "committedDate": "2020-06-15T10:29:48Z", "message": "Renamed Reactive to Reactor Gateways."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "fdcbac0aacd4ca6621e06af194ca4c0055c8d667", "author": {"user": {"login": "m1l4n54v1c", "name": "Milan Savic"}}, "url": "https://github.com/AxonFramework/AxonFramework/commit/fdcbac0aacd4ca6621e06af194ca4c0055c8d667", "committedDate": "2020-06-18T14:45:27Z", "message": "Reactor Command Gateway Tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9eb35bde4737bcf2828b77fb48655350fa0b23a1", "author": {"user": {"login": "m1l4n54v1c", "name": "Milan Savic"}}, "url": "https://github.com/AxonFramework/AxonFramework/commit/9eb35bde4737bcf2828b77fb48655350fa0b23a1", "committedDate": "2020-06-22T09:08:58Z", "message": "Renamed Reactive Interceptors to Reactor Interceptors."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2c783a51ce37bc1259c27997024dc90c906c8a58", "author": {"user": {"login": "m1l4n54v1c", "name": "Milan Savic"}}, "url": "https://github.com/AxonFramework/AxonFramework/commit/2c783a51ce37bc1259c27997024dc90c906c8a58", "committedDate": "2020-06-22T09:30:56Z", "message": "Enhanced ReactorQueryGateway API."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d747ba0b44c2006beac72a7faae3a3dc5cd56183", "author": {"user": {"login": "m1l4n54v1c", "name": "Milan Savic"}}, "url": "https://github.com/AxonFramework/AxonFramework/commit/d747ba0b44c2006beac72a7faae3a3dc5cd56183", "committedDate": "2020-06-23T15:29:48Z", "message": "Added support to GrpcBackedQueryUpdateMessage for errors."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4208bd41187caca66f6422eb8280f014716f1a6f", "author": {"user": {"login": "stefanvozd", "name": "Stefan Dragisic"}}, "url": "https://github.com/AxonFramework/AxonFramework/commit/4208bd41187caca66f6422eb8280f014716f1a6f", "committedDate": "2020-06-23T15:29:53Z", "message": "Solve case when command handler is void type or returns null"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "dbe26de15a85ee168bfbf9232adcd939f53a9cca", "author": {"user": {"login": "stefanvozd", "name": "Stefan Dragisic"}}, "url": "https://github.com/AxonFramework/AxonFramework/commit/dbe26de15a85ee168bfbf9232adcd939f53a9cca", "committedDate": "2020-06-23T15:31:06Z", "message": "Merge branch 'reactive-gateways' of github.com:AxonFramework/AxonFramework into reactive-gateways"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "127c01e78625dfc62bd199aa17bc34bab2b4acf0", "author": {"user": {"login": "m1l4n54v1c", "name": "Milan Savic"}}, "url": "https://github.com/AxonFramework/AxonFramework/commit/127c01e78625dfc62bd199aa17bc34bab2b4acf0", "committedDate": "2020-06-23T15:34:02Z", "message": "Merge branch 'master' into reactive-gateways"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "440176753605f7e0dd5da749335c96de71bebc2d", "author": {"user": {"login": "stefanvozd", "name": "Stefan Dragisic"}}, "url": "https://github.com/AxonFramework/AxonFramework/commit/440176753605f7e0dd5da749335c96de71bebc2d", "committedDate": "2020-06-23T15:42:12Z", "message": "removed unnecessary code. we already map to error in reactive callback"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "570a1c6bc56a5f72077b2450ee6ecfe370334844", "author": {"user": {"login": "m1l4n54v1c", "name": "Milan Savic"}}, "url": "https://github.com/AxonFramework/AxonFramework/commit/570a1c6bc56a5f72077b2450ee6ecfe370334844", "committedDate": "2020-06-24T11:34:33Z", "message": "Removed additional reactor-core dep.\nFormatted ReactiveCallbackTest."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "edb8263633031512b43ebcf5dc47b4c65ffebbd6", "author": {"user": {"login": "m1l4n54v1c", "name": "Milan Savic"}}, "url": "https://github.com/AxonFramework/AxonFramework/commit/edb8263633031512b43ebcf5dc47b4c65ffebbd6", "committedDate": "2020-06-24T11:34:58Z", "message": "Merge remote-tracking branch 'origin/reactive-gateways' into reactive-gateways"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c047ece2cd069f4189247f83bc94536a606a05d3", "author": {"user": {"login": "m1l4n54v1c", "name": "Milan Savic"}}, "url": "https://github.com/AxonFramework/AxonFramework/commit/c047ece2cd069f4189247f83bc94536a606a05d3", "committedDate": "2020-06-29T06:54:22Z", "message": "Increased Project Reactor version."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "56966d4168fde1fff0307269ffe91c05259df0cd", "author": {"user": {"login": "m1l4n54v1c", "name": "Milan Savic"}}, "url": "https://github.com/AxonFramework/AxonFramework/commit/56966d4168fde1fff0307269ffe91c05259df0cd", "committedDate": "2020-06-29T06:55:21Z", "message": "Merge branch 'master' into reactive-gateways"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "fb5618a60243784657fce38c376d4c62f3b5abd4", "author": {"user": {"login": "stefanvozd", "name": "Stefan Dragisic"}}, "url": "https://github.com/AxonFramework/AxonFramework/commit/fb5618a60243784657fce38c376d4c62f3b5abd4", "committedDate": "2020-06-29T09:11:11Z", "message": "Detect context loss & security context filters tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e6882dbe07c5b3785702364d7a67bb41ad563d10", "author": {"user": {"login": "m1l4n54v1c", "name": "Milan Savic"}}, "url": "https://github.com/AxonFramework/AxonFramework/commit/e6882dbe07c5b3785702364d7a67bb41ad563d10", "committedDate": "2020-06-29T12:33:58Z", "message": "Merge branch 'master' into reactive-gateways"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "586775639f2cf646664779c47f6add110b3334b4", "author": {"user": {"login": "m1l4n54v1c", "name": "Milan Savic"}}, "url": "https://github.com/AxonFramework/AxonFramework/commit/586775639f2cf646664779c47f6add110b3334b4", "committedDate": "2020-06-29T12:34:40Z", "message": "Merge remote-tracking branch 'origin/reactive-gateways' into reactive-gateways"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e7da852c0adbaeb8abc3ee419f54f2ce31cb820c", "author": {"user": {"login": "m1l4n54v1c", "name": "Milan Savic"}}, "url": "https://github.com/AxonFramework/AxonFramework/commit/e7da852c0adbaeb8abc3ee419f54f2ce31cb820c", "committedDate": "2020-06-30T07:49:14Z", "message": "Added tests for queryUpdates and subscriptionQueryMany methods.\nAdded tests for ReactorMessageDispatchInterceptor default method.\nFixed Sonar issues."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a90cc9c1f9184218c8667ac796367d0b55730bc5", "author": {"user": {"login": "m1l4n54v1c", "name": "Milan Savic"}}, "url": "https://github.com/AxonFramework/AxonFramework/commit/a90cc9c1f9184218c8667ac796367d0b55730bc5", "committedDate": "2020-06-30T09:38:32Z", "message": "Added tests for GenericSubscriptionQueryUpdateMessage."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "eec6bd0db95448564114ec9a451770b6827855c3", "author": {"user": {"login": "m1l4n54v1c", "name": "Milan Savic"}}, "url": "https://github.com/AxonFramework/AxonFramework/commit/eec6bd0db95448564114ec9a451770b6827855c3", "committedDate": "2020-06-30T10:19:27Z", "message": "Added tests for exceptional cases in SubscriptionMessageSerializerTest."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0f81708cdc145726b9a836c4b08462c3720103d1", "author": {"user": {"login": "m1l4n54v1c", "name": "Milan Savic"}}, "url": "https://github.com/AxonFramework/AxonFramework/commit/0f81708cdc145726b9a836c4b08462c3720103d1", "committedDate": "2020-06-30T16:11:21Z", "message": "Added ReactorEventGateway."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f1e5788b49252c33d6af8d7f82fd5e4de4699bc9", "author": {"user": {"login": "m1l4n54v1c", "name": "Milan Savic"}}, "url": "https://github.com/AxonFramework/AxonFramework/commit/f1e5788b49252c33d6af8d7f82fd5e4de4699bc9", "committedDate": "2020-07-01T07:48:17Z", "message": "Removed wildcards from generics as return type of ReactorEventGateway methods."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "98865ab1427e4d879301c1bf542842eccc8aa3c3", "author": {"user": {"login": "m1l4n54v1c", "name": "Milan Savic"}}, "url": "https://github.com/AxonFramework/AxonFramework/commit/98865ab1427e4d879301c1bf542842eccc8aa3c3", "committedDate": "2020-07-01T10:08:21Z", "message": "Removed blocking publishing of event message."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ2MTk0NjE2", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#pullrequestreview-446194616", "createdAt": "2020-07-10T07:52:10Z", "commit": {"oid": "98865ab1427e4d879301c1bf542842eccc8aa3c3"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 59, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xMFQwNzo1MjoxMFrOGvthVw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xMFQxMzowNjowOFrOGv2lsA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjY4MjA3MQ==", "bodyText": "Nit: details sounds a little vague here if you ask me.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    Supplier<Object> details = serializedPayload == null\n          \n          \n            \n                    Supplier<Object> exceptionDetails = serializedPayload == null", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r452682071", "createdAt": "2020-07-10T07:52:10Z", "author": {"login": "smcvb"}, "path": "axon-server-connector/src/main/java/org/axonframework/axonserver/connector/query/subscription/GrpcBackedQueryUpdateMessage.java", "diffHunk": "@@ -49,18 +53,27 @@\n      *                    given {@code queryUpdate}\n      */\n     public GrpcBackedQueryUpdateMessage(QueryUpdate queryUpdate, Serializer serializer) {\n-        this(\n-                queryUpdate,\n-                new LazyDeserializingObject<>(new GrpcSerializedObject(queryUpdate.getPayload()), serializer),\n-                new GrpcMetaData(queryUpdate.getMetaDataMap(), serializer)\n-        );\n+        this.queryUpdate = queryUpdate;\n+        this.serializedPayload = queryUpdate.hasPayload()\n+                ? new LazyDeserializingObject<>(new GrpcSerializedObject(queryUpdate.getPayload()), serializer)\n+                : null;\n+        Supplier<Object> details = serializedPayload == null", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "98865ab1427e4d879301c1bf542842eccc8aa3c3"}, "originalPosition": 40}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjY4MzI1Mg==", "bodyText": "Super nit: indenting looks a little awful here if you ask me.", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r452683252", "createdAt": "2020-07-10T07:54:33Z", "author": {"login": "smcvb"}, "path": "axon-server-connector/src/main/java/org/axonframework/axonserver/connector/query/subscription/SubscriptionMessageSerializer.java", "diffHunk": "@@ -116,19 +118,28 @@ public SubscriptionQuery serialize(SubscriptionQueryMessage subscriptionQueryMes\n         return new GrpcBackedSubscriptionQueryMessage<>(subscriptionQuery, messageSerializer, serializer);\n     }\n \n-    QueryProviderOutbound serialize(QueryResponseMessage initialResult, String subscriptionId) {\n-        QueryResponse queryResponse =\n+    QueryProviderOutbound serialize(QueryResponseMessage<?> initialResult, String subscriptionId) {\n+        QueryResponse.Builder responseBuilder =\n                 QueryResponse.newBuilder()\n-                             .setPayload(payloadSerializer.apply(initialResult))\n                              .putAllMetaData(metadataSerializer.apply(initialResult.getMetaData()))\n                              .setMessageIdentifier(initialResult.getIdentifier())\n-                             .setRequestIdentifier(subscriptionId)\n-                             .build();\n+                             .setRequestIdentifier(subscriptionId);\n+        if (initialResult.isExceptional()) {\n+            Throwable exceptionResult = initialResult.exceptionResult();\n+            responseBuilder.setErrorCode(ErrorCode.QUERY_EXECUTION_ERROR.errorCode());\n+            responseBuilder.setErrorMessage(ExceptionSerializer", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "98865ab1427e4d879301c1bf542842eccc8aa3c3"}, "originalPosition": 34}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjY4NTU1Nw==", "bodyText": "Nit: might be worth validating there is a null payload? If that's what we're going to tell our users, than making sure it is so sounds reasonable to me.", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r452685557", "createdAt": "2020-07-10T07:58:44Z", "author": {"login": "smcvb"}, "path": "axon-server-connector/src/test/java/org/axonframework/axonserver/connector/query/subscription/SubscriptionMessageSerializerTest.java", "diffHunk": "@@ -76,12 +77,29 @@ void testInitialResponse() {\n         assertEquals(message.getMetaData(), deserialized.getMetaData());\n     }\n \n+    @Test\n+    void testExceptionalInitialResponse() {\n+        MetaData metadata = MetaData.with(\"firstKey\", \"firstValue\")\n+                                    .mergedWith(MetaData.with(\"secondKey\", \"secondValue\"));\n+        QueryResponseMessage<String> message = new GenericQueryResponseMessage<>(String.class,\n+                                                                                 new RuntimeException(\"oops\"),\n+                                                                                 metadata);\n+        QueryProviderOutbound grpcMessage = testSubject.serialize(message, \"subscriptionId\");\n+        assertEquals(\"subscriptionId\", grpcMessage.getSubscriptionQueryResponse().getSubscriptionIdentifier());\n+        QueryResponse initialResponse = grpcMessage.getSubscriptionQueryResponse().getInitialResult();\n+        QueryResponseMessage<Object> deserialized = testSubject.deserialize(initialResponse);\n+        assertEquals(message.getIdentifier(), deserialized.getIdentifier());\n+        assertEquals(message.getMetaData(), deserialized.getMetaData());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "98865ab1427e4d879301c1bf542842eccc8aa3c3"}, "originalPosition": 48}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjY4NjAwNw==", "bodyText": "Same asserrtNull(message.getPayload()) suggestions as for the testExceptionalInitialResponse().", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r452686007", "createdAt": "2020-07-10T07:59:38Z", "author": {"login": "smcvb"}, "path": "axon-server-connector/src/test/java/org/axonframework/axonserver/connector/query/subscription/SubscriptionMessageSerializerTest.java", "diffHunk": "@@ -92,6 +110,21 @@ void testUpdate() {\n         assertEquals(message.getMetaData(), deserialized.getMetaData());\n     }\n \n+    @Test\n+    void testExceptionalUpdate() {\n+        MetaData metaData = MetaData.with(\"k1\", \"v1\");\n+        SubscriptionQueryUpdateMessage<String> message =\n+                new GenericSubscriptionQueryUpdateMessage<>(String.class, new RuntimeException(\"oops\"), metaData);\n+        QueryProviderOutbound grpcMessage = testSubject.serialize(message, \"subscriptionId\");\n+        assertEquals(\"subscriptionId\", grpcMessage.getSubscriptionQueryResponse().getSubscriptionIdentifier());\n+        QueryUpdate update = grpcMessage.getSubscriptionQueryResponse().getUpdate();\n+        SubscriptionQueryUpdateMessage<Object> deserialized = testSubject.deserialize(update);\n+        assertEquals(message.getIdentifier(), deserialized.getIdentifier());\n+        assertEquals(message.getMetaData(), deserialized.getMetaData());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "98865ab1427e4d879301c1bf542842eccc8aa3c3"}, "originalPosition": 77}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjY4NjU3MQ==", "bodyText": "You could similarly argue that validating the following for successful calls makes sense: assertFalse(message.isExceptional())", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r452686571", "createdAt": "2020-07-10T08:00:44Z", "author": {"login": "smcvb"}, "path": "axon-server-connector/src/test/java/org/axonframework/axonserver/connector/query/subscription/SubscriptionMessageSerializerTest.java", "diffHunk": "@@ -76,12 +77,29 @@ void testInitialResponse() {\n         assertEquals(message.getMetaData(), deserialized.getMetaData());\n     }\n \n+    @Test\n+    void testExceptionalInitialResponse() {\n+        MetaData metadata = MetaData.with(\"firstKey\", \"firstValue\")\n+                                    .mergedWith(MetaData.with(\"secondKey\", \"secondValue\"));\n+        QueryResponseMessage<String> message = new GenericQueryResponseMessage<>(String.class,\n+                                                                                 new RuntimeException(\"oops\"),\n+                                                                                 metadata);\n+        QueryProviderOutbound grpcMessage = testSubject.serialize(message, \"subscriptionId\");\n+        assertEquals(\"subscriptionId\", grpcMessage.getSubscriptionQueryResponse().getSubscriptionIdentifier());\n+        QueryResponse initialResponse = grpcMessage.getSubscriptionQueryResponse().getInitialResult();\n+        QueryResponseMessage<Object> deserialized = testSubject.deserialize(initialResponse);\n+        assertEquals(message.getIdentifier(), deserialized.getIdentifier());\n+        assertEquals(message.getMetaData(), deserialized.getMetaData());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjY4NTU1Nw=="}, "originalCommit": {"oid": "98865ab1427e4d879301c1bf542842eccc8aa3c3"}, "originalPosition": 48}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjY4NzA3NA==", "bodyText": "Nits: I'd {@link ...} to CommandCallback and CommandBus here. Definitely no blocker though.", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r452687074", "createdAt": "2020-07-10T08:01:45Z", "author": {"login": "smcvb"}, "path": "messaging/src/main/java/org/axonframework/commandhandling/callbacks/ReactiveCallback.java", "diffHunk": "@@ -0,0 +1,57 @@\n+/*\n+ * Copyright (c) 2010-2018. Axon Framework\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.axonframework.commandhandling.callbacks;\n+\n+import org.axonframework.commandhandling.CommandCallback;\n+import org.axonframework.commandhandling.CommandMessage;\n+import org.axonframework.commandhandling.CommandResultMessage;\n+import org.reactivestreams.Publisher;\n+import org.reactivestreams.Subscriber;\n+import reactor.core.publisher.EmitterProcessor;\n+import reactor.core.publisher.FluxSink;\n+\n+/**\n+ * Command Handler Callback that allows the dispatching thread to wait for the result of the callback, using the", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "98865ab1427e4d879301c1bf542842eccc8aa3c3"}, "originalPosition": 28}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjY4NzMzMA==", "bodyText": "What's this suppression for? Worth adding a short comment on in the code why this is suppressed?", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r452687330", "createdAt": "2020-07-10T08:02:12Z", "author": {"login": "smcvb"}, "path": "messaging/src/main/java/org/axonframework/commandhandling/callbacks/ReactiveCallback.java", "diffHunk": "@@ -0,0 +1,57 @@\n+/*\n+ * Copyright (c) 2010-2018. Axon Framework\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.axonframework.commandhandling.callbacks;\n+\n+import org.axonframework.commandhandling.CommandCallback;\n+import org.axonframework.commandhandling.CommandMessage;\n+import org.axonframework.commandhandling.CommandResultMessage;\n+import org.reactivestreams.Publisher;\n+import org.reactivestreams.Subscriber;\n+import reactor.core.publisher.EmitterProcessor;\n+import reactor.core.publisher.FluxSink;\n+\n+/**\n+ * Command Handler Callback that allows the dispatching thread to wait for the result of the callback, using the\n+ * Project Reactor mechanisms. This callback allows the caller to synchronize calls when an asynchronous command bus is\n+ * being used.\n+ *\n+ * @author Stefan Dragisic\n+ * @since 4.4\n+ */\n+@SuppressWarnings(\"ReactiveStreamsPublisherImplementation\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "98865ab1427e4d879301c1bf542842eccc8aa3c3"}, "originalPosition": 35}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjY4OTQzOA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             * Variation of {@link CommandGateway}. Provides support for reactive return type such as {@link Mono} from Project\n          \n          \n            \n             * Variation of the {@link CommandGateway}, wrapping a {@link CommandBus} for a friendlier API. Provides support for reactive return types such as {@link Mono} from Project", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r452689438", "createdAt": "2020-07-10T08:06:37Z", "author": {"login": "smcvb"}, "path": "messaging/src/main/java/org/axonframework/commandhandling/gateway/ReactorCommandGateway.java", "diffHunk": "@@ -0,0 +1,71 @@\n+/*\n+ * Copyright (c) 2010-2020. Axon Framework\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.axonframework.commandhandling.gateway;\n+\n+import org.axonframework.commandhandling.CommandBus;\n+import org.axonframework.commandhandling.CommandMessage;\n+import org.axonframework.commandhandling.CommandResultMessage;\n+import org.axonframework.messaging.Message;\n+import org.axonframework.messaging.MetaData;\n+import org.axonframework.messaging.reactive.ReactorMessageDispatchInterceptorSupport;\n+import org.axonframework.messaging.reactive.ReactorResultHandlerInterceptorSupport;\n+import org.reactivestreams.Publisher;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Mono;\n+\n+import java.util.function.Function;\n+\n+/**\n+ * Variation of {@link CommandGateway}. Provides support for reactive return type such as {@link Mono} from Project", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "98865ab1427e4d879301c1bf542842eccc8aa3c3"}, "originalPosition": 33}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjY5MDU5OA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * Uses given Publisher of commands to send incoming commands away. Commands will be sent sequentially - once a\n          \n          \n            \n                 * result of Nth command arrives, (N + 1)th command is dispatched.\n          \n          \n            \n                 *\n          \n          \n            \n                 * @param commands a Publisher stream of commands to be dispatched\n          \n          \n            \n                 * @return a Flux of command results. An ordering of command results corresponds to an ordering of commands being\n          \n          \n            \n                 * dispatched\n          \n          \n            \n                 * Uses the given {@link Publisher} of commands to send incoming commands away. Commands will be sent sequentially. Once the\n          \n          \n            \n                 * result of the Nth command arrives, the (N + 1)th command is dispatched.\n          \n          \n            \n                 *\n          \n          \n            \n                 * @param commands a {@link Publisher} stream of commands to be dispatched\n          \n          \n            \n                 * @return a {@link Flux} of command results. The ordering of command results corresponds to the ordering of commands being\n          \n          \n            \n                 * dispatched", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r452690598", "createdAt": "2020-07-10T08:09:03Z", "author": {"login": "smcvb"}, "path": "messaging/src/main/java/org/axonframework/commandhandling/gateway/ReactorCommandGateway.java", "diffHunk": "@@ -0,0 +1,71 @@\n+/*\n+ * Copyright (c) 2010-2020. Axon Framework\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.axonframework.commandhandling.gateway;\n+\n+import org.axonframework.commandhandling.CommandBus;\n+import org.axonframework.commandhandling.CommandMessage;\n+import org.axonframework.commandhandling.CommandResultMessage;\n+import org.axonframework.messaging.Message;\n+import org.axonframework.messaging.MetaData;\n+import org.axonframework.messaging.reactive.ReactorMessageDispatchInterceptorSupport;\n+import org.axonframework.messaging.reactive.ReactorResultHandlerInterceptorSupport;\n+import org.reactivestreams.Publisher;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Mono;\n+\n+import java.util.function.Function;\n+\n+/**\n+ * Variation of {@link CommandGateway}. Provides support for reactive return type such as {@link Mono} from Project\n+ * Reactor.\n+ *\n+ * @author Milan Savic\n+ * @since 4.4\n+ */\n+public interface ReactorCommandGateway\n+        extends ReactorMessageDispatchInterceptorSupport<CommandMessage<?>>,\n+        ReactorResultHandlerInterceptorSupport<CommandMessage<?>, CommandResultMessage<?>> {\n+\n+    /**\n+     * Sends the given {@code command} once the caller subscribes to the command result. Returns immediately.\n+     * <p/>\n+     * The given {@code command} is wrapped as the payload of a {@link CommandMessage} that is eventually posted on the\n+     * {@link CommandBus}, unless the {@code command} already implements {@link Message}. In that case, a\n+     * {@code CommandMessage} is constructed from that message's payload and {@link MetaData}.\n+     *\n+     * @param command the command to dispatch\n+     * @param <R>     the type of the command result\n+     * @return a {@link Mono} which is resolved when the command is executed\n+     */\n+    <R> Mono<R> send(Object command);\n+\n+    /**\n+     * Uses given Publisher of commands to send incoming commands away. Commands will be sent sequentially - once a\n+     * result of Nth command arrives, (N + 1)th command is dispatched.\n+     *\n+     * @param commands a Publisher stream of commands to be dispatched\n+     * @return a Flux of command results. An ordering of command results corresponds to an ordering of commands being\n+     * dispatched", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "98865ab1427e4d879301c1bf542842eccc8aa3c3"}, "originalPosition": 62}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjY5MDgzOQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             * Variation of {@link EventGateway}. Provides support for reactive return types such as {@link Flux} from Project\n          \n          \n            \n             * Variation of the {@link EventGateway}, wrapping a {@link EventBus} for a friendlier API. Provides support for reactive return types such as {@link Flux} from Project", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r452690839", "createdAt": "2020-07-10T08:09:32Z", "author": {"login": "smcvb"}, "path": "messaging/src/main/java/org/axonframework/eventhandling/gateway/ReactorEventGateway.java", "diffHunk": "@@ -0,0 +1,84 @@\n+/*\n+ * Copyright (c) 2010-2020. Axon Framework\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.axonframework.eventhandling.gateway;\n+\n+import org.axonframework.eventhandling.EventBus;\n+import org.axonframework.eventhandling.EventMessage;\n+import org.axonframework.messaging.Message;\n+import org.axonframework.messaging.reactive.ReactorMessageDispatchInterceptorSupport;\n+import org.reactivestreams.Publisher;\n+import reactor.core.publisher.Flux;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+\n+/**\n+ * Variation of {@link EventGateway}. Provides support for reactive return types such as {@link Flux} from Project", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "98865ab1427e4d879301c1bf542842eccc8aa3c3"}, "originalPosition": 30}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjY5MTIyNw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * Publishes given {@code events} once the caller subscribes to the resulting Flux. Returns immediately.\n          \n          \n            \n                 * Publishes the given {@code events} once the caller subscribes to the resulting {@link Flux}. Returns immediately.", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r452691227", "createdAt": "2020-07-10T08:10:20Z", "author": {"login": "smcvb"}, "path": "messaging/src/main/java/org/axonframework/eventhandling/gateway/ReactorEventGateway.java", "diffHunk": "@@ -0,0 +1,84 @@\n+/*\n+ * Copyright (c) 2010-2020. Axon Framework\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.axonframework.eventhandling.gateway;\n+\n+import org.axonframework.eventhandling.EventBus;\n+import org.axonframework.eventhandling.EventMessage;\n+import org.axonframework.messaging.Message;\n+import org.axonframework.messaging.reactive.ReactorMessageDispatchInterceptorSupport;\n+import org.reactivestreams.Publisher;\n+import reactor.core.publisher.Flux;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+\n+/**\n+ * Variation of {@link EventGateway}. Provides support for reactive return types such as {@link Flux} from Project\n+ * Reactor.\n+ *\n+ * @author Milan Savic\n+ * @since 4.4\n+ */\n+public interface ReactorEventGateway extends ReactorMessageDispatchInterceptorSupport<EventMessage<?>> {\n+\n+    /**\n+     * Publishes given {@code events} once the caller subscribes to the resulting Flux. Returns immediately.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "98865ab1427e4d879301c1bf542842eccc8aa3c3"}, "originalPosition": 39}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjY5MTQ3MA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * Publishes given {@code events} once the caller subscribes to the resulting Flux. Returns immediately.\n          \n          \n            \n                 * Publishes the given {@code events} once the caller subscribes to the resulting {@link Flux}. Returns immediately.", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r452691470", "createdAt": "2020-07-10T08:10:53Z", "author": {"login": "smcvb"}, "path": "messaging/src/main/java/org/axonframework/eventhandling/gateway/ReactorEventGateway.java", "diffHunk": "@@ -0,0 +1,84 @@\n+/*\n+ * Copyright (c) 2010-2020. Axon Framework\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.axonframework.eventhandling.gateway;\n+\n+import org.axonframework.eventhandling.EventBus;\n+import org.axonframework.eventhandling.EventMessage;\n+import org.axonframework.messaging.Message;\n+import org.axonframework.messaging.reactive.ReactorMessageDispatchInterceptorSupport;\n+import org.reactivestreams.Publisher;\n+import reactor.core.publisher.Flux;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+\n+/**\n+ * Variation of {@link EventGateway}. Provides support for reactive return types such as {@link Flux} from Project\n+ * Reactor.\n+ *\n+ * @author Milan Savic\n+ * @since 4.4\n+ */\n+public interface ReactorEventGateway extends ReactorMessageDispatchInterceptorSupport<EventMessage<?>> {\n+\n+    /**\n+     * Publishes given {@code events} once the caller subscribes to the resulting Flux. Returns immediately.\n+     * <p/>\n+     * Given {@code events} are wrapped as payloads of a {@link EventMessage} that are eventually published on the\n+     * {@link EventBus}, unless {@code event} already implements {@link Message}. In that case, a {@code EventMessage}\n+     * is constructed from that message's payload and {@link org.axonframework.messaging.MetaData}.\n+     *\n+     * @param events events to be published\n+     * @return events that were published. DO NOTE: if there were some interceptors registered to this {@code gateway},\n+     * they will be processed first, before returning events to the caller. The order of returned events is the same as\n+     * one provided as the input parameter.\n+     */\n+    default Flux<Object> publish(Object... events) { // NOSONAR\n+        return publish(Arrays.asList(events));\n+    }\n+\n+    /**\n+     * Publishes given {@code events} once the caller subscribes to the resulting Flux. Returns immediately.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "98865ab1427e4d879301c1bf542842eccc8aa3c3"}, "originalPosition": 55}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjY5MTc3Ng==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * Publishes given {@code events} once the caller subscribes to the resulting Flux. Returns immediately.\n          \n          \n            \n                 * Publishes the given {@code events} once the caller subscribes to the resulting {@link Flux}. Returns immediately.", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r452691776", "createdAt": "2020-07-10T08:11:30Z", "author": {"login": "smcvb"}, "path": "messaging/src/main/java/org/axonframework/eventhandling/gateway/ReactorEventGateway.java", "diffHunk": "@@ -0,0 +1,84 @@\n+/*\n+ * Copyright (c) 2010-2020. Axon Framework\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.axonframework.eventhandling.gateway;\n+\n+import org.axonframework.eventhandling.EventBus;\n+import org.axonframework.eventhandling.EventMessage;\n+import org.axonframework.messaging.Message;\n+import org.axonframework.messaging.reactive.ReactorMessageDispatchInterceptorSupport;\n+import org.reactivestreams.Publisher;\n+import reactor.core.publisher.Flux;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+\n+/**\n+ * Variation of {@link EventGateway}. Provides support for reactive return types such as {@link Flux} from Project\n+ * Reactor.\n+ *\n+ * @author Milan Savic\n+ * @since 4.4\n+ */\n+public interface ReactorEventGateway extends ReactorMessageDispatchInterceptorSupport<EventMessage<?>> {\n+\n+    /**\n+     * Publishes given {@code events} once the caller subscribes to the resulting Flux. Returns immediately.\n+     * <p/>\n+     * Given {@code events} are wrapped as payloads of a {@link EventMessage} that are eventually published on the\n+     * {@link EventBus}, unless {@code event} already implements {@link Message}. In that case, a {@code EventMessage}\n+     * is constructed from that message's payload and {@link org.axonframework.messaging.MetaData}.\n+     *\n+     * @param events events to be published\n+     * @return events that were published. DO NOTE: if there were some interceptors registered to this {@code gateway},\n+     * they will be processed first, before returning events to the caller. The order of returned events is the same as\n+     * one provided as the input parameter.\n+     */\n+    default Flux<Object> publish(Object... events) { // NOSONAR\n+        return publish(Arrays.asList(events));\n+    }\n+\n+    /**\n+     * Publishes given {@code events} once the caller subscribes to the resulting Flux. Returns immediately.\n+     * <p/>\n+     * Given {@code events} are wrapped as payloads of a {@link EventMessage} that are eventually published on the\n+     * {@link EventBus}, unless {@code event} already implements {@link Message}. In that case, a {@code EventMessage}\n+     * is constructed from that message's payload and {@link org.axonframework.messaging.MetaData}.\n+     *\n+     * @param events the list of events to be published\n+     * @return events that were published. DO NOTE: if there were some interceptors registered to this {@code gateway},\n+     * they will be processed first, before returning events to the caller. The order of returned events is the same as\n+     * one provided as the input parameter.\n+     */\n+    Flux<Object> publish(List<?> events);\n+\n+    /**\n+     * Publishes given {@code events} once the caller subscribes to the resulting Flux. Returns immediately.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "98865ab1427e4d879301c1bf542842eccc8aa3c3"}, "originalPosition": 69}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjY5MjEyOA==", "bodyText": "Nit: Slightly doubtful on this, but might be nice to reference the MessageDispatchInterceptor instead of just stating interceptors.", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r452692128", "createdAt": "2020-07-10T08:12:13Z", "author": {"login": "smcvb"}, "path": "messaging/src/main/java/org/axonframework/eventhandling/gateway/ReactorEventGateway.java", "diffHunk": "@@ -0,0 +1,84 @@\n+/*\n+ * Copyright (c) 2010-2020. Axon Framework\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.axonframework.eventhandling.gateway;\n+\n+import org.axonframework.eventhandling.EventBus;\n+import org.axonframework.eventhandling.EventMessage;\n+import org.axonframework.messaging.Message;\n+import org.axonframework.messaging.reactive.ReactorMessageDispatchInterceptorSupport;\n+import org.reactivestreams.Publisher;\n+import reactor.core.publisher.Flux;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+\n+/**\n+ * Variation of {@link EventGateway}. Provides support for reactive return types such as {@link Flux} from Project\n+ * Reactor.\n+ *\n+ * @author Milan Savic\n+ * @since 4.4\n+ */\n+public interface ReactorEventGateway extends ReactorMessageDispatchInterceptorSupport<EventMessage<?>> {\n+\n+    /**\n+     * Publishes given {@code events} once the caller subscribes to the resulting Flux. Returns immediately.\n+     * <p/>\n+     * Given {@code events} are wrapped as payloads of a {@link EventMessage} that are eventually published on the\n+     * {@link EventBus}, unless {@code event} already implements {@link Message}. In that case, a {@code EventMessage}\n+     * is constructed from that message's payload and {@link org.axonframework.messaging.MetaData}.\n+     *\n+     * @param events events to be published\n+     * @return events that were published. DO NOTE: if there were some interceptors registered to this {@code gateway},", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "98865ab1427e4d879301c1bf542842eccc8aa3c3"}, "originalPosition": 46}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjY5MjY5Mg==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             * Interceptor that allows messages to be intercepted and modified before they are dispatched. Implementations are\n          \n          \n            \n             * required to provide a function that modifies a {@link Mono} of a message and returns a modified/new {@code Mono} to\n          \n          \n            \n             * be passed down the interceptor chain or to be dispatched. This way we provide a reactive approach to intercepting\n          \n          \n            \n             * messages.\n          \n          \n            \n             * Interceptor that allows messages to be intercepted and modified before they are dispatched. Implementations are\n          \n          \n            \n             * required to provide a function that modifies a {@link Mono} of a message and returns a modified/new {@code Mono} to\n          \n          \n            \n             * be passed down the interceptor chain or to be dispatched.\n          \n      \n    \n    \n  \n\nAlthough that last sentence is true, I believe this speaks for itself.", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r452692692", "createdAt": "2020-07-10T08:13:27Z", "author": {"login": "smcvb"}, "path": "messaging/src/main/java/org/axonframework/messaging/reactive/ReactorMessageDispatchInterceptor.java", "diffHunk": "@@ -0,0 +1,53 @@\n+/*\n+ * Copyright (c) 2010-2020. Axon Framework\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.axonframework.messaging.reactive;\n+\n+import org.axonframework.messaging.Message;\n+import org.axonframework.messaging.MessageDispatchInterceptor;\n+import reactor.core.publisher.Mono;\n+\n+import java.util.List;\n+import java.util.function.BiFunction;\n+\n+/**\n+ * Interceptor that allows messages to be intercepted and modified before they are dispatched. Implementations are\n+ * required to provide a function that modifies a {@link Mono} of a message and returns a modified/new {@code Mono} to\n+ * be passed down the interceptor chain or to be dispatched. This way we provide a reactive approach to intercepting\n+ * messages.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "98865ab1427e4d879301c1bf542842eccc8aa3c3"}, "originalPosition": 30}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjY5MzI2OA==", "bodyText": "Added, would it make sense to state something like the following in the class level javadoc too:\nThis interceptor provides a very early means to alter or reject Messages, even before any Unit of Work is created.", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r452693268", "createdAt": "2020-07-10T08:14:38Z", "author": {"login": "smcvb"}, "path": "messaging/src/main/java/org/axonframework/messaging/reactive/ReactorMessageDispatchInterceptor.java", "diffHunk": "@@ -0,0 +1,53 @@\n+/*\n+ * Copyright (c) 2010-2020. Axon Framework\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.axonframework.messaging.reactive;\n+\n+import org.axonframework.messaging.Message;\n+import org.axonframework.messaging.MessageDispatchInterceptor;\n+import reactor.core.publisher.Mono;\n+\n+import java.util.List;\n+import java.util.function.BiFunction;\n+\n+/**\n+ * Interceptor that allows messages to be intercepted and modified before they are dispatched. Implementations are\n+ * required to provide a function that modifies a {@link Mono} of a message and returns a modified/new {@code Mono} to\n+ * be passed down the interceptor chain or to be dispatched. This way we provide a reactive approach to intercepting\n+ * messages.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjY5MjY5Mg=="}, "originalCommit": {"oid": "98865ab1427e4d879301c1bf542842eccc8aa3c3"}, "originalPosition": 30}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjY5NDIyNQ==", "bodyText": "Curious: why would you break a result message chain?", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r452694225", "createdAt": "2020-07-10T08:16:26Z", "author": {"login": "smcvb"}, "path": "messaging/src/main/java/org/axonframework/messaging/reactive/ReactorResultHandlerInterceptor.java", "diffHunk": "@@ -0,0 +1,45 @@\n+/*\n+ * Copyright (c) 2010-2020. Axon Framework\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.axonframework.messaging.reactive;\n+\n+import org.axonframework.messaging.Message;\n+import org.axonframework.messaging.ResultMessage;\n+import reactor.core.publisher.Flux;\n+\n+/**\n+ * Interceptor that allows results to be intercepted and modified before they are handled. Implementations are required\n+ * to operate on a {@link Flux} of results or return a new {@link Flux} which will be passed down the interceptor chain.\n+ * Also, implementations may make decisions based on the message that was dispatched.\n+ *\n+ * @param <M> The type of the message for which the result is going to be intercepted\n+ * @param <R> The type of the result to be intercepted\n+ * @author Sara Pellegrini\n+ * @since 4.4\n+ */\n+@FunctionalInterface\n+public interface ReactorResultHandlerInterceptor<M extends Message<?>, R extends ResultMessage<?>> {\n+\n+    /**\n+     * Intercepts result messages. It's possible to break the interceptor chain by returning {@link Flux#empty()} or", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "98865ab1427e4d879301c1bf542842eccc8aa3c3"}, "originalPosition": 37}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjY5NDY3NQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * @param results results of a dispatched message\n          \n          \n            \n                 * @return intercepted results\n          \n          \n            \n                 * @param results the outcome of the dispatched {@code message}\n          \n          \n            \n                 * @return the intercepted {@code results}", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r452694675", "createdAt": "2020-07-10T08:17:21Z", "author": {"login": "smcvb"}, "path": "messaging/src/main/java/org/axonframework/messaging/reactive/ReactorResultHandlerInterceptor.java", "diffHunk": "@@ -0,0 +1,45 @@\n+/*\n+ * Copyright (c) 2010-2020. Axon Framework\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.axonframework.messaging.reactive;\n+\n+import org.axonframework.messaging.Message;\n+import org.axonframework.messaging.ResultMessage;\n+import reactor.core.publisher.Flux;\n+\n+/**\n+ * Interceptor that allows results to be intercepted and modified before they are handled. Implementations are required\n+ * to operate on a {@link Flux} of results or return a new {@link Flux} which will be passed down the interceptor chain.\n+ * Also, implementations may make decisions based on the message that was dispatched.\n+ *\n+ * @param <M> The type of the message for which the result is going to be intercepted\n+ * @param <R> The type of the result to be intercepted\n+ * @author Sara Pellegrini\n+ * @since 4.4\n+ */\n+@FunctionalInterface\n+public interface ReactorResultHandlerInterceptor<M extends Message<?>, R extends ResultMessage<?>> {\n+\n+    /**\n+     * Intercepts result messages. It's possible to break the interceptor chain by returning {@link Flux#empty()} or\n+     * {@link Flux#error(Throwable)} variations.\n+     *\n+     * @param message a message that was dispatched (and caused these {@code results})\n+     * @param results results of a dispatched message\n+     * @return intercepted results", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "98865ab1427e4d879301c1bf542842eccc8aa3c3"}, "originalPosition": 42}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjY5NTIxOA==", "bodyText": "Have you verified this serialVersionUID is the actual serialVersionUID used prior to having specified it?", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r452695218", "createdAt": "2020-07-10T08:18:33Z", "author": {"login": "smcvb"}, "path": "messaging/src/main/java/org/axonframework/messaging/responsetypes/ConvertingResponseMessage.java", "diffHunk": "@@ -21,6 +21,7 @@\n  */\n public class ConvertingResponseMessage<R> implements QueryResponseMessage<R> {\n \n+    private static final long serialVersionUID = -8926628997626431513L;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "98865ab1427e4d879301c1bf542842eccc8aa3c3"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjY5NTI5Mg==", "bodyText": "Have you verified this serialVersionUID is the actual serialVersionUID used prior to having specified it?", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r452695292", "createdAt": "2020-07-10T08:18:43Z", "author": {"login": "smcvb"}, "path": "axon-server-connector/src/main/java/org/axonframework/axonserver/connector/query/subscription/GrpcBackedQueryUpdateMessage.java", "diffHunk": "@@ -36,8 +38,10 @@\n  */\n class GrpcBackedQueryUpdateMessage<U> implements SubscriptionQueryUpdateMessage<U> {\n \n+    private static final long serialVersionUID = 488652969630034329L;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "98865ab1427e4d879301c1bf542842eccc8aa3c3"}, "originalPosition": 20}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjY5NjU2Nw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             * Variation of {@link QueryGateway}. Provides support for reactive return types such as {@link Mono} and {@link Flux}\n          \n          \n            \n             * Variation of the {@link QueryGateway}, wrapping a {@link QueryBus} for a friendlier API. Provides support for reactive return types such as {@link Mono} and {@link Flux}", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r452696567", "createdAt": "2020-07-10T08:21:09Z", "author": {"login": "smcvb"}, "path": "messaging/src/main/java/org/axonframework/queryhandling/ReactorQueryGateway.java", "diffHunk": "@@ -0,0 +1,547 @@\n+/*\n+ * Copyright (c) 2010-2020. Axon Framework\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.axonframework.queryhandling;\n+\n+import org.axonframework.messaging.ResultMessage;\n+import org.axonframework.messaging.reactive.ReactorMessageDispatchInterceptorSupport;\n+import org.axonframework.messaging.reactive.ReactorResultHandlerInterceptorSupport;\n+import org.axonframework.messaging.responsetypes.ResponseType;\n+import org.axonframework.messaging.responsetypes.ResponseTypes;\n+import org.reactivestreams.Publisher;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Mono;\n+import reactor.util.concurrent.Queues;\n+\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Function;\n+\n+/**\n+ * Variation of {@link QueryGateway}. Provides support for reactive return types such as {@link Mono} and {@link Flux}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "98865ab1427e4d879301c1bf542842eccc8aa3c3"}, "originalPosition": 33}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjcwNTE5OA==", "bodyText": "You should take into account that the query given here might be a QueryMessage implementation. Thus simply doing query.getClass().getName() might result in QueryMessage as the result, which is not it's intended purpose. I'd recommend to use the QueryMessage#queryName(Object) method to figure out the actual queryName to provider here.", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r452705198", "createdAt": "2020-07-10T08:38:05Z", "author": {"login": "smcvb"}, "path": "messaging/src/main/java/org/axonframework/queryhandling/ReactorQueryGateway.java", "diffHunk": "@@ -0,0 +1,547 @@\n+/*\n+ * Copyright (c) 2010-2020. Axon Framework\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.axonframework.queryhandling;\n+\n+import org.axonframework.messaging.ResultMessage;\n+import org.axonframework.messaging.reactive.ReactorMessageDispatchInterceptorSupport;\n+import org.axonframework.messaging.reactive.ReactorResultHandlerInterceptorSupport;\n+import org.axonframework.messaging.responsetypes.ResponseType;\n+import org.axonframework.messaging.responsetypes.ResponseTypes;\n+import org.reactivestreams.Publisher;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Mono;\n+import reactor.util.concurrent.Queues;\n+\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Function;\n+\n+/**\n+ * Variation of {@link QueryGateway}. Provides support for reactive return types such as {@link Mono} and {@link Flux}\n+ * from Project Reactor.\n+ *\n+ * @author Milan Savic\n+ * @since 4.4\n+ */\n+public interface ReactorQueryGateway extends ReactorMessageDispatchInterceptorSupport<QueryMessage<?, ?>>,\n+        ReactorResultHandlerInterceptorSupport<QueryMessage<?, ?>, ResultMessage<?>> {\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response with the given {@code responseType}\n+     * from a single source. The query name will be derived from the provided {@code query}. Execution may be\n+     * asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param query        The {@code query} to be sent\n+     * @param responseType A {@link Class} describing the desired response type\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(Q query, Class<R> responseType) {\n+        return query(query.getClass().getName(), query, responseType);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "98865ab1427e4d879301c1bf542842eccc8aa3c3"}, "originalPosition": 56}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjcwNTk0Mg==", "bodyText": "You should take into account that the query given here might be a QueryMessage implementation. Thus simply doing query.getClass().getName() might result in QueryMessage as the result, which is not it's intended purpose. I'd recommend to use the QueryMessage#queryName(Object) method to figure out the actual queryName to provider here.", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r452705942", "createdAt": "2020-07-10T08:39:36Z", "author": {"login": "smcvb"}, "path": "messaging/src/main/java/org/axonframework/queryhandling/ReactorQueryGateway.java", "diffHunk": "@@ -0,0 +1,547 @@\n+/*\n+ * Copyright (c) 2010-2020. Axon Framework\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.axonframework.queryhandling;\n+\n+import org.axonframework.messaging.ResultMessage;\n+import org.axonframework.messaging.reactive.ReactorMessageDispatchInterceptorSupport;\n+import org.axonframework.messaging.reactive.ReactorResultHandlerInterceptorSupport;\n+import org.axonframework.messaging.responsetypes.ResponseType;\n+import org.axonframework.messaging.responsetypes.ResponseTypes;\n+import org.reactivestreams.Publisher;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Mono;\n+import reactor.util.concurrent.Queues;\n+\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Function;\n+\n+/**\n+ * Variation of {@link QueryGateway}. Provides support for reactive return types such as {@link Mono} and {@link Flux}\n+ * from Project Reactor.\n+ *\n+ * @author Milan Savic\n+ * @since 4.4\n+ */\n+public interface ReactorQueryGateway extends ReactorMessageDispatchInterceptorSupport<QueryMessage<?, ?>>,\n+        ReactorResultHandlerInterceptorSupport<QueryMessage<?, ?>, ResultMessage<?>> {\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response with the given {@code responseType}\n+     * from a single source. The query name will be derived from the provided {@code query}. Execution may be\n+     * asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param query        The {@code query} to be sent\n+     * @param responseType A {@link Class} describing the desired response type\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(Q query, Class<R> responseType) {\n+        return query(query.getClass().getName(), query, responseType);\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response with the given {@code responseType}\n+     * from a single source. Execution may be asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(String queryName, Q query, Class<R> responseType) {\n+        return query(queryName, query, ResponseTypes.instanceOf(responseType));\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from a single source. The query name will be derived from the provided {@code query}. Execution may be\n+     * asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(Q query, ResponseType<R> responseType) {\n+        return query(query.getClass().getName(), query, responseType);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "98865ab1427e4d879301c1bf542842eccc8aa3c3"}, "originalPosition": 90}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjcwNzE4Nw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * Uses given Publisher of query messages to send incoming queries away. Queries will be sent sequentially - once a\n          \n          \n            \n                 * result of Nth query arrives, (N + 1)th query is dispatched.\n          \n          \n            \n                 *\n          \n          \n            \n                 * @param queries a Publisher stream of queries to be dispatched\n          \n          \n            \n                 * @return a Flux of query results. An ordering of query results corresponds to an ordering of queries being\n          \n          \n            \n                 * dispatched\n          \n          \n            \n                 * Use the given {@link Publisher} of {@link QueryMessage}s to send the incoming queries away. Queries will be sent sequentially. Once the\n          \n          \n            \n                 * result of the Nth query arrives, the (N + 1)th query is dispatched.\n          \n          \n            \n                 *\n          \n          \n            \n                 * @param queries a {@link Publisher} stream of queries to be dispatched\n          \n          \n            \n                 * @return a {@link Flux} of query results. The ordering of query results corresponds to the ordering of queries being\n          \n          \n            \n                 * dispatched", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r452707187", "createdAt": "2020-07-10T08:41:57Z", "author": {"login": "smcvb"}, "path": "messaging/src/main/java/org/axonframework/queryhandling/ReactorQueryGateway.java", "diffHunk": "@@ -0,0 +1,547 @@\n+/*\n+ * Copyright (c) 2010-2020. Axon Framework\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.axonframework.queryhandling;\n+\n+import org.axonframework.messaging.ResultMessage;\n+import org.axonframework.messaging.reactive.ReactorMessageDispatchInterceptorSupport;\n+import org.axonframework.messaging.reactive.ReactorResultHandlerInterceptorSupport;\n+import org.axonframework.messaging.responsetypes.ResponseType;\n+import org.axonframework.messaging.responsetypes.ResponseTypes;\n+import org.reactivestreams.Publisher;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Mono;\n+import reactor.util.concurrent.Queues;\n+\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Function;\n+\n+/**\n+ * Variation of {@link QueryGateway}. Provides support for reactive return types such as {@link Mono} and {@link Flux}\n+ * from Project Reactor.\n+ *\n+ * @author Milan Savic\n+ * @since 4.4\n+ */\n+public interface ReactorQueryGateway extends ReactorMessageDispatchInterceptorSupport<QueryMessage<?, ?>>,\n+        ReactorResultHandlerInterceptorSupport<QueryMessage<?, ?>, ResultMessage<?>> {\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response with the given {@code responseType}\n+     * from a single source. The query name will be derived from the provided {@code query}. Execution may be\n+     * asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param query        The {@code query} to be sent\n+     * @param responseType A {@link Class} describing the desired response type\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(Q query, Class<R> responseType) {\n+        return query(query.getClass().getName(), query, responseType);\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response with the given {@code responseType}\n+     * from a single source. Execution may be asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(String queryName, Q query, Class<R> responseType) {\n+        return query(queryName, query, ResponseTypes.instanceOf(responseType));\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from a single source. The query name will be derived from the provided {@code query}. Execution may be\n+     * asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(Q query, ResponseType<R> responseType) {\n+        return query(query.getClass().getName(), query, responseType);\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from a single source. Execution may be asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    <R, Q> Mono<R> query(String queryName, Q query, ResponseType<R> responseType);\n+\n+    /**\n+     * Uses given Publisher of query messages to send incoming queries away. Queries will be sent sequentially - once a\n+     * result of Nth query arrives, (N + 1)th query is dispatched.\n+     *\n+     * @param queries a Publisher stream of queries to be dispatched\n+     * @return a Flux of query results. An ordering of query results corresponds to an ordering of queries being\n+     * dispatched", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "98865ab1427e4d879301c1bf542842eccc8aa3c3"}, "originalPosition": 114}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjcwNzU4Mg==", "bodyText": "You should take into account that the query given here might be a QueryMessage implementation. Thus simply doing query.getClass().getName() might result in QueryMessage as the result, which is not it's intended purpose. I'd recommend to use the QueryMessage#queryName(Object) method to figure out the actual queryName to provider here.", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r452707582", "createdAt": "2020-07-10T08:42:46Z", "author": {"login": "smcvb"}, "path": "messaging/src/main/java/org/axonframework/queryhandling/ReactorQueryGateway.java", "diffHunk": "@@ -0,0 +1,547 @@\n+/*\n+ * Copyright (c) 2010-2020. Axon Framework\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.axonframework.queryhandling;\n+\n+import org.axonframework.messaging.ResultMessage;\n+import org.axonframework.messaging.reactive.ReactorMessageDispatchInterceptorSupport;\n+import org.axonframework.messaging.reactive.ReactorResultHandlerInterceptorSupport;\n+import org.axonframework.messaging.responsetypes.ResponseType;\n+import org.axonframework.messaging.responsetypes.ResponseTypes;\n+import org.reactivestreams.Publisher;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Mono;\n+import reactor.util.concurrent.Queues;\n+\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Function;\n+\n+/**\n+ * Variation of {@link QueryGateway}. Provides support for reactive return types such as {@link Mono} and {@link Flux}\n+ * from Project Reactor.\n+ *\n+ * @author Milan Savic\n+ * @since 4.4\n+ */\n+public interface ReactorQueryGateway extends ReactorMessageDispatchInterceptorSupport<QueryMessage<?, ?>>,\n+        ReactorResultHandlerInterceptorSupport<QueryMessage<?, ?>, ResultMessage<?>> {\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response with the given {@code responseType}\n+     * from a single source. The query name will be derived from the provided {@code query}. Execution may be\n+     * asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param query        The {@code query} to be sent\n+     * @param responseType A {@link Class} describing the desired response type\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(Q query, Class<R> responseType) {\n+        return query(query.getClass().getName(), query, responseType);\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response with the given {@code responseType}\n+     * from a single source. Execution may be asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(String queryName, Q query, Class<R> responseType) {\n+        return query(queryName, query, ResponseTypes.instanceOf(responseType));\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from a single source. The query name will be derived from the provided {@code query}. Execution may be\n+     * asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(Q query, ResponseType<R> responseType) {\n+        return query(query.getClass().getName(), query, responseType);\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from a single source. Execution may be asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    <R, Q> Mono<R> query(String queryName, Q query, ResponseType<R> responseType);\n+\n+    /**\n+     * Uses given Publisher of query messages to send incoming queries away. Queries will be sent sequentially - once a\n+     * result of Nth query arrives, (N + 1)th query is dispatched.\n+     *\n+     * @param queries a Publisher stream of queries to be dispatched\n+     * @return a Flux of query results. An ordering of query results corresponds to an ordering of queries being\n+     * dispatched\n+     *\n+     * @see #query(String, Object, ResponseType)\n+     * @see Flux#concatMap(Function)\n+     */\n+    default Flux<Object> query(Publisher<QueryMessage<?, ?>> queries) {\n+        return Flux.from(queries)\n+                   .concatMap(q -> query(q.getQueryName(), q.getPayload(), q.getResponseType()));\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from several sources. The returned {@link Flux} is completed when a {@code timeout} occurs or when all possible\n+     * results are received. The query name will be derived from the provided {@code query}. Execution may be\n+     * asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     * <b>Note</b>: Any {@code null} results will be filtered out by the {@link ReactorQueryGateway}. If you require\n+     * the {@code null} to be returned, we suggest using {@code QueryBus} instead.\n+     *\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param timeout      A timeout of {@code long} for the query\n+     * @param timeUnit     The selected {@link TimeUnit} for the given {@code timeout}\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Flux} containing the query results as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Flux<R> scatterGather(Q query, ResponseType<R> responseType, long timeout, TimeUnit timeUnit) {\n+        return scatterGather(query.getClass().getName(), query, responseType, timeout, timeUnit);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "98865ab1427e4d879301c1bf542842eccc8aa3c3"}, "originalPosition": 143}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjcwODEwOQ==", "bodyText": "Using \"note\" to start two sentences in a row feels kinda off. Might be nice to rephrase this slightly.", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r452708109", "createdAt": "2020-07-10T08:43:48Z", "author": {"login": "smcvb"}, "path": "messaging/src/main/java/org/axonframework/queryhandling/ReactorQueryGateway.java", "diffHunk": "@@ -0,0 +1,547 @@\n+/*\n+ * Copyright (c) 2010-2020. Axon Framework\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.axonframework.queryhandling;\n+\n+import org.axonframework.messaging.ResultMessage;\n+import org.axonframework.messaging.reactive.ReactorMessageDispatchInterceptorSupport;\n+import org.axonframework.messaging.reactive.ReactorResultHandlerInterceptorSupport;\n+import org.axonframework.messaging.responsetypes.ResponseType;\n+import org.axonframework.messaging.responsetypes.ResponseTypes;\n+import org.reactivestreams.Publisher;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Mono;\n+import reactor.util.concurrent.Queues;\n+\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Function;\n+\n+/**\n+ * Variation of {@link QueryGateway}. Provides support for reactive return types such as {@link Mono} and {@link Flux}\n+ * from Project Reactor.\n+ *\n+ * @author Milan Savic\n+ * @since 4.4\n+ */\n+public interface ReactorQueryGateway extends ReactorMessageDispatchInterceptorSupport<QueryMessage<?, ?>>,\n+        ReactorResultHandlerInterceptorSupport<QueryMessage<?, ?>, ResultMessage<?>> {\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response with the given {@code responseType}\n+     * from a single source. The query name will be derived from the provided {@code query}. Execution may be\n+     * asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param query        The {@code query} to be sent\n+     * @param responseType A {@link Class} describing the desired response type\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(Q query, Class<R> responseType) {\n+        return query(query.getClass().getName(), query, responseType);\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response with the given {@code responseType}\n+     * from a single source. Execution may be asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(String queryName, Q query, Class<R> responseType) {\n+        return query(queryName, query, ResponseTypes.instanceOf(responseType));\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from a single source. The query name will be derived from the provided {@code query}. Execution may be\n+     * asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(Q query, ResponseType<R> responseType) {\n+        return query(query.getClass().getName(), query, responseType);\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from a single source. Execution may be asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    <R, Q> Mono<R> query(String queryName, Q query, ResponseType<R> responseType);\n+\n+    /**\n+     * Uses given Publisher of query messages to send incoming queries away. Queries will be sent sequentially - once a\n+     * result of Nth query arrives, (N + 1)th query is dispatched.\n+     *\n+     * @param queries a Publisher stream of queries to be dispatched\n+     * @return a Flux of query results. An ordering of query results corresponds to an ordering of queries being\n+     * dispatched\n+     *\n+     * @see #query(String, Object, ResponseType)\n+     * @see Flux#concatMap(Function)\n+     */\n+    default Flux<Object> query(Publisher<QueryMessage<?, ?>> queries) {\n+        return Flux.from(queries)\n+                   .concatMap(q -> query(q.getQueryName(), q.getPayload(), q.getResponseType()));\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from several sources. The returned {@link Flux} is completed when a {@code timeout} occurs or when all possible\n+     * results are received. The query name will be derived from the provided {@code query}. Execution may be\n+     * asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     * <b>Note</b>: Any {@code null} results will be filtered out by the {@link ReactorQueryGateway}. If you require\n+     * the {@code null} to be returned, we suggest using {@code QueryBus} instead.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "98865ab1427e4d879301c1bf542842eccc8aa3c3"}, "originalPosition": 132}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjcwODk2NQ==", "bodyText": "Using \"note\" to start two sentences in a row feels kinda off. Might be nice to rephrase this slightly.", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r452708965", "createdAt": "2020-07-10T08:45:23Z", "author": {"login": "smcvb"}, "path": "messaging/src/main/java/org/axonframework/queryhandling/ReactorQueryGateway.java", "diffHunk": "@@ -0,0 +1,547 @@\n+/*\n+ * Copyright (c) 2010-2020. Axon Framework\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.axonframework.queryhandling;\n+\n+import org.axonframework.messaging.ResultMessage;\n+import org.axonframework.messaging.reactive.ReactorMessageDispatchInterceptorSupport;\n+import org.axonframework.messaging.reactive.ReactorResultHandlerInterceptorSupport;\n+import org.axonframework.messaging.responsetypes.ResponseType;\n+import org.axonframework.messaging.responsetypes.ResponseTypes;\n+import org.reactivestreams.Publisher;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Mono;\n+import reactor.util.concurrent.Queues;\n+\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Function;\n+\n+/**\n+ * Variation of {@link QueryGateway}. Provides support for reactive return types such as {@link Mono} and {@link Flux}\n+ * from Project Reactor.\n+ *\n+ * @author Milan Savic\n+ * @since 4.4\n+ */\n+public interface ReactorQueryGateway extends ReactorMessageDispatchInterceptorSupport<QueryMessage<?, ?>>,\n+        ReactorResultHandlerInterceptorSupport<QueryMessage<?, ?>, ResultMessage<?>> {\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response with the given {@code responseType}\n+     * from a single source. The query name will be derived from the provided {@code query}. Execution may be\n+     * asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param query        The {@code query} to be sent\n+     * @param responseType A {@link Class} describing the desired response type\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(Q query, Class<R> responseType) {\n+        return query(query.getClass().getName(), query, responseType);\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response with the given {@code responseType}\n+     * from a single source. Execution may be asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(String queryName, Q query, Class<R> responseType) {\n+        return query(queryName, query, ResponseTypes.instanceOf(responseType));\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from a single source. The query name will be derived from the provided {@code query}. Execution may be\n+     * asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(Q query, ResponseType<R> responseType) {\n+        return query(query.getClass().getName(), query, responseType);\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from a single source. Execution may be asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    <R, Q> Mono<R> query(String queryName, Q query, ResponseType<R> responseType);\n+\n+    /**\n+     * Uses given Publisher of query messages to send incoming queries away. Queries will be sent sequentially - once a\n+     * result of Nth query arrives, (N + 1)th query is dispatched.\n+     *\n+     * @param queries a Publisher stream of queries to be dispatched\n+     * @return a Flux of query results. An ordering of query results corresponds to an ordering of queries being\n+     * dispatched\n+     *\n+     * @see #query(String, Object, ResponseType)\n+     * @see Flux#concatMap(Function)\n+     */\n+    default Flux<Object> query(Publisher<QueryMessage<?, ?>> queries) {\n+        return Flux.from(queries)\n+                   .concatMap(q -> query(q.getQueryName(), q.getPayload(), q.getResponseType()));\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from several sources. The returned {@link Flux} is completed when a {@code timeout} occurs or when all possible\n+     * results are received. The query name will be derived from the provided {@code query}. Execution may be\n+     * asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     * <b>Note</b>: Any {@code null} results will be filtered out by the {@link ReactorQueryGateway}. If you require\n+     * the {@code null} to be returned, we suggest using {@code QueryBus} instead.\n+     *\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param timeout      A timeout of {@code long} for the query\n+     * @param timeUnit     The selected {@link TimeUnit} for the given {@code timeout}\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Flux} containing the query results as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Flux<R> scatterGather(Q query, ResponseType<R> responseType, long timeout, TimeUnit timeUnit) {\n+        return scatterGather(query.getClass().getName(), query, responseType, timeout, timeUnit);\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from several sources. The returned {@link Flux} is completed when a {@code timeout} occurs or when all results\n+     * are received. Execution may be asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     * <b>Note</b>: Any {@code null} results will be filtered out by the {@link ReactorQueryGateway}. If you require\n+     * the {@code null} to be returned, we suggest using {@code QueryBus} instead.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "98865ab1427e4d879301c1bf542842eccc8aa3c3"}, "originalPosition": 153}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjcwOTY2Nw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * Uses given Publisher of queries to send incoming queries in scatter gather manner. Queries will be sent\n          \n          \n            \n                 * sequentially - once a result of Nth query arrives, (N + 1)th query is dispatched. All queries will be dispatched\n          \n          \n            \n                 * using given {@code timeout} and {@code timeUnit}.\n          \n          \n            \n                 *\n          \n          \n            \n                 * @param queries  a Publisher stream of queries to be dispatched\n          \n          \n            \n                 * @param timeout  A timeout of {@code long} for the query\n          \n          \n            \n                 * @param timeUnit The selected {@link TimeUnit} for the given {@code timeout}\n          \n          \n            \n                 * @return a Flux of query results. An ordering of query results corresponds to an ordering of queries being\n          \n          \n            \n                 * dispatched\n          \n          \n            \n                 * Uses the given {@link Publisher} of {@link QueryMessage}s to send incoming queries in scatter gather manner. Queries will be sent\n          \n          \n            \n                 * sequentially. Once the result of Nth query arrives, the (N + 1)th query is dispatched. All queries will be dispatched\n          \n          \n            \n                 * using given {@code timeout} and {@code timeUnit}.\n          \n          \n            \n                 *\n          \n          \n            \n                 * @param queries  a {@link Publisher} stream of queries to be dispatched\n          \n          \n            \n                 * @param timeout  A timeout of {@code long} for the query\n          \n          \n            \n                 * @param timeUnit The selected {@link TimeUnit} for the given {@code timeout}\n          \n          \n            \n                 * @return a {@link Flux} of query results. The ordering of query results corresponds to the ordering of queries being\n          \n          \n            \n                 * dispatched", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r452709667", "createdAt": "2020-07-10T08:46:42Z", "author": {"login": "smcvb"}, "path": "messaging/src/main/java/org/axonframework/queryhandling/ReactorQueryGateway.java", "diffHunk": "@@ -0,0 +1,547 @@\n+/*\n+ * Copyright (c) 2010-2020. Axon Framework\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.axonframework.queryhandling;\n+\n+import org.axonframework.messaging.ResultMessage;\n+import org.axonframework.messaging.reactive.ReactorMessageDispatchInterceptorSupport;\n+import org.axonframework.messaging.reactive.ReactorResultHandlerInterceptorSupport;\n+import org.axonframework.messaging.responsetypes.ResponseType;\n+import org.axonframework.messaging.responsetypes.ResponseTypes;\n+import org.reactivestreams.Publisher;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Mono;\n+import reactor.util.concurrent.Queues;\n+\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Function;\n+\n+/**\n+ * Variation of {@link QueryGateway}. Provides support for reactive return types such as {@link Mono} and {@link Flux}\n+ * from Project Reactor.\n+ *\n+ * @author Milan Savic\n+ * @since 4.4\n+ */\n+public interface ReactorQueryGateway extends ReactorMessageDispatchInterceptorSupport<QueryMessage<?, ?>>,\n+        ReactorResultHandlerInterceptorSupport<QueryMessage<?, ?>, ResultMessage<?>> {\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response with the given {@code responseType}\n+     * from a single source. The query name will be derived from the provided {@code query}. Execution may be\n+     * asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param query        The {@code query} to be sent\n+     * @param responseType A {@link Class} describing the desired response type\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(Q query, Class<R> responseType) {\n+        return query(query.getClass().getName(), query, responseType);\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response with the given {@code responseType}\n+     * from a single source. Execution may be asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(String queryName, Q query, Class<R> responseType) {\n+        return query(queryName, query, ResponseTypes.instanceOf(responseType));\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from a single source. The query name will be derived from the provided {@code query}. Execution may be\n+     * asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(Q query, ResponseType<R> responseType) {\n+        return query(query.getClass().getName(), query, responseType);\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from a single source. Execution may be asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    <R, Q> Mono<R> query(String queryName, Q query, ResponseType<R> responseType);\n+\n+    /**\n+     * Uses given Publisher of query messages to send incoming queries away. Queries will be sent sequentially - once a\n+     * result of Nth query arrives, (N + 1)th query is dispatched.\n+     *\n+     * @param queries a Publisher stream of queries to be dispatched\n+     * @return a Flux of query results. An ordering of query results corresponds to an ordering of queries being\n+     * dispatched\n+     *\n+     * @see #query(String, Object, ResponseType)\n+     * @see Flux#concatMap(Function)\n+     */\n+    default Flux<Object> query(Publisher<QueryMessage<?, ?>> queries) {\n+        return Flux.from(queries)\n+                   .concatMap(q -> query(q.getQueryName(), q.getPayload(), q.getResponseType()));\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from several sources. The returned {@link Flux} is completed when a {@code timeout} occurs or when all possible\n+     * results are received. The query name will be derived from the provided {@code query}. Execution may be\n+     * asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     * <b>Note</b>: Any {@code null} results will be filtered out by the {@link ReactorQueryGateway}. If you require\n+     * the {@code null} to be returned, we suggest using {@code QueryBus} instead.\n+     *\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param timeout      A timeout of {@code long} for the query\n+     * @param timeUnit     The selected {@link TimeUnit} for the given {@code timeout}\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Flux} containing the query results as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Flux<R> scatterGather(Q query, ResponseType<R> responseType, long timeout, TimeUnit timeUnit) {\n+        return scatterGather(query.getClass().getName(), query, responseType, timeout, timeUnit);\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from several sources. The returned {@link Flux} is completed when a {@code timeout} occurs or when all results\n+     * are received. Execution may be asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     * <b>Note</b>: Any {@code null} results will be filtered out by the {@link ReactorQueryGateway}. If you require\n+     * the {@code null} to be returned, we suggest using {@code QueryBus} instead.\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param timeout      A timeout of {@code long} for the query\n+     * @param timeUnit     The selected {@link TimeUnit} for the given {@code timeout}\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Flux} containing the query results as dictated by the given {@code responseType}\n+     */\n+    <R, Q> Flux<R> scatterGather(String queryName, Q query, ResponseType<R> responseType, long timeout,\n+                                 TimeUnit timeUnit);\n+\n+    /**\n+     * Uses given Publisher of queries to send incoming queries in scatter gather manner. Queries will be sent\n+     * sequentially - once a result of Nth query arrives, (N + 1)th query is dispatched. All queries will be dispatched\n+     * using given {@code timeout} and {@code timeUnit}.\n+     *\n+     * @param queries  a Publisher stream of queries to be dispatched\n+     * @param timeout  A timeout of {@code long} for the query\n+     * @param timeUnit The selected {@link TimeUnit} for the given {@code timeout}\n+     * @return a Flux of query results. An ordering of query results corresponds to an ordering of queries being\n+     * dispatched", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "98865ab1427e4d879301c1bf542842eccc8aa3c3"}, "originalPosition": 176}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjcxMDE0Mg==", "bodyText": "Why is there no reference to the concatMap operation, like on the Flux<Object> query(Publisher<QueryMessage<?, ?>> queries) javadoc?", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r452710142", "createdAt": "2020-07-10T08:47:40Z", "author": {"login": "smcvb"}, "path": "messaging/src/main/java/org/axonframework/queryhandling/ReactorQueryGateway.java", "diffHunk": "@@ -0,0 +1,547 @@\n+/*\n+ * Copyright (c) 2010-2020. Axon Framework\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.axonframework.queryhandling;\n+\n+import org.axonframework.messaging.ResultMessage;\n+import org.axonframework.messaging.reactive.ReactorMessageDispatchInterceptorSupport;\n+import org.axonframework.messaging.reactive.ReactorResultHandlerInterceptorSupport;\n+import org.axonframework.messaging.responsetypes.ResponseType;\n+import org.axonframework.messaging.responsetypes.ResponseTypes;\n+import org.reactivestreams.Publisher;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Mono;\n+import reactor.util.concurrent.Queues;\n+\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Function;\n+\n+/**\n+ * Variation of {@link QueryGateway}. Provides support for reactive return types such as {@link Mono} and {@link Flux}\n+ * from Project Reactor.\n+ *\n+ * @author Milan Savic\n+ * @since 4.4\n+ */\n+public interface ReactorQueryGateway extends ReactorMessageDispatchInterceptorSupport<QueryMessage<?, ?>>,\n+        ReactorResultHandlerInterceptorSupport<QueryMessage<?, ?>, ResultMessage<?>> {\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response with the given {@code responseType}\n+     * from a single source. The query name will be derived from the provided {@code query}. Execution may be\n+     * asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param query        The {@code query} to be sent\n+     * @param responseType A {@link Class} describing the desired response type\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(Q query, Class<R> responseType) {\n+        return query(query.getClass().getName(), query, responseType);\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response with the given {@code responseType}\n+     * from a single source. Execution may be asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(String queryName, Q query, Class<R> responseType) {\n+        return query(queryName, query, ResponseTypes.instanceOf(responseType));\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from a single source. The query name will be derived from the provided {@code query}. Execution may be\n+     * asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(Q query, ResponseType<R> responseType) {\n+        return query(query.getClass().getName(), query, responseType);\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from a single source. Execution may be asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    <R, Q> Mono<R> query(String queryName, Q query, ResponseType<R> responseType);\n+\n+    /**\n+     * Uses given Publisher of query messages to send incoming queries away. Queries will be sent sequentially - once a\n+     * result of Nth query arrives, (N + 1)th query is dispatched.\n+     *\n+     * @param queries a Publisher stream of queries to be dispatched\n+     * @return a Flux of query results. An ordering of query results corresponds to an ordering of queries being\n+     * dispatched\n+     *\n+     * @see #query(String, Object, ResponseType)\n+     * @see Flux#concatMap(Function)\n+     */\n+    default Flux<Object> query(Publisher<QueryMessage<?, ?>> queries) {\n+        return Flux.from(queries)\n+                   .concatMap(q -> query(q.getQueryName(), q.getPayload(), q.getResponseType()));\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from several sources. The returned {@link Flux} is completed when a {@code timeout} occurs or when all possible\n+     * results are received. The query name will be derived from the provided {@code query}. Execution may be\n+     * asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     * <b>Note</b>: Any {@code null} results will be filtered out by the {@link ReactorQueryGateway}. If you require\n+     * the {@code null} to be returned, we suggest using {@code QueryBus} instead.\n+     *\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param timeout      A timeout of {@code long} for the query\n+     * @param timeUnit     The selected {@link TimeUnit} for the given {@code timeout}\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Flux} containing the query results as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Flux<R> scatterGather(Q query, ResponseType<R> responseType, long timeout, TimeUnit timeUnit) {\n+        return scatterGather(query.getClass().getName(), query, responseType, timeout, timeUnit);\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from several sources. The returned {@link Flux} is completed when a {@code timeout} occurs or when all results\n+     * are received. Execution may be asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     * <b>Note</b>: Any {@code null} results will be filtered out by the {@link ReactorQueryGateway}. If you require\n+     * the {@code null} to be returned, we suggest using {@code QueryBus} instead.\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param timeout      A timeout of {@code long} for the query\n+     * @param timeUnit     The selected {@link TimeUnit} for the given {@code timeout}\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Flux} containing the query results as dictated by the given {@code responseType}\n+     */\n+    <R, Q> Flux<R> scatterGather(String queryName, Q query, ResponseType<R> responseType, long timeout,\n+                                 TimeUnit timeUnit);\n+\n+    /**\n+     * Uses given Publisher of queries to send incoming queries in scatter gather manner. Queries will be sent\n+     * sequentially - once a result of Nth query arrives, (N + 1)th query is dispatched. All queries will be dispatched\n+     * using given {@code timeout} and {@code timeUnit}.\n+     *\n+     * @param queries  a Publisher stream of queries to be dispatched\n+     * @param timeout  A timeout of {@code long} for the query\n+     * @param timeUnit The selected {@link TimeUnit} for the given {@code timeout}\n+     * @return a Flux of query results. An ordering of query results corresponds to an ordering of queries being\n+     * dispatched\n+     */", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "98865ab1427e4d879301c1bf542842eccc8aa3c3"}, "originalPosition": 177}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjcxMTE0NA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * Sends the given {@code query} over the {@link QueryBus}, returns initial result and keeps streaming\n          \n          \n            \n                 * incremental updates until subscriber unsubscribes from Flux.\n          \n          \n            \n                 * Should be used when response type of initial result and incremental update match.\n          \n          \n            \n                 * Sends the given {@code query} over the {@link QueryBus}, returning the initial result and a stream of\n          \n          \n            \n                 * incremental updates until the subscriber unsubscribes from the resulting {@link Flux}.\n          \n          \n            \n                 * Should be used when the response type of the initial result and incremental update match.", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r452711144", "createdAt": "2020-07-10T08:49:46Z", "author": {"login": "smcvb"}, "path": "messaging/src/main/java/org/axonframework/queryhandling/ReactorQueryGateway.java", "diffHunk": "@@ -0,0 +1,547 @@\n+/*\n+ * Copyright (c) 2010-2020. Axon Framework\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.axonframework.queryhandling;\n+\n+import org.axonframework.messaging.ResultMessage;\n+import org.axonframework.messaging.reactive.ReactorMessageDispatchInterceptorSupport;\n+import org.axonframework.messaging.reactive.ReactorResultHandlerInterceptorSupport;\n+import org.axonframework.messaging.responsetypes.ResponseType;\n+import org.axonframework.messaging.responsetypes.ResponseTypes;\n+import org.reactivestreams.Publisher;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Mono;\n+import reactor.util.concurrent.Queues;\n+\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Function;\n+\n+/**\n+ * Variation of {@link QueryGateway}. Provides support for reactive return types such as {@link Mono} and {@link Flux}\n+ * from Project Reactor.\n+ *\n+ * @author Milan Savic\n+ * @since 4.4\n+ */\n+public interface ReactorQueryGateway extends ReactorMessageDispatchInterceptorSupport<QueryMessage<?, ?>>,\n+        ReactorResultHandlerInterceptorSupport<QueryMessage<?, ?>, ResultMessage<?>> {\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response with the given {@code responseType}\n+     * from a single source. The query name will be derived from the provided {@code query}. Execution may be\n+     * asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param query        The {@code query} to be sent\n+     * @param responseType A {@link Class} describing the desired response type\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(Q query, Class<R> responseType) {\n+        return query(query.getClass().getName(), query, responseType);\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response with the given {@code responseType}\n+     * from a single source. Execution may be asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(String queryName, Q query, Class<R> responseType) {\n+        return query(queryName, query, ResponseTypes.instanceOf(responseType));\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from a single source. The query name will be derived from the provided {@code query}. Execution may be\n+     * asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(Q query, ResponseType<R> responseType) {\n+        return query(query.getClass().getName(), query, responseType);\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from a single source. Execution may be asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    <R, Q> Mono<R> query(String queryName, Q query, ResponseType<R> responseType);\n+\n+    /**\n+     * Uses given Publisher of query messages to send incoming queries away. Queries will be sent sequentially - once a\n+     * result of Nth query arrives, (N + 1)th query is dispatched.\n+     *\n+     * @param queries a Publisher stream of queries to be dispatched\n+     * @return a Flux of query results. An ordering of query results corresponds to an ordering of queries being\n+     * dispatched\n+     *\n+     * @see #query(String, Object, ResponseType)\n+     * @see Flux#concatMap(Function)\n+     */\n+    default Flux<Object> query(Publisher<QueryMessage<?, ?>> queries) {\n+        return Flux.from(queries)\n+                   .concatMap(q -> query(q.getQueryName(), q.getPayload(), q.getResponseType()));\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from several sources. The returned {@link Flux} is completed when a {@code timeout} occurs or when all possible\n+     * results are received. The query name will be derived from the provided {@code query}. Execution may be\n+     * asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     * <b>Note</b>: Any {@code null} results will be filtered out by the {@link ReactorQueryGateway}. If you require\n+     * the {@code null} to be returned, we suggest using {@code QueryBus} instead.\n+     *\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param timeout      A timeout of {@code long} for the query\n+     * @param timeUnit     The selected {@link TimeUnit} for the given {@code timeout}\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Flux} containing the query results as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Flux<R> scatterGather(Q query, ResponseType<R> responseType, long timeout, TimeUnit timeUnit) {\n+        return scatterGather(query.getClass().getName(), query, responseType, timeout, timeUnit);\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from several sources. The returned {@link Flux} is completed when a {@code timeout} occurs or when all results\n+     * are received. Execution may be asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     * <b>Note</b>: Any {@code null} results will be filtered out by the {@link ReactorQueryGateway}. If you require\n+     * the {@code null} to be returned, we suggest using {@code QueryBus} instead.\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param timeout      A timeout of {@code long} for the query\n+     * @param timeUnit     The selected {@link TimeUnit} for the given {@code timeout}\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Flux} containing the query results as dictated by the given {@code responseType}\n+     */\n+    <R, Q> Flux<R> scatterGather(String queryName, Q query, ResponseType<R> responseType, long timeout,\n+                                 TimeUnit timeUnit);\n+\n+    /**\n+     * Uses given Publisher of queries to send incoming queries in scatter gather manner. Queries will be sent\n+     * sequentially - once a result of Nth query arrives, (N + 1)th query is dispatched. All queries will be dispatched\n+     * using given {@code timeout} and {@code timeUnit}.\n+     *\n+     * @param queries  a Publisher stream of queries to be dispatched\n+     * @param timeout  A timeout of {@code long} for the query\n+     * @param timeUnit The selected {@link TimeUnit} for the given {@code timeout}\n+     * @return a Flux of query results. An ordering of query results corresponds to an ordering of queries being\n+     * dispatched\n+     */\n+    default Flux<Object> scatterGather(Publisher<QueryMessage<?, ?>> queries, long timeout, TimeUnit timeUnit) {\n+        return Flux.from(queries)\n+                   .concatMap(q -> scatterGather(q.getQueryName(),\n+                                                 q.getPayload(),\n+                                                 q.getResponseType(),\n+                                                 timeout,\n+                                                 timeUnit));\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, returns initial result and keeps streaming\n+     * incremental updates until subscriber unsubscribes from Flux.\n+     * Should be used when response type of initial result and incremental update match.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "98865ab1427e4d879301c1bf542842eccc8aa3c3"}, "originalPosition": 190}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjcxMTMyMg==", "bodyText": "Why this this sentence between brackets?", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r452711322", "createdAt": "2020-07-10T08:50:01Z", "author": {"login": "smcvb"}, "path": "messaging/src/main/java/org/axonframework/queryhandling/ReactorQueryGateway.java", "diffHunk": "@@ -0,0 +1,547 @@\n+/*\n+ * Copyright (c) 2010-2020. Axon Framework\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.axonframework.queryhandling;\n+\n+import org.axonframework.messaging.ResultMessage;\n+import org.axonframework.messaging.reactive.ReactorMessageDispatchInterceptorSupport;\n+import org.axonframework.messaging.reactive.ReactorResultHandlerInterceptorSupport;\n+import org.axonframework.messaging.responsetypes.ResponseType;\n+import org.axonframework.messaging.responsetypes.ResponseTypes;\n+import org.reactivestreams.Publisher;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Mono;\n+import reactor.util.concurrent.Queues;\n+\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Function;\n+\n+/**\n+ * Variation of {@link QueryGateway}. Provides support for reactive return types such as {@link Mono} and {@link Flux}\n+ * from Project Reactor.\n+ *\n+ * @author Milan Savic\n+ * @since 4.4\n+ */\n+public interface ReactorQueryGateway extends ReactorMessageDispatchInterceptorSupport<QueryMessage<?, ?>>,\n+        ReactorResultHandlerInterceptorSupport<QueryMessage<?, ?>, ResultMessage<?>> {\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response with the given {@code responseType}\n+     * from a single source. The query name will be derived from the provided {@code query}. Execution may be\n+     * asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param query        The {@code query} to be sent\n+     * @param responseType A {@link Class} describing the desired response type\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(Q query, Class<R> responseType) {\n+        return query(query.getClass().getName(), query, responseType);\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response with the given {@code responseType}\n+     * from a single source. Execution may be asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(String queryName, Q query, Class<R> responseType) {\n+        return query(queryName, query, ResponseTypes.instanceOf(responseType));\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from a single source. The query name will be derived from the provided {@code query}. Execution may be\n+     * asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(Q query, ResponseType<R> responseType) {\n+        return query(query.getClass().getName(), query, responseType);\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from a single source. Execution may be asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    <R, Q> Mono<R> query(String queryName, Q query, ResponseType<R> responseType);\n+\n+    /**\n+     * Uses given Publisher of query messages to send incoming queries away. Queries will be sent sequentially - once a\n+     * result of Nth query arrives, (N + 1)th query is dispatched.\n+     *\n+     * @param queries a Publisher stream of queries to be dispatched\n+     * @return a Flux of query results. An ordering of query results corresponds to an ordering of queries being\n+     * dispatched\n+     *\n+     * @see #query(String, Object, ResponseType)\n+     * @see Flux#concatMap(Function)\n+     */\n+    default Flux<Object> query(Publisher<QueryMessage<?, ?>> queries) {\n+        return Flux.from(queries)\n+                   .concatMap(q -> query(q.getQueryName(), q.getPayload(), q.getResponseType()));\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from several sources. The returned {@link Flux} is completed when a {@code timeout} occurs or when all possible\n+     * results are received. The query name will be derived from the provided {@code query}. Execution may be\n+     * asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     * <b>Note</b>: Any {@code null} results will be filtered out by the {@link ReactorQueryGateway}. If you require\n+     * the {@code null} to be returned, we suggest using {@code QueryBus} instead.\n+     *\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param timeout      A timeout of {@code long} for the query\n+     * @param timeUnit     The selected {@link TimeUnit} for the given {@code timeout}\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Flux} containing the query results as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Flux<R> scatterGather(Q query, ResponseType<R> responseType, long timeout, TimeUnit timeUnit) {\n+        return scatterGather(query.getClass().getName(), query, responseType, timeout, timeUnit);\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from several sources. The returned {@link Flux} is completed when a {@code timeout} occurs or when all results\n+     * are received. Execution may be asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     * <b>Note</b>: Any {@code null} results will be filtered out by the {@link ReactorQueryGateway}. If you require\n+     * the {@code null} to be returned, we suggest using {@code QueryBus} instead.\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param timeout      A timeout of {@code long} for the query\n+     * @param timeUnit     The selected {@link TimeUnit} for the given {@code timeout}\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Flux} containing the query results as dictated by the given {@code responseType}\n+     */\n+    <R, Q> Flux<R> scatterGather(String queryName, Q query, ResponseType<R> responseType, long timeout,\n+                                 TimeUnit timeUnit);\n+\n+    /**\n+     * Uses given Publisher of queries to send incoming queries in scatter gather manner. Queries will be sent\n+     * sequentially - once a result of Nth query arrives, (N + 1)th query is dispatched. All queries will be dispatched\n+     * using given {@code timeout} and {@code timeUnit}.\n+     *\n+     * @param queries  a Publisher stream of queries to be dispatched\n+     * @param timeout  A timeout of {@code long} for the query\n+     * @param timeUnit The selected {@link TimeUnit} for the given {@code timeout}\n+     * @return a Flux of query results. An ordering of query results corresponds to an ordering of queries being\n+     * dispatched\n+     */\n+    default Flux<Object> scatterGather(Publisher<QueryMessage<?, ?>> queries, long timeout, TimeUnit timeUnit) {\n+        return Flux.from(queries)\n+                   .concatMap(q -> scatterGather(q.getQueryName(),\n+                                                 q.getPayload(),\n+                                                 q.getResponseType(),\n+                                                 timeout,\n+                                                 timeUnit));\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, returns initial result and keeps streaming\n+     * incremental updates until subscriber unsubscribes from Flux.\n+     * Should be used when response type of initial result and incremental update match.\n+     * (received at the moment the query is sent, until it is cancelled by the caller or closed by the emitting side).", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "98865ab1427e4d879301c1bf542842eccc8aa3c3"}, "originalPosition": 191}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjcxMTU5Mg==", "bodyText": "Using \"note\" to start two sentences in a row feels kinda off. Might be nice to rephrase this slightly.", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r452711592", "createdAt": "2020-07-10T08:50:33Z", "author": {"login": "smcvb"}, "path": "messaging/src/main/java/org/axonframework/queryhandling/ReactorQueryGateway.java", "diffHunk": "@@ -0,0 +1,547 @@\n+/*\n+ * Copyright (c) 2010-2020. Axon Framework\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.axonframework.queryhandling;\n+\n+import org.axonframework.messaging.ResultMessage;\n+import org.axonframework.messaging.reactive.ReactorMessageDispatchInterceptorSupport;\n+import org.axonframework.messaging.reactive.ReactorResultHandlerInterceptorSupport;\n+import org.axonframework.messaging.responsetypes.ResponseType;\n+import org.axonframework.messaging.responsetypes.ResponseTypes;\n+import org.reactivestreams.Publisher;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Mono;\n+import reactor.util.concurrent.Queues;\n+\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Function;\n+\n+/**\n+ * Variation of {@link QueryGateway}. Provides support for reactive return types such as {@link Mono} and {@link Flux}\n+ * from Project Reactor.\n+ *\n+ * @author Milan Savic\n+ * @since 4.4\n+ */\n+public interface ReactorQueryGateway extends ReactorMessageDispatchInterceptorSupport<QueryMessage<?, ?>>,\n+        ReactorResultHandlerInterceptorSupport<QueryMessage<?, ?>, ResultMessage<?>> {\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response with the given {@code responseType}\n+     * from a single source. The query name will be derived from the provided {@code query}. Execution may be\n+     * asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param query        The {@code query} to be sent\n+     * @param responseType A {@link Class} describing the desired response type\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(Q query, Class<R> responseType) {\n+        return query(query.getClass().getName(), query, responseType);\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response with the given {@code responseType}\n+     * from a single source. Execution may be asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(String queryName, Q query, Class<R> responseType) {\n+        return query(queryName, query, ResponseTypes.instanceOf(responseType));\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from a single source. The query name will be derived from the provided {@code query}. Execution may be\n+     * asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(Q query, ResponseType<R> responseType) {\n+        return query(query.getClass().getName(), query, responseType);\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from a single source. Execution may be asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    <R, Q> Mono<R> query(String queryName, Q query, ResponseType<R> responseType);\n+\n+    /**\n+     * Uses given Publisher of query messages to send incoming queries away. Queries will be sent sequentially - once a\n+     * result of Nth query arrives, (N + 1)th query is dispatched.\n+     *\n+     * @param queries a Publisher stream of queries to be dispatched\n+     * @return a Flux of query results. An ordering of query results corresponds to an ordering of queries being\n+     * dispatched\n+     *\n+     * @see #query(String, Object, ResponseType)\n+     * @see Flux#concatMap(Function)\n+     */\n+    default Flux<Object> query(Publisher<QueryMessage<?, ?>> queries) {\n+        return Flux.from(queries)\n+                   .concatMap(q -> query(q.getQueryName(), q.getPayload(), q.getResponseType()));\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from several sources. The returned {@link Flux} is completed when a {@code timeout} occurs or when all possible\n+     * results are received. The query name will be derived from the provided {@code query}. Execution may be\n+     * asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     * <b>Note</b>: Any {@code null} results will be filtered out by the {@link ReactorQueryGateway}. If you require\n+     * the {@code null} to be returned, we suggest using {@code QueryBus} instead.\n+     *\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param timeout      A timeout of {@code long} for the query\n+     * @param timeUnit     The selected {@link TimeUnit} for the given {@code timeout}\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Flux} containing the query results as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Flux<R> scatterGather(Q query, ResponseType<R> responseType, long timeout, TimeUnit timeUnit) {\n+        return scatterGather(query.getClass().getName(), query, responseType, timeout, timeUnit);\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from several sources. The returned {@link Flux} is completed when a {@code timeout} occurs or when all results\n+     * are received. Execution may be asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     * <b>Note</b>: Any {@code null} results will be filtered out by the {@link ReactorQueryGateway}. If you require\n+     * the {@code null} to be returned, we suggest using {@code QueryBus} instead.\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param timeout      A timeout of {@code long} for the query\n+     * @param timeUnit     The selected {@link TimeUnit} for the given {@code timeout}\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Flux} containing the query results as dictated by the given {@code responseType}\n+     */\n+    <R, Q> Flux<R> scatterGather(String queryName, Q query, ResponseType<R> responseType, long timeout,\n+                                 TimeUnit timeUnit);\n+\n+    /**\n+     * Uses given Publisher of queries to send incoming queries in scatter gather manner. Queries will be sent\n+     * sequentially - once a result of Nth query arrives, (N + 1)th query is dispatched. All queries will be dispatched\n+     * using given {@code timeout} and {@code timeUnit}.\n+     *\n+     * @param queries  a Publisher stream of queries to be dispatched\n+     * @param timeout  A timeout of {@code long} for the query\n+     * @param timeUnit The selected {@link TimeUnit} for the given {@code timeout}\n+     * @return a Flux of query results. An ordering of query results corresponds to an ordering of queries being\n+     * dispatched\n+     */\n+    default Flux<Object> scatterGather(Publisher<QueryMessage<?, ?>> queries, long timeout, TimeUnit timeUnit) {\n+        return Flux.from(queries)\n+                   .concatMap(q -> scatterGather(q.getQueryName(),\n+                                                 q.getPayload(),\n+                                                 q.getResponseType(),\n+                                                 timeout,\n+                                                 timeUnit));\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, returns initial result and keeps streaming\n+     * incremental updates until subscriber unsubscribes from Flux.\n+     * Should be used when response type of initial result and incremental update match.\n+     * (received at the moment the query is sent, until it is cancelled by the caller or closed by the emitting side).\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Flux}</b></p>\n+     * <p>\n+     * <b>Note</b>: Any {@code null} results, on the initial result or the updates, will be filtered out by the\n+     * {@link ReactorQueryGateway}. If you require the {@code null} to be returned for the initial and update results,\n+     * we suggest using the {@code QueryBus} instead.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "98865ab1427e4d879301c1bf542842eccc8aa3c3"}, "originalPosition": 197}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjcxMjczNQ==", "bodyText": "The same javadoc comments I placed on the previous method apply to this guy.", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r452712735", "createdAt": "2020-07-10T08:52:43Z", "author": {"login": "smcvb"}, "path": "messaging/src/main/java/org/axonframework/queryhandling/ReactorQueryGateway.java", "diffHunk": "@@ -0,0 +1,547 @@\n+/*\n+ * Copyright (c) 2010-2020. Axon Framework\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.axonframework.queryhandling;\n+\n+import org.axonframework.messaging.ResultMessage;\n+import org.axonframework.messaging.reactive.ReactorMessageDispatchInterceptorSupport;\n+import org.axonframework.messaging.reactive.ReactorResultHandlerInterceptorSupport;\n+import org.axonframework.messaging.responsetypes.ResponseType;\n+import org.axonframework.messaging.responsetypes.ResponseTypes;\n+import org.reactivestreams.Publisher;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Mono;\n+import reactor.util.concurrent.Queues;\n+\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Function;\n+\n+/**\n+ * Variation of {@link QueryGateway}. Provides support for reactive return types such as {@link Mono} and {@link Flux}\n+ * from Project Reactor.\n+ *\n+ * @author Milan Savic\n+ * @since 4.4\n+ */\n+public interface ReactorQueryGateway extends ReactorMessageDispatchInterceptorSupport<QueryMessage<?, ?>>,\n+        ReactorResultHandlerInterceptorSupport<QueryMessage<?, ?>, ResultMessage<?>> {\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response with the given {@code responseType}\n+     * from a single source. The query name will be derived from the provided {@code query}. Execution may be\n+     * asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param query        The {@code query} to be sent\n+     * @param responseType A {@link Class} describing the desired response type\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(Q query, Class<R> responseType) {\n+        return query(query.getClass().getName(), query, responseType);\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response with the given {@code responseType}\n+     * from a single source. Execution may be asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(String queryName, Q query, Class<R> responseType) {\n+        return query(queryName, query, ResponseTypes.instanceOf(responseType));\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from a single source. The query name will be derived from the provided {@code query}. Execution may be\n+     * asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(Q query, ResponseType<R> responseType) {\n+        return query(query.getClass().getName(), query, responseType);\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from a single source. Execution may be asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    <R, Q> Mono<R> query(String queryName, Q query, ResponseType<R> responseType);\n+\n+    /**\n+     * Uses given Publisher of query messages to send incoming queries away. Queries will be sent sequentially - once a\n+     * result of Nth query arrives, (N + 1)th query is dispatched.\n+     *\n+     * @param queries a Publisher stream of queries to be dispatched\n+     * @return a Flux of query results. An ordering of query results corresponds to an ordering of queries being\n+     * dispatched\n+     *\n+     * @see #query(String, Object, ResponseType)\n+     * @see Flux#concatMap(Function)\n+     */\n+    default Flux<Object> query(Publisher<QueryMessage<?, ?>> queries) {\n+        return Flux.from(queries)\n+                   .concatMap(q -> query(q.getQueryName(), q.getPayload(), q.getResponseType()));\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from several sources. The returned {@link Flux} is completed when a {@code timeout} occurs or when all possible\n+     * results are received. The query name will be derived from the provided {@code query}. Execution may be\n+     * asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     * <b>Note</b>: Any {@code null} results will be filtered out by the {@link ReactorQueryGateway}. If you require\n+     * the {@code null} to be returned, we suggest using {@code QueryBus} instead.\n+     *\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param timeout      A timeout of {@code long} for the query\n+     * @param timeUnit     The selected {@link TimeUnit} for the given {@code timeout}\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Flux} containing the query results as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Flux<R> scatterGather(Q query, ResponseType<R> responseType, long timeout, TimeUnit timeUnit) {\n+        return scatterGather(query.getClass().getName(), query, responseType, timeout, timeUnit);\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from several sources. The returned {@link Flux} is completed when a {@code timeout} occurs or when all results\n+     * are received. Execution may be asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     * <b>Note</b>: Any {@code null} results will be filtered out by the {@link ReactorQueryGateway}. If you require\n+     * the {@code null} to be returned, we suggest using {@code QueryBus} instead.\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param timeout      A timeout of {@code long} for the query\n+     * @param timeUnit     The selected {@link TimeUnit} for the given {@code timeout}\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Flux} containing the query results as dictated by the given {@code responseType}\n+     */\n+    <R, Q> Flux<R> scatterGather(String queryName, Q query, ResponseType<R> responseType, long timeout,\n+                                 TimeUnit timeUnit);\n+\n+    /**\n+     * Uses given Publisher of queries to send incoming queries in scatter gather manner. Queries will be sent\n+     * sequentially - once a result of Nth query arrives, (N + 1)th query is dispatched. All queries will be dispatched\n+     * using given {@code timeout} and {@code timeUnit}.\n+     *\n+     * @param queries  a Publisher stream of queries to be dispatched\n+     * @param timeout  A timeout of {@code long} for the query\n+     * @param timeUnit The selected {@link TimeUnit} for the given {@code timeout}\n+     * @return a Flux of query results. An ordering of query results corresponds to an ordering of queries being\n+     * dispatched\n+     */\n+    default Flux<Object> scatterGather(Publisher<QueryMessage<?, ?>> queries, long timeout, TimeUnit timeUnit) {\n+        return Flux.from(queries)\n+                   .concatMap(q -> scatterGather(q.getQueryName(),\n+                                                 q.getPayload(),\n+                                                 q.getResponseType(),\n+                                                 timeout,\n+                                                 timeUnit));\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, returns initial result and keeps streaming\n+     * incremental updates until subscriber unsubscribes from Flux.\n+     * Should be used when response type of initial result and incremental update match.\n+     * (received at the moment the query is sent, until it is cancelled by the caller or closed by the emitting side).\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Flux}</b></p>\n+     * <p>\n+     * <b>Note</b>: Any {@code null} results, on the initial result or the updates, will be filtered out by the\n+     * {@link ReactorQueryGateway}. If you require the {@code null} to be returned for the initial and update results,\n+     * we suggest using the {@code QueryBus} instead.\n+     *\n+     * @param query      The {@code query} to be sent\n+     * @param resultType The response type used for this query\n+     * @param <Q>        The type of the query\n+     * @param <R>        The type of the result (initial & updates)\n+     * @return Flux which can be used to cancel receiving updates\n+     *\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage)\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage, SubscriptionQueryBackpressure, int)\n+     */\n+    default <Q, R> Flux<R> subscriptionQuery(Q query, ResponseType<R> resultType) {\n+        return subscriptionQuery(query, resultType, resultType)\n+                .flatMapMany(result -> result.initialResult()\n+                                             .concatWith(result.updates())\n+                                             .doFinally(signal -> result.close()));\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, returns initial result and keeps streaming", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "98865ab1427e4d879301c1bf542842eccc8aa3c3"}, "originalPosition": 216}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjcxMzI2MQ==", "bodyText": "The same javadoc comments I placed on the previous method apply to this guy.", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r452713261", "createdAt": "2020-07-10T08:53:34Z", "author": {"login": "smcvb"}, "path": "messaging/src/main/java/org/axonframework/queryhandling/ReactorQueryGateway.java", "diffHunk": "@@ -0,0 +1,547 @@\n+/*\n+ * Copyright (c) 2010-2020. Axon Framework\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.axonframework.queryhandling;\n+\n+import org.axonframework.messaging.ResultMessage;\n+import org.axonframework.messaging.reactive.ReactorMessageDispatchInterceptorSupport;\n+import org.axonframework.messaging.reactive.ReactorResultHandlerInterceptorSupport;\n+import org.axonframework.messaging.responsetypes.ResponseType;\n+import org.axonframework.messaging.responsetypes.ResponseTypes;\n+import org.reactivestreams.Publisher;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Mono;\n+import reactor.util.concurrent.Queues;\n+\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Function;\n+\n+/**\n+ * Variation of {@link QueryGateway}. Provides support for reactive return types such as {@link Mono} and {@link Flux}\n+ * from Project Reactor.\n+ *\n+ * @author Milan Savic\n+ * @since 4.4\n+ */\n+public interface ReactorQueryGateway extends ReactorMessageDispatchInterceptorSupport<QueryMessage<?, ?>>,\n+        ReactorResultHandlerInterceptorSupport<QueryMessage<?, ?>, ResultMessage<?>> {\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response with the given {@code responseType}\n+     * from a single source. The query name will be derived from the provided {@code query}. Execution may be\n+     * asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param query        The {@code query} to be sent\n+     * @param responseType A {@link Class} describing the desired response type\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(Q query, Class<R> responseType) {\n+        return query(query.getClass().getName(), query, responseType);\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response with the given {@code responseType}\n+     * from a single source. Execution may be asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(String queryName, Q query, Class<R> responseType) {\n+        return query(queryName, query, ResponseTypes.instanceOf(responseType));\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from a single source. The query name will be derived from the provided {@code query}. Execution may be\n+     * asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(Q query, ResponseType<R> responseType) {\n+        return query(query.getClass().getName(), query, responseType);\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from a single source. Execution may be asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    <R, Q> Mono<R> query(String queryName, Q query, ResponseType<R> responseType);\n+\n+    /**\n+     * Uses given Publisher of query messages to send incoming queries away. Queries will be sent sequentially - once a\n+     * result of Nth query arrives, (N + 1)th query is dispatched.\n+     *\n+     * @param queries a Publisher stream of queries to be dispatched\n+     * @return a Flux of query results. An ordering of query results corresponds to an ordering of queries being\n+     * dispatched\n+     *\n+     * @see #query(String, Object, ResponseType)\n+     * @see Flux#concatMap(Function)\n+     */\n+    default Flux<Object> query(Publisher<QueryMessage<?, ?>> queries) {\n+        return Flux.from(queries)\n+                   .concatMap(q -> query(q.getQueryName(), q.getPayload(), q.getResponseType()));\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from several sources. The returned {@link Flux} is completed when a {@code timeout} occurs or when all possible\n+     * results are received. The query name will be derived from the provided {@code query}. Execution may be\n+     * asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     * <b>Note</b>: Any {@code null} results will be filtered out by the {@link ReactorQueryGateway}. If you require\n+     * the {@code null} to be returned, we suggest using {@code QueryBus} instead.\n+     *\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param timeout      A timeout of {@code long} for the query\n+     * @param timeUnit     The selected {@link TimeUnit} for the given {@code timeout}\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Flux} containing the query results as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Flux<R> scatterGather(Q query, ResponseType<R> responseType, long timeout, TimeUnit timeUnit) {\n+        return scatterGather(query.getClass().getName(), query, responseType, timeout, timeUnit);\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from several sources. The returned {@link Flux} is completed when a {@code timeout} occurs or when all results\n+     * are received. Execution may be asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     * <b>Note</b>: Any {@code null} results will be filtered out by the {@link ReactorQueryGateway}. If you require\n+     * the {@code null} to be returned, we suggest using {@code QueryBus} instead.\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param timeout      A timeout of {@code long} for the query\n+     * @param timeUnit     The selected {@link TimeUnit} for the given {@code timeout}\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Flux} containing the query results as dictated by the given {@code responseType}\n+     */\n+    <R, Q> Flux<R> scatterGather(String queryName, Q query, ResponseType<R> responseType, long timeout,\n+                                 TimeUnit timeUnit);\n+\n+    /**\n+     * Uses given Publisher of queries to send incoming queries in scatter gather manner. Queries will be sent\n+     * sequentially - once a result of Nth query arrives, (N + 1)th query is dispatched. All queries will be dispatched\n+     * using given {@code timeout} and {@code timeUnit}.\n+     *\n+     * @param queries  a Publisher stream of queries to be dispatched\n+     * @param timeout  A timeout of {@code long} for the query\n+     * @param timeUnit The selected {@link TimeUnit} for the given {@code timeout}\n+     * @return a Flux of query results. An ordering of query results corresponds to an ordering of queries being\n+     * dispatched\n+     */\n+    default Flux<Object> scatterGather(Publisher<QueryMessage<?, ?>> queries, long timeout, TimeUnit timeUnit) {\n+        return Flux.from(queries)\n+                   .concatMap(q -> scatterGather(q.getQueryName(),\n+                                                 q.getPayload(),\n+                                                 q.getResponseType(),\n+                                                 timeout,\n+                                                 timeUnit));\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, returns initial result and keeps streaming\n+     * incremental updates until subscriber unsubscribes from Flux.\n+     * Should be used when response type of initial result and incremental update match.\n+     * (received at the moment the query is sent, until it is cancelled by the caller or closed by the emitting side).\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Flux}</b></p>\n+     * <p>\n+     * <b>Note</b>: Any {@code null} results, on the initial result or the updates, will be filtered out by the\n+     * {@link ReactorQueryGateway}. If you require the {@code null} to be returned for the initial and update results,\n+     * we suggest using the {@code QueryBus} instead.\n+     *\n+     * @param query      The {@code query} to be sent\n+     * @param resultType The response type used for this query\n+     * @param <Q>        The type of the query\n+     * @param <R>        The type of the result (initial & updates)\n+     * @return Flux which can be used to cancel receiving updates\n+     *\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage)\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage, SubscriptionQueryBackpressure, int)\n+     */\n+    default <Q, R> Flux<R> subscriptionQuery(Q query, ResponseType<R> resultType) {\n+        return subscriptionQuery(query, resultType, resultType)\n+                .flatMapMany(result -> result.initialResult()\n+                                             .concatWith(result.updates())\n+                                             .doFinally(signal -> result.close()));\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, returns initial result and keeps streaming\n+     * incremental updates until subscriber unsubscribes from Flux.\n+     * Should be used when response type of initial result and incremental update match.\n+     * (received at the moment the query is sent, until it is cancelled by the caller or closed by the emitting side).\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Flux}</b></p>\n+     * <p>\n+     * <b>Note</b>: Any {@code null} results, on the initial result or the updates, will be filtered out by the\n+     * {@link ReactorQueryGateway}. If you require the {@code null} to be returned for the initial and update results,\n+     * we suggest using the {@code QueryBus} instead.\n+     *\n+     * @param query      The {@code query} to be sent\n+     * @param resultType The response type used for this query\n+     * @param <Q>        The type of the query\n+     * @param <R>        The type of the result (initial & updates)\n+     * @return Flux which can be used to cancel receiving updates\n+     *\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage)\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage, SubscriptionQueryBackpressure, int)\n+     */\n+    default <Q, R> Flux<R> subscriptionQuery(Q query, Class<R> resultType) {\n+        return subscriptionQuery(query, ResponseTypes.instanceOf(resultType));\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, returns initial result and keeps streaming", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "98865ab1427e4d879301c1bf542842eccc8aa3c3"}, "originalPosition": 241}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjcxMzcxMg==", "bodyText": "Using \"note\" to start two sentences in a row feels kinda off. Might be nice to rephrase this slightly.", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r452713712", "createdAt": "2020-07-10T08:54:19Z", "author": {"login": "smcvb"}, "path": "messaging/src/main/java/org/axonframework/queryhandling/ReactorQueryGateway.java", "diffHunk": "@@ -0,0 +1,547 @@\n+/*\n+ * Copyright (c) 2010-2020. Axon Framework\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.axonframework.queryhandling;\n+\n+import org.axonframework.messaging.ResultMessage;\n+import org.axonframework.messaging.reactive.ReactorMessageDispatchInterceptorSupport;\n+import org.axonframework.messaging.reactive.ReactorResultHandlerInterceptorSupport;\n+import org.axonframework.messaging.responsetypes.ResponseType;\n+import org.axonframework.messaging.responsetypes.ResponseTypes;\n+import org.reactivestreams.Publisher;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Mono;\n+import reactor.util.concurrent.Queues;\n+\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Function;\n+\n+/**\n+ * Variation of {@link QueryGateway}. Provides support for reactive return types such as {@link Mono} and {@link Flux}\n+ * from Project Reactor.\n+ *\n+ * @author Milan Savic\n+ * @since 4.4\n+ */\n+public interface ReactorQueryGateway extends ReactorMessageDispatchInterceptorSupport<QueryMessage<?, ?>>,\n+        ReactorResultHandlerInterceptorSupport<QueryMessage<?, ?>, ResultMessage<?>> {\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response with the given {@code responseType}\n+     * from a single source. The query name will be derived from the provided {@code query}. Execution may be\n+     * asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param query        The {@code query} to be sent\n+     * @param responseType A {@link Class} describing the desired response type\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(Q query, Class<R> responseType) {\n+        return query(query.getClass().getName(), query, responseType);\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response with the given {@code responseType}\n+     * from a single source. Execution may be asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(String queryName, Q query, Class<R> responseType) {\n+        return query(queryName, query, ResponseTypes.instanceOf(responseType));\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from a single source. The query name will be derived from the provided {@code query}. Execution may be\n+     * asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(Q query, ResponseType<R> responseType) {\n+        return query(query.getClass().getName(), query, responseType);\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from a single source. Execution may be asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    <R, Q> Mono<R> query(String queryName, Q query, ResponseType<R> responseType);\n+\n+    /**\n+     * Uses given Publisher of query messages to send incoming queries away. Queries will be sent sequentially - once a\n+     * result of Nth query arrives, (N + 1)th query is dispatched.\n+     *\n+     * @param queries a Publisher stream of queries to be dispatched\n+     * @return a Flux of query results. An ordering of query results corresponds to an ordering of queries being\n+     * dispatched\n+     *\n+     * @see #query(String, Object, ResponseType)\n+     * @see Flux#concatMap(Function)\n+     */\n+    default Flux<Object> query(Publisher<QueryMessage<?, ?>> queries) {\n+        return Flux.from(queries)\n+                   .concatMap(q -> query(q.getQueryName(), q.getPayload(), q.getResponseType()));\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from several sources. The returned {@link Flux} is completed when a {@code timeout} occurs or when all possible\n+     * results are received. The query name will be derived from the provided {@code query}. Execution may be\n+     * asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     * <b>Note</b>: Any {@code null} results will be filtered out by the {@link ReactorQueryGateway}. If you require\n+     * the {@code null} to be returned, we suggest using {@code QueryBus} instead.\n+     *\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param timeout      A timeout of {@code long} for the query\n+     * @param timeUnit     The selected {@link TimeUnit} for the given {@code timeout}\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Flux} containing the query results as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Flux<R> scatterGather(Q query, ResponseType<R> responseType, long timeout, TimeUnit timeUnit) {\n+        return scatterGather(query.getClass().getName(), query, responseType, timeout, timeUnit);\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from several sources. The returned {@link Flux} is completed when a {@code timeout} occurs or when all results\n+     * are received. Execution may be asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     * <b>Note</b>: Any {@code null} results will be filtered out by the {@link ReactorQueryGateway}. If you require\n+     * the {@code null} to be returned, we suggest using {@code QueryBus} instead.\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param timeout      A timeout of {@code long} for the query\n+     * @param timeUnit     The selected {@link TimeUnit} for the given {@code timeout}\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Flux} containing the query results as dictated by the given {@code responseType}\n+     */\n+    <R, Q> Flux<R> scatterGather(String queryName, Q query, ResponseType<R> responseType, long timeout,\n+                                 TimeUnit timeUnit);\n+\n+    /**\n+     * Uses given Publisher of queries to send incoming queries in scatter gather manner. Queries will be sent\n+     * sequentially - once a result of Nth query arrives, (N + 1)th query is dispatched. All queries will be dispatched\n+     * using given {@code timeout} and {@code timeUnit}.\n+     *\n+     * @param queries  a Publisher stream of queries to be dispatched\n+     * @param timeout  A timeout of {@code long} for the query\n+     * @param timeUnit The selected {@link TimeUnit} for the given {@code timeout}\n+     * @return a Flux of query results. An ordering of query results corresponds to an ordering of queries being\n+     * dispatched\n+     */\n+    default Flux<Object> scatterGather(Publisher<QueryMessage<?, ?>> queries, long timeout, TimeUnit timeUnit) {\n+        return Flux.from(queries)\n+                   .concatMap(q -> scatterGather(q.getQueryName(),\n+                                                 q.getPayload(),\n+                                                 q.getResponseType(),\n+                                                 timeout,\n+                                                 timeUnit));\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, returns initial result and keeps streaming\n+     * incremental updates until subscriber unsubscribes from Flux.\n+     * Should be used when response type of initial result and incremental update match.\n+     * (received at the moment the query is sent, until it is cancelled by the caller or closed by the emitting side).\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Flux}</b></p>\n+     * <p>\n+     * <b>Note</b>: Any {@code null} results, on the initial result or the updates, will be filtered out by the\n+     * {@link ReactorQueryGateway}. If you require the {@code null} to be returned for the initial and update results,\n+     * we suggest using the {@code QueryBus} instead.\n+     *\n+     * @param query      The {@code query} to be sent\n+     * @param resultType The response type used for this query\n+     * @param <Q>        The type of the query\n+     * @param <R>        The type of the result (initial & updates)\n+     * @return Flux which can be used to cancel receiving updates\n+     *\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage)\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage, SubscriptionQueryBackpressure, int)\n+     */\n+    default <Q, R> Flux<R> subscriptionQuery(Q query, ResponseType<R> resultType) {\n+        return subscriptionQuery(query, resultType, resultType)\n+                .flatMapMany(result -> result.initialResult()\n+                                             .concatWith(result.updates())\n+                                             .doFinally(signal -> result.close()));\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, returns initial result and keeps streaming\n+     * incremental updates until subscriber unsubscribes from Flux.\n+     * Should be used when response type of initial result and incremental update match.\n+     * (received at the moment the query is sent, until it is cancelled by the caller or closed by the emitting side).\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Flux}</b></p>\n+     * <p>\n+     * <b>Note</b>: Any {@code null} results, on the initial result or the updates, will be filtered out by the\n+     * {@link ReactorQueryGateway}. If you require the {@code null} to be returned for the initial and update results,\n+     * we suggest using the {@code QueryBus} instead.\n+     *\n+     * @param query      The {@code query} to be sent\n+     * @param resultType The response type used for this query\n+     * @param <Q>        The type of the query\n+     * @param <R>        The type of the result (initial & updates)\n+     * @return Flux which can be used to cancel receiving updates\n+     *\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage)\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage, SubscriptionQueryBackpressure, int)\n+     */\n+    default <Q, R> Flux<R> subscriptionQuery(Q query, Class<R> resultType) {\n+        return subscriptionQuery(query, ResponseTypes.instanceOf(resultType));\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, returns initial result and keeps streaming\n+     * incremental updates until subscriber unsubscribes from Flux.\n+     * Should be used when initial result contains multiple instances of response type and needs to be flatten.\n+     * Response type of initial response and incremental updates needs to match.\n+     * (received at the moment the query is sent, until it is cancelled by the caller or closed by the emitting side).\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Flux}</b></p>\n+     * <p>\n+     * <b>Note</b>: Any {@code null} results, on the initial result or the updates, will be filtered out by the\n+     * {@link ReactorQueryGateway}. If you require the {@code null} to be returned for the initial and update results,\n+     * we suggest using the {@code QueryBus} instead.\n+     *\n+     * @param query      The {@code query} to be sent\n+     * @param resultType The response type used for this query\n+     * @param <Q>        The type of the query\n+     * @param <R>        The type of the result (initial & updates)\n+     * @return Flux which can be used to cancel receiving updates\n+     *\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage)\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage, SubscriptionQueryBackpressure, int)\n+     */\n+    default <Q, R> Flux<R> subscriptionQueryMany(Q query, Class<R> resultType) {\n+        return subscriptionQuery(query,\n+                                 ResponseTypes.multipleInstancesOf(resultType),\n+                                 ResponseTypes.instanceOf(resultType))\n+                .flatMapMany(result -> result.initialResult()\n+                                             .flatMapMany(Flux::fromIterable)\n+                                             .concatWith(result.updates())\n+                                             .doFinally(signal -> result.close()));\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, and streams\n+     * incremental updates until subscriber unsubscribes from Flux.\n+     * Should be used when subscriber is interested only in updates.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Flux}</b></p>\n+     * <p>\n+     * <b>Note</b>: Any {@code null} results, will be filtered out by the\n+     * {@link ReactorQueryGateway}. If you require the {@code null} to be returned for the initial and update results,\n+     * we suggest using the {@code QueryBus} instead.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "98865ab1427e4d879301c1bf542842eccc8aa3c3"}, "originalPosition": 281}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjcxNDEyNg==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * Sends the given {@code query} over the {@link QueryBus}, and streams\n          \n          \n            \n                 * incremental updates until subscriber unsubscribes from Flux.\n          \n          \n            \n                 * Should be used when subscriber is interested only in updates.\n          \n          \n            \n                 * Sends the given {@code query} over the {@link QueryBus}, streaming\n          \n          \n            \n                 * incremental updates until the subscriber unsubscribes from the resulting {@link Flux}.\n          \n          \n            \n                 * Should be used when the subscriber is interested only in updates.", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r452714126", "createdAt": "2020-07-10T08:54:59Z", "author": {"login": "smcvb"}, "path": "messaging/src/main/java/org/axonframework/queryhandling/ReactorQueryGateway.java", "diffHunk": "@@ -0,0 +1,547 @@\n+/*\n+ * Copyright (c) 2010-2020. Axon Framework\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.axonframework.queryhandling;\n+\n+import org.axonframework.messaging.ResultMessage;\n+import org.axonframework.messaging.reactive.ReactorMessageDispatchInterceptorSupport;\n+import org.axonframework.messaging.reactive.ReactorResultHandlerInterceptorSupport;\n+import org.axonframework.messaging.responsetypes.ResponseType;\n+import org.axonframework.messaging.responsetypes.ResponseTypes;\n+import org.reactivestreams.Publisher;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Mono;\n+import reactor.util.concurrent.Queues;\n+\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Function;\n+\n+/**\n+ * Variation of {@link QueryGateway}. Provides support for reactive return types such as {@link Mono} and {@link Flux}\n+ * from Project Reactor.\n+ *\n+ * @author Milan Savic\n+ * @since 4.4\n+ */\n+public interface ReactorQueryGateway extends ReactorMessageDispatchInterceptorSupport<QueryMessage<?, ?>>,\n+        ReactorResultHandlerInterceptorSupport<QueryMessage<?, ?>, ResultMessage<?>> {\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response with the given {@code responseType}\n+     * from a single source. The query name will be derived from the provided {@code query}. Execution may be\n+     * asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param query        The {@code query} to be sent\n+     * @param responseType A {@link Class} describing the desired response type\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(Q query, Class<R> responseType) {\n+        return query(query.getClass().getName(), query, responseType);\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response with the given {@code responseType}\n+     * from a single source. Execution may be asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(String queryName, Q query, Class<R> responseType) {\n+        return query(queryName, query, ResponseTypes.instanceOf(responseType));\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from a single source. The query name will be derived from the provided {@code query}. Execution may be\n+     * asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(Q query, ResponseType<R> responseType) {\n+        return query(query.getClass().getName(), query, responseType);\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from a single source. Execution may be asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    <R, Q> Mono<R> query(String queryName, Q query, ResponseType<R> responseType);\n+\n+    /**\n+     * Uses given Publisher of query messages to send incoming queries away. Queries will be sent sequentially - once a\n+     * result of Nth query arrives, (N + 1)th query is dispatched.\n+     *\n+     * @param queries a Publisher stream of queries to be dispatched\n+     * @return a Flux of query results. An ordering of query results corresponds to an ordering of queries being\n+     * dispatched\n+     *\n+     * @see #query(String, Object, ResponseType)\n+     * @see Flux#concatMap(Function)\n+     */\n+    default Flux<Object> query(Publisher<QueryMessage<?, ?>> queries) {\n+        return Flux.from(queries)\n+                   .concatMap(q -> query(q.getQueryName(), q.getPayload(), q.getResponseType()));\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from several sources. The returned {@link Flux} is completed when a {@code timeout} occurs or when all possible\n+     * results are received. The query name will be derived from the provided {@code query}. Execution may be\n+     * asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     * <b>Note</b>: Any {@code null} results will be filtered out by the {@link ReactorQueryGateway}. If you require\n+     * the {@code null} to be returned, we suggest using {@code QueryBus} instead.\n+     *\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param timeout      A timeout of {@code long} for the query\n+     * @param timeUnit     The selected {@link TimeUnit} for the given {@code timeout}\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Flux} containing the query results as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Flux<R> scatterGather(Q query, ResponseType<R> responseType, long timeout, TimeUnit timeUnit) {\n+        return scatterGather(query.getClass().getName(), query, responseType, timeout, timeUnit);\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from several sources. The returned {@link Flux} is completed when a {@code timeout} occurs or when all results\n+     * are received. Execution may be asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     * <b>Note</b>: Any {@code null} results will be filtered out by the {@link ReactorQueryGateway}. If you require\n+     * the {@code null} to be returned, we suggest using {@code QueryBus} instead.\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param timeout      A timeout of {@code long} for the query\n+     * @param timeUnit     The selected {@link TimeUnit} for the given {@code timeout}\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Flux} containing the query results as dictated by the given {@code responseType}\n+     */\n+    <R, Q> Flux<R> scatterGather(String queryName, Q query, ResponseType<R> responseType, long timeout,\n+                                 TimeUnit timeUnit);\n+\n+    /**\n+     * Uses given Publisher of queries to send incoming queries in scatter gather manner. Queries will be sent\n+     * sequentially - once a result of Nth query arrives, (N + 1)th query is dispatched. All queries will be dispatched\n+     * using given {@code timeout} and {@code timeUnit}.\n+     *\n+     * @param queries  a Publisher stream of queries to be dispatched\n+     * @param timeout  A timeout of {@code long} for the query\n+     * @param timeUnit The selected {@link TimeUnit} for the given {@code timeout}\n+     * @return a Flux of query results. An ordering of query results corresponds to an ordering of queries being\n+     * dispatched\n+     */\n+    default Flux<Object> scatterGather(Publisher<QueryMessage<?, ?>> queries, long timeout, TimeUnit timeUnit) {\n+        return Flux.from(queries)\n+                   .concatMap(q -> scatterGather(q.getQueryName(),\n+                                                 q.getPayload(),\n+                                                 q.getResponseType(),\n+                                                 timeout,\n+                                                 timeUnit));\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, returns initial result and keeps streaming\n+     * incremental updates until subscriber unsubscribes from Flux.\n+     * Should be used when response type of initial result and incremental update match.\n+     * (received at the moment the query is sent, until it is cancelled by the caller or closed by the emitting side).\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Flux}</b></p>\n+     * <p>\n+     * <b>Note</b>: Any {@code null} results, on the initial result or the updates, will be filtered out by the\n+     * {@link ReactorQueryGateway}. If you require the {@code null} to be returned for the initial and update results,\n+     * we suggest using the {@code QueryBus} instead.\n+     *\n+     * @param query      The {@code query} to be sent\n+     * @param resultType The response type used for this query\n+     * @param <Q>        The type of the query\n+     * @param <R>        The type of the result (initial & updates)\n+     * @return Flux which can be used to cancel receiving updates\n+     *\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage)\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage, SubscriptionQueryBackpressure, int)\n+     */\n+    default <Q, R> Flux<R> subscriptionQuery(Q query, ResponseType<R> resultType) {\n+        return subscriptionQuery(query, resultType, resultType)\n+                .flatMapMany(result -> result.initialResult()\n+                                             .concatWith(result.updates())\n+                                             .doFinally(signal -> result.close()));\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, returns initial result and keeps streaming\n+     * incremental updates until subscriber unsubscribes from Flux.\n+     * Should be used when response type of initial result and incremental update match.\n+     * (received at the moment the query is sent, until it is cancelled by the caller or closed by the emitting side).\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Flux}</b></p>\n+     * <p>\n+     * <b>Note</b>: Any {@code null} results, on the initial result or the updates, will be filtered out by the\n+     * {@link ReactorQueryGateway}. If you require the {@code null} to be returned for the initial and update results,\n+     * we suggest using the {@code QueryBus} instead.\n+     *\n+     * @param query      The {@code query} to be sent\n+     * @param resultType The response type used for this query\n+     * @param <Q>        The type of the query\n+     * @param <R>        The type of the result (initial & updates)\n+     * @return Flux which can be used to cancel receiving updates\n+     *\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage)\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage, SubscriptionQueryBackpressure, int)\n+     */\n+    default <Q, R> Flux<R> subscriptionQuery(Q query, Class<R> resultType) {\n+        return subscriptionQuery(query, ResponseTypes.instanceOf(resultType));\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, returns initial result and keeps streaming\n+     * incremental updates until subscriber unsubscribes from Flux.\n+     * Should be used when initial result contains multiple instances of response type and needs to be flatten.\n+     * Response type of initial response and incremental updates needs to match.\n+     * (received at the moment the query is sent, until it is cancelled by the caller or closed by the emitting side).\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Flux}</b></p>\n+     * <p>\n+     * <b>Note</b>: Any {@code null} results, on the initial result or the updates, will be filtered out by the\n+     * {@link ReactorQueryGateway}. If you require the {@code null} to be returned for the initial and update results,\n+     * we suggest using the {@code QueryBus} instead.\n+     *\n+     * @param query      The {@code query} to be sent\n+     * @param resultType The response type used for this query\n+     * @param <Q>        The type of the query\n+     * @param <R>        The type of the result (initial & updates)\n+     * @return Flux which can be used to cancel receiving updates\n+     *\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage)\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage, SubscriptionQueryBackpressure, int)\n+     */\n+    default <Q, R> Flux<R> subscriptionQueryMany(Q query, Class<R> resultType) {\n+        return subscriptionQuery(query,\n+                                 ResponseTypes.multipleInstancesOf(resultType),\n+                                 ResponseTypes.instanceOf(resultType))\n+                .flatMapMany(result -> result.initialResult()\n+                                             .flatMapMany(Flux::fromIterable)\n+                                             .concatWith(result.updates())\n+                                             .doFinally(signal -> result.close()));\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, and streams\n+     * incremental updates until subscriber unsubscribes from Flux.\n+     * Should be used when subscriber is interested only in updates.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "98865ab1427e4d879301c1bf542842eccc8aa3c3"}, "originalPosition": 275}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjcxNDU0MA==", "bodyText": "Interesting, using Void as the initial result will make it so we disregard the initial result?", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r452714540", "createdAt": "2020-07-10T08:55:39Z", "author": {"login": "smcvb"}, "path": "messaging/src/main/java/org/axonframework/queryhandling/ReactorQueryGateway.java", "diffHunk": "@@ -0,0 +1,547 @@\n+/*\n+ * Copyright (c) 2010-2020. Axon Framework\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.axonframework.queryhandling;\n+\n+import org.axonframework.messaging.ResultMessage;\n+import org.axonframework.messaging.reactive.ReactorMessageDispatchInterceptorSupport;\n+import org.axonframework.messaging.reactive.ReactorResultHandlerInterceptorSupport;\n+import org.axonframework.messaging.responsetypes.ResponseType;\n+import org.axonframework.messaging.responsetypes.ResponseTypes;\n+import org.reactivestreams.Publisher;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Mono;\n+import reactor.util.concurrent.Queues;\n+\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Function;\n+\n+/**\n+ * Variation of {@link QueryGateway}. Provides support for reactive return types such as {@link Mono} and {@link Flux}\n+ * from Project Reactor.\n+ *\n+ * @author Milan Savic\n+ * @since 4.4\n+ */\n+public interface ReactorQueryGateway extends ReactorMessageDispatchInterceptorSupport<QueryMessage<?, ?>>,\n+        ReactorResultHandlerInterceptorSupport<QueryMessage<?, ?>, ResultMessage<?>> {\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response with the given {@code responseType}\n+     * from a single source. The query name will be derived from the provided {@code query}. Execution may be\n+     * asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param query        The {@code query} to be sent\n+     * @param responseType A {@link Class} describing the desired response type\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(Q query, Class<R> responseType) {\n+        return query(query.getClass().getName(), query, responseType);\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response with the given {@code responseType}\n+     * from a single source. Execution may be asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(String queryName, Q query, Class<R> responseType) {\n+        return query(queryName, query, ResponseTypes.instanceOf(responseType));\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from a single source. The query name will be derived from the provided {@code query}. Execution may be\n+     * asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(Q query, ResponseType<R> responseType) {\n+        return query(query.getClass().getName(), query, responseType);\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from a single source. Execution may be asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    <R, Q> Mono<R> query(String queryName, Q query, ResponseType<R> responseType);\n+\n+    /**\n+     * Uses given Publisher of query messages to send incoming queries away. Queries will be sent sequentially - once a\n+     * result of Nth query arrives, (N + 1)th query is dispatched.\n+     *\n+     * @param queries a Publisher stream of queries to be dispatched\n+     * @return a Flux of query results. An ordering of query results corresponds to an ordering of queries being\n+     * dispatched\n+     *\n+     * @see #query(String, Object, ResponseType)\n+     * @see Flux#concatMap(Function)\n+     */\n+    default Flux<Object> query(Publisher<QueryMessage<?, ?>> queries) {\n+        return Flux.from(queries)\n+                   .concatMap(q -> query(q.getQueryName(), q.getPayload(), q.getResponseType()));\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from several sources. The returned {@link Flux} is completed when a {@code timeout} occurs or when all possible\n+     * results are received. The query name will be derived from the provided {@code query}. Execution may be\n+     * asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     * <b>Note</b>: Any {@code null} results will be filtered out by the {@link ReactorQueryGateway}. If you require\n+     * the {@code null} to be returned, we suggest using {@code QueryBus} instead.\n+     *\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param timeout      A timeout of {@code long} for the query\n+     * @param timeUnit     The selected {@link TimeUnit} for the given {@code timeout}\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Flux} containing the query results as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Flux<R> scatterGather(Q query, ResponseType<R> responseType, long timeout, TimeUnit timeUnit) {\n+        return scatterGather(query.getClass().getName(), query, responseType, timeout, timeUnit);\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from several sources. The returned {@link Flux} is completed when a {@code timeout} occurs or when all results\n+     * are received. Execution may be asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     * <b>Note</b>: Any {@code null} results will be filtered out by the {@link ReactorQueryGateway}. If you require\n+     * the {@code null} to be returned, we suggest using {@code QueryBus} instead.\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param timeout      A timeout of {@code long} for the query\n+     * @param timeUnit     The selected {@link TimeUnit} for the given {@code timeout}\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Flux} containing the query results as dictated by the given {@code responseType}\n+     */\n+    <R, Q> Flux<R> scatterGather(String queryName, Q query, ResponseType<R> responseType, long timeout,\n+                                 TimeUnit timeUnit);\n+\n+    /**\n+     * Uses given Publisher of queries to send incoming queries in scatter gather manner. Queries will be sent\n+     * sequentially - once a result of Nth query arrives, (N + 1)th query is dispatched. All queries will be dispatched\n+     * using given {@code timeout} and {@code timeUnit}.\n+     *\n+     * @param queries  a Publisher stream of queries to be dispatched\n+     * @param timeout  A timeout of {@code long} for the query\n+     * @param timeUnit The selected {@link TimeUnit} for the given {@code timeout}\n+     * @return a Flux of query results. An ordering of query results corresponds to an ordering of queries being\n+     * dispatched\n+     */\n+    default Flux<Object> scatterGather(Publisher<QueryMessage<?, ?>> queries, long timeout, TimeUnit timeUnit) {\n+        return Flux.from(queries)\n+                   .concatMap(q -> scatterGather(q.getQueryName(),\n+                                                 q.getPayload(),\n+                                                 q.getResponseType(),\n+                                                 timeout,\n+                                                 timeUnit));\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, returns initial result and keeps streaming\n+     * incremental updates until subscriber unsubscribes from Flux.\n+     * Should be used when response type of initial result and incremental update match.\n+     * (received at the moment the query is sent, until it is cancelled by the caller or closed by the emitting side).\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Flux}</b></p>\n+     * <p>\n+     * <b>Note</b>: Any {@code null} results, on the initial result or the updates, will be filtered out by the\n+     * {@link ReactorQueryGateway}. If you require the {@code null} to be returned for the initial and update results,\n+     * we suggest using the {@code QueryBus} instead.\n+     *\n+     * @param query      The {@code query} to be sent\n+     * @param resultType The response type used for this query\n+     * @param <Q>        The type of the query\n+     * @param <R>        The type of the result (initial & updates)\n+     * @return Flux which can be used to cancel receiving updates\n+     *\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage)\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage, SubscriptionQueryBackpressure, int)\n+     */\n+    default <Q, R> Flux<R> subscriptionQuery(Q query, ResponseType<R> resultType) {\n+        return subscriptionQuery(query, resultType, resultType)\n+                .flatMapMany(result -> result.initialResult()\n+                                             .concatWith(result.updates())\n+                                             .doFinally(signal -> result.close()));\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, returns initial result and keeps streaming\n+     * incremental updates until subscriber unsubscribes from Flux.\n+     * Should be used when response type of initial result and incremental update match.\n+     * (received at the moment the query is sent, until it is cancelled by the caller or closed by the emitting side).\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Flux}</b></p>\n+     * <p>\n+     * <b>Note</b>: Any {@code null} results, on the initial result or the updates, will be filtered out by the\n+     * {@link ReactorQueryGateway}. If you require the {@code null} to be returned for the initial and update results,\n+     * we suggest using the {@code QueryBus} instead.\n+     *\n+     * @param query      The {@code query} to be sent\n+     * @param resultType The response type used for this query\n+     * @param <Q>        The type of the query\n+     * @param <R>        The type of the result (initial & updates)\n+     * @return Flux which can be used to cancel receiving updates\n+     *\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage)\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage, SubscriptionQueryBackpressure, int)\n+     */\n+    default <Q, R> Flux<R> subscriptionQuery(Q query, Class<R> resultType) {\n+        return subscriptionQuery(query, ResponseTypes.instanceOf(resultType));\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, returns initial result and keeps streaming\n+     * incremental updates until subscriber unsubscribes from Flux.\n+     * Should be used when initial result contains multiple instances of response type and needs to be flatten.\n+     * Response type of initial response and incremental updates needs to match.\n+     * (received at the moment the query is sent, until it is cancelled by the caller or closed by the emitting side).\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Flux}</b></p>\n+     * <p>\n+     * <b>Note</b>: Any {@code null} results, on the initial result or the updates, will be filtered out by the\n+     * {@link ReactorQueryGateway}. If you require the {@code null} to be returned for the initial and update results,\n+     * we suggest using the {@code QueryBus} instead.\n+     *\n+     * @param query      The {@code query} to be sent\n+     * @param resultType The response type used for this query\n+     * @param <Q>        The type of the query\n+     * @param <R>        The type of the result (initial & updates)\n+     * @return Flux which can be used to cancel receiving updates\n+     *\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage)\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage, SubscriptionQueryBackpressure, int)\n+     */\n+    default <Q, R> Flux<R> subscriptionQueryMany(Q query, Class<R> resultType) {\n+        return subscriptionQuery(query,\n+                                 ResponseTypes.multipleInstancesOf(resultType),\n+                                 ResponseTypes.instanceOf(resultType))\n+                .flatMapMany(result -> result.initialResult()\n+                                             .flatMapMany(Flux::fromIterable)\n+                                             .concatWith(result.updates())\n+                                             .doFinally(signal -> result.close()));\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, and streams\n+     * incremental updates until subscriber unsubscribes from Flux.\n+     * Should be used when subscriber is interested only in updates.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Flux}</b></p>\n+     * <p>\n+     * <b>Note</b>: Any {@code null} results, will be filtered out by the\n+     * {@link ReactorQueryGateway}. If you require the {@code null} to be returned for the initial and update results,\n+     * we suggest using the {@code QueryBus} instead.\n+     *\n+     * @param query      The {@code query} to be sent\n+     * @param resultType The response type used for this query\n+     * @param <Q>        The type of the query\n+     * @param <R>        The type of the result (updates)\n+     * @return Flux which can be used to cancel receiving updates\n+     *\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage)\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage, SubscriptionQueryBackpressure, int)\n+     */\n+    default <Q, R> Flux<R> queryUpdates(Q query, ResponseType<R> resultType) {\n+        return subscriptionQuery(query, ResponseTypes.instanceOf(Void.class), resultType)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "98865ab1427e4d879301c1bf542842eccc8aa3c3"}, "originalPosition": 293}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjcxNDc1Nw==", "bodyText": "Using \"note\" to start two sentences in a row feels kinda off. Might be nice to rephrase this slightly.", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r452714757", "createdAt": "2020-07-10T08:56:01Z", "author": {"login": "smcvb"}, "path": "messaging/src/main/java/org/axonframework/queryhandling/ReactorQueryGateway.java", "diffHunk": "@@ -0,0 +1,547 @@\n+/*\n+ * Copyright (c) 2010-2020. Axon Framework\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.axonframework.queryhandling;\n+\n+import org.axonframework.messaging.ResultMessage;\n+import org.axonframework.messaging.reactive.ReactorMessageDispatchInterceptorSupport;\n+import org.axonframework.messaging.reactive.ReactorResultHandlerInterceptorSupport;\n+import org.axonframework.messaging.responsetypes.ResponseType;\n+import org.axonframework.messaging.responsetypes.ResponseTypes;\n+import org.reactivestreams.Publisher;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Mono;\n+import reactor.util.concurrent.Queues;\n+\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Function;\n+\n+/**\n+ * Variation of {@link QueryGateway}. Provides support for reactive return types such as {@link Mono} and {@link Flux}\n+ * from Project Reactor.\n+ *\n+ * @author Milan Savic\n+ * @since 4.4\n+ */\n+public interface ReactorQueryGateway extends ReactorMessageDispatchInterceptorSupport<QueryMessage<?, ?>>,\n+        ReactorResultHandlerInterceptorSupport<QueryMessage<?, ?>, ResultMessage<?>> {\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response with the given {@code responseType}\n+     * from a single source. The query name will be derived from the provided {@code query}. Execution may be\n+     * asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param query        The {@code query} to be sent\n+     * @param responseType A {@link Class} describing the desired response type\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(Q query, Class<R> responseType) {\n+        return query(query.getClass().getName(), query, responseType);\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response with the given {@code responseType}\n+     * from a single source. Execution may be asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(String queryName, Q query, Class<R> responseType) {\n+        return query(queryName, query, ResponseTypes.instanceOf(responseType));\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from a single source. The query name will be derived from the provided {@code query}. Execution may be\n+     * asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(Q query, ResponseType<R> responseType) {\n+        return query(query.getClass().getName(), query, responseType);\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from a single source. Execution may be asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    <R, Q> Mono<R> query(String queryName, Q query, ResponseType<R> responseType);\n+\n+    /**\n+     * Uses given Publisher of query messages to send incoming queries away. Queries will be sent sequentially - once a\n+     * result of Nth query arrives, (N + 1)th query is dispatched.\n+     *\n+     * @param queries a Publisher stream of queries to be dispatched\n+     * @return a Flux of query results. An ordering of query results corresponds to an ordering of queries being\n+     * dispatched\n+     *\n+     * @see #query(String, Object, ResponseType)\n+     * @see Flux#concatMap(Function)\n+     */\n+    default Flux<Object> query(Publisher<QueryMessage<?, ?>> queries) {\n+        return Flux.from(queries)\n+                   .concatMap(q -> query(q.getQueryName(), q.getPayload(), q.getResponseType()));\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from several sources. The returned {@link Flux} is completed when a {@code timeout} occurs or when all possible\n+     * results are received. The query name will be derived from the provided {@code query}. Execution may be\n+     * asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     * <b>Note</b>: Any {@code null} results will be filtered out by the {@link ReactorQueryGateway}. If you require\n+     * the {@code null} to be returned, we suggest using {@code QueryBus} instead.\n+     *\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param timeout      A timeout of {@code long} for the query\n+     * @param timeUnit     The selected {@link TimeUnit} for the given {@code timeout}\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Flux} containing the query results as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Flux<R> scatterGather(Q query, ResponseType<R> responseType, long timeout, TimeUnit timeUnit) {\n+        return scatterGather(query.getClass().getName(), query, responseType, timeout, timeUnit);\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from several sources. The returned {@link Flux} is completed when a {@code timeout} occurs or when all results\n+     * are received. Execution may be asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     * <b>Note</b>: Any {@code null} results will be filtered out by the {@link ReactorQueryGateway}. If you require\n+     * the {@code null} to be returned, we suggest using {@code QueryBus} instead.\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param timeout      A timeout of {@code long} for the query\n+     * @param timeUnit     The selected {@link TimeUnit} for the given {@code timeout}\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Flux} containing the query results as dictated by the given {@code responseType}\n+     */\n+    <R, Q> Flux<R> scatterGather(String queryName, Q query, ResponseType<R> responseType, long timeout,\n+                                 TimeUnit timeUnit);\n+\n+    /**\n+     * Uses given Publisher of queries to send incoming queries in scatter gather manner. Queries will be sent\n+     * sequentially - once a result of Nth query arrives, (N + 1)th query is dispatched. All queries will be dispatched\n+     * using given {@code timeout} and {@code timeUnit}.\n+     *\n+     * @param queries  a Publisher stream of queries to be dispatched\n+     * @param timeout  A timeout of {@code long} for the query\n+     * @param timeUnit The selected {@link TimeUnit} for the given {@code timeout}\n+     * @return a Flux of query results. An ordering of query results corresponds to an ordering of queries being\n+     * dispatched\n+     */\n+    default Flux<Object> scatterGather(Publisher<QueryMessage<?, ?>> queries, long timeout, TimeUnit timeUnit) {\n+        return Flux.from(queries)\n+                   .concatMap(q -> scatterGather(q.getQueryName(),\n+                                                 q.getPayload(),\n+                                                 q.getResponseType(),\n+                                                 timeout,\n+                                                 timeUnit));\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, returns initial result and keeps streaming\n+     * incremental updates until subscriber unsubscribes from Flux.\n+     * Should be used when response type of initial result and incremental update match.\n+     * (received at the moment the query is sent, until it is cancelled by the caller or closed by the emitting side).\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Flux}</b></p>\n+     * <p>\n+     * <b>Note</b>: Any {@code null} results, on the initial result or the updates, will be filtered out by the\n+     * {@link ReactorQueryGateway}. If you require the {@code null} to be returned for the initial and update results,\n+     * we suggest using the {@code QueryBus} instead.\n+     *\n+     * @param query      The {@code query} to be sent\n+     * @param resultType The response type used for this query\n+     * @param <Q>        The type of the query\n+     * @param <R>        The type of the result (initial & updates)\n+     * @return Flux which can be used to cancel receiving updates\n+     *\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage)\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage, SubscriptionQueryBackpressure, int)\n+     */\n+    default <Q, R> Flux<R> subscriptionQuery(Q query, ResponseType<R> resultType) {\n+        return subscriptionQuery(query, resultType, resultType)\n+                .flatMapMany(result -> result.initialResult()\n+                                             .concatWith(result.updates())\n+                                             .doFinally(signal -> result.close()));\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, returns initial result and keeps streaming\n+     * incremental updates until subscriber unsubscribes from Flux.\n+     * Should be used when response type of initial result and incremental update match.\n+     * (received at the moment the query is sent, until it is cancelled by the caller or closed by the emitting side).\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Flux}</b></p>\n+     * <p>\n+     * <b>Note</b>: Any {@code null} results, on the initial result or the updates, will be filtered out by the\n+     * {@link ReactorQueryGateway}. If you require the {@code null} to be returned for the initial and update results,\n+     * we suggest using the {@code QueryBus} instead.\n+     *\n+     * @param query      The {@code query} to be sent\n+     * @param resultType The response type used for this query\n+     * @param <Q>        The type of the query\n+     * @param <R>        The type of the result (initial & updates)\n+     * @return Flux which can be used to cancel receiving updates\n+     *\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage)\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage, SubscriptionQueryBackpressure, int)\n+     */\n+    default <Q, R> Flux<R> subscriptionQuery(Q query, Class<R> resultType) {\n+        return subscriptionQuery(query, ResponseTypes.instanceOf(resultType));\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, returns initial result and keeps streaming\n+     * incremental updates until subscriber unsubscribes from Flux.\n+     * Should be used when initial result contains multiple instances of response type and needs to be flatten.\n+     * Response type of initial response and incremental updates needs to match.\n+     * (received at the moment the query is sent, until it is cancelled by the caller or closed by the emitting side).\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Flux}</b></p>\n+     * <p>\n+     * <b>Note</b>: Any {@code null} results, on the initial result or the updates, will be filtered out by the\n+     * {@link ReactorQueryGateway}. If you require the {@code null} to be returned for the initial and update results,\n+     * we suggest using the {@code QueryBus} instead.\n+     *\n+     * @param query      The {@code query} to be sent\n+     * @param resultType The response type used for this query\n+     * @param <Q>        The type of the query\n+     * @param <R>        The type of the result (initial & updates)\n+     * @return Flux which can be used to cancel receiving updates\n+     *\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage)\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage, SubscriptionQueryBackpressure, int)\n+     */\n+    default <Q, R> Flux<R> subscriptionQueryMany(Q query, Class<R> resultType) {\n+        return subscriptionQuery(query,\n+                                 ResponseTypes.multipleInstancesOf(resultType),\n+                                 ResponseTypes.instanceOf(resultType))\n+                .flatMapMany(result -> result.initialResult()\n+                                             .flatMapMany(Flux::fromIterable)\n+                                             .concatWith(result.updates())\n+                                             .doFinally(signal -> result.close()));\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, and streams\n+     * incremental updates until subscriber unsubscribes from Flux.\n+     * Should be used when subscriber is interested only in updates.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Flux}</b></p>\n+     * <p>\n+     * <b>Note</b>: Any {@code null} results, will be filtered out by the\n+     * {@link ReactorQueryGateway}. If you require the {@code null} to be returned for the initial and update results,\n+     * we suggest using the {@code QueryBus} instead.\n+     *\n+     * @param query      The {@code query} to be sent\n+     * @param resultType The response type used for this query\n+     * @param <Q>        The type of the query\n+     * @param <R>        The type of the result (updates)\n+     * @return Flux which can be used to cancel receiving updates\n+     *\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage)\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage, SubscriptionQueryBackpressure, int)\n+     */\n+    default <Q, R> Flux<R> queryUpdates(Q query, ResponseType<R> resultType) {\n+        return subscriptionQuery(query, ResponseTypes.instanceOf(Void.class), resultType)\n+                .flatMapMany(result -> result.updates()\n+                                             .doFinally(signal -> result.close()));\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, and streams\n+     * incremental updates until subscriber unsubscribes from Flux.\n+     * Should be used when subscriber is interested only in updates.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Flux}</b></p>\n+     * <p>\n+     * <b>Note</b>: Any {@code null} results, will be filtered out by the\n+     * {@link ReactorQueryGateway}. If you require the {@code null} to be returned for the initial and update results,\n+     * we suggest using the {@code QueryBus} instead.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "98865ab1427e4d879301c1bf542842eccc8aa3c3"}, "originalPosition": 307}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjcxNDk5OA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * Sends the given {@code query} over the {@link QueryBus}, and streams\n          \n          \n            \n                 * incremental updates until subscriber unsubscribes from Flux.\n          \n          \n            \n                 * Should be used when subscriber is interested only in updates.\n          \n          \n            \n                 * Sends the given {@code query} over the {@link QueryBus}, streaming\n          \n          \n            \n                 * incremental updates until hte subscriber unsubscribes from the resulting {@link Flux}.\n          \n          \n            \n                 * Should be used when the subscriber is interested only in updates.", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r452714998", "createdAt": "2020-07-10T08:56:27Z", "author": {"login": "smcvb"}, "path": "messaging/src/main/java/org/axonframework/queryhandling/ReactorQueryGateway.java", "diffHunk": "@@ -0,0 +1,547 @@\n+/*\n+ * Copyright (c) 2010-2020. Axon Framework\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.axonframework.queryhandling;\n+\n+import org.axonframework.messaging.ResultMessage;\n+import org.axonframework.messaging.reactive.ReactorMessageDispatchInterceptorSupport;\n+import org.axonframework.messaging.reactive.ReactorResultHandlerInterceptorSupport;\n+import org.axonframework.messaging.responsetypes.ResponseType;\n+import org.axonframework.messaging.responsetypes.ResponseTypes;\n+import org.reactivestreams.Publisher;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Mono;\n+import reactor.util.concurrent.Queues;\n+\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Function;\n+\n+/**\n+ * Variation of {@link QueryGateway}. Provides support for reactive return types such as {@link Mono} and {@link Flux}\n+ * from Project Reactor.\n+ *\n+ * @author Milan Savic\n+ * @since 4.4\n+ */\n+public interface ReactorQueryGateway extends ReactorMessageDispatchInterceptorSupport<QueryMessage<?, ?>>,\n+        ReactorResultHandlerInterceptorSupport<QueryMessage<?, ?>, ResultMessage<?>> {\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response with the given {@code responseType}\n+     * from a single source. The query name will be derived from the provided {@code query}. Execution may be\n+     * asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param query        The {@code query} to be sent\n+     * @param responseType A {@link Class} describing the desired response type\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(Q query, Class<R> responseType) {\n+        return query(query.getClass().getName(), query, responseType);\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response with the given {@code responseType}\n+     * from a single source. Execution may be asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(String queryName, Q query, Class<R> responseType) {\n+        return query(queryName, query, ResponseTypes.instanceOf(responseType));\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from a single source. The query name will be derived from the provided {@code query}. Execution may be\n+     * asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(Q query, ResponseType<R> responseType) {\n+        return query(query.getClass().getName(), query, responseType);\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from a single source. Execution may be asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    <R, Q> Mono<R> query(String queryName, Q query, ResponseType<R> responseType);\n+\n+    /**\n+     * Uses given Publisher of query messages to send incoming queries away. Queries will be sent sequentially - once a\n+     * result of Nth query arrives, (N + 1)th query is dispatched.\n+     *\n+     * @param queries a Publisher stream of queries to be dispatched\n+     * @return a Flux of query results. An ordering of query results corresponds to an ordering of queries being\n+     * dispatched\n+     *\n+     * @see #query(String, Object, ResponseType)\n+     * @see Flux#concatMap(Function)\n+     */\n+    default Flux<Object> query(Publisher<QueryMessage<?, ?>> queries) {\n+        return Flux.from(queries)\n+                   .concatMap(q -> query(q.getQueryName(), q.getPayload(), q.getResponseType()));\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from several sources. The returned {@link Flux} is completed when a {@code timeout} occurs or when all possible\n+     * results are received. The query name will be derived from the provided {@code query}. Execution may be\n+     * asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     * <b>Note</b>: Any {@code null} results will be filtered out by the {@link ReactorQueryGateway}. If you require\n+     * the {@code null} to be returned, we suggest using {@code QueryBus} instead.\n+     *\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param timeout      A timeout of {@code long} for the query\n+     * @param timeUnit     The selected {@link TimeUnit} for the given {@code timeout}\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Flux} containing the query results as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Flux<R> scatterGather(Q query, ResponseType<R> responseType, long timeout, TimeUnit timeUnit) {\n+        return scatterGather(query.getClass().getName(), query, responseType, timeout, timeUnit);\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from several sources. The returned {@link Flux} is completed when a {@code timeout} occurs or when all results\n+     * are received. Execution may be asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     * <b>Note</b>: Any {@code null} results will be filtered out by the {@link ReactorQueryGateway}. If you require\n+     * the {@code null} to be returned, we suggest using {@code QueryBus} instead.\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param timeout      A timeout of {@code long} for the query\n+     * @param timeUnit     The selected {@link TimeUnit} for the given {@code timeout}\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Flux} containing the query results as dictated by the given {@code responseType}\n+     */\n+    <R, Q> Flux<R> scatterGather(String queryName, Q query, ResponseType<R> responseType, long timeout,\n+                                 TimeUnit timeUnit);\n+\n+    /**\n+     * Uses given Publisher of queries to send incoming queries in scatter gather manner. Queries will be sent\n+     * sequentially - once a result of Nth query arrives, (N + 1)th query is dispatched. All queries will be dispatched\n+     * using given {@code timeout} and {@code timeUnit}.\n+     *\n+     * @param queries  a Publisher stream of queries to be dispatched\n+     * @param timeout  A timeout of {@code long} for the query\n+     * @param timeUnit The selected {@link TimeUnit} for the given {@code timeout}\n+     * @return a Flux of query results. An ordering of query results corresponds to an ordering of queries being\n+     * dispatched\n+     */\n+    default Flux<Object> scatterGather(Publisher<QueryMessage<?, ?>> queries, long timeout, TimeUnit timeUnit) {\n+        return Flux.from(queries)\n+                   .concatMap(q -> scatterGather(q.getQueryName(),\n+                                                 q.getPayload(),\n+                                                 q.getResponseType(),\n+                                                 timeout,\n+                                                 timeUnit));\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, returns initial result and keeps streaming\n+     * incremental updates until subscriber unsubscribes from Flux.\n+     * Should be used when response type of initial result and incremental update match.\n+     * (received at the moment the query is sent, until it is cancelled by the caller or closed by the emitting side).\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Flux}</b></p>\n+     * <p>\n+     * <b>Note</b>: Any {@code null} results, on the initial result or the updates, will be filtered out by the\n+     * {@link ReactorQueryGateway}. If you require the {@code null} to be returned for the initial and update results,\n+     * we suggest using the {@code QueryBus} instead.\n+     *\n+     * @param query      The {@code query} to be sent\n+     * @param resultType The response type used for this query\n+     * @param <Q>        The type of the query\n+     * @param <R>        The type of the result (initial & updates)\n+     * @return Flux which can be used to cancel receiving updates\n+     *\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage)\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage, SubscriptionQueryBackpressure, int)\n+     */\n+    default <Q, R> Flux<R> subscriptionQuery(Q query, ResponseType<R> resultType) {\n+        return subscriptionQuery(query, resultType, resultType)\n+                .flatMapMany(result -> result.initialResult()\n+                                             .concatWith(result.updates())\n+                                             .doFinally(signal -> result.close()));\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, returns initial result and keeps streaming\n+     * incremental updates until subscriber unsubscribes from Flux.\n+     * Should be used when response type of initial result and incremental update match.\n+     * (received at the moment the query is sent, until it is cancelled by the caller or closed by the emitting side).\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Flux}</b></p>\n+     * <p>\n+     * <b>Note</b>: Any {@code null} results, on the initial result or the updates, will be filtered out by the\n+     * {@link ReactorQueryGateway}. If you require the {@code null} to be returned for the initial and update results,\n+     * we suggest using the {@code QueryBus} instead.\n+     *\n+     * @param query      The {@code query} to be sent\n+     * @param resultType The response type used for this query\n+     * @param <Q>        The type of the query\n+     * @param <R>        The type of the result (initial & updates)\n+     * @return Flux which can be used to cancel receiving updates\n+     *\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage)\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage, SubscriptionQueryBackpressure, int)\n+     */\n+    default <Q, R> Flux<R> subscriptionQuery(Q query, Class<R> resultType) {\n+        return subscriptionQuery(query, ResponseTypes.instanceOf(resultType));\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, returns initial result and keeps streaming\n+     * incremental updates until subscriber unsubscribes from Flux.\n+     * Should be used when initial result contains multiple instances of response type and needs to be flatten.\n+     * Response type of initial response and incremental updates needs to match.\n+     * (received at the moment the query is sent, until it is cancelled by the caller or closed by the emitting side).\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Flux}</b></p>\n+     * <p>\n+     * <b>Note</b>: Any {@code null} results, on the initial result or the updates, will be filtered out by the\n+     * {@link ReactorQueryGateway}. If you require the {@code null} to be returned for the initial and update results,\n+     * we suggest using the {@code QueryBus} instead.\n+     *\n+     * @param query      The {@code query} to be sent\n+     * @param resultType The response type used for this query\n+     * @param <Q>        The type of the query\n+     * @param <R>        The type of the result (initial & updates)\n+     * @return Flux which can be used to cancel receiving updates\n+     *\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage)\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage, SubscriptionQueryBackpressure, int)\n+     */\n+    default <Q, R> Flux<R> subscriptionQueryMany(Q query, Class<R> resultType) {\n+        return subscriptionQuery(query,\n+                                 ResponseTypes.multipleInstancesOf(resultType),\n+                                 ResponseTypes.instanceOf(resultType))\n+                .flatMapMany(result -> result.initialResult()\n+                                             .flatMapMany(Flux::fromIterable)\n+                                             .concatWith(result.updates())\n+                                             .doFinally(signal -> result.close()));\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, and streams\n+     * incremental updates until subscriber unsubscribes from Flux.\n+     * Should be used when subscriber is interested only in updates.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Flux}</b></p>\n+     * <p>\n+     * <b>Note</b>: Any {@code null} results, will be filtered out by the\n+     * {@link ReactorQueryGateway}. If you require the {@code null} to be returned for the initial and update results,\n+     * we suggest using the {@code QueryBus} instead.\n+     *\n+     * @param query      The {@code query} to be sent\n+     * @param resultType The response type used for this query\n+     * @param <Q>        The type of the query\n+     * @param <R>        The type of the result (updates)\n+     * @return Flux which can be used to cancel receiving updates\n+     *\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage)\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage, SubscriptionQueryBackpressure, int)\n+     */\n+    default <Q, R> Flux<R> queryUpdates(Q query, ResponseType<R> resultType) {\n+        return subscriptionQuery(query, ResponseTypes.instanceOf(Void.class), resultType)\n+                .flatMapMany(result -> result.updates()\n+                                             .doFinally(signal -> result.close()));\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, and streams\n+     * incremental updates until subscriber unsubscribes from Flux.\n+     * Should be used when subscriber is interested only in updates.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "98865ab1427e4d879301c1bf542842eccc8aa3c3"}, "originalPosition": 301}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjcxNTMwMg==", "bodyText": "You should take into account that the query given here might be a QueryMessage implementation. Thus simply doing query.getClass().getName() might result in QueryMessage as the result, which is not it's intended purpose. I'd recommend to use the QueryMessage#queryName(Object) method to figure out the actual queryName to provider here.", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r452715302", "createdAt": "2020-07-10T08:56:55Z", "author": {"login": "smcvb"}, "path": "messaging/src/main/java/org/axonframework/queryhandling/ReactorQueryGateway.java", "diffHunk": "@@ -0,0 +1,547 @@\n+/*\n+ * Copyright (c) 2010-2020. Axon Framework\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.axonframework.queryhandling;\n+\n+import org.axonframework.messaging.ResultMessage;\n+import org.axonframework.messaging.reactive.ReactorMessageDispatchInterceptorSupport;\n+import org.axonframework.messaging.reactive.ReactorResultHandlerInterceptorSupport;\n+import org.axonframework.messaging.responsetypes.ResponseType;\n+import org.axonframework.messaging.responsetypes.ResponseTypes;\n+import org.reactivestreams.Publisher;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Mono;\n+import reactor.util.concurrent.Queues;\n+\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Function;\n+\n+/**\n+ * Variation of {@link QueryGateway}. Provides support for reactive return types such as {@link Mono} and {@link Flux}\n+ * from Project Reactor.\n+ *\n+ * @author Milan Savic\n+ * @since 4.4\n+ */\n+public interface ReactorQueryGateway extends ReactorMessageDispatchInterceptorSupport<QueryMessage<?, ?>>,\n+        ReactorResultHandlerInterceptorSupport<QueryMessage<?, ?>, ResultMessage<?>> {\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response with the given {@code responseType}\n+     * from a single source. The query name will be derived from the provided {@code query}. Execution may be\n+     * asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param query        The {@code query} to be sent\n+     * @param responseType A {@link Class} describing the desired response type\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(Q query, Class<R> responseType) {\n+        return query(query.getClass().getName(), query, responseType);\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response with the given {@code responseType}\n+     * from a single source. Execution may be asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(String queryName, Q query, Class<R> responseType) {\n+        return query(queryName, query, ResponseTypes.instanceOf(responseType));\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from a single source. The query name will be derived from the provided {@code query}. Execution may be\n+     * asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(Q query, ResponseType<R> responseType) {\n+        return query(query.getClass().getName(), query, responseType);\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from a single source. Execution may be asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    <R, Q> Mono<R> query(String queryName, Q query, ResponseType<R> responseType);\n+\n+    /**\n+     * Uses given Publisher of query messages to send incoming queries away. Queries will be sent sequentially - once a\n+     * result of Nth query arrives, (N + 1)th query is dispatched.\n+     *\n+     * @param queries a Publisher stream of queries to be dispatched\n+     * @return a Flux of query results. An ordering of query results corresponds to an ordering of queries being\n+     * dispatched\n+     *\n+     * @see #query(String, Object, ResponseType)\n+     * @see Flux#concatMap(Function)\n+     */\n+    default Flux<Object> query(Publisher<QueryMessage<?, ?>> queries) {\n+        return Flux.from(queries)\n+                   .concatMap(q -> query(q.getQueryName(), q.getPayload(), q.getResponseType()));\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from several sources. The returned {@link Flux} is completed when a {@code timeout} occurs or when all possible\n+     * results are received. The query name will be derived from the provided {@code query}. Execution may be\n+     * asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     * <b>Note</b>: Any {@code null} results will be filtered out by the {@link ReactorQueryGateway}. If you require\n+     * the {@code null} to be returned, we suggest using {@code QueryBus} instead.\n+     *\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param timeout      A timeout of {@code long} for the query\n+     * @param timeUnit     The selected {@link TimeUnit} for the given {@code timeout}\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Flux} containing the query results as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Flux<R> scatterGather(Q query, ResponseType<R> responseType, long timeout, TimeUnit timeUnit) {\n+        return scatterGather(query.getClass().getName(), query, responseType, timeout, timeUnit);\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from several sources. The returned {@link Flux} is completed when a {@code timeout} occurs or when all results\n+     * are received. Execution may be asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     * <b>Note</b>: Any {@code null} results will be filtered out by the {@link ReactorQueryGateway}. If you require\n+     * the {@code null} to be returned, we suggest using {@code QueryBus} instead.\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param timeout      A timeout of {@code long} for the query\n+     * @param timeUnit     The selected {@link TimeUnit} for the given {@code timeout}\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Flux} containing the query results as dictated by the given {@code responseType}\n+     */\n+    <R, Q> Flux<R> scatterGather(String queryName, Q query, ResponseType<R> responseType, long timeout,\n+                                 TimeUnit timeUnit);\n+\n+    /**\n+     * Uses given Publisher of queries to send incoming queries in scatter gather manner. Queries will be sent\n+     * sequentially - once a result of Nth query arrives, (N + 1)th query is dispatched. All queries will be dispatched\n+     * using given {@code timeout} and {@code timeUnit}.\n+     *\n+     * @param queries  a Publisher stream of queries to be dispatched\n+     * @param timeout  A timeout of {@code long} for the query\n+     * @param timeUnit The selected {@link TimeUnit} for the given {@code timeout}\n+     * @return a Flux of query results. An ordering of query results corresponds to an ordering of queries being\n+     * dispatched\n+     */\n+    default Flux<Object> scatterGather(Publisher<QueryMessage<?, ?>> queries, long timeout, TimeUnit timeUnit) {\n+        return Flux.from(queries)\n+                   .concatMap(q -> scatterGather(q.getQueryName(),\n+                                                 q.getPayload(),\n+                                                 q.getResponseType(),\n+                                                 timeout,\n+                                                 timeUnit));\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, returns initial result and keeps streaming\n+     * incremental updates until subscriber unsubscribes from Flux.\n+     * Should be used when response type of initial result and incremental update match.\n+     * (received at the moment the query is sent, until it is cancelled by the caller or closed by the emitting side).\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Flux}</b></p>\n+     * <p>\n+     * <b>Note</b>: Any {@code null} results, on the initial result or the updates, will be filtered out by the\n+     * {@link ReactorQueryGateway}. If you require the {@code null} to be returned for the initial and update results,\n+     * we suggest using the {@code QueryBus} instead.\n+     *\n+     * @param query      The {@code query} to be sent\n+     * @param resultType The response type used for this query\n+     * @param <Q>        The type of the query\n+     * @param <R>        The type of the result (initial & updates)\n+     * @return Flux which can be used to cancel receiving updates\n+     *\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage)\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage, SubscriptionQueryBackpressure, int)\n+     */\n+    default <Q, R> Flux<R> subscriptionQuery(Q query, ResponseType<R> resultType) {\n+        return subscriptionQuery(query, resultType, resultType)\n+                .flatMapMany(result -> result.initialResult()\n+                                             .concatWith(result.updates())\n+                                             .doFinally(signal -> result.close()));\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, returns initial result and keeps streaming\n+     * incremental updates until subscriber unsubscribes from Flux.\n+     * Should be used when response type of initial result and incremental update match.\n+     * (received at the moment the query is sent, until it is cancelled by the caller or closed by the emitting side).\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Flux}</b></p>\n+     * <p>\n+     * <b>Note</b>: Any {@code null} results, on the initial result or the updates, will be filtered out by the\n+     * {@link ReactorQueryGateway}. If you require the {@code null} to be returned for the initial and update results,\n+     * we suggest using the {@code QueryBus} instead.\n+     *\n+     * @param query      The {@code query} to be sent\n+     * @param resultType The response type used for this query\n+     * @param <Q>        The type of the query\n+     * @param <R>        The type of the result (initial & updates)\n+     * @return Flux which can be used to cancel receiving updates\n+     *\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage)\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage, SubscriptionQueryBackpressure, int)\n+     */\n+    default <Q, R> Flux<R> subscriptionQuery(Q query, Class<R> resultType) {\n+        return subscriptionQuery(query, ResponseTypes.instanceOf(resultType));\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, returns initial result and keeps streaming\n+     * incremental updates until subscriber unsubscribes from Flux.\n+     * Should be used when initial result contains multiple instances of response type and needs to be flatten.\n+     * Response type of initial response and incremental updates needs to match.\n+     * (received at the moment the query is sent, until it is cancelled by the caller or closed by the emitting side).\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Flux}</b></p>\n+     * <p>\n+     * <b>Note</b>: Any {@code null} results, on the initial result or the updates, will be filtered out by the\n+     * {@link ReactorQueryGateway}. If you require the {@code null} to be returned for the initial and update results,\n+     * we suggest using the {@code QueryBus} instead.\n+     *\n+     * @param query      The {@code query} to be sent\n+     * @param resultType The response type used for this query\n+     * @param <Q>        The type of the query\n+     * @param <R>        The type of the result (initial & updates)\n+     * @return Flux which can be used to cancel receiving updates\n+     *\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage)\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage, SubscriptionQueryBackpressure, int)\n+     */\n+    default <Q, R> Flux<R> subscriptionQueryMany(Q query, Class<R> resultType) {\n+        return subscriptionQuery(query,\n+                                 ResponseTypes.multipleInstancesOf(resultType),\n+                                 ResponseTypes.instanceOf(resultType))\n+                .flatMapMany(result -> result.initialResult()\n+                                             .flatMapMany(Flux::fromIterable)\n+                                             .concatWith(result.updates())\n+                                             .doFinally(signal -> result.close()));\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, and streams\n+     * incremental updates until subscriber unsubscribes from Flux.\n+     * Should be used when subscriber is interested only in updates.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Flux}</b></p>\n+     * <p>\n+     * <b>Note</b>: Any {@code null} results, will be filtered out by the\n+     * {@link ReactorQueryGateway}. If you require the {@code null} to be returned for the initial and update results,\n+     * we suggest using the {@code QueryBus} instead.\n+     *\n+     * @param query      The {@code query} to be sent\n+     * @param resultType The response type used for this query\n+     * @param <Q>        The type of the query\n+     * @param <R>        The type of the result (updates)\n+     * @return Flux which can be used to cancel receiving updates\n+     *\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage)\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage, SubscriptionQueryBackpressure, int)\n+     */\n+    default <Q, R> Flux<R> queryUpdates(Q query, ResponseType<R> resultType) {\n+        return subscriptionQuery(query, ResponseTypes.instanceOf(Void.class), resultType)\n+                .flatMapMany(result -> result.updates()\n+                                             .doFinally(signal -> result.close()));\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, and streams\n+     * incremental updates until subscriber unsubscribes from Flux.\n+     * Should be used when subscriber is interested only in updates.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Flux}</b></p>\n+     * <p>\n+     * <b>Note</b>: Any {@code null} results, will be filtered out by the\n+     * {@link ReactorQueryGateway}. If you require the {@code null} to be returned for the initial and update results,\n+     * we suggest using the {@code QueryBus} instead.\n+     *\n+     * @param query      The {@code query} to be sent\n+     * @param resultType The response type used for this query\n+     * @param <Q>        The type of the query\n+     * @param <R>        The type of the result (updates)\n+     * @return Flux which can be used to cancel receiving updates\n+     *\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage)\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage, SubscriptionQueryBackpressure, int)\n+     */\n+    default <Q, R> Flux<R> queryUpdates(Q query, Class<R> resultType) {\n+        return queryUpdates(query, ResponseTypes.instanceOf(resultType));\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus} and returns result containing initial response and\n+     * incremental updates (received at the moment the query is sent, until it is cancelled by the caller or closed by\n+     * the emitting side).\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     * <p>\n+     * <b>Note</b>: Any {@code null} results, on the initial result or the updates, will be filtered out by the\n+     * {@link ReactorQueryGateway}. If you require the {@code null} to be returned for the initial and update results,\n+     * we suggest using the {@code QueryBus} instead.\n+     *\n+     * @param query               The {@code query} to be sent\n+     * @param initialResponseType The initial response type used for this query\n+     * @param updateResponseType  The update response type used for this query\n+     * @param <Q>                 The type of the query\n+     * @param <I>                 The type of the initial response\n+     * @param <U>                 The type of the incremental update\n+     * @return registration which can be used to cancel receiving updates\n+     *\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage)\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage, SubscriptionQueryBackpressure, int)\n+     */\n+    default <Q, I, U> Mono<SubscriptionQueryResult<I, U>> subscriptionQuery(Q query, Class<I> initialResponseType,\n+                                                                            Class<U> updateResponseType) {\n+        return subscriptionQuery(query.getClass().getName(),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "98865ab1427e4d879301c1bf542842eccc8aa3c3"}, "originalPosition": 346}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mjc4MzI1Mg==", "bodyText": "I see it come back in the other subscription query methods too, so I'll stop copying this comment.", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r452783252", "createdAt": "2020-07-10T11:20:19Z", "author": {"login": "smcvb"}, "path": "messaging/src/main/java/org/axonframework/queryhandling/ReactorQueryGateway.java", "diffHunk": "@@ -0,0 +1,547 @@\n+/*\n+ * Copyright (c) 2010-2020. Axon Framework\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.axonframework.queryhandling;\n+\n+import org.axonframework.messaging.ResultMessage;\n+import org.axonframework.messaging.reactive.ReactorMessageDispatchInterceptorSupport;\n+import org.axonframework.messaging.reactive.ReactorResultHandlerInterceptorSupport;\n+import org.axonframework.messaging.responsetypes.ResponseType;\n+import org.axonframework.messaging.responsetypes.ResponseTypes;\n+import org.reactivestreams.Publisher;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Mono;\n+import reactor.util.concurrent.Queues;\n+\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Function;\n+\n+/**\n+ * Variation of {@link QueryGateway}. Provides support for reactive return types such as {@link Mono} and {@link Flux}\n+ * from Project Reactor.\n+ *\n+ * @author Milan Savic\n+ * @since 4.4\n+ */\n+public interface ReactorQueryGateway extends ReactorMessageDispatchInterceptorSupport<QueryMessage<?, ?>>,\n+        ReactorResultHandlerInterceptorSupport<QueryMessage<?, ?>, ResultMessage<?>> {\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response with the given {@code responseType}\n+     * from a single source. The query name will be derived from the provided {@code query}. Execution may be\n+     * asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param query        The {@code query} to be sent\n+     * @param responseType A {@link Class} describing the desired response type\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(Q query, Class<R> responseType) {\n+        return query(query.getClass().getName(), query, responseType);\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response with the given {@code responseType}\n+     * from a single source. Execution may be asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(String queryName, Q query, Class<R> responseType) {\n+        return query(queryName, query, ResponseTypes.instanceOf(responseType));\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from a single source. The query name will be derived from the provided {@code query}. Execution may be\n+     * asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(Q query, ResponseType<R> responseType) {\n+        return query(query.getClass().getName(), query, responseType);\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from a single source. Execution may be asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    <R, Q> Mono<R> query(String queryName, Q query, ResponseType<R> responseType);\n+\n+    /**\n+     * Uses given Publisher of query messages to send incoming queries away. Queries will be sent sequentially - once a\n+     * result of Nth query arrives, (N + 1)th query is dispatched.\n+     *\n+     * @param queries a Publisher stream of queries to be dispatched\n+     * @return a Flux of query results. An ordering of query results corresponds to an ordering of queries being\n+     * dispatched\n+     *\n+     * @see #query(String, Object, ResponseType)\n+     * @see Flux#concatMap(Function)\n+     */\n+    default Flux<Object> query(Publisher<QueryMessage<?, ?>> queries) {\n+        return Flux.from(queries)\n+                   .concatMap(q -> query(q.getQueryName(), q.getPayload(), q.getResponseType()));\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from several sources. The returned {@link Flux} is completed when a {@code timeout} occurs or when all possible\n+     * results are received. The query name will be derived from the provided {@code query}. Execution may be\n+     * asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     * <b>Note</b>: Any {@code null} results will be filtered out by the {@link ReactorQueryGateway}. If you require\n+     * the {@code null} to be returned, we suggest using {@code QueryBus} instead.\n+     *\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param timeout      A timeout of {@code long} for the query\n+     * @param timeUnit     The selected {@link TimeUnit} for the given {@code timeout}\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Flux} containing the query results as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Flux<R> scatterGather(Q query, ResponseType<R> responseType, long timeout, TimeUnit timeUnit) {\n+        return scatterGather(query.getClass().getName(), query, responseType, timeout, timeUnit);\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from several sources. The returned {@link Flux} is completed when a {@code timeout} occurs or when all results\n+     * are received. Execution may be asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     * <b>Note</b>: Any {@code null} results will be filtered out by the {@link ReactorQueryGateway}. If you require\n+     * the {@code null} to be returned, we suggest using {@code QueryBus} instead.\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param timeout      A timeout of {@code long} for the query\n+     * @param timeUnit     The selected {@link TimeUnit} for the given {@code timeout}\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Flux} containing the query results as dictated by the given {@code responseType}\n+     */\n+    <R, Q> Flux<R> scatterGather(String queryName, Q query, ResponseType<R> responseType, long timeout,\n+                                 TimeUnit timeUnit);\n+\n+    /**\n+     * Uses given Publisher of queries to send incoming queries in scatter gather manner. Queries will be sent\n+     * sequentially - once a result of Nth query arrives, (N + 1)th query is dispatched. All queries will be dispatched\n+     * using given {@code timeout} and {@code timeUnit}.\n+     *\n+     * @param queries  a Publisher stream of queries to be dispatched\n+     * @param timeout  A timeout of {@code long} for the query\n+     * @param timeUnit The selected {@link TimeUnit} for the given {@code timeout}\n+     * @return a Flux of query results. An ordering of query results corresponds to an ordering of queries being\n+     * dispatched\n+     */\n+    default Flux<Object> scatterGather(Publisher<QueryMessage<?, ?>> queries, long timeout, TimeUnit timeUnit) {\n+        return Flux.from(queries)\n+                   .concatMap(q -> scatterGather(q.getQueryName(),\n+                                                 q.getPayload(),\n+                                                 q.getResponseType(),\n+                                                 timeout,\n+                                                 timeUnit));\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, returns initial result and keeps streaming\n+     * incremental updates until subscriber unsubscribes from Flux.\n+     * Should be used when response type of initial result and incremental update match.\n+     * (received at the moment the query is sent, until it is cancelled by the caller or closed by the emitting side).\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Flux}</b></p>\n+     * <p>\n+     * <b>Note</b>: Any {@code null} results, on the initial result or the updates, will be filtered out by the\n+     * {@link ReactorQueryGateway}. If you require the {@code null} to be returned for the initial and update results,\n+     * we suggest using the {@code QueryBus} instead.\n+     *\n+     * @param query      The {@code query} to be sent\n+     * @param resultType The response type used for this query\n+     * @param <Q>        The type of the query\n+     * @param <R>        The type of the result (initial & updates)\n+     * @return Flux which can be used to cancel receiving updates\n+     *\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage)\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage, SubscriptionQueryBackpressure, int)\n+     */\n+    default <Q, R> Flux<R> subscriptionQuery(Q query, ResponseType<R> resultType) {\n+        return subscriptionQuery(query, resultType, resultType)\n+                .flatMapMany(result -> result.initialResult()\n+                                             .concatWith(result.updates())\n+                                             .doFinally(signal -> result.close()));\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, returns initial result and keeps streaming\n+     * incremental updates until subscriber unsubscribes from Flux.\n+     * Should be used when response type of initial result and incremental update match.\n+     * (received at the moment the query is sent, until it is cancelled by the caller or closed by the emitting side).\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Flux}</b></p>\n+     * <p>\n+     * <b>Note</b>: Any {@code null} results, on the initial result or the updates, will be filtered out by the\n+     * {@link ReactorQueryGateway}. If you require the {@code null} to be returned for the initial and update results,\n+     * we suggest using the {@code QueryBus} instead.\n+     *\n+     * @param query      The {@code query} to be sent\n+     * @param resultType The response type used for this query\n+     * @param <Q>        The type of the query\n+     * @param <R>        The type of the result (initial & updates)\n+     * @return Flux which can be used to cancel receiving updates\n+     *\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage)\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage, SubscriptionQueryBackpressure, int)\n+     */\n+    default <Q, R> Flux<R> subscriptionQuery(Q query, Class<R> resultType) {\n+        return subscriptionQuery(query, ResponseTypes.instanceOf(resultType));\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, returns initial result and keeps streaming\n+     * incremental updates until subscriber unsubscribes from Flux.\n+     * Should be used when initial result contains multiple instances of response type and needs to be flatten.\n+     * Response type of initial response and incremental updates needs to match.\n+     * (received at the moment the query is sent, until it is cancelled by the caller or closed by the emitting side).\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Flux}</b></p>\n+     * <p>\n+     * <b>Note</b>: Any {@code null} results, on the initial result or the updates, will be filtered out by the\n+     * {@link ReactorQueryGateway}. If you require the {@code null} to be returned for the initial and update results,\n+     * we suggest using the {@code QueryBus} instead.\n+     *\n+     * @param query      The {@code query} to be sent\n+     * @param resultType The response type used for this query\n+     * @param <Q>        The type of the query\n+     * @param <R>        The type of the result (initial & updates)\n+     * @return Flux which can be used to cancel receiving updates\n+     *\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage)\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage, SubscriptionQueryBackpressure, int)\n+     */\n+    default <Q, R> Flux<R> subscriptionQueryMany(Q query, Class<R> resultType) {\n+        return subscriptionQuery(query,\n+                                 ResponseTypes.multipleInstancesOf(resultType),\n+                                 ResponseTypes.instanceOf(resultType))\n+                .flatMapMany(result -> result.initialResult()\n+                                             .flatMapMany(Flux::fromIterable)\n+                                             .concatWith(result.updates())\n+                                             .doFinally(signal -> result.close()));\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, and streams\n+     * incremental updates until subscriber unsubscribes from Flux.\n+     * Should be used when subscriber is interested only in updates.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Flux}</b></p>\n+     * <p>\n+     * <b>Note</b>: Any {@code null} results, will be filtered out by the\n+     * {@link ReactorQueryGateway}. If you require the {@code null} to be returned for the initial and update results,\n+     * we suggest using the {@code QueryBus} instead.\n+     *\n+     * @param query      The {@code query} to be sent\n+     * @param resultType The response type used for this query\n+     * @param <Q>        The type of the query\n+     * @param <R>        The type of the result (updates)\n+     * @return Flux which can be used to cancel receiving updates\n+     *\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage)\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage, SubscriptionQueryBackpressure, int)\n+     */\n+    default <Q, R> Flux<R> queryUpdates(Q query, ResponseType<R> resultType) {\n+        return subscriptionQuery(query, ResponseTypes.instanceOf(Void.class), resultType)\n+                .flatMapMany(result -> result.updates()\n+                                             .doFinally(signal -> result.close()));\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, and streams\n+     * incremental updates until subscriber unsubscribes from Flux.\n+     * Should be used when subscriber is interested only in updates.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Flux}</b></p>\n+     * <p>\n+     * <b>Note</b>: Any {@code null} results, will be filtered out by the\n+     * {@link ReactorQueryGateway}. If you require the {@code null} to be returned for the initial and update results,\n+     * we suggest using the {@code QueryBus} instead.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjcxNDc1Nw=="}, "originalCommit": {"oid": "98865ab1427e4d879301c1bf542842eccc8aa3c3"}, "originalPosition": 307}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mjc4MzM4Mw==", "bodyText": "You should take into account that the query given here might be a QueryMessage implementation. Thus simply doing query.getClass().getName() might result in QueryMessage as the result, which is not it's intended purpose. I'd recommend to use the QueryMessage#queryName(Object) method to figure out the actual queryName to provider here.", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r452783383", "createdAt": "2020-07-10T11:20:39Z", "author": {"login": "smcvb"}, "path": "messaging/src/main/java/org/axonframework/queryhandling/ReactorQueryGateway.java", "diffHunk": "@@ -0,0 +1,547 @@\n+/*\n+ * Copyright (c) 2010-2020. Axon Framework\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.axonframework.queryhandling;\n+\n+import org.axonframework.messaging.ResultMessage;\n+import org.axonframework.messaging.reactive.ReactorMessageDispatchInterceptorSupport;\n+import org.axonframework.messaging.reactive.ReactorResultHandlerInterceptorSupport;\n+import org.axonframework.messaging.responsetypes.ResponseType;\n+import org.axonframework.messaging.responsetypes.ResponseTypes;\n+import org.reactivestreams.Publisher;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Mono;\n+import reactor.util.concurrent.Queues;\n+\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Function;\n+\n+/**\n+ * Variation of {@link QueryGateway}. Provides support for reactive return types such as {@link Mono} and {@link Flux}\n+ * from Project Reactor.\n+ *\n+ * @author Milan Savic\n+ * @since 4.4\n+ */\n+public interface ReactorQueryGateway extends ReactorMessageDispatchInterceptorSupport<QueryMessage<?, ?>>,\n+        ReactorResultHandlerInterceptorSupport<QueryMessage<?, ?>, ResultMessage<?>> {\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response with the given {@code responseType}\n+     * from a single source. The query name will be derived from the provided {@code query}. Execution may be\n+     * asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param query        The {@code query} to be sent\n+     * @param responseType A {@link Class} describing the desired response type\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(Q query, Class<R> responseType) {\n+        return query(query.getClass().getName(), query, responseType);\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response with the given {@code responseType}\n+     * from a single source. Execution may be asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(String queryName, Q query, Class<R> responseType) {\n+        return query(queryName, query, ResponseTypes.instanceOf(responseType));\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from a single source. The query name will be derived from the provided {@code query}. Execution may be\n+     * asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(Q query, ResponseType<R> responseType) {\n+        return query(query.getClass().getName(), query, responseType);\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from a single source. Execution may be asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    <R, Q> Mono<R> query(String queryName, Q query, ResponseType<R> responseType);\n+\n+    /**\n+     * Uses given Publisher of query messages to send incoming queries away. Queries will be sent sequentially - once a\n+     * result of Nth query arrives, (N + 1)th query is dispatched.\n+     *\n+     * @param queries a Publisher stream of queries to be dispatched\n+     * @return a Flux of query results. An ordering of query results corresponds to an ordering of queries being\n+     * dispatched\n+     *\n+     * @see #query(String, Object, ResponseType)\n+     * @see Flux#concatMap(Function)\n+     */\n+    default Flux<Object> query(Publisher<QueryMessage<?, ?>> queries) {\n+        return Flux.from(queries)\n+                   .concatMap(q -> query(q.getQueryName(), q.getPayload(), q.getResponseType()));\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from several sources. The returned {@link Flux} is completed when a {@code timeout} occurs or when all possible\n+     * results are received. The query name will be derived from the provided {@code query}. Execution may be\n+     * asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     * <b>Note</b>: Any {@code null} results will be filtered out by the {@link ReactorQueryGateway}. If you require\n+     * the {@code null} to be returned, we suggest using {@code QueryBus} instead.\n+     *\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param timeout      A timeout of {@code long} for the query\n+     * @param timeUnit     The selected {@link TimeUnit} for the given {@code timeout}\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Flux} containing the query results as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Flux<R> scatterGather(Q query, ResponseType<R> responseType, long timeout, TimeUnit timeUnit) {\n+        return scatterGather(query.getClass().getName(), query, responseType, timeout, timeUnit);\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from several sources. The returned {@link Flux} is completed when a {@code timeout} occurs or when all results\n+     * are received. Execution may be asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     * <b>Note</b>: Any {@code null} results will be filtered out by the {@link ReactorQueryGateway}. If you require\n+     * the {@code null} to be returned, we suggest using {@code QueryBus} instead.\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param timeout      A timeout of {@code long} for the query\n+     * @param timeUnit     The selected {@link TimeUnit} for the given {@code timeout}\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Flux} containing the query results as dictated by the given {@code responseType}\n+     */\n+    <R, Q> Flux<R> scatterGather(String queryName, Q query, ResponseType<R> responseType, long timeout,\n+                                 TimeUnit timeUnit);\n+\n+    /**\n+     * Uses given Publisher of queries to send incoming queries in scatter gather manner. Queries will be sent\n+     * sequentially - once a result of Nth query arrives, (N + 1)th query is dispatched. All queries will be dispatched\n+     * using given {@code timeout} and {@code timeUnit}.\n+     *\n+     * @param queries  a Publisher stream of queries to be dispatched\n+     * @param timeout  A timeout of {@code long} for the query\n+     * @param timeUnit The selected {@link TimeUnit} for the given {@code timeout}\n+     * @return a Flux of query results. An ordering of query results corresponds to an ordering of queries being\n+     * dispatched\n+     */\n+    default Flux<Object> scatterGather(Publisher<QueryMessage<?, ?>> queries, long timeout, TimeUnit timeUnit) {\n+        return Flux.from(queries)\n+                   .concatMap(q -> scatterGather(q.getQueryName(),\n+                                                 q.getPayload(),\n+                                                 q.getResponseType(),\n+                                                 timeout,\n+                                                 timeUnit));\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, returns initial result and keeps streaming\n+     * incremental updates until subscriber unsubscribes from Flux.\n+     * Should be used when response type of initial result and incremental update match.\n+     * (received at the moment the query is sent, until it is cancelled by the caller or closed by the emitting side).\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Flux}</b></p>\n+     * <p>\n+     * <b>Note</b>: Any {@code null} results, on the initial result or the updates, will be filtered out by the\n+     * {@link ReactorQueryGateway}. If you require the {@code null} to be returned for the initial and update results,\n+     * we suggest using the {@code QueryBus} instead.\n+     *\n+     * @param query      The {@code query} to be sent\n+     * @param resultType The response type used for this query\n+     * @param <Q>        The type of the query\n+     * @param <R>        The type of the result (initial & updates)\n+     * @return Flux which can be used to cancel receiving updates\n+     *\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage)\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage, SubscriptionQueryBackpressure, int)\n+     */\n+    default <Q, R> Flux<R> subscriptionQuery(Q query, ResponseType<R> resultType) {\n+        return subscriptionQuery(query, resultType, resultType)\n+                .flatMapMany(result -> result.initialResult()\n+                                             .concatWith(result.updates())\n+                                             .doFinally(signal -> result.close()));\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, returns initial result and keeps streaming\n+     * incremental updates until subscriber unsubscribes from Flux.\n+     * Should be used when response type of initial result and incremental update match.\n+     * (received at the moment the query is sent, until it is cancelled by the caller or closed by the emitting side).\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Flux}</b></p>\n+     * <p>\n+     * <b>Note</b>: Any {@code null} results, on the initial result or the updates, will be filtered out by the\n+     * {@link ReactorQueryGateway}. If you require the {@code null} to be returned for the initial and update results,\n+     * we suggest using the {@code QueryBus} instead.\n+     *\n+     * @param query      The {@code query} to be sent\n+     * @param resultType The response type used for this query\n+     * @param <Q>        The type of the query\n+     * @param <R>        The type of the result (initial & updates)\n+     * @return Flux which can be used to cancel receiving updates\n+     *\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage)\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage, SubscriptionQueryBackpressure, int)\n+     */\n+    default <Q, R> Flux<R> subscriptionQuery(Q query, Class<R> resultType) {\n+        return subscriptionQuery(query, ResponseTypes.instanceOf(resultType));\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, returns initial result and keeps streaming\n+     * incremental updates until subscriber unsubscribes from Flux.\n+     * Should be used when initial result contains multiple instances of response type and needs to be flatten.\n+     * Response type of initial response and incremental updates needs to match.\n+     * (received at the moment the query is sent, until it is cancelled by the caller or closed by the emitting side).\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Flux}</b></p>\n+     * <p>\n+     * <b>Note</b>: Any {@code null} results, on the initial result or the updates, will be filtered out by the\n+     * {@link ReactorQueryGateway}. If you require the {@code null} to be returned for the initial and update results,\n+     * we suggest using the {@code QueryBus} instead.\n+     *\n+     * @param query      The {@code query} to be sent\n+     * @param resultType The response type used for this query\n+     * @param <Q>        The type of the query\n+     * @param <R>        The type of the result (initial & updates)\n+     * @return Flux which can be used to cancel receiving updates\n+     *\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage)\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage, SubscriptionQueryBackpressure, int)\n+     */\n+    default <Q, R> Flux<R> subscriptionQueryMany(Q query, Class<R> resultType) {\n+        return subscriptionQuery(query,\n+                                 ResponseTypes.multipleInstancesOf(resultType),\n+                                 ResponseTypes.instanceOf(resultType))\n+                .flatMapMany(result -> result.initialResult()\n+                                             .flatMapMany(Flux::fromIterable)\n+                                             .concatWith(result.updates())\n+                                             .doFinally(signal -> result.close()));\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, and streams\n+     * incremental updates until subscriber unsubscribes from Flux.\n+     * Should be used when subscriber is interested only in updates.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Flux}</b></p>\n+     * <p>\n+     * <b>Note</b>: Any {@code null} results, will be filtered out by the\n+     * {@link ReactorQueryGateway}. If you require the {@code null} to be returned for the initial and update results,\n+     * we suggest using the {@code QueryBus} instead.\n+     *\n+     * @param query      The {@code query} to be sent\n+     * @param resultType The response type used for this query\n+     * @param <Q>        The type of the query\n+     * @param <R>        The type of the result (updates)\n+     * @return Flux which can be used to cancel receiving updates\n+     *\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage)\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage, SubscriptionQueryBackpressure, int)\n+     */\n+    default <Q, R> Flux<R> queryUpdates(Q query, ResponseType<R> resultType) {\n+        return subscriptionQuery(query, ResponseTypes.instanceOf(Void.class), resultType)\n+                .flatMapMany(result -> result.updates()\n+                                             .doFinally(signal -> result.close()));\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, and streams\n+     * incremental updates until subscriber unsubscribes from Flux.\n+     * Should be used when subscriber is interested only in updates.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Flux}</b></p>\n+     * <p>\n+     * <b>Note</b>: Any {@code null} results, will be filtered out by the\n+     * {@link ReactorQueryGateway}. If you require the {@code null} to be returned for the initial and update results,\n+     * we suggest using the {@code QueryBus} instead.\n+     *\n+     * @param query      The {@code query} to be sent\n+     * @param resultType The response type used for this query\n+     * @param <Q>        The type of the query\n+     * @param <R>        The type of the result (updates)\n+     * @return Flux which can be used to cancel receiving updates\n+     *\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage)\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage, SubscriptionQueryBackpressure, int)\n+     */\n+    default <Q, R> Flux<R> queryUpdates(Q query, Class<R> resultType) {\n+        return queryUpdates(query, ResponseTypes.instanceOf(resultType));\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus} and returns result containing initial response and\n+     * incremental updates (received at the moment the query is sent, until it is cancelled by the caller or closed by\n+     * the emitting side).\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     * <p>\n+     * <b>Note</b>: Any {@code null} results, on the initial result or the updates, will be filtered out by the\n+     * {@link ReactorQueryGateway}. If you require the {@code null} to be returned for the initial and update results,\n+     * we suggest using the {@code QueryBus} instead.\n+     *\n+     * @param query               The {@code query} to be sent\n+     * @param initialResponseType The initial response type used for this query\n+     * @param updateResponseType  The update response type used for this query\n+     * @param <Q>                 The type of the query\n+     * @param <I>                 The type of the initial response\n+     * @param <U>                 The type of the incremental update\n+     * @return registration which can be used to cancel receiving updates\n+     *\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage)\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage, SubscriptionQueryBackpressure, int)\n+     */\n+    default <Q, I, U> Mono<SubscriptionQueryResult<I, U>> subscriptionQuery(Q query, Class<I> initialResponseType,\n+                                                                            Class<U> updateResponseType) {\n+        return subscriptionQuery(query.getClass().getName(),\n+                                 query,\n+                                 initialResponseType,\n+                                 updateResponseType);\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus} and returns result containing initial response and\n+     * incremental updates (received at the moment the query is sent, until it is cancelled by the caller or closed by\n+     * the emitting side).\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     * <p>\n+     * <b>Note</b>: Any {@code null} results, on the initial result or the updates, will be filtered out by the\n+     * {@link ReactorQueryGateway}. If you require the {@code null} to be returned for the initial and update results,\n+     * we suggest using the {@code QueryBus} instead.\n+     *\n+     * @param queryName           A {@link String} describing query to be executed\n+     * @param query               The {@code query} to be sent\n+     * @param initialResponseType The initial response type used for this query\n+     * @param updateResponseType  The update response type used for this query\n+     * @param <Q>                 The type of the query\n+     * @param <I>                 The type of the initial response\n+     * @param <U>                 The type of the incremental update\n+     * @return registration which can be used to cancel receiving updates\n+     *\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage)\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage, SubscriptionQueryBackpressure, int)\n+     */\n+    default <Q, I, U> Mono<SubscriptionQueryResult<I, U>> subscriptionQuery(String queryName, Q query,\n+                                                                            Class<I> initialResponseType,\n+                                                                            Class<U> updateResponseType) {\n+        return subscriptionQuery(queryName,\n+                                 query,\n+                                 ResponseTypes.instanceOf(initialResponseType),\n+                                 ResponseTypes.instanceOf(updateResponseType),\n+                                 SubscriptionQueryBackpressure.defaultBackpressure());\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus} and returns result containing initial response and\n+     * incremental updates (received at the moment the query is sent, until it is cancelled by the caller or closed by\n+     * the emitting side).\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     * <p>\n+     * <b>Note</b>: Any {@code null} results, on the initial result or the updates, will be filtered out by the\n+     * {@link ReactorQueryGateway}. If you require the {@code null} to be returned for the initial and update results,\n+     * we suggest using the {@code QueryBus} instead.\n+     *\n+     * @param query               The {@code query} to be sent\n+     * @param initialResponseType The initial response type used for this query\n+     * @param updateResponseType  The update response type used for this query\n+     * @param <Q>                 The type of the query\n+     * @param <I>                 The type of the initial response\n+     * @param <U>                 The type of the incremental update\n+     * @return registration which can be used to cancel receiving updates\n+     *\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage)\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage, SubscriptionQueryBackpressure, int)\n+     */\n+    default <Q, I, U> Mono<SubscriptionQueryResult<I, U>> subscriptionQuery(Q query,\n+                                                                            ResponseType<I> initialResponseType,\n+                                                                            ResponseType<U> updateResponseType) {\n+        return subscriptionQuery(query.getClass().getName(),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "98865ab1427e4d879301c1bf542842eccc8aa3c3"}, "originalPosition": 410}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mjc4Mzk3Mw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * Uses given Publisher of queries to send incoming queries away. Queries will be sent sequentially - once a result\n          \n          \n            \n                 * of Nth query arrives, (N + 1)th query is dispatched.\n          \n          \n            \n                 *\n          \n          \n            \n                 * @param queries a Publisher stream of queries to be dispatched\n          \n          \n            \n                 * @return a Flux of query results. An ordering of query results corresponds to an ordering of queries being\n          \n          \n            \n                 * dispatched\n          \n          \n            \n                 * Uses the given {@link Publisher} of {@link SubscriptionQueryMessage}s to send incoming queries away. Queries will be sent sequentially. Once the result\n          \n          \n            \n                 * of Nth query arrives, the (N + 1)th query is dispatched.\n          \n          \n            \n                 *\n          \n          \n            \n                 * @param queries a {@link Publisher} stream of queries to be dispatched\n          \n          \n            \n                 * @return a {@link Flux} of query results. The ordering of query results corresponds to the ordering of queries being\n          \n          \n            \n                 * dispatched", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r452783973", "createdAt": "2020-07-10T11:22:12Z", "author": {"login": "smcvb"}, "path": "messaging/src/main/java/org/axonframework/queryhandling/ReactorQueryGateway.java", "diffHunk": "@@ -0,0 +1,547 @@\n+/*\n+ * Copyright (c) 2010-2020. Axon Framework\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.axonframework.queryhandling;\n+\n+import org.axonframework.messaging.ResultMessage;\n+import org.axonframework.messaging.reactive.ReactorMessageDispatchInterceptorSupport;\n+import org.axonframework.messaging.reactive.ReactorResultHandlerInterceptorSupport;\n+import org.axonframework.messaging.responsetypes.ResponseType;\n+import org.axonframework.messaging.responsetypes.ResponseTypes;\n+import org.reactivestreams.Publisher;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Mono;\n+import reactor.util.concurrent.Queues;\n+\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Function;\n+\n+/**\n+ * Variation of {@link QueryGateway}. Provides support for reactive return types such as {@link Mono} and {@link Flux}\n+ * from Project Reactor.\n+ *\n+ * @author Milan Savic\n+ * @since 4.4\n+ */\n+public interface ReactorQueryGateway extends ReactorMessageDispatchInterceptorSupport<QueryMessage<?, ?>>,\n+        ReactorResultHandlerInterceptorSupport<QueryMessage<?, ?>, ResultMessage<?>> {\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response with the given {@code responseType}\n+     * from a single source. The query name will be derived from the provided {@code query}. Execution may be\n+     * asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param query        The {@code query} to be sent\n+     * @param responseType A {@link Class} describing the desired response type\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(Q query, Class<R> responseType) {\n+        return query(query.getClass().getName(), query, responseType);\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response with the given {@code responseType}\n+     * from a single source. Execution may be asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(String queryName, Q query, Class<R> responseType) {\n+        return query(queryName, query, ResponseTypes.instanceOf(responseType));\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from a single source. The query name will be derived from the provided {@code query}. Execution may be\n+     * asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(Q query, ResponseType<R> responseType) {\n+        return query(query.getClass().getName(), query, responseType);\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from a single source. Execution may be asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    <R, Q> Mono<R> query(String queryName, Q query, ResponseType<R> responseType);\n+\n+    /**\n+     * Uses given Publisher of query messages to send incoming queries away. Queries will be sent sequentially - once a\n+     * result of Nth query arrives, (N + 1)th query is dispatched.\n+     *\n+     * @param queries a Publisher stream of queries to be dispatched\n+     * @return a Flux of query results. An ordering of query results corresponds to an ordering of queries being\n+     * dispatched\n+     *\n+     * @see #query(String, Object, ResponseType)\n+     * @see Flux#concatMap(Function)\n+     */\n+    default Flux<Object> query(Publisher<QueryMessage<?, ?>> queries) {\n+        return Flux.from(queries)\n+                   .concatMap(q -> query(q.getQueryName(), q.getPayload(), q.getResponseType()));\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from several sources. The returned {@link Flux} is completed when a {@code timeout} occurs or when all possible\n+     * results are received. The query name will be derived from the provided {@code query}. Execution may be\n+     * asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     * <b>Note</b>: Any {@code null} results will be filtered out by the {@link ReactorQueryGateway}. If you require\n+     * the {@code null} to be returned, we suggest using {@code QueryBus} instead.\n+     *\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param timeout      A timeout of {@code long} for the query\n+     * @param timeUnit     The selected {@link TimeUnit} for the given {@code timeout}\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Flux} containing the query results as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Flux<R> scatterGather(Q query, ResponseType<R> responseType, long timeout, TimeUnit timeUnit) {\n+        return scatterGather(query.getClass().getName(), query, responseType, timeout, timeUnit);\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from several sources. The returned {@link Flux} is completed when a {@code timeout} occurs or when all results\n+     * are received. Execution may be asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     * <b>Note</b>: Any {@code null} results will be filtered out by the {@link ReactorQueryGateway}. If you require\n+     * the {@code null} to be returned, we suggest using {@code QueryBus} instead.\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param timeout      A timeout of {@code long} for the query\n+     * @param timeUnit     The selected {@link TimeUnit} for the given {@code timeout}\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Flux} containing the query results as dictated by the given {@code responseType}\n+     */\n+    <R, Q> Flux<R> scatterGather(String queryName, Q query, ResponseType<R> responseType, long timeout,\n+                                 TimeUnit timeUnit);\n+\n+    /**\n+     * Uses given Publisher of queries to send incoming queries in scatter gather manner. Queries will be sent\n+     * sequentially - once a result of Nth query arrives, (N + 1)th query is dispatched. All queries will be dispatched\n+     * using given {@code timeout} and {@code timeUnit}.\n+     *\n+     * @param queries  a Publisher stream of queries to be dispatched\n+     * @param timeout  A timeout of {@code long} for the query\n+     * @param timeUnit The selected {@link TimeUnit} for the given {@code timeout}\n+     * @return a Flux of query results. An ordering of query results corresponds to an ordering of queries being\n+     * dispatched\n+     */\n+    default Flux<Object> scatterGather(Publisher<QueryMessage<?, ?>> queries, long timeout, TimeUnit timeUnit) {\n+        return Flux.from(queries)\n+                   .concatMap(q -> scatterGather(q.getQueryName(),\n+                                                 q.getPayload(),\n+                                                 q.getResponseType(),\n+                                                 timeout,\n+                                                 timeUnit));\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, returns initial result and keeps streaming\n+     * incremental updates until subscriber unsubscribes from Flux.\n+     * Should be used when response type of initial result and incremental update match.\n+     * (received at the moment the query is sent, until it is cancelled by the caller or closed by the emitting side).\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Flux}</b></p>\n+     * <p>\n+     * <b>Note</b>: Any {@code null} results, on the initial result or the updates, will be filtered out by the\n+     * {@link ReactorQueryGateway}. If you require the {@code null} to be returned for the initial and update results,\n+     * we suggest using the {@code QueryBus} instead.\n+     *\n+     * @param query      The {@code query} to be sent\n+     * @param resultType The response type used for this query\n+     * @param <Q>        The type of the query\n+     * @param <R>        The type of the result (initial & updates)\n+     * @return Flux which can be used to cancel receiving updates\n+     *\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage)\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage, SubscriptionQueryBackpressure, int)\n+     */\n+    default <Q, R> Flux<R> subscriptionQuery(Q query, ResponseType<R> resultType) {\n+        return subscriptionQuery(query, resultType, resultType)\n+                .flatMapMany(result -> result.initialResult()\n+                                             .concatWith(result.updates())\n+                                             .doFinally(signal -> result.close()));\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, returns initial result and keeps streaming\n+     * incremental updates until subscriber unsubscribes from Flux.\n+     * Should be used when response type of initial result and incremental update match.\n+     * (received at the moment the query is sent, until it is cancelled by the caller or closed by the emitting side).\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Flux}</b></p>\n+     * <p>\n+     * <b>Note</b>: Any {@code null} results, on the initial result or the updates, will be filtered out by the\n+     * {@link ReactorQueryGateway}. If you require the {@code null} to be returned for the initial and update results,\n+     * we suggest using the {@code QueryBus} instead.\n+     *\n+     * @param query      The {@code query} to be sent\n+     * @param resultType The response type used for this query\n+     * @param <Q>        The type of the query\n+     * @param <R>        The type of the result (initial & updates)\n+     * @return Flux which can be used to cancel receiving updates\n+     *\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage)\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage, SubscriptionQueryBackpressure, int)\n+     */\n+    default <Q, R> Flux<R> subscriptionQuery(Q query, Class<R> resultType) {\n+        return subscriptionQuery(query, ResponseTypes.instanceOf(resultType));\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, returns initial result and keeps streaming\n+     * incremental updates until subscriber unsubscribes from Flux.\n+     * Should be used when initial result contains multiple instances of response type and needs to be flatten.\n+     * Response type of initial response and incremental updates needs to match.\n+     * (received at the moment the query is sent, until it is cancelled by the caller or closed by the emitting side).\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Flux}</b></p>\n+     * <p>\n+     * <b>Note</b>: Any {@code null} results, on the initial result or the updates, will be filtered out by the\n+     * {@link ReactorQueryGateway}. If you require the {@code null} to be returned for the initial and update results,\n+     * we suggest using the {@code QueryBus} instead.\n+     *\n+     * @param query      The {@code query} to be sent\n+     * @param resultType The response type used for this query\n+     * @param <Q>        The type of the query\n+     * @param <R>        The type of the result (initial & updates)\n+     * @return Flux which can be used to cancel receiving updates\n+     *\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage)\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage, SubscriptionQueryBackpressure, int)\n+     */\n+    default <Q, R> Flux<R> subscriptionQueryMany(Q query, Class<R> resultType) {\n+        return subscriptionQuery(query,\n+                                 ResponseTypes.multipleInstancesOf(resultType),\n+                                 ResponseTypes.instanceOf(resultType))\n+                .flatMapMany(result -> result.initialResult()\n+                                             .flatMapMany(Flux::fromIterable)\n+                                             .concatWith(result.updates())\n+                                             .doFinally(signal -> result.close()));\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, and streams\n+     * incremental updates until subscriber unsubscribes from Flux.\n+     * Should be used when subscriber is interested only in updates.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Flux}</b></p>\n+     * <p>\n+     * <b>Note</b>: Any {@code null} results, will be filtered out by the\n+     * {@link ReactorQueryGateway}. If you require the {@code null} to be returned for the initial and update results,\n+     * we suggest using the {@code QueryBus} instead.\n+     *\n+     * @param query      The {@code query} to be sent\n+     * @param resultType The response type used for this query\n+     * @param <Q>        The type of the query\n+     * @param <R>        The type of the result (updates)\n+     * @return Flux which can be used to cancel receiving updates\n+     *\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage)\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage, SubscriptionQueryBackpressure, int)\n+     */\n+    default <Q, R> Flux<R> queryUpdates(Q query, ResponseType<R> resultType) {\n+        return subscriptionQuery(query, ResponseTypes.instanceOf(Void.class), resultType)\n+                .flatMapMany(result -> result.updates()\n+                                             .doFinally(signal -> result.close()));\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, and streams\n+     * incremental updates until subscriber unsubscribes from Flux.\n+     * Should be used when subscriber is interested only in updates.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Flux}</b></p>\n+     * <p>\n+     * <b>Note</b>: Any {@code null} results, will be filtered out by the\n+     * {@link ReactorQueryGateway}. If you require the {@code null} to be returned for the initial and update results,\n+     * we suggest using the {@code QueryBus} instead.\n+     *\n+     * @param query      The {@code query} to be sent\n+     * @param resultType The response type used for this query\n+     * @param <Q>        The type of the query\n+     * @param <R>        The type of the result (updates)\n+     * @return Flux which can be used to cancel receiving updates\n+     *\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage)\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage, SubscriptionQueryBackpressure, int)\n+     */\n+    default <Q, R> Flux<R> queryUpdates(Q query, Class<R> resultType) {\n+        return queryUpdates(query, ResponseTypes.instanceOf(resultType));\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus} and returns result containing initial response and\n+     * incremental updates (received at the moment the query is sent, until it is cancelled by the caller or closed by\n+     * the emitting side).\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     * <p>\n+     * <b>Note</b>: Any {@code null} results, on the initial result or the updates, will be filtered out by the\n+     * {@link ReactorQueryGateway}. If you require the {@code null} to be returned for the initial and update results,\n+     * we suggest using the {@code QueryBus} instead.\n+     *\n+     * @param query               The {@code query} to be sent\n+     * @param initialResponseType The initial response type used for this query\n+     * @param updateResponseType  The update response type used for this query\n+     * @param <Q>                 The type of the query\n+     * @param <I>                 The type of the initial response\n+     * @param <U>                 The type of the incremental update\n+     * @return registration which can be used to cancel receiving updates\n+     *\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage)\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage, SubscriptionQueryBackpressure, int)\n+     */\n+    default <Q, I, U> Mono<SubscriptionQueryResult<I, U>> subscriptionQuery(Q query, Class<I> initialResponseType,\n+                                                                            Class<U> updateResponseType) {\n+        return subscriptionQuery(query.getClass().getName(),\n+                                 query,\n+                                 initialResponseType,\n+                                 updateResponseType);\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus} and returns result containing initial response and\n+     * incremental updates (received at the moment the query is sent, until it is cancelled by the caller or closed by\n+     * the emitting side).\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     * <p>\n+     * <b>Note</b>: Any {@code null} results, on the initial result or the updates, will be filtered out by the\n+     * {@link ReactorQueryGateway}. If you require the {@code null} to be returned for the initial and update results,\n+     * we suggest using the {@code QueryBus} instead.\n+     *\n+     * @param queryName           A {@link String} describing query to be executed\n+     * @param query               The {@code query} to be sent\n+     * @param initialResponseType The initial response type used for this query\n+     * @param updateResponseType  The update response type used for this query\n+     * @param <Q>                 The type of the query\n+     * @param <I>                 The type of the initial response\n+     * @param <U>                 The type of the incremental update\n+     * @return registration which can be used to cancel receiving updates\n+     *\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage)\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage, SubscriptionQueryBackpressure, int)\n+     */\n+    default <Q, I, U> Mono<SubscriptionQueryResult<I, U>> subscriptionQuery(String queryName, Q query,\n+                                                                            Class<I> initialResponseType,\n+                                                                            Class<U> updateResponseType) {\n+        return subscriptionQuery(queryName,\n+                                 query,\n+                                 ResponseTypes.instanceOf(initialResponseType),\n+                                 ResponseTypes.instanceOf(updateResponseType),\n+                                 SubscriptionQueryBackpressure.defaultBackpressure());\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus} and returns result containing initial response and\n+     * incremental updates (received at the moment the query is sent, until it is cancelled by the caller or closed by\n+     * the emitting side).\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     * <p>\n+     * <b>Note</b>: Any {@code null} results, on the initial result or the updates, will be filtered out by the\n+     * {@link ReactorQueryGateway}. If you require the {@code null} to be returned for the initial and update results,\n+     * we suggest using the {@code QueryBus} instead.\n+     *\n+     * @param query               The {@code query} to be sent\n+     * @param initialResponseType The initial response type used for this query\n+     * @param updateResponseType  The update response type used for this query\n+     * @param <Q>                 The type of the query\n+     * @param <I>                 The type of the initial response\n+     * @param <U>                 The type of the incremental update\n+     * @return registration which can be used to cancel receiving updates\n+     *\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage)\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage, SubscriptionQueryBackpressure, int)\n+     */\n+    default <Q, I, U> Mono<SubscriptionQueryResult<I, U>> subscriptionQuery(Q query,\n+                                                                            ResponseType<I> initialResponseType,\n+                                                                            ResponseType<U> updateResponseType) {\n+        return subscriptionQuery(query.getClass().getName(),\n+                                 query,\n+                                 initialResponseType,\n+                                 updateResponseType,\n+                                 SubscriptionQueryBackpressure.defaultBackpressure());\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus} and returns result containing initial response and\n+     * incremental updates (received at the moment the query is sent, until it is cancelled by the caller or closed by\n+     * the emitting side).\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     * <p>\n+     * <b>Note</b>: Any {@code null} results, on the initial result or the updates, will be filtered out by the\n+     * {@link ReactorQueryGateway}. If you require the {@code null} to be returned for the initial and update results,\n+     * we suggest using the {@code QueryBus} instead.\n+     *\n+     * @param queryName           A {@link String} describing query to be executed\n+     * @param query               The {@code query} to be sent\n+     * @param initialResponseType The initial response type used for this query\n+     * @param updateResponseType  The update response type used for this query\n+     * @param backpressure        The backpressure mechanism to deal with producing of incremental updates\n+     * @param <Q>                 The type of the query\n+     * @param <I>                 The type of the initial response\n+     * @param <U>                 The type of the incremental update\n+     * @return registration which can be used to cancel receiving updates\n+     *\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage)\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage, SubscriptionQueryBackpressure, int)\n+     */\n+    default <Q, I, U> Mono<SubscriptionQueryResult<I, U>> subscriptionQuery(String queryName, Q query,\n+                                                                            ResponseType<I> initialResponseType,\n+                                                                            ResponseType<U> updateResponseType,\n+                                                                            SubscriptionQueryBackpressure backpressure) {\n+        return subscriptionQuery(queryName,\n+                                 query,\n+                                 initialResponseType,\n+                                 updateResponseType,\n+                                 backpressure,\n+                                 Queues.SMALL_BUFFER_SIZE);\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus} and returns result containing initial response and\n+     * incremental updates (received at the moment the query is sent, until it is cancelled by the caller or closed by\n+     * the emitting side).\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     * <p>\n+     * <b>Note</b>: Any {@code null} results, on the initial result or the updates, will be filtered out by the\n+     * {@link ReactorQueryGateway}. If you require the {@code null} to be returned for the initial and update results,\n+     * we suggest using the {@code QueryBus} instead.\n+     *\n+     * @param queryName           A {@link String} describing query to be executed\n+     * @param query               The {@code query} to be sent\n+     * @param initialResponseType The initial response type used for this query\n+     * @param updateResponseType  The update response type used for this query\n+     * @param backpressure        The backpressure mechanism to deal with producing of incremental updates\n+     * @param updateBufferSize    The size of buffer which accumulates updates before subscription to the {@code flux}\n+     *                            is made\n+     * @param <Q>                 The type of the query\n+     * @param <I>                 The type of the initial response\n+     * @param <U>                 The type of the incremental update\n+     * @return registration which can be used to cancel receiving updates\n+     *\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage)\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage, SubscriptionQueryBackpressure, int)\n+     */\n+    <Q, I, U> Mono<SubscriptionQueryResult<I, U>> subscriptionQuery(String queryName, Q query,\n+                                                                    ResponseType<I> initialResponseType,\n+                                                                    ResponseType<U> updateResponseType,\n+                                                                    SubscriptionQueryBackpressure backpressure,\n+                                                                    int updateBufferSize);\n+\n+    /**\n+     * Uses given Publisher of queries to send incoming queries away. Queries will be sent sequentially - once a result\n+     * of Nth query arrives, (N + 1)th query is dispatched.\n+     *\n+     * @param queries a Publisher stream of queries to be dispatched\n+     * @return a Flux of query results. An ordering of query results corresponds to an ordering of queries being\n+     * dispatched", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "98865ab1427e4d879301c1bf542842eccc8aa3c3"}, "originalPosition": 491}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mjc4NDM5OA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * Uses given Publisher of queries to send incoming queries away. Queries will be sent sequentially - once a result\n          \n          \n            \n                 * of Nth query arrives, (N + 1)th query is dispatched. All queries will be dispatched using given {@code\n          \n          \n            \n                 * backpressure}.\n          \n          \n            \n                 *\n          \n          \n            \n                 * @param queries      a Publisher stream of queries to be dispatched\n          \n          \n            \n                 * @param backpressure The backpressure mechanism to deal with producing of incremental updates\n          \n          \n            \n                 * @return a Flux of query results. An ordering of query results corresponds to an ordering of queries being\n          \n          \n            \n                 * dispatched\n          \n          \n            \n                 * Uses the given {@link Publisher} of {@link SubscriptionQueryMessage}s to send incoming queries away. Queries will be sent sequentially. Once the result\n          \n          \n            \n                 * of Nth query arrives, the (N + 1)th query is dispatched. All queries will be dispatched using the given {@code\n          \n          \n            \n                 * backpressure}.\n          \n          \n            \n                 *\n          \n          \n            \n                 * @param queries      a {@link Publisher} stream of queries to be dispatched\n          \n          \n            \n                 * @param backpressure the backpressure mechanism to deal with producing of incremental updates\n          \n          \n            \n                 * @return a {@link Flux} of query results. The ordering of query results corresponds to the ordering of queries being\n          \n          \n            \n                 * dispatched", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r452784398", "createdAt": "2020-07-10T11:23:24Z", "author": {"login": "smcvb"}, "path": "messaging/src/main/java/org/axonframework/queryhandling/ReactorQueryGateway.java", "diffHunk": "@@ -0,0 +1,547 @@\n+/*\n+ * Copyright (c) 2010-2020. Axon Framework\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.axonframework.queryhandling;\n+\n+import org.axonframework.messaging.ResultMessage;\n+import org.axonframework.messaging.reactive.ReactorMessageDispatchInterceptorSupport;\n+import org.axonframework.messaging.reactive.ReactorResultHandlerInterceptorSupport;\n+import org.axonframework.messaging.responsetypes.ResponseType;\n+import org.axonframework.messaging.responsetypes.ResponseTypes;\n+import org.reactivestreams.Publisher;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Mono;\n+import reactor.util.concurrent.Queues;\n+\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Function;\n+\n+/**\n+ * Variation of {@link QueryGateway}. Provides support for reactive return types such as {@link Mono} and {@link Flux}\n+ * from Project Reactor.\n+ *\n+ * @author Milan Savic\n+ * @since 4.4\n+ */\n+public interface ReactorQueryGateway extends ReactorMessageDispatchInterceptorSupport<QueryMessage<?, ?>>,\n+        ReactorResultHandlerInterceptorSupport<QueryMessage<?, ?>, ResultMessage<?>> {\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response with the given {@code responseType}\n+     * from a single source. The query name will be derived from the provided {@code query}. Execution may be\n+     * asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param query        The {@code query} to be sent\n+     * @param responseType A {@link Class} describing the desired response type\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(Q query, Class<R> responseType) {\n+        return query(query.getClass().getName(), query, responseType);\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response with the given {@code responseType}\n+     * from a single source. Execution may be asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(String queryName, Q query, Class<R> responseType) {\n+        return query(queryName, query, ResponseTypes.instanceOf(responseType));\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from a single source. The query name will be derived from the provided {@code query}. Execution may be\n+     * asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(Q query, ResponseType<R> responseType) {\n+        return query(query.getClass().getName(), query, responseType);\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from a single source. Execution may be asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    <R, Q> Mono<R> query(String queryName, Q query, ResponseType<R> responseType);\n+\n+    /**\n+     * Uses given Publisher of query messages to send incoming queries away. Queries will be sent sequentially - once a\n+     * result of Nth query arrives, (N + 1)th query is dispatched.\n+     *\n+     * @param queries a Publisher stream of queries to be dispatched\n+     * @return a Flux of query results. An ordering of query results corresponds to an ordering of queries being\n+     * dispatched\n+     *\n+     * @see #query(String, Object, ResponseType)\n+     * @see Flux#concatMap(Function)\n+     */\n+    default Flux<Object> query(Publisher<QueryMessage<?, ?>> queries) {\n+        return Flux.from(queries)\n+                   .concatMap(q -> query(q.getQueryName(), q.getPayload(), q.getResponseType()));\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from several sources. The returned {@link Flux} is completed when a {@code timeout} occurs or when all possible\n+     * results are received. The query name will be derived from the provided {@code query}. Execution may be\n+     * asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     * <b>Note</b>: Any {@code null} results will be filtered out by the {@link ReactorQueryGateway}. If you require\n+     * the {@code null} to be returned, we suggest using {@code QueryBus} instead.\n+     *\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param timeout      A timeout of {@code long} for the query\n+     * @param timeUnit     The selected {@link TimeUnit} for the given {@code timeout}\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Flux} containing the query results as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Flux<R> scatterGather(Q query, ResponseType<R> responseType, long timeout, TimeUnit timeUnit) {\n+        return scatterGather(query.getClass().getName(), query, responseType, timeout, timeUnit);\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from several sources. The returned {@link Flux} is completed when a {@code timeout} occurs or when all results\n+     * are received. Execution may be asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     * <b>Note</b>: Any {@code null} results will be filtered out by the {@link ReactorQueryGateway}. If you require\n+     * the {@code null} to be returned, we suggest using {@code QueryBus} instead.\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param timeout      A timeout of {@code long} for the query\n+     * @param timeUnit     The selected {@link TimeUnit} for the given {@code timeout}\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Flux} containing the query results as dictated by the given {@code responseType}\n+     */\n+    <R, Q> Flux<R> scatterGather(String queryName, Q query, ResponseType<R> responseType, long timeout,\n+                                 TimeUnit timeUnit);\n+\n+    /**\n+     * Uses given Publisher of queries to send incoming queries in scatter gather manner. Queries will be sent\n+     * sequentially - once a result of Nth query arrives, (N + 1)th query is dispatched. All queries will be dispatched\n+     * using given {@code timeout} and {@code timeUnit}.\n+     *\n+     * @param queries  a Publisher stream of queries to be dispatched\n+     * @param timeout  A timeout of {@code long} for the query\n+     * @param timeUnit The selected {@link TimeUnit} for the given {@code timeout}\n+     * @return a Flux of query results. An ordering of query results corresponds to an ordering of queries being\n+     * dispatched\n+     */\n+    default Flux<Object> scatterGather(Publisher<QueryMessage<?, ?>> queries, long timeout, TimeUnit timeUnit) {\n+        return Flux.from(queries)\n+                   .concatMap(q -> scatterGather(q.getQueryName(),\n+                                                 q.getPayload(),\n+                                                 q.getResponseType(),\n+                                                 timeout,\n+                                                 timeUnit));\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, returns initial result and keeps streaming\n+     * incremental updates until subscriber unsubscribes from Flux.\n+     * Should be used when response type of initial result and incremental update match.\n+     * (received at the moment the query is sent, until it is cancelled by the caller or closed by the emitting side).\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Flux}</b></p>\n+     * <p>\n+     * <b>Note</b>: Any {@code null} results, on the initial result or the updates, will be filtered out by the\n+     * {@link ReactorQueryGateway}. If you require the {@code null} to be returned for the initial and update results,\n+     * we suggest using the {@code QueryBus} instead.\n+     *\n+     * @param query      The {@code query} to be sent\n+     * @param resultType The response type used for this query\n+     * @param <Q>        The type of the query\n+     * @param <R>        The type of the result (initial & updates)\n+     * @return Flux which can be used to cancel receiving updates\n+     *\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage)\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage, SubscriptionQueryBackpressure, int)\n+     */\n+    default <Q, R> Flux<R> subscriptionQuery(Q query, ResponseType<R> resultType) {\n+        return subscriptionQuery(query, resultType, resultType)\n+                .flatMapMany(result -> result.initialResult()\n+                                             .concatWith(result.updates())\n+                                             .doFinally(signal -> result.close()));\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, returns initial result and keeps streaming\n+     * incremental updates until subscriber unsubscribes from Flux.\n+     * Should be used when response type of initial result and incremental update match.\n+     * (received at the moment the query is sent, until it is cancelled by the caller or closed by the emitting side).\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Flux}</b></p>\n+     * <p>\n+     * <b>Note</b>: Any {@code null} results, on the initial result or the updates, will be filtered out by the\n+     * {@link ReactorQueryGateway}. If you require the {@code null} to be returned for the initial and update results,\n+     * we suggest using the {@code QueryBus} instead.\n+     *\n+     * @param query      The {@code query} to be sent\n+     * @param resultType The response type used for this query\n+     * @param <Q>        The type of the query\n+     * @param <R>        The type of the result (initial & updates)\n+     * @return Flux which can be used to cancel receiving updates\n+     *\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage)\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage, SubscriptionQueryBackpressure, int)\n+     */\n+    default <Q, R> Flux<R> subscriptionQuery(Q query, Class<R> resultType) {\n+        return subscriptionQuery(query, ResponseTypes.instanceOf(resultType));\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, returns initial result and keeps streaming\n+     * incremental updates until subscriber unsubscribes from Flux.\n+     * Should be used when initial result contains multiple instances of response type and needs to be flatten.\n+     * Response type of initial response and incremental updates needs to match.\n+     * (received at the moment the query is sent, until it is cancelled by the caller or closed by the emitting side).\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Flux}</b></p>\n+     * <p>\n+     * <b>Note</b>: Any {@code null} results, on the initial result or the updates, will be filtered out by the\n+     * {@link ReactorQueryGateway}. If you require the {@code null} to be returned for the initial and update results,\n+     * we suggest using the {@code QueryBus} instead.\n+     *\n+     * @param query      The {@code query} to be sent\n+     * @param resultType The response type used for this query\n+     * @param <Q>        The type of the query\n+     * @param <R>        The type of the result (initial & updates)\n+     * @return Flux which can be used to cancel receiving updates\n+     *\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage)\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage, SubscriptionQueryBackpressure, int)\n+     */\n+    default <Q, R> Flux<R> subscriptionQueryMany(Q query, Class<R> resultType) {\n+        return subscriptionQuery(query,\n+                                 ResponseTypes.multipleInstancesOf(resultType),\n+                                 ResponseTypes.instanceOf(resultType))\n+                .flatMapMany(result -> result.initialResult()\n+                                             .flatMapMany(Flux::fromIterable)\n+                                             .concatWith(result.updates())\n+                                             .doFinally(signal -> result.close()));\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, and streams\n+     * incremental updates until subscriber unsubscribes from Flux.\n+     * Should be used when subscriber is interested only in updates.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Flux}</b></p>\n+     * <p>\n+     * <b>Note</b>: Any {@code null} results, will be filtered out by the\n+     * {@link ReactorQueryGateway}. If you require the {@code null} to be returned for the initial and update results,\n+     * we suggest using the {@code QueryBus} instead.\n+     *\n+     * @param query      The {@code query} to be sent\n+     * @param resultType The response type used for this query\n+     * @param <Q>        The type of the query\n+     * @param <R>        The type of the result (updates)\n+     * @return Flux which can be used to cancel receiving updates\n+     *\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage)\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage, SubscriptionQueryBackpressure, int)\n+     */\n+    default <Q, R> Flux<R> queryUpdates(Q query, ResponseType<R> resultType) {\n+        return subscriptionQuery(query, ResponseTypes.instanceOf(Void.class), resultType)\n+                .flatMapMany(result -> result.updates()\n+                                             .doFinally(signal -> result.close()));\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, and streams\n+     * incremental updates until subscriber unsubscribes from Flux.\n+     * Should be used when subscriber is interested only in updates.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Flux}</b></p>\n+     * <p>\n+     * <b>Note</b>: Any {@code null} results, will be filtered out by the\n+     * {@link ReactorQueryGateway}. If you require the {@code null} to be returned for the initial and update results,\n+     * we suggest using the {@code QueryBus} instead.\n+     *\n+     * @param query      The {@code query} to be sent\n+     * @param resultType The response type used for this query\n+     * @param <Q>        The type of the query\n+     * @param <R>        The type of the result (updates)\n+     * @return Flux which can be used to cancel receiving updates\n+     *\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage)\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage, SubscriptionQueryBackpressure, int)\n+     */\n+    default <Q, R> Flux<R> queryUpdates(Q query, Class<R> resultType) {\n+        return queryUpdates(query, ResponseTypes.instanceOf(resultType));\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus} and returns result containing initial response and\n+     * incremental updates (received at the moment the query is sent, until it is cancelled by the caller or closed by\n+     * the emitting side).\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     * <p>\n+     * <b>Note</b>: Any {@code null} results, on the initial result or the updates, will be filtered out by the\n+     * {@link ReactorQueryGateway}. If you require the {@code null} to be returned for the initial and update results,\n+     * we suggest using the {@code QueryBus} instead.\n+     *\n+     * @param query               The {@code query} to be sent\n+     * @param initialResponseType The initial response type used for this query\n+     * @param updateResponseType  The update response type used for this query\n+     * @param <Q>                 The type of the query\n+     * @param <I>                 The type of the initial response\n+     * @param <U>                 The type of the incremental update\n+     * @return registration which can be used to cancel receiving updates\n+     *\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage)\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage, SubscriptionQueryBackpressure, int)\n+     */\n+    default <Q, I, U> Mono<SubscriptionQueryResult<I, U>> subscriptionQuery(Q query, Class<I> initialResponseType,\n+                                                                            Class<U> updateResponseType) {\n+        return subscriptionQuery(query.getClass().getName(),\n+                                 query,\n+                                 initialResponseType,\n+                                 updateResponseType);\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus} and returns result containing initial response and\n+     * incremental updates (received at the moment the query is sent, until it is cancelled by the caller or closed by\n+     * the emitting side).\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     * <p>\n+     * <b>Note</b>: Any {@code null} results, on the initial result or the updates, will be filtered out by the\n+     * {@link ReactorQueryGateway}. If you require the {@code null} to be returned for the initial and update results,\n+     * we suggest using the {@code QueryBus} instead.\n+     *\n+     * @param queryName           A {@link String} describing query to be executed\n+     * @param query               The {@code query} to be sent\n+     * @param initialResponseType The initial response type used for this query\n+     * @param updateResponseType  The update response type used for this query\n+     * @param <Q>                 The type of the query\n+     * @param <I>                 The type of the initial response\n+     * @param <U>                 The type of the incremental update\n+     * @return registration which can be used to cancel receiving updates\n+     *\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage)\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage, SubscriptionQueryBackpressure, int)\n+     */\n+    default <Q, I, U> Mono<SubscriptionQueryResult<I, U>> subscriptionQuery(String queryName, Q query,\n+                                                                            Class<I> initialResponseType,\n+                                                                            Class<U> updateResponseType) {\n+        return subscriptionQuery(queryName,\n+                                 query,\n+                                 ResponseTypes.instanceOf(initialResponseType),\n+                                 ResponseTypes.instanceOf(updateResponseType),\n+                                 SubscriptionQueryBackpressure.defaultBackpressure());\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus} and returns result containing initial response and\n+     * incremental updates (received at the moment the query is sent, until it is cancelled by the caller or closed by\n+     * the emitting side).\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     * <p>\n+     * <b>Note</b>: Any {@code null} results, on the initial result or the updates, will be filtered out by the\n+     * {@link ReactorQueryGateway}. If you require the {@code null} to be returned for the initial and update results,\n+     * we suggest using the {@code QueryBus} instead.\n+     *\n+     * @param query               The {@code query} to be sent\n+     * @param initialResponseType The initial response type used for this query\n+     * @param updateResponseType  The update response type used for this query\n+     * @param <Q>                 The type of the query\n+     * @param <I>                 The type of the initial response\n+     * @param <U>                 The type of the incremental update\n+     * @return registration which can be used to cancel receiving updates\n+     *\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage)\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage, SubscriptionQueryBackpressure, int)\n+     */\n+    default <Q, I, U> Mono<SubscriptionQueryResult<I, U>> subscriptionQuery(Q query,\n+                                                                            ResponseType<I> initialResponseType,\n+                                                                            ResponseType<U> updateResponseType) {\n+        return subscriptionQuery(query.getClass().getName(),\n+                                 query,\n+                                 initialResponseType,\n+                                 updateResponseType,\n+                                 SubscriptionQueryBackpressure.defaultBackpressure());\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus} and returns result containing initial response and\n+     * incremental updates (received at the moment the query is sent, until it is cancelled by the caller or closed by\n+     * the emitting side).\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     * <p>\n+     * <b>Note</b>: Any {@code null} results, on the initial result or the updates, will be filtered out by the\n+     * {@link ReactorQueryGateway}. If you require the {@code null} to be returned for the initial and update results,\n+     * we suggest using the {@code QueryBus} instead.\n+     *\n+     * @param queryName           A {@link String} describing query to be executed\n+     * @param query               The {@code query} to be sent\n+     * @param initialResponseType The initial response type used for this query\n+     * @param updateResponseType  The update response type used for this query\n+     * @param backpressure        The backpressure mechanism to deal with producing of incremental updates\n+     * @param <Q>                 The type of the query\n+     * @param <I>                 The type of the initial response\n+     * @param <U>                 The type of the incremental update\n+     * @return registration which can be used to cancel receiving updates\n+     *\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage)\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage, SubscriptionQueryBackpressure, int)\n+     */\n+    default <Q, I, U> Mono<SubscriptionQueryResult<I, U>> subscriptionQuery(String queryName, Q query,\n+                                                                            ResponseType<I> initialResponseType,\n+                                                                            ResponseType<U> updateResponseType,\n+                                                                            SubscriptionQueryBackpressure backpressure) {\n+        return subscriptionQuery(queryName,\n+                                 query,\n+                                 initialResponseType,\n+                                 updateResponseType,\n+                                 backpressure,\n+                                 Queues.SMALL_BUFFER_SIZE);\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus} and returns result containing initial response and\n+     * incremental updates (received at the moment the query is sent, until it is cancelled by the caller or closed by\n+     * the emitting side).\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     * <p>\n+     * <b>Note</b>: Any {@code null} results, on the initial result or the updates, will be filtered out by the\n+     * {@link ReactorQueryGateway}. If you require the {@code null} to be returned for the initial and update results,\n+     * we suggest using the {@code QueryBus} instead.\n+     *\n+     * @param queryName           A {@link String} describing query to be executed\n+     * @param query               The {@code query} to be sent\n+     * @param initialResponseType The initial response type used for this query\n+     * @param updateResponseType  The update response type used for this query\n+     * @param backpressure        The backpressure mechanism to deal with producing of incremental updates\n+     * @param updateBufferSize    The size of buffer which accumulates updates before subscription to the {@code flux}\n+     *                            is made\n+     * @param <Q>                 The type of the query\n+     * @param <I>                 The type of the initial response\n+     * @param <U>                 The type of the incremental update\n+     * @return registration which can be used to cancel receiving updates\n+     *\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage)\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage, SubscriptionQueryBackpressure, int)\n+     */\n+    <Q, I, U> Mono<SubscriptionQueryResult<I, U>> subscriptionQuery(String queryName, Q query,\n+                                                                    ResponseType<I> initialResponseType,\n+                                                                    ResponseType<U> updateResponseType,\n+                                                                    SubscriptionQueryBackpressure backpressure,\n+                                                                    int updateBufferSize);\n+\n+    /**\n+     * Uses given Publisher of queries to send incoming queries away. Queries will be sent sequentially - once a result\n+     * of Nth query arrives, (N + 1)th query is dispatched.\n+     *\n+     * @param queries a Publisher stream of queries to be dispatched\n+     * @return a Flux of query results. An ordering of query results corresponds to an ordering of queries being\n+     * dispatched\n+     *\n+     * @see #subscriptionQuery(String, Object, Class, Class)\n+     * @see Flux#concatMap(Function)\n+     */\n+    default Flux<SubscriptionQueryResult<?, ?>> subscriptionQuery( // NOSONAR\n+                                                                   Publisher<SubscriptionQueryMessage<?, ?, ?>> queries) {\n+        return subscriptionQuery(queries, SubscriptionQueryBackpressure.defaultBackpressure());\n+    }\n+\n+    /**\n+     * Uses given Publisher of queries to send incoming queries away. Queries will be sent sequentially - once a result\n+     * of Nth query arrives, (N + 1)th query is dispatched. All queries will be dispatched using given {@code\n+     * backpressure}.\n+     *\n+     * @param queries      a Publisher stream of queries to be dispatched\n+     * @param backpressure The backpressure mechanism to deal with producing of incremental updates\n+     * @return a Flux of query results. An ordering of query results corresponds to an ordering of queries being\n+     * dispatched", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "98865ab1427e4d879301c1bf542842eccc8aa3c3"}, "originalPosition": 509}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mjc4NDg0OA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * Uses given Publisher of queries to send incoming queries away. Queries will be sent sequentially - once a result\n          \n          \n            \n                 * of Nth query arrives, (N + 1)th query is dispatched. All queries will be dispatched using given {@code\n          \n          \n            \n                 * backpressure} and {@code updateBufferSize}.\n          \n          \n            \n                 *\n          \n          \n            \n                 * @param queries          a Publisher stream of queries to be dispatched\n          \n          \n            \n                 * @param backpressure     The backpressure mechanism to deal with producing of incremental updates\n          \n          \n            \n                 * @param updateBufferSize The size of buffer which accumulates updates before subscription to the {@code flux}\n          \n          \n            \n                 *                         is made\n          \n          \n            \n                 * @return a Flux of query results. An ordering of query results corresponds to an ordering of queries being\n          \n          \n            \n                 * dispatched\n          \n          \n            \n                 * Uses the given {@link Publisher} of {@link SubscriptionQueryMessage}s to send incoming queries away. Queries will be sent sequentially. Once the result\n          \n          \n            \n                 * of Nth query arrives, the (N + 1)th query is dispatched. All queries will be dispatched using given {@code\n          \n          \n            \n                 * backpressure} and {@code updateBufferSize}.\n          \n          \n            \n                 *\n          \n          \n            \n                 * @param queries          a {@link Publisher} stream of queries to be dispatched\n          \n          \n            \n                 * @param backpressure     the backpressure mechanism to deal with producing of incremental updates\n          \n          \n            \n                 * @param updateBufferSize the size of buffer which accumulates updates before subscription to the {@code flux}\n          \n          \n            \n                 *                         is made\n          \n          \n            \n                 * @return a {@link Flux} of query results. The ordering of query results corresponds to the ordering of queries being\n          \n          \n            \n                 * dispatched", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r452784848", "createdAt": "2020-07-10T11:24:28Z", "author": {"login": "smcvb"}, "path": "messaging/src/main/java/org/axonframework/queryhandling/ReactorQueryGateway.java", "diffHunk": "@@ -0,0 +1,547 @@\n+/*\n+ * Copyright (c) 2010-2020. Axon Framework\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.axonframework.queryhandling;\n+\n+import org.axonframework.messaging.ResultMessage;\n+import org.axonframework.messaging.reactive.ReactorMessageDispatchInterceptorSupport;\n+import org.axonframework.messaging.reactive.ReactorResultHandlerInterceptorSupport;\n+import org.axonframework.messaging.responsetypes.ResponseType;\n+import org.axonframework.messaging.responsetypes.ResponseTypes;\n+import org.reactivestreams.Publisher;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Mono;\n+import reactor.util.concurrent.Queues;\n+\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Function;\n+\n+/**\n+ * Variation of {@link QueryGateway}. Provides support for reactive return types such as {@link Mono} and {@link Flux}\n+ * from Project Reactor.\n+ *\n+ * @author Milan Savic\n+ * @since 4.4\n+ */\n+public interface ReactorQueryGateway extends ReactorMessageDispatchInterceptorSupport<QueryMessage<?, ?>>,\n+        ReactorResultHandlerInterceptorSupport<QueryMessage<?, ?>, ResultMessage<?>> {\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response with the given {@code responseType}\n+     * from a single source. The query name will be derived from the provided {@code query}. Execution may be\n+     * asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param query        The {@code query} to be sent\n+     * @param responseType A {@link Class} describing the desired response type\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(Q query, Class<R> responseType) {\n+        return query(query.getClass().getName(), query, responseType);\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response with the given {@code responseType}\n+     * from a single source. Execution may be asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(String queryName, Q query, Class<R> responseType) {\n+        return query(queryName, query, ResponseTypes.instanceOf(responseType));\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from a single source. The query name will be derived from the provided {@code query}. Execution may be\n+     * asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(Q query, ResponseType<R> responseType) {\n+        return query(query.getClass().getName(), query, responseType);\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from a single source. Execution may be asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    <R, Q> Mono<R> query(String queryName, Q query, ResponseType<R> responseType);\n+\n+    /**\n+     * Uses given Publisher of query messages to send incoming queries away. Queries will be sent sequentially - once a\n+     * result of Nth query arrives, (N + 1)th query is dispatched.\n+     *\n+     * @param queries a Publisher stream of queries to be dispatched\n+     * @return a Flux of query results. An ordering of query results corresponds to an ordering of queries being\n+     * dispatched\n+     *\n+     * @see #query(String, Object, ResponseType)\n+     * @see Flux#concatMap(Function)\n+     */\n+    default Flux<Object> query(Publisher<QueryMessage<?, ?>> queries) {\n+        return Flux.from(queries)\n+                   .concatMap(q -> query(q.getQueryName(), q.getPayload(), q.getResponseType()));\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from several sources. The returned {@link Flux} is completed when a {@code timeout} occurs or when all possible\n+     * results are received. The query name will be derived from the provided {@code query}. Execution may be\n+     * asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     * <b>Note</b>: Any {@code null} results will be filtered out by the {@link ReactorQueryGateway}. If you require\n+     * the {@code null} to be returned, we suggest using {@code QueryBus} instead.\n+     *\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param timeout      A timeout of {@code long} for the query\n+     * @param timeUnit     The selected {@link TimeUnit} for the given {@code timeout}\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Flux} containing the query results as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Flux<R> scatterGather(Q query, ResponseType<R> responseType, long timeout, TimeUnit timeUnit) {\n+        return scatterGather(query.getClass().getName(), query, responseType, timeout, timeUnit);\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from several sources. The returned {@link Flux} is completed when a {@code timeout} occurs or when all results\n+     * are received. Execution may be asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     * <b>Note</b>: Any {@code null} results will be filtered out by the {@link ReactorQueryGateway}. If you require\n+     * the {@code null} to be returned, we suggest using {@code QueryBus} instead.\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param timeout      A timeout of {@code long} for the query\n+     * @param timeUnit     The selected {@link TimeUnit} for the given {@code timeout}\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Flux} containing the query results as dictated by the given {@code responseType}\n+     */\n+    <R, Q> Flux<R> scatterGather(String queryName, Q query, ResponseType<R> responseType, long timeout,\n+                                 TimeUnit timeUnit);\n+\n+    /**\n+     * Uses given Publisher of queries to send incoming queries in scatter gather manner. Queries will be sent\n+     * sequentially - once a result of Nth query arrives, (N + 1)th query is dispatched. All queries will be dispatched\n+     * using given {@code timeout} and {@code timeUnit}.\n+     *\n+     * @param queries  a Publisher stream of queries to be dispatched\n+     * @param timeout  A timeout of {@code long} for the query\n+     * @param timeUnit The selected {@link TimeUnit} for the given {@code timeout}\n+     * @return a Flux of query results. An ordering of query results corresponds to an ordering of queries being\n+     * dispatched\n+     */\n+    default Flux<Object> scatterGather(Publisher<QueryMessage<?, ?>> queries, long timeout, TimeUnit timeUnit) {\n+        return Flux.from(queries)\n+                   .concatMap(q -> scatterGather(q.getQueryName(),\n+                                                 q.getPayload(),\n+                                                 q.getResponseType(),\n+                                                 timeout,\n+                                                 timeUnit));\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, returns initial result and keeps streaming\n+     * incremental updates until subscriber unsubscribes from Flux.\n+     * Should be used when response type of initial result and incremental update match.\n+     * (received at the moment the query is sent, until it is cancelled by the caller or closed by the emitting side).\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Flux}</b></p>\n+     * <p>\n+     * <b>Note</b>: Any {@code null} results, on the initial result or the updates, will be filtered out by the\n+     * {@link ReactorQueryGateway}. If you require the {@code null} to be returned for the initial and update results,\n+     * we suggest using the {@code QueryBus} instead.\n+     *\n+     * @param query      The {@code query} to be sent\n+     * @param resultType The response type used for this query\n+     * @param <Q>        The type of the query\n+     * @param <R>        The type of the result (initial & updates)\n+     * @return Flux which can be used to cancel receiving updates\n+     *\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage)\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage, SubscriptionQueryBackpressure, int)\n+     */\n+    default <Q, R> Flux<R> subscriptionQuery(Q query, ResponseType<R> resultType) {\n+        return subscriptionQuery(query, resultType, resultType)\n+                .flatMapMany(result -> result.initialResult()\n+                                             .concatWith(result.updates())\n+                                             .doFinally(signal -> result.close()));\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, returns initial result and keeps streaming\n+     * incremental updates until subscriber unsubscribes from Flux.\n+     * Should be used when response type of initial result and incremental update match.\n+     * (received at the moment the query is sent, until it is cancelled by the caller or closed by the emitting side).\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Flux}</b></p>\n+     * <p>\n+     * <b>Note</b>: Any {@code null} results, on the initial result or the updates, will be filtered out by the\n+     * {@link ReactorQueryGateway}. If you require the {@code null} to be returned for the initial and update results,\n+     * we suggest using the {@code QueryBus} instead.\n+     *\n+     * @param query      The {@code query} to be sent\n+     * @param resultType The response type used for this query\n+     * @param <Q>        The type of the query\n+     * @param <R>        The type of the result (initial & updates)\n+     * @return Flux which can be used to cancel receiving updates\n+     *\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage)\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage, SubscriptionQueryBackpressure, int)\n+     */\n+    default <Q, R> Flux<R> subscriptionQuery(Q query, Class<R> resultType) {\n+        return subscriptionQuery(query, ResponseTypes.instanceOf(resultType));\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, returns initial result and keeps streaming\n+     * incremental updates until subscriber unsubscribes from Flux.\n+     * Should be used when initial result contains multiple instances of response type and needs to be flatten.\n+     * Response type of initial response and incremental updates needs to match.\n+     * (received at the moment the query is sent, until it is cancelled by the caller or closed by the emitting side).\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Flux}</b></p>\n+     * <p>\n+     * <b>Note</b>: Any {@code null} results, on the initial result or the updates, will be filtered out by the\n+     * {@link ReactorQueryGateway}. If you require the {@code null} to be returned for the initial and update results,\n+     * we suggest using the {@code QueryBus} instead.\n+     *\n+     * @param query      The {@code query} to be sent\n+     * @param resultType The response type used for this query\n+     * @param <Q>        The type of the query\n+     * @param <R>        The type of the result (initial & updates)\n+     * @return Flux which can be used to cancel receiving updates\n+     *\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage)\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage, SubscriptionQueryBackpressure, int)\n+     */\n+    default <Q, R> Flux<R> subscriptionQueryMany(Q query, Class<R> resultType) {\n+        return subscriptionQuery(query,\n+                                 ResponseTypes.multipleInstancesOf(resultType),\n+                                 ResponseTypes.instanceOf(resultType))\n+                .flatMapMany(result -> result.initialResult()\n+                                             .flatMapMany(Flux::fromIterable)\n+                                             .concatWith(result.updates())\n+                                             .doFinally(signal -> result.close()));\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, and streams\n+     * incremental updates until subscriber unsubscribes from Flux.\n+     * Should be used when subscriber is interested only in updates.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Flux}</b></p>\n+     * <p>\n+     * <b>Note</b>: Any {@code null} results, will be filtered out by the\n+     * {@link ReactorQueryGateway}. If you require the {@code null} to be returned for the initial and update results,\n+     * we suggest using the {@code QueryBus} instead.\n+     *\n+     * @param query      The {@code query} to be sent\n+     * @param resultType The response type used for this query\n+     * @param <Q>        The type of the query\n+     * @param <R>        The type of the result (updates)\n+     * @return Flux which can be used to cancel receiving updates\n+     *\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage)\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage, SubscriptionQueryBackpressure, int)\n+     */\n+    default <Q, R> Flux<R> queryUpdates(Q query, ResponseType<R> resultType) {\n+        return subscriptionQuery(query, ResponseTypes.instanceOf(Void.class), resultType)\n+                .flatMapMany(result -> result.updates()\n+                                             .doFinally(signal -> result.close()));\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, and streams\n+     * incremental updates until subscriber unsubscribes from Flux.\n+     * Should be used when subscriber is interested only in updates.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Flux}</b></p>\n+     * <p>\n+     * <b>Note</b>: Any {@code null} results, will be filtered out by the\n+     * {@link ReactorQueryGateway}. If you require the {@code null} to be returned for the initial and update results,\n+     * we suggest using the {@code QueryBus} instead.\n+     *\n+     * @param query      The {@code query} to be sent\n+     * @param resultType The response type used for this query\n+     * @param <Q>        The type of the query\n+     * @param <R>        The type of the result (updates)\n+     * @return Flux which can be used to cancel receiving updates\n+     *\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage)\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage, SubscriptionQueryBackpressure, int)\n+     */\n+    default <Q, R> Flux<R> queryUpdates(Q query, Class<R> resultType) {\n+        return queryUpdates(query, ResponseTypes.instanceOf(resultType));\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus} and returns result containing initial response and\n+     * incremental updates (received at the moment the query is sent, until it is cancelled by the caller or closed by\n+     * the emitting side).\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     * <p>\n+     * <b>Note</b>: Any {@code null} results, on the initial result or the updates, will be filtered out by the\n+     * {@link ReactorQueryGateway}. If you require the {@code null} to be returned for the initial and update results,\n+     * we suggest using the {@code QueryBus} instead.\n+     *\n+     * @param query               The {@code query} to be sent\n+     * @param initialResponseType The initial response type used for this query\n+     * @param updateResponseType  The update response type used for this query\n+     * @param <Q>                 The type of the query\n+     * @param <I>                 The type of the initial response\n+     * @param <U>                 The type of the incremental update\n+     * @return registration which can be used to cancel receiving updates\n+     *\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage)\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage, SubscriptionQueryBackpressure, int)\n+     */\n+    default <Q, I, U> Mono<SubscriptionQueryResult<I, U>> subscriptionQuery(Q query, Class<I> initialResponseType,\n+                                                                            Class<U> updateResponseType) {\n+        return subscriptionQuery(query.getClass().getName(),\n+                                 query,\n+                                 initialResponseType,\n+                                 updateResponseType);\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus} and returns result containing initial response and\n+     * incremental updates (received at the moment the query is sent, until it is cancelled by the caller or closed by\n+     * the emitting side).\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     * <p>\n+     * <b>Note</b>: Any {@code null} results, on the initial result or the updates, will be filtered out by the\n+     * {@link ReactorQueryGateway}. If you require the {@code null} to be returned for the initial and update results,\n+     * we suggest using the {@code QueryBus} instead.\n+     *\n+     * @param queryName           A {@link String} describing query to be executed\n+     * @param query               The {@code query} to be sent\n+     * @param initialResponseType The initial response type used for this query\n+     * @param updateResponseType  The update response type used for this query\n+     * @param <Q>                 The type of the query\n+     * @param <I>                 The type of the initial response\n+     * @param <U>                 The type of the incremental update\n+     * @return registration which can be used to cancel receiving updates\n+     *\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage)\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage, SubscriptionQueryBackpressure, int)\n+     */\n+    default <Q, I, U> Mono<SubscriptionQueryResult<I, U>> subscriptionQuery(String queryName, Q query,\n+                                                                            Class<I> initialResponseType,\n+                                                                            Class<U> updateResponseType) {\n+        return subscriptionQuery(queryName,\n+                                 query,\n+                                 ResponseTypes.instanceOf(initialResponseType),\n+                                 ResponseTypes.instanceOf(updateResponseType),\n+                                 SubscriptionQueryBackpressure.defaultBackpressure());\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus} and returns result containing initial response and\n+     * incremental updates (received at the moment the query is sent, until it is cancelled by the caller or closed by\n+     * the emitting side).\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     * <p>\n+     * <b>Note</b>: Any {@code null} results, on the initial result or the updates, will be filtered out by the\n+     * {@link ReactorQueryGateway}. If you require the {@code null} to be returned for the initial and update results,\n+     * we suggest using the {@code QueryBus} instead.\n+     *\n+     * @param query               The {@code query} to be sent\n+     * @param initialResponseType The initial response type used for this query\n+     * @param updateResponseType  The update response type used for this query\n+     * @param <Q>                 The type of the query\n+     * @param <I>                 The type of the initial response\n+     * @param <U>                 The type of the incremental update\n+     * @return registration which can be used to cancel receiving updates\n+     *\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage)\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage, SubscriptionQueryBackpressure, int)\n+     */\n+    default <Q, I, U> Mono<SubscriptionQueryResult<I, U>> subscriptionQuery(Q query,\n+                                                                            ResponseType<I> initialResponseType,\n+                                                                            ResponseType<U> updateResponseType) {\n+        return subscriptionQuery(query.getClass().getName(),\n+                                 query,\n+                                 initialResponseType,\n+                                 updateResponseType,\n+                                 SubscriptionQueryBackpressure.defaultBackpressure());\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus} and returns result containing initial response and\n+     * incremental updates (received at the moment the query is sent, until it is cancelled by the caller or closed by\n+     * the emitting side).\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     * <p>\n+     * <b>Note</b>: Any {@code null} results, on the initial result or the updates, will be filtered out by the\n+     * {@link ReactorQueryGateway}. If you require the {@code null} to be returned for the initial and update results,\n+     * we suggest using the {@code QueryBus} instead.\n+     *\n+     * @param queryName           A {@link String} describing query to be executed\n+     * @param query               The {@code query} to be sent\n+     * @param initialResponseType The initial response type used for this query\n+     * @param updateResponseType  The update response type used for this query\n+     * @param backpressure        The backpressure mechanism to deal with producing of incremental updates\n+     * @param <Q>                 The type of the query\n+     * @param <I>                 The type of the initial response\n+     * @param <U>                 The type of the incremental update\n+     * @return registration which can be used to cancel receiving updates\n+     *\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage)\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage, SubscriptionQueryBackpressure, int)\n+     */\n+    default <Q, I, U> Mono<SubscriptionQueryResult<I, U>> subscriptionQuery(String queryName, Q query,\n+                                                                            ResponseType<I> initialResponseType,\n+                                                                            ResponseType<U> updateResponseType,\n+                                                                            SubscriptionQueryBackpressure backpressure) {\n+        return subscriptionQuery(queryName,\n+                                 query,\n+                                 initialResponseType,\n+                                 updateResponseType,\n+                                 backpressure,\n+                                 Queues.SMALL_BUFFER_SIZE);\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus} and returns result containing initial response and\n+     * incremental updates (received at the moment the query is sent, until it is cancelled by the caller or closed by\n+     * the emitting side).\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     * <p>\n+     * <b>Note</b>: Any {@code null} results, on the initial result or the updates, will be filtered out by the\n+     * {@link ReactorQueryGateway}. If you require the {@code null} to be returned for the initial and update results,\n+     * we suggest using the {@code QueryBus} instead.\n+     *\n+     * @param queryName           A {@link String} describing query to be executed\n+     * @param query               The {@code query} to be sent\n+     * @param initialResponseType The initial response type used for this query\n+     * @param updateResponseType  The update response type used for this query\n+     * @param backpressure        The backpressure mechanism to deal with producing of incremental updates\n+     * @param updateBufferSize    The size of buffer which accumulates updates before subscription to the {@code flux}\n+     *                            is made\n+     * @param <Q>                 The type of the query\n+     * @param <I>                 The type of the initial response\n+     * @param <U>                 The type of the incremental update\n+     * @return registration which can be used to cancel receiving updates\n+     *\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage)\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage, SubscriptionQueryBackpressure, int)\n+     */\n+    <Q, I, U> Mono<SubscriptionQueryResult<I, U>> subscriptionQuery(String queryName, Q query,\n+                                                                    ResponseType<I> initialResponseType,\n+                                                                    ResponseType<U> updateResponseType,\n+                                                                    SubscriptionQueryBackpressure backpressure,\n+                                                                    int updateBufferSize);\n+\n+    /**\n+     * Uses given Publisher of queries to send incoming queries away. Queries will be sent sequentially - once a result\n+     * of Nth query arrives, (N + 1)th query is dispatched.\n+     *\n+     * @param queries a Publisher stream of queries to be dispatched\n+     * @return a Flux of query results. An ordering of query results corresponds to an ordering of queries being\n+     * dispatched\n+     *\n+     * @see #subscriptionQuery(String, Object, Class, Class)\n+     * @see Flux#concatMap(Function)\n+     */\n+    default Flux<SubscriptionQueryResult<?, ?>> subscriptionQuery( // NOSONAR\n+                                                                   Publisher<SubscriptionQueryMessage<?, ?, ?>> queries) {\n+        return subscriptionQuery(queries, SubscriptionQueryBackpressure.defaultBackpressure());\n+    }\n+\n+    /**\n+     * Uses given Publisher of queries to send incoming queries away. Queries will be sent sequentially - once a result\n+     * of Nth query arrives, (N + 1)th query is dispatched. All queries will be dispatched using given {@code\n+     * backpressure}.\n+     *\n+     * @param queries      a Publisher stream of queries to be dispatched\n+     * @param backpressure The backpressure mechanism to deal with producing of incremental updates\n+     * @return a Flux of query results. An ordering of query results corresponds to an ordering of queries being\n+     * dispatched\n+     *\n+     * @see #subscriptionQuery(String, Object, Class, Class)\n+     * @see Flux#concatMap(Function)\n+     */\n+    default Flux<SubscriptionQueryResult<?, ?>> subscriptionQuery( // NOSONAR\n+                                                                   Publisher<SubscriptionQueryMessage<?, ?, ?>> queries,\n+                                                                   SubscriptionQueryBackpressure backpressure) {\n+        return subscriptionQuery(queries, backpressure, Queues.SMALL_BUFFER_SIZE);\n+    }\n+\n+    /**\n+     * Uses given Publisher of queries to send incoming queries away. Queries will be sent sequentially - once a result\n+     * of Nth query arrives, (N + 1)th query is dispatched. All queries will be dispatched using given {@code\n+     * backpressure} and {@code updateBufferSize}.\n+     *\n+     * @param queries          a Publisher stream of queries to be dispatched\n+     * @param backpressure     The backpressure mechanism to deal with producing of incremental updates\n+     * @param updateBufferSize The size of buffer which accumulates updates before subscription to the {@code flux}\n+     *                         is made\n+     * @return a Flux of query results. An ordering of query results corresponds to an ordering of queries being\n+     * dispatched", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "98865ab1427e4d879301c1bf542842eccc8aa3c3"}, "originalPosition": 530}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mjc4NTc1Nw==", "bodyText": "Might be more reasonable to reuse the org.axonframework.test.utils.RecordingCommandBus instead of building a new.", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r452785757", "createdAt": "2020-07-10T11:26:39Z", "author": {"login": "smcvb"}, "path": "messaging/src/test/java/org/axonframework/commandhandling/gateway/CommandBusStub.java", "diffHunk": "@@ -0,0 +1,70 @@\n+package org.axonframework.commandhandling.gateway;\n+\n+import org.axonframework.commandhandling.CommandBus;\n+import org.axonframework.commandhandling.CommandCallback;\n+import org.axonframework.commandhandling.CommandMessage;\n+import org.axonframework.commandhandling.CommandResultMessage;\n+import org.axonframework.commandhandling.GenericCommandResultMessage;\n+import org.axonframework.common.Registration;\n+import org.axonframework.messaging.MessageDispatchInterceptor;\n+import org.axonframework.messaging.MessageHandler;\n+import org.axonframework.messaging.MessageHandlerInterceptor;\n+\n+import java.util.LinkedList;\n+\n+/**\n+ * A stub of {@link CommandBus} that captures sent commands.\n+ *\n+ * @author Sara Pellegrini\n+ * @since 4.4\n+ */\n+public class CommandBusStub implements CommandBus {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "98865ab1427e4d879301c1bf542842eccc8aa3c3"}, "originalPosition": 21}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mjc4OTAxNg==", "bodyText": "\"reactiveness\", nice \ud83d\ude0e", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r452789016", "createdAt": "2020-07-10T11:34:34Z", "author": {"login": "smcvb"}, "path": "messaging/src/main/java/org/axonframework/commandhandling/gateway/DefaultReactorCommandGateway.java", "diffHunk": "@@ -0,0 +1,253 @@\n+/*\n+ * Copyright (c) 2010-2020. Axon Framework\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.axonframework.commandhandling.gateway;\n+\n+import org.axonframework.commandhandling.*;\n+import org.axonframework.commandhandling.callbacks.ReactiveCallback;\n+import org.axonframework.common.AxonConfigurationException;\n+import org.axonframework.common.Registration;\n+import org.axonframework.messaging.ResultMessage;\n+import org.axonframework.messaging.reactive.ReactorMessageDispatchInterceptor;\n+import org.axonframework.messaging.reactive.ReactorResultHandlerInterceptor;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Mono;\n+import reactor.util.function.Tuple2;\n+\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.concurrent.CopyOnWriteArrayList;\n+\n+import static java.util.Arrays.asList;\n+import static org.axonframework.common.BuilderUtils.assertNonNull;\n+\n+/**\n+ * Implementation of the {@link ReactorCommandGateway} that uses Project Reactor to achieve reactiveness.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "98865ab1427e4d879301c1bf542842eccc8aa3c3"}, "originalPosition": 38}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mjc5MDc3NA==", "bodyText": "Curious: do we need to do Flux.from(reactiveCallback) because the the ReactiveCallback is an implementation of Publisher? Looks somewhat funky to do Mono.just(Flux.from(...)), so assuming you cannot make a Mono from a Publisher directly?", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r452790774", "createdAt": "2020-07-10T11:39:15Z", "author": {"login": "smcvb"}, "path": "messaging/src/main/java/org/axonframework/commandhandling/gateway/DefaultReactorCommandGateway.java", "diffHunk": "@@ -0,0 +1,253 @@\n+/*\n+ * Copyright (c) 2010-2020. Axon Framework\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.axonframework.commandhandling.gateway;\n+\n+import org.axonframework.commandhandling.*;\n+import org.axonframework.commandhandling.callbacks.ReactiveCallback;\n+import org.axonframework.common.AxonConfigurationException;\n+import org.axonframework.common.Registration;\n+import org.axonframework.messaging.ResultMessage;\n+import org.axonframework.messaging.reactive.ReactorMessageDispatchInterceptor;\n+import org.axonframework.messaging.reactive.ReactorResultHandlerInterceptor;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Mono;\n+import reactor.util.function.Tuple2;\n+\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.concurrent.CopyOnWriteArrayList;\n+\n+import static java.util.Arrays.asList;\n+import static org.axonframework.common.BuilderUtils.assertNonNull;\n+\n+/**\n+ * Implementation of the {@link ReactorCommandGateway} that uses Project Reactor to achieve reactiveness.\n+ *\n+ * @author Milan Savic\n+ * @since 4.4\n+ */\n+public class DefaultReactorCommandGateway implements ReactorCommandGateway {\n+\n+    private final CommandBus commandBus;\n+    private final RetryScheduler retryScheduler;\n+    private final List<ReactorMessageDispatchInterceptor<CommandMessage<?>>> dispatchInterceptors;\n+    private final List<ReactorResultHandlerInterceptor<CommandMessage<?>, CommandResultMessage<?>>> resultInterceptors;\n+\n+    /**\n+     * Creates an instance of {@link DefaultReactorCommandGateway} based on the fields contained in the {@link\n+     * Builder}.\n+     * <p>\n+     * Will assert that the {@link CommandBus} is not {@code null} and throws an {@link AxonConfigurationException} if\n+     * it is.\n+     * </p>\n+     *\n+     * @param builder the {@link Builder} used to instantiate a {@link DefaultReactorCommandGateway} instance\n+     */\n+    protected DefaultReactorCommandGateway(Builder builder) {\n+        builder.validate();\n+        this.commandBus = builder.commandBus;\n+        this.retryScheduler = builder.retryScheduler;\n+        this.dispatchInterceptors = builder.dispatchInterceptors;\n+        this.resultInterceptors = builder.resultInterceptors;\n+    }\n+\n+    /**\n+     * Instantiate a Builder to be able to create a {@link DefaultReactorCommandGateway}.\n+     * <p>\n+     * The {@code dispatchInterceptors} are defaulted to an empty list.\n+     * The {@code resultHandlerInterceptors} are defaulted to an empty list.\n+     * The {@link CommandBus} is a <b>hard requirement</b> and as such should be provided.\n+     * </p>\n+     *\n+     * @return a Builder to be able to create a {@link DefaultReactorCommandGateway}\n+     */\n+    public static Builder builder() {\n+        return new Builder();\n+    }\n+\n+    @Override\n+    public <R> Mono<R> send(Object command) {\n+        //noinspection unchecked\n+        return Mono.<CommandMessage<?>>just(GenericCommandMessage.asCommandMessage(command))\n+                .transform(this::processCommandInterceptors)\n+                .flatMap(this::dispatchCommand)\n+                .flatMap(this::processResultsInterceptors)\n+                .transform(this::getPayload);\n+    }\n+\n+    @Override\n+    public Registration registerDispatchInterceptor(ReactorMessageDispatchInterceptor<CommandMessage<?>> interceptor) {\n+        dispatchInterceptors.add(interceptor);\n+        return () -> dispatchInterceptors.remove(interceptor);\n+    }\n+\n+    @Override\n+    public Registration registerResultHandlerInterceptor(\n+            ReactorResultHandlerInterceptor<CommandMessage<?>, CommandResultMessage<?>> interceptor) {\n+        resultInterceptors.add(interceptor);\n+        return () -> resultInterceptors.remove(interceptor);\n+    }\n+\n+    private Mono<CommandMessage<?>> processCommandInterceptors(Mono<CommandMessage<?>> commandMessage) {\n+        return Flux.fromIterable(dispatchInterceptors)\n+                   .reduce(commandMessage, (command, interceptor) -> interceptor.intercept(command))\n+                   .flatMap(Mono::from);\n+    }\n+\n+    private <C, R> Mono<Tuple2<CommandMessage<C>, Flux<CommandResultMessage<? extends R>>>> dispatchCommand(\n+            CommandMessage<C> commandMessage) {\n+        ReactiveCallback<C, R> reactiveCallback = new ReactiveCallback<>();\n+        CommandCallback<C, R> callback = reactiveCallback;\n+        if (retryScheduler != null) {\n+            callback = new RetryingCallback<>(callback, retryScheduler, commandBus);\n+        }\n+        commandBus.dispatch(commandMessage, callback);\n+        return Mono.just(commandMessage).zipWith(Mono.just(Flux.from(reactiveCallback)));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "98865ab1427e4d879301c1bf542842eccc8aa3c3"}, "originalPosition": 119}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mjc5MTk2Nw==", "bodyText": "What makes null a response type to filter out? Couldn't a null be valid as a command response?", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r452791967", "createdAt": "2020-07-10T11:42:08Z", "author": {"login": "smcvb"}, "path": "messaging/src/main/java/org/axonframework/commandhandling/gateway/DefaultReactorCommandGateway.java", "diffHunk": "@@ -0,0 +1,253 @@\n+/*\n+ * Copyright (c) 2010-2020. Axon Framework\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.axonframework.commandhandling.gateway;\n+\n+import org.axonframework.commandhandling.*;\n+import org.axonframework.commandhandling.callbacks.ReactiveCallback;\n+import org.axonframework.common.AxonConfigurationException;\n+import org.axonframework.common.Registration;\n+import org.axonframework.messaging.ResultMessage;\n+import org.axonframework.messaging.reactive.ReactorMessageDispatchInterceptor;\n+import org.axonframework.messaging.reactive.ReactorResultHandlerInterceptor;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Mono;\n+import reactor.util.function.Tuple2;\n+\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.concurrent.CopyOnWriteArrayList;\n+\n+import static java.util.Arrays.asList;\n+import static org.axonframework.common.BuilderUtils.assertNonNull;\n+\n+/**\n+ * Implementation of the {@link ReactorCommandGateway} that uses Project Reactor to achieve reactiveness.\n+ *\n+ * @author Milan Savic\n+ * @since 4.4\n+ */\n+public class DefaultReactorCommandGateway implements ReactorCommandGateway {\n+\n+    private final CommandBus commandBus;\n+    private final RetryScheduler retryScheduler;\n+    private final List<ReactorMessageDispatchInterceptor<CommandMessage<?>>> dispatchInterceptors;\n+    private final List<ReactorResultHandlerInterceptor<CommandMessage<?>, CommandResultMessage<?>>> resultInterceptors;\n+\n+    /**\n+     * Creates an instance of {@link DefaultReactorCommandGateway} based on the fields contained in the {@link\n+     * Builder}.\n+     * <p>\n+     * Will assert that the {@link CommandBus} is not {@code null} and throws an {@link AxonConfigurationException} if\n+     * it is.\n+     * </p>\n+     *\n+     * @param builder the {@link Builder} used to instantiate a {@link DefaultReactorCommandGateway} instance\n+     */\n+    protected DefaultReactorCommandGateway(Builder builder) {\n+        builder.validate();\n+        this.commandBus = builder.commandBus;\n+        this.retryScheduler = builder.retryScheduler;\n+        this.dispatchInterceptors = builder.dispatchInterceptors;\n+        this.resultInterceptors = builder.resultInterceptors;\n+    }\n+\n+    /**\n+     * Instantiate a Builder to be able to create a {@link DefaultReactorCommandGateway}.\n+     * <p>\n+     * The {@code dispatchInterceptors} are defaulted to an empty list.\n+     * The {@code resultHandlerInterceptors} are defaulted to an empty list.\n+     * The {@link CommandBus} is a <b>hard requirement</b> and as such should be provided.\n+     * </p>\n+     *\n+     * @return a Builder to be able to create a {@link DefaultReactorCommandGateway}\n+     */\n+    public static Builder builder() {\n+        return new Builder();\n+    }\n+\n+    @Override\n+    public <R> Mono<R> send(Object command) {\n+        //noinspection unchecked\n+        return Mono.<CommandMessage<?>>just(GenericCommandMessage.asCommandMessage(command))\n+                .transform(this::processCommandInterceptors)\n+                .flatMap(this::dispatchCommand)\n+                .flatMap(this::processResultsInterceptors)\n+                .transform(this::getPayload);\n+    }\n+\n+    @Override\n+    public Registration registerDispatchInterceptor(ReactorMessageDispatchInterceptor<CommandMessage<?>> interceptor) {\n+        dispatchInterceptors.add(interceptor);\n+        return () -> dispatchInterceptors.remove(interceptor);\n+    }\n+\n+    @Override\n+    public Registration registerResultHandlerInterceptor(\n+            ReactorResultHandlerInterceptor<CommandMessage<?>, CommandResultMessage<?>> interceptor) {\n+        resultInterceptors.add(interceptor);\n+        return () -> resultInterceptors.remove(interceptor);\n+    }\n+\n+    private Mono<CommandMessage<?>> processCommandInterceptors(Mono<CommandMessage<?>> commandMessage) {\n+        return Flux.fromIterable(dispatchInterceptors)\n+                   .reduce(commandMessage, (command, interceptor) -> interceptor.intercept(command))\n+                   .flatMap(Mono::from);\n+    }\n+\n+    private <C, R> Mono<Tuple2<CommandMessage<C>, Flux<CommandResultMessage<? extends R>>>> dispatchCommand(\n+            CommandMessage<C> commandMessage) {\n+        ReactiveCallback<C, R> reactiveCallback = new ReactiveCallback<>();\n+        CommandCallback<C, R> callback = reactiveCallback;\n+        if (retryScheduler != null) {\n+            callback = new RetryingCallback<>(callback, retryScheduler, commandBus);\n+        }\n+        commandBus.dispatch(commandMessage, callback);\n+        return Mono.just(commandMessage).zipWith(Mono.just(Flux.from(reactiveCallback)));\n+    }\n+\n+    private <C> Mono<? extends CommandResultMessage<?>> processResultsInterceptors(\n+            Tuple2<CommandMessage<C>, Flux<CommandResultMessage<?>>> commandWithResults) {\n+        CommandMessage<?> commandMessage = commandWithResults.getT1();\n+        Flux<CommandResultMessage<?>> commandResultMessages = commandWithResults.getT2();\n+        return Flux.fromIterable(resultInterceptors)\n+                   .reduce(commandResultMessages,\n+                           (result, interceptor) -> interceptor.intercept(commandMessage, result))\n+                   .flatMap(Flux::next); // command handlers provide only one result!\n+    }\n+\n+    private <R> Mono<R> getPayload(Mono<? extends CommandResultMessage<?>> commandResultMessage) {\n+        //noinspection unchecked\n+        return commandResultMessage\n+                .filter(r -> Objects.nonNull(r.getPayload()))\n+                .map(it -> (R) it.getPayload());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "98865ab1427e4d879301c1bf542842eccc8aa3c3"}, "originalPosition": 136}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mjc5NDM5Mg==", "bodyText": "Why is there a result to publishing events? Is that a necessity which follows from being able to subscribe to this Flux, which will be the actual initiation of publishing the events?\nIf so, could we change this to Flux<Void> instead of Flux<Object>? Object makes it seem (to me at least) like they'll get an actual response.", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r452794392", "createdAt": "2020-07-10T11:48:11Z", "author": {"login": "smcvb"}, "path": "messaging/src/main/java/org/axonframework/eventhandling/gateway/ReactorEventGateway.java", "diffHunk": "@@ -0,0 +1,84 @@\n+/*\n+ * Copyright (c) 2010-2020. Axon Framework\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.axonframework.eventhandling.gateway;\n+\n+import org.axonframework.eventhandling.EventBus;\n+import org.axonframework.eventhandling.EventMessage;\n+import org.axonframework.messaging.Message;\n+import org.axonframework.messaging.reactive.ReactorMessageDispatchInterceptorSupport;\n+import org.reactivestreams.Publisher;\n+import reactor.core.publisher.Flux;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+\n+/**\n+ * Variation of {@link EventGateway}. Provides support for reactive return types such as {@link Flux} from Project\n+ * Reactor.\n+ *\n+ * @author Milan Savic\n+ * @since 4.4\n+ */\n+public interface ReactorEventGateway extends ReactorMessageDispatchInterceptorSupport<EventMessage<?>> {\n+\n+    /**\n+     * Publishes given {@code events} once the caller subscribes to the resulting Flux. Returns immediately.\n+     * <p/>\n+     * Given {@code events} are wrapped as payloads of a {@link EventMessage} that are eventually published on the\n+     * {@link EventBus}, unless {@code event} already implements {@link Message}. In that case, a {@code EventMessage}\n+     * is constructed from that message's payload and {@link org.axonframework.messaging.MetaData}.\n+     *\n+     * @param events events to be published\n+     * @return events that were published. DO NOTE: if there were some interceptors registered to this {@code gateway},\n+     * they will be processed first, before returning events to the caller. The order of returned events is the same as\n+     * one provided as the input parameter.\n+     */\n+    default Flux<Object> publish(Object... events) { // NOSONAR\n+        return publish(Arrays.asList(events));\n+    }\n+\n+    /**\n+     * Publishes given {@code events} once the caller subscribes to the resulting Flux. Returns immediately.\n+     * <p/>\n+     * Given {@code events} are wrapped as payloads of a {@link EventMessage} that are eventually published on the\n+     * {@link EventBus}, unless {@code event} already implements {@link Message}. In that case, a {@code EventMessage}\n+     * is constructed from that message's payload and {@link org.axonframework.messaging.MetaData}.\n+     *\n+     * @param events the list of events to be published\n+     * @return events that were published. DO NOTE: if there were some interceptors registered to this {@code gateway},\n+     * they will be processed first, before returning events to the caller. The order of returned events is the same as\n+     * one provided as the input parameter.\n+     */\n+    Flux<Object> publish(List<?> events);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "98865ab1427e4d879301c1bf542842eccc8aa3c3"}, "originalPosition": 66}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mjc5NDYxMg==", "bodyText": "Curious whether this is actually needed in this form, or whether we can just do void/null here by default. Follows from my comment on the interface by the way.", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r452794612", "createdAt": "2020-07-10T11:48:51Z", "author": {"login": "smcvb"}, "path": "messaging/src/main/java/org/axonframework/eventhandling/gateway/DefaultReactorEventGateway.java", "diffHunk": "@@ -0,0 +1,177 @@\n+/*\n+ * Copyright (c) 2010-2020. Axon Framework\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.axonframework.eventhandling.gateway;\n+\n+import org.axonframework.common.AxonConfigurationException;\n+import org.axonframework.common.Registration;\n+import org.axonframework.eventhandling.EventBus;\n+import org.axonframework.eventhandling.EventMessage;\n+import org.axonframework.eventhandling.GenericEventMessage;\n+import org.axonframework.messaging.Message;\n+import org.axonframework.messaging.reactive.ReactorMessageDispatchInterceptor;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Mono;\n+\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.concurrent.CopyOnWriteArrayList;\n+\n+import static java.util.Arrays.asList;\n+import static org.axonframework.common.BuilderUtils.assertNonNull;\n+\n+/**\n+ * Implementation of the {@link ReactorEventGateway} that uses Project Reactor to achieve reactiveness.\n+ *\n+ * @author Milan Savic\n+ * @since 4.4\n+ */\n+public class DefaultReactorEventGateway implements ReactorEventGateway {\n+\n+    private final EventBus eventBus;\n+    private final List<ReactorMessageDispatchInterceptor<EventMessage<?>>> dispatchInterceptors;\n+\n+    /**\n+     * Creates an instance of {@link DefaultReactorEventGateway} based on the fields contained in the {@link Builder}.\n+     * <p>\n+     * Will assert that the {@link EventBus} is not {@code null} and throws an {@link\n+     * org.axonframework.common.AxonConfigurationException} if it is.\n+     * </p>\n+     *\n+     * @param builder the {@link Builder} used to instantiate a {@link DefaultReactorEventGateway} instance\n+     */\n+    protected DefaultReactorEventGateway(Builder builder) {\n+        builder.validate();\n+        this.eventBus = builder.eventBus;\n+        this.dispatchInterceptors = builder.dispatchInterceptors;\n+    }\n+\n+    /**\n+     * Instantiate a Builder to be able to create a {@link DefaultReactorEventGateway}.\n+     * <p>\n+     * The {@code dispatchInterceptors} are defaulted to an empty list.\n+     * The {@link EventBus} is a <b>hard requirement</b>\n+     * </p>\n+     *\n+     * @return a Builder to be able to create a {@link DefaultReactorEventGateway}\n+     */\n+    public static Builder builder() {\n+        return new Builder();\n+    }\n+\n+    @Override\n+    public Flux<Object> publish(List<?> events) {\n+        return Flux.fromIterable(events)\n+                   .map(event -> Mono.<EventMessage<?>>just(GenericEventMessage.asEventMessage(event)))\n+                   .flatMap(this::processEventInterceptors)\n+                   .flatMap(this::publishEvent)\n+                   .transform(this::getPayload);\n+    }\n+\n+    @Override\n+    public Registration registerDispatchInterceptor(ReactorMessageDispatchInterceptor<EventMessage<?>> interceptor) {\n+        dispatchInterceptors.add(interceptor);\n+        return () -> dispatchInterceptors.remove(interceptor);\n+    }\n+\n+    private Mono<EventMessage<?>> processEventInterceptors(Mono<EventMessage<?>> eventMessage) {\n+        return Flux.fromIterable(dispatchInterceptors)\n+                   .reduce(eventMessage, (event, interceptor) -> interceptor.intercept(event))\n+                   .flatMap(Mono::from);\n+    }\n+\n+    private Mono<EventMessage<?>> publishEvent(EventMessage<?> eventMessage) {\n+        return Mono.fromRunnable(() -> eventBus.publish(eventMessage))\n+                   .thenReturn(eventMessage);\n+    }\n+\n+    private Flux<Object> getPayload(Flux<EventMessage<?>> eventMessage) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "98865ab1427e4d879301c1bf542842eccc8aa3c3"}, "originalPosition": 101}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjgwMDUyNA==", "bodyText": "The second assert here is the same as the first one. Think the second one is intended to verify k2 == k3.", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r452800524", "createdAt": "2020-07-10T12:03:07Z", "author": {"login": "smcvb"}, "path": "messaging/src/test/java/org/axonframework/commandhandling/gateway/DefaultReactorCommandGatewayTest.java", "diffHunk": "@@ -0,0 +1,213 @@\n+package org.axonframework.commandhandling.gateway;\n+\n+import org.axonframework.commandhandling.CommandMessage;\n+import org.axonframework.commandhandling.CommandResultMessage;\n+import org.axonframework.commandhandling.GenericCommandMessage;\n+import org.axonframework.commandhandling.GenericCommandResultMessage;\n+import org.junit.jupiter.api.*;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Mono;\n+import reactor.test.StepVerifier;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.function.BiFunction;\n+import java.util.function.Function;\n+import java.util.function.Predicate;\n+\n+import static org.junit.jupiter.api.Assertions.*;\n+\n+/**\n+ * Unit tests for {@link DefaultReactorCommandGateway}.\n+ *\n+ * @author Sara Pellegrini\n+ * @since 4.4\n+ */\n+class DefaultReactorCommandGatewayTest {\n+\n+    private CommandBusStub commandBus;\n+    private ReactorCommandGateway gateway;\n+\n+    @BeforeEach\n+    public void setUp() {\n+        commandBus = new CommandBusStub();\n+        gateway = DefaultReactorCommandGateway.builder()\n+                                              .commandBus(commandBus)\n+                                              .build();\n+    }\n+\n+    @Test\n+    void testInterceptorOrder() {\n+\n+        // int 1 -> metadata on command k1 -> v1\n+        Map<String, String> metadata1 = new HashMap<>();\n+        metadata1.put(\"k1\", \"v1\");\n+        registerMessageMapping(gateway, command -> command.andMetaData(metadata1));\n+\n+        // int 2 -> copy metadata from command into results\n+        registerResultMapping(gateway,\n+                              (command, result) -> new GenericCommandResultMessage<>(command.getMetaData().get(\"k1\")));\n+\n+        // int 3 -> metadata on command k1 -> v2\n+        Map<String, String> metadata2 = new HashMap<>();\n+        metadata1.put(\"k1\", \"v2\");\n+        registerMessageMapping(gateway, command -> command.andMetaData(metadata2));\n+\n+        //send\n+        Mono<String> results = gateway.send(\"\");\n+\n+        // verify -> results equals v2\n+        StepVerifier.create(results)\n+                    .expectNextMatches(result -> result.equals(\"v2\"))\n+                    .verifyComplete();\n+\n+        // verify -> command sent has k1 -> v2\n+        CommandMessage<?> sentCommand = commandBus.lastSentCommand();\n+        assertEquals(\"v2\", sentCommand.getMetaData().get(\"k1\"));\n+    }\n+\n+    @Test\n+    void testResultFiltering() {\n+        registerResultsFilter(gateway, result -> result.getMetaData().containsKey(\"K\"));\n+        // int 1 -> flux of results is filtered\n+\n+        Mono<CommandResultMessage<?>> results = gateway.send(\"\");\n+        StepVerifier.create(results)\n+                    .verifyComplete();\n+        // verify -> command has been sent\n+        assertEquals(1, commandBus.numberOfSentCommands());\n+    }\n+\n+    @Test\n+    void testCommandFiltering() {\n+        registerMessageFilter(gateway, result -> result.getMetaData().containsKey(\"K\"));\n+        // int 1 -> flux of results is filtered\n+\n+        Mono<CommandResultMessage<?>> results = gateway.send(\"\");\n+        StepVerifier.create(results)\n+                    .verifyComplete();\n+        // verify -> command has not been sent\n+        assertEquals(0, commandBus.numberOfSentCommands());\n+    }\n+\n+    @Test\n+    void testCommandDispatchAndResultHandlerInterceptor() {\n+        // int 1 -> add Principal to command and results\n+        Map<String, String> principalMetadata = new HashMap<>();\n+        principalMetadata.put(\"username\", \"admin\");\n+        registerMapping(gateway,\n+                        command -> command.andMetaData(principalMetadata),\n+                        (command, result) -> result.andMetaData(principalMetadata));\n+\n+        // int 2 -> validate authorizations and results\n+        registerMapping(gateway,\n+                        command -> {\n+                            assert command.getMetaData().get(\"username\").equals(\"admin\");\n+                            return command;\n+                        },\n+                        (command, result) -> {\n+                            assert result.getMetaData().get(\"username\").equals(\"admin\");\n+                            return result;\n+                        });\n+\n+        Mono<CommandResultMessage<?>> results = gateway.send(\"\");\n+\n+        StepVerifier.create(results)\n+                    .expectNextCount(1)\n+                    .verifyComplete();\n+\n+        assertEquals(1, commandBus.numberOfSentCommands());\n+    }\n+\n+    @Test\n+    void testCommandResultHandlerChain() {\n+        // int 1 -> metadata on result k1 -> v1\n+        Map<String, String> metadata1 = new HashMap<>();\n+        metadata1.put(\"k1\", \"v1\");\n+        registerResultMapping(gateway, (command, result) -> result.andMetaData(metadata1));\n+\n+        // int 2 -> metadata on result k1 -> v2\n+        Map<String, String> metadata2 = new HashMap<>();\n+        metadata2.put(\"k1\", \"v2\");\n+        registerResultMapping(gateway, (command, result) -> result.andMetaData(metadata2));\n+\n+        // int 3 -> metadata on result k2 -> v3\n+        Map<String, String> metadata3 = new HashMap<>();\n+        metadata3.put(\"k2\", \"v3\");\n+        registerResultMapping(gateway, (command, result) -> result.andMetaData(metadata3));\n+\n+        Mono<CommandResultMessage<?>> results = gateway.send(\"\");\n+\n+        // verify -> results have k1 -> v2 and k2 -> v3\n+        StepVerifier.create(results)\n+                    .expectNextMatches(result -> result.getMetaData().get(\"k1\").equals(\"v2\") &&", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "98865ab1427e4d879301c1bf542842eccc8aa3c3"}, "originalPosition": 143}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjgwMjMzMA==", "bodyText": "Curious: Why not make it actually void, without a return statement?", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r452802330", "createdAt": "2020-07-10T12:07:15Z", "author": {"login": "smcvb"}, "path": "messaging/src/test/java/org/axonframework/commandhandling/gateway/DefaultReactorCommandGatewayComponentTest.java", "diffHunk": "@@ -0,0 +1,321 @@\n+/*\n+ * Copyright (c) 2010-2020. Axon Framework\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.axonframework.commandhandling.gateway;\n+\n+import org.axonframework.commandhandling.AsynchronousCommandBus;\n+import org.axonframework.commandhandling.CommandBus;\n+import org.axonframework.commandhandling.CommandMessage;\n+import org.axonframework.commandhandling.GenericCommandResultMessage;\n+import org.axonframework.common.Registration;\n+import org.axonframework.messaging.MessageHandler;\n+import org.junit.jupiter.api.*;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Hooks;\n+import reactor.core.publisher.Mono;\n+import reactor.test.StepVerifier;\n+import reactor.util.context.Context;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.stream.IntStream;\n+\n+import static java.util.stream.Collectors.toList;\n+import static org.junit.jupiter.api.Assertions.*;\n+import static org.mockito.Mockito.*;\n+\n+/**\n+ * Tests for {@link DefaultReactorCommandGateway} all together with Command Bus.\n+ *\n+ * @author Milan Savic\n+ */\n+class DefaultReactorCommandGatewayComponentTest {\n+\n+    private DefaultReactorCommandGateway reactiveCommandGateway;\n+    private MessageHandler<CommandMessage<?>> commandMessageHandler;\n+    private MessageHandler<CommandMessage<?>> failingCommandHandler;\n+    private MessageHandler<CommandMessage<?>> voidCommandHandler;\n+    private RetryScheduler mockRetryScheduler;\n+    private CommandBus commandBus;\n+\n+    @BeforeEach\n+    void setUp() {\n+        Hooks.enableContextLossTracking();\n+        Hooks.onOperatorDebug();\n+\n+        commandBus = spy(AsynchronousCommandBus.builder().build());\n+\n+        mockRetryScheduler = mock(RetryScheduler.class);\n+        commandMessageHandler = spy(new MessageHandler<CommandMessage<?>>() {\n+\n+            private final AtomicInteger count = new AtomicInteger();\n+\n+            @Override\n+            public Object handle(CommandMessage<?> message) {\n+                if (\"backpressure\".equals(message.getPayload())) {\n+                    return count.incrementAndGet();\n+                }\n+                return \"handled\";\n+            }\n+        });\n+        commandBus.subscribe(String.class.getName(), commandMessageHandler);\n+        failingCommandHandler = spy(new MessageHandler<CommandMessage<?>>() {\n+            @Override\n+            public Object handle(CommandMessage<?> message) throws Exception {\n+                throw new RuntimeException();\n+            }\n+        });\n+\n+        voidCommandHandler = spy(new MessageHandler<CommandMessage<?>>() {\n+            @Override\n+            public Object handle(CommandMessage<?> message) throws Exception {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "98865ab1427e4d879301c1bf542842eccc8aa3c3"}, "originalPosition": 87}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjgwODE4Mg==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                     * Sets {@link ReactorResultHandlerInterceptor}s for {@link CommandResultMessage}s.\n          \n          \n            \n                     * Are invoked when a result has been received.\n          \n          \n            \n                     * Sets {@link ReactorResultHandlerInterceptor}s for {@link ResultMessage}s.\n          \n          \n            \n                     * Are invoked when a result has been received.", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r452808182", "createdAt": "2020-07-10T12:20:46Z", "author": {"login": "smcvb"}, "path": "messaging/src/main/java/org/axonframework/queryhandling/DefaultReactorQueryGateway.java", "diffHunk": "@@ -0,0 +1,318 @@\n+/*\n+ * Copyright (c) 2010-2020. Axon Framework\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.axonframework.queryhandling;\n+\n+import org.axonframework.commandhandling.CommandResultMessage;\n+import org.axonframework.common.AxonConfigurationException;\n+import org.axonframework.common.Registration;\n+import org.axonframework.messaging.ResultMessage;\n+import org.axonframework.messaging.reactive.ReactorMessageDispatchInterceptor;\n+import org.axonframework.messaging.reactive.ReactorResultHandlerInterceptor;\n+import org.axonframework.messaging.responsetypes.ResponseType;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Mono;\n+import reactor.util.function.Tuple2;\n+\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.concurrent.CopyOnWriteArrayList;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Function;\n+\n+import static java.util.Arrays.asList;\n+import static org.axonframework.common.BuilderUtils.assertNonNull;\n+import static org.axonframework.messaging.GenericMessage.asMessage;\n+\n+/**\n+ * Implementation of the {@link ReactorQueryGateway} that uses Project Reactor to achieve reactiveness.\n+ *\n+ * @author Milan Savic\n+ * @since 4.4\n+ */\n+public class DefaultReactorQueryGateway implements ReactorQueryGateway {\n+\n+    private final List<ReactorMessageDispatchInterceptor<QueryMessage<?, ?>>> dispatchInterceptors;\n+    private final List<ReactorResultHandlerInterceptor<QueryMessage<?, ?>, ResultMessage<?>>> resultInterceptors;\n+\n+    private final QueryBus queryBus;\n+\n+    /**\n+     * Creates an instance of {@link DefaultReactorQueryGateway} based on the fields contained in the {@link\n+     * Builder}.\n+     * <p>\n+     * Will assert that the {@link QueryBus} is not {@code null} and throws an {@link AxonConfigurationException} if\n+     * it is.\n+     * </p>\n+     *\n+     * @param builder the {@link Builder} used to instantiated a {@link DefaultReactorQueryGateway} instance\n+     */\n+    protected DefaultReactorQueryGateway(Builder builder) {\n+        builder.validate();\n+        this.queryBus = builder.queryBus;\n+        this.dispatchInterceptors = builder.dispatchInterceptors;\n+        this.resultInterceptors = builder.resultInterceptors;\n+    }\n+\n+    /**\n+     * Instantiate a Builder to be able to create a {@link DefaultReactorQueryGateway}.\n+     * <p>\n+     * The {@code dispatchInterceptors} are defaulted to an empty list.\n+     * The {@code resultHandlerInterceptors} are defaulted to an empty list.\n+     * The {@link QueryBus} is a <b>hard requirement</b> and as such should be provided.\n+     * </p>\n+     *\n+     * @return a Builder to be able to create a {@link DefaultReactorQueryGateway}\n+     */\n+    public static Builder builder() {\n+        return new Builder();\n+    }\n+\n+    @Override\n+    public Registration registerDispatchInterceptor(\n+            ReactorMessageDispatchInterceptor<QueryMessage<?, ?>> interceptor) {\n+        dispatchInterceptors.add(interceptor);\n+        return () -> dispatchInterceptors.remove(interceptor);\n+    }\n+\n+    @Override\n+    public Registration registerResultHandlerInterceptor(\n+            ReactorResultHandlerInterceptor<QueryMessage<?, ?>, ResultMessage<?>> interceptor) {\n+        resultInterceptors.add(interceptor);\n+        return () -> resultInterceptors.remove(interceptor);\n+    }\n+\n+    @Override\n+    public <R, Q> Mono<R> query(String queryName, Q query, ResponseType<R> responseType) {\n+        return Mono.<QueryMessage<?, ?>>fromCallable(() -> new GenericQueryMessage<>(asMessage(query),\n+                                                                                     queryName,\n+                                                                                     responseType))\n+                .transform(this::processDispatchInterceptors)\n+                .flatMap(this::dispatchQuery)\n+                .flatMapMany(this::processResultsInterceptors)\n+                .<R>transform(this::getPayload)\n+                .next();\n+    }\n+\n+    @Override\n+    public <R, Q> Flux<R> scatterGather(String queryName, Q query, ResponseType<R> responseType, long timeout,\n+                                        TimeUnit timeUnit) {\n+        return Mono.<QueryMessage<?, ?>>fromCallable(() -> new GenericQueryMessage<>(asMessage(query),\n+                                                                                     queryName,\n+                                                                                     responseType))\n+                .transform(this::processDispatchInterceptors)\n+                .flatMap(q -> dispatchScatterGatherQuery(q, timeout, timeUnit))\n+                .flatMapMany(this::processResultsInterceptors)\n+                .transform(this::getPayload);\n+    }\n+\n+    @Override\n+    public <Q, I, U> Mono<SubscriptionQueryResult<I, U>> subscriptionQuery(String queryName, Q query,\n+                                                                           ResponseType<I> initialResponseType,\n+                                                                           ResponseType<U> updateResponseType,\n+                                                                           SubscriptionQueryBackpressure backpressure,\n+                                                                           int updateBufferSize) {\n+\n+        //noinspection unchecked\n+        return Mono.<QueryMessage<?, ?>>fromCallable(() -> new GenericSubscriptionQueryMessage<>(query,\n+                                                                                                 initialResponseType,\n+                                                                                                 updateResponseType))\n+                .transform(this::processDispatchInterceptors)\n+                .map(isq -> (SubscriptionQueryMessage<Q, U, I>) isq)\n+                .flatMap(isq -> dispatchSubscriptionQuery(isq, backpressure, updateBufferSize))\n+                .flatMap(processSubscriptionQueryResult());\n+    }\n+\n+\n+    private Mono<Tuple2<QueryMessage<?, ?>, Flux<ResultMessage<?>>>> dispatchQuery(QueryMessage<?, ?> queryMessage) {\n+        Flux<ResultMessage<?>> results = Flux\n+                .defer(() -> Mono.fromFuture(queryBus.query(queryMessage)));\n+\n+        return Mono.<QueryMessage<?, ?>>just(queryMessage)\n+                .zipWith(Mono.just(results));\n+    }\n+\n+    private Mono<Tuple2<QueryMessage<?, ?>, Flux<ResultMessage<?>>>> dispatchScatterGatherQuery(\n+            QueryMessage<?, ?> queryMessage, long timeout, TimeUnit timeUnit) {\n+        Flux<ResultMessage<?>> results = Flux\n+                .defer(() -> Flux.fromStream(queryBus.scatterGather(queryMessage,\n+                                                                    timeout,\n+                                                                    timeUnit)));\n+\n+        return Mono.<QueryMessage<?, ?>>just(queryMessage)\n+                .zipWith(Mono.just(results));\n+    }\n+\n+    private <Q, I, U> Mono<Tuple2<QueryMessage<Q, I>, Mono<SubscriptionQueryResult<QueryResponseMessage<I>, SubscriptionQueryUpdateMessage<U>>>>> dispatchSubscriptionQuery(\n+            SubscriptionQueryMessage<Q, I, U> queryMessage, SubscriptionQueryBackpressure backpressure,\n+            int updateBufferSize) {\n+        Mono<SubscriptionQueryResult<QueryResponseMessage<I>, SubscriptionQueryUpdateMessage<U>>> result = Mono\n+                .fromCallable(() -> queryBus.subscriptionQuery(queryMessage, backpressure, updateBufferSize));\n+        return Mono.<QueryMessage<Q, I>>just(queryMessage)\n+                .zipWith(Mono.just(result));\n+    }\n+\n+    private Mono<QueryMessage<?, ?>> processDispatchInterceptors(Mono<QueryMessage<?, ?>> queryMessageMono) {\n+        return Flux.fromIterable(dispatchInterceptors)\n+                   .reduce(queryMessageMono, (queryMessage, interceptor) -> interceptor.intercept(queryMessage))\n+                   .flatMap(Mono::from);\n+    }\n+\n+    private Flux<ResultMessage<?>> processResultsInterceptors(\n+            Tuple2<QueryMessage<?, ?>, Flux<ResultMessage<?>>> queryWithResponses) {\n+        QueryMessage<?, ?> queryMessage = queryWithResponses.getT1();\n+        Flux<ResultMessage<?>> queryResultMessage = queryWithResponses.getT2();\n+\n+        return Flux.fromIterable(resultInterceptors)\n+                   .reduce(queryResultMessage,\n+                           (result, interceptor) -> interceptor.intercept(queryMessage, result))\n+                   .flatMapMany(it -> it);\n+    }\n+\n+    private <Q, I, U> Function<Tuple2<QueryMessage<Q, U>,\n+            Mono<SubscriptionQueryResult<QueryResponseMessage<U>, SubscriptionQueryUpdateMessage<I>>>>,\n+            Mono<SubscriptionQueryResult<I, U>>> processSubscriptionQueryResult() {\n+\n+        return messageWithResult -> messageWithResult.getT2().map(sqr -> {\n+            Mono<I> interceptedInitialResult = Mono.<QueryMessage<?, ?>>just(messageWithResult.getT1())\n+                    .zipWith(Mono.just(Flux.<ResultMessage<?>>from(sqr.initialResult())))\n+                    .flatMapMany(this::processResultsInterceptors)\n+                    .<I>transform(this::getPayload)\n+                    .next();\n+\n+            Flux<U> interceptedUpdates = Mono.<QueryMessage<?, ?>>just(messageWithResult.getT1())\n+                    .zipWith(Mono.just(sqr.updates().<ResultMessage<?>>map(it -> it)))\n+                    .flatMapMany(this::processResultsInterceptors)\n+                    .transform(this::getPayload);\n+\n+            return new DefaultSubscriptionQueryResult<>(interceptedInitialResult, interceptedUpdates, sqr);\n+        });\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    private <R> Flux<R> getPayload(Flux<ResultMessage<?>> resultMessageFlux) {\n+        return resultMessageFlux\n+                .flatMap(this::mapResult)\n+                .filter(r -> Objects.nonNull(r.getPayload()))\n+                .map(it -> (R) it.getPayload());\n+    }\n+\n+    private Flux<? extends ResultMessage<?>> mapResult(ResultMessage<?> response) {\n+        return response.isExceptional() ? Flux.error(response.exceptionResult()) : Flux.just(response);\n+    }\n+\n+    /**\n+     * Builder class to instantiate {@link DefaultReactorQueryGateway}.\n+     * <p>\n+     * The {@code dispatchInterceptors} are defaulted to an empty list.\n+     * The {@link QueryBus} is a <b>hard requirement</b> and as such should be provided.\n+     * </p>\n+     */\n+    public static class Builder {\n+\n+        private QueryBus queryBus;\n+        private List<ReactorMessageDispatchInterceptor<QueryMessage<?, ?>>> dispatchInterceptors = new CopyOnWriteArrayList<>();\n+        private List<ReactorResultHandlerInterceptor<QueryMessage<?, ?>, ResultMessage<?>>> resultInterceptors = new CopyOnWriteArrayList<>();\n+\n+        /**\n+         * Sets the {@link QueryBus} used to dispatch queries.\n+         *\n+         * @param queryBus a {@link QueryBus} used to dispatch queries\n+         * @return the current Builder instance, for fluent interfacing\n+         */\n+        public Builder queryBus(QueryBus queryBus) {\n+            assertNonNull(queryBus, \"QueryBus may not be null\");\n+            this.queryBus = queryBus;\n+            return this;\n+        }\n+\n+        /**\n+         * Sets {@link ReactorMessageDispatchInterceptor}s for {@link QueryMessage}s. Are invoked\n+         * when a query is being dispatched.\n+         *\n+         * @param dispatchInterceptors which are invoked when a query is being dispatched\n+         * @return the current Builder instance, for fluent interfacing\n+         */\n+        @SafeVarargs\n+        public final Builder dispatchInterceptors(\n+                ReactorMessageDispatchInterceptor<QueryMessage<?, ?>>... dispatchInterceptors) {\n+            return dispatchInterceptors(asList(dispatchInterceptors));\n+        }\n+\n+        /**\n+         * Sets the {@link List} of {@link ReactorMessageDispatchInterceptor}s for {@link QueryMessage}s. Are invoked\n+         * when a query is being dispatched.\n+         *\n+         * @param dispatchInterceptors which are invoked when a query is being dispatched\n+         * @return the current Builder instance, for fluent interfacing\n+         */\n+        public Builder dispatchInterceptors(\n+                List<ReactorMessageDispatchInterceptor<QueryMessage<?, ?>>> dispatchInterceptors) {\n+            this.dispatchInterceptors = dispatchInterceptors != null && dispatchInterceptors.isEmpty()\n+                    ? new CopyOnWriteArrayList<>(dispatchInterceptors)\n+                    : new CopyOnWriteArrayList<>();\n+            return this;\n+        }\n+\n+        /**\n+         * Sets {@link ReactorResultHandlerInterceptor}s for {@link CommandResultMessage}s.\n+         * Are invoked when a result has been received.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "98865ab1427e4d879301c1bf542842eccc8aa3c3"}, "originalPosition": 272}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjgwODI5MA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                     * Sets the {@link List} of {@link ReactorResultHandlerInterceptor}s for {@link CommandResultMessage}s.\n          \n          \n            \n                     * Sets the {@link List} of {@link ReactorResultHandlerInterceptor}s for {@link ResultMessage}s.", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r452808290", "createdAt": "2020-07-10T12:20:59Z", "author": {"login": "smcvb"}, "path": "messaging/src/main/java/org/axonframework/queryhandling/DefaultReactorQueryGateway.java", "diffHunk": "@@ -0,0 +1,318 @@\n+/*\n+ * Copyright (c) 2010-2020. Axon Framework\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.axonframework.queryhandling;\n+\n+import org.axonframework.commandhandling.CommandResultMessage;\n+import org.axonframework.common.AxonConfigurationException;\n+import org.axonframework.common.Registration;\n+import org.axonframework.messaging.ResultMessage;\n+import org.axonframework.messaging.reactive.ReactorMessageDispatchInterceptor;\n+import org.axonframework.messaging.reactive.ReactorResultHandlerInterceptor;\n+import org.axonframework.messaging.responsetypes.ResponseType;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Mono;\n+import reactor.util.function.Tuple2;\n+\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.concurrent.CopyOnWriteArrayList;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Function;\n+\n+import static java.util.Arrays.asList;\n+import static org.axonframework.common.BuilderUtils.assertNonNull;\n+import static org.axonframework.messaging.GenericMessage.asMessage;\n+\n+/**\n+ * Implementation of the {@link ReactorQueryGateway} that uses Project Reactor to achieve reactiveness.\n+ *\n+ * @author Milan Savic\n+ * @since 4.4\n+ */\n+public class DefaultReactorQueryGateway implements ReactorQueryGateway {\n+\n+    private final List<ReactorMessageDispatchInterceptor<QueryMessage<?, ?>>> dispatchInterceptors;\n+    private final List<ReactorResultHandlerInterceptor<QueryMessage<?, ?>, ResultMessage<?>>> resultInterceptors;\n+\n+    private final QueryBus queryBus;\n+\n+    /**\n+     * Creates an instance of {@link DefaultReactorQueryGateway} based on the fields contained in the {@link\n+     * Builder}.\n+     * <p>\n+     * Will assert that the {@link QueryBus} is not {@code null} and throws an {@link AxonConfigurationException} if\n+     * it is.\n+     * </p>\n+     *\n+     * @param builder the {@link Builder} used to instantiated a {@link DefaultReactorQueryGateway} instance\n+     */\n+    protected DefaultReactorQueryGateway(Builder builder) {\n+        builder.validate();\n+        this.queryBus = builder.queryBus;\n+        this.dispatchInterceptors = builder.dispatchInterceptors;\n+        this.resultInterceptors = builder.resultInterceptors;\n+    }\n+\n+    /**\n+     * Instantiate a Builder to be able to create a {@link DefaultReactorQueryGateway}.\n+     * <p>\n+     * The {@code dispatchInterceptors} are defaulted to an empty list.\n+     * The {@code resultHandlerInterceptors} are defaulted to an empty list.\n+     * The {@link QueryBus} is a <b>hard requirement</b> and as such should be provided.\n+     * </p>\n+     *\n+     * @return a Builder to be able to create a {@link DefaultReactorQueryGateway}\n+     */\n+    public static Builder builder() {\n+        return new Builder();\n+    }\n+\n+    @Override\n+    public Registration registerDispatchInterceptor(\n+            ReactorMessageDispatchInterceptor<QueryMessage<?, ?>> interceptor) {\n+        dispatchInterceptors.add(interceptor);\n+        return () -> dispatchInterceptors.remove(interceptor);\n+    }\n+\n+    @Override\n+    public Registration registerResultHandlerInterceptor(\n+            ReactorResultHandlerInterceptor<QueryMessage<?, ?>, ResultMessage<?>> interceptor) {\n+        resultInterceptors.add(interceptor);\n+        return () -> resultInterceptors.remove(interceptor);\n+    }\n+\n+    @Override\n+    public <R, Q> Mono<R> query(String queryName, Q query, ResponseType<R> responseType) {\n+        return Mono.<QueryMessage<?, ?>>fromCallable(() -> new GenericQueryMessage<>(asMessage(query),\n+                                                                                     queryName,\n+                                                                                     responseType))\n+                .transform(this::processDispatchInterceptors)\n+                .flatMap(this::dispatchQuery)\n+                .flatMapMany(this::processResultsInterceptors)\n+                .<R>transform(this::getPayload)\n+                .next();\n+    }\n+\n+    @Override\n+    public <R, Q> Flux<R> scatterGather(String queryName, Q query, ResponseType<R> responseType, long timeout,\n+                                        TimeUnit timeUnit) {\n+        return Mono.<QueryMessage<?, ?>>fromCallable(() -> new GenericQueryMessage<>(asMessage(query),\n+                                                                                     queryName,\n+                                                                                     responseType))\n+                .transform(this::processDispatchInterceptors)\n+                .flatMap(q -> dispatchScatterGatherQuery(q, timeout, timeUnit))\n+                .flatMapMany(this::processResultsInterceptors)\n+                .transform(this::getPayload);\n+    }\n+\n+    @Override\n+    public <Q, I, U> Mono<SubscriptionQueryResult<I, U>> subscriptionQuery(String queryName, Q query,\n+                                                                           ResponseType<I> initialResponseType,\n+                                                                           ResponseType<U> updateResponseType,\n+                                                                           SubscriptionQueryBackpressure backpressure,\n+                                                                           int updateBufferSize) {\n+\n+        //noinspection unchecked\n+        return Mono.<QueryMessage<?, ?>>fromCallable(() -> new GenericSubscriptionQueryMessage<>(query,\n+                                                                                                 initialResponseType,\n+                                                                                                 updateResponseType))\n+                .transform(this::processDispatchInterceptors)\n+                .map(isq -> (SubscriptionQueryMessage<Q, U, I>) isq)\n+                .flatMap(isq -> dispatchSubscriptionQuery(isq, backpressure, updateBufferSize))\n+                .flatMap(processSubscriptionQueryResult());\n+    }\n+\n+\n+    private Mono<Tuple2<QueryMessage<?, ?>, Flux<ResultMessage<?>>>> dispatchQuery(QueryMessage<?, ?> queryMessage) {\n+        Flux<ResultMessage<?>> results = Flux\n+                .defer(() -> Mono.fromFuture(queryBus.query(queryMessage)));\n+\n+        return Mono.<QueryMessage<?, ?>>just(queryMessage)\n+                .zipWith(Mono.just(results));\n+    }\n+\n+    private Mono<Tuple2<QueryMessage<?, ?>, Flux<ResultMessage<?>>>> dispatchScatterGatherQuery(\n+            QueryMessage<?, ?> queryMessage, long timeout, TimeUnit timeUnit) {\n+        Flux<ResultMessage<?>> results = Flux\n+                .defer(() -> Flux.fromStream(queryBus.scatterGather(queryMessage,\n+                                                                    timeout,\n+                                                                    timeUnit)));\n+\n+        return Mono.<QueryMessage<?, ?>>just(queryMessage)\n+                .zipWith(Mono.just(results));\n+    }\n+\n+    private <Q, I, U> Mono<Tuple2<QueryMessage<Q, I>, Mono<SubscriptionQueryResult<QueryResponseMessage<I>, SubscriptionQueryUpdateMessage<U>>>>> dispatchSubscriptionQuery(\n+            SubscriptionQueryMessage<Q, I, U> queryMessage, SubscriptionQueryBackpressure backpressure,\n+            int updateBufferSize) {\n+        Mono<SubscriptionQueryResult<QueryResponseMessage<I>, SubscriptionQueryUpdateMessage<U>>> result = Mono\n+                .fromCallable(() -> queryBus.subscriptionQuery(queryMessage, backpressure, updateBufferSize));\n+        return Mono.<QueryMessage<Q, I>>just(queryMessage)\n+                .zipWith(Mono.just(result));\n+    }\n+\n+    private Mono<QueryMessage<?, ?>> processDispatchInterceptors(Mono<QueryMessage<?, ?>> queryMessageMono) {\n+        return Flux.fromIterable(dispatchInterceptors)\n+                   .reduce(queryMessageMono, (queryMessage, interceptor) -> interceptor.intercept(queryMessage))\n+                   .flatMap(Mono::from);\n+    }\n+\n+    private Flux<ResultMessage<?>> processResultsInterceptors(\n+            Tuple2<QueryMessage<?, ?>, Flux<ResultMessage<?>>> queryWithResponses) {\n+        QueryMessage<?, ?> queryMessage = queryWithResponses.getT1();\n+        Flux<ResultMessage<?>> queryResultMessage = queryWithResponses.getT2();\n+\n+        return Flux.fromIterable(resultInterceptors)\n+                   .reduce(queryResultMessage,\n+                           (result, interceptor) -> interceptor.intercept(queryMessage, result))\n+                   .flatMapMany(it -> it);\n+    }\n+\n+    private <Q, I, U> Function<Tuple2<QueryMessage<Q, U>,\n+            Mono<SubscriptionQueryResult<QueryResponseMessage<U>, SubscriptionQueryUpdateMessage<I>>>>,\n+            Mono<SubscriptionQueryResult<I, U>>> processSubscriptionQueryResult() {\n+\n+        return messageWithResult -> messageWithResult.getT2().map(sqr -> {\n+            Mono<I> interceptedInitialResult = Mono.<QueryMessage<?, ?>>just(messageWithResult.getT1())\n+                    .zipWith(Mono.just(Flux.<ResultMessage<?>>from(sqr.initialResult())))\n+                    .flatMapMany(this::processResultsInterceptors)\n+                    .<I>transform(this::getPayload)\n+                    .next();\n+\n+            Flux<U> interceptedUpdates = Mono.<QueryMessage<?, ?>>just(messageWithResult.getT1())\n+                    .zipWith(Mono.just(sqr.updates().<ResultMessage<?>>map(it -> it)))\n+                    .flatMapMany(this::processResultsInterceptors)\n+                    .transform(this::getPayload);\n+\n+            return new DefaultSubscriptionQueryResult<>(interceptedInitialResult, interceptedUpdates, sqr);\n+        });\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    private <R> Flux<R> getPayload(Flux<ResultMessage<?>> resultMessageFlux) {\n+        return resultMessageFlux\n+                .flatMap(this::mapResult)\n+                .filter(r -> Objects.nonNull(r.getPayload()))\n+                .map(it -> (R) it.getPayload());\n+    }\n+\n+    private Flux<? extends ResultMessage<?>> mapResult(ResultMessage<?> response) {\n+        return response.isExceptional() ? Flux.error(response.exceptionResult()) : Flux.just(response);\n+    }\n+\n+    /**\n+     * Builder class to instantiate {@link DefaultReactorQueryGateway}.\n+     * <p>\n+     * The {@code dispatchInterceptors} are defaulted to an empty list.\n+     * The {@link QueryBus} is a <b>hard requirement</b> and as such should be provided.\n+     * </p>\n+     */\n+    public static class Builder {\n+\n+        private QueryBus queryBus;\n+        private List<ReactorMessageDispatchInterceptor<QueryMessage<?, ?>>> dispatchInterceptors = new CopyOnWriteArrayList<>();\n+        private List<ReactorResultHandlerInterceptor<QueryMessage<?, ?>, ResultMessage<?>>> resultInterceptors = new CopyOnWriteArrayList<>();\n+\n+        /**\n+         * Sets the {@link QueryBus} used to dispatch queries.\n+         *\n+         * @param queryBus a {@link QueryBus} used to dispatch queries\n+         * @return the current Builder instance, for fluent interfacing\n+         */\n+        public Builder queryBus(QueryBus queryBus) {\n+            assertNonNull(queryBus, \"QueryBus may not be null\");\n+            this.queryBus = queryBus;\n+            return this;\n+        }\n+\n+        /**\n+         * Sets {@link ReactorMessageDispatchInterceptor}s for {@link QueryMessage}s. Are invoked\n+         * when a query is being dispatched.\n+         *\n+         * @param dispatchInterceptors which are invoked when a query is being dispatched\n+         * @return the current Builder instance, for fluent interfacing\n+         */\n+        @SafeVarargs\n+        public final Builder dispatchInterceptors(\n+                ReactorMessageDispatchInterceptor<QueryMessage<?, ?>>... dispatchInterceptors) {\n+            return dispatchInterceptors(asList(dispatchInterceptors));\n+        }\n+\n+        /**\n+         * Sets the {@link List} of {@link ReactorMessageDispatchInterceptor}s for {@link QueryMessage}s. Are invoked\n+         * when a query is being dispatched.\n+         *\n+         * @param dispatchInterceptors which are invoked when a query is being dispatched\n+         * @return the current Builder instance, for fluent interfacing\n+         */\n+        public Builder dispatchInterceptors(\n+                List<ReactorMessageDispatchInterceptor<QueryMessage<?, ?>>> dispatchInterceptors) {\n+            this.dispatchInterceptors = dispatchInterceptors != null && dispatchInterceptors.isEmpty()\n+                    ? new CopyOnWriteArrayList<>(dispatchInterceptors)\n+                    : new CopyOnWriteArrayList<>();\n+            return this;\n+        }\n+\n+        /**\n+         * Sets {@link ReactorResultHandlerInterceptor}s for {@link CommandResultMessage}s.\n+         * Are invoked when a result has been received.\n+         *\n+         * @param resultInterceptors which are invoked when a result has been received\n+         * @return the current Builder instance, for fluent interfacing\n+         */\n+        @SafeVarargs\n+        public final Builder resultInterceptors(\n+                ReactorResultHandlerInterceptor<QueryMessage<?, ?>, ResultMessage<?>>... resultInterceptors) {\n+            return resultInterceptors(asList(resultInterceptors));\n+        }\n+\n+        /**\n+         * Sets the {@link List} of {@link ReactorResultHandlerInterceptor}s for {@link CommandResultMessage}s.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "98865ab1427e4d879301c1bf542842eccc8aa3c3"}, "originalPosition": 284}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjgxMjIwMQ==", "bodyText": "My personal preference would go to using interceptedQuery instead of isq. The abbreviation forces people to think what the original author meant with the name.", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r452812201", "createdAt": "2020-07-10T12:29:36Z", "author": {"login": "smcvb"}, "path": "messaging/src/main/java/org/axonframework/queryhandling/DefaultReactorQueryGateway.java", "diffHunk": "@@ -0,0 +1,318 @@\n+/*\n+ * Copyright (c) 2010-2020. Axon Framework\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.axonframework.queryhandling;\n+\n+import org.axonframework.commandhandling.CommandResultMessage;\n+import org.axonframework.common.AxonConfigurationException;\n+import org.axonframework.common.Registration;\n+import org.axonframework.messaging.ResultMessage;\n+import org.axonframework.messaging.reactive.ReactorMessageDispatchInterceptor;\n+import org.axonframework.messaging.reactive.ReactorResultHandlerInterceptor;\n+import org.axonframework.messaging.responsetypes.ResponseType;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Mono;\n+import reactor.util.function.Tuple2;\n+\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.concurrent.CopyOnWriteArrayList;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Function;\n+\n+import static java.util.Arrays.asList;\n+import static org.axonframework.common.BuilderUtils.assertNonNull;\n+import static org.axonframework.messaging.GenericMessage.asMessage;\n+\n+/**\n+ * Implementation of the {@link ReactorQueryGateway} that uses Project Reactor to achieve reactiveness.\n+ *\n+ * @author Milan Savic\n+ * @since 4.4\n+ */\n+public class DefaultReactorQueryGateway implements ReactorQueryGateway {\n+\n+    private final List<ReactorMessageDispatchInterceptor<QueryMessage<?, ?>>> dispatchInterceptors;\n+    private final List<ReactorResultHandlerInterceptor<QueryMessage<?, ?>, ResultMessage<?>>> resultInterceptors;\n+\n+    private final QueryBus queryBus;\n+\n+    /**\n+     * Creates an instance of {@link DefaultReactorQueryGateway} based on the fields contained in the {@link\n+     * Builder}.\n+     * <p>\n+     * Will assert that the {@link QueryBus} is not {@code null} and throws an {@link AxonConfigurationException} if\n+     * it is.\n+     * </p>\n+     *\n+     * @param builder the {@link Builder} used to instantiated a {@link DefaultReactorQueryGateway} instance\n+     */\n+    protected DefaultReactorQueryGateway(Builder builder) {\n+        builder.validate();\n+        this.queryBus = builder.queryBus;\n+        this.dispatchInterceptors = builder.dispatchInterceptors;\n+        this.resultInterceptors = builder.resultInterceptors;\n+    }\n+\n+    /**\n+     * Instantiate a Builder to be able to create a {@link DefaultReactorQueryGateway}.\n+     * <p>\n+     * The {@code dispatchInterceptors} are defaulted to an empty list.\n+     * The {@code resultHandlerInterceptors} are defaulted to an empty list.\n+     * The {@link QueryBus} is a <b>hard requirement</b> and as such should be provided.\n+     * </p>\n+     *\n+     * @return a Builder to be able to create a {@link DefaultReactorQueryGateway}\n+     */\n+    public static Builder builder() {\n+        return new Builder();\n+    }\n+\n+    @Override\n+    public Registration registerDispatchInterceptor(\n+            ReactorMessageDispatchInterceptor<QueryMessage<?, ?>> interceptor) {\n+        dispatchInterceptors.add(interceptor);\n+        return () -> dispatchInterceptors.remove(interceptor);\n+    }\n+\n+    @Override\n+    public Registration registerResultHandlerInterceptor(\n+            ReactorResultHandlerInterceptor<QueryMessage<?, ?>, ResultMessage<?>> interceptor) {\n+        resultInterceptors.add(interceptor);\n+        return () -> resultInterceptors.remove(interceptor);\n+    }\n+\n+    @Override\n+    public <R, Q> Mono<R> query(String queryName, Q query, ResponseType<R> responseType) {\n+        return Mono.<QueryMessage<?, ?>>fromCallable(() -> new GenericQueryMessage<>(asMessage(query),\n+                                                                                     queryName,\n+                                                                                     responseType))\n+                .transform(this::processDispatchInterceptors)\n+                .flatMap(this::dispatchQuery)\n+                .flatMapMany(this::processResultsInterceptors)\n+                .<R>transform(this::getPayload)\n+                .next();\n+    }\n+\n+    @Override\n+    public <R, Q> Flux<R> scatterGather(String queryName, Q query, ResponseType<R> responseType, long timeout,\n+                                        TimeUnit timeUnit) {\n+        return Mono.<QueryMessage<?, ?>>fromCallable(() -> new GenericQueryMessage<>(asMessage(query),\n+                                                                                     queryName,\n+                                                                                     responseType))\n+                .transform(this::processDispatchInterceptors)\n+                .flatMap(q -> dispatchScatterGatherQuery(q, timeout, timeUnit))\n+                .flatMapMany(this::processResultsInterceptors)\n+                .transform(this::getPayload);\n+    }\n+\n+    @Override\n+    public <Q, I, U> Mono<SubscriptionQueryResult<I, U>> subscriptionQuery(String queryName, Q query,\n+                                                                           ResponseType<I> initialResponseType,\n+                                                                           ResponseType<U> updateResponseType,\n+                                                                           SubscriptionQueryBackpressure backpressure,\n+                                                                           int updateBufferSize) {\n+\n+        //noinspection unchecked\n+        return Mono.<QueryMessage<?, ?>>fromCallable(() -> new GenericSubscriptionQueryMessage<>(query,\n+                                                                                                 initialResponseType,\n+                                                                                                 updateResponseType))\n+                .transform(this::processDispatchInterceptors)\n+                .map(isq -> (SubscriptionQueryMessage<Q, U, I>) isq)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "98865ab1427e4d879301c1bf542842eccc8aa3c3"}, "originalPosition": 134}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjgxMjU3NA==", "bodyText": "Daaaaamn what a signature. Almost calls for type aliases to make things human readable.", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r452812574", "createdAt": "2020-07-10T12:30:21Z", "author": {"login": "smcvb"}, "path": "messaging/src/main/java/org/axonframework/queryhandling/DefaultReactorQueryGateway.java", "diffHunk": "@@ -0,0 +1,318 @@\n+/*\n+ * Copyright (c) 2010-2020. Axon Framework\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.axonframework.queryhandling;\n+\n+import org.axonframework.commandhandling.CommandResultMessage;\n+import org.axonframework.common.AxonConfigurationException;\n+import org.axonframework.common.Registration;\n+import org.axonframework.messaging.ResultMessage;\n+import org.axonframework.messaging.reactive.ReactorMessageDispatchInterceptor;\n+import org.axonframework.messaging.reactive.ReactorResultHandlerInterceptor;\n+import org.axonframework.messaging.responsetypes.ResponseType;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Mono;\n+import reactor.util.function.Tuple2;\n+\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.concurrent.CopyOnWriteArrayList;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Function;\n+\n+import static java.util.Arrays.asList;\n+import static org.axonframework.common.BuilderUtils.assertNonNull;\n+import static org.axonframework.messaging.GenericMessage.asMessage;\n+\n+/**\n+ * Implementation of the {@link ReactorQueryGateway} that uses Project Reactor to achieve reactiveness.\n+ *\n+ * @author Milan Savic\n+ * @since 4.4\n+ */\n+public class DefaultReactorQueryGateway implements ReactorQueryGateway {\n+\n+    private final List<ReactorMessageDispatchInterceptor<QueryMessage<?, ?>>> dispatchInterceptors;\n+    private final List<ReactorResultHandlerInterceptor<QueryMessage<?, ?>, ResultMessage<?>>> resultInterceptors;\n+\n+    private final QueryBus queryBus;\n+\n+    /**\n+     * Creates an instance of {@link DefaultReactorQueryGateway} based on the fields contained in the {@link\n+     * Builder}.\n+     * <p>\n+     * Will assert that the {@link QueryBus} is not {@code null} and throws an {@link AxonConfigurationException} if\n+     * it is.\n+     * </p>\n+     *\n+     * @param builder the {@link Builder} used to instantiated a {@link DefaultReactorQueryGateway} instance\n+     */\n+    protected DefaultReactorQueryGateway(Builder builder) {\n+        builder.validate();\n+        this.queryBus = builder.queryBus;\n+        this.dispatchInterceptors = builder.dispatchInterceptors;\n+        this.resultInterceptors = builder.resultInterceptors;\n+    }\n+\n+    /**\n+     * Instantiate a Builder to be able to create a {@link DefaultReactorQueryGateway}.\n+     * <p>\n+     * The {@code dispatchInterceptors} are defaulted to an empty list.\n+     * The {@code resultHandlerInterceptors} are defaulted to an empty list.\n+     * The {@link QueryBus} is a <b>hard requirement</b> and as such should be provided.\n+     * </p>\n+     *\n+     * @return a Builder to be able to create a {@link DefaultReactorQueryGateway}\n+     */\n+    public static Builder builder() {\n+        return new Builder();\n+    }\n+\n+    @Override\n+    public Registration registerDispatchInterceptor(\n+            ReactorMessageDispatchInterceptor<QueryMessage<?, ?>> interceptor) {\n+        dispatchInterceptors.add(interceptor);\n+        return () -> dispatchInterceptors.remove(interceptor);\n+    }\n+\n+    @Override\n+    public Registration registerResultHandlerInterceptor(\n+            ReactorResultHandlerInterceptor<QueryMessage<?, ?>, ResultMessage<?>> interceptor) {\n+        resultInterceptors.add(interceptor);\n+        return () -> resultInterceptors.remove(interceptor);\n+    }\n+\n+    @Override\n+    public <R, Q> Mono<R> query(String queryName, Q query, ResponseType<R> responseType) {\n+        return Mono.<QueryMessage<?, ?>>fromCallable(() -> new GenericQueryMessage<>(asMessage(query),\n+                                                                                     queryName,\n+                                                                                     responseType))\n+                .transform(this::processDispatchInterceptors)\n+                .flatMap(this::dispatchQuery)\n+                .flatMapMany(this::processResultsInterceptors)\n+                .<R>transform(this::getPayload)\n+                .next();\n+    }\n+\n+    @Override\n+    public <R, Q> Flux<R> scatterGather(String queryName, Q query, ResponseType<R> responseType, long timeout,\n+                                        TimeUnit timeUnit) {\n+        return Mono.<QueryMessage<?, ?>>fromCallable(() -> new GenericQueryMessage<>(asMessage(query),\n+                                                                                     queryName,\n+                                                                                     responseType))\n+                .transform(this::processDispatchInterceptors)\n+                .flatMap(q -> dispatchScatterGatherQuery(q, timeout, timeUnit))\n+                .flatMapMany(this::processResultsInterceptors)\n+                .transform(this::getPayload);\n+    }\n+\n+    @Override\n+    public <Q, I, U> Mono<SubscriptionQueryResult<I, U>> subscriptionQuery(String queryName, Q query,\n+                                                                           ResponseType<I> initialResponseType,\n+                                                                           ResponseType<U> updateResponseType,\n+                                                                           SubscriptionQueryBackpressure backpressure,\n+                                                                           int updateBufferSize) {\n+\n+        //noinspection unchecked\n+        return Mono.<QueryMessage<?, ?>>fromCallable(() -> new GenericSubscriptionQueryMessage<>(query,\n+                                                                                                 initialResponseType,\n+                                                                                                 updateResponseType))\n+                .transform(this::processDispatchInterceptors)\n+                .map(isq -> (SubscriptionQueryMessage<Q, U, I>) isq)\n+                .flatMap(isq -> dispatchSubscriptionQuery(isq, backpressure, updateBufferSize))\n+                .flatMap(processSubscriptionQueryResult());\n+    }\n+\n+\n+    private Mono<Tuple2<QueryMessage<?, ?>, Flux<ResultMessage<?>>>> dispatchQuery(QueryMessage<?, ?> queryMessage) {\n+        Flux<ResultMessage<?>> results = Flux\n+                .defer(() -> Mono.fromFuture(queryBus.query(queryMessage)));\n+\n+        return Mono.<QueryMessage<?, ?>>just(queryMessage)\n+                .zipWith(Mono.just(results));\n+    }\n+\n+    private Mono<Tuple2<QueryMessage<?, ?>, Flux<ResultMessage<?>>>> dispatchScatterGatherQuery(\n+            QueryMessage<?, ?> queryMessage, long timeout, TimeUnit timeUnit) {\n+        Flux<ResultMessage<?>> results = Flux\n+                .defer(() -> Flux.fromStream(queryBus.scatterGather(queryMessage,\n+                                                                    timeout,\n+                                                                    timeUnit)));\n+\n+        return Mono.<QueryMessage<?, ?>>just(queryMessage)\n+                .zipWith(Mono.just(results));\n+    }\n+\n+    private <Q, I, U> Mono<Tuple2<QueryMessage<Q, I>, Mono<SubscriptionQueryResult<QueryResponseMessage<I>, SubscriptionQueryUpdateMessage<U>>>>> dispatchSubscriptionQuery(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "98865ab1427e4d879301c1bf542842eccc8aa3c3"}, "originalPosition": 159}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjgxNDE5MA==", "bodyText": "My personal preference would go to using subscriptionResult instead of sqr. The abbreviation forces people to think what the original author meant with the name.", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r452814190", "createdAt": "2020-07-10T12:33:29Z", "author": {"login": "smcvb"}, "path": "messaging/src/main/java/org/axonframework/queryhandling/DefaultReactorQueryGateway.java", "diffHunk": "@@ -0,0 +1,318 @@\n+/*\n+ * Copyright (c) 2010-2020. Axon Framework\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.axonframework.queryhandling;\n+\n+import org.axonframework.commandhandling.CommandResultMessage;\n+import org.axonframework.common.AxonConfigurationException;\n+import org.axonframework.common.Registration;\n+import org.axonframework.messaging.ResultMessage;\n+import org.axonframework.messaging.reactive.ReactorMessageDispatchInterceptor;\n+import org.axonframework.messaging.reactive.ReactorResultHandlerInterceptor;\n+import org.axonframework.messaging.responsetypes.ResponseType;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Mono;\n+import reactor.util.function.Tuple2;\n+\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.concurrent.CopyOnWriteArrayList;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Function;\n+\n+import static java.util.Arrays.asList;\n+import static org.axonframework.common.BuilderUtils.assertNonNull;\n+import static org.axonframework.messaging.GenericMessage.asMessage;\n+\n+/**\n+ * Implementation of the {@link ReactorQueryGateway} that uses Project Reactor to achieve reactiveness.\n+ *\n+ * @author Milan Savic\n+ * @since 4.4\n+ */\n+public class DefaultReactorQueryGateway implements ReactorQueryGateway {\n+\n+    private final List<ReactorMessageDispatchInterceptor<QueryMessage<?, ?>>> dispatchInterceptors;\n+    private final List<ReactorResultHandlerInterceptor<QueryMessage<?, ?>, ResultMessage<?>>> resultInterceptors;\n+\n+    private final QueryBus queryBus;\n+\n+    /**\n+     * Creates an instance of {@link DefaultReactorQueryGateway} based on the fields contained in the {@link\n+     * Builder}.\n+     * <p>\n+     * Will assert that the {@link QueryBus} is not {@code null} and throws an {@link AxonConfigurationException} if\n+     * it is.\n+     * </p>\n+     *\n+     * @param builder the {@link Builder} used to instantiated a {@link DefaultReactorQueryGateway} instance\n+     */\n+    protected DefaultReactorQueryGateway(Builder builder) {\n+        builder.validate();\n+        this.queryBus = builder.queryBus;\n+        this.dispatchInterceptors = builder.dispatchInterceptors;\n+        this.resultInterceptors = builder.resultInterceptors;\n+    }\n+\n+    /**\n+     * Instantiate a Builder to be able to create a {@link DefaultReactorQueryGateway}.\n+     * <p>\n+     * The {@code dispatchInterceptors} are defaulted to an empty list.\n+     * The {@code resultHandlerInterceptors} are defaulted to an empty list.\n+     * The {@link QueryBus} is a <b>hard requirement</b> and as such should be provided.\n+     * </p>\n+     *\n+     * @return a Builder to be able to create a {@link DefaultReactorQueryGateway}\n+     */\n+    public static Builder builder() {\n+        return new Builder();\n+    }\n+\n+    @Override\n+    public Registration registerDispatchInterceptor(\n+            ReactorMessageDispatchInterceptor<QueryMessage<?, ?>> interceptor) {\n+        dispatchInterceptors.add(interceptor);\n+        return () -> dispatchInterceptors.remove(interceptor);\n+    }\n+\n+    @Override\n+    public Registration registerResultHandlerInterceptor(\n+            ReactorResultHandlerInterceptor<QueryMessage<?, ?>, ResultMessage<?>> interceptor) {\n+        resultInterceptors.add(interceptor);\n+        return () -> resultInterceptors.remove(interceptor);\n+    }\n+\n+    @Override\n+    public <R, Q> Mono<R> query(String queryName, Q query, ResponseType<R> responseType) {\n+        return Mono.<QueryMessage<?, ?>>fromCallable(() -> new GenericQueryMessage<>(asMessage(query),\n+                                                                                     queryName,\n+                                                                                     responseType))\n+                .transform(this::processDispatchInterceptors)\n+                .flatMap(this::dispatchQuery)\n+                .flatMapMany(this::processResultsInterceptors)\n+                .<R>transform(this::getPayload)\n+                .next();\n+    }\n+\n+    @Override\n+    public <R, Q> Flux<R> scatterGather(String queryName, Q query, ResponseType<R> responseType, long timeout,\n+                                        TimeUnit timeUnit) {\n+        return Mono.<QueryMessage<?, ?>>fromCallable(() -> new GenericQueryMessage<>(asMessage(query),\n+                                                                                     queryName,\n+                                                                                     responseType))\n+                .transform(this::processDispatchInterceptors)\n+                .flatMap(q -> dispatchScatterGatherQuery(q, timeout, timeUnit))\n+                .flatMapMany(this::processResultsInterceptors)\n+                .transform(this::getPayload);\n+    }\n+\n+    @Override\n+    public <Q, I, U> Mono<SubscriptionQueryResult<I, U>> subscriptionQuery(String queryName, Q query,\n+                                                                           ResponseType<I> initialResponseType,\n+                                                                           ResponseType<U> updateResponseType,\n+                                                                           SubscriptionQueryBackpressure backpressure,\n+                                                                           int updateBufferSize) {\n+\n+        //noinspection unchecked\n+        return Mono.<QueryMessage<?, ?>>fromCallable(() -> new GenericSubscriptionQueryMessage<>(query,\n+                                                                                                 initialResponseType,\n+                                                                                                 updateResponseType))\n+                .transform(this::processDispatchInterceptors)\n+                .map(isq -> (SubscriptionQueryMessage<Q, U, I>) isq)\n+                .flatMap(isq -> dispatchSubscriptionQuery(isq, backpressure, updateBufferSize))\n+                .flatMap(processSubscriptionQueryResult());\n+    }\n+\n+\n+    private Mono<Tuple2<QueryMessage<?, ?>, Flux<ResultMessage<?>>>> dispatchQuery(QueryMessage<?, ?> queryMessage) {\n+        Flux<ResultMessage<?>> results = Flux\n+                .defer(() -> Mono.fromFuture(queryBus.query(queryMessage)));\n+\n+        return Mono.<QueryMessage<?, ?>>just(queryMessage)\n+                .zipWith(Mono.just(results));\n+    }\n+\n+    private Mono<Tuple2<QueryMessage<?, ?>, Flux<ResultMessage<?>>>> dispatchScatterGatherQuery(\n+            QueryMessage<?, ?> queryMessage, long timeout, TimeUnit timeUnit) {\n+        Flux<ResultMessage<?>> results = Flux\n+                .defer(() -> Flux.fromStream(queryBus.scatterGather(queryMessage,\n+                                                                    timeout,\n+                                                                    timeUnit)));\n+\n+        return Mono.<QueryMessage<?, ?>>just(queryMessage)\n+                .zipWith(Mono.just(results));\n+    }\n+\n+    private <Q, I, U> Mono<Tuple2<QueryMessage<Q, I>, Mono<SubscriptionQueryResult<QueryResponseMessage<I>, SubscriptionQueryUpdateMessage<U>>>>> dispatchSubscriptionQuery(\n+            SubscriptionQueryMessage<Q, I, U> queryMessage, SubscriptionQueryBackpressure backpressure,\n+            int updateBufferSize) {\n+        Mono<SubscriptionQueryResult<QueryResponseMessage<I>, SubscriptionQueryUpdateMessage<U>>> result = Mono\n+                .fromCallable(() -> queryBus.subscriptionQuery(queryMessage, backpressure, updateBufferSize));\n+        return Mono.<QueryMessage<Q, I>>just(queryMessage)\n+                .zipWith(Mono.just(result));\n+    }\n+\n+    private Mono<QueryMessage<?, ?>> processDispatchInterceptors(Mono<QueryMessage<?, ?>> queryMessageMono) {\n+        return Flux.fromIterable(dispatchInterceptors)\n+                   .reduce(queryMessageMono, (queryMessage, interceptor) -> interceptor.intercept(queryMessage))\n+                   .flatMap(Mono::from);\n+    }\n+\n+    private Flux<ResultMessage<?>> processResultsInterceptors(\n+            Tuple2<QueryMessage<?, ?>, Flux<ResultMessage<?>>> queryWithResponses) {\n+        QueryMessage<?, ?> queryMessage = queryWithResponses.getT1();\n+        Flux<ResultMessage<?>> queryResultMessage = queryWithResponses.getT2();\n+\n+        return Flux.fromIterable(resultInterceptors)\n+                   .reduce(queryResultMessage,\n+                           (result, interceptor) -> interceptor.intercept(queryMessage, result))\n+                   .flatMapMany(it -> it);\n+    }\n+\n+    private <Q, I, U> Function<Tuple2<QueryMessage<Q, U>,\n+            Mono<SubscriptionQueryResult<QueryResponseMessage<U>, SubscriptionQueryUpdateMessage<I>>>>,\n+            Mono<SubscriptionQueryResult<I, U>>> processSubscriptionQueryResult() {\n+\n+        return messageWithResult -> messageWithResult.getT2().map(sqr -> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "98865ab1427e4d879301c1bf542842eccc8aa3c3"}, "originalPosition": 189}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjgzMDY0MA==", "bodyText": "Curious/nit: Why is the lambda variable a p for the QueryUpdateEmitter#complete call? Shouldn't that be a q too?", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r452830640", "createdAt": "2020-07-10T13:06:08Z", "author": {"login": "smcvb"}, "path": "messaging/src/test/java/org/axonframework/queryhandling/DefaultReactorQueryGatewayTest.java", "diffHunk": "@@ -0,0 +1,780 @@\n+/*\n+ * Copyright (c) 2010-2020. Axon Framework\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.axonframework.queryhandling;\n+\n+import org.axonframework.common.Registration;\n+import org.axonframework.messaging.MessageHandler;\n+import org.axonframework.messaging.ResultMessage;\n+import org.axonframework.messaging.responsetypes.ResponseTypes;\n+import org.junit.jupiter.api.*;\n+import org.junit.jupiter.api.extension.*;\n+import org.mockito.junit.jupiter.*;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Hooks;\n+import reactor.core.publisher.Mono;\n+import reactor.test.StepVerifier;\n+import reactor.util.context.Context;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+\n+import static org.axonframework.common.ReflectionUtils.methodOf;\n+import static org.junit.jupiter.api.Assertions.*;\n+import static org.mockito.Mockito.*;\n+\n+/**\n+ * Tests for {@link DefaultReactorQueryGateway}.\n+ *\n+ * @author Milan Savic\n+ */\n+@ExtendWith(MockitoExtension.class)\n+class DefaultReactorQueryGatewayTest {\n+\n+    private DefaultReactorQueryGateway reactiveQueryGateway;\n+    private QueryUpdateEmitter queryUpdateEmitter;\n+    private MessageHandler<QueryMessage<?, Object>> queryMessageHandler1;\n+    private MessageHandler<QueryMessage<?, Object>> queryMessageHandler2;\n+    private MessageHandler<QueryMessage<?, Object>> queryMessageHandler3;\n+    private SimpleQueryBus queryBus;\n+\n+    @BeforeEach\n+    void setUp() throws NoSuchMethodException {\n+        Hooks.enableContextLossTracking();\n+        Hooks.onOperatorDebug();\n+\n+        queryBus = spy(SimpleQueryBus.builder().build());\n+\n+        queryUpdateEmitter = queryBus.queryUpdateEmitter();\n+        AtomicInteger count = new AtomicInteger();\n+        queryMessageHandler1 = spy(new MessageHandler<QueryMessage<?, Object>>() {\n+\n+            @Override\n+            public Object handle(QueryMessage<?, Object> message) {\n+                if (\"backpressure\".equals(message.getPayload())) {\n+                    return count.incrementAndGet();\n+                }\n+                return \"handled\";\n+            }\n+        });\n+        queryMessageHandler2 = spy(new MessageHandler<QueryMessage<?, Object>>() {\n+            @Override\n+            public Object handle(QueryMessage<?, Object> message) {\n+                if (\"backpressure\".equals(message.getPayload())) {\n+                    return count.incrementAndGet();\n+                }\n+                return \"handled\";\n+            }\n+        });\n+\n+        queryMessageHandler3 = spy(new MessageHandler<QueryMessage<?, Object>>() {\n+            @Override\n+            public Object handle(QueryMessage<?, Object> message) {\n+                throw new RuntimeException();\n+            }\n+        });\n+\n+        queryBus.subscribe(String.class.getName(), String.class, queryMessageHandler1);\n+        queryBus.subscribe(String.class.getName(), String.class, queryMessageHandler2);\n+        queryBus.subscribe(Integer.class.getName(), Integer.class, queryMessageHandler3);\n+\n+        queryBus.subscribe(Boolean.class.getName(),\n+                           String.class,\n+                           message -> \"\" + message.getMetaData().getOrDefault(\"key1\", \"\")\n+                                   + message.getMetaData().getOrDefault(\"key2\", \"\"));\n+\n+        queryBus.subscribe(Long.class.getName(), String.class, message -> null);\n+\n+        queryBus.subscribe(Double.class.getName(),\n+                           methodOf(this.getClass(), \"stringListQueryHandler\").getGenericReturnType(),\n+                           message -> Arrays.asList(\"value1\", \"value2\", \"value3\"));\n+\n+        reactiveQueryGateway = DefaultReactorQueryGateway.builder()\n+                                                         .queryBus(queryBus)\n+                                                         .build();\n+    }\n+\n+    @SuppressWarnings(\"unused\") // Used by 'testSubscriptionQueryMany()' to generate query handler response type\n+    public List<String> stringListQueryHandler() {\n+        return new ArrayList<>();\n+    }\n+\n+    @Test\n+    void testQuery() throws Exception {\n+\n+        Mono<String> result = reactiveQueryGateway.query(\"criteria\", String.class);\n+        verifyZeroInteractions(queryMessageHandler1);\n+        verifyZeroInteractions(queryMessageHandler2);\n+        StepVerifier.create(result)\n+                    .expectNext(\"handled\")\n+                    .verifyComplete();\n+        verify(queryMessageHandler1).handle(any());\n+    }\n+\n+    @Test\n+    void testQueryWithContext() throws Exception {\n+        Context context = Context.of(\"k1\", \"v1\");\n+\n+        Mono<String> result = reactiveQueryGateway.query(\"criteria\", String.class).subscriberContext(context);\n+\n+        verifyZeroInteractions(queryMessageHandler1);\n+        verifyZeroInteractions(queryMessageHandler2);\n+        StepVerifier.create(result)\n+                    .expectNext(\"handled\")\n+                    .expectAccessibleContext()\n+                    .containsOnly(context)\n+                    .then()\n+                    .verifyComplete();\n+        verify(queryMessageHandler1).handle(any());\n+    }\n+\n+    @Test\n+    void testMultipleQueries() throws Exception {\n+        Flux<QueryMessage<?, ?>> queries = Flux.fromIterable(Arrays.asList(\n+                new GenericQueryMessage<>(\"query1\", ResponseTypes.instanceOf(String.class)),\n+                new GenericQueryMessage<>(4, ResponseTypes.instanceOf(Integer.class)),\n+                new GenericQueryMessage<>(\"query2\", ResponseTypes.instanceOf(String.class)),\n+                new GenericQueryMessage<>(5, ResponseTypes.instanceOf(Integer.class)),\n+                new GenericQueryMessage<>(true, ResponseTypes.instanceOf(String.class))));\n+\n+        Flux<Object> result = reactiveQueryGateway.query(queries);\n+        verifyZeroInteractions(queryMessageHandler1);\n+        verifyZeroInteractions(queryMessageHandler2);\n+\n+        List<Throwable> exceptions = new ArrayList<>(2);\n+        StepVerifier.create(result.onErrorContinue((t, o) -> exceptions.add(t)))\n+                    .expectNext(\"handled\", \"handled\", \"\")\n+                    .verifyComplete();\n+\n+        assertEquals(2, exceptions.size());\n+        assertTrue(exceptions.get(0) instanceof RuntimeException);\n+        assertTrue(exceptions.get(1) instanceof RuntimeException);\n+        verify(queryMessageHandler1, times(2)).handle(any());\n+    }\n+\n+    @Test\n+    void testMultipleQueriesOrdering() throws Exception {\n+        int numberOfQueries = 10_000;\n+        Flux<QueryMessage<?, ?>> queries = Flux\n+                .fromStream(IntStream.range(0, numberOfQueries)\n+                                     .mapToObj(i -> new GenericQueryMessage<>(\"backpressure\",\n+                                                                              ResponseTypes.instanceOf(String.class))));\n+        List<Integer> expectedResults = IntStream.range(1, numberOfQueries + 1)\n+                                                 .boxed()\n+                                                 .collect(Collectors.toList());\n+        Flux<Object> result = reactiveQueryGateway.query(queries);\n+        StepVerifier.create(result)\n+                    .expectNext(expectedResults.toArray(new Integer[0]))\n+                    .verifyComplete();\n+        verify(queryMessageHandler1, times(numberOfQueries)).handle(any());\n+    }\n+\n+    @Test\n+    void testQueryReturningNull() {\n+        assertNull(reactiveQueryGateway.query(0L, String.class).block());\n+        StepVerifier.create(reactiveQueryGateway.query(0L, String.class))\n+                    .expectComplete()\n+                    .verify();\n+    }\n+\n+    @Test\n+    void testQueryWithDispatchInterceptor() {\n+        reactiveQueryGateway\n+                .registerDispatchInterceptor(queryMono -> queryMono\n+                        .map(query -> query.andMetaData(Collections.singletonMap(\"key1\", \"value1\"))));\n+        Registration registration2 = reactiveQueryGateway\n+                .registerDispatchInterceptor(queryMono -> queryMono\n+                        .map(query -> query.andMetaData(Collections.singletonMap(\"key2\", \"value2\"))));\n+\n+        StepVerifier.create(reactiveQueryGateway.query(true, String.class))\n+                    .expectNext(\"value1value2\")\n+                    .verifyComplete();\n+\n+        registration2.cancel();\n+\n+        StepVerifier.create(reactiveQueryGateway.query(true, String.class))\n+                    .expectNext(\"value1\")\n+                    .verifyComplete();\n+    }\n+\n+    @Test\n+    void testQueryWithDispatchInterceptorWithContext() {\n+        Context context = Context.of(\"security\", true);\n+\n+        reactiveQueryGateway\n+                .registerDispatchInterceptor(queryMono -> queryMono\n+                        .filterWhen(v -> Mono.subscriberContext()\n+                                             .filter(ctx -> ctx.hasKey(\"security\"))\n+                                             .map(ctx -> ctx.get(\"security\")))\n+                        .map(query -> query.andMetaData(Collections.singletonMap(\"key1\", \"value1\"))));\n+\n+        StepVerifier.create(reactiveQueryGateway.query(true, String.class).subscriberContext(context))\n+                    .expectNext(\"value1\")\n+                    .expectAccessibleContext()\n+                    .containsOnly(context)\n+                    .then()\n+                    .verifyComplete();\n+    }\n+\n+    @Test\n+    void testQueryWithResultInterceptorAlterResult() throws Exception {\n+        reactiveQueryGateway.registerResultHandlerInterceptor((q, results) -> results\n+                .map(it -> new GenericQueryResponseMessage<>(\"handled-modified\")));\n+\n+        Mono<String> result = reactiveQueryGateway.query(\"criteria\", String.class);\n+        verifyZeroInteractions(queryMessageHandler1);\n+        verifyZeroInteractions(queryMessageHandler2);\n+        StepVerifier.create(result)\n+                    .expectNext(\"handled-modified\")\n+                    .verifyComplete();\n+        verify(queryMessageHandler1).handle(any());\n+    }\n+\n+    @Test\n+    void testQueryWithResultInterceptorFilterResult() throws Exception {\n+        reactiveQueryGateway.registerResultHandlerInterceptor((q, results) -> results\n+                .filter(it -> !it.getPayload().equals(\"handled\")));\n+\n+        Mono<String> result = reactiveQueryGateway.query(\"criteria\", String.class);\n+        verifyZeroInteractions(queryMessageHandler1);\n+        verifyZeroInteractions(queryMessageHandler2);\n+        StepVerifier.create(result)\n+                    .expectComplete()\n+                    .verify();\n+        verify(queryMessageHandler1).handle(any());\n+    }\n+\n+    @Test\n+    void testQueryWithDispatchInterceptorThrowingAnException() {\n+        reactiveQueryGateway\n+                .registerDispatchInterceptor(queryMono -> {\n+                    throw new RuntimeException();\n+                });\n+        StepVerifier.create(reactiveQueryGateway.query(true, String.class))\n+                    .verifyError(RuntimeException.class);\n+    }\n+\n+    @Test\n+    void testQueryWithDispatchInterceptorReturningErrorMono() {\n+        reactiveQueryGateway\n+                .registerDispatchInterceptor(queryMono -> Mono.error(new RuntimeException()));\n+        StepVerifier.create(reactiveQueryGateway.query(true, String.class))\n+                    .verifyError(RuntimeException.class);\n+    }\n+\n+    @Test\n+    void testQueryFails() {\n+        StepVerifier.create(reactiveQueryGateway.query(5, Integer.class))\n+                    .verifyError(RuntimeException.class);\n+    }\n+\n+    @Test\n+    void testQueryFailsWithRetry() throws Exception {\n+\n+        Mono<Integer> query = reactiveQueryGateway.query(5, Integer.class).retry(5);\n+\n+        StepVerifier.create(query)\n+                    .verifyError(RuntimeException.class);\n+\n+        verify(queryMessageHandler3, times(6)).handle(any());\n+    }\n+\n+\n+    @Test\n+    void testScatterGather() throws Exception {\n+        Flux<String> result = reactiveQueryGateway.scatterGather(\"criteria\",\n+                                                                 ResponseTypes.instanceOf(String.class),\n+                                                                 1,\n+                                                                 TimeUnit.SECONDS);\n+        verifyZeroInteractions(queryMessageHandler1);\n+        verifyZeroInteractions(queryMessageHandler2);\n+        StepVerifier.create(result)\n+                    .expectNext(\"handled\", \"handled\")\n+                    .verifyComplete();\n+        verify(queryMessageHandler1).handle(any());\n+        verify(queryMessageHandler2).handle(any());\n+    }\n+\n+    @Test\n+    void testMultipleScatterGather() throws Exception {\n+        Flux<QueryMessage<?, ?>> queries = Flux.fromIterable(Arrays.asList(\n+                new GenericQueryMessage<>(\"query1\", ResponseTypes.instanceOf(String.class)),\n+                new GenericQueryMessage<>(4, ResponseTypes.instanceOf(Integer.class)),\n+                new GenericQueryMessage<>(\"query2\", ResponseTypes.instanceOf(String.class)),\n+                new GenericQueryMessage<>(5, ResponseTypes.instanceOf(Integer.class)),\n+                new GenericQueryMessage<>(true, ResponseTypes.instanceOf(String.class))));\n+\n+        Flux<Object> result = reactiveQueryGateway.scatterGather(queries, 1, TimeUnit.SECONDS);\n+        verifyZeroInteractions(queryMessageHandler1);\n+        verifyZeroInteractions(queryMessageHandler2);\n+\n+        StepVerifier.create(result)\n+                    .expectNext(\"handled\", \"handled\", \"handled\", \"handled\", \"\")\n+                    .verifyComplete();\n+\n+        verify(queryMessageHandler1, times(2)).handle(any());\n+        verify(queryMessageHandler2, times(2)).handle(any());\n+    }\n+\n+    @Test\n+    void testMultipleScatterGatherOrdering() throws Exception {\n+        int numberOfQueries = 10_000;\n+        Flux<QueryMessage<?, ?>> queries = Flux\n+                .fromStream(IntStream.range(0, numberOfQueries)\n+                                     .mapToObj(i -> new GenericQueryMessage<>(\"backpressure\",\n+                                                                              ResponseTypes.instanceOf(String.class))));\n+        List<Integer> expectedResults = IntStream.range(1, 2 * numberOfQueries + 1)\n+                                                 .boxed()\n+                                                 .collect(Collectors.toList());\n+        Flux<Object> result = reactiveQueryGateway.scatterGather(queries, 1, TimeUnit.SECONDS);\n+        StepVerifier.create(result)\n+                    .expectNext(expectedResults.toArray(new Integer[0]))\n+                    .verifyComplete();\n+        verify(queryMessageHandler1, times(numberOfQueries)).handle(any());\n+        verify(queryMessageHandler2, times(numberOfQueries)).handle(any());\n+    }\n+\n+    @Test\n+    void testScatterGatherReturningNull() {\n+        assertNull(reactiveQueryGateway.scatterGather(0L, ResponseTypes.instanceOf(String.class), 1, TimeUnit.SECONDS)\n+                                       .blockFirst());\n+        StepVerifier.create(reactiveQueryGateway\n+                                    .scatterGather(0L, ResponseTypes.instanceOf(String.class), 1, TimeUnit.SECONDS))\n+                    .expectNext()\n+                    .verifyComplete();\n+    }\n+\n+    @Test\n+    void testScatterGatherWithDispatchInterceptor() {\n+        reactiveQueryGateway\n+                .registerDispatchInterceptor(queryMono -> queryMono\n+                        .map(query -> query.andMetaData(Collections.singletonMap(\"key1\", \"value1\"))));\n+        Registration registration2 = reactiveQueryGateway\n+                .registerDispatchInterceptor(queryMono -> queryMono\n+                        .map(query -> query.andMetaData(Collections.singletonMap(\"key2\", \"value2\"))));\n+\n+        StepVerifier.create(reactiveQueryGateway\n+                                    .scatterGather(true, ResponseTypes.instanceOf(String.class), 1, TimeUnit.SECONDS))\n+                    .expectNext(\"value1value2\")\n+                    .verifyComplete();\n+\n+        registration2.cancel();\n+\n+        StepVerifier.create(reactiveQueryGateway.query(true, String.class))\n+                    .expectNext(\"value1\")\n+                    .verifyComplete();\n+    }\n+\n+    @Test\n+    void testScatterGatherWithResultIntercept() throws Exception {\n+        reactiveQueryGateway\n+                .registerResultHandlerInterceptor(\n+                        (query, results) -> results\n+                                .map(it -> new GenericQueryResponseMessage<>(\"handled-modified\"))\n+                );\n+\n+        Flux<QueryMessage<?, ?>> queries = Flux.fromIterable(Arrays.asList(\n+                new GenericQueryMessage<>(\"query1\", ResponseTypes.instanceOf(String.class)),\n+                new GenericQueryMessage<>(4, ResponseTypes.instanceOf(Integer.class)),\n+                new GenericQueryMessage<>(\"query2\", ResponseTypes.instanceOf(String.class)),\n+                new GenericQueryMessage<>(5, ResponseTypes.instanceOf(Integer.class)),\n+                new GenericQueryMessage<>(true, ResponseTypes.instanceOf(String.class))));\n+\n+        Flux<Object> result = reactiveQueryGateway.scatterGather(queries, 1, TimeUnit.SECONDS);\n+        verifyZeroInteractions(queryMessageHandler1);\n+        verifyZeroInteractions(queryMessageHandler2);\n+\n+        StepVerifier.create(result)\n+                    .expectNext(\"handled-modified\",\n+                                \"handled-modified\",\n+                                \"handled-modified\",\n+                                \"handled-modified\",\n+                                \"handled-modified\")\n+                    .verifyComplete();\n+\n+        verify(queryMessageHandler1, times(2)).handle(any());\n+        verify(queryMessageHandler2, times(2)).handle(any());\n+    }\n+\n+    @Test\n+    void testQueryWithResultInterceptorModifyResultBasedOnQuery() throws Exception {\n+        reactiveQueryGateway.registerDispatchInterceptor(q -> q.map(it ->\n+                                                                            it.andMetaData(Collections.singletonMap(\n+                                                                                    \"block\",\n+                                                                                    it.getPayload() instanceof Boolean)\n+                                                                            )));\n+        reactiveQueryGateway\n+                .registerResultHandlerInterceptor((q, results) -> results\n+                        .filter(it -> !((boolean) q.getMetaData().get(\"block\")))\n+                );\n+\n+        Flux<QueryMessage<?, ?>> queries = Flux.fromIterable(Arrays.asList(\n+                new GenericQueryMessage<>(\"query1\", ResponseTypes.instanceOf(String.class)),\n+                new GenericQueryMessage<>(4, ResponseTypes.instanceOf(Integer.class)),\n+                new GenericQueryMessage<>(\"query2\", ResponseTypes.instanceOf(String.class)),\n+                new GenericQueryMessage<>(5, ResponseTypes.instanceOf(Integer.class)),\n+                new GenericQueryMessage<>(Boolean.TRUE, ResponseTypes.instanceOf(String.class))));\n+\n+        Flux<Object> result = reactiveQueryGateway.scatterGather(queries, 1, TimeUnit.SECONDS);\n+        verifyZeroInteractions(queryMessageHandler1);\n+        verifyZeroInteractions(queryMessageHandler2);\n+\n+        StepVerifier.create(result)\n+                    .expectNext(\"handled\", \"handled\", \"handled\", \"handled\")\n+                    .verifyComplete();\n+\n+        verify(queryMessageHandler1, times(2)).handle(any());\n+        verify(queryMessageHandler2, times(2)).handle(any());\n+    }\n+\n+    @Test\n+    void testScatterGatherWithResultInterceptReplacedWithError() throws Exception {\n+        reactiveQueryGateway\n+                .registerResultHandlerInterceptor(\n+                        (query, results) -> results.flatMap(r -> {\n+                            if (r.getPayload().equals(\"\")) {\n+                                return Flux.<ResultMessage<?>>error(new RuntimeException(\"no empty strings allowed\"));\n+                            } else {\n+                                return Flux.just(r);\n+                            }\n+                        })\n+                );\n+\n+        Flux<QueryMessage<?, ?>> queries = Flux.fromIterable(Arrays.asList(\n+                new GenericQueryMessage<>(\"query1\", ResponseTypes.instanceOf(String.class)),\n+                new GenericQueryMessage<>(4, ResponseTypes.instanceOf(Integer.class)),\n+                new GenericQueryMessage<>(\"query2\", ResponseTypes.instanceOf(String.class)),\n+                new GenericQueryMessage<>(5, ResponseTypes.instanceOf(Integer.class)),\n+                new GenericQueryMessage<>(true, ResponseTypes.instanceOf(String.class))));\n+\n+        Flux<Object> result = reactiveQueryGateway.scatterGather(queries, 1, TimeUnit.SECONDS);\n+        verifyZeroInteractions(queryMessageHandler1);\n+        verifyZeroInteractions(queryMessageHandler2);\n+\n+        StepVerifier.create(result)\n+                    .expectNext(\"handled\", \"handled\", \"handled\", \"handled\")\n+                    .expectError(RuntimeException.class)\n+                    .verify();\n+\n+        verify(queryMessageHandler1, times(2)).handle(any());\n+        verify(queryMessageHandler2, times(2)).handle(any());\n+    }\n+\n+    @Test\n+    void testScatterGatherWithDispatchInterceptorThrowingAnException() {\n+        reactiveQueryGateway\n+                .registerDispatchInterceptor(queryMono -> {\n+                    throw new RuntimeException();\n+                });\n+        StepVerifier.create(reactiveQueryGateway\n+                                    .scatterGather(true, ResponseTypes.instanceOf(String.class), 1, TimeUnit.SECONDS))\n+                    .verifyError(RuntimeException.class);\n+    }\n+\n+    @Test\n+    void testScatterGatherWithDispatchInterceptorReturningErrorMono() {\n+        reactiveQueryGateway\n+                .registerDispatchInterceptor(queryMono -> Mono.error(new RuntimeException()));\n+        StepVerifier.create(reactiveQueryGateway\n+                                    .scatterGather(true, ResponseTypes.instanceOf(String.class), 1, TimeUnit.SECONDS))\n+                    .verifyError(RuntimeException.class);\n+    }\n+\n+    @Test\n+    void testScatterGatherFails() {\n+        StepVerifier.create(reactiveQueryGateway.scatterGather(6,\n+                                                               ResponseTypes.instanceOf(Integer.class),\n+                                                               1,\n+                                                               TimeUnit.SECONDS))\n+                    .expectNextCount(0)\n+                    .verifyComplete();\n+    }\n+\n+    @Test\n+    void testScatterGatherFailsWithRetry() throws Exception {\n+        doThrow(new RuntimeException(\":(\")).when(queryBus).scatterGather(any(), anyLong(), any());\n+\n+        Flux<Integer> query = reactiveQueryGateway.scatterGather(6,\n+                                                                 ResponseTypes.instanceOf(Integer.class),\n+                                                                 1,\n+                                                                 TimeUnit.SECONDS).retry(5);\n+\n+        StepVerifier.create(query)\n+                    .verifyError();\n+\n+\n+        verify(queryBus, times(6)).scatterGather(any(), anyLong(), any());\n+    }\n+\n+\n+    @Test\n+    void testSubscriptionQuery() throws Exception {\n+        Mono<SubscriptionQueryResult<String, String>> monoResult = reactiveQueryGateway.subscriptionQuery(\"criteria\",\n+                                                                                                          String.class,\n+                                                                                                          String.class);\n+        verifyZeroInteractions(queryMessageHandler1);\n+        verifyZeroInteractions(queryMessageHandler2);\n+\n+        SubscriptionQueryResult<String, String> result = monoResult.block();\n+        assertNotNull(result);\n+        StepVerifier.create(result.initialResult())\n+                    .expectNext(\"handled\")\n+                    .verifyComplete();\n+        StepVerifier.create(result.updates()\n+                                  .doOnSubscribe(s -> {\n+                                      queryUpdateEmitter.emit(String.class, q -> true, \"update\");\n+                                      queryUpdateEmitter.complete(String.class, q -> true);\n+                                  }))\n+                    .expectNext(\"update\")\n+                    .verifyComplete();\n+        verify(queryMessageHandler1).handle(any());\n+    }\n+\n+    @Test\n+    void testMultipleSubscriptionQueries() throws Exception {\n+        Flux<SubscriptionQueryMessage<?, ?, ?>> queries = Flux.fromIterable(Arrays.asList(\n+                new GenericSubscriptionQueryMessage<>(\"query1\",\n+                                                      ResponseTypes.instanceOf(String.class),\n+                                                      ResponseTypes.instanceOf(String.class)),\n+                new GenericSubscriptionQueryMessage<>(4,\n+                                                      ResponseTypes.instanceOf(Integer.class),\n+                                                      ResponseTypes.instanceOf(String.class))));\n+\n+        Flux<SubscriptionQueryResult<?, ?>> result = reactiveQueryGateway.subscriptionQuery(queries);\n+        verifyZeroInteractions(queryMessageHandler1);\n+        verifyZeroInteractions(queryMessageHandler2);\n+        List<Mono<Object>> initialResults = new ArrayList<>(2);\n+        //noinspection unchecked\n+        result.subscribe(sqr -> initialResults.add((Mono<Object>) sqr.initialResult()));\n+        assertEquals(2, initialResults.size());\n+        StepVerifier.create(initialResults.get(0))\n+                    .expectNext(\"handled\")\n+                    .verifyComplete();\n+        StepVerifier.create(initialResults.get(1))\n+                    .verifyError(RuntimeException.class);\n+\n+        verify(queryMessageHandler1).handle(any());\n+    }\n+\n+    @Test\n+    void testMultipleSubscriptionQueriesOrdering() throws Exception {\n+        int numberOfQueries = 10_000;\n+        Flux<SubscriptionQueryMessage<?, ?, ?>> queries = Flux\n+                .fromStream(IntStream.range(0, numberOfQueries)\n+                                     .mapToObj(i -> new GenericSubscriptionQueryMessage<>(\"backpressure\",\n+                                                                                          ResponseTypes\n+                                                                                                  .instanceOf(String.class),\n+                                                                                          ResponseTypes\n+                                                                                                  .instanceOf(String.class))));\n+        List<Integer> expectedResults = IntStream.range(1, numberOfQueries + 1)\n+                                                 .boxed()\n+                                                 .collect(Collectors.toList());\n+        Flux<SubscriptionQueryResult<?, ?>> result = reactiveQueryGateway.subscriptionQuery(queries);\n+        List<Mono<Object>> initialResults = new ArrayList<>(numberOfQueries);\n+        //noinspection unchecked\n+        result.subscribe(sqr -> initialResults.add((Mono<Object>) sqr.initialResult()));\n+        assertEquals(numberOfQueries, initialResults.size());\n+        for (int i = 0; i < numberOfQueries; i++) {\n+            StepVerifier.create(initialResults.get(i))\n+                        .expectNext(expectedResults.get(i))\n+                        .verifyComplete();\n+        }\n+\n+        verify(queryMessageHandler1, times(numberOfQueries)).handle(any());\n+    }\n+\n+    @Test\n+    void testSubscriptionQueryReturningNull() {\n+        SubscriptionQueryResult<String, String> result = reactiveQueryGateway.subscriptionQuery(0L,\n+                                                                                                String.class,\n+                                                                                                String.class)\n+                                                                             .block();\n+        assertNotNull(result);\n+        assertNull(result.initialResult().block());\n+        StepVerifier.create(result.initialResult())\n+                    .expectNext()\n+                    .verifyComplete();\n+        StepVerifier.create(result.updates()\n+                                  .doOnSubscribe(s -> {\n+                                      queryUpdateEmitter.emit(Long.class, q -> true, (String) null);\n+                                      queryUpdateEmitter.complete(Long.class, q -> true);\n+                                  }))\n+                    .expectNext()\n+                    .verifyComplete();\n+    }\n+\n+    @Test\n+    void testSubscriptionQueryWithDispatchInterceptor() {\n+        reactiveQueryGateway\n+                .registerDispatchInterceptor(queryMono -> queryMono\n+                        .map(query -> query.andMetaData(Collections.singletonMap(\"key1\", \"value1\"))));\n+        Registration registration2 = reactiveQueryGateway\n+                .registerDispatchInterceptor(queryMono -> queryMono\n+                        .map(query -> query.andMetaData(Collections.singletonMap(\"key2\", \"value2\"))));\n+\n+        Mono<SubscriptionQueryResult<String, String>> monoResult = reactiveQueryGateway\n+                .subscriptionQuery(true, String.class, String.class);\n+        SubscriptionQueryResult<String, String> result = monoResult.block();\n+        assertNotNull(result);\n+        StepVerifier.create(result.initialResult())\n+                    .expectNext(\"value1value2\")\n+                    .verifyComplete();\n+\n+        registration2.cancel();\n+\n+        monoResult = reactiveQueryGateway.subscriptionQuery(true, String.class, String.class);\n+        result = monoResult.block();\n+        assertNotNull(result);\n+        StepVerifier.create(result.initialResult())\n+                    .expectNext(\"value1\")\n+                    .verifyComplete();\n+    }\n+\n+    @Test\n+    void testSubscriptionQueryWithDispatchInterceptorThrowingAnException() {\n+        reactiveQueryGateway\n+                .registerDispatchInterceptor(queryMono -> {\n+                    throw new RuntimeException();\n+                });\n+        StepVerifier.create(reactiveQueryGateway.subscriptionQuery(true, String.class, String.class))\n+                    .verifyError(RuntimeException.class);\n+    }\n+\n+    @Test\n+    void testSubscriptionQueryWithDispatchInterceptorReturningErrorMono() {\n+        reactiveQueryGateway\n+                .registerDispatchInterceptor(queryMono -> Mono.error(new RuntimeException()));\n+        StepVerifier.create(reactiveQueryGateway.subscriptionQuery(true, String.class, String.class))\n+                    .verifyError(RuntimeException.class);\n+    }\n+\n+    @Test\n+    void testSubscriptionQueryFails() {\n+        Mono<SubscriptionQueryResult<Integer, Integer>> monoResult = reactiveQueryGateway.subscriptionQuery(6,\n+                                                                                                            Integer.class,\n+                                                                                                            Integer.class);\n+        SubscriptionQueryResult<Integer, Integer> result = monoResult.block();\n+        assertNotNull(result);\n+        StepVerifier.create(result.initialResult())\n+                    .verifyError(RuntimeException.class);\n+    }\n+\n+    @Test\n+    void testSubscriptionQueryFailsRetryInitialDispatchQuery() throws Exception {\n+\n+        doThrow(new RuntimeException(\":(\")).when(queryBus).subscriptionQuery(any(), any(), anyInt());\n+\n+        Mono<SubscriptionQueryResult<Integer, Integer>> monoResult = reactiveQueryGateway.subscriptionQuery(6,\n+                                                                                                            Integer.class,\n+                                                                                                            Integer.class)\n+                                                                                         .retry(5);\n+\n+        StepVerifier.create(monoResult)\n+                    .verifyError(RuntimeException.class);\n+\n+        verify(queryBus, times(6)).subscriptionQuery(any(), any(), anyInt());\n+    }\n+\n+    @Test\n+    void testSubscriptionQueryFailsRetryInitialResult() throws Exception {\n+        Mono<SubscriptionQueryResult<Integer, Integer>> monoResult = reactiveQueryGateway.subscriptionQuery(6,\n+                                                                                                            Integer.class,\n+                                                                                                            Integer.class);\n+\n+        SubscriptionQueryResult<Integer, Integer> result = monoResult.block();\n+        assertNotNull(result);\n+        StepVerifier.create(result.initialResult().retry(5))\n+                    .verifyError(RuntimeException.class);\n+\n+        verify(queryMessageHandler3, times(6)).handle(any());\n+    }\n+\n+    @Test\n+    void testSubscriptionQuerySingleInitialResultAndUpdates() {\n+        Flux<String> result = reactiveQueryGateway.subscriptionQuery(\"6\", String.class);\n+        CountDownLatch countDownLatch = new CountDownLatch(1);\n+\n+        ScheduledExecutorService executorService = Executors.newSingleThreadScheduledExecutor();\n+        executorService.execute(() -> {\n+            try {\n+                countDownLatch.await();\n+            } catch (InterruptedException e) {\n+                fail(e.getMessage());\n+            }\n+            queryUpdateEmitter.emit(String.class, q -> true, \"1\");\n+            queryUpdateEmitter.emit(String.class, q -> true, \"2\");\n+            queryUpdateEmitter.emit(String.class, q -> true, \"3\");\n+            queryUpdateEmitter.emit(String.class, q -> true, \"4\");\n+            queryUpdateEmitter.emit(String.class, q -> true, \"5\");\n+            queryUpdateEmitter.complete(String.class, p -> true);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "98865ab1427e4d879301c1bf542842eccc8aa3c3"}, "originalPosition": 731}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7113d03d8dd6b9f8ba847ae6b872a9f415d88399", "author": {"user": {"login": "stefanvozd", "name": "Stefan Dragisic"}}, "url": "https://github.com/AxonFramework/AxonFramework/commit/7113d03d8dd6b9f8ba847ae6b872a9f415d88399", "committedDate": "2020-07-13T14:36:08Z", "message": "Extend Mono for ReactiveCallback instead of Publisher"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "74bf5d23722a08b6472378bf49061e0441f55012", "author": {"user": {"login": "stefanvozd", "name": "Stefan Dragisic"}}, "url": "https://github.com/AxonFramework/AxonFramework/commit/74bf5d23722a08b6472378bf49061e0441f55012", "committedDate": "2020-07-13T14:37:53Z", "message": "Rename ReactiveCallback to ReactorCallback"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1386c0f757f80e3c178f2f68452fe2a4c8c32aed", "author": {"user": {"login": "stefanvozd", "name": "Stefan Dragisic"}}, "url": "https://github.com/AxonFramework/AxonFramework/commit/1386c0f757f80e3c178f2f68452fe2a4c8c32aed", "committedDate": "2020-07-13T14:45:47Z", "message": "Update messaging/src/main/java/org/axonframework/queryhandling/DefaultReactorQueryGateway.java\n\nCo-authored-by: Steven van Beelen <steven.vanbeelen@axoniq.io>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "924dec53a5a27af4adfaf5a9e622ca6b005dd7c2", "author": {"user": {"login": "stefanvozd", "name": "Stefan Dragisic"}}, "url": "https://github.com/AxonFramework/AxonFramework/commit/924dec53a5a27af4adfaf5a9e622ca6b005dd7c2", "committedDate": "2020-07-13T14:52:22Z", "message": "Update axon-server-connector/src/main/java/org/axonframework/axonserver/connector/query/subscription/GrpcBackedQueryUpdateMessage.java\n\nCo-authored-by: Steven van Beelen <steven.vanbeelen@axoniq.io>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b215bbdc42cb50cc79fc3d4581c5f960f96f1066", "author": {"user": {"login": "stefanvozd", "name": "Stefan Dragisic"}}, "url": "https://github.com/AxonFramework/AxonFramework/commit/b215bbdc42cb50cc79fc3d4581c5f960f96f1066", "committedDate": "2020-07-13T15:06:38Z", "message": "Update messaging/src/main/java/org/axonframework/eventhandling/gateway/ReactorEventGateway.java\n\nCo-authored-by: Steven van Beelen <steven.vanbeelen@axoniq.io>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9a058a0221303d8e1b0c400c3b080d4724b8b348", "author": {"user": {"login": "stefanvozd", "name": "Stefan Dragisic"}}, "url": "https://github.com/AxonFramework/AxonFramework/commit/9a058a0221303d8e1b0c400c3b080d4724b8b348", "committedDate": "2020-07-13T15:06:58Z", "message": "Update messaging/src/main/java/org/axonframework/eventhandling/gateway/ReactorEventGateway.java\n\nCo-authored-by: Steven van Beelen <steven.vanbeelen@axoniq.io>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f609554f36164a88fec7563533a8a18a095d6478", "author": {"user": {"login": "stefanvozd", "name": "Stefan Dragisic"}}, "url": "https://github.com/AxonFramework/AxonFramework/commit/f609554f36164a88fec7563533a8a18a095d6478", "committedDate": "2020-07-13T15:07:16Z", "message": "Update messaging/src/main/java/org/axonframework/messaging/reactive/ReactorResultHandlerInterceptor.java\n\nCo-authored-by: Steven van Beelen <steven.vanbeelen@axoniq.io>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ffb61b6bf7ddfb7bda8d32c45f6d57c9aedccab0", "author": {"user": {"login": "stefanvozd", "name": "Stefan Dragisic"}}, "url": "https://github.com/AxonFramework/AxonFramework/commit/ffb61b6bf7ddfb7bda8d32c45f6d57c9aedccab0", "committedDate": "2020-07-13T15:07:43Z", "message": "Update messaging/src/main/java/org/axonframework/eventhandling/gateway/ReactorEventGateway.java\n\nCo-authored-by: Steven van Beelen <steven.vanbeelen@axoniq.io>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "02688581e2cf74452505996da9c6dad7b2fc2f2d", "author": {"user": {"login": "stefanvozd", "name": "Stefan Dragisic"}}, "url": "https://github.com/AxonFramework/AxonFramework/commit/02688581e2cf74452505996da9c6dad7b2fc2f2d", "committedDate": "2020-07-13T15:14:14Z", "message": "Update messaging/src/main/java/org/axonframework/queryhandling/ReactorQueryGateway.java\n\nCo-authored-by: Steven van Beelen <steven.vanbeelen@axoniq.io>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3697d15e2f6025bbb49a23e02e7c24c79f341d2e", "author": {"user": {"login": "stefanvozd", "name": "Stefan Dragisic"}}, "url": "https://github.com/AxonFramework/AxonFramework/commit/3697d15e2f6025bbb49a23e02e7c24c79f341d2e", "committedDate": "2020-07-13T15:14:43Z", "message": "Update messaging/src/main/java/org/axonframework/queryhandling/ReactorQueryGateway.java\n\nCo-authored-by: Steven van Beelen <steven.vanbeelen@axoniq.io>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDUxNTIzMTIw", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#pullrequestreview-451523120", "createdAt": "2020-07-20T11:32:03Z", "commit": {"oid": "3697d15e2f6025bbb49a23e02e7c24c79f341d2e"}, "state": "COMMENTED", "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMFQxMTozMjowM1rOG0HXsA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMFQxMjoxNzoyNVrOG0JMKw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzI5OTg4OA==", "bodyText": "Is a new Mono needed here, or can Function.identity() be used instead of Mono::from?", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r457299888", "createdAt": "2020-07-20T11:32:03Z", "author": {"login": "sandjelkovic"}, "path": "messaging/src/main/java/org/axonframework/commandhandling/gateway/DefaultReactorCommandGateway.java", "diffHunk": "@@ -0,0 +1,252 @@\n+/*\n+ * Copyright (c) 2010-2020. Axon Framework\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.axonframework.commandhandling.gateway;\n+\n+import org.axonframework.commandhandling.*;\n+import org.axonframework.commandhandling.callbacks.ReactorCallback;\n+import org.axonframework.common.AxonConfigurationException;\n+import org.axonframework.common.Registration;\n+import org.axonframework.messaging.reactive.ReactorMessageDispatchInterceptor;\n+import org.axonframework.messaging.reactive.ReactorResultHandlerInterceptor;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Mono;\n+import reactor.util.function.Tuple2;\n+\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.concurrent.CopyOnWriteArrayList;\n+\n+import static java.util.Arrays.asList;\n+import static org.axonframework.common.BuilderUtils.assertNonNull;\n+\n+/**\n+ * Implementation of the {@link ReactorCommandGateway} that uses Project Reactor to achieve reactiveness.\n+ *\n+ * @author Milan Savic\n+ * @since 4.4\n+ */\n+public class DefaultReactorCommandGateway implements ReactorCommandGateway {\n+\n+    private final CommandBus commandBus;\n+    private final RetryScheduler retryScheduler;\n+    private final List<ReactorMessageDispatchInterceptor<CommandMessage<?>>> dispatchInterceptors;\n+    private final List<ReactorResultHandlerInterceptor<CommandMessage<?>, CommandResultMessage<?>>> resultInterceptors;\n+\n+    /**\n+     * Creates an instance of {@link DefaultReactorCommandGateway} based on the fields contained in the {@link\n+     * Builder}.\n+     * <p>\n+     * Will assert that the {@link CommandBus} is not {@code null} and throws an {@link AxonConfigurationException} if\n+     * it is.\n+     * </p>\n+     *\n+     * @param builder the {@link Builder} used to instantiate a {@link DefaultReactorCommandGateway} instance\n+     */\n+    protected DefaultReactorCommandGateway(Builder builder) {\n+        builder.validate();\n+        this.commandBus = builder.commandBus;\n+        this.retryScheduler = builder.retryScheduler;\n+        this.dispatchInterceptors = builder.dispatchInterceptors;\n+        this.resultInterceptors = builder.resultInterceptors;\n+    }\n+\n+    /**\n+     * Instantiate a Builder to be able to create a {@link DefaultReactorCommandGateway}.\n+     * <p>\n+     * The {@code dispatchInterceptors} are defaulted to an empty list.\n+     * The {@code resultHandlerInterceptors} are defaulted to an empty list.\n+     * The {@link CommandBus} is a <b>hard requirement</b> and as such should be provided.\n+     * </p>\n+     *\n+     * @return a Builder to be able to create a {@link DefaultReactorCommandGateway}\n+     */\n+    public static Builder builder() {\n+        return new Builder();\n+    }\n+\n+    @Override\n+    public <R> Mono<R> send(Object command) {\n+        //noinspection unchecked\n+        return Mono.<CommandMessage<?>>just(GenericCommandMessage.asCommandMessage(command))\n+                .transform(this::processCommandInterceptors)\n+                .flatMap(this::dispatchCommand)\n+                .flatMap(this::processResultsInterceptors)\n+                .transform(this::getPayload);\n+    }\n+\n+    @Override\n+    public Registration registerDispatchInterceptor(ReactorMessageDispatchInterceptor<CommandMessage<?>> interceptor) {\n+        dispatchInterceptors.add(interceptor);\n+        return () -> dispatchInterceptors.remove(interceptor);\n+    }\n+\n+    @Override\n+    public Registration registerResultHandlerInterceptor(\n+            ReactorResultHandlerInterceptor<CommandMessage<?>, CommandResultMessage<?>> interceptor) {\n+        resultInterceptors.add(interceptor);\n+        return () -> resultInterceptors.remove(interceptor);\n+    }\n+\n+    private Mono<CommandMessage<?>> processCommandInterceptors(Mono<CommandMessage<?>> commandMessage) {\n+        return Flux.fromIterable(dispatchInterceptors)\n+                   .reduce(commandMessage, (command, interceptor) -> interceptor.intercept(command))\n+                   .flatMap(Mono::from);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3697d15e2f6025bbb49a23e02e7c24c79f341d2e"}, "originalPosition": 107}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzMwNDYzOA==", "bodyText": "Can this be a Mono<CommandResultMessage<? extends R>> instead of Flux<CommandResultMessage<? extends R>>.\nFor a full return value signature of Mono<Tuple2<CommandMessage<C>, Mono<CommandResultMessage<? extends R>>>>", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r457304638", "createdAt": "2020-07-20T11:39:51Z", "author": {"login": "sandjelkovic"}, "path": "messaging/src/main/java/org/axonframework/commandhandling/gateway/DefaultReactorCommandGateway.java", "diffHunk": "@@ -0,0 +1,252 @@\n+/*\n+ * Copyright (c) 2010-2020. Axon Framework\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.axonframework.commandhandling.gateway;\n+\n+import org.axonframework.commandhandling.*;\n+import org.axonframework.commandhandling.callbacks.ReactorCallback;\n+import org.axonframework.common.AxonConfigurationException;\n+import org.axonframework.common.Registration;\n+import org.axonframework.messaging.reactive.ReactorMessageDispatchInterceptor;\n+import org.axonframework.messaging.reactive.ReactorResultHandlerInterceptor;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Mono;\n+import reactor.util.function.Tuple2;\n+\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.concurrent.CopyOnWriteArrayList;\n+\n+import static java.util.Arrays.asList;\n+import static org.axonframework.common.BuilderUtils.assertNonNull;\n+\n+/**\n+ * Implementation of the {@link ReactorCommandGateway} that uses Project Reactor to achieve reactiveness.\n+ *\n+ * @author Milan Savic\n+ * @since 4.4\n+ */\n+public class DefaultReactorCommandGateway implements ReactorCommandGateway {\n+\n+    private final CommandBus commandBus;\n+    private final RetryScheduler retryScheduler;\n+    private final List<ReactorMessageDispatchInterceptor<CommandMessage<?>>> dispatchInterceptors;\n+    private final List<ReactorResultHandlerInterceptor<CommandMessage<?>, CommandResultMessage<?>>> resultInterceptors;\n+\n+    /**\n+     * Creates an instance of {@link DefaultReactorCommandGateway} based on the fields contained in the {@link\n+     * Builder}.\n+     * <p>\n+     * Will assert that the {@link CommandBus} is not {@code null} and throws an {@link AxonConfigurationException} if\n+     * it is.\n+     * </p>\n+     *\n+     * @param builder the {@link Builder} used to instantiate a {@link DefaultReactorCommandGateway} instance\n+     */\n+    protected DefaultReactorCommandGateway(Builder builder) {\n+        builder.validate();\n+        this.commandBus = builder.commandBus;\n+        this.retryScheduler = builder.retryScheduler;\n+        this.dispatchInterceptors = builder.dispatchInterceptors;\n+        this.resultInterceptors = builder.resultInterceptors;\n+    }\n+\n+    /**\n+     * Instantiate a Builder to be able to create a {@link DefaultReactorCommandGateway}.\n+     * <p>\n+     * The {@code dispatchInterceptors} are defaulted to an empty list.\n+     * The {@code resultHandlerInterceptors} are defaulted to an empty list.\n+     * The {@link CommandBus} is a <b>hard requirement</b> and as such should be provided.\n+     * </p>\n+     *\n+     * @return a Builder to be able to create a {@link DefaultReactorCommandGateway}\n+     */\n+    public static Builder builder() {\n+        return new Builder();\n+    }\n+\n+    @Override\n+    public <R> Mono<R> send(Object command) {\n+        //noinspection unchecked\n+        return Mono.<CommandMessage<?>>just(GenericCommandMessage.asCommandMessage(command))\n+                .transform(this::processCommandInterceptors)\n+                .flatMap(this::dispatchCommand)\n+                .flatMap(this::processResultsInterceptors)\n+                .transform(this::getPayload);\n+    }\n+\n+    @Override\n+    public Registration registerDispatchInterceptor(ReactorMessageDispatchInterceptor<CommandMessage<?>> interceptor) {\n+        dispatchInterceptors.add(interceptor);\n+        return () -> dispatchInterceptors.remove(interceptor);\n+    }\n+\n+    @Override\n+    public Registration registerResultHandlerInterceptor(\n+            ReactorResultHandlerInterceptor<CommandMessage<?>, CommandResultMessage<?>> interceptor) {\n+        resultInterceptors.add(interceptor);\n+        return () -> resultInterceptors.remove(interceptor);\n+    }\n+\n+    private Mono<CommandMessage<?>> processCommandInterceptors(Mono<CommandMessage<?>> commandMessage) {\n+        return Flux.fromIterable(dispatchInterceptors)\n+                   .reduce(commandMessage, (command, interceptor) -> interceptor.intercept(command))\n+                   .flatMap(Mono::from);\n+    }\n+\n+    private <C, R> Mono<Tuple2<CommandMessage<C>, Flux<CommandResultMessage<? extends R>>>> dispatchCommand(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3697d15e2f6025bbb49a23e02e7c24c79f341d2e"}, "originalPosition": 110}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzMxMDY2NQ==", "bodyText": "Considering that Command handling can provide only one result, shouldn't this also be a Mono<CommandResultMessage<?>> instead of a Flux<CommandResultMessage<?>>?", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r457310665", "createdAt": "2020-07-20T11:48:55Z", "author": {"login": "sandjelkovic"}, "path": "messaging/src/main/java/org/axonframework/commandhandling/gateway/DefaultReactorCommandGateway.java", "diffHunk": "@@ -0,0 +1,252 @@\n+/*\n+ * Copyright (c) 2010-2020. Axon Framework\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.axonframework.commandhandling.gateway;\n+\n+import org.axonframework.commandhandling.*;\n+import org.axonframework.commandhandling.callbacks.ReactorCallback;\n+import org.axonframework.common.AxonConfigurationException;\n+import org.axonframework.common.Registration;\n+import org.axonframework.messaging.reactive.ReactorMessageDispatchInterceptor;\n+import org.axonframework.messaging.reactive.ReactorResultHandlerInterceptor;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Mono;\n+import reactor.util.function.Tuple2;\n+\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.concurrent.CopyOnWriteArrayList;\n+\n+import static java.util.Arrays.asList;\n+import static org.axonframework.common.BuilderUtils.assertNonNull;\n+\n+/**\n+ * Implementation of the {@link ReactorCommandGateway} that uses Project Reactor to achieve reactiveness.\n+ *\n+ * @author Milan Savic\n+ * @since 4.4\n+ */\n+public class DefaultReactorCommandGateway implements ReactorCommandGateway {\n+\n+    private final CommandBus commandBus;\n+    private final RetryScheduler retryScheduler;\n+    private final List<ReactorMessageDispatchInterceptor<CommandMessage<?>>> dispatchInterceptors;\n+    private final List<ReactorResultHandlerInterceptor<CommandMessage<?>, CommandResultMessage<?>>> resultInterceptors;\n+\n+    /**\n+     * Creates an instance of {@link DefaultReactorCommandGateway} based on the fields contained in the {@link\n+     * Builder}.\n+     * <p>\n+     * Will assert that the {@link CommandBus} is not {@code null} and throws an {@link AxonConfigurationException} if\n+     * it is.\n+     * </p>\n+     *\n+     * @param builder the {@link Builder} used to instantiate a {@link DefaultReactorCommandGateway} instance\n+     */\n+    protected DefaultReactorCommandGateway(Builder builder) {\n+        builder.validate();\n+        this.commandBus = builder.commandBus;\n+        this.retryScheduler = builder.retryScheduler;\n+        this.dispatchInterceptors = builder.dispatchInterceptors;\n+        this.resultInterceptors = builder.resultInterceptors;\n+    }\n+\n+    /**\n+     * Instantiate a Builder to be able to create a {@link DefaultReactorCommandGateway}.\n+     * <p>\n+     * The {@code dispatchInterceptors} are defaulted to an empty list.\n+     * The {@code resultHandlerInterceptors} are defaulted to an empty list.\n+     * The {@link CommandBus} is a <b>hard requirement</b> and as such should be provided.\n+     * </p>\n+     *\n+     * @return a Builder to be able to create a {@link DefaultReactorCommandGateway}\n+     */\n+    public static Builder builder() {\n+        return new Builder();\n+    }\n+\n+    @Override\n+    public <R> Mono<R> send(Object command) {\n+        //noinspection unchecked\n+        return Mono.<CommandMessage<?>>just(GenericCommandMessage.asCommandMessage(command))\n+                .transform(this::processCommandInterceptors)\n+                .flatMap(this::dispatchCommand)\n+                .flatMap(this::processResultsInterceptors)\n+                .transform(this::getPayload);\n+    }\n+\n+    @Override\n+    public Registration registerDispatchInterceptor(ReactorMessageDispatchInterceptor<CommandMessage<?>> interceptor) {\n+        dispatchInterceptors.add(interceptor);\n+        return () -> dispatchInterceptors.remove(interceptor);\n+    }\n+\n+    @Override\n+    public Registration registerResultHandlerInterceptor(\n+            ReactorResultHandlerInterceptor<CommandMessage<?>, CommandResultMessage<?>> interceptor) {\n+        resultInterceptors.add(interceptor);\n+        return () -> resultInterceptors.remove(interceptor);\n+    }\n+\n+    private Mono<CommandMessage<?>> processCommandInterceptors(Mono<CommandMessage<?>> commandMessage) {\n+        return Flux.fromIterable(dispatchInterceptors)\n+                   .reduce(commandMessage, (command, interceptor) -> interceptor.intercept(command))\n+                   .flatMap(Mono::from);\n+    }\n+\n+    private <C, R> Mono<Tuple2<CommandMessage<C>, Flux<CommandResultMessage<? extends R>>>> dispatchCommand(\n+            CommandMessage<C> commandMessage) {\n+        ReactorCallback<C, R> reactorCallback = new ReactorCallback<>();\n+        CommandCallback<C, R> callback = reactorCallback;\n+        if (retryScheduler != null) {\n+            callback = new RetryingCallback<>(callback, retryScheduler, commandBus);\n+        }\n+        commandBus.dispatch(commandMessage, callback);\n+        return Mono.just(commandMessage).zipWith(Mono.just(Flux.from(reactorCallback)));\n+    }\n+\n+    private <C> Mono<? extends CommandResultMessage<?>> processResultsInterceptors(\n+            Tuple2<CommandMessage<C>, Flux<CommandResultMessage<?>>> commandWithResults) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3697d15e2f6025bbb49a23e02e7c24c79f341d2e"}, "originalPosition": 122}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzMyMjA2Mw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                               .flatMapMany(it -> it);\n          \n          \n            \n                               .flatMapMany(Function.identity());", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r457322063", "createdAt": "2020-07-20T12:05:57Z", "author": {"login": "sandjelkovic"}, "path": "messaging/src/main/java/org/axonframework/queryhandling/DefaultReactorQueryGateway.java", "diffHunk": "@@ -0,0 +1,318 @@\n+/*\n+ * Copyright (c) 2010-2020. Axon Framework\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.axonframework.queryhandling;\n+\n+import org.axonframework.commandhandling.CommandResultMessage;\n+import org.axonframework.common.AxonConfigurationException;\n+import org.axonframework.common.Registration;\n+import org.axonframework.messaging.ResultMessage;\n+import org.axonframework.messaging.reactive.ReactorMessageDispatchInterceptor;\n+import org.axonframework.messaging.reactive.ReactorResultHandlerInterceptor;\n+import org.axonframework.messaging.responsetypes.ResponseType;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Mono;\n+import reactor.util.function.Tuple2;\n+\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.concurrent.CopyOnWriteArrayList;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Function;\n+\n+import static java.util.Arrays.asList;\n+import static org.axonframework.common.BuilderUtils.assertNonNull;\n+import static org.axonframework.messaging.GenericMessage.asMessage;\n+\n+/**\n+ * Implementation of the {@link ReactorQueryGateway} that uses Project Reactor to achieve reactiveness.\n+ *\n+ * @author Milan Savic\n+ * @since 4.4\n+ */\n+public class DefaultReactorQueryGateway implements ReactorQueryGateway {\n+\n+    private final List<ReactorMessageDispatchInterceptor<QueryMessage<?, ?>>> dispatchInterceptors;\n+    private final List<ReactorResultHandlerInterceptor<QueryMessage<?, ?>, ResultMessage<?>>> resultInterceptors;\n+\n+    private final QueryBus queryBus;\n+\n+    /**\n+     * Creates an instance of {@link DefaultReactorQueryGateway} based on the fields contained in the {@link\n+     * Builder}.\n+     * <p>\n+     * Will assert that the {@link QueryBus} is not {@code null} and throws an {@link AxonConfigurationException} if\n+     * it is.\n+     * </p>\n+     *\n+     * @param builder the {@link Builder} used to instantiated a {@link DefaultReactorQueryGateway} instance\n+     */\n+    protected DefaultReactorQueryGateway(Builder builder) {\n+        builder.validate();\n+        this.queryBus = builder.queryBus;\n+        this.dispatchInterceptors = builder.dispatchInterceptors;\n+        this.resultInterceptors = builder.resultInterceptors;\n+    }\n+\n+    /**\n+     * Instantiate a Builder to be able to create a {@link DefaultReactorQueryGateway}.\n+     * <p>\n+     * The {@code dispatchInterceptors} are defaulted to an empty list.\n+     * The {@code resultHandlerInterceptors} are defaulted to an empty list.\n+     * The {@link QueryBus} is a <b>hard requirement</b> and as such should be provided.\n+     * </p>\n+     *\n+     * @return a Builder to be able to create a {@link DefaultReactorQueryGateway}\n+     */\n+    public static Builder builder() {\n+        return new Builder();\n+    }\n+\n+    @Override\n+    public Registration registerDispatchInterceptor(\n+            ReactorMessageDispatchInterceptor<QueryMessage<?, ?>> interceptor) {\n+        dispatchInterceptors.add(interceptor);\n+        return () -> dispatchInterceptors.remove(interceptor);\n+    }\n+\n+    @Override\n+    public Registration registerResultHandlerInterceptor(\n+            ReactorResultHandlerInterceptor<QueryMessage<?, ?>, ResultMessage<?>> interceptor) {\n+        resultInterceptors.add(interceptor);\n+        return () -> resultInterceptors.remove(interceptor);\n+    }\n+\n+    @Override\n+    public <R, Q> Mono<R> query(String queryName, Q query, ResponseType<R> responseType) {\n+        return Mono.<QueryMessage<?, ?>>fromCallable(() -> new GenericQueryMessage<>(asMessage(query),\n+                                                                                     queryName,\n+                                                                                     responseType))\n+                .transform(this::processDispatchInterceptors)\n+                .flatMap(this::dispatchQuery)\n+                .flatMapMany(this::processResultsInterceptors)\n+                .<R>transform(this::getPayload)\n+                .next();\n+    }\n+\n+    @Override\n+    public <R, Q> Flux<R> scatterGather(String queryName, Q query, ResponseType<R> responseType, long timeout,\n+                                        TimeUnit timeUnit) {\n+        return Mono.<QueryMessage<?, ?>>fromCallable(() -> new GenericQueryMessage<>(asMessage(query),\n+                                                                                     queryName,\n+                                                                                     responseType))\n+                .transform(this::processDispatchInterceptors)\n+                .flatMap(q -> dispatchScatterGatherQuery(q, timeout, timeUnit))\n+                .flatMapMany(this::processResultsInterceptors)\n+                .transform(this::getPayload);\n+    }\n+\n+    @Override\n+    public <Q, I, U> Mono<SubscriptionQueryResult<I, U>> subscriptionQuery(String queryName, Q query,\n+                                                                           ResponseType<I> initialResponseType,\n+                                                                           ResponseType<U> updateResponseType,\n+                                                                           SubscriptionQueryBackpressure backpressure,\n+                                                                           int updateBufferSize) {\n+\n+        //noinspection unchecked\n+        return Mono.<QueryMessage<?, ?>>fromCallable(() -> new GenericSubscriptionQueryMessage<>(query,\n+                                                                                                 initialResponseType,\n+                                                                                                 updateResponseType))\n+                .transform(this::processDispatchInterceptors)\n+                .map(isq -> (SubscriptionQueryMessage<Q, U, I>) isq)\n+                .flatMap(isq -> dispatchSubscriptionQuery(isq, backpressure, updateBufferSize))\n+                .flatMap(processSubscriptionQueryResult());\n+    }\n+\n+\n+    private Mono<Tuple2<QueryMessage<?, ?>, Flux<ResultMessage<?>>>> dispatchQuery(QueryMessage<?, ?> queryMessage) {\n+        Flux<ResultMessage<?>> results = Flux\n+                .defer(() -> Mono.fromFuture(queryBus.query(queryMessage)));\n+\n+        return Mono.<QueryMessage<?, ?>>just(queryMessage)\n+                .zipWith(Mono.just(results));\n+    }\n+\n+    private Mono<Tuple2<QueryMessage<?, ?>, Flux<ResultMessage<?>>>> dispatchScatterGatherQuery(\n+            QueryMessage<?, ?> queryMessage, long timeout, TimeUnit timeUnit) {\n+        Flux<ResultMessage<?>> results = Flux\n+                .defer(() -> Flux.fromStream(queryBus.scatterGather(queryMessage,\n+                                                                    timeout,\n+                                                                    timeUnit)));\n+\n+        return Mono.<QueryMessage<?, ?>>just(queryMessage)\n+                .zipWith(Mono.just(results));\n+    }\n+\n+    private <Q, I, U> Mono<Tuple2<QueryMessage<Q, I>, Mono<SubscriptionQueryResult<QueryResponseMessage<I>, SubscriptionQueryUpdateMessage<U>>>>> dispatchSubscriptionQuery(\n+            SubscriptionQueryMessage<Q, I, U> queryMessage, SubscriptionQueryBackpressure backpressure,\n+            int updateBufferSize) {\n+        Mono<SubscriptionQueryResult<QueryResponseMessage<I>, SubscriptionQueryUpdateMessage<U>>> result = Mono\n+                .fromCallable(() -> queryBus.subscriptionQuery(queryMessage, backpressure, updateBufferSize));\n+        return Mono.<QueryMessage<Q, I>>just(queryMessage)\n+                .zipWith(Mono.just(result));\n+    }\n+\n+    private Mono<QueryMessage<?, ?>> processDispatchInterceptors(Mono<QueryMessage<?, ?>> queryMessageMono) {\n+        return Flux.fromIterable(dispatchInterceptors)\n+                   .reduce(queryMessageMono, (queryMessage, interceptor) -> interceptor.intercept(queryMessage))\n+                   .flatMap(Mono::from);\n+    }\n+\n+    private Flux<ResultMessage<?>> processResultsInterceptors(\n+            Tuple2<QueryMessage<?, ?>, Flux<ResultMessage<?>>> queryWithResponses) {\n+        QueryMessage<?, ?> queryMessage = queryWithResponses.getT1();\n+        Flux<ResultMessage<?>> queryResultMessage = queryWithResponses.getT2();\n+\n+        return Flux.fromIterable(resultInterceptors)\n+                   .reduce(queryResultMessage,\n+                           (result, interceptor) -> interceptor.intercept(queryMessage, result))\n+                   .flatMapMany(it -> it);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3697d15e2f6025bbb49a23e02e7c24c79f341d2e"}, "originalPosition": 182}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzMyNjUzOA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * Should be used when initial result contains multiple instances of response type and needs to be flatten.\n          \n          \n            \n                 * Should be used when initial result contains multiple instances of response type and needs to be flattened.", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r457326538", "createdAt": "2020-07-20T12:12:39Z", "author": {"login": "sandjelkovic"}, "path": "messaging/src/main/java/org/axonframework/queryhandling/ReactorQueryGateway.java", "diffHunk": "@@ -0,0 +1,547 @@\n+/*\n+ * Copyright (c) 2010-2020. Axon Framework\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.axonframework.queryhandling;\n+\n+import org.axonframework.messaging.ResultMessage;\n+import org.axonframework.messaging.reactive.ReactorMessageDispatchInterceptorSupport;\n+import org.axonframework.messaging.reactive.ReactorResultHandlerInterceptorSupport;\n+import org.axonframework.messaging.responsetypes.ResponseType;\n+import org.axonframework.messaging.responsetypes.ResponseTypes;\n+import org.reactivestreams.Publisher;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Mono;\n+import reactor.util.concurrent.Queues;\n+\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Function;\n+\n+/**\n+ * Variation of the {@link QueryGateway}, wrapping a {@link QueryBus} for a friendlier API. Provides support for reactive return types such as {@link Mono} and {@link Flux}\n+ * from Project Reactor.\n+ *\n+ * @author Milan Savic\n+ * @since 4.4\n+ */\n+public interface ReactorQueryGateway extends ReactorMessageDispatchInterceptorSupport<QueryMessage<?, ?>>,\n+        ReactorResultHandlerInterceptorSupport<QueryMessage<?, ?>, ResultMessage<?>> {\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response with the given {@code responseType}\n+     * from a single source. The query name will be derived from the provided {@code query}. Execution may be\n+     * asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param query        The {@code query} to be sent\n+     * @param responseType A {@link Class} describing the desired response type\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(Q query, Class<R> responseType) {\n+        return query(query.getClass().getName(), query, responseType);\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response with the given {@code responseType}\n+     * from a single source. Execution may be asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(String queryName, Q query, Class<R> responseType) {\n+        return query(queryName, query, ResponseTypes.instanceOf(responseType));\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from a single source. The query name will be derived from the provided {@code query}. Execution may be\n+     * asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(Q query, ResponseType<R> responseType) {\n+        return query(query.getClass().getName(), query, responseType);\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from a single source. Execution may be asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    <R, Q> Mono<R> query(String queryName, Q query, ResponseType<R> responseType);\n+\n+    /**\n+     * Uses given Publisher of query messages to send incoming queries away. Queries will be sent sequentially - once a\n+     * result of Nth query arrives, (N + 1)th query is dispatched.\n+     *\n+     * @param queries a Publisher stream of queries to be dispatched\n+     * @return a Flux of query results. An ordering of query results corresponds to an ordering of queries being\n+     * dispatched\n+     *\n+     * @see #query(String, Object, ResponseType)\n+     * @see Flux#concatMap(Function)\n+     */\n+    default Flux<Object> query(Publisher<QueryMessage<?, ?>> queries) {\n+        return Flux.from(queries)\n+                   .concatMap(q -> query(q.getQueryName(), q.getPayload(), q.getResponseType()));\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from several sources. The returned {@link Flux} is completed when a {@code timeout} occurs or when all possible\n+     * results are received. The query name will be derived from the provided {@code query}. Execution may be\n+     * asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     * <b>Note</b>: Any {@code null} results will be filtered out by the {@link ReactorQueryGateway}. If you require\n+     * the {@code null} to be returned, we suggest using {@code QueryBus} instead.\n+     *\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param timeout      A timeout of {@code long} for the query\n+     * @param timeUnit     The selected {@link TimeUnit} for the given {@code timeout}\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Flux} containing the query results as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Flux<R> scatterGather(Q query, ResponseType<R> responseType, long timeout, TimeUnit timeUnit) {\n+        return scatterGather(query.getClass().getName(), query, responseType, timeout, timeUnit);\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from several sources. The returned {@link Flux} is completed when a {@code timeout} occurs or when all results\n+     * are received. Execution may be asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     * <b>Note</b>: Any {@code null} results will be filtered out by the {@link ReactorQueryGateway}. If you require\n+     * the {@code null} to be returned, we suggest using {@code QueryBus} instead.\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param timeout      A timeout of {@code long} for the query\n+     * @param timeUnit     The selected {@link TimeUnit} for the given {@code timeout}\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Flux} containing the query results as dictated by the given {@code responseType}\n+     */\n+    <R, Q> Flux<R> scatterGather(String queryName, Q query, ResponseType<R> responseType, long timeout,\n+                                 TimeUnit timeUnit);\n+\n+    /**\n+     * Uses the given {@link Publisher} of {@link QueryMessage}s to send incoming queries in scatter gather manner. Queries will be sent\n+     * sequentially. Once the result of Nth query arrives, the (N + 1)th query is dispatched. All queries will be dispatched\n+     * using given {@code timeout} and {@code timeUnit}.\n+     *\n+     * @param queries  a {@link Publisher} stream of queries to be dispatched\n+     * @param timeout  A timeout of {@code long} for the query\n+     * @param timeUnit The selected {@link TimeUnit} for the given {@code timeout}\n+     * @return a {@link Flux} of query results. The ordering of query results corresponds to the ordering of queries being\n+     * dispatched\n+     */\n+    default Flux<Object> scatterGather(Publisher<QueryMessage<?, ?>> queries, long timeout, TimeUnit timeUnit) {\n+        return Flux.from(queries)\n+                   .concatMap(q -> scatterGather(q.getQueryName(),\n+                                                 q.getPayload(),\n+                                                 q.getResponseType(),\n+                                                 timeout,\n+                                                 timeUnit));\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, returns initial result and keeps streaming\n+     * incremental updates until subscriber unsubscribes from Flux.\n+     * Should be used when response type of initial result and incremental update match.\n+     * (received at the moment the query is sent, until it is cancelled by the caller or closed by the emitting side).\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Flux}</b></p>\n+     * <p>\n+     * <b>Note</b>: Any {@code null} results, on the initial result or the updates, will be filtered out by the\n+     * {@link ReactorQueryGateway}. If you require the {@code null} to be returned for the initial and update results,\n+     * we suggest using the {@code QueryBus} instead.\n+     *\n+     * @param query      The {@code query} to be sent\n+     * @param resultType The response type used for this query\n+     * @param <Q>        The type of the query\n+     * @param <R>        The type of the result (initial & updates)\n+     * @return Flux which can be used to cancel receiving updates\n+     *\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage)\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage, SubscriptionQueryBackpressure, int)\n+     */\n+    default <Q, R> Flux<R> subscriptionQuery(Q query, ResponseType<R> resultType) {\n+        return subscriptionQuery(query, resultType, resultType)\n+                .flatMapMany(result -> result.initialResult()\n+                                             .concatWith(result.updates())\n+                                             .doFinally(signal -> result.close()));\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, returns initial result and keeps streaming\n+     * incremental updates until subscriber unsubscribes from Flux.\n+     * Should be used when response type of initial result and incremental update match.\n+     * (received at the moment the query is sent, until it is cancelled by the caller or closed by the emitting side).\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Flux}</b></p>\n+     * <p>\n+     * <b>Note</b>: Any {@code null} results, on the initial result or the updates, will be filtered out by the\n+     * {@link ReactorQueryGateway}. If you require the {@code null} to be returned for the initial and update results,\n+     * we suggest using the {@code QueryBus} instead.\n+     *\n+     * @param query      The {@code query} to be sent\n+     * @param resultType The response type used for this query\n+     * @param <Q>        The type of the query\n+     * @param <R>        The type of the result (initial & updates)\n+     * @return Flux which can be used to cancel receiving updates\n+     *\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage)\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage, SubscriptionQueryBackpressure, int)\n+     */\n+    default <Q, R> Flux<R> subscriptionQuery(Q query, Class<R> resultType) {\n+        return subscriptionQuery(query, ResponseTypes.instanceOf(resultType));\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, returns initial result and keeps streaming\n+     * incremental updates until subscriber unsubscribes from Flux.\n+     * Should be used when initial result contains multiple instances of response type and needs to be flatten.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3697d15e2f6025bbb49a23e02e7c24c79f341d2e"}, "originalPosition": 243}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzMyOTcwNw==", "bodyText": "Is it possible to use Duration instead of long timeout, TimeUnit timeUnit for the public interface and convert/split to TimeUnit and long for QueryBus's needs?", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r457329707", "createdAt": "2020-07-20T12:17:25Z", "author": {"login": "sandjelkovic"}, "path": "messaging/src/main/java/org/axonframework/queryhandling/ReactorQueryGateway.java", "diffHunk": "@@ -0,0 +1,547 @@\n+/*\n+ * Copyright (c) 2010-2020. Axon Framework\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.axonframework.queryhandling;\n+\n+import org.axonframework.messaging.ResultMessage;\n+import org.axonframework.messaging.reactive.ReactorMessageDispatchInterceptorSupport;\n+import org.axonframework.messaging.reactive.ReactorResultHandlerInterceptorSupport;\n+import org.axonframework.messaging.responsetypes.ResponseType;\n+import org.axonframework.messaging.responsetypes.ResponseTypes;\n+import org.reactivestreams.Publisher;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Mono;\n+import reactor.util.concurrent.Queues;\n+\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Function;\n+\n+/**\n+ * Variation of the {@link QueryGateway}, wrapping a {@link QueryBus} for a friendlier API. Provides support for reactive return types such as {@link Mono} and {@link Flux}\n+ * from Project Reactor.\n+ *\n+ * @author Milan Savic\n+ * @since 4.4\n+ */\n+public interface ReactorQueryGateway extends ReactorMessageDispatchInterceptorSupport<QueryMessage<?, ?>>,\n+        ReactorResultHandlerInterceptorSupport<QueryMessage<?, ?>, ResultMessage<?>> {\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response with the given {@code responseType}\n+     * from a single source. The query name will be derived from the provided {@code query}. Execution may be\n+     * asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param query        The {@code query} to be sent\n+     * @param responseType A {@link Class} describing the desired response type\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(Q query, Class<R> responseType) {\n+        return query(query.getClass().getName(), query, responseType);\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response with the given {@code responseType}\n+     * from a single source. Execution may be asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(String queryName, Q query, Class<R> responseType) {\n+        return query(queryName, query, ResponseTypes.instanceOf(responseType));\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from a single source. The query name will be derived from the provided {@code query}. Execution may be\n+     * asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(Q query, ResponseType<R> responseType) {\n+        return query(query.getClass().getName(), query, responseType);\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from a single source. Execution may be asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    <R, Q> Mono<R> query(String queryName, Q query, ResponseType<R> responseType);\n+\n+    /**\n+     * Uses given Publisher of query messages to send incoming queries away. Queries will be sent sequentially - once a\n+     * result of Nth query arrives, (N + 1)th query is dispatched.\n+     *\n+     * @param queries a Publisher stream of queries to be dispatched\n+     * @return a Flux of query results. An ordering of query results corresponds to an ordering of queries being\n+     * dispatched\n+     *\n+     * @see #query(String, Object, ResponseType)\n+     * @see Flux#concatMap(Function)\n+     */\n+    default Flux<Object> query(Publisher<QueryMessage<?, ?>> queries) {\n+        return Flux.from(queries)\n+                   .concatMap(q -> query(q.getQueryName(), q.getPayload(), q.getResponseType()));\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from several sources. The returned {@link Flux} is completed when a {@code timeout} occurs or when all possible\n+     * results are received. The query name will be derived from the provided {@code query}. Execution may be\n+     * asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     * <b>Note</b>: Any {@code null} results will be filtered out by the {@link ReactorQueryGateway}. If you require\n+     * the {@code null} to be returned, we suggest using {@code QueryBus} instead.\n+     *\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param timeout      A timeout of {@code long} for the query\n+     * @param timeUnit     The selected {@link TimeUnit} for the given {@code timeout}\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Flux} containing the query results as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Flux<R> scatterGather(Q query, ResponseType<R> responseType, long timeout, TimeUnit timeUnit) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3697d15e2f6025bbb49a23e02e7c24c79f341d2e"}, "originalPosition": 142}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "207abde71f84524f00fc85fe6f0b24616a2f4949", "author": {"user": {"login": "m1l4n54v1c", "name": "Milan Savic"}}, "url": "https://github.com/AxonFramework/AxonFramework/commit/207abde71f84524f00fc85fe6f0b24616a2f4949", "committedDate": "2020-07-20T13:53:28Z", "message": "Update messaging/src/main/java/org/axonframework/messaging/reactive/ReactorMessageDispatchInterceptor.java\n\nCo-authored-by: Steven van Beelen <steven.vanbeelen@axoniq.io>"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1838, "cost": 1, "resetAt": "2021-11-01T11:59:11Z"}}}