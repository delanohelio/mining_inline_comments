{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDk4NTUyMTQx", "number": 1521, "reviewThreads": {"totalCount": 18, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wN1QwNzoxMjoyMVrOErCtLg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wN1QxMzo0NToyNVrOErL9aw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEzNTY4NTU4OnYy", "diffSide": "RIGHT", "path": "eventsourcing/src/main/java/org/axonframework/eventsourcing/AbstractSnapshotTrigger.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wN1QwNzoxMjoyMVrOHdliWQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wN1QwNzoxMjoyMVrOHdliWQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDc4NTc1Mw==", "bodyText": "I'd call this method just reset.", "url": "https://github.com/AxonFramework/AxonFramework/pull/1521#discussion_r500785753", "createdAt": "2020-10-07T07:12:21Z", "author": {"login": "m1l4n54v1c"}, "path": "eventsourcing/src/main/java/org/axonframework/eventsourcing/AbstractSnapshotTrigger.java", "diffHunk": "@@ -0,0 +1,70 @@\n+package org.axonframework.eventsourcing;\n+\n+import java.io.Serializable;\n+\n+import org.axonframework.eventhandling.DomainEventMessage;\n+import org.axonframework.eventhandling.EventMessage;\n+import org.axonframework.messaging.unitofwork.CurrentUnitOfWork;\n+\n+/**\n+ * Abstract implementation of the {@link org.axonframework.eventsourcing.SnapshotTrigger} that schedules snapshots on\n+ * the Unit of Work. Actual logic when to schedule a snapshot should be provided by a subclass.\n+ *\n+ * @author Yvonne Ceelie\n+ * @since 4.4\n+ */\n+public abstract class AbstractSnapshotTrigger implements SnapshotTrigger, Serializable {\n+\n+    static final long serialVersionUID = 4129616856823136473L;\n+    transient Snapshotter snapshotter;\n+    Class<?> aggregateType;\n+    boolean initialized;\n+\n+    @Override\n+    public void eventHandled(EventMessage<?> msg) {\n+        if (msg instanceof DomainEventMessage && exceedsThreshold()) {\n+            prepareSnapshotScheduling((DomainEventMessage<?>) msg);\n+            resetVariables();\n+        }\n+    }\n+\n+    @Override\n+    public void initializationFinished() {\n+        initialized = true;\n+    }\n+\n+    public void prepareSnapshotScheduling(DomainEventMessage<?> eventMessage) {\n+        if (CurrentUnitOfWork.isStarted()) {\n+            if (initialized) {\n+                CurrentUnitOfWork.get().onPrepareCommit(\n+                        u -> scheduleSnapshot(eventMessage));\n+            } else {\n+                CurrentUnitOfWork.get().onCleanup(\n+                        u -> scheduleSnapshot(eventMessage));\n+            }\n+        } else {\n+            scheduleSnapshot(eventMessage);\n+        }\n+    }\n+\n+    void scheduleSnapshot(DomainEventMessage<?> eventMessage) {\n+        snapshotter.scheduleSnapshot(aggregateType, eventMessage.getAggregateIdentifier());\n+    }\n+\n+\n+    public void setSnapshotter(Snapshotter snapshotter) {\n+        this.snapshotter = snapshotter;\n+    }\n+\n+    /**\n+     * This method is used to determine if a new snapshot should be created\n+     */\n+    protected abstract boolean exceedsThreshold();\n+\n+\n+    /**\n+     * This method is used to reset all the variables that are used to check if a threshold has been exceeded\n+     */\n+    protected abstract void resetVariables();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "52b34a9ee3f577d0807951f52e4b0436f1bf4730"}, "originalPosition": 68}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEzNzAyNTQwOnYy", "diffSide": "RIGHT", "path": "eventsourcing/src/main/java/org/axonframework/eventsourcing/AbstractSnapshotTrigger.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wN1QxMzowNzoxNFrOHdyZHg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wN1QxMzowNzoxNFrOHdyZHg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDk5NjM4Mg==", "bodyText": "Missing javadoc on this method, if it will remain public. Could imagine this guy can be private too.", "url": "https://github.com/AxonFramework/AxonFramework/pull/1521#discussion_r500996382", "createdAt": "2020-10-07T13:07:14Z", "author": {"login": "smcvb"}, "path": "eventsourcing/src/main/java/org/axonframework/eventsourcing/AbstractSnapshotTrigger.java", "diffHunk": "@@ -0,0 +1,76 @@\n+package org.axonframework.eventsourcing;\n+\n+import java.io.Serializable;\n+\n+import org.axonframework.eventhandling.DomainEventMessage;\n+import org.axonframework.eventhandling.EventMessage;\n+import org.axonframework.messaging.unitofwork.CurrentUnitOfWork;\n+\n+/**\n+ * Abstract implementation of the {@link org.axonframework.eventsourcing.SnapshotTrigger} that schedules snapshots on\n+ * the Unit of Work. Actual logic when to schedule a snapshot should be provided by a subclass.\n+ *\n+ * @author Yvonne Ceelie\n+ * @since 4.4\n+ */\n+public abstract class AbstractSnapshotTrigger implements SnapshotTrigger, Serializable {\n+\n+    private static final long serialVersionUID = 4129616856823136473L;\n+    private transient Snapshotter snapshotter;\n+    private Class<?> aggregateType;\n+    private boolean initialized;\n+\n+    protected AbstractSnapshotTrigger(Snapshotter snapshotter, Class<?> aggregateType) {\n+        this.snapshotter = snapshotter;\n+        this.aggregateType = aggregateType;\n+        this.initialized = false;\n+    }\n+\n+    @Override\n+    public void eventHandled(EventMessage<?> msg) {\n+        if (msg instanceof DomainEventMessage && exceedsThreshold()) {\n+            prepareSnapshotScheduling((DomainEventMessage<?>) msg);\n+            reset();\n+        }\n+    }\n+\n+    @Override\n+    public void initializationFinished() {\n+        initialized = true;\n+    }\n+\n+    public void prepareSnapshotScheduling(DomainEventMessage<?> eventMessage) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2a4a3fd3401564d9d009e4591d9051136a674215"}, "originalPosition": 42}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEzNzAyNTg0OnYy", "diffSide": "RIGHT", "path": "eventsourcing/src/main/java/org/axonframework/eventsourcing/AbstractSnapshotTrigger.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wN1QxMzowNzoyMFrOHdyZWg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wN1QxMzowNzoyMFrOHdyZWg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDk5NjQ0Mg==", "bodyText": "Missing javadoc on this constructor.", "url": "https://github.com/AxonFramework/AxonFramework/pull/1521#discussion_r500996442", "createdAt": "2020-10-07T13:07:20Z", "author": {"login": "smcvb"}, "path": "eventsourcing/src/main/java/org/axonframework/eventsourcing/AbstractSnapshotTrigger.java", "diffHunk": "@@ -0,0 +1,76 @@\n+package org.axonframework.eventsourcing;\n+\n+import java.io.Serializable;\n+\n+import org.axonframework.eventhandling.DomainEventMessage;\n+import org.axonframework.eventhandling.EventMessage;\n+import org.axonframework.messaging.unitofwork.CurrentUnitOfWork;\n+\n+/**\n+ * Abstract implementation of the {@link org.axonframework.eventsourcing.SnapshotTrigger} that schedules snapshots on\n+ * the Unit of Work. Actual logic when to schedule a snapshot should be provided by a subclass.\n+ *\n+ * @author Yvonne Ceelie\n+ * @since 4.4\n+ */\n+public abstract class AbstractSnapshotTrigger implements SnapshotTrigger, Serializable {\n+\n+    private static final long serialVersionUID = 4129616856823136473L;\n+    private transient Snapshotter snapshotter;\n+    private Class<?> aggregateType;\n+    private boolean initialized;\n+\n+    protected AbstractSnapshotTrigger(Snapshotter snapshotter, Class<?> aggregateType) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2a4a3fd3401564d9d009e4591d9051136a674215"}, "originalPosition": 23}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEzNzAyOTkyOnYy", "diffSide": "RIGHT", "path": "eventsourcing/src/main/java/org/axonframework/eventsourcing/AbstractSnapshotTrigger.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wN1QxMzowODoxOFrOHdyb0w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wN1QxMzowODoxOFrOHdyb0w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDk5NzA3NQ==", "bodyText": "Is this intended to be package-private? Could we make it private perhaps?", "url": "https://github.com/AxonFramework/AxonFramework/pull/1521#discussion_r500997075", "createdAt": "2020-10-07T13:08:18Z", "author": {"login": "smcvb"}, "path": "eventsourcing/src/main/java/org/axonframework/eventsourcing/AbstractSnapshotTrigger.java", "diffHunk": "@@ -0,0 +1,76 @@\n+package org.axonframework.eventsourcing;\n+\n+import java.io.Serializable;\n+\n+import org.axonframework.eventhandling.DomainEventMessage;\n+import org.axonframework.eventhandling.EventMessage;\n+import org.axonframework.messaging.unitofwork.CurrentUnitOfWork;\n+\n+/**\n+ * Abstract implementation of the {@link org.axonframework.eventsourcing.SnapshotTrigger} that schedules snapshots on\n+ * the Unit of Work. Actual logic when to schedule a snapshot should be provided by a subclass.\n+ *\n+ * @author Yvonne Ceelie\n+ * @since 4.4\n+ */\n+public abstract class AbstractSnapshotTrigger implements SnapshotTrigger, Serializable {\n+\n+    private static final long serialVersionUID = 4129616856823136473L;\n+    private transient Snapshotter snapshotter;\n+    private Class<?> aggregateType;\n+    private boolean initialized;\n+\n+    protected AbstractSnapshotTrigger(Snapshotter snapshotter, Class<?> aggregateType) {\n+        this.snapshotter = snapshotter;\n+        this.aggregateType = aggregateType;\n+        this.initialized = false;\n+    }\n+\n+    @Override\n+    public void eventHandled(EventMessage<?> msg) {\n+        if (msg instanceof DomainEventMessage && exceedsThreshold()) {\n+            prepareSnapshotScheduling((DomainEventMessage<?>) msg);\n+            reset();\n+        }\n+    }\n+\n+    @Override\n+    public void initializationFinished() {\n+        initialized = true;\n+    }\n+\n+    public void prepareSnapshotScheduling(DomainEventMessage<?> eventMessage) {\n+        if (CurrentUnitOfWork.isStarted()) {\n+            if (initialized) {\n+                CurrentUnitOfWork.get().onPrepareCommit(\n+                        u -> scheduleSnapshot(eventMessage));\n+            } else {\n+                CurrentUnitOfWork.get().onCleanup(\n+                        u -> scheduleSnapshot(eventMessage));\n+            }\n+        } else {\n+            scheduleSnapshot(eventMessage);\n+        }\n+    }\n+\n+    void scheduleSnapshot(DomainEventMessage<?> eventMessage) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2a4a3fd3401564d9d009e4591d9051136a674215"}, "originalPosition": 56}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEzNzAzNDk5OnYy", "diffSide": "RIGHT", "path": "eventsourcing/src/main/java/org/axonframework/eventsourcing/AbstractSnapshotTrigger.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wN1QxMzowOToyNlrOHdye3g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wN1QxMzowOToyNlrOHdye3g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDk5Nzg1NA==", "bodyText": "I think this method should have some javadoc, however boring setters are :-)", "url": "https://github.com/AxonFramework/AxonFramework/pull/1521#discussion_r500997854", "createdAt": "2020-10-07T13:09:26Z", "author": {"login": "smcvb"}, "path": "eventsourcing/src/main/java/org/axonframework/eventsourcing/AbstractSnapshotTrigger.java", "diffHunk": "@@ -0,0 +1,76 @@\n+package org.axonframework.eventsourcing;\n+\n+import java.io.Serializable;\n+\n+import org.axonframework.eventhandling.DomainEventMessage;\n+import org.axonframework.eventhandling.EventMessage;\n+import org.axonframework.messaging.unitofwork.CurrentUnitOfWork;\n+\n+/**\n+ * Abstract implementation of the {@link org.axonframework.eventsourcing.SnapshotTrigger} that schedules snapshots on\n+ * the Unit of Work. Actual logic when to schedule a snapshot should be provided by a subclass.\n+ *\n+ * @author Yvonne Ceelie\n+ * @since 4.4\n+ */\n+public abstract class AbstractSnapshotTrigger implements SnapshotTrigger, Serializable {\n+\n+    private static final long serialVersionUID = 4129616856823136473L;\n+    private transient Snapshotter snapshotter;\n+    private Class<?> aggregateType;\n+    private boolean initialized;\n+\n+    protected AbstractSnapshotTrigger(Snapshotter snapshotter, Class<?> aggregateType) {\n+        this.snapshotter = snapshotter;\n+        this.aggregateType = aggregateType;\n+        this.initialized = false;\n+    }\n+\n+    @Override\n+    public void eventHandled(EventMessage<?> msg) {\n+        if (msg instanceof DomainEventMessage && exceedsThreshold()) {\n+            prepareSnapshotScheduling((DomainEventMessage<?>) msg);\n+            reset();\n+        }\n+    }\n+\n+    @Override\n+    public void initializationFinished() {\n+        initialized = true;\n+    }\n+\n+    public void prepareSnapshotScheduling(DomainEventMessage<?> eventMessage) {\n+        if (CurrentUnitOfWork.isStarted()) {\n+            if (initialized) {\n+                CurrentUnitOfWork.get().onPrepareCommit(\n+                        u -> scheduleSnapshot(eventMessage));\n+            } else {\n+                CurrentUnitOfWork.get().onCleanup(\n+                        u -> scheduleSnapshot(eventMessage));\n+            }\n+        } else {\n+            scheduleSnapshot(eventMessage);\n+        }\n+    }\n+\n+    void scheduleSnapshot(DomainEventMessage<?> eventMessage) {\n+        snapshotter.scheduleSnapshot(aggregateType, eventMessage.getAggregateIdentifier());\n+    }\n+\n+\n+    public void setSnapshotter(Snapshotter snapshotter) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2a4a3fd3401564d9d009e4591d9051136a674215"}, "originalPosition": 61}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEzNzAzNjQyOnYy", "diffSide": "RIGHT", "path": "eventsourcing/src/main/java/org/axonframework/eventsourcing/AbstractSnapshotTrigger.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wN1QxMzowOTo0NlrOHdyfyg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wN1QxMzowOTo0NlrOHdyfyg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDk5ODA5MA==", "bodyText": "The @return value should be specified for this piece of javadoc.", "url": "https://github.com/AxonFramework/AxonFramework/pull/1521#discussion_r500998090", "createdAt": "2020-10-07T13:09:46Z", "author": {"login": "smcvb"}, "path": "eventsourcing/src/main/java/org/axonframework/eventsourcing/AbstractSnapshotTrigger.java", "diffHunk": "@@ -0,0 +1,76 @@\n+package org.axonframework.eventsourcing;\n+\n+import java.io.Serializable;\n+\n+import org.axonframework.eventhandling.DomainEventMessage;\n+import org.axonframework.eventhandling.EventMessage;\n+import org.axonframework.messaging.unitofwork.CurrentUnitOfWork;\n+\n+/**\n+ * Abstract implementation of the {@link org.axonframework.eventsourcing.SnapshotTrigger} that schedules snapshots on\n+ * the Unit of Work. Actual logic when to schedule a snapshot should be provided by a subclass.\n+ *\n+ * @author Yvonne Ceelie\n+ * @since 4.4\n+ */\n+public abstract class AbstractSnapshotTrigger implements SnapshotTrigger, Serializable {\n+\n+    private static final long serialVersionUID = 4129616856823136473L;\n+    private transient Snapshotter snapshotter;\n+    private Class<?> aggregateType;\n+    private boolean initialized;\n+\n+    protected AbstractSnapshotTrigger(Snapshotter snapshotter, Class<?> aggregateType) {\n+        this.snapshotter = snapshotter;\n+        this.aggregateType = aggregateType;\n+        this.initialized = false;\n+    }\n+\n+    @Override\n+    public void eventHandled(EventMessage<?> msg) {\n+        if (msg instanceof DomainEventMessage && exceedsThreshold()) {\n+            prepareSnapshotScheduling((DomainEventMessage<?>) msg);\n+            reset();\n+        }\n+    }\n+\n+    @Override\n+    public void initializationFinished() {\n+        initialized = true;\n+    }\n+\n+    public void prepareSnapshotScheduling(DomainEventMessage<?> eventMessage) {\n+        if (CurrentUnitOfWork.isStarted()) {\n+            if (initialized) {\n+                CurrentUnitOfWork.get().onPrepareCommit(\n+                        u -> scheduleSnapshot(eventMessage));\n+            } else {\n+                CurrentUnitOfWork.get().onCleanup(\n+                        u -> scheduleSnapshot(eventMessage));\n+            }\n+        } else {\n+            scheduleSnapshot(eventMessage);\n+        }\n+    }\n+\n+    void scheduleSnapshot(DomainEventMessage<?> eventMessage) {\n+        snapshotter.scheduleSnapshot(aggregateType, eventMessage.getAggregateIdentifier());\n+    }\n+\n+\n+    public void setSnapshotter(Snapshotter snapshotter) {\n+        this.snapshotter = snapshotter;\n+    }\n+\n+    /**\n+     * This method is used to determine if a new snapshot should be created", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2a4a3fd3401564d9d009e4591d9051136a674215"}, "originalPosition": 66}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEzNzA2MTM5OnYy", "diffSide": "RIGHT", "path": "eventsourcing/src/main/java/org/axonframework/eventsourcing/EventCountSnapshotTriggerDefinition.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wN1QxMzoxNToxNFrOHdyu6A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wN1QxMzoxNToxNFrOHdyu6A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTAwMTk2MA==", "bodyText": "Nit: Believe adding @Override to this method would make things slightly clearer.", "url": "https://github.com/AxonFramework/AxonFramework/pull/1521#discussion_r501001960", "createdAt": "2020-10-07T13:15:14Z", "author": {"login": "smcvb"}, "path": "eventsourcing/src/main/java/org/axonframework/eventsourcing/EventCountSnapshotTriggerDefinition.java", "diffHunk": "@@ -71,52 +65,23 @@ public SnapshotTrigger reconfigure(Class<?> aggregateType, SnapshotTrigger trigg\n         return new EventCountSnapshotTrigger(snapshotter, aggregateType, threshold);\n     }\n \n-    private static class EventCountSnapshotTrigger implements SnapshotTrigger, Serializable {\n+    private static class EventCountSnapshotTrigger extends AbstractSnapshotTrigger {\n \n-        private static final long serialVersionUID = 4129616856823136473L;\n-        private final Class<?> aggregateType;\n         private final int threshold;\n-\n-        private transient Snapshotter snapshotter;\n         private int counter = 0;\n-        private boolean initialized = false;\n \n         public EventCountSnapshotTrigger(Snapshotter snapshotter, Class<?> aggregateType, int threshold) {\n-            this.snapshotter = snapshotter;\n-            this.aggregateType = aggregateType;\n+            super(snapshotter, aggregateType);\n             this.threshold = threshold;\n         }\n \n-        @Override\n-        public void eventHandled(EventMessage<?> msg) {\n-            if (msg instanceof DomainEventMessage && ++counter >= threshold) {\n-                if (CurrentUnitOfWork.isStarted()) {\n-                    if (initialized) {\n-                        CurrentUnitOfWork.get().onPrepareCommit(\n-                                u -> scheduleSnapshot((DomainEventMessage<?>) msg));\n-                    } else {\n-                        CurrentUnitOfWork.get().onCleanup(\n-                                u -> scheduleSnapshot((DomainEventMessage<?>) msg));\n-                    }\n-                } else {\n-                    scheduleSnapshot((DomainEventMessage<?>) msg);\n-                }\n-                counter = 0;\n-            }\n+        public boolean exceedsThreshold() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2a4a3fd3401564d9d009e4591d9051136a674215"}, "originalPosition": 51}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEzNzA2MTc3OnYy", "diffSide": "RIGHT", "path": "eventsourcing/src/main/java/org/axonframework/eventsourcing/EventCountSnapshotTriggerDefinition.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wN1QxMzoxNToxOFrOHdyvIA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wN1QxMzoxNToxOFrOHdyvIA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTAwMjAxNg==", "bodyText": "Nit: Believe adding @Override to this method would make things slightly clearer.", "url": "https://github.com/AxonFramework/AxonFramework/pull/1521#discussion_r501002016", "createdAt": "2020-10-07T13:15:18Z", "author": {"login": "smcvb"}, "path": "eventsourcing/src/main/java/org/axonframework/eventsourcing/EventCountSnapshotTriggerDefinition.java", "diffHunk": "@@ -71,52 +65,23 @@ public SnapshotTrigger reconfigure(Class<?> aggregateType, SnapshotTrigger trigg\n         return new EventCountSnapshotTrigger(snapshotter, aggregateType, threshold);\n     }\n \n-    private static class EventCountSnapshotTrigger implements SnapshotTrigger, Serializable {\n+    private static class EventCountSnapshotTrigger extends AbstractSnapshotTrigger {\n \n-        private static final long serialVersionUID = 4129616856823136473L;\n-        private final Class<?> aggregateType;\n         private final int threshold;\n-\n-        private transient Snapshotter snapshotter;\n         private int counter = 0;\n-        private boolean initialized = false;\n \n         public EventCountSnapshotTrigger(Snapshotter snapshotter, Class<?> aggregateType, int threshold) {\n-            this.snapshotter = snapshotter;\n-            this.aggregateType = aggregateType;\n+            super(snapshotter, aggregateType);\n             this.threshold = threshold;\n         }\n \n-        @Override\n-        public void eventHandled(EventMessage<?> msg) {\n-            if (msg instanceof DomainEventMessage && ++counter >= threshold) {\n-                if (CurrentUnitOfWork.isStarted()) {\n-                    if (initialized) {\n-                        CurrentUnitOfWork.get().onPrepareCommit(\n-                                u -> scheduleSnapshot((DomainEventMessage<?>) msg));\n-                    } else {\n-                        CurrentUnitOfWork.get().onCleanup(\n-                                u -> scheduleSnapshot((DomainEventMessage<?>) msg));\n-                    }\n-                } else {\n-                    scheduleSnapshot((DomainEventMessage<?>) msg);\n-                }\n-                counter = 0;\n-            }\n+        public boolean exceedsThreshold() {\n+            return ++counter >= threshold;\n         }\n \n-        protected void scheduleSnapshot(DomainEventMessage<?> msg) {\n-            snapshotter.scheduleSnapshot(aggregateType, msg.getAggregateIdentifier());\n+        public void reset() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2a4a3fd3401564d9d009e4591d9051136a674215"}, "originalPosition": 57}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEzNzA2ODQ0OnYy", "diffSide": "RIGHT", "path": "eventsourcing/src/main/java/org/axonframework/eventsourcing/AbstractSnapshotTrigger.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wN1QxMzoxNjo1MVrOHdyzVA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wN1QxMzoxNjo1MVrOHdyzVA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTAwMzA5Mg==", "bodyText": "To be exact, this is being introduced in 4.4.4, as the branch points to axon-4.4.x :-)", "url": "https://github.com/AxonFramework/AxonFramework/pull/1521#discussion_r501003092", "createdAt": "2020-10-07T13:16:51Z", "author": {"login": "smcvb"}, "path": "eventsourcing/src/main/java/org/axonframework/eventsourcing/AbstractSnapshotTrigger.java", "diffHunk": "@@ -0,0 +1,76 @@\n+package org.axonframework.eventsourcing;\n+\n+import java.io.Serializable;\n+\n+import org.axonframework.eventhandling.DomainEventMessage;\n+import org.axonframework.eventhandling.EventMessage;\n+import org.axonframework.messaging.unitofwork.CurrentUnitOfWork;\n+\n+/**\n+ * Abstract implementation of the {@link org.axonframework.eventsourcing.SnapshotTrigger} that schedules snapshots on\n+ * the Unit of Work. Actual logic when to schedule a snapshot should be provided by a subclass.\n+ *\n+ * @author Yvonne Ceelie\n+ * @since 4.4", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2a4a3fd3401564d9d009e4591d9051136a674215"}, "originalPosition": 14}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEzNzA3MDE1OnYy", "diffSide": "RIGHT", "path": "eventsourcing/src/main/java/org/axonframework/eventsourcing/AggregateLoadTimeSnapshotTriggerDefinition.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wN1QxMzoxNzoxMVrOHdy0Wg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wN1QxMzoxNzoxMVrOHdy0Wg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTAwMzM1NA==", "bodyText": "To be exact, this is being introduced in 4.4.4, as the branch points to axon-4.4.x :-)", "url": "https://github.com/AxonFramework/AxonFramework/pull/1521#discussion_r501003354", "createdAt": "2020-10-07T13:17:11Z", "author": {"login": "smcvb"}, "path": "eventsourcing/src/main/java/org/axonframework/eventsourcing/AggregateLoadTimeSnapshotTriggerDefinition.java", "diffHunk": "@@ -0,0 +1,90 @@\n+/*\n+ * Copyright (c) 2010-2020. Axon Framework\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.axonframework.eventsourcing;\n+\n+import java.time.Clock;\n+\n+/**\n+ * Snapshotter trigger mechanism that decides on the loading time of the Aggregate when to create a snapshot. A snapshot\n+ * is triggered when loading the aggregate exceeds the given {@code loadTimeMillisThreshold} in milliseconds.\n+ * <p>\n+ * This number can exceed in two distinct scenarios:\n+ * <ol>\n+ *     <li> When initializing / event sourcing the aggregate in question.</li>\n+ *     <li> When new events are being applied by the aggregate.</li>\n+ * </ol>\n+ * <p>\n+ * If the definable {@code threshold} is met in situation one, the snapshot will be triggered regardless of the outcome\n+ * of command handling. Thus also if command handling returns exceptionally. If the {@code threshold} is only reached\n+ * once the aggregate has been fully initialized, than the snapshot will only be triggered if handling resolves\n+ * successfully.\n+ *\n+ * @author Yvonne Ceelie\n+ * @since 4.4", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2a4a3fd3401564d9d009e4591d9051136a674215"}, "originalPosition": 37}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEzNzEzNTcyOnYy", "diffSide": "RIGHT", "path": "eventsourcing/src/main/java/org/axonframework/eventsourcing/AggregateLoadTimeSnapshotTriggerDefinition.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wN1QxMzozMTowN1rOHdzdfA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wN1QxMzozMTowN1rOHdzdfA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTAxMzg4NA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             * Snapshotter trigger mechanism that decides on the loading time of the Aggregate when to create a snapshot. A snapshot\n          \n          \n            \n             * A {@link SnapshotterTriggerDefinition} implementation which based on the loading time of an Aggregate decides when to trigger the creation of a snapshot. A snapshot", "url": "https://github.com/AxonFramework/AxonFramework/pull/1521#discussion_r501013884", "createdAt": "2020-10-07T13:31:07Z", "author": {"login": "smcvb"}, "path": "eventsourcing/src/main/java/org/axonframework/eventsourcing/AggregateLoadTimeSnapshotTriggerDefinition.java", "diffHunk": "@@ -0,0 +1,90 @@\n+/*\n+ * Copyright (c) 2010-2020. Axon Framework\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.axonframework.eventsourcing;\n+\n+import java.time.Clock;\n+\n+/**\n+ * Snapshotter trigger mechanism that decides on the loading time of the Aggregate when to create a snapshot. A snapshot", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2a4a3fd3401564d9d009e4591d9051136a674215"}, "originalPosition": 22}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEzNzE0MDU1OnYy", "diffSide": "RIGHT", "path": "eventsourcing/src/main/java/org/axonframework/eventsourcing/AggregateLoadTimeSnapshotTriggerDefinition.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wN1QxMzozMjoxOVrOHdzgqA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wN1QxMzozMjoxOVrOHdzgqA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTAxNDY5Ng==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             * If the definable {@code threshold} is met in situation one, the snapshot will be triggered regardless of the outcome\n          \n          \n            \n             * If the definable {@code loadTimeMillisThreshold} is met in situation one, the snapshot will be triggered regardless of the outcome", "url": "https://github.com/AxonFramework/AxonFramework/pull/1521#discussion_r501014696", "createdAt": "2020-10-07T13:32:19Z", "author": {"login": "smcvb"}, "path": "eventsourcing/src/main/java/org/axonframework/eventsourcing/AggregateLoadTimeSnapshotTriggerDefinition.java", "diffHunk": "@@ -0,0 +1,90 @@\n+/*\n+ * Copyright (c) 2010-2020. Axon Framework\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.axonframework.eventsourcing;\n+\n+import java.time.Clock;\n+\n+/**\n+ * Snapshotter trigger mechanism that decides on the loading time of the Aggregate when to create a snapshot. A snapshot\n+ * is triggered when loading the aggregate exceeds the given {@code loadTimeMillisThreshold} in milliseconds.\n+ * <p>\n+ * This number can exceed in two distinct scenarios:\n+ * <ol>\n+ *     <li> When initializing / event sourcing the aggregate in question.</li>\n+ *     <li> When new events are being applied by the aggregate.</li>\n+ * </ol>\n+ * <p>\n+ * If the definable {@code threshold} is met in situation one, the snapshot will be triggered regardless of the outcome", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2a4a3fd3401564d9d009e4591d9051136a674215"}, "originalPosition": 31}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEzNzE0MTQ4OnYy", "diffSide": "RIGHT", "path": "eventsourcing/src/main/java/org/axonframework/eventsourcing/AggregateLoadTimeSnapshotTriggerDefinition.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wN1QxMzozMjozM1rOHdzhRw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wN1QxMzozMjozM1rOHdzhRw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTAxNDg1NQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             * of command handling. Thus also if command handling returns exceptionally. If the {@code threshold} is only reached\n          \n          \n            \n             * of command handling. Thus also if command handling returns exceptionally. If the {@code loadTimeMillisThreshold} is only reached", "url": "https://github.com/AxonFramework/AxonFramework/pull/1521#discussion_r501014855", "createdAt": "2020-10-07T13:32:33Z", "author": {"login": "smcvb"}, "path": "eventsourcing/src/main/java/org/axonframework/eventsourcing/AggregateLoadTimeSnapshotTriggerDefinition.java", "diffHunk": "@@ -0,0 +1,90 @@\n+/*\n+ * Copyright (c) 2010-2020. Axon Framework\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.axonframework.eventsourcing;\n+\n+import java.time.Clock;\n+\n+/**\n+ * Snapshotter trigger mechanism that decides on the loading time of the Aggregate when to create a snapshot. A snapshot\n+ * is triggered when loading the aggregate exceeds the given {@code loadTimeMillisThreshold} in milliseconds.\n+ * <p>\n+ * This number can exceed in two distinct scenarios:\n+ * <ol>\n+ *     <li> When initializing / event sourcing the aggregate in question.</li>\n+ *     <li> When new events are being applied by the aggregate.</li>\n+ * </ol>\n+ * <p>\n+ * If the definable {@code threshold} is met in situation one, the snapshot will be triggered regardless of the outcome\n+ * of command handling. Thus also if command handling returns exceptionally. If the {@code threshold} is only reached", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2a4a3fd3401564d9d009e4591d9051136a674215"}, "originalPosition": 32}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEzNzE0NDI4OnYy", "diffSide": "RIGHT", "path": "eventsourcing/src/main/java/org/axonframework/eventsourcing/AggregateLoadTimeSnapshotTriggerDefinition.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wN1QxMzozMzoxMVrOHdzjAw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wN1QxMzozMzoxMVrOHdzjAw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTAxNTI5OQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             * This number can exceed in two distinct scenarios:\n          \n          \n            \n             * This threshold can be exceeded in two distinct scenarios:", "url": "https://github.com/AxonFramework/AxonFramework/pull/1521#discussion_r501015299", "createdAt": "2020-10-07T13:33:11Z", "author": {"login": "smcvb"}, "path": "eventsourcing/src/main/java/org/axonframework/eventsourcing/AggregateLoadTimeSnapshotTriggerDefinition.java", "diffHunk": "@@ -0,0 +1,90 @@\n+/*\n+ * Copyright (c) 2010-2020. Axon Framework\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.axonframework.eventsourcing;\n+\n+import java.time.Clock;\n+\n+/**\n+ * Snapshotter trigger mechanism that decides on the loading time of the Aggregate when to create a snapshot. A snapshot\n+ * is triggered when loading the aggregate exceeds the given {@code loadTimeMillisThreshold} in milliseconds.\n+ * <p>\n+ * This number can exceed in two distinct scenarios:", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2a4a3fd3401564d9d009e4591d9051136a674215"}, "originalPosition": 25}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEzNzE1MTM5OnYy", "diffSide": "RIGHT", "path": "eventsourcing/src/main/java/org/axonframework/eventsourcing/AggregateLoadTimeSnapshotTriggerDefinition.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wN1QxMzozNDo0MFrOHdzniA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wN1QxMzozNDo0MFrOHdzniA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTAxNjQ1Ng==", "bodyText": "I think this guy should be made public, so that users can, if they need to, change the Clock (quite similar as currently is possible on the GenericEventMessage.", "url": "https://github.com/AxonFramework/AxonFramework/pull/1521#discussion_r501016456", "createdAt": "2020-10-07T13:34:40Z", "author": {"login": "smcvb"}, "path": "eventsourcing/src/main/java/org/axonframework/eventsourcing/AggregateLoadTimeSnapshotTriggerDefinition.java", "diffHunk": "@@ -0,0 +1,90 @@\n+/*\n+ * Copyright (c) 2010-2020. Axon Framework\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.axonframework.eventsourcing;\n+\n+import java.time.Clock;\n+\n+/**\n+ * Snapshotter trigger mechanism that decides on the loading time of the Aggregate when to create a snapshot. A snapshot\n+ * is triggered when loading the aggregate exceeds the given {@code loadTimeMillisThreshold} in milliseconds.\n+ * <p>\n+ * This number can exceed in two distinct scenarios:\n+ * <ol>\n+ *     <li> When initializing / event sourcing the aggregate in question.</li>\n+ *     <li> When new events are being applied by the aggregate.</li>\n+ * </ol>\n+ * <p>\n+ * If the definable {@code threshold} is met in situation one, the snapshot will be triggered regardless of the outcome\n+ * of command handling. Thus also if command handling returns exceptionally. If the {@code threshold} is only reached\n+ * once the aggregate has been fully initialized, than the snapshot will only be triggered if handling resolves\n+ * successfully.\n+ *\n+ * @author Yvonne Ceelie\n+ * @since 4.4\n+ */\n+public class AggregateLoadTimeSnapshotTriggerDefinition implements SnapshotTriggerDefinition {\n+\n+    private final Snapshotter snapshotter;\n+    private final long loadTimeMillisThreshold;\n+    static Clock clock = Clock.systemUTC();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2a4a3fd3401564d9d009e4591d9051136a674215"}, "originalPosition": 43}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEzNzE3MjQxOnYy", "diffSide": "RIGHT", "path": "eventsourcing/src/main/java/org/axonframework/eventsourcing/AggregateLoadTimeSnapshotTriggerDefinition.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wN1QxMzozOToxN1rOHdz0xg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wN1QxMzozOToxN1rOHdz0xg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTAxOTg0Ng==", "bodyText": "Nit: Believe adding @Override to this method would make things slightly clearer.", "url": "https://github.com/AxonFramework/AxonFramework/pull/1521#discussion_r501019846", "createdAt": "2020-10-07T13:39:17Z", "author": {"login": "smcvb"}, "path": "eventsourcing/src/main/java/org/axonframework/eventsourcing/AggregateLoadTimeSnapshotTriggerDefinition.java", "diffHunk": "@@ -0,0 +1,90 @@\n+/*\n+ * Copyright (c) 2010-2020. Axon Framework\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.axonframework.eventsourcing;\n+\n+import java.time.Clock;\n+\n+/**\n+ * Snapshotter trigger mechanism that decides on the loading time of the Aggregate when to create a snapshot. A snapshot\n+ * is triggered when loading the aggregate exceeds the given {@code loadTimeMillisThreshold} in milliseconds.\n+ * <p>\n+ * This number can exceed in two distinct scenarios:\n+ * <ol>\n+ *     <li> When initializing / event sourcing the aggregate in question.</li>\n+ *     <li> When new events are being applied by the aggregate.</li>\n+ * </ol>\n+ * <p>\n+ * If the definable {@code threshold} is met in situation one, the snapshot will be triggered regardless of the outcome\n+ * of command handling. Thus also if command handling returns exceptionally. If the {@code threshold} is only reached\n+ * once the aggregate has been fully initialized, than the snapshot will only be triggered if handling resolves\n+ * successfully.\n+ *\n+ * @author Yvonne Ceelie\n+ * @since 4.4\n+ */\n+public class AggregateLoadTimeSnapshotTriggerDefinition implements SnapshotTriggerDefinition {\n+\n+    private final Snapshotter snapshotter;\n+    private final long loadTimeMillisThreshold;\n+    static Clock clock = Clock.systemUTC();\n+\n+\n+    /**\n+     * Initialized the SnapshotTriggerDefinition to threshold snapshots using the given {@code snapshotter} when loading\n+     * the aggregate instance takes longer than {@code loadTimeMillisThreshold}\n+     *\n+     * @param snapshotter the snapshotter to notify when a snapshot needs to be taken\n+     * @param loadTimeMillisThreshold  the maximum time that loading an aggregate may take\n+     */\n+    public AggregateLoadTimeSnapshotTriggerDefinition(Snapshotter snapshotter, long loadTimeMillisThreshold) {\n+        this.snapshotter = snapshotter;\n+        this.loadTimeMillisThreshold = loadTimeMillisThreshold;\n+    }\n+\n+    @Override\n+    public SnapshotTrigger prepareTrigger(Class<?> aggregateType) {\n+        return new AggregateLoadTimeSnapshotTrigger(snapshotter, aggregateType, loadTimeMillisThreshold);\n+    }\n+\n+    @Override\n+    public SnapshotTrigger reconfigure(Class<?> aggregateType, SnapshotTrigger trigger) {\n+        if (trigger instanceof AggregateLoadTimeSnapshotTrigger) {\n+            ((AggregateLoadTimeSnapshotTrigger) trigger).setSnapshotter(snapshotter);\n+            return trigger;\n+        }\n+        return new AggregateLoadTimeSnapshotTrigger(snapshotter, aggregateType, loadTimeMillisThreshold);\n+    }\n+\n+    private static class AggregateLoadTimeSnapshotTrigger extends AbstractSnapshotTrigger {\n+\n+        private final long loadTimeMillisThreshold;\n+        private long startTime = clock.instant().toEpochMilli();\n+\n+        public AggregateLoadTimeSnapshotTrigger(Snapshotter snapshotter, Class<?> aggregateType, long loadTimeMillisThreshold) {\n+            super(snapshotter, aggregateType);\n+            this.loadTimeMillisThreshold = loadTimeMillisThreshold;\n+        }\n+\n+        public boolean exceedsThreshold(){", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2a4a3fd3401564d9d009e4591d9051136a674215"}, "originalPosition": 82}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEzNzE3MjU4OnYy", "diffSide": "RIGHT", "path": "eventsourcing/src/main/java/org/axonframework/eventsourcing/AggregateLoadTimeSnapshotTriggerDefinition.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wN1QxMzozOToyMVrOHdz06A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wN1QxMzozOToyMVrOHdz06A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTAxOTg4MA==", "bodyText": "Nit: Believe adding @Override to this method would make things slightly clearer.", "url": "https://github.com/AxonFramework/AxonFramework/pull/1521#discussion_r501019880", "createdAt": "2020-10-07T13:39:21Z", "author": {"login": "smcvb"}, "path": "eventsourcing/src/main/java/org/axonframework/eventsourcing/AggregateLoadTimeSnapshotTriggerDefinition.java", "diffHunk": "@@ -0,0 +1,90 @@\n+/*\n+ * Copyright (c) 2010-2020. Axon Framework\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.axonframework.eventsourcing;\n+\n+import java.time.Clock;\n+\n+/**\n+ * Snapshotter trigger mechanism that decides on the loading time of the Aggregate when to create a snapshot. A snapshot\n+ * is triggered when loading the aggregate exceeds the given {@code loadTimeMillisThreshold} in milliseconds.\n+ * <p>\n+ * This number can exceed in two distinct scenarios:\n+ * <ol>\n+ *     <li> When initializing / event sourcing the aggregate in question.</li>\n+ *     <li> When new events are being applied by the aggregate.</li>\n+ * </ol>\n+ * <p>\n+ * If the definable {@code threshold} is met in situation one, the snapshot will be triggered regardless of the outcome\n+ * of command handling. Thus also if command handling returns exceptionally. If the {@code threshold} is only reached\n+ * once the aggregate has been fully initialized, than the snapshot will only be triggered if handling resolves\n+ * successfully.\n+ *\n+ * @author Yvonne Ceelie\n+ * @since 4.4\n+ */\n+public class AggregateLoadTimeSnapshotTriggerDefinition implements SnapshotTriggerDefinition {\n+\n+    private final Snapshotter snapshotter;\n+    private final long loadTimeMillisThreshold;\n+    static Clock clock = Clock.systemUTC();\n+\n+\n+    /**\n+     * Initialized the SnapshotTriggerDefinition to threshold snapshots using the given {@code snapshotter} when loading\n+     * the aggregate instance takes longer than {@code loadTimeMillisThreshold}\n+     *\n+     * @param snapshotter the snapshotter to notify when a snapshot needs to be taken\n+     * @param loadTimeMillisThreshold  the maximum time that loading an aggregate may take\n+     */\n+    public AggregateLoadTimeSnapshotTriggerDefinition(Snapshotter snapshotter, long loadTimeMillisThreshold) {\n+        this.snapshotter = snapshotter;\n+        this.loadTimeMillisThreshold = loadTimeMillisThreshold;\n+    }\n+\n+    @Override\n+    public SnapshotTrigger prepareTrigger(Class<?> aggregateType) {\n+        return new AggregateLoadTimeSnapshotTrigger(snapshotter, aggregateType, loadTimeMillisThreshold);\n+    }\n+\n+    @Override\n+    public SnapshotTrigger reconfigure(Class<?> aggregateType, SnapshotTrigger trigger) {\n+        if (trigger instanceof AggregateLoadTimeSnapshotTrigger) {\n+            ((AggregateLoadTimeSnapshotTrigger) trigger).setSnapshotter(snapshotter);\n+            return trigger;\n+        }\n+        return new AggregateLoadTimeSnapshotTrigger(snapshotter, aggregateType, loadTimeMillisThreshold);\n+    }\n+\n+    private static class AggregateLoadTimeSnapshotTrigger extends AbstractSnapshotTrigger {\n+\n+        private final long loadTimeMillisThreshold;\n+        private long startTime = clock.instant().toEpochMilli();\n+\n+        public AggregateLoadTimeSnapshotTrigger(Snapshotter snapshotter, Class<?> aggregateType, long loadTimeMillisThreshold) {\n+            super(snapshotter, aggregateType);\n+            this.loadTimeMillisThreshold = loadTimeMillisThreshold;\n+        }\n+\n+        public boolean exceedsThreshold(){\n+            return (clock.instant().toEpochMilli() - startTime) > loadTimeMillisThreshold;\n+        }\n+\n+        public void reset() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2a4a3fd3401564d9d009e4591d9051136a674215"}, "originalPosition": 86}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEzNzIwMTcxOnYy", "diffSide": "RIGHT", "path": "eventsourcing/src/main/java/org/axonframework/eventsourcing/AggregateLoadTimeSnapshotTriggerDefinition.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wN1QxMzo0NToyNVrOHd0HFw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wN1QxMzo0NToyNVrOHd0HFw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTAyNDUzNQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * Initialized the SnapshotTriggerDefinition to threshold snapshots using the given {@code snapshotter} when loading\n          \n          \n            \n                 * the aggregate instance takes longer than {@code loadTimeMillisThreshold}\n          \n          \n            \n                 * Initialize a {@link SnapshotTriggerDefinition} to trigger snapshot creation using the given {@code snapshotter} when loading\n          \n          \n            \n                 * the aggregate instance takes longer than the given {@code loadTimeMillisThreshold}.", "url": "https://github.com/AxonFramework/AxonFramework/pull/1521#discussion_r501024535", "createdAt": "2020-10-07T13:45:25Z", "author": {"login": "smcvb"}, "path": "eventsourcing/src/main/java/org/axonframework/eventsourcing/AggregateLoadTimeSnapshotTriggerDefinition.java", "diffHunk": "@@ -0,0 +1,90 @@\n+/*\n+ * Copyright (c) 2010-2020. Axon Framework\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.axonframework.eventsourcing;\n+\n+import java.time.Clock;\n+\n+/**\n+ * Snapshotter trigger mechanism that decides on the loading time of the Aggregate when to create a snapshot. A snapshot\n+ * is triggered when loading the aggregate exceeds the given {@code loadTimeMillisThreshold} in milliseconds.\n+ * <p>\n+ * This number can exceed in two distinct scenarios:\n+ * <ol>\n+ *     <li> When initializing / event sourcing the aggregate in question.</li>\n+ *     <li> When new events are being applied by the aggregate.</li>\n+ * </ol>\n+ * <p>\n+ * If the definable {@code threshold} is met in situation one, the snapshot will be triggered regardless of the outcome\n+ * of command handling. Thus also if command handling returns exceptionally. If the {@code threshold} is only reached\n+ * once the aggregate has been fully initialized, than the snapshot will only be triggered if handling resolves\n+ * successfully.\n+ *\n+ * @author Yvonne Ceelie\n+ * @since 4.4\n+ */\n+public class AggregateLoadTimeSnapshotTriggerDefinition implements SnapshotTriggerDefinition {\n+\n+    private final Snapshotter snapshotter;\n+    private final long loadTimeMillisThreshold;\n+    static Clock clock = Clock.systemUTC();\n+\n+\n+    /**\n+     * Initialized the SnapshotTriggerDefinition to threshold snapshots using the given {@code snapshotter} when loading\n+     * the aggregate instance takes longer than {@code loadTimeMillisThreshold}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2a4a3fd3401564d9d009e4591d9051136a674215"}, "originalPosition": 48}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3244, "cost": 1, "resetAt": "2021-11-12T11:18:39Z"}}}