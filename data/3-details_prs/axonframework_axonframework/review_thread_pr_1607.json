{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTIxNzM3MzM1", "number": 1607, "reviewThreads": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xN1QxMDowMDozNlrOE58I7w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yMFQxMDowMzowNlrOE7eS3Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI5MTg5NjE1OnYy", "diffSide": "RIGHT", "path": "eventsourcing/src/main/java/org/axonframework/eventsourcing/eventstore/jdbc/JdbcEventStorageEngine.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xN1QxMDowMDozNlrOH0tLDA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xN1QxMTo1MjowMlrOH0xUyQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTAyODEwOA==", "bodyText": "I feel like the method should include the word index somewhere. And since you created this for head, we can have something similar for tail as we are doing almost the same thing at createTailToken - to have it consistent.", "url": "https://github.com/AxonFramework/AxonFramework/pull/1607#discussion_r525028108", "createdAt": "2020-11-17T10:00:36Z", "author": {"login": "lfgcampos"}, "path": "eventsourcing/src/main/java/org/axonframework/eventsourcing/eventstore/jdbc/JdbcEventStorageEngine.java", "diffHunk": "@@ -418,37 +431,40 @@ public TrackingToken createTailToken() {\n                 resultSet -> nextAndExtract(resultSet, 1, Long.class),\n                 e -> new EventStoreException(\"Failed to get tail token\", e)\n         ));\n-        return Optional.ofNullable(index)\n-                       .map(seq -> GapAwareTrackingToken.newInstance(seq, Collections.emptySet()))\n-                       .orElse(null);\n+        return createToken(index);\n     }\n \n     @Override\n     public TrackingToken createHeadToken() {\n+        return createToken(mostRecentToken());\n+    }\n+\n+    @Override\n+    public TrackingToken createTokenAt(Instant dateTime) {\n         Long index = transactionManager.fetchInTransaction(() -> executeQuery(\n+                getConnection(),\n+                connection -> createTokenAt(connection, dateTime),\n+                resultSet -> nextAndExtract(resultSet, 1, Long.class),\n+                e -> new EventStoreException(format(\"Failed to get token at [%s]\", dateTime), e)\n+        ));\n+        return index != null ? createToken(index) : createToken(mostRecentToken());\n+    }\n+\n+    private Long mostRecentToken() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "343d2e8e30493421d8c2f0b5d2574d9f63ee85d5"}, "originalPosition": 53}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTA2NjMyMA==", "bodyText": "Renaming to mostRecentIndex actually is reasonable, as we're dealing with indices. They might refer to tokens, but it's good to keep that apart at this stage.\nUncertain about a similar private method for the createTailToken though. The only reason I introduce the mostRecentToken/mostRecentIndex method is because I need it to be reused between the createHeadToken and createTokenAt methods. As we don't have to do a similar thing for tail tokens, I figure this should be fine to be honest.\nLet me know what you think!", "url": "https://github.com/AxonFramework/AxonFramework/pull/1607#discussion_r525066320", "createdAt": "2020-11-17T11:00:01Z", "author": {"login": "smcvb"}, "path": "eventsourcing/src/main/java/org/axonframework/eventsourcing/eventstore/jdbc/JdbcEventStorageEngine.java", "diffHunk": "@@ -418,37 +431,40 @@ public TrackingToken createTailToken() {\n                 resultSet -> nextAndExtract(resultSet, 1, Long.class),\n                 e -> new EventStoreException(\"Failed to get tail token\", e)\n         ));\n-        return Optional.ofNullable(index)\n-                       .map(seq -> GapAwareTrackingToken.newInstance(seq, Collections.emptySet()))\n-                       .orElse(null);\n+        return createToken(index);\n     }\n \n     @Override\n     public TrackingToken createHeadToken() {\n+        return createToken(mostRecentToken());\n+    }\n+\n+    @Override\n+    public TrackingToken createTokenAt(Instant dateTime) {\n         Long index = transactionManager.fetchInTransaction(() -> executeQuery(\n+                getConnection(),\n+                connection -> createTokenAt(connection, dateTime),\n+                resultSet -> nextAndExtract(resultSet, 1, Long.class),\n+                e -> new EventStoreException(format(\"Failed to get token at [%s]\", dateTime), e)\n+        ));\n+        return index != null ? createToken(index) : createToken(mostRecentToken());\n+    }\n+\n+    private Long mostRecentToken() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTAyODEwOA=="}, "originalCommit": {"oid": "343d2e8e30493421d8c2f0b5d2574d9f63ee85d5"}, "originalPosition": 53}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTA5NjEzNw==", "bodyText": "That is completely fine!", "url": "https://github.com/AxonFramework/AxonFramework/pull/1607#discussion_r525096137", "createdAt": "2020-11-17T11:52:02Z", "author": {"login": "lfgcampos"}, "path": "eventsourcing/src/main/java/org/axonframework/eventsourcing/eventstore/jdbc/JdbcEventStorageEngine.java", "diffHunk": "@@ -418,37 +431,40 @@ public TrackingToken createTailToken() {\n                 resultSet -> nextAndExtract(resultSet, 1, Long.class),\n                 e -> new EventStoreException(\"Failed to get tail token\", e)\n         ));\n-        return Optional.ofNullable(index)\n-                       .map(seq -> GapAwareTrackingToken.newInstance(seq, Collections.emptySet()))\n-                       .orElse(null);\n+        return createToken(index);\n     }\n \n     @Override\n     public TrackingToken createHeadToken() {\n+        return createToken(mostRecentToken());\n+    }\n+\n+    @Override\n+    public TrackingToken createTokenAt(Instant dateTime) {\n         Long index = transactionManager.fetchInTransaction(() -> executeQuery(\n+                getConnection(),\n+                connection -> createTokenAt(connection, dateTime),\n+                resultSet -> nextAndExtract(resultSet, 1, Long.class),\n+                e -> new EventStoreException(format(\"Failed to get token at [%s]\", dateTime), e)\n+        ));\n+        return index != null ? createToken(index) : createToken(mostRecentToken());\n+    }\n+\n+    private Long mostRecentToken() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTAyODEwOA=="}, "originalCommit": {"oid": "343d2e8e30493421d8c2f0b5d2574d9f63ee85d5"}, "originalPosition": 53}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI5MTk1MjUzOnYy", "diffSide": "RIGHT", "path": "eventsourcing/src/test/java/org/axonframework/eventsourcing/MultiStreamableMessageSourceTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xN1QxMDoxNDoyMlrOH0ttqA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xN1QxMDoxNDoyMlrOH0ttqA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTAzNjk2OA==", "bodyText": "nit: silly line break here", "url": "https://github.com/AxonFramework/AxonFramework/pull/1607#discussion_r525036968", "createdAt": "2020-11-17T10:14:22Z", "author": {"login": "lfgcampos"}, "path": "eventsourcing/src/test/java/org/axonframework/eventsourcing/MultiStreamableMessageSourceTest.java", "diffHunk": "@@ -257,74 +257,103 @@ void peekWithMultipleStreams() throws InterruptedException {\n         singleEventStream.close();\n     }\n \n+    /**\n+     * Create a timestamp a bit prior to {@link Instant#now()}. This can for example be used on {@link\n+     * StreamableMessageSource#createTokenAt(Instant)} right after the insertion of some events, so that the created\n+     * token will take in these new events. Simply using {@link Instant#now()} allows for a window of opportunity which\n+     * misses these recent events.\n+     *\n+     * @return a timestamp a bit prior to {@link Instant#now()}\n+     */\n+    private static Instant recentTimeStamp() {\n+        return Instant.now().minusMillis(1000);\n+    }\n+\n     @Test\n     void createTailToken() {\n-        EventMessage pubToStreamA = GenericEventMessage.asEventMessage(\"Event1\");\n+        EventMessage<?> pubToStreamA = GenericEventMessage.asEventMessage(\"Event1\");\n         eventStoreA.publish(pubToStreamA);\n \n-        EventMessage pubToStreamB = GenericEventMessage.asEventMessage(\"Event2\");\n+        EventMessage<?> pubToStreamB = GenericEventMessage.asEventMessage(\"Event2\");\n         eventStoreB.publish(pubToStreamB);\n \n         MultiSourceTrackingToken tailToken = testSubject.createTailToken();\n \n-        assertEquals(-1L, tailToken.getTokenForStream(\"eventStoreA\").position().getAsLong());\n-        assertEquals(-1L, tailToken.getTokenForStream(\"eventStoreB\").position().getAsLong());\n+        OptionalLong storeAPosition = tailToken.getTokenForStream(\"eventStoreA\").position();\n+        assertTrue(storeAPosition.isPresent());\n+        assertEquals(-1L, storeAPosition.getAsLong());\n+        OptionalLong storeBPosition = tailToken.getTokenForStream(\"eventStoreB\").position();\n+        assertTrue(storeBPosition.isPresent());\n+        assertEquals(-1L, storeBPosition.getAsLong());\n     }\n \n     @Test\n     void createHeadToken() {\n-        EventMessage pubToStreamA = GenericEventMessage.asEventMessage(\"Event1\");\n+        EventMessage<?> pubToStreamA = GenericEventMessage.asEventMessage(\"Event1\");\n         eventStoreA.publish(pubToStreamA);\n \n-        EventMessage pubToStreamB = GenericEventMessage.asEventMessage(\"Event2\");\n+        EventMessage<?> pubToStreamB = GenericEventMessage.asEventMessage(\"Event2\");\n         eventStoreB.publish(pubToStreamB);\n         eventStoreB.publish(pubToStreamB);\n \n         MultiSourceTrackingToken headToken = testSubject.createHeadToken();\n \n-        assertEquals(0L, headToken.getTokenForStream(\"eventStoreA\").position().getAsLong());\n-        assertEquals(1L, headToken.getTokenForStream(\"eventStoreB\").position().getAsLong());\n+        OptionalLong storeAPosition = headToken.getTokenForStream(\"eventStoreA\").position();\n+        assertTrue(storeAPosition.isPresent());\n+        assertEquals(0L, storeAPosition.getAsLong());\n+        OptionalLong storeBPosition = headToken.getTokenForStream(\"eventStoreB\").position();\n+        assertTrue(storeBPosition.isPresent());\n+        assertEquals(1L, storeBPosition.getAsLong());\n     }\n \n     @Test\n     void createTokenAt() throws InterruptedException {\n-        EventMessage pubToStreamA = GenericEventMessage.asEventMessage(\"Event1\");\n+        EventMessage<?> pubToStreamA = GenericEventMessage.asEventMessage(\"Event1\");\n         eventStoreA.publish(pubToStreamA);\n         eventStoreA.publish(pubToStreamA);\n \n         Thread.sleep(20);\n \n-        EventMessage pubToStreamB = GenericEventMessage.asEventMessage(\"Event2\");\n+        EventMessage<?> pubToStreamB = GenericEventMessage.asEventMessage(\"Event2\");\n         eventStoreB.publish(pubToStreamB);\n \n-        MultiSourceTrackingToken createdAtToken = testSubject.createTokenAt(Instant.now().minus(10, ChronoUnit.MILLIS));\n-        //token should track events in eventStoreB and skip those in eventStoreA\n-        assertNull(createdAtToken.getTokenForStream(\"eventStoreA\"));\n-        assertEquals(-1L, createdAtToken.getTokenForStream(\"eventStoreB\").position().getAsLong());\n+        // Token should track events in eventStoreB and skip those in eventStoreA\n+        MultiSourceTrackingToken createdAtToken = testSubject.createTokenAt(Instant.now().minusMillis(10));\n+\n+        // storeA's token resembles an storeA head token since the create token at timestamp is after all its events\n+        assertEquals(eventStoreA.createHeadToken(), createdAtToken.getTokenForStream(\"eventStoreA\"));\n+        OptionalLong storeBPosition = createdAtToken.getTokenForStream(\"eventStoreB\").position();\n+        assertTrue(storeBPosition.isPresent());\n+        assertEquals(-1L, storeBPosition.getAsLong());\n     }\n \n     @Test\n     void createTokenSince() throws InterruptedException {\n-        EventMessage pubToStreamA = GenericEventMessage.asEventMessage(\"Event1\");\n+        EventMessage<?> pubToStreamA = GenericEventMessage.asEventMessage(\"Event1\");\n         eventStoreA.publish(pubToStreamA);\n         eventStoreA.publish(pubToStreamA);\n \n         Thread.sleep(20);\n \n-        EventMessage pubToStreamB = GenericEventMessage.asEventMessage(\"Event2\");\n+        EventMessage<?> pubToStreamB = GenericEventMessage.asEventMessage(\"Event2\");\n         eventStoreB.publish(pubToStreamB);\n \n+        // Token should track events in eventStoreB and skip those in eventStoreA\n         MultiSourceTrackingToken createdSinceToken = testSubject.createTokenSince(Duration.ofMillis(10));\n-        //token should track events in eventStoreB and skip those in eventStoreA\n-        assertNull(createdSinceToken.getTokenForStream(\"eventStoreA\"));\n-        assertEquals(-1L, createdSinceToken.getTokenForStream(\"eventStoreB\").position().getAsLong());\n+\n+        // storeA's token resembles an storeA head token since the create token at timestamp is after all its events\n+        assertEquals(eventStoreA.createHeadToken(), createdSinceToken.getTokenForStream(\"eventStoreA\"));\n+        OptionalLong storeBPosition = createdSinceToken.getTokenForStream(\"eventStoreB\").position();\n+        assertTrue(storeBPosition.isPresent());\n+        assertEquals(-1L, storeBPosition.getAsLong());\n     }\n \n     @Test\n     void configuredDifferentComparator() throws InterruptedException {\n         Comparator<Map.Entry<String, TrackedEventMessage<?>>> eventStoreAPriority =\n-                Comparator.comparing((Map.Entry<String, TrackedEventMessage<?>> e) -> !e.getKey().equals(\"eventStoreA\")).\n-                        thenComparing(e -> e.getValue().getTimestamp());\n+                Comparator.comparing((Map.Entry<String, TrackedEventMessage<?>> e) -> !e.getKey().equals(\"eventStoreA\"))\n+                          .", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "343d2e8e30493421d8c2f0b5d2574d9f63ee85d5"}, "originalPosition": 287}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI5MTk4MjYyOnYy", "diffSide": "RIGHT", "path": "eventsourcing/src/main/java/org/axonframework/eventsourcing/eventstore/jpa/JpaEventStorageEngine.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xN1QxMDoyMTozOVrOH0uADQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xN1QxMDoyMTozOVrOH0uADQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTA0MTY3Nw==", "bodyText": "Same comment here, about having the word index somewhere.", "url": "https://github.com/AxonFramework/AxonFramework/pull/1607#discussion_r525041677", "createdAt": "2020-11-17T10:21:39Z", "author": {"login": "lfgcampos"}, "path": "eventsourcing/src/main/java/org/axonframework/eventsourcing/eventstore/jpa/JpaEventStorageEngine.java", "diffHunk": "@@ -325,27 +325,37 @@ public TrackingToken createTailToken() {\n \n     @Override\n     public TrackingToken createHeadToken() {\n-        List<Long> results = entityManager().createQuery(\n-                \"SELECT MAX(e.globalIndex) FROM \" + domainEventEntryEntityName() + \" e\", Long.class\n-        ).getResultList();\n-        return createToken(results);\n+        return createToken(mostRecentToken());\n     }\n \n     @Override\n     public TrackingToken createTokenAt(Instant dateTime) {\n-        List<Long> results = entityManager().createQuery(\n-                \"SELECT MIN(e.globalIndex) - 1 FROM \" + domainEventEntryEntityName()\n-                        + \" e WHERE e.timeStamp >= :dateTime\", Long.class\n-        ).setParameter(\"dateTime\", formatInstant(dateTime))\n-                                            .getResultList();\n-        return createToken(results);\n+        List<Long> results = entityManager()\n+                .createQuery(\n+                        \"SELECT MIN(e.globalIndex) - 1 FROM \" + domainEventEntryEntityName() + \" e \"\n+                                + \"WHERE e.timeStamp >= :dateTime\", Long.class\n+                )\n+                .setParameter(\"dateTime\", formatInstant(dateTime))\n+                .getResultList();\n+\n+        return noTokenFound(results) ? createToken(mostRecentToken()) : createToken(results);\n+    }\n+\n+    private List<Long> mostRecentToken() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "343d2e8e30493421d8c2f0b5d2574d9f63ee85d5"}, "originalPosition": 30}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMwNzk3Nzg5OnYy", "diffSide": "RIGHT", "path": "eventsourcing/src/main/java/org/axonframework/eventsourcing/eventstore/inmemory/InMemoryEventStorageEngine.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yMFQxMDowMzowNlrOH3JE9g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yMFQxMDoxODo0NVrOH3JoCA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzU4MjQ1NA==", "bodyText": "This construct causes \"createHeadToken\" to be called upon each call of \"createTokenAt\". That may be an expensive operation. Please use orElseGet(this::createHeadToken) instead.", "url": "https://github.com/AxonFramework/AxonFramework/pull/1607#discussion_r527582454", "createdAt": "2020-11-20T10:03:06Z", "author": {"login": "abuijze"}, "path": "eventsourcing/src/main/java/org/axonframework/eventsourcing/eventstore/inmemory/InMemoryEventStorageEngine.java", "diffHunk": "@@ -153,7 +153,8 @@ public TrackingToken createTokenAt(Instant dateTime) {\n                      .map(TrackedEventMessage::trackingToken)\n                      .map(tt -> (GlobalSequenceTrackingToken) tt)\n                      .map(tt -> new GlobalSequenceTrackingToken(tt.getGlobalIndex() - 1))\n-                     .orElse(null);\n+                     .map(tt -> (TrackingToken) tt)\n+                     .orElse(createHeadToken());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9d4ba3a5e76e2e41aa8a451db7dc0f0c5910c7a5"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzU5MTQzMg==", "bodyText": "Darn, good point. Resolved.", "url": "https://github.com/AxonFramework/AxonFramework/pull/1607#discussion_r527591432", "createdAt": "2020-11-20T10:18:45Z", "author": {"login": "smcvb"}, "path": "eventsourcing/src/main/java/org/axonframework/eventsourcing/eventstore/inmemory/InMemoryEventStorageEngine.java", "diffHunk": "@@ -153,7 +153,8 @@ public TrackingToken createTokenAt(Instant dateTime) {\n                      .map(TrackedEventMessage::trackingToken)\n                      .map(tt -> (GlobalSequenceTrackingToken) tt)\n                      .map(tt -> new GlobalSequenceTrackingToken(tt.getGlobalIndex() - 1))\n-                     .orElse(null);\n+                     .map(tt -> (TrackingToken) tt)\n+                     .orElse(createHeadToken());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzU4MjQ1NA=="}, "originalCommit": {"oid": "9d4ba3a5e76e2e41aa8a451db7dc0f0c5910c7a5"}, "originalPosition": 6}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3150, "cost": 1, "resetAt": "2021-11-12T11:18:39Z"}}}