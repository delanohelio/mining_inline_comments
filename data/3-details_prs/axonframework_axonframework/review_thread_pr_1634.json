{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTM1OTQ5NjA0", "number": 1634, "reviewThreads": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMFQxMzo1NTozN1rOFDfVYQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMFQxMzo1NzoyMFrOFDfY1w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM5MjAzNDI1OnYy", "diffSide": "RIGHT", "path": "messaging/src/main/java/org/axonframework/commandhandling/distributed/AbstractRoutingStrategy.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMFQxMzo1NTozN1rOIDKafA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMFQxNDowNDozMFrOIDK0Mg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDE4NzI2MA==", "bodyText": "Why is the generic parameter here? It doesn't seem to be used anywhere.", "url": "https://github.com/AxonFramework/AxonFramework/pull/1634#discussion_r540187260", "createdAt": "2020-12-10T13:55:37Z", "author": {"login": "abuijze"}, "path": "messaging/src/main/java/org/axonframework/commandhandling/distributed/AbstractRoutingStrategy.java", "diffHunk": "@@ -17,62 +17,99 @@\n package org.axonframework.commandhandling.distributed;\n \n import org.axonframework.commandhandling.CommandMessage;\n-import org.axonframework.common.Assert;\n+import org.axonframework.common.AxonConfigurationException;\n \n-import java.util.concurrent.atomic.AtomicLong;\n-\n-import static java.lang.String.format;\n+import static org.axonframework.common.BuilderUtils.assertNonNull;\n \n /**\n- * Abstract implementation of the RoutingStrategy interface that uses a policy to prescribe what happens when a routing\n- * cannot be resolved.\n+ * Abstract implementation of the {@link RoutingStrategy} interface that includes a fallback {@code RoutingStrategy}\n+ * which prescribes what happens when routing cannot be resolved by this implementation.\n  *\n  * @author Allard Buijze\n  * @since 2.0\n  */\n-public abstract class AbstractRoutingStrategy implements RoutingStrategy {\n+public abstract class AbstractRoutingStrategy<B extends RoutingStrategy> implements RoutingStrategy {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "303c6ad88e68de395ed1aff32f4bccc18b395013"}, "originalPosition": 22}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDE5Mzg0Mg==", "bodyText": "That's for the protected AbstractRoutingStrategy(Builder<B> builder) { ... } constructor.\nAnd added,I intended to create a public abstract B builder(); method, which I missed.", "url": "https://github.com/AxonFramework/AxonFramework/pull/1634#discussion_r540193842", "createdAt": "2020-12-10T14:04:30Z", "author": {"login": "smcvb"}, "path": "messaging/src/main/java/org/axonframework/commandhandling/distributed/AbstractRoutingStrategy.java", "diffHunk": "@@ -17,62 +17,99 @@\n package org.axonframework.commandhandling.distributed;\n \n import org.axonframework.commandhandling.CommandMessage;\n-import org.axonframework.common.Assert;\n+import org.axonframework.common.AxonConfigurationException;\n \n-import java.util.concurrent.atomic.AtomicLong;\n-\n-import static java.lang.String.format;\n+import static org.axonframework.common.BuilderUtils.assertNonNull;\n \n /**\n- * Abstract implementation of the RoutingStrategy interface that uses a policy to prescribe what happens when a routing\n- * cannot be resolved.\n+ * Abstract implementation of the {@link RoutingStrategy} interface that includes a fallback {@code RoutingStrategy}\n+ * which prescribes what happens when routing cannot be resolved by this implementation.\n  *\n  * @author Allard Buijze\n  * @since 2.0\n  */\n-public abstract class AbstractRoutingStrategy implements RoutingStrategy {\n+public abstract class AbstractRoutingStrategy<B extends RoutingStrategy> implements RoutingStrategy {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDE4NzI2MA=="}, "originalCommit": {"oid": "303c6ad88e68de395ed1aff32f4bccc18b395013"}, "originalPosition": 22}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM5MjA0MzExOnYy", "diffSide": "RIGHT", "path": "messaging/src/main/java/org/axonframework/commandhandling/distributed/AbstractRoutingStrategy.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMFQxMzo1NzoyMFrOIDKffw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMFQxNDowNTo1OFrOIDK4Pg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDE4ODU0Mw==", "bodyText": "Since this is an abstract class, I doubt whether using the builder pattern here simplifies things.", "url": "https://github.com/AxonFramework/AxonFramework/pull/1634#discussion_r540188543", "createdAt": "2020-12-10T13:57:20Z", "author": {"login": "abuijze"}, "path": "messaging/src/main/java/org/axonframework/commandhandling/distributed/AbstractRoutingStrategy.java", "diffHunk": "@@ -17,62 +17,99 @@\n package org.axonframework.commandhandling.distributed;\n \n import org.axonframework.commandhandling.CommandMessage;\n-import org.axonframework.common.Assert;\n+import org.axonframework.common.AxonConfigurationException;\n \n-import java.util.concurrent.atomic.AtomicLong;\n-\n-import static java.lang.String.format;\n+import static org.axonframework.common.BuilderUtils.assertNonNull;\n \n /**\n- * Abstract implementation of the RoutingStrategy interface that uses a policy to prescribe what happens when a routing\n- * cannot be resolved.\n+ * Abstract implementation of the {@link RoutingStrategy} interface that includes a fallback {@code RoutingStrategy}\n+ * which prescribes what happens when routing cannot be resolved by this implementation.\n  *\n  * @author Allard Buijze\n  * @since 2.0\n  */\n-public abstract class AbstractRoutingStrategy implements RoutingStrategy {\n+public abstract class AbstractRoutingStrategy<B extends RoutingStrategy> implements RoutingStrategy {\n \n-    private static final String STATIC_ROUTING_KEY = \"unresolved\";\n+    private final RoutingStrategy fallbackRoutingStrategy;\n \n-    private final UnresolvedRoutingKeyPolicy unresolvedRoutingKeyPolicy;\n-    private final AtomicLong counter = new AtomicLong(0);\n+    /**\n+     * Instantiate a {@link AbstractRoutingStrategy} based on the fields contained in the given {@code builder}\n+     *\n+     * @param builder the {@link Builder} used to instantiate a {@link AbstractRoutingStrategy} instance\n+     */\n+    protected AbstractRoutingStrategy(Builder<B> builder) {\n+        builder.validate();\n+        this.fallbackRoutingStrategy = builder.fallbackRoutingStrategy;\n+    }\n \n     /**\n-     * Initializes the strategy using given {@code unresolvedRoutingKeyPolicy} prescribing what happens when a\n-     * routing key cannot be resolved.\n+     * Initializes the strategy using given {@link UnresolvedRoutingKeyPolicy} prescribing the fallback approach when\n+     * this implementation cannot resolve a routing key.\n      *\n-     * @param unresolvedRoutingKeyPolicy The policy for unresolved routing keys.\n+     * @param fallbackRoutingStrategy the fallback routing to use whenever this {@link RoutingStrategy} doesn't succeed\n+     * @deprecated in favor of the {@link #AbstractRoutingStrategy(Builder)}\n      */\n-    public AbstractRoutingStrategy(UnresolvedRoutingKeyPolicy unresolvedRoutingKeyPolicy) {\n-        Assert.notNull(unresolvedRoutingKeyPolicy, () -> \"unresolvedRoutingKeyPolicy may not be null\");\n-        this.unresolvedRoutingKeyPolicy = unresolvedRoutingKeyPolicy;\n+    @Deprecated\n+    public AbstractRoutingStrategy(UnresolvedRoutingKeyPolicy fallbackRoutingStrategy) {\n+        assertNonNull(fallbackRoutingStrategy, \"Fallback RoutingStrategy may not be null\");\n+        this.fallbackRoutingStrategy = fallbackRoutingStrategy;\n     }\n \n     @Override\n     public String getRoutingKey(CommandMessage<?> command) {\n         String routingKey = doResolveRoutingKey(command);\n         if (routingKey == null) {\n-            switch (unresolvedRoutingKeyPolicy) {\n-                case ERROR:\n-                    throw new CommandDispatchException(format(\"The command [%s] does not contain a routing key.\",\n-                                                              command.getCommandName()));\n-                case RANDOM_KEY:\n-                    return Long.toHexString(counter.getAndIncrement());\n-                case STATIC_KEY:\n-                    return STATIC_ROUTING_KEY;\n-                default:\n-                    throw new IllegalStateException(\"The configured UnresolvedRoutingPolicy of \"\n-                                                            + unresolvedRoutingKeyPolicy.name() + \" is not supported.\");\n-            }\n+            routingKey = fallbackRoutingStrategy.getRoutingKey(command);\n         }\n         return routingKey;\n     }\n \n     /**\n      * Resolve the Routing Key for the given {@code command}.\n      *\n-     * @param command The command to resolve the routing key for\n-     * @return the String representing the Routing Key, or {@code null} if unresolved.\n+     * @param command the command to resolve the routing key for\n+     * @return the String representing the Routing Key, or {@code null} if unresolved\n      */\n     protected abstract String doResolveRoutingKey(CommandMessage<?> command);\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "303c6ad88e68de395ed1aff32f4bccc18b395013"}, "originalPosition": 88}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDE5NDg3OA==", "bodyText": "Not necessarily simplify, no, but giving us the flexibility to change whatever without creating [5/10/N] new constructors. So from the same stance as to why the other infra components have a builder instead of a constructor. Let's chat offline whether we should go this route for components of this size.", "url": "https://github.com/AxonFramework/AxonFramework/pull/1634#discussion_r540194878", "createdAt": "2020-12-10T14:05:58Z", "author": {"login": "smcvb"}, "path": "messaging/src/main/java/org/axonframework/commandhandling/distributed/AbstractRoutingStrategy.java", "diffHunk": "@@ -17,62 +17,99 @@\n package org.axonframework.commandhandling.distributed;\n \n import org.axonframework.commandhandling.CommandMessage;\n-import org.axonframework.common.Assert;\n+import org.axonframework.common.AxonConfigurationException;\n \n-import java.util.concurrent.atomic.AtomicLong;\n-\n-import static java.lang.String.format;\n+import static org.axonframework.common.BuilderUtils.assertNonNull;\n \n /**\n- * Abstract implementation of the RoutingStrategy interface that uses a policy to prescribe what happens when a routing\n- * cannot be resolved.\n+ * Abstract implementation of the {@link RoutingStrategy} interface that includes a fallback {@code RoutingStrategy}\n+ * which prescribes what happens when routing cannot be resolved by this implementation.\n  *\n  * @author Allard Buijze\n  * @since 2.0\n  */\n-public abstract class AbstractRoutingStrategy implements RoutingStrategy {\n+public abstract class AbstractRoutingStrategy<B extends RoutingStrategy> implements RoutingStrategy {\n \n-    private static final String STATIC_ROUTING_KEY = \"unresolved\";\n+    private final RoutingStrategy fallbackRoutingStrategy;\n \n-    private final UnresolvedRoutingKeyPolicy unresolvedRoutingKeyPolicy;\n-    private final AtomicLong counter = new AtomicLong(0);\n+    /**\n+     * Instantiate a {@link AbstractRoutingStrategy} based on the fields contained in the given {@code builder}\n+     *\n+     * @param builder the {@link Builder} used to instantiate a {@link AbstractRoutingStrategy} instance\n+     */\n+    protected AbstractRoutingStrategy(Builder<B> builder) {\n+        builder.validate();\n+        this.fallbackRoutingStrategy = builder.fallbackRoutingStrategy;\n+    }\n \n     /**\n-     * Initializes the strategy using given {@code unresolvedRoutingKeyPolicy} prescribing what happens when a\n-     * routing key cannot be resolved.\n+     * Initializes the strategy using given {@link UnresolvedRoutingKeyPolicy} prescribing the fallback approach when\n+     * this implementation cannot resolve a routing key.\n      *\n-     * @param unresolvedRoutingKeyPolicy The policy for unresolved routing keys.\n+     * @param fallbackRoutingStrategy the fallback routing to use whenever this {@link RoutingStrategy} doesn't succeed\n+     * @deprecated in favor of the {@link #AbstractRoutingStrategy(Builder)}\n      */\n-    public AbstractRoutingStrategy(UnresolvedRoutingKeyPolicy unresolvedRoutingKeyPolicy) {\n-        Assert.notNull(unresolvedRoutingKeyPolicy, () -> \"unresolvedRoutingKeyPolicy may not be null\");\n-        this.unresolvedRoutingKeyPolicy = unresolvedRoutingKeyPolicy;\n+    @Deprecated\n+    public AbstractRoutingStrategy(UnresolvedRoutingKeyPolicy fallbackRoutingStrategy) {\n+        assertNonNull(fallbackRoutingStrategy, \"Fallback RoutingStrategy may not be null\");\n+        this.fallbackRoutingStrategy = fallbackRoutingStrategy;\n     }\n \n     @Override\n     public String getRoutingKey(CommandMessage<?> command) {\n         String routingKey = doResolveRoutingKey(command);\n         if (routingKey == null) {\n-            switch (unresolvedRoutingKeyPolicy) {\n-                case ERROR:\n-                    throw new CommandDispatchException(format(\"The command [%s] does not contain a routing key.\",\n-                                                              command.getCommandName()));\n-                case RANDOM_KEY:\n-                    return Long.toHexString(counter.getAndIncrement());\n-                case STATIC_KEY:\n-                    return STATIC_ROUTING_KEY;\n-                default:\n-                    throw new IllegalStateException(\"The configured UnresolvedRoutingPolicy of \"\n-                                                            + unresolvedRoutingKeyPolicy.name() + \" is not supported.\");\n-            }\n+            routingKey = fallbackRoutingStrategy.getRoutingKey(command);\n         }\n         return routingKey;\n     }\n \n     /**\n      * Resolve the Routing Key for the given {@code command}.\n      *\n-     * @param command The command to resolve the routing key for\n-     * @return the String representing the Routing Key, or {@code null} if unresolved.\n+     * @param command the command to resolve the routing key for\n+     * @return the String representing the Routing Key, or {@code null} if unresolved\n      */\n     protected abstract String doResolveRoutingKey(CommandMessage<?> command);\n+", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDE4ODU0Mw=="}, "originalCommit": {"oid": "303c6ad88e68de395ed1aff32f4bccc18b395013"}, "originalPosition": 88}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3170, "cost": 1, "resetAt": "2021-11-12T11:18:39Z"}}}