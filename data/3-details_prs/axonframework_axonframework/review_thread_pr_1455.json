{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDM3ODMwODEx", "number": 1455, "reviewThreads": {"totalCount": 22, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNFQwOTowNzo0N1rOEISGeQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yM1QwODo1NDozNFrOERXKUQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc3MTIwNjMzOnYy", "diffSide": "RIGHT", "path": "messaging/src/main/java/org/axonframework/common/ListUtils.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNFQwOTowNzo0N1rOGoJmMg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNFQwOTowNzo0N1rOGoJmMg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDc1MzQ1OA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                /** Returns a new list containing unique elements from the given {@code list}. Original list is not modified.\n          \n          \n            \n                 * @param list Original list that will not be modified\n          \n          \n            \n                /** \n          \n          \n            \n                 * Returns a new list containing unique elements from the given {@code list}. Original list is not modified.\n          \n          \n            \n                 *\n          \n          \n            \n                 * @param list Original list that will not be modified", "url": "https://github.com/AxonFramework/AxonFramework/pull/1455#discussion_r444753458", "createdAt": "2020-06-24T09:07:47Z", "author": {"login": "smcvb"}, "path": "messaging/src/main/java/org/axonframework/common/ListUtils.java", "diffHunk": "@@ -0,0 +1,26 @@\n+package org.axonframework.common;\n+\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * Utility methods for operations on lists.\n+ *\n+ * @author Stefan Andjelkovic\n+ * @since 4.4\n+ */\n+public abstract class ListUtils {\n+\n+    private ListUtils() {\n+        // prevent instantiation\n+    }\n+\n+    /** Returns a new list containing unique elements from the given {@code list}. Original list is not modified.\n+     * @param list Original list that will not be modified", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ee3b11b9e1708fdabecc2974d1f04904fb0689d5"}, "originalPosition": 19}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc3MTIyMjUwOnYy", "diffSide": "RIGHT", "path": "messaging/src/main/java/org/axonframework/common/ReflectionUtils.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNFQwOToxMjowNVrOGoJwIA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNFQwOToxMjowNVrOGoJwIA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDc1NjAwMA==", "bodyText": "Shouldn't this line state something like the target object the given {@code method} is invoked on?", "url": "https://github.com/AxonFramework/AxonFramework/pull/1455#discussion_r444756000", "createdAt": "2020-06-24T09:12:05Z", "author": {"login": "smcvb"}, "path": "messaging/src/main/java/org/axonframework/common/ReflectionUtils.java", "diffHunk": "@@ -325,6 +340,114 @@ public static boolean isTransient(Field field) {\n         return Optional.of((Class<?>) ((ParameterizedType) genericType).getActualTypeArguments()[genericTypeIndex]);\n     }\n \n+    /**\n+     * Resolve a generic type parameter from a member declaration\n+     *\n+     * @param member           The member to find generic parameters for\n+     * @param genericTypeIndex The index of the type\n+     * @return an optional that contains the resolved type, if found\n+     */\n+    public static Optional<Class<?>> resolveMemberGenericType(Member member, int genericTypeIndex) {\n+        final Type genericType = getMemberGenericType(member);\n+        if (!(genericType instanceof ParameterizedType)\n+                || ((ParameterizedType) genericType).getActualTypeArguments().length <= genericTypeIndex) {\n+            return Optional.empty();\n+        }\n+        return Optional.of((Class<?>) ((ParameterizedType) genericType).getActualTypeArguments()[genericTypeIndex]);\n+    }\n+\n+    /**\n+     * Invokes and returns the return value of the given {@code method} in the given {@code object}. If necessary, the method is\n+     * made accessible, assuming the security manager allows it.\n+     * @param method The method to invoke\n+     * @param object The target object to retrieve the field's value from", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ee3b11b9e1708fdabecc2974d1f04904fb0689d5"}, "originalPosition": 58}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc3MTIyOTgwOnYy", "diffSide": "RIGHT", "path": "messaging/src/main/java/org/axonframework/common/ReflectionUtils.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNFQwOToxNDowNFrOGoJ0ng==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNFQwOToxNDowNFrOGoJ0ng==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDc1NzE1MA==", "bodyText": "I am assuming this constant can be private. If not, it'll require some javadoc to be added.", "url": "https://github.com/AxonFramework/AxonFramework/pull/1455#discussion_r444757150", "createdAt": "2020-06-24T09:14:04Z", "author": {"login": "smcvb"}, "path": "messaging/src/main/java/org/axonframework/common/ReflectionUtils.java", "diffHunk": "@@ -34,6 +48,7 @@\n      * A map of Primitive types to their respective wrapper types.\n      */\n     private static final Map<Type, Class<?>> primitiveWrapperTypeMap = new HashMap<>(8);\n+    public static final String UNSUPPORTED_MEMBER_TYPE_EXCEPTION_MESSAGE = \"Unsupported member type [%s]\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ee3b11b9e1708fdabecc2974d1f04904fb0689d5"}, "originalPosition": 30}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc3MTI0NDc2OnYy", "diffSide": "RIGHT", "path": "messaging/src/main/java/org/axonframework/common/annotation/AnnotationUtils.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNFQwOToxODowMlrOGoJ-Cg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNFQwOToxODowMlrOGoJ-Cg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDc1OTU2Mg==", "bodyText": "Missing javadoc on this method.", "url": "https://github.com/AxonFramework/AxonFramework/pull/1455#discussion_r444759562", "createdAt": "2020-06-24T09:18:02Z", "author": {"login": "smcvb"}, "path": "messaging/src/main/java/org/axonframework/common/annotation/AnnotationUtils.java", "diffHunk": "@@ -110,6 +110,15 @@ public static boolean isAnnotationPresent(AnnotatedElement element, String annot\n         return findAnnotationAttributes(element, annotationType.getName());\n     }\n \n+    @SuppressWarnings(\"unchecked\")\n+    public static <T> Optional<T> findAnnotationAttribute(AnnotatedElement element,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ee3b11b9e1708fdabecc2974d1f04904fb0689d5"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc3MTU5NzUyOnYy", "diffSide": "RIGHT", "path": "modelling/src/main/java/org/axonframework/modelling/command/inspection/AbstractChildEntityDefinition.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNFQxMTowNDo0OVrOGoNbLg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNFQxMTowNDo0OVrOGoNbLg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDgxNjE3NA==", "bodyText": "Please add by what this method is being replaced on the @deprecated line of javadoc.", "url": "https://github.com/AxonFramework/AxonFramework/pull/1455#discussion_r444816174", "createdAt": "2020-06-24T11:04:49Z", "author": {"login": "smcvb"}, "path": "modelling/src/main/java/org/axonframework/modelling/command/inspection/AbstractChildEntityDefinition.java", "diffHunk": "@@ -72,31 +76,41 @@\n      *\n      * @param field a {@link java.lang.reflect.Field} containing a Child Entity\n      * @return true if the type is as required by the implementation and false if it is not\n+     * @deprecated", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ee3b11b9e1708fdabecc2974d1f04904fb0689d5"}, "originalPosition": 52}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc3MTY3MzU0OnYy", "diffSide": "RIGHT", "path": "modelling/src/main/java/org/axonframework/modelling/command/inspection/AggregateMemberAnnotatedChildEntityCollectionDefinition.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNFQxMTozMDo0MlrOGoOKLA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNFQxMTozMDo0MlrOGoOKLA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDgyODIwNA==", "bodyText": "I'd rename this variable to memberValue.", "url": "https://github.com/AxonFramework/AxonFramework/pull/1455#discussion_r444828204", "createdAt": "2020-06-24T11:30:42Z", "author": {"login": "smcvb"}, "path": "modelling/src/main/java/org/axonframework/modelling/command/inspection/AggregateMemberAnnotatedChildEntityCollectionDefinition.java", "diffHunk": "@@ -86,9 +98,9 @@ protected boolean isFieldTypeSupported(Field field) {\n     @Override\n     protected <T> Stream<Object> resolveEventTargets(EventMessage message,\n                                                      T parentEntity,\n-                                                     Field field,\n+                                                     Member member,\n                                                      ForwardingMode eventForwardingMode) {\n-        Iterable<Object> fieldValue = ReflectionUtils.getFieldValue(field, parentEntity);\n+        Iterable<Object> fieldValue = ReflectionUtils.getMemberValue(member, parentEntity);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ee3b11b9e1708fdabecc2974d1f04904fb0689d5"}, "originalPosition": 84}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc3MTY3NTQxOnYy", "diffSide": "RIGHT", "path": "modelling/src/main/java/org/axonframework/modelling/command/inspection/AggregateMemberAnnotatedChildEntityMapDefinition.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNFQxMTozMToxNVrOGoOLQQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNFQxMTozMToxNVrOGoOLQQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDgyODQ4MQ==", "bodyText": "I'd rename this variable to memberValue.", "url": "https://github.com/AxonFramework/AxonFramework/pull/1455#discussion_r444828481", "createdAt": "2020-06-24T11:31:15Z", "author": {"login": "smcvb"}, "path": "modelling/src/main/java/org/axonframework/modelling/command/inspection/AggregateMemberAnnotatedChildEntityMapDefinition.java", "diffHunk": "@@ -65,25 +77,24 @@ protected boolean isFieldTypeSupported(Field field) {\n     @Override\n     protected <T> Object resolveCommandTarget(CommandMessage<?> msg,\n                                               T parent,\n-                                              Field field,\n+                                              Member member,\n                                               EntityModel<Object> childEntityModel) {\n         Map<String, Property<Object>> commandHandlerRoutingKeys =\n-                extractCommandHandlerRoutingKeys(field, childEntityModel);\n+                extractCommandHandlerRoutingKeys(member, childEntityModel);\n \n         Object routingValue = commandHandlerRoutingKeys.get(msg.getCommandName())\n                                                        .getValue(msg.getPayload());\n-        Map<?, ?> fieldValue = ReflectionUtils.getFieldValue(field, parent);\n+        Map<?, ?> fieldValue = ReflectionUtils.getMemberValue(member, parent);\n \n         return fieldValue == null ? null : fieldValue.get(routingValue);\n     }\n \n-    @SuppressWarnings(\"unchecked\")\n     @Override\n     protected <T> Stream<Object> resolveEventTargets(EventMessage message,\n                                                      T parentEntity,\n-                                                     Field field,\n+                                                     Member member,\n                                                      ForwardingMode eventForwardingMode) {\n-        Map<?, Object> fieldValue = ReflectionUtils.getFieldValue(field, parentEntity);\n+        Map<?, Object> fieldValue = ReflectionUtils.getMemberValue(member, parentEntity);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ee3b11b9e1708fdabecc2974d1f04904fb0689d5"}, "originalPosition": 85}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc3MTc2Nzk5OnYy", "diffSide": "RIGHT", "path": "modelling/src/main/java/org/axonframework/modelling/command/inspection/AnnotatedAggregateMetaModelFactory.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNFQxMjowMDo0NlrOGoPEEg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNFQxMjowMDo0NlrOGoPEEg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDg0MzAyNg==", "bodyText": "I think this constant should be private, or otherwise javadoc should be included.", "url": "https://github.com/AxonFramework/AxonFramework/pull/1455#discussion_r444843026", "createdAt": "2020-06-24T12:00:46Z", "author": {"login": "smcvb"}, "path": "modelling/src/main/java/org/axonframework/modelling/command/inspection/AnnotatedAggregateMetaModelFactory.java", "diffHunk": "@@ -188,6 +194,7 @@ public AnnotatedAggregateMetaModelFactory(ParameterResolverFactory parameterReso\n \n     private class AnnotatedAggregateModel<T> implements AggregateModel<T> {\n \n+        public static final String JAVAX_PERSISTENCE_ID = \"javax.persistence.Id\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ee3b11b9e1708fdabecc2974d1f04904fb0689d5"}, "originalPosition": 72}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc3MTc5MTI2OnYy", "diffSide": "RIGHT", "path": "modelling/src/main/java/org/axonframework/modelling/command/inspection/AnnotatedAggregateMetaModelFactory.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNFQxMjowODozMFrOGoPTCw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNFQxMjowODozMFrOGoPTCw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDg0Njg1OQ==", "bodyText": "Nit: we could move this to a private method maybe, to deduplicate the Field and Method invocations.", "url": "https://github.com/AxonFramework/AxonFramework/pull/1455#discussion_r444846859", "createdAt": "2020-06-24T12:08:30Z", "author": {"login": "smcvb"}, "path": "modelling/src/main/java/org/axonframework/modelling/command/inspection/AnnotatedAggregateMetaModelFactory.java", "diffHunk": "@@ -303,62 +311,99 @@ private void inspectAggregateTypes() {\n \n         private String findDeclaredType(Class<?> type) {\n             return AnnotationUtils.findAnnotationAttributes(type, AggregateRoot.class)\n-                                  .map(map -> (String) map.get(\"type\")).filter(i -> i.length() > 0).orElse(type.getSimpleName());\n+                                  .map(map -> (String) map.get(\"type\")).filter(i -> i.length() > 0)\n+                                  .orElse(type.getSimpleName());\n         }\n \n-        private void inspectFields() {\n+        private void inspectFieldsAndMethods() {\n             ServiceLoader<ChildEntityDefinition> childEntityDefinitions =\n                     ServiceLoader.load(ChildEntityDefinition.class, inspectedType.getClassLoader());\n-            boolean persistenceId = false;\n+            ArrayList<Member> entityIdMembers = new ArrayList<>();\n+            ArrayList<Member> persistenceIdMembers = new ArrayList<>();\n+            ArrayList<Member> aggregateVersionMembers = new ArrayList<>();\n             for (Class<?> type : handlerInspector.getAllHandlers().keySet()) {\n                 for (Field field : ReflectionUtils.fieldsOf(type)) {\n                     childEntityDefinitions.forEach(def -> def.createChildDefinition(field, this).ifPresent(child -> {\n                         children.add(child);\n-                        child.commandHandlers().forEach(handler -> addHandler(allCommandHandlers,\n-                                                                              type,\n-                                                                              handler));\n+                        child.commandHandlers().forEach(handler -> addHandler(allCommandHandlers, type, handler));\n                     }));\n-\n-                    if (AnnotationUtils.findAnnotationAttributes(field, EntityId.class).isPresent()) {\n-                        if (identifierField != null && !field.equals(identifierField) && !persistenceId) {\n-                            throw new AggregateModellingException(format(\n-                                    \"Aggregate [%s] has two identifier fields [%s] and [%s].\",\n-                                    inspectedType,\n-                                    identifierField,\n-                                    field));\n-                        }\n-                        persistenceId = false;\n-                        identifierField = field;\n-                        Map<String, Object> attributes =\n-                                AnnotationUtils.findAnnotationAttributes(field, EntityId.class).get();\n-                        if (!\"\".equals(attributes.get(\"routingKey\"))) {\n-                            routingKey = (String) attributes.get(\"routingKey\");\n-                        } else {\n-                            routingKey = field.getName();\n-                        }\n-                    }\n-                    if (identifierField == null\n-                            && AnnotationUtils.findAnnotationAttributes(field, \"javax.persistence.Id\")\n-                                              .isPresent()) {\n-                            persistenceId = true;\n-                            identifierField = field;\n-                            routingKey = field.getName();\n-                    }\n+                    AnnotationUtils.findAnnotationAttributes(field, EntityId.class)\n+                                   .ifPresent(attributes -> entityIdMembers.add(field));\n+                    AnnotationUtils.findAnnotationAttributes(field, JAVAX_PERSISTENCE_ID)\n+                                   .ifPresent(attributes -> persistenceIdMembers.add(field));\n                     AnnotationUtils.findAnnotationAttributes(field, AggregateVersion.class)\n+                                   .ifPresent(attributes -> aggregateVersionMembers.add(field));\n+                }\n+                for (Method method : ReflectionUtils.methodsOf(type)) {\n+                    childEntityDefinitions.forEach(def -> def.createChildDefinition(method, this).ifPresent(child -> {\n+                        children.add(child);\n+                        child.commandHandlers().forEach(handler -> addHandler(allCommandHandlers, type, handler));\n+                    }));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ee3b11b9e1708fdabecc2974d1f04904fb0689d5"}, "originalPosition": 166}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc3MTgwNTI2OnYy", "diffSide": "RIGHT", "path": "modelling/src/main/java/org/axonframework/modelling/command/inspection/AnnotatedAggregateMetaModelFactory.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNFQxMjoxMzowMFrOGoPbtw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNFQxMjoxMzowMFrOGoPbtw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDg0OTA3OQ==", "bodyText": "Nit: I'd replace the type ArrayList for List here.", "url": "https://github.com/AxonFramework/AxonFramework/pull/1455#discussion_r444849079", "createdAt": "2020-06-24T12:13:00Z", "author": {"login": "smcvb"}, "path": "modelling/src/main/java/org/axonframework/modelling/command/inspection/AnnotatedAggregateMetaModelFactory.java", "diffHunk": "@@ -303,62 +311,99 @@ private void inspectAggregateTypes() {\n \n         private String findDeclaredType(Class<?> type) {\n             return AnnotationUtils.findAnnotationAttributes(type, AggregateRoot.class)\n-                                  .map(map -> (String) map.get(\"type\")).filter(i -> i.length() > 0).orElse(type.getSimpleName());\n+                                  .map(map -> (String) map.get(\"type\")).filter(i -> i.length() > 0)\n+                                  .orElse(type.getSimpleName());\n         }\n \n-        private void inspectFields() {\n+        private void inspectFieldsAndMethods() {\n             ServiceLoader<ChildEntityDefinition> childEntityDefinitions =\n                     ServiceLoader.load(ChildEntityDefinition.class, inspectedType.getClassLoader());\n-            boolean persistenceId = false;\n+            ArrayList<Member> entityIdMembers = new ArrayList<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ee3b11b9e1708fdabecc2974d1f04904fb0689d5"}, "originalPosition": 117}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc3MTg1ODUxOnYy", "diffSide": "RIGHT", "path": "modelling/src/main/java/org/axonframework/modelling/command/inspection/AnnotatedAggregateMetaModelFactory.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNFQxMjoyODo0NlrOGoP8kg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMVQxMjoxMzowNFrOG01GLg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDg1NzQ5MA==", "bodyText": "I'd add something to this exception stating that no parameters are expected for an aggregate's annotated methods. Should be careful with the wording though, as a command handler is also an annotated method of an aggregate of course \ud83d\ude05", "url": "https://github.com/AxonFramework/AxonFramework/pull/1455#discussion_r444857490", "createdAt": "2020-06-24T12:28:46Z", "author": {"login": "smcvb"}, "path": "modelling/src/main/java/org/axonframework/modelling/command/inspection/AnnotatedAggregateMetaModelFactory.java", "diffHunk": "@@ -303,62 +311,99 @@ private void inspectAggregateTypes() {\n \n         private String findDeclaredType(Class<?> type) {\n             return AnnotationUtils.findAnnotationAttributes(type, AggregateRoot.class)\n-                                  .map(map -> (String) map.get(\"type\")).filter(i -> i.length() > 0).orElse(type.getSimpleName());\n+                                  .map(map -> (String) map.get(\"type\")).filter(i -> i.length() > 0)\n+                                  .orElse(type.getSimpleName());\n         }\n \n-        private void inspectFields() {\n+        private void inspectFieldsAndMethods() {\n             ServiceLoader<ChildEntityDefinition> childEntityDefinitions =\n                     ServiceLoader.load(ChildEntityDefinition.class, inspectedType.getClassLoader());\n-            boolean persistenceId = false;\n+            ArrayList<Member> entityIdMembers = new ArrayList<>();\n+            ArrayList<Member> persistenceIdMembers = new ArrayList<>();\n+            ArrayList<Member> aggregateVersionMembers = new ArrayList<>();\n             for (Class<?> type : handlerInspector.getAllHandlers().keySet()) {\n                 for (Field field : ReflectionUtils.fieldsOf(type)) {\n                     childEntityDefinitions.forEach(def -> def.createChildDefinition(field, this).ifPresent(child -> {\n                         children.add(child);\n-                        child.commandHandlers().forEach(handler -> addHandler(allCommandHandlers,\n-                                                                              type,\n-                                                                              handler));\n+                        child.commandHandlers().forEach(handler -> addHandler(allCommandHandlers, type, handler));\n                     }));\n-\n-                    if (AnnotationUtils.findAnnotationAttributes(field, EntityId.class).isPresent()) {\n-                        if (identifierField != null && !field.equals(identifierField) && !persistenceId) {\n-                            throw new AggregateModellingException(format(\n-                                    \"Aggregate [%s] has two identifier fields [%s] and [%s].\",\n-                                    inspectedType,\n-                                    identifierField,\n-                                    field));\n-                        }\n-                        persistenceId = false;\n-                        identifierField = field;\n-                        Map<String, Object> attributes =\n-                                AnnotationUtils.findAnnotationAttributes(field, EntityId.class).get();\n-                        if (!\"\".equals(attributes.get(\"routingKey\"))) {\n-                            routingKey = (String) attributes.get(\"routingKey\");\n-                        } else {\n-                            routingKey = field.getName();\n-                        }\n-                    }\n-                    if (identifierField == null\n-                            && AnnotationUtils.findAnnotationAttributes(field, \"javax.persistence.Id\")\n-                                              .isPresent()) {\n-                            persistenceId = true;\n-                            identifierField = field;\n-                            routingKey = field.getName();\n-                    }\n+                    AnnotationUtils.findAnnotationAttributes(field, EntityId.class)\n+                                   .ifPresent(attributes -> entityIdMembers.add(field));\n+                    AnnotationUtils.findAnnotationAttributes(field, JAVAX_PERSISTENCE_ID)\n+                                   .ifPresent(attributes -> persistenceIdMembers.add(field));\n                     AnnotationUtils.findAnnotationAttributes(field, AggregateVersion.class)\n+                                   .ifPresent(attributes -> aggregateVersionMembers.add(field));\n+                }\n+                for (Method method : ReflectionUtils.methodsOf(type)) {\n+                    childEntityDefinitions.forEach(def -> def.createChildDefinition(method, this).ifPresent(child -> {\n+                        children.add(child);\n+                        child.commandHandlers().forEach(handler -> addHandler(allCommandHandlers, type, handler));\n+                    }));\n+                    AnnotationUtils.findAnnotationAttributes(method, EntityId.class)\n                                    .ifPresent(attributes -> {\n-                                       if (versionField != null && !field.equals(versionField)) {\n-                                           throw new AggregateModellingException(format(\n-                                                   \"Aggregate [%s] has two version fields [%s] and [%s].\",\n-                                                   inspectedType,\n-                                                   versionField,\n-                                                   field));\n-                                       }\n-                                       versionField = field;\n+                                       assertValidValueProvidingMethod(method);\n+                                       entityIdMembers.add(method);\n+                                   });\n+                    AnnotationUtils.findAnnotationAttributes(method, JAVAX_PERSISTENCE_ID)\n+                                   .ifPresent(attributes -> {\n+                                       assertValidValueProvidingMethod(method);\n+                                       persistenceIdMembers.add(method);\n+                                   });\n+                    AnnotationUtils.findAnnotationAttributes(method, AggregateVersion.class)\n+                                   .ifPresent(attributes -> {\n+                                       assertValidValueProvidingMethod(method);\n+                                       aggregateVersionMembers.add(method);\n                                    });\n                 }\n             }\n-            if (identifierField != null) {\n-                final Class<?> idClazz = identifierField.getType();\n+\n+            findIdentifierMember(distinct(entityIdMembers), distinct(persistenceIdMembers))\n+                    .ifPresent(this::setIdentifierAndRoutingKey);\n+            if (!aggregateVersionMembers.isEmpty()) {\n+                setVersionMember(aggregateVersionMembers.get(0));\n+            }\n+            assertIdentifierValidity(identifierMember);\n+        }\n+\n+        private void setIdentifierAndRoutingKey(Member identifier) {\n+            identifierMember = identifier;\n+            routingKey = findRoutingKey((AccessibleObject) identifier)\n+                    .orElseGet(identifier::getName);\n+        }\n+\n+        private Optional<Member> findIdentifierMember(List<Member> entityIdMembers,\n+                                                      List<Member> persistenceIdMembers) {\n+            if (entityIdMembers.size() > 1) {\n+                throw new AggregateModellingException(format(\n+                        \"Aggregate [%s] has more than one identifier member\",\n+                        inspectedType));\n+            }\n+            if (!entityIdMembers.isEmpty()) {\n+                return Optional.of(entityIdMembers.get(0));\n+            } else if (!persistenceIdMembers.isEmpty()) {\n+                return Optional.of(persistenceIdMembers.get(0));\n+            }\n+            return Optional.empty();\n+        }\n+\n+        private void assertValidValueProvidingMethod(Method method) {\n+            if (method.getParameterCount() != 0) {\n+                throw new AggregateModellingException(format(\n+                        \"Aggregate [%s] has an annotated method [%s] with parameters\",", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ee3b11b9e1708fdabecc2974d1f04904fb0689d5"}, "originalPosition": 227}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzE5ODUzMQ==", "bodyText": "Aggregate [%s] has an annotated value providing method [%s] with parameters maybe?\nThat would also be applicable to Aggregate [%s] has an annotated value providing method [%s] with void return type, but a return value is required", "url": "https://github.com/AxonFramework/AxonFramework/pull/1455#discussion_r457198531", "createdAt": "2020-07-20T09:02:26Z", "author": {"login": "sandjelkovic"}, "path": "modelling/src/main/java/org/axonframework/modelling/command/inspection/AnnotatedAggregateMetaModelFactory.java", "diffHunk": "@@ -303,62 +311,99 @@ private void inspectAggregateTypes() {\n \n         private String findDeclaredType(Class<?> type) {\n             return AnnotationUtils.findAnnotationAttributes(type, AggregateRoot.class)\n-                                  .map(map -> (String) map.get(\"type\")).filter(i -> i.length() > 0).orElse(type.getSimpleName());\n+                                  .map(map -> (String) map.get(\"type\")).filter(i -> i.length() > 0)\n+                                  .orElse(type.getSimpleName());\n         }\n \n-        private void inspectFields() {\n+        private void inspectFieldsAndMethods() {\n             ServiceLoader<ChildEntityDefinition> childEntityDefinitions =\n                     ServiceLoader.load(ChildEntityDefinition.class, inspectedType.getClassLoader());\n-            boolean persistenceId = false;\n+            ArrayList<Member> entityIdMembers = new ArrayList<>();\n+            ArrayList<Member> persistenceIdMembers = new ArrayList<>();\n+            ArrayList<Member> aggregateVersionMembers = new ArrayList<>();\n             for (Class<?> type : handlerInspector.getAllHandlers().keySet()) {\n                 for (Field field : ReflectionUtils.fieldsOf(type)) {\n                     childEntityDefinitions.forEach(def -> def.createChildDefinition(field, this).ifPresent(child -> {\n                         children.add(child);\n-                        child.commandHandlers().forEach(handler -> addHandler(allCommandHandlers,\n-                                                                              type,\n-                                                                              handler));\n+                        child.commandHandlers().forEach(handler -> addHandler(allCommandHandlers, type, handler));\n                     }));\n-\n-                    if (AnnotationUtils.findAnnotationAttributes(field, EntityId.class).isPresent()) {\n-                        if (identifierField != null && !field.equals(identifierField) && !persistenceId) {\n-                            throw new AggregateModellingException(format(\n-                                    \"Aggregate [%s] has two identifier fields [%s] and [%s].\",\n-                                    inspectedType,\n-                                    identifierField,\n-                                    field));\n-                        }\n-                        persistenceId = false;\n-                        identifierField = field;\n-                        Map<String, Object> attributes =\n-                                AnnotationUtils.findAnnotationAttributes(field, EntityId.class).get();\n-                        if (!\"\".equals(attributes.get(\"routingKey\"))) {\n-                            routingKey = (String) attributes.get(\"routingKey\");\n-                        } else {\n-                            routingKey = field.getName();\n-                        }\n-                    }\n-                    if (identifierField == null\n-                            && AnnotationUtils.findAnnotationAttributes(field, \"javax.persistence.Id\")\n-                                              .isPresent()) {\n-                            persistenceId = true;\n-                            identifierField = field;\n-                            routingKey = field.getName();\n-                    }\n+                    AnnotationUtils.findAnnotationAttributes(field, EntityId.class)\n+                                   .ifPresent(attributes -> entityIdMembers.add(field));\n+                    AnnotationUtils.findAnnotationAttributes(field, JAVAX_PERSISTENCE_ID)\n+                                   .ifPresent(attributes -> persistenceIdMembers.add(field));\n                     AnnotationUtils.findAnnotationAttributes(field, AggregateVersion.class)\n+                                   .ifPresent(attributes -> aggregateVersionMembers.add(field));\n+                }\n+                for (Method method : ReflectionUtils.methodsOf(type)) {\n+                    childEntityDefinitions.forEach(def -> def.createChildDefinition(method, this).ifPresent(child -> {\n+                        children.add(child);\n+                        child.commandHandlers().forEach(handler -> addHandler(allCommandHandlers, type, handler));\n+                    }));\n+                    AnnotationUtils.findAnnotationAttributes(method, EntityId.class)\n                                    .ifPresent(attributes -> {\n-                                       if (versionField != null && !field.equals(versionField)) {\n-                                           throw new AggregateModellingException(format(\n-                                                   \"Aggregate [%s] has two version fields [%s] and [%s].\",\n-                                                   inspectedType,\n-                                                   versionField,\n-                                                   field));\n-                                       }\n-                                       versionField = field;\n+                                       assertValidValueProvidingMethod(method);\n+                                       entityIdMembers.add(method);\n+                                   });\n+                    AnnotationUtils.findAnnotationAttributes(method, JAVAX_PERSISTENCE_ID)\n+                                   .ifPresent(attributes -> {\n+                                       assertValidValueProvidingMethod(method);\n+                                       persistenceIdMembers.add(method);\n+                                   });\n+                    AnnotationUtils.findAnnotationAttributes(method, AggregateVersion.class)\n+                                   .ifPresent(attributes -> {\n+                                       assertValidValueProvidingMethod(method);\n+                                       aggregateVersionMembers.add(method);\n                                    });\n                 }\n             }\n-            if (identifierField != null) {\n-                final Class<?> idClazz = identifierField.getType();\n+\n+            findIdentifierMember(distinct(entityIdMembers), distinct(persistenceIdMembers))\n+                    .ifPresent(this::setIdentifierAndRoutingKey);\n+            if (!aggregateVersionMembers.isEmpty()) {\n+                setVersionMember(aggregateVersionMembers.get(0));\n+            }\n+            assertIdentifierValidity(identifierMember);\n+        }\n+\n+        private void setIdentifierAndRoutingKey(Member identifier) {\n+            identifierMember = identifier;\n+            routingKey = findRoutingKey((AccessibleObject) identifier)\n+                    .orElseGet(identifier::getName);\n+        }\n+\n+        private Optional<Member> findIdentifierMember(List<Member> entityIdMembers,\n+                                                      List<Member> persistenceIdMembers) {\n+            if (entityIdMembers.size() > 1) {\n+                throw new AggregateModellingException(format(\n+                        \"Aggregate [%s] has more than one identifier member\",\n+                        inspectedType));\n+            }\n+            if (!entityIdMembers.isEmpty()) {\n+                return Optional.of(entityIdMembers.get(0));\n+            } else if (!persistenceIdMembers.isEmpty()) {\n+                return Optional.of(persistenceIdMembers.get(0));\n+            }\n+            return Optional.empty();\n+        }\n+\n+        private void assertValidValueProvidingMethod(Method method) {\n+            if (method.getParameterCount() != 0) {\n+                throw new AggregateModellingException(format(\n+                        \"Aggregate [%s] has an annotated method [%s] with parameters\",", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDg1NzQ5MA=="}, "originalCommit": {"oid": "ee3b11b9e1708fdabecc2974d1f04904fb0689d5"}, "originalPosition": 227}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODA0OTA3MA==", "bodyText": "Message in the exception has been adjusted to be slightly more specific.", "url": "https://github.com/AxonFramework/AxonFramework/pull/1455#discussion_r458049070", "createdAt": "2020-07-21T12:13:04Z", "author": {"login": "smcvb"}, "path": "modelling/src/main/java/org/axonframework/modelling/command/inspection/AnnotatedAggregateMetaModelFactory.java", "diffHunk": "@@ -303,62 +311,99 @@ private void inspectAggregateTypes() {\n \n         private String findDeclaredType(Class<?> type) {\n             return AnnotationUtils.findAnnotationAttributes(type, AggregateRoot.class)\n-                                  .map(map -> (String) map.get(\"type\")).filter(i -> i.length() > 0).orElse(type.getSimpleName());\n+                                  .map(map -> (String) map.get(\"type\")).filter(i -> i.length() > 0)\n+                                  .orElse(type.getSimpleName());\n         }\n \n-        private void inspectFields() {\n+        private void inspectFieldsAndMethods() {\n             ServiceLoader<ChildEntityDefinition> childEntityDefinitions =\n                     ServiceLoader.load(ChildEntityDefinition.class, inspectedType.getClassLoader());\n-            boolean persistenceId = false;\n+            ArrayList<Member> entityIdMembers = new ArrayList<>();\n+            ArrayList<Member> persistenceIdMembers = new ArrayList<>();\n+            ArrayList<Member> aggregateVersionMembers = new ArrayList<>();\n             for (Class<?> type : handlerInspector.getAllHandlers().keySet()) {\n                 for (Field field : ReflectionUtils.fieldsOf(type)) {\n                     childEntityDefinitions.forEach(def -> def.createChildDefinition(field, this).ifPresent(child -> {\n                         children.add(child);\n-                        child.commandHandlers().forEach(handler -> addHandler(allCommandHandlers,\n-                                                                              type,\n-                                                                              handler));\n+                        child.commandHandlers().forEach(handler -> addHandler(allCommandHandlers, type, handler));\n                     }));\n-\n-                    if (AnnotationUtils.findAnnotationAttributes(field, EntityId.class).isPresent()) {\n-                        if (identifierField != null && !field.equals(identifierField) && !persistenceId) {\n-                            throw new AggregateModellingException(format(\n-                                    \"Aggregate [%s] has two identifier fields [%s] and [%s].\",\n-                                    inspectedType,\n-                                    identifierField,\n-                                    field));\n-                        }\n-                        persistenceId = false;\n-                        identifierField = field;\n-                        Map<String, Object> attributes =\n-                                AnnotationUtils.findAnnotationAttributes(field, EntityId.class).get();\n-                        if (!\"\".equals(attributes.get(\"routingKey\"))) {\n-                            routingKey = (String) attributes.get(\"routingKey\");\n-                        } else {\n-                            routingKey = field.getName();\n-                        }\n-                    }\n-                    if (identifierField == null\n-                            && AnnotationUtils.findAnnotationAttributes(field, \"javax.persistence.Id\")\n-                                              .isPresent()) {\n-                            persistenceId = true;\n-                            identifierField = field;\n-                            routingKey = field.getName();\n-                    }\n+                    AnnotationUtils.findAnnotationAttributes(field, EntityId.class)\n+                                   .ifPresent(attributes -> entityIdMembers.add(field));\n+                    AnnotationUtils.findAnnotationAttributes(field, JAVAX_PERSISTENCE_ID)\n+                                   .ifPresent(attributes -> persistenceIdMembers.add(field));\n                     AnnotationUtils.findAnnotationAttributes(field, AggregateVersion.class)\n+                                   .ifPresent(attributes -> aggregateVersionMembers.add(field));\n+                }\n+                for (Method method : ReflectionUtils.methodsOf(type)) {\n+                    childEntityDefinitions.forEach(def -> def.createChildDefinition(method, this).ifPresent(child -> {\n+                        children.add(child);\n+                        child.commandHandlers().forEach(handler -> addHandler(allCommandHandlers, type, handler));\n+                    }));\n+                    AnnotationUtils.findAnnotationAttributes(method, EntityId.class)\n                                    .ifPresent(attributes -> {\n-                                       if (versionField != null && !field.equals(versionField)) {\n-                                           throw new AggregateModellingException(format(\n-                                                   \"Aggregate [%s] has two version fields [%s] and [%s].\",\n-                                                   inspectedType,\n-                                                   versionField,\n-                                                   field));\n-                                       }\n-                                       versionField = field;\n+                                       assertValidValueProvidingMethod(method);\n+                                       entityIdMembers.add(method);\n+                                   });\n+                    AnnotationUtils.findAnnotationAttributes(method, JAVAX_PERSISTENCE_ID)\n+                                   .ifPresent(attributes -> {\n+                                       assertValidValueProvidingMethod(method);\n+                                       persistenceIdMembers.add(method);\n+                                   });\n+                    AnnotationUtils.findAnnotationAttributes(method, AggregateVersion.class)\n+                                   .ifPresent(attributes -> {\n+                                       assertValidValueProvidingMethod(method);\n+                                       aggregateVersionMembers.add(method);\n                                    });\n                 }\n             }\n-            if (identifierField != null) {\n-                final Class<?> idClazz = identifierField.getType();\n+\n+            findIdentifierMember(distinct(entityIdMembers), distinct(persistenceIdMembers))\n+                    .ifPresent(this::setIdentifierAndRoutingKey);\n+            if (!aggregateVersionMembers.isEmpty()) {\n+                setVersionMember(aggregateVersionMembers.get(0));\n+            }\n+            assertIdentifierValidity(identifierMember);\n+        }\n+\n+        private void setIdentifierAndRoutingKey(Member identifier) {\n+            identifierMember = identifier;\n+            routingKey = findRoutingKey((AccessibleObject) identifier)\n+                    .orElseGet(identifier::getName);\n+        }\n+\n+        private Optional<Member> findIdentifierMember(List<Member> entityIdMembers,\n+                                                      List<Member> persistenceIdMembers) {\n+            if (entityIdMembers.size() > 1) {\n+                throw new AggregateModellingException(format(\n+                        \"Aggregate [%s] has more than one identifier member\",\n+                        inspectedType));\n+            }\n+            if (!entityIdMembers.isEmpty()) {\n+                return Optional.of(entityIdMembers.get(0));\n+            } else if (!persistenceIdMembers.isEmpty()) {\n+                return Optional.of(persistenceIdMembers.get(0));\n+            }\n+            return Optional.empty();\n+        }\n+\n+        private void assertValidValueProvidingMethod(Method method) {\n+            if (method.getParameterCount() != 0) {\n+                throw new AggregateModellingException(format(\n+                        \"Aggregate [%s] has an annotated method [%s] with parameters\",", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDg1NzQ5MA=="}, "originalCommit": {"oid": "ee3b11b9e1708fdabecc2974d1f04904fb0689d5"}, "originalPosition": 227}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc3MjAwNTM2OnYy", "diffSide": "RIGHT", "path": "modelling/src/main/java/org/axonframework/modelling/command/ForwardingMode.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNFQxMzoxMTowM1rOGoRZyw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMFQxNjoyNToxMVrOG0V3jA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDg4MTM1NQ==", "bodyText": "Somewhat of a bummer, but this isn't backwards compatible. Than again, chances are slim users have implemented this themselves...let's discuss whether we should go forward with this or deprecate the Field methods and add a Member method.\nThe latter would introduce a similar change as you did for the AbstractChildEntityDefinition#isFieldTypeSupported(Field), on all the methods where Field has been replaced by Member.", "url": "https://github.com/AxonFramework/AxonFramework/pull/1455#discussion_r444881355", "createdAt": "2020-06-24T13:11:03Z", "author": {"login": "smcvb"}, "path": "modelling/src/main/java/org/axonframework/modelling/command/ForwardingMode.java", "diffHunk": "@@ -34,12 +34,12 @@\n     /**\n      * Initializes an instance of a {@link ForwardingMode}.\n      *\n-     * @param field       The {@link java.lang.reflect.Field} to apply a ForwardingMode on. Provided to be able to check\n+     * @param member      The {@link java.lang.reflect.Member} to apply a ForwardingMode on. Provided to be able to check\n      *                    for annotations attributes which might assist in the forwarding process.\n      * @param childEntity A {@link EntityModel} constructed from the\n      *                    given {@code field}.\n      */\n-    default void initialize(Field field, EntityModel childEntity) {\n+    default void initialize(Member member, EntityModel childEntity) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ee3b11b9e1708fdabecc2974d1f04904fb0689d5"}, "originalPosition": 20}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzUzNzQyMA==", "bodyText": "Resolved through internal discussion to be a none issue.", "url": "https://github.com/AxonFramework/AxonFramework/pull/1455#discussion_r457537420", "createdAt": "2020-07-20T16:25:11Z", "author": {"login": "smcvb"}, "path": "modelling/src/main/java/org/axonframework/modelling/command/ForwardingMode.java", "diffHunk": "@@ -34,12 +34,12 @@\n     /**\n      * Initializes an instance of a {@link ForwardingMode}.\n      *\n-     * @param field       The {@link java.lang.reflect.Field} to apply a ForwardingMode on. Provided to be able to check\n+     * @param member      The {@link java.lang.reflect.Member} to apply a ForwardingMode on. Provided to be able to check\n      *                    for annotations attributes which might assist in the forwarding process.\n      * @param childEntity A {@link EntityModel} constructed from the\n      *                    given {@code field}.\n      */\n-    default void initialize(Field field, EntityModel childEntity) {\n+    default void initialize(Member member, EntityModel childEntity) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDg4MTM1NQ=="}, "originalCommit": {"oid": "ee3b11b9e1708fdabecc2974d1f04904fb0689d5"}, "originalPosition": 20}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc3MjAxMjk0OnYy", "diffSide": "LEFT", "path": "modelling/src/main/java/org/axonframework/modelling/command/inspection/AbstractChildEntityDefinition.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNFQxMzoxMzowNFrOGoResg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMFQxNjoyNToxNlrOG0V3zA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDg4MjYxMA==", "bodyText": "Same backwards compatibility argument we need to discuss.", "url": "https://github.com/AxonFramework/AxonFramework/pull/1455#discussion_r444882610", "createdAt": "2020-06-24T13:13:04Z", "author": {"login": "smcvb"}, "path": "modelling/src/main/java/org/axonframework/modelling/command/inspection/AbstractChildEntityDefinition.java", "diffHunk": "@@ -72,31 +76,41 @@\n      *\n      * @param field a {@link java.lang.reflect.Field} containing a Child Entity\n      * @return true if the type is as required by the implementation and false if it is not\n+     * @deprecated\n      */\n+    @Deprecated\n     protected abstract boolean isFieldTypeSupported(Field field);\n \n+    /**\n+     * Check whether the given {@link java.lang.reflect.Member} is of a type supported by this definition.\n+     *\n+     * @param member a {@link java.lang.reflect.Member} containing or returning a Child Entity\n+     * @return true if the type is as required by the implementation and false if it is not\n+     */\n+    protected abstract boolean isMemberTypeSupported(Member member);\n+\n     /**\n      * Extracts the Child Entity contained in the given {@code declaringEntity} as an {@link EntityModel}.\n      * The type of the Child Entity is defined through a key in the provided {@code attributes} or based on given\n      * {@link java.lang.reflect.Field}.\n      *\n      * @param declaringEntity the {@link EntityModel} declaring the given {@code field}\n      * @param attributes      a {@link java.util.Map} containing the {@link AggregateMember} attributes\n-     * @param field           the {@link java.lang.reflect.Field} containing the Child Entity.\n+     * @param member          the {@link java.lang.reflect.Member} containing the Child Entity.\n      * @param <T>             the type {@code T} of the given {@code declaringEntity} {@link EntityModel}\n      * @return the Child Entity contained in the {@code declaringEntity}\n      */\n     protected abstract <T> EntityModel<Object> extractChildEntityModel(EntityModel<T> declaringEntity,\n                                                                        Map<String, Object> attributes,\n-                                                                       Field field);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ee3b11b9e1708fdabecc2974d1f04904fb0689d5"}, "originalPosition": 79}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzUzNzQ4NA==", "bodyText": "Resolved through internal discussion to be a none issue.", "url": "https://github.com/AxonFramework/AxonFramework/pull/1455#discussion_r457537484", "createdAt": "2020-07-20T16:25:16Z", "author": {"login": "smcvb"}, "path": "modelling/src/main/java/org/axonframework/modelling/command/inspection/AbstractChildEntityDefinition.java", "diffHunk": "@@ -72,31 +76,41 @@\n      *\n      * @param field a {@link java.lang.reflect.Field} containing a Child Entity\n      * @return true if the type is as required by the implementation and false if it is not\n+     * @deprecated\n      */\n+    @Deprecated\n     protected abstract boolean isFieldTypeSupported(Field field);\n \n+    /**\n+     * Check whether the given {@link java.lang.reflect.Member} is of a type supported by this definition.\n+     *\n+     * @param member a {@link java.lang.reflect.Member} containing or returning a Child Entity\n+     * @return true if the type is as required by the implementation and false if it is not\n+     */\n+    protected abstract boolean isMemberTypeSupported(Member member);\n+\n     /**\n      * Extracts the Child Entity contained in the given {@code declaringEntity} as an {@link EntityModel}.\n      * The type of the Child Entity is defined through a key in the provided {@code attributes} or based on given\n      * {@link java.lang.reflect.Field}.\n      *\n      * @param declaringEntity the {@link EntityModel} declaring the given {@code field}\n      * @param attributes      a {@link java.util.Map} containing the {@link AggregateMember} attributes\n-     * @param field           the {@link java.lang.reflect.Field} containing the Child Entity.\n+     * @param member          the {@link java.lang.reflect.Member} containing the Child Entity.\n      * @param <T>             the type {@code T} of the given {@code declaringEntity} {@link EntityModel}\n      * @return the Child Entity contained in the {@code declaringEntity}\n      */\n     protected abstract <T> EntityModel<Object> extractChildEntityModel(EntityModel<T> declaringEntity,\n                                                                        Map<String, Object> attributes,\n-                                                                       Field field);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDg4MjYxMA=="}, "originalCommit": {"oid": "ee3b11b9e1708fdabecc2974d1f04904fb0689d5"}, "originalPosition": 79}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc3MjAxNDE5OnYy", "diffSide": "RIGHT", "path": "modelling/src/main/java/org/axonframework/modelling/command/inspection/AbstractChildEntityDefinition.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNFQxMzoxMzoyNVrOGoRffg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMFQxNjoyNToyMFrOG0V37A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDg4MjgxNA==", "bodyText": "Same backwards compatibility argument we need to discuss.", "url": "https://github.com/AxonFramework/AxonFramework/pull/1455#discussion_r444882814", "createdAt": "2020-06-24T13:13:25Z", "author": {"login": "smcvb"}, "path": "modelling/src/main/java/org/axonframework/modelling/command/inspection/AbstractChildEntityDefinition.java", "diffHunk": "@@ -113,28 +127,28 @@ private ForwardingMode instantiateForwardingMode(Field field,\n      * @param msg              the {@link org.axonframework.commandhandling.CommandMessage} which is being resolved to a\n      *                         target entity\n      * @param parent           the {@code parent} Entity of type {@code T} of this Child Entity\n-     * @param field            the {@link java.lang.reflect.Field} containing the Child Entity.\n+     * @param member           the {@link java.lang.reflect.Member} containing the Child Entity.\n      * @param childEntityModel the {@link EntityModel} for the Child Entity\n      * @param <T>              the type {@code T} of the given {@code parent} Entity\n      * @return the Child Entity which is the target of the incoming {@link org.axonframework.commandhandling.CommandMessage}.\n      */\n     protected abstract <T> Object resolveCommandTarget(CommandMessage<?> msg,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ee3b11b9e1708fdabecc2974d1f04904fb0689d5"}, "originalPosition": 104}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzUzNzUxNg==", "bodyText": "Resolved through internal discussion to be a none issue.", "url": "https://github.com/AxonFramework/AxonFramework/pull/1455#discussion_r457537516", "createdAt": "2020-07-20T16:25:20Z", "author": {"login": "smcvb"}, "path": "modelling/src/main/java/org/axonframework/modelling/command/inspection/AbstractChildEntityDefinition.java", "diffHunk": "@@ -113,28 +127,28 @@ private ForwardingMode instantiateForwardingMode(Field field,\n      * @param msg              the {@link org.axonframework.commandhandling.CommandMessage} which is being resolved to a\n      *                         target entity\n      * @param parent           the {@code parent} Entity of type {@code T} of this Child Entity\n-     * @param field            the {@link java.lang.reflect.Field} containing the Child Entity.\n+     * @param member           the {@link java.lang.reflect.Member} containing the Child Entity.\n      * @param childEntityModel the {@link EntityModel} for the Child Entity\n      * @param <T>              the type {@code T} of the given {@code parent} Entity\n      * @return the Child Entity which is the target of the incoming {@link org.axonframework.commandhandling.CommandMessage}.\n      */\n     protected abstract <T> Object resolveCommandTarget(CommandMessage<?> msg,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDg4MjgxNA=="}, "originalCommit": {"oid": "ee3b11b9e1708fdabecc2974d1f04904fb0689d5"}, "originalPosition": 104}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc3MjAxNDg4OnYy", "diffSide": "RIGHT", "path": "modelling/src/main/java/org/axonframework/modelling/command/inspection/AbstractChildEntityDefinition.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNFQxMzoxMzozNlrOGoRf7g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMFQxNjoyNToyOFrOG0V4RQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDg4MjkyNg==", "bodyText": "Same backwards compatibility argument we need to discuss.", "url": "https://github.com/AxonFramework/AxonFramework/pull/1455#discussion_r444882926", "createdAt": "2020-06-24T13:13:36Z", "author": {"login": "smcvb"}, "path": "modelling/src/main/java/org/axonframework/modelling/command/inspection/AbstractChildEntityDefinition.java", "diffHunk": "@@ -113,28 +127,28 @@ private ForwardingMode instantiateForwardingMode(Field field,\n      * @param msg              the {@link org.axonframework.commandhandling.CommandMessage} which is being resolved to a\n      *                         target entity\n      * @param parent           the {@code parent} Entity of type {@code T} of this Child Entity\n-     * @param field            the {@link java.lang.reflect.Field} containing the Child Entity.\n+     * @param member           the {@link java.lang.reflect.Member} containing the Child Entity.\n      * @param childEntityModel the {@link EntityModel} for the Child Entity\n      * @param <T>              the type {@code T} of the given {@code parent} Entity\n      * @return the Child Entity which is the target of the incoming {@link org.axonframework.commandhandling.CommandMessage}.\n      */\n     protected abstract <T> Object resolveCommandTarget(CommandMessage<?> msg,\n                                                        T parent,\n-                                                       Field field,\n+                                                       Member member,\n                                                        EntityModel<Object> childEntityModel);\n \n     /**\n      * Retrieves the routing keys of every command handler on the given {@code childEntityModel} to be able to correctly\n      * route commands to Entities.\n      *\n-     * @param field            a {@link java.lang.reflect.Field} denoting the Child Entity upon which the\n+     * @param member           a {@link java.lang.reflect.Member} denoting the Child Entity upon which the\n      *                         {@code childEntityModel} is based\n      * @param childEntityModel a {@link EntityModel} to retrieve the routing key properties from\n      * @return a {@link java.util.Map} of key/value types {@link java.lang.String}\n      * {@link org.axonframework.common.property.Property} from Command Message name to routing key\n      */\n     @SuppressWarnings(\"WeakerAccess\")\n-    protected Map<String, Property<Object>> extractCommandHandlerRoutingKeys(Field field,\n+    protected Map<String, Property<Object>> extractCommandHandlerRoutingKeys(Member member,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ee3b11b9e1708fdabecc2974d1f04904fb0689d5"}, "originalPosition": 123}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzUzNzYwNQ==", "bodyText": "Resolved through internal discussion to be a none issue.", "url": "https://github.com/AxonFramework/AxonFramework/pull/1455#discussion_r457537605", "createdAt": "2020-07-20T16:25:28Z", "author": {"login": "smcvb"}, "path": "modelling/src/main/java/org/axonframework/modelling/command/inspection/AbstractChildEntityDefinition.java", "diffHunk": "@@ -113,28 +127,28 @@ private ForwardingMode instantiateForwardingMode(Field field,\n      * @param msg              the {@link org.axonframework.commandhandling.CommandMessage} which is being resolved to a\n      *                         target entity\n      * @param parent           the {@code parent} Entity of type {@code T} of this Child Entity\n-     * @param field            the {@link java.lang.reflect.Field} containing the Child Entity.\n+     * @param member           the {@link java.lang.reflect.Member} containing the Child Entity.\n      * @param childEntityModel the {@link EntityModel} for the Child Entity\n      * @param <T>              the type {@code T} of the given {@code parent} Entity\n      * @return the Child Entity which is the target of the incoming {@link org.axonframework.commandhandling.CommandMessage}.\n      */\n     protected abstract <T> Object resolveCommandTarget(CommandMessage<?> msg,\n                                                        T parent,\n-                                                       Field field,\n+                                                       Member member,\n                                                        EntityModel<Object> childEntityModel);\n \n     /**\n      * Retrieves the routing keys of every command handler on the given {@code childEntityModel} to be able to correctly\n      * route commands to Entities.\n      *\n-     * @param field            a {@link java.lang.reflect.Field} denoting the Child Entity upon which the\n+     * @param member           a {@link java.lang.reflect.Member} denoting the Child Entity upon which the\n      *                         {@code childEntityModel} is based\n      * @param childEntityModel a {@link EntityModel} to retrieve the routing key properties from\n      * @return a {@link java.util.Map} of key/value types {@link java.lang.String}\n      * {@link org.axonframework.common.property.Property} from Command Message name to routing key\n      */\n     @SuppressWarnings(\"WeakerAccess\")\n-    protected Map<String, Property<Object>> extractCommandHandlerRoutingKeys(Field field,\n+    protected Map<String, Property<Object>> extractCommandHandlerRoutingKeys(Member member,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDg4MjkyNg=="}, "originalCommit": {"oid": "ee3b11b9e1708fdabecc2974d1f04904fb0689d5"}, "originalPosition": 123}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc3MjAxNTk3OnYy", "diffSide": "RIGHT", "path": "modelling/src/main/java/org/axonframework/modelling/command/inspection/AbstractChildEntityDefinition.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNFQxMzoxMzo1NFrOGoRgpw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMFQxNjoyNTozM1rOG0V4dw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDg4MzExMQ==", "bodyText": "Same backwards compatibility argument we need to discuss.", "url": "https://github.com/AxonFramework/AxonFramework/pull/1455#discussion_r444883111", "createdAt": "2020-06-24T13:13:54Z", "author": {"login": "smcvb"}, "path": "modelling/src/main/java/org/axonframework/modelling/command/inspection/AbstractChildEntityDefinition.java", "diffHunk": "@@ -196,7 +210,7 @@ private ForwardingMode instantiateForwardingMode(Field field,\n      */\n     protected abstract <T> Stream<Object> resolveEventTargets(EventMessage message,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ee3b11b9e1708fdabecc2974d1f04904fb0689d5"}, "originalPosition": 169}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzUzNzY1NQ==", "bodyText": "Resolved through internal discussion to be a none issue.", "url": "https://github.com/AxonFramework/AxonFramework/pull/1455#discussion_r457537655", "createdAt": "2020-07-20T16:25:33Z", "author": {"login": "smcvb"}, "path": "modelling/src/main/java/org/axonframework/modelling/command/inspection/AbstractChildEntityDefinition.java", "diffHunk": "@@ -196,7 +210,7 @@ private ForwardingMode instantiateForwardingMode(Field field,\n      */\n     protected abstract <T> Stream<Object> resolveEventTargets(EventMessage message,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDg4MzExMQ=="}, "originalCommit": {"oid": "ee3b11b9e1708fdabecc2974d1f04904fb0689d5"}, "originalPosition": 169}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc3MjAxODMxOnYy", "diffSide": "LEFT", "path": "modelling/src/main/java/org/axonframework/modelling/command/inspection/ChildEntityDefinition.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNFQxMzoxNDoyM1rOGoRiAQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMFQxNjoyNTozOFrOG0V4oQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDg4MzQ1Nw==", "bodyText": "Same backwards compatibility argument we need to discuss.", "url": "https://github.com/AxonFramework/AxonFramework/pull/1455#discussion_r444883457", "createdAt": "2020-06-24T13:14:23Z", "author": {"login": "smcvb"}, "path": "modelling/src/main/java/org/axonframework/modelling/command/inspection/ChildEntityDefinition.java", "diffHunk": "@@ -29,14 +29,14 @@\n public interface ChildEntityDefinition {\n \n     /**\n-     * Inspect the given {@code field}, which is declared on the given {@code declaringEntity} for the presence of a\n+     * Inspect the given {@code member}, which is declared on the given {@code declaringEntity} for the presence of a\n      * Child Entity.\n      *\n-     * @param field           The field potentially containing a Child entity\n+     * @param member          The member potentially containing a Child entity\n      * @param declaringEntity The entity model declaring the field\n      * @param <T>             The type of entity on which the field is declared\n      * @return an optional that resolved to a ChildEntity if the field represents a child.\n      */\n-    <T> Optional<ChildEntity<T>> createChildDefinition(Field field, EntityModel<T> declaringEntity);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ee3b11b9e1708fdabecc2974d1f04904fb0689d5"}, "originalPosition": 23}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzUzNzY5Nw==", "bodyText": "Resolved through internal discussion to be a none issue.", "url": "https://github.com/AxonFramework/AxonFramework/pull/1455#discussion_r457537697", "createdAt": "2020-07-20T16:25:38Z", "author": {"login": "smcvb"}, "path": "modelling/src/main/java/org/axonframework/modelling/command/inspection/ChildEntityDefinition.java", "diffHunk": "@@ -29,14 +29,14 @@\n public interface ChildEntityDefinition {\n \n     /**\n-     * Inspect the given {@code field}, which is declared on the given {@code declaringEntity} for the presence of a\n+     * Inspect the given {@code member}, which is declared on the given {@code declaringEntity} for the presence of a\n      * Child Entity.\n      *\n-     * @param field           The field potentially containing a Child entity\n+     * @param member          The member potentially containing a Child entity\n      * @param declaringEntity The entity model declaring the field\n      * @param <T>             The type of entity on which the field is declared\n      * @return an optional that resolved to a ChildEntity if the field represents a child.\n      */\n-    <T> Optional<ChildEntity<T>> createChildDefinition(Field field, EntityModel<T> declaringEntity);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDg4MzQ1Nw=="}, "originalCommit": {"oid": "ee3b11b9e1708fdabecc2974d1f04904fb0689d5"}, "originalPosition": 23}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc3MjIyODc3OnYy", "diffSide": "RIGHT", "path": "modelling/src/test/java/org/axonframework/modelling/command/inspection/AnnotatedAggregateMetaModelFactoryTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNFQxNDowMjo1NVrOGoTleg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNFQxNDowMjo1NVrOGoTleg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDkxNzExNA==", "bodyText": "When matching the models' routing key with the routing key in the @CommandHandler, it is expected to be identical to the property name in the command. So, not the method name, as is being validated here. As such, we should remove any get prepending the routing key if it comes from a method.", "url": "https://github.com/AxonFramework/AxonFramework/pull/1455#discussion_r444917114", "createdAt": "2020-06-24T14:02:55Z", "author": {"login": "smcvb"}, "path": "modelling/src/test/java/org/axonframework/modelling/command/inspection/AnnotatedAggregateMetaModelFactoryTest.java", "diffHunk": "@@ -247,6 +267,26 @@ void testFindIdentifier() {\n         assertEquals(\"id\", inspector.routingKey());\n     }\n \n+    @Test\n+    void testFindGetterIdentifier() {\n+        AggregateModel<SomeGetterIdAnnotatedHandlers> inspector =\n+                AnnotatedAggregateMetaModelFactory.inspectAggregate(SomeGetterIdAnnotatedHandlers.class);\n+\n+        assertEquals(\"SomeGetterIdAnnotatedHandlers\", inspector.type());\n+        assertEquals(\"id\", inspector.getIdentifier(new SomeGetterIdAnnotatedHandlers()));\n+        assertEquals(\"getId\", inspector.routingKey());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ee3b11b9e1708fdabecc2974d1f04904fb0689d5"}, "originalPosition": 38}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc3MjIzNjM5OnYy", "diffSide": "RIGHT", "path": "modelling/src/test/java/org/axonframework/modelling/command/inspection/AnnotatedAggregateMetaModelFactoryTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNFQxNDowNDo1OVrOGoTqug==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMVQxMjoxMjoyMFrOG01EvQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDkxODQ1OA==", "bodyText": "This scenario would be a valid use case where the routingKey should be set on the @EntityId/@AggregateIdentifier. Would be smart to be specific about this in the javadoc too.", "url": "https://github.com/AxonFramework/AxonFramework/pull/1455#discussion_r444918458", "createdAt": "2020-06-24T14:04:59Z", "author": {"login": "smcvb"}, "path": "modelling/src/test/java/org/axonframework/modelling/command/inspection/AnnotatedAggregateMetaModelFactoryTest.java", "diffHunk": "@@ -247,6 +267,26 @@ void testFindIdentifier() {\n         assertEquals(\"id\", inspector.routingKey());\n     }\n \n+    @Test\n+    void testFindGetterIdentifier() {\n+        AggregateModel<SomeGetterIdAnnotatedHandlers> inspector =\n+                AnnotatedAggregateMetaModelFactory.inspectAggregate(SomeGetterIdAnnotatedHandlers.class);\n+\n+        assertEquals(\"SomeGetterIdAnnotatedHandlers\", inspector.type());\n+        assertEquals(\"id\", inspector.getIdentifier(new SomeGetterIdAnnotatedHandlers()));\n+        assertEquals(\"getId\", inspector.routingKey());\n+    }\n+\n+    @Test\n+    void testFindMethodIdentifier() {\n+        AggregateModel<SomeMethodIdAnnotatedHandlers> inspector =\n+                AnnotatedAggregateMetaModelFactory.inspectAggregate(SomeMethodIdAnnotatedHandlers.class);\n+\n+        assertEquals(\"SomeMethodIdAnnotatedHandlers\", inspector.type());\n+        assertEquals(\"id\", inspector.getIdentifier(new SomeMethodIdAnnotatedHandlers()));\n+        assertEquals(\"calculatedId\", inspector.routingKey());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ee3b11b9e1708fdabecc2974d1f04904fb0689d5"}, "originalPosition": 48}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODA0ODcwMQ==", "bodyText": "Javadoc for the @EntityId and @AggregateIdentifier has been adjusted to clarify this.", "url": "https://github.com/AxonFramework/AxonFramework/pull/1455#discussion_r458048701", "createdAt": "2020-07-21T12:12:20Z", "author": {"login": "smcvb"}, "path": "modelling/src/test/java/org/axonframework/modelling/command/inspection/AnnotatedAggregateMetaModelFactoryTest.java", "diffHunk": "@@ -247,6 +267,26 @@ void testFindIdentifier() {\n         assertEquals(\"id\", inspector.routingKey());\n     }\n \n+    @Test\n+    void testFindGetterIdentifier() {\n+        AggregateModel<SomeGetterIdAnnotatedHandlers> inspector =\n+                AnnotatedAggregateMetaModelFactory.inspectAggregate(SomeGetterIdAnnotatedHandlers.class);\n+\n+        assertEquals(\"SomeGetterIdAnnotatedHandlers\", inspector.type());\n+        assertEquals(\"id\", inspector.getIdentifier(new SomeGetterIdAnnotatedHandlers()));\n+        assertEquals(\"getId\", inspector.routingKey());\n+    }\n+\n+    @Test\n+    void testFindMethodIdentifier() {\n+        AggregateModel<SomeMethodIdAnnotatedHandlers> inspector =\n+                AnnotatedAggregateMetaModelFactory.inspectAggregate(SomeMethodIdAnnotatedHandlers.class);\n+\n+        assertEquals(\"SomeMethodIdAnnotatedHandlers\", inspector.type());\n+        assertEquals(\"id\", inspector.getIdentifier(new SomeMethodIdAnnotatedHandlers()));\n+        assertEquals(\"calculatedId\", inspector.routingKey());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDkxODQ1OA=="}, "originalCommit": {"oid": "ee3b11b9e1708fdabecc2974d1f04904fb0689d5"}, "originalPosition": 48}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc3MjI4NTEzOnYy", "diffSide": "RIGHT", "path": "modelling/src/test/java/org/axonframework/modelling/command/inspection/AnnotatedAggregateMetaModelFactoryTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNFQxNDoxNjowOFrOGoUJaA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNFQxNDoxNjowOFrOGoUJaA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDkyNjMxMg==", "bodyText": "This case, when users only provide an @Id field, is obviously rather problematic on a method. Not sure we can do anything about this...", "url": "https://github.com/AxonFramework/AxonFramework/pull/1455#discussion_r444926312", "createdAt": "2020-06-24T14:16:08Z", "author": {"login": "smcvb"}, "path": "modelling/src/test/java/org/axonframework/modelling/command/inspection/AnnotatedAggregateMetaModelFactoryTest.java", "diffHunk": "@@ -256,6 +296,24 @@ void testFindJavaxPersistenceIdentifier() {\n         assertEquals(\"id\", inspector.routingKey());\n     }\n \n+    @Test\n+    void testFindJavaxPersistenceGetterIdentifier() {\n+        AggregateModel<JavaxPersistenceGetterAnnotatedHandlers> inspector =\n+                AnnotatedAggregateMetaModelFactory.inspectAggregate(JavaxPersistenceGetterAnnotatedHandlers.class);\n+\n+        assertEquals(\"id\", inspector.getIdentifier(new JavaxPersistenceGetterAnnotatedHandlers()));\n+        assertEquals(\"getId\", inspector.routingKey());\n+    }\n+\n+    @Test\n+    void testFindJavaxPersistenceMethodIdentifier() {\n+        AggregateModel<JavaxPersistenceMethodIdAnnotatedHandlers> inspector =\n+                AnnotatedAggregateMetaModelFactory.inspectAggregate(JavaxPersistenceMethodIdAnnotatedHandlers.class);\n+\n+        assertEquals(\"id\", inspector.getIdentifier(new JavaxPersistenceMethodIdAnnotatedHandlers()));\n+        assertEquals(\"calculatedId\", inspector.routingKey());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ee3b11b9e1708fdabecc2974d1f04904fb0689d5"}, "originalPosition": 73}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc3MjI5NjQ0OnYy", "diffSide": "RIGHT", "path": "modelling/src/test/java/org/axonframework/modelling/command/inspection/AnnotatedAggregateMetaModelFactoryTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNFQxNDoxODo0MFrOGoUQjA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNFQxNDoxODo0MFrOGoUQjA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDkyODE0MA==", "bodyText": "Shouldn't GetterTypedIdentifierAggregate be used for this test instead of TypedIdentifierAggregate?", "url": "https://github.com/AxonFramework/AxonFramework/pull/1455#discussion_r444928140", "createdAt": "2020-06-24T14:18:40Z", "author": {"login": "smcvb"}, "path": "modelling/src/test/java/org/axonframework/modelling/command/inspection/AnnotatedAggregateMetaModelFactoryTest.java", "diffHunk": "@@ -302,6 +370,33 @@ void typedAggregateIdentifier() {\n                 () -> AnnotatedAggregateMetaModelFactory.inspectAggregate(TypedIdentifierAggregate.class));\n     }\n \n+    @Test\n+    void testGetterTypedAggregateIdentifier() {\n+        assertThrows(\n+                AxonConfigurationException.class,\n+                () -> AnnotatedAggregateMetaModelFactory.inspectAggregate(TypedIdentifierAggregate.class));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ee3b11b9e1708fdabecc2974d1f04904fb0689d5"}, "originalPosition": 113}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg2NjQwNzIxOnYy", "diffSide": "RIGHT", "path": "modelling/src/main/java/org/axonframework/modelling/command/inspection/AbstractChildEntityDefinition.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yM1QwODo1NDozNFrOG2BzSg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yM1QwODo1NDozNFrOG2BzSg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTMwNTgwMg==", "bodyText": "Why not remove abstract from this method and invoke isMemberTypeSupported. Having it this way, you could remove \"dummy\" impls from children of this class.", "url": "https://github.com/AxonFramework/AxonFramework/pull/1455#discussion_r459305802", "createdAt": "2020-07-23T08:54:34Z", "author": {"login": "m1l4n54v1c"}, "path": "modelling/src/main/java/org/axonframework/modelling/command/inspection/AbstractChildEntityDefinition.java", "diffHunk": "@@ -47,56 +50,68 @@\n \n     @SuppressWarnings(\"unchecked\")  // Suppresses cast to Class of ForwardingMode\n     @Override\n-    public <T> Optional<ChildEntity<T>> createChildDefinition(Field field, EntityModel<T> declaringEntity) {\n-        Map<String, Object> attributes = findAnnotationAttributes(field, AggregateMember.class).orElse(null);\n-        if (attributes == null || !isFieldTypeSupported(field)) {\n+    public <T> Optional<ChildEntity<T>> createChildDefinition(Member member, EntityModel<T> declaringEntity) {\n+        Map<String, Object> attributes =\n+                findAnnotationAttributes((AnnotatedElement) member, AggregateMember.class).orElse(null);\n+        if (attributes == null || !isMemberTypeSupported(member)) {\n             return Optional.empty();\n         }\n \n-        EntityModel<Object> childEntityModel = extractChildEntityModel(declaringEntity, attributes, field);\n+        EntityModel<Object> childEntityModel = extractChildEntityModel(declaringEntity, attributes, member);\n \n-        ForwardingMode eventForwardingMode = instantiateForwardingMode(\n-                field, childEntityModel, (Class<? extends ForwardingMode>) attributes.get(\"eventForwardingMode\")\n+        ForwardingMode<EventMessage<?>> eventForwardingMode = instantiateForwardingMode(\n+                member,\n+                childEntityModel,\n+                (Class<? extends ForwardingMode<EventMessage<?>>>) attributes.get(\"eventForwardingMode\")\n         );\n \n         return Optional.of(new AnnotatedChildEntity<>(\n                 childEntityModel,\n                 (Boolean) attributes.get(\"forwardCommands\"),\n-                (msg, parent) -> resolveCommandTarget(msg, parent, field, childEntityModel),\n-                (msg, parent) -> resolveEventTargets(msg, parent, field, eventForwardingMode)\n+                (msg, parent) -> resolveCommandTarget(msg, parent, member, childEntityModel),\n+                (msg, parent) -> resolveEventTargets(msg, parent, member, eventForwardingMode)\n         ));\n     }\n \n     /**\n-     * Check whether the given {@link java.lang.reflect.Field} is of a type supported by this definition.\n+     * Check whether the given {@link Field} is of a type supported by this definition.\n      *\n-     * @param field a {@link java.lang.reflect.Field} containing a Child Entity\n+     * @param field a {@link Field} containing a Child Entity\n      * @return true if the type is as required by the implementation and false if it is not\n+     * @deprecated in favour of {@link #isMemberTypeSupported(Member)}\n      */\n+    @Deprecated\n     protected abstract boolean isFieldTypeSupported(Field field);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e3e7fd4e39613e5a6bd01eb60f9870f6d9fc1912"}, "originalPosition": 68}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3211, "cost": 1, "resetAt": "2021-11-12T11:18:39Z"}}}