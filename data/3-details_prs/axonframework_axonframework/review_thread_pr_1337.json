{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzcxMjQyODU2", "number": 1337, "reviewThreads": {"totalCount": 104, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMFQxMjoxMjozOVrOEQJICA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOFQwNzo0MzowMVrOESsRmg==", "hasNextPage": false, "hasPreviousPage": true}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg1MzYyMTg0OnYy", "diffSide": "RIGHT", "path": "messaging/src/main/java/org/axonframework/queryhandling/ReactorQueryGateway.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMFQxMjoxMjozOVrOG0I_yg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMFQxMjoxMjozOVrOG0I_yg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzMyNjUzOA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * Should be used when initial result contains multiple instances of response type and needs to be flatten.\n          \n          \n            \n                 * Should be used when initial result contains multiple instances of response type and needs to be flattened.", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r457326538", "createdAt": "2020-07-20T12:12:39Z", "author": {"login": "sandjelkovic"}, "path": "messaging/src/main/java/org/axonframework/queryhandling/ReactorQueryGateway.java", "diffHunk": "@@ -0,0 +1,547 @@\n+/*\n+ * Copyright (c) 2010-2020. Axon Framework\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.axonframework.queryhandling;\n+\n+import org.axonframework.messaging.ResultMessage;\n+import org.axonframework.messaging.reactive.ReactorMessageDispatchInterceptorSupport;\n+import org.axonframework.messaging.reactive.ReactorResultHandlerInterceptorSupport;\n+import org.axonframework.messaging.responsetypes.ResponseType;\n+import org.axonframework.messaging.responsetypes.ResponseTypes;\n+import org.reactivestreams.Publisher;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Mono;\n+import reactor.util.concurrent.Queues;\n+\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Function;\n+\n+/**\n+ * Variation of the {@link QueryGateway}, wrapping a {@link QueryBus} for a friendlier API. Provides support for reactive return types such as {@link Mono} and {@link Flux}\n+ * from Project Reactor.\n+ *\n+ * @author Milan Savic\n+ * @since 4.4\n+ */\n+public interface ReactorQueryGateway extends ReactorMessageDispatchInterceptorSupport<QueryMessage<?, ?>>,\n+        ReactorResultHandlerInterceptorSupport<QueryMessage<?, ?>, ResultMessage<?>> {\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response with the given {@code responseType}\n+     * from a single source. The query name will be derived from the provided {@code query}. Execution may be\n+     * asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param query        The {@code query} to be sent\n+     * @param responseType A {@link Class} describing the desired response type\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(Q query, Class<R> responseType) {\n+        return query(query.getClass().getName(), query, responseType);\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response with the given {@code responseType}\n+     * from a single source. Execution may be asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(String queryName, Q query, Class<R> responseType) {\n+        return query(queryName, query, ResponseTypes.instanceOf(responseType));\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from a single source. The query name will be derived from the provided {@code query}. Execution may be\n+     * asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(Q query, ResponseType<R> responseType) {\n+        return query(query.getClass().getName(), query, responseType);\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from a single source. Execution may be asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    <R, Q> Mono<R> query(String queryName, Q query, ResponseType<R> responseType);\n+\n+    /**\n+     * Uses given Publisher of query messages to send incoming queries away. Queries will be sent sequentially - once a\n+     * result of Nth query arrives, (N + 1)th query is dispatched.\n+     *\n+     * @param queries a Publisher stream of queries to be dispatched\n+     * @return a Flux of query results. An ordering of query results corresponds to an ordering of queries being\n+     * dispatched\n+     *\n+     * @see #query(String, Object, ResponseType)\n+     * @see Flux#concatMap(Function)\n+     */\n+    default Flux<Object> query(Publisher<QueryMessage<?, ?>> queries) {\n+        return Flux.from(queries)\n+                   .concatMap(q -> query(q.getQueryName(), q.getPayload(), q.getResponseType()));\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from several sources. The returned {@link Flux} is completed when a {@code timeout} occurs or when all possible\n+     * results are received. The query name will be derived from the provided {@code query}. Execution may be\n+     * asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     * <b>Note</b>: Any {@code null} results will be filtered out by the {@link ReactorQueryGateway}. If you require\n+     * the {@code null} to be returned, we suggest using {@code QueryBus} instead.\n+     *\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param timeout      A timeout of {@code long} for the query\n+     * @param timeUnit     The selected {@link TimeUnit} for the given {@code timeout}\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Flux} containing the query results as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Flux<R> scatterGather(Q query, ResponseType<R> responseType, long timeout, TimeUnit timeUnit) {\n+        return scatterGather(query.getClass().getName(), query, responseType, timeout, timeUnit);\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from several sources. The returned {@link Flux} is completed when a {@code timeout} occurs or when all results\n+     * are received. Execution may be asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     * <b>Note</b>: Any {@code null} results will be filtered out by the {@link ReactorQueryGateway}. If you require\n+     * the {@code null} to be returned, we suggest using {@code QueryBus} instead.\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param timeout      A timeout of {@code long} for the query\n+     * @param timeUnit     The selected {@link TimeUnit} for the given {@code timeout}\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Flux} containing the query results as dictated by the given {@code responseType}\n+     */\n+    <R, Q> Flux<R> scatterGather(String queryName, Q query, ResponseType<R> responseType, long timeout,\n+                                 TimeUnit timeUnit);\n+\n+    /**\n+     * Uses the given {@link Publisher} of {@link QueryMessage}s to send incoming queries in scatter gather manner. Queries will be sent\n+     * sequentially. Once the result of Nth query arrives, the (N + 1)th query is dispatched. All queries will be dispatched\n+     * using given {@code timeout} and {@code timeUnit}.\n+     *\n+     * @param queries  a {@link Publisher} stream of queries to be dispatched\n+     * @param timeout  A timeout of {@code long} for the query\n+     * @param timeUnit The selected {@link TimeUnit} for the given {@code timeout}\n+     * @return a {@link Flux} of query results. The ordering of query results corresponds to the ordering of queries being\n+     * dispatched\n+     */\n+    default Flux<Object> scatterGather(Publisher<QueryMessage<?, ?>> queries, long timeout, TimeUnit timeUnit) {\n+        return Flux.from(queries)\n+                   .concatMap(q -> scatterGather(q.getQueryName(),\n+                                                 q.getPayload(),\n+                                                 q.getResponseType(),\n+                                                 timeout,\n+                                                 timeUnit));\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, returns initial result and keeps streaming\n+     * incremental updates until subscriber unsubscribes from Flux.\n+     * Should be used when response type of initial result and incremental update match.\n+     * (received at the moment the query is sent, until it is cancelled by the caller or closed by the emitting side).\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Flux}</b></p>\n+     * <p>\n+     * <b>Note</b>: Any {@code null} results, on the initial result or the updates, will be filtered out by the\n+     * {@link ReactorQueryGateway}. If you require the {@code null} to be returned for the initial and update results,\n+     * we suggest using the {@code QueryBus} instead.\n+     *\n+     * @param query      The {@code query} to be sent\n+     * @param resultType The response type used for this query\n+     * @param <Q>        The type of the query\n+     * @param <R>        The type of the result (initial & updates)\n+     * @return Flux which can be used to cancel receiving updates\n+     *\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage)\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage, SubscriptionQueryBackpressure, int)\n+     */\n+    default <Q, R> Flux<R> subscriptionQuery(Q query, ResponseType<R> resultType) {\n+        return subscriptionQuery(query, resultType, resultType)\n+                .flatMapMany(result -> result.initialResult()\n+                                             .concatWith(result.updates())\n+                                             .doFinally(signal -> result.close()));\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, returns initial result and keeps streaming\n+     * incremental updates until subscriber unsubscribes from Flux.\n+     * Should be used when response type of initial result and incremental update match.\n+     * (received at the moment the query is sent, until it is cancelled by the caller or closed by the emitting side).\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Flux}</b></p>\n+     * <p>\n+     * <b>Note</b>: Any {@code null} results, on the initial result or the updates, will be filtered out by the\n+     * {@link ReactorQueryGateway}. If you require the {@code null} to be returned for the initial and update results,\n+     * we suggest using the {@code QueryBus} instead.\n+     *\n+     * @param query      The {@code query} to be sent\n+     * @param resultType The response type used for this query\n+     * @param <Q>        The type of the query\n+     * @param <R>        The type of the result (initial & updates)\n+     * @return Flux which can be used to cancel receiving updates\n+     *\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage)\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage, SubscriptionQueryBackpressure, int)\n+     */\n+    default <Q, R> Flux<R> subscriptionQuery(Q query, Class<R> resultType) {\n+        return subscriptionQuery(query, ResponseTypes.instanceOf(resultType));\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, returns initial result and keeps streaming\n+     * incremental updates until subscriber unsubscribes from Flux.\n+     * Should be used when initial result contains multiple instances of response type and needs to be flatten.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3697d15e2f6025bbb49a23e02e7c24c79f341d2e"}, "originalPosition": 243}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg1MzY0MjgyOnYy", "diffSide": "RIGHT", "path": "messaging/src/main/java/org/axonframework/queryhandling/ReactorQueryGateway.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMFQxMjoxNzoyNVrOG0JMKw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMFQxNToxNDo0NFrOG0SdMQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzMyOTcwNw==", "bodyText": "Is it possible to use Duration instead of long timeout, TimeUnit timeUnit for the public interface and convert/split to TimeUnit and long for QueryBus's needs?", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r457329707", "createdAt": "2020-07-20T12:17:25Z", "author": {"login": "sandjelkovic"}, "path": "messaging/src/main/java/org/axonframework/queryhandling/ReactorQueryGateway.java", "diffHunk": "@@ -0,0 +1,547 @@\n+/*\n+ * Copyright (c) 2010-2020. Axon Framework\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.axonframework.queryhandling;\n+\n+import org.axonframework.messaging.ResultMessage;\n+import org.axonframework.messaging.reactive.ReactorMessageDispatchInterceptorSupport;\n+import org.axonframework.messaging.reactive.ReactorResultHandlerInterceptorSupport;\n+import org.axonframework.messaging.responsetypes.ResponseType;\n+import org.axonframework.messaging.responsetypes.ResponseTypes;\n+import org.reactivestreams.Publisher;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Mono;\n+import reactor.util.concurrent.Queues;\n+\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Function;\n+\n+/**\n+ * Variation of the {@link QueryGateway}, wrapping a {@link QueryBus} for a friendlier API. Provides support for reactive return types such as {@link Mono} and {@link Flux}\n+ * from Project Reactor.\n+ *\n+ * @author Milan Savic\n+ * @since 4.4\n+ */\n+public interface ReactorQueryGateway extends ReactorMessageDispatchInterceptorSupport<QueryMessage<?, ?>>,\n+        ReactorResultHandlerInterceptorSupport<QueryMessage<?, ?>, ResultMessage<?>> {\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response with the given {@code responseType}\n+     * from a single source. The query name will be derived from the provided {@code query}. Execution may be\n+     * asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param query        The {@code query} to be sent\n+     * @param responseType A {@link Class} describing the desired response type\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(Q query, Class<R> responseType) {\n+        return query(query.getClass().getName(), query, responseType);\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response with the given {@code responseType}\n+     * from a single source. Execution may be asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(String queryName, Q query, Class<R> responseType) {\n+        return query(queryName, query, ResponseTypes.instanceOf(responseType));\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from a single source. The query name will be derived from the provided {@code query}. Execution may be\n+     * asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(Q query, ResponseType<R> responseType) {\n+        return query(query.getClass().getName(), query, responseType);\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from a single source. Execution may be asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    <R, Q> Mono<R> query(String queryName, Q query, ResponseType<R> responseType);\n+\n+    /**\n+     * Uses given Publisher of query messages to send incoming queries away. Queries will be sent sequentially - once a\n+     * result of Nth query arrives, (N + 1)th query is dispatched.\n+     *\n+     * @param queries a Publisher stream of queries to be dispatched\n+     * @return a Flux of query results. An ordering of query results corresponds to an ordering of queries being\n+     * dispatched\n+     *\n+     * @see #query(String, Object, ResponseType)\n+     * @see Flux#concatMap(Function)\n+     */\n+    default Flux<Object> query(Publisher<QueryMessage<?, ?>> queries) {\n+        return Flux.from(queries)\n+                   .concatMap(q -> query(q.getQueryName(), q.getPayload(), q.getResponseType()));\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from several sources. The returned {@link Flux} is completed when a {@code timeout} occurs or when all possible\n+     * results are received. The query name will be derived from the provided {@code query}. Execution may be\n+     * asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     * <b>Note</b>: Any {@code null} results will be filtered out by the {@link ReactorQueryGateway}. If you require\n+     * the {@code null} to be returned, we suggest using {@code QueryBus} instead.\n+     *\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param timeout      A timeout of {@code long} for the query\n+     * @param timeUnit     The selected {@link TimeUnit} for the given {@code timeout}\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Flux} containing the query results as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Flux<R> scatterGather(Q query, ResponseType<R> responseType, long timeout, TimeUnit timeUnit) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3697d15e2f6025bbb49a23e02e7c24c79f341d2e"}, "originalPosition": 142}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzQ4MTUyMQ==", "bodyText": "yes! good suggestion!", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r457481521", "createdAt": "2020-07-20T15:14:44Z", "author": {"login": "m1l4n54v1c"}, "path": "messaging/src/main/java/org/axonframework/queryhandling/ReactorQueryGateway.java", "diffHunk": "@@ -0,0 +1,547 @@\n+/*\n+ * Copyright (c) 2010-2020. Axon Framework\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.axonframework.queryhandling;\n+\n+import org.axonframework.messaging.ResultMessage;\n+import org.axonframework.messaging.reactive.ReactorMessageDispatchInterceptorSupport;\n+import org.axonframework.messaging.reactive.ReactorResultHandlerInterceptorSupport;\n+import org.axonframework.messaging.responsetypes.ResponseType;\n+import org.axonframework.messaging.responsetypes.ResponseTypes;\n+import org.reactivestreams.Publisher;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Mono;\n+import reactor.util.concurrent.Queues;\n+\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Function;\n+\n+/**\n+ * Variation of the {@link QueryGateway}, wrapping a {@link QueryBus} for a friendlier API. Provides support for reactive return types such as {@link Mono} and {@link Flux}\n+ * from Project Reactor.\n+ *\n+ * @author Milan Savic\n+ * @since 4.4\n+ */\n+public interface ReactorQueryGateway extends ReactorMessageDispatchInterceptorSupport<QueryMessage<?, ?>>,\n+        ReactorResultHandlerInterceptorSupport<QueryMessage<?, ?>, ResultMessage<?>> {\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response with the given {@code responseType}\n+     * from a single source. The query name will be derived from the provided {@code query}. Execution may be\n+     * asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param query        The {@code query} to be sent\n+     * @param responseType A {@link Class} describing the desired response type\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(Q query, Class<R> responseType) {\n+        return query(query.getClass().getName(), query, responseType);\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response with the given {@code responseType}\n+     * from a single source. Execution may be asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(String queryName, Q query, Class<R> responseType) {\n+        return query(queryName, query, ResponseTypes.instanceOf(responseType));\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from a single source. The query name will be derived from the provided {@code query}. Execution may be\n+     * asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(Q query, ResponseType<R> responseType) {\n+        return query(query.getClass().getName(), query, responseType);\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from a single source. Execution may be asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    <R, Q> Mono<R> query(String queryName, Q query, ResponseType<R> responseType);\n+\n+    /**\n+     * Uses given Publisher of query messages to send incoming queries away. Queries will be sent sequentially - once a\n+     * result of Nth query arrives, (N + 1)th query is dispatched.\n+     *\n+     * @param queries a Publisher stream of queries to be dispatched\n+     * @return a Flux of query results. An ordering of query results corresponds to an ordering of queries being\n+     * dispatched\n+     *\n+     * @see #query(String, Object, ResponseType)\n+     * @see Flux#concatMap(Function)\n+     */\n+    default Flux<Object> query(Publisher<QueryMessage<?, ?>> queries) {\n+        return Flux.from(queries)\n+                   .concatMap(q -> query(q.getQueryName(), q.getPayload(), q.getResponseType()));\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from several sources. The returned {@link Flux} is completed when a {@code timeout} occurs or when all possible\n+     * results are received. The query name will be derived from the provided {@code query}. Execution may be\n+     * asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     * <b>Note</b>: Any {@code null} results will be filtered out by the {@link ReactorQueryGateway}. If you require\n+     * the {@code null} to be returned, we suggest using {@code QueryBus} instead.\n+     *\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param timeout      A timeout of {@code long} for the query\n+     * @param timeUnit     The selected {@link TimeUnit} for the given {@code timeout}\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Flux} containing the query results as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Flux<R> scatterGather(Q query, ResponseType<R> responseType, long timeout, TimeUnit timeUnit) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzMyOTcwNw=="}, "originalCommit": {"oid": "3697d15e2f6025bbb49a23e02e7c24c79f341d2e"}, "originalPosition": 142}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg4MDM1MTUzOnYy", "diffSide": "RIGHT", "path": "messaging/src/main/java/org/axonframework/commandhandling/callbacks/ReactorCallback.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOFQwNzo0Mjo0OFrOG4AiaQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOFQwNzo0Mjo0OFrOG4AiaQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTM4MjI0OQ==", "bodyText": "Shouldn't these two be private final?", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r461382249", "createdAt": "2020-07-28T07:42:48Z", "author": {"login": "smcvb"}, "path": "messaging/src/main/java/org/axonframework/commandhandling/callbacks/ReactorCallback.java", "diffHunk": "@@ -0,0 +1,60 @@\n+/*\n+ * Copyright (c) 2010-2018. Axon Framework\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.axonframework.commandhandling.callbacks;\n+\n+import org.axonframework.commandhandling.CommandCallback;\n+import org.axonframework.commandhandling.CommandMessage;\n+import org.axonframework.commandhandling.CommandResultMessage;\n+import reactor.core.CoreSubscriber;\n+import reactor.core.publisher.EmitterProcessor;\n+import reactor.core.publisher.FluxSink;\n+import reactor.core.publisher.Mono;\n+\n+/**\n+ * Command Handler Callback that allows the dispatching thread to wait for the result of the callback, using the\n+ * Project Reactor mechanisms. This callback allows the caller to synchronize calls when an asynchronous command bus is\n+ * being used.\n+ *\n+ * @author Stefan Dragisic\n+ * @since 4.4\n+ *\n+ * @see CommandCallback\n+ * @see org.axonframework.commandhandling.CommandBus\n+ */\n+\n+public class ReactorCallback<C, R> extends Mono<CommandResultMessage<? extends R>> implements CommandCallback<C, R> {\n+\n+    EmitterProcessor<CommandResultMessage<? extends R>> commandResultMessageEmitter = EmitterProcessor.create(1);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9d2da7ff7507791063c95d39681098c708145c94"}, "originalPosition": 41}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg4MDM1MjI2OnYy", "diffSide": "RIGHT", "path": "messaging/src/main/java/org/axonframework/commandhandling/callbacks/ReactorCallback.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOFQwNzo0MzowMVrOG4Ai0g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOFQwNzo0MzowMVrOG4Ai0g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTM4MjM1NA==", "bodyText": "Unintended empty line here.", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r461382354", "createdAt": "2020-07-28T07:43:01Z", "author": {"login": "smcvb"}, "path": "messaging/src/main/java/org/axonframework/commandhandling/callbacks/ReactorCallback.java", "diffHunk": "@@ -0,0 +1,60 @@\n+/*\n+ * Copyright (c) 2010-2018. Axon Framework\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.axonframework.commandhandling.callbacks;\n+\n+import org.axonframework.commandhandling.CommandCallback;\n+import org.axonframework.commandhandling.CommandMessage;\n+import org.axonframework.commandhandling.CommandResultMessage;\n+import reactor.core.CoreSubscriber;\n+import reactor.core.publisher.EmitterProcessor;\n+import reactor.core.publisher.FluxSink;\n+import reactor.core.publisher.Mono;\n+\n+/**\n+ * Command Handler Callback that allows the dispatching thread to wait for the result of the callback, using the\n+ * Project Reactor mechanisms. This callback allows the caller to synchronize calls when an asynchronous command bus is\n+ * being used.\n+ *\n+ * @author Stefan Dragisic\n+ * @since 4.4\n+ *\n+ * @see CommandCallback\n+ * @see org.axonframework.commandhandling.CommandBus\n+ */\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9d2da7ff7507791063c95d39681098c708145c94"}, "originalPosition": 38}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMyMTI4ODMzOnYy", "diffSide": "RIGHT", "path": "messaging/src/main/java/org/axonframework/queryhandling/ReactiveQueryGateway.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNVQxNTozMjowMVrOFl8Mng==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNVQxNTozMjowMVrOFl8Mng==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTMyNzkwMg==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * <b>Note</b>: Any {@code null} results, on the initial result or the updates, wil lbe filtered out by the\n          \n          \n            \n                 * <b>Note</b>: Any {@code null} results, on the initial result or the updates, will be filtered out by the", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r375327902", "createdAt": "2020-02-05T15:32:01Z", "author": {"login": "corradom"}, "path": "messaging/src/main/java/org/axonframework/queryhandling/ReactiveQueryGateway.java", "diffHunk": "@@ -0,0 +1,280 @@\n+/*\n+ * Copyright (c) 2010-2020. Axon Framework\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.axonframework.queryhandling;\n+\n+import org.axonframework.messaging.responsetypes.ResponseType;\n+import org.axonframework.messaging.responsetypes.ResponseTypes;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Mono;\n+import reactor.util.concurrent.Queues;\n+\n+import java.util.concurrent.TimeUnit;\n+\n+/**\n+ * Variation of {@link QueryGateway}. Provides support for reactive return types such as {@link Mono} and {@link Flux}\n+ * from Project Reactor.\n+ *\n+ * @author Milan Savic\n+ * @since 4.4\n+ */\n+public interface ReactiveQueryGateway {\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus}, expecting a response with the given {@code responseType}\n+     * from a single source. The query name will be derived from the provided {@code query}. Execution may be\n+     * asynchronous, depending on the QueryBus implementation.\n+     *\n+     * @param query        The {@code query} to be sent\n+     * @param responseType A {@link Class} describing the desired response type\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(Q query, Class<R> responseType) {\n+        return query(query.getClass().getName(), query, responseType);\n+    }\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus}, expecting a response with the given {@code responseType}\n+     * from a single source. Execution may be asynchronous, depending on the QueryBus implementation.\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(String queryName, Q query, Class<R> responseType) {\n+        return query(queryName, query, ResponseTypes.instanceOf(responseType));\n+    }\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from a single source. The query name will be derived from the provided {@code query}. Execution may be\n+     * asynchronous, depending on the QueryBus implementation.\n+     *\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(Q query, ResponseType<R> responseType) {\n+        return query(query.getClass().getName(), query, responseType);\n+    }\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from a single source. Execution may be asynchronous, depending on the QueryBus implementation.\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    <R, Q> Mono<R> query(String queryName, Q query, ResponseType<R> responseType);\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from several sources. The flux is completed when a {@code timeout} occurs or when all results are received. The\n+     * query name will be derived from the provided {@code query}. Execution may be asynchronous, depending on the\n+     * QueryBus implementation.\n+     *\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param timeout      A timeout of {@code long} for the query\n+     * @param timeUnit     The selected {@link TimeUnit} for the given {@code timeout}\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A flux of results\n+     */\n+    default <R, Q> Flux<R> scatterGather(Q query, ResponseType<R> responseType, long timeout, TimeUnit timeUnit) {\n+        return scatterGather(query.getClass().getName(), query, responseType, timeout, timeUnit);\n+    }\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from several sources. The flux is completed when a {@code timeout} occurs or when all results are received.\n+     * Execution may be asynchronous, depending on the QueryBus implementation.\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param timeout      A timeout of {@code long} for the query\n+     * @param timeUnit     The selected {@link TimeUnit} for the given {@code timeout}\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A flux of results.\n+     */\n+    <R, Q> Flux<R> scatterGather(String queryName, Q query, ResponseType<R> responseType, long timeout,\n+                                 TimeUnit timeUnit);\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus} and returns result containing initial response and\n+     * incremental updates (received at the moment the query is sent, until it is cancelled by the caller or closed by\n+     * the emitting side).\n+     * <p>\n+     * <b>Note</b>: Any {@code null} results, on the initial result or the updates, wil lbe filtered out by the\n+     * QueryGateway. If you require the {@code null} to be returned for the initial and update results, we suggest using\n+     * the {@link QueryBus} instead.\n+     *\n+     * @param query               The {@code query} to be sent\n+     * @param initialResponseType The initial response type used for this query\n+     * @param updateResponseType  The update response type used for this query\n+     * @param <Q>                 The type of the query\n+     * @param <I>                 The type of the initial response\n+     * @param <U>                 The type of the incremental update\n+     * @return registration which can be used to cancel receiving updates\n+     *\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage)\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage, SubscriptionQueryBackpressure, int)\n+     */\n+    default <Q, I, U> SubscriptionQueryResult<I, U> subscriptionQuery(Q query, Class<I> initialResponseType,\n+                                                                      Class<U> updateResponseType) {\n+        return subscriptionQuery(query.getClass().getName(),\n+                                 query,\n+                                 initialResponseType,\n+                                 updateResponseType);\n+    }\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus} and returns result containing initial response and\n+     * incremental updates (received at the moment the query is sent, until it is cancelled by the caller or closed by\n+     * the emitting side).\n+     * <p>\n+     * <b>Note</b>: Any {@code null} results, on the initial result or the updates, wil lbe filtered out by the", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d6548cde5c65c7e904684da54b903b93110f095f"}, "originalPosition": 162}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMyMTI5MTUwOnYy", "diffSide": "RIGHT", "path": "messaging/src/main/java/org/axonframework/queryhandling/ReactiveQueryGateway.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNVQxNTozMjo0OFrOFl8Ojw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNVQxNTozMjo0OFrOFl8Ojw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTMyODM5OQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * <b>Note</b>: Any {@code null} results, on the initial result or the updates, wil lbe filtered out by the\n          \n          \n            \n                 * <b>Note</b>: Any {@code null} results, on the initial result or the updates, will be filtered out by the", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r375328399", "createdAt": "2020-02-05T15:32:48Z", "author": {"login": "corradom"}, "path": "messaging/src/main/java/org/axonframework/queryhandling/ReactiveQueryGateway.java", "diffHunk": "@@ -0,0 +1,280 @@\n+/*\n+ * Copyright (c) 2010-2020. Axon Framework\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.axonframework.queryhandling;\n+\n+import org.axonframework.messaging.responsetypes.ResponseType;\n+import org.axonframework.messaging.responsetypes.ResponseTypes;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Mono;\n+import reactor.util.concurrent.Queues;\n+\n+import java.util.concurrent.TimeUnit;\n+\n+/**\n+ * Variation of {@link QueryGateway}. Provides support for reactive return types such as {@link Mono} and {@link Flux}\n+ * from Project Reactor.\n+ *\n+ * @author Milan Savic\n+ * @since 4.4\n+ */\n+public interface ReactiveQueryGateway {\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus}, expecting a response with the given {@code responseType}\n+     * from a single source. The query name will be derived from the provided {@code query}. Execution may be\n+     * asynchronous, depending on the QueryBus implementation.\n+     *\n+     * @param query        The {@code query} to be sent\n+     * @param responseType A {@link Class} describing the desired response type\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(Q query, Class<R> responseType) {\n+        return query(query.getClass().getName(), query, responseType);\n+    }\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus}, expecting a response with the given {@code responseType}\n+     * from a single source. Execution may be asynchronous, depending on the QueryBus implementation.\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(String queryName, Q query, Class<R> responseType) {\n+        return query(queryName, query, ResponseTypes.instanceOf(responseType));\n+    }\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from a single source. The query name will be derived from the provided {@code query}. Execution may be\n+     * asynchronous, depending on the QueryBus implementation.\n+     *\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(Q query, ResponseType<R> responseType) {\n+        return query(query.getClass().getName(), query, responseType);\n+    }\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from a single source. Execution may be asynchronous, depending on the QueryBus implementation.\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    <R, Q> Mono<R> query(String queryName, Q query, ResponseType<R> responseType);\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from several sources. The flux is completed when a {@code timeout} occurs or when all results are received. The\n+     * query name will be derived from the provided {@code query}. Execution may be asynchronous, depending on the\n+     * QueryBus implementation.\n+     *\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param timeout      A timeout of {@code long} for the query\n+     * @param timeUnit     The selected {@link TimeUnit} for the given {@code timeout}\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A flux of results\n+     */\n+    default <R, Q> Flux<R> scatterGather(Q query, ResponseType<R> responseType, long timeout, TimeUnit timeUnit) {\n+        return scatterGather(query.getClass().getName(), query, responseType, timeout, timeUnit);\n+    }\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from several sources. The flux is completed when a {@code timeout} occurs or when all results are received.\n+     * Execution may be asynchronous, depending on the QueryBus implementation.\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param timeout      A timeout of {@code long} for the query\n+     * @param timeUnit     The selected {@link TimeUnit} for the given {@code timeout}\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A flux of results.\n+     */\n+    <R, Q> Flux<R> scatterGather(String queryName, Q query, ResponseType<R> responseType, long timeout,\n+                                 TimeUnit timeUnit);\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus} and returns result containing initial response and\n+     * incremental updates (received at the moment the query is sent, until it is cancelled by the caller or closed by\n+     * the emitting side).\n+     * <p>\n+     * <b>Note</b>: Any {@code null} results, on the initial result or the updates, wil lbe filtered out by the", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d6548cde5c65c7e904684da54b903b93110f095f"}, "originalPosition": 134}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMyMTI5NjA4OnYy", "diffSide": "RIGHT", "path": "messaging/src/main/java/org/axonframework/queryhandling/ReactiveQueryGateway.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNVQxNTozMzo1OVrOFl8RcQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNVQxNTozMzo1OVrOFl8RcQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTMyOTEzNw==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * <b>Note</b>: Any {@code null} results, on the initial result or the updates, wil lbe filtered out by the\n          \n          \n            \n                 * <b>Note</b>: Any {@code null} results, on the initial result or the updates, will be filtered out by the", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r375329137", "createdAt": "2020-02-05T15:33:59Z", "author": {"login": "corradom"}, "path": "messaging/src/main/java/org/axonframework/queryhandling/ReactiveQueryGateway.java", "diffHunk": "@@ -0,0 +1,280 @@\n+/*\n+ * Copyright (c) 2010-2020. Axon Framework\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.axonframework.queryhandling;\n+\n+import org.axonframework.messaging.responsetypes.ResponseType;\n+import org.axonframework.messaging.responsetypes.ResponseTypes;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Mono;\n+import reactor.util.concurrent.Queues;\n+\n+import java.util.concurrent.TimeUnit;\n+\n+/**\n+ * Variation of {@link QueryGateway}. Provides support for reactive return types such as {@link Mono} and {@link Flux}\n+ * from Project Reactor.\n+ *\n+ * @author Milan Savic\n+ * @since 4.4\n+ */\n+public interface ReactiveQueryGateway {\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus}, expecting a response with the given {@code responseType}\n+     * from a single source. The query name will be derived from the provided {@code query}. Execution may be\n+     * asynchronous, depending on the QueryBus implementation.\n+     *\n+     * @param query        The {@code query} to be sent\n+     * @param responseType A {@link Class} describing the desired response type\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(Q query, Class<R> responseType) {\n+        return query(query.getClass().getName(), query, responseType);\n+    }\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus}, expecting a response with the given {@code responseType}\n+     * from a single source. Execution may be asynchronous, depending on the QueryBus implementation.\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(String queryName, Q query, Class<R> responseType) {\n+        return query(queryName, query, ResponseTypes.instanceOf(responseType));\n+    }\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from a single source. The query name will be derived from the provided {@code query}. Execution may be\n+     * asynchronous, depending on the QueryBus implementation.\n+     *\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(Q query, ResponseType<R> responseType) {\n+        return query(query.getClass().getName(), query, responseType);\n+    }\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from a single source. Execution may be asynchronous, depending on the QueryBus implementation.\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    <R, Q> Mono<R> query(String queryName, Q query, ResponseType<R> responseType);\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from several sources. The flux is completed when a {@code timeout} occurs or when all results are received. The\n+     * query name will be derived from the provided {@code query}. Execution may be asynchronous, depending on the\n+     * QueryBus implementation.\n+     *\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param timeout      A timeout of {@code long} for the query\n+     * @param timeUnit     The selected {@link TimeUnit} for the given {@code timeout}\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A flux of results\n+     */\n+    default <R, Q> Flux<R> scatterGather(Q query, ResponseType<R> responseType, long timeout, TimeUnit timeUnit) {\n+        return scatterGather(query.getClass().getName(), query, responseType, timeout, timeUnit);\n+    }\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from several sources. The flux is completed when a {@code timeout} occurs or when all results are received.\n+     * Execution may be asynchronous, depending on the QueryBus implementation.\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param timeout      A timeout of {@code long} for the query\n+     * @param timeUnit     The selected {@link TimeUnit} for the given {@code timeout}\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A flux of results.\n+     */\n+    <R, Q> Flux<R> scatterGather(String queryName, Q query, ResponseType<R> responseType, long timeout,\n+                                 TimeUnit timeUnit);\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus} and returns result containing initial response and\n+     * incremental updates (received at the moment the query is sent, until it is cancelled by the caller or closed by\n+     * the emitting side).\n+     * <p>\n+     * <b>Note</b>: Any {@code null} results, on the initial result or the updates, wil lbe filtered out by the\n+     * QueryGateway. If you require the {@code null} to be returned for the initial and update results, we suggest using\n+     * the {@link QueryBus} instead.\n+     *\n+     * @param query               The {@code query} to be sent\n+     * @param initialResponseType The initial response type used for this query\n+     * @param updateResponseType  The update response type used for this query\n+     * @param <Q>                 The type of the query\n+     * @param <I>                 The type of the initial response\n+     * @param <U>                 The type of the incremental update\n+     * @return registration which can be used to cancel receiving updates\n+     *\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage)\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage, SubscriptionQueryBackpressure, int)\n+     */\n+    default <Q, I, U> SubscriptionQueryResult<I, U> subscriptionQuery(Q query, Class<I> initialResponseType,\n+                                                                      Class<U> updateResponseType) {\n+        return subscriptionQuery(query.getClass().getName(),\n+                                 query,\n+                                 initialResponseType,\n+                                 updateResponseType);\n+    }\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus} and returns result containing initial response and\n+     * incremental updates (received at the moment the query is sent, until it is cancelled by the caller or closed by\n+     * the emitting side).\n+     * <p>\n+     * <b>Note</b>: Any {@code null} results, on the initial result or the updates, wil lbe filtered out by the\n+     * QueryGateway. If you require the {@code null} to be returned for the initial and update results, we suggest using\n+     * the {@link QueryBus} instead.\n+     *\n+     * @param queryName           A {@link String} describing query to be executed\n+     * @param query               The {@code query} to be sent\n+     * @param initialResponseType The initial response type used for this query\n+     * @param updateResponseType  The update response type used for this query\n+     * @param <Q>                 The type of the query\n+     * @param <I>                 The type of the initial response\n+     * @param <U>                 The type of the incremental update\n+     * @return registration which can be used to cancel receiving updates\n+     *\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage)\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage, SubscriptionQueryBackpressure, int)\n+     */\n+    default <Q, I, U> SubscriptionQueryResult<I, U> subscriptionQuery(String queryName, Q query,\n+                                                                      Class<I> initialResponseType,\n+                                                                      Class<U> updateResponseType) {\n+        return subscriptionQuery(queryName,\n+                                 query,\n+                                 ResponseTypes.instanceOf(initialResponseType),\n+                                 ResponseTypes.instanceOf(updateResponseType),\n+                                 SubscriptionQueryBackpressure.defaultBackpressure());\n+    }\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus} and returns result containing initial response and\n+     * incremental updates (received at the moment the query is sent, until it is cancelled by the caller or closed by\n+     * the emitting side).\n+     * <p>\n+     * <b>Note</b>: Any {@code null} results, on the initial result or the updates, wil lbe filtered out by the", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d6548cde5c65c7e904684da54b903b93110f095f"}, "originalPosition": 193}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMyMTI5Njc4OnYy", "diffSide": "RIGHT", "path": "messaging/src/main/java/org/axonframework/queryhandling/ReactiveQueryGateway.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNVQxNTozNDowOFrOFl8R5A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNVQxNTozNDowOFrOFl8R5A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTMyOTI1Mg==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * <b>Note</b>: Any {@code null} results, on the initial result or the updates, wil lbe filtered out by the\n          \n          \n            \n                 * <b>Note</b>: Any {@code null} results, on the initial result or the updates, will be filtered out by the", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r375329252", "createdAt": "2020-02-05T15:34:08Z", "author": {"login": "corradom"}, "path": "messaging/src/main/java/org/axonframework/queryhandling/ReactiveQueryGateway.java", "diffHunk": "@@ -0,0 +1,280 @@\n+/*\n+ * Copyright (c) 2010-2020. Axon Framework\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.axonframework.queryhandling;\n+\n+import org.axonframework.messaging.responsetypes.ResponseType;\n+import org.axonframework.messaging.responsetypes.ResponseTypes;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Mono;\n+import reactor.util.concurrent.Queues;\n+\n+import java.util.concurrent.TimeUnit;\n+\n+/**\n+ * Variation of {@link QueryGateway}. Provides support for reactive return types such as {@link Mono} and {@link Flux}\n+ * from Project Reactor.\n+ *\n+ * @author Milan Savic\n+ * @since 4.4\n+ */\n+public interface ReactiveQueryGateway {\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus}, expecting a response with the given {@code responseType}\n+     * from a single source. The query name will be derived from the provided {@code query}. Execution may be\n+     * asynchronous, depending on the QueryBus implementation.\n+     *\n+     * @param query        The {@code query} to be sent\n+     * @param responseType A {@link Class} describing the desired response type\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(Q query, Class<R> responseType) {\n+        return query(query.getClass().getName(), query, responseType);\n+    }\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus}, expecting a response with the given {@code responseType}\n+     * from a single source. Execution may be asynchronous, depending on the QueryBus implementation.\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(String queryName, Q query, Class<R> responseType) {\n+        return query(queryName, query, ResponseTypes.instanceOf(responseType));\n+    }\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from a single source. The query name will be derived from the provided {@code query}. Execution may be\n+     * asynchronous, depending on the QueryBus implementation.\n+     *\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(Q query, ResponseType<R> responseType) {\n+        return query(query.getClass().getName(), query, responseType);\n+    }\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from a single source. Execution may be asynchronous, depending on the QueryBus implementation.\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    <R, Q> Mono<R> query(String queryName, Q query, ResponseType<R> responseType);\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from several sources. The flux is completed when a {@code timeout} occurs or when all results are received. The\n+     * query name will be derived from the provided {@code query}. Execution may be asynchronous, depending on the\n+     * QueryBus implementation.\n+     *\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param timeout      A timeout of {@code long} for the query\n+     * @param timeUnit     The selected {@link TimeUnit} for the given {@code timeout}\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A flux of results\n+     */\n+    default <R, Q> Flux<R> scatterGather(Q query, ResponseType<R> responseType, long timeout, TimeUnit timeUnit) {\n+        return scatterGather(query.getClass().getName(), query, responseType, timeout, timeUnit);\n+    }\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from several sources. The flux is completed when a {@code timeout} occurs or when all results are received.\n+     * Execution may be asynchronous, depending on the QueryBus implementation.\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param timeout      A timeout of {@code long} for the query\n+     * @param timeUnit     The selected {@link TimeUnit} for the given {@code timeout}\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A flux of results.\n+     */\n+    <R, Q> Flux<R> scatterGather(String queryName, Q query, ResponseType<R> responseType, long timeout,\n+                                 TimeUnit timeUnit);\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus} and returns result containing initial response and\n+     * incremental updates (received at the moment the query is sent, until it is cancelled by the caller or closed by\n+     * the emitting side).\n+     * <p>\n+     * <b>Note</b>: Any {@code null} results, on the initial result or the updates, wil lbe filtered out by the\n+     * QueryGateway. If you require the {@code null} to be returned for the initial and update results, we suggest using\n+     * the {@link QueryBus} instead.\n+     *\n+     * @param query               The {@code query} to be sent\n+     * @param initialResponseType The initial response type used for this query\n+     * @param updateResponseType  The update response type used for this query\n+     * @param <Q>                 The type of the query\n+     * @param <I>                 The type of the initial response\n+     * @param <U>                 The type of the incremental update\n+     * @return registration which can be used to cancel receiving updates\n+     *\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage)\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage, SubscriptionQueryBackpressure, int)\n+     */\n+    default <Q, I, U> SubscriptionQueryResult<I, U> subscriptionQuery(Q query, Class<I> initialResponseType,\n+                                                                      Class<U> updateResponseType) {\n+        return subscriptionQuery(query.getClass().getName(),\n+                                 query,\n+                                 initialResponseType,\n+                                 updateResponseType);\n+    }\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus} and returns result containing initial response and\n+     * incremental updates (received at the moment the query is sent, until it is cancelled by the caller or closed by\n+     * the emitting side).\n+     * <p>\n+     * <b>Note</b>: Any {@code null} results, on the initial result or the updates, wil lbe filtered out by the\n+     * QueryGateway. If you require the {@code null} to be returned for the initial and update results, we suggest using\n+     * the {@link QueryBus} instead.\n+     *\n+     * @param queryName           A {@link String} describing query to be executed\n+     * @param query               The {@code query} to be sent\n+     * @param initialResponseType The initial response type used for this query\n+     * @param updateResponseType  The update response type used for this query\n+     * @param <Q>                 The type of the query\n+     * @param <I>                 The type of the initial response\n+     * @param <U>                 The type of the incremental update\n+     * @return registration which can be used to cancel receiving updates\n+     *\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage)\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage, SubscriptionQueryBackpressure, int)\n+     */\n+    default <Q, I, U> SubscriptionQueryResult<I, U> subscriptionQuery(String queryName, Q query,\n+                                                                      Class<I> initialResponseType,\n+                                                                      Class<U> updateResponseType) {\n+        return subscriptionQuery(queryName,\n+                                 query,\n+                                 ResponseTypes.instanceOf(initialResponseType),\n+                                 ResponseTypes.instanceOf(updateResponseType),\n+                                 SubscriptionQueryBackpressure.defaultBackpressure());\n+    }\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus} and returns result containing initial response and\n+     * incremental updates (received at the moment the query is sent, until it is cancelled by the caller or closed by\n+     * the emitting side).\n+     * <p>\n+     * <b>Note</b>: Any {@code null} results, on the initial result or the updates, wil lbe filtered out by the\n+     * QueryGateway. If you require the {@code null} to be returned for the initial and update results, we suggest using\n+     * the {@link QueryBus} instead.\n+     *\n+     * @param query               The {@code query} to be sent\n+     * @param initialResponseType The initial response type used for this query\n+     * @param updateResponseType  The update response type used for this query\n+     * @param <Q>                 The type of the query\n+     * @param <I>                 The type of the initial response\n+     * @param <U>                 The type of the incremental update\n+     * @return registration which can be used to cancel receiving updates\n+     *\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage)\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage, SubscriptionQueryBackpressure, int)\n+     */\n+    default <Q, I, U> SubscriptionQueryResult<I, U> subscriptionQuery(Q query, ResponseType<I> initialResponseType,\n+                                                                      ResponseType<U> updateResponseType) {\n+        return subscriptionQuery(query.getClass().getName(),\n+                                 query,\n+                                 initialResponseType,\n+                                 updateResponseType,\n+                                 SubscriptionQueryBackpressure.defaultBackpressure());\n+    }\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus} and returns result containing initial response and\n+     * incremental updates (received at the moment the query is sent, until it is cancelled by the caller or closed by\n+     * the emitting side).\n+     * <p>\n+     * <b>Note</b>: Any {@code null} results, on the initial result or the updates, wil lbe filtered out by the", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d6548cde5c65c7e904684da54b903b93110f095f"}, "originalPosition": 222}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMyMTI5NzQ2OnYy", "diffSide": "RIGHT", "path": "messaging/src/main/java/org/axonframework/queryhandling/ReactiveQueryGateway.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNVQxNTozNDoyMVrOFl8SXw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNVQxNTozNDoyMVrOFl8SXw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTMyOTM3NQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * <b>Note</b>: Any {@code null} results, on the initial result or the updates, wil lbe filtered out by the\n          \n          \n            \n                 * <b>Note</b>: Any {@code null} results, on the initial result or the updates, will be filtered out by the", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r375329375", "createdAt": "2020-02-05T15:34:21Z", "author": {"login": "corradom"}, "path": "messaging/src/main/java/org/axonframework/queryhandling/ReactiveQueryGateway.java", "diffHunk": "@@ -0,0 +1,280 @@\n+/*\n+ * Copyright (c) 2010-2020. Axon Framework\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.axonframework.queryhandling;\n+\n+import org.axonframework.messaging.responsetypes.ResponseType;\n+import org.axonframework.messaging.responsetypes.ResponseTypes;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Mono;\n+import reactor.util.concurrent.Queues;\n+\n+import java.util.concurrent.TimeUnit;\n+\n+/**\n+ * Variation of {@link QueryGateway}. Provides support for reactive return types such as {@link Mono} and {@link Flux}\n+ * from Project Reactor.\n+ *\n+ * @author Milan Savic\n+ * @since 4.4\n+ */\n+public interface ReactiveQueryGateway {\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus}, expecting a response with the given {@code responseType}\n+     * from a single source. The query name will be derived from the provided {@code query}. Execution may be\n+     * asynchronous, depending on the QueryBus implementation.\n+     *\n+     * @param query        The {@code query} to be sent\n+     * @param responseType A {@link Class} describing the desired response type\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(Q query, Class<R> responseType) {\n+        return query(query.getClass().getName(), query, responseType);\n+    }\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus}, expecting a response with the given {@code responseType}\n+     * from a single source. Execution may be asynchronous, depending on the QueryBus implementation.\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(String queryName, Q query, Class<R> responseType) {\n+        return query(queryName, query, ResponseTypes.instanceOf(responseType));\n+    }\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from a single source. The query name will be derived from the provided {@code query}. Execution may be\n+     * asynchronous, depending on the QueryBus implementation.\n+     *\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(Q query, ResponseType<R> responseType) {\n+        return query(query.getClass().getName(), query, responseType);\n+    }\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from a single source. Execution may be asynchronous, depending on the QueryBus implementation.\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    <R, Q> Mono<R> query(String queryName, Q query, ResponseType<R> responseType);\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from several sources. The flux is completed when a {@code timeout} occurs or when all results are received. The\n+     * query name will be derived from the provided {@code query}. Execution may be asynchronous, depending on the\n+     * QueryBus implementation.\n+     *\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param timeout      A timeout of {@code long} for the query\n+     * @param timeUnit     The selected {@link TimeUnit} for the given {@code timeout}\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A flux of results\n+     */\n+    default <R, Q> Flux<R> scatterGather(Q query, ResponseType<R> responseType, long timeout, TimeUnit timeUnit) {\n+        return scatterGather(query.getClass().getName(), query, responseType, timeout, timeUnit);\n+    }\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from several sources. The flux is completed when a {@code timeout} occurs or when all results are received.\n+     * Execution may be asynchronous, depending on the QueryBus implementation.\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param timeout      A timeout of {@code long} for the query\n+     * @param timeUnit     The selected {@link TimeUnit} for the given {@code timeout}\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A flux of results.\n+     */\n+    <R, Q> Flux<R> scatterGather(String queryName, Q query, ResponseType<R> responseType, long timeout,\n+                                 TimeUnit timeUnit);\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus} and returns result containing initial response and\n+     * incremental updates (received at the moment the query is sent, until it is cancelled by the caller or closed by\n+     * the emitting side).\n+     * <p>\n+     * <b>Note</b>: Any {@code null} results, on the initial result or the updates, wil lbe filtered out by the\n+     * QueryGateway. If you require the {@code null} to be returned for the initial and update results, we suggest using\n+     * the {@link QueryBus} instead.\n+     *\n+     * @param query               The {@code query} to be sent\n+     * @param initialResponseType The initial response type used for this query\n+     * @param updateResponseType  The update response type used for this query\n+     * @param <Q>                 The type of the query\n+     * @param <I>                 The type of the initial response\n+     * @param <U>                 The type of the incremental update\n+     * @return registration which can be used to cancel receiving updates\n+     *\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage)\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage, SubscriptionQueryBackpressure, int)\n+     */\n+    default <Q, I, U> SubscriptionQueryResult<I, U> subscriptionQuery(Q query, Class<I> initialResponseType,\n+                                                                      Class<U> updateResponseType) {\n+        return subscriptionQuery(query.getClass().getName(),\n+                                 query,\n+                                 initialResponseType,\n+                                 updateResponseType);\n+    }\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus} and returns result containing initial response and\n+     * incremental updates (received at the moment the query is sent, until it is cancelled by the caller or closed by\n+     * the emitting side).\n+     * <p>\n+     * <b>Note</b>: Any {@code null} results, on the initial result or the updates, wil lbe filtered out by the\n+     * QueryGateway. If you require the {@code null} to be returned for the initial and update results, we suggest using\n+     * the {@link QueryBus} instead.\n+     *\n+     * @param queryName           A {@link String} describing query to be executed\n+     * @param query               The {@code query} to be sent\n+     * @param initialResponseType The initial response type used for this query\n+     * @param updateResponseType  The update response type used for this query\n+     * @param <Q>                 The type of the query\n+     * @param <I>                 The type of the initial response\n+     * @param <U>                 The type of the incremental update\n+     * @return registration which can be used to cancel receiving updates\n+     *\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage)\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage, SubscriptionQueryBackpressure, int)\n+     */\n+    default <Q, I, U> SubscriptionQueryResult<I, U> subscriptionQuery(String queryName, Q query,\n+                                                                      Class<I> initialResponseType,\n+                                                                      Class<U> updateResponseType) {\n+        return subscriptionQuery(queryName,\n+                                 query,\n+                                 ResponseTypes.instanceOf(initialResponseType),\n+                                 ResponseTypes.instanceOf(updateResponseType),\n+                                 SubscriptionQueryBackpressure.defaultBackpressure());\n+    }\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus} and returns result containing initial response and\n+     * incremental updates (received at the moment the query is sent, until it is cancelled by the caller or closed by\n+     * the emitting side).\n+     * <p>\n+     * <b>Note</b>: Any {@code null} results, on the initial result or the updates, wil lbe filtered out by the\n+     * QueryGateway. If you require the {@code null} to be returned for the initial and update results, we suggest using\n+     * the {@link QueryBus} instead.\n+     *\n+     * @param query               The {@code query} to be sent\n+     * @param initialResponseType The initial response type used for this query\n+     * @param updateResponseType  The update response type used for this query\n+     * @param <Q>                 The type of the query\n+     * @param <I>                 The type of the initial response\n+     * @param <U>                 The type of the incremental update\n+     * @return registration which can be used to cancel receiving updates\n+     *\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage)\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage, SubscriptionQueryBackpressure, int)\n+     */\n+    default <Q, I, U> SubscriptionQueryResult<I, U> subscriptionQuery(Q query, ResponseType<I> initialResponseType,\n+                                                                      ResponseType<U> updateResponseType) {\n+        return subscriptionQuery(query.getClass().getName(),\n+                                 query,\n+                                 initialResponseType,\n+                                 updateResponseType,\n+                                 SubscriptionQueryBackpressure.defaultBackpressure());\n+    }\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus} and returns result containing initial response and\n+     * incremental updates (received at the moment the query is sent, until it is cancelled by the caller or closed by\n+     * the emitting side).\n+     * <p>\n+     * <b>Note</b>: Any {@code null} results, on the initial result or the updates, wil lbe filtered out by the\n+     * QueryGateway. If you require the {@code null} to be returned for the initial and update results, we suggest using\n+     * the {@link QueryBus} instead.\n+     *\n+     * @param queryName           A {@link String} describing query to be executed\n+     * @param query               The {@code query} to be sent\n+     * @param initialResponseType The initial response type used for this query\n+     * @param updateResponseType  The update response type used for this query\n+     * @param backpressure        The backpressure mechanism to deal with producing of incremental updates\n+     * @param <Q>                 The type of the query\n+     * @param <I>                 The type of the initial response\n+     * @param <U>                 The type of the incremental update\n+     * @return registration which can be used to cancel receiving updates\n+     *\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage)\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage, SubscriptionQueryBackpressure, int)\n+     */\n+    default <Q, I, U> SubscriptionQueryResult<I, U> subscriptionQuery(String queryName, Q query,\n+                                                                      ResponseType<I> initialResponseType,\n+                                                                      ResponseType<U> updateResponseType,\n+                                                                      SubscriptionQueryBackpressure backpressure) {\n+        return subscriptionQuery(queryName,\n+                                 query,\n+                                 initialResponseType,\n+                                 updateResponseType,\n+                                 backpressure,\n+                                 Queues.SMALL_BUFFER_SIZE);\n+    }\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus} and returns result containing initial response and\n+     * incremental updates (received at the moment the query is sent, until it is cancelled by the caller or closed by\n+     * the emitting side).\n+     * <p>\n+     * <b>Note</b>: Any {@code null} results, on the initial result or the updates, wil lbe filtered out by the", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d6548cde5c65c7e904684da54b903b93110f095f"}, "originalPosition": 256}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM4NDY0MDc2OnYy", "diffSide": "RIGHT", "path": "messaging/src/main/java/org/axonframework/commandhandling/gateway/DefaultReactiveCommandGateway.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yN1QxMDo1MDozMlrOFvNoaA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yN1QxMzo1NzoxMlrOFvTIow==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTA1MDcyOA==", "bodyText": "Is there a use case where a retryScheduler is needed and Mono's out of the box retry mechanism isn't enough? If so, documentation for each use case would be great.", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r385050728", "createdAt": "2020-02-27T10:50:32Z", "author": {"login": "sandjelkovic"}, "path": "messaging/src/main/java/org/axonframework/commandhandling/gateway/DefaultReactiveCommandGateway.java", "diffHunk": "@@ -0,0 +1,207 @@\n+/*\n+ * Copyright (c) 2010-2020. Axon Framework\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.axonframework.commandhandling.gateway;\n+\n+import org.axonframework.commandhandling.CommandBus;\n+import org.axonframework.commandhandling.CommandCallback;\n+import org.axonframework.commandhandling.CommandMessage;\n+import org.axonframework.commandhandling.GenericCommandMessage;\n+import org.axonframework.common.AxonConfigurationException;\n+import org.axonframework.common.Registration;\n+import org.axonframework.messaging.ReactiveMessageDispatchInterceptor;\n+import reactor.core.publisher.Mono;\n+\n+import java.util.List;\n+import java.util.concurrent.CopyOnWriteArrayList;\n+\n+import static java.util.Arrays.asList;\n+import static org.axonframework.common.BuilderUtils.assertNonNull;\n+\n+/**\n+ * Default implementation of {@link ReactiveCommandGateway}.\n+ *\n+ * @author Milan Savic\n+ * @since 4.4\n+ */\n+public class DefaultReactiveCommandGateway implements ReactiveCommandGateway {\n+\n+    private final CommandBus commandBus;\n+    private final RetryScheduler retryScheduler;\n+    private final List<ReactiveMessageDispatchInterceptor<CommandMessage<?>>> dispatchInterceptors;\n+\n+    /**\n+     * Creates an instance of {@link DefaultReactiveCommandGateway} based on the fields contained in the {@link\n+     * Builder}.\n+     * <p>\n+     * Will assert that the {@link CommandBus} is not {@code null} and throws an {@link AxonConfigurationException} if\n+     * it is.\n+     * </p>\n+     *\n+     * @param builder the {@link Builder} used to instantiated a {@link DefaultReactiveCommandGateway} instance\n+     */\n+    protected DefaultReactiveCommandGateway(Builder builder) {\n+        builder.validate();\n+        this.commandBus = builder.commandBus;\n+        this.retryScheduler = builder.retryScheduler;\n+        this.dispatchInterceptors = builder.dispatchInterceptors;\n+    }\n+\n+    /**\n+     * Instantiate a Builder to be able to create a {@link DefaultReactiveCommandGateway}.\n+     * <p>\n+     * The {@code dispatchInterceptors} are defaulted to an empty list.\n+     * The {@link CommandBus} is a <b>hard requirements</b> and as such should be provided.\n+     * </p>\n+     *\n+     * @return a Builder to be able to create a {@link DefaultReactiveCommandGateway}\n+     */\n+    public static Builder builder() {\n+        return new Builder();\n+    }\n+\n+    @Override\n+    public <R> Mono<R> send(Mono<Object> command) {\n+        return processInterceptors(command.map(GenericCommandMessage::asCommandMessage))\n+                .flatMap(commandMessage -> Mono.create(\n+                        sink -> {\n+                            CommandCallback<Object, R> commandCallback = (cm, result) -> {\n+                                try {\n+                                    if (result.isExceptional()) {\n+                                        sink.error(result.exceptionResult());\n+                                    } else {\n+                                        sink.success(result.getPayload());\n+                                    }\n+                                } catch (Exception e) {\n+                                    sink.error(e);\n+                                }\n+                            };\n+                            if (retryScheduler != null) {\n+                                commandCallback = new RetryingCallback<>(commandCallback, retryScheduler, commandBus);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3253ff7e66e6230d258f3b680193b689d66774a0"}, "originalPosition": 93}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTE0MDg5OQ==", "bodyText": "Mono retry mechanism is great. Retry scheduler, in this case, is an optimization (we might discuss whether is necessary) to retry only command sending and not the whole loop with interceptors. Also, you might wanna reconsider Mono's retry since you'd retry interceptors which purpose might be to return Mono.error which indicates command dispatching should be cancelled.", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r385140899", "createdAt": "2020-02-27T13:57:12Z", "author": {"login": "m1l4n54v1c"}, "path": "messaging/src/main/java/org/axonframework/commandhandling/gateway/DefaultReactiveCommandGateway.java", "diffHunk": "@@ -0,0 +1,207 @@\n+/*\n+ * Copyright (c) 2010-2020. Axon Framework\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.axonframework.commandhandling.gateway;\n+\n+import org.axonframework.commandhandling.CommandBus;\n+import org.axonframework.commandhandling.CommandCallback;\n+import org.axonframework.commandhandling.CommandMessage;\n+import org.axonframework.commandhandling.GenericCommandMessage;\n+import org.axonframework.common.AxonConfigurationException;\n+import org.axonframework.common.Registration;\n+import org.axonframework.messaging.ReactiveMessageDispatchInterceptor;\n+import reactor.core.publisher.Mono;\n+\n+import java.util.List;\n+import java.util.concurrent.CopyOnWriteArrayList;\n+\n+import static java.util.Arrays.asList;\n+import static org.axonframework.common.BuilderUtils.assertNonNull;\n+\n+/**\n+ * Default implementation of {@link ReactiveCommandGateway}.\n+ *\n+ * @author Milan Savic\n+ * @since 4.4\n+ */\n+public class DefaultReactiveCommandGateway implements ReactiveCommandGateway {\n+\n+    private final CommandBus commandBus;\n+    private final RetryScheduler retryScheduler;\n+    private final List<ReactiveMessageDispatchInterceptor<CommandMessage<?>>> dispatchInterceptors;\n+\n+    /**\n+     * Creates an instance of {@link DefaultReactiveCommandGateway} based on the fields contained in the {@link\n+     * Builder}.\n+     * <p>\n+     * Will assert that the {@link CommandBus} is not {@code null} and throws an {@link AxonConfigurationException} if\n+     * it is.\n+     * </p>\n+     *\n+     * @param builder the {@link Builder} used to instantiated a {@link DefaultReactiveCommandGateway} instance\n+     */\n+    protected DefaultReactiveCommandGateway(Builder builder) {\n+        builder.validate();\n+        this.commandBus = builder.commandBus;\n+        this.retryScheduler = builder.retryScheduler;\n+        this.dispatchInterceptors = builder.dispatchInterceptors;\n+    }\n+\n+    /**\n+     * Instantiate a Builder to be able to create a {@link DefaultReactiveCommandGateway}.\n+     * <p>\n+     * The {@code dispatchInterceptors} are defaulted to an empty list.\n+     * The {@link CommandBus} is a <b>hard requirements</b> and as such should be provided.\n+     * </p>\n+     *\n+     * @return a Builder to be able to create a {@link DefaultReactiveCommandGateway}\n+     */\n+    public static Builder builder() {\n+        return new Builder();\n+    }\n+\n+    @Override\n+    public <R> Mono<R> send(Mono<Object> command) {\n+        return processInterceptors(command.map(GenericCommandMessage::asCommandMessage))\n+                .flatMap(commandMessage -> Mono.create(\n+                        sink -> {\n+                            CommandCallback<Object, R> commandCallback = (cm, result) -> {\n+                                try {\n+                                    if (result.isExceptional()) {\n+                                        sink.error(result.exceptionResult());\n+                                    } else {\n+                                        sink.success(result.getPayload());\n+                                    }\n+                                } catch (Exception e) {\n+                                    sink.error(e);\n+                                }\n+                            };\n+                            if (retryScheduler != null) {\n+                                commandCallback = new RetryingCallback<>(commandCallback, retryScheduler, commandBus);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTA1MDcyOA=="}, "originalCommit": {"oid": "3253ff7e66e6230d258f3b680193b689d66774a0"}, "originalPosition": 93}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ1NzU0Mzk4OnYy", "diffSide": "RIGHT", "path": "messaging/src/main/java/org/axonframework/commandhandling/gateway/ReactiveCommandGateway.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yM1QxMzoxMDowM1rOF6En1g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yM1QxMzoxMDowM1rOF6En1g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjQzNzQ2Mg==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * The given {@code command} is wrapped as the payload of the CommandMessage that is eventually posted on the\n          \n          \n            \n                 * Command Bus, unless Command already implements {@link Message}. In that case, a\n          \n          \n            \n                 * CommandMessage is constructed from that message's payload and MetaData.\n          \n          \n            \n                 * The given {@code command} is wrapped as the payload of a {@link CommandMessage} that is eventually posted on the\n          \n          \n            \n                 * {@link CommandBus}, unless the {@code command} already implements {@link Message}. In that case, a\n          \n          \n            \n                 * {@code CommandMessage} is constructed from that message's payload and {@link MetaData}.", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r396437462", "createdAt": "2020-03-23T13:10:03Z", "author": {"login": "smcvb"}, "path": "messaging/src/main/java/org/axonframework/commandhandling/gateway/ReactiveCommandGateway.java", "diffHunk": "@@ -0,0 +1,55 @@\n+/*\n+ * Copyright (c) 2010-2020. Axon Framework\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.axonframework.commandhandling.gateway;\n+\n+import org.axonframework.messaging.Message;\n+import reactor.core.publisher.Mono;\n+\n+/**\n+ * Variation of {@link CommandGateway}. Provides support for reactive return type such as {@link Mono} from Project\n+ * Reactor.\n+ *\n+ * @author Milan Savic\n+ * @since 4.4\n+ */\n+public interface ReactiveCommandGateway {\n+\n+    /**\n+     * Sends the given {@code command} once the caller subscribes to the command result. Returns immediately.\n+     * <p/>\n+     * The given {@code command} is wrapped as the payload of the CommandMessage that is eventually posted on the\n+     * Command Bus, unless Command already implements {@link Message}. In that case, a\n+     * CommandMessage is constructed from that message's payload and MetaData.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c4511e81820de8d15c641e1c3038f4b688e29b51"}, "originalPosition": 36}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ1NzU1OTY1OnYy", "diffSide": "RIGHT", "path": "messaging/src/main/java/org/axonframework/messaging/ReactiveMessageDispatchInterceptor.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yM1QxMzoxMzo1NlrOF6Exig==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yM1QxMzoxMzo1NlrOF6Exig==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjQzOTk0Ng==", "bodyText": "Wouldn't hurt to add @FunctionalInterface here I think. Or, would that auto-magically be populated from the Supplier interface this interface extends?", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r396439946", "createdAt": "2020-03-23T13:13:56Z", "author": {"login": "smcvb"}, "path": "messaging/src/main/java/org/axonframework/messaging/ReactiveMessageDispatchInterceptor.java", "diffHunk": "@@ -0,0 +1,44 @@\n+/*\n+ * Copyright (c) 2010-2020. Axon Framework\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.axonframework.messaging;\n+\n+import reactor.core.publisher.Mono;\n+\n+import java.util.function.Function;\n+import java.util.function.Supplier;\n+\n+/**\n+ * Interceptor that allows messages to be intercepted and modified before they are dispatched. Implementations are\n+ * required to provide a function that modifies a {@link Mono} of a message and returns a modified/new {@link Mono} to\n+ * be passed down the interceptor chain or to be sent. This way we provide a reactive way to intercept messages.\n+ *\n+ * @param <T> the message type this interceptor can process\n+ * @author Milan Savic\n+ * @since 4.4\n+ */", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c4511e81820de8d15c641e1c3038f4b688e29b51"}, "originalPosition": 32}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ1NzU2MjczOnYy", "diffSide": "RIGHT", "path": "messaging/src/main/java/org/axonframework/messaging/ReactiveMessageDispatchInterceptor.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yM1QxMzoxNDo0NVrOF6Ezbw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yM1QxMzoxNDo0NVrOF6Ezbw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjQ0MDQzMQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             * required to provide a function that modifies a {@link Mono} of a message and returns a modified/new {@link Mono} to\n          \n          \n            \n             * be passed down the interceptor chain or to be sent. This way we provide a reactive way to intercept messages.\n          \n          \n            \n             * required to provide a function that modifies a {@link Mono} of a message and returns a modified/new {@code Mono} to\n          \n          \n            \n             * be passed down the interceptor chain or to be dispatched. This way we provide a reactive approach to intercepting messages.", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r396440431", "createdAt": "2020-03-23T13:14:45Z", "author": {"login": "smcvb"}, "path": "messaging/src/main/java/org/axonframework/messaging/ReactiveMessageDispatchInterceptor.java", "diffHunk": "@@ -0,0 +1,44 @@\n+/*\n+ * Copyright (c) 2010-2020. Axon Framework\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.axonframework.messaging;\n+\n+import reactor.core.publisher.Mono;\n+\n+import java.util.function.Function;\n+import java.util.function.Supplier;\n+\n+/**\n+ * Interceptor that allows messages to be intercepted and modified before they are dispatched. Implementations are\n+ * required to provide a function that modifies a {@link Mono} of a message and returns a modified/new {@link Mono} to\n+ * be passed down the interceptor chain or to be sent. This way we provide a reactive way to intercept messages.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c4511e81820de8d15c641e1c3038f4b688e29b51"}, "originalPosition": 27}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ1NzYwNzEwOnYy", "diffSide": "RIGHT", "path": "messaging/src/main/java/org/axonframework/queryhandling/ReactiveQueryGateway.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yM1QxMzoyNTo0MlrOF6FPfg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yM1QxMzoyNTo0MlrOF6FPfg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjQ0NzYxNA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * Sends given {@code query} over the {@link QueryBus}, expecting a response with the given {@code responseType}\n          \n          \n            \n                 * from a single source. The query name will be derived from the provided {@code query}. Execution may be\n          \n          \n            \n                 * asynchronous, depending on the QueryBus implementation.\n          \n          \n            \n                 * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n          \n          \n            \n                 * Mono}</b></p>\n          \n          \n            \n                 * Sends the given {@code query} over the {@link QueryBus}, expecting a response with the given {@code responseType}\n          \n          \n            \n                 * from a single source. The query name will be derived from the provided {@code query}. Execution may be\n          \n          \n            \n                 * asynchronous, depending on the {@code QueryBus} implementation.\n          \n          \n            \n                 * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n          \n          \n            \n                 * Mono}</b></p>", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r396447614", "createdAt": "2020-03-23T13:25:42Z", "author": {"login": "smcvb"}, "path": "messaging/src/main/java/org/axonframework/queryhandling/ReactiveQueryGateway.java", "diffHunk": "@@ -0,0 +1,386 @@\n+/*\n+ * Copyright (c) 2010-2020. Axon Framework\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.axonframework.queryhandling;\n+\n+import org.axonframework.messaging.responsetypes.ResponseType;\n+import org.axonframework.messaging.responsetypes.ResponseTypes;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Mono;\n+import reactor.util.concurrent.Queues;\n+\n+import java.util.concurrent.TimeUnit;\n+\n+/**\n+ * Variation of {@link QueryGateway}. Provides support for reactive return types such as {@link Mono} and {@link Flux}\n+ * from Project Reactor.\n+ *\n+ * @author Milan Savic\n+ * @since 4.4\n+ */\n+public interface ReactiveQueryGateway {\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus}, expecting a response with the given {@code responseType}\n+     * from a single source. The query name will be derived from the provided {@code query}. Execution may be\n+     * asynchronous, depending on the QueryBus implementation.\n+     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c4511e81820de8d15c641e1c3038f4b688e29b51"}, "originalPosition": 41}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ1NzYxMDc5OnYy", "diffSide": "RIGHT", "path": "messaging/src/main/java/org/axonframework/queryhandling/ReactiveQueryGateway.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yM1QxMzoyNjo0NFrOF6FSAw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yM1QxMzoyNjo0NFrOF6FSAw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjQ0ODI1OQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * Sends given {@code query} over the {@link QueryBus}, expecting a response with the given {@code responseType}\n          \n          \n            \n                 * from a single source. Execution may be asynchronous, depending on the QueryBus implementation.\n          \n          \n            \n                 * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n          \n          \n            \n                 * Mono}</b></p>\n          \n          \n            \n                 * Sends the given {@code query} over the {@link QueryBus}, expecting a response with the given {@code responseType}\n          \n          \n            \n                 * from a single source. Execution may be asynchronous, depending on the {@code QueryBus} implementation.\n          \n          \n            \n                 * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n          \n          \n            \n                 * Mono}</b></p>", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r396448259", "createdAt": "2020-03-23T13:26:44Z", "author": {"login": "smcvb"}, "path": "messaging/src/main/java/org/axonframework/queryhandling/ReactiveQueryGateway.java", "diffHunk": "@@ -0,0 +1,386 @@\n+/*\n+ * Copyright (c) 2010-2020. Axon Framework\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.axonframework.queryhandling;\n+\n+import org.axonframework.messaging.responsetypes.ResponseType;\n+import org.axonframework.messaging.responsetypes.ResponseTypes;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Mono;\n+import reactor.util.concurrent.Queues;\n+\n+import java.util.concurrent.TimeUnit;\n+\n+/**\n+ * Variation of {@link QueryGateway}. Provides support for reactive return types such as {@link Mono} and {@link Flux}\n+ * from Project Reactor.\n+ *\n+ * @author Milan Savic\n+ * @since 4.4\n+ */\n+public interface ReactiveQueryGateway {\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus}, expecting a response with the given {@code responseType}\n+     * from a single source. The query name will be derived from the provided {@code query}. Execution may be\n+     * asynchronous, depending on the QueryBus implementation.\n+     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param query        The {@code query} to be sent\n+     * @param responseType A {@link Class} describing the desired response type\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(Q query, Class<R> responseType) {\n+        return query(query.getClass().getName(), query, responseType);\n+    }\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus}, expecting a response with the given {@code responseType}\n+     * from a single source. Execution may be asynchronous, depending on the QueryBus implementation.\n+     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c4511e81820de8d15c641e1c3038f4b688e29b51"}, "originalPosition": 57}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ1NzYxMzM2OnYy", "diffSide": "RIGHT", "path": "messaging/src/main/java/org/axonframework/queryhandling/ReactiveQueryGateway.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yM1QxMzoyNzoyOFrOF6FTpw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yM1QxMzoyNzoyOFrOF6FTpw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjQ0ODY3OQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * Sends given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n          \n          \n            \n                 * from a single source. The query name will be derived from the provided {@code query}. Execution may be\n          \n          \n            \n                 * asynchronous, depending on the QueryBus implementation.\n          \n          \n            \n                 * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n          \n          \n            \n                 * Mono}</b></p>\n          \n          \n            \n                 * Sends the given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n          \n          \n            \n                 * from a single source. The query name will be derived from the provided {@code query}. Execution may be\n          \n          \n            \n                 * asynchronous, depending on the {@code QueryBus} implementation.\n          \n          \n            \n                 * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n          \n          \n            \n                 * Mono}</b></p>", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r396448679", "createdAt": "2020-03-23T13:27:28Z", "author": {"login": "smcvb"}, "path": "messaging/src/main/java/org/axonframework/queryhandling/ReactiveQueryGateway.java", "diffHunk": "@@ -0,0 +1,386 @@\n+/*\n+ * Copyright (c) 2010-2020. Axon Framework\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.axonframework.queryhandling;\n+\n+import org.axonframework.messaging.responsetypes.ResponseType;\n+import org.axonframework.messaging.responsetypes.ResponseTypes;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Mono;\n+import reactor.util.concurrent.Queues;\n+\n+import java.util.concurrent.TimeUnit;\n+\n+/**\n+ * Variation of {@link QueryGateway}. Provides support for reactive return types such as {@link Mono} and {@link Flux}\n+ * from Project Reactor.\n+ *\n+ * @author Milan Savic\n+ * @since 4.4\n+ */\n+public interface ReactiveQueryGateway {\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus}, expecting a response with the given {@code responseType}\n+     * from a single source. The query name will be derived from the provided {@code query}. Execution may be\n+     * asynchronous, depending on the QueryBus implementation.\n+     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param query        The {@code query} to be sent\n+     * @param responseType A {@link Class} describing the desired response type\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(Q query, Class<R> responseType) {\n+        return query(query.getClass().getName(), query, responseType);\n+    }\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus}, expecting a response with the given {@code responseType}\n+     * from a single source. Execution may be asynchronous, depending on the QueryBus implementation.\n+     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(String queryName, Q query, Class<R> responseType) {\n+        return query(queryName, query, ResponseTypes.instanceOf(responseType));\n+    }\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from a single source. The query name will be derived from the provided {@code query}. Execution may be\n+     * asynchronous, depending on the QueryBus implementation.\n+     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c4511e81820de8d15c641e1c3038f4b688e29b51"}, "originalPosition": 75}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ1NzYxNjE2OnYy", "diffSide": "RIGHT", "path": "messaging/src/main/java/org/axonframework/queryhandling/ReactiveQueryGateway.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yM1QxMzoyODowNVrOF6FVYA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yM1QxMzoyODowNVrOF6FVYA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjQ0OTEyMA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * Sends given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n          \n          \n            \n                 * from a single source. Execution may be asynchronous, depending on the QueryBus implementation.\n          \n          \n            \n                 * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n          \n          \n            \n                 * Mono}</b></p>\n          \n          \n            \n                 * Sends the given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n          \n          \n            \n                 * from a single source. Execution may be asynchronous, depending on the {@code QueryBus} implementation.\n          \n          \n            \n                 * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n          \n          \n            \n                 * Mono}</b></p>", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r396449120", "createdAt": "2020-03-23T13:28:05Z", "author": {"login": "smcvb"}, "path": "messaging/src/main/java/org/axonframework/queryhandling/ReactiveQueryGateway.java", "diffHunk": "@@ -0,0 +1,386 @@\n+/*\n+ * Copyright (c) 2010-2020. Axon Framework\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.axonframework.queryhandling;\n+\n+import org.axonframework.messaging.responsetypes.ResponseType;\n+import org.axonframework.messaging.responsetypes.ResponseTypes;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Mono;\n+import reactor.util.concurrent.Queues;\n+\n+import java.util.concurrent.TimeUnit;\n+\n+/**\n+ * Variation of {@link QueryGateway}. Provides support for reactive return types such as {@link Mono} and {@link Flux}\n+ * from Project Reactor.\n+ *\n+ * @author Milan Savic\n+ * @since 4.4\n+ */\n+public interface ReactiveQueryGateway {\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus}, expecting a response with the given {@code responseType}\n+     * from a single source. The query name will be derived from the provided {@code query}. Execution may be\n+     * asynchronous, depending on the QueryBus implementation.\n+     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param query        The {@code query} to be sent\n+     * @param responseType A {@link Class} describing the desired response type\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(Q query, Class<R> responseType) {\n+        return query(query.getClass().getName(), query, responseType);\n+    }\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus}, expecting a response with the given {@code responseType}\n+     * from a single source. Execution may be asynchronous, depending on the QueryBus implementation.\n+     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(String queryName, Q query, Class<R> responseType) {\n+        return query(queryName, query, ResponseTypes.instanceOf(responseType));\n+    }\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from a single source. The query name will be derived from the provided {@code query}. Execution may be\n+     * asynchronous, depending on the QueryBus implementation.\n+     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(Q query, ResponseType<R> responseType) {\n+        return query(query.getClass().getName(), query, responseType);\n+    }\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from a single source. Execution may be asynchronous, depending on the QueryBus implementation.\n+     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c4511e81820de8d15c641e1c3038f4b688e29b51"}, "originalPosition": 91}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ1NzYyMDQwOnYy", "diffSide": "RIGHT", "path": "messaging/src/main/java/org/axonframework/queryhandling/ReactiveQueryGateway.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yM1QxMzoyODo1OFrOF6FX4g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yM1QxMzoyODo1OFrOF6FX4g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjQ0OTc2Mg==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * Sends given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n          \n          \n            \n                 * from a single source. Execution may be asynchronous, depending on the QueryBus implementation.\n          \n          \n            \n                 * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n          \n          \n            \n                 * Mono}</b></p>\n          \n          \n            \n                 * Sends the given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n          \n          \n            \n                 * from a single source. Execution may be asynchronous, depending on the {@code QueryBus} implementation.\n          \n          \n            \n                 * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n          \n          \n            \n                 * Mono}</b></p>", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r396449762", "createdAt": "2020-03-23T13:28:58Z", "author": {"login": "smcvb"}, "path": "messaging/src/main/java/org/axonframework/queryhandling/ReactiveQueryGateway.java", "diffHunk": "@@ -0,0 +1,386 @@\n+/*\n+ * Copyright (c) 2010-2020. Axon Framework\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.axonframework.queryhandling;\n+\n+import org.axonframework.messaging.responsetypes.ResponseType;\n+import org.axonframework.messaging.responsetypes.ResponseTypes;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Mono;\n+import reactor.util.concurrent.Queues;\n+\n+import java.util.concurrent.TimeUnit;\n+\n+/**\n+ * Variation of {@link QueryGateway}. Provides support for reactive return types such as {@link Mono} and {@link Flux}\n+ * from Project Reactor.\n+ *\n+ * @author Milan Savic\n+ * @since 4.4\n+ */\n+public interface ReactiveQueryGateway {\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus}, expecting a response with the given {@code responseType}\n+     * from a single source. The query name will be derived from the provided {@code query}. Execution may be\n+     * asynchronous, depending on the QueryBus implementation.\n+     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param query        The {@code query} to be sent\n+     * @param responseType A {@link Class} describing the desired response type\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(Q query, Class<R> responseType) {\n+        return query(query.getClass().getName(), query, responseType);\n+    }\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus}, expecting a response with the given {@code responseType}\n+     * from a single source. Execution may be asynchronous, depending on the QueryBus implementation.\n+     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(String queryName, Q query, Class<R> responseType) {\n+        return query(queryName, query, ResponseTypes.instanceOf(responseType));\n+    }\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from a single source. The query name will be derived from the provided {@code query}. Execution may be\n+     * asynchronous, depending on the QueryBus implementation.\n+     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(Q query, ResponseType<R> responseType) {\n+        return query(query.getClass().getName(), query, responseType);\n+    }\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from a single source. Execution may be asynchronous, depending on the QueryBus implementation.\n+     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(String queryName, Q query, ResponseType<R> responseType) {\n+        return query(queryName, Mono.just(query), responseType);\n+    }\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from a single source. Execution may be asynchronous, depending on the QueryBus implementation.\n+     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c4511e81820de8d15c641e1c3038f4b688e29b51"}, "originalPosition": 108}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ1NzYyOTk5OnYy", "diffSide": "RIGHT", "path": "messaging/src/main/java/org/axonframework/queryhandling/ReactiveQueryGateway.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yM1QxMzozMToxM1rOF6Fd2w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yM1QxMzozMToxM1rOF6Fd2w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjQ1MTI5MQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * Sends given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n          \n          \n            \n                 * from several sources. The flux is completed when a {@code timeout} occurs or when all results are received. The\n          \n          \n            \n                 * query name will be derived from the provided {@code query}. Execution may be asynchronous, depending on the\n          \n          \n            \n                 * QueryBus implementation.\n          \n          \n            \n                 * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n          \n          \n            \n                 * Mono}</b></p>\n          \n          \n            \n                 * <b>Note</b>: Any {@code null} results will be filtered out by the QueryGateway. If you require the {@code null}\n          \n          \n            \n                 * to be returned, we suggest using {@link QueryBus} instead.\n          \n          \n            \n                 * Sends the given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n          \n          \n            \n                 * from several sources. The returned {@link Flux} is completed when a {@code timeout} occurs or when all possible results are received. The\n          \n          \n            \n                 * query name will be derived from the provided {@code query}. Execution may be asynchronous, depending on the\n          \n          \n            \n                 * {@code QueryBus} implementation.\n          \n          \n            \n                 * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n          \n          \n            \n                 * Mono}</b></p>\n          \n          \n            \n                 * <b>Note</b>: Any {@code null} results will be filtered out by the {@link ReactiveQueryGateway}. If you require the {@code null}\n          \n          \n            \n                 * to be returned, we suggest using {@code QueryBus} instead.", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r396451291", "createdAt": "2020-03-23T13:31:13Z", "author": {"login": "smcvb"}, "path": "messaging/src/main/java/org/axonframework/queryhandling/ReactiveQueryGateway.java", "diffHunk": "@@ -0,0 +1,386 @@\n+/*\n+ * Copyright (c) 2010-2020. Axon Framework\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.axonframework.queryhandling;\n+\n+import org.axonframework.messaging.responsetypes.ResponseType;\n+import org.axonframework.messaging.responsetypes.ResponseTypes;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Mono;\n+import reactor.util.concurrent.Queues;\n+\n+import java.util.concurrent.TimeUnit;\n+\n+/**\n+ * Variation of {@link QueryGateway}. Provides support for reactive return types such as {@link Mono} and {@link Flux}\n+ * from Project Reactor.\n+ *\n+ * @author Milan Savic\n+ * @since 4.4\n+ */\n+public interface ReactiveQueryGateway {\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus}, expecting a response with the given {@code responseType}\n+     * from a single source. The query name will be derived from the provided {@code query}. Execution may be\n+     * asynchronous, depending on the QueryBus implementation.\n+     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param query        The {@code query} to be sent\n+     * @param responseType A {@link Class} describing the desired response type\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(Q query, Class<R> responseType) {\n+        return query(query.getClass().getName(), query, responseType);\n+    }\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus}, expecting a response with the given {@code responseType}\n+     * from a single source. Execution may be asynchronous, depending on the QueryBus implementation.\n+     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(String queryName, Q query, Class<R> responseType) {\n+        return query(queryName, query, ResponseTypes.instanceOf(responseType));\n+    }\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from a single source. The query name will be derived from the provided {@code query}. Execution may be\n+     * asynchronous, depending on the QueryBus implementation.\n+     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(Q query, ResponseType<R> responseType) {\n+        return query(query.getClass().getName(), query, responseType);\n+    }\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from a single source. Execution may be asynchronous, depending on the QueryBus implementation.\n+     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(String queryName, Q query, ResponseType<R> responseType) {\n+        return query(queryName, Mono.just(query), responseType);\n+    }\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from a single source. Execution may be asynchronous, depending on the QueryBus implementation.\n+     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        a {@link Mono} which is resolved once the caller subscribes to the query result\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    <R, Q> Mono<R> query(String queryName, Mono<Q> query, ResponseType<R> responseType);\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from several sources. The flux is completed when a {@code timeout} occurs or when all results are received. The\n+     * query name will be derived from the provided {@code query}. Execution may be asynchronous, depending on the\n+     * QueryBus implementation.\n+     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     * <b>Note</b>: Any {@code null} results will be filtered out by the QueryGateway. If you require the {@code null}\n+     * to be returned, we suggest using {@link QueryBus} instead.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c4511e81820de8d15c641e1c3038f4b688e29b51"}, "originalPosition": 127}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ1NzYzODc5OnYy", "diffSide": "RIGHT", "path": "messaging/src/main/java/org/axonframework/queryhandling/ReactiveQueryGateway.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yM1QxMzozMzoyNVrOF6Fjjg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yM1QxMzozMzoyNVrOF6Fjjg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjQ1Mjc1MA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * @return A flux of results\n          \n          \n            \n                 * @return A {@link Flux} containing the query results as dictated by the given {@code responseType}", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r396452750", "createdAt": "2020-03-23T13:33:25Z", "author": {"login": "smcvb"}, "path": "messaging/src/main/java/org/axonframework/queryhandling/ReactiveQueryGateway.java", "diffHunk": "@@ -0,0 +1,386 @@\n+/*\n+ * Copyright (c) 2010-2020. Axon Framework\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.axonframework.queryhandling;\n+\n+import org.axonframework.messaging.responsetypes.ResponseType;\n+import org.axonframework.messaging.responsetypes.ResponseTypes;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Mono;\n+import reactor.util.concurrent.Queues;\n+\n+import java.util.concurrent.TimeUnit;\n+\n+/**\n+ * Variation of {@link QueryGateway}. Provides support for reactive return types such as {@link Mono} and {@link Flux}\n+ * from Project Reactor.\n+ *\n+ * @author Milan Savic\n+ * @since 4.4\n+ */\n+public interface ReactiveQueryGateway {\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus}, expecting a response with the given {@code responseType}\n+     * from a single source. The query name will be derived from the provided {@code query}. Execution may be\n+     * asynchronous, depending on the QueryBus implementation.\n+     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param query        The {@code query} to be sent\n+     * @param responseType A {@link Class} describing the desired response type\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(Q query, Class<R> responseType) {\n+        return query(query.getClass().getName(), query, responseType);\n+    }\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus}, expecting a response with the given {@code responseType}\n+     * from a single source. Execution may be asynchronous, depending on the QueryBus implementation.\n+     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(String queryName, Q query, Class<R> responseType) {\n+        return query(queryName, query, ResponseTypes.instanceOf(responseType));\n+    }\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from a single source. The query name will be derived from the provided {@code query}. Execution may be\n+     * asynchronous, depending on the QueryBus implementation.\n+     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(Q query, ResponseType<R> responseType) {\n+        return query(query.getClass().getName(), query, responseType);\n+    }\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from a single source. Execution may be asynchronous, depending on the QueryBus implementation.\n+     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(String queryName, Q query, ResponseType<R> responseType) {\n+        return query(queryName, Mono.just(query), responseType);\n+    }\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from a single source. Execution may be asynchronous, depending on the QueryBus implementation.\n+     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        a {@link Mono} which is resolved once the caller subscribes to the query result\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    <R, Q> Mono<R> query(String queryName, Mono<Q> query, ResponseType<R> responseType);\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from several sources. The flux is completed when a {@code timeout} occurs or when all results are received. The\n+     * query name will be derived from the provided {@code query}. Execution may be asynchronous, depending on the\n+     * QueryBus implementation.\n+     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     * <b>Note</b>: Any {@code null} results will be filtered out by the QueryGateway. If you require the {@code null}\n+     * to be returned, we suggest using {@link QueryBus} instead.\n+     *\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param timeout      A timeout of {@code long} for the query\n+     * @param timeUnit     The selected {@link TimeUnit} for the given {@code timeout}\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A flux of results", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c4511e81820de8d15c641e1c3038f4b688e29b51"}, "originalPosition": 135}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ1NzY0MTMxOnYy", "diffSide": "RIGHT", "path": "messaging/src/main/java/org/axonframework/queryhandling/ReactiveQueryGateway.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yM1QxMzozMzo1OVrOF6FlEw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yM1QxMzozMzo1OVrOF6FlEw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjQ1MzEzOQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * @return A flux of results.\n          \n          \n            \n                 * @return A {@link Flux} containing the query results as dictated by the given {@code responseType}", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r396453139", "createdAt": "2020-03-23T13:33:59Z", "author": {"login": "smcvb"}, "path": "messaging/src/main/java/org/axonframework/queryhandling/ReactiveQueryGateway.java", "diffHunk": "@@ -0,0 +1,386 @@\n+/*\n+ * Copyright (c) 2010-2020. Axon Framework\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.axonframework.queryhandling;\n+\n+import org.axonframework.messaging.responsetypes.ResponseType;\n+import org.axonframework.messaging.responsetypes.ResponseTypes;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Mono;\n+import reactor.util.concurrent.Queues;\n+\n+import java.util.concurrent.TimeUnit;\n+\n+/**\n+ * Variation of {@link QueryGateway}. Provides support for reactive return types such as {@link Mono} and {@link Flux}\n+ * from Project Reactor.\n+ *\n+ * @author Milan Savic\n+ * @since 4.4\n+ */\n+public interface ReactiveQueryGateway {\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus}, expecting a response with the given {@code responseType}\n+     * from a single source. The query name will be derived from the provided {@code query}. Execution may be\n+     * asynchronous, depending on the QueryBus implementation.\n+     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param query        The {@code query} to be sent\n+     * @param responseType A {@link Class} describing the desired response type\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(Q query, Class<R> responseType) {\n+        return query(query.getClass().getName(), query, responseType);\n+    }\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus}, expecting a response with the given {@code responseType}\n+     * from a single source. Execution may be asynchronous, depending on the QueryBus implementation.\n+     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(String queryName, Q query, Class<R> responseType) {\n+        return query(queryName, query, ResponseTypes.instanceOf(responseType));\n+    }\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from a single source. The query name will be derived from the provided {@code query}. Execution may be\n+     * asynchronous, depending on the QueryBus implementation.\n+     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(Q query, ResponseType<R> responseType) {\n+        return query(query.getClass().getName(), query, responseType);\n+    }\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from a single source. Execution may be asynchronous, depending on the QueryBus implementation.\n+     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(String queryName, Q query, ResponseType<R> responseType) {\n+        return query(queryName, Mono.just(query), responseType);\n+    }\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from a single source. Execution may be asynchronous, depending on the QueryBus implementation.\n+     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        a {@link Mono} which is resolved once the caller subscribes to the query result\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    <R, Q> Mono<R> query(String queryName, Mono<Q> query, ResponseType<R> responseType);\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from several sources. The flux is completed when a {@code timeout} occurs or when all results are received. The\n+     * query name will be derived from the provided {@code query}. Execution may be asynchronous, depending on the\n+     * QueryBus implementation.\n+     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     * <b>Note</b>: Any {@code null} results will be filtered out by the QueryGateway. If you require the {@code null}\n+     * to be returned, we suggest using {@link QueryBus} instead.\n+     *\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param timeout      A timeout of {@code long} for the query\n+     * @param timeUnit     The selected {@link TimeUnit} for the given {@code timeout}\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A flux of results\n+     */\n+    default <R, Q> Flux<R> scatterGather(Q query, ResponseType<R> responseType, long timeout, TimeUnit timeUnit) {\n+        return scatterGather(query.getClass().getName(), query, responseType, timeout, timeUnit);\n+    }\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from several sources. The flux is completed when a {@code timeout} occurs or when all results are received.\n+     * Execution may be asynchronous, depending on the QueryBus implementation.\n+     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     * <b>Note</b>: Any {@code null} results will be filtered out by the QueryGateway. If you require the {@code null}\n+     * to be returned, we suggest using {@link QueryBus} instead.\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param timeout      A timeout of {@code long} for the query\n+     * @param timeUnit     The selected {@link TimeUnit} for the given {@code timeout}\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A flux of results.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c4511e81820de8d15c641e1c3038f4b688e29b51"}, "originalPosition": 157}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ1NzY0MjA2OnYy", "diffSide": "RIGHT", "path": "messaging/src/main/java/org/axonframework/queryhandling/ReactiveQueryGateway.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yM1QxMzozNDoxMFrOF6Flig==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yM1QxMzozNDoxMFrOF6Flig==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjQ1MzI1OA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * @return A flux of results.\n          \n          \n            \n                 * @return A {@link Flux} containing the query results as dictated by the given {@code responseType}", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r396453258", "createdAt": "2020-03-23T13:34:10Z", "author": {"login": "smcvb"}, "path": "messaging/src/main/java/org/axonframework/queryhandling/ReactiveQueryGateway.java", "diffHunk": "@@ -0,0 +1,386 @@\n+/*\n+ * Copyright (c) 2010-2020. Axon Framework\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.axonframework.queryhandling;\n+\n+import org.axonframework.messaging.responsetypes.ResponseType;\n+import org.axonframework.messaging.responsetypes.ResponseTypes;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Mono;\n+import reactor.util.concurrent.Queues;\n+\n+import java.util.concurrent.TimeUnit;\n+\n+/**\n+ * Variation of {@link QueryGateway}. Provides support for reactive return types such as {@link Mono} and {@link Flux}\n+ * from Project Reactor.\n+ *\n+ * @author Milan Savic\n+ * @since 4.4\n+ */\n+public interface ReactiveQueryGateway {\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus}, expecting a response with the given {@code responseType}\n+     * from a single source. The query name will be derived from the provided {@code query}. Execution may be\n+     * asynchronous, depending on the QueryBus implementation.\n+     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param query        The {@code query} to be sent\n+     * @param responseType A {@link Class} describing the desired response type\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(Q query, Class<R> responseType) {\n+        return query(query.getClass().getName(), query, responseType);\n+    }\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus}, expecting a response with the given {@code responseType}\n+     * from a single source. Execution may be asynchronous, depending on the QueryBus implementation.\n+     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(String queryName, Q query, Class<R> responseType) {\n+        return query(queryName, query, ResponseTypes.instanceOf(responseType));\n+    }\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from a single source. The query name will be derived from the provided {@code query}. Execution may be\n+     * asynchronous, depending on the QueryBus implementation.\n+     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(Q query, ResponseType<R> responseType) {\n+        return query(query.getClass().getName(), query, responseType);\n+    }\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from a single source. Execution may be asynchronous, depending on the QueryBus implementation.\n+     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(String queryName, Q query, ResponseType<R> responseType) {\n+        return query(queryName, Mono.just(query), responseType);\n+    }\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from a single source. Execution may be asynchronous, depending on the QueryBus implementation.\n+     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        a {@link Mono} which is resolved once the caller subscribes to the query result\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    <R, Q> Mono<R> query(String queryName, Mono<Q> query, ResponseType<R> responseType);\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from several sources. The flux is completed when a {@code timeout} occurs or when all results are received. The\n+     * query name will be derived from the provided {@code query}. Execution may be asynchronous, depending on the\n+     * QueryBus implementation.\n+     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     * <b>Note</b>: Any {@code null} results will be filtered out by the QueryGateway. If you require the {@code null}\n+     * to be returned, we suggest using {@link QueryBus} instead.\n+     *\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param timeout      A timeout of {@code long} for the query\n+     * @param timeUnit     The selected {@link TimeUnit} for the given {@code timeout}\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A flux of results\n+     */\n+    default <R, Q> Flux<R> scatterGather(Q query, ResponseType<R> responseType, long timeout, TimeUnit timeUnit) {\n+        return scatterGather(query.getClass().getName(), query, responseType, timeout, timeUnit);\n+    }\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from several sources. The flux is completed when a {@code timeout} occurs or when all results are received.\n+     * Execution may be asynchronous, depending on the QueryBus implementation.\n+     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     * <b>Note</b>: Any {@code null} results will be filtered out by the QueryGateway. If you require the {@code null}\n+     * to be returned, we suggest using {@link QueryBus} instead.\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param timeout      A timeout of {@code long} for the query\n+     * @param timeUnit     The selected {@link TimeUnit} for the given {@code timeout}\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A flux of results.\n+     */\n+    default <R, Q> Flux<R> scatterGather(String queryName, Q query, ResponseType<R> responseType, long timeout,\n+                                         TimeUnit timeUnit) {\n+        return scatterGather(queryName, Mono.just(query), responseType, timeout, timeUnit);\n+    }\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from several sources. The flux is completed when a {@code timeout} occurs or when all results are received.\n+     * Execution may be asynchronous, depending on the QueryBus implementation.\n+     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     * <b>Note</b>: Any {@code null} results will be filtered out by the QueryGateway. If you require the {@code null}\n+     * to be returned, we suggest using {@link QueryBus} instead.\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        a {@link Mono} which is resolved once the caller subscribes to the query result\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param timeout      A timeout of {@code long} for the query\n+     * @param timeUnit     The selected {@link TimeUnit} for the given {@code timeout}\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A flux of results.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c4511e81820de8d15c641e1c3038f4b688e29b51"}, "originalPosition": 180}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ1NzY0ODQwOnYy", "diffSide": "RIGHT", "path": "messaging/src/main/java/org/axonframework/queryhandling/ReactiveQueryGateway.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yM1QxMzozNTozOVrOF6Fpfw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yM1QxMzozNTozOVrOF6Fpfw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjQ1NDI3MQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * Sends given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n          \n          \n            \n                 * from several sources. The flux is completed when a {@code timeout} occurs or when all results are received.\n          \n          \n            \n                 * Execution may be asynchronous, depending on the QueryBus implementation.\n          \n          \n            \n                 * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n          \n          \n            \n                 * Mono}</b></p>\n          \n          \n            \n                 * <b>Note</b>: Any {@code null} results will be filtered out by the QueryGateway. If you require the {@code null}\n          \n          \n            \n                 * to be returned, we suggest using {@link QueryBus} instead.\n          \n          \n            \n                 * Sends the given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n          \n          \n            \n                 * from several sources. The returned {@link Flux} is completed when a {@code timeout} occurs or when all results are received.\n          \n          \n            \n                 * Execution may be asynchronous, depending on the {@code QueryBus} implementation.\n          \n          \n            \n                 * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n          \n          \n            \n                 * Mono}</b></p>\n          \n          \n            \n                 * <b>Note</b>: Any {@code null} results will be filtered out by the {@link ReactiveQueryGateway}. If you require the {@code null}\n          \n          \n            \n                 * to be returned, we suggest using {@code QueryBus} instead.", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r396454271", "createdAt": "2020-03-23T13:35:39Z", "author": {"login": "smcvb"}, "path": "messaging/src/main/java/org/axonframework/queryhandling/ReactiveQueryGateway.java", "diffHunk": "@@ -0,0 +1,386 @@\n+/*\n+ * Copyright (c) 2010-2020. Axon Framework\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.axonframework.queryhandling;\n+\n+import org.axonframework.messaging.responsetypes.ResponseType;\n+import org.axonframework.messaging.responsetypes.ResponseTypes;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Mono;\n+import reactor.util.concurrent.Queues;\n+\n+import java.util.concurrent.TimeUnit;\n+\n+/**\n+ * Variation of {@link QueryGateway}. Provides support for reactive return types such as {@link Mono} and {@link Flux}\n+ * from Project Reactor.\n+ *\n+ * @author Milan Savic\n+ * @since 4.4\n+ */\n+public interface ReactiveQueryGateway {\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus}, expecting a response with the given {@code responseType}\n+     * from a single source. The query name will be derived from the provided {@code query}. Execution may be\n+     * asynchronous, depending on the QueryBus implementation.\n+     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param query        The {@code query} to be sent\n+     * @param responseType A {@link Class} describing the desired response type\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(Q query, Class<R> responseType) {\n+        return query(query.getClass().getName(), query, responseType);\n+    }\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus}, expecting a response with the given {@code responseType}\n+     * from a single source. Execution may be asynchronous, depending on the QueryBus implementation.\n+     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(String queryName, Q query, Class<R> responseType) {\n+        return query(queryName, query, ResponseTypes.instanceOf(responseType));\n+    }\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from a single source. The query name will be derived from the provided {@code query}. Execution may be\n+     * asynchronous, depending on the QueryBus implementation.\n+     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(Q query, ResponseType<R> responseType) {\n+        return query(query.getClass().getName(), query, responseType);\n+    }\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from a single source. Execution may be asynchronous, depending on the QueryBus implementation.\n+     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(String queryName, Q query, ResponseType<R> responseType) {\n+        return query(queryName, Mono.just(query), responseType);\n+    }\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from a single source. Execution may be asynchronous, depending on the QueryBus implementation.\n+     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        a {@link Mono} which is resolved once the caller subscribes to the query result\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    <R, Q> Mono<R> query(String queryName, Mono<Q> query, ResponseType<R> responseType);\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from several sources. The flux is completed when a {@code timeout} occurs or when all results are received. The\n+     * query name will be derived from the provided {@code query}. Execution may be asynchronous, depending on the\n+     * QueryBus implementation.\n+     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     * <b>Note</b>: Any {@code null} results will be filtered out by the QueryGateway. If you require the {@code null}\n+     * to be returned, we suggest using {@link QueryBus} instead.\n+     *\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param timeout      A timeout of {@code long} for the query\n+     * @param timeUnit     The selected {@link TimeUnit} for the given {@code timeout}\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A flux of results\n+     */\n+    default <R, Q> Flux<R> scatterGather(Q query, ResponseType<R> responseType, long timeout, TimeUnit timeUnit) {\n+        return scatterGather(query.getClass().getName(), query, responseType, timeout, timeUnit);\n+    }\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from several sources. The flux is completed when a {@code timeout} occurs or when all results are received.\n+     * Execution may be asynchronous, depending on the QueryBus implementation.\n+     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     * <b>Note</b>: Any {@code null} results will be filtered out by the QueryGateway. If you require the {@code null}\n+     * to be returned, we suggest using {@link QueryBus} instead.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c4511e81820de8d15c641e1c3038f4b688e29b51"}, "originalPosition": 148}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ1NzY1NzE5OnYy", "diffSide": "RIGHT", "path": "messaging/src/main/java/org/axonframework/queryhandling/ReactiveQueryGateway.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yM1QxMzozNzo0N1rOF6FvHA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yM1QxMzozNzo0N1rOF6FvHA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjQ1NTcwOA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * Sends given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n          \n          \n            \n                 * from several sources. The flux is completed when a {@code timeout} occurs or when all results are received.\n          \n          \n            \n                 * Execution may be asynchronous, depending on the QueryBus implementation.\n          \n          \n            \n                 * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n          \n          \n            \n                 * Mono}</b></p>\n          \n          \n            \n                 * <b>Note</b>: Any {@code null} results will be filtered out by the QueryGateway. If you require the {@code null}\n          \n          \n            \n                 * to be returned, we suggest using {@link QueryBus} instead.\n          \n          \n            \n                 * Sends the given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n          \n          \n            \n                 * from several sources. The returned {@link Flux} is completed when a {@code timeout} occurs or when all results are received.\n          \n          \n            \n                 * Execution may be asynchronous, depending on the {@code QueryBus} implementation.\n          \n          \n            \n                 * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n          \n          \n            \n                 * Mono}</b></p>\n          \n          \n            \n                 * <b>Note</b>: Any {@code null} results will be filtered out by the {@link ReactiveQueryGateway}. If you require the {@code null}\n          \n          \n            \n                 * to be returned, we suggest using {@code QueryBus} instead.", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r396455708", "createdAt": "2020-03-23T13:37:47Z", "author": {"login": "smcvb"}, "path": "messaging/src/main/java/org/axonframework/queryhandling/ReactiveQueryGateway.java", "diffHunk": "@@ -0,0 +1,386 @@\n+/*\n+ * Copyright (c) 2010-2020. Axon Framework\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.axonframework.queryhandling;\n+\n+import org.axonframework.messaging.responsetypes.ResponseType;\n+import org.axonframework.messaging.responsetypes.ResponseTypes;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Mono;\n+import reactor.util.concurrent.Queues;\n+\n+import java.util.concurrent.TimeUnit;\n+\n+/**\n+ * Variation of {@link QueryGateway}. Provides support for reactive return types such as {@link Mono} and {@link Flux}\n+ * from Project Reactor.\n+ *\n+ * @author Milan Savic\n+ * @since 4.4\n+ */\n+public interface ReactiveQueryGateway {\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus}, expecting a response with the given {@code responseType}\n+     * from a single source. The query name will be derived from the provided {@code query}. Execution may be\n+     * asynchronous, depending on the QueryBus implementation.\n+     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param query        The {@code query} to be sent\n+     * @param responseType A {@link Class} describing the desired response type\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(Q query, Class<R> responseType) {\n+        return query(query.getClass().getName(), query, responseType);\n+    }\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus}, expecting a response with the given {@code responseType}\n+     * from a single source. Execution may be asynchronous, depending on the QueryBus implementation.\n+     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(String queryName, Q query, Class<R> responseType) {\n+        return query(queryName, query, ResponseTypes.instanceOf(responseType));\n+    }\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from a single source. The query name will be derived from the provided {@code query}. Execution may be\n+     * asynchronous, depending on the QueryBus implementation.\n+     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(Q query, ResponseType<R> responseType) {\n+        return query(query.getClass().getName(), query, responseType);\n+    }\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from a single source. Execution may be asynchronous, depending on the QueryBus implementation.\n+     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(String queryName, Q query, ResponseType<R> responseType) {\n+        return query(queryName, Mono.just(query), responseType);\n+    }\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from a single source. Execution may be asynchronous, depending on the QueryBus implementation.\n+     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        a {@link Mono} which is resolved once the caller subscribes to the query result\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    <R, Q> Mono<R> query(String queryName, Mono<Q> query, ResponseType<R> responseType);\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from several sources. The flux is completed when a {@code timeout} occurs or when all results are received. The\n+     * query name will be derived from the provided {@code query}. Execution may be asynchronous, depending on the\n+     * QueryBus implementation.\n+     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     * <b>Note</b>: Any {@code null} results will be filtered out by the QueryGateway. If you require the {@code null}\n+     * to be returned, we suggest using {@link QueryBus} instead.\n+     *\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param timeout      A timeout of {@code long} for the query\n+     * @param timeUnit     The selected {@link TimeUnit} for the given {@code timeout}\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A flux of results\n+     */\n+    default <R, Q> Flux<R> scatterGather(Q query, ResponseType<R> responseType, long timeout, TimeUnit timeUnit) {\n+        return scatterGather(query.getClass().getName(), query, responseType, timeout, timeUnit);\n+    }\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from several sources. The flux is completed when a {@code timeout} occurs or when all results are received.\n+     * Execution may be asynchronous, depending on the QueryBus implementation.\n+     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     * <b>Note</b>: Any {@code null} results will be filtered out by the QueryGateway. If you require the {@code null}\n+     * to be returned, we suggest using {@link QueryBus} instead.\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param timeout      A timeout of {@code long} for the query\n+     * @param timeUnit     The selected {@link TimeUnit} for the given {@code timeout}\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A flux of results.\n+     */\n+    default <R, Q> Flux<R> scatterGather(String queryName, Q query, ResponseType<R> responseType, long timeout,\n+                                         TimeUnit timeUnit) {\n+        return scatterGather(queryName, Mono.just(query), responseType, timeout, timeUnit);\n+    }\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from several sources. The flux is completed when a {@code timeout} occurs or when all results are received.\n+     * Execution may be asynchronous, depending on the QueryBus implementation.\n+     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     * <b>Note</b>: Any {@code null} results will be filtered out by the QueryGateway. If you require the {@code null}\n+     * to be returned, we suggest using {@link QueryBus} instead.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c4511e81820de8d15c641e1c3038f4b688e29b51"}, "originalPosition": 171}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ1NzcyMjMwOnYy", "diffSide": "RIGHT", "path": "messaging/src/main/java/org/axonframework/queryhandling/ReactiveQueryGateway.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yM1QxMzo1MjozNFrOF6GXbg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yM1QxMzo1MjozNFrOF6GXbg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjQ2NjAzMA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * Sends given {@code query} over the {@link QueryBus} and returns result containing initial response and\n          \n          \n            \n                 * incremental updates (received at the moment the query is sent, until it is cancelled by the caller or closed by\n          \n          \n            \n                 * the emitting side).\n          \n          \n            \n                 * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n          \n          \n            \n                 * Mono}</b></p>\n          \n          \n            \n                 * <p>\n          \n          \n            \n                 * <b>Note</b>: Any {@code null} results, on the initial result or the updates, will be filtered out by the\n          \n          \n            \n                 * QueryGateway. If you require the {@code null} to be returned for the initial and update results, we suggest using\n          \n          \n            \n                 * the {@link QueryBus} instead.\n          \n          \n            \n                 * Sends the given {@code query} over the {@link QueryBus} and returns result containing initial response and\n          \n          \n            \n                 * incremental updates (received at the moment the query is sent, until it is cancelled by the caller or closed by\n          \n          \n            \n                 * the emitting side).\n          \n          \n            \n                 * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n          \n          \n            \n                 * Mono}</b></p>\n          \n          \n            \n                 * <p>\n          \n          \n            \n                 * <b>Note</b>: Any {@code null} results, on the initial result or the updates, will be filtered out by the\n          \n          \n            \n                 * {@link ReactiveQueryGateway}. If you require the {@code null} to be returned for the initial and update results, we suggest using\n          \n          \n            \n                 * the {@code QueryBus} instead.", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r396466030", "createdAt": "2020-03-23T13:52:34Z", "author": {"login": "smcvb"}, "path": "messaging/src/main/java/org/axonframework/queryhandling/ReactiveQueryGateway.java", "diffHunk": "@@ -0,0 +1,386 @@\n+/*\n+ * Copyright (c) 2010-2020. Axon Framework\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.axonframework.queryhandling;\n+\n+import org.axonframework.messaging.responsetypes.ResponseType;\n+import org.axonframework.messaging.responsetypes.ResponseTypes;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Mono;\n+import reactor.util.concurrent.Queues;\n+\n+import java.util.concurrent.TimeUnit;\n+\n+/**\n+ * Variation of {@link QueryGateway}. Provides support for reactive return types such as {@link Mono} and {@link Flux}\n+ * from Project Reactor.\n+ *\n+ * @author Milan Savic\n+ * @since 4.4\n+ */\n+public interface ReactiveQueryGateway {\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus}, expecting a response with the given {@code responseType}\n+     * from a single source. The query name will be derived from the provided {@code query}. Execution may be\n+     * asynchronous, depending on the QueryBus implementation.\n+     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param query        The {@code query} to be sent\n+     * @param responseType A {@link Class} describing the desired response type\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(Q query, Class<R> responseType) {\n+        return query(query.getClass().getName(), query, responseType);\n+    }\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus}, expecting a response with the given {@code responseType}\n+     * from a single source. Execution may be asynchronous, depending on the QueryBus implementation.\n+     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(String queryName, Q query, Class<R> responseType) {\n+        return query(queryName, query, ResponseTypes.instanceOf(responseType));\n+    }\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from a single source. The query name will be derived from the provided {@code query}. Execution may be\n+     * asynchronous, depending on the QueryBus implementation.\n+     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(Q query, ResponseType<R> responseType) {\n+        return query(query.getClass().getName(), query, responseType);\n+    }\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from a single source. Execution may be asynchronous, depending on the QueryBus implementation.\n+     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(String queryName, Q query, ResponseType<R> responseType) {\n+        return query(queryName, Mono.just(query), responseType);\n+    }\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from a single source. Execution may be asynchronous, depending on the QueryBus implementation.\n+     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        a {@link Mono} which is resolved once the caller subscribes to the query result\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    <R, Q> Mono<R> query(String queryName, Mono<Q> query, ResponseType<R> responseType);\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from several sources. The flux is completed when a {@code timeout} occurs or when all results are received. The\n+     * query name will be derived from the provided {@code query}. Execution may be asynchronous, depending on the\n+     * QueryBus implementation.\n+     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     * <b>Note</b>: Any {@code null} results will be filtered out by the QueryGateway. If you require the {@code null}\n+     * to be returned, we suggest using {@link QueryBus} instead.\n+     *\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param timeout      A timeout of {@code long} for the query\n+     * @param timeUnit     The selected {@link TimeUnit} for the given {@code timeout}\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A flux of results\n+     */\n+    default <R, Q> Flux<R> scatterGather(Q query, ResponseType<R> responseType, long timeout, TimeUnit timeUnit) {\n+        return scatterGather(query.getClass().getName(), query, responseType, timeout, timeUnit);\n+    }\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from several sources. The flux is completed when a {@code timeout} occurs or when all results are received.\n+     * Execution may be asynchronous, depending on the QueryBus implementation.\n+     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     * <b>Note</b>: Any {@code null} results will be filtered out by the QueryGateway. If you require the {@code null}\n+     * to be returned, we suggest using {@link QueryBus} instead.\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param timeout      A timeout of {@code long} for the query\n+     * @param timeUnit     The selected {@link TimeUnit} for the given {@code timeout}\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A flux of results.\n+     */\n+    default <R, Q> Flux<R> scatterGather(String queryName, Q query, ResponseType<R> responseType, long timeout,\n+                                         TimeUnit timeUnit) {\n+        return scatterGather(queryName, Mono.just(query), responseType, timeout, timeUnit);\n+    }\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from several sources. The flux is completed when a {@code timeout} occurs or when all results are received.\n+     * Execution may be asynchronous, depending on the QueryBus implementation.\n+     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     * <b>Note</b>: Any {@code null} results will be filtered out by the QueryGateway. If you require the {@code null}\n+     * to be returned, we suggest using {@link QueryBus} instead.\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        a {@link Mono} which is resolved once the caller subscribes to the query result\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param timeout      A timeout of {@code long} for the query\n+     * @param timeUnit     The selected {@link TimeUnit} for the given {@code timeout}\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A flux of results.\n+     */\n+    <R, Q> Flux<R> scatterGather(String queryName, Mono<Q> query, ResponseType<R> responseType, long timeout,\n+                                 TimeUnit timeUnit);\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus} and returns result containing initial response and\n+     * incremental updates (received at the moment the query is sent, until it is cancelled by the caller or closed by\n+     * the emitting side).\n+     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     * <p>\n+     * <b>Note</b>: Any {@code null} results, on the initial result or the updates, will be filtered out by the\n+     * QueryGateway. If you require the {@code null} to be returned for the initial and update results, we suggest using\n+     * the {@link QueryBus} instead.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c4511e81820de8d15c641e1c3038f4b688e29b51"}, "originalPosition": 194}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ1NzcyODg3OnYy", "diffSide": "RIGHT", "path": "messaging/src/main/java/org/axonframework/queryhandling/ReactiveQueryGateway.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yM1QxMzo1NDowMlrOF6Gbkg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yM1QxMzo1NDowMlrOF6Gbkg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjQ2NzA5MA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * Sends given {@code query} over the {@link QueryBus} and returns result containing initial response and\n          \n          \n            \n                 * incremental updates (received at the moment the query is sent, until it is cancelled by the caller or closed by\n          \n          \n            \n                 * the emitting side).\n          \n          \n            \n                 * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n          \n          \n            \n                 * Mono}</b></p>\n          \n          \n            \n                 * <p>\n          \n          \n            \n                 * <b>Note</b>: Any {@code null} results, on the initial result or the updates, will be filtered out by the\n          \n          \n            \n                 * QueryGateway. If you require the {@code null} to be returned for the initial and update results, we suggest using\n          \n          \n            \n                 * the {@link QueryBus} instead.\n          \n          \n            \n                 * Sends the given {@code query} over the {@link QueryBus} and returns result containing initial response and\n          \n          \n            \n                 * incremental updates (received at the moment the query is sent, until it is cancelled by the caller or closed by\n          \n          \n            \n                 * the emitting side).\n          \n          \n            \n                 * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n          \n          \n            \n                 * Mono}</b></p>\n          \n          \n            \n                 * <p>\n          \n          \n            \n                 * <b>Note</b>: Any {@code null} results, on the initial result or the updates, will be filtered out by the\n          \n          \n            \n                 * {@link ReactiveQueryGateway}. If you require the {@code null} to be returned for the initial and update results, we suggest using\n          \n          \n            \n                 * the {@code QueryBus} instead.", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r396467090", "createdAt": "2020-03-23T13:54:02Z", "author": {"login": "smcvb"}, "path": "messaging/src/main/java/org/axonframework/queryhandling/ReactiveQueryGateway.java", "diffHunk": "@@ -0,0 +1,386 @@\n+/*\n+ * Copyright (c) 2010-2020. Axon Framework\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.axonframework.queryhandling;\n+\n+import org.axonframework.messaging.responsetypes.ResponseType;\n+import org.axonframework.messaging.responsetypes.ResponseTypes;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Mono;\n+import reactor.util.concurrent.Queues;\n+\n+import java.util.concurrent.TimeUnit;\n+\n+/**\n+ * Variation of {@link QueryGateway}. Provides support for reactive return types such as {@link Mono} and {@link Flux}\n+ * from Project Reactor.\n+ *\n+ * @author Milan Savic\n+ * @since 4.4\n+ */\n+public interface ReactiveQueryGateway {\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus}, expecting a response with the given {@code responseType}\n+     * from a single source. The query name will be derived from the provided {@code query}. Execution may be\n+     * asynchronous, depending on the QueryBus implementation.\n+     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param query        The {@code query} to be sent\n+     * @param responseType A {@link Class} describing the desired response type\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(Q query, Class<R> responseType) {\n+        return query(query.getClass().getName(), query, responseType);\n+    }\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus}, expecting a response with the given {@code responseType}\n+     * from a single source. Execution may be asynchronous, depending on the QueryBus implementation.\n+     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(String queryName, Q query, Class<R> responseType) {\n+        return query(queryName, query, ResponseTypes.instanceOf(responseType));\n+    }\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from a single source. The query name will be derived from the provided {@code query}. Execution may be\n+     * asynchronous, depending on the QueryBus implementation.\n+     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(Q query, ResponseType<R> responseType) {\n+        return query(query.getClass().getName(), query, responseType);\n+    }\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from a single source. Execution may be asynchronous, depending on the QueryBus implementation.\n+     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(String queryName, Q query, ResponseType<R> responseType) {\n+        return query(queryName, Mono.just(query), responseType);\n+    }\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from a single source. Execution may be asynchronous, depending on the QueryBus implementation.\n+     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        a {@link Mono} which is resolved once the caller subscribes to the query result\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    <R, Q> Mono<R> query(String queryName, Mono<Q> query, ResponseType<R> responseType);\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from several sources. The flux is completed when a {@code timeout} occurs or when all results are received. The\n+     * query name will be derived from the provided {@code query}. Execution may be asynchronous, depending on the\n+     * QueryBus implementation.\n+     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     * <b>Note</b>: Any {@code null} results will be filtered out by the QueryGateway. If you require the {@code null}\n+     * to be returned, we suggest using {@link QueryBus} instead.\n+     *\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param timeout      A timeout of {@code long} for the query\n+     * @param timeUnit     The selected {@link TimeUnit} for the given {@code timeout}\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A flux of results\n+     */\n+    default <R, Q> Flux<R> scatterGather(Q query, ResponseType<R> responseType, long timeout, TimeUnit timeUnit) {\n+        return scatterGather(query.getClass().getName(), query, responseType, timeout, timeUnit);\n+    }\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from several sources. The flux is completed when a {@code timeout} occurs or when all results are received.\n+     * Execution may be asynchronous, depending on the QueryBus implementation.\n+     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     * <b>Note</b>: Any {@code null} results will be filtered out by the QueryGateway. If you require the {@code null}\n+     * to be returned, we suggest using {@link QueryBus} instead.\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param timeout      A timeout of {@code long} for the query\n+     * @param timeUnit     The selected {@link TimeUnit} for the given {@code timeout}\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A flux of results.\n+     */\n+    default <R, Q> Flux<R> scatterGather(String queryName, Q query, ResponseType<R> responseType, long timeout,\n+                                         TimeUnit timeUnit) {\n+        return scatterGather(queryName, Mono.just(query), responseType, timeout, timeUnit);\n+    }\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from several sources. The flux is completed when a {@code timeout} occurs or when all results are received.\n+     * Execution may be asynchronous, depending on the QueryBus implementation.\n+     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     * <b>Note</b>: Any {@code null} results will be filtered out by the QueryGateway. If you require the {@code null}\n+     * to be returned, we suggest using {@link QueryBus} instead.\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        a {@link Mono} which is resolved once the caller subscribes to the query result\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param timeout      A timeout of {@code long} for the query\n+     * @param timeUnit     The selected {@link TimeUnit} for the given {@code timeout}\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A flux of results.\n+     */\n+    <R, Q> Flux<R> scatterGather(String queryName, Mono<Q> query, ResponseType<R> responseType, long timeout,\n+                                 TimeUnit timeUnit);\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus} and returns result containing initial response and\n+     * incremental updates (received at the moment the query is sent, until it is cancelled by the caller or closed by\n+     * the emitting side).\n+     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     * <p>\n+     * <b>Note</b>: Any {@code null} results, on the initial result or the updates, will be filtered out by the\n+     * QueryGateway. If you require the {@code null} to be returned for the initial and update results, we suggest using\n+     * the {@link QueryBus} instead.\n+     *\n+     * @param query               The {@code query} to be sent\n+     * @param initialResponseType The initial response type used for this query\n+     * @param updateResponseType  The update response type used for this query\n+     * @param <Q>                 The type of the query\n+     * @param <I>                 The type of the initial response\n+     * @param <U>                 The type of the incremental update\n+     * @return registration which can be used to cancel receiving updates\n+     *\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage)\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage, SubscriptionQueryBackpressure, int)\n+     */\n+    default <Q, I, U> Mono<SubscriptionQueryResult<I, U>> subscriptionQuery(Q query, Class<I> initialResponseType,\n+                                                                            Class<U> updateResponseType) {\n+        return subscriptionQuery(query.getClass().getName(),\n+                                 query,\n+                                 initialResponseType,\n+                                 updateResponseType);\n+    }\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus} and returns result containing initial response and\n+     * incremental updates (received at the moment the query is sent, until it is cancelled by the caller or closed by\n+     * the emitting side).\n+     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     * <p>\n+     * <b>Note</b>: Any {@code null} results, on the initial result or the updates, will be filtered out by the\n+     * QueryGateway. If you require the {@code null} to be returned for the initial and update results, we suggest using\n+     * the {@link QueryBus} instead.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c4511e81820de8d15c641e1c3038f4b688e29b51"}, "originalPosition": 224}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ1NzczMjQ1OnYy", "diffSide": "RIGHT", "path": "messaging/src/main/java/org/axonframework/queryhandling/ReactiveQueryGateway.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yM1QxMzo1NDo1MFrOF6Gd5Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yM1QxMzo1NDo1MFrOF6Gd5Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjQ2NzY4NQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * Sends given {@code query} over the {@link QueryBus} and returns result containing initial response and\n          \n          \n            \n                 * incremental updates (received at the moment the query is sent, until it is cancelled by the caller or closed by\n          \n          \n            \n                 * the emitting side).\n          \n          \n            \n                 * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n          \n          \n            \n                 * Mono}</b></p>\n          \n          \n            \n                 * <p>\n          \n          \n            \n                 * <b>Note</b>: Any {@code null} results, on the initial result or the updates, will be filtered out by the\n          \n          \n            \n                 * QueryGateway. If you require the {@code null} to be returned for the initial and update results, we suggest using\n          \n          \n            \n                 * the {@link QueryBus} instead.\n          \n          \n            \n                 * Sends the given {@code query} over the {@link QueryBus} and returns result containing initial response and\n          \n          \n            \n                 * incremental updates (received at the moment the query is sent, until it is cancelled by the caller or closed by\n          \n          \n            \n                 * the emitting side).\n          \n          \n            \n                 * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n          \n          \n            \n                 * Mono}</b></p>\n          \n          \n            \n                 * <p>\n          \n          \n            \n                 * <b>Note</b>: Any {@code null} results, on the initial result or the updates, will be filtered out by the\n          \n          \n            \n                 * {@link ReactiveQueryGateway}. If you require the {@code null} to be returned for the initial and update results, we suggest using\n          \n          \n            \n                 * the {@code QueryBus} instead.", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r396467685", "createdAt": "2020-03-23T13:54:50Z", "author": {"login": "smcvb"}, "path": "messaging/src/main/java/org/axonframework/queryhandling/ReactiveQueryGateway.java", "diffHunk": "@@ -0,0 +1,386 @@\n+/*\n+ * Copyright (c) 2010-2020. Axon Framework\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.axonframework.queryhandling;\n+\n+import org.axonframework.messaging.responsetypes.ResponseType;\n+import org.axonframework.messaging.responsetypes.ResponseTypes;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Mono;\n+import reactor.util.concurrent.Queues;\n+\n+import java.util.concurrent.TimeUnit;\n+\n+/**\n+ * Variation of {@link QueryGateway}. Provides support for reactive return types such as {@link Mono} and {@link Flux}\n+ * from Project Reactor.\n+ *\n+ * @author Milan Savic\n+ * @since 4.4\n+ */\n+public interface ReactiveQueryGateway {\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus}, expecting a response with the given {@code responseType}\n+     * from a single source. The query name will be derived from the provided {@code query}. Execution may be\n+     * asynchronous, depending on the QueryBus implementation.\n+     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param query        The {@code query} to be sent\n+     * @param responseType A {@link Class} describing the desired response type\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(Q query, Class<R> responseType) {\n+        return query(query.getClass().getName(), query, responseType);\n+    }\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus}, expecting a response with the given {@code responseType}\n+     * from a single source. Execution may be asynchronous, depending on the QueryBus implementation.\n+     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(String queryName, Q query, Class<R> responseType) {\n+        return query(queryName, query, ResponseTypes.instanceOf(responseType));\n+    }\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from a single source. The query name will be derived from the provided {@code query}. Execution may be\n+     * asynchronous, depending on the QueryBus implementation.\n+     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(Q query, ResponseType<R> responseType) {\n+        return query(query.getClass().getName(), query, responseType);\n+    }\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from a single source. Execution may be asynchronous, depending on the QueryBus implementation.\n+     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(String queryName, Q query, ResponseType<R> responseType) {\n+        return query(queryName, Mono.just(query), responseType);\n+    }\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from a single source. Execution may be asynchronous, depending on the QueryBus implementation.\n+     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        a {@link Mono} which is resolved once the caller subscribes to the query result\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    <R, Q> Mono<R> query(String queryName, Mono<Q> query, ResponseType<R> responseType);\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from several sources. The flux is completed when a {@code timeout} occurs or when all results are received. The\n+     * query name will be derived from the provided {@code query}. Execution may be asynchronous, depending on the\n+     * QueryBus implementation.\n+     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     * <b>Note</b>: Any {@code null} results will be filtered out by the QueryGateway. If you require the {@code null}\n+     * to be returned, we suggest using {@link QueryBus} instead.\n+     *\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param timeout      A timeout of {@code long} for the query\n+     * @param timeUnit     The selected {@link TimeUnit} for the given {@code timeout}\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A flux of results\n+     */\n+    default <R, Q> Flux<R> scatterGather(Q query, ResponseType<R> responseType, long timeout, TimeUnit timeUnit) {\n+        return scatterGather(query.getClass().getName(), query, responseType, timeout, timeUnit);\n+    }\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from several sources. The flux is completed when a {@code timeout} occurs or when all results are received.\n+     * Execution may be asynchronous, depending on the QueryBus implementation.\n+     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     * <b>Note</b>: Any {@code null} results will be filtered out by the QueryGateway. If you require the {@code null}\n+     * to be returned, we suggest using {@link QueryBus} instead.\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param timeout      A timeout of {@code long} for the query\n+     * @param timeUnit     The selected {@link TimeUnit} for the given {@code timeout}\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A flux of results.\n+     */\n+    default <R, Q> Flux<R> scatterGather(String queryName, Q query, ResponseType<R> responseType, long timeout,\n+                                         TimeUnit timeUnit) {\n+        return scatterGather(queryName, Mono.just(query), responseType, timeout, timeUnit);\n+    }\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from several sources. The flux is completed when a {@code timeout} occurs or when all results are received.\n+     * Execution may be asynchronous, depending on the QueryBus implementation.\n+     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     * <b>Note</b>: Any {@code null} results will be filtered out by the QueryGateway. If you require the {@code null}\n+     * to be returned, we suggest using {@link QueryBus} instead.\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        a {@link Mono} which is resolved once the caller subscribes to the query result\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param timeout      A timeout of {@code long} for the query\n+     * @param timeUnit     The selected {@link TimeUnit} for the given {@code timeout}\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A flux of results.\n+     */\n+    <R, Q> Flux<R> scatterGather(String queryName, Mono<Q> query, ResponseType<R> responseType, long timeout,\n+                                 TimeUnit timeUnit);\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus} and returns result containing initial response and\n+     * incremental updates (received at the moment the query is sent, until it is cancelled by the caller or closed by\n+     * the emitting side).\n+     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     * <p>\n+     * <b>Note</b>: Any {@code null} results, on the initial result or the updates, will be filtered out by the\n+     * QueryGateway. If you require the {@code null} to be returned for the initial and update results, we suggest using\n+     * the {@link QueryBus} instead.\n+     *\n+     * @param query               The {@code query} to be sent\n+     * @param initialResponseType The initial response type used for this query\n+     * @param updateResponseType  The update response type used for this query\n+     * @param <Q>                 The type of the query\n+     * @param <I>                 The type of the initial response\n+     * @param <U>                 The type of the incremental update\n+     * @return registration which can be used to cancel receiving updates\n+     *\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage)\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage, SubscriptionQueryBackpressure, int)\n+     */\n+    default <Q, I, U> Mono<SubscriptionQueryResult<I, U>> subscriptionQuery(Q query, Class<I> initialResponseType,\n+                                                                            Class<U> updateResponseType) {\n+        return subscriptionQuery(query.getClass().getName(),\n+                                 query,\n+                                 initialResponseType,\n+                                 updateResponseType);\n+    }\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus} and returns result containing initial response and\n+     * incremental updates (received at the moment the query is sent, until it is cancelled by the caller or closed by\n+     * the emitting side).\n+     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     * <p>\n+     * <b>Note</b>: Any {@code null} results, on the initial result or the updates, will be filtered out by the\n+     * QueryGateway. If you require the {@code null} to be returned for the initial and update results, we suggest using\n+     * the {@link QueryBus} instead.\n+     *\n+     * @param queryName           A {@link String} describing query to be executed\n+     * @param query               The {@code query} to be sent\n+     * @param initialResponseType The initial response type used for this query\n+     * @param updateResponseType  The update response type used for this query\n+     * @param <Q>                 The type of the query\n+     * @param <I>                 The type of the initial response\n+     * @param <U>                 The type of the incremental update\n+     * @return registration which can be used to cancel receiving updates\n+     *\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage)\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage, SubscriptionQueryBackpressure, int)\n+     */\n+    default <Q, I, U> Mono<SubscriptionQueryResult<I, U>> subscriptionQuery(String queryName, Q query,\n+                                                                            Class<I> initialResponseType,\n+                                                                            Class<U> updateResponseType) {\n+        return subscriptionQuery(queryName,\n+                                 query,\n+                                 ResponseTypes.instanceOf(initialResponseType),\n+                                 ResponseTypes.instanceOf(updateResponseType),\n+                                 SubscriptionQueryBackpressure.defaultBackpressure());\n+    }\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus} and returns result containing initial response and\n+     * incremental updates (received at the moment the query is sent, until it is cancelled by the caller or closed by\n+     * the emitting side).\n+     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     * <p>\n+     * <b>Note</b>: Any {@code null} results, on the initial result or the updates, will be filtered out by the\n+     * QueryGateway. If you require the {@code null} to be returned for the initial and update results, we suggest using\n+     * the {@link QueryBus} instead.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c4511e81820de8d15c641e1c3038f4b688e29b51"}, "originalPosition": 257}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ1Nzc1NDAzOnYy", "diffSide": "RIGHT", "path": "messaging/src/main/java/org/axonframework/queryhandling/ReactiveQueryGateway.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yM1QxMzo1OTozOFrOF6Grmw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yM1QxMzo1OTozOFrOF6Grmw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjQ3MTE5NQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * Sends given {@code query} over the {@link QueryBus} and returns result containing initial response and\n          \n          \n            \n                 * incremental updates (received at the moment the query is sent, until it is cancelled by the caller or closed by\n          \n          \n            \n                 * the emitting side).\n          \n          \n            \n                 * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n          \n          \n            \n                 * Mono}</b></p>\n          \n          \n            \n                 * <p>\n          \n          \n            \n                 * <b>Note</b>: Any {@code null} results, on the initial result or the updates, will be filtered out by the\n          \n          \n            \n                 * QueryGateway. If you require the {@code null} to be returned for the initial and update results, we suggest using\n          \n          \n            \n                 * the {@link QueryBus} instead.\n          \n          \n            \n                 * Sends the given {@code query} over the {@link QueryBus} and returns result containing initial response and\n          \n          \n            \n                 * incremental updates (received at the moment the query is sent, until it is cancelled by the caller or closed by\n          \n          \n            \n                 * the emitting side).\n          \n          \n            \n                 * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n          \n          \n            \n                 * Mono}</b></p>\n          \n          \n            \n                 * <p>\n          \n          \n            \n                 * <b>Note</b>: Any {@code null} results, on the initial result or the updates, will be filtered out by the\n          \n          \n            \n                 * {@link ReactiveQueryGateway}. If you require the {@code null} to be returned for the initial and update results, we suggest using\n          \n          \n            \n                 * the {@code QueryBus} instead.", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r396471195", "createdAt": "2020-03-23T13:59:38Z", "author": {"login": "smcvb"}, "path": "messaging/src/main/java/org/axonframework/queryhandling/ReactiveQueryGateway.java", "diffHunk": "@@ -0,0 +1,386 @@\n+/*\n+ * Copyright (c) 2010-2020. Axon Framework\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.axonframework.queryhandling;\n+\n+import org.axonframework.messaging.responsetypes.ResponseType;\n+import org.axonframework.messaging.responsetypes.ResponseTypes;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Mono;\n+import reactor.util.concurrent.Queues;\n+\n+import java.util.concurrent.TimeUnit;\n+\n+/**\n+ * Variation of {@link QueryGateway}. Provides support for reactive return types such as {@link Mono} and {@link Flux}\n+ * from Project Reactor.\n+ *\n+ * @author Milan Savic\n+ * @since 4.4\n+ */\n+public interface ReactiveQueryGateway {\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus}, expecting a response with the given {@code responseType}\n+     * from a single source. The query name will be derived from the provided {@code query}. Execution may be\n+     * asynchronous, depending on the QueryBus implementation.\n+     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param query        The {@code query} to be sent\n+     * @param responseType A {@link Class} describing the desired response type\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(Q query, Class<R> responseType) {\n+        return query(query.getClass().getName(), query, responseType);\n+    }\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus}, expecting a response with the given {@code responseType}\n+     * from a single source. Execution may be asynchronous, depending on the QueryBus implementation.\n+     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(String queryName, Q query, Class<R> responseType) {\n+        return query(queryName, query, ResponseTypes.instanceOf(responseType));\n+    }\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from a single source. The query name will be derived from the provided {@code query}. Execution may be\n+     * asynchronous, depending on the QueryBus implementation.\n+     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(Q query, ResponseType<R> responseType) {\n+        return query(query.getClass().getName(), query, responseType);\n+    }\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from a single source. Execution may be asynchronous, depending on the QueryBus implementation.\n+     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(String queryName, Q query, ResponseType<R> responseType) {\n+        return query(queryName, Mono.just(query), responseType);\n+    }\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from a single source. Execution may be asynchronous, depending on the QueryBus implementation.\n+     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        a {@link Mono} which is resolved once the caller subscribes to the query result\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    <R, Q> Mono<R> query(String queryName, Mono<Q> query, ResponseType<R> responseType);\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from several sources. The flux is completed when a {@code timeout} occurs or when all results are received. The\n+     * query name will be derived from the provided {@code query}. Execution may be asynchronous, depending on the\n+     * QueryBus implementation.\n+     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     * <b>Note</b>: Any {@code null} results will be filtered out by the QueryGateway. If you require the {@code null}\n+     * to be returned, we suggest using {@link QueryBus} instead.\n+     *\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param timeout      A timeout of {@code long} for the query\n+     * @param timeUnit     The selected {@link TimeUnit} for the given {@code timeout}\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A flux of results\n+     */\n+    default <R, Q> Flux<R> scatterGather(Q query, ResponseType<R> responseType, long timeout, TimeUnit timeUnit) {\n+        return scatterGather(query.getClass().getName(), query, responseType, timeout, timeUnit);\n+    }\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from several sources. The flux is completed when a {@code timeout} occurs or when all results are received.\n+     * Execution may be asynchronous, depending on the QueryBus implementation.\n+     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     * <b>Note</b>: Any {@code null} results will be filtered out by the QueryGateway. If you require the {@code null}\n+     * to be returned, we suggest using {@link QueryBus} instead.\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param timeout      A timeout of {@code long} for the query\n+     * @param timeUnit     The selected {@link TimeUnit} for the given {@code timeout}\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A flux of results.\n+     */\n+    default <R, Q> Flux<R> scatterGather(String queryName, Q query, ResponseType<R> responseType, long timeout,\n+                                         TimeUnit timeUnit) {\n+        return scatterGather(queryName, Mono.just(query), responseType, timeout, timeUnit);\n+    }\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from several sources. The flux is completed when a {@code timeout} occurs or when all results are received.\n+     * Execution may be asynchronous, depending on the QueryBus implementation.\n+     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     * <b>Note</b>: Any {@code null} results will be filtered out by the QueryGateway. If you require the {@code null}\n+     * to be returned, we suggest using {@link QueryBus} instead.\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        a {@link Mono} which is resolved once the caller subscribes to the query result\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param timeout      A timeout of {@code long} for the query\n+     * @param timeUnit     The selected {@link TimeUnit} for the given {@code timeout}\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A flux of results.\n+     */\n+    <R, Q> Flux<R> scatterGather(String queryName, Mono<Q> query, ResponseType<R> responseType, long timeout,\n+                                 TimeUnit timeUnit);\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus} and returns result containing initial response and\n+     * incremental updates (received at the moment the query is sent, until it is cancelled by the caller or closed by\n+     * the emitting side).\n+     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     * <p>\n+     * <b>Note</b>: Any {@code null} results, on the initial result or the updates, will be filtered out by the\n+     * QueryGateway. If you require the {@code null} to be returned for the initial and update results, we suggest using\n+     * the {@link QueryBus} instead.\n+     *\n+     * @param query               The {@code query} to be sent\n+     * @param initialResponseType The initial response type used for this query\n+     * @param updateResponseType  The update response type used for this query\n+     * @param <Q>                 The type of the query\n+     * @param <I>                 The type of the initial response\n+     * @param <U>                 The type of the incremental update\n+     * @return registration which can be used to cancel receiving updates\n+     *\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage)\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage, SubscriptionQueryBackpressure, int)\n+     */\n+    default <Q, I, U> Mono<SubscriptionQueryResult<I, U>> subscriptionQuery(Q query, Class<I> initialResponseType,\n+                                                                            Class<U> updateResponseType) {\n+        return subscriptionQuery(query.getClass().getName(),\n+                                 query,\n+                                 initialResponseType,\n+                                 updateResponseType);\n+    }\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus} and returns result containing initial response and\n+     * incremental updates (received at the moment the query is sent, until it is cancelled by the caller or closed by\n+     * the emitting side).\n+     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     * <p>\n+     * <b>Note</b>: Any {@code null} results, on the initial result or the updates, will be filtered out by the\n+     * QueryGateway. If you require the {@code null} to be returned for the initial and update results, we suggest using\n+     * the {@link QueryBus} instead.\n+     *\n+     * @param queryName           A {@link String} describing query to be executed\n+     * @param query               The {@code query} to be sent\n+     * @param initialResponseType The initial response type used for this query\n+     * @param updateResponseType  The update response type used for this query\n+     * @param <Q>                 The type of the query\n+     * @param <I>                 The type of the initial response\n+     * @param <U>                 The type of the incremental update\n+     * @return registration which can be used to cancel receiving updates\n+     *\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage)\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage, SubscriptionQueryBackpressure, int)\n+     */\n+    default <Q, I, U> Mono<SubscriptionQueryResult<I, U>> subscriptionQuery(String queryName, Q query,\n+                                                                            Class<I> initialResponseType,\n+                                                                            Class<U> updateResponseType) {\n+        return subscriptionQuery(queryName,\n+                                 query,\n+                                 ResponseTypes.instanceOf(initialResponseType),\n+                                 ResponseTypes.instanceOf(updateResponseType),\n+                                 SubscriptionQueryBackpressure.defaultBackpressure());\n+    }\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus} and returns result containing initial response and\n+     * incremental updates (received at the moment the query is sent, until it is cancelled by the caller or closed by\n+     * the emitting side).\n+     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     * <p>\n+     * <b>Note</b>: Any {@code null} results, on the initial result or the updates, will be filtered out by the\n+     * QueryGateway. If you require the {@code null} to be returned for the initial and update results, we suggest using\n+     * the {@link QueryBus} instead.\n+     *\n+     * @param query               The {@code query} to be sent\n+     * @param initialResponseType The initial response type used for this query\n+     * @param updateResponseType  The update response type used for this query\n+     * @param <Q>                 The type of the query\n+     * @param <I>                 The type of the initial response\n+     * @param <U>                 The type of the incremental update\n+     * @return registration which can be used to cancel receiving updates\n+     *\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage)\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage, SubscriptionQueryBackpressure, int)\n+     */\n+    default <Q, I, U> Mono<SubscriptionQueryResult<I, U>> subscriptionQuery(Q query,\n+                                                                            ResponseType<I> initialResponseType,\n+                                                                            ResponseType<U> updateResponseType) {\n+        return subscriptionQuery(query.getClass().getName(),\n+                                 query,\n+                                 initialResponseType,\n+                                 updateResponseType,\n+                                 SubscriptionQueryBackpressure.defaultBackpressure());\n+    }\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus} and returns result containing initial response and\n+     * incremental updates (received at the moment the query is sent, until it is cancelled by the caller or closed by\n+     * the emitting side).\n+     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     * <p>\n+     * <b>Note</b>: Any {@code null} results, on the initial result or the updates, will be filtered out by the\n+     * QueryGateway. If you require the {@code null} to be returned for the initial and update results, we suggest using\n+     * the {@link QueryBus} instead.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c4511e81820de8d15c641e1c3038f4b688e29b51"}, "originalPosition": 289}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ1Nzc1OTAxOnYy", "diffSide": "RIGHT", "path": "messaging/src/main/java/org/axonframework/queryhandling/ReactiveQueryGateway.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yM1QxNDowMDo0N1rOF6GuvQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yM1QxNDowMDo0N1rOF6GuvQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjQ3MTk5Nw==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * Sends given {@code query} over the {@link QueryBus} and returns result containing initial response and\n          \n          \n            \n                 * incremental updates (received at the moment the query is sent, until it is cancelled by the caller or closed by\n          \n          \n            \n                 * the emitting side).\n          \n          \n            \n                 * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n          \n          \n            \n                 * Mono}</b></p>\n          \n          \n            \n                 * <p>\n          \n          \n            \n                 * <b>Note</b>: Any {@code null} results, on the initial result or the updates, will be filtered out by the\n          \n          \n            \n                 * QueryGateway. If you require the {@code null} to be returned for the initial and update results, we suggest using\n          \n          \n            \n                 * the {@link QueryBus} instead.\n          \n          \n            \n                 * Sends thegiven {@code query} over the {@link QueryBus} and returns result containing initial response and\n          \n          \n            \n                 * incremental updates (received at the moment the query is sent, until it is cancelled by the caller or closed by\n          \n          \n            \n                 * the emitting side).\n          \n          \n            \n                 * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n          \n          \n            \n                 * Mono}</b></p>\n          \n          \n            \n                 * <p>\n          \n          \n            \n                 * <b>Note</b>: Any {@code null} results, on the initial result or the updates, will be filtered out by the\n          \n          \n            \n                 * {@link ReactiveQueryGateway}. If you require the {@code null} to be returned for the initial and update results, we suggest using\n          \n          \n            \n                 * the {@code QueryBus} instead.", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r396471997", "createdAt": "2020-03-23T14:00:47Z", "author": {"login": "smcvb"}, "path": "messaging/src/main/java/org/axonframework/queryhandling/ReactiveQueryGateway.java", "diffHunk": "@@ -0,0 +1,386 @@\n+/*\n+ * Copyright (c) 2010-2020. Axon Framework\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.axonframework.queryhandling;\n+\n+import org.axonframework.messaging.responsetypes.ResponseType;\n+import org.axonframework.messaging.responsetypes.ResponseTypes;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Mono;\n+import reactor.util.concurrent.Queues;\n+\n+import java.util.concurrent.TimeUnit;\n+\n+/**\n+ * Variation of {@link QueryGateway}. Provides support for reactive return types such as {@link Mono} and {@link Flux}\n+ * from Project Reactor.\n+ *\n+ * @author Milan Savic\n+ * @since 4.4\n+ */\n+public interface ReactiveQueryGateway {\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus}, expecting a response with the given {@code responseType}\n+     * from a single source. The query name will be derived from the provided {@code query}. Execution may be\n+     * asynchronous, depending on the QueryBus implementation.\n+     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param query        The {@code query} to be sent\n+     * @param responseType A {@link Class} describing the desired response type\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(Q query, Class<R> responseType) {\n+        return query(query.getClass().getName(), query, responseType);\n+    }\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus}, expecting a response with the given {@code responseType}\n+     * from a single source. Execution may be asynchronous, depending on the QueryBus implementation.\n+     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(String queryName, Q query, Class<R> responseType) {\n+        return query(queryName, query, ResponseTypes.instanceOf(responseType));\n+    }\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from a single source. The query name will be derived from the provided {@code query}. Execution may be\n+     * asynchronous, depending on the QueryBus implementation.\n+     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(Q query, ResponseType<R> responseType) {\n+        return query(query.getClass().getName(), query, responseType);\n+    }\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from a single source. Execution may be asynchronous, depending on the QueryBus implementation.\n+     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(String queryName, Q query, ResponseType<R> responseType) {\n+        return query(queryName, Mono.just(query), responseType);\n+    }\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from a single source. Execution may be asynchronous, depending on the QueryBus implementation.\n+     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        a {@link Mono} which is resolved once the caller subscribes to the query result\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    <R, Q> Mono<R> query(String queryName, Mono<Q> query, ResponseType<R> responseType);\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from several sources. The flux is completed when a {@code timeout} occurs or when all results are received. The\n+     * query name will be derived from the provided {@code query}. Execution may be asynchronous, depending on the\n+     * QueryBus implementation.\n+     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     * <b>Note</b>: Any {@code null} results will be filtered out by the QueryGateway. If you require the {@code null}\n+     * to be returned, we suggest using {@link QueryBus} instead.\n+     *\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param timeout      A timeout of {@code long} for the query\n+     * @param timeUnit     The selected {@link TimeUnit} for the given {@code timeout}\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A flux of results\n+     */\n+    default <R, Q> Flux<R> scatterGather(Q query, ResponseType<R> responseType, long timeout, TimeUnit timeUnit) {\n+        return scatterGather(query.getClass().getName(), query, responseType, timeout, timeUnit);\n+    }\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from several sources. The flux is completed when a {@code timeout} occurs or when all results are received.\n+     * Execution may be asynchronous, depending on the QueryBus implementation.\n+     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     * <b>Note</b>: Any {@code null} results will be filtered out by the QueryGateway. If you require the {@code null}\n+     * to be returned, we suggest using {@link QueryBus} instead.\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param timeout      A timeout of {@code long} for the query\n+     * @param timeUnit     The selected {@link TimeUnit} for the given {@code timeout}\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A flux of results.\n+     */\n+    default <R, Q> Flux<R> scatterGather(String queryName, Q query, ResponseType<R> responseType, long timeout,\n+                                         TimeUnit timeUnit) {\n+        return scatterGather(queryName, Mono.just(query), responseType, timeout, timeUnit);\n+    }\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from several sources. The flux is completed when a {@code timeout} occurs or when all results are received.\n+     * Execution may be asynchronous, depending on the QueryBus implementation.\n+     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     * <b>Note</b>: Any {@code null} results will be filtered out by the QueryGateway. If you require the {@code null}\n+     * to be returned, we suggest using {@link QueryBus} instead.\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        a {@link Mono} which is resolved once the caller subscribes to the query result\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param timeout      A timeout of {@code long} for the query\n+     * @param timeUnit     The selected {@link TimeUnit} for the given {@code timeout}\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A flux of results.\n+     */\n+    <R, Q> Flux<R> scatterGather(String queryName, Mono<Q> query, ResponseType<R> responseType, long timeout,\n+                                 TimeUnit timeUnit);\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus} and returns result containing initial response and\n+     * incremental updates (received at the moment the query is sent, until it is cancelled by the caller or closed by\n+     * the emitting side).\n+     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     * <p>\n+     * <b>Note</b>: Any {@code null} results, on the initial result or the updates, will be filtered out by the\n+     * QueryGateway. If you require the {@code null} to be returned for the initial and update results, we suggest using\n+     * the {@link QueryBus} instead.\n+     *\n+     * @param query               The {@code query} to be sent\n+     * @param initialResponseType The initial response type used for this query\n+     * @param updateResponseType  The update response type used for this query\n+     * @param <Q>                 The type of the query\n+     * @param <I>                 The type of the initial response\n+     * @param <U>                 The type of the incremental update\n+     * @return registration which can be used to cancel receiving updates\n+     *\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage)\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage, SubscriptionQueryBackpressure, int)\n+     */\n+    default <Q, I, U> Mono<SubscriptionQueryResult<I, U>> subscriptionQuery(Q query, Class<I> initialResponseType,\n+                                                                            Class<U> updateResponseType) {\n+        return subscriptionQuery(query.getClass().getName(),\n+                                 query,\n+                                 initialResponseType,\n+                                 updateResponseType);\n+    }\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus} and returns result containing initial response and\n+     * incremental updates (received at the moment the query is sent, until it is cancelled by the caller or closed by\n+     * the emitting side).\n+     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     * <p>\n+     * <b>Note</b>: Any {@code null} results, on the initial result or the updates, will be filtered out by the\n+     * QueryGateway. If you require the {@code null} to be returned for the initial and update results, we suggest using\n+     * the {@link QueryBus} instead.\n+     *\n+     * @param queryName           A {@link String} describing query to be executed\n+     * @param query               The {@code query} to be sent\n+     * @param initialResponseType The initial response type used for this query\n+     * @param updateResponseType  The update response type used for this query\n+     * @param <Q>                 The type of the query\n+     * @param <I>                 The type of the initial response\n+     * @param <U>                 The type of the incremental update\n+     * @return registration which can be used to cancel receiving updates\n+     *\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage)\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage, SubscriptionQueryBackpressure, int)\n+     */\n+    default <Q, I, U> Mono<SubscriptionQueryResult<I, U>> subscriptionQuery(String queryName, Q query,\n+                                                                            Class<I> initialResponseType,\n+                                                                            Class<U> updateResponseType) {\n+        return subscriptionQuery(queryName,\n+                                 query,\n+                                 ResponseTypes.instanceOf(initialResponseType),\n+                                 ResponseTypes.instanceOf(updateResponseType),\n+                                 SubscriptionQueryBackpressure.defaultBackpressure());\n+    }\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus} and returns result containing initial response and\n+     * incremental updates (received at the moment the query is sent, until it is cancelled by the caller or closed by\n+     * the emitting side).\n+     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     * <p>\n+     * <b>Note</b>: Any {@code null} results, on the initial result or the updates, will be filtered out by the\n+     * QueryGateway. If you require the {@code null} to be returned for the initial and update results, we suggest using\n+     * the {@link QueryBus} instead.\n+     *\n+     * @param query               The {@code query} to be sent\n+     * @param initialResponseType The initial response type used for this query\n+     * @param updateResponseType  The update response type used for this query\n+     * @param <Q>                 The type of the query\n+     * @param <I>                 The type of the initial response\n+     * @param <U>                 The type of the incremental update\n+     * @return registration which can be used to cancel receiving updates\n+     *\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage)\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage, SubscriptionQueryBackpressure, int)\n+     */\n+    default <Q, I, U> Mono<SubscriptionQueryResult<I, U>> subscriptionQuery(Q query,\n+                                                                            ResponseType<I> initialResponseType,\n+                                                                            ResponseType<U> updateResponseType) {\n+        return subscriptionQuery(query.getClass().getName(),\n+                                 query,\n+                                 initialResponseType,\n+                                 updateResponseType,\n+                                 SubscriptionQueryBackpressure.defaultBackpressure());\n+    }\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus} and returns result containing initial response and\n+     * incremental updates (received at the moment the query is sent, until it is cancelled by the caller or closed by\n+     * the emitting side).\n+     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     * <p>\n+     * <b>Note</b>: Any {@code null} results, on the initial result or the updates, will be filtered out by the\n+     * QueryGateway. If you require the {@code null} to be returned for the initial and update results, we suggest using\n+     * the {@link QueryBus} instead.\n+     *\n+     * @param queryName           A {@link String} describing query to be executed\n+     * @param query               The {@code query} to be sent\n+     * @param initialResponseType The initial response type used for this query\n+     * @param updateResponseType  The update response type used for this query\n+     * @param backpressure        The backpressure mechanism to deal with producing of incremental updates\n+     * @param <Q>                 The type of the query\n+     * @param <I>                 The type of the initial response\n+     * @param <U>                 The type of the incremental update\n+     * @return registration which can be used to cancel receiving updates\n+     *\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage)\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage, SubscriptionQueryBackpressure, int)\n+     */\n+    default <Q, I, U> Mono<SubscriptionQueryResult<I, U>> subscriptionQuery(String queryName, Q query,\n+                                                                            ResponseType<I> initialResponseType,\n+                                                                            ResponseType<U> updateResponseType,\n+                                                                            SubscriptionQueryBackpressure backpressure) {\n+        return subscriptionQuery(queryName,\n+                                 query,\n+                                 initialResponseType,\n+                                 updateResponseType,\n+                                 backpressure,\n+                                 Queues.SMALL_BUFFER_SIZE);\n+    }\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus} and returns result containing initial response and\n+     * incremental updates (received at the moment the query is sent, until it is cancelled by the caller or closed by\n+     * the emitting side).\n+     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     * <p>\n+     * <b>Note</b>: Any {@code null} results, on the initial result or the updates, will be filtered out by the\n+     * QueryGateway. If you require the {@code null} to be returned for the initial and update results, we suggest using\n+     * the {@link QueryBus} instead.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c4511e81820de8d15c641e1c3038f4b688e29b51"}, "originalPosition": 325}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ1Nzc4ODI5OnYy", "diffSide": "RIGHT", "path": "messaging/src/main/java/org/axonframework/queryhandling/ReactiveQueryGateway.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yM1QxNDowNzo1NlrOF6HBnQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yM1QxNDowNzo1NlrOF6HBnQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjQ3NjgyOQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * Sends given {@code query} over the {@link QueryBus} and returns result containing initial response and\n          \n          \n            \n                 * incremental updates (received at the moment the query is sent, until it is cancelled by the caller or closed by\n          \n          \n            \n                 * the emitting side).\n          \n          \n            \n                 * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n          \n          \n            \n                 * Mono}</b></p>\n          \n          \n            \n                 * <p>\n          \n          \n            \n                 * <b>Note</b>: Any {@code null} results, on the initial result or the updates, will be filtered out by the\n          \n          \n            \n                 * QueryGateway. If you require the {@code null} to be returned for the initial and update results, we suggest using\n          \n          \n            \n                 * the {@link QueryBus} instead.\n          \n          \n            \n                 * Sends the given {@code query} over the {@link QueryBus} and returns result containing initial response and\n          \n          \n            \n                 * incremental updates (received at the moment the query is sent, until it is cancelled by the caller or closed by\n          \n          \n            \n                 * the emitting side).\n          \n          \n            \n                 * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n          \n          \n            \n                 * Mono}</b></p>\n          \n          \n            \n                 * <p>\n          \n          \n            \n                 * <b>Note</b>: Any {@code null} results, on the initial result or the updates, will be filtered out by the\n          \n          \n            \n                 * {@link ReactiveQueryGateway}. If you require the {@code null} to be returned for the initial and update results, we suggest using\n          \n          \n            \n                 * the {@code QueryBus} instead.", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r396476829", "createdAt": "2020-03-23T14:07:56Z", "author": {"login": "smcvb"}, "path": "messaging/src/main/java/org/axonframework/queryhandling/ReactiveQueryGateway.java", "diffHunk": "@@ -0,0 +1,386 @@\n+/*\n+ * Copyright (c) 2010-2020. Axon Framework\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.axonframework.queryhandling;\n+\n+import org.axonframework.messaging.responsetypes.ResponseType;\n+import org.axonframework.messaging.responsetypes.ResponseTypes;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Mono;\n+import reactor.util.concurrent.Queues;\n+\n+import java.util.concurrent.TimeUnit;\n+\n+/**\n+ * Variation of {@link QueryGateway}. Provides support for reactive return types such as {@link Mono} and {@link Flux}\n+ * from Project Reactor.\n+ *\n+ * @author Milan Savic\n+ * @since 4.4\n+ */\n+public interface ReactiveQueryGateway {\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus}, expecting a response with the given {@code responseType}\n+     * from a single source. The query name will be derived from the provided {@code query}. Execution may be\n+     * asynchronous, depending on the QueryBus implementation.\n+     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param query        The {@code query} to be sent\n+     * @param responseType A {@link Class} describing the desired response type\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(Q query, Class<R> responseType) {\n+        return query(query.getClass().getName(), query, responseType);\n+    }\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus}, expecting a response with the given {@code responseType}\n+     * from a single source. Execution may be asynchronous, depending on the QueryBus implementation.\n+     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(String queryName, Q query, Class<R> responseType) {\n+        return query(queryName, query, ResponseTypes.instanceOf(responseType));\n+    }\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from a single source. The query name will be derived from the provided {@code query}. Execution may be\n+     * asynchronous, depending on the QueryBus implementation.\n+     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(Q query, ResponseType<R> responseType) {\n+        return query(query.getClass().getName(), query, responseType);\n+    }\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from a single source. Execution may be asynchronous, depending on the QueryBus implementation.\n+     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(String queryName, Q query, ResponseType<R> responseType) {\n+        return query(queryName, Mono.just(query), responseType);\n+    }\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from a single source. Execution may be asynchronous, depending on the QueryBus implementation.\n+     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        a {@link Mono} which is resolved once the caller subscribes to the query result\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    <R, Q> Mono<R> query(String queryName, Mono<Q> query, ResponseType<R> responseType);\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from several sources. The flux is completed when a {@code timeout} occurs or when all results are received. The\n+     * query name will be derived from the provided {@code query}. Execution may be asynchronous, depending on the\n+     * QueryBus implementation.\n+     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     * <b>Note</b>: Any {@code null} results will be filtered out by the QueryGateway. If you require the {@code null}\n+     * to be returned, we suggest using {@link QueryBus} instead.\n+     *\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param timeout      A timeout of {@code long} for the query\n+     * @param timeUnit     The selected {@link TimeUnit} for the given {@code timeout}\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A flux of results\n+     */\n+    default <R, Q> Flux<R> scatterGather(Q query, ResponseType<R> responseType, long timeout, TimeUnit timeUnit) {\n+        return scatterGather(query.getClass().getName(), query, responseType, timeout, timeUnit);\n+    }\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from several sources. The flux is completed when a {@code timeout} occurs or when all results are received.\n+     * Execution may be asynchronous, depending on the QueryBus implementation.\n+     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     * <b>Note</b>: Any {@code null} results will be filtered out by the QueryGateway. If you require the {@code null}\n+     * to be returned, we suggest using {@link QueryBus} instead.\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param timeout      A timeout of {@code long} for the query\n+     * @param timeUnit     The selected {@link TimeUnit} for the given {@code timeout}\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A flux of results.\n+     */\n+    default <R, Q> Flux<R> scatterGather(String queryName, Q query, ResponseType<R> responseType, long timeout,\n+                                         TimeUnit timeUnit) {\n+        return scatterGather(queryName, Mono.just(query), responseType, timeout, timeUnit);\n+    }\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from several sources. The flux is completed when a {@code timeout} occurs or when all results are received.\n+     * Execution may be asynchronous, depending on the QueryBus implementation.\n+     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     * <b>Note</b>: Any {@code null} results will be filtered out by the QueryGateway. If you require the {@code null}\n+     * to be returned, we suggest using {@link QueryBus} instead.\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        a {@link Mono} which is resolved once the caller subscribes to the query result\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param timeout      A timeout of {@code long} for the query\n+     * @param timeUnit     The selected {@link TimeUnit} for the given {@code timeout}\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A flux of results.\n+     */\n+    <R, Q> Flux<R> scatterGather(String queryName, Mono<Q> query, ResponseType<R> responseType, long timeout,\n+                                 TimeUnit timeUnit);\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus} and returns result containing initial response and\n+     * incremental updates (received at the moment the query is sent, until it is cancelled by the caller or closed by\n+     * the emitting side).\n+     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     * <p>\n+     * <b>Note</b>: Any {@code null} results, on the initial result or the updates, will be filtered out by the\n+     * QueryGateway. If you require the {@code null} to be returned for the initial and update results, we suggest using\n+     * the {@link QueryBus} instead.\n+     *\n+     * @param query               The {@code query} to be sent\n+     * @param initialResponseType The initial response type used for this query\n+     * @param updateResponseType  The update response type used for this query\n+     * @param <Q>                 The type of the query\n+     * @param <I>                 The type of the initial response\n+     * @param <U>                 The type of the incremental update\n+     * @return registration which can be used to cancel receiving updates\n+     *\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage)\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage, SubscriptionQueryBackpressure, int)\n+     */\n+    default <Q, I, U> Mono<SubscriptionQueryResult<I, U>> subscriptionQuery(Q query, Class<I> initialResponseType,\n+                                                                            Class<U> updateResponseType) {\n+        return subscriptionQuery(query.getClass().getName(),\n+                                 query,\n+                                 initialResponseType,\n+                                 updateResponseType);\n+    }\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus} and returns result containing initial response and\n+     * incremental updates (received at the moment the query is sent, until it is cancelled by the caller or closed by\n+     * the emitting side).\n+     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     * <p>\n+     * <b>Note</b>: Any {@code null} results, on the initial result or the updates, will be filtered out by the\n+     * QueryGateway. If you require the {@code null} to be returned for the initial and update results, we suggest using\n+     * the {@link QueryBus} instead.\n+     *\n+     * @param queryName           A {@link String} describing query to be executed\n+     * @param query               The {@code query} to be sent\n+     * @param initialResponseType The initial response type used for this query\n+     * @param updateResponseType  The update response type used for this query\n+     * @param <Q>                 The type of the query\n+     * @param <I>                 The type of the initial response\n+     * @param <U>                 The type of the incremental update\n+     * @return registration which can be used to cancel receiving updates\n+     *\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage)\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage, SubscriptionQueryBackpressure, int)\n+     */\n+    default <Q, I, U> Mono<SubscriptionQueryResult<I, U>> subscriptionQuery(String queryName, Q query,\n+                                                                            Class<I> initialResponseType,\n+                                                                            Class<U> updateResponseType) {\n+        return subscriptionQuery(queryName,\n+                                 query,\n+                                 ResponseTypes.instanceOf(initialResponseType),\n+                                 ResponseTypes.instanceOf(updateResponseType),\n+                                 SubscriptionQueryBackpressure.defaultBackpressure());\n+    }\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus} and returns result containing initial response and\n+     * incremental updates (received at the moment the query is sent, until it is cancelled by the caller or closed by\n+     * the emitting side).\n+     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     * <p>\n+     * <b>Note</b>: Any {@code null} results, on the initial result or the updates, will be filtered out by the\n+     * QueryGateway. If you require the {@code null} to be returned for the initial and update results, we suggest using\n+     * the {@link QueryBus} instead.\n+     *\n+     * @param query               The {@code query} to be sent\n+     * @param initialResponseType The initial response type used for this query\n+     * @param updateResponseType  The update response type used for this query\n+     * @param <Q>                 The type of the query\n+     * @param <I>                 The type of the initial response\n+     * @param <U>                 The type of the incremental update\n+     * @return registration which can be used to cancel receiving updates\n+     *\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage)\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage, SubscriptionQueryBackpressure, int)\n+     */\n+    default <Q, I, U> Mono<SubscriptionQueryResult<I, U>> subscriptionQuery(Q query,\n+                                                                            ResponseType<I> initialResponseType,\n+                                                                            ResponseType<U> updateResponseType) {\n+        return subscriptionQuery(query.getClass().getName(),\n+                                 query,\n+                                 initialResponseType,\n+                                 updateResponseType,\n+                                 SubscriptionQueryBackpressure.defaultBackpressure());\n+    }\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus} and returns result containing initial response and\n+     * incremental updates (received at the moment the query is sent, until it is cancelled by the caller or closed by\n+     * the emitting side).\n+     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     * <p>\n+     * <b>Note</b>: Any {@code null} results, on the initial result or the updates, will be filtered out by the\n+     * QueryGateway. If you require the {@code null} to be returned for the initial and update results, we suggest using\n+     * the {@link QueryBus} instead.\n+     *\n+     * @param queryName           A {@link String} describing query to be executed\n+     * @param query               The {@code query} to be sent\n+     * @param initialResponseType The initial response type used for this query\n+     * @param updateResponseType  The update response type used for this query\n+     * @param backpressure        The backpressure mechanism to deal with producing of incremental updates\n+     * @param <Q>                 The type of the query\n+     * @param <I>                 The type of the initial response\n+     * @param <U>                 The type of the incremental update\n+     * @return registration which can be used to cancel receiving updates\n+     *\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage)\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage, SubscriptionQueryBackpressure, int)\n+     */\n+    default <Q, I, U> Mono<SubscriptionQueryResult<I, U>> subscriptionQuery(String queryName, Q query,\n+                                                                            ResponseType<I> initialResponseType,\n+                                                                            ResponseType<U> updateResponseType,\n+                                                                            SubscriptionQueryBackpressure backpressure) {\n+        return subscriptionQuery(queryName,\n+                                 query,\n+                                 initialResponseType,\n+                                 updateResponseType,\n+                                 backpressure,\n+                                 Queues.SMALL_BUFFER_SIZE);\n+    }\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus} and returns result containing initial response and\n+     * incremental updates (received at the moment the query is sent, until it is cancelled by the caller or closed by\n+     * the emitting side).\n+     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     * <p>\n+     * <b>Note</b>: Any {@code null} results, on the initial result or the updates, will be filtered out by the\n+     * QueryGateway. If you require the {@code null} to be returned for the initial and update results, we suggest using\n+     * the {@link QueryBus} instead.\n+     *\n+     * @param queryName           A {@link String} describing query to be executed\n+     * @param query               The {@code query} to be sent\n+     * @param initialResponseType The initial response type used for this query\n+     * @param updateResponseType  The update response type used for this query\n+     * @param backpressure        The backpressure mechanism to deal with producing of incremental updates\n+     * @param updateBufferSize    The size of buffer which accumulates updates before subscription to the {@code} flux\n+     *                            is made\n+     * @param <Q>                 The type of the query\n+     * @param <I>                 The type of the initial response\n+     * @param <U>                 The type of the incremental update\n+     * @return registration which can be used to cancel receiving updates\n+     *\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage)\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage, SubscriptionQueryBackpressure, int)\n+     */\n+    default <Q, I, U> Mono<SubscriptionQueryResult<I, U>> subscriptionQuery(String queryName, Q query,\n+                                                                            ResponseType<I> initialResponseType,\n+                                                                            ResponseType<U> updateResponseType,\n+                                                                            SubscriptionQueryBackpressure backpressure,\n+                                                                            int updateBufferSize) {\n+        return subscriptionQuery(queryName,\n+                                 Mono.just(query),\n+                                 initialResponseType,\n+                                 updateResponseType,\n+                                 backpressure,\n+                                 updateBufferSize);\n+    }\n+\n+    /**\n+     * Sends given {@code query} over the {@link QueryBus} and returns result containing initial response and\n+     * incremental updates (received at the moment the query is sent, until it is cancelled by the caller or closed by\n+     * the emitting side).\n+     * <p><b>Do note that query will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     * <p>\n+     * <b>Note</b>: Any {@code null} results, on the initial result or the updates, will be filtered out by the\n+     * QueryGateway. If you require the {@code null} to be returned for the initial and update results, we suggest using\n+     * the {@link QueryBus} instead.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c4511e81820de8d15c641e1c3038f4b688e29b51"}, "originalPosition": 364}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ1Nzc5MjE4OnYy", "diffSide": "RIGHT", "path": "spring-boot-autoconfigure/src/main/java/org/axonframework/springboot/autoconfig/AxonAutoConfiguration.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yM1QxNDowODo0N1rOF6HD8A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yM1QxNDowODo0N1rOF6HD8A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjQ3NzQyNA==", "bodyText": "I am missing tests which verify these beans are created.", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r396477424", "createdAt": "2020-03-23T14:08:47Z", "author": {"login": "smcvb"}, "path": "spring-boot-autoconfigure/src/main/java/org/axonframework/springboot/autoconfig/AxonAutoConfiguration.java", "diffHunk": "@@ -202,6 +205,24 @@ public QueryGateway queryGateway(QueryBus queryBus) {\n         return DefaultQueryGateway.builder().queryBus(queryBus).build();\n     }\n \n+    @Bean", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c4511e81820de8d15c641e1c3038f4b688e29b51"}, "originalPosition": 21}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ1NzgwNDI4OnYy", "diffSide": "RIGHT", "path": "messaging/src/main/java/org/axonframework/commandhandling/gateway/DefaultReactiveCommandGateway.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yM1QxNDoxMTozNlrOF6HLrw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yM1QxNDoxMTozNlrOF6HLrw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjQ3OTQwNw==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             * Default implementation of {@link ReactiveCommandGateway}.\n          \n          \n            \n             * Default implementation of the {@link ReactiveCommandGateway}.", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r396479407", "createdAt": "2020-03-23T14:11:36Z", "author": {"login": "smcvb"}, "path": "messaging/src/main/java/org/axonframework/commandhandling/gateway/DefaultReactiveCommandGateway.java", "diffHunk": "@@ -0,0 +1,207 @@\n+/*\n+ * Copyright (c) 2010-2020. Axon Framework\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.axonframework.commandhandling.gateway;\n+\n+import org.axonframework.commandhandling.CommandBus;\n+import org.axonframework.commandhandling.CommandCallback;\n+import org.axonframework.commandhandling.CommandMessage;\n+import org.axonframework.commandhandling.GenericCommandMessage;\n+import org.axonframework.common.AxonConfigurationException;\n+import org.axonframework.common.Registration;\n+import org.axonframework.messaging.ReactiveMessageDispatchInterceptor;\n+import reactor.core.publisher.Mono;\n+\n+import java.util.List;\n+import java.util.concurrent.CopyOnWriteArrayList;\n+\n+import static java.util.Arrays.asList;\n+import static org.axonframework.common.BuilderUtils.assertNonNull;\n+\n+/**\n+ * Default implementation of {@link ReactiveCommandGateway}.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c4511e81820de8d15c641e1c3038f4b688e29b51"}, "originalPosition": 35}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ1NzgzMjY2OnYy", "diffSide": "RIGHT", "path": "messaging/src/main/java/org/axonframework/commandhandling/gateway/ReactiveCommandGateway.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yM1QxNDoxODowMFrOF6Hd4A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yM1QxNDoxODowMFrOF6Hd4A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjQ4NDA2NA==", "bodyText": "Would it make sense to introduce a ReactiveMessageDispatchInterceptorSupport implementation which this interface extends? I feel it does, but might be suited for a follow up issue.", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r396484064", "createdAt": "2020-03-23T14:18:00Z", "author": {"login": "smcvb"}, "path": "messaging/src/main/java/org/axonframework/commandhandling/gateway/ReactiveCommandGateway.java", "diffHunk": "@@ -0,0 +1,55 @@\n+/*\n+ * Copyright (c) 2010-2020. Axon Framework\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.axonframework.commandhandling.gateway;\n+\n+import org.axonframework.messaging.Message;\n+import reactor.core.publisher.Mono;\n+\n+/**\n+ * Variation of {@link CommandGateway}. Provides support for reactive return type such as {@link Mono} from Project\n+ * Reactor.\n+ *\n+ * @author Milan Savic\n+ * @since 4.4\n+ */\n+public interface ReactiveCommandGateway {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c4511e81820de8d15c641e1c3038f4b688e29b51"}, "originalPosition": 29}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ1NzgzNjU4OnYy", "diffSide": "RIGHT", "path": "messaging/src/main/java/org/axonframework/messaging/ReactiveMessageDispatchInterceptor.java", "isResolved": true, "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yM1QxNDoxODo1MFrOF6HgXw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yNFQxMToxOToxNFrOGLS7sw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjQ4NDcwMw==", "bodyText": "Would there be a way to reuse the existing MessageDispatchInterceptor implementations as a ReactiveMessageDispatchInterceptor?", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r396484703", "createdAt": "2020-03-23T14:18:50Z", "author": {"login": "smcvb"}, "path": "messaging/src/main/java/org/axonframework/messaging/ReactiveMessageDispatchInterceptor.java", "diffHunk": "@@ -0,0 +1,44 @@\n+/*\n+ * Copyright (c) 2010-2020. Axon Framework\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.axonframework.messaging;\n+\n+import reactor.core.publisher.Mono;\n+\n+import java.util.function.Function;\n+import java.util.function.Supplier;\n+\n+/**\n+ * Interceptor that allows messages to be intercepted and modified before they are dispatched. Implementations are\n+ * required to provide a function that modifies a {@link Mono} of a message and returns a modified/new {@link Mono} to\n+ * be passed down the interceptor chain or to be sent. This way we provide a reactive way to intercept messages.\n+ *\n+ * @param <T> the message type this interceptor can process\n+ * @author Milan Savic\n+ * @since 4.4\n+ */\n+public interface ReactiveMessageDispatchInterceptor<T extends Message<?>> extends Supplier<Function<Mono<T>, Mono<T>>> {\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c4511e81820de8d15c641e1c3038f4b688e29b51"}, "originalPosition": 34}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTQ3MDg3Mg==", "bodyText": "Not really, at least I don't see a way since MessageDispatchInterceptor is parameterized with T extends Message<?> and ReactiveMessageDispatchInterceptor assumes using Mono<T extends Message<?>>.\nIf you have something else in mind please share :)", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r401470872", "createdAt": "2020-04-01T09:17:26Z", "author": {"login": "m1l4n54v1c"}, "path": "messaging/src/main/java/org/axonframework/messaging/ReactiveMessageDispatchInterceptor.java", "diffHunk": "@@ -0,0 +1,44 @@\n+/*\n+ * Copyright (c) 2010-2020. Axon Framework\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.axonframework.messaging;\n+\n+import reactor.core.publisher.Mono;\n+\n+import java.util.function.Function;\n+import java.util.function.Supplier;\n+\n+/**\n+ * Interceptor that allows messages to be intercepted and modified before they are dispatched. Implementations are\n+ * required to provide a function that modifies a {@link Mono} of a message and returns a modified/new {@link Mono} to\n+ * be passed down the interceptor chain or to be sent. This way we provide a reactive way to intercept messages.\n+ *\n+ * @param <T> the message type this interceptor can process\n+ * @author Milan Savic\n+ * @since 4.4\n+ */\n+public interface ReactiveMessageDispatchInterceptor<T extends Message<?>> extends Supplier<Function<Mono<T>, Mono<T>>> {\n+", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjQ4NDcwMw=="}, "originalCommit": {"oid": "c4511e81820de8d15c641e1c3038f4b688e29b51"}, "originalPosition": 34}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDEyMzU2Mg==", "bodyText": "Nope, not really...let's go with this for now and have both gateways take their own path.", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r404123562", "createdAt": "2020-04-06T14:13:29Z", "author": {"login": "smcvb"}, "path": "messaging/src/main/java/org/axonframework/messaging/ReactiveMessageDispatchInterceptor.java", "diffHunk": "@@ -0,0 +1,44 @@\n+/*\n+ * Copyright (c) 2010-2020. Axon Framework\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.axonframework.messaging;\n+\n+import reactor.core.publisher.Mono;\n+\n+import java.util.function.Function;\n+import java.util.function.Supplier;\n+\n+/**\n+ * Interceptor that allows messages to be intercepted and modified before they are dispatched. Implementations are\n+ * required to provide a function that modifies a {@link Mono} of a message and returns a modified/new {@link Mono} to\n+ * be passed down the interceptor chain or to be sent. This way we provide a reactive way to intercept messages.\n+ *\n+ * @param <T> the message type this interceptor can process\n+ * @author Milan Savic\n+ * @since 4.4\n+ */\n+public interface ReactiveMessageDispatchInterceptor<T extends Message<?>> extends Supplier<Function<Mono<T>, Mono<T>>> {\n+", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjQ4NDcwMw=="}, "originalCommit": {"oid": "c4511e81820de8d15c641e1c3038f4b688e29b51"}, "originalPosition": 34}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzY4NTA2NA==", "bodyText": "Can we then at least make sure that existing DispatchInterceptors can be used in the reactive gateway? By means of a wrapper, perhaps?", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r413685064", "createdAt": "2020-04-23T10:04:40Z", "author": {"login": "abuijze"}, "path": "messaging/src/main/java/org/axonframework/messaging/ReactiveMessageDispatchInterceptor.java", "diffHunk": "@@ -0,0 +1,44 @@\n+/*\n+ * Copyright (c) 2010-2020. Axon Framework\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.axonframework.messaging;\n+\n+import reactor.core.publisher.Mono;\n+\n+import java.util.function.Function;\n+import java.util.function.Supplier;\n+\n+/**\n+ * Interceptor that allows messages to be intercepted and modified before they are dispatched. Implementations are\n+ * required to provide a function that modifies a {@link Mono} of a message and returns a modified/new {@link Mono} to\n+ * be passed down the interceptor chain or to be sent. This way we provide a reactive way to intercept messages.\n+ *\n+ * @param <T> the message type this interceptor can process\n+ * @author Milan Savic\n+ * @since 4.4\n+ */\n+public interface ReactiveMessageDispatchInterceptor<T extends Message<?>> extends Supplier<Function<Mono<T>, Mono<T>>> {\n+", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjQ4NDcwMw=="}, "originalCommit": {"oid": "c4511e81820de8d15c641e1c3038f4b688e29b51"}, "originalPosition": 34}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzY5MDIxNQ==", "bodyText": "I actually think it is possible, generics wise....", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r413690215", "createdAt": "2020-04-23T10:12:23Z", "author": {"login": "abuijze"}, "path": "messaging/src/main/java/org/axonframework/messaging/ReactiveMessageDispatchInterceptor.java", "diffHunk": "@@ -0,0 +1,44 @@\n+/*\n+ * Copyright (c) 2010-2020. Axon Framework\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.axonframework.messaging;\n+\n+import reactor.core.publisher.Mono;\n+\n+import java.util.function.Function;\n+import java.util.function.Supplier;\n+\n+/**\n+ * Interceptor that allows messages to be intercepted and modified before they are dispatched. Implementations are\n+ * required to provide a function that modifies a {@link Mono} of a message and returns a modified/new {@link Mono} to\n+ * be passed down the interceptor chain or to be sent. This way we provide a reactive way to intercept messages.\n+ *\n+ * @param <T> the message type this interceptor can process\n+ * @author Milan Savic\n+ * @since 4.4\n+ */\n+public interface ReactiveMessageDispatchInterceptor<T extends Message<?>> extends Supplier<Function<Mono<T>, Mono<T>>> {\n+", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjQ4NDcwMw=="}, "originalCommit": {"oid": "c4511e81820de8d15c641e1c3038f4b688e29b51"}, "originalPosition": 34}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDQ5NzcxNQ==", "bodyText": "Oooh, looking forward to that! Would definitely improve this implementation if the existing interceptors can be used.", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r414497715", "createdAt": "2020-04-24T11:19:14Z", "author": {"login": "smcvb"}, "path": "messaging/src/main/java/org/axonframework/messaging/ReactiveMessageDispatchInterceptor.java", "diffHunk": "@@ -0,0 +1,44 @@\n+/*\n+ * Copyright (c) 2010-2020. Axon Framework\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.axonframework.messaging;\n+\n+import reactor.core.publisher.Mono;\n+\n+import java.util.function.Function;\n+import java.util.function.Supplier;\n+\n+/**\n+ * Interceptor that allows messages to be intercepted and modified before they are dispatched. Implementations are\n+ * required to provide a function that modifies a {@link Mono} of a message and returns a modified/new {@link Mono} to\n+ * be passed down the interceptor chain or to be sent. This way we provide a reactive way to intercept messages.\n+ *\n+ * @param <T> the message type this interceptor can process\n+ * @author Milan Savic\n+ * @since 4.4\n+ */\n+public interface ReactiveMessageDispatchInterceptor<T extends Message<?>> extends Supplier<Function<Mono<T>, Mono<T>>> {\n+", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjQ4NDcwMw=="}, "originalCommit": {"oid": "c4511e81820de8d15c641e1c3038f4b688e29b51"}, "originalPosition": 34}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ1Nzg0MjE1OnYy", "diffSide": "RIGHT", "path": "messaging/src/main/java/org/axonframework/queryhandling/DefaultReactiveQueryGateway.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yM1QxNDoyMDowOFrOF6HkAQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yM1QxNDoyMDowOFrOF6HkAQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjQ4NTYzMw==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             * Default implementation of {@link ReactiveQueryGateway}.\n          \n          \n            \n             * Default implementation of the {@link ReactiveQueryGateway}.", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r396485633", "createdAt": "2020-03-23T14:20:08Z", "author": {"login": "smcvb"}, "path": "messaging/src/main/java/org/axonframework/queryhandling/DefaultReactiveQueryGateway.java", "diffHunk": "@@ -0,0 +1,244 @@\n+/*\n+ * Copyright (c) 2010-2020. Axon Framework\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.axonframework.queryhandling;\n+\n+import org.axonframework.common.AxonConfigurationException;\n+import org.axonframework.common.Registration;\n+import org.axonframework.messaging.IllegalPayloadAccessException;\n+import org.axonframework.messaging.Message;\n+import org.axonframework.messaging.ReactiveMessageDispatchInterceptor;\n+import org.axonframework.messaging.responsetypes.ResponseType;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Mono;\n+\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.concurrent.CopyOnWriteArrayList;\n+import java.util.concurrent.TimeUnit;\n+\n+import static java.util.Arrays.asList;\n+import static org.axonframework.common.BuilderUtils.assertNonNull;\n+\n+/**\n+ * Default implementation of {@link ReactiveQueryGateway}.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c4511e81820de8d15c641e1c3038f4b688e29b51"}, "originalPosition": 37}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ1Nzg1NTgzOnYy", "diffSide": "RIGHT", "path": "messaging/src/main/java/org/axonframework/queryhandling/DefaultReactiveQueryGateway.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yM1QxNDoyMjo1NVrOF6HsmQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yN1QxNTo0MzozNVrOF826qw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjQ4NzgzMw==", "bodyText": "Thought: I've personally been moving away from method-level warning suppression towards line/statement suppression. Reasoning behind this is that developers can now accidentally add unintended stuff they do not want to suppress. What do you think?", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r396487833", "createdAt": "2020-03-23T14:22:55Z", "author": {"login": "smcvb"}, "path": "messaging/src/main/java/org/axonframework/queryhandling/DefaultReactiveQueryGateway.java", "diffHunk": "@@ -0,0 +1,244 @@\n+/*\n+ * Copyright (c) 2010-2020. Axon Framework\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.axonframework.queryhandling;\n+\n+import org.axonframework.common.AxonConfigurationException;\n+import org.axonframework.common.Registration;\n+import org.axonframework.messaging.IllegalPayloadAccessException;\n+import org.axonframework.messaging.Message;\n+import org.axonframework.messaging.ReactiveMessageDispatchInterceptor;\n+import org.axonframework.messaging.responsetypes.ResponseType;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Mono;\n+\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.concurrent.CopyOnWriteArrayList;\n+import java.util.concurrent.TimeUnit;\n+\n+import static java.util.Arrays.asList;\n+import static org.axonframework.common.BuilderUtils.assertNonNull;\n+\n+/**\n+ * Default implementation of {@link ReactiveQueryGateway}.\n+ *\n+ * @author Milan Savic\n+ * @since 4.4\n+ */\n+public class DefaultReactiveQueryGateway implements ReactiveQueryGateway {\n+\n+    private final List<ReactiveMessageDispatchInterceptor<QueryMessage<?, ?>>> dispatchInterceptors;\n+\n+    private final QueryBus queryBus;\n+\n+    /**\n+     * Creates an instance of {@link DefaultReactiveQueryGateway} based on the fields contained in the {@link\n+     * Builder}.\n+     * <p>\n+     * Will assert that the {@link QueryBus} is not {@code null} and throws an {@link AxonConfigurationException} if\n+     * it is.\n+     * </p>\n+     *\n+     * @param builder the {@link Builder} used to instantiated a {@link DefaultReactiveQueryGateway} instance\n+     */\n+    protected DefaultReactiveQueryGateway(Builder builder) {\n+        builder.validate();\n+        this.queryBus = builder.queryBus;\n+        this.dispatchInterceptors = builder.dispatchInterceptors;\n+    }\n+\n+    /**\n+     * Instantiate a Builder to be able to create a {@link DefaultReactiveQueryGateway}.\n+     * <p>\n+     * The {@code dispatchInterceptors} are defaulted to an empty list.\n+     * The {@link QueryBus} is a <b>hard requirements</b> and as such should be provided.\n+     * </p>\n+     *\n+     * @return a Builder to be able to create a {@link DefaultReactiveQueryGateway}\n+     */\n+    public static Builder builder() {\n+        return new Builder();\n+    }\n+\n+    /**\n+     * Registers a {@link ReactiveMessageDispatchInterceptor} within this reactive gateway.\n+     *\n+     * @param interceptor intercepts a query message\n+     * @return a registration which can be used to unregister this {@code interceptor}\n+     */\n+    public Registration registerQueryDispatchInterceptor(\n+            ReactiveMessageDispatchInterceptor<QueryMessage<?, ?>> interceptor) {\n+        dispatchInterceptors.add(interceptor);\n+        return () -> dispatchInterceptors.remove(interceptor);\n+    }\n+\n+    private Mono<QueryMessage<?, ?>> processInterceptors(Mono<QueryMessage<?, ?>> queryMessage) {\n+        Mono<QueryMessage<?, ?>> message = queryMessage;\n+        for (ReactiveMessageDispatchInterceptor<QueryMessage<?, ?>> dispatchInterceptor : dispatchInterceptors) {\n+            try {\n+                message = dispatchInterceptor.intercept(message);\n+            } catch (Throwable t) {\n+                return Mono.error(t);\n+            }\n+        }\n+        return message;\n+    }\n+\n+    @Override\n+    @SuppressWarnings(\"unchecked\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c4511e81820de8d15c641e1c3038f4b688e29b51"}, "originalPosition": 102}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTM1ODYzNQ==", "bodyText": "Agree!", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r399358635", "createdAt": "2020-03-27T15:43:35Z", "author": {"login": "m1l4n54v1c"}, "path": "messaging/src/main/java/org/axonframework/queryhandling/DefaultReactiveQueryGateway.java", "diffHunk": "@@ -0,0 +1,244 @@\n+/*\n+ * Copyright (c) 2010-2020. Axon Framework\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.axonframework.queryhandling;\n+\n+import org.axonframework.common.AxonConfigurationException;\n+import org.axonframework.common.Registration;\n+import org.axonframework.messaging.IllegalPayloadAccessException;\n+import org.axonframework.messaging.Message;\n+import org.axonframework.messaging.ReactiveMessageDispatchInterceptor;\n+import org.axonframework.messaging.responsetypes.ResponseType;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Mono;\n+\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.concurrent.CopyOnWriteArrayList;\n+import java.util.concurrent.TimeUnit;\n+\n+import static java.util.Arrays.asList;\n+import static org.axonframework.common.BuilderUtils.assertNonNull;\n+\n+/**\n+ * Default implementation of {@link ReactiveQueryGateway}.\n+ *\n+ * @author Milan Savic\n+ * @since 4.4\n+ */\n+public class DefaultReactiveQueryGateway implements ReactiveQueryGateway {\n+\n+    private final List<ReactiveMessageDispatchInterceptor<QueryMessage<?, ?>>> dispatchInterceptors;\n+\n+    private final QueryBus queryBus;\n+\n+    /**\n+     * Creates an instance of {@link DefaultReactiveQueryGateway} based on the fields contained in the {@link\n+     * Builder}.\n+     * <p>\n+     * Will assert that the {@link QueryBus} is not {@code null} and throws an {@link AxonConfigurationException} if\n+     * it is.\n+     * </p>\n+     *\n+     * @param builder the {@link Builder} used to instantiated a {@link DefaultReactiveQueryGateway} instance\n+     */\n+    protected DefaultReactiveQueryGateway(Builder builder) {\n+        builder.validate();\n+        this.queryBus = builder.queryBus;\n+        this.dispatchInterceptors = builder.dispatchInterceptors;\n+    }\n+\n+    /**\n+     * Instantiate a Builder to be able to create a {@link DefaultReactiveQueryGateway}.\n+     * <p>\n+     * The {@code dispatchInterceptors} are defaulted to an empty list.\n+     * The {@link QueryBus} is a <b>hard requirements</b> and as such should be provided.\n+     * </p>\n+     *\n+     * @return a Builder to be able to create a {@link DefaultReactiveQueryGateway}\n+     */\n+    public static Builder builder() {\n+        return new Builder();\n+    }\n+\n+    /**\n+     * Registers a {@link ReactiveMessageDispatchInterceptor} within this reactive gateway.\n+     *\n+     * @param interceptor intercepts a query message\n+     * @return a registration which can be used to unregister this {@code interceptor}\n+     */\n+    public Registration registerQueryDispatchInterceptor(\n+            ReactiveMessageDispatchInterceptor<QueryMessage<?, ?>> interceptor) {\n+        dispatchInterceptors.add(interceptor);\n+        return () -> dispatchInterceptors.remove(interceptor);\n+    }\n+\n+    private Mono<QueryMessage<?, ?>> processInterceptors(Mono<QueryMessage<?, ?>> queryMessage) {\n+        Mono<QueryMessage<?, ?>> message = queryMessage;\n+        for (ReactiveMessageDispatchInterceptor<QueryMessage<?, ?>> dispatchInterceptor : dispatchInterceptors) {\n+            try {\n+                message = dispatchInterceptor.intercept(message);\n+            } catch (Throwable t) {\n+                return Mono.error(t);\n+            }\n+        }\n+        return message;\n+    }\n+\n+    @Override\n+    @SuppressWarnings(\"unchecked\")", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjQ4NzgzMw=="}, "originalCommit": {"oid": "c4511e81820de8d15c641e1c3038f4b688e29b51"}, "originalPosition": 102}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ1Nzg5MjA5OnYy", "diffSide": "RIGHT", "path": "messaging/src/test/java/org/axonframework/commandhandling/gateway/DefaultReactiveCommandGatewayTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yM1QxNDozMTowNFrOF6ID2g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yM1QxNDozMTowNFrOF6ID2g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjQ5Mzc4Ng==", "bodyText": "With the move to JUnit 5, all test classes have been made package-private.", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r396493786", "createdAt": "2020-03-23T14:31:04Z", "author": {"login": "smcvb"}, "path": "messaging/src/test/java/org/axonframework/commandhandling/gateway/DefaultReactiveCommandGatewayTest.java", "diffHunk": "@@ -0,0 +1,121 @@\n+/*\n+ * Copyright (c) 2010-2020. Axon Framework\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.axonframework.commandhandling.gateway;\n+\n+import org.axonframework.commandhandling.CommandBus;\n+import org.axonframework.commandhandling.CommandMessage;\n+import org.axonframework.commandhandling.SimpleCommandBus;\n+import org.axonframework.common.Registration;\n+import org.axonframework.messaging.MessageHandler;\n+import org.junit.jupiter.api.*;\n+import reactor.core.publisher.Mono;\n+import reactor.test.StepVerifier;\n+\n+import java.util.Collections;\n+\n+import static org.mockito.Mockito.*;\n+\n+/**\n+ * Tests for {@link ReactiveCommandGateway}.\n+ *\n+ * @author Milan Savic\n+ */\n+public class DefaultReactiveCommandGatewayTest {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c4511e81820de8d15c641e1c3038f4b688e29b51"}, "originalPosition": 37}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUwNzc1MjIwOnYy", "diffSide": "RIGHT", "path": "messaging/src/main/java/org/axonframework/messaging/ReactiveMessageDispatchInterceptorSupport.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNlQxNDozNTowOVrOGBazjg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNlQxNDozNTowOVrOGBazjg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDE0MDk0Mg==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             * Interface marking components capable of registering Reactive Dispatch Interceptors. Generally, these are Messaging\n          \n          \n            \n             * Interface marking components capable of registering a {@link ReactiveMessageDispatchInterceptor}. Generally, these are messaging", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r404140942", "createdAt": "2020-04-06T14:35:09Z", "author": {"login": "smcvb"}, "path": "messaging/src/main/java/org/axonframework/messaging/ReactiveMessageDispatchInterceptorSupport.java", "diffHunk": "@@ -0,0 +1,39 @@\n+/*\n+ * Copyright (c) 2010-2020. Axon Framework\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.axonframework.messaging;\n+\n+import org.axonframework.common.Registration;\n+\n+/**\n+ * Interface marking components capable of registering Reactive Dispatch Interceptors. Generally, these are Messaging", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d85b4f18074f957a2039ac08fdfb6e5a86d919f5"}, "originalPosition": 22}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUwNzc1NTc2OnYy", "diffSide": "RIGHT", "path": "messaging/src/main/java/org/axonframework/messaging/ReactiveMessageDispatchInterceptorSupport.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNlQxNDozNTo1OFrOGBa10w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNFQwNzo0Mjo0NlrOGFCFbQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDE0MTUyMw==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * Register the given Reactive Dispatch Interceptor. After registration, the interceptor will be invoked for each\n          \n          \n            \n                 * Message dispatched on the messaging component that it was registered to.\n          \n          \n            \n                 *\n          \n          \n            \n                 * @param interceptor The reactive interceptor to register\n          \n          \n            \n                 * @return a Registration, which may be used to remove the unregister the interceptor\n          \n          \n            \n                 * Register the given {@link ReactiveMessageDispatchInterceptor}. After registration, the interceptor will be invoked for each\n          \n          \n            \n                 * message dispatched on the messaging component that it was registered to.\n          \n          \n            \n                 *\n          \n          \n            \n                 * @param interceptor The reactive interceptor to register\n          \n          \n            \n                 * @return a Registration, which may be used to unregister the interceptor", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r404141523", "createdAt": "2020-04-06T14:35:58Z", "author": {"login": "smcvb"}, "path": "messaging/src/main/java/org/axonframework/messaging/ReactiveMessageDispatchInterceptorSupport.java", "diffHunk": "@@ -0,0 +1,39 @@\n+/*\n+ * Copyright (c) 2010-2020. Axon Framework\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.axonframework.messaging;\n+\n+import org.axonframework.common.Registration;\n+\n+/**\n+ * Interface marking components capable of registering Reactive Dispatch Interceptors. Generally, these are Messaging\n+ * components injected into the sending end of the communication.\n+ *\n+ * @param <T>\n+ * @author Milan Savic\n+ * @since 4.4\n+ */\n+public interface ReactiveMessageDispatchInterceptorSupport<T extends Message<?>> {\n+\n+    /**\n+     * Register the given Reactive Dispatch Interceptor. After registration, the interceptor will be invoked for each\n+     * Message dispatched on the messaging component that it was registered to.\n+     *\n+     * @param interceptor The reactive interceptor to register\n+     * @return a Registration, which may be used to remove the unregister the interceptor", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d85b4f18074f957a2039ac08fdfb6e5a86d919f5"}, "originalPosition": 36}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjAwNjQ1MA==", "bodyText": "essage? :O", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r406006450", "createdAt": "2020-04-09T07:25:05Z", "author": {"login": "m1l4n54v1c"}, "path": "messaging/src/main/java/org/axonframework/messaging/ReactiveMessageDispatchInterceptorSupport.java", "diffHunk": "@@ -0,0 +1,39 @@\n+/*\n+ * Copyright (c) 2010-2020. Axon Framework\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.axonframework.messaging;\n+\n+import org.axonframework.common.Registration;\n+\n+/**\n+ * Interface marking components capable of registering Reactive Dispatch Interceptors. Generally, these are Messaging\n+ * components injected into the sending end of the communication.\n+ *\n+ * @param <T>\n+ * @author Milan Savic\n+ * @since 4.4\n+ */\n+public interface ReactiveMessageDispatchInterceptorSupport<T extends Message<?>> {\n+\n+    /**\n+     * Register the given Reactive Dispatch Interceptor. After registration, the interceptor will be invoked for each\n+     * Message dispatched on the messaging component that it was registered to.\n+     *\n+     * @param interceptor The reactive interceptor to register\n+     * @return a Registration, which may be used to remove the unregister the interceptor", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDE0MTUyMw=="}, "originalCommit": {"oid": "d85b4f18074f957a2039ac08fdfb6e5a86d919f5"}, "originalPosition": 36}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzkzMDIyMQ==", "bodyText": "Whoops, that suggestion isn't entirely correct. Updated it just now.", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r407930221", "createdAt": "2020-04-14T07:42:46Z", "author": {"login": "smcvb"}, "path": "messaging/src/main/java/org/axonframework/messaging/ReactiveMessageDispatchInterceptorSupport.java", "diffHunk": "@@ -0,0 +1,39 @@\n+/*\n+ * Copyright (c) 2010-2020. Axon Framework\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.axonframework.messaging;\n+\n+import org.axonframework.common.Registration;\n+\n+/**\n+ * Interface marking components capable of registering Reactive Dispatch Interceptors. Generally, these are Messaging\n+ * components injected into the sending end of the communication.\n+ *\n+ * @param <T>\n+ * @author Milan Savic\n+ * @since 4.4\n+ */\n+public interface ReactiveMessageDispatchInterceptorSupport<T extends Message<?>> {\n+\n+    /**\n+     * Register the given Reactive Dispatch Interceptor. After registration, the interceptor will be invoked for each\n+     * Message dispatched on the messaging component that it was registered to.\n+     *\n+     * @param interceptor The reactive interceptor to register\n+     * @return a Registration, which may be used to remove the unregister the interceptor", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDE0MTUyMw=="}, "originalCommit": {"oid": "d85b4f18074f957a2039ac08fdfb6e5a86d919f5"}, "originalPosition": 36}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUwNzc3Nzk0OnYy", "diffSide": "RIGHT", "path": "messaging/src/main/java/org/axonframework/queryhandling/SimpleQueryBus.java", "isResolved": true, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNlQxNDo0MDozOFrOGBbD3w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNFQwNzo0MzowOFrOGFCGHQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDE0NTExOQ==", "bodyText": "This change makes it so that the javadoc of the QueryBus#scatterGather method is no longer incorrect, as it states:\n\nIf no handlers are available to provide a result, or when all available handlers throw an exception while attempting to do so, the returned Stream is empty.\n\nWith these, exceptions are also reported. Sounds fine to me, but the documentation should be correct on the matter.", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r404145119", "createdAt": "2020-04-06T14:40:38Z", "author": {"login": "smcvb"}, "path": "messaging/src/main/java/org/axonframework/queryhandling/SimpleQueryBus.java", "diffHunk": "@@ -198,16 +198,22 @@ private boolean unsubscribe(String queryName,\n                                    interceptAndInvoke(DefaultUnitOfWork.startAndGet(interceptedQuery),\n                                                       handler);\n                            QueryResponseMessage<R> response = null;\n+                           //noinspection unchecked", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d85b4f18074f957a2039ac08fdfb6e5a86d919f5"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDE0NzY5Mg==", "bodyText": "Additionally, this change will make it so that users of the DefaultQueryGateway now experience IllegalPayloadAccessException when going through the stream of results.\nThis occurs because the GenericResultMessage#getPayload will throw this in case of an exception. Is that desired?", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r404147692", "createdAt": "2020-04-06T14:44:00Z", "author": {"login": "smcvb"}, "path": "messaging/src/main/java/org/axonframework/queryhandling/SimpleQueryBus.java", "diffHunk": "@@ -198,16 +198,22 @@ private boolean unsubscribe(String queryName,\n                                    interceptAndInvoke(DefaultUnitOfWork.startAndGet(interceptedQuery),\n                                                       handler);\n                            QueryResponseMessage<R> response = null;\n+                           //noinspection unchecked", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDE0NTExOQ=="}, "originalCommit": {"oid": "d85b4f18074f957a2039ac08fdfb6e5a86d919f5"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjAxMTExNA==", "bodyText": "Good point! I propose to filter out exceptional results on the gateway. @abuijze what's your take on the bus change?", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r406011114", "createdAt": "2020-04-09T07:34:41Z", "author": {"login": "m1l4n54v1c"}, "path": "messaging/src/main/java/org/axonframework/queryhandling/SimpleQueryBus.java", "diffHunk": "@@ -198,16 +198,22 @@ private boolean unsubscribe(String queryName,\n                                    interceptAndInvoke(DefaultUnitOfWork.startAndGet(interceptedQuery),\n                                                       handler);\n                            QueryResponseMessage<R> response = null;\n+                           //noinspection unchecked", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDE0NTExOQ=="}, "originalCommit": {"oid": "d85b4f18074f957a2039ac08fdfb6e5a86d919f5"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjcyNDM4NA==", "bodyText": "Had a discussion with Allard. The conclusion is not to report query handling errors of scatter-gather queries to the calling side. Rationale: scatter-gather is best effort query and it shouldn't care about errors like a simple query.", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r406724384", "createdAt": "2020-04-10T11:52:33Z", "author": {"login": "m1l4n54v1c"}, "path": "messaging/src/main/java/org/axonframework/queryhandling/SimpleQueryBus.java", "diffHunk": "@@ -198,16 +198,22 @@ private boolean unsubscribe(String queryName,\n                                    interceptAndInvoke(DefaultUnitOfWork.startAndGet(interceptedQuery),\n                                                       handler);\n                            QueryResponseMessage<R> response = null;\n+                           //noinspection unchecked", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDE0NTExOQ=="}, "originalCommit": {"oid": "d85b4f18074f957a2039ac08fdfb6e5a86d919f5"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzkzMDM5Nw==", "bodyText": "Thanks for the clarification \ud83d\udc4d", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r407930397", "createdAt": "2020-04-14T07:43:08Z", "author": {"login": "smcvb"}, "path": "messaging/src/main/java/org/axonframework/queryhandling/SimpleQueryBus.java", "diffHunk": "@@ -198,16 +198,22 @@ private boolean unsubscribe(String queryName,\n                                    interceptAndInvoke(DefaultUnitOfWork.startAndGet(interceptedQuery),\n                                                       handler);\n                            QueryResponseMessage<R> response = null;\n+                           //noinspection unchecked", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDE0NTExOQ=="}, "originalCommit": {"oid": "d85b4f18074f957a2039ac08fdfb6e5a86d919f5"}, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUzMjU3NjQ3OnYy", "diffSide": "RIGHT", "path": "messaging/src/test/java/org/axonframework/commandhandling/gateway/DefaultReactiveCommandGatewayTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNFQwNzo1Njo1MFrOGFCkYw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yN1QxMDoyNToyNFrOGMb8rw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzkzODE0Nw==", "bodyText": "At this stage, it's still zero because the Flux/Publisher hasn't begun publishing yet, right? That only starts as soon as you push the result through the StepVerifier(?).", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r407938147", "createdAt": "2020-04-14T07:56:50Z", "author": {"login": "smcvb"}, "path": "messaging/src/test/java/org/axonframework/commandhandling/gateway/DefaultReactiveCommandGatewayTest.java", "diffHunk": "@@ -0,0 +1,168 @@\n+/*\n+ * Copyright (c) 2010-2020. Axon Framework\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.axonframework.commandhandling.gateway;\n+\n+import org.axonframework.commandhandling.AsynchronousCommandBus;\n+import org.axonframework.commandhandling.CommandBus;\n+import org.axonframework.commandhandling.CommandMessage;\n+import org.axonframework.common.Registration;\n+import org.axonframework.messaging.MessageHandler;\n+import org.junit.jupiter.api.*;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Mono;\n+import reactor.test.StepVerifier;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.stream.IntStream;\n+\n+import static java.util.stream.Collectors.toList;\n+import static org.junit.jupiter.api.Assertions.*;\n+import static org.mockito.Mockito.*;\n+\n+/**\n+ * Tests for {@link ReactiveCommandGateway}.\n+ *\n+ * @author Milan Savic\n+ */\n+class DefaultReactiveCommandGatewayTest {\n+\n+    private DefaultReactiveCommandGateway reactiveCommandGateway;\n+    private MessageHandler<CommandMessage<?>> commandMessageHandler;\n+    private RetryScheduler mockRetryScheduler;\n+\n+    @BeforeEach\n+    void setUp() {\n+        CommandBus commandBus = AsynchronousCommandBus.builder().build();\n+        mockRetryScheduler = mock(RetryScheduler.class);\n+        commandMessageHandler = spy(new MessageHandler<CommandMessage<?>>() {\n+\n+            private final AtomicInteger count = new AtomicInteger();\n+\n+            @Override\n+            public Object handle(CommandMessage<?> message) {\n+                if (\"backpressure\".equals(message.getPayload())) {\n+                    return count.incrementAndGet();\n+                }\n+                return \"handled\";\n+            }\n+        });\n+        commandBus.subscribe(String.class.getName(), commandMessageHandler);\n+        commandBus.subscribe(Integer.class.getName(), message -> {\n+            throw new RuntimeException();\n+        });\n+        commandBus.subscribe(Boolean.class.getName(),\n+                             message -> \"\" + message.getMetaData().getOrDefault(\"key1\", \"\")\n+                                     + message.getMetaData().getOrDefault(\"key2\", \"\"));\n+        reactiveCommandGateway = DefaultReactiveCommandGateway.builder()\n+                                                              .commandBus(commandBus)\n+                                                              .retryScheduler(mockRetryScheduler)\n+                                                              .build();\n+    }\n+\n+    @Test\n+    void testSend() throws Exception {\n+        Mono<String> result = reactiveCommandGateway.send(\"command\");\n+        verifyZeroInteractions(commandMessageHandler);\n+        StepVerifier.create(result)\n+                    .expectNext(\"handled\")\n+                    .verifyComplete();\n+        verify(commandMessageHandler).handle(any());\n+        verifyZeroInteractions(mockRetryScheduler);\n+    }\n+\n+    @Test\n+    void testSendAll() throws Exception {\n+        Flux<Object> commands = Flux.fromIterable(Arrays.asList(\"command1\", 4, \"command2\", 5, true));\n+\n+        Flux<Object> result = reactiveCommandGateway.sendAll(commands);\n+        verifyZeroInteractions(commandMessageHandler);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fed248c8e117f0334af95f899d86d3007752c065"}, "originalPosition": 96}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTY5Mzk5OQ==", "bodyText": "As soon as you subscribe, not before. That's what we're testing here - laziness.", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r415693999", "createdAt": "2020-04-27T10:25:24Z", "author": {"login": "m1l4n54v1c"}, "path": "messaging/src/test/java/org/axonframework/commandhandling/gateway/DefaultReactiveCommandGatewayTest.java", "diffHunk": "@@ -0,0 +1,168 @@\n+/*\n+ * Copyright (c) 2010-2020. Axon Framework\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.axonframework.commandhandling.gateway;\n+\n+import org.axonframework.commandhandling.AsynchronousCommandBus;\n+import org.axonframework.commandhandling.CommandBus;\n+import org.axonframework.commandhandling.CommandMessage;\n+import org.axonframework.common.Registration;\n+import org.axonframework.messaging.MessageHandler;\n+import org.junit.jupiter.api.*;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Mono;\n+import reactor.test.StepVerifier;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.stream.IntStream;\n+\n+import static java.util.stream.Collectors.toList;\n+import static org.junit.jupiter.api.Assertions.*;\n+import static org.mockito.Mockito.*;\n+\n+/**\n+ * Tests for {@link ReactiveCommandGateway}.\n+ *\n+ * @author Milan Savic\n+ */\n+class DefaultReactiveCommandGatewayTest {\n+\n+    private DefaultReactiveCommandGateway reactiveCommandGateway;\n+    private MessageHandler<CommandMessage<?>> commandMessageHandler;\n+    private RetryScheduler mockRetryScheduler;\n+\n+    @BeforeEach\n+    void setUp() {\n+        CommandBus commandBus = AsynchronousCommandBus.builder().build();\n+        mockRetryScheduler = mock(RetryScheduler.class);\n+        commandMessageHandler = spy(new MessageHandler<CommandMessage<?>>() {\n+\n+            private final AtomicInteger count = new AtomicInteger();\n+\n+            @Override\n+            public Object handle(CommandMessage<?> message) {\n+                if (\"backpressure\".equals(message.getPayload())) {\n+                    return count.incrementAndGet();\n+                }\n+                return \"handled\";\n+            }\n+        });\n+        commandBus.subscribe(String.class.getName(), commandMessageHandler);\n+        commandBus.subscribe(Integer.class.getName(), message -> {\n+            throw new RuntimeException();\n+        });\n+        commandBus.subscribe(Boolean.class.getName(),\n+                             message -> \"\" + message.getMetaData().getOrDefault(\"key1\", \"\")\n+                                     + message.getMetaData().getOrDefault(\"key2\", \"\"));\n+        reactiveCommandGateway = DefaultReactiveCommandGateway.builder()\n+                                                              .commandBus(commandBus)\n+                                                              .retryScheduler(mockRetryScheduler)\n+                                                              .build();\n+    }\n+\n+    @Test\n+    void testSend() throws Exception {\n+        Mono<String> result = reactiveCommandGateway.send(\"command\");\n+        verifyZeroInteractions(commandMessageHandler);\n+        StepVerifier.create(result)\n+                    .expectNext(\"handled\")\n+                    .verifyComplete();\n+        verify(commandMessageHandler).handle(any());\n+        verifyZeroInteractions(mockRetryScheduler);\n+    }\n+\n+    @Test\n+    void testSendAll() throws Exception {\n+        Flux<Object> commands = Flux.fromIterable(Arrays.asList(\"command1\", 4, \"command2\", 5, true));\n+\n+        Flux<Object> result = reactiveCommandGateway.sendAll(commands);\n+        verifyZeroInteractions(commandMessageHandler);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzkzODE0Nw=="}, "originalCommit": {"oid": "fed248c8e117f0334af95f899d86d3007752c065"}, "originalPosition": 96}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU3MTE1NTU3OnYy", "diffSide": "RIGHT", "path": "messaging/src/main/java/org/axonframework/commandhandling/gateway/DefaultReactiveCommandGateway.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yM1QxMDowNzozM1rOGKhc9A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yM1QxMDowNzo1OVrOGKhd-Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzY4NzAyOA==", "bodyText": "Is this the DefaultReactiveCommandGateway or a ReactorReactiveCommandGateway? The implementation \"assumption\" this makes, is that you use Project Reactor, right?", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r413687028", "createdAt": "2020-04-23T10:07:33Z", "author": {"login": "abuijze"}, "path": "messaging/src/main/java/org/axonframework/commandhandling/gateway/DefaultReactiveCommandGateway.java", "diffHunk": "@@ -0,0 +1,201 @@\n+/*\n+ * Copyright (c) 2010-2020. Axon Framework\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.axonframework.commandhandling.gateway;\n+\n+import org.axonframework.commandhandling.CommandBus;\n+import org.axonframework.commandhandling.CommandCallback;\n+import org.axonframework.commandhandling.CommandMessage;\n+import org.axonframework.commandhandling.GenericCommandMessage;\n+import org.axonframework.common.AxonConfigurationException;\n+import org.axonframework.common.Registration;\n+import org.axonframework.messaging.ReactiveMessageDispatchInterceptor;\n+import reactor.core.publisher.Mono;\n+\n+import java.util.List;\n+import java.util.concurrent.CopyOnWriteArrayList;\n+\n+import static java.util.Arrays.asList;\n+import static org.axonframework.common.BuilderUtils.assertNonNull;\n+\n+/**\n+ * Default implementation of the {@link ReactiveCommandGateway}.\n+ *\n+ * @author Milan Savic\n+ * @since 4.4\n+ */\n+public class DefaultReactiveCommandGateway implements ReactiveCommandGateway {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "458600ec7c51f894a998d38906b60087fe1ccc7a"}, "originalPosition": 40}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzY4NzI4OQ==", "bodyText": "That's also something that's worth mentioning in the class level Javadoc", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r413687289", "createdAt": "2020-04-23T10:07:59Z", "author": {"login": "abuijze"}, "path": "messaging/src/main/java/org/axonframework/commandhandling/gateway/DefaultReactiveCommandGateway.java", "diffHunk": "@@ -0,0 +1,201 @@\n+/*\n+ * Copyright (c) 2010-2020. Axon Framework\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.axonframework.commandhandling.gateway;\n+\n+import org.axonframework.commandhandling.CommandBus;\n+import org.axonframework.commandhandling.CommandCallback;\n+import org.axonframework.commandhandling.CommandMessage;\n+import org.axonframework.commandhandling.GenericCommandMessage;\n+import org.axonframework.common.AxonConfigurationException;\n+import org.axonframework.common.Registration;\n+import org.axonframework.messaging.ReactiveMessageDispatchInterceptor;\n+import reactor.core.publisher.Mono;\n+\n+import java.util.List;\n+import java.util.concurrent.CopyOnWriteArrayList;\n+\n+import static java.util.Arrays.asList;\n+import static org.axonframework.common.BuilderUtils.assertNonNull;\n+\n+/**\n+ * Default implementation of the {@link ReactiveCommandGateway}.\n+ *\n+ * @author Milan Savic\n+ * @since 4.4\n+ */\n+public class DefaultReactiveCommandGateway implements ReactiveCommandGateway {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzY4NzAyOA=="}, "originalCommit": {"oid": "458600ec7c51f894a998d38906b60087fe1ccc7a"}, "originalPosition": 40}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU3MTE3Mzg5OnYy", "diffSide": "RIGHT", "path": "messaging/src/main/java/org/axonframework/commandhandling/gateway/ReactiveCommandGateway.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yM1QxMDoxMTo1NVrOGKhoLQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yM1QxMDoxMTo1NVrOGKhoLQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzY4OTkwMQ==", "bodyText": "Please also have it implement MessageDispatchInterceptorSupport. Preferably, I'd like the Reactive implementations to show more compatibility by extending the MessageDispatchInterceptorSupport. The reactive impl could do an instanceof check to see if implementations are already reactive. If not, it could wrap them with a reactive wrapper implementation.", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r413689901", "createdAt": "2020-04-23T10:11:55Z", "author": {"login": "abuijze"}, "path": "messaging/src/main/java/org/axonframework/commandhandling/gateway/ReactiveCommandGateway.java", "diffHunk": "@@ -0,0 +1,67 @@\n+/*\n+ * Copyright (c) 2010-2020. Axon Framework\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.axonframework.commandhandling.gateway;\n+\n+import org.axonframework.commandhandling.CommandBus;\n+import org.axonframework.commandhandling.CommandMessage;\n+import org.axonframework.messaging.Message;\n+import org.axonframework.messaging.MetaData;\n+import org.axonframework.messaging.ReactiveMessageDispatchInterceptorSupport;\n+import org.reactivestreams.Publisher;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Mono;\n+\n+import java.util.function.Function;\n+\n+/**\n+ * Variation of {@link CommandGateway}. Provides support for reactive return type such as {@link Mono} from Project\n+ * Reactor.\n+ *\n+ * @author Milan Savic\n+ * @since 4.4\n+ */\n+public interface ReactiveCommandGateway extends ReactiveMessageDispatchInterceptorSupport<CommandMessage<?>> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "458600ec7c51f894a998d38906b60087fe1ccc7a"}, "originalPosition": 37}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU3MTE4MDA3OnYy", "diffSide": "RIGHT", "path": "messaging/src/main/java/org/axonframework/messaging/ReactiveMessageDispatchInterceptor.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yM1QxMDoxMzoyN1rOGKhsIw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yM1QxMDoxMzoyN1rOGKhsIw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzY5MDkxNQ==", "bodyText": "Why does it need to be a Supplier of a Function, and not just the Function itself?", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r413690915", "createdAt": "2020-04-23T10:13:27Z", "author": {"login": "abuijze"}, "path": "messaging/src/main/java/org/axonframework/messaging/ReactiveMessageDispatchInterceptor.java", "diffHunk": "@@ -0,0 +1,45 @@\n+/*\n+ * Copyright (c) 2010-2020. Axon Framework\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.axonframework.messaging;\n+\n+import reactor.core.publisher.Mono;\n+\n+import java.util.function.Function;\n+import java.util.function.Supplier;\n+\n+/**\n+ * Interceptor that allows messages to be intercepted and modified before they are dispatched. Implementations are\n+ * required to provide a function that modifies a {@link Mono} of a message and returns a modified/new {@code Mono} to\n+ * be passed down the interceptor chain or to be dispatched. This way we provide a reactive approach to intercepting messages.\n+ *\n+ * @param <T> the message type this interceptor can process\n+ * @author Milan Savic\n+ * @since 4.4\n+ */\n+@FunctionalInterface\n+public interface ReactiveMessageDispatchInterceptor<T extends Message<?>> extends Supplier<Function<Mono<T>, Mono<T>>> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "458600ec7c51f894a998d38906b60087fe1ccc7a"}, "originalPosition": 34}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgyMjUyNzY1OnYy", "diffSide": "RIGHT", "path": "axon-server-connector/src/main/java/org/axonframework/axonserver/connector/query/subscription/GrpcBackedQueryUpdateMessage.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xMFQwNzo1MjoxMFrOGvthVw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xMFQwNzo1MjoxMFrOGvthVw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjY4MjA3MQ==", "bodyText": "Nit: details sounds a little vague here if you ask me.\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    Supplier<Object> details = serializedPayload == null\n          \n          \n            \n                    Supplier<Object> exceptionDetails = serializedPayload == null", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r452682071", "createdAt": "2020-07-10T07:52:10Z", "author": {"login": "smcvb"}, "path": "axon-server-connector/src/main/java/org/axonframework/axonserver/connector/query/subscription/GrpcBackedQueryUpdateMessage.java", "diffHunk": "@@ -49,18 +53,27 @@\n      *                    given {@code queryUpdate}\n      */\n     public GrpcBackedQueryUpdateMessage(QueryUpdate queryUpdate, Serializer serializer) {\n-        this(\n-                queryUpdate,\n-                new LazyDeserializingObject<>(new GrpcSerializedObject(queryUpdate.getPayload()), serializer),\n-                new GrpcMetaData(queryUpdate.getMetaDataMap(), serializer)\n-        );\n+        this.queryUpdate = queryUpdate;\n+        this.serializedPayload = queryUpdate.hasPayload()\n+                ? new LazyDeserializingObject<>(new GrpcSerializedObject(queryUpdate.getPayload()), serializer)\n+                : null;\n+        Supplier<Object> details = serializedPayload == null", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "98865ab1427e4d879301c1bf542842eccc8aa3c3"}, "originalPosition": 40}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgyMjUzNDk2OnYy", "diffSide": "RIGHT", "path": "axon-server-connector/src/main/java/org/axonframework/axonserver/connector/query/subscription/SubscriptionMessageSerializer.java", "isResolved": true, "comments": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xMFQwNzo1NDozM1rOGvtl9A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yN1QxMDowNDozMVrOG3b_bg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjY4MzI1Mg==", "bodyText": "Super nit: indenting looks a little awful here if you ask me.", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r452683252", "createdAt": "2020-07-10T07:54:33Z", "author": {"login": "smcvb"}, "path": "axon-server-connector/src/main/java/org/axonframework/axonserver/connector/query/subscription/SubscriptionMessageSerializer.java", "diffHunk": "@@ -116,19 +118,28 @@ public SubscriptionQuery serialize(SubscriptionQueryMessage subscriptionQueryMes\n         return new GrpcBackedSubscriptionQueryMessage<>(subscriptionQuery, messageSerializer, serializer);\n     }\n \n-    QueryProviderOutbound serialize(QueryResponseMessage initialResult, String subscriptionId) {\n-        QueryResponse queryResponse =\n+    QueryProviderOutbound serialize(QueryResponseMessage<?> initialResult, String subscriptionId) {\n+        QueryResponse.Builder responseBuilder =\n                 QueryResponse.newBuilder()\n-                             .setPayload(payloadSerializer.apply(initialResult))\n                              .putAllMetaData(metadataSerializer.apply(initialResult.getMetaData()))\n                              .setMessageIdentifier(initialResult.getIdentifier())\n-                             .setRequestIdentifier(subscriptionId)\n-                             .build();\n+                             .setRequestIdentifier(subscriptionId);\n+        if (initialResult.isExceptional()) {\n+            Throwable exceptionResult = initialResult.exceptionResult();\n+            responseBuilder.setErrorCode(ErrorCode.QUERY_EXECUTION_ERROR.errorCode());\n+            responseBuilder.setErrorMessage(ExceptionSerializer", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "98865ab1427e4d879301c1bf542842eccc8aa3c3"}, "originalPosition": 34}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzI2MjA5OQ==", "bodyText": "Not sure what you mean by it :)", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r457262099", "createdAt": "2020-07-20T10:31:00Z", "author": {"login": "m1l4n54v1c"}, "path": "axon-server-connector/src/main/java/org/axonframework/axonserver/connector/query/subscription/SubscriptionMessageSerializer.java", "diffHunk": "@@ -116,19 +118,28 @@ public SubscriptionQuery serialize(SubscriptionQueryMessage subscriptionQueryMes\n         return new GrpcBackedSubscriptionQueryMessage<>(subscriptionQuery, messageSerializer, serializer);\n     }\n \n-    QueryProviderOutbound serialize(QueryResponseMessage initialResult, String subscriptionId) {\n-        QueryResponse queryResponse =\n+    QueryProviderOutbound serialize(QueryResponseMessage<?> initialResult, String subscriptionId) {\n+        QueryResponse.Builder responseBuilder =\n                 QueryResponse.newBuilder()\n-                             .setPayload(payloadSerializer.apply(initialResult))\n                              .putAllMetaData(metadataSerializer.apply(initialResult.getMetaData()))\n                              .setMessageIdentifier(initialResult.getIdentifier())\n-                             .setRequestIdentifier(subscriptionId)\n-                             .build();\n+                             .setRequestIdentifier(subscriptionId);\n+        if (initialResult.isExceptional()) {\n+            Throwable exceptionResult = initialResult.exceptionResult();\n+            responseBuilder.setErrorCode(ErrorCode.QUERY_EXECUTION_ERROR.errorCode());\n+            responseBuilder.setErrorMessage(ExceptionSerializer", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjY4MzI1Mg=="}, "originalCommit": {"oid": "98865ab1427e4d879301c1bf542842eccc8aa3c3"}, "originalPosition": 34}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzI2MjMwMQ==", "bodyText": "IntelliJ does not complain...", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r457262301", "createdAt": "2020-07-20T10:31:18Z", "author": {"login": "m1l4n54v1c"}, "path": "axon-server-connector/src/main/java/org/axonframework/axonserver/connector/query/subscription/SubscriptionMessageSerializer.java", "diffHunk": "@@ -116,19 +118,28 @@ public SubscriptionQuery serialize(SubscriptionQueryMessage subscriptionQueryMes\n         return new GrpcBackedSubscriptionQueryMessage<>(subscriptionQuery, messageSerializer, serializer);\n     }\n \n-    QueryProviderOutbound serialize(QueryResponseMessage initialResult, String subscriptionId) {\n-        QueryResponse queryResponse =\n+    QueryProviderOutbound serialize(QueryResponseMessage<?> initialResult, String subscriptionId) {\n+        QueryResponse.Builder responseBuilder =\n                 QueryResponse.newBuilder()\n-                             .setPayload(payloadSerializer.apply(initialResult))\n                              .putAllMetaData(metadataSerializer.apply(initialResult.getMetaData()))\n                              .setMessageIdentifier(initialResult.getIdentifier())\n-                             .setRequestIdentifier(subscriptionId)\n-                             .build();\n+                             .setRequestIdentifier(subscriptionId);\n+        if (initialResult.isExceptional()) {\n+            Throwable exceptionResult = initialResult.exceptionResult();\n+            responseBuilder.setErrorCode(ErrorCode.QUERY_EXECUTION_ERROR.errorCode());\n+            responseBuilder.setErrorMessage(ExceptionSerializer", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjY4MzI1Mg=="}, "originalCommit": {"oid": "98865ab1427e4d879301c1bf542842eccc8aa3c3"}, "originalPosition": 34}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODA1Nzk5MQ==", "bodyText": "Intellij might not, but my eyes do when I see this:\nresponseBuilder.setErrorMessage(ExceptionSerializer\n                                        .serialize(configuration.getClientId(), exceptionResult));\nwhich I would rewrite to\nresponseBuilder.setErrorMessage(\n    ExceptionSerializer.serialize(configuration.getClientId(), exceptionResult)\n);\nHence why it is a super nit.", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r458057991", "createdAt": "2020-07-21T12:29:38Z", "author": {"login": "smcvb"}, "path": "axon-server-connector/src/main/java/org/axonframework/axonserver/connector/query/subscription/SubscriptionMessageSerializer.java", "diffHunk": "@@ -116,19 +118,28 @@ public SubscriptionQuery serialize(SubscriptionQueryMessage subscriptionQueryMes\n         return new GrpcBackedSubscriptionQueryMessage<>(subscriptionQuery, messageSerializer, serializer);\n     }\n \n-    QueryProviderOutbound serialize(QueryResponseMessage initialResult, String subscriptionId) {\n-        QueryResponse queryResponse =\n+    QueryProviderOutbound serialize(QueryResponseMessage<?> initialResult, String subscriptionId) {\n+        QueryResponse.Builder responseBuilder =\n                 QueryResponse.newBuilder()\n-                             .setPayload(payloadSerializer.apply(initialResult))\n                              .putAllMetaData(metadataSerializer.apply(initialResult.getMetaData()))\n                              .setMessageIdentifier(initialResult.getIdentifier())\n-                             .setRequestIdentifier(subscriptionId)\n-                             .build();\n+                             .setRequestIdentifier(subscriptionId);\n+        if (initialResult.isExceptional()) {\n+            Throwable exceptionResult = initialResult.exceptionResult();\n+            responseBuilder.setErrorCode(ErrorCode.QUERY_EXECUTION_ERROR.errorCode());\n+            responseBuilder.setErrorMessage(ExceptionSerializer", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjY4MzI1Mg=="}, "originalCommit": {"oid": "98865ab1427e4d879301c1bf542842eccc8aa3c3"}, "originalPosition": 34}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODA1OTg2NA==", "bodyText": "Let me just provide a suggestion instead of a comment.", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r458059864", "createdAt": "2020-07-21T12:32:52Z", "author": {"login": "smcvb"}, "path": "axon-server-connector/src/main/java/org/axonframework/axonserver/connector/query/subscription/SubscriptionMessageSerializer.java", "diffHunk": "@@ -116,19 +118,28 @@ public SubscriptionQuery serialize(SubscriptionQueryMessage subscriptionQueryMes\n         return new GrpcBackedSubscriptionQueryMessage<>(subscriptionQuery, messageSerializer, serializer);\n     }\n \n-    QueryProviderOutbound serialize(QueryResponseMessage initialResult, String subscriptionId) {\n-        QueryResponse queryResponse =\n+    QueryProviderOutbound serialize(QueryResponseMessage<?> initialResult, String subscriptionId) {\n+        QueryResponse.Builder responseBuilder =\n                 QueryResponse.newBuilder()\n-                             .setPayload(payloadSerializer.apply(initialResult))\n                              .putAllMetaData(metadataSerializer.apply(initialResult.getMetaData()))\n                              .setMessageIdentifier(initialResult.getIdentifier())\n-                             .setRequestIdentifier(subscriptionId)\n-                             .build();\n+                             .setRequestIdentifier(subscriptionId);\n+        if (initialResult.isExceptional()) {\n+            Throwable exceptionResult = initialResult.exceptionResult();\n+            responseBuilder.setErrorCode(ErrorCode.QUERY_EXECUTION_ERROR.errorCode());\n+            responseBuilder.setErrorMessage(ExceptionSerializer", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjY4MzI1Mg=="}, "originalCommit": {"oid": "98865ab1427e4d879301c1bf542842eccc8aa3c3"}, "originalPosition": 34}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODA2NTU1OA==", "bodyText": "responseBuilder.setErrorMessage(\n                ExceptionSerializer.serialize(configuration.getClientId(), exceptionResult)\n            );\n            initialResult.exceptionDetails()\n                         .ifPresent(details -> responseBuilder.setPayload(exceptionDetailsSerializer.apply(details)));", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r458065558", "createdAt": "2020-07-21T12:42:47Z", "author": {"login": "smcvb"}, "path": "axon-server-connector/src/main/java/org/axonframework/axonserver/connector/query/subscription/SubscriptionMessageSerializer.java", "diffHunk": "@@ -116,19 +118,28 @@ public SubscriptionQuery serialize(SubscriptionQueryMessage subscriptionQueryMes\n         return new GrpcBackedSubscriptionQueryMessage<>(subscriptionQuery, messageSerializer, serializer);\n     }\n \n-    QueryProviderOutbound serialize(QueryResponseMessage initialResult, String subscriptionId) {\n-        QueryResponse queryResponse =\n+    QueryProviderOutbound serialize(QueryResponseMessage<?> initialResult, String subscriptionId) {\n+        QueryResponse.Builder responseBuilder =\n                 QueryResponse.newBuilder()\n-                             .setPayload(payloadSerializer.apply(initialResult))\n                              .putAllMetaData(metadataSerializer.apply(initialResult.getMetaData()))\n                              .setMessageIdentifier(initialResult.getIdentifier())\n-                             .setRequestIdentifier(subscriptionId)\n-                             .build();\n+                             .setRequestIdentifier(subscriptionId);\n+        if (initialResult.isExceptional()) {\n+            Throwable exceptionResult = initialResult.exceptionResult();\n+            responseBuilder.setErrorCode(ErrorCode.QUERY_EXECUTION_ERROR.errorCode());\n+            responseBuilder.setErrorMessage(ExceptionSerializer", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjY4MzI1Mg=="}, "originalCommit": {"oid": "98865ab1427e4d879301c1bf542842eccc8aa3c3"}, "originalPosition": 34}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDc4MzQ3MA==", "bodyText": "I'm gonna do it this way!", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r460783470", "createdAt": "2020-07-27T10:04:31Z", "author": {"login": "m1l4n54v1c"}, "path": "axon-server-connector/src/main/java/org/axonframework/axonserver/connector/query/subscription/SubscriptionMessageSerializer.java", "diffHunk": "@@ -116,19 +118,28 @@ public SubscriptionQuery serialize(SubscriptionQueryMessage subscriptionQueryMes\n         return new GrpcBackedSubscriptionQueryMessage<>(subscriptionQuery, messageSerializer, serializer);\n     }\n \n-    QueryProviderOutbound serialize(QueryResponseMessage initialResult, String subscriptionId) {\n-        QueryResponse queryResponse =\n+    QueryProviderOutbound serialize(QueryResponseMessage<?> initialResult, String subscriptionId) {\n+        QueryResponse.Builder responseBuilder =\n                 QueryResponse.newBuilder()\n-                             .setPayload(payloadSerializer.apply(initialResult))\n                              .putAllMetaData(metadataSerializer.apply(initialResult.getMetaData()))\n                              .setMessageIdentifier(initialResult.getIdentifier())\n-                             .setRequestIdentifier(subscriptionId)\n-                             .build();\n+                             .setRequestIdentifier(subscriptionId);\n+        if (initialResult.isExceptional()) {\n+            Throwable exceptionResult = initialResult.exceptionResult();\n+            responseBuilder.setErrorCode(ErrorCode.QUERY_EXECUTION_ERROR.errorCode());\n+            responseBuilder.setErrorMessage(ExceptionSerializer", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjY4MzI1Mg=="}, "originalCommit": {"oid": "98865ab1427e4d879301c1bf542842eccc8aa3c3"}, "originalPosition": 34}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgyMjU0OTk1OnYy", "diffSide": "RIGHT", "path": "axon-server-connector/src/test/java/org/axonframework/axonserver/connector/query/subscription/SubscriptionMessageSerializerTest.java", "isResolved": true, "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xMFQwNzo1ODo0NFrOGvtu9Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yN1QxMzoxNjowNVrOG3h9lg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjY4NTU1Nw==", "bodyText": "Nit: might be worth validating there is a null payload? If that's what we're going to tell our users, than making sure it is so sounds reasonable to me.", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r452685557", "createdAt": "2020-07-10T07:58:44Z", "author": {"login": "smcvb"}, "path": "axon-server-connector/src/test/java/org/axonframework/axonserver/connector/query/subscription/SubscriptionMessageSerializerTest.java", "diffHunk": "@@ -76,12 +77,29 @@ void testInitialResponse() {\n         assertEquals(message.getMetaData(), deserialized.getMetaData());\n     }\n \n+    @Test\n+    void testExceptionalInitialResponse() {\n+        MetaData metadata = MetaData.with(\"firstKey\", \"firstValue\")\n+                                    .mergedWith(MetaData.with(\"secondKey\", \"secondValue\"));\n+        QueryResponseMessage<String> message = new GenericQueryResponseMessage<>(String.class,\n+                                                                                 new RuntimeException(\"oops\"),\n+                                                                                 metadata);\n+        QueryProviderOutbound grpcMessage = testSubject.serialize(message, \"subscriptionId\");\n+        assertEquals(\"subscriptionId\", grpcMessage.getSubscriptionQueryResponse().getSubscriptionIdentifier());\n+        QueryResponse initialResponse = grpcMessage.getSubscriptionQueryResponse().getInitialResult();\n+        QueryResponseMessage<Object> deserialized = testSubject.deserialize(initialResponse);\n+        assertEquals(message.getIdentifier(), deserialized.getIdentifier());\n+        assertEquals(message.getMetaData(), deserialized.getMetaData());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "98865ab1427e4d879301c1bf542842eccc8aa3c3"}, "originalPosition": 48}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjY4NjU3MQ==", "bodyText": "You could similarly argue that validating the following for successful calls makes sense: assertFalse(message.isExceptional())", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r452686571", "createdAt": "2020-07-10T08:00:44Z", "author": {"login": "smcvb"}, "path": "axon-server-connector/src/test/java/org/axonframework/axonserver/connector/query/subscription/SubscriptionMessageSerializerTest.java", "diffHunk": "@@ -76,12 +77,29 @@ void testInitialResponse() {\n         assertEquals(message.getMetaData(), deserialized.getMetaData());\n     }\n \n+    @Test\n+    void testExceptionalInitialResponse() {\n+        MetaData metadata = MetaData.with(\"firstKey\", \"firstValue\")\n+                                    .mergedWith(MetaData.with(\"secondKey\", \"secondValue\"));\n+        QueryResponseMessage<String> message = new GenericQueryResponseMessage<>(String.class,\n+                                                                                 new RuntimeException(\"oops\"),\n+                                                                                 metadata);\n+        QueryProviderOutbound grpcMessage = testSubject.serialize(message, \"subscriptionId\");\n+        assertEquals(\"subscriptionId\", grpcMessage.getSubscriptionQueryResponse().getSubscriptionIdentifier());\n+        QueryResponse initialResponse = grpcMessage.getSubscriptionQueryResponse().getInitialResult();\n+        QueryResponseMessage<Object> deserialized = testSubject.deserialize(initialResponse);\n+        assertEquals(message.getIdentifier(), deserialized.getIdentifier());\n+        assertEquals(message.getMetaData(), deserialized.getMetaData());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjY4NTU1Nw=="}, "originalCommit": {"oid": "98865ab1427e4d879301c1bf542842eccc8aa3c3"}, "originalPosition": 48}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzI2NTQzOA==", "bodyText": "Actually, .getPayload should throw an IllegalPayloadException in this case :) I'll validate that.", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r457265438", "createdAt": "2020-07-20T10:36:07Z", "author": {"login": "m1l4n54v1c"}, "path": "axon-server-connector/src/test/java/org/axonframework/axonserver/connector/query/subscription/SubscriptionMessageSerializerTest.java", "diffHunk": "@@ -76,12 +77,29 @@ void testInitialResponse() {\n         assertEquals(message.getMetaData(), deserialized.getMetaData());\n     }\n \n+    @Test\n+    void testExceptionalInitialResponse() {\n+        MetaData metadata = MetaData.with(\"firstKey\", \"firstValue\")\n+                                    .mergedWith(MetaData.with(\"secondKey\", \"secondValue\"));\n+        QueryResponseMessage<String> message = new GenericQueryResponseMessage<>(String.class,\n+                                                                                 new RuntimeException(\"oops\"),\n+                                                                                 metadata);\n+        QueryProviderOutbound grpcMessage = testSubject.serialize(message, \"subscriptionId\");\n+        assertEquals(\"subscriptionId\", grpcMessage.getSubscriptionQueryResponse().getSubscriptionIdentifier());\n+        QueryResponse initialResponse = grpcMessage.getSubscriptionQueryResponse().getInitialResult();\n+        QueryResponseMessage<Object> deserialized = testSubject.deserialize(initialResponse);\n+        assertEquals(message.getIdentifier(), deserialized.getIdentifier());\n+        assertEquals(message.getMetaData(), deserialized.getMetaData());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjY4NTU1Nw=="}, "originalCommit": {"oid": "98865ab1427e4d879301c1bf542842eccc8aa3c3"}, "originalPosition": 48}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzM5NDQ1OQ==", "bodyText": "Hmmmm, you're actually right! But I'm not sure now whether we should throw an exception here or return null in an exceptional case. What's your take on it?", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r457394459", "createdAt": "2020-07-20T13:41:17Z", "author": {"login": "m1l4n54v1c"}, "path": "axon-server-connector/src/test/java/org/axonframework/axonserver/connector/query/subscription/SubscriptionMessageSerializerTest.java", "diffHunk": "@@ -76,12 +77,29 @@ void testInitialResponse() {\n         assertEquals(message.getMetaData(), deserialized.getMetaData());\n     }\n \n+    @Test\n+    void testExceptionalInitialResponse() {\n+        MetaData metadata = MetaData.with(\"firstKey\", \"firstValue\")\n+                                    .mergedWith(MetaData.with(\"secondKey\", \"secondValue\"));\n+        QueryResponseMessage<String> message = new GenericQueryResponseMessage<>(String.class,\n+                                                                                 new RuntimeException(\"oops\"),\n+                                                                                 metadata);\n+        QueryProviderOutbound grpcMessage = testSubject.serialize(message, \"subscriptionId\");\n+        assertEquals(\"subscriptionId\", grpcMessage.getSubscriptionQueryResponse().getSubscriptionIdentifier());\n+        QueryResponse initialResponse = grpcMessage.getSubscriptionQueryResponse().getInitialResult();\n+        QueryResponseMessage<Object> deserialized = testSubject.deserialize(initialResponse);\n+        assertEquals(message.getIdentifier(), deserialized.getIdentifier());\n+        assertEquals(message.getMetaData(), deserialized.getMetaData());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjY4NTU1Nw=="}, "originalCommit": {"oid": "98865ab1427e4d879301c1bf542842eccc8aa3c3"}, "originalPosition": 48}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODA3NTAyNA==", "bodyText": "To be a 100% honest with you, I am uncertain why I suggested this \ud83e\udd14\nMight be worth to have a short call about this when time allows it.", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r458075024", "createdAt": "2020-07-21T12:58:21Z", "author": {"login": "smcvb"}, "path": "axon-server-connector/src/test/java/org/axonframework/axonserver/connector/query/subscription/SubscriptionMessageSerializerTest.java", "diffHunk": "@@ -76,12 +77,29 @@ void testInitialResponse() {\n         assertEquals(message.getMetaData(), deserialized.getMetaData());\n     }\n \n+    @Test\n+    void testExceptionalInitialResponse() {\n+        MetaData metadata = MetaData.with(\"firstKey\", \"firstValue\")\n+                                    .mergedWith(MetaData.with(\"secondKey\", \"secondValue\"));\n+        QueryResponseMessage<String> message = new GenericQueryResponseMessage<>(String.class,\n+                                                                                 new RuntimeException(\"oops\"),\n+                                                                                 metadata);\n+        QueryProviderOutbound grpcMessage = testSubject.serialize(message, \"subscriptionId\");\n+        assertEquals(\"subscriptionId\", grpcMessage.getSubscriptionQueryResponse().getSubscriptionIdentifier());\n+        QueryResponse initialResponse = grpcMessage.getSubscriptionQueryResponse().getInitialResult();\n+        QueryResponseMessage<Object> deserialized = testSubject.deserialize(initialResponse);\n+        assertEquals(message.getIdentifier(), deserialized.getIdentifier());\n+        assertEquals(message.getMetaData(), deserialized.getMetaData());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjY4NTU1Nw=="}, "originalCommit": {"oid": "98865ab1427e4d879301c1bf542842eccc8aa3c3"}, "originalPosition": 48}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDg4MTMwMg==", "bodyText": "After a discussion, we decided to address this concern in a separate issue: #1477", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r460881302", "createdAt": "2020-07-27T13:16:05Z", "author": {"login": "m1l4n54v1c"}, "path": "axon-server-connector/src/test/java/org/axonframework/axonserver/connector/query/subscription/SubscriptionMessageSerializerTest.java", "diffHunk": "@@ -76,12 +77,29 @@ void testInitialResponse() {\n         assertEquals(message.getMetaData(), deserialized.getMetaData());\n     }\n \n+    @Test\n+    void testExceptionalInitialResponse() {\n+        MetaData metadata = MetaData.with(\"firstKey\", \"firstValue\")\n+                                    .mergedWith(MetaData.with(\"secondKey\", \"secondValue\"));\n+        QueryResponseMessage<String> message = new GenericQueryResponseMessage<>(String.class,\n+                                                                                 new RuntimeException(\"oops\"),\n+                                                                                 metadata);\n+        QueryProviderOutbound grpcMessage = testSubject.serialize(message, \"subscriptionId\");\n+        assertEquals(\"subscriptionId\", grpcMessage.getSubscriptionQueryResponse().getSubscriptionIdentifier());\n+        QueryResponse initialResponse = grpcMessage.getSubscriptionQueryResponse().getInitialResult();\n+        QueryResponseMessage<Object> deserialized = testSubject.deserialize(initialResponse);\n+        assertEquals(message.getIdentifier(), deserialized.getIdentifier());\n+        assertEquals(message.getMetaData(), deserialized.getMetaData());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjY4NTU1Nw=="}, "originalCommit": {"oid": "98865ab1427e4d879301c1bf542842eccc8aa3c3"}, "originalPosition": 48}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgyMjU1Mjg2OnYy", "diffSide": "RIGHT", "path": "axon-server-connector/src/test/java/org/axonframework/axonserver/connector/query/subscription/SubscriptionMessageSerializerTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xMFQwNzo1OTozOFrOGvtwtw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOFQwNzozNDoyMlrOG4AQSA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjY4NjAwNw==", "bodyText": "Same asserrtNull(message.getPayload()) suggestions as for the testExceptionalInitialResponse().", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r452686007", "createdAt": "2020-07-10T07:59:38Z", "author": {"login": "smcvb"}, "path": "axon-server-connector/src/test/java/org/axonframework/axonserver/connector/query/subscription/SubscriptionMessageSerializerTest.java", "diffHunk": "@@ -92,6 +110,21 @@ void testUpdate() {\n         assertEquals(message.getMetaData(), deserialized.getMetaData());\n     }\n \n+    @Test\n+    void testExceptionalUpdate() {\n+        MetaData metaData = MetaData.with(\"k1\", \"v1\");\n+        SubscriptionQueryUpdateMessage<String> message =\n+                new GenericSubscriptionQueryUpdateMessage<>(String.class, new RuntimeException(\"oops\"), metaData);\n+        QueryProviderOutbound grpcMessage = testSubject.serialize(message, \"subscriptionId\");\n+        assertEquals(\"subscriptionId\", grpcMessage.getSubscriptionQueryResponse().getSubscriptionIdentifier());\n+        QueryUpdate update = grpcMessage.getSubscriptionQueryResponse().getUpdate();\n+        SubscriptionQueryUpdateMessage<Object> deserialized = testSubject.deserialize(update);\n+        assertEquals(message.getIdentifier(), deserialized.getIdentifier());\n+        assertEquals(message.getMetaData(), deserialized.getMetaData());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "98865ab1427e4d879301c1bf542842eccc8aa3c3"}, "originalPosition": 77}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTM3NzYwOA==", "bodyText": "Resolved verbally; this will be tackled in a different issue.", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r461377608", "createdAt": "2020-07-28T07:34:22Z", "author": {"login": "smcvb"}, "path": "axon-server-connector/src/test/java/org/axonframework/axonserver/connector/query/subscription/SubscriptionMessageSerializerTest.java", "diffHunk": "@@ -92,6 +110,21 @@ void testUpdate() {\n         assertEquals(message.getMetaData(), deserialized.getMetaData());\n     }\n \n+    @Test\n+    void testExceptionalUpdate() {\n+        MetaData metaData = MetaData.with(\"k1\", \"v1\");\n+        SubscriptionQueryUpdateMessage<String> message =\n+                new GenericSubscriptionQueryUpdateMessage<>(String.class, new RuntimeException(\"oops\"), metaData);\n+        QueryProviderOutbound grpcMessage = testSubject.serialize(message, \"subscriptionId\");\n+        assertEquals(\"subscriptionId\", grpcMessage.getSubscriptionQueryResponse().getSubscriptionIdentifier());\n+        QueryUpdate update = grpcMessage.getSubscriptionQueryResponse().getUpdate();\n+        SubscriptionQueryUpdateMessage<Object> deserialized = testSubject.deserialize(update);\n+        assertEquals(message.getIdentifier(), deserialized.getIdentifier());\n+        assertEquals(message.getMetaData(), deserialized.getMetaData());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjY4NjAwNw=="}, "originalCommit": {"oid": "98865ab1427e4d879301c1bf542842eccc8aa3c3"}, "originalPosition": 77}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgyMjU1OTcwOnYy", "diffSide": "RIGHT", "path": "messaging/src/main/java/org/axonframework/commandhandling/callbacks/ReactiveCallback.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xMFQwODowMTo0NVrOGvt04g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yN1QxMDoyMDo0M1rOG3cgXQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjY4NzA3NA==", "bodyText": "Nits: I'd {@link ...} to CommandCallback and CommandBus here. Definitely no blocker though.", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r452687074", "createdAt": "2020-07-10T08:01:45Z", "author": {"login": "smcvb"}, "path": "messaging/src/main/java/org/axonframework/commandhandling/callbacks/ReactiveCallback.java", "diffHunk": "@@ -0,0 +1,57 @@\n+/*\n+ * Copyright (c) 2010-2018. Axon Framework\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.axonframework.commandhandling.callbacks;\n+\n+import org.axonframework.commandhandling.CommandCallback;\n+import org.axonframework.commandhandling.CommandMessage;\n+import org.axonframework.commandhandling.CommandResultMessage;\n+import org.reactivestreams.Publisher;\n+import org.reactivestreams.Subscriber;\n+import reactor.core.publisher.EmitterProcessor;\n+import reactor.core.publisher.FluxSink;\n+\n+/**\n+ * Command Handler Callback that allows the dispatching thread to wait for the result of the callback, using the", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "98865ab1427e4d879301c1bf542842eccc8aa3c3"}, "originalPosition": 28}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDc5MTkwMQ==", "bodyText": "Done!", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r460791901", "createdAt": "2020-07-27T10:20:43Z", "author": {"login": "m1l4n54v1c"}, "path": "messaging/src/main/java/org/axonframework/commandhandling/callbacks/ReactiveCallback.java", "diffHunk": "@@ -0,0 +1,57 @@\n+/*\n+ * Copyright (c) 2010-2018. Axon Framework\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.axonframework.commandhandling.callbacks;\n+\n+import org.axonframework.commandhandling.CommandCallback;\n+import org.axonframework.commandhandling.CommandMessage;\n+import org.axonframework.commandhandling.CommandResultMessage;\n+import org.reactivestreams.Publisher;\n+import org.reactivestreams.Subscriber;\n+import reactor.core.publisher.EmitterProcessor;\n+import reactor.core.publisher.FluxSink;\n+\n+/**\n+ * Command Handler Callback that allows the dispatching thread to wait for the result of the callback, using the", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjY4NzA3NA=="}, "originalCommit": {"oid": "98865ab1427e4d879301c1bf542842eccc8aa3c3"}, "originalPosition": 28}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgyMjU2MTQ5OnYy", "diffSide": "RIGHT", "path": "messaging/src/main/java/org/axonframework/commandhandling/callbacks/ReactiveCallback.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xMFQwODowMjoxMlrOGvt14g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xM1QxNDozNTozMlrOGwrY5w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjY4NzMzMA==", "bodyText": "What's this suppression for? Worth adding a short comment on in the code why this is suppressed?", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r452687330", "createdAt": "2020-07-10T08:02:12Z", "author": {"login": "smcvb"}, "path": "messaging/src/main/java/org/axonframework/commandhandling/callbacks/ReactiveCallback.java", "diffHunk": "@@ -0,0 +1,57 @@\n+/*\n+ * Copyright (c) 2010-2018. Axon Framework\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.axonframework.commandhandling.callbacks;\n+\n+import org.axonframework.commandhandling.CommandCallback;\n+import org.axonframework.commandhandling.CommandMessage;\n+import org.axonframework.commandhandling.CommandResultMessage;\n+import org.reactivestreams.Publisher;\n+import org.reactivestreams.Subscriber;\n+import reactor.core.publisher.EmitterProcessor;\n+import reactor.core.publisher.FluxSink;\n+\n+/**\n+ * Command Handler Callback that allows the dispatching thread to wait for the result of the callback, using the\n+ * Project Reactor mechanisms. This callback allows the caller to synchronize calls when an asynchronous command bus is\n+ * being used.\n+ *\n+ * @author Stefan Dragisic\n+ * @since 4.4\n+ */\n+@SuppressWarnings(\"ReactiveStreamsPublisherImplementation\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "98865ab1427e4d879301c1bf542842eccc8aa3c3"}, "originalPosition": 35}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzY5NTcxOQ==", "bodyText": "The warning is due to recommendation not to extend the Publisher class. Extending Mono instead to remove warning and ease the use of API", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r453695719", "createdAt": "2020-07-13T14:35:32Z", "author": {"login": "schananas"}, "path": "messaging/src/main/java/org/axonframework/commandhandling/callbacks/ReactiveCallback.java", "diffHunk": "@@ -0,0 +1,57 @@\n+/*\n+ * Copyright (c) 2010-2018. Axon Framework\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.axonframework.commandhandling.callbacks;\n+\n+import org.axonframework.commandhandling.CommandCallback;\n+import org.axonframework.commandhandling.CommandMessage;\n+import org.axonframework.commandhandling.CommandResultMessage;\n+import org.reactivestreams.Publisher;\n+import org.reactivestreams.Subscriber;\n+import reactor.core.publisher.EmitterProcessor;\n+import reactor.core.publisher.FluxSink;\n+\n+/**\n+ * Command Handler Callback that allows the dispatching thread to wait for the result of the callback, using the\n+ * Project Reactor mechanisms. This callback allows the caller to synchronize calls when an asynchronous command bus is\n+ * being used.\n+ *\n+ * @author Stefan Dragisic\n+ * @since 4.4\n+ */\n+@SuppressWarnings(\"ReactiveStreamsPublisherImplementation\")", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjY4NzMzMA=="}, "originalCommit": {"oid": "98865ab1427e4d879301c1bf542842eccc8aa3c3"}, "originalPosition": 35}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgyMjU3NTExOnYy", "diffSide": "RIGHT", "path": "messaging/src/main/java/org/axonframework/commandhandling/gateway/ReactorCommandGateway.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xMFQwODowNjozN1rOGvt-Hg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xMFQwODowNjozN1rOGvt-Hg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjY4OTQzOA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             * Variation of {@link CommandGateway}. Provides support for reactive return type such as {@link Mono} from Project\n          \n          \n            \n             * Variation of the {@link CommandGateway}, wrapping a {@link CommandBus} for a friendlier API. Provides support for reactive return types such as {@link Mono} from Project", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r452689438", "createdAt": "2020-07-10T08:06:37Z", "author": {"login": "smcvb"}, "path": "messaging/src/main/java/org/axonframework/commandhandling/gateway/ReactorCommandGateway.java", "diffHunk": "@@ -0,0 +1,71 @@\n+/*\n+ * Copyright (c) 2010-2020. Axon Framework\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.axonframework.commandhandling.gateway;\n+\n+import org.axonframework.commandhandling.CommandBus;\n+import org.axonframework.commandhandling.CommandMessage;\n+import org.axonframework.commandhandling.CommandResultMessage;\n+import org.axonframework.messaging.Message;\n+import org.axonframework.messaging.MetaData;\n+import org.axonframework.messaging.reactive.ReactorMessageDispatchInterceptorSupport;\n+import org.axonframework.messaging.reactive.ReactorResultHandlerInterceptorSupport;\n+import org.reactivestreams.Publisher;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Mono;\n+\n+import java.util.function.Function;\n+\n+/**\n+ * Variation of {@link CommandGateway}. Provides support for reactive return type such as {@link Mono} from Project", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "98865ab1427e4d879301c1bf542842eccc8aa3c3"}, "originalPosition": 33}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgyMjU4MjgyOnYy", "diffSide": "RIGHT", "path": "messaging/src/main/java/org/axonframework/commandhandling/gateway/ReactorCommandGateway.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xMFQwODowOTowM1rOGvuCpg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xMFQwODowOTowM1rOGvuCpg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjY5MDU5OA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * Uses given Publisher of commands to send incoming commands away. Commands will be sent sequentially - once a\n          \n          \n            \n                 * result of Nth command arrives, (N + 1)th command is dispatched.\n          \n          \n            \n                 *\n          \n          \n            \n                 * @param commands a Publisher stream of commands to be dispatched\n          \n          \n            \n                 * @return a Flux of command results. An ordering of command results corresponds to an ordering of commands being\n          \n          \n            \n                 * dispatched\n          \n          \n            \n                 * Uses the given {@link Publisher} of commands to send incoming commands away. Commands will be sent sequentially. Once the\n          \n          \n            \n                 * result of the Nth command arrives, the (N + 1)th command is dispatched.\n          \n          \n            \n                 *\n          \n          \n            \n                 * @param commands a {@link Publisher} stream of commands to be dispatched\n          \n          \n            \n                 * @return a {@link Flux} of command results. The ordering of command results corresponds to the ordering of commands being\n          \n          \n            \n                 * dispatched", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r452690598", "createdAt": "2020-07-10T08:09:03Z", "author": {"login": "smcvb"}, "path": "messaging/src/main/java/org/axonframework/commandhandling/gateway/ReactorCommandGateway.java", "diffHunk": "@@ -0,0 +1,71 @@\n+/*\n+ * Copyright (c) 2010-2020. Axon Framework\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.axonframework.commandhandling.gateway;\n+\n+import org.axonframework.commandhandling.CommandBus;\n+import org.axonframework.commandhandling.CommandMessage;\n+import org.axonframework.commandhandling.CommandResultMessage;\n+import org.axonframework.messaging.Message;\n+import org.axonframework.messaging.MetaData;\n+import org.axonframework.messaging.reactive.ReactorMessageDispatchInterceptorSupport;\n+import org.axonframework.messaging.reactive.ReactorResultHandlerInterceptorSupport;\n+import org.reactivestreams.Publisher;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Mono;\n+\n+import java.util.function.Function;\n+\n+/**\n+ * Variation of {@link CommandGateway}. Provides support for reactive return type such as {@link Mono} from Project\n+ * Reactor.\n+ *\n+ * @author Milan Savic\n+ * @since 4.4\n+ */\n+public interface ReactorCommandGateway\n+        extends ReactorMessageDispatchInterceptorSupport<CommandMessage<?>>,\n+        ReactorResultHandlerInterceptorSupport<CommandMessage<?>, CommandResultMessage<?>> {\n+\n+    /**\n+     * Sends the given {@code command} once the caller subscribes to the command result. Returns immediately.\n+     * <p/>\n+     * The given {@code command} is wrapped as the payload of a {@link CommandMessage} that is eventually posted on the\n+     * {@link CommandBus}, unless the {@code command} already implements {@link Message}. In that case, a\n+     * {@code CommandMessage} is constructed from that message's payload and {@link MetaData}.\n+     *\n+     * @param command the command to dispatch\n+     * @param <R>     the type of the command result\n+     * @return a {@link Mono} which is resolved when the command is executed\n+     */\n+    <R> Mono<R> send(Object command);\n+\n+    /**\n+     * Uses given Publisher of commands to send incoming commands away. Commands will be sent sequentially - once a\n+     * result of Nth command arrives, (N + 1)th command is dispatched.\n+     *\n+     * @param commands a Publisher stream of commands to be dispatched\n+     * @return a Flux of command results. An ordering of command results corresponds to an ordering of commands being\n+     * dispatched", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "98865ab1427e4d879301c1bf542842eccc8aa3c3"}, "originalPosition": 62}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgyMjU4NDQwOnYy", "diffSide": "RIGHT", "path": "messaging/src/main/java/org/axonframework/eventhandling/gateway/ReactorEventGateway.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xMFQwODowOTozMlrOGvuDlw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xMFQwODowOTozMlrOGvuDlw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjY5MDgzOQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             * Variation of {@link EventGateway}. Provides support for reactive return types such as {@link Flux} from Project\n          \n          \n            \n             * Variation of the {@link EventGateway}, wrapping a {@link EventBus} for a friendlier API. Provides support for reactive return types such as {@link Flux} from Project", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r452690839", "createdAt": "2020-07-10T08:09:32Z", "author": {"login": "smcvb"}, "path": "messaging/src/main/java/org/axonframework/eventhandling/gateway/ReactorEventGateway.java", "diffHunk": "@@ -0,0 +1,84 @@\n+/*\n+ * Copyright (c) 2010-2020. Axon Framework\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.axonframework.eventhandling.gateway;\n+\n+import org.axonframework.eventhandling.EventBus;\n+import org.axonframework.eventhandling.EventMessage;\n+import org.axonframework.messaging.Message;\n+import org.axonframework.messaging.reactive.ReactorMessageDispatchInterceptorSupport;\n+import org.reactivestreams.Publisher;\n+import reactor.core.publisher.Flux;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+\n+/**\n+ * Variation of {@link EventGateway}. Provides support for reactive return types such as {@link Flux} from Project", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "98865ab1427e4d879301c1bf542842eccc8aa3c3"}, "originalPosition": 30}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgyMjU4Njk5OnYy", "diffSide": "RIGHT", "path": "messaging/src/main/java/org/axonframework/eventhandling/gateway/ReactorEventGateway.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xMFQwODoxMDoyMFrOGvuFGw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xMFQwODoxMDoyMFrOGvuFGw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjY5MTIyNw==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * Publishes given {@code events} once the caller subscribes to the resulting Flux. Returns immediately.\n          \n          \n            \n                 * Publishes the given {@code events} once the caller subscribes to the resulting {@link Flux}. Returns immediately.", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r452691227", "createdAt": "2020-07-10T08:10:20Z", "author": {"login": "smcvb"}, "path": "messaging/src/main/java/org/axonframework/eventhandling/gateway/ReactorEventGateway.java", "diffHunk": "@@ -0,0 +1,84 @@\n+/*\n+ * Copyright (c) 2010-2020. Axon Framework\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.axonframework.eventhandling.gateway;\n+\n+import org.axonframework.eventhandling.EventBus;\n+import org.axonframework.eventhandling.EventMessage;\n+import org.axonframework.messaging.Message;\n+import org.axonframework.messaging.reactive.ReactorMessageDispatchInterceptorSupport;\n+import org.reactivestreams.Publisher;\n+import reactor.core.publisher.Flux;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+\n+/**\n+ * Variation of {@link EventGateway}. Provides support for reactive return types such as {@link Flux} from Project\n+ * Reactor.\n+ *\n+ * @author Milan Savic\n+ * @since 4.4\n+ */\n+public interface ReactorEventGateway extends ReactorMessageDispatchInterceptorSupport<EventMessage<?>> {\n+\n+    /**\n+     * Publishes given {@code events} once the caller subscribes to the resulting Flux. Returns immediately.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "98865ab1427e4d879301c1bf542842eccc8aa3c3"}, "originalPosition": 39}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgyMjU4ODQ2OnYy", "diffSide": "RIGHT", "path": "messaging/src/main/java/org/axonframework/eventhandling/gateway/ReactorEventGateway.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xMFQwODoxMDo1M1rOGvuGDg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xMFQwODoxMDo1M1rOGvuGDg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjY5MTQ3MA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * Publishes given {@code events} once the caller subscribes to the resulting Flux. Returns immediately.\n          \n          \n            \n                 * Publishes the given {@code events} once the caller subscribes to the resulting {@link Flux}. Returns immediately.", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r452691470", "createdAt": "2020-07-10T08:10:53Z", "author": {"login": "smcvb"}, "path": "messaging/src/main/java/org/axonframework/eventhandling/gateway/ReactorEventGateway.java", "diffHunk": "@@ -0,0 +1,84 @@\n+/*\n+ * Copyright (c) 2010-2020. Axon Framework\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.axonframework.eventhandling.gateway;\n+\n+import org.axonframework.eventhandling.EventBus;\n+import org.axonframework.eventhandling.EventMessage;\n+import org.axonframework.messaging.Message;\n+import org.axonframework.messaging.reactive.ReactorMessageDispatchInterceptorSupport;\n+import org.reactivestreams.Publisher;\n+import reactor.core.publisher.Flux;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+\n+/**\n+ * Variation of {@link EventGateway}. Provides support for reactive return types such as {@link Flux} from Project\n+ * Reactor.\n+ *\n+ * @author Milan Savic\n+ * @since 4.4\n+ */\n+public interface ReactorEventGateway extends ReactorMessageDispatchInterceptorSupport<EventMessage<?>> {\n+\n+    /**\n+     * Publishes given {@code events} once the caller subscribes to the resulting Flux. Returns immediately.\n+     * <p/>\n+     * Given {@code events} are wrapped as payloads of a {@link EventMessage} that are eventually published on the\n+     * {@link EventBus}, unless {@code event} already implements {@link Message}. In that case, a {@code EventMessage}\n+     * is constructed from that message's payload and {@link org.axonframework.messaging.MetaData}.\n+     *\n+     * @param events events to be published\n+     * @return events that were published. DO NOTE: if there were some interceptors registered to this {@code gateway},\n+     * they will be processed first, before returning events to the caller. The order of returned events is the same as\n+     * one provided as the input parameter.\n+     */\n+    default Flux<Object> publish(Object... events) { // NOSONAR\n+        return publish(Arrays.asList(events));\n+    }\n+\n+    /**\n+     * Publishes given {@code events} once the caller subscribes to the resulting Flux. Returns immediately.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "98865ab1427e4d879301c1bf542842eccc8aa3c3"}, "originalPosition": 55}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgyMjU5MDQ0OnYy", "diffSide": "RIGHT", "path": "messaging/src/main/java/org/axonframework/eventhandling/gateway/ReactorEventGateway.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xMFQwODoxMTozMFrOGvuHQA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xMFQwODoxMTozMFrOGvuHQA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjY5MTc3Ng==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * Publishes given {@code events} once the caller subscribes to the resulting Flux. Returns immediately.\n          \n          \n            \n                 * Publishes the given {@code events} once the caller subscribes to the resulting {@link Flux}. Returns immediately.", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r452691776", "createdAt": "2020-07-10T08:11:30Z", "author": {"login": "smcvb"}, "path": "messaging/src/main/java/org/axonframework/eventhandling/gateway/ReactorEventGateway.java", "diffHunk": "@@ -0,0 +1,84 @@\n+/*\n+ * Copyright (c) 2010-2020. Axon Framework\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.axonframework.eventhandling.gateway;\n+\n+import org.axonframework.eventhandling.EventBus;\n+import org.axonframework.eventhandling.EventMessage;\n+import org.axonframework.messaging.Message;\n+import org.axonframework.messaging.reactive.ReactorMessageDispatchInterceptorSupport;\n+import org.reactivestreams.Publisher;\n+import reactor.core.publisher.Flux;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+\n+/**\n+ * Variation of {@link EventGateway}. Provides support for reactive return types such as {@link Flux} from Project\n+ * Reactor.\n+ *\n+ * @author Milan Savic\n+ * @since 4.4\n+ */\n+public interface ReactorEventGateway extends ReactorMessageDispatchInterceptorSupport<EventMessage<?>> {\n+\n+    /**\n+     * Publishes given {@code events} once the caller subscribes to the resulting Flux. Returns immediately.\n+     * <p/>\n+     * Given {@code events} are wrapped as payloads of a {@link EventMessage} that are eventually published on the\n+     * {@link EventBus}, unless {@code event} already implements {@link Message}. In that case, a {@code EventMessage}\n+     * is constructed from that message's payload and {@link org.axonframework.messaging.MetaData}.\n+     *\n+     * @param events events to be published\n+     * @return events that were published. DO NOTE: if there were some interceptors registered to this {@code gateway},\n+     * they will be processed first, before returning events to the caller. The order of returned events is the same as\n+     * one provided as the input parameter.\n+     */\n+    default Flux<Object> publish(Object... events) { // NOSONAR\n+        return publish(Arrays.asList(events));\n+    }\n+\n+    /**\n+     * Publishes given {@code events} once the caller subscribes to the resulting Flux. Returns immediately.\n+     * <p/>\n+     * Given {@code events} are wrapped as payloads of a {@link EventMessage} that are eventually published on the\n+     * {@link EventBus}, unless {@code event} already implements {@link Message}. In that case, a {@code EventMessage}\n+     * is constructed from that message's payload and {@link org.axonframework.messaging.MetaData}.\n+     *\n+     * @param events the list of events to be published\n+     * @return events that were published. DO NOTE: if there were some interceptors registered to this {@code gateway},\n+     * they will be processed first, before returning events to the caller. The order of returned events is the same as\n+     * one provided as the input parameter.\n+     */\n+    Flux<Object> publish(List<?> events);\n+\n+    /**\n+     * Publishes given {@code events} once the caller subscribes to the resulting Flux. Returns immediately.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "98865ab1427e4d879301c1bf542842eccc8aa3c3"}, "originalPosition": 69}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgyMjU5MjU3OnYy", "diffSide": "RIGHT", "path": "messaging/src/main/java/org/axonframework/eventhandling/gateway/ReactorEventGateway.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xMFQwODoxMjoxM1rOGvuIoA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yN1QxMDoyMTozN1rOG3ch7Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjY5MjEyOA==", "bodyText": "Nit: Slightly doubtful on this, but might be nice to reference the MessageDispatchInterceptor instead of just stating interceptors.", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r452692128", "createdAt": "2020-07-10T08:12:13Z", "author": {"login": "smcvb"}, "path": "messaging/src/main/java/org/axonframework/eventhandling/gateway/ReactorEventGateway.java", "diffHunk": "@@ -0,0 +1,84 @@\n+/*\n+ * Copyright (c) 2010-2020. Axon Framework\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.axonframework.eventhandling.gateway;\n+\n+import org.axonframework.eventhandling.EventBus;\n+import org.axonframework.eventhandling.EventMessage;\n+import org.axonframework.messaging.Message;\n+import org.axonframework.messaging.reactive.ReactorMessageDispatchInterceptorSupport;\n+import org.reactivestreams.Publisher;\n+import reactor.core.publisher.Flux;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+\n+/**\n+ * Variation of {@link EventGateway}. Provides support for reactive return types such as {@link Flux} from Project\n+ * Reactor.\n+ *\n+ * @author Milan Savic\n+ * @since 4.4\n+ */\n+public interface ReactorEventGateway extends ReactorMessageDispatchInterceptorSupport<EventMessage<?>> {\n+\n+    /**\n+     * Publishes given {@code events} once the caller subscribes to the resulting Flux. Returns immediately.\n+     * <p/>\n+     * Given {@code events} are wrapped as payloads of a {@link EventMessage} that are eventually published on the\n+     * {@link EventBus}, unless {@code event} already implements {@link Message}. In that case, a {@code EventMessage}\n+     * is constructed from that message's payload and {@link org.axonframework.messaging.MetaData}.\n+     *\n+     * @param events events to be published\n+     * @return events that were published. DO NOTE: if there were some interceptors registered to this {@code gateway},", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "98865ab1427e4d879301c1bf542842eccc8aa3c3"}, "originalPosition": 46}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDc5MjMwMQ==", "bodyText": "Done!", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r460792301", "createdAt": "2020-07-27T10:21:37Z", "author": {"login": "m1l4n54v1c"}, "path": "messaging/src/main/java/org/axonframework/eventhandling/gateway/ReactorEventGateway.java", "diffHunk": "@@ -0,0 +1,84 @@\n+/*\n+ * Copyright (c) 2010-2020. Axon Framework\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.axonframework.eventhandling.gateway;\n+\n+import org.axonframework.eventhandling.EventBus;\n+import org.axonframework.eventhandling.EventMessage;\n+import org.axonframework.messaging.Message;\n+import org.axonframework.messaging.reactive.ReactorMessageDispatchInterceptorSupport;\n+import org.reactivestreams.Publisher;\n+import reactor.core.publisher.Flux;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+\n+/**\n+ * Variation of {@link EventGateway}. Provides support for reactive return types such as {@link Flux} from Project\n+ * Reactor.\n+ *\n+ * @author Milan Savic\n+ * @since 4.4\n+ */\n+public interface ReactorEventGateway extends ReactorMessageDispatchInterceptorSupport<EventMessage<?>> {\n+\n+    /**\n+     * Publishes given {@code events} once the caller subscribes to the resulting Flux. Returns immediately.\n+     * <p/>\n+     * Given {@code events} are wrapped as payloads of a {@link EventMessage} that are eventually published on the\n+     * {@link EventBus}, unless {@code event} already implements {@link Message}. In that case, a {@code EventMessage}\n+     * is constructed from that message's payload and {@link org.axonframework.messaging.MetaData}.\n+     *\n+     * @param events events to be published\n+     * @return events that were published. DO NOTE: if there were some interceptors registered to this {@code gateway},", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjY5MjEyOA=="}, "originalCommit": {"oid": "98865ab1427e4d879301c1bf542842eccc8aa3c3"}, "originalPosition": 46}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgyMjU5NjIxOnYy", "diffSide": "RIGHT", "path": "messaging/src/main/java/org/axonframework/messaging/reactive/ReactorMessageDispatchInterceptor.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xMFQwODoxMzoyN1rOGvuK1A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xMFQwODoxNDozOFrOGvuNFA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjY5MjY5Mg==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             * Interceptor that allows messages to be intercepted and modified before they are dispatched. Implementations are\n          \n          \n            \n             * required to provide a function that modifies a {@link Mono} of a message and returns a modified/new {@code Mono} to\n          \n          \n            \n             * be passed down the interceptor chain or to be dispatched. This way we provide a reactive approach to intercepting\n          \n          \n            \n             * messages.\n          \n          \n            \n             * Interceptor that allows messages to be intercepted and modified before they are dispatched. Implementations are\n          \n          \n            \n             * required to provide a function that modifies a {@link Mono} of a message and returns a modified/new {@code Mono} to\n          \n          \n            \n             * be passed down the interceptor chain or to be dispatched.\n          \n      \n    \n    \n  \n\nAlthough that last sentence is true, I believe this speaks for itself.", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r452692692", "createdAt": "2020-07-10T08:13:27Z", "author": {"login": "smcvb"}, "path": "messaging/src/main/java/org/axonframework/messaging/reactive/ReactorMessageDispatchInterceptor.java", "diffHunk": "@@ -0,0 +1,53 @@\n+/*\n+ * Copyright (c) 2010-2020. Axon Framework\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.axonframework.messaging.reactive;\n+\n+import org.axonframework.messaging.Message;\n+import org.axonframework.messaging.MessageDispatchInterceptor;\n+import reactor.core.publisher.Mono;\n+\n+import java.util.List;\n+import java.util.function.BiFunction;\n+\n+/**\n+ * Interceptor that allows messages to be intercepted and modified before they are dispatched. Implementations are\n+ * required to provide a function that modifies a {@link Mono} of a message and returns a modified/new {@code Mono} to\n+ * be passed down the interceptor chain or to be dispatched. This way we provide a reactive approach to intercepting\n+ * messages.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "98865ab1427e4d879301c1bf542842eccc8aa3c3"}, "originalPosition": 30}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjY5MzI2OA==", "bodyText": "Added, would it make sense to state something like the following in the class level javadoc too:\nThis interceptor provides a very early means to alter or reject Messages, even before any Unit of Work is created.", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r452693268", "createdAt": "2020-07-10T08:14:38Z", "author": {"login": "smcvb"}, "path": "messaging/src/main/java/org/axonframework/messaging/reactive/ReactorMessageDispatchInterceptor.java", "diffHunk": "@@ -0,0 +1,53 @@\n+/*\n+ * Copyright (c) 2010-2020. Axon Framework\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.axonframework.messaging.reactive;\n+\n+import org.axonframework.messaging.Message;\n+import org.axonframework.messaging.MessageDispatchInterceptor;\n+import reactor.core.publisher.Mono;\n+\n+import java.util.List;\n+import java.util.function.BiFunction;\n+\n+/**\n+ * Interceptor that allows messages to be intercepted and modified before they are dispatched. Implementations are\n+ * required to provide a function that modifies a {@link Mono} of a message and returns a modified/new {@code Mono} to\n+ * be passed down the interceptor chain or to be dispatched. This way we provide a reactive approach to intercepting\n+ * messages.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjY5MjY5Mg=="}, "originalCommit": {"oid": "98865ab1427e4d879301c1bf542842eccc8aa3c3"}, "originalPosition": 30}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgyMjYwNjEzOnYy", "diffSide": "RIGHT", "path": "messaging/src/main/java/org/axonframework/messaging/reactive/ReactorResultHandlerInterceptor.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xMFQwODoxNjoyNlrOGvuQ0Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMVQxMzowNjoyNFrOG03ARg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjY5NDIyNQ==", "bodyText": "Curious: why would you break a result message chain?", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r452694225", "createdAt": "2020-07-10T08:16:26Z", "author": {"login": "smcvb"}, "path": "messaging/src/main/java/org/axonframework/messaging/reactive/ReactorResultHandlerInterceptor.java", "diffHunk": "@@ -0,0 +1,45 @@\n+/*\n+ * Copyright (c) 2010-2020. Axon Framework\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.axonframework.messaging.reactive;\n+\n+import org.axonframework.messaging.Message;\n+import org.axonframework.messaging.ResultMessage;\n+import reactor.core.publisher.Flux;\n+\n+/**\n+ * Interceptor that allows results to be intercepted and modified before they are handled. Implementations are required\n+ * to operate on a {@link Flux} of results or return a new {@link Flux} which will be passed down the interceptor chain.\n+ * Also, implementations may make decisions based on the message that was dispatched.\n+ *\n+ * @param <M> The type of the message for which the result is going to be intercepted\n+ * @param <R> The type of the result to be intercepted\n+ * @author Sara Pellegrini\n+ * @since 4.4\n+ */\n+@FunctionalInterface\n+public interface ReactorResultHandlerInterceptor<M extends Message<?>, R extends ResultMessage<?>> {\n+\n+    /**\n+     * Intercepts result messages. It's possible to break the interceptor chain by returning {@link Flux#empty()} or", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "98865ab1427e4d879301c1bf542842eccc8aa3c3"}, "originalPosition": 37}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzcyMzkyMg==", "bodyText": "Few ideas:\nHistorically in the regular interceptor, you have the chain control viaproceed() function (this is reactive way of doing it)\nHandling transient exception, via flat map you can convert error to empty publisher\nThis could be useful for subscription queries, with result interceptor you could define global rule when \"infinitive\" subscriber should stop listening for updates\nYou want to filter messages that fulfill client predicate (filter function can be used for this)", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r453723922", "createdAt": "2020-07-13T15:14:03Z", "author": {"login": "schananas"}, "path": "messaging/src/main/java/org/axonframework/messaging/reactive/ReactorResultHandlerInterceptor.java", "diffHunk": "@@ -0,0 +1,45 @@\n+/*\n+ * Copyright (c) 2010-2020. Axon Framework\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.axonframework.messaging.reactive;\n+\n+import org.axonframework.messaging.Message;\n+import org.axonframework.messaging.ResultMessage;\n+import reactor.core.publisher.Flux;\n+\n+/**\n+ * Interceptor that allows results to be intercepted and modified before they are handled. Implementations are required\n+ * to operate on a {@link Flux} of results or return a new {@link Flux} which will be passed down the interceptor chain.\n+ * Also, implementations may make decisions based on the message that was dispatched.\n+ *\n+ * @param <M> The type of the message for which the result is going to be intercepted\n+ * @param <R> The type of the result to be intercepted\n+ * @author Sara Pellegrini\n+ * @since 4.4\n+ */\n+@FunctionalInterface\n+public interface ReactorResultHandlerInterceptor<M extends Message<?>, R extends ResultMessage<?>> {\n+\n+    /**\n+     * Intercepts result messages. It's possible to break the interceptor chain by returning {@link Flux#empty()} or", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjY5NDIyNQ=="}, "originalCommit": {"oid": "98865ab1427e4d879301c1bf542842eccc8aa3c3"}, "originalPosition": 37}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODA4MDMyNg==", "bodyText": "Sweet, sounds good.\nIt would be very helpful to add these suggestions to the Reference Guide (to build) around the Reactive Gateways, as this will definitely help out our users.", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r458080326", "createdAt": "2020-07-21T13:06:24Z", "author": {"login": "smcvb"}, "path": "messaging/src/main/java/org/axonframework/messaging/reactive/ReactorResultHandlerInterceptor.java", "diffHunk": "@@ -0,0 +1,45 @@\n+/*\n+ * Copyright (c) 2010-2020. Axon Framework\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.axonframework.messaging.reactive;\n+\n+import org.axonframework.messaging.Message;\n+import org.axonframework.messaging.ResultMessage;\n+import reactor.core.publisher.Flux;\n+\n+/**\n+ * Interceptor that allows results to be intercepted and modified before they are handled. Implementations are required\n+ * to operate on a {@link Flux} of results or return a new {@link Flux} which will be passed down the interceptor chain.\n+ * Also, implementations may make decisions based on the message that was dispatched.\n+ *\n+ * @param <M> The type of the message for which the result is going to be intercepted\n+ * @param <R> The type of the result to be intercepted\n+ * @author Sara Pellegrini\n+ * @since 4.4\n+ */\n+@FunctionalInterface\n+public interface ReactorResultHandlerInterceptor<M extends Message<?>, R extends ResultMessage<?>> {\n+\n+    /**\n+     * Intercepts result messages. It's possible to break the interceptor chain by returning {@link Flux#empty()} or", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjY5NDIyNQ=="}, "originalCommit": {"oid": "98865ab1427e4d879301c1bf542842eccc8aa3c3"}, "originalPosition": 37}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgyMjYwOTA2OnYy", "diffSide": "RIGHT", "path": "messaging/src/main/java/org/axonframework/messaging/reactive/ReactorResultHandlerInterceptor.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xMFQwODoxNzoyMVrOGvuSkw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xMFQwODoxNzoyMVrOGvuSkw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjY5NDY3NQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * @param results results of a dispatched message\n          \n          \n            \n                 * @return intercepted results\n          \n          \n            \n                 * @param results the outcome of the dispatched {@code message}\n          \n          \n            \n                 * @return the intercepted {@code results}", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r452694675", "createdAt": "2020-07-10T08:17:21Z", "author": {"login": "smcvb"}, "path": "messaging/src/main/java/org/axonframework/messaging/reactive/ReactorResultHandlerInterceptor.java", "diffHunk": "@@ -0,0 +1,45 @@\n+/*\n+ * Copyright (c) 2010-2020. Axon Framework\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.axonframework.messaging.reactive;\n+\n+import org.axonframework.messaging.Message;\n+import org.axonframework.messaging.ResultMessage;\n+import reactor.core.publisher.Flux;\n+\n+/**\n+ * Interceptor that allows results to be intercepted and modified before they are handled. Implementations are required\n+ * to operate on a {@link Flux} of results or return a new {@link Flux} which will be passed down the interceptor chain.\n+ * Also, implementations may make decisions based on the message that was dispatched.\n+ *\n+ * @param <M> The type of the message for which the result is going to be intercepted\n+ * @param <R> The type of the result to be intercepted\n+ * @author Sara Pellegrini\n+ * @since 4.4\n+ */\n+@FunctionalInterface\n+public interface ReactorResultHandlerInterceptor<M extends Message<?>, R extends ResultMessage<?>> {\n+\n+    /**\n+     * Intercepts result messages. It's possible to break the interceptor chain by returning {@link Flux#empty()} or\n+     * {@link Flux#error(Throwable)} variations.\n+     *\n+     * @param message a message that was dispatched (and caused these {@code results})\n+     * @param results results of a dispatched message\n+     * @return intercepted results", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "98865ab1427e4d879301c1bf542842eccc8aa3c3"}, "originalPosition": 42}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgyMjYxMjQ2OnYy", "diffSide": "RIGHT", "path": "messaging/src/main/java/org/axonframework/messaging/responsetypes/ConvertingResponseMessage.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xMFQwODoxODozM1rOGvuUsg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMFQxNDowNjo1N1rOG0OlVA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjY5NTIxOA==", "bodyText": "Have you verified this serialVersionUID is the actual serialVersionUID used prior to having specified it?", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r452695218", "createdAt": "2020-07-10T08:18:33Z", "author": {"login": "smcvb"}, "path": "messaging/src/main/java/org/axonframework/messaging/responsetypes/ConvertingResponseMessage.java", "diffHunk": "@@ -21,6 +21,7 @@\n  */\n public class ConvertingResponseMessage<R> implements QueryResponseMessage<R> {\n \n+    private static final long serialVersionUID = -8926628997626431513L;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "98865ab1427e4d879301c1bf542842eccc8aa3c3"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzQxODA2OA==", "bodyText": "Uh no! Nice catch, I'll remove it!", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r457418068", "createdAt": "2020-07-20T14:06:57Z", "author": {"login": "m1l4n54v1c"}, "path": "messaging/src/main/java/org/axonframework/messaging/responsetypes/ConvertingResponseMessage.java", "diffHunk": "@@ -21,6 +21,7 @@\n  */\n public class ConvertingResponseMessage<R> implements QueryResponseMessage<R> {\n \n+    private static final long serialVersionUID = -8926628997626431513L;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjY5NTIxOA=="}, "originalCommit": {"oid": "98865ab1427e4d879301c1bf542842eccc8aa3c3"}, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgyMjYxMjk5OnYy", "diffSide": "RIGHT", "path": "axon-server-connector/src/main/java/org/axonframework/axonserver/connector/query/subscription/GrpcBackedQueryUpdateMessage.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xMFQwODoxODo0M1rOGvuU_A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMVQxMzowNzowMlrOG03B1A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjY5NTI5Mg==", "bodyText": "Have you verified this serialVersionUID is the actual serialVersionUID used prior to having specified it?", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r452695292", "createdAt": "2020-07-10T08:18:43Z", "author": {"login": "smcvb"}, "path": "axon-server-connector/src/main/java/org/axonframework/axonserver/connector/query/subscription/GrpcBackedQueryUpdateMessage.java", "diffHunk": "@@ -36,8 +38,10 @@\n  */\n class GrpcBackedQueryUpdateMessage<U> implements SubscriptionQueryUpdateMessage<U> {\n \n+    private static final long serialVersionUID = 488652969630034329L;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "98865ab1427e4d879301c1bf542842eccc8aa3c3"}, "originalPosition": 20}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzQxODg4MQ==", "bodyText": "I haven't ;(", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r457418881", "createdAt": "2020-07-20T14:07:41Z", "author": {"login": "m1l4n54v1c"}, "path": "axon-server-connector/src/main/java/org/axonframework/axonserver/connector/query/subscription/GrpcBackedQueryUpdateMessage.java", "diffHunk": "@@ -36,8 +38,10 @@\n  */\n class GrpcBackedQueryUpdateMessage<U> implements SubscriptionQueryUpdateMessage<U> {\n \n+    private static final long serialVersionUID = 488652969630034329L;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjY5NTI5Mg=="}, "originalCommit": {"oid": "98865ab1427e4d879301c1bf542842eccc8aa3c3"}, "originalPosition": 20}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODA4MDcyNA==", "bodyText": "That's ok, that's why I've asked it! Worth verifying prior to pushing this at least :-)", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r458080724", "createdAt": "2020-07-21T13:07:02Z", "author": {"login": "smcvb"}, "path": "axon-server-connector/src/main/java/org/axonframework/axonserver/connector/query/subscription/GrpcBackedQueryUpdateMessage.java", "diffHunk": "@@ -36,8 +38,10 @@\n  */\n class GrpcBackedQueryUpdateMessage<U> implements SubscriptionQueryUpdateMessage<U> {\n \n+    private static final long serialVersionUID = 488652969630034329L;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjY5NTI5Mg=="}, "originalCommit": {"oid": "98865ab1427e4d879301c1bf542842eccc8aa3c3"}, "originalPosition": 20}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgyMjYyMTQ4OnYy", "diffSide": "RIGHT", "path": "messaging/src/main/java/org/axonframework/queryhandling/ReactorQueryGateway.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xMFQwODoyMTowOVrOGvuZ9w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xMFQwODoyMTowOVrOGvuZ9w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjY5NjU2Nw==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             * Variation of {@link QueryGateway}. Provides support for reactive return types such as {@link Mono} and {@link Flux}\n          \n          \n            \n             * Variation of the {@link QueryGateway}, wrapping a {@link QueryBus} for a friendlier API. Provides support for reactive return types such as {@link Mono} and {@link Flux}", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r452696567", "createdAt": "2020-07-10T08:21:09Z", "author": {"login": "smcvb"}, "path": "messaging/src/main/java/org/axonframework/queryhandling/ReactorQueryGateway.java", "diffHunk": "@@ -0,0 +1,547 @@\n+/*\n+ * Copyright (c) 2010-2020. Axon Framework\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.axonframework.queryhandling;\n+\n+import org.axonframework.messaging.ResultMessage;\n+import org.axonframework.messaging.reactive.ReactorMessageDispatchInterceptorSupport;\n+import org.axonframework.messaging.reactive.ReactorResultHandlerInterceptorSupport;\n+import org.axonframework.messaging.responsetypes.ResponseType;\n+import org.axonframework.messaging.responsetypes.ResponseTypes;\n+import org.reactivestreams.Publisher;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Mono;\n+import reactor.util.concurrent.Queues;\n+\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Function;\n+\n+/**\n+ * Variation of {@link QueryGateway}. Provides support for reactive return types such as {@link Mono} and {@link Flux}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "98865ab1427e4d879301c1bf542842eccc8aa3c3"}, "originalPosition": 33}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgyMjY3NjI4OnYy", "diffSide": "RIGHT", "path": "messaging/src/main/java/org/axonframework/queryhandling/ReactorQueryGateway.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xMFQwODozODowNVrOGvu7rg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yN1QxMDoyMzowNlrOG3clKg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjcwNTE5OA==", "bodyText": "You should take into account that the query given here might be a QueryMessage implementation. Thus simply doing query.getClass().getName() might result in QueryMessage as the result, which is not it's intended purpose. I'd recommend to use the QueryMessage#queryName(Object) method to figure out the actual queryName to provider here.", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r452705198", "createdAt": "2020-07-10T08:38:05Z", "author": {"login": "smcvb"}, "path": "messaging/src/main/java/org/axonframework/queryhandling/ReactorQueryGateway.java", "diffHunk": "@@ -0,0 +1,547 @@\n+/*\n+ * Copyright (c) 2010-2020. Axon Framework\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.axonframework.queryhandling;\n+\n+import org.axonframework.messaging.ResultMessage;\n+import org.axonframework.messaging.reactive.ReactorMessageDispatchInterceptorSupport;\n+import org.axonframework.messaging.reactive.ReactorResultHandlerInterceptorSupport;\n+import org.axonframework.messaging.responsetypes.ResponseType;\n+import org.axonframework.messaging.responsetypes.ResponseTypes;\n+import org.reactivestreams.Publisher;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Mono;\n+import reactor.util.concurrent.Queues;\n+\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Function;\n+\n+/**\n+ * Variation of {@link QueryGateway}. Provides support for reactive return types such as {@link Mono} and {@link Flux}\n+ * from Project Reactor.\n+ *\n+ * @author Milan Savic\n+ * @since 4.4\n+ */\n+public interface ReactorQueryGateway extends ReactorMessageDispatchInterceptorSupport<QueryMessage<?, ?>>,\n+        ReactorResultHandlerInterceptorSupport<QueryMessage<?, ?>, ResultMessage<?>> {\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response with the given {@code responseType}\n+     * from a single source. The query name will be derived from the provided {@code query}. Execution may be\n+     * asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param query        The {@code query} to be sent\n+     * @param responseType A {@link Class} describing the desired response type\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(Q query, Class<R> responseType) {\n+        return query(query.getClass().getName(), query, responseType);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "98865ab1427e4d879301c1bf542842eccc8aa3c3"}, "originalPosition": 56}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDc5MzEzMA==", "bodyText": "Done!", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r460793130", "createdAt": "2020-07-27T10:23:06Z", "author": {"login": "m1l4n54v1c"}, "path": "messaging/src/main/java/org/axonframework/queryhandling/ReactorQueryGateway.java", "diffHunk": "@@ -0,0 +1,547 @@\n+/*\n+ * Copyright (c) 2010-2020. Axon Framework\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.axonframework.queryhandling;\n+\n+import org.axonframework.messaging.ResultMessage;\n+import org.axonframework.messaging.reactive.ReactorMessageDispatchInterceptorSupport;\n+import org.axonframework.messaging.reactive.ReactorResultHandlerInterceptorSupport;\n+import org.axonframework.messaging.responsetypes.ResponseType;\n+import org.axonframework.messaging.responsetypes.ResponseTypes;\n+import org.reactivestreams.Publisher;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Mono;\n+import reactor.util.concurrent.Queues;\n+\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Function;\n+\n+/**\n+ * Variation of {@link QueryGateway}. Provides support for reactive return types such as {@link Mono} and {@link Flux}\n+ * from Project Reactor.\n+ *\n+ * @author Milan Savic\n+ * @since 4.4\n+ */\n+public interface ReactorQueryGateway extends ReactorMessageDispatchInterceptorSupport<QueryMessage<?, ?>>,\n+        ReactorResultHandlerInterceptorSupport<QueryMessage<?, ?>, ResultMessage<?>> {\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response with the given {@code responseType}\n+     * from a single source. The query name will be derived from the provided {@code query}. Execution may be\n+     * asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param query        The {@code query} to be sent\n+     * @param responseType A {@link Class} describing the desired response type\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(Q query, Class<R> responseType) {\n+        return query(query.getClass().getName(), query, responseType);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjcwNTE5OA=="}, "originalCommit": {"oid": "98865ab1427e4d879301c1bf542842eccc8aa3c3"}, "originalPosition": 56}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgyMjY4MDcyOnYy", "diffSide": "RIGHT", "path": "messaging/src/main/java/org/axonframework/queryhandling/ReactorQueryGateway.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xMFQwODozOTozNlrOGvu-lg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yN1QxMDoyMzoxNVrOG3clew==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjcwNTk0Mg==", "bodyText": "You should take into account that the query given here might be a QueryMessage implementation. Thus simply doing query.getClass().getName() might result in QueryMessage as the result, which is not it's intended purpose. I'd recommend to use the QueryMessage#queryName(Object) method to figure out the actual queryName to provider here.", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r452705942", "createdAt": "2020-07-10T08:39:36Z", "author": {"login": "smcvb"}, "path": "messaging/src/main/java/org/axonframework/queryhandling/ReactorQueryGateway.java", "diffHunk": "@@ -0,0 +1,547 @@\n+/*\n+ * Copyright (c) 2010-2020. Axon Framework\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.axonframework.queryhandling;\n+\n+import org.axonframework.messaging.ResultMessage;\n+import org.axonframework.messaging.reactive.ReactorMessageDispatchInterceptorSupport;\n+import org.axonframework.messaging.reactive.ReactorResultHandlerInterceptorSupport;\n+import org.axonframework.messaging.responsetypes.ResponseType;\n+import org.axonframework.messaging.responsetypes.ResponseTypes;\n+import org.reactivestreams.Publisher;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Mono;\n+import reactor.util.concurrent.Queues;\n+\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Function;\n+\n+/**\n+ * Variation of {@link QueryGateway}. Provides support for reactive return types such as {@link Mono} and {@link Flux}\n+ * from Project Reactor.\n+ *\n+ * @author Milan Savic\n+ * @since 4.4\n+ */\n+public interface ReactorQueryGateway extends ReactorMessageDispatchInterceptorSupport<QueryMessage<?, ?>>,\n+        ReactorResultHandlerInterceptorSupport<QueryMessage<?, ?>, ResultMessage<?>> {\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response with the given {@code responseType}\n+     * from a single source. The query name will be derived from the provided {@code query}. Execution may be\n+     * asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param query        The {@code query} to be sent\n+     * @param responseType A {@link Class} describing the desired response type\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(Q query, Class<R> responseType) {\n+        return query(query.getClass().getName(), query, responseType);\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response with the given {@code responseType}\n+     * from a single source. Execution may be asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(String queryName, Q query, Class<R> responseType) {\n+        return query(queryName, query, ResponseTypes.instanceOf(responseType));\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from a single source. The query name will be derived from the provided {@code query}. Execution may be\n+     * asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(Q query, ResponseType<R> responseType) {\n+        return query(query.getClass().getName(), query, responseType);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "98865ab1427e4d879301c1bf542842eccc8aa3c3"}, "originalPosition": 90}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDc5MzIxMQ==", "bodyText": "Done!", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r460793211", "createdAt": "2020-07-27T10:23:15Z", "author": {"login": "m1l4n54v1c"}, "path": "messaging/src/main/java/org/axonframework/queryhandling/ReactorQueryGateway.java", "diffHunk": "@@ -0,0 +1,547 @@\n+/*\n+ * Copyright (c) 2010-2020. Axon Framework\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.axonframework.queryhandling;\n+\n+import org.axonframework.messaging.ResultMessage;\n+import org.axonframework.messaging.reactive.ReactorMessageDispatchInterceptorSupport;\n+import org.axonframework.messaging.reactive.ReactorResultHandlerInterceptorSupport;\n+import org.axonframework.messaging.responsetypes.ResponseType;\n+import org.axonframework.messaging.responsetypes.ResponseTypes;\n+import org.reactivestreams.Publisher;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Mono;\n+import reactor.util.concurrent.Queues;\n+\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Function;\n+\n+/**\n+ * Variation of {@link QueryGateway}. Provides support for reactive return types such as {@link Mono} and {@link Flux}\n+ * from Project Reactor.\n+ *\n+ * @author Milan Savic\n+ * @since 4.4\n+ */\n+public interface ReactorQueryGateway extends ReactorMessageDispatchInterceptorSupport<QueryMessage<?, ?>>,\n+        ReactorResultHandlerInterceptorSupport<QueryMessage<?, ?>, ResultMessage<?>> {\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response with the given {@code responseType}\n+     * from a single source. The query name will be derived from the provided {@code query}. Execution may be\n+     * asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param query        The {@code query} to be sent\n+     * @param responseType A {@link Class} describing the desired response type\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(Q query, Class<R> responseType) {\n+        return query(query.getClass().getName(), query, responseType);\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response with the given {@code responseType}\n+     * from a single source. Execution may be asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(String queryName, Q query, Class<R> responseType) {\n+        return query(queryName, query, ResponseTypes.instanceOf(responseType));\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from a single source. The query name will be derived from the provided {@code query}. Execution may be\n+     * asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(Q query, ResponseType<R> responseType) {\n+        return query(query.getClass().getName(), query, responseType);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjcwNTk0Mg=="}, "originalCommit": {"oid": "98865ab1427e4d879301c1bf542842eccc8aa3c3"}, "originalPosition": 90}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgyMjY4ODcyOnYy", "diffSide": "RIGHT", "path": "messaging/src/main/java/org/axonframework/queryhandling/ReactorQueryGateway.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xMFQwODo0MTo1N1rOGvvDcw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xMFQwODo0MTo1N1rOGvvDcw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjcwNzE4Nw==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * Uses given Publisher of query messages to send incoming queries away. Queries will be sent sequentially - once a\n          \n          \n            \n                 * result of Nth query arrives, (N + 1)th query is dispatched.\n          \n          \n            \n                 *\n          \n          \n            \n                 * @param queries a Publisher stream of queries to be dispatched\n          \n          \n            \n                 * @return a Flux of query results. An ordering of query results corresponds to an ordering of queries being\n          \n          \n            \n                 * dispatched\n          \n          \n            \n                 * Use the given {@link Publisher} of {@link QueryMessage}s to send the incoming queries away. Queries will be sent sequentially. Once the\n          \n          \n            \n                 * result of the Nth query arrives, the (N + 1)th query is dispatched.\n          \n          \n            \n                 *\n          \n          \n            \n                 * @param queries a {@link Publisher} stream of queries to be dispatched\n          \n          \n            \n                 * @return a {@link Flux} of query results. The ordering of query results corresponds to the ordering of queries being\n          \n          \n            \n                 * dispatched", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r452707187", "createdAt": "2020-07-10T08:41:57Z", "author": {"login": "smcvb"}, "path": "messaging/src/main/java/org/axonframework/queryhandling/ReactorQueryGateway.java", "diffHunk": "@@ -0,0 +1,547 @@\n+/*\n+ * Copyright (c) 2010-2020. Axon Framework\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.axonframework.queryhandling;\n+\n+import org.axonframework.messaging.ResultMessage;\n+import org.axonframework.messaging.reactive.ReactorMessageDispatchInterceptorSupport;\n+import org.axonframework.messaging.reactive.ReactorResultHandlerInterceptorSupport;\n+import org.axonframework.messaging.responsetypes.ResponseType;\n+import org.axonframework.messaging.responsetypes.ResponseTypes;\n+import org.reactivestreams.Publisher;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Mono;\n+import reactor.util.concurrent.Queues;\n+\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Function;\n+\n+/**\n+ * Variation of {@link QueryGateway}. Provides support for reactive return types such as {@link Mono} and {@link Flux}\n+ * from Project Reactor.\n+ *\n+ * @author Milan Savic\n+ * @since 4.4\n+ */\n+public interface ReactorQueryGateway extends ReactorMessageDispatchInterceptorSupport<QueryMessage<?, ?>>,\n+        ReactorResultHandlerInterceptorSupport<QueryMessage<?, ?>, ResultMessage<?>> {\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response with the given {@code responseType}\n+     * from a single source. The query name will be derived from the provided {@code query}. Execution may be\n+     * asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param query        The {@code query} to be sent\n+     * @param responseType A {@link Class} describing the desired response type\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(Q query, Class<R> responseType) {\n+        return query(query.getClass().getName(), query, responseType);\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response with the given {@code responseType}\n+     * from a single source. Execution may be asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(String queryName, Q query, Class<R> responseType) {\n+        return query(queryName, query, ResponseTypes.instanceOf(responseType));\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from a single source. The query name will be derived from the provided {@code query}. Execution may be\n+     * asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(Q query, ResponseType<R> responseType) {\n+        return query(query.getClass().getName(), query, responseType);\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from a single source. Execution may be asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    <R, Q> Mono<R> query(String queryName, Q query, ResponseType<R> responseType);\n+\n+    /**\n+     * Uses given Publisher of query messages to send incoming queries away. Queries will be sent sequentially - once a\n+     * result of Nth query arrives, (N + 1)th query is dispatched.\n+     *\n+     * @param queries a Publisher stream of queries to be dispatched\n+     * @return a Flux of query results. An ordering of query results corresponds to an ordering of queries being\n+     * dispatched", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "98865ab1427e4d879301c1bf542842eccc8aa3c3"}, "originalPosition": 114}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgyMjY5MTE2OnYy", "diffSide": "RIGHT", "path": "messaging/src/main/java/org/axonframework/queryhandling/ReactorQueryGateway.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xMFQwODo0Mjo0NlrOGvvE_g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yN1QxMDoyMzoyM1rOG3cltA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjcwNzU4Mg==", "bodyText": "You should take into account that the query given here might be a QueryMessage implementation. Thus simply doing query.getClass().getName() might result in QueryMessage as the result, which is not it's intended purpose. I'd recommend to use the QueryMessage#queryName(Object) method to figure out the actual queryName to provider here.", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r452707582", "createdAt": "2020-07-10T08:42:46Z", "author": {"login": "smcvb"}, "path": "messaging/src/main/java/org/axonframework/queryhandling/ReactorQueryGateway.java", "diffHunk": "@@ -0,0 +1,547 @@\n+/*\n+ * Copyright (c) 2010-2020. Axon Framework\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.axonframework.queryhandling;\n+\n+import org.axonframework.messaging.ResultMessage;\n+import org.axonframework.messaging.reactive.ReactorMessageDispatchInterceptorSupport;\n+import org.axonframework.messaging.reactive.ReactorResultHandlerInterceptorSupport;\n+import org.axonframework.messaging.responsetypes.ResponseType;\n+import org.axonframework.messaging.responsetypes.ResponseTypes;\n+import org.reactivestreams.Publisher;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Mono;\n+import reactor.util.concurrent.Queues;\n+\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Function;\n+\n+/**\n+ * Variation of {@link QueryGateway}. Provides support for reactive return types such as {@link Mono} and {@link Flux}\n+ * from Project Reactor.\n+ *\n+ * @author Milan Savic\n+ * @since 4.4\n+ */\n+public interface ReactorQueryGateway extends ReactorMessageDispatchInterceptorSupport<QueryMessage<?, ?>>,\n+        ReactorResultHandlerInterceptorSupport<QueryMessage<?, ?>, ResultMessage<?>> {\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response with the given {@code responseType}\n+     * from a single source. The query name will be derived from the provided {@code query}. Execution may be\n+     * asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param query        The {@code query} to be sent\n+     * @param responseType A {@link Class} describing the desired response type\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(Q query, Class<R> responseType) {\n+        return query(query.getClass().getName(), query, responseType);\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response with the given {@code responseType}\n+     * from a single source. Execution may be asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(String queryName, Q query, Class<R> responseType) {\n+        return query(queryName, query, ResponseTypes.instanceOf(responseType));\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from a single source. The query name will be derived from the provided {@code query}. Execution may be\n+     * asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(Q query, ResponseType<R> responseType) {\n+        return query(query.getClass().getName(), query, responseType);\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from a single source. Execution may be asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    <R, Q> Mono<R> query(String queryName, Q query, ResponseType<R> responseType);\n+\n+    /**\n+     * Uses given Publisher of query messages to send incoming queries away. Queries will be sent sequentially - once a\n+     * result of Nth query arrives, (N + 1)th query is dispatched.\n+     *\n+     * @param queries a Publisher stream of queries to be dispatched\n+     * @return a Flux of query results. An ordering of query results corresponds to an ordering of queries being\n+     * dispatched\n+     *\n+     * @see #query(String, Object, ResponseType)\n+     * @see Flux#concatMap(Function)\n+     */\n+    default Flux<Object> query(Publisher<QueryMessage<?, ?>> queries) {\n+        return Flux.from(queries)\n+                   .concatMap(q -> query(q.getQueryName(), q.getPayload(), q.getResponseType()));\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from several sources. The returned {@link Flux} is completed when a {@code timeout} occurs or when all possible\n+     * results are received. The query name will be derived from the provided {@code query}. Execution may be\n+     * asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     * <b>Note</b>: Any {@code null} results will be filtered out by the {@link ReactorQueryGateway}. If you require\n+     * the {@code null} to be returned, we suggest using {@code QueryBus} instead.\n+     *\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param timeout      A timeout of {@code long} for the query\n+     * @param timeUnit     The selected {@link TimeUnit} for the given {@code timeout}\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Flux} containing the query results as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Flux<R> scatterGather(Q query, ResponseType<R> responseType, long timeout, TimeUnit timeUnit) {\n+        return scatterGather(query.getClass().getName(), query, responseType, timeout, timeUnit);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "98865ab1427e4d879301c1bf542842eccc8aa3c3"}, "originalPosition": 143}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDc5MzI2OA==", "bodyText": "Done!", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r460793268", "createdAt": "2020-07-27T10:23:23Z", "author": {"login": "m1l4n54v1c"}, "path": "messaging/src/main/java/org/axonframework/queryhandling/ReactorQueryGateway.java", "diffHunk": "@@ -0,0 +1,547 @@\n+/*\n+ * Copyright (c) 2010-2020. Axon Framework\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.axonframework.queryhandling;\n+\n+import org.axonframework.messaging.ResultMessage;\n+import org.axonframework.messaging.reactive.ReactorMessageDispatchInterceptorSupport;\n+import org.axonframework.messaging.reactive.ReactorResultHandlerInterceptorSupport;\n+import org.axonframework.messaging.responsetypes.ResponseType;\n+import org.axonframework.messaging.responsetypes.ResponseTypes;\n+import org.reactivestreams.Publisher;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Mono;\n+import reactor.util.concurrent.Queues;\n+\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Function;\n+\n+/**\n+ * Variation of {@link QueryGateway}. Provides support for reactive return types such as {@link Mono} and {@link Flux}\n+ * from Project Reactor.\n+ *\n+ * @author Milan Savic\n+ * @since 4.4\n+ */\n+public interface ReactorQueryGateway extends ReactorMessageDispatchInterceptorSupport<QueryMessage<?, ?>>,\n+        ReactorResultHandlerInterceptorSupport<QueryMessage<?, ?>, ResultMessage<?>> {\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response with the given {@code responseType}\n+     * from a single source. The query name will be derived from the provided {@code query}. Execution may be\n+     * asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param query        The {@code query} to be sent\n+     * @param responseType A {@link Class} describing the desired response type\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(Q query, Class<R> responseType) {\n+        return query(query.getClass().getName(), query, responseType);\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response with the given {@code responseType}\n+     * from a single source. Execution may be asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(String queryName, Q query, Class<R> responseType) {\n+        return query(queryName, query, ResponseTypes.instanceOf(responseType));\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from a single source. The query name will be derived from the provided {@code query}. Execution may be\n+     * asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(Q query, ResponseType<R> responseType) {\n+        return query(query.getClass().getName(), query, responseType);\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from a single source. Execution may be asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    <R, Q> Mono<R> query(String queryName, Q query, ResponseType<R> responseType);\n+\n+    /**\n+     * Uses given Publisher of query messages to send incoming queries away. Queries will be sent sequentially - once a\n+     * result of Nth query arrives, (N + 1)th query is dispatched.\n+     *\n+     * @param queries a Publisher stream of queries to be dispatched\n+     * @return a Flux of query results. An ordering of query results corresponds to an ordering of queries being\n+     * dispatched\n+     *\n+     * @see #query(String, Object, ResponseType)\n+     * @see Flux#concatMap(Function)\n+     */\n+    default Flux<Object> query(Publisher<QueryMessage<?, ?>> queries) {\n+        return Flux.from(queries)\n+                   .concatMap(q -> query(q.getQueryName(), q.getPayload(), q.getResponseType()));\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from several sources. The returned {@link Flux} is completed when a {@code timeout} occurs or when all possible\n+     * results are received. The query name will be derived from the provided {@code query}. Execution may be\n+     * asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     * <b>Note</b>: Any {@code null} results will be filtered out by the {@link ReactorQueryGateway}. If you require\n+     * the {@code null} to be returned, we suggest using {@code QueryBus} instead.\n+     *\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param timeout      A timeout of {@code long} for the query\n+     * @param timeUnit     The selected {@link TimeUnit} for the given {@code timeout}\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Flux} containing the query results as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Flux<R> scatterGather(Q query, ResponseType<R> responseType, long timeout, TimeUnit timeUnit) {\n+        return scatterGather(query.getClass().getName(), query, responseType, timeout, timeUnit);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjcwNzU4Mg=="}, "originalCommit": {"oid": "98865ab1427e4d879301c1bf542842eccc8aa3c3"}, "originalPosition": 143}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgyMjY5NDI3OnYy", "diffSide": "RIGHT", "path": "messaging/src/main/java/org/axonframework/queryhandling/ReactorQueryGateway.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xMFQwODo0Mzo0OFrOGvvHDQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yN1QxMDoyMzo1NVrOG3cmqA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjcwODEwOQ==", "bodyText": "Using \"note\" to start two sentences in a row feels kinda off. Might be nice to rephrase this slightly.", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r452708109", "createdAt": "2020-07-10T08:43:48Z", "author": {"login": "smcvb"}, "path": "messaging/src/main/java/org/axonframework/queryhandling/ReactorQueryGateway.java", "diffHunk": "@@ -0,0 +1,547 @@\n+/*\n+ * Copyright (c) 2010-2020. Axon Framework\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.axonframework.queryhandling;\n+\n+import org.axonframework.messaging.ResultMessage;\n+import org.axonframework.messaging.reactive.ReactorMessageDispatchInterceptorSupport;\n+import org.axonframework.messaging.reactive.ReactorResultHandlerInterceptorSupport;\n+import org.axonframework.messaging.responsetypes.ResponseType;\n+import org.axonframework.messaging.responsetypes.ResponseTypes;\n+import org.reactivestreams.Publisher;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Mono;\n+import reactor.util.concurrent.Queues;\n+\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Function;\n+\n+/**\n+ * Variation of {@link QueryGateway}. Provides support for reactive return types such as {@link Mono} and {@link Flux}\n+ * from Project Reactor.\n+ *\n+ * @author Milan Savic\n+ * @since 4.4\n+ */\n+public interface ReactorQueryGateway extends ReactorMessageDispatchInterceptorSupport<QueryMessage<?, ?>>,\n+        ReactorResultHandlerInterceptorSupport<QueryMessage<?, ?>, ResultMessage<?>> {\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response with the given {@code responseType}\n+     * from a single source. The query name will be derived from the provided {@code query}. Execution may be\n+     * asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param query        The {@code query} to be sent\n+     * @param responseType A {@link Class} describing the desired response type\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(Q query, Class<R> responseType) {\n+        return query(query.getClass().getName(), query, responseType);\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response with the given {@code responseType}\n+     * from a single source. Execution may be asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(String queryName, Q query, Class<R> responseType) {\n+        return query(queryName, query, ResponseTypes.instanceOf(responseType));\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from a single source. The query name will be derived from the provided {@code query}. Execution may be\n+     * asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(Q query, ResponseType<R> responseType) {\n+        return query(query.getClass().getName(), query, responseType);\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from a single source. Execution may be asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    <R, Q> Mono<R> query(String queryName, Q query, ResponseType<R> responseType);\n+\n+    /**\n+     * Uses given Publisher of query messages to send incoming queries away. Queries will be sent sequentially - once a\n+     * result of Nth query arrives, (N + 1)th query is dispatched.\n+     *\n+     * @param queries a Publisher stream of queries to be dispatched\n+     * @return a Flux of query results. An ordering of query results corresponds to an ordering of queries being\n+     * dispatched\n+     *\n+     * @see #query(String, Object, ResponseType)\n+     * @see Flux#concatMap(Function)\n+     */\n+    default Flux<Object> query(Publisher<QueryMessage<?, ?>> queries) {\n+        return Flux.from(queries)\n+                   .concatMap(q -> query(q.getQueryName(), q.getPayload(), q.getResponseType()));\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from several sources. The returned {@link Flux} is completed when a {@code timeout} occurs or when all possible\n+     * results are received. The query name will be derived from the provided {@code query}. Execution may be\n+     * asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     * <b>Note</b>: Any {@code null} results will be filtered out by the {@link ReactorQueryGateway}. If you require\n+     * the {@code null} to be returned, we suggest using {@code QueryBus} instead.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "98865ab1427e4d879301c1bf542842eccc8aa3c3"}, "originalPosition": 132}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDc5MzUxMg==", "bodyText": "Addressed.", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r460793512", "createdAt": "2020-07-27T10:23:55Z", "author": {"login": "m1l4n54v1c"}, "path": "messaging/src/main/java/org/axonframework/queryhandling/ReactorQueryGateway.java", "diffHunk": "@@ -0,0 +1,547 @@\n+/*\n+ * Copyright (c) 2010-2020. Axon Framework\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.axonframework.queryhandling;\n+\n+import org.axonframework.messaging.ResultMessage;\n+import org.axonframework.messaging.reactive.ReactorMessageDispatchInterceptorSupport;\n+import org.axonframework.messaging.reactive.ReactorResultHandlerInterceptorSupport;\n+import org.axonframework.messaging.responsetypes.ResponseType;\n+import org.axonframework.messaging.responsetypes.ResponseTypes;\n+import org.reactivestreams.Publisher;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Mono;\n+import reactor.util.concurrent.Queues;\n+\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Function;\n+\n+/**\n+ * Variation of {@link QueryGateway}. Provides support for reactive return types such as {@link Mono} and {@link Flux}\n+ * from Project Reactor.\n+ *\n+ * @author Milan Savic\n+ * @since 4.4\n+ */\n+public interface ReactorQueryGateway extends ReactorMessageDispatchInterceptorSupport<QueryMessage<?, ?>>,\n+        ReactorResultHandlerInterceptorSupport<QueryMessage<?, ?>, ResultMessage<?>> {\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response with the given {@code responseType}\n+     * from a single source. The query name will be derived from the provided {@code query}. Execution may be\n+     * asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param query        The {@code query} to be sent\n+     * @param responseType A {@link Class} describing the desired response type\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(Q query, Class<R> responseType) {\n+        return query(query.getClass().getName(), query, responseType);\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response with the given {@code responseType}\n+     * from a single source. Execution may be asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(String queryName, Q query, Class<R> responseType) {\n+        return query(queryName, query, ResponseTypes.instanceOf(responseType));\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from a single source. The query name will be derived from the provided {@code query}. Execution may be\n+     * asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(Q query, ResponseType<R> responseType) {\n+        return query(query.getClass().getName(), query, responseType);\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from a single source. Execution may be asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    <R, Q> Mono<R> query(String queryName, Q query, ResponseType<R> responseType);\n+\n+    /**\n+     * Uses given Publisher of query messages to send incoming queries away. Queries will be sent sequentially - once a\n+     * result of Nth query arrives, (N + 1)th query is dispatched.\n+     *\n+     * @param queries a Publisher stream of queries to be dispatched\n+     * @return a Flux of query results. An ordering of query results corresponds to an ordering of queries being\n+     * dispatched\n+     *\n+     * @see #query(String, Object, ResponseType)\n+     * @see Flux#concatMap(Function)\n+     */\n+    default Flux<Object> query(Publisher<QueryMessage<?, ?>> queries) {\n+        return Flux.from(queries)\n+                   .concatMap(q -> query(q.getQueryName(), q.getPayload(), q.getResponseType()));\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from several sources. The returned {@link Flux} is completed when a {@code timeout} occurs or when all possible\n+     * results are received. The query name will be derived from the provided {@code query}. Execution may be\n+     * asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     * <b>Note</b>: Any {@code null} results will be filtered out by the {@link ReactorQueryGateway}. If you require\n+     * the {@code null} to be returned, we suggest using {@code QueryBus} instead.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjcwODEwOQ=="}, "originalCommit": {"oid": "98865ab1427e4d879301c1bf542842eccc8aa3c3"}, "originalPosition": 132}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgyMjcwMDAzOnYy", "diffSide": "RIGHT", "path": "messaging/src/main/java/org/axonframework/queryhandling/ReactorQueryGateway.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xMFQwODo0NToyM1rOGvvKZQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yN1QxMDoyNDowMVrOG3cm3A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjcwODk2NQ==", "bodyText": "Using \"note\" to start two sentences in a row feels kinda off. Might be nice to rephrase this slightly.", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r452708965", "createdAt": "2020-07-10T08:45:23Z", "author": {"login": "smcvb"}, "path": "messaging/src/main/java/org/axonframework/queryhandling/ReactorQueryGateway.java", "diffHunk": "@@ -0,0 +1,547 @@\n+/*\n+ * Copyright (c) 2010-2020. Axon Framework\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.axonframework.queryhandling;\n+\n+import org.axonframework.messaging.ResultMessage;\n+import org.axonframework.messaging.reactive.ReactorMessageDispatchInterceptorSupport;\n+import org.axonframework.messaging.reactive.ReactorResultHandlerInterceptorSupport;\n+import org.axonframework.messaging.responsetypes.ResponseType;\n+import org.axonframework.messaging.responsetypes.ResponseTypes;\n+import org.reactivestreams.Publisher;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Mono;\n+import reactor.util.concurrent.Queues;\n+\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Function;\n+\n+/**\n+ * Variation of {@link QueryGateway}. Provides support for reactive return types such as {@link Mono} and {@link Flux}\n+ * from Project Reactor.\n+ *\n+ * @author Milan Savic\n+ * @since 4.4\n+ */\n+public interface ReactorQueryGateway extends ReactorMessageDispatchInterceptorSupport<QueryMessage<?, ?>>,\n+        ReactorResultHandlerInterceptorSupport<QueryMessage<?, ?>, ResultMessage<?>> {\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response with the given {@code responseType}\n+     * from a single source. The query name will be derived from the provided {@code query}. Execution may be\n+     * asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param query        The {@code query} to be sent\n+     * @param responseType A {@link Class} describing the desired response type\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(Q query, Class<R> responseType) {\n+        return query(query.getClass().getName(), query, responseType);\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response with the given {@code responseType}\n+     * from a single source. Execution may be asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(String queryName, Q query, Class<R> responseType) {\n+        return query(queryName, query, ResponseTypes.instanceOf(responseType));\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from a single source. The query name will be derived from the provided {@code query}. Execution may be\n+     * asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(Q query, ResponseType<R> responseType) {\n+        return query(query.getClass().getName(), query, responseType);\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from a single source. Execution may be asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    <R, Q> Mono<R> query(String queryName, Q query, ResponseType<R> responseType);\n+\n+    /**\n+     * Uses given Publisher of query messages to send incoming queries away. Queries will be sent sequentially - once a\n+     * result of Nth query arrives, (N + 1)th query is dispatched.\n+     *\n+     * @param queries a Publisher stream of queries to be dispatched\n+     * @return a Flux of query results. An ordering of query results corresponds to an ordering of queries being\n+     * dispatched\n+     *\n+     * @see #query(String, Object, ResponseType)\n+     * @see Flux#concatMap(Function)\n+     */\n+    default Flux<Object> query(Publisher<QueryMessage<?, ?>> queries) {\n+        return Flux.from(queries)\n+                   .concatMap(q -> query(q.getQueryName(), q.getPayload(), q.getResponseType()));\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from several sources. The returned {@link Flux} is completed when a {@code timeout} occurs or when all possible\n+     * results are received. The query name will be derived from the provided {@code query}. Execution may be\n+     * asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     * <b>Note</b>: Any {@code null} results will be filtered out by the {@link ReactorQueryGateway}. If you require\n+     * the {@code null} to be returned, we suggest using {@code QueryBus} instead.\n+     *\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param timeout      A timeout of {@code long} for the query\n+     * @param timeUnit     The selected {@link TimeUnit} for the given {@code timeout}\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Flux} containing the query results as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Flux<R> scatterGather(Q query, ResponseType<R> responseType, long timeout, TimeUnit timeUnit) {\n+        return scatterGather(query.getClass().getName(), query, responseType, timeout, timeUnit);\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from several sources. The returned {@link Flux} is completed when a {@code timeout} occurs or when all results\n+     * are received. Execution may be asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     * <b>Note</b>: Any {@code null} results will be filtered out by the {@link ReactorQueryGateway}. If you require\n+     * the {@code null} to be returned, we suggest using {@code QueryBus} instead.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "98865ab1427e4d879301c1bf542842eccc8aa3c3"}, "originalPosition": 153}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDc5MzU2NA==", "bodyText": "Addressed.", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r460793564", "createdAt": "2020-07-27T10:24:01Z", "author": {"login": "m1l4n54v1c"}, "path": "messaging/src/main/java/org/axonframework/queryhandling/ReactorQueryGateway.java", "diffHunk": "@@ -0,0 +1,547 @@\n+/*\n+ * Copyright (c) 2010-2020. Axon Framework\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.axonframework.queryhandling;\n+\n+import org.axonframework.messaging.ResultMessage;\n+import org.axonframework.messaging.reactive.ReactorMessageDispatchInterceptorSupport;\n+import org.axonframework.messaging.reactive.ReactorResultHandlerInterceptorSupport;\n+import org.axonframework.messaging.responsetypes.ResponseType;\n+import org.axonframework.messaging.responsetypes.ResponseTypes;\n+import org.reactivestreams.Publisher;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Mono;\n+import reactor.util.concurrent.Queues;\n+\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Function;\n+\n+/**\n+ * Variation of {@link QueryGateway}. Provides support for reactive return types such as {@link Mono} and {@link Flux}\n+ * from Project Reactor.\n+ *\n+ * @author Milan Savic\n+ * @since 4.4\n+ */\n+public interface ReactorQueryGateway extends ReactorMessageDispatchInterceptorSupport<QueryMessage<?, ?>>,\n+        ReactorResultHandlerInterceptorSupport<QueryMessage<?, ?>, ResultMessage<?>> {\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response with the given {@code responseType}\n+     * from a single source. The query name will be derived from the provided {@code query}. Execution may be\n+     * asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param query        The {@code query} to be sent\n+     * @param responseType A {@link Class} describing the desired response type\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(Q query, Class<R> responseType) {\n+        return query(query.getClass().getName(), query, responseType);\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response with the given {@code responseType}\n+     * from a single source. Execution may be asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(String queryName, Q query, Class<R> responseType) {\n+        return query(queryName, query, ResponseTypes.instanceOf(responseType));\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from a single source. The query name will be derived from the provided {@code query}. Execution may be\n+     * asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(Q query, ResponseType<R> responseType) {\n+        return query(query.getClass().getName(), query, responseType);\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from a single source. Execution may be asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    <R, Q> Mono<R> query(String queryName, Q query, ResponseType<R> responseType);\n+\n+    /**\n+     * Uses given Publisher of query messages to send incoming queries away. Queries will be sent sequentially - once a\n+     * result of Nth query arrives, (N + 1)th query is dispatched.\n+     *\n+     * @param queries a Publisher stream of queries to be dispatched\n+     * @return a Flux of query results. An ordering of query results corresponds to an ordering of queries being\n+     * dispatched\n+     *\n+     * @see #query(String, Object, ResponseType)\n+     * @see Flux#concatMap(Function)\n+     */\n+    default Flux<Object> query(Publisher<QueryMessage<?, ?>> queries) {\n+        return Flux.from(queries)\n+                   .concatMap(q -> query(q.getQueryName(), q.getPayload(), q.getResponseType()));\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from several sources. The returned {@link Flux} is completed when a {@code timeout} occurs or when all possible\n+     * results are received. The query name will be derived from the provided {@code query}. Execution may be\n+     * asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     * <b>Note</b>: Any {@code null} results will be filtered out by the {@link ReactorQueryGateway}. If you require\n+     * the {@code null} to be returned, we suggest using {@code QueryBus} instead.\n+     *\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param timeout      A timeout of {@code long} for the query\n+     * @param timeUnit     The selected {@link TimeUnit} for the given {@code timeout}\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Flux} containing the query results as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Flux<R> scatterGather(Q query, ResponseType<R> responseType, long timeout, TimeUnit timeUnit) {\n+        return scatterGather(query.getClass().getName(), query, responseType, timeout, timeUnit);\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from several sources. The returned {@link Flux} is completed when a {@code timeout} occurs or when all results\n+     * are received. Execution may be asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     * <b>Note</b>: Any {@code null} results will be filtered out by the {@link ReactorQueryGateway}. If you require\n+     * the {@code null} to be returned, we suggest using {@code QueryBus} instead.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjcwODk2NQ=="}, "originalCommit": {"oid": "98865ab1427e4d879301c1bf542842eccc8aa3c3"}, "originalPosition": 153}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgyMjcwNDQ4OnYy", "diffSide": "RIGHT", "path": "messaging/src/main/java/org/axonframework/queryhandling/ReactorQueryGateway.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xMFQwODo0Njo0MlrOGvvNIw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xMFQwODo0Njo0MlrOGvvNIw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjcwOTY2Nw==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * Uses given Publisher of queries to send incoming queries in scatter gather manner. Queries will be sent\n          \n          \n            \n                 * sequentially - once a result of Nth query arrives, (N + 1)th query is dispatched. All queries will be dispatched\n          \n          \n            \n                 * using given {@code timeout} and {@code timeUnit}.\n          \n          \n            \n                 *\n          \n          \n            \n                 * @param queries  a Publisher stream of queries to be dispatched\n          \n          \n            \n                 * @param timeout  A timeout of {@code long} for the query\n          \n          \n            \n                 * @param timeUnit The selected {@link TimeUnit} for the given {@code timeout}\n          \n          \n            \n                 * @return a Flux of query results. An ordering of query results corresponds to an ordering of queries being\n          \n          \n            \n                 * dispatched\n          \n          \n            \n                 * Uses the given {@link Publisher} of {@link QueryMessage}s to send incoming queries in scatter gather manner. Queries will be sent\n          \n          \n            \n                 * sequentially. Once the result of Nth query arrives, the (N + 1)th query is dispatched. All queries will be dispatched\n          \n          \n            \n                 * using given {@code timeout} and {@code timeUnit}.\n          \n          \n            \n                 *\n          \n          \n            \n                 * @param queries  a {@link Publisher} stream of queries to be dispatched\n          \n          \n            \n                 * @param timeout  A timeout of {@code long} for the query\n          \n          \n            \n                 * @param timeUnit The selected {@link TimeUnit} for the given {@code timeout}\n          \n          \n            \n                 * @return a {@link Flux} of query results. The ordering of query results corresponds to the ordering of queries being\n          \n          \n            \n                 * dispatched", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r452709667", "createdAt": "2020-07-10T08:46:42Z", "author": {"login": "smcvb"}, "path": "messaging/src/main/java/org/axonframework/queryhandling/ReactorQueryGateway.java", "diffHunk": "@@ -0,0 +1,547 @@\n+/*\n+ * Copyright (c) 2010-2020. Axon Framework\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.axonframework.queryhandling;\n+\n+import org.axonframework.messaging.ResultMessage;\n+import org.axonframework.messaging.reactive.ReactorMessageDispatchInterceptorSupport;\n+import org.axonframework.messaging.reactive.ReactorResultHandlerInterceptorSupport;\n+import org.axonframework.messaging.responsetypes.ResponseType;\n+import org.axonframework.messaging.responsetypes.ResponseTypes;\n+import org.reactivestreams.Publisher;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Mono;\n+import reactor.util.concurrent.Queues;\n+\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Function;\n+\n+/**\n+ * Variation of {@link QueryGateway}. Provides support for reactive return types such as {@link Mono} and {@link Flux}\n+ * from Project Reactor.\n+ *\n+ * @author Milan Savic\n+ * @since 4.4\n+ */\n+public interface ReactorQueryGateway extends ReactorMessageDispatchInterceptorSupport<QueryMessage<?, ?>>,\n+        ReactorResultHandlerInterceptorSupport<QueryMessage<?, ?>, ResultMessage<?>> {\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response with the given {@code responseType}\n+     * from a single source. The query name will be derived from the provided {@code query}. Execution may be\n+     * asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param query        The {@code query} to be sent\n+     * @param responseType A {@link Class} describing the desired response type\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(Q query, Class<R> responseType) {\n+        return query(query.getClass().getName(), query, responseType);\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response with the given {@code responseType}\n+     * from a single source. Execution may be asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(String queryName, Q query, Class<R> responseType) {\n+        return query(queryName, query, ResponseTypes.instanceOf(responseType));\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from a single source. The query name will be derived from the provided {@code query}. Execution may be\n+     * asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(Q query, ResponseType<R> responseType) {\n+        return query(query.getClass().getName(), query, responseType);\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from a single source. Execution may be asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    <R, Q> Mono<R> query(String queryName, Q query, ResponseType<R> responseType);\n+\n+    /**\n+     * Uses given Publisher of query messages to send incoming queries away. Queries will be sent sequentially - once a\n+     * result of Nth query arrives, (N + 1)th query is dispatched.\n+     *\n+     * @param queries a Publisher stream of queries to be dispatched\n+     * @return a Flux of query results. An ordering of query results corresponds to an ordering of queries being\n+     * dispatched\n+     *\n+     * @see #query(String, Object, ResponseType)\n+     * @see Flux#concatMap(Function)\n+     */\n+    default Flux<Object> query(Publisher<QueryMessage<?, ?>> queries) {\n+        return Flux.from(queries)\n+                   .concatMap(q -> query(q.getQueryName(), q.getPayload(), q.getResponseType()));\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from several sources. The returned {@link Flux} is completed when a {@code timeout} occurs or when all possible\n+     * results are received. The query name will be derived from the provided {@code query}. Execution may be\n+     * asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     * <b>Note</b>: Any {@code null} results will be filtered out by the {@link ReactorQueryGateway}. If you require\n+     * the {@code null} to be returned, we suggest using {@code QueryBus} instead.\n+     *\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param timeout      A timeout of {@code long} for the query\n+     * @param timeUnit     The selected {@link TimeUnit} for the given {@code timeout}\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Flux} containing the query results as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Flux<R> scatterGather(Q query, ResponseType<R> responseType, long timeout, TimeUnit timeUnit) {\n+        return scatterGather(query.getClass().getName(), query, responseType, timeout, timeUnit);\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from several sources. The returned {@link Flux} is completed when a {@code timeout} occurs or when all results\n+     * are received. Execution may be asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     * <b>Note</b>: Any {@code null} results will be filtered out by the {@link ReactorQueryGateway}. If you require\n+     * the {@code null} to be returned, we suggest using {@code QueryBus} instead.\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param timeout      A timeout of {@code long} for the query\n+     * @param timeUnit     The selected {@link TimeUnit} for the given {@code timeout}\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Flux} containing the query results as dictated by the given {@code responseType}\n+     */\n+    <R, Q> Flux<R> scatterGather(String queryName, Q query, ResponseType<R> responseType, long timeout,\n+                                 TimeUnit timeUnit);\n+\n+    /**\n+     * Uses given Publisher of queries to send incoming queries in scatter gather manner. Queries will be sent\n+     * sequentially - once a result of Nth query arrives, (N + 1)th query is dispatched. All queries will be dispatched\n+     * using given {@code timeout} and {@code timeUnit}.\n+     *\n+     * @param queries  a Publisher stream of queries to be dispatched\n+     * @param timeout  A timeout of {@code long} for the query\n+     * @param timeUnit The selected {@link TimeUnit} for the given {@code timeout}\n+     * @return a Flux of query results. An ordering of query results corresponds to an ordering of queries being\n+     * dispatched", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "98865ab1427e4d879301c1bf542842eccc8aa3c3"}, "originalPosition": 176}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgyMjcwNzI1OnYy", "diffSide": "RIGHT", "path": "messaging/src/main/java/org/axonframework/queryhandling/ReactorQueryGateway.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xMFQwODo0Nzo0MFrOGvvO_g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yN1QxMDozMjozOFrOG3c5HA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjcxMDE0Mg==", "bodyText": "Why is there no reference to the concatMap operation, like on the Flux<Object> query(Publisher<QueryMessage<?, ?>> queries) javadoc?", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r452710142", "createdAt": "2020-07-10T08:47:40Z", "author": {"login": "smcvb"}, "path": "messaging/src/main/java/org/axonframework/queryhandling/ReactorQueryGateway.java", "diffHunk": "@@ -0,0 +1,547 @@\n+/*\n+ * Copyright (c) 2010-2020. Axon Framework\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.axonframework.queryhandling;\n+\n+import org.axonframework.messaging.ResultMessage;\n+import org.axonframework.messaging.reactive.ReactorMessageDispatchInterceptorSupport;\n+import org.axonframework.messaging.reactive.ReactorResultHandlerInterceptorSupport;\n+import org.axonframework.messaging.responsetypes.ResponseType;\n+import org.axonframework.messaging.responsetypes.ResponseTypes;\n+import org.reactivestreams.Publisher;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Mono;\n+import reactor.util.concurrent.Queues;\n+\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Function;\n+\n+/**\n+ * Variation of {@link QueryGateway}. Provides support for reactive return types such as {@link Mono} and {@link Flux}\n+ * from Project Reactor.\n+ *\n+ * @author Milan Savic\n+ * @since 4.4\n+ */\n+public interface ReactorQueryGateway extends ReactorMessageDispatchInterceptorSupport<QueryMessage<?, ?>>,\n+        ReactorResultHandlerInterceptorSupport<QueryMessage<?, ?>, ResultMessage<?>> {\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response with the given {@code responseType}\n+     * from a single source. The query name will be derived from the provided {@code query}. Execution may be\n+     * asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param query        The {@code query} to be sent\n+     * @param responseType A {@link Class} describing the desired response type\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(Q query, Class<R> responseType) {\n+        return query(query.getClass().getName(), query, responseType);\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response with the given {@code responseType}\n+     * from a single source. Execution may be asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(String queryName, Q query, Class<R> responseType) {\n+        return query(queryName, query, ResponseTypes.instanceOf(responseType));\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from a single source. The query name will be derived from the provided {@code query}. Execution may be\n+     * asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(Q query, ResponseType<R> responseType) {\n+        return query(query.getClass().getName(), query, responseType);\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from a single source. Execution may be asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    <R, Q> Mono<R> query(String queryName, Q query, ResponseType<R> responseType);\n+\n+    /**\n+     * Uses given Publisher of query messages to send incoming queries away. Queries will be sent sequentially - once a\n+     * result of Nth query arrives, (N + 1)th query is dispatched.\n+     *\n+     * @param queries a Publisher stream of queries to be dispatched\n+     * @return a Flux of query results. An ordering of query results corresponds to an ordering of queries being\n+     * dispatched\n+     *\n+     * @see #query(String, Object, ResponseType)\n+     * @see Flux#concatMap(Function)\n+     */\n+    default Flux<Object> query(Publisher<QueryMessage<?, ?>> queries) {\n+        return Flux.from(queries)\n+                   .concatMap(q -> query(q.getQueryName(), q.getPayload(), q.getResponseType()));\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from several sources. The returned {@link Flux} is completed when a {@code timeout} occurs or when all possible\n+     * results are received. The query name will be derived from the provided {@code query}. Execution may be\n+     * asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     * <b>Note</b>: Any {@code null} results will be filtered out by the {@link ReactorQueryGateway}. If you require\n+     * the {@code null} to be returned, we suggest using {@code QueryBus} instead.\n+     *\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param timeout      A timeout of {@code long} for the query\n+     * @param timeUnit     The selected {@link TimeUnit} for the given {@code timeout}\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Flux} containing the query results as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Flux<R> scatterGather(Q query, ResponseType<R> responseType, long timeout, TimeUnit timeUnit) {\n+        return scatterGather(query.getClass().getName(), query, responseType, timeout, timeUnit);\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from several sources. The returned {@link Flux} is completed when a {@code timeout} occurs or when all results\n+     * are received. Execution may be asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     * <b>Note</b>: Any {@code null} results will be filtered out by the {@link ReactorQueryGateway}. If you require\n+     * the {@code null} to be returned, we suggest using {@code QueryBus} instead.\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param timeout      A timeout of {@code long} for the query\n+     * @param timeUnit     The selected {@link TimeUnit} for the given {@code timeout}\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Flux} containing the query results as dictated by the given {@code responseType}\n+     */\n+    <R, Q> Flux<R> scatterGather(String queryName, Q query, ResponseType<R> responseType, long timeout,\n+                                 TimeUnit timeUnit);\n+\n+    /**\n+     * Uses given Publisher of queries to send incoming queries in scatter gather manner. Queries will be sent\n+     * sequentially - once a result of Nth query arrives, (N + 1)th query is dispatched. All queries will be dispatched\n+     * using given {@code timeout} and {@code timeUnit}.\n+     *\n+     * @param queries  a Publisher stream of queries to be dispatched\n+     * @param timeout  A timeout of {@code long} for the query\n+     * @param timeUnit The selected {@link TimeUnit} for the given {@code timeout}\n+     * @return a Flux of query results. An ordering of query results corresponds to an ordering of queries being\n+     * dispatched\n+     */", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "98865ab1427e4d879301c1bf542842eccc8aa3c3"}, "originalPosition": 177}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDc5ODIzNg==", "bodyText": "Because I forgot :/ Adding it :)", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r460798236", "createdAt": "2020-07-27T10:32:38Z", "author": {"login": "m1l4n54v1c"}, "path": "messaging/src/main/java/org/axonframework/queryhandling/ReactorQueryGateway.java", "diffHunk": "@@ -0,0 +1,547 @@\n+/*\n+ * Copyright (c) 2010-2020. Axon Framework\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.axonframework.queryhandling;\n+\n+import org.axonframework.messaging.ResultMessage;\n+import org.axonframework.messaging.reactive.ReactorMessageDispatchInterceptorSupport;\n+import org.axonframework.messaging.reactive.ReactorResultHandlerInterceptorSupport;\n+import org.axonframework.messaging.responsetypes.ResponseType;\n+import org.axonframework.messaging.responsetypes.ResponseTypes;\n+import org.reactivestreams.Publisher;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Mono;\n+import reactor.util.concurrent.Queues;\n+\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Function;\n+\n+/**\n+ * Variation of {@link QueryGateway}. Provides support for reactive return types such as {@link Mono} and {@link Flux}\n+ * from Project Reactor.\n+ *\n+ * @author Milan Savic\n+ * @since 4.4\n+ */\n+public interface ReactorQueryGateway extends ReactorMessageDispatchInterceptorSupport<QueryMessage<?, ?>>,\n+        ReactorResultHandlerInterceptorSupport<QueryMessage<?, ?>, ResultMessage<?>> {\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response with the given {@code responseType}\n+     * from a single source. The query name will be derived from the provided {@code query}. Execution may be\n+     * asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param query        The {@code query} to be sent\n+     * @param responseType A {@link Class} describing the desired response type\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(Q query, Class<R> responseType) {\n+        return query(query.getClass().getName(), query, responseType);\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response with the given {@code responseType}\n+     * from a single source. Execution may be asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(String queryName, Q query, Class<R> responseType) {\n+        return query(queryName, query, ResponseTypes.instanceOf(responseType));\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from a single source. The query name will be derived from the provided {@code query}. Execution may be\n+     * asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(Q query, ResponseType<R> responseType) {\n+        return query(query.getClass().getName(), query, responseType);\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from a single source. Execution may be asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    <R, Q> Mono<R> query(String queryName, Q query, ResponseType<R> responseType);\n+\n+    /**\n+     * Uses given Publisher of query messages to send incoming queries away. Queries will be sent sequentially - once a\n+     * result of Nth query arrives, (N + 1)th query is dispatched.\n+     *\n+     * @param queries a Publisher stream of queries to be dispatched\n+     * @return a Flux of query results. An ordering of query results corresponds to an ordering of queries being\n+     * dispatched\n+     *\n+     * @see #query(String, Object, ResponseType)\n+     * @see Flux#concatMap(Function)\n+     */\n+    default Flux<Object> query(Publisher<QueryMessage<?, ?>> queries) {\n+        return Flux.from(queries)\n+                   .concatMap(q -> query(q.getQueryName(), q.getPayload(), q.getResponseType()));\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from several sources. The returned {@link Flux} is completed when a {@code timeout} occurs or when all possible\n+     * results are received. The query name will be derived from the provided {@code query}. Execution may be\n+     * asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     * <b>Note</b>: Any {@code null} results will be filtered out by the {@link ReactorQueryGateway}. If you require\n+     * the {@code null} to be returned, we suggest using {@code QueryBus} instead.\n+     *\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param timeout      A timeout of {@code long} for the query\n+     * @param timeUnit     The selected {@link TimeUnit} for the given {@code timeout}\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Flux} containing the query results as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Flux<R> scatterGather(Q query, ResponseType<R> responseType, long timeout, TimeUnit timeUnit) {\n+        return scatterGather(query.getClass().getName(), query, responseType, timeout, timeUnit);\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from several sources. The returned {@link Flux} is completed when a {@code timeout} occurs or when all results\n+     * are received. Execution may be asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     * <b>Note</b>: Any {@code null} results will be filtered out by the {@link ReactorQueryGateway}. If you require\n+     * the {@code null} to be returned, we suggest using {@code QueryBus} instead.\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param timeout      A timeout of {@code long} for the query\n+     * @param timeUnit     The selected {@link TimeUnit} for the given {@code timeout}\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Flux} containing the query results as dictated by the given {@code responseType}\n+     */\n+    <R, Q> Flux<R> scatterGather(String queryName, Q query, ResponseType<R> responseType, long timeout,\n+                                 TimeUnit timeUnit);\n+\n+    /**\n+     * Uses given Publisher of queries to send incoming queries in scatter gather manner. Queries will be sent\n+     * sequentially - once a result of Nth query arrives, (N + 1)th query is dispatched. All queries will be dispatched\n+     * using given {@code timeout} and {@code timeUnit}.\n+     *\n+     * @param queries  a Publisher stream of queries to be dispatched\n+     * @param timeout  A timeout of {@code long} for the query\n+     * @param timeUnit The selected {@link TimeUnit} for the given {@code timeout}\n+     * @return a Flux of query results. An ordering of query results corresponds to an ordering of queries being\n+     * dispatched\n+     */", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjcxMDE0Mg=="}, "originalCommit": {"oid": "98865ab1427e4d879301c1bf542842eccc8aa3c3"}, "originalPosition": 177}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgyMjcxMzc2OnYy", "diffSide": "RIGHT", "path": "messaging/src/main/java/org/axonframework/queryhandling/ReactorQueryGateway.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xMFQwODo0OTo0NlrOGvvS6A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xMFQwODo0OTo0NlrOGvvS6A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjcxMTE0NA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * Sends the given {@code query} over the {@link QueryBus}, returns initial result and keeps streaming\n          \n          \n            \n                 * incremental updates until subscriber unsubscribes from Flux.\n          \n          \n            \n                 * Should be used when response type of initial result and incremental update match.\n          \n          \n            \n                 * Sends the given {@code query} over the {@link QueryBus}, returning the initial result and a stream of\n          \n          \n            \n                 * incremental updates until the subscriber unsubscribes from the resulting {@link Flux}.\n          \n          \n            \n                 * Should be used when the response type of the initial result and incremental update match.", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r452711144", "createdAt": "2020-07-10T08:49:46Z", "author": {"login": "smcvb"}, "path": "messaging/src/main/java/org/axonframework/queryhandling/ReactorQueryGateway.java", "diffHunk": "@@ -0,0 +1,547 @@\n+/*\n+ * Copyright (c) 2010-2020. Axon Framework\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.axonframework.queryhandling;\n+\n+import org.axonframework.messaging.ResultMessage;\n+import org.axonframework.messaging.reactive.ReactorMessageDispatchInterceptorSupport;\n+import org.axonframework.messaging.reactive.ReactorResultHandlerInterceptorSupport;\n+import org.axonframework.messaging.responsetypes.ResponseType;\n+import org.axonframework.messaging.responsetypes.ResponseTypes;\n+import org.reactivestreams.Publisher;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Mono;\n+import reactor.util.concurrent.Queues;\n+\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Function;\n+\n+/**\n+ * Variation of {@link QueryGateway}. Provides support for reactive return types such as {@link Mono} and {@link Flux}\n+ * from Project Reactor.\n+ *\n+ * @author Milan Savic\n+ * @since 4.4\n+ */\n+public interface ReactorQueryGateway extends ReactorMessageDispatchInterceptorSupport<QueryMessage<?, ?>>,\n+        ReactorResultHandlerInterceptorSupport<QueryMessage<?, ?>, ResultMessage<?>> {\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response with the given {@code responseType}\n+     * from a single source. The query name will be derived from the provided {@code query}. Execution may be\n+     * asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param query        The {@code query} to be sent\n+     * @param responseType A {@link Class} describing the desired response type\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(Q query, Class<R> responseType) {\n+        return query(query.getClass().getName(), query, responseType);\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response with the given {@code responseType}\n+     * from a single source. Execution may be asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(String queryName, Q query, Class<R> responseType) {\n+        return query(queryName, query, ResponseTypes.instanceOf(responseType));\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from a single source. The query name will be derived from the provided {@code query}. Execution may be\n+     * asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(Q query, ResponseType<R> responseType) {\n+        return query(query.getClass().getName(), query, responseType);\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from a single source. Execution may be asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    <R, Q> Mono<R> query(String queryName, Q query, ResponseType<R> responseType);\n+\n+    /**\n+     * Uses given Publisher of query messages to send incoming queries away. Queries will be sent sequentially - once a\n+     * result of Nth query arrives, (N + 1)th query is dispatched.\n+     *\n+     * @param queries a Publisher stream of queries to be dispatched\n+     * @return a Flux of query results. An ordering of query results corresponds to an ordering of queries being\n+     * dispatched\n+     *\n+     * @see #query(String, Object, ResponseType)\n+     * @see Flux#concatMap(Function)\n+     */\n+    default Flux<Object> query(Publisher<QueryMessage<?, ?>> queries) {\n+        return Flux.from(queries)\n+                   .concatMap(q -> query(q.getQueryName(), q.getPayload(), q.getResponseType()));\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from several sources. The returned {@link Flux} is completed when a {@code timeout} occurs or when all possible\n+     * results are received. The query name will be derived from the provided {@code query}. Execution may be\n+     * asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     * <b>Note</b>: Any {@code null} results will be filtered out by the {@link ReactorQueryGateway}. If you require\n+     * the {@code null} to be returned, we suggest using {@code QueryBus} instead.\n+     *\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param timeout      A timeout of {@code long} for the query\n+     * @param timeUnit     The selected {@link TimeUnit} for the given {@code timeout}\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Flux} containing the query results as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Flux<R> scatterGather(Q query, ResponseType<R> responseType, long timeout, TimeUnit timeUnit) {\n+        return scatterGather(query.getClass().getName(), query, responseType, timeout, timeUnit);\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from several sources. The returned {@link Flux} is completed when a {@code timeout} occurs or when all results\n+     * are received. Execution may be asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     * <b>Note</b>: Any {@code null} results will be filtered out by the {@link ReactorQueryGateway}. If you require\n+     * the {@code null} to be returned, we suggest using {@code QueryBus} instead.\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param timeout      A timeout of {@code long} for the query\n+     * @param timeUnit     The selected {@link TimeUnit} for the given {@code timeout}\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Flux} containing the query results as dictated by the given {@code responseType}\n+     */\n+    <R, Q> Flux<R> scatterGather(String queryName, Q query, ResponseType<R> responseType, long timeout,\n+                                 TimeUnit timeUnit);\n+\n+    /**\n+     * Uses given Publisher of queries to send incoming queries in scatter gather manner. Queries will be sent\n+     * sequentially - once a result of Nth query arrives, (N + 1)th query is dispatched. All queries will be dispatched\n+     * using given {@code timeout} and {@code timeUnit}.\n+     *\n+     * @param queries  a Publisher stream of queries to be dispatched\n+     * @param timeout  A timeout of {@code long} for the query\n+     * @param timeUnit The selected {@link TimeUnit} for the given {@code timeout}\n+     * @return a Flux of query results. An ordering of query results corresponds to an ordering of queries being\n+     * dispatched\n+     */\n+    default Flux<Object> scatterGather(Publisher<QueryMessage<?, ?>> queries, long timeout, TimeUnit timeUnit) {\n+        return Flux.from(queries)\n+                   .concatMap(q -> scatterGather(q.getQueryName(),\n+                                                 q.getPayload(),\n+                                                 q.getResponseType(),\n+                                                 timeout,\n+                                                 timeUnit));\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, returns initial result and keeps streaming\n+     * incremental updates until subscriber unsubscribes from Flux.\n+     * Should be used when response type of initial result and incremental update match.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "98865ab1427e4d879301c1bf542842eccc8aa3c3"}, "originalPosition": 190}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgyMjcxNDk0OnYy", "diffSide": "RIGHT", "path": "messaging/src/main/java/org/axonframework/queryhandling/ReactorQueryGateway.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xMFQwODo1MDowMVrOGvvTmg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMVQxMzoxMToxNVrOG03NAQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjcxMTMyMg==", "bodyText": "Why this this sentence between brackets?", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r452711322", "createdAt": "2020-07-10T08:50:01Z", "author": {"login": "smcvb"}, "path": "messaging/src/main/java/org/axonframework/queryhandling/ReactorQueryGateway.java", "diffHunk": "@@ -0,0 +1,547 @@\n+/*\n+ * Copyright (c) 2010-2020. Axon Framework\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.axonframework.queryhandling;\n+\n+import org.axonframework.messaging.ResultMessage;\n+import org.axonframework.messaging.reactive.ReactorMessageDispatchInterceptorSupport;\n+import org.axonframework.messaging.reactive.ReactorResultHandlerInterceptorSupport;\n+import org.axonframework.messaging.responsetypes.ResponseType;\n+import org.axonframework.messaging.responsetypes.ResponseTypes;\n+import org.reactivestreams.Publisher;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Mono;\n+import reactor.util.concurrent.Queues;\n+\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Function;\n+\n+/**\n+ * Variation of {@link QueryGateway}. Provides support for reactive return types such as {@link Mono} and {@link Flux}\n+ * from Project Reactor.\n+ *\n+ * @author Milan Savic\n+ * @since 4.4\n+ */\n+public interface ReactorQueryGateway extends ReactorMessageDispatchInterceptorSupport<QueryMessage<?, ?>>,\n+        ReactorResultHandlerInterceptorSupport<QueryMessage<?, ?>, ResultMessage<?>> {\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response with the given {@code responseType}\n+     * from a single source. The query name will be derived from the provided {@code query}. Execution may be\n+     * asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param query        The {@code query} to be sent\n+     * @param responseType A {@link Class} describing the desired response type\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(Q query, Class<R> responseType) {\n+        return query(query.getClass().getName(), query, responseType);\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response with the given {@code responseType}\n+     * from a single source. Execution may be asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(String queryName, Q query, Class<R> responseType) {\n+        return query(queryName, query, ResponseTypes.instanceOf(responseType));\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from a single source. The query name will be derived from the provided {@code query}. Execution may be\n+     * asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(Q query, ResponseType<R> responseType) {\n+        return query(query.getClass().getName(), query, responseType);\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from a single source. Execution may be asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    <R, Q> Mono<R> query(String queryName, Q query, ResponseType<R> responseType);\n+\n+    /**\n+     * Uses given Publisher of query messages to send incoming queries away. Queries will be sent sequentially - once a\n+     * result of Nth query arrives, (N + 1)th query is dispatched.\n+     *\n+     * @param queries a Publisher stream of queries to be dispatched\n+     * @return a Flux of query results. An ordering of query results corresponds to an ordering of queries being\n+     * dispatched\n+     *\n+     * @see #query(String, Object, ResponseType)\n+     * @see Flux#concatMap(Function)\n+     */\n+    default Flux<Object> query(Publisher<QueryMessage<?, ?>> queries) {\n+        return Flux.from(queries)\n+                   .concatMap(q -> query(q.getQueryName(), q.getPayload(), q.getResponseType()));\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from several sources. The returned {@link Flux} is completed when a {@code timeout} occurs or when all possible\n+     * results are received. The query name will be derived from the provided {@code query}. Execution may be\n+     * asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     * <b>Note</b>: Any {@code null} results will be filtered out by the {@link ReactorQueryGateway}. If you require\n+     * the {@code null} to be returned, we suggest using {@code QueryBus} instead.\n+     *\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param timeout      A timeout of {@code long} for the query\n+     * @param timeUnit     The selected {@link TimeUnit} for the given {@code timeout}\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Flux} containing the query results as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Flux<R> scatterGather(Q query, ResponseType<R> responseType, long timeout, TimeUnit timeUnit) {\n+        return scatterGather(query.getClass().getName(), query, responseType, timeout, timeUnit);\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from several sources. The returned {@link Flux} is completed when a {@code timeout} occurs or when all results\n+     * are received. Execution may be asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     * <b>Note</b>: Any {@code null} results will be filtered out by the {@link ReactorQueryGateway}. If you require\n+     * the {@code null} to be returned, we suggest using {@code QueryBus} instead.\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param timeout      A timeout of {@code long} for the query\n+     * @param timeUnit     The selected {@link TimeUnit} for the given {@code timeout}\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Flux} containing the query results as dictated by the given {@code responseType}\n+     */\n+    <R, Q> Flux<R> scatterGather(String queryName, Q query, ResponseType<R> responseType, long timeout,\n+                                 TimeUnit timeUnit);\n+\n+    /**\n+     * Uses given Publisher of queries to send incoming queries in scatter gather manner. Queries will be sent\n+     * sequentially - once a result of Nth query arrives, (N + 1)th query is dispatched. All queries will be dispatched\n+     * using given {@code timeout} and {@code timeUnit}.\n+     *\n+     * @param queries  a Publisher stream of queries to be dispatched\n+     * @param timeout  A timeout of {@code long} for the query\n+     * @param timeUnit The selected {@link TimeUnit} for the given {@code timeout}\n+     * @return a Flux of query results. An ordering of query results corresponds to an ordering of queries being\n+     * dispatched\n+     */\n+    default Flux<Object> scatterGather(Publisher<QueryMessage<?, ?>> queries, long timeout, TimeUnit timeUnit) {\n+        return Flux.from(queries)\n+                   .concatMap(q -> scatterGather(q.getQueryName(),\n+                                                 q.getPayload(),\n+                                                 q.getResponseType(),\n+                                                 timeout,\n+                                                 timeUnit));\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, returns initial result and keeps streaming\n+     * incremental updates until subscriber unsubscribes from Flux.\n+     * Should be used when response type of initial result and incremental update match.\n+     * (received at the moment the query is sent, until it is cancelled by the caller or closed by the emitting side).", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "98865ab1427e4d879301c1bf542842eccc8aa3c3"}, "originalPosition": 191}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzQzMjU0NA==", "bodyText": "I guess it's not that important to be the part of the main sentence, but it provides additional info. Just tried to underline an important part of JavaDoc. Could be removed though...", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r457432544", "createdAt": "2020-07-20T14:22:57Z", "author": {"login": "m1l4n54v1c"}, "path": "messaging/src/main/java/org/axonframework/queryhandling/ReactorQueryGateway.java", "diffHunk": "@@ -0,0 +1,547 @@\n+/*\n+ * Copyright (c) 2010-2020. Axon Framework\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.axonframework.queryhandling;\n+\n+import org.axonframework.messaging.ResultMessage;\n+import org.axonframework.messaging.reactive.ReactorMessageDispatchInterceptorSupport;\n+import org.axonframework.messaging.reactive.ReactorResultHandlerInterceptorSupport;\n+import org.axonframework.messaging.responsetypes.ResponseType;\n+import org.axonframework.messaging.responsetypes.ResponseTypes;\n+import org.reactivestreams.Publisher;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Mono;\n+import reactor.util.concurrent.Queues;\n+\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Function;\n+\n+/**\n+ * Variation of {@link QueryGateway}. Provides support for reactive return types such as {@link Mono} and {@link Flux}\n+ * from Project Reactor.\n+ *\n+ * @author Milan Savic\n+ * @since 4.4\n+ */\n+public interface ReactorQueryGateway extends ReactorMessageDispatchInterceptorSupport<QueryMessage<?, ?>>,\n+        ReactorResultHandlerInterceptorSupport<QueryMessage<?, ?>, ResultMessage<?>> {\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response with the given {@code responseType}\n+     * from a single source. The query name will be derived from the provided {@code query}. Execution may be\n+     * asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param query        The {@code query} to be sent\n+     * @param responseType A {@link Class} describing the desired response type\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(Q query, Class<R> responseType) {\n+        return query(query.getClass().getName(), query, responseType);\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response with the given {@code responseType}\n+     * from a single source. Execution may be asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(String queryName, Q query, Class<R> responseType) {\n+        return query(queryName, query, ResponseTypes.instanceOf(responseType));\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from a single source. The query name will be derived from the provided {@code query}. Execution may be\n+     * asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(Q query, ResponseType<R> responseType) {\n+        return query(query.getClass().getName(), query, responseType);\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from a single source. Execution may be asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    <R, Q> Mono<R> query(String queryName, Q query, ResponseType<R> responseType);\n+\n+    /**\n+     * Uses given Publisher of query messages to send incoming queries away. Queries will be sent sequentially - once a\n+     * result of Nth query arrives, (N + 1)th query is dispatched.\n+     *\n+     * @param queries a Publisher stream of queries to be dispatched\n+     * @return a Flux of query results. An ordering of query results corresponds to an ordering of queries being\n+     * dispatched\n+     *\n+     * @see #query(String, Object, ResponseType)\n+     * @see Flux#concatMap(Function)\n+     */\n+    default Flux<Object> query(Publisher<QueryMessage<?, ?>> queries) {\n+        return Flux.from(queries)\n+                   .concatMap(q -> query(q.getQueryName(), q.getPayload(), q.getResponseType()));\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from several sources. The returned {@link Flux} is completed when a {@code timeout} occurs or when all possible\n+     * results are received. The query name will be derived from the provided {@code query}. Execution may be\n+     * asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     * <b>Note</b>: Any {@code null} results will be filtered out by the {@link ReactorQueryGateway}. If you require\n+     * the {@code null} to be returned, we suggest using {@code QueryBus} instead.\n+     *\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param timeout      A timeout of {@code long} for the query\n+     * @param timeUnit     The selected {@link TimeUnit} for the given {@code timeout}\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Flux} containing the query results as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Flux<R> scatterGather(Q query, ResponseType<R> responseType, long timeout, TimeUnit timeUnit) {\n+        return scatterGather(query.getClass().getName(), query, responseType, timeout, timeUnit);\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from several sources. The returned {@link Flux} is completed when a {@code timeout} occurs or when all results\n+     * are received. Execution may be asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     * <b>Note</b>: Any {@code null} results will be filtered out by the {@link ReactorQueryGateway}. If you require\n+     * the {@code null} to be returned, we suggest using {@code QueryBus} instead.\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param timeout      A timeout of {@code long} for the query\n+     * @param timeUnit     The selected {@link TimeUnit} for the given {@code timeout}\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Flux} containing the query results as dictated by the given {@code responseType}\n+     */\n+    <R, Q> Flux<R> scatterGather(String queryName, Q query, ResponseType<R> responseType, long timeout,\n+                                 TimeUnit timeUnit);\n+\n+    /**\n+     * Uses given Publisher of queries to send incoming queries in scatter gather manner. Queries will be sent\n+     * sequentially - once a result of Nth query arrives, (N + 1)th query is dispatched. All queries will be dispatched\n+     * using given {@code timeout} and {@code timeUnit}.\n+     *\n+     * @param queries  a Publisher stream of queries to be dispatched\n+     * @param timeout  A timeout of {@code long} for the query\n+     * @param timeUnit The selected {@link TimeUnit} for the given {@code timeout}\n+     * @return a Flux of query results. An ordering of query results corresponds to an ordering of queries being\n+     * dispatched\n+     */\n+    default Flux<Object> scatterGather(Publisher<QueryMessage<?, ?>> queries, long timeout, TimeUnit timeUnit) {\n+        return Flux.from(queries)\n+                   .concatMap(q -> scatterGather(q.getQueryName(),\n+                                                 q.getPayload(),\n+                                                 q.getResponseType(),\n+                                                 timeout,\n+                                                 timeUnit));\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, returns initial result and keeps streaming\n+     * incremental updates until subscriber unsubscribes from Flux.\n+     * Should be used when response type of initial result and incremental update match.\n+     * (received at the moment the query is sent, until it is cancelled by the caller or closed by the emitting side).", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjcxMTMyMg=="}, "originalCommit": {"oid": "98865ab1427e4d879301c1bf542842eccc8aa3c3"}, "originalPosition": 191}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODA4MzU4NQ==", "bodyText": "Hmm, I think it makes sense to have this bit in here to be honest! So I'd personally be fine with removing the brackets and making it a fullfledged sentence.", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r458083585", "createdAt": "2020-07-21T13:11:15Z", "author": {"login": "smcvb"}, "path": "messaging/src/main/java/org/axonframework/queryhandling/ReactorQueryGateway.java", "diffHunk": "@@ -0,0 +1,547 @@\n+/*\n+ * Copyright (c) 2010-2020. Axon Framework\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.axonframework.queryhandling;\n+\n+import org.axonframework.messaging.ResultMessage;\n+import org.axonframework.messaging.reactive.ReactorMessageDispatchInterceptorSupport;\n+import org.axonframework.messaging.reactive.ReactorResultHandlerInterceptorSupport;\n+import org.axonframework.messaging.responsetypes.ResponseType;\n+import org.axonframework.messaging.responsetypes.ResponseTypes;\n+import org.reactivestreams.Publisher;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Mono;\n+import reactor.util.concurrent.Queues;\n+\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Function;\n+\n+/**\n+ * Variation of {@link QueryGateway}. Provides support for reactive return types such as {@link Mono} and {@link Flux}\n+ * from Project Reactor.\n+ *\n+ * @author Milan Savic\n+ * @since 4.4\n+ */\n+public interface ReactorQueryGateway extends ReactorMessageDispatchInterceptorSupport<QueryMessage<?, ?>>,\n+        ReactorResultHandlerInterceptorSupport<QueryMessage<?, ?>, ResultMessage<?>> {\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response with the given {@code responseType}\n+     * from a single source. The query name will be derived from the provided {@code query}. Execution may be\n+     * asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param query        The {@code query} to be sent\n+     * @param responseType A {@link Class} describing the desired response type\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(Q query, Class<R> responseType) {\n+        return query(query.getClass().getName(), query, responseType);\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response with the given {@code responseType}\n+     * from a single source. Execution may be asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(String queryName, Q query, Class<R> responseType) {\n+        return query(queryName, query, ResponseTypes.instanceOf(responseType));\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from a single source. The query name will be derived from the provided {@code query}. Execution may be\n+     * asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(Q query, ResponseType<R> responseType) {\n+        return query(query.getClass().getName(), query, responseType);\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from a single source. Execution may be asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    <R, Q> Mono<R> query(String queryName, Q query, ResponseType<R> responseType);\n+\n+    /**\n+     * Uses given Publisher of query messages to send incoming queries away. Queries will be sent sequentially - once a\n+     * result of Nth query arrives, (N + 1)th query is dispatched.\n+     *\n+     * @param queries a Publisher stream of queries to be dispatched\n+     * @return a Flux of query results. An ordering of query results corresponds to an ordering of queries being\n+     * dispatched\n+     *\n+     * @see #query(String, Object, ResponseType)\n+     * @see Flux#concatMap(Function)\n+     */\n+    default Flux<Object> query(Publisher<QueryMessage<?, ?>> queries) {\n+        return Flux.from(queries)\n+                   .concatMap(q -> query(q.getQueryName(), q.getPayload(), q.getResponseType()));\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from several sources. The returned {@link Flux} is completed when a {@code timeout} occurs or when all possible\n+     * results are received. The query name will be derived from the provided {@code query}. Execution may be\n+     * asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     * <b>Note</b>: Any {@code null} results will be filtered out by the {@link ReactorQueryGateway}. If you require\n+     * the {@code null} to be returned, we suggest using {@code QueryBus} instead.\n+     *\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param timeout      A timeout of {@code long} for the query\n+     * @param timeUnit     The selected {@link TimeUnit} for the given {@code timeout}\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Flux} containing the query results as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Flux<R> scatterGather(Q query, ResponseType<R> responseType, long timeout, TimeUnit timeUnit) {\n+        return scatterGather(query.getClass().getName(), query, responseType, timeout, timeUnit);\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from several sources. The returned {@link Flux} is completed when a {@code timeout} occurs or when all results\n+     * are received. Execution may be asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     * <b>Note</b>: Any {@code null} results will be filtered out by the {@link ReactorQueryGateway}. If you require\n+     * the {@code null} to be returned, we suggest using {@code QueryBus} instead.\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param timeout      A timeout of {@code long} for the query\n+     * @param timeUnit     The selected {@link TimeUnit} for the given {@code timeout}\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Flux} containing the query results as dictated by the given {@code responseType}\n+     */\n+    <R, Q> Flux<R> scatterGather(String queryName, Q query, ResponseType<R> responseType, long timeout,\n+                                 TimeUnit timeUnit);\n+\n+    /**\n+     * Uses given Publisher of queries to send incoming queries in scatter gather manner. Queries will be sent\n+     * sequentially - once a result of Nth query arrives, (N + 1)th query is dispatched. All queries will be dispatched\n+     * using given {@code timeout} and {@code timeUnit}.\n+     *\n+     * @param queries  a Publisher stream of queries to be dispatched\n+     * @param timeout  A timeout of {@code long} for the query\n+     * @param timeUnit The selected {@link TimeUnit} for the given {@code timeout}\n+     * @return a Flux of query results. An ordering of query results corresponds to an ordering of queries being\n+     * dispatched\n+     */\n+    default Flux<Object> scatterGather(Publisher<QueryMessage<?, ?>> queries, long timeout, TimeUnit timeUnit) {\n+        return Flux.from(queries)\n+                   .concatMap(q -> scatterGather(q.getQueryName(),\n+                                                 q.getPayload(),\n+                                                 q.getResponseType(),\n+                                                 timeout,\n+                                                 timeUnit));\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, returns initial result and keeps streaming\n+     * incremental updates until subscriber unsubscribes from Flux.\n+     * Should be used when response type of initial result and incremental update match.\n+     * (received at the moment the query is sent, until it is cancelled by the caller or closed by the emitting side).", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjcxMTMyMg=="}, "originalCommit": {"oid": "98865ab1427e4d879301c1bf542842eccc8aa3c3"}, "originalPosition": 191}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgyMjcxNjg1OnYy", "diffSide": "RIGHT", "path": "messaging/src/main/java/org/axonframework/queryhandling/ReactorQueryGateway.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xMFQwODo1MDozM1rOGvvUqA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xMFQwODo1MDozM1rOGvvUqA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjcxMTU5Mg==", "bodyText": "Using \"note\" to start two sentences in a row feels kinda off. Might be nice to rephrase this slightly.", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r452711592", "createdAt": "2020-07-10T08:50:33Z", "author": {"login": "smcvb"}, "path": "messaging/src/main/java/org/axonframework/queryhandling/ReactorQueryGateway.java", "diffHunk": "@@ -0,0 +1,547 @@\n+/*\n+ * Copyright (c) 2010-2020. Axon Framework\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.axonframework.queryhandling;\n+\n+import org.axonframework.messaging.ResultMessage;\n+import org.axonframework.messaging.reactive.ReactorMessageDispatchInterceptorSupport;\n+import org.axonframework.messaging.reactive.ReactorResultHandlerInterceptorSupport;\n+import org.axonframework.messaging.responsetypes.ResponseType;\n+import org.axonframework.messaging.responsetypes.ResponseTypes;\n+import org.reactivestreams.Publisher;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Mono;\n+import reactor.util.concurrent.Queues;\n+\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Function;\n+\n+/**\n+ * Variation of {@link QueryGateway}. Provides support for reactive return types such as {@link Mono} and {@link Flux}\n+ * from Project Reactor.\n+ *\n+ * @author Milan Savic\n+ * @since 4.4\n+ */\n+public interface ReactorQueryGateway extends ReactorMessageDispatchInterceptorSupport<QueryMessage<?, ?>>,\n+        ReactorResultHandlerInterceptorSupport<QueryMessage<?, ?>, ResultMessage<?>> {\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response with the given {@code responseType}\n+     * from a single source. The query name will be derived from the provided {@code query}. Execution may be\n+     * asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param query        The {@code query} to be sent\n+     * @param responseType A {@link Class} describing the desired response type\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(Q query, Class<R> responseType) {\n+        return query(query.getClass().getName(), query, responseType);\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response with the given {@code responseType}\n+     * from a single source. Execution may be asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(String queryName, Q query, Class<R> responseType) {\n+        return query(queryName, query, ResponseTypes.instanceOf(responseType));\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from a single source. The query name will be derived from the provided {@code query}. Execution may be\n+     * asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(Q query, ResponseType<R> responseType) {\n+        return query(query.getClass().getName(), query, responseType);\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from a single source. Execution may be asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    <R, Q> Mono<R> query(String queryName, Q query, ResponseType<R> responseType);\n+\n+    /**\n+     * Uses given Publisher of query messages to send incoming queries away. Queries will be sent sequentially - once a\n+     * result of Nth query arrives, (N + 1)th query is dispatched.\n+     *\n+     * @param queries a Publisher stream of queries to be dispatched\n+     * @return a Flux of query results. An ordering of query results corresponds to an ordering of queries being\n+     * dispatched\n+     *\n+     * @see #query(String, Object, ResponseType)\n+     * @see Flux#concatMap(Function)\n+     */\n+    default Flux<Object> query(Publisher<QueryMessage<?, ?>> queries) {\n+        return Flux.from(queries)\n+                   .concatMap(q -> query(q.getQueryName(), q.getPayload(), q.getResponseType()));\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from several sources. The returned {@link Flux} is completed when a {@code timeout} occurs or when all possible\n+     * results are received. The query name will be derived from the provided {@code query}. Execution may be\n+     * asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     * <b>Note</b>: Any {@code null} results will be filtered out by the {@link ReactorQueryGateway}. If you require\n+     * the {@code null} to be returned, we suggest using {@code QueryBus} instead.\n+     *\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param timeout      A timeout of {@code long} for the query\n+     * @param timeUnit     The selected {@link TimeUnit} for the given {@code timeout}\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Flux} containing the query results as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Flux<R> scatterGather(Q query, ResponseType<R> responseType, long timeout, TimeUnit timeUnit) {\n+        return scatterGather(query.getClass().getName(), query, responseType, timeout, timeUnit);\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from several sources. The returned {@link Flux} is completed when a {@code timeout} occurs or when all results\n+     * are received. Execution may be asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     * <b>Note</b>: Any {@code null} results will be filtered out by the {@link ReactorQueryGateway}. If you require\n+     * the {@code null} to be returned, we suggest using {@code QueryBus} instead.\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param timeout      A timeout of {@code long} for the query\n+     * @param timeUnit     The selected {@link TimeUnit} for the given {@code timeout}\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Flux} containing the query results as dictated by the given {@code responseType}\n+     */\n+    <R, Q> Flux<R> scatterGather(String queryName, Q query, ResponseType<R> responseType, long timeout,\n+                                 TimeUnit timeUnit);\n+\n+    /**\n+     * Uses given Publisher of queries to send incoming queries in scatter gather manner. Queries will be sent\n+     * sequentially - once a result of Nth query arrives, (N + 1)th query is dispatched. All queries will be dispatched\n+     * using given {@code timeout} and {@code timeUnit}.\n+     *\n+     * @param queries  a Publisher stream of queries to be dispatched\n+     * @param timeout  A timeout of {@code long} for the query\n+     * @param timeUnit The selected {@link TimeUnit} for the given {@code timeout}\n+     * @return a Flux of query results. An ordering of query results corresponds to an ordering of queries being\n+     * dispatched\n+     */\n+    default Flux<Object> scatterGather(Publisher<QueryMessage<?, ?>> queries, long timeout, TimeUnit timeUnit) {\n+        return Flux.from(queries)\n+                   .concatMap(q -> scatterGather(q.getQueryName(),\n+                                                 q.getPayload(),\n+                                                 q.getResponseType(),\n+                                                 timeout,\n+                                                 timeUnit));\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, returns initial result and keeps streaming\n+     * incremental updates until subscriber unsubscribes from Flux.\n+     * Should be used when response type of initial result and incremental update match.\n+     * (received at the moment the query is sent, until it is cancelled by the caller or closed by the emitting side).\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Flux}</b></p>\n+     * <p>\n+     * <b>Note</b>: Any {@code null} results, on the initial result or the updates, will be filtered out by the\n+     * {@link ReactorQueryGateway}. If you require the {@code null} to be returned for the initial and update results,\n+     * we suggest using the {@code QueryBus} instead.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "98865ab1427e4d879301c1bf542842eccc8aa3c3"}, "originalPosition": 197}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgyMjcyNDE1OnYy", "diffSide": "RIGHT", "path": "messaging/src/main/java/org/axonframework/queryhandling/ReactorQueryGateway.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xMFQwODo1Mjo0M1rOGvvZHw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xMFQwODo1Mjo0M1rOGvvZHw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjcxMjczNQ==", "bodyText": "The same javadoc comments I placed on the previous method apply to this guy.", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r452712735", "createdAt": "2020-07-10T08:52:43Z", "author": {"login": "smcvb"}, "path": "messaging/src/main/java/org/axonframework/queryhandling/ReactorQueryGateway.java", "diffHunk": "@@ -0,0 +1,547 @@\n+/*\n+ * Copyright (c) 2010-2020. Axon Framework\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.axonframework.queryhandling;\n+\n+import org.axonframework.messaging.ResultMessage;\n+import org.axonframework.messaging.reactive.ReactorMessageDispatchInterceptorSupport;\n+import org.axonframework.messaging.reactive.ReactorResultHandlerInterceptorSupport;\n+import org.axonframework.messaging.responsetypes.ResponseType;\n+import org.axonframework.messaging.responsetypes.ResponseTypes;\n+import org.reactivestreams.Publisher;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Mono;\n+import reactor.util.concurrent.Queues;\n+\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Function;\n+\n+/**\n+ * Variation of {@link QueryGateway}. Provides support for reactive return types such as {@link Mono} and {@link Flux}\n+ * from Project Reactor.\n+ *\n+ * @author Milan Savic\n+ * @since 4.4\n+ */\n+public interface ReactorQueryGateway extends ReactorMessageDispatchInterceptorSupport<QueryMessage<?, ?>>,\n+        ReactorResultHandlerInterceptorSupport<QueryMessage<?, ?>, ResultMessage<?>> {\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response with the given {@code responseType}\n+     * from a single source. The query name will be derived from the provided {@code query}. Execution may be\n+     * asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param query        The {@code query} to be sent\n+     * @param responseType A {@link Class} describing the desired response type\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(Q query, Class<R> responseType) {\n+        return query(query.getClass().getName(), query, responseType);\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response with the given {@code responseType}\n+     * from a single source. Execution may be asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(String queryName, Q query, Class<R> responseType) {\n+        return query(queryName, query, ResponseTypes.instanceOf(responseType));\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from a single source. The query name will be derived from the provided {@code query}. Execution may be\n+     * asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(Q query, ResponseType<R> responseType) {\n+        return query(query.getClass().getName(), query, responseType);\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from a single source. Execution may be asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    <R, Q> Mono<R> query(String queryName, Q query, ResponseType<R> responseType);\n+\n+    /**\n+     * Uses given Publisher of query messages to send incoming queries away. Queries will be sent sequentially - once a\n+     * result of Nth query arrives, (N + 1)th query is dispatched.\n+     *\n+     * @param queries a Publisher stream of queries to be dispatched\n+     * @return a Flux of query results. An ordering of query results corresponds to an ordering of queries being\n+     * dispatched\n+     *\n+     * @see #query(String, Object, ResponseType)\n+     * @see Flux#concatMap(Function)\n+     */\n+    default Flux<Object> query(Publisher<QueryMessage<?, ?>> queries) {\n+        return Flux.from(queries)\n+                   .concatMap(q -> query(q.getQueryName(), q.getPayload(), q.getResponseType()));\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from several sources. The returned {@link Flux} is completed when a {@code timeout} occurs or when all possible\n+     * results are received. The query name will be derived from the provided {@code query}. Execution may be\n+     * asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     * <b>Note</b>: Any {@code null} results will be filtered out by the {@link ReactorQueryGateway}. If you require\n+     * the {@code null} to be returned, we suggest using {@code QueryBus} instead.\n+     *\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param timeout      A timeout of {@code long} for the query\n+     * @param timeUnit     The selected {@link TimeUnit} for the given {@code timeout}\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Flux} containing the query results as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Flux<R> scatterGather(Q query, ResponseType<R> responseType, long timeout, TimeUnit timeUnit) {\n+        return scatterGather(query.getClass().getName(), query, responseType, timeout, timeUnit);\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from several sources. The returned {@link Flux} is completed when a {@code timeout} occurs or when all results\n+     * are received. Execution may be asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     * <b>Note</b>: Any {@code null} results will be filtered out by the {@link ReactorQueryGateway}. If you require\n+     * the {@code null} to be returned, we suggest using {@code QueryBus} instead.\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param timeout      A timeout of {@code long} for the query\n+     * @param timeUnit     The selected {@link TimeUnit} for the given {@code timeout}\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Flux} containing the query results as dictated by the given {@code responseType}\n+     */\n+    <R, Q> Flux<R> scatterGather(String queryName, Q query, ResponseType<R> responseType, long timeout,\n+                                 TimeUnit timeUnit);\n+\n+    /**\n+     * Uses given Publisher of queries to send incoming queries in scatter gather manner. Queries will be sent\n+     * sequentially - once a result of Nth query arrives, (N + 1)th query is dispatched. All queries will be dispatched\n+     * using given {@code timeout} and {@code timeUnit}.\n+     *\n+     * @param queries  a Publisher stream of queries to be dispatched\n+     * @param timeout  A timeout of {@code long} for the query\n+     * @param timeUnit The selected {@link TimeUnit} for the given {@code timeout}\n+     * @return a Flux of query results. An ordering of query results corresponds to an ordering of queries being\n+     * dispatched\n+     */\n+    default Flux<Object> scatterGather(Publisher<QueryMessage<?, ?>> queries, long timeout, TimeUnit timeUnit) {\n+        return Flux.from(queries)\n+                   .concatMap(q -> scatterGather(q.getQueryName(),\n+                                                 q.getPayload(),\n+                                                 q.getResponseType(),\n+                                                 timeout,\n+                                                 timeUnit));\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, returns initial result and keeps streaming\n+     * incremental updates until subscriber unsubscribes from Flux.\n+     * Should be used when response type of initial result and incremental update match.\n+     * (received at the moment the query is sent, until it is cancelled by the caller or closed by the emitting side).\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Flux}</b></p>\n+     * <p>\n+     * <b>Note</b>: Any {@code null} results, on the initial result or the updates, will be filtered out by the\n+     * {@link ReactorQueryGateway}. If you require the {@code null} to be returned for the initial and update results,\n+     * we suggest using the {@code QueryBus} instead.\n+     *\n+     * @param query      The {@code query} to be sent\n+     * @param resultType The response type used for this query\n+     * @param <Q>        The type of the query\n+     * @param <R>        The type of the result (initial & updates)\n+     * @return Flux which can be used to cancel receiving updates\n+     *\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage)\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage, SubscriptionQueryBackpressure, int)\n+     */\n+    default <Q, R> Flux<R> subscriptionQuery(Q query, ResponseType<R> resultType) {\n+        return subscriptionQuery(query, resultType, resultType)\n+                .flatMapMany(result -> result.initialResult()\n+                                             .concatWith(result.updates())\n+                                             .doFinally(signal -> result.close()));\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, returns initial result and keeps streaming", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "98865ab1427e4d879301c1bf542842eccc8aa3c3"}, "originalPosition": 216}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgyMjcyNzc2OnYy", "diffSide": "RIGHT", "path": "messaging/src/main/java/org/axonframework/queryhandling/ReactorQueryGateway.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xMFQwODo1MzozNFrOGvvbLQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xMFQwODo1MzozNFrOGvvbLQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjcxMzI2MQ==", "bodyText": "The same javadoc comments I placed on the previous method apply to this guy.", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r452713261", "createdAt": "2020-07-10T08:53:34Z", "author": {"login": "smcvb"}, "path": "messaging/src/main/java/org/axonframework/queryhandling/ReactorQueryGateway.java", "diffHunk": "@@ -0,0 +1,547 @@\n+/*\n+ * Copyright (c) 2010-2020. Axon Framework\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.axonframework.queryhandling;\n+\n+import org.axonframework.messaging.ResultMessage;\n+import org.axonframework.messaging.reactive.ReactorMessageDispatchInterceptorSupport;\n+import org.axonframework.messaging.reactive.ReactorResultHandlerInterceptorSupport;\n+import org.axonframework.messaging.responsetypes.ResponseType;\n+import org.axonframework.messaging.responsetypes.ResponseTypes;\n+import org.reactivestreams.Publisher;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Mono;\n+import reactor.util.concurrent.Queues;\n+\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Function;\n+\n+/**\n+ * Variation of {@link QueryGateway}. Provides support for reactive return types such as {@link Mono} and {@link Flux}\n+ * from Project Reactor.\n+ *\n+ * @author Milan Savic\n+ * @since 4.4\n+ */\n+public interface ReactorQueryGateway extends ReactorMessageDispatchInterceptorSupport<QueryMessage<?, ?>>,\n+        ReactorResultHandlerInterceptorSupport<QueryMessage<?, ?>, ResultMessage<?>> {\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response with the given {@code responseType}\n+     * from a single source. The query name will be derived from the provided {@code query}. Execution may be\n+     * asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param query        The {@code query} to be sent\n+     * @param responseType A {@link Class} describing the desired response type\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(Q query, Class<R> responseType) {\n+        return query(query.getClass().getName(), query, responseType);\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response with the given {@code responseType}\n+     * from a single source. Execution may be asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(String queryName, Q query, Class<R> responseType) {\n+        return query(queryName, query, ResponseTypes.instanceOf(responseType));\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from a single source. The query name will be derived from the provided {@code query}. Execution may be\n+     * asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(Q query, ResponseType<R> responseType) {\n+        return query(query.getClass().getName(), query, responseType);\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from a single source. Execution may be asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    <R, Q> Mono<R> query(String queryName, Q query, ResponseType<R> responseType);\n+\n+    /**\n+     * Uses given Publisher of query messages to send incoming queries away. Queries will be sent sequentially - once a\n+     * result of Nth query arrives, (N + 1)th query is dispatched.\n+     *\n+     * @param queries a Publisher stream of queries to be dispatched\n+     * @return a Flux of query results. An ordering of query results corresponds to an ordering of queries being\n+     * dispatched\n+     *\n+     * @see #query(String, Object, ResponseType)\n+     * @see Flux#concatMap(Function)\n+     */\n+    default Flux<Object> query(Publisher<QueryMessage<?, ?>> queries) {\n+        return Flux.from(queries)\n+                   .concatMap(q -> query(q.getQueryName(), q.getPayload(), q.getResponseType()));\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from several sources. The returned {@link Flux} is completed when a {@code timeout} occurs or when all possible\n+     * results are received. The query name will be derived from the provided {@code query}. Execution may be\n+     * asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     * <b>Note</b>: Any {@code null} results will be filtered out by the {@link ReactorQueryGateway}. If you require\n+     * the {@code null} to be returned, we suggest using {@code QueryBus} instead.\n+     *\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param timeout      A timeout of {@code long} for the query\n+     * @param timeUnit     The selected {@link TimeUnit} for the given {@code timeout}\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Flux} containing the query results as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Flux<R> scatterGather(Q query, ResponseType<R> responseType, long timeout, TimeUnit timeUnit) {\n+        return scatterGather(query.getClass().getName(), query, responseType, timeout, timeUnit);\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from several sources. The returned {@link Flux} is completed when a {@code timeout} occurs or when all results\n+     * are received. Execution may be asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     * <b>Note</b>: Any {@code null} results will be filtered out by the {@link ReactorQueryGateway}. If you require\n+     * the {@code null} to be returned, we suggest using {@code QueryBus} instead.\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param timeout      A timeout of {@code long} for the query\n+     * @param timeUnit     The selected {@link TimeUnit} for the given {@code timeout}\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Flux} containing the query results as dictated by the given {@code responseType}\n+     */\n+    <R, Q> Flux<R> scatterGather(String queryName, Q query, ResponseType<R> responseType, long timeout,\n+                                 TimeUnit timeUnit);\n+\n+    /**\n+     * Uses given Publisher of queries to send incoming queries in scatter gather manner. Queries will be sent\n+     * sequentially - once a result of Nth query arrives, (N + 1)th query is dispatched. All queries will be dispatched\n+     * using given {@code timeout} and {@code timeUnit}.\n+     *\n+     * @param queries  a Publisher stream of queries to be dispatched\n+     * @param timeout  A timeout of {@code long} for the query\n+     * @param timeUnit The selected {@link TimeUnit} for the given {@code timeout}\n+     * @return a Flux of query results. An ordering of query results corresponds to an ordering of queries being\n+     * dispatched\n+     */\n+    default Flux<Object> scatterGather(Publisher<QueryMessage<?, ?>> queries, long timeout, TimeUnit timeUnit) {\n+        return Flux.from(queries)\n+                   .concatMap(q -> scatterGather(q.getQueryName(),\n+                                                 q.getPayload(),\n+                                                 q.getResponseType(),\n+                                                 timeout,\n+                                                 timeUnit));\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, returns initial result and keeps streaming\n+     * incremental updates until subscriber unsubscribes from Flux.\n+     * Should be used when response type of initial result and incremental update match.\n+     * (received at the moment the query is sent, until it is cancelled by the caller or closed by the emitting side).\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Flux}</b></p>\n+     * <p>\n+     * <b>Note</b>: Any {@code null} results, on the initial result or the updates, will be filtered out by the\n+     * {@link ReactorQueryGateway}. If you require the {@code null} to be returned for the initial and update results,\n+     * we suggest using the {@code QueryBus} instead.\n+     *\n+     * @param query      The {@code query} to be sent\n+     * @param resultType The response type used for this query\n+     * @param <Q>        The type of the query\n+     * @param <R>        The type of the result (initial & updates)\n+     * @return Flux which can be used to cancel receiving updates\n+     *\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage)\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage, SubscriptionQueryBackpressure, int)\n+     */\n+    default <Q, R> Flux<R> subscriptionQuery(Q query, ResponseType<R> resultType) {\n+        return subscriptionQuery(query, resultType, resultType)\n+                .flatMapMany(result -> result.initialResult()\n+                                             .concatWith(result.updates())\n+                                             .doFinally(signal -> result.close()));\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, returns initial result and keeps streaming\n+     * incremental updates until subscriber unsubscribes from Flux.\n+     * Should be used when response type of initial result and incremental update match.\n+     * (received at the moment the query is sent, until it is cancelled by the caller or closed by the emitting side).\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Flux}</b></p>\n+     * <p>\n+     * <b>Note</b>: Any {@code null} results, on the initial result or the updates, will be filtered out by the\n+     * {@link ReactorQueryGateway}. If you require the {@code null} to be returned for the initial and update results,\n+     * we suggest using the {@code QueryBus} instead.\n+     *\n+     * @param query      The {@code query} to be sent\n+     * @param resultType The response type used for this query\n+     * @param <Q>        The type of the query\n+     * @param <R>        The type of the result (initial & updates)\n+     * @return Flux which can be used to cancel receiving updates\n+     *\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage)\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage, SubscriptionQueryBackpressure, int)\n+     */\n+    default <Q, R> Flux<R> subscriptionQuery(Q query, Class<R> resultType) {\n+        return subscriptionQuery(query, ResponseTypes.instanceOf(resultType));\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, returns initial result and keeps streaming", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "98865ab1427e4d879301c1bf542842eccc8aa3c3"}, "originalPosition": 241}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgyMjczMDc0OnYy", "diffSide": "RIGHT", "path": "messaging/src/main/java/org/axonframework/queryhandling/ReactorQueryGateway.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xMFQwODo1NDoxOVrOGvvc8A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xMFQwODo1NDoxOVrOGvvc8A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjcxMzcxMg==", "bodyText": "Using \"note\" to start two sentences in a row feels kinda off. Might be nice to rephrase this slightly.", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r452713712", "createdAt": "2020-07-10T08:54:19Z", "author": {"login": "smcvb"}, "path": "messaging/src/main/java/org/axonframework/queryhandling/ReactorQueryGateway.java", "diffHunk": "@@ -0,0 +1,547 @@\n+/*\n+ * Copyright (c) 2010-2020. Axon Framework\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.axonframework.queryhandling;\n+\n+import org.axonframework.messaging.ResultMessage;\n+import org.axonframework.messaging.reactive.ReactorMessageDispatchInterceptorSupport;\n+import org.axonframework.messaging.reactive.ReactorResultHandlerInterceptorSupport;\n+import org.axonframework.messaging.responsetypes.ResponseType;\n+import org.axonframework.messaging.responsetypes.ResponseTypes;\n+import org.reactivestreams.Publisher;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Mono;\n+import reactor.util.concurrent.Queues;\n+\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Function;\n+\n+/**\n+ * Variation of {@link QueryGateway}. Provides support for reactive return types such as {@link Mono} and {@link Flux}\n+ * from Project Reactor.\n+ *\n+ * @author Milan Savic\n+ * @since 4.4\n+ */\n+public interface ReactorQueryGateway extends ReactorMessageDispatchInterceptorSupport<QueryMessage<?, ?>>,\n+        ReactorResultHandlerInterceptorSupport<QueryMessage<?, ?>, ResultMessage<?>> {\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response with the given {@code responseType}\n+     * from a single source. The query name will be derived from the provided {@code query}. Execution may be\n+     * asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param query        The {@code query} to be sent\n+     * @param responseType A {@link Class} describing the desired response type\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(Q query, Class<R> responseType) {\n+        return query(query.getClass().getName(), query, responseType);\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response with the given {@code responseType}\n+     * from a single source. Execution may be asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(String queryName, Q query, Class<R> responseType) {\n+        return query(queryName, query, ResponseTypes.instanceOf(responseType));\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from a single source. The query name will be derived from the provided {@code query}. Execution may be\n+     * asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(Q query, ResponseType<R> responseType) {\n+        return query(query.getClass().getName(), query, responseType);\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from a single source. Execution may be asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    <R, Q> Mono<R> query(String queryName, Q query, ResponseType<R> responseType);\n+\n+    /**\n+     * Uses given Publisher of query messages to send incoming queries away. Queries will be sent sequentially - once a\n+     * result of Nth query arrives, (N + 1)th query is dispatched.\n+     *\n+     * @param queries a Publisher stream of queries to be dispatched\n+     * @return a Flux of query results. An ordering of query results corresponds to an ordering of queries being\n+     * dispatched\n+     *\n+     * @see #query(String, Object, ResponseType)\n+     * @see Flux#concatMap(Function)\n+     */\n+    default Flux<Object> query(Publisher<QueryMessage<?, ?>> queries) {\n+        return Flux.from(queries)\n+                   .concatMap(q -> query(q.getQueryName(), q.getPayload(), q.getResponseType()));\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from several sources. The returned {@link Flux} is completed when a {@code timeout} occurs or when all possible\n+     * results are received. The query name will be derived from the provided {@code query}. Execution may be\n+     * asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     * <b>Note</b>: Any {@code null} results will be filtered out by the {@link ReactorQueryGateway}. If you require\n+     * the {@code null} to be returned, we suggest using {@code QueryBus} instead.\n+     *\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param timeout      A timeout of {@code long} for the query\n+     * @param timeUnit     The selected {@link TimeUnit} for the given {@code timeout}\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Flux} containing the query results as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Flux<R> scatterGather(Q query, ResponseType<R> responseType, long timeout, TimeUnit timeUnit) {\n+        return scatterGather(query.getClass().getName(), query, responseType, timeout, timeUnit);\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from several sources. The returned {@link Flux} is completed when a {@code timeout} occurs or when all results\n+     * are received. Execution may be asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     * <b>Note</b>: Any {@code null} results will be filtered out by the {@link ReactorQueryGateway}. If you require\n+     * the {@code null} to be returned, we suggest using {@code QueryBus} instead.\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param timeout      A timeout of {@code long} for the query\n+     * @param timeUnit     The selected {@link TimeUnit} for the given {@code timeout}\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Flux} containing the query results as dictated by the given {@code responseType}\n+     */\n+    <R, Q> Flux<R> scatterGather(String queryName, Q query, ResponseType<R> responseType, long timeout,\n+                                 TimeUnit timeUnit);\n+\n+    /**\n+     * Uses given Publisher of queries to send incoming queries in scatter gather manner. Queries will be sent\n+     * sequentially - once a result of Nth query arrives, (N + 1)th query is dispatched. All queries will be dispatched\n+     * using given {@code timeout} and {@code timeUnit}.\n+     *\n+     * @param queries  a Publisher stream of queries to be dispatched\n+     * @param timeout  A timeout of {@code long} for the query\n+     * @param timeUnit The selected {@link TimeUnit} for the given {@code timeout}\n+     * @return a Flux of query results. An ordering of query results corresponds to an ordering of queries being\n+     * dispatched\n+     */\n+    default Flux<Object> scatterGather(Publisher<QueryMessage<?, ?>> queries, long timeout, TimeUnit timeUnit) {\n+        return Flux.from(queries)\n+                   .concatMap(q -> scatterGather(q.getQueryName(),\n+                                                 q.getPayload(),\n+                                                 q.getResponseType(),\n+                                                 timeout,\n+                                                 timeUnit));\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, returns initial result and keeps streaming\n+     * incremental updates until subscriber unsubscribes from Flux.\n+     * Should be used when response type of initial result and incremental update match.\n+     * (received at the moment the query is sent, until it is cancelled by the caller or closed by the emitting side).\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Flux}</b></p>\n+     * <p>\n+     * <b>Note</b>: Any {@code null} results, on the initial result or the updates, will be filtered out by the\n+     * {@link ReactorQueryGateway}. If you require the {@code null} to be returned for the initial and update results,\n+     * we suggest using the {@code QueryBus} instead.\n+     *\n+     * @param query      The {@code query} to be sent\n+     * @param resultType The response type used for this query\n+     * @param <Q>        The type of the query\n+     * @param <R>        The type of the result (initial & updates)\n+     * @return Flux which can be used to cancel receiving updates\n+     *\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage)\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage, SubscriptionQueryBackpressure, int)\n+     */\n+    default <Q, R> Flux<R> subscriptionQuery(Q query, ResponseType<R> resultType) {\n+        return subscriptionQuery(query, resultType, resultType)\n+                .flatMapMany(result -> result.initialResult()\n+                                             .concatWith(result.updates())\n+                                             .doFinally(signal -> result.close()));\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, returns initial result and keeps streaming\n+     * incremental updates until subscriber unsubscribes from Flux.\n+     * Should be used when response type of initial result and incremental update match.\n+     * (received at the moment the query is sent, until it is cancelled by the caller or closed by the emitting side).\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Flux}</b></p>\n+     * <p>\n+     * <b>Note</b>: Any {@code null} results, on the initial result or the updates, will be filtered out by the\n+     * {@link ReactorQueryGateway}. If you require the {@code null} to be returned for the initial and update results,\n+     * we suggest using the {@code QueryBus} instead.\n+     *\n+     * @param query      The {@code query} to be sent\n+     * @param resultType The response type used for this query\n+     * @param <Q>        The type of the query\n+     * @param <R>        The type of the result (initial & updates)\n+     * @return Flux which can be used to cancel receiving updates\n+     *\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage)\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage, SubscriptionQueryBackpressure, int)\n+     */\n+    default <Q, R> Flux<R> subscriptionQuery(Q query, Class<R> resultType) {\n+        return subscriptionQuery(query, ResponseTypes.instanceOf(resultType));\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, returns initial result and keeps streaming\n+     * incremental updates until subscriber unsubscribes from Flux.\n+     * Should be used when initial result contains multiple instances of response type and needs to be flatten.\n+     * Response type of initial response and incremental updates needs to match.\n+     * (received at the moment the query is sent, until it is cancelled by the caller or closed by the emitting side).\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Flux}</b></p>\n+     * <p>\n+     * <b>Note</b>: Any {@code null} results, on the initial result or the updates, will be filtered out by the\n+     * {@link ReactorQueryGateway}. If you require the {@code null} to be returned for the initial and update results,\n+     * we suggest using the {@code QueryBus} instead.\n+     *\n+     * @param query      The {@code query} to be sent\n+     * @param resultType The response type used for this query\n+     * @param <Q>        The type of the query\n+     * @param <R>        The type of the result (initial & updates)\n+     * @return Flux which can be used to cancel receiving updates\n+     *\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage)\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage, SubscriptionQueryBackpressure, int)\n+     */\n+    default <Q, R> Flux<R> subscriptionQueryMany(Q query, Class<R> resultType) {\n+        return subscriptionQuery(query,\n+                                 ResponseTypes.multipleInstancesOf(resultType),\n+                                 ResponseTypes.instanceOf(resultType))\n+                .flatMapMany(result -> result.initialResult()\n+                                             .flatMapMany(Flux::fromIterable)\n+                                             .concatWith(result.updates())\n+                                             .doFinally(signal -> result.close()));\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, and streams\n+     * incremental updates until subscriber unsubscribes from Flux.\n+     * Should be used when subscriber is interested only in updates.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Flux}</b></p>\n+     * <p>\n+     * <b>Note</b>: Any {@code null} results, will be filtered out by the\n+     * {@link ReactorQueryGateway}. If you require the {@code null} to be returned for the initial and update results,\n+     * we suggest using the {@code QueryBus} instead.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "98865ab1427e4d879301c1bf542842eccc8aa3c3"}, "originalPosition": 281}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgyMjczMzM1OnYy", "diffSide": "RIGHT", "path": "messaging/src/main/java/org/axonframework/queryhandling/ReactorQueryGateway.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xMFQwODo1NDo1OVrOGvvejg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xMFQwODo1NDo1OVrOGvvejg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjcxNDEyNg==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * Sends the given {@code query} over the {@link QueryBus}, and streams\n          \n          \n            \n                 * incremental updates until subscriber unsubscribes from Flux.\n          \n          \n            \n                 * Should be used when subscriber is interested only in updates.\n          \n          \n            \n                 * Sends the given {@code query} over the {@link QueryBus}, streaming\n          \n          \n            \n                 * incremental updates until the subscriber unsubscribes from the resulting {@link Flux}.\n          \n          \n            \n                 * Should be used when the subscriber is interested only in updates.", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r452714126", "createdAt": "2020-07-10T08:54:59Z", "author": {"login": "smcvb"}, "path": "messaging/src/main/java/org/axonframework/queryhandling/ReactorQueryGateway.java", "diffHunk": "@@ -0,0 +1,547 @@\n+/*\n+ * Copyright (c) 2010-2020. Axon Framework\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.axonframework.queryhandling;\n+\n+import org.axonframework.messaging.ResultMessage;\n+import org.axonframework.messaging.reactive.ReactorMessageDispatchInterceptorSupport;\n+import org.axonframework.messaging.reactive.ReactorResultHandlerInterceptorSupport;\n+import org.axonframework.messaging.responsetypes.ResponseType;\n+import org.axonframework.messaging.responsetypes.ResponseTypes;\n+import org.reactivestreams.Publisher;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Mono;\n+import reactor.util.concurrent.Queues;\n+\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Function;\n+\n+/**\n+ * Variation of {@link QueryGateway}. Provides support for reactive return types such as {@link Mono} and {@link Flux}\n+ * from Project Reactor.\n+ *\n+ * @author Milan Savic\n+ * @since 4.4\n+ */\n+public interface ReactorQueryGateway extends ReactorMessageDispatchInterceptorSupport<QueryMessage<?, ?>>,\n+        ReactorResultHandlerInterceptorSupport<QueryMessage<?, ?>, ResultMessage<?>> {\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response with the given {@code responseType}\n+     * from a single source. The query name will be derived from the provided {@code query}. Execution may be\n+     * asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param query        The {@code query} to be sent\n+     * @param responseType A {@link Class} describing the desired response type\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(Q query, Class<R> responseType) {\n+        return query(query.getClass().getName(), query, responseType);\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response with the given {@code responseType}\n+     * from a single source. Execution may be asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(String queryName, Q query, Class<R> responseType) {\n+        return query(queryName, query, ResponseTypes.instanceOf(responseType));\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from a single source. The query name will be derived from the provided {@code query}. Execution may be\n+     * asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(Q query, ResponseType<R> responseType) {\n+        return query(query.getClass().getName(), query, responseType);\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from a single source. Execution may be asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    <R, Q> Mono<R> query(String queryName, Q query, ResponseType<R> responseType);\n+\n+    /**\n+     * Uses given Publisher of query messages to send incoming queries away. Queries will be sent sequentially - once a\n+     * result of Nth query arrives, (N + 1)th query is dispatched.\n+     *\n+     * @param queries a Publisher stream of queries to be dispatched\n+     * @return a Flux of query results. An ordering of query results corresponds to an ordering of queries being\n+     * dispatched\n+     *\n+     * @see #query(String, Object, ResponseType)\n+     * @see Flux#concatMap(Function)\n+     */\n+    default Flux<Object> query(Publisher<QueryMessage<?, ?>> queries) {\n+        return Flux.from(queries)\n+                   .concatMap(q -> query(q.getQueryName(), q.getPayload(), q.getResponseType()));\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from several sources. The returned {@link Flux} is completed when a {@code timeout} occurs or when all possible\n+     * results are received. The query name will be derived from the provided {@code query}. Execution may be\n+     * asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     * <b>Note</b>: Any {@code null} results will be filtered out by the {@link ReactorQueryGateway}. If you require\n+     * the {@code null} to be returned, we suggest using {@code QueryBus} instead.\n+     *\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param timeout      A timeout of {@code long} for the query\n+     * @param timeUnit     The selected {@link TimeUnit} for the given {@code timeout}\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Flux} containing the query results as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Flux<R> scatterGather(Q query, ResponseType<R> responseType, long timeout, TimeUnit timeUnit) {\n+        return scatterGather(query.getClass().getName(), query, responseType, timeout, timeUnit);\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from several sources. The returned {@link Flux} is completed when a {@code timeout} occurs or when all results\n+     * are received. Execution may be asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     * <b>Note</b>: Any {@code null} results will be filtered out by the {@link ReactorQueryGateway}. If you require\n+     * the {@code null} to be returned, we suggest using {@code QueryBus} instead.\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param timeout      A timeout of {@code long} for the query\n+     * @param timeUnit     The selected {@link TimeUnit} for the given {@code timeout}\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Flux} containing the query results as dictated by the given {@code responseType}\n+     */\n+    <R, Q> Flux<R> scatterGather(String queryName, Q query, ResponseType<R> responseType, long timeout,\n+                                 TimeUnit timeUnit);\n+\n+    /**\n+     * Uses given Publisher of queries to send incoming queries in scatter gather manner. Queries will be sent\n+     * sequentially - once a result of Nth query arrives, (N + 1)th query is dispatched. All queries will be dispatched\n+     * using given {@code timeout} and {@code timeUnit}.\n+     *\n+     * @param queries  a Publisher stream of queries to be dispatched\n+     * @param timeout  A timeout of {@code long} for the query\n+     * @param timeUnit The selected {@link TimeUnit} for the given {@code timeout}\n+     * @return a Flux of query results. An ordering of query results corresponds to an ordering of queries being\n+     * dispatched\n+     */\n+    default Flux<Object> scatterGather(Publisher<QueryMessage<?, ?>> queries, long timeout, TimeUnit timeUnit) {\n+        return Flux.from(queries)\n+                   .concatMap(q -> scatterGather(q.getQueryName(),\n+                                                 q.getPayload(),\n+                                                 q.getResponseType(),\n+                                                 timeout,\n+                                                 timeUnit));\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, returns initial result and keeps streaming\n+     * incremental updates until subscriber unsubscribes from Flux.\n+     * Should be used when response type of initial result and incremental update match.\n+     * (received at the moment the query is sent, until it is cancelled by the caller or closed by the emitting side).\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Flux}</b></p>\n+     * <p>\n+     * <b>Note</b>: Any {@code null} results, on the initial result or the updates, will be filtered out by the\n+     * {@link ReactorQueryGateway}. If you require the {@code null} to be returned for the initial and update results,\n+     * we suggest using the {@code QueryBus} instead.\n+     *\n+     * @param query      The {@code query} to be sent\n+     * @param resultType The response type used for this query\n+     * @param <Q>        The type of the query\n+     * @param <R>        The type of the result (initial & updates)\n+     * @return Flux which can be used to cancel receiving updates\n+     *\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage)\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage, SubscriptionQueryBackpressure, int)\n+     */\n+    default <Q, R> Flux<R> subscriptionQuery(Q query, ResponseType<R> resultType) {\n+        return subscriptionQuery(query, resultType, resultType)\n+                .flatMapMany(result -> result.initialResult()\n+                                             .concatWith(result.updates())\n+                                             .doFinally(signal -> result.close()));\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, returns initial result and keeps streaming\n+     * incremental updates until subscriber unsubscribes from Flux.\n+     * Should be used when response type of initial result and incremental update match.\n+     * (received at the moment the query is sent, until it is cancelled by the caller or closed by the emitting side).\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Flux}</b></p>\n+     * <p>\n+     * <b>Note</b>: Any {@code null} results, on the initial result or the updates, will be filtered out by the\n+     * {@link ReactorQueryGateway}. If you require the {@code null} to be returned for the initial and update results,\n+     * we suggest using the {@code QueryBus} instead.\n+     *\n+     * @param query      The {@code query} to be sent\n+     * @param resultType The response type used for this query\n+     * @param <Q>        The type of the query\n+     * @param <R>        The type of the result (initial & updates)\n+     * @return Flux which can be used to cancel receiving updates\n+     *\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage)\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage, SubscriptionQueryBackpressure, int)\n+     */\n+    default <Q, R> Flux<R> subscriptionQuery(Q query, Class<R> resultType) {\n+        return subscriptionQuery(query, ResponseTypes.instanceOf(resultType));\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, returns initial result and keeps streaming\n+     * incremental updates until subscriber unsubscribes from Flux.\n+     * Should be used when initial result contains multiple instances of response type and needs to be flatten.\n+     * Response type of initial response and incremental updates needs to match.\n+     * (received at the moment the query is sent, until it is cancelled by the caller or closed by the emitting side).\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Flux}</b></p>\n+     * <p>\n+     * <b>Note</b>: Any {@code null} results, on the initial result or the updates, will be filtered out by the\n+     * {@link ReactorQueryGateway}. If you require the {@code null} to be returned for the initial and update results,\n+     * we suggest using the {@code QueryBus} instead.\n+     *\n+     * @param query      The {@code query} to be sent\n+     * @param resultType The response type used for this query\n+     * @param <Q>        The type of the query\n+     * @param <R>        The type of the result (initial & updates)\n+     * @return Flux which can be used to cancel receiving updates\n+     *\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage)\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage, SubscriptionQueryBackpressure, int)\n+     */\n+    default <Q, R> Flux<R> subscriptionQueryMany(Q query, Class<R> resultType) {\n+        return subscriptionQuery(query,\n+                                 ResponseTypes.multipleInstancesOf(resultType),\n+                                 ResponseTypes.instanceOf(resultType))\n+                .flatMapMany(result -> result.initialResult()\n+                                             .flatMapMany(Flux::fromIterable)\n+                                             .concatWith(result.updates())\n+                                             .doFinally(signal -> result.close()));\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, and streams\n+     * incremental updates until subscriber unsubscribes from Flux.\n+     * Should be used when subscriber is interested only in updates.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "98865ab1427e4d879301c1bf542842eccc8aa3c3"}, "originalPosition": 275}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgyMjczNjE4OnYy", "diffSide": "RIGHT", "path": "messaging/src/main/java/org/axonframework/queryhandling/ReactorQueryGateway.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xMFQwODo1NTozOVrOGvvgLA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMVQxMzoxMjowNVrOG03PGQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjcxNDU0MA==", "bodyText": "Interesting, using Void as the initial result will make it so we disregard the initial result?", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r452714540", "createdAt": "2020-07-10T08:55:39Z", "author": {"login": "smcvb"}, "path": "messaging/src/main/java/org/axonframework/queryhandling/ReactorQueryGateway.java", "diffHunk": "@@ -0,0 +1,547 @@\n+/*\n+ * Copyright (c) 2010-2020. Axon Framework\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.axonframework.queryhandling;\n+\n+import org.axonframework.messaging.ResultMessage;\n+import org.axonframework.messaging.reactive.ReactorMessageDispatchInterceptorSupport;\n+import org.axonframework.messaging.reactive.ReactorResultHandlerInterceptorSupport;\n+import org.axonframework.messaging.responsetypes.ResponseType;\n+import org.axonframework.messaging.responsetypes.ResponseTypes;\n+import org.reactivestreams.Publisher;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Mono;\n+import reactor.util.concurrent.Queues;\n+\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Function;\n+\n+/**\n+ * Variation of {@link QueryGateway}. Provides support for reactive return types such as {@link Mono} and {@link Flux}\n+ * from Project Reactor.\n+ *\n+ * @author Milan Savic\n+ * @since 4.4\n+ */\n+public interface ReactorQueryGateway extends ReactorMessageDispatchInterceptorSupport<QueryMessage<?, ?>>,\n+        ReactorResultHandlerInterceptorSupport<QueryMessage<?, ?>, ResultMessage<?>> {\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response with the given {@code responseType}\n+     * from a single source. The query name will be derived from the provided {@code query}. Execution may be\n+     * asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param query        The {@code query} to be sent\n+     * @param responseType A {@link Class} describing the desired response type\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(Q query, Class<R> responseType) {\n+        return query(query.getClass().getName(), query, responseType);\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response with the given {@code responseType}\n+     * from a single source. Execution may be asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(String queryName, Q query, Class<R> responseType) {\n+        return query(queryName, query, ResponseTypes.instanceOf(responseType));\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from a single source. The query name will be derived from the provided {@code query}. Execution may be\n+     * asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(Q query, ResponseType<R> responseType) {\n+        return query(query.getClass().getName(), query, responseType);\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from a single source. Execution may be asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    <R, Q> Mono<R> query(String queryName, Q query, ResponseType<R> responseType);\n+\n+    /**\n+     * Uses given Publisher of query messages to send incoming queries away. Queries will be sent sequentially - once a\n+     * result of Nth query arrives, (N + 1)th query is dispatched.\n+     *\n+     * @param queries a Publisher stream of queries to be dispatched\n+     * @return a Flux of query results. An ordering of query results corresponds to an ordering of queries being\n+     * dispatched\n+     *\n+     * @see #query(String, Object, ResponseType)\n+     * @see Flux#concatMap(Function)\n+     */\n+    default Flux<Object> query(Publisher<QueryMessage<?, ?>> queries) {\n+        return Flux.from(queries)\n+                   .concatMap(q -> query(q.getQueryName(), q.getPayload(), q.getResponseType()));\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from several sources. The returned {@link Flux} is completed when a {@code timeout} occurs or when all possible\n+     * results are received. The query name will be derived from the provided {@code query}. Execution may be\n+     * asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     * <b>Note</b>: Any {@code null} results will be filtered out by the {@link ReactorQueryGateway}. If you require\n+     * the {@code null} to be returned, we suggest using {@code QueryBus} instead.\n+     *\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param timeout      A timeout of {@code long} for the query\n+     * @param timeUnit     The selected {@link TimeUnit} for the given {@code timeout}\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Flux} containing the query results as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Flux<R> scatterGather(Q query, ResponseType<R> responseType, long timeout, TimeUnit timeUnit) {\n+        return scatterGather(query.getClass().getName(), query, responseType, timeout, timeUnit);\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from several sources. The returned {@link Flux} is completed when a {@code timeout} occurs or when all results\n+     * are received. Execution may be asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     * <b>Note</b>: Any {@code null} results will be filtered out by the {@link ReactorQueryGateway}. If you require\n+     * the {@code null} to be returned, we suggest using {@code QueryBus} instead.\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param timeout      A timeout of {@code long} for the query\n+     * @param timeUnit     The selected {@link TimeUnit} for the given {@code timeout}\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Flux} containing the query results as dictated by the given {@code responseType}\n+     */\n+    <R, Q> Flux<R> scatterGather(String queryName, Q query, ResponseType<R> responseType, long timeout,\n+                                 TimeUnit timeUnit);\n+\n+    /**\n+     * Uses given Publisher of queries to send incoming queries in scatter gather manner. Queries will be sent\n+     * sequentially - once a result of Nth query arrives, (N + 1)th query is dispatched. All queries will be dispatched\n+     * using given {@code timeout} and {@code timeUnit}.\n+     *\n+     * @param queries  a Publisher stream of queries to be dispatched\n+     * @param timeout  A timeout of {@code long} for the query\n+     * @param timeUnit The selected {@link TimeUnit} for the given {@code timeout}\n+     * @return a Flux of query results. An ordering of query results corresponds to an ordering of queries being\n+     * dispatched\n+     */\n+    default Flux<Object> scatterGather(Publisher<QueryMessage<?, ?>> queries, long timeout, TimeUnit timeUnit) {\n+        return Flux.from(queries)\n+                   .concatMap(q -> scatterGather(q.getQueryName(),\n+                                                 q.getPayload(),\n+                                                 q.getResponseType(),\n+                                                 timeout,\n+                                                 timeUnit));\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, returns initial result and keeps streaming\n+     * incremental updates until subscriber unsubscribes from Flux.\n+     * Should be used when response type of initial result and incremental update match.\n+     * (received at the moment the query is sent, until it is cancelled by the caller or closed by the emitting side).\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Flux}</b></p>\n+     * <p>\n+     * <b>Note</b>: Any {@code null} results, on the initial result or the updates, will be filtered out by the\n+     * {@link ReactorQueryGateway}. If you require the {@code null} to be returned for the initial and update results,\n+     * we suggest using the {@code QueryBus} instead.\n+     *\n+     * @param query      The {@code query} to be sent\n+     * @param resultType The response type used for this query\n+     * @param <Q>        The type of the query\n+     * @param <R>        The type of the result (initial & updates)\n+     * @return Flux which can be used to cancel receiving updates\n+     *\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage)\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage, SubscriptionQueryBackpressure, int)\n+     */\n+    default <Q, R> Flux<R> subscriptionQuery(Q query, ResponseType<R> resultType) {\n+        return subscriptionQuery(query, resultType, resultType)\n+                .flatMapMany(result -> result.initialResult()\n+                                             .concatWith(result.updates())\n+                                             .doFinally(signal -> result.close()));\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, returns initial result and keeps streaming\n+     * incremental updates until subscriber unsubscribes from Flux.\n+     * Should be used when response type of initial result and incremental update match.\n+     * (received at the moment the query is sent, until it is cancelled by the caller or closed by the emitting side).\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Flux}</b></p>\n+     * <p>\n+     * <b>Note</b>: Any {@code null} results, on the initial result or the updates, will be filtered out by the\n+     * {@link ReactorQueryGateway}. If you require the {@code null} to be returned for the initial and update results,\n+     * we suggest using the {@code QueryBus} instead.\n+     *\n+     * @param query      The {@code query} to be sent\n+     * @param resultType The response type used for this query\n+     * @param <Q>        The type of the query\n+     * @param <R>        The type of the result (initial & updates)\n+     * @return Flux which can be used to cancel receiving updates\n+     *\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage)\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage, SubscriptionQueryBackpressure, int)\n+     */\n+    default <Q, R> Flux<R> subscriptionQuery(Q query, Class<R> resultType) {\n+        return subscriptionQuery(query, ResponseTypes.instanceOf(resultType));\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, returns initial result and keeps streaming\n+     * incremental updates until subscriber unsubscribes from Flux.\n+     * Should be used when initial result contains multiple instances of response type and needs to be flatten.\n+     * Response type of initial response and incremental updates needs to match.\n+     * (received at the moment the query is sent, until it is cancelled by the caller or closed by the emitting side).\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Flux}</b></p>\n+     * <p>\n+     * <b>Note</b>: Any {@code null} results, on the initial result or the updates, will be filtered out by the\n+     * {@link ReactorQueryGateway}. If you require the {@code null} to be returned for the initial and update results,\n+     * we suggest using the {@code QueryBus} instead.\n+     *\n+     * @param query      The {@code query} to be sent\n+     * @param resultType The response type used for this query\n+     * @param <Q>        The type of the query\n+     * @param <R>        The type of the result (initial & updates)\n+     * @return Flux which can be used to cancel receiving updates\n+     *\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage)\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage, SubscriptionQueryBackpressure, int)\n+     */\n+    default <Q, R> Flux<R> subscriptionQueryMany(Q query, Class<R> resultType) {\n+        return subscriptionQuery(query,\n+                                 ResponseTypes.multipleInstancesOf(resultType),\n+                                 ResponseTypes.instanceOf(resultType))\n+                .flatMapMany(result -> result.initialResult()\n+                                             .flatMapMany(Flux::fromIterable)\n+                                             .concatWith(result.updates())\n+                                             .doFinally(signal -> result.close()));\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, and streams\n+     * incremental updates until subscriber unsubscribes from Flux.\n+     * Should be used when subscriber is interested only in updates.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Flux}</b></p>\n+     * <p>\n+     * <b>Note</b>: Any {@code null} results, will be filtered out by the\n+     * {@link ReactorQueryGateway}. If you require the {@code null} to be returned for the initial and update results,\n+     * we suggest using the {@code QueryBus} instead.\n+     *\n+     * @param query      The {@code query} to be sent\n+     * @param resultType The response type used for this query\n+     * @param <Q>        The type of the query\n+     * @param <R>        The type of the result (updates)\n+     * @return Flux which can be used to cancel receiving updates\n+     *\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage)\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage, SubscriptionQueryBackpressure, int)\n+     */\n+    default <Q, R> Flux<R> queryUpdates(Q query, ResponseType<R> resultType) {\n+        return subscriptionQuery(query, ResponseTypes.instanceOf(Void.class), resultType)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "98865ab1427e4d879301c1bf542842eccc8aa3c3"}, "originalPosition": 293}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzQ0MTk3MQ==", "bodyText": "Actually, it's never invoked, essentially it doesn't matter.", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r457441971", "createdAt": "2020-07-20T14:32:37Z", "author": {"login": "m1l4n54v1c"}, "path": "messaging/src/main/java/org/axonframework/queryhandling/ReactorQueryGateway.java", "diffHunk": "@@ -0,0 +1,547 @@\n+/*\n+ * Copyright (c) 2010-2020. Axon Framework\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.axonframework.queryhandling;\n+\n+import org.axonframework.messaging.ResultMessage;\n+import org.axonframework.messaging.reactive.ReactorMessageDispatchInterceptorSupport;\n+import org.axonframework.messaging.reactive.ReactorResultHandlerInterceptorSupport;\n+import org.axonframework.messaging.responsetypes.ResponseType;\n+import org.axonframework.messaging.responsetypes.ResponseTypes;\n+import org.reactivestreams.Publisher;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Mono;\n+import reactor.util.concurrent.Queues;\n+\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Function;\n+\n+/**\n+ * Variation of {@link QueryGateway}. Provides support for reactive return types such as {@link Mono} and {@link Flux}\n+ * from Project Reactor.\n+ *\n+ * @author Milan Savic\n+ * @since 4.4\n+ */\n+public interface ReactorQueryGateway extends ReactorMessageDispatchInterceptorSupport<QueryMessage<?, ?>>,\n+        ReactorResultHandlerInterceptorSupport<QueryMessage<?, ?>, ResultMessage<?>> {\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response with the given {@code responseType}\n+     * from a single source. The query name will be derived from the provided {@code query}. Execution may be\n+     * asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param query        The {@code query} to be sent\n+     * @param responseType A {@link Class} describing the desired response type\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(Q query, Class<R> responseType) {\n+        return query(query.getClass().getName(), query, responseType);\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response with the given {@code responseType}\n+     * from a single source. Execution may be asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(String queryName, Q query, Class<R> responseType) {\n+        return query(queryName, query, ResponseTypes.instanceOf(responseType));\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from a single source. The query name will be derived from the provided {@code query}. Execution may be\n+     * asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(Q query, ResponseType<R> responseType) {\n+        return query(query.getClass().getName(), query, responseType);\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from a single source. Execution may be asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    <R, Q> Mono<R> query(String queryName, Q query, ResponseType<R> responseType);\n+\n+    /**\n+     * Uses given Publisher of query messages to send incoming queries away. Queries will be sent sequentially - once a\n+     * result of Nth query arrives, (N + 1)th query is dispatched.\n+     *\n+     * @param queries a Publisher stream of queries to be dispatched\n+     * @return a Flux of query results. An ordering of query results corresponds to an ordering of queries being\n+     * dispatched\n+     *\n+     * @see #query(String, Object, ResponseType)\n+     * @see Flux#concatMap(Function)\n+     */\n+    default Flux<Object> query(Publisher<QueryMessage<?, ?>> queries) {\n+        return Flux.from(queries)\n+                   .concatMap(q -> query(q.getQueryName(), q.getPayload(), q.getResponseType()));\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from several sources. The returned {@link Flux} is completed when a {@code timeout} occurs or when all possible\n+     * results are received. The query name will be derived from the provided {@code query}. Execution may be\n+     * asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     * <b>Note</b>: Any {@code null} results will be filtered out by the {@link ReactorQueryGateway}. If you require\n+     * the {@code null} to be returned, we suggest using {@code QueryBus} instead.\n+     *\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param timeout      A timeout of {@code long} for the query\n+     * @param timeUnit     The selected {@link TimeUnit} for the given {@code timeout}\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Flux} containing the query results as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Flux<R> scatterGather(Q query, ResponseType<R> responseType, long timeout, TimeUnit timeUnit) {\n+        return scatterGather(query.getClass().getName(), query, responseType, timeout, timeUnit);\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from several sources. The returned {@link Flux} is completed when a {@code timeout} occurs or when all results\n+     * are received. Execution may be asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     * <b>Note</b>: Any {@code null} results will be filtered out by the {@link ReactorQueryGateway}. If you require\n+     * the {@code null} to be returned, we suggest using {@code QueryBus} instead.\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param timeout      A timeout of {@code long} for the query\n+     * @param timeUnit     The selected {@link TimeUnit} for the given {@code timeout}\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Flux} containing the query results as dictated by the given {@code responseType}\n+     */\n+    <R, Q> Flux<R> scatterGather(String queryName, Q query, ResponseType<R> responseType, long timeout,\n+                                 TimeUnit timeUnit);\n+\n+    /**\n+     * Uses given Publisher of queries to send incoming queries in scatter gather manner. Queries will be sent\n+     * sequentially - once a result of Nth query arrives, (N + 1)th query is dispatched. All queries will be dispatched\n+     * using given {@code timeout} and {@code timeUnit}.\n+     *\n+     * @param queries  a Publisher stream of queries to be dispatched\n+     * @param timeout  A timeout of {@code long} for the query\n+     * @param timeUnit The selected {@link TimeUnit} for the given {@code timeout}\n+     * @return a Flux of query results. An ordering of query results corresponds to an ordering of queries being\n+     * dispatched\n+     */\n+    default Flux<Object> scatterGather(Publisher<QueryMessage<?, ?>> queries, long timeout, TimeUnit timeUnit) {\n+        return Flux.from(queries)\n+                   .concatMap(q -> scatterGather(q.getQueryName(),\n+                                                 q.getPayload(),\n+                                                 q.getResponseType(),\n+                                                 timeout,\n+                                                 timeUnit));\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, returns initial result and keeps streaming\n+     * incremental updates until subscriber unsubscribes from Flux.\n+     * Should be used when response type of initial result and incremental update match.\n+     * (received at the moment the query is sent, until it is cancelled by the caller or closed by the emitting side).\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Flux}</b></p>\n+     * <p>\n+     * <b>Note</b>: Any {@code null} results, on the initial result or the updates, will be filtered out by the\n+     * {@link ReactorQueryGateway}. If you require the {@code null} to be returned for the initial and update results,\n+     * we suggest using the {@code QueryBus} instead.\n+     *\n+     * @param query      The {@code query} to be sent\n+     * @param resultType The response type used for this query\n+     * @param <Q>        The type of the query\n+     * @param <R>        The type of the result (initial & updates)\n+     * @return Flux which can be used to cancel receiving updates\n+     *\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage)\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage, SubscriptionQueryBackpressure, int)\n+     */\n+    default <Q, R> Flux<R> subscriptionQuery(Q query, ResponseType<R> resultType) {\n+        return subscriptionQuery(query, resultType, resultType)\n+                .flatMapMany(result -> result.initialResult()\n+                                             .concatWith(result.updates())\n+                                             .doFinally(signal -> result.close()));\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, returns initial result and keeps streaming\n+     * incremental updates until subscriber unsubscribes from Flux.\n+     * Should be used when response type of initial result and incremental update match.\n+     * (received at the moment the query is sent, until it is cancelled by the caller or closed by the emitting side).\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Flux}</b></p>\n+     * <p>\n+     * <b>Note</b>: Any {@code null} results, on the initial result or the updates, will be filtered out by the\n+     * {@link ReactorQueryGateway}. If you require the {@code null} to be returned for the initial and update results,\n+     * we suggest using the {@code QueryBus} instead.\n+     *\n+     * @param query      The {@code query} to be sent\n+     * @param resultType The response type used for this query\n+     * @param <Q>        The type of the query\n+     * @param <R>        The type of the result (initial & updates)\n+     * @return Flux which can be used to cancel receiving updates\n+     *\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage)\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage, SubscriptionQueryBackpressure, int)\n+     */\n+    default <Q, R> Flux<R> subscriptionQuery(Q query, Class<R> resultType) {\n+        return subscriptionQuery(query, ResponseTypes.instanceOf(resultType));\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, returns initial result and keeps streaming\n+     * incremental updates until subscriber unsubscribes from Flux.\n+     * Should be used when initial result contains multiple instances of response type and needs to be flatten.\n+     * Response type of initial response and incremental updates needs to match.\n+     * (received at the moment the query is sent, until it is cancelled by the caller or closed by the emitting side).\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Flux}</b></p>\n+     * <p>\n+     * <b>Note</b>: Any {@code null} results, on the initial result or the updates, will be filtered out by the\n+     * {@link ReactorQueryGateway}. If you require the {@code null} to be returned for the initial and update results,\n+     * we suggest using the {@code QueryBus} instead.\n+     *\n+     * @param query      The {@code query} to be sent\n+     * @param resultType The response type used for this query\n+     * @param <Q>        The type of the query\n+     * @param <R>        The type of the result (initial & updates)\n+     * @return Flux which can be used to cancel receiving updates\n+     *\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage)\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage, SubscriptionQueryBackpressure, int)\n+     */\n+    default <Q, R> Flux<R> subscriptionQueryMany(Q query, Class<R> resultType) {\n+        return subscriptionQuery(query,\n+                                 ResponseTypes.multipleInstancesOf(resultType),\n+                                 ResponseTypes.instanceOf(resultType))\n+                .flatMapMany(result -> result.initialResult()\n+                                             .flatMapMany(Flux::fromIterable)\n+                                             .concatWith(result.updates())\n+                                             .doFinally(signal -> result.close()));\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, and streams\n+     * incremental updates until subscriber unsubscribes from Flux.\n+     * Should be used when subscriber is interested only in updates.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Flux}</b></p>\n+     * <p>\n+     * <b>Note</b>: Any {@code null} results, will be filtered out by the\n+     * {@link ReactorQueryGateway}. If you require the {@code null} to be returned for the initial and update results,\n+     * we suggest using the {@code QueryBus} instead.\n+     *\n+     * @param query      The {@code query} to be sent\n+     * @param resultType The response type used for this query\n+     * @param <Q>        The type of the query\n+     * @param <R>        The type of the result (updates)\n+     * @return Flux which can be used to cancel receiving updates\n+     *\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage)\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage, SubscriptionQueryBackpressure, int)\n+     */\n+    default <Q, R> Flux<R> queryUpdates(Q query, ResponseType<R> resultType) {\n+        return subscriptionQuery(query, ResponseTypes.instanceOf(Void.class), resultType)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjcxNDU0MA=="}, "originalCommit": {"oid": "98865ab1427e4d879301c1bf542842eccc8aa3c3"}, "originalPosition": 293}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODA4NDEyMQ==", "bodyText": "Aaah gotcha, because this is just a query for the updates... Thanks for clarifying!", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r458084121", "createdAt": "2020-07-21T13:12:05Z", "author": {"login": "smcvb"}, "path": "messaging/src/main/java/org/axonframework/queryhandling/ReactorQueryGateway.java", "diffHunk": "@@ -0,0 +1,547 @@\n+/*\n+ * Copyright (c) 2010-2020. Axon Framework\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.axonframework.queryhandling;\n+\n+import org.axonframework.messaging.ResultMessage;\n+import org.axonframework.messaging.reactive.ReactorMessageDispatchInterceptorSupport;\n+import org.axonframework.messaging.reactive.ReactorResultHandlerInterceptorSupport;\n+import org.axonframework.messaging.responsetypes.ResponseType;\n+import org.axonframework.messaging.responsetypes.ResponseTypes;\n+import org.reactivestreams.Publisher;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Mono;\n+import reactor.util.concurrent.Queues;\n+\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Function;\n+\n+/**\n+ * Variation of {@link QueryGateway}. Provides support for reactive return types such as {@link Mono} and {@link Flux}\n+ * from Project Reactor.\n+ *\n+ * @author Milan Savic\n+ * @since 4.4\n+ */\n+public interface ReactorQueryGateway extends ReactorMessageDispatchInterceptorSupport<QueryMessage<?, ?>>,\n+        ReactorResultHandlerInterceptorSupport<QueryMessage<?, ?>, ResultMessage<?>> {\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response with the given {@code responseType}\n+     * from a single source. The query name will be derived from the provided {@code query}. Execution may be\n+     * asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param query        The {@code query} to be sent\n+     * @param responseType A {@link Class} describing the desired response type\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(Q query, Class<R> responseType) {\n+        return query(query.getClass().getName(), query, responseType);\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response with the given {@code responseType}\n+     * from a single source. Execution may be asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(String queryName, Q query, Class<R> responseType) {\n+        return query(queryName, query, ResponseTypes.instanceOf(responseType));\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from a single source. The query name will be derived from the provided {@code query}. Execution may be\n+     * asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(Q query, ResponseType<R> responseType) {\n+        return query(query.getClass().getName(), query, responseType);\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from a single source. Execution may be asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    <R, Q> Mono<R> query(String queryName, Q query, ResponseType<R> responseType);\n+\n+    /**\n+     * Uses given Publisher of query messages to send incoming queries away. Queries will be sent sequentially - once a\n+     * result of Nth query arrives, (N + 1)th query is dispatched.\n+     *\n+     * @param queries a Publisher stream of queries to be dispatched\n+     * @return a Flux of query results. An ordering of query results corresponds to an ordering of queries being\n+     * dispatched\n+     *\n+     * @see #query(String, Object, ResponseType)\n+     * @see Flux#concatMap(Function)\n+     */\n+    default Flux<Object> query(Publisher<QueryMessage<?, ?>> queries) {\n+        return Flux.from(queries)\n+                   .concatMap(q -> query(q.getQueryName(), q.getPayload(), q.getResponseType()));\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from several sources. The returned {@link Flux} is completed when a {@code timeout} occurs or when all possible\n+     * results are received. The query name will be derived from the provided {@code query}. Execution may be\n+     * asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     * <b>Note</b>: Any {@code null} results will be filtered out by the {@link ReactorQueryGateway}. If you require\n+     * the {@code null} to be returned, we suggest using {@code QueryBus} instead.\n+     *\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param timeout      A timeout of {@code long} for the query\n+     * @param timeUnit     The selected {@link TimeUnit} for the given {@code timeout}\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Flux} containing the query results as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Flux<R> scatterGather(Q query, ResponseType<R> responseType, long timeout, TimeUnit timeUnit) {\n+        return scatterGather(query.getClass().getName(), query, responseType, timeout, timeUnit);\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from several sources. The returned {@link Flux} is completed when a {@code timeout} occurs or when all results\n+     * are received. Execution may be asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     * <b>Note</b>: Any {@code null} results will be filtered out by the {@link ReactorQueryGateway}. If you require\n+     * the {@code null} to be returned, we suggest using {@code QueryBus} instead.\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param timeout      A timeout of {@code long} for the query\n+     * @param timeUnit     The selected {@link TimeUnit} for the given {@code timeout}\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Flux} containing the query results as dictated by the given {@code responseType}\n+     */\n+    <R, Q> Flux<R> scatterGather(String queryName, Q query, ResponseType<R> responseType, long timeout,\n+                                 TimeUnit timeUnit);\n+\n+    /**\n+     * Uses given Publisher of queries to send incoming queries in scatter gather manner. Queries will be sent\n+     * sequentially - once a result of Nth query arrives, (N + 1)th query is dispatched. All queries will be dispatched\n+     * using given {@code timeout} and {@code timeUnit}.\n+     *\n+     * @param queries  a Publisher stream of queries to be dispatched\n+     * @param timeout  A timeout of {@code long} for the query\n+     * @param timeUnit The selected {@link TimeUnit} for the given {@code timeout}\n+     * @return a Flux of query results. An ordering of query results corresponds to an ordering of queries being\n+     * dispatched\n+     */\n+    default Flux<Object> scatterGather(Publisher<QueryMessage<?, ?>> queries, long timeout, TimeUnit timeUnit) {\n+        return Flux.from(queries)\n+                   .concatMap(q -> scatterGather(q.getQueryName(),\n+                                                 q.getPayload(),\n+                                                 q.getResponseType(),\n+                                                 timeout,\n+                                                 timeUnit));\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, returns initial result and keeps streaming\n+     * incremental updates until subscriber unsubscribes from Flux.\n+     * Should be used when response type of initial result and incremental update match.\n+     * (received at the moment the query is sent, until it is cancelled by the caller or closed by the emitting side).\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Flux}</b></p>\n+     * <p>\n+     * <b>Note</b>: Any {@code null} results, on the initial result or the updates, will be filtered out by the\n+     * {@link ReactorQueryGateway}. If you require the {@code null} to be returned for the initial and update results,\n+     * we suggest using the {@code QueryBus} instead.\n+     *\n+     * @param query      The {@code query} to be sent\n+     * @param resultType The response type used for this query\n+     * @param <Q>        The type of the query\n+     * @param <R>        The type of the result (initial & updates)\n+     * @return Flux which can be used to cancel receiving updates\n+     *\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage)\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage, SubscriptionQueryBackpressure, int)\n+     */\n+    default <Q, R> Flux<R> subscriptionQuery(Q query, ResponseType<R> resultType) {\n+        return subscriptionQuery(query, resultType, resultType)\n+                .flatMapMany(result -> result.initialResult()\n+                                             .concatWith(result.updates())\n+                                             .doFinally(signal -> result.close()));\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, returns initial result and keeps streaming\n+     * incremental updates until subscriber unsubscribes from Flux.\n+     * Should be used when response type of initial result and incremental update match.\n+     * (received at the moment the query is sent, until it is cancelled by the caller or closed by the emitting side).\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Flux}</b></p>\n+     * <p>\n+     * <b>Note</b>: Any {@code null} results, on the initial result or the updates, will be filtered out by the\n+     * {@link ReactorQueryGateway}. If you require the {@code null} to be returned for the initial and update results,\n+     * we suggest using the {@code QueryBus} instead.\n+     *\n+     * @param query      The {@code query} to be sent\n+     * @param resultType The response type used for this query\n+     * @param <Q>        The type of the query\n+     * @param <R>        The type of the result (initial & updates)\n+     * @return Flux which can be used to cancel receiving updates\n+     *\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage)\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage, SubscriptionQueryBackpressure, int)\n+     */\n+    default <Q, R> Flux<R> subscriptionQuery(Q query, Class<R> resultType) {\n+        return subscriptionQuery(query, ResponseTypes.instanceOf(resultType));\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, returns initial result and keeps streaming\n+     * incremental updates until subscriber unsubscribes from Flux.\n+     * Should be used when initial result contains multiple instances of response type and needs to be flatten.\n+     * Response type of initial response and incremental updates needs to match.\n+     * (received at the moment the query is sent, until it is cancelled by the caller or closed by the emitting side).\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Flux}</b></p>\n+     * <p>\n+     * <b>Note</b>: Any {@code null} results, on the initial result or the updates, will be filtered out by the\n+     * {@link ReactorQueryGateway}. If you require the {@code null} to be returned for the initial and update results,\n+     * we suggest using the {@code QueryBus} instead.\n+     *\n+     * @param query      The {@code query} to be sent\n+     * @param resultType The response type used for this query\n+     * @param <Q>        The type of the query\n+     * @param <R>        The type of the result (initial & updates)\n+     * @return Flux which can be used to cancel receiving updates\n+     *\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage)\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage, SubscriptionQueryBackpressure, int)\n+     */\n+    default <Q, R> Flux<R> subscriptionQueryMany(Q query, Class<R> resultType) {\n+        return subscriptionQuery(query,\n+                                 ResponseTypes.multipleInstancesOf(resultType),\n+                                 ResponseTypes.instanceOf(resultType))\n+                .flatMapMany(result -> result.initialResult()\n+                                             .flatMapMany(Flux::fromIterable)\n+                                             .concatWith(result.updates())\n+                                             .doFinally(signal -> result.close()));\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, and streams\n+     * incremental updates until subscriber unsubscribes from Flux.\n+     * Should be used when subscriber is interested only in updates.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Flux}</b></p>\n+     * <p>\n+     * <b>Note</b>: Any {@code null} results, will be filtered out by the\n+     * {@link ReactorQueryGateway}. If you require the {@code null} to be returned for the initial and update results,\n+     * we suggest using the {@code QueryBus} instead.\n+     *\n+     * @param query      The {@code query} to be sent\n+     * @param resultType The response type used for this query\n+     * @param <Q>        The type of the query\n+     * @param <R>        The type of the result (updates)\n+     * @return Flux which can be used to cancel receiving updates\n+     *\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage)\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage, SubscriptionQueryBackpressure, int)\n+     */\n+    default <Q, R> Flux<R> queryUpdates(Q query, ResponseType<R> resultType) {\n+        return subscriptionQuery(query, ResponseTypes.instanceOf(Void.class), resultType)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjcxNDU0MA=="}, "originalCommit": {"oid": "98865ab1427e4d879301c1bf542842eccc8aa3c3"}, "originalPosition": 293}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgyMjczNzU1OnYy", "diffSide": "RIGHT", "path": "messaging/src/main/java/org/axonframework/queryhandling/ReactorQueryGateway.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xMFQwODo1NjowMVrOGvvhBQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xMFQxMToyMDoxOVrOGvzslA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjcxNDc1Nw==", "bodyText": "Using \"note\" to start two sentences in a row feels kinda off. Might be nice to rephrase this slightly.", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r452714757", "createdAt": "2020-07-10T08:56:01Z", "author": {"login": "smcvb"}, "path": "messaging/src/main/java/org/axonframework/queryhandling/ReactorQueryGateway.java", "diffHunk": "@@ -0,0 +1,547 @@\n+/*\n+ * Copyright (c) 2010-2020. Axon Framework\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.axonframework.queryhandling;\n+\n+import org.axonframework.messaging.ResultMessage;\n+import org.axonframework.messaging.reactive.ReactorMessageDispatchInterceptorSupport;\n+import org.axonframework.messaging.reactive.ReactorResultHandlerInterceptorSupport;\n+import org.axonframework.messaging.responsetypes.ResponseType;\n+import org.axonframework.messaging.responsetypes.ResponseTypes;\n+import org.reactivestreams.Publisher;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Mono;\n+import reactor.util.concurrent.Queues;\n+\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Function;\n+\n+/**\n+ * Variation of {@link QueryGateway}. Provides support for reactive return types such as {@link Mono} and {@link Flux}\n+ * from Project Reactor.\n+ *\n+ * @author Milan Savic\n+ * @since 4.4\n+ */\n+public interface ReactorQueryGateway extends ReactorMessageDispatchInterceptorSupport<QueryMessage<?, ?>>,\n+        ReactorResultHandlerInterceptorSupport<QueryMessage<?, ?>, ResultMessage<?>> {\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response with the given {@code responseType}\n+     * from a single source. The query name will be derived from the provided {@code query}. Execution may be\n+     * asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param query        The {@code query} to be sent\n+     * @param responseType A {@link Class} describing the desired response type\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(Q query, Class<R> responseType) {\n+        return query(query.getClass().getName(), query, responseType);\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response with the given {@code responseType}\n+     * from a single source. Execution may be asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(String queryName, Q query, Class<R> responseType) {\n+        return query(queryName, query, ResponseTypes.instanceOf(responseType));\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from a single source. The query name will be derived from the provided {@code query}. Execution may be\n+     * asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(Q query, ResponseType<R> responseType) {\n+        return query(query.getClass().getName(), query, responseType);\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from a single source. Execution may be asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    <R, Q> Mono<R> query(String queryName, Q query, ResponseType<R> responseType);\n+\n+    /**\n+     * Uses given Publisher of query messages to send incoming queries away. Queries will be sent sequentially - once a\n+     * result of Nth query arrives, (N + 1)th query is dispatched.\n+     *\n+     * @param queries a Publisher stream of queries to be dispatched\n+     * @return a Flux of query results. An ordering of query results corresponds to an ordering of queries being\n+     * dispatched\n+     *\n+     * @see #query(String, Object, ResponseType)\n+     * @see Flux#concatMap(Function)\n+     */\n+    default Flux<Object> query(Publisher<QueryMessage<?, ?>> queries) {\n+        return Flux.from(queries)\n+                   .concatMap(q -> query(q.getQueryName(), q.getPayload(), q.getResponseType()));\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from several sources. The returned {@link Flux} is completed when a {@code timeout} occurs or when all possible\n+     * results are received. The query name will be derived from the provided {@code query}. Execution may be\n+     * asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     * <b>Note</b>: Any {@code null} results will be filtered out by the {@link ReactorQueryGateway}. If you require\n+     * the {@code null} to be returned, we suggest using {@code QueryBus} instead.\n+     *\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param timeout      A timeout of {@code long} for the query\n+     * @param timeUnit     The selected {@link TimeUnit} for the given {@code timeout}\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Flux} containing the query results as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Flux<R> scatterGather(Q query, ResponseType<R> responseType, long timeout, TimeUnit timeUnit) {\n+        return scatterGather(query.getClass().getName(), query, responseType, timeout, timeUnit);\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from several sources. The returned {@link Flux} is completed when a {@code timeout} occurs or when all results\n+     * are received. Execution may be asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     * <b>Note</b>: Any {@code null} results will be filtered out by the {@link ReactorQueryGateway}. If you require\n+     * the {@code null} to be returned, we suggest using {@code QueryBus} instead.\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param timeout      A timeout of {@code long} for the query\n+     * @param timeUnit     The selected {@link TimeUnit} for the given {@code timeout}\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Flux} containing the query results as dictated by the given {@code responseType}\n+     */\n+    <R, Q> Flux<R> scatterGather(String queryName, Q query, ResponseType<R> responseType, long timeout,\n+                                 TimeUnit timeUnit);\n+\n+    /**\n+     * Uses given Publisher of queries to send incoming queries in scatter gather manner. Queries will be sent\n+     * sequentially - once a result of Nth query arrives, (N + 1)th query is dispatched. All queries will be dispatched\n+     * using given {@code timeout} and {@code timeUnit}.\n+     *\n+     * @param queries  a Publisher stream of queries to be dispatched\n+     * @param timeout  A timeout of {@code long} for the query\n+     * @param timeUnit The selected {@link TimeUnit} for the given {@code timeout}\n+     * @return a Flux of query results. An ordering of query results corresponds to an ordering of queries being\n+     * dispatched\n+     */\n+    default Flux<Object> scatterGather(Publisher<QueryMessage<?, ?>> queries, long timeout, TimeUnit timeUnit) {\n+        return Flux.from(queries)\n+                   .concatMap(q -> scatterGather(q.getQueryName(),\n+                                                 q.getPayload(),\n+                                                 q.getResponseType(),\n+                                                 timeout,\n+                                                 timeUnit));\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, returns initial result and keeps streaming\n+     * incremental updates until subscriber unsubscribes from Flux.\n+     * Should be used when response type of initial result and incremental update match.\n+     * (received at the moment the query is sent, until it is cancelled by the caller or closed by the emitting side).\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Flux}</b></p>\n+     * <p>\n+     * <b>Note</b>: Any {@code null} results, on the initial result or the updates, will be filtered out by the\n+     * {@link ReactorQueryGateway}. If you require the {@code null} to be returned for the initial and update results,\n+     * we suggest using the {@code QueryBus} instead.\n+     *\n+     * @param query      The {@code query} to be sent\n+     * @param resultType The response type used for this query\n+     * @param <Q>        The type of the query\n+     * @param <R>        The type of the result (initial & updates)\n+     * @return Flux which can be used to cancel receiving updates\n+     *\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage)\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage, SubscriptionQueryBackpressure, int)\n+     */\n+    default <Q, R> Flux<R> subscriptionQuery(Q query, ResponseType<R> resultType) {\n+        return subscriptionQuery(query, resultType, resultType)\n+                .flatMapMany(result -> result.initialResult()\n+                                             .concatWith(result.updates())\n+                                             .doFinally(signal -> result.close()));\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, returns initial result and keeps streaming\n+     * incremental updates until subscriber unsubscribes from Flux.\n+     * Should be used when response type of initial result and incremental update match.\n+     * (received at the moment the query is sent, until it is cancelled by the caller or closed by the emitting side).\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Flux}</b></p>\n+     * <p>\n+     * <b>Note</b>: Any {@code null} results, on the initial result or the updates, will be filtered out by the\n+     * {@link ReactorQueryGateway}. If you require the {@code null} to be returned for the initial and update results,\n+     * we suggest using the {@code QueryBus} instead.\n+     *\n+     * @param query      The {@code query} to be sent\n+     * @param resultType The response type used for this query\n+     * @param <Q>        The type of the query\n+     * @param <R>        The type of the result (initial & updates)\n+     * @return Flux which can be used to cancel receiving updates\n+     *\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage)\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage, SubscriptionQueryBackpressure, int)\n+     */\n+    default <Q, R> Flux<R> subscriptionQuery(Q query, Class<R> resultType) {\n+        return subscriptionQuery(query, ResponseTypes.instanceOf(resultType));\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, returns initial result and keeps streaming\n+     * incremental updates until subscriber unsubscribes from Flux.\n+     * Should be used when initial result contains multiple instances of response type and needs to be flatten.\n+     * Response type of initial response and incremental updates needs to match.\n+     * (received at the moment the query is sent, until it is cancelled by the caller or closed by the emitting side).\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Flux}</b></p>\n+     * <p>\n+     * <b>Note</b>: Any {@code null} results, on the initial result or the updates, will be filtered out by the\n+     * {@link ReactorQueryGateway}. If you require the {@code null} to be returned for the initial and update results,\n+     * we suggest using the {@code QueryBus} instead.\n+     *\n+     * @param query      The {@code query} to be sent\n+     * @param resultType The response type used for this query\n+     * @param <Q>        The type of the query\n+     * @param <R>        The type of the result (initial & updates)\n+     * @return Flux which can be used to cancel receiving updates\n+     *\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage)\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage, SubscriptionQueryBackpressure, int)\n+     */\n+    default <Q, R> Flux<R> subscriptionQueryMany(Q query, Class<R> resultType) {\n+        return subscriptionQuery(query,\n+                                 ResponseTypes.multipleInstancesOf(resultType),\n+                                 ResponseTypes.instanceOf(resultType))\n+                .flatMapMany(result -> result.initialResult()\n+                                             .flatMapMany(Flux::fromIterable)\n+                                             .concatWith(result.updates())\n+                                             .doFinally(signal -> result.close()));\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, and streams\n+     * incremental updates until subscriber unsubscribes from Flux.\n+     * Should be used when subscriber is interested only in updates.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Flux}</b></p>\n+     * <p>\n+     * <b>Note</b>: Any {@code null} results, will be filtered out by the\n+     * {@link ReactorQueryGateway}. If you require the {@code null} to be returned for the initial and update results,\n+     * we suggest using the {@code QueryBus} instead.\n+     *\n+     * @param query      The {@code query} to be sent\n+     * @param resultType The response type used for this query\n+     * @param <Q>        The type of the query\n+     * @param <R>        The type of the result (updates)\n+     * @return Flux which can be used to cancel receiving updates\n+     *\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage)\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage, SubscriptionQueryBackpressure, int)\n+     */\n+    default <Q, R> Flux<R> queryUpdates(Q query, ResponseType<R> resultType) {\n+        return subscriptionQuery(query, ResponseTypes.instanceOf(Void.class), resultType)\n+                .flatMapMany(result -> result.updates()\n+                                             .doFinally(signal -> result.close()));\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, and streams\n+     * incremental updates until subscriber unsubscribes from Flux.\n+     * Should be used when subscriber is interested only in updates.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Flux}</b></p>\n+     * <p>\n+     * <b>Note</b>: Any {@code null} results, will be filtered out by the\n+     * {@link ReactorQueryGateway}. If you require the {@code null} to be returned for the initial and update results,\n+     * we suggest using the {@code QueryBus} instead.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "98865ab1427e4d879301c1bf542842eccc8aa3c3"}, "originalPosition": 307}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mjc4MzI1Mg==", "bodyText": "I see it come back in the other subscription query methods too, so I'll stop copying this comment.", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r452783252", "createdAt": "2020-07-10T11:20:19Z", "author": {"login": "smcvb"}, "path": "messaging/src/main/java/org/axonframework/queryhandling/ReactorQueryGateway.java", "diffHunk": "@@ -0,0 +1,547 @@\n+/*\n+ * Copyright (c) 2010-2020. Axon Framework\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.axonframework.queryhandling;\n+\n+import org.axonframework.messaging.ResultMessage;\n+import org.axonframework.messaging.reactive.ReactorMessageDispatchInterceptorSupport;\n+import org.axonframework.messaging.reactive.ReactorResultHandlerInterceptorSupport;\n+import org.axonframework.messaging.responsetypes.ResponseType;\n+import org.axonframework.messaging.responsetypes.ResponseTypes;\n+import org.reactivestreams.Publisher;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Mono;\n+import reactor.util.concurrent.Queues;\n+\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Function;\n+\n+/**\n+ * Variation of {@link QueryGateway}. Provides support for reactive return types such as {@link Mono} and {@link Flux}\n+ * from Project Reactor.\n+ *\n+ * @author Milan Savic\n+ * @since 4.4\n+ */\n+public interface ReactorQueryGateway extends ReactorMessageDispatchInterceptorSupport<QueryMessage<?, ?>>,\n+        ReactorResultHandlerInterceptorSupport<QueryMessage<?, ?>, ResultMessage<?>> {\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response with the given {@code responseType}\n+     * from a single source. The query name will be derived from the provided {@code query}. Execution may be\n+     * asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param query        The {@code query} to be sent\n+     * @param responseType A {@link Class} describing the desired response type\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(Q query, Class<R> responseType) {\n+        return query(query.getClass().getName(), query, responseType);\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response with the given {@code responseType}\n+     * from a single source. Execution may be asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(String queryName, Q query, Class<R> responseType) {\n+        return query(queryName, query, ResponseTypes.instanceOf(responseType));\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from a single source. The query name will be derived from the provided {@code query}. Execution may be\n+     * asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(Q query, ResponseType<R> responseType) {\n+        return query(query.getClass().getName(), query, responseType);\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from a single source. Execution may be asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    <R, Q> Mono<R> query(String queryName, Q query, ResponseType<R> responseType);\n+\n+    /**\n+     * Uses given Publisher of query messages to send incoming queries away. Queries will be sent sequentially - once a\n+     * result of Nth query arrives, (N + 1)th query is dispatched.\n+     *\n+     * @param queries a Publisher stream of queries to be dispatched\n+     * @return a Flux of query results. An ordering of query results corresponds to an ordering of queries being\n+     * dispatched\n+     *\n+     * @see #query(String, Object, ResponseType)\n+     * @see Flux#concatMap(Function)\n+     */\n+    default Flux<Object> query(Publisher<QueryMessage<?, ?>> queries) {\n+        return Flux.from(queries)\n+                   .concatMap(q -> query(q.getQueryName(), q.getPayload(), q.getResponseType()));\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from several sources. The returned {@link Flux} is completed when a {@code timeout} occurs or when all possible\n+     * results are received. The query name will be derived from the provided {@code query}. Execution may be\n+     * asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     * <b>Note</b>: Any {@code null} results will be filtered out by the {@link ReactorQueryGateway}. If you require\n+     * the {@code null} to be returned, we suggest using {@code QueryBus} instead.\n+     *\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param timeout      A timeout of {@code long} for the query\n+     * @param timeUnit     The selected {@link TimeUnit} for the given {@code timeout}\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Flux} containing the query results as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Flux<R> scatterGather(Q query, ResponseType<R> responseType, long timeout, TimeUnit timeUnit) {\n+        return scatterGather(query.getClass().getName(), query, responseType, timeout, timeUnit);\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from several sources. The returned {@link Flux} is completed when a {@code timeout} occurs or when all results\n+     * are received. Execution may be asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     * <b>Note</b>: Any {@code null} results will be filtered out by the {@link ReactorQueryGateway}. If you require\n+     * the {@code null} to be returned, we suggest using {@code QueryBus} instead.\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param timeout      A timeout of {@code long} for the query\n+     * @param timeUnit     The selected {@link TimeUnit} for the given {@code timeout}\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Flux} containing the query results as dictated by the given {@code responseType}\n+     */\n+    <R, Q> Flux<R> scatterGather(String queryName, Q query, ResponseType<R> responseType, long timeout,\n+                                 TimeUnit timeUnit);\n+\n+    /**\n+     * Uses given Publisher of queries to send incoming queries in scatter gather manner. Queries will be sent\n+     * sequentially - once a result of Nth query arrives, (N + 1)th query is dispatched. All queries will be dispatched\n+     * using given {@code timeout} and {@code timeUnit}.\n+     *\n+     * @param queries  a Publisher stream of queries to be dispatched\n+     * @param timeout  A timeout of {@code long} for the query\n+     * @param timeUnit The selected {@link TimeUnit} for the given {@code timeout}\n+     * @return a Flux of query results. An ordering of query results corresponds to an ordering of queries being\n+     * dispatched\n+     */\n+    default Flux<Object> scatterGather(Publisher<QueryMessage<?, ?>> queries, long timeout, TimeUnit timeUnit) {\n+        return Flux.from(queries)\n+                   .concatMap(q -> scatterGather(q.getQueryName(),\n+                                                 q.getPayload(),\n+                                                 q.getResponseType(),\n+                                                 timeout,\n+                                                 timeUnit));\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, returns initial result and keeps streaming\n+     * incremental updates until subscriber unsubscribes from Flux.\n+     * Should be used when response type of initial result and incremental update match.\n+     * (received at the moment the query is sent, until it is cancelled by the caller or closed by the emitting side).\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Flux}</b></p>\n+     * <p>\n+     * <b>Note</b>: Any {@code null} results, on the initial result or the updates, will be filtered out by the\n+     * {@link ReactorQueryGateway}. If you require the {@code null} to be returned for the initial and update results,\n+     * we suggest using the {@code QueryBus} instead.\n+     *\n+     * @param query      The {@code query} to be sent\n+     * @param resultType The response type used for this query\n+     * @param <Q>        The type of the query\n+     * @param <R>        The type of the result (initial & updates)\n+     * @return Flux which can be used to cancel receiving updates\n+     *\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage)\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage, SubscriptionQueryBackpressure, int)\n+     */\n+    default <Q, R> Flux<R> subscriptionQuery(Q query, ResponseType<R> resultType) {\n+        return subscriptionQuery(query, resultType, resultType)\n+                .flatMapMany(result -> result.initialResult()\n+                                             .concatWith(result.updates())\n+                                             .doFinally(signal -> result.close()));\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, returns initial result and keeps streaming\n+     * incremental updates until subscriber unsubscribes from Flux.\n+     * Should be used when response type of initial result and incremental update match.\n+     * (received at the moment the query is sent, until it is cancelled by the caller or closed by the emitting side).\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Flux}</b></p>\n+     * <p>\n+     * <b>Note</b>: Any {@code null} results, on the initial result or the updates, will be filtered out by the\n+     * {@link ReactorQueryGateway}. If you require the {@code null} to be returned for the initial and update results,\n+     * we suggest using the {@code QueryBus} instead.\n+     *\n+     * @param query      The {@code query} to be sent\n+     * @param resultType The response type used for this query\n+     * @param <Q>        The type of the query\n+     * @param <R>        The type of the result (initial & updates)\n+     * @return Flux which can be used to cancel receiving updates\n+     *\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage)\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage, SubscriptionQueryBackpressure, int)\n+     */\n+    default <Q, R> Flux<R> subscriptionQuery(Q query, Class<R> resultType) {\n+        return subscriptionQuery(query, ResponseTypes.instanceOf(resultType));\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, returns initial result and keeps streaming\n+     * incremental updates until subscriber unsubscribes from Flux.\n+     * Should be used when initial result contains multiple instances of response type and needs to be flatten.\n+     * Response type of initial response and incremental updates needs to match.\n+     * (received at the moment the query is sent, until it is cancelled by the caller or closed by the emitting side).\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Flux}</b></p>\n+     * <p>\n+     * <b>Note</b>: Any {@code null} results, on the initial result or the updates, will be filtered out by the\n+     * {@link ReactorQueryGateway}. If you require the {@code null} to be returned for the initial and update results,\n+     * we suggest using the {@code QueryBus} instead.\n+     *\n+     * @param query      The {@code query} to be sent\n+     * @param resultType The response type used for this query\n+     * @param <Q>        The type of the query\n+     * @param <R>        The type of the result (initial & updates)\n+     * @return Flux which can be used to cancel receiving updates\n+     *\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage)\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage, SubscriptionQueryBackpressure, int)\n+     */\n+    default <Q, R> Flux<R> subscriptionQueryMany(Q query, Class<R> resultType) {\n+        return subscriptionQuery(query,\n+                                 ResponseTypes.multipleInstancesOf(resultType),\n+                                 ResponseTypes.instanceOf(resultType))\n+                .flatMapMany(result -> result.initialResult()\n+                                             .flatMapMany(Flux::fromIterable)\n+                                             .concatWith(result.updates())\n+                                             .doFinally(signal -> result.close()));\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, and streams\n+     * incremental updates until subscriber unsubscribes from Flux.\n+     * Should be used when subscriber is interested only in updates.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Flux}</b></p>\n+     * <p>\n+     * <b>Note</b>: Any {@code null} results, will be filtered out by the\n+     * {@link ReactorQueryGateway}. If you require the {@code null} to be returned for the initial and update results,\n+     * we suggest using the {@code QueryBus} instead.\n+     *\n+     * @param query      The {@code query} to be sent\n+     * @param resultType The response type used for this query\n+     * @param <Q>        The type of the query\n+     * @param <R>        The type of the result (updates)\n+     * @return Flux which can be used to cancel receiving updates\n+     *\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage)\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage, SubscriptionQueryBackpressure, int)\n+     */\n+    default <Q, R> Flux<R> queryUpdates(Q query, ResponseType<R> resultType) {\n+        return subscriptionQuery(query, ResponseTypes.instanceOf(Void.class), resultType)\n+                .flatMapMany(result -> result.updates()\n+                                             .doFinally(signal -> result.close()));\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, and streams\n+     * incremental updates until subscriber unsubscribes from Flux.\n+     * Should be used when subscriber is interested only in updates.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Flux}</b></p>\n+     * <p>\n+     * <b>Note</b>: Any {@code null} results, will be filtered out by the\n+     * {@link ReactorQueryGateway}. If you require the {@code null} to be returned for the initial and update results,\n+     * we suggest using the {@code QueryBus} instead.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjcxNDc1Nw=="}, "originalCommit": {"oid": "98865ab1427e4d879301c1bf542842eccc8aa3c3"}, "originalPosition": 307}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgyMjczOTAwOnYy", "diffSide": "RIGHT", "path": "messaging/src/main/java/org/axonframework/queryhandling/ReactorQueryGateway.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xMFQwODo1NjoyN1rOGvvh9g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xMFQwODo1NjoyN1rOGvvh9g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjcxNDk5OA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * Sends the given {@code query} over the {@link QueryBus}, and streams\n          \n          \n            \n                 * incremental updates until subscriber unsubscribes from Flux.\n          \n          \n            \n                 * Should be used when subscriber is interested only in updates.\n          \n          \n            \n                 * Sends the given {@code query} over the {@link QueryBus}, streaming\n          \n          \n            \n                 * incremental updates until hte subscriber unsubscribes from the resulting {@link Flux}.\n          \n          \n            \n                 * Should be used when the subscriber is interested only in updates.", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r452714998", "createdAt": "2020-07-10T08:56:27Z", "author": {"login": "smcvb"}, "path": "messaging/src/main/java/org/axonframework/queryhandling/ReactorQueryGateway.java", "diffHunk": "@@ -0,0 +1,547 @@\n+/*\n+ * Copyright (c) 2010-2020. Axon Framework\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.axonframework.queryhandling;\n+\n+import org.axonframework.messaging.ResultMessage;\n+import org.axonframework.messaging.reactive.ReactorMessageDispatchInterceptorSupport;\n+import org.axonframework.messaging.reactive.ReactorResultHandlerInterceptorSupport;\n+import org.axonframework.messaging.responsetypes.ResponseType;\n+import org.axonframework.messaging.responsetypes.ResponseTypes;\n+import org.reactivestreams.Publisher;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Mono;\n+import reactor.util.concurrent.Queues;\n+\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Function;\n+\n+/**\n+ * Variation of {@link QueryGateway}. Provides support for reactive return types such as {@link Mono} and {@link Flux}\n+ * from Project Reactor.\n+ *\n+ * @author Milan Savic\n+ * @since 4.4\n+ */\n+public interface ReactorQueryGateway extends ReactorMessageDispatchInterceptorSupport<QueryMessage<?, ?>>,\n+        ReactorResultHandlerInterceptorSupport<QueryMessage<?, ?>, ResultMessage<?>> {\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response with the given {@code responseType}\n+     * from a single source. The query name will be derived from the provided {@code query}. Execution may be\n+     * asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param query        The {@code query} to be sent\n+     * @param responseType A {@link Class} describing the desired response type\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(Q query, Class<R> responseType) {\n+        return query(query.getClass().getName(), query, responseType);\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response with the given {@code responseType}\n+     * from a single source. Execution may be asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(String queryName, Q query, Class<R> responseType) {\n+        return query(queryName, query, ResponseTypes.instanceOf(responseType));\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from a single source. The query name will be derived from the provided {@code query}. Execution may be\n+     * asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(Q query, ResponseType<R> responseType) {\n+        return query(query.getClass().getName(), query, responseType);\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from a single source. Execution may be asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    <R, Q> Mono<R> query(String queryName, Q query, ResponseType<R> responseType);\n+\n+    /**\n+     * Uses given Publisher of query messages to send incoming queries away. Queries will be sent sequentially - once a\n+     * result of Nth query arrives, (N + 1)th query is dispatched.\n+     *\n+     * @param queries a Publisher stream of queries to be dispatched\n+     * @return a Flux of query results. An ordering of query results corresponds to an ordering of queries being\n+     * dispatched\n+     *\n+     * @see #query(String, Object, ResponseType)\n+     * @see Flux#concatMap(Function)\n+     */\n+    default Flux<Object> query(Publisher<QueryMessage<?, ?>> queries) {\n+        return Flux.from(queries)\n+                   .concatMap(q -> query(q.getQueryName(), q.getPayload(), q.getResponseType()));\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from several sources. The returned {@link Flux} is completed when a {@code timeout} occurs or when all possible\n+     * results are received. The query name will be derived from the provided {@code query}. Execution may be\n+     * asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     * <b>Note</b>: Any {@code null} results will be filtered out by the {@link ReactorQueryGateway}. If you require\n+     * the {@code null} to be returned, we suggest using {@code QueryBus} instead.\n+     *\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param timeout      A timeout of {@code long} for the query\n+     * @param timeUnit     The selected {@link TimeUnit} for the given {@code timeout}\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Flux} containing the query results as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Flux<R> scatterGather(Q query, ResponseType<R> responseType, long timeout, TimeUnit timeUnit) {\n+        return scatterGather(query.getClass().getName(), query, responseType, timeout, timeUnit);\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from several sources. The returned {@link Flux} is completed when a {@code timeout} occurs or when all results\n+     * are received. Execution may be asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     * <b>Note</b>: Any {@code null} results will be filtered out by the {@link ReactorQueryGateway}. If you require\n+     * the {@code null} to be returned, we suggest using {@code QueryBus} instead.\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param timeout      A timeout of {@code long} for the query\n+     * @param timeUnit     The selected {@link TimeUnit} for the given {@code timeout}\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Flux} containing the query results as dictated by the given {@code responseType}\n+     */\n+    <R, Q> Flux<R> scatterGather(String queryName, Q query, ResponseType<R> responseType, long timeout,\n+                                 TimeUnit timeUnit);\n+\n+    /**\n+     * Uses given Publisher of queries to send incoming queries in scatter gather manner. Queries will be sent\n+     * sequentially - once a result of Nth query arrives, (N + 1)th query is dispatched. All queries will be dispatched\n+     * using given {@code timeout} and {@code timeUnit}.\n+     *\n+     * @param queries  a Publisher stream of queries to be dispatched\n+     * @param timeout  A timeout of {@code long} for the query\n+     * @param timeUnit The selected {@link TimeUnit} for the given {@code timeout}\n+     * @return a Flux of query results. An ordering of query results corresponds to an ordering of queries being\n+     * dispatched\n+     */\n+    default Flux<Object> scatterGather(Publisher<QueryMessage<?, ?>> queries, long timeout, TimeUnit timeUnit) {\n+        return Flux.from(queries)\n+                   .concatMap(q -> scatterGather(q.getQueryName(),\n+                                                 q.getPayload(),\n+                                                 q.getResponseType(),\n+                                                 timeout,\n+                                                 timeUnit));\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, returns initial result and keeps streaming\n+     * incremental updates until subscriber unsubscribes from Flux.\n+     * Should be used when response type of initial result and incremental update match.\n+     * (received at the moment the query is sent, until it is cancelled by the caller or closed by the emitting side).\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Flux}</b></p>\n+     * <p>\n+     * <b>Note</b>: Any {@code null} results, on the initial result or the updates, will be filtered out by the\n+     * {@link ReactorQueryGateway}. If you require the {@code null} to be returned for the initial and update results,\n+     * we suggest using the {@code QueryBus} instead.\n+     *\n+     * @param query      The {@code query} to be sent\n+     * @param resultType The response type used for this query\n+     * @param <Q>        The type of the query\n+     * @param <R>        The type of the result (initial & updates)\n+     * @return Flux which can be used to cancel receiving updates\n+     *\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage)\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage, SubscriptionQueryBackpressure, int)\n+     */\n+    default <Q, R> Flux<R> subscriptionQuery(Q query, ResponseType<R> resultType) {\n+        return subscriptionQuery(query, resultType, resultType)\n+                .flatMapMany(result -> result.initialResult()\n+                                             .concatWith(result.updates())\n+                                             .doFinally(signal -> result.close()));\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, returns initial result and keeps streaming\n+     * incremental updates until subscriber unsubscribes from Flux.\n+     * Should be used when response type of initial result and incremental update match.\n+     * (received at the moment the query is sent, until it is cancelled by the caller or closed by the emitting side).\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Flux}</b></p>\n+     * <p>\n+     * <b>Note</b>: Any {@code null} results, on the initial result or the updates, will be filtered out by the\n+     * {@link ReactorQueryGateway}. If you require the {@code null} to be returned for the initial and update results,\n+     * we suggest using the {@code QueryBus} instead.\n+     *\n+     * @param query      The {@code query} to be sent\n+     * @param resultType The response type used for this query\n+     * @param <Q>        The type of the query\n+     * @param <R>        The type of the result (initial & updates)\n+     * @return Flux which can be used to cancel receiving updates\n+     *\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage)\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage, SubscriptionQueryBackpressure, int)\n+     */\n+    default <Q, R> Flux<R> subscriptionQuery(Q query, Class<R> resultType) {\n+        return subscriptionQuery(query, ResponseTypes.instanceOf(resultType));\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, returns initial result and keeps streaming\n+     * incremental updates until subscriber unsubscribes from Flux.\n+     * Should be used when initial result contains multiple instances of response type and needs to be flatten.\n+     * Response type of initial response and incremental updates needs to match.\n+     * (received at the moment the query is sent, until it is cancelled by the caller or closed by the emitting side).\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Flux}</b></p>\n+     * <p>\n+     * <b>Note</b>: Any {@code null} results, on the initial result or the updates, will be filtered out by the\n+     * {@link ReactorQueryGateway}. If you require the {@code null} to be returned for the initial and update results,\n+     * we suggest using the {@code QueryBus} instead.\n+     *\n+     * @param query      The {@code query} to be sent\n+     * @param resultType The response type used for this query\n+     * @param <Q>        The type of the query\n+     * @param <R>        The type of the result (initial & updates)\n+     * @return Flux which can be used to cancel receiving updates\n+     *\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage)\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage, SubscriptionQueryBackpressure, int)\n+     */\n+    default <Q, R> Flux<R> subscriptionQueryMany(Q query, Class<R> resultType) {\n+        return subscriptionQuery(query,\n+                                 ResponseTypes.multipleInstancesOf(resultType),\n+                                 ResponseTypes.instanceOf(resultType))\n+                .flatMapMany(result -> result.initialResult()\n+                                             .flatMapMany(Flux::fromIterable)\n+                                             .concatWith(result.updates())\n+                                             .doFinally(signal -> result.close()));\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, and streams\n+     * incremental updates until subscriber unsubscribes from Flux.\n+     * Should be used when subscriber is interested only in updates.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Flux}</b></p>\n+     * <p>\n+     * <b>Note</b>: Any {@code null} results, will be filtered out by the\n+     * {@link ReactorQueryGateway}. If you require the {@code null} to be returned for the initial and update results,\n+     * we suggest using the {@code QueryBus} instead.\n+     *\n+     * @param query      The {@code query} to be sent\n+     * @param resultType The response type used for this query\n+     * @param <Q>        The type of the query\n+     * @param <R>        The type of the result (updates)\n+     * @return Flux which can be used to cancel receiving updates\n+     *\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage)\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage, SubscriptionQueryBackpressure, int)\n+     */\n+    default <Q, R> Flux<R> queryUpdates(Q query, ResponseType<R> resultType) {\n+        return subscriptionQuery(query, ResponseTypes.instanceOf(Void.class), resultType)\n+                .flatMapMany(result -> result.updates()\n+                                             .doFinally(signal -> result.close()));\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, and streams\n+     * incremental updates until subscriber unsubscribes from Flux.\n+     * Should be used when subscriber is interested only in updates.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "98865ab1427e4d879301c1bf542842eccc8aa3c3"}, "originalPosition": 301}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgyMjc0MTAzOnYy", "diffSide": "RIGHT", "path": "messaging/src/main/java/org/axonframework/queryhandling/ReactorQueryGateway.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xMFQwODo1Njo1NVrOGvvjJg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xMFQwODo1Njo1NVrOGvvjJg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjcxNTMwMg==", "bodyText": "You should take into account that the query given here might be a QueryMessage implementation. Thus simply doing query.getClass().getName() might result in QueryMessage as the result, which is not it's intended purpose. I'd recommend to use the QueryMessage#queryName(Object) method to figure out the actual queryName to provider here.", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r452715302", "createdAt": "2020-07-10T08:56:55Z", "author": {"login": "smcvb"}, "path": "messaging/src/main/java/org/axonframework/queryhandling/ReactorQueryGateway.java", "diffHunk": "@@ -0,0 +1,547 @@\n+/*\n+ * Copyright (c) 2010-2020. Axon Framework\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.axonframework.queryhandling;\n+\n+import org.axonframework.messaging.ResultMessage;\n+import org.axonframework.messaging.reactive.ReactorMessageDispatchInterceptorSupport;\n+import org.axonframework.messaging.reactive.ReactorResultHandlerInterceptorSupport;\n+import org.axonframework.messaging.responsetypes.ResponseType;\n+import org.axonframework.messaging.responsetypes.ResponseTypes;\n+import org.reactivestreams.Publisher;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Mono;\n+import reactor.util.concurrent.Queues;\n+\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Function;\n+\n+/**\n+ * Variation of {@link QueryGateway}. Provides support for reactive return types such as {@link Mono} and {@link Flux}\n+ * from Project Reactor.\n+ *\n+ * @author Milan Savic\n+ * @since 4.4\n+ */\n+public interface ReactorQueryGateway extends ReactorMessageDispatchInterceptorSupport<QueryMessage<?, ?>>,\n+        ReactorResultHandlerInterceptorSupport<QueryMessage<?, ?>, ResultMessage<?>> {\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response with the given {@code responseType}\n+     * from a single source. The query name will be derived from the provided {@code query}. Execution may be\n+     * asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param query        The {@code query} to be sent\n+     * @param responseType A {@link Class} describing the desired response type\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(Q query, Class<R> responseType) {\n+        return query(query.getClass().getName(), query, responseType);\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response with the given {@code responseType}\n+     * from a single source. Execution may be asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(String queryName, Q query, Class<R> responseType) {\n+        return query(queryName, query, ResponseTypes.instanceOf(responseType));\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from a single source. The query name will be derived from the provided {@code query}. Execution may be\n+     * asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(Q query, ResponseType<R> responseType) {\n+        return query(query.getClass().getName(), query, responseType);\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from a single source. Execution may be asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    <R, Q> Mono<R> query(String queryName, Q query, ResponseType<R> responseType);\n+\n+    /**\n+     * Uses given Publisher of query messages to send incoming queries away. Queries will be sent sequentially - once a\n+     * result of Nth query arrives, (N + 1)th query is dispatched.\n+     *\n+     * @param queries a Publisher stream of queries to be dispatched\n+     * @return a Flux of query results. An ordering of query results corresponds to an ordering of queries being\n+     * dispatched\n+     *\n+     * @see #query(String, Object, ResponseType)\n+     * @see Flux#concatMap(Function)\n+     */\n+    default Flux<Object> query(Publisher<QueryMessage<?, ?>> queries) {\n+        return Flux.from(queries)\n+                   .concatMap(q -> query(q.getQueryName(), q.getPayload(), q.getResponseType()));\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from several sources. The returned {@link Flux} is completed when a {@code timeout} occurs or when all possible\n+     * results are received. The query name will be derived from the provided {@code query}. Execution may be\n+     * asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     * <b>Note</b>: Any {@code null} results will be filtered out by the {@link ReactorQueryGateway}. If you require\n+     * the {@code null} to be returned, we suggest using {@code QueryBus} instead.\n+     *\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param timeout      A timeout of {@code long} for the query\n+     * @param timeUnit     The selected {@link TimeUnit} for the given {@code timeout}\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Flux} containing the query results as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Flux<R> scatterGather(Q query, ResponseType<R> responseType, long timeout, TimeUnit timeUnit) {\n+        return scatterGather(query.getClass().getName(), query, responseType, timeout, timeUnit);\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from several sources. The returned {@link Flux} is completed when a {@code timeout} occurs or when all results\n+     * are received. Execution may be asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     * <b>Note</b>: Any {@code null} results will be filtered out by the {@link ReactorQueryGateway}. If you require\n+     * the {@code null} to be returned, we suggest using {@code QueryBus} instead.\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param timeout      A timeout of {@code long} for the query\n+     * @param timeUnit     The selected {@link TimeUnit} for the given {@code timeout}\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Flux} containing the query results as dictated by the given {@code responseType}\n+     */\n+    <R, Q> Flux<R> scatterGather(String queryName, Q query, ResponseType<R> responseType, long timeout,\n+                                 TimeUnit timeUnit);\n+\n+    /**\n+     * Uses given Publisher of queries to send incoming queries in scatter gather manner. Queries will be sent\n+     * sequentially - once a result of Nth query arrives, (N + 1)th query is dispatched. All queries will be dispatched\n+     * using given {@code timeout} and {@code timeUnit}.\n+     *\n+     * @param queries  a Publisher stream of queries to be dispatched\n+     * @param timeout  A timeout of {@code long} for the query\n+     * @param timeUnit The selected {@link TimeUnit} for the given {@code timeout}\n+     * @return a Flux of query results. An ordering of query results corresponds to an ordering of queries being\n+     * dispatched\n+     */\n+    default Flux<Object> scatterGather(Publisher<QueryMessage<?, ?>> queries, long timeout, TimeUnit timeUnit) {\n+        return Flux.from(queries)\n+                   .concatMap(q -> scatterGather(q.getQueryName(),\n+                                                 q.getPayload(),\n+                                                 q.getResponseType(),\n+                                                 timeout,\n+                                                 timeUnit));\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, returns initial result and keeps streaming\n+     * incremental updates until subscriber unsubscribes from Flux.\n+     * Should be used when response type of initial result and incremental update match.\n+     * (received at the moment the query is sent, until it is cancelled by the caller or closed by the emitting side).\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Flux}</b></p>\n+     * <p>\n+     * <b>Note</b>: Any {@code null} results, on the initial result or the updates, will be filtered out by the\n+     * {@link ReactorQueryGateway}. If you require the {@code null} to be returned for the initial and update results,\n+     * we suggest using the {@code QueryBus} instead.\n+     *\n+     * @param query      The {@code query} to be sent\n+     * @param resultType The response type used for this query\n+     * @param <Q>        The type of the query\n+     * @param <R>        The type of the result (initial & updates)\n+     * @return Flux which can be used to cancel receiving updates\n+     *\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage)\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage, SubscriptionQueryBackpressure, int)\n+     */\n+    default <Q, R> Flux<R> subscriptionQuery(Q query, ResponseType<R> resultType) {\n+        return subscriptionQuery(query, resultType, resultType)\n+                .flatMapMany(result -> result.initialResult()\n+                                             .concatWith(result.updates())\n+                                             .doFinally(signal -> result.close()));\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, returns initial result and keeps streaming\n+     * incremental updates until subscriber unsubscribes from Flux.\n+     * Should be used when response type of initial result and incremental update match.\n+     * (received at the moment the query is sent, until it is cancelled by the caller or closed by the emitting side).\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Flux}</b></p>\n+     * <p>\n+     * <b>Note</b>: Any {@code null} results, on the initial result or the updates, will be filtered out by the\n+     * {@link ReactorQueryGateway}. If you require the {@code null} to be returned for the initial and update results,\n+     * we suggest using the {@code QueryBus} instead.\n+     *\n+     * @param query      The {@code query} to be sent\n+     * @param resultType The response type used for this query\n+     * @param <Q>        The type of the query\n+     * @param <R>        The type of the result (initial & updates)\n+     * @return Flux which can be used to cancel receiving updates\n+     *\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage)\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage, SubscriptionQueryBackpressure, int)\n+     */\n+    default <Q, R> Flux<R> subscriptionQuery(Q query, Class<R> resultType) {\n+        return subscriptionQuery(query, ResponseTypes.instanceOf(resultType));\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, returns initial result and keeps streaming\n+     * incremental updates until subscriber unsubscribes from Flux.\n+     * Should be used when initial result contains multiple instances of response type and needs to be flatten.\n+     * Response type of initial response and incremental updates needs to match.\n+     * (received at the moment the query is sent, until it is cancelled by the caller or closed by the emitting side).\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Flux}</b></p>\n+     * <p>\n+     * <b>Note</b>: Any {@code null} results, on the initial result or the updates, will be filtered out by the\n+     * {@link ReactorQueryGateway}. If you require the {@code null} to be returned for the initial and update results,\n+     * we suggest using the {@code QueryBus} instead.\n+     *\n+     * @param query      The {@code query} to be sent\n+     * @param resultType The response type used for this query\n+     * @param <Q>        The type of the query\n+     * @param <R>        The type of the result (initial & updates)\n+     * @return Flux which can be used to cancel receiving updates\n+     *\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage)\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage, SubscriptionQueryBackpressure, int)\n+     */\n+    default <Q, R> Flux<R> subscriptionQueryMany(Q query, Class<R> resultType) {\n+        return subscriptionQuery(query,\n+                                 ResponseTypes.multipleInstancesOf(resultType),\n+                                 ResponseTypes.instanceOf(resultType))\n+                .flatMapMany(result -> result.initialResult()\n+                                             .flatMapMany(Flux::fromIterable)\n+                                             .concatWith(result.updates())\n+                                             .doFinally(signal -> result.close()));\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, and streams\n+     * incremental updates until subscriber unsubscribes from Flux.\n+     * Should be used when subscriber is interested only in updates.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Flux}</b></p>\n+     * <p>\n+     * <b>Note</b>: Any {@code null} results, will be filtered out by the\n+     * {@link ReactorQueryGateway}. If you require the {@code null} to be returned for the initial and update results,\n+     * we suggest using the {@code QueryBus} instead.\n+     *\n+     * @param query      The {@code query} to be sent\n+     * @param resultType The response type used for this query\n+     * @param <Q>        The type of the query\n+     * @param <R>        The type of the result (updates)\n+     * @return Flux which can be used to cancel receiving updates\n+     *\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage)\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage, SubscriptionQueryBackpressure, int)\n+     */\n+    default <Q, R> Flux<R> queryUpdates(Q query, ResponseType<R> resultType) {\n+        return subscriptionQuery(query, ResponseTypes.instanceOf(Void.class), resultType)\n+                .flatMapMany(result -> result.updates()\n+                                             .doFinally(signal -> result.close()));\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, and streams\n+     * incremental updates until subscriber unsubscribes from Flux.\n+     * Should be used when subscriber is interested only in updates.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Flux}</b></p>\n+     * <p>\n+     * <b>Note</b>: Any {@code null} results, will be filtered out by the\n+     * {@link ReactorQueryGateway}. If you require the {@code null} to be returned for the initial and update results,\n+     * we suggest using the {@code QueryBus} instead.\n+     *\n+     * @param query      The {@code query} to be sent\n+     * @param resultType The response type used for this query\n+     * @param <Q>        The type of the query\n+     * @param <R>        The type of the result (updates)\n+     * @return Flux which can be used to cancel receiving updates\n+     *\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage)\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage, SubscriptionQueryBackpressure, int)\n+     */\n+    default <Q, R> Flux<R> queryUpdates(Q query, Class<R> resultType) {\n+        return queryUpdates(query, ResponseTypes.instanceOf(resultType));\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus} and returns result containing initial response and\n+     * incremental updates (received at the moment the query is sent, until it is cancelled by the caller or closed by\n+     * the emitting side).\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     * <p>\n+     * <b>Note</b>: Any {@code null} results, on the initial result or the updates, will be filtered out by the\n+     * {@link ReactorQueryGateway}. If you require the {@code null} to be returned for the initial and update results,\n+     * we suggest using the {@code QueryBus} instead.\n+     *\n+     * @param query               The {@code query} to be sent\n+     * @param initialResponseType The initial response type used for this query\n+     * @param updateResponseType  The update response type used for this query\n+     * @param <Q>                 The type of the query\n+     * @param <I>                 The type of the initial response\n+     * @param <U>                 The type of the incremental update\n+     * @return registration which can be used to cancel receiving updates\n+     *\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage)\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage, SubscriptionQueryBackpressure, int)\n+     */\n+    default <Q, I, U> Mono<SubscriptionQueryResult<I, U>> subscriptionQuery(Q query, Class<I> initialResponseType,\n+                                                                            Class<U> updateResponseType) {\n+        return subscriptionQuery(query.getClass().getName(),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "98865ab1427e4d879301c1bf542842eccc8aa3c3"}, "originalPosition": 346}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgyMzE3NTQxOnYy", "diffSide": "RIGHT", "path": "messaging/src/main/java/org/axonframework/queryhandling/ReactorQueryGateway.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xMFQxMToyMDozOVrOGvztFw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xMFQxMToyMDozOVrOGvztFw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mjc4MzM4Mw==", "bodyText": "You should take into account that the query given here might be a QueryMessage implementation. Thus simply doing query.getClass().getName() might result in QueryMessage as the result, which is not it's intended purpose. I'd recommend to use the QueryMessage#queryName(Object) method to figure out the actual queryName to provider here.", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r452783383", "createdAt": "2020-07-10T11:20:39Z", "author": {"login": "smcvb"}, "path": "messaging/src/main/java/org/axonframework/queryhandling/ReactorQueryGateway.java", "diffHunk": "@@ -0,0 +1,547 @@\n+/*\n+ * Copyright (c) 2010-2020. Axon Framework\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.axonframework.queryhandling;\n+\n+import org.axonframework.messaging.ResultMessage;\n+import org.axonframework.messaging.reactive.ReactorMessageDispatchInterceptorSupport;\n+import org.axonframework.messaging.reactive.ReactorResultHandlerInterceptorSupport;\n+import org.axonframework.messaging.responsetypes.ResponseType;\n+import org.axonframework.messaging.responsetypes.ResponseTypes;\n+import org.reactivestreams.Publisher;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Mono;\n+import reactor.util.concurrent.Queues;\n+\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Function;\n+\n+/**\n+ * Variation of {@link QueryGateway}. Provides support for reactive return types such as {@link Mono} and {@link Flux}\n+ * from Project Reactor.\n+ *\n+ * @author Milan Savic\n+ * @since 4.4\n+ */\n+public interface ReactorQueryGateway extends ReactorMessageDispatchInterceptorSupport<QueryMessage<?, ?>>,\n+        ReactorResultHandlerInterceptorSupport<QueryMessage<?, ?>, ResultMessage<?>> {\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response with the given {@code responseType}\n+     * from a single source. The query name will be derived from the provided {@code query}. Execution may be\n+     * asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param query        The {@code query} to be sent\n+     * @param responseType A {@link Class} describing the desired response type\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(Q query, Class<R> responseType) {\n+        return query(query.getClass().getName(), query, responseType);\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response with the given {@code responseType}\n+     * from a single source. Execution may be asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(String queryName, Q query, Class<R> responseType) {\n+        return query(queryName, query, ResponseTypes.instanceOf(responseType));\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from a single source. The query name will be derived from the provided {@code query}. Execution may be\n+     * asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(Q query, ResponseType<R> responseType) {\n+        return query(query.getClass().getName(), query, responseType);\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from a single source. Execution may be asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    <R, Q> Mono<R> query(String queryName, Q query, ResponseType<R> responseType);\n+\n+    /**\n+     * Uses given Publisher of query messages to send incoming queries away. Queries will be sent sequentially - once a\n+     * result of Nth query arrives, (N + 1)th query is dispatched.\n+     *\n+     * @param queries a Publisher stream of queries to be dispatched\n+     * @return a Flux of query results. An ordering of query results corresponds to an ordering of queries being\n+     * dispatched\n+     *\n+     * @see #query(String, Object, ResponseType)\n+     * @see Flux#concatMap(Function)\n+     */\n+    default Flux<Object> query(Publisher<QueryMessage<?, ?>> queries) {\n+        return Flux.from(queries)\n+                   .concatMap(q -> query(q.getQueryName(), q.getPayload(), q.getResponseType()));\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from several sources. The returned {@link Flux} is completed when a {@code timeout} occurs or when all possible\n+     * results are received. The query name will be derived from the provided {@code query}. Execution may be\n+     * asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     * <b>Note</b>: Any {@code null} results will be filtered out by the {@link ReactorQueryGateway}. If you require\n+     * the {@code null} to be returned, we suggest using {@code QueryBus} instead.\n+     *\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param timeout      A timeout of {@code long} for the query\n+     * @param timeUnit     The selected {@link TimeUnit} for the given {@code timeout}\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Flux} containing the query results as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Flux<R> scatterGather(Q query, ResponseType<R> responseType, long timeout, TimeUnit timeUnit) {\n+        return scatterGather(query.getClass().getName(), query, responseType, timeout, timeUnit);\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from several sources. The returned {@link Flux} is completed when a {@code timeout} occurs or when all results\n+     * are received. Execution may be asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     * <b>Note</b>: Any {@code null} results will be filtered out by the {@link ReactorQueryGateway}. If you require\n+     * the {@code null} to be returned, we suggest using {@code QueryBus} instead.\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param timeout      A timeout of {@code long} for the query\n+     * @param timeUnit     The selected {@link TimeUnit} for the given {@code timeout}\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Flux} containing the query results as dictated by the given {@code responseType}\n+     */\n+    <R, Q> Flux<R> scatterGather(String queryName, Q query, ResponseType<R> responseType, long timeout,\n+                                 TimeUnit timeUnit);\n+\n+    /**\n+     * Uses given Publisher of queries to send incoming queries in scatter gather manner. Queries will be sent\n+     * sequentially - once a result of Nth query arrives, (N + 1)th query is dispatched. All queries will be dispatched\n+     * using given {@code timeout} and {@code timeUnit}.\n+     *\n+     * @param queries  a Publisher stream of queries to be dispatched\n+     * @param timeout  A timeout of {@code long} for the query\n+     * @param timeUnit The selected {@link TimeUnit} for the given {@code timeout}\n+     * @return a Flux of query results. An ordering of query results corresponds to an ordering of queries being\n+     * dispatched\n+     */\n+    default Flux<Object> scatterGather(Publisher<QueryMessage<?, ?>> queries, long timeout, TimeUnit timeUnit) {\n+        return Flux.from(queries)\n+                   .concatMap(q -> scatterGather(q.getQueryName(),\n+                                                 q.getPayload(),\n+                                                 q.getResponseType(),\n+                                                 timeout,\n+                                                 timeUnit));\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, returns initial result and keeps streaming\n+     * incremental updates until subscriber unsubscribes from Flux.\n+     * Should be used when response type of initial result and incremental update match.\n+     * (received at the moment the query is sent, until it is cancelled by the caller or closed by the emitting side).\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Flux}</b></p>\n+     * <p>\n+     * <b>Note</b>: Any {@code null} results, on the initial result or the updates, will be filtered out by the\n+     * {@link ReactorQueryGateway}. If you require the {@code null} to be returned for the initial and update results,\n+     * we suggest using the {@code QueryBus} instead.\n+     *\n+     * @param query      The {@code query} to be sent\n+     * @param resultType The response type used for this query\n+     * @param <Q>        The type of the query\n+     * @param <R>        The type of the result (initial & updates)\n+     * @return Flux which can be used to cancel receiving updates\n+     *\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage)\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage, SubscriptionQueryBackpressure, int)\n+     */\n+    default <Q, R> Flux<R> subscriptionQuery(Q query, ResponseType<R> resultType) {\n+        return subscriptionQuery(query, resultType, resultType)\n+                .flatMapMany(result -> result.initialResult()\n+                                             .concatWith(result.updates())\n+                                             .doFinally(signal -> result.close()));\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, returns initial result and keeps streaming\n+     * incremental updates until subscriber unsubscribes from Flux.\n+     * Should be used when response type of initial result and incremental update match.\n+     * (received at the moment the query is sent, until it is cancelled by the caller or closed by the emitting side).\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Flux}</b></p>\n+     * <p>\n+     * <b>Note</b>: Any {@code null} results, on the initial result or the updates, will be filtered out by the\n+     * {@link ReactorQueryGateway}. If you require the {@code null} to be returned for the initial and update results,\n+     * we suggest using the {@code QueryBus} instead.\n+     *\n+     * @param query      The {@code query} to be sent\n+     * @param resultType The response type used for this query\n+     * @param <Q>        The type of the query\n+     * @param <R>        The type of the result (initial & updates)\n+     * @return Flux which can be used to cancel receiving updates\n+     *\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage)\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage, SubscriptionQueryBackpressure, int)\n+     */\n+    default <Q, R> Flux<R> subscriptionQuery(Q query, Class<R> resultType) {\n+        return subscriptionQuery(query, ResponseTypes.instanceOf(resultType));\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, returns initial result and keeps streaming\n+     * incremental updates until subscriber unsubscribes from Flux.\n+     * Should be used when initial result contains multiple instances of response type and needs to be flatten.\n+     * Response type of initial response and incremental updates needs to match.\n+     * (received at the moment the query is sent, until it is cancelled by the caller or closed by the emitting side).\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Flux}</b></p>\n+     * <p>\n+     * <b>Note</b>: Any {@code null} results, on the initial result or the updates, will be filtered out by the\n+     * {@link ReactorQueryGateway}. If you require the {@code null} to be returned for the initial and update results,\n+     * we suggest using the {@code QueryBus} instead.\n+     *\n+     * @param query      The {@code query} to be sent\n+     * @param resultType The response type used for this query\n+     * @param <Q>        The type of the query\n+     * @param <R>        The type of the result (initial & updates)\n+     * @return Flux which can be used to cancel receiving updates\n+     *\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage)\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage, SubscriptionQueryBackpressure, int)\n+     */\n+    default <Q, R> Flux<R> subscriptionQueryMany(Q query, Class<R> resultType) {\n+        return subscriptionQuery(query,\n+                                 ResponseTypes.multipleInstancesOf(resultType),\n+                                 ResponseTypes.instanceOf(resultType))\n+                .flatMapMany(result -> result.initialResult()\n+                                             .flatMapMany(Flux::fromIterable)\n+                                             .concatWith(result.updates())\n+                                             .doFinally(signal -> result.close()));\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, and streams\n+     * incremental updates until subscriber unsubscribes from Flux.\n+     * Should be used when subscriber is interested only in updates.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Flux}</b></p>\n+     * <p>\n+     * <b>Note</b>: Any {@code null} results, will be filtered out by the\n+     * {@link ReactorQueryGateway}. If you require the {@code null} to be returned for the initial and update results,\n+     * we suggest using the {@code QueryBus} instead.\n+     *\n+     * @param query      The {@code query} to be sent\n+     * @param resultType The response type used for this query\n+     * @param <Q>        The type of the query\n+     * @param <R>        The type of the result (updates)\n+     * @return Flux which can be used to cancel receiving updates\n+     *\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage)\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage, SubscriptionQueryBackpressure, int)\n+     */\n+    default <Q, R> Flux<R> queryUpdates(Q query, ResponseType<R> resultType) {\n+        return subscriptionQuery(query, ResponseTypes.instanceOf(Void.class), resultType)\n+                .flatMapMany(result -> result.updates()\n+                                             .doFinally(signal -> result.close()));\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, and streams\n+     * incremental updates until subscriber unsubscribes from Flux.\n+     * Should be used when subscriber is interested only in updates.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Flux}</b></p>\n+     * <p>\n+     * <b>Note</b>: Any {@code null} results, will be filtered out by the\n+     * {@link ReactorQueryGateway}. If you require the {@code null} to be returned for the initial and update results,\n+     * we suggest using the {@code QueryBus} instead.\n+     *\n+     * @param query      The {@code query} to be sent\n+     * @param resultType The response type used for this query\n+     * @param <Q>        The type of the query\n+     * @param <R>        The type of the result (updates)\n+     * @return Flux which can be used to cancel receiving updates\n+     *\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage)\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage, SubscriptionQueryBackpressure, int)\n+     */\n+    default <Q, R> Flux<R> queryUpdates(Q query, Class<R> resultType) {\n+        return queryUpdates(query, ResponseTypes.instanceOf(resultType));\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus} and returns result containing initial response and\n+     * incremental updates (received at the moment the query is sent, until it is cancelled by the caller or closed by\n+     * the emitting side).\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     * <p>\n+     * <b>Note</b>: Any {@code null} results, on the initial result or the updates, will be filtered out by the\n+     * {@link ReactorQueryGateway}. If you require the {@code null} to be returned for the initial and update results,\n+     * we suggest using the {@code QueryBus} instead.\n+     *\n+     * @param query               The {@code query} to be sent\n+     * @param initialResponseType The initial response type used for this query\n+     * @param updateResponseType  The update response type used for this query\n+     * @param <Q>                 The type of the query\n+     * @param <I>                 The type of the initial response\n+     * @param <U>                 The type of the incremental update\n+     * @return registration which can be used to cancel receiving updates\n+     *\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage)\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage, SubscriptionQueryBackpressure, int)\n+     */\n+    default <Q, I, U> Mono<SubscriptionQueryResult<I, U>> subscriptionQuery(Q query, Class<I> initialResponseType,\n+                                                                            Class<U> updateResponseType) {\n+        return subscriptionQuery(query.getClass().getName(),\n+                                 query,\n+                                 initialResponseType,\n+                                 updateResponseType);\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus} and returns result containing initial response and\n+     * incremental updates (received at the moment the query is sent, until it is cancelled by the caller or closed by\n+     * the emitting side).\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     * <p>\n+     * <b>Note</b>: Any {@code null} results, on the initial result or the updates, will be filtered out by the\n+     * {@link ReactorQueryGateway}. If you require the {@code null} to be returned for the initial and update results,\n+     * we suggest using the {@code QueryBus} instead.\n+     *\n+     * @param queryName           A {@link String} describing query to be executed\n+     * @param query               The {@code query} to be sent\n+     * @param initialResponseType The initial response type used for this query\n+     * @param updateResponseType  The update response type used for this query\n+     * @param <Q>                 The type of the query\n+     * @param <I>                 The type of the initial response\n+     * @param <U>                 The type of the incremental update\n+     * @return registration which can be used to cancel receiving updates\n+     *\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage)\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage, SubscriptionQueryBackpressure, int)\n+     */\n+    default <Q, I, U> Mono<SubscriptionQueryResult<I, U>> subscriptionQuery(String queryName, Q query,\n+                                                                            Class<I> initialResponseType,\n+                                                                            Class<U> updateResponseType) {\n+        return subscriptionQuery(queryName,\n+                                 query,\n+                                 ResponseTypes.instanceOf(initialResponseType),\n+                                 ResponseTypes.instanceOf(updateResponseType),\n+                                 SubscriptionQueryBackpressure.defaultBackpressure());\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus} and returns result containing initial response and\n+     * incremental updates (received at the moment the query is sent, until it is cancelled by the caller or closed by\n+     * the emitting side).\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     * <p>\n+     * <b>Note</b>: Any {@code null} results, on the initial result or the updates, will be filtered out by the\n+     * {@link ReactorQueryGateway}. If you require the {@code null} to be returned for the initial and update results,\n+     * we suggest using the {@code QueryBus} instead.\n+     *\n+     * @param query               The {@code query} to be sent\n+     * @param initialResponseType The initial response type used for this query\n+     * @param updateResponseType  The update response type used for this query\n+     * @param <Q>                 The type of the query\n+     * @param <I>                 The type of the initial response\n+     * @param <U>                 The type of the incremental update\n+     * @return registration which can be used to cancel receiving updates\n+     *\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage)\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage, SubscriptionQueryBackpressure, int)\n+     */\n+    default <Q, I, U> Mono<SubscriptionQueryResult<I, U>> subscriptionQuery(Q query,\n+                                                                            ResponseType<I> initialResponseType,\n+                                                                            ResponseType<U> updateResponseType) {\n+        return subscriptionQuery(query.getClass().getName(),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "98865ab1427e4d879301c1bf542842eccc8aa3c3"}, "originalPosition": 410}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgyMzE3OTE1OnYy", "diffSide": "RIGHT", "path": "messaging/src/main/java/org/axonframework/queryhandling/ReactorQueryGateway.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xMFQxMToyMjoxMlrOGvzvZQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xMFQxMToyMjoxMlrOGvzvZQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mjc4Mzk3Mw==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * Uses given Publisher of queries to send incoming queries away. Queries will be sent sequentially - once a result\n          \n          \n            \n                 * of Nth query arrives, (N + 1)th query is dispatched.\n          \n          \n            \n                 *\n          \n          \n            \n                 * @param queries a Publisher stream of queries to be dispatched\n          \n          \n            \n                 * @return a Flux of query results. An ordering of query results corresponds to an ordering of queries being\n          \n          \n            \n                 * dispatched\n          \n          \n            \n                 * Uses the given {@link Publisher} of {@link SubscriptionQueryMessage}s to send incoming queries away. Queries will be sent sequentially. Once the result\n          \n          \n            \n                 * of Nth query arrives, the (N + 1)th query is dispatched.\n          \n          \n            \n                 *\n          \n          \n            \n                 * @param queries a {@link Publisher} stream of queries to be dispatched\n          \n          \n            \n                 * @return a {@link Flux} of query results. The ordering of query results corresponds to the ordering of queries being\n          \n          \n            \n                 * dispatched", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r452783973", "createdAt": "2020-07-10T11:22:12Z", "author": {"login": "smcvb"}, "path": "messaging/src/main/java/org/axonframework/queryhandling/ReactorQueryGateway.java", "diffHunk": "@@ -0,0 +1,547 @@\n+/*\n+ * Copyright (c) 2010-2020. Axon Framework\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.axonframework.queryhandling;\n+\n+import org.axonframework.messaging.ResultMessage;\n+import org.axonframework.messaging.reactive.ReactorMessageDispatchInterceptorSupport;\n+import org.axonframework.messaging.reactive.ReactorResultHandlerInterceptorSupport;\n+import org.axonframework.messaging.responsetypes.ResponseType;\n+import org.axonframework.messaging.responsetypes.ResponseTypes;\n+import org.reactivestreams.Publisher;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Mono;\n+import reactor.util.concurrent.Queues;\n+\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Function;\n+\n+/**\n+ * Variation of {@link QueryGateway}. Provides support for reactive return types such as {@link Mono} and {@link Flux}\n+ * from Project Reactor.\n+ *\n+ * @author Milan Savic\n+ * @since 4.4\n+ */\n+public interface ReactorQueryGateway extends ReactorMessageDispatchInterceptorSupport<QueryMessage<?, ?>>,\n+        ReactorResultHandlerInterceptorSupport<QueryMessage<?, ?>, ResultMessage<?>> {\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response with the given {@code responseType}\n+     * from a single source. The query name will be derived from the provided {@code query}. Execution may be\n+     * asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param query        The {@code query} to be sent\n+     * @param responseType A {@link Class} describing the desired response type\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(Q query, Class<R> responseType) {\n+        return query(query.getClass().getName(), query, responseType);\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response with the given {@code responseType}\n+     * from a single source. Execution may be asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(String queryName, Q query, Class<R> responseType) {\n+        return query(queryName, query, ResponseTypes.instanceOf(responseType));\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from a single source. The query name will be derived from the provided {@code query}. Execution may be\n+     * asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(Q query, ResponseType<R> responseType) {\n+        return query(query.getClass().getName(), query, responseType);\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from a single source. Execution may be asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    <R, Q> Mono<R> query(String queryName, Q query, ResponseType<R> responseType);\n+\n+    /**\n+     * Uses given Publisher of query messages to send incoming queries away. Queries will be sent sequentially - once a\n+     * result of Nth query arrives, (N + 1)th query is dispatched.\n+     *\n+     * @param queries a Publisher stream of queries to be dispatched\n+     * @return a Flux of query results. An ordering of query results corresponds to an ordering of queries being\n+     * dispatched\n+     *\n+     * @see #query(String, Object, ResponseType)\n+     * @see Flux#concatMap(Function)\n+     */\n+    default Flux<Object> query(Publisher<QueryMessage<?, ?>> queries) {\n+        return Flux.from(queries)\n+                   .concatMap(q -> query(q.getQueryName(), q.getPayload(), q.getResponseType()));\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from several sources. The returned {@link Flux} is completed when a {@code timeout} occurs or when all possible\n+     * results are received. The query name will be derived from the provided {@code query}. Execution may be\n+     * asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     * <b>Note</b>: Any {@code null} results will be filtered out by the {@link ReactorQueryGateway}. If you require\n+     * the {@code null} to be returned, we suggest using {@code QueryBus} instead.\n+     *\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param timeout      A timeout of {@code long} for the query\n+     * @param timeUnit     The selected {@link TimeUnit} for the given {@code timeout}\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Flux} containing the query results as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Flux<R> scatterGather(Q query, ResponseType<R> responseType, long timeout, TimeUnit timeUnit) {\n+        return scatterGather(query.getClass().getName(), query, responseType, timeout, timeUnit);\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from several sources. The returned {@link Flux} is completed when a {@code timeout} occurs or when all results\n+     * are received. Execution may be asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     * <b>Note</b>: Any {@code null} results will be filtered out by the {@link ReactorQueryGateway}. If you require\n+     * the {@code null} to be returned, we suggest using {@code QueryBus} instead.\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param timeout      A timeout of {@code long} for the query\n+     * @param timeUnit     The selected {@link TimeUnit} for the given {@code timeout}\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Flux} containing the query results as dictated by the given {@code responseType}\n+     */\n+    <R, Q> Flux<R> scatterGather(String queryName, Q query, ResponseType<R> responseType, long timeout,\n+                                 TimeUnit timeUnit);\n+\n+    /**\n+     * Uses given Publisher of queries to send incoming queries in scatter gather manner. Queries will be sent\n+     * sequentially - once a result of Nth query arrives, (N + 1)th query is dispatched. All queries will be dispatched\n+     * using given {@code timeout} and {@code timeUnit}.\n+     *\n+     * @param queries  a Publisher stream of queries to be dispatched\n+     * @param timeout  A timeout of {@code long} for the query\n+     * @param timeUnit The selected {@link TimeUnit} for the given {@code timeout}\n+     * @return a Flux of query results. An ordering of query results corresponds to an ordering of queries being\n+     * dispatched\n+     */\n+    default Flux<Object> scatterGather(Publisher<QueryMessage<?, ?>> queries, long timeout, TimeUnit timeUnit) {\n+        return Flux.from(queries)\n+                   .concatMap(q -> scatterGather(q.getQueryName(),\n+                                                 q.getPayload(),\n+                                                 q.getResponseType(),\n+                                                 timeout,\n+                                                 timeUnit));\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, returns initial result and keeps streaming\n+     * incremental updates until subscriber unsubscribes from Flux.\n+     * Should be used when response type of initial result and incremental update match.\n+     * (received at the moment the query is sent, until it is cancelled by the caller or closed by the emitting side).\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Flux}</b></p>\n+     * <p>\n+     * <b>Note</b>: Any {@code null} results, on the initial result or the updates, will be filtered out by the\n+     * {@link ReactorQueryGateway}. If you require the {@code null} to be returned for the initial and update results,\n+     * we suggest using the {@code QueryBus} instead.\n+     *\n+     * @param query      The {@code query} to be sent\n+     * @param resultType The response type used for this query\n+     * @param <Q>        The type of the query\n+     * @param <R>        The type of the result (initial & updates)\n+     * @return Flux which can be used to cancel receiving updates\n+     *\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage)\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage, SubscriptionQueryBackpressure, int)\n+     */\n+    default <Q, R> Flux<R> subscriptionQuery(Q query, ResponseType<R> resultType) {\n+        return subscriptionQuery(query, resultType, resultType)\n+                .flatMapMany(result -> result.initialResult()\n+                                             .concatWith(result.updates())\n+                                             .doFinally(signal -> result.close()));\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, returns initial result and keeps streaming\n+     * incremental updates until subscriber unsubscribes from Flux.\n+     * Should be used when response type of initial result and incremental update match.\n+     * (received at the moment the query is sent, until it is cancelled by the caller or closed by the emitting side).\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Flux}</b></p>\n+     * <p>\n+     * <b>Note</b>: Any {@code null} results, on the initial result or the updates, will be filtered out by the\n+     * {@link ReactorQueryGateway}. If you require the {@code null} to be returned for the initial and update results,\n+     * we suggest using the {@code QueryBus} instead.\n+     *\n+     * @param query      The {@code query} to be sent\n+     * @param resultType The response type used for this query\n+     * @param <Q>        The type of the query\n+     * @param <R>        The type of the result (initial & updates)\n+     * @return Flux which can be used to cancel receiving updates\n+     *\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage)\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage, SubscriptionQueryBackpressure, int)\n+     */\n+    default <Q, R> Flux<R> subscriptionQuery(Q query, Class<R> resultType) {\n+        return subscriptionQuery(query, ResponseTypes.instanceOf(resultType));\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, returns initial result and keeps streaming\n+     * incremental updates until subscriber unsubscribes from Flux.\n+     * Should be used when initial result contains multiple instances of response type and needs to be flatten.\n+     * Response type of initial response and incremental updates needs to match.\n+     * (received at the moment the query is sent, until it is cancelled by the caller or closed by the emitting side).\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Flux}</b></p>\n+     * <p>\n+     * <b>Note</b>: Any {@code null} results, on the initial result or the updates, will be filtered out by the\n+     * {@link ReactorQueryGateway}. If you require the {@code null} to be returned for the initial and update results,\n+     * we suggest using the {@code QueryBus} instead.\n+     *\n+     * @param query      The {@code query} to be sent\n+     * @param resultType The response type used for this query\n+     * @param <Q>        The type of the query\n+     * @param <R>        The type of the result (initial & updates)\n+     * @return Flux which can be used to cancel receiving updates\n+     *\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage)\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage, SubscriptionQueryBackpressure, int)\n+     */\n+    default <Q, R> Flux<R> subscriptionQueryMany(Q query, Class<R> resultType) {\n+        return subscriptionQuery(query,\n+                                 ResponseTypes.multipleInstancesOf(resultType),\n+                                 ResponseTypes.instanceOf(resultType))\n+                .flatMapMany(result -> result.initialResult()\n+                                             .flatMapMany(Flux::fromIterable)\n+                                             .concatWith(result.updates())\n+                                             .doFinally(signal -> result.close()));\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, and streams\n+     * incremental updates until subscriber unsubscribes from Flux.\n+     * Should be used when subscriber is interested only in updates.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Flux}</b></p>\n+     * <p>\n+     * <b>Note</b>: Any {@code null} results, will be filtered out by the\n+     * {@link ReactorQueryGateway}. If you require the {@code null} to be returned for the initial and update results,\n+     * we suggest using the {@code QueryBus} instead.\n+     *\n+     * @param query      The {@code query} to be sent\n+     * @param resultType The response type used for this query\n+     * @param <Q>        The type of the query\n+     * @param <R>        The type of the result (updates)\n+     * @return Flux which can be used to cancel receiving updates\n+     *\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage)\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage, SubscriptionQueryBackpressure, int)\n+     */\n+    default <Q, R> Flux<R> queryUpdates(Q query, ResponseType<R> resultType) {\n+        return subscriptionQuery(query, ResponseTypes.instanceOf(Void.class), resultType)\n+                .flatMapMany(result -> result.updates()\n+                                             .doFinally(signal -> result.close()));\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, and streams\n+     * incremental updates until subscriber unsubscribes from Flux.\n+     * Should be used when subscriber is interested only in updates.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Flux}</b></p>\n+     * <p>\n+     * <b>Note</b>: Any {@code null} results, will be filtered out by the\n+     * {@link ReactorQueryGateway}. If you require the {@code null} to be returned for the initial and update results,\n+     * we suggest using the {@code QueryBus} instead.\n+     *\n+     * @param query      The {@code query} to be sent\n+     * @param resultType The response type used for this query\n+     * @param <Q>        The type of the query\n+     * @param <R>        The type of the result (updates)\n+     * @return Flux which can be used to cancel receiving updates\n+     *\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage)\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage, SubscriptionQueryBackpressure, int)\n+     */\n+    default <Q, R> Flux<R> queryUpdates(Q query, Class<R> resultType) {\n+        return queryUpdates(query, ResponseTypes.instanceOf(resultType));\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus} and returns result containing initial response and\n+     * incremental updates (received at the moment the query is sent, until it is cancelled by the caller or closed by\n+     * the emitting side).\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     * <p>\n+     * <b>Note</b>: Any {@code null} results, on the initial result or the updates, will be filtered out by the\n+     * {@link ReactorQueryGateway}. If you require the {@code null} to be returned for the initial and update results,\n+     * we suggest using the {@code QueryBus} instead.\n+     *\n+     * @param query               The {@code query} to be sent\n+     * @param initialResponseType The initial response type used for this query\n+     * @param updateResponseType  The update response type used for this query\n+     * @param <Q>                 The type of the query\n+     * @param <I>                 The type of the initial response\n+     * @param <U>                 The type of the incremental update\n+     * @return registration which can be used to cancel receiving updates\n+     *\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage)\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage, SubscriptionQueryBackpressure, int)\n+     */\n+    default <Q, I, U> Mono<SubscriptionQueryResult<I, U>> subscriptionQuery(Q query, Class<I> initialResponseType,\n+                                                                            Class<U> updateResponseType) {\n+        return subscriptionQuery(query.getClass().getName(),\n+                                 query,\n+                                 initialResponseType,\n+                                 updateResponseType);\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus} and returns result containing initial response and\n+     * incremental updates (received at the moment the query is sent, until it is cancelled by the caller or closed by\n+     * the emitting side).\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     * <p>\n+     * <b>Note</b>: Any {@code null} results, on the initial result or the updates, will be filtered out by the\n+     * {@link ReactorQueryGateway}. If you require the {@code null} to be returned for the initial and update results,\n+     * we suggest using the {@code QueryBus} instead.\n+     *\n+     * @param queryName           A {@link String} describing query to be executed\n+     * @param query               The {@code query} to be sent\n+     * @param initialResponseType The initial response type used for this query\n+     * @param updateResponseType  The update response type used for this query\n+     * @param <Q>                 The type of the query\n+     * @param <I>                 The type of the initial response\n+     * @param <U>                 The type of the incremental update\n+     * @return registration which can be used to cancel receiving updates\n+     *\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage)\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage, SubscriptionQueryBackpressure, int)\n+     */\n+    default <Q, I, U> Mono<SubscriptionQueryResult<I, U>> subscriptionQuery(String queryName, Q query,\n+                                                                            Class<I> initialResponseType,\n+                                                                            Class<U> updateResponseType) {\n+        return subscriptionQuery(queryName,\n+                                 query,\n+                                 ResponseTypes.instanceOf(initialResponseType),\n+                                 ResponseTypes.instanceOf(updateResponseType),\n+                                 SubscriptionQueryBackpressure.defaultBackpressure());\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus} and returns result containing initial response and\n+     * incremental updates (received at the moment the query is sent, until it is cancelled by the caller or closed by\n+     * the emitting side).\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     * <p>\n+     * <b>Note</b>: Any {@code null} results, on the initial result or the updates, will be filtered out by the\n+     * {@link ReactorQueryGateway}. If you require the {@code null} to be returned for the initial and update results,\n+     * we suggest using the {@code QueryBus} instead.\n+     *\n+     * @param query               The {@code query} to be sent\n+     * @param initialResponseType The initial response type used for this query\n+     * @param updateResponseType  The update response type used for this query\n+     * @param <Q>                 The type of the query\n+     * @param <I>                 The type of the initial response\n+     * @param <U>                 The type of the incremental update\n+     * @return registration which can be used to cancel receiving updates\n+     *\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage)\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage, SubscriptionQueryBackpressure, int)\n+     */\n+    default <Q, I, U> Mono<SubscriptionQueryResult<I, U>> subscriptionQuery(Q query,\n+                                                                            ResponseType<I> initialResponseType,\n+                                                                            ResponseType<U> updateResponseType) {\n+        return subscriptionQuery(query.getClass().getName(),\n+                                 query,\n+                                 initialResponseType,\n+                                 updateResponseType,\n+                                 SubscriptionQueryBackpressure.defaultBackpressure());\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus} and returns result containing initial response and\n+     * incremental updates (received at the moment the query is sent, until it is cancelled by the caller or closed by\n+     * the emitting side).\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     * <p>\n+     * <b>Note</b>: Any {@code null} results, on the initial result or the updates, will be filtered out by the\n+     * {@link ReactorQueryGateway}. If you require the {@code null} to be returned for the initial and update results,\n+     * we suggest using the {@code QueryBus} instead.\n+     *\n+     * @param queryName           A {@link String} describing query to be executed\n+     * @param query               The {@code query} to be sent\n+     * @param initialResponseType The initial response type used for this query\n+     * @param updateResponseType  The update response type used for this query\n+     * @param backpressure        The backpressure mechanism to deal with producing of incremental updates\n+     * @param <Q>                 The type of the query\n+     * @param <I>                 The type of the initial response\n+     * @param <U>                 The type of the incremental update\n+     * @return registration which can be used to cancel receiving updates\n+     *\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage)\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage, SubscriptionQueryBackpressure, int)\n+     */\n+    default <Q, I, U> Mono<SubscriptionQueryResult<I, U>> subscriptionQuery(String queryName, Q query,\n+                                                                            ResponseType<I> initialResponseType,\n+                                                                            ResponseType<U> updateResponseType,\n+                                                                            SubscriptionQueryBackpressure backpressure) {\n+        return subscriptionQuery(queryName,\n+                                 query,\n+                                 initialResponseType,\n+                                 updateResponseType,\n+                                 backpressure,\n+                                 Queues.SMALL_BUFFER_SIZE);\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus} and returns result containing initial response and\n+     * incremental updates (received at the moment the query is sent, until it is cancelled by the caller or closed by\n+     * the emitting side).\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     * <p>\n+     * <b>Note</b>: Any {@code null} results, on the initial result or the updates, will be filtered out by the\n+     * {@link ReactorQueryGateway}. If you require the {@code null} to be returned for the initial and update results,\n+     * we suggest using the {@code QueryBus} instead.\n+     *\n+     * @param queryName           A {@link String} describing query to be executed\n+     * @param query               The {@code query} to be sent\n+     * @param initialResponseType The initial response type used for this query\n+     * @param updateResponseType  The update response type used for this query\n+     * @param backpressure        The backpressure mechanism to deal with producing of incremental updates\n+     * @param updateBufferSize    The size of buffer which accumulates updates before subscription to the {@code flux}\n+     *                            is made\n+     * @param <Q>                 The type of the query\n+     * @param <I>                 The type of the initial response\n+     * @param <U>                 The type of the incremental update\n+     * @return registration which can be used to cancel receiving updates\n+     *\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage)\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage, SubscriptionQueryBackpressure, int)\n+     */\n+    <Q, I, U> Mono<SubscriptionQueryResult<I, U>> subscriptionQuery(String queryName, Q query,\n+                                                                    ResponseType<I> initialResponseType,\n+                                                                    ResponseType<U> updateResponseType,\n+                                                                    SubscriptionQueryBackpressure backpressure,\n+                                                                    int updateBufferSize);\n+\n+    /**\n+     * Uses given Publisher of queries to send incoming queries away. Queries will be sent sequentially - once a result\n+     * of Nth query arrives, (N + 1)th query is dispatched.\n+     *\n+     * @param queries a Publisher stream of queries to be dispatched\n+     * @return a Flux of query results. An ordering of query results corresponds to an ordering of queries being\n+     * dispatched", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "98865ab1427e4d879301c1bf542842eccc8aa3c3"}, "originalPosition": 491}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgyMzE4MTk2OnYy", "diffSide": "RIGHT", "path": "messaging/src/main/java/org/axonframework/queryhandling/ReactorQueryGateway.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xMFQxMToyMzoyNFrOGvzxDg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xMFQxMToyMzoyNFrOGvzxDg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mjc4NDM5OA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * Uses given Publisher of queries to send incoming queries away. Queries will be sent sequentially - once a result\n          \n          \n            \n                 * of Nth query arrives, (N + 1)th query is dispatched. All queries will be dispatched using given {@code\n          \n          \n            \n                 * backpressure}.\n          \n          \n            \n                 *\n          \n          \n            \n                 * @param queries      a Publisher stream of queries to be dispatched\n          \n          \n            \n                 * @param backpressure The backpressure mechanism to deal with producing of incremental updates\n          \n          \n            \n                 * @return a Flux of query results. An ordering of query results corresponds to an ordering of queries being\n          \n          \n            \n                 * dispatched\n          \n          \n            \n                 * Uses the given {@link Publisher} of {@link SubscriptionQueryMessage}s to send incoming queries away. Queries will be sent sequentially. Once the result\n          \n          \n            \n                 * of Nth query arrives, the (N + 1)th query is dispatched. All queries will be dispatched using the given {@code\n          \n          \n            \n                 * backpressure}.\n          \n          \n            \n                 *\n          \n          \n            \n                 * @param queries      a {@link Publisher} stream of queries to be dispatched\n          \n          \n            \n                 * @param backpressure the backpressure mechanism to deal with producing of incremental updates\n          \n          \n            \n                 * @return a {@link Flux} of query results. The ordering of query results corresponds to the ordering of queries being\n          \n          \n            \n                 * dispatched", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r452784398", "createdAt": "2020-07-10T11:23:24Z", "author": {"login": "smcvb"}, "path": "messaging/src/main/java/org/axonframework/queryhandling/ReactorQueryGateway.java", "diffHunk": "@@ -0,0 +1,547 @@\n+/*\n+ * Copyright (c) 2010-2020. Axon Framework\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.axonframework.queryhandling;\n+\n+import org.axonframework.messaging.ResultMessage;\n+import org.axonframework.messaging.reactive.ReactorMessageDispatchInterceptorSupport;\n+import org.axonframework.messaging.reactive.ReactorResultHandlerInterceptorSupport;\n+import org.axonframework.messaging.responsetypes.ResponseType;\n+import org.axonframework.messaging.responsetypes.ResponseTypes;\n+import org.reactivestreams.Publisher;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Mono;\n+import reactor.util.concurrent.Queues;\n+\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Function;\n+\n+/**\n+ * Variation of {@link QueryGateway}. Provides support for reactive return types such as {@link Mono} and {@link Flux}\n+ * from Project Reactor.\n+ *\n+ * @author Milan Savic\n+ * @since 4.4\n+ */\n+public interface ReactorQueryGateway extends ReactorMessageDispatchInterceptorSupport<QueryMessage<?, ?>>,\n+        ReactorResultHandlerInterceptorSupport<QueryMessage<?, ?>, ResultMessage<?>> {\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response with the given {@code responseType}\n+     * from a single source. The query name will be derived from the provided {@code query}. Execution may be\n+     * asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param query        The {@code query} to be sent\n+     * @param responseType A {@link Class} describing the desired response type\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(Q query, Class<R> responseType) {\n+        return query(query.getClass().getName(), query, responseType);\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response with the given {@code responseType}\n+     * from a single source. Execution may be asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(String queryName, Q query, Class<R> responseType) {\n+        return query(queryName, query, ResponseTypes.instanceOf(responseType));\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from a single source. The query name will be derived from the provided {@code query}. Execution may be\n+     * asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(Q query, ResponseType<R> responseType) {\n+        return query(query.getClass().getName(), query, responseType);\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from a single source. Execution may be asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    <R, Q> Mono<R> query(String queryName, Q query, ResponseType<R> responseType);\n+\n+    /**\n+     * Uses given Publisher of query messages to send incoming queries away. Queries will be sent sequentially - once a\n+     * result of Nth query arrives, (N + 1)th query is dispatched.\n+     *\n+     * @param queries a Publisher stream of queries to be dispatched\n+     * @return a Flux of query results. An ordering of query results corresponds to an ordering of queries being\n+     * dispatched\n+     *\n+     * @see #query(String, Object, ResponseType)\n+     * @see Flux#concatMap(Function)\n+     */\n+    default Flux<Object> query(Publisher<QueryMessage<?, ?>> queries) {\n+        return Flux.from(queries)\n+                   .concatMap(q -> query(q.getQueryName(), q.getPayload(), q.getResponseType()));\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from several sources. The returned {@link Flux} is completed when a {@code timeout} occurs or when all possible\n+     * results are received. The query name will be derived from the provided {@code query}. Execution may be\n+     * asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     * <b>Note</b>: Any {@code null} results will be filtered out by the {@link ReactorQueryGateway}. If you require\n+     * the {@code null} to be returned, we suggest using {@code QueryBus} instead.\n+     *\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param timeout      A timeout of {@code long} for the query\n+     * @param timeUnit     The selected {@link TimeUnit} for the given {@code timeout}\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Flux} containing the query results as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Flux<R> scatterGather(Q query, ResponseType<R> responseType, long timeout, TimeUnit timeUnit) {\n+        return scatterGather(query.getClass().getName(), query, responseType, timeout, timeUnit);\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from several sources. The returned {@link Flux} is completed when a {@code timeout} occurs or when all results\n+     * are received. Execution may be asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     * <b>Note</b>: Any {@code null} results will be filtered out by the {@link ReactorQueryGateway}. If you require\n+     * the {@code null} to be returned, we suggest using {@code QueryBus} instead.\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param timeout      A timeout of {@code long} for the query\n+     * @param timeUnit     The selected {@link TimeUnit} for the given {@code timeout}\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Flux} containing the query results as dictated by the given {@code responseType}\n+     */\n+    <R, Q> Flux<R> scatterGather(String queryName, Q query, ResponseType<R> responseType, long timeout,\n+                                 TimeUnit timeUnit);\n+\n+    /**\n+     * Uses given Publisher of queries to send incoming queries in scatter gather manner. Queries will be sent\n+     * sequentially - once a result of Nth query arrives, (N + 1)th query is dispatched. All queries will be dispatched\n+     * using given {@code timeout} and {@code timeUnit}.\n+     *\n+     * @param queries  a Publisher stream of queries to be dispatched\n+     * @param timeout  A timeout of {@code long} for the query\n+     * @param timeUnit The selected {@link TimeUnit} for the given {@code timeout}\n+     * @return a Flux of query results. An ordering of query results corresponds to an ordering of queries being\n+     * dispatched\n+     */\n+    default Flux<Object> scatterGather(Publisher<QueryMessage<?, ?>> queries, long timeout, TimeUnit timeUnit) {\n+        return Flux.from(queries)\n+                   .concatMap(q -> scatterGather(q.getQueryName(),\n+                                                 q.getPayload(),\n+                                                 q.getResponseType(),\n+                                                 timeout,\n+                                                 timeUnit));\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, returns initial result and keeps streaming\n+     * incremental updates until subscriber unsubscribes from Flux.\n+     * Should be used when response type of initial result and incremental update match.\n+     * (received at the moment the query is sent, until it is cancelled by the caller or closed by the emitting side).\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Flux}</b></p>\n+     * <p>\n+     * <b>Note</b>: Any {@code null} results, on the initial result or the updates, will be filtered out by the\n+     * {@link ReactorQueryGateway}. If you require the {@code null} to be returned for the initial and update results,\n+     * we suggest using the {@code QueryBus} instead.\n+     *\n+     * @param query      The {@code query} to be sent\n+     * @param resultType The response type used for this query\n+     * @param <Q>        The type of the query\n+     * @param <R>        The type of the result (initial & updates)\n+     * @return Flux which can be used to cancel receiving updates\n+     *\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage)\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage, SubscriptionQueryBackpressure, int)\n+     */\n+    default <Q, R> Flux<R> subscriptionQuery(Q query, ResponseType<R> resultType) {\n+        return subscriptionQuery(query, resultType, resultType)\n+                .flatMapMany(result -> result.initialResult()\n+                                             .concatWith(result.updates())\n+                                             .doFinally(signal -> result.close()));\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, returns initial result and keeps streaming\n+     * incremental updates until subscriber unsubscribes from Flux.\n+     * Should be used when response type of initial result and incremental update match.\n+     * (received at the moment the query is sent, until it is cancelled by the caller or closed by the emitting side).\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Flux}</b></p>\n+     * <p>\n+     * <b>Note</b>: Any {@code null} results, on the initial result or the updates, will be filtered out by the\n+     * {@link ReactorQueryGateway}. If you require the {@code null} to be returned for the initial and update results,\n+     * we suggest using the {@code QueryBus} instead.\n+     *\n+     * @param query      The {@code query} to be sent\n+     * @param resultType The response type used for this query\n+     * @param <Q>        The type of the query\n+     * @param <R>        The type of the result (initial & updates)\n+     * @return Flux which can be used to cancel receiving updates\n+     *\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage)\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage, SubscriptionQueryBackpressure, int)\n+     */\n+    default <Q, R> Flux<R> subscriptionQuery(Q query, Class<R> resultType) {\n+        return subscriptionQuery(query, ResponseTypes.instanceOf(resultType));\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, returns initial result and keeps streaming\n+     * incremental updates until subscriber unsubscribes from Flux.\n+     * Should be used when initial result contains multiple instances of response type and needs to be flatten.\n+     * Response type of initial response and incremental updates needs to match.\n+     * (received at the moment the query is sent, until it is cancelled by the caller or closed by the emitting side).\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Flux}</b></p>\n+     * <p>\n+     * <b>Note</b>: Any {@code null} results, on the initial result or the updates, will be filtered out by the\n+     * {@link ReactorQueryGateway}. If you require the {@code null} to be returned for the initial and update results,\n+     * we suggest using the {@code QueryBus} instead.\n+     *\n+     * @param query      The {@code query} to be sent\n+     * @param resultType The response type used for this query\n+     * @param <Q>        The type of the query\n+     * @param <R>        The type of the result (initial & updates)\n+     * @return Flux which can be used to cancel receiving updates\n+     *\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage)\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage, SubscriptionQueryBackpressure, int)\n+     */\n+    default <Q, R> Flux<R> subscriptionQueryMany(Q query, Class<R> resultType) {\n+        return subscriptionQuery(query,\n+                                 ResponseTypes.multipleInstancesOf(resultType),\n+                                 ResponseTypes.instanceOf(resultType))\n+                .flatMapMany(result -> result.initialResult()\n+                                             .flatMapMany(Flux::fromIterable)\n+                                             .concatWith(result.updates())\n+                                             .doFinally(signal -> result.close()));\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, and streams\n+     * incremental updates until subscriber unsubscribes from Flux.\n+     * Should be used when subscriber is interested only in updates.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Flux}</b></p>\n+     * <p>\n+     * <b>Note</b>: Any {@code null} results, will be filtered out by the\n+     * {@link ReactorQueryGateway}. If you require the {@code null} to be returned for the initial and update results,\n+     * we suggest using the {@code QueryBus} instead.\n+     *\n+     * @param query      The {@code query} to be sent\n+     * @param resultType The response type used for this query\n+     * @param <Q>        The type of the query\n+     * @param <R>        The type of the result (updates)\n+     * @return Flux which can be used to cancel receiving updates\n+     *\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage)\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage, SubscriptionQueryBackpressure, int)\n+     */\n+    default <Q, R> Flux<R> queryUpdates(Q query, ResponseType<R> resultType) {\n+        return subscriptionQuery(query, ResponseTypes.instanceOf(Void.class), resultType)\n+                .flatMapMany(result -> result.updates()\n+                                             .doFinally(signal -> result.close()));\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, and streams\n+     * incremental updates until subscriber unsubscribes from Flux.\n+     * Should be used when subscriber is interested only in updates.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Flux}</b></p>\n+     * <p>\n+     * <b>Note</b>: Any {@code null} results, will be filtered out by the\n+     * {@link ReactorQueryGateway}. If you require the {@code null} to be returned for the initial and update results,\n+     * we suggest using the {@code QueryBus} instead.\n+     *\n+     * @param query      The {@code query} to be sent\n+     * @param resultType The response type used for this query\n+     * @param <Q>        The type of the query\n+     * @param <R>        The type of the result (updates)\n+     * @return Flux which can be used to cancel receiving updates\n+     *\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage)\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage, SubscriptionQueryBackpressure, int)\n+     */\n+    default <Q, R> Flux<R> queryUpdates(Q query, Class<R> resultType) {\n+        return queryUpdates(query, ResponseTypes.instanceOf(resultType));\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus} and returns result containing initial response and\n+     * incremental updates (received at the moment the query is sent, until it is cancelled by the caller or closed by\n+     * the emitting side).\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     * <p>\n+     * <b>Note</b>: Any {@code null} results, on the initial result or the updates, will be filtered out by the\n+     * {@link ReactorQueryGateway}. If you require the {@code null} to be returned for the initial and update results,\n+     * we suggest using the {@code QueryBus} instead.\n+     *\n+     * @param query               The {@code query} to be sent\n+     * @param initialResponseType The initial response type used for this query\n+     * @param updateResponseType  The update response type used for this query\n+     * @param <Q>                 The type of the query\n+     * @param <I>                 The type of the initial response\n+     * @param <U>                 The type of the incremental update\n+     * @return registration which can be used to cancel receiving updates\n+     *\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage)\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage, SubscriptionQueryBackpressure, int)\n+     */\n+    default <Q, I, U> Mono<SubscriptionQueryResult<I, U>> subscriptionQuery(Q query, Class<I> initialResponseType,\n+                                                                            Class<U> updateResponseType) {\n+        return subscriptionQuery(query.getClass().getName(),\n+                                 query,\n+                                 initialResponseType,\n+                                 updateResponseType);\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus} and returns result containing initial response and\n+     * incremental updates (received at the moment the query is sent, until it is cancelled by the caller or closed by\n+     * the emitting side).\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     * <p>\n+     * <b>Note</b>: Any {@code null} results, on the initial result or the updates, will be filtered out by the\n+     * {@link ReactorQueryGateway}. If you require the {@code null} to be returned for the initial and update results,\n+     * we suggest using the {@code QueryBus} instead.\n+     *\n+     * @param queryName           A {@link String} describing query to be executed\n+     * @param query               The {@code query} to be sent\n+     * @param initialResponseType The initial response type used for this query\n+     * @param updateResponseType  The update response type used for this query\n+     * @param <Q>                 The type of the query\n+     * @param <I>                 The type of the initial response\n+     * @param <U>                 The type of the incremental update\n+     * @return registration which can be used to cancel receiving updates\n+     *\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage)\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage, SubscriptionQueryBackpressure, int)\n+     */\n+    default <Q, I, U> Mono<SubscriptionQueryResult<I, U>> subscriptionQuery(String queryName, Q query,\n+                                                                            Class<I> initialResponseType,\n+                                                                            Class<U> updateResponseType) {\n+        return subscriptionQuery(queryName,\n+                                 query,\n+                                 ResponseTypes.instanceOf(initialResponseType),\n+                                 ResponseTypes.instanceOf(updateResponseType),\n+                                 SubscriptionQueryBackpressure.defaultBackpressure());\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus} and returns result containing initial response and\n+     * incremental updates (received at the moment the query is sent, until it is cancelled by the caller or closed by\n+     * the emitting side).\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     * <p>\n+     * <b>Note</b>: Any {@code null} results, on the initial result or the updates, will be filtered out by the\n+     * {@link ReactorQueryGateway}. If you require the {@code null} to be returned for the initial and update results,\n+     * we suggest using the {@code QueryBus} instead.\n+     *\n+     * @param query               The {@code query} to be sent\n+     * @param initialResponseType The initial response type used for this query\n+     * @param updateResponseType  The update response type used for this query\n+     * @param <Q>                 The type of the query\n+     * @param <I>                 The type of the initial response\n+     * @param <U>                 The type of the incremental update\n+     * @return registration which can be used to cancel receiving updates\n+     *\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage)\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage, SubscriptionQueryBackpressure, int)\n+     */\n+    default <Q, I, U> Mono<SubscriptionQueryResult<I, U>> subscriptionQuery(Q query,\n+                                                                            ResponseType<I> initialResponseType,\n+                                                                            ResponseType<U> updateResponseType) {\n+        return subscriptionQuery(query.getClass().getName(),\n+                                 query,\n+                                 initialResponseType,\n+                                 updateResponseType,\n+                                 SubscriptionQueryBackpressure.defaultBackpressure());\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus} and returns result containing initial response and\n+     * incremental updates (received at the moment the query is sent, until it is cancelled by the caller or closed by\n+     * the emitting side).\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     * <p>\n+     * <b>Note</b>: Any {@code null} results, on the initial result or the updates, will be filtered out by the\n+     * {@link ReactorQueryGateway}. If you require the {@code null} to be returned for the initial and update results,\n+     * we suggest using the {@code QueryBus} instead.\n+     *\n+     * @param queryName           A {@link String} describing query to be executed\n+     * @param query               The {@code query} to be sent\n+     * @param initialResponseType The initial response type used for this query\n+     * @param updateResponseType  The update response type used for this query\n+     * @param backpressure        The backpressure mechanism to deal with producing of incremental updates\n+     * @param <Q>                 The type of the query\n+     * @param <I>                 The type of the initial response\n+     * @param <U>                 The type of the incremental update\n+     * @return registration which can be used to cancel receiving updates\n+     *\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage)\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage, SubscriptionQueryBackpressure, int)\n+     */\n+    default <Q, I, U> Mono<SubscriptionQueryResult<I, U>> subscriptionQuery(String queryName, Q query,\n+                                                                            ResponseType<I> initialResponseType,\n+                                                                            ResponseType<U> updateResponseType,\n+                                                                            SubscriptionQueryBackpressure backpressure) {\n+        return subscriptionQuery(queryName,\n+                                 query,\n+                                 initialResponseType,\n+                                 updateResponseType,\n+                                 backpressure,\n+                                 Queues.SMALL_BUFFER_SIZE);\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus} and returns result containing initial response and\n+     * incremental updates (received at the moment the query is sent, until it is cancelled by the caller or closed by\n+     * the emitting side).\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     * <p>\n+     * <b>Note</b>: Any {@code null} results, on the initial result or the updates, will be filtered out by the\n+     * {@link ReactorQueryGateway}. If you require the {@code null} to be returned for the initial and update results,\n+     * we suggest using the {@code QueryBus} instead.\n+     *\n+     * @param queryName           A {@link String} describing query to be executed\n+     * @param query               The {@code query} to be sent\n+     * @param initialResponseType The initial response type used for this query\n+     * @param updateResponseType  The update response type used for this query\n+     * @param backpressure        The backpressure mechanism to deal with producing of incremental updates\n+     * @param updateBufferSize    The size of buffer which accumulates updates before subscription to the {@code flux}\n+     *                            is made\n+     * @param <Q>                 The type of the query\n+     * @param <I>                 The type of the initial response\n+     * @param <U>                 The type of the incremental update\n+     * @return registration which can be used to cancel receiving updates\n+     *\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage)\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage, SubscriptionQueryBackpressure, int)\n+     */\n+    <Q, I, U> Mono<SubscriptionQueryResult<I, U>> subscriptionQuery(String queryName, Q query,\n+                                                                    ResponseType<I> initialResponseType,\n+                                                                    ResponseType<U> updateResponseType,\n+                                                                    SubscriptionQueryBackpressure backpressure,\n+                                                                    int updateBufferSize);\n+\n+    /**\n+     * Uses given Publisher of queries to send incoming queries away. Queries will be sent sequentially - once a result\n+     * of Nth query arrives, (N + 1)th query is dispatched.\n+     *\n+     * @param queries a Publisher stream of queries to be dispatched\n+     * @return a Flux of query results. An ordering of query results corresponds to an ordering of queries being\n+     * dispatched\n+     *\n+     * @see #subscriptionQuery(String, Object, Class, Class)\n+     * @see Flux#concatMap(Function)\n+     */\n+    default Flux<SubscriptionQueryResult<?, ?>> subscriptionQuery( // NOSONAR\n+                                                                   Publisher<SubscriptionQueryMessage<?, ?, ?>> queries) {\n+        return subscriptionQuery(queries, SubscriptionQueryBackpressure.defaultBackpressure());\n+    }\n+\n+    /**\n+     * Uses given Publisher of queries to send incoming queries away. Queries will be sent sequentially - once a result\n+     * of Nth query arrives, (N + 1)th query is dispatched. All queries will be dispatched using given {@code\n+     * backpressure}.\n+     *\n+     * @param queries      a Publisher stream of queries to be dispatched\n+     * @param backpressure The backpressure mechanism to deal with producing of incremental updates\n+     * @return a Flux of query results. An ordering of query results corresponds to an ordering of queries being\n+     * dispatched", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "98865ab1427e4d879301c1bf542842eccc8aa3c3"}, "originalPosition": 509}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgyMzE4NDk1OnYy", "diffSide": "RIGHT", "path": "messaging/src/main/java/org/axonframework/queryhandling/ReactorQueryGateway.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xMFQxMToyNDoyOFrOGvzy0A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xMFQxMToyNDoyOFrOGvzy0A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mjc4NDg0OA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * Uses given Publisher of queries to send incoming queries away. Queries will be sent sequentially - once a result\n          \n          \n            \n                 * of Nth query arrives, (N + 1)th query is dispatched. All queries will be dispatched using given {@code\n          \n          \n            \n                 * backpressure} and {@code updateBufferSize}.\n          \n          \n            \n                 *\n          \n          \n            \n                 * @param queries          a Publisher stream of queries to be dispatched\n          \n          \n            \n                 * @param backpressure     The backpressure mechanism to deal with producing of incremental updates\n          \n          \n            \n                 * @param updateBufferSize The size of buffer which accumulates updates before subscription to the {@code flux}\n          \n          \n            \n                 *                         is made\n          \n          \n            \n                 * @return a Flux of query results. An ordering of query results corresponds to an ordering of queries being\n          \n          \n            \n                 * dispatched\n          \n          \n            \n                 * Uses the given {@link Publisher} of {@link SubscriptionQueryMessage}s to send incoming queries away. Queries will be sent sequentially. Once the result\n          \n          \n            \n                 * of Nth query arrives, the (N + 1)th query is dispatched. All queries will be dispatched using given {@code\n          \n          \n            \n                 * backpressure} and {@code updateBufferSize}.\n          \n          \n            \n                 *\n          \n          \n            \n                 * @param queries          a {@link Publisher} stream of queries to be dispatched\n          \n          \n            \n                 * @param backpressure     the backpressure mechanism to deal with producing of incremental updates\n          \n          \n            \n                 * @param updateBufferSize the size of buffer which accumulates updates before subscription to the {@code flux}\n          \n          \n            \n                 *                         is made\n          \n          \n            \n                 * @return a {@link Flux} of query results. The ordering of query results corresponds to the ordering of queries being\n          \n          \n            \n                 * dispatched", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r452784848", "createdAt": "2020-07-10T11:24:28Z", "author": {"login": "smcvb"}, "path": "messaging/src/main/java/org/axonframework/queryhandling/ReactorQueryGateway.java", "diffHunk": "@@ -0,0 +1,547 @@\n+/*\n+ * Copyright (c) 2010-2020. Axon Framework\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.axonframework.queryhandling;\n+\n+import org.axonframework.messaging.ResultMessage;\n+import org.axonframework.messaging.reactive.ReactorMessageDispatchInterceptorSupport;\n+import org.axonframework.messaging.reactive.ReactorResultHandlerInterceptorSupport;\n+import org.axonframework.messaging.responsetypes.ResponseType;\n+import org.axonframework.messaging.responsetypes.ResponseTypes;\n+import org.reactivestreams.Publisher;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Mono;\n+import reactor.util.concurrent.Queues;\n+\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Function;\n+\n+/**\n+ * Variation of {@link QueryGateway}. Provides support for reactive return types such as {@link Mono} and {@link Flux}\n+ * from Project Reactor.\n+ *\n+ * @author Milan Savic\n+ * @since 4.4\n+ */\n+public interface ReactorQueryGateway extends ReactorMessageDispatchInterceptorSupport<QueryMessage<?, ?>>,\n+        ReactorResultHandlerInterceptorSupport<QueryMessage<?, ?>, ResultMessage<?>> {\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response with the given {@code responseType}\n+     * from a single source. The query name will be derived from the provided {@code query}. Execution may be\n+     * asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param query        The {@code query} to be sent\n+     * @param responseType A {@link Class} describing the desired response type\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(Q query, Class<R> responseType) {\n+        return query(query.getClass().getName(), query, responseType);\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response with the given {@code responseType}\n+     * from a single source. Execution may be asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(String queryName, Q query, Class<R> responseType) {\n+        return query(queryName, query, ResponseTypes.instanceOf(responseType));\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from a single source. The query name will be derived from the provided {@code query}. Execution may be\n+     * asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Mono<R> query(Q query, ResponseType<R> responseType) {\n+        return query(query.getClass().getName(), query, responseType);\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from a single source. Execution may be asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Mono} containing the query result as dictated by the given {@code responseType}\n+     */\n+    <R, Q> Mono<R> query(String queryName, Q query, ResponseType<R> responseType);\n+\n+    /**\n+     * Uses given Publisher of query messages to send incoming queries away. Queries will be sent sequentially - once a\n+     * result of Nth query arrives, (N + 1)th query is dispatched.\n+     *\n+     * @param queries a Publisher stream of queries to be dispatched\n+     * @return a Flux of query results. An ordering of query results corresponds to an ordering of queries being\n+     * dispatched\n+     *\n+     * @see #query(String, Object, ResponseType)\n+     * @see Flux#concatMap(Function)\n+     */\n+    default Flux<Object> query(Publisher<QueryMessage<?, ?>> queries) {\n+        return Flux.from(queries)\n+                   .concatMap(q -> query(q.getQueryName(), q.getPayload(), q.getResponseType()));\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from several sources. The returned {@link Flux} is completed when a {@code timeout} occurs or when all possible\n+     * results are received. The query name will be derived from the provided {@code query}. Execution may be\n+     * asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     * <b>Note</b>: Any {@code null} results will be filtered out by the {@link ReactorQueryGateway}. If you require\n+     * the {@code null} to be returned, we suggest using {@code QueryBus} instead.\n+     *\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param timeout      A timeout of {@code long} for the query\n+     * @param timeUnit     The selected {@link TimeUnit} for the given {@code timeout}\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Flux} containing the query results as dictated by the given {@code responseType}\n+     */\n+    default <R, Q> Flux<R> scatterGather(Q query, ResponseType<R> responseType, long timeout, TimeUnit timeUnit) {\n+        return scatterGather(query.getClass().getName(), query, responseType, timeout, timeUnit);\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, expecting a response in the form of {@code responseType}\n+     * from several sources. The returned {@link Flux} is completed when a {@code timeout} occurs or when all results\n+     * are received. Execution may be asynchronous, depending on the {@code QueryBus} implementation.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     * <b>Note</b>: Any {@code null} results will be filtered out by the {@link ReactorQueryGateway}. If you require\n+     * the {@code null} to be returned, we suggest using {@code QueryBus} instead.\n+     *\n+     * @param queryName    A {@link String} describing the query to be executed\n+     * @param query        The {@code query} to be sent\n+     * @param responseType The {@link ResponseType} used for this query\n+     * @param timeout      A timeout of {@code long} for the query\n+     * @param timeUnit     The selected {@link TimeUnit} for the given {@code timeout}\n+     * @param <R>          The response class contained in the given {@code responseType}\n+     * @param <Q>          The query class\n+     * @return A {@link Flux} containing the query results as dictated by the given {@code responseType}\n+     */\n+    <R, Q> Flux<R> scatterGather(String queryName, Q query, ResponseType<R> responseType, long timeout,\n+                                 TimeUnit timeUnit);\n+\n+    /**\n+     * Uses given Publisher of queries to send incoming queries in scatter gather manner. Queries will be sent\n+     * sequentially - once a result of Nth query arrives, (N + 1)th query is dispatched. All queries will be dispatched\n+     * using given {@code timeout} and {@code timeUnit}.\n+     *\n+     * @param queries  a Publisher stream of queries to be dispatched\n+     * @param timeout  A timeout of {@code long} for the query\n+     * @param timeUnit The selected {@link TimeUnit} for the given {@code timeout}\n+     * @return a Flux of query results. An ordering of query results corresponds to an ordering of queries being\n+     * dispatched\n+     */\n+    default Flux<Object> scatterGather(Publisher<QueryMessage<?, ?>> queries, long timeout, TimeUnit timeUnit) {\n+        return Flux.from(queries)\n+                   .concatMap(q -> scatterGather(q.getQueryName(),\n+                                                 q.getPayload(),\n+                                                 q.getResponseType(),\n+                                                 timeout,\n+                                                 timeUnit));\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, returns initial result and keeps streaming\n+     * incremental updates until subscriber unsubscribes from Flux.\n+     * Should be used when response type of initial result and incremental update match.\n+     * (received at the moment the query is sent, until it is cancelled by the caller or closed by the emitting side).\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Flux}</b></p>\n+     * <p>\n+     * <b>Note</b>: Any {@code null} results, on the initial result or the updates, will be filtered out by the\n+     * {@link ReactorQueryGateway}. If you require the {@code null} to be returned for the initial and update results,\n+     * we suggest using the {@code QueryBus} instead.\n+     *\n+     * @param query      The {@code query} to be sent\n+     * @param resultType The response type used for this query\n+     * @param <Q>        The type of the query\n+     * @param <R>        The type of the result (initial & updates)\n+     * @return Flux which can be used to cancel receiving updates\n+     *\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage)\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage, SubscriptionQueryBackpressure, int)\n+     */\n+    default <Q, R> Flux<R> subscriptionQuery(Q query, ResponseType<R> resultType) {\n+        return subscriptionQuery(query, resultType, resultType)\n+                .flatMapMany(result -> result.initialResult()\n+                                             .concatWith(result.updates())\n+                                             .doFinally(signal -> result.close()));\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, returns initial result and keeps streaming\n+     * incremental updates until subscriber unsubscribes from Flux.\n+     * Should be used when response type of initial result and incremental update match.\n+     * (received at the moment the query is sent, until it is cancelled by the caller or closed by the emitting side).\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Flux}</b></p>\n+     * <p>\n+     * <b>Note</b>: Any {@code null} results, on the initial result or the updates, will be filtered out by the\n+     * {@link ReactorQueryGateway}. If you require the {@code null} to be returned for the initial and update results,\n+     * we suggest using the {@code QueryBus} instead.\n+     *\n+     * @param query      The {@code query} to be sent\n+     * @param resultType The response type used for this query\n+     * @param <Q>        The type of the query\n+     * @param <R>        The type of the result (initial & updates)\n+     * @return Flux which can be used to cancel receiving updates\n+     *\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage)\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage, SubscriptionQueryBackpressure, int)\n+     */\n+    default <Q, R> Flux<R> subscriptionQuery(Q query, Class<R> resultType) {\n+        return subscriptionQuery(query, ResponseTypes.instanceOf(resultType));\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, returns initial result and keeps streaming\n+     * incremental updates until subscriber unsubscribes from Flux.\n+     * Should be used when initial result contains multiple instances of response type and needs to be flatten.\n+     * Response type of initial response and incremental updates needs to match.\n+     * (received at the moment the query is sent, until it is cancelled by the caller or closed by the emitting side).\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Flux}</b></p>\n+     * <p>\n+     * <b>Note</b>: Any {@code null} results, on the initial result or the updates, will be filtered out by the\n+     * {@link ReactorQueryGateway}. If you require the {@code null} to be returned for the initial and update results,\n+     * we suggest using the {@code QueryBus} instead.\n+     *\n+     * @param query      The {@code query} to be sent\n+     * @param resultType The response type used for this query\n+     * @param <Q>        The type of the query\n+     * @param <R>        The type of the result (initial & updates)\n+     * @return Flux which can be used to cancel receiving updates\n+     *\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage)\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage, SubscriptionQueryBackpressure, int)\n+     */\n+    default <Q, R> Flux<R> subscriptionQueryMany(Q query, Class<R> resultType) {\n+        return subscriptionQuery(query,\n+                                 ResponseTypes.multipleInstancesOf(resultType),\n+                                 ResponseTypes.instanceOf(resultType))\n+                .flatMapMany(result -> result.initialResult()\n+                                             .flatMapMany(Flux::fromIterable)\n+                                             .concatWith(result.updates())\n+                                             .doFinally(signal -> result.close()));\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, and streams\n+     * incremental updates until subscriber unsubscribes from Flux.\n+     * Should be used when subscriber is interested only in updates.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Flux}</b></p>\n+     * <p>\n+     * <b>Note</b>: Any {@code null} results, will be filtered out by the\n+     * {@link ReactorQueryGateway}. If you require the {@code null} to be returned for the initial and update results,\n+     * we suggest using the {@code QueryBus} instead.\n+     *\n+     * @param query      The {@code query} to be sent\n+     * @param resultType The response type used for this query\n+     * @param <Q>        The type of the query\n+     * @param <R>        The type of the result (updates)\n+     * @return Flux which can be used to cancel receiving updates\n+     *\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage)\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage, SubscriptionQueryBackpressure, int)\n+     */\n+    default <Q, R> Flux<R> queryUpdates(Q query, ResponseType<R> resultType) {\n+        return subscriptionQuery(query, ResponseTypes.instanceOf(Void.class), resultType)\n+                .flatMapMany(result -> result.updates()\n+                                             .doFinally(signal -> result.close()));\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus}, and streams\n+     * incremental updates until subscriber unsubscribes from Flux.\n+     * Should be used when subscriber is interested only in updates.\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Flux}</b></p>\n+     * <p>\n+     * <b>Note</b>: Any {@code null} results, will be filtered out by the\n+     * {@link ReactorQueryGateway}. If you require the {@code null} to be returned for the initial and update results,\n+     * we suggest using the {@code QueryBus} instead.\n+     *\n+     * @param query      The {@code query} to be sent\n+     * @param resultType The response type used for this query\n+     * @param <Q>        The type of the query\n+     * @param <R>        The type of the result (updates)\n+     * @return Flux which can be used to cancel receiving updates\n+     *\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage)\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage, SubscriptionQueryBackpressure, int)\n+     */\n+    default <Q, R> Flux<R> queryUpdates(Q query, Class<R> resultType) {\n+        return queryUpdates(query, ResponseTypes.instanceOf(resultType));\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus} and returns result containing initial response and\n+     * incremental updates (received at the moment the query is sent, until it is cancelled by the caller or closed by\n+     * the emitting side).\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     * <p>\n+     * <b>Note</b>: Any {@code null} results, on the initial result or the updates, will be filtered out by the\n+     * {@link ReactorQueryGateway}. If you require the {@code null} to be returned for the initial and update results,\n+     * we suggest using the {@code QueryBus} instead.\n+     *\n+     * @param query               The {@code query} to be sent\n+     * @param initialResponseType The initial response type used for this query\n+     * @param updateResponseType  The update response type used for this query\n+     * @param <Q>                 The type of the query\n+     * @param <I>                 The type of the initial response\n+     * @param <U>                 The type of the incremental update\n+     * @return registration which can be used to cancel receiving updates\n+     *\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage)\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage, SubscriptionQueryBackpressure, int)\n+     */\n+    default <Q, I, U> Mono<SubscriptionQueryResult<I, U>> subscriptionQuery(Q query, Class<I> initialResponseType,\n+                                                                            Class<U> updateResponseType) {\n+        return subscriptionQuery(query.getClass().getName(),\n+                                 query,\n+                                 initialResponseType,\n+                                 updateResponseType);\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus} and returns result containing initial response and\n+     * incremental updates (received at the moment the query is sent, until it is cancelled by the caller or closed by\n+     * the emitting side).\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     * <p>\n+     * <b>Note</b>: Any {@code null} results, on the initial result or the updates, will be filtered out by the\n+     * {@link ReactorQueryGateway}. If you require the {@code null} to be returned for the initial and update results,\n+     * we suggest using the {@code QueryBus} instead.\n+     *\n+     * @param queryName           A {@link String} describing query to be executed\n+     * @param query               The {@code query} to be sent\n+     * @param initialResponseType The initial response type used for this query\n+     * @param updateResponseType  The update response type used for this query\n+     * @param <Q>                 The type of the query\n+     * @param <I>                 The type of the initial response\n+     * @param <U>                 The type of the incremental update\n+     * @return registration which can be used to cancel receiving updates\n+     *\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage)\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage, SubscriptionQueryBackpressure, int)\n+     */\n+    default <Q, I, U> Mono<SubscriptionQueryResult<I, U>> subscriptionQuery(String queryName, Q query,\n+                                                                            Class<I> initialResponseType,\n+                                                                            Class<U> updateResponseType) {\n+        return subscriptionQuery(queryName,\n+                                 query,\n+                                 ResponseTypes.instanceOf(initialResponseType),\n+                                 ResponseTypes.instanceOf(updateResponseType),\n+                                 SubscriptionQueryBackpressure.defaultBackpressure());\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus} and returns result containing initial response and\n+     * incremental updates (received at the moment the query is sent, until it is cancelled by the caller or closed by\n+     * the emitting side).\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     * <p>\n+     * <b>Note</b>: Any {@code null} results, on the initial result or the updates, will be filtered out by the\n+     * {@link ReactorQueryGateway}. If you require the {@code null} to be returned for the initial and update results,\n+     * we suggest using the {@code QueryBus} instead.\n+     *\n+     * @param query               The {@code query} to be sent\n+     * @param initialResponseType The initial response type used for this query\n+     * @param updateResponseType  The update response type used for this query\n+     * @param <Q>                 The type of the query\n+     * @param <I>                 The type of the initial response\n+     * @param <U>                 The type of the incremental update\n+     * @return registration which can be used to cancel receiving updates\n+     *\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage)\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage, SubscriptionQueryBackpressure, int)\n+     */\n+    default <Q, I, U> Mono<SubscriptionQueryResult<I, U>> subscriptionQuery(Q query,\n+                                                                            ResponseType<I> initialResponseType,\n+                                                                            ResponseType<U> updateResponseType) {\n+        return subscriptionQuery(query.getClass().getName(),\n+                                 query,\n+                                 initialResponseType,\n+                                 updateResponseType,\n+                                 SubscriptionQueryBackpressure.defaultBackpressure());\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus} and returns result containing initial response and\n+     * incremental updates (received at the moment the query is sent, until it is cancelled by the caller or closed by\n+     * the emitting side).\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     * <p>\n+     * <b>Note</b>: Any {@code null} results, on the initial result or the updates, will be filtered out by the\n+     * {@link ReactorQueryGateway}. If you require the {@code null} to be returned for the initial and update results,\n+     * we suggest using the {@code QueryBus} instead.\n+     *\n+     * @param queryName           A {@link String} describing query to be executed\n+     * @param query               The {@code query} to be sent\n+     * @param initialResponseType The initial response type used for this query\n+     * @param updateResponseType  The update response type used for this query\n+     * @param backpressure        The backpressure mechanism to deal with producing of incremental updates\n+     * @param <Q>                 The type of the query\n+     * @param <I>                 The type of the initial response\n+     * @param <U>                 The type of the incremental update\n+     * @return registration which can be used to cancel receiving updates\n+     *\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage)\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage, SubscriptionQueryBackpressure, int)\n+     */\n+    default <Q, I, U> Mono<SubscriptionQueryResult<I, U>> subscriptionQuery(String queryName, Q query,\n+                                                                            ResponseType<I> initialResponseType,\n+                                                                            ResponseType<U> updateResponseType,\n+                                                                            SubscriptionQueryBackpressure backpressure) {\n+        return subscriptionQuery(queryName,\n+                                 query,\n+                                 initialResponseType,\n+                                 updateResponseType,\n+                                 backpressure,\n+                                 Queues.SMALL_BUFFER_SIZE);\n+    }\n+\n+    /**\n+     * Sends the given {@code query} over the {@link QueryBus} and returns result containing initial response and\n+     * incremental updates (received at the moment the query is sent, until it is cancelled by the caller or closed by\n+     * the emitting side).\n+     * <p><b>Do note that the {@code query} will not be dispatched until there is a subscription to the resulting {@link\n+     * Mono}</b></p>\n+     * <p>\n+     * <b>Note</b>: Any {@code null} results, on the initial result or the updates, will be filtered out by the\n+     * {@link ReactorQueryGateway}. If you require the {@code null} to be returned for the initial and update results,\n+     * we suggest using the {@code QueryBus} instead.\n+     *\n+     * @param queryName           A {@link String} describing query to be executed\n+     * @param query               The {@code query} to be sent\n+     * @param initialResponseType The initial response type used for this query\n+     * @param updateResponseType  The update response type used for this query\n+     * @param backpressure        The backpressure mechanism to deal with producing of incremental updates\n+     * @param updateBufferSize    The size of buffer which accumulates updates before subscription to the {@code flux}\n+     *                            is made\n+     * @param <Q>                 The type of the query\n+     * @param <I>                 The type of the initial response\n+     * @param <U>                 The type of the incremental update\n+     * @return registration which can be used to cancel receiving updates\n+     *\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage)\n+     * @see QueryBus#subscriptionQuery(SubscriptionQueryMessage, SubscriptionQueryBackpressure, int)\n+     */\n+    <Q, I, U> Mono<SubscriptionQueryResult<I, U>> subscriptionQuery(String queryName, Q query,\n+                                                                    ResponseType<I> initialResponseType,\n+                                                                    ResponseType<U> updateResponseType,\n+                                                                    SubscriptionQueryBackpressure backpressure,\n+                                                                    int updateBufferSize);\n+\n+    /**\n+     * Uses given Publisher of queries to send incoming queries away. Queries will be sent sequentially - once a result\n+     * of Nth query arrives, (N + 1)th query is dispatched.\n+     *\n+     * @param queries a Publisher stream of queries to be dispatched\n+     * @return a Flux of query results. An ordering of query results corresponds to an ordering of queries being\n+     * dispatched\n+     *\n+     * @see #subscriptionQuery(String, Object, Class, Class)\n+     * @see Flux#concatMap(Function)\n+     */\n+    default Flux<SubscriptionQueryResult<?, ?>> subscriptionQuery( // NOSONAR\n+                                                                   Publisher<SubscriptionQueryMessage<?, ?, ?>> queries) {\n+        return subscriptionQuery(queries, SubscriptionQueryBackpressure.defaultBackpressure());\n+    }\n+\n+    /**\n+     * Uses given Publisher of queries to send incoming queries away. Queries will be sent sequentially - once a result\n+     * of Nth query arrives, (N + 1)th query is dispatched. All queries will be dispatched using given {@code\n+     * backpressure}.\n+     *\n+     * @param queries      a Publisher stream of queries to be dispatched\n+     * @param backpressure The backpressure mechanism to deal with producing of incremental updates\n+     * @return a Flux of query results. An ordering of query results corresponds to an ordering of queries being\n+     * dispatched\n+     *\n+     * @see #subscriptionQuery(String, Object, Class, Class)\n+     * @see Flux#concatMap(Function)\n+     */\n+    default Flux<SubscriptionQueryResult<?, ?>> subscriptionQuery( // NOSONAR\n+                                                                   Publisher<SubscriptionQueryMessage<?, ?, ?>> queries,\n+                                                                   SubscriptionQueryBackpressure backpressure) {\n+        return subscriptionQuery(queries, backpressure, Queues.SMALL_BUFFER_SIZE);\n+    }\n+\n+    /**\n+     * Uses given Publisher of queries to send incoming queries away. Queries will be sent sequentially - once a result\n+     * of Nth query arrives, (N + 1)th query is dispatched. All queries will be dispatched using given {@code\n+     * backpressure} and {@code updateBufferSize}.\n+     *\n+     * @param queries          a Publisher stream of queries to be dispatched\n+     * @param backpressure     The backpressure mechanism to deal with producing of incremental updates\n+     * @param updateBufferSize The size of buffer which accumulates updates before subscription to the {@code flux}\n+     *                         is made\n+     * @return a Flux of query results. An ordering of query results corresponds to an ordering of queries being\n+     * dispatched", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "98865ab1427e4d879301c1bf542842eccc8aa3c3"}, "originalPosition": 530}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgyMzE5MDg3OnYy", "diffSide": "RIGHT", "path": "messaging/src/test/java/org/axonframework/commandhandling/gateway/CommandBusStub.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xMFQxMToyNjozOVrOGvz2XQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMVQxMzoxNTowMVrOG03Wzg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mjc4NTc1Nw==", "bodyText": "Might be more reasonable to reuse the org.axonframework.test.utils.RecordingCommandBus instead of building a new.", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r452785757", "createdAt": "2020-07-10T11:26:39Z", "author": {"login": "smcvb"}, "path": "messaging/src/test/java/org/axonframework/commandhandling/gateway/CommandBusStub.java", "diffHunk": "@@ -0,0 +1,70 @@\n+package org.axonframework.commandhandling.gateway;\n+\n+import org.axonframework.commandhandling.CommandBus;\n+import org.axonframework.commandhandling.CommandCallback;\n+import org.axonframework.commandhandling.CommandMessage;\n+import org.axonframework.commandhandling.CommandResultMessage;\n+import org.axonframework.commandhandling.GenericCommandResultMessage;\n+import org.axonframework.common.Registration;\n+import org.axonframework.messaging.MessageDispatchInterceptor;\n+import org.axonframework.messaging.MessageHandler;\n+import org.axonframework.messaging.MessageHandlerInterceptor;\n+\n+import java.util.LinkedList;\n+\n+/**\n+ * A stub of {@link CommandBus} that captures sent commands.\n+ *\n+ * @author Sara Pellegrini\n+ * @since 4.4\n+ */\n+public class CommandBusStub implements CommandBus {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "98865ab1427e4d879301c1bf542842eccc8aa3c3"}, "originalPosition": 21}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzQ2OTA1NQ==", "bodyText": "we should build axon-messaging with test-jar goal. Is this smth we want to do?", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r457469055", "createdAt": "2020-07-20T15:01:24Z", "author": {"login": "m1l4n54v1c"}, "path": "messaging/src/test/java/org/axonframework/commandhandling/gateway/CommandBusStub.java", "diffHunk": "@@ -0,0 +1,70 @@\n+package org.axonframework.commandhandling.gateway;\n+\n+import org.axonframework.commandhandling.CommandBus;\n+import org.axonframework.commandhandling.CommandCallback;\n+import org.axonframework.commandhandling.CommandMessage;\n+import org.axonframework.commandhandling.CommandResultMessage;\n+import org.axonframework.commandhandling.GenericCommandResultMessage;\n+import org.axonframework.common.Registration;\n+import org.axonframework.messaging.MessageDispatchInterceptor;\n+import org.axonframework.messaging.MessageHandler;\n+import org.axonframework.messaging.MessageHandlerInterceptor;\n+\n+import java.util.LinkedList;\n+\n+/**\n+ * A stub of {@link CommandBus} that captures sent commands.\n+ *\n+ * @author Sara Pellegrini\n+ * @since 4.4\n+ */\n+public class CommandBusStub implements CommandBus {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mjc4NTc1Nw=="}, "originalCommit": {"oid": "98865ab1427e4d879301c1bf542842eccc8aa3c3"}, "originalPosition": 21}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODA4NDY4NQ==", "bodyText": "Hmmm good point...Let's put this in the incubator to look into at a latter stage.", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r458084685", "createdAt": "2020-07-21T13:12:55Z", "author": {"login": "smcvb"}, "path": "messaging/src/test/java/org/axonframework/commandhandling/gateway/CommandBusStub.java", "diffHunk": "@@ -0,0 +1,70 @@\n+package org.axonframework.commandhandling.gateway;\n+\n+import org.axonframework.commandhandling.CommandBus;\n+import org.axonframework.commandhandling.CommandCallback;\n+import org.axonframework.commandhandling.CommandMessage;\n+import org.axonframework.commandhandling.CommandResultMessage;\n+import org.axonframework.commandhandling.GenericCommandResultMessage;\n+import org.axonframework.common.Registration;\n+import org.axonframework.messaging.MessageDispatchInterceptor;\n+import org.axonframework.messaging.MessageHandler;\n+import org.axonframework.messaging.MessageHandlerInterceptor;\n+\n+import java.util.LinkedList;\n+\n+/**\n+ * A stub of {@link CommandBus} that captures sent commands.\n+ *\n+ * @author Sara Pellegrini\n+ * @since 4.4\n+ */\n+public class CommandBusStub implements CommandBus {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mjc4NTc1Nw=="}, "originalCommit": {"oid": "98865ab1427e4d879301c1bf542842eccc8aa3c3"}, "originalPosition": 21}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODA4NjA5NA==", "bodyText": "Added it there, so I'll resolve this thread.", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r458086094", "createdAt": "2020-07-21T13:15:01Z", "author": {"login": "smcvb"}, "path": "messaging/src/test/java/org/axonframework/commandhandling/gateway/CommandBusStub.java", "diffHunk": "@@ -0,0 +1,70 @@\n+package org.axonframework.commandhandling.gateway;\n+\n+import org.axonframework.commandhandling.CommandBus;\n+import org.axonframework.commandhandling.CommandCallback;\n+import org.axonframework.commandhandling.CommandMessage;\n+import org.axonframework.commandhandling.CommandResultMessage;\n+import org.axonframework.commandhandling.GenericCommandResultMessage;\n+import org.axonframework.common.Registration;\n+import org.axonframework.messaging.MessageDispatchInterceptor;\n+import org.axonframework.messaging.MessageHandler;\n+import org.axonframework.messaging.MessageHandlerInterceptor;\n+\n+import java.util.LinkedList;\n+\n+/**\n+ * A stub of {@link CommandBus} that captures sent commands.\n+ *\n+ * @author Sara Pellegrini\n+ * @since 4.4\n+ */\n+public class CommandBusStub implements CommandBus {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mjc4NTc1Nw=="}, "originalCommit": {"oid": "98865ab1427e4d879301c1bf542842eccc8aa3c3"}, "originalPosition": 21}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgyMzIxMjk5OnYy", "diffSide": "RIGHT", "path": "messaging/src/main/java/org/axonframework/commandhandling/gateway/DefaultReactorCommandGateway.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xMFQxMTozNDozNFrOGv0DGA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xMFQxMTozNDozNFrOGv0DGA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mjc4OTAxNg==", "bodyText": "\"reactiveness\", nice \ud83d\ude0e", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r452789016", "createdAt": "2020-07-10T11:34:34Z", "author": {"login": "smcvb"}, "path": "messaging/src/main/java/org/axonframework/commandhandling/gateway/DefaultReactorCommandGateway.java", "diffHunk": "@@ -0,0 +1,253 @@\n+/*\n+ * Copyright (c) 2010-2020. Axon Framework\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.axonframework.commandhandling.gateway;\n+\n+import org.axonframework.commandhandling.*;\n+import org.axonframework.commandhandling.callbacks.ReactiveCallback;\n+import org.axonframework.common.AxonConfigurationException;\n+import org.axonframework.common.Registration;\n+import org.axonframework.messaging.ResultMessage;\n+import org.axonframework.messaging.reactive.ReactorMessageDispatchInterceptor;\n+import org.axonframework.messaging.reactive.ReactorResultHandlerInterceptor;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Mono;\n+import reactor.util.function.Tuple2;\n+\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.concurrent.CopyOnWriteArrayList;\n+\n+import static java.util.Arrays.asList;\n+import static org.axonframework.common.BuilderUtils.assertNonNull;\n+\n+/**\n+ * Implementation of the {@link ReactorCommandGateway} that uses Project Reactor to achieve reactiveness.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "98865ab1427e4d879301c1bf542842eccc8aa3c3"}, "originalPosition": 38}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgyMzIyNDI0OnYy", "diffSide": "RIGHT", "path": "messaging/src/main/java/org/axonframework/commandhandling/gateway/DefaultReactorCommandGateway.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xMFQxMTozOToxNVrOGv0J9g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOFQwNzozNjoyOVrOG4AUuQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mjc5MDc3NA==", "bodyText": "Curious: do we need to do Flux.from(reactiveCallback) because the the ReactiveCallback is an implementation of Publisher? Looks somewhat funky to do Mono.just(Flux.from(...)), so assuming you cannot make a Mono from a Publisher directly?", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r452790774", "createdAt": "2020-07-10T11:39:15Z", "author": {"login": "smcvb"}, "path": "messaging/src/main/java/org/axonframework/commandhandling/gateway/DefaultReactorCommandGateway.java", "diffHunk": "@@ -0,0 +1,253 @@\n+/*\n+ * Copyright (c) 2010-2020. Axon Framework\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.axonframework.commandhandling.gateway;\n+\n+import org.axonframework.commandhandling.*;\n+import org.axonframework.commandhandling.callbacks.ReactiveCallback;\n+import org.axonframework.common.AxonConfigurationException;\n+import org.axonframework.common.Registration;\n+import org.axonframework.messaging.ResultMessage;\n+import org.axonframework.messaging.reactive.ReactorMessageDispatchInterceptor;\n+import org.axonframework.messaging.reactive.ReactorResultHandlerInterceptor;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Mono;\n+import reactor.util.function.Tuple2;\n+\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.concurrent.CopyOnWriteArrayList;\n+\n+import static java.util.Arrays.asList;\n+import static org.axonframework.common.BuilderUtils.assertNonNull;\n+\n+/**\n+ * Implementation of the {@link ReactorCommandGateway} that uses Project Reactor to achieve reactiveness.\n+ *\n+ * @author Milan Savic\n+ * @since 4.4\n+ */\n+public class DefaultReactorCommandGateway implements ReactorCommandGateway {\n+\n+    private final CommandBus commandBus;\n+    private final RetryScheduler retryScheduler;\n+    private final List<ReactorMessageDispatchInterceptor<CommandMessage<?>>> dispatchInterceptors;\n+    private final List<ReactorResultHandlerInterceptor<CommandMessage<?>, CommandResultMessage<?>>> resultInterceptors;\n+\n+    /**\n+     * Creates an instance of {@link DefaultReactorCommandGateway} based on the fields contained in the {@link\n+     * Builder}.\n+     * <p>\n+     * Will assert that the {@link CommandBus} is not {@code null} and throws an {@link AxonConfigurationException} if\n+     * it is.\n+     * </p>\n+     *\n+     * @param builder the {@link Builder} used to instantiate a {@link DefaultReactorCommandGateway} instance\n+     */\n+    protected DefaultReactorCommandGateway(Builder builder) {\n+        builder.validate();\n+        this.commandBus = builder.commandBus;\n+        this.retryScheduler = builder.retryScheduler;\n+        this.dispatchInterceptors = builder.dispatchInterceptors;\n+        this.resultInterceptors = builder.resultInterceptors;\n+    }\n+\n+    /**\n+     * Instantiate a Builder to be able to create a {@link DefaultReactorCommandGateway}.\n+     * <p>\n+     * The {@code dispatchInterceptors} are defaulted to an empty list.\n+     * The {@code resultHandlerInterceptors} are defaulted to an empty list.\n+     * The {@link CommandBus} is a <b>hard requirement</b> and as such should be provided.\n+     * </p>\n+     *\n+     * @return a Builder to be able to create a {@link DefaultReactorCommandGateway}\n+     */\n+    public static Builder builder() {\n+        return new Builder();\n+    }\n+\n+    @Override\n+    public <R> Mono<R> send(Object command) {\n+        //noinspection unchecked\n+        return Mono.<CommandMessage<?>>just(GenericCommandMessage.asCommandMessage(command))\n+                .transform(this::processCommandInterceptors)\n+                .flatMap(this::dispatchCommand)\n+                .flatMap(this::processResultsInterceptors)\n+                .transform(this::getPayload);\n+    }\n+\n+    @Override\n+    public Registration registerDispatchInterceptor(ReactorMessageDispatchInterceptor<CommandMessage<?>> interceptor) {\n+        dispatchInterceptors.add(interceptor);\n+        return () -> dispatchInterceptors.remove(interceptor);\n+    }\n+\n+    @Override\n+    public Registration registerResultHandlerInterceptor(\n+            ReactorResultHandlerInterceptor<CommandMessage<?>, CommandResultMessage<?>> interceptor) {\n+        resultInterceptors.add(interceptor);\n+        return () -> resultInterceptors.remove(interceptor);\n+    }\n+\n+    private Mono<CommandMessage<?>> processCommandInterceptors(Mono<CommandMessage<?>> commandMessage) {\n+        return Flux.fromIterable(dispatchInterceptors)\n+                   .reduce(commandMessage, (command, interceptor) -> interceptor.intercept(command))\n+                   .flatMap(Mono::from);\n+    }\n+\n+    private <C, R> Mono<Tuple2<CommandMessage<C>, Flux<CommandResultMessage<? extends R>>>> dispatchCommand(\n+            CommandMessage<C> commandMessage) {\n+        ReactiveCallback<C, R> reactiveCallback = new ReactiveCallback<>();\n+        CommandCallback<C, R> callback = reactiveCallback;\n+        if (retryScheduler != null) {\n+            callback = new RetryingCallback<>(callback, retryScheduler, commandBus);\n+        }\n+        commandBus.dispatch(commandMessage, callback);\n+        return Mono.just(commandMessage).zipWith(Mono.just(Flux.from(reactiveCallback)));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "98865ab1427e4d879301c1bf542842eccc8aa3c3"}, "originalPosition": 119}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzU4Mzg1MQ==", "bodyText": "Unfortunately, it's not because of making Mono from Publisher, the common result interceptor signature makes this code complex.\nIf ReactiveCallback would extend Mono instead of Published we would still need to convert Mono to Flux because of result interceptor signature (intercepts flux of results).\nAnyway will try to think if there is a way to improve interceptor signature to make this code more readable and less complex", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r453583851", "createdAt": "2020-07-13T11:29:55Z", "author": {"login": "schananas"}, "path": "messaging/src/main/java/org/axonframework/commandhandling/gateway/DefaultReactorCommandGateway.java", "diffHunk": "@@ -0,0 +1,253 @@\n+/*\n+ * Copyright (c) 2010-2020. Axon Framework\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.axonframework.commandhandling.gateway;\n+\n+import org.axonframework.commandhandling.*;\n+import org.axonframework.commandhandling.callbacks.ReactiveCallback;\n+import org.axonframework.common.AxonConfigurationException;\n+import org.axonframework.common.Registration;\n+import org.axonframework.messaging.ResultMessage;\n+import org.axonframework.messaging.reactive.ReactorMessageDispatchInterceptor;\n+import org.axonframework.messaging.reactive.ReactorResultHandlerInterceptor;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Mono;\n+import reactor.util.function.Tuple2;\n+\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.concurrent.CopyOnWriteArrayList;\n+\n+import static java.util.Arrays.asList;\n+import static org.axonframework.common.BuilderUtils.assertNonNull;\n+\n+/**\n+ * Implementation of the {@link ReactorCommandGateway} that uses Project Reactor to achieve reactiveness.\n+ *\n+ * @author Milan Savic\n+ * @since 4.4\n+ */\n+public class DefaultReactorCommandGateway implements ReactorCommandGateway {\n+\n+    private final CommandBus commandBus;\n+    private final RetryScheduler retryScheduler;\n+    private final List<ReactorMessageDispatchInterceptor<CommandMessage<?>>> dispatchInterceptors;\n+    private final List<ReactorResultHandlerInterceptor<CommandMessage<?>, CommandResultMessage<?>>> resultInterceptors;\n+\n+    /**\n+     * Creates an instance of {@link DefaultReactorCommandGateway} based on the fields contained in the {@link\n+     * Builder}.\n+     * <p>\n+     * Will assert that the {@link CommandBus} is not {@code null} and throws an {@link AxonConfigurationException} if\n+     * it is.\n+     * </p>\n+     *\n+     * @param builder the {@link Builder} used to instantiate a {@link DefaultReactorCommandGateway} instance\n+     */\n+    protected DefaultReactorCommandGateway(Builder builder) {\n+        builder.validate();\n+        this.commandBus = builder.commandBus;\n+        this.retryScheduler = builder.retryScheduler;\n+        this.dispatchInterceptors = builder.dispatchInterceptors;\n+        this.resultInterceptors = builder.resultInterceptors;\n+    }\n+\n+    /**\n+     * Instantiate a Builder to be able to create a {@link DefaultReactorCommandGateway}.\n+     * <p>\n+     * The {@code dispatchInterceptors} are defaulted to an empty list.\n+     * The {@code resultHandlerInterceptors} are defaulted to an empty list.\n+     * The {@link CommandBus} is a <b>hard requirement</b> and as such should be provided.\n+     * </p>\n+     *\n+     * @return a Builder to be able to create a {@link DefaultReactorCommandGateway}\n+     */\n+    public static Builder builder() {\n+        return new Builder();\n+    }\n+\n+    @Override\n+    public <R> Mono<R> send(Object command) {\n+        //noinspection unchecked\n+        return Mono.<CommandMessage<?>>just(GenericCommandMessage.asCommandMessage(command))\n+                .transform(this::processCommandInterceptors)\n+                .flatMap(this::dispatchCommand)\n+                .flatMap(this::processResultsInterceptors)\n+                .transform(this::getPayload);\n+    }\n+\n+    @Override\n+    public Registration registerDispatchInterceptor(ReactorMessageDispatchInterceptor<CommandMessage<?>> interceptor) {\n+        dispatchInterceptors.add(interceptor);\n+        return () -> dispatchInterceptors.remove(interceptor);\n+    }\n+\n+    @Override\n+    public Registration registerResultHandlerInterceptor(\n+            ReactorResultHandlerInterceptor<CommandMessage<?>, CommandResultMessage<?>> interceptor) {\n+        resultInterceptors.add(interceptor);\n+        return () -> resultInterceptors.remove(interceptor);\n+    }\n+\n+    private Mono<CommandMessage<?>> processCommandInterceptors(Mono<CommandMessage<?>> commandMessage) {\n+        return Flux.fromIterable(dispatchInterceptors)\n+                   .reduce(commandMessage, (command, interceptor) -> interceptor.intercept(command))\n+                   .flatMap(Mono::from);\n+    }\n+\n+    private <C, R> Mono<Tuple2<CommandMessage<C>, Flux<CommandResultMessage<? extends R>>>> dispatchCommand(\n+            CommandMessage<C> commandMessage) {\n+        ReactiveCallback<C, R> reactiveCallback = new ReactiveCallback<>();\n+        CommandCallback<C, R> callback = reactiveCallback;\n+        if (retryScheduler != null) {\n+            callback = new RetryingCallback<>(callback, retryScheduler, commandBus);\n+        }\n+        commandBus.dispatch(commandMessage, callback);\n+        return Mono.just(commandMessage).zipWith(Mono.just(Flux.from(reactiveCallback)));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mjc5MDc3NA=="}, "originalCommit": {"oid": "98865ab1427e4d879301c1bf542842eccc8aa3c3"}, "originalPosition": 119}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTM3ODc0NQ==", "bodyText": "Thanks for the explanation here @stefanvozd. Think for now, this is ok; it's good to have a think about this if we can improve this.", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r461378745", "createdAt": "2020-07-28T07:36:29Z", "author": {"login": "smcvb"}, "path": "messaging/src/main/java/org/axonframework/commandhandling/gateway/DefaultReactorCommandGateway.java", "diffHunk": "@@ -0,0 +1,253 @@\n+/*\n+ * Copyright (c) 2010-2020. Axon Framework\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.axonframework.commandhandling.gateway;\n+\n+import org.axonframework.commandhandling.*;\n+import org.axonframework.commandhandling.callbacks.ReactiveCallback;\n+import org.axonframework.common.AxonConfigurationException;\n+import org.axonframework.common.Registration;\n+import org.axonframework.messaging.ResultMessage;\n+import org.axonframework.messaging.reactive.ReactorMessageDispatchInterceptor;\n+import org.axonframework.messaging.reactive.ReactorResultHandlerInterceptor;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Mono;\n+import reactor.util.function.Tuple2;\n+\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.concurrent.CopyOnWriteArrayList;\n+\n+import static java.util.Arrays.asList;\n+import static org.axonframework.common.BuilderUtils.assertNonNull;\n+\n+/**\n+ * Implementation of the {@link ReactorCommandGateway} that uses Project Reactor to achieve reactiveness.\n+ *\n+ * @author Milan Savic\n+ * @since 4.4\n+ */\n+public class DefaultReactorCommandGateway implements ReactorCommandGateway {\n+\n+    private final CommandBus commandBus;\n+    private final RetryScheduler retryScheduler;\n+    private final List<ReactorMessageDispatchInterceptor<CommandMessage<?>>> dispatchInterceptors;\n+    private final List<ReactorResultHandlerInterceptor<CommandMessage<?>, CommandResultMessage<?>>> resultInterceptors;\n+\n+    /**\n+     * Creates an instance of {@link DefaultReactorCommandGateway} based on the fields contained in the {@link\n+     * Builder}.\n+     * <p>\n+     * Will assert that the {@link CommandBus} is not {@code null} and throws an {@link AxonConfigurationException} if\n+     * it is.\n+     * </p>\n+     *\n+     * @param builder the {@link Builder} used to instantiate a {@link DefaultReactorCommandGateway} instance\n+     */\n+    protected DefaultReactorCommandGateway(Builder builder) {\n+        builder.validate();\n+        this.commandBus = builder.commandBus;\n+        this.retryScheduler = builder.retryScheduler;\n+        this.dispatchInterceptors = builder.dispatchInterceptors;\n+        this.resultInterceptors = builder.resultInterceptors;\n+    }\n+\n+    /**\n+     * Instantiate a Builder to be able to create a {@link DefaultReactorCommandGateway}.\n+     * <p>\n+     * The {@code dispatchInterceptors} are defaulted to an empty list.\n+     * The {@code resultHandlerInterceptors} are defaulted to an empty list.\n+     * The {@link CommandBus} is a <b>hard requirement</b> and as such should be provided.\n+     * </p>\n+     *\n+     * @return a Builder to be able to create a {@link DefaultReactorCommandGateway}\n+     */\n+    public static Builder builder() {\n+        return new Builder();\n+    }\n+\n+    @Override\n+    public <R> Mono<R> send(Object command) {\n+        //noinspection unchecked\n+        return Mono.<CommandMessage<?>>just(GenericCommandMessage.asCommandMessage(command))\n+                .transform(this::processCommandInterceptors)\n+                .flatMap(this::dispatchCommand)\n+                .flatMap(this::processResultsInterceptors)\n+                .transform(this::getPayload);\n+    }\n+\n+    @Override\n+    public Registration registerDispatchInterceptor(ReactorMessageDispatchInterceptor<CommandMessage<?>> interceptor) {\n+        dispatchInterceptors.add(interceptor);\n+        return () -> dispatchInterceptors.remove(interceptor);\n+    }\n+\n+    @Override\n+    public Registration registerResultHandlerInterceptor(\n+            ReactorResultHandlerInterceptor<CommandMessage<?>, CommandResultMessage<?>> interceptor) {\n+        resultInterceptors.add(interceptor);\n+        return () -> resultInterceptors.remove(interceptor);\n+    }\n+\n+    private Mono<CommandMessage<?>> processCommandInterceptors(Mono<CommandMessage<?>> commandMessage) {\n+        return Flux.fromIterable(dispatchInterceptors)\n+                   .reduce(commandMessage, (command, interceptor) -> interceptor.intercept(command))\n+                   .flatMap(Mono::from);\n+    }\n+\n+    private <C, R> Mono<Tuple2<CommandMessage<C>, Flux<CommandResultMessage<? extends R>>>> dispatchCommand(\n+            CommandMessage<C> commandMessage) {\n+        ReactiveCallback<C, R> reactiveCallback = new ReactiveCallback<>();\n+        CommandCallback<C, R> callback = reactiveCallback;\n+        if (retryScheduler != null) {\n+            callback = new RetryingCallback<>(callback, retryScheduler, commandBus);\n+        }\n+        commandBus.dispatch(commandMessage, callback);\n+        return Mono.just(commandMessage).zipWith(Mono.just(Flux.from(reactiveCallback)));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mjc5MDc3NA=="}, "originalCommit": {"oid": "98865ab1427e4d879301c1bf542842eccc8aa3c3"}, "originalPosition": 119}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgyMzIzMjA4OnYy", "diffSide": "RIGHT", "path": "messaging/src/main/java/org/axonframework/commandhandling/gateway/DefaultReactorCommandGateway.java", "isResolved": true, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xMFQxMTo0MjowOFrOGv0Onw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOFQwNzozNzoyOVrOG4AW5w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mjc5MTk2Nw==", "bodyText": "What makes null a response type to filter out? Couldn't a null be valid as a command response?", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r452791967", "createdAt": "2020-07-10T11:42:08Z", "author": {"login": "smcvb"}, "path": "messaging/src/main/java/org/axonframework/commandhandling/gateway/DefaultReactorCommandGateway.java", "diffHunk": "@@ -0,0 +1,253 @@\n+/*\n+ * Copyright (c) 2010-2020. Axon Framework\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.axonframework.commandhandling.gateway;\n+\n+import org.axonframework.commandhandling.*;\n+import org.axonframework.commandhandling.callbacks.ReactiveCallback;\n+import org.axonframework.common.AxonConfigurationException;\n+import org.axonframework.common.Registration;\n+import org.axonframework.messaging.ResultMessage;\n+import org.axonframework.messaging.reactive.ReactorMessageDispatchInterceptor;\n+import org.axonframework.messaging.reactive.ReactorResultHandlerInterceptor;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Mono;\n+import reactor.util.function.Tuple2;\n+\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.concurrent.CopyOnWriteArrayList;\n+\n+import static java.util.Arrays.asList;\n+import static org.axonframework.common.BuilderUtils.assertNonNull;\n+\n+/**\n+ * Implementation of the {@link ReactorCommandGateway} that uses Project Reactor to achieve reactiveness.\n+ *\n+ * @author Milan Savic\n+ * @since 4.4\n+ */\n+public class DefaultReactorCommandGateway implements ReactorCommandGateway {\n+\n+    private final CommandBus commandBus;\n+    private final RetryScheduler retryScheduler;\n+    private final List<ReactorMessageDispatchInterceptor<CommandMessage<?>>> dispatchInterceptors;\n+    private final List<ReactorResultHandlerInterceptor<CommandMessage<?>, CommandResultMessage<?>>> resultInterceptors;\n+\n+    /**\n+     * Creates an instance of {@link DefaultReactorCommandGateway} based on the fields contained in the {@link\n+     * Builder}.\n+     * <p>\n+     * Will assert that the {@link CommandBus} is not {@code null} and throws an {@link AxonConfigurationException} if\n+     * it is.\n+     * </p>\n+     *\n+     * @param builder the {@link Builder} used to instantiate a {@link DefaultReactorCommandGateway} instance\n+     */\n+    protected DefaultReactorCommandGateway(Builder builder) {\n+        builder.validate();\n+        this.commandBus = builder.commandBus;\n+        this.retryScheduler = builder.retryScheduler;\n+        this.dispatchInterceptors = builder.dispatchInterceptors;\n+        this.resultInterceptors = builder.resultInterceptors;\n+    }\n+\n+    /**\n+     * Instantiate a Builder to be able to create a {@link DefaultReactorCommandGateway}.\n+     * <p>\n+     * The {@code dispatchInterceptors} are defaulted to an empty list.\n+     * The {@code resultHandlerInterceptors} are defaulted to an empty list.\n+     * The {@link CommandBus} is a <b>hard requirement</b> and as such should be provided.\n+     * </p>\n+     *\n+     * @return a Builder to be able to create a {@link DefaultReactorCommandGateway}\n+     */\n+    public static Builder builder() {\n+        return new Builder();\n+    }\n+\n+    @Override\n+    public <R> Mono<R> send(Object command) {\n+        //noinspection unchecked\n+        return Mono.<CommandMessage<?>>just(GenericCommandMessage.asCommandMessage(command))\n+                .transform(this::processCommandInterceptors)\n+                .flatMap(this::dispatchCommand)\n+                .flatMap(this::processResultsInterceptors)\n+                .transform(this::getPayload);\n+    }\n+\n+    @Override\n+    public Registration registerDispatchInterceptor(ReactorMessageDispatchInterceptor<CommandMessage<?>> interceptor) {\n+        dispatchInterceptors.add(interceptor);\n+        return () -> dispatchInterceptors.remove(interceptor);\n+    }\n+\n+    @Override\n+    public Registration registerResultHandlerInterceptor(\n+            ReactorResultHandlerInterceptor<CommandMessage<?>, CommandResultMessage<?>> interceptor) {\n+        resultInterceptors.add(interceptor);\n+        return () -> resultInterceptors.remove(interceptor);\n+    }\n+\n+    private Mono<CommandMessage<?>> processCommandInterceptors(Mono<CommandMessage<?>> commandMessage) {\n+        return Flux.fromIterable(dispatchInterceptors)\n+                   .reduce(commandMessage, (command, interceptor) -> interceptor.intercept(command))\n+                   .flatMap(Mono::from);\n+    }\n+\n+    private <C, R> Mono<Tuple2<CommandMessage<C>, Flux<CommandResultMessage<? extends R>>>> dispatchCommand(\n+            CommandMessage<C> commandMessage) {\n+        ReactiveCallback<C, R> reactiveCallback = new ReactiveCallback<>();\n+        CommandCallback<C, R> callback = reactiveCallback;\n+        if (retryScheduler != null) {\n+            callback = new RetryingCallback<>(callback, retryScheduler, commandBus);\n+        }\n+        commandBus.dispatch(commandMessage, callback);\n+        return Mono.just(commandMessage).zipWith(Mono.just(Flux.from(reactiveCallback)));\n+    }\n+\n+    private <C> Mono<? extends CommandResultMessage<?>> processResultsInterceptors(\n+            Tuple2<CommandMessage<C>, Flux<CommandResultMessage<?>>> commandWithResults) {\n+        CommandMessage<?> commandMessage = commandWithResults.getT1();\n+        Flux<CommandResultMessage<?>> commandResultMessages = commandWithResults.getT2();\n+        return Flux.fromIterable(resultInterceptors)\n+                   .reduce(commandResultMessages,\n+                           (result, interceptor) -> interceptor.intercept(commandMessage, result))\n+                   .flatMap(Flux::next); // command handlers provide only one result!\n+    }\n+\n+    private <R> Mono<R> getPayload(Mono<? extends CommandResultMessage<?>> commandResultMessage) {\n+        //noinspection unchecked\n+        return commandResultMessage\n+                .filter(r -> Objects.nonNull(r.getPayload()))\n+                .map(it -> (R) it.getPayload());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "98865ab1427e4d879301c1bf542842eccc8aa3c3"}, "originalPosition": 136}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzU3MzYyOA==", "bodyText": "The reactor doesn't support null values in a stream. Null value is equivalent of Mono.empty() in this case. Filter operator archive's that.", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r453573628", "createdAt": "2020-07-13T11:09:23Z", "author": {"login": "schananas"}, "path": "messaging/src/main/java/org/axonframework/commandhandling/gateway/DefaultReactorCommandGateway.java", "diffHunk": "@@ -0,0 +1,253 @@\n+/*\n+ * Copyright (c) 2010-2020. Axon Framework\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.axonframework.commandhandling.gateway;\n+\n+import org.axonframework.commandhandling.*;\n+import org.axonframework.commandhandling.callbacks.ReactiveCallback;\n+import org.axonframework.common.AxonConfigurationException;\n+import org.axonframework.common.Registration;\n+import org.axonframework.messaging.ResultMessage;\n+import org.axonframework.messaging.reactive.ReactorMessageDispatchInterceptor;\n+import org.axonframework.messaging.reactive.ReactorResultHandlerInterceptor;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Mono;\n+import reactor.util.function.Tuple2;\n+\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.concurrent.CopyOnWriteArrayList;\n+\n+import static java.util.Arrays.asList;\n+import static org.axonframework.common.BuilderUtils.assertNonNull;\n+\n+/**\n+ * Implementation of the {@link ReactorCommandGateway} that uses Project Reactor to achieve reactiveness.\n+ *\n+ * @author Milan Savic\n+ * @since 4.4\n+ */\n+public class DefaultReactorCommandGateway implements ReactorCommandGateway {\n+\n+    private final CommandBus commandBus;\n+    private final RetryScheduler retryScheduler;\n+    private final List<ReactorMessageDispatchInterceptor<CommandMessage<?>>> dispatchInterceptors;\n+    private final List<ReactorResultHandlerInterceptor<CommandMessage<?>, CommandResultMessage<?>>> resultInterceptors;\n+\n+    /**\n+     * Creates an instance of {@link DefaultReactorCommandGateway} based on the fields contained in the {@link\n+     * Builder}.\n+     * <p>\n+     * Will assert that the {@link CommandBus} is not {@code null} and throws an {@link AxonConfigurationException} if\n+     * it is.\n+     * </p>\n+     *\n+     * @param builder the {@link Builder} used to instantiate a {@link DefaultReactorCommandGateway} instance\n+     */\n+    protected DefaultReactorCommandGateway(Builder builder) {\n+        builder.validate();\n+        this.commandBus = builder.commandBus;\n+        this.retryScheduler = builder.retryScheduler;\n+        this.dispatchInterceptors = builder.dispatchInterceptors;\n+        this.resultInterceptors = builder.resultInterceptors;\n+    }\n+\n+    /**\n+     * Instantiate a Builder to be able to create a {@link DefaultReactorCommandGateway}.\n+     * <p>\n+     * The {@code dispatchInterceptors} are defaulted to an empty list.\n+     * The {@code resultHandlerInterceptors} are defaulted to an empty list.\n+     * The {@link CommandBus} is a <b>hard requirement</b> and as such should be provided.\n+     * </p>\n+     *\n+     * @return a Builder to be able to create a {@link DefaultReactorCommandGateway}\n+     */\n+    public static Builder builder() {\n+        return new Builder();\n+    }\n+\n+    @Override\n+    public <R> Mono<R> send(Object command) {\n+        //noinspection unchecked\n+        return Mono.<CommandMessage<?>>just(GenericCommandMessage.asCommandMessage(command))\n+                .transform(this::processCommandInterceptors)\n+                .flatMap(this::dispatchCommand)\n+                .flatMap(this::processResultsInterceptors)\n+                .transform(this::getPayload);\n+    }\n+\n+    @Override\n+    public Registration registerDispatchInterceptor(ReactorMessageDispatchInterceptor<CommandMessage<?>> interceptor) {\n+        dispatchInterceptors.add(interceptor);\n+        return () -> dispatchInterceptors.remove(interceptor);\n+    }\n+\n+    @Override\n+    public Registration registerResultHandlerInterceptor(\n+            ReactorResultHandlerInterceptor<CommandMessage<?>, CommandResultMessage<?>> interceptor) {\n+        resultInterceptors.add(interceptor);\n+        return () -> resultInterceptors.remove(interceptor);\n+    }\n+\n+    private Mono<CommandMessage<?>> processCommandInterceptors(Mono<CommandMessage<?>> commandMessage) {\n+        return Flux.fromIterable(dispatchInterceptors)\n+                   .reduce(commandMessage, (command, interceptor) -> interceptor.intercept(command))\n+                   .flatMap(Mono::from);\n+    }\n+\n+    private <C, R> Mono<Tuple2<CommandMessage<C>, Flux<CommandResultMessage<? extends R>>>> dispatchCommand(\n+            CommandMessage<C> commandMessage) {\n+        ReactiveCallback<C, R> reactiveCallback = new ReactiveCallback<>();\n+        CommandCallback<C, R> callback = reactiveCallback;\n+        if (retryScheduler != null) {\n+            callback = new RetryingCallback<>(callback, retryScheduler, commandBus);\n+        }\n+        commandBus.dispatch(commandMessage, callback);\n+        return Mono.just(commandMessage).zipWith(Mono.just(Flux.from(reactiveCallback)));\n+    }\n+\n+    private <C> Mono<? extends CommandResultMessage<?>> processResultsInterceptors(\n+            Tuple2<CommandMessage<C>, Flux<CommandResultMessage<?>>> commandWithResults) {\n+        CommandMessage<?> commandMessage = commandWithResults.getT1();\n+        Flux<CommandResultMessage<?>> commandResultMessages = commandWithResults.getT2();\n+        return Flux.fromIterable(resultInterceptors)\n+                   .reduce(commandResultMessages,\n+                           (result, interceptor) -> interceptor.intercept(commandMessage, result))\n+                   .flatMap(Flux::next); // command handlers provide only one result!\n+    }\n+\n+    private <R> Mono<R> getPayload(Mono<? extends CommandResultMessage<?>> commandResultMessage) {\n+        //noinspection unchecked\n+        return commandResultMessage\n+                .filter(r -> Objects.nonNull(r.getPayload()))\n+                .map(it -> (R) it.getPayload());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mjc5MTk2Nw=="}, "originalCommit": {"oid": "98865ab1427e4d879301c1bf542842eccc8aa3c3"}, "originalPosition": 136}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODEwODkwMQ==", "bodyText": "What does it mean to be archived? Does that mean that users can still see there were null responses?\nI'd argue that null is a valid response for some queries, hence why I am asking for it.\nYou could however further argue that if users are interested in this, that they can use the OptionalResponseType to better tie into that.\nAnyhow, what I am angling for, is there a way to get such a result to users at all?", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r458108901", "createdAt": "2020-07-21T13:46:35Z", "author": {"login": "smcvb"}, "path": "messaging/src/main/java/org/axonframework/commandhandling/gateway/DefaultReactorCommandGateway.java", "diffHunk": "@@ -0,0 +1,253 @@\n+/*\n+ * Copyright (c) 2010-2020. Axon Framework\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.axonframework.commandhandling.gateway;\n+\n+import org.axonframework.commandhandling.*;\n+import org.axonframework.commandhandling.callbacks.ReactiveCallback;\n+import org.axonframework.common.AxonConfigurationException;\n+import org.axonframework.common.Registration;\n+import org.axonframework.messaging.ResultMessage;\n+import org.axonframework.messaging.reactive.ReactorMessageDispatchInterceptor;\n+import org.axonframework.messaging.reactive.ReactorResultHandlerInterceptor;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Mono;\n+import reactor.util.function.Tuple2;\n+\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.concurrent.CopyOnWriteArrayList;\n+\n+import static java.util.Arrays.asList;\n+import static org.axonframework.common.BuilderUtils.assertNonNull;\n+\n+/**\n+ * Implementation of the {@link ReactorCommandGateway} that uses Project Reactor to achieve reactiveness.\n+ *\n+ * @author Milan Savic\n+ * @since 4.4\n+ */\n+public class DefaultReactorCommandGateway implements ReactorCommandGateway {\n+\n+    private final CommandBus commandBus;\n+    private final RetryScheduler retryScheduler;\n+    private final List<ReactorMessageDispatchInterceptor<CommandMessage<?>>> dispatchInterceptors;\n+    private final List<ReactorResultHandlerInterceptor<CommandMessage<?>, CommandResultMessage<?>>> resultInterceptors;\n+\n+    /**\n+     * Creates an instance of {@link DefaultReactorCommandGateway} based on the fields contained in the {@link\n+     * Builder}.\n+     * <p>\n+     * Will assert that the {@link CommandBus} is not {@code null} and throws an {@link AxonConfigurationException} if\n+     * it is.\n+     * </p>\n+     *\n+     * @param builder the {@link Builder} used to instantiate a {@link DefaultReactorCommandGateway} instance\n+     */\n+    protected DefaultReactorCommandGateway(Builder builder) {\n+        builder.validate();\n+        this.commandBus = builder.commandBus;\n+        this.retryScheduler = builder.retryScheduler;\n+        this.dispatchInterceptors = builder.dispatchInterceptors;\n+        this.resultInterceptors = builder.resultInterceptors;\n+    }\n+\n+    /**\n+     * Instantiate a Builder to be able to create a {@link DefaultReactorCommandGateway}.\n+     * <p>\n+     * The {@code dispatchInterceptors} are defaulted to an empty list.\n+     * The {@code resultHandlerInterceptors} are defaulted to an empty list.\n+     * The {@link CommandBus} is a <b>hard requirement</b> and as such should be provided.\n+     * </p>\n+     *\n+     * @return a Builder to be able to create a {@link DefaultReactorCommandGateway}\n+     */\n+    public static Builder builder() {\n+        return new Builder();\n+    }\n+\n+    @Override\n+    public <R> Mono<R> send(Object command) {\n+        //noinspection unchecked\n+        return Mono.<CommandMessage<?>>just(GenericCommandMessage.asCommandMessage(command))\n+                .transform(this::processCommandInterceptors)\n+                .flatMap(this::dispatchCommand)\n+                .flatMap(this::processResultsInterceptors)\n+                .transform(this::getPayload);\n+    }\n+\n+    @Override\n+    public Registration registerDispatchInterceptor(ReactorMessageDispatchInterceptor<CommandMessage<?>> interceptor) {\n+        dispatchInterceptors.add(interceptor);\n+        return () -> dispatchInterceptors.remove(interceptor);\n+    }\n+\n+    @Override\n+    public Registration registerResultHandlerInterceptor(\n+            ReactorResultHandlerInterceptor<CommandMessage<?>, CommandResultMessage<?>> interceptor) {\n+        resultInterceptors.add(interceptor);\n+        return () -> resultInterceptors.remove(interceptor);\n+    }\n+\n+    private Mono<CommandMessage<?>> processCommandInterceptors(Mono<CommandMessage<?>> commandMessage) {\n+        return Flux.fromIterable(dispatchInterceptors)\n+                   .reduce(commandMessage, (command, interceptor) -> interceptor.intercept(command))\n+                   .flatMap(Mono::from);\n+    }\n+\n+    private <C, R> Mono<Tuple2<CommandMessage<C>, Flux<CommandResultMessage<? extends R>>>> dispatchCommand(\n+            CommandMessage<C> commandMessage) {\n+        ReactiveCallback<C, R> reactiveCallback = new ReactiveCallback<>();\n+        CommandCallback<C, R> callback = reactiveCallback;\n+        if (retryScheduler != null) {\n+            callback = new RetryingCallback<>(callback, retryScheduler, commandBus);\n+        }\n+        commandBus.dispatch(commandMessage, callback);\n+        return Mono.just(commandMessage).zipWith(Mono.just(Flux.from(reactiveCallback)));\n+    }\n+\n+    private <C> Mono<? extends CommandResultMessage<?>> processResultsInterceptors(\n+            Tuple2<CommandMessage<C>, Flux<CommandResultMessage<?>>> commandWithResults) {\n+        CommandMessage<?> commandMessage = commandWithResults.getT1();\n+        Flux<CommandResultMessage<?>> commandResultMessages = commandWithResults.getT2();\n+        return Flux.fromIterable(resultInterceptors)\n+                   .reduce(commandResultMessages,\n+                           (result, interceptor) -> interceptor.intercept(commandMessage, result))\n+                   .flatMap(Flux::next); // command handlers provide only one result!\n+    }\n+\n+    private <R> Mono<R> getPayload(Mono<? extends CommandResultMessage<?>> commandResultMessage) {\n+        //noinspection unchecked\n+        return commandResultMessage\n+                .filter(r -> Objects.nonNull(r.getPayload()))\n+                .map(it -> (R) it.getPayload());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mjc5MTk2Nw=="}, "originalCommit": {"oid": "98865ab1427e4d879301c1bf542842eccc8aa3c3"}, "originalPosition": 136}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDc0MTYyMg==", "bodyText": "sorry not achieve, its achieve. so if query returns null it will be mapped to Mono.empty, and user can react on that as it can on null value, but in a reactive, functional way. Instead of using optional or writing if statements, different operators like .switchIfEmpty could be used to handle null return values. Additionally, as you mentioned user can introduce OptionalResponseType, but I see that as an anti-pattern, since Mono offers the same functionality.\nBottom line:   Optional.empty = Mono.empty,  for reactive streams mono.empty should be used instead of optional", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r460741622", "createdAt": "2020-07-27T08:51:37Z", "author": {"login": "schananas"}, "path": "messaging/src/main/java/org/axonframework/commandhandling/gateway/DefaultReactorCommandGateway.java", "diffHunk": "@@ -0,0 +1,253 @@\n+/*\n+ * Copyright (c) 2010-2020. Axon Framework\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.axonframework.commandhandling.gateway;\n+\n+import org.axonframework.commandhandling.*;\n+import org.axonframework.commandhandling.callbacks.ReactiveCallback;\n+import org.axonframework.common.AxonConfigurationException;\n+import org.axonframework.common.Registration;\n+import org.axonframework.messaging.ResultMessage;\n+import org.axonframework.messaging.reactive.ReactorMessageDispatchInterceptor;\n+import org.axonframework.messaging.reactive.ReactorResultHandlerInterceptor;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Mono;\n+import reactor.util.function.Tuple2;\n+\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.concurrent.CopyOnWriteArrayList;\n+\n+import static java.util.Arrays.asList;\n+import static org.axonframework.common.BuilderUtils.assertNonNull;\n+\n+/**\n+ * Implementation of the {@link ReactorCommandGateway} that uses Project Reactor to achieve reactiveness.\n+ *\n+ * @author Milan Savic\n+ * @since 4.4\n+ */\n+public class DefaultReactorCommandGateway implements ReactorCommandGateway {\n+\n+    private final CommandBus commandBus;\n+    private final RetryScheduler retryScheduler;\n+    private final List<ReactorMessageDispatchInterceptor<CommandMessage<?>>> dispatchInterceptors;\n+    private final List<ReactorResultHandlerInterceptor<CommandMessage<?>, CommandResultMessage<?>>> resultInterceptors;\n+\n+    /**\n+     * Creates an instance of {@link DefaultReactorCommandGateway} based on the fields contained in the {@link\n+     * Builder}.\n+     * <p>\n+     * Will assert that the {@link CommandBus} is not {@code null} and throws an {@link AxonConfigurationException} if\n+     * it is.\n+     * </p>\n+     *\n+     * @param builder the {@link Builder} used to instantiate a {@link DefaultReactorCommandGateway} instance\n+     */\n+    protected DefaultReactorCommandGateway(Builder builder) {\n+        builder.validate();\n+        this.commandBus = builder.commandBus;\n+        this.retryScheduler = builder.retryScheduler;\n+        this.dispatchInterceptors = builder.dispatchInterceptors;\n+        this.resultInterceptors = builder.resultInterceptors;\n+    }\n+\n+    /**\n+     * Instantiate a Builder to be able to create a {@link DefaultReactorCommandGateway}.\n+     * <p>\n+     * The {@code dispatchInterceptors} are defaulted to an empty list.\n+     * The {@code resultHandlerInterceptors} are defaulted to an empty list.\n+     * The {@link CommandBus} is a <b>hard requirement</b> and as such should be provided.\n+     * </p>\n+     *\n+     * @return a Builder to be able to create a {@link DefaultReactorCommandGateway}\n+     */\n+    public static Builder builder() {\n+        return new Builder();\n+    }\n+\n+    @Override\n+    public <R> Mono<R> send(Object command) {\n+        //noinspection unchecked\n+        return Mono.<CommandMessage<?>>just(GenericCommandMessage.asCommandMessage(command))\n+                .transform(this::processCommandInterceptors)\n+                .flatMap(this::dispatchCommand)\n+                .flatMap(this::processResultsInterceptors)\n+                .transform(this::getPayload);\n+    }\n+\n+    @Override\n+    public Registration registerDispatchInterceptor(ReactorMessageDispatchInterceptor<CommandMessage<?>> interceptor) {\n+        dispatchInterceptors.add(interceptor);\n+        return () -> dispatchInterceptors.remove(interceptor);\n+    }\n+\n+    @Override\n+    public Registration registerResultHandlerInterceptor(\n+            ReactorResultHandlerInterceptor<CommandMessage<?>, CommandResultMessage<?>> interceptor) {\n+        resultInterceptors.add(interceptor);\n+        return () -> resultInterceptors.remove(interceptor);\n+    }\n+\n+    private Mono<CommandMessage<?>> processCommandInterceptors(Mono<CommandMessage<?>> commandMessage) {\n+        return Flux.fromIterable(dispatchInterceptors)\n+                   .reduce(commandMessage, (command, interceptor) -> interceptor.intercept(command))\n+                   .flatMap(Mono::from);\n+    }\n+\n+    private <C, R> Mono<Tuple2<CommandMessage<C>, Flux<CommandResultMessage<? extends R>>>> dispatchCommand(\n+            CommandMessage<C> commandMessage) {\n+        ReactiveCallback<C, R> reactiveCallback = new ReactiveCallback<>();\n+        CommandCallback<C, R> callback = reactiveCallback;\n+        if (retryScheduler != null) {\n+            callback = new RetryingCallback<>(callback, retryScheduler, commandBus);\n+        }\n+        commandBus.dispatch(commandMessage, callback);\n+        return Mono.just(commandMessage).zipWith(Mono.just(Flux.from(reactiveCallback)));\n+    }\n+\n+    private <C> Mono<? extends CommandResultMessage<?>> processResultsInterceptors(\n+            Tuple2<CommandMessage<C>, Flux<CommandResultMessage<?>>> commandWithResults) {\n+        CommandMessage<?> commandMessage = commandWithResults.getT1();\n+        Flux<CommandResultMessage<?>> commandResultMessages = commandWithResults.getT2();\n+        return Flux.fromIterable(resultInterceptors)\n+                   .reduce(commandResultMessages,\n+                           (result, interceptor) -> interceptor.intercept(commandMessage, result))\n+                   .flatMap(Flux::next); // command handlers provide only one result!\n+    }\n+\n+    private <R> Mono<R> getPayload(Mono<? extends CommandResultMessage<?>> commandResultMessage) {\n+        //noinspection unchecked\n+        return commandResultMessage\n+                .filter(r -> Objects.nonNull(r.getPayload()))\n+                .map(it -> (R) it.getPayload());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mjc5MTk2Nw=="}, "originalCommit": {"oid": "98865ab1427e4d879301c1bf542842eccc8aa3c3"}, "originalPosition": 136}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTM3OTMwMw==", "bodyText": "Gotcha, thanks for explaining this further @stefanvozd!", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r461379303", "createdAt": "2020-07-28T07:37:29Z", "author": {"login": "smcvb"}, "path": "messaging/src/main/java/org/axonframework/commandhandling/gateway/DefaultReactorCommandGateway.java", "diffHunk": "@@ -0,0 +1,253 @@\n+/*\n+ * Copyright (c) 2010-2020. Axon Framework\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.axonframework.commandhandling.gateway;\n+\n+import org.axonframework.commandhandling.*;\n+import org.axonframework.commandhandling.callbacks.ReactiveCallback;\n+import org.axonframework.common.AxonConfigurationException;\n+import org.axonframework.common.Registration;\n+import org.axonframework.messaging.ResultMessage;\n+import org.axonframework.messaging.reactive.ReactorMessageDispatchInterceptor;\n+import org.axonframework.messaging.reactive.ReactorResultHandlerInterceptor;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Mono;\n+import reactor.util.function.Tuple2;\n+\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.concurrent.CopyOnWriteArrayList;\n+\n+import static java.util.Arrays.asList;\n+import static org.axonframework.common.BuilderUtils.assertNonNull;\n+\n+/**\n+ * Implementation of the {@link ReactorCommandGateway} that uses Project Reactor to achieve reactiveness.\n+ *\n+ * @author Milan Savic\n+ * @since 4.4\n+ */\n+public class DefaultReactorCommandGateway implements ReactorCommandGateway {\n+\n+    private final CommandBus commandBus;\n+    private final RetryScheduler retryScheduler;\n+    private final List<ReactorMessageDispatchInterceptor<CommandMessage<?>>> dispatchInterceptors;\n+    private final List<ReactorResultHandlerInterceptor<CommandMessage<?>, CommandResultMessage<?>>> resultInterceptors;\n+\n+    /**\n+     * Creates an instance of {@link DefaultReactorCommandGateway} based on the fields contained in the {@link\n+     * Builder}.\n+     * <p>\n+     * Will assert that the {@link CommandBus} is not {@code null} and throws an {@link AxonConfigurationException} if\n+     * it is.\n+     * </p>\n+     *\n+     * @param builder the {@link Builder} used to instantiate a {@link DefaultReactorCommandGateway} instance\n+     */\n+    protected DefaultReactorCommandGateway(Builder builder) {\n+        builder.validate();\n+        this.commandBus = builder.commandBus;\n+        this.retryScheduler = builder.retryScheduler;\n+        this.dispatchInterceptors = builder.dispatchInterceptors;\n+        this.resultInterceptors = builder.resultInterceptors;\n+    }\n+\n+    /**\n+     * Instantiate a Builder to be able to create a {@link DefaultReactorCommandGateway}.\n+     * <p>\n+     * The {@code dispatchInterceptors} are defaulted to an empty list.\n+     * The {@code resultHandlerInterceptors} are defaulted to an empty list.\n+     * The {@link CommandBus} is a <b>hard requirement</b> and as such should be provided.\n+     * </p>\n+     *\n+     * @return a Builder to be able to create a {@link DefaultReactorCommandGateway}\n+     */\n+    public static Builder builder() {\n+        return new Builder();\n+    }\n+\n+    @Override\n+    public <R> Mono<R> send(Object command) {\n+        //noinspection unchecked\n+        return Mono.<CommandMessage<?>>just(GenericCommandMessage.asCommandMessage(command))\n+                .transform(this::processCommandInterceptors)\n+                .flatMap(this::dispatchCommand)\n+                .flatMap(this::processResultsInterceptors)\n+                .transform(this::getPayload);\n+    }\n+\n+    @Override\n+    public Registration registerDispatchInterceptor(ReactorMessageDispatchInterceptor<CommandMessage<?>> interceptor) {\n+        dispatchInterceptors.add(interceptor);\n+        return () -> dispatchInterceptors.remove(interceptor);\n+    }\n+\n+    @Override\n+    public Registration registerResultHandlerInterceptor(\n+            ReactorResultHandlerInterceptor<CommandMessage<?>, CommandResultMessage<?>> interceptor) {\n+        resultInterceptors.add(interceptor);\n+        return () -> resultInterceptors.remove(interceptor);\n+    }\n+\n+    private Mono<CommandMessage<?>> processCommandInterceptors(Mono<CommandMessage<?>> commandMessage) {\n+        return Flux.fromIterable(dispatchInterceptors)\n+                   .reduce(commandMessage, (command, interceptor) -> interceptor.intercept(command))\n+                   .flatMap(Mono::from);\n+    }\n+\n+    private <C, R> Mono<Tuple2<CommandMessage<C>, Flux<CommandResultMessage<? extends R>>>> dispatchCommand(\n+            CommandMessage<C> commandMessage) {\n+        ReactiveCallback<C, R> reactiveCallback = new ReactiveCallback<>();\n+        CommandCallback<C, R> callback = reactiveCallback;\n+        if (retryScheduler != null) {\n+            callback = new RetryingCallback<>(callback, retryScheduler, commandBus);\n+        }\n+        commandBus.dispatch(commandMessage, callback);\n+        return Mono.just(commandMessage).zipWith(Mono.just(Flux.from(reactiveCallback)));\n+    }\n+\n+    private <C> Mono<? extends CommandResultMessage<?>> processResultsInterceptors(\n+            Tuple2<CommandMessage<C>, Flux<CommandResultMessage<?>>> commandWithResults) {\n+        CommandMessage<?> commandMessage = commandWithResults.getT1();\n+        Flux<CommandResultMessage<?>> commandResultMessages = commandWithResults.getT2();\n+        return Flux.fromIterable(resultInterceptors)\n+                   .reduce(commandResultMessages,\n+                           (result, interceptor) -> interceptor.intercept(commandMessage, result))\n+                   .flatMap(Flux::next); // command handlers provide only one result!\n+    }\n+\n+    private <R> Mono<R> getPayload(Mono<? extends CommandResultMessage<?>> commandResultMessage) {\n+        //noinspection unchecked\n+        return commandResultMessage\n+                .filter(r -> Objects.nonNull(r.getPayload()))\n+                .map(it -> (R) it.getPayload());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mjc5MTk2Nw=="}, "originalCommit": {"oid": "98865ab1427e4d879301c1bf542842eccc8aa3c3"}, "originalPosition": 136}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgyMzI0NzAwOnYy", "diffSide": "RIGHT", "path": "messaging/src/main/java/org/axonframework/eventhandling/gateway/ReactorEventGateway.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xMFQxMTo0ODoxMVrOGv0YGA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMVQxMzo0ODoxNVrOG041CA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mjc5NDM5Mg==", "bodyText": "Why is there a result to publishing events? Is that a necessity which follows from being able to subscribe to this Flux, which will be the actual initiation of publishing the events?\nIf so, could we change this to Flux<Void> instead of Flux<Object>? Object makes it seem (to me at least) like they'll get an actual response.", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r452794392", "createdAt": "2020-07-10T11:48:11Z", "author": {"login": "smcvb"}, "path": "messaging/src/main/java/org/axonframework/eventhandling/gateway/ReactorEventGateway.java", "diffHunk": "@@ -0,0 +1,84 @@\n+/*\n+ * Copyright (c) 2010-2020. Axon Framework\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.axonframework.eventhandling.gateway;\n+\n+import org.axonframework.eventhandling.EventBus;\n+import org.axonframework.eventhandling.EventMessage;\n+import org.axonframework.messaging.Message;\n+import org.axonframework.messaging.reactive.ReactorMessageDispatchInterceptorSupport;\n+import org.reactivestreams.Publisher;\n+import reactor.core.publisher.Flux;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+\n+/**\n+ * Variation of {@link EventGateway}. Provides support for reactive return types such as {@link Flux} from Project\n+ * Reactor.\n+ *\n+ * @author Milan Savic\n+ * @since 4.4\n+ */\n+public interface ReactorEventGateway extends ReactorMessageDispatchInterceptorSupport<EventMessage<?>> {\n+\n+    /**\n+     * Publishes given {@code events} once the caller subscribes to the resulting Flux. Returns immediately.\n+     * <p/>\n+     * Given {@code events} are wrapped as payloads of a {@link EventMessage} that are eventually published on the\n+     * {@link EventBus}, unless {@code event} already implements {@link Message}. In that case, a {@code EventMessage}\n+     * is constructed from that message's payload and {@link org.axonframework.messaging.MetaData}.\n+     *\n+     * @param events events to be published\n+     * @return events that were published. DO NOTE: if there were some interceptors registered to this {@code gateway},\n+     * they will be processed first, before returning events to the caller. The order of returned events is the same as\n+     * one provided as the input parameter.\n+     */\n+    default Flux<Object> publish(Object... events) { // NOSONAR\n+        return publish(Arrays.asList(events));\n+    }\n+\n+    /**\n+     * Publishes given {@code events} once the caller subscribes to the resulting Flux. Returns immediately.\n+     * <p/>\n+     * Given {@code events} are wrapped as payloads of a {@link EventMessage} that are eventually published on the\n+     * {@link EventBus}, unless {@code event} already implements {@link Message}. In that case, a {@code EventMessage}\n+     * is constructed from that message's payload and {@link org.axonframework.messaging.MetaData}.\n+     *\n+     * @param events the list of events to be published\n+     * @return events that were published. DO NOTE: if there were some interceptors registered to this {@code gateway},\n+     * they will be processed first, before returning events to the caller. The order of returned events is the same as\n+     * one provided as the input parameter.\n+     */\n+    Flux<Object> publish(List<?> events);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "98865ab1427e4d879301c1bf542842eccc8aa3c3"}, "originalPosition": 66}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzQ3MTgxMg==", "bodyText": "I get your point! Return values, in this case, are intercepted events. One of the reasons why we return a flux here is to be more consistent with other Reactor APIs - don't do anything until you subscribe. We could change it to Void, but I felt it is more useful to see how your events look before hitting the bus.", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r457471812", "createdAt": "2020-07-20T15:04:26Z", "author": {"login": "m1l4n54v1c"}, "path": "messaging/src/main/java/org/axonframework/eventhandling/gateway/ReactorEventGateway.java", "diffHunk": "@@ -0,0 +1,84 @@\n+/*\n+ * Copyright (c) 2010-2020. Axon Framework\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.axonframework.eventhandling.gateway;\n+\n+import org.axonframework.eventhandling.EventBus;\n+import org.axonframework.eventhandling.EventMessage;\n+import org.axonframework.messaging.Message;\n+import org.axonframework.messaging.reactive.ReactorMessageDispatchInterceptorSupport;\n+import org.reactivestreams.Publisher;\n+import reactor.core.publisher.Flux;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+\n+/**\n+ * Variation of {@link EventGateway}. Provides support for reactive return types such as {@link Flux} from Project\n+ * Reactor.\n+ *\n+ * @author Milan Savic\n+ * @since 4.4\n+ */\n+public interface ReactorEventGateway extends ReactorMessageDispatchInterceptorSupport<EventMessage<?>> {\n+\n+    /**\n+     * Publishes given {@code events} once the caller subscribes to the resulting Flux. Returns immediately.\n+     * <p/>\n+     * Given {@code events} are wrapped as payloads of a {@link EventMessage} that are eventually published on the\n+     * {@link EventBus}, unless {@code event} already implements {@link Message}. In that case, a {@code EventMessage}\n+     * is constructed from that message's payload and {@link org.axonframework.messaging.MetaData}.\n+     *\n+     * @param events events to be published\n+     * @return events that were published. DO NOTE: if there were some interceptors registered to this {@code gateway},\n+     * they will be processed first, before returning events to the caller. The order of returned events is the same as\n+     * one provided as the input parameter.\n+     */\n+    default Flux<Object> publish(Object... events) { // NOSONAR\n+        return publish(Arrays.asList(events));\n+    }\n+\n+    /**\n+     * Publishes given {@code events} once the caller subscribes to the resulting Flux. Returns immediately.\n+     * <p/>\n+     * Given {@code events} are wrapped as payloads of a {@link EventMessage} that are eventually published on the\n+     * {@link EventBus}, unless {@code event} already implements {@link Message}. In that case, a {@code EventMessage}\n+     * is constructed from that message's payload and {@link org.axonframework.messaging.MetaData}.\n+     *\n+     * @param events the list of events to be published\n+     * @return events that were published. DO NOTE: if there were some interceptors registered to this {@code gateway},\n+     * they will be processed first, before returning events to the caller. The order of returned events is the same as\n+     * one provided as the input parameter.\n+     */\n+    Flux<Object> publish(List<?> events);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mjc5NDM5Mg=="}, "originalCommit": {"oid": "98865ab1427e4d879301c1bf542842eccc8aa3c3"}, "originalPosition": 66}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODExMDIxNg==", "bodyText": "Aaah gotcha, as the Flux returned is indeed allowing you to do additional steps prior to subscription. Using Object as the generic type makes total sense than. Thanks for clarifying @m1l4n54v1c, I'll resolve this thread.", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r458110216", "createdAt": "2020-07-21T13:48:15Z", "author": {"login": "smcvb"}, "path": "messaging/src/main/java/org/axonframework/eventhandling/gateway/ReactorEventGateway.java", "diffHunk": "@@ -0,0 +1,84 @@\n+/*\n+ * Copyright (c) 2010-2020. Axon Framework\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.axonframework.eventhandling.gateway;\n+\n+import org.axonframework.eventhandling.EventBus;\n+import org.axonframework.eventhandling.EventMessage;\n+import org.axonframework.messaging.Message;\n+import org.axonframework.messaging.reactive.ReactorMessageDispatchInterceptorSupport;\n+import org.reactivestreams.Publisher;\n+import reactor.core.publisher.Flux;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+\n+/**\n+ * Variation of {@link EventGateway}. Provides support for reactive return types such as {@link Flux} from Project\n+ * Reactor.\n+ *\n+ * @author Milan Savic\n+ * @since 4.4\n+ */\n+public interface ReactorEventGateway extends ReactorMessageDispatchInterceptorSupport<EventMessage<?>> {\n+\n+    /**\n+     * Publishes given {@code events} once the caller subscribes to the resulting Flux. Returns immediately.\n+     * <p/>\n+     * Given {@code events} are wrapped as payloads of a {@link EventMessage} that are eventually published on the\n+     * {@link EventBus}, unless {@code event} already implements {@link Message}. In that case, a {@code EventMessage}\n+     * is constructed from that message's payload and {@link org.axonframework.messaging.MetaData}.\n+     *\n+     * @param events events to be published\n+     * @return events that were published. DO NOTE: if there were some interceptors registered to this {@code gateway},\n+     * they will be processed first, before returning events to the caller. The order of returned events is the same as\n+     * one provided as the input parameter.\n+     */\n+    default Flux<Object> publish(Object... events) { // NOSONAR\n+        return publish(Arrays.asList(events));\n+    }\n+\n+    /**\n+     * Publishes given {@code events} once the caller subscribes to the resulting Flux. Returns immediately.\n+     * <p/>\n+     * Given {@code events} are wrapped as payloads of a {@link EventMessage} that are eventually published on the\n+     * {@link EventBus}, unless {@code event} already implements {@link Message}. In that case, a {@code EventMessage}\n+     * is constructed from that message's payload and {@link org.axonframework.messaging.MetaData}.\n+     *\n+     * @param events the list of events to be published\n+     * @return events that were published. DO NOTE: if there were some interceptors registered to this {@code gateway},\n+     * they will be processed first, before returning events to the caller. The order of returned events is the same as\n+     * one provided as the input parameter.\n+     */\n+    Flux<Object> publish(List<?> events);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mjc5NDM5Mg=="}, "originalCommit": {"oid": "98865ab1427e4d879301c1bf542842eccc8aa3c3"}, "originalPosition": 66}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgyMzI0ODMzOnYy", "diffSide": "RIGHT", "path": "messaging/src/main/java/org/axonframework/eventhandling/gateway/DefaultReactorEventGateway.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xMFQxMTo0ODo1MVrOGv0Y9A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOFQwNzo0MDowNVrOG4Accg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mjc5NDYxMg==", "bodyText": "Curious whether this is actually needed in this form, or whether we can just do void/null here by default. Follows from my comment on the interface by the way.", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r452794612", "createdAt": "2020-07-10T11:48:51Z", "author": {"login": "smcvb"}, "path": "messaging/src/main/java/org/axonframework/eventhandling/gateway/DefaultReactorEventGateway.java", "diffHunk": "@@ -0,0 +1,177 @@\n+/*\n+ * Copyright (c) 2010-2020. Axon Framework\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.axonframework.eventhandling.gateway;\n+\n+import org.axonframework.common.AxonConfigurationException;\n+import org.axonframework.common.Registration;\n+import org.axonframework.eventhandling.EventBus;\n+import org.axonframework.eventhandling.EventMessage;\n+import org.axonframework.eventhandling.GenericEventMessage;\n+import org.axonframework.messaging.Message;\n+import org.axonframework.messaging.reactive.ReactorMessageDispatchInterceptor;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Mono;\n+\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.concurrent.CopyOnWriteArrayList;\n+\n+import static java.util.Arrays.asList;\n+import static org.axonframework.common.BuilderUtils.assertNonNull;\n+\n+/**\n+ * Implementation of the {@link ReactorEventGateway} that uses Project Reactor to achieve reactiveness.\n+ *\n+ * @author Milan Savic\n+ * @since 4.4\n+ */\n+public class DefaultReactorEventGateway implements ReactorEventGateway {\n+\n+    private final EventBus eventBus;\n+    private final List<ReactorMessageDispatchInterceptor<EventMessage<?>>> dispatchInterceptors;\n+\n+    /**\n+     * Creates an instance of {@link DefaultReactorEventGateway} based on the fields contained in the {@link Builder}.\n+     * <p>\n+     * Will assert that the {@link EventBus} is not {@code null} and throws an {@link\n+     * org.axonframework.common.AxonConfigurationException} if it is.\n+     * </p>\n+     *\n+     * @param builder the {@link Builder} used to instantiate a {@link DefaultReactorEventGateway} instance\n+     */\n+    protected DefaultReactorEventGateway(Builder builder) {\n+        builder.validate();\n+        this.eventBus = builder.eventBus;\n+        this.dispatchInterceptors = builder.dispatchInterceptors;\n+    }\n+\n+    /**\n+     * Instantiate a Builder to be able to create a {@link DefaultReactorEventGateway}.\n+     * <p>\n+     * The {@code dispatchInterceptors} are defaulted to an empty list.\n+     * The {@link EventBus} is a <b>hard requirement</b>\n+     * </p>\n+     *\n+     * @return a Builder to be able to create a {@link DefaultReactorEventGateway}\n+     */\n+    public static Builder builder() {\n+        return new Builder();\n+    }\n+\n+    @Override\n+    public Flux<Object> publish(List<?> events) {\n+        return Flux.fromIterable(events)\n+                   .map(event -> Mono.<EventMessage<?>>just(GenericEventMessage.asEventMessage(event)))\n+                   .flatMap(this::processEventInterceptors)\n+                   .flatMap(this::publishEvent)\n+                   .transform(this::getPayload);\n+    }\n+\n+    @Override\n+    public Registration registerDispatchInterceptor(ReactorMessageDispatchInterceptor<EventMessage<?>> interceptor) {\n+        dispatchInterceptors.add(interceptor);\n+        return () -> dispatchInterceptors.remove(interceptor);\n+    }\n+\n+    private Mono<EventMessage<?>> processEventInterceptors(Mono<EventMessage<?>> eventMessage) {\n+        return Flux.fromIterable(dispatchInterceptors)\n+                   .reduce(eventMessage, (event, interceptor) -> interceptor.intercept(event))\n+                   .flatMap(Mono::from);\n+    }\n+\n+    private Mono<EventMessage<?>> publishEvent(EventMessage<?> eventMessage) {\n+        return Mono.fromRunnable(() -> eventBus.publish(eventMessage))\n+                   .thenReturn(eventMessage);\n+    }\n+\n+    private Flux<Object> getPayload(Flux<EventMessage<?>> eventMessage) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "98865ab1427e4d879301c1bf542842eccc8aa3c3"}, "originalPosition": 101}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTM4MDcyMg==", "bodyText": "Resolved through the previous comment in this file.", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r461380722", "createdAt": "2020-07-28T07:40:05Z", "author": {"login": "smcvb"}, "path": "messaging/src/main/java/org/axonframework/eventhandling/gateway/DefaultReactorEventGateway.java", "diffHunk": "@@ -0,0 +1,177 @@\n+/*\n+ * Copyright (c) 2010-2020. Axon Framework\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.axonframework.eventhandling.gateway;\n+\n+import org.axonframework.common.AxonConfigurationException;\n+import org.axonframework.common.Registration;\n+import org.axonframework.eventhandling.EventBus;\n+import org.axonframework.eventhandling.EventMessage;\n+import org.axonframework.eventhandling.GenericEventMessage;\n+import org.axonframework.messaging.Message;\n+import org.axonframework.messaging.reactive.ReactorMessageDispatchInterceptor;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Mono;\n+\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.concurrent.CopyOnWriteArrayList;\n+\n+import static java.util.Arrays.asList;\n+import static org.axonframework.common.BuilderUtils.assertNonNull;\n+\n+/**\n+ * Implementation of the {@link ReactorEventGateway} that uses Project Reactor to achieve reactiveness.\n+ *\n+ * @author Milan Savic\n+ * @since 4.4\n+ */\n+public class DefaultReactorEventGateway implements ReactorEventGateway {\n+\n+    private final EventBus eventBus;\n+    private final List<ReactorMessageDispatchInterceptor<EventMessage<?>>> dispatchInterceptors;\n+\n+    /**\n+     * Creates an instance of {@link DefaultReactorEventGateway} based on the fields contained in the {@link Builder}.\n+     * <p>\n+     * Will assert that the {@link EventBus} is not {@code null} and throws an {@link\n+     * org.axonframework.common.AxonConfigurationException} if it is.\n+     * </p>\n+     *\n+     * @param builder the {@link Builder} used to instantiate a {@link DefaultReactorEventGateway} instance\n+     */\n+    protected DefaultReactorEventGateway(Builder builder) {\n+        builder.validate();\n+        this.eventBus = builder.eventBus;\n+        this.dispatchInterceptors = builder.dispatchInterceptors;\n+    }\n+\n+    /**\n+     * Instantiate a Builder to be able to create a {@link DefaultReactorEventGateway}.\n+     * <p>\n+     * The {@code dispatchInterceptors} are defaulted to an empty list.\n+     * The {@link EventBus} is a <b>hard requirement</b>\n+     * </p>\n+     *\n+     * @return a Builder to be able to create a {@link DefaultReactorEventGateway}\n+     */\n+    public static Builder builder() {\n+        return new Builder();\n+    }\n+\n+    @Override\n+    public Flux<Object> publish(List<?> events) {\n+        return Flux.fromIterable(events)\n+                   .map(event -> Mono.<EventMessage<?>>just(GenericEventMessage.asEventMessage(event)))\n+                   .flatMap(this::processEventInterceptors)\n+                   .flatMap(this::publishEvent)\n+                   .transform(this::getPayload);\n+    }\n+\n+    @Override\n+    public Registration registerDispatchInterceptor(ReactorMessageDispatchInterceptor<EventMessage<?>> interceptor) {\n+        dispatchInterceptors.add(interceptor);\n+        return () -> dispatchInterceptors.remove(interceptor);\n+    }\n+\n+    private Mono<EventMessage<?>> processEventInterceptors(Mono<EventMessage<?>> eventMessage) {\n+        return Flux.fromIterable(dispatchInterceptors)\n+                   .reduce(eventMessage, (event, interceptor) -> interceptor.intercept(event))\n+                   .flatMap(Mono::from);\n+    }\n+\n+    private Mono<EventMessage<?>> publishEvent(EventMessage<?> eventMessage) {\n+        return Mono.fromRunnable(() -> eventBus.publish(eventMessage))\n+                   .thenReturn(eventMessage);\n+    }\n+\n+    private Flux<Object> getPayload(Flux<EventMessage<?>> eventMessage) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mjc5NDYxMg=="}, "originalCommit": {"oid": "98865ab1427e4d879301c1bf542842eccc8aa3c3"}, "originalPosition": 101}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgyMzI4NTczOnYy", "diffSide": "RIGHT", "path": "messaging/src/test/java/org/axonframework/commandhandling/gateway/DefaultReactorCommandGatewayTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xMFQxMjowMzowN1rOGv0wDA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xMFQxMjowMzowN1rOGv0wDA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjgwMDUyNA==", "bodyText": "The second assert here is the same as the first one. Think the second one is intended to verify k2 == k3.", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r452800524", "createdAt": "2020-07-10T12:03:07Z", "author": {"login": "smcvb"}, "path": "messaging/src/test/java/org/axonframework/commandhandling/gateway/DefaultReactorCommandGatewayTest.java", "diffHunk": "@@ -0,0 +1,213 @@\n+package org.axonframework.commandhandling.gateway;\n+\n+import org.axonframework.commandhandling.CommandMessage;\n+import org.axonframework.commandhandling.CommandResultMessage;\n+import org.axonframework.commandhandling.GenericCommandMessage;\n+import org.axonframework.commandhandling.GenericCommandResultMessage;\n+import org.junit.jupiter.api.*;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Mono;\n+import reactor.test.StepVerifier;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.function.BiFunction;\n+import java.util.function.Function;\n+import java.util.function.Predicate;\n+\n+import static org.junit.jupiter.api.Assertions.*;\n+\n+/**\n+ * Unit tests for {@link DefaultReactorCommandGateway}.\n+ *\n+ * @author Sara Pellegrini\n+ * @since 4.4\n+ */\n+class DefaultReactorCommandGatewayTest {\n+\n+    private CommandBusStub commandBus;\n+    private ReactorCommandGateway gateway;\n+\n+    @BeforeEach\n+    public void setUp() {\n+        commandBus = new CommandBusStub();\n+        gateway = DefaultReactorCommandGateway.builder()\n+                                              .commandBus(commandBus)\n+                                              .build();\n+    }\n+\n+    @Test\n+    void testInterceptorOrder() {\n+\n+        // int 1 -> metadata on command k1 -> v1\n+        Map<String, String> metadata1 = new HashMap<>();\n+        metadata1.put(\"k1\", \"v1\");\n+        registerMessageMapping(gateway, command -> command.andMetaData(metadata1));\n+\n+        // int 2 -> copy metadata from command into results\n+        registerResultMapping(gateway,\n+                              (command, result) -> new GenericCommandResultMessage<>(command.getMetaData().get(\"k1\")));\n+\n+        // int 3 -> metadata on command k1 -> v2\n+        Map<String, String> metadata2 = new HashMap<>();\n+        metadata1.put(\"k1\", \"v2\");\n+        registerMessageMapping(gateway, command -> command.andMetaData(metadata2));\n+\n+        //send\n+        Mono<String> results = gateway.send(\"\");\n+\n+        // verify -> results equals v2\n+        StepVerifier.create(results)\n+                    .expectNextMatches(result -> result.equals(\"v2\"))\n+                    .verifyComplete();\n+\n+        // verify -> command sent has k1 -> v2\n+        CommandMessage<?> sentCommand = commandBus.lastSentCommand();\n+        assertEquals(\"v2\", sentCommand.getMetaData().get(\"k1\"));\n+    }\n+\n+    @Test\n+    void testResultFiltering() {\n+        registerResultsFilter(gateway, result -> result.getMetaData().containsKey(\"K\"));\n+        // int 1 -> flux of results is filtered\n+\n+        Mono<CommandResultMessage<?>> results = gateway.send(\"\");\n+        StepVerifier.create(results)\n+                    .verifyComplete();\n+        // verify -> command has been sent\n+        assertEquals(1, commandBus.numberOfSentCommands());\n+    }\n+\n+    @Test\n+    void testCommandFiltering() {\n+        registerMessageFilter(gateway, result -> result.getMetaData().containsKey(\"K\"));\n+        // int 1 -> flux of results is filtered\n+\n+        Mono<CommandResultMessage<?>> results = gateway.send(\"\");\n+        StepVerifier.create(results)\n+                    .verifyComplete();\n+        // verify -> command has not been sent\n+        assertEquals(0, commandBus.numberOfSentCommands());\n+    }\n+\n+    @Test\n+    void testCommandDispatchAndResultHandlerInterceptor() {\n+        // int 1 -> add Principal to command and results\n+        Map<String, String> principalMetadata = new HashMap<>();\n+        principalMetadata.put(\"username\", \"admin\");\n+        registerMapping(gateway,\n+                        command -> command.andMetaData(principalMetadata),\n+                        (command, result) -> result.andMetaData(principalMetadata));\n+\n+        // int 2 -> validate authorizations and results\n+        registerMapping(gateway,\n+                        command -> {\n+                            assert command.getMetaData().get(\"username\").equals(\"admin\");\n+                            return command;\n+                        },\n+                        (command, result) -> {\n+                            assert result.getMetaData().get(\"username\").equals(\"admin\");\n+                            return result;\n+                        });\n+\n+        Mono<CommandResultMessage<?>> results = gateway.send(\"\");\n+\n+        StepVerifier.create(results)\n+                    .expectNextCount(1)\n+                    .verifyComplete();\n+\n+        assertEquals(1, commandBus.numberOfSentCommands());\n+    }\n+\n+    @Test\n+    void testCommandResultHandlerChain() {\n+        // int 1 -> metadata on result k1 -> v1\n+        Map<String, String> metadata1 = new HashMap<>();\n+        metadata1.put(\"k1\", \"v1\");\n+        registerResultMapping(gateway, (command, result) -> result.andMetaData(metadata1));\n+\n+        // int 2 -> metadata on result k1 -> v2\n+        Map<String, String> metadata2 = new HashMap<>();\n+        metadata2.put(\"k1\", \"v2\");\n+        registerResultMapping(gateway, (command, result) -> result.andMetaData(metadata2));\n+\n+        // int 3 -> metadata on result k2 -> v3\n+        Map<String, String> metadata3 = new HashMap<>();\n+        metadata3.put(\"k2\", \"v3\");\n+        registerResultMapping(gateway, (command, result) -> result.andMetaData(metadata3));\n+\n+        Mono<CommandResultMessage<?>> results = gateway.send(\"\");\n+\n+        // verify -> results have k1 -> v2 and k2 -> v3\n+        StepVerifier.create(results)\n+                    .expectNextMatches(result -> result.getMetaData().get(\"k1\").equals(\"v2\") &&", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "98865ab1427e4d879301c1bf542842eccc8aa3c3"}, "originalPosition": 143}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgyMzI5NzM2OnYy", "diffSide": "RIGHT", "path": "messaging/src/test/java/org/axonframework/commandhandling/gateway/DefaultReactorCommandGatewayComponentTest.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xMFQxMjowNzoxNVrOGv03Gg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMVQxMzo0OTowNFrOG043WA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjgwMjMzMA==", "bodyText": "Curious: Why not make it actually void, without a return statement?", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r452802330", "createdAt": "2020-07-10T12:07:15Z", "author": {"login": "smcvb"}, "path": "messaging/src/test/java/org/axonframework/commandhandling/gateway/DefaultReactorCommandGatewayComponentTest.java", "diffHunk": "@@ -0,0 +1,321 @@\n+/*\n+ * Copyright (c) 2010-2020. Axon Framework\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.axonframework.commandhandling.gateway;\n+\n+import org.axonframework.commandhandling.AsynchronousCommandBus;\n+import org.axonframework.commandhandling.CommandBus;\n+import org.axonframework.commandhandling.CommandMessage;\n+import org.axonframework.commandhandling.GenericCommandResultMessage;\n+import org.axonframework.common.Registration;\n+import org.axonframework.messaging.MessageHandler;\n+import org.junit.jupiter.api.*;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Hooks;\n+import reactor.core.publisher.Mono;\n+import reactor.test.StepVerifier;\n+import reactor.util.context.Context;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.stream.IntStream;\n+\n+import static java.util.stream.Collectors.toList;\n+import static org.junit.jupiter.api.Assertions.*;\n+import static org.mockito.Mockito.*;\n+\n+/**\n+ * Tests for {@link DefaultReactorCommandGateway} all together with Command Bus.\n+ *\n+ * @author Milan Savic\n+ */\n+class DefaultReactorCommandGatewayComponentTest {\n+\n+    private DefaultReactorCommandGateway reactiveCommandGateway;\n+    private MessageHandler<CommandMessage<?>> commandMessageHandler;\n+    private MessageHandler<CommandMessage<?>> failingCommandHandler;\n+    private MessageHandler<CommandMessage<?>> voidCommandHandler;\n+    private RetryScheduler mockRetryScheduler;\n+    private CommandBus commandBus;\n+\n+    @BeforeEach\n+    void setUp() {\n+        Hooks.enableContextLossTracking();\n+        Hooks.onOperatorDebug();\n+\n+        commandBus = spy(AsynchronousCommandBus.builder().build());\n+\n+        mockRetryScheduler = mock(RetryScheduler.class);\n+        commandMessageHandler = spy(new MessageHandler<CommandMessage<?>>() {\n+\n+            private final AtomicInteger count = new AtomicInteger();\n+\n+            @Override\n+            public Object handle(CommandMessage<?> message) {\n+                if (\"backpressure\".equals(message.getPayload())) {\n+                    return count.incrementAndGet();\n+                }\n+                return \"handled\";\n+            }\n+        });\n+        commandBus.subscribe(String.class.getName(), commandMessageHandler);\n+        failingCommandHandler = spy(new MessageHandler<CommandMessage<?>>() {\n+            @Override\n+            public Object handle(CommandMessage<?> message) throws Exception {\n+                throw new RuntimeException();\n+            }\n+        });\n+\n+        voidCommandHandler = spy(new MessageHandler<CommandMessage<?>>() {\n+            @Override\n+            public Object handle(CommandMessage<?> message) throws Exception {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "98865ab1427e4d879301c1bf542842eccc8aa3c3"}, "originalPosition": 87}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzQ3NDM5Mg==", "bodyText": "That's the signature of MessageHandler :)", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r457474392", "createdAt": "2020-07-20T15:07:17Z", "author": {"login": "m1l4n54v1c"}, "path": "messaging/src/test/java/org/axonframework/commandhandling/gateway/DefaultReactorCommandGatewayComponentTest.java", "diffHunk": "@@ -0,0 +1,321 @@\n+/*\n+ * Copyright (c) 2010-2020. Axon Framework\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.axonframework.commandhandling.gateway;\n+\n+import org.axonframework.commandhandling.AsynchronousCommandBus;\n+import org.axonframework.commandhandling.CommandBus;\n+import org.axonframework.commandhandling.CommandMessage;\n+import org.axonframework.commandhandling.GenericCommandResultMessage;\n+import org.axonframework.common.Registration;\n+import org.axonframework.messaging.MessageHandler;\n+import org.junit.jupiter.api.*;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Hooks;\n+import reactor.core.publisher.Mono;\n+import reactor.test.StepVerifier;\n+import reactor.util.context.Context;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.stream.IntStream;\n+\n+import static java.util.stream.Collectors.toList;\n+import static org.junit.jupiter.api.Assertions.*;\n+import static org.mockito.Mockito.*;\n+\n+/**\n+ * Tests for {@link DefaultReactorCommandGateway} all together with Command Bus.\n+ *\n+ * @author Milan Savic\n+ */\n+class DefaultReactorCommandGatewayComponentTest {\n+\n+    private DefaultReactorCommandGateway reactiveCommandGateway;\n+    private MessageHandler<CommandMessage<?>> commandMessageHandler;\n+    private MessageHandler<CommandMessage<?>> failingCommandHandler;\n+    private MessageHandler<CommandMessage<?>> voidCommandHandler;\n+    private RetryScheduler mockRetryScheduler;\n+    private CommandBus commandBus;\n+\n+    @BeforeEach\n+    void setUp() {\n+        Hooks.enableContextLossTracking();\n+        Hooks.onOperatorDebug();\n+\n+        commandBus = spy(AsynchronousCommandBus.builder().build());\n+\n+        mockRetryScheduler = mock(RetryScheduler.class);\n+        commandMessageHandler = spy(new MessageHandler<CommandMessage<?>>() {\n+\n+            private final AtomicInteger count = new AtomicInteger();\n+\n+            @Override\n+            public Object handle(CommandMessage<?> message) {\n+                if (\"backpressure\".equals(message.getPayload())) {\n+                    return count.incrementAndGet();\n+                }\n+                return \"handled\";\n+            }\n+        });\n+        commandBus.subscribe(String.class.getName(), commandMessageHandler);\n+        failingCommandHandler = spy(new MessageHandler<CommandMessage<?>>() {\n+            @Override\n+            public Object handle(CommandMessage<?> message) throws Exception {\n+                throw new RuntimeException();\n+            }\n+        });\n+\n+        voidCommandHandler = spy(new MessageHandler<CommandMessage<?>>() {\n+            @Override\n+            public Object handle(CommandMessage<?> message) throws Exception {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjgwMjMzMA=="}, "originalCommit": {"oid": "98865ab1427e4d879301c1bf542842eccc8aa3c3"}, "originalPosition": 87}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODExMDgwOA==", "bodyText": "You are completely right here @m1l4n54v1c >_>", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r458110808", "createdAt": "2020-07-21T13:49:04Z", "author": {"login": "smcvb"}, "path": "messaging/src/test/java/org/axonframework/commandhandling/gateway/DefaultReactorCommandGatewayComponentTest.java", "diffHunk": "@@ -0,0 +1,321 @@\n+/*\n+ * Copyright (c) 2010-2020. Axon Framework\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.axonframework.commandhandling.gateway;\n+\n+import org.axonframework.commandhandling.AsynchronousCommandBus;\n+import org.axonframework.commandhandling.CommandBus;\n+import org.axonframework.commandhandling.CommandMessage;\n+import org.axonframework.commandhandling.GenericCommandResultMessage;\n+import org.axonframework.common.Registration;\n+import org.axonframework.messaging.MessageHandler;\n+import org.junit.jupiter.api.*;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Hooks;\n+import reactor.core.publisher.Mono;\n+import reactor.test.StepVerifier;\n+import reactor.util.context.Context;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.stream.IntStream;\n+\n+import static java.util.stream.Collectors.toList;\n+import static org.junit.jupiter.api.Assertions.*;\n+import static org.mockito.Mockito.*;\n+\n+/**\n+ * Tests for {@link DefaultReactorCommandGateway} all together with Command Bus.\n+ *\n+ * @author Milan Savic\n+ */\n+class DefaultReactorCommandGatewayComponentTest {\n+\n+    private DefaultReactorCommandGateway reactiveCommandGateway;\n+    private MessageHandler<CommandMessage<?>> commandMessageHandler;\n+    private MessageHandler<CommandMessage<?>> failingCommandHandler;\n+    private MessageHandler<CommandMessage<?>> voidCommandHandler;\n+    private RetryScheduler mockRetryScheduler;\n+    private CommandBus commandBus;\n+\n+    @BeforeEach\n+    void setUp() {\n+        Hooks.enableContextLossTracking();\n+        Hooks.onOperatorDebug();\n+\n+        commandBus = spy(AsynchronousCommandBus.builder().build());\n+\n+        mockRetryScheduler = mock(RetryScheduler.class);\n+        commandMessageHandler = spy(new MessageHandler<CommandMessage<?>>() {\n+\n+            private final AtomicInteger count = new AtomicInteger();\n+\n+            @Override\n+            public Object handle(CommandMessage<?> message) {\n+                if (\"backpressure\".equals(message.getPayload())) {\n+                    return count.incrementAndGet();\n+                }\n+                return \"handled\";\n+            }\n+        });\n+        commandBus.subscribe(String.class.getName(), commandMessageHandler);\n+        failingCommandHandler = spy(new MessageHandler<CommandMessage<?>>() {\n+            @Override\n+            public Object handle(CommandMessage<?> message) throws Exception {\n+                throw new RuntimeException();\n+            }\n+        });\n+\n+        voidCommandHandler = spy(new MessageHandler<CommandMessage<?>>() {\n+            @Override\n+            public Object handle(CommandMessage<?> message) throws Exception {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjgwMjMzMA=="}, "originalCommit": {"oid": "98865ab1427e4d879301c1bf542842eccc8aa3c3"}, "originalPosition": 87}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgyMzMzNjI0OnYy", "diffSide": "RIGHT", "path": "messaging/src/main/java/org/axonframework/queryhandling/DefaultReactorQueryGateway.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xMFQxMjoyMDo0NlrOGv1N9g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xMFQxMjoyMDo0NlrOGv1N9g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjgwODE4Mg==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                     * Sets {@link ReactorResultHandlerInterceptor}s for {@link CommandResultMessage}s.\n          \n          \n            \n                     * Are invoked when a result has been received.\n          \n          \n            \n                     * Sets {@link ReactorResultHandlerInterceptor}s for {@link ResultMessage}s.\n          \n          \n            \n                     * Are invoked when a result has been received.", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r452808182", "createdAt": "2020-07-10T12:20:46Z", "author": {"login": "smcvb"}, "path": "messaging/src/main/java/org/axonframework/queryhandling/DefaultReactorQueryGateway.java", "diffHunk": "@@ -0,0 +1,318 @@\n+/*\n+ * Copyright (c) 2010-2020. Axon Framework\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.axonframework.queryhandling;\n+\n+import org.axonframework.commandhandling.CommandResultMessage;\n+import org.axonframework.common.AxonConfigurationException;\n+import org.axonframework.common.Registration;\n+import org.axonframework.messaging.ResultMessage;\n+import org.axonframework.messaging.reactive.ReactorMessageDispatchInterceptor;\n+import org.axonframework.messaging.reactive.ReactorResultHandlerInterceptor;\n+import org.axonframework.messaging.responsetypes.ResponseType;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Mono;\n+import reactor.util.function.Tuple2;\n+\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.concurrent.CopyOnWriteArrayList;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Function;\n+\n+import static java.util.Arrays.asList;\n+import static org.axonframework.common.BuilderUtils.assertNonNull;\n+import static org.axonframework.messaging.GenericMessage.asMessage;\n+\n+/**\n+ * Implementation of the {@link ReactorQueryGateway} that uses Project Reactor to achieve reactiveness.\n+ *\n+ * @author Milan Savic\n+ * @since 4.4\n+ */\n+public class DefaultReactorQueryGateway implements ReactorQueryGateway {\n+\n+    private final List<ReactorMessageDispatchInterceptor<QueryMessage<?, ?>>> dispatchInterceptors;\n+    private final List<ReactorResultHandlerInterceptor<QueryMessage<?, ?>, ResultMessage<?>>> resultInterceptors;\n+\n+    private final QueryBus queryBus;\n+\n+    /**\n+     * Creates an instance of {@link DefaultReactorQueryGateway} based on the fields contained in the {@link\n+     * Builder}.\n+     * <p>\n+     * Will assert that the {@link QueryBus} is not {@code null} and throws an {@link AxonConfigurationException} if\n+     * it is.\n+     * </p>\n+     *\n+     * @param builder the {@link Builder} used to instantiated a {@link DefaultReactorQueryGateway} instance\n+     */\n+    protected DefaultReactorQueryGateway(Builder builder) {\n+        builder.validate();\n+        this.queryBus = builder.queryBus;\n+        this.dispatchInterceptors = builder.dispatchInterceptors;\n+        this.resultInterceptors = builder.resultInterceptors;\n+    }\n+\n+    /**\n+     * Instantiate a Builder to be able to create a {@link DefaultReactorQueryGateway}.\n+     * <p>\n+     * The {@code dispatchInterceptors} are defaulted to an empty list.\n+     * The {@code resultHandlerInterceptors} are defaulted to an empty list.\n+     * The {@link QueryBus} is a <b>hard requirement</b> and as such should be provided.\n+     * </p>\n+     *\n+     * @return a Builder to be able to create a {@link DefaultReactorQueryGateway}\n+     */\n+    public static Builder builder() {\n+        return new Builder();\n+    }\n+\n+    @Override\n+    public Registration registerDispatchInterceptor(\n+            ReactorMessageDispatchInterceptor<QueryMessage<?, ?>> interceptor) {\n+        dispatchInterceptors.add(interceptor);\n+        return () -> dispatchInterceptors.remove(interceptor);\n+    }\n+\n+    @Override\n+    public Registration registerResultHandlerInterceptor(\n+            ReactorResultHandlerInterceptor<QueryMessage<?, ?>, ResultMessage<?>> interceptor) {\n+        resultInterceptors.add(interceptor);\n+        return () -> resultInterceptors.remove(interceptor);\n+    }\n+\n+    @Override\n+    public <R, Q> Mono<R> query(String queryName, Q query, ResponseType<R> responseType) {\n+        return Mono.<QueryMessage<?, ?>>fromCallable(() -> new GenericQueryMessage<>(asMessage(query),\n+                                                                                     queryName,\n+                                                                                     responseType))\n+                .transform(this::processDispatchInterceptors)\n+                .flatMap(this::dispatchQuery)\n+                .flatMapMany(this::processResultsInterceptors)\n+                .<R>transform(this::getPayload)\n+                .next();\n+    }\n+\n+    @Override\n+    public <R, Q> Flux<R> scatterGather(String queryName, Q query, ResponseType<R> responseType, long timeout,\n+                                        TimeUnit timeUnit) {\n+        return Mono.<QueryMessage<?, ?>>fromCallable(() -> new GenericQueryMessage<>(asMessage(query),\n+                                                                                     queryName,\n+                                                                                     responseType))\n+                .transform(this::processDispatchInterceptors)\n+                .flatMap(q -> dispatchScatterGatherQuery(q, timeout, timeUnit))\n+                .flatMapMany(this::processResultsInterceptors)\n+                .transform(this::getPayload);\n+    }\n+\n+    @Override\n+    public <Q, I, U> Mono<SubscriptionQueryResult<I, U>> subscriptionQuery(String queryName, Q query,\n+                                                                           ResponseType<I> initialResponseType,\n+                                                                           ResponseType<U> updateResponseType,\n+                                                                           SubscriptionQueryBackpressure backpressure,\n+                                                                           int updateBufferSize) {\n+\n+        //noinspection unchecked\n+        return Mono.<QueryMessage<?, ?>>fromCallable(() -> new GenericSubscriptionQueryMessage<>(query,\n+                                                                                                 initialResponseType,\n+                                                                                                 updateResponseType))\n+                .transform(this::processDispatchInterceptors)\n+                .map(isq -> (SubscriptionQueryMessage<Q, U, I>) isq)\n+                .flatMap(isq -> dispatchSubscriptionQuery(isq, backpressure, updateBufferSize))\n+                .flatMap(processSubscriptionQueryResult());\n+    }\n+\n+\n+    private Mono<Tuple2<QueryMessage<?, ?>, Flux<ResultMessage<?>>>> dispatchQuery(QueryMessage<?, ?> queryMessage) {\n+        Flux<ResultMessage<?>> results = Flux\n+                .defer(() -> Mono.fromFuture(queryBus.query(queryMessage)));\n+\n+        return Mono.<QueryMessage<?, ?>>just(queryMessage)\n+                .zipWith(Mono.just(results));\n+    }\n+\n+    private Mono<Tuple2<QueryMessage<?, ?>, Flux<ResultMessage<?>>>> dispatchScatterGatherQuery(\n+            QueryMessage<?, ?> queryMessage, long timeout, TimeUnit timeUnit) {\n+        Flux<ResultMessage<?>> results = Flux\n+                .defer(() -> Flux.fromStream(queryBus.scatterGather(queryMessage,\n+                                                                    timeout,\n+                                                                    timeUnit)));\n+\n+        return Mono.<QueryMessage<?, ?>>just(queryMessage)\n+                .zipWith(Mono.just(results));\n+    }\n+\n+    private <Q, I, U> Mono<Tuple2<QueryMessage<Q, I>, Mono<SubscriptionQueryResult<QueryResponseMessage<I>, SubscriptionQueryUpdateMessage<U>>>>> dispatchSubscriptionQuery(\n+            SubscriptionQueryMessage<Q, I, U> queryMessage, SubscriptionQueryBackpressure backpressure,\n+            int updateBufferSize) {\n+        Mono<SubscriptionQueryResult<QueryResponseMessage<I>, SubscriptionQueryUpdateMessage<U>>> result = Mono\n+                .fromCallable(() -> queryBus.subscriptionQuery(queryMessage, backpressure, updateBufferSize));\n+        return Mono.<QueryMessage<Q, I>>just(queryMessage)\n+                .zipWith(Mono.just(result));\n+    }\n+\n+    private Mono<QueryMessage<?, ?>> processDispatchInterceptors(Mono<QueryMessage<?, ?>> queryMessageMono) {\n+        return Flux.fromIterable(dispatchInterceptors)\n+                   .reduce(queryMessageMono, (queryMessage, interceptor) -> interceptor.intercept(queryMessage))\n+                   .flatMap(Mono::from);\n+    }\n+\n+    private Flux<ResultMessage<?>> processResultsInterceptors(\n+            Tuple2<QueryMessage<?, ?>, Flux<ResultMessage<?>>> queryWithResponses) {\n+        QueryMessage<?, ?> queryMessage = queryWithResponses.getT1();\n+        Flux<ResultMessage<?>> queryResultMessage = queryWithResponses.getT2();\n+\n+        return Flux.fromIterable(resultInterceptors)\n+                   .reduce(queryResultMessage,\n+                           (result, interceptor) -> interceptor.intercept(queryMessage, result))\n+                   .flatMapMany(it -> it);\n+    }\n+\n+    private <Q, I, U> Function<Tuple2<QueryMessage<Q, U>,\n+            Mono<SubscriptionQueryResult<QueryResponseMessage<U>, SubscriptionQueryUpdateMessage<I>>>>,\n+            Mono<SubscriptionQueryResult<I, U>>> processSubscriptionQueryResult() {\n+\n+        return messageWithResult -> messageWithResult.getT2().map(sqr -> {\n+            Mono<I> interceptedInitialResult = Mono.<QueryMessage<?, ?>>just(messageWithResult.getT1())\n+                    .zipWith(Mono.just(Flux.<ResultMessage<?>>from(sqr.initialResult())))\n+                    .flatMapMany(this::processResultsInterceptors)\n+                    .<I>transform(this::getPayload)\n+                    .next();\n+\n+            Flux<U> interceptedUpdates = Mono.<QueryMessage<?, ?>>just(messageWithResult.getT1())\n+                    .zipWith(Mono.just(sqr.updates().<ResultMessage<?>>map(it -> it)))\n+                    .flatMapMany(this::processResultsInterceptors)\n+                    .transform(this::getPayload);\n+\n+            return new DefaultSubscriptionQueryResult<>(interceptedInitialResult, interceptedUpdates, sqr);\n+        });\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    private <R> Flux<R> getPayload(Flux<ResultMessage<?>> resultMessageFlux) {\n+        return resultMessageFlux\n+                .flatMap(this::mapResult)\n+                .filter(r -> Objects.nonNull(r.getPayload()))\n+                .map(it -> (R) it.getPayload());\n+    }\n+\n+    private Flux<? extends ResultMessage<?>> mapResult(ResultMessage<?> response) {\n+        return response.isExceptional() ? Flux.error(response.exceptionResult()) : Flux.just(response);\n+    }\n+\n+    /**\n+     * Builder class to instantiate {@link DefaultReactorQueryGateway}.\n+     * <p>\n+     * The {@code dispatchInterceptors} are defaulted to an empty list.\n+     * The {@link QueryBus} is a <b>hard requirement</b> and as such should be provided.\n+     * </p>\n+     */\n+    public static class Builder {\n+\n+        private QueryBus queryBus;\n+        private List<ReactorMessageDispatchInterceptor<QueryMessage<?, ?>>> dispatchInterceptors = new CopyOnWriteArrayList<>();\n+        private List<ReactorResultHandlerInterceptor<QueryMessage<?, ?>, ResultMessage<?>>> resultInterceptors = new CopyOnWriteArrayList<>();\n+\n+        /**\n+         * Sets the {@link QueryBus} used to dispatch queries.\n+         *\n+         * @param queryBus a {@link QueryBus} used to dispatch queries\n+         * @return the current Builder instance, for fluent interfacing\n+         */\n+        public Builder queryBus(QueryBus queryBus) {\n+            assertNonNull(queryBus, \"QueryBus may not be null\");\n+            this.queryBus = queryBus;\n+            return this;\n+        }\n+\n+        /**\n+         * Sets {@link ReactorMessageDispatchInterceptor}s for {@link QueryMessage}s. Are invoked\n+         * when a query is being dispatched.\n+         *\n+         * @param dispatchInterceptors which are invoked when a query is being dispatched\n+         * @return the current Builder instance, for fluent interfacing\n+         */\n+        @SafeVarargs\n+        public final Builder dispatchInterceptors(\n+                ReactorMessageDispatchInterceptor<QueryMessage<?, ?>>... dispatchInterceptors) {\n+            return dispatchInterceptors(asList(dispatchInterceptors));\n+        }\n+\n+        /**\n+         * Sets the {@link List} of {@link ReactorMessageDispatchInterceptor}s for {@link QueryMessage}s. Are invoked\n+         * when a query is being dispatched.\n+         *\n+         * @param dispatchInterceptors which are invoked when a query is being dispatched\n+         * @return the current Builder instance, for fluent interfacing\n+         */\n+        public Builder dispatchInterceptors(\n+                List<ReactorMessageDispatchInterceptor<QueryMessage<?, ?>>> dispatchInterceptors) {\n+            this.dispatchInterceptors = dispatchInterceptors != null && dispatchInterceptors.isEmpty()\n+                    ? new CopyOnWriteArrayList<>(dispatchInterceptors)\n+                    : new CopyOnWriteArrayList<>();\n+            return this;\n+        }\n+\n+        /**\n+         * Sets {@link ReactorResultHandlerInterceptor}s for {@link CommandResultMessage}s.\n+         * Are invoked when a result has been received.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "98865ab1427e4d879301c1bf542842eccc8aa3c3"}, "originalPosition": 272}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgyMzMzNjk1OnYy", "diffSide": "RIGHT", "path": "messaging/src/main/java/org/axonframework/queryhandling/DefaultReactorQueryGateway.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xMFQxMjoyMDo1OVrOGv1OYg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xMFQxMjoyMDo1OVrOGv1OYg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjgwODI5MA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                     * Sets the {@link List} of {@link ReactorResultHandlerInterceptor}s for {@link CommandResultMessage}s.\n          \n          \n            \n                     * Sets the {@link List} of {@link ReactorResultHandlerInterceptor}s for {@link ResultMessage}s.", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r452808290", "createdAt": "2020-07-10T12:20:59Z", "author": {"login": "smcvb"}, "path": "messaging/src/main/java/org/axonframework/queryhandling/DefaultReactorQueryGateway.java", "diffHunk": "@@ -0,0 +1,318 @@\n+/*\n+ * Copyright (c) 2010-2020. Axon Framework\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.axonframework.queryhandling;\n+\n+import org.axonframework.commandhandling.CommandResultMessage;\n+import org.axonframework.common.AxonConfigurationException;\n+import org.axonframework.common.Registration;\n+import org.axonframework.messaging.ResultMessage;\n+import org.axonframework.messaging.reactive.ReactorMessageDispatchInterceptor;\n+import org.axonframework.messaging.reactive.ReactorResultHandlerInterceptor;\n+import org.axonframework.messaging.responsetypes.ResponseType;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Mono;\n+import reactor.util.function.Tuple2;\n+\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.concurrent.CopyOnWriteArrayList;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Function;\n+\n+import static java.util.Arrays.asList;\n+import static org.axonframework.common.BuilderUtils.assertNonNull;\n+import static org.axonframework.messaging.GenericMessage.asMessage;\n+\n+/**\n+ * Implementation of the {@link ReactorQueryGateway} that uses Project Reactor to achieve reactiveness.\n+ *\n+ * @author Milan Savic\n+ * @since 4.4\n+ */\n+public class DefaultReactorQueryGateway implements ReactorQueryGateway {\n+\n+    private final List<ReactorMessageDispatchInterceptor<QueryMessage<?, ?>>> dispatchInterceptors;\n+    private final List<ReactorResultHandlerInterceptor<QueryMessage<?, ?>, ResultMessage<?>>> resultInterceptors;\n+\n+    private final QueryBus queryBus;\n+\n+    /**\n+     * Creates an instance of {@link DefaultReactorQueryGateway} based on the fields contained in the {@link\n+     * Builder}.\n+     * <p>\n+     * Will assert that the {@link QueryBus} is not {@code null} and throws an {@link AxonConfigurationException} if\n+     * it is.\n+     * </p>\n+     *\n+     * @param builder the {@link Builder} used to instantiated a {@link DefaultReactorQueryGateway} instance\n+     */\n+    protected DefaultReactorQueryGateway(Builder builder) {\n+        builder.validate();\n+        this.queryBus = builder.queryBus;\n+        this.dispatchInterceptors = builder.dispatchInterceptors;\n+        this.resultInterceptors = builder.resultInterceptors;\n+    }\n+\n+    /**\n+     * Instantiate a Builder to be able to create a {@link DefaultReactorQueryGateway}.\n+     * <p>\n+     * The {@code dispatchInterceptors} are defaulted to an empty list.\n+     * The {@code resultHandlerInterceptors} are defaulted to an empty list.\n+     * The {@link QueryBus} is a <b>hard requirement</b> and as such should be provided.\n+     * </p>\n+     *\n+     * @return a Builder to be able to create a {@link DefaultReactorQueryGateway}\n+     */\n+    public static Builder builder() {\n+        return new Builder();\n+    }\n+\n+    @Override\n+    public Registration registerDispatchInterceptor(\n+            ReactorMessageDispatchInterceptor<QueryMessage<?, ?>> interceptor) {\n+        dispatchInterceptors.add(interceptor);\n+        return () -> dispatchInterceptors.remove(interceptor);\n+    }\n+\n+    @Override\n+    public Registration registerResultHandlerInterceptor(\n+            ReactorResultHandlerInterceptor<QueryMessage<?, ?>, ResultMessage<?>> interceptor) {\n+        resultInterceptors.add(interceptor);\n+        return () -> resultInterceptors.remove(interceptor);\n+    }\n+\n+    @Override\n+    public <R, Q> Mono<R> query(String queryName, Q query, ResponseType<R> responseType) {\n+        return Mono.<QueryMessage<?, ?>>fromCallable(() -> new GenericQueryMessage<>(asMessage(query),\n+                                                                                     queryName,\n+                                                                                     responseType))\n+                .transform(this::processDispatchInterceptors)\n+                .flatMap(this::dispatchQuery)\n+                .flatMapMany(this::processResultsInterceptors)\n+                .<R>transform(this::getPayload)\n+                .next();\n+    }\n+\n+    @Override\n+    public <R, Q> Flux<R> scatterGather(String queryName, Q query, ResponseType<R> responseType, long timeout,\n+                                        TimeUnit timeUnit) {\n+        return Mono.<QueryMessage<?, ?>>fromCallable(() -> new GenericQueryMessage<>(asMessage(query),\n+                                                                                     queryName,\n+                                                                                     responseType))\n+                .transform(this::processDispatchInterceptors)\n+                .flatMap(q -> dispatchScatterGatherQuery(q, timeout, timeUnit))\n+                .flatMapMany(this::processResultsInterceptors)\n+                .transform(this::getPayload);\n+    }\n+\n+    @Override\n+    public <Q, I, U> Mono<SubscriptionQueryResult<I, U>> subscriptionQuery(String queryName, Q query,\n+                                                                           ResponseType<I> initialResponseType,\n+                                                                           ResponseType<U> updateResponseType,\n+                                                                           SubscriptionQueryBackpressure backpressure,\n+                                                                           int updateBufferSize) {\n+\n+        //noinspection unchecked\n+        return Mono.<QueryMessage<?, ?>>fromCallable(() -> new GenericSubscriptionQueryMessage<>(query,\n+                                                                                                 initialResponseType,\n+                                                                                                 updateResponseType))\n+                .transform(this::processDispatchInterceptors)\n+                .map(isq -> (SubscriptionQueryMessage<Q, U, I>) isq)\n+                .flatMap(isq -> dispatchSubscriptionQuery(isq, backpressure, updateBufferSize))\n+                .flatMap(processSubscriptionQueryResult());\n+    }\n+\n+\n+    private Mono<Tuple2<QueryMessage<?, ?>, Flux<ResultMessage<?>>>> dispatchQuery(QueryMessage<?, ?> queryMessage) {\n+        Flux<ResultMessage<?>> results = Flux\n+                .defer(() -> Mono.fromFuture(queryBus.query(queryMessage)));\n+\n+        return Mono.<QueryMessage<?, ?>>just(queryMessage)\n+                .zipWith(Mono.just(results));\n+    }\n+\n+    private Mono<Tuple2<QueryMessage<?, ?>, Flux<ResultMessage<?>>>> dispatchScatterGatherQuery(\n+            QueryMessage<?, ?> queryMessage, long timeout, TimeUnit timeUnit) {\n+        Flux<ResultMessage<?>> results = Flux\n+                .defer(() -> Flux.fromStream(queryBus.scatterGather(queryMessage,\n+                                                                    timeout,\n+                                                                    timeUnit)));\n+\n+        return Mono.<QueryMessage<?, ?>>just(queryMessage)\n+                .zipWith(Mono.just(results));\n+    }\n+\n+    private <Q, I, U> Mono<Tuple2<QueryMessage<Q, I>, Mono<SubscriptionQueryResult<QueryResponseMessage<I>, SubscriptionQueryUpdateMessage<U>>>>> dispatchSubscriptionQuery(\n+            SubscriptionQueryMessage<Q, I, U> queryMessage, SubscriptionQueryBackpressure backpressure,\n+            int updateBufferSize) {\n+        Mono<SubscriptionQueryResult<QueryResponseMessage<I>, SubscriptionQueryUpdateMessage<U>>> result = Mono\n+                .fromCallable(() -> queryBus.subscriptionQuery(queryMessage, backpressure, updateBufferSize));\n+        return Mono.<QueryMessage<Q, I>>just(queryMessage)\n+                .zipWith(Mono.just(result));\n+    }\n+\n+    private Mono<QueryMessage<?, ?>> processDispatchInterceptors(Mono<QueryMessage<?, ?>> queryMessageMono) {\n+        return Flux.fromIterable(dispatchInterceptors)\n+                   .reduce(queryMessageMono, (queryMessage, interceptor) -> interceptor.intercept(queryMessage))\n+                   .flatMap(Mono::from);\n+    }\n+\n+    private Flux<ResultMessage<?>> processResultsInterceptors(\n+            Tuple2<QueryMessage<?, ?>, Flux<ResultMessage<?>>> queryWithResponses) {\n+        QueryMessage<?, ?> queryMessage = queryWithResponses.getT1();\n+        Flux<ResultMessage<?>> queryResultMessage = queryWithResponses.getT2();\n+\n+        return Flux.fromIterable(resultInterceptors)\n+                   .reduce(queryResultMessage,\n+                           (result, interceptor) -> interceptor.intercept(queryMessage, result))\n+                   .flatMapMany(it -> it);\n+    }\n+\n+    private <Q, I, U> Function<Tuple2<QueryMessage<Q, U>,\n+            Mono<SubscriptionQueryResult<QueryResponseMessage<U>, SubscriptionQueryUpdateMessage<I>>>>,\n+            Mono<SubscriptionQueryResult<I, U>>> processSubscriptionQueryResult() {\n+\n+        return messageWithResult -> messageWithResult.getT2().map(sqr -> {\n+            Mono<I> interceptedInitialResult = Mono.<QueryMessage<?, ?>>just(messageWithResult.getT1())\n+                    .zipWith(Mono.just(Flux.<ResultMessage<?>>from(sqr.initialResult())))\n+                    .flatMapMany(this::processResultsInterceptors)\n+                    .<I>transform(this::getPayload)\n+                    .next();\n+\n+            Flux<U> interceptedUpdates = Mono.<QueryMessage<?, ?>>just(messageWithResult.getT1())\n+                    .zipWith(Mono.just(sqr.updates().<ResultMessage<?>>map(it -> it)))\n+                    .flatMapMany(this::processResultsInterceptors)\n+                    .transform(this::getPayload);\n+\n+            return new DefaultSubscriptionQueryResult<>(interceptedInitialResult, interceptedUpdates, sqr);\n+        });\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    private <R> Flux<R> getPayload(Flux<ResultMessage<?>> resultMessageFlux) {\n+        return resultMessageFlux\n+                .flatMap(this::mapResult)\n+                .filter(r -> Objects.nonNull(r.getPayload()))\n+                .map(it -> (R) it.getPayload());\n+    }\n+\n+    private Flux<? extends ResultMessage<?>> mapResult(ResultMessage<?> response) {\n+        return response.isExceptional() ? Flux.error(response.exceptionResult()) : Flux.just(response);\n+    }\n+\n+    /**\n+     * Builder class to instantiate {@link DefaultReactorQueryGateway}.\n+     * <p>\n+     * The {@code dispatchInterceptors} are defaulted to an empty list.\n+     * The {@link QueryBus} is a <b>hard requirement</b> and as such should be provided.\n+     * </p>\n+     */\n+    public static class Builder {\n+\n+        private QueryBus queryBus;\n+        private List<ReactorMessageDispatchInterceptor<QueryMessage<?, ?>>> dispatchInterceptors = new CopyOnWriteArrayList<>();\n+        private List<ReactorResultHandlerInterceptor<QueryMessage<?, ?>, ResultMessage<?>>> resultInterceptors = new CopyOnWriteArrayList<>();\n+\n+        /**\n+         * Sets the {@link QueryBus} used to dispatch queries.\n+         *\n+         * @param queryBus a {@link QueryBus} used to dispatch queries\n+         * @return the current Builder instance, for fluent interfacing\n+         */\n+        public Builder queryBus(QueryBus queryBus) {\n+            assertNonNull(queryBus, \"QueryBus may not be null\");\n+            this.queryBus = queryBus;\n+            return this;\n+        }\n+\n+        /**\n+         * Sets {@link ReactorMessageDispatchInterceptor}s for {@link QueryMessage}s. Are invoked\n+         * when a query is being dispatched.\n+         *\n+         * @param dispatchInterceptors which are invoked when a query is being dispatched\n+         * @return the current Builder instance, for fluent interfacing\n+         */\n+        @SafeVarargs\n+        public final Builder dispatchInterceptors(\n+                ReactorMessageDispatchInterceptor<QueryMessage<?, ?>>... dispatchInterceptors) {\n+            return dispatchInterceptors(asList(dispatchInterceptors));\n+        }\n+\n+        /**\n+         * Sets the {@link List} of {@link ReactorMessageDispatchInterceptor}s for {@link QueryMessage}s. Are invoked\n+         * when a query is being dispatched.\n+         *\n+         * @param dispatchInterceptors which are invoked when a query is being dispatched\n+         * @return the current Builder instance, for fluent interfacing\n+         */\n+        public Builder dispatchInterceptors(\n+                List<ReactorMessageDispatchInterceptor<QueryMessage<?, ?>>> dispatchInterceptors) {\n+            this.dispatchInterceptors = dispatchInterceptors != null && dispatchInterceptors.isEmpty()\n+                    ? new CopyOnWriteArrayList<>(dispatchInterceptors)\n+                    : new CopyOnWriteArrayList<>();\n+            return this;\n+        }\n+\n+        /**\n+         * Sets {@link ReactorResultHandlerInterceptor}s for {@link CommandResultMessage}s.\n+         * Are invoked when a result has been received.\n+         *\n+         * @param resultInterceptors which are invoked when a result has been received\n+         * @return the current Builder instance, for fluent interfacing\n+         */\n+        @SafeVarargs\n+        public final Builder resultInterceptors(\n+                ReactorResultHandlerInterceptor<QueryMessage<?, ?>, ResultMessage<?>>... resultInterceptors) {\n+            return resultInterceptors(asList(resultInterceptors));\n+        }\n+\n+        /**\n+         * Sets the {@link List} of {@link ReactorResultHandlerInterceptor}s for {@link CommandResultMessage}s.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "98865ab1427e4d879301c1bf542842eccc8aa3c3"}, "originalPosition": 284}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgyMzM2MTk1OnYy", "diffSide": "RIGHT", "path": "messaging/src/main/java/org/axonframework/queryhandling/DefaultReactorQueryGateway.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xMFQxMjoyOTozNlrOGv1dqQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOFQwNzo1MToyMFrOG4A1Xg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjgxMjIwMQ==", "bodyText": "My personal preference would go to using interceptedQuery instead of isq. The abbreviation forces people to think what the original author meant with the name.", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r452812201", "createdAt": "2020-07-10T12:29:36Z", "author": {"login": "smcvb"}, "path": "messaging/src/main/java/org/axonframework/queryhandling/DefaultReactorQueryGateway.java", "diffHunk": "@@ -0,0 +1,318 @@\n+/*\n+ * Copyright (c) 2010-2020. Axon Framework\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.axonframework.queryhandling;\n+\n+import org.axonframework.commandhandling.CommandResultMessage;\n+import org.axonframework.common.AxonConfigurationException;\n+import org.axonframework.common.Registration;\n+import org.axonframework.messaging.ResultMessage;\n+import org.axonframework.messaging.reactive.ReactorMessageDispatchInterceptor;\n+import org.axonframework.messaging.reactive.ReactorResultHandlerInterceptor;\n+import org.axonframework.messaging.responsetypes.ResponseType;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Mono;\n+import reactor.util.function.Tuple2;\n+\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.concurrent.CopyOnWriteArrayList;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Function;\n+\n+import static java.util.Arrays.asList;\n+import static org.axonframework.common.BuilderUtils.assertNonNull;\n+import static org.axonframework.messaging.GenericMessage.asMessage;\n+\n+/**\n+ * Implementation of the {@link ReactorQueryGateway} that uses Project Reactor to achieve reactiveness.\n+ *\n+ * @author Milan Savic\n+ * @since 4.4\n+ */\n+public class DefaultReactorQueryGateway implements ReactorQueryGateway {\n+\n+    private final List<ReactorMessageDispatchInterceptor<QueryMessage<?, ?>>> dispatchInterceptors;\n+    private final List<ReactorResultHandlerInterceptor<QueryMessage<?, ?>, ResultMessage<?>>> resultInterceptors;\n+\n+    private final QueryBus queryBus;\n+\n+    /**\n+     * Creates an instance of {@link DefaultReactorQueryGateway} based on the fields contained in the {@link\n+     * Builder}.\n+     * <p>\n+     * Will assert that the {@link QueryBus} is not {@code null} and throws an {@link AxonConfigurationException} if\n+     * it is.\n+     * </p>\n+     *\n+     * @param builder the {@link Builder} used to instantiated a {@link DefaultReactorQueryGateway} instance\n+     */\n+    protected DefaultReactorQueryGateway(Builder builder) {\n+        builder.validate();\n+        this.queryBus = builder.queryBus;\n+        this.dispatchInterceptors = builder.dispatchInterceptors;\n+        this.resultInterceptors = builder.resultInterceptors;\n+    }\n+\n+    /**\n+     * Instantiate a Builder to be able to create a {@link DefaultReactorQueryGateway}.\n+     * <p>\n+     * The {@code dispatchInterceptors} are defaulted to an empty list.\n+     * The {@code resultHandlerInterceptors} are defaulted to an empty list.\n+     * The {@link QueryBus} is a <b>hard requirement</b> and as such should be provided.\n+     * </p>\n+     *\n+     * @return a Builder to be able to create a {@link DefaultReactorQueryGateway}\n+     */\n+    public static Builder builder() {\n+        return new Builder();\n+    }\n+\n+    @Override\n+    public Registration registerDispatchInterceptor(\n+            ReactorMessageDispatchInterceptor<QueryMessage<?, ?>> interceptor) {\n+        dispatchInterceptors.add(interceptor);\n+        return () -> dispatchInterceptors.remove(interceptor);\n+    }\n+\n+    @Override\n+    public Registration registerResultHandlerInterceptor(\n+            ReactorResultHandlerInterceptor<QueryMessage<?, ?>, ResultMessage<?>> interceptor) {\n+        resultInterceptors.add(interceptor);\n+        return () -> resultInterceptors.remove(interceptor);\n+    }\n+\n+    @Override\n+    public <R, Q> Mono<R> query(String queryName, Q query, ResponseType<R> responseType) {\n+        return Mono.<QueryMessage<?, ?>>fromCallable(() -> new GenericQueryMessage<>(asMessage(query),\n+                                                                                     queryName,\n+                                                                                     responseType))\n+                .transform(this::processDispatchInterceptors)\n+                .flatMap(this::dispatchQuery)\n+                .flatMapMany(this::processResultsInterceptors)\n+                .<R>transform(this::getPayload)\n+                .next();\n+    }\n+\n+    @Override\n+    public <R, Q> Flux<R> scatterGather(String queryName, Q query, ResponseType<R> responseType, long timeout,\n+                                        TimeUnit timeUnit) {\n+        return Mono.<QueryMessage<?, ?>>fromCallable(() -> new GenericQueryMessage<>(asMessage(query),\n+                                                                                     queryName,\n+                                                                                     responseType))\n+                .transform(this::processDispatchInterceptors)\n+                .flatMap(q -> dispatchScatterGatherQuery(q, timeout, timeUnit))\n+                .flatMapMany(this::processResultsInterceptors)\n+                .transform(this::getPayload);\n+    }\n+\n+    @Override\n+    public <Q, I, U> Mono<SubscriptionQueryResult<I, U>> subscriptionQuery(String queryName, Q query,\n+                                                                           ResponseType<I> initialResponseType,\n+                                                                           ResponseType<U> updateResponseType,\n+                                                                           SubscriptionQueryBackpressure backpressure,\n+                                                                           int updateBufferSize) {\n+\n+        //noinspection unchecked\n+        return Mono.<QueryMessage<?, ?>>fromCallable(() -> new GenericSubscriptionQueryMessage<>(query,\n+                                                                                                 initialResponseType,\n+                                                                                                 updateResponseType))\n+                .transform(this::processDispatchInterceptors)\n+                .map(isq -> (SubscriptionQueryMessage<Q, U, I>) isq)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "98865ab1427e4d879301c1bf542842eccc8aa3c3"}, "originalPosition": 134}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTM4NzEwMg==", "bodyText": "Sad to see this hasn't been discussed or altered, but just resolved ;-)", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r461387102", "createdAt": "2020-07-28T07:51:20Z", "author": {"login": "smcvb"}, "path": "messaging/src/main/java/org/axonframework/queryhandling/DefaultReactorQueryGateway.java", "diffHunk": "@@ -0,0 +1,318 @@\n+/*\n+ * Copyright (c) 2010-2020. Axon Framework\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.axonframework.queryhandling;\n+\n+import org.axonframework.commandhandling.CommandResultMessage;\n+import org.axonframework.common.AxonConfigurationException;\n+import org.axonframework.common.Registration;\n+import org.axonframework.messaging.ResultMessage;\n+import org.axonframework.messaging.reactive.ReactorMessageDispatchInterceptor;\n+import org.axonframework.messaging.reactive.ReactorResultHandlerInterceptor;\n+import org.axonframework.messaging.responsetypes.ResponseType;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Mono;\n+import reactor.util.function.Tuple2;\n+\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.concurrent.CopyOnWriteArrayList;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Function;\n+\n+import static java.util.Arrays.asList;\n+import static org.axonframework.common.BuilderUtils.assertNonNull;\n+import static org.axonframework.messaging.GenericMessage.asMessage;\n+\n+/**\n+ * Implementation of the {@link ReactorQueryGateway} that uses Project Reactor to achieve reactiveness.\n+ *\n+ * @author Milan Savic\n+ * @since 4.4\n+ */\n+public class DefaultReactorQueryGateway implements ReactorQueryGateway {\n+\n+    private final List<ReactorMessageDispatchInterceptor<QueryMessage<?, ?>>> dispatchInterceptors;\n+    private final List<ReactorResultHandlerInterceptor<QueryMessage<?, ?>, ResultMessage<?>>> resultInterceptors;\n+\n+    private final QueryBus queryBus;\n+\n+    /**\n+     * Creates an instance of {@link DefaultReactorQueryGateway} based on the fields contained in the {@link\n+     * Builder}.\n+     * <p>\n+     * Will assert that the {@link QueryBus} is not {@code null} and throws an {@link AxonConfigurationException} if\n+     * it is.\n+     * </p>\n+     *\n+     * @param builder the {@link Builder} used to instantiated a {@link DefaultReactorQueryGateway} instance\n+     */\n+    protected DefaultReactorQueryGateway(Builder builder) {\n+        builder.validate();\n+        this.queryBus = builder.queryBus;\n+        this.dispatchInterceptors = builder.dispatchInterceptors;\n+        this.resultInterceptors = builder.resultInterceptors;\n+    }\n+\n+    /**\n+     * Instantiate a Builder to be able to create a {@link DefaultReactorQueryGateway}.\n+     * <p>\n+     * The {@code dispatchInterceptors} are defaulted to an empty list.\n+     * The {@code resultHandlerInterceptors} are defaulted to an empty list.\n+     * The {@link QueryBus} is a <b>hard requirement</b> and as such should be provided.\n+     * </p>\n+     *\n+     * @return a Builder to be able to create a {@link DefaultReactorQueryGateway}\n+     */\n+    public static Builder builder() {\n+        return new Builder();\n+    }\n+\n+    @Override\n+    public Registration registerDispatchInterceptor(\n+            ReactorMessageDispatchInterceptor<QueryMessage<?, ?>> interceptor) {\n+        dispatchInterceptors.add(interceptor);\n+        return () -> dispatchInterceptors.remove(interceptor);\n+    }\n+\n+    @Override\n+    public Registration registerResultHandlerInterceptor(\n+            ReactorResultHandlerInterceptor<QueryMessage<?, ?>, ResultMessage<?>> interceptor) {\n+        resultInterceptors.add(interceptor);\n+        return () -> resultInterceptors.remove(interceptor);\n+    }\n+\n+    @Override\n+    public <R, Q> Mono<R> query(String queryName, Q query, ResponseType<R> responseType) {\n+        return Mono.<QueryMessage<?, ?>>fromCallable(() -> new GenericQueryMessage<>(asMessage(query),\n+                                                                                     queryName,\n+                                                                                     responseType))\n+                .transform(this::processDispatchInterceptors)\n+                .flatMap(this::dispatchQuery)\n+                .flatMapMany(this::processResultsInterceptors)\n+                .<R>transform(this::getPayload)\n+                .next();\n+    }\n+\n+    @Override\n+    public <R, Q> Flux<R> scatterGather(String queryName, Q query, ResponseType<R> responseType, long timeout,\n+                                        TimeUnit timeUnit) {\n+        return Mono.<QueryMessage<?, ?>>fromCallable(() -> new GenericQueryMessage<>(asMessage(query),\n+                                                                                     queryName,\n+                                                                                     responseType))\n+                .transform(this::processDispatchInterceptors)\n+                .flatMap(q -> dispatchScatterGatherQuery(q, timeout, timeUnit))\n+                .flatMapMany(this::processResultsInterceptors)\n+                .transform(this::getPayload);\n+    }\n+\n+    @Override\n+    public <Q, I, U> Mono<SubscriptionQueryResult<I, U>> subscriptionQuery(String queryName, Q query,\n+                                                                           ResponseType<I> initialResponseType,\n+                                                                           ResponseType<U> updateResponseType,\n+                                                                           SubscriptionQueryBackpressure backpressure,\n+                                                                           int updateBufferSize) {\n+\n+        //noinspection unchecked\n+        return Mono.<QueryMessage<?, ?>>fromCallable(() -> new GenericSubscriptionQueryMessage<>(query,\n+                                                                                                 initialResponseType,\n+                                                                                                 updateResponseType))\n+                .transform(this::processDispatchInterceptors)\n+                .map(isq -> (SubscriptionQueryMessage<Q, U, I>) isq)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjgxMjIwMQ=="}, "originalCommit": {"oid": "98865ab1427e4d879301c1bf542842eccc8aa3c3"}, "originalPosition": 134}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgyMzM2NDU5OnYy", "diffSide": "RIGHT", "path": "messaging/src/main/java/org/axonframework/queryhandling/DefaultReactorQueryGateway.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xMFQxMjozMDoyMVrOGv1fHg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMVQxMzo0OTo1NVrOG045-A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjgxMjU3NA==", "bodyText": "Daaaaamn what a signature. Almost calls for type aliases to make things human readable.", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r452812574", "createdAt": "2020-07-10T12:30:21Z", "author": {"login": "smcvb"}, "path": "messaging/src/main/java/org/axonframework/queryhandling/DefaultReactorQueryGateway.java", "diffHunk": "@@ -0,0 +1,318 @@\n+/*\n+ * Copyright (c) 2010-2020. Axon Framework\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.axonframework.queryhandling;\n+\n+import org.axonframework.commandhandling.CommandResultMessage;\n+import org.axonframework.common.AxonConfigurationException;\n+import org.axonframework.common.Registration;\n+import org.axonframework.messaging.ResultMessage;\n+import org.axonframework.messaging.reactive.ReactorMessageDispatchInterceptor;\n+import org.axonframework.messaging.reactive.ReactorResultHandlerInterceptor;\n+import org.axonframework.messaging.responsetypes.ResponseType;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Mono;\n+import reactor.util.function.Tuple2;\n+\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.concurrent.CopyOnWriteArrayList;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Function;\n+\n+import static java.util.Arrays.asList;\n+import static org.axonframework.common.BuilderUtils.assertNonNull;\n+import static org.axonframework.messaging.GenericMessage.asMessage;\n+\n+/**\n+ * Implementation of the {@link ReactorQueryGateway} that uses Project Reactor to achieve reactiveness.\n+ *\n+ * @author Milan Savic\n+ * @since 4.4\n+ */\n+public class DefaultReactorQueryGateway implements ReactorQueryGateway {\n+\n+    private final List<ReactorMessageDispatchInterceptor<QueryMessage<?, ?>>> dispatchInterceptors;\n+    private final List<ReactorResultHandlerInterceptor<QueryMessage<?, ?>, ResultMessage<?>>> resultInterceptors;\n+\n+    private final QueryBus queryBus;\n+\n+    /**\n+     * Creates an instance of {@link DefaultReactorQueryGateway} based on the fields contained in the {@link\n+     * Builder}.\n+     * <p>\n+     * Will assert that the {@link QueryBus} is not {@code null} and throws an {@link AxonConfigurationException} if\n+     * it is.\n+     * </p>\n+     *\n+     * @param builder the {@link Builder} used to instantiated a {@link DefaultReactorQueryGateway} instance\n+     */\n+    protected DefaultReactorQueryGateway(Builder builder) {\n+        builder.validate();\n+        this.queryBus = builder.queryBus;\n+        this.dispatchInterceptors = builder.dispatchInterceptors;\n+        this.resultInterceptors = builder.resultInterceptors;\n+    }\n+\n+    /**\n+     * Instantiate a Builder to be able to create a {@link DefaultReactorQueryGateway}.\n+     * <p>\n+     * The {@code dispatchInterceptors} are defaulted to an empty list.\n+     * The {@code resultHandlerInterceptors} are defaulted to an empty list.\n+     * The {@link QueryBus} is a <b>hard requirement</b> and as such should be provided.\n+     * </p>\n+     *\n+     * @return a Builder to be able to create a {@link DefaultReactorQueryGateway}\n+     */\n+    public static Builder builder() {\n+        return new Builder();\n+    }\n+\n+    @Override\n+    public Registration registerDispatchInterceptor(\n+            ReactorMessageDispatchInterceptor<QueryMessage<?, ?>> interceptor) {\n+        dispatchInterceptors.add(interceptor);\n+        return () -> dispatchInterceptors.remove(interceptor);\n+    }\n+\n+    @Override\n+    public Registration registerResultHandlerInterceptor(\n+            ReactorResultHandlerInterceptor<QueryMessage<?, ?>, ResultMessage<?>> interceptor) {\n+        resultInterceptors.add(interceptor);\n+        return () -> resultInterceptors.remove(interceptor);\n+    }\n+\n+    @Override\n+    public <R, Q> Mono<R> query(String queryName, Q query, ResponseType<R> responseType) {\n+        return Mono.<QueryMessage<?, ?>>fromCallable(() -> new GenericQueryMessage<>(asMessage(query),\n+                                                                                     queryName,\n+                                                                                     responseType))\n+                .transform(this::processDispatchInterceptors)\n+                .flatMap(this::dispatchQuery)\n+                .flatMapMany(this::processResultsInterceptors)\n+                .<R>transform(this::getPayload)\n+                .next();\n+    }\n+\n+    @Override\n+    public <R, Q> Flux<R> scatterGather(String queryName, Q query, ResponseType<R> responseType, long timeout,\n+                                        TimeUnit timeUnit) {\n+        return Mono.<QueryMessage<?, ?>>fromCallable(() -> new GenericQueryMessage<>(asMessage(query),\n+                                                                                     queryName,\n+                                                                                     responseType))\n+                .transform(this::processDispatchInterceptors)\n+                .flatMap(q -> dispatchScatterGatherQuery(q, timeout, timeUnit))\n+                .flatMapMany(this::processResultsInterceptors)\n+                .transform(this::getPayload);\n+    }\n+\n+    @Override\n+    public <Q, I, U> Mono<SubscriptionQueryResult<I, U>> subscriptionQuery(String queryName, Q query,\n+                                                                           ResponseType<I> initialResponseType,\n+                                                                           ResponseType<U> updateResponseType,\n+                                                                           SubscriptionQueryBackpressure backpressure,\n+                                                                           int updateBufferSize) {\n+\n+        //noinspection unchecked\n+        return Mono.<QueryMessage<?, ?>>fromCallable(() -> new GenericSubscriptionQueryMessage<>(query,\n+                                                                                                 initialResponseType,\n+                                                                                                 updateResponseType))\n+                .transform(this::processDispatchInterceptors)\n+                .map(isq -> (SubscriptionQueryMessage<Q, U, I>) isq)\n+                .flatMap(isq -> dispatchSubscriptionQuery(isq, backpressure, updateBufferSize))\n+                .flatMap(processSubscriptionQueryResult());\n+    }\n+\n+\n+    private Mono<Tuple2<QueryMessage<?, ?>, Flux<ResultMessage<?>>>> dispatchQuery(QueryMessage<?, ?> queryMessage) {\n+        Flux<ResultMessage<?>> results = Flux\n+                .defer(() -> Mono.fromFuture(queryBus.query(queryMessage)));\n+\n+        return Mono.<QueryMessage<?, ?>>just(queryMessage)\n+                .zipWith(Mono.just(results));\n+    }\n+\n+    private Mono<Tuple2<QueryMessage<?, ?>, Flux<ResultMessage<?>>>> dispatchScatterGatherQuery(\n+            QueryMessage<?, ?> queryMessage, long timeout, TimeUnit timeUnit) {\n+        Flux<ResultMessage<?>> results = Flux\n+                .defer(() -> Flux.fromStream(queryBus.scatterGather(queryMessage,\n+                                                                    timeout,\n+                                                                    timeUnit)));\n+\n+        return Mono.<QueryMessage<?, ?>>just(queryMessage)\n+                .zipWith(Mono.just(results));\n+    }\n+\n+    private <Q, I, U> Mono<Tuple2<QueryMessage<Q, I>, Mono<SubscriptionQueryResult<QueryResponseMessage<I>, SubscriptionQueryUpdateMessage<U>>>>> dispatchSubscriptionQuery(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "98865ab1427e4d879301c1bf542842eccc8aa3c3"}, "originalPosition": 159}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzcwNTA0NQ==", "bodyText": "not much we can do here, lot of complexity comes from how result interceptor works :/", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r453705045", "createdAt": "2020-07-13T14:48:17Z", "author": {"login": "schananas"}, "path": "messaging/src/main/java/org/axonframework/queryhandling/DefaultReactorQueryGateway.java", "diffHunk": "@@ -0,0 +1,318 @@\n+/*\n+ * Copyright (c) 2010-2020. Axon Framework\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.axonframework.queryhandling;\n+\n+import org.axonframework.commandhandling.CommandResultMessage;\n+import org.axonframework.common.AxonConfigurationException;\n+import org.axonframework.common.Registration;\n+import org.axonframework.messaging.ResultMessage;\n+import org.axonframework.messaging.reactive.ReactorMessageDispatchInterceptor;\n+import org.axonframework.messaging.reactive.ReactorResultHandlerInterceptor;\n+import org.axonframework.messaging.responsetypes.ResponseType;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Mono;\n+import reactor.util.function.Tuple2;\n+\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.concurrent.CopyOnWriteArrayList;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Function;\n+\n+import static java.util.Arrays.asList;\n+import static org.axonframework.common.BuilderUtils.assertNonNull;\n+import static org.axonframework.messaging.GenericMessage.asMessage;\n+\n+/**\n+ * Implementation of the {@link ReactorQueryGateway} that uses Project Reactor to achieve reactiveness.\n+ *\n+ * @author Milan Savic\n+ * @since 4.4\n+ */\n+public class DefaultReactorQueryGateway implements ReactorQueryGateway {\n+\n+    private final List<ReactorMessageDispatchInterceptor<QueryMessage<?, ?>>> dispatchInterceptors;\n+    private final List<ReactorResultHandlerInterceptor<QueryMessage<?, ?>, ResultMessage<?>>> resultInterceptors;\n+\n+    private final QueryBus queryBus;\n+\n+    /**\n+     * Creates an instance of {@link DefaultReactorQueryGateway} based on the fields contained in the {@link\n+     * Builder}.\n+     * <p>\n+     * Will assert that the {@link QueryBus} is not {@code null} and throws an {@link AxonConfigurationException} if\n+     * it is.\n+     * </p>\n+     *\n+     * @param builder the {@link Builder} used to instantiated a {@link DefaultReactorQueryGateway} instance\n+     */\n+    protected DefaultReactorQueryGateway(Builder builder) {\n+        builder.validate();\n+        this.queryBus = builder.queryBus;\n+        this.dispatchInterceptors = builder.dispatchInterceptors;\n+        this.resultInterceptors = builder.resultInterceptors;\n+    }\n+\n+    /**\n+     * Instantiate a Builder to be able to create a {@link DefaultReactorQueryGateway}.\n+     * <p>\n+     * The {@code dispatchInterceptors} are defaulted to an empty list.\n+     * The {@code resultHandlerInterceptors} are defaulted to an empty list.\n+     * The {@link QueryBus} is a <b>hard requirement</b> and as such should be provided.\n+     * </p>\n+     *\n+     * @return a Builder to be able to create a {@link DefaultReactorQueryGateway}\n+     */\n+    public static Builder builder() {\n+        return new Builder();\n+    }\n+\n+    @Override\n+    public Registration registerDispatchInterceptor(\n+            ReactorMessageDispatchInterceptor<QueryMessage<?, ?>> interceptor) {\n+        dispatchInterceptors.add(interceptor);\n+        return () -> dispatchInterceptors.remove(interceptor);\n+    }\n+\n+    @Override\n+    public Registration registerResultHandlerInterceptor(\n+            ReactorResultHandlerInterceptor<QueryMessage<?, ?>, ResultMessage<?>> interceptor) {\n+        resultInterceptors.add(interceptor);\n+        return () -> resultInterceptors.remove(interceptor);\n+    }\n+\n+    @Override\n+    public <R, Q> Mono<R> query(String queryName, Q query, ResponseType<R> responseType) {\n+        return Mono.<QueryMessage<?, ?>>fromCallable(() -> new GenericQueryMessage<>(asMessage(query),\n+                                                                                     queryName,\n+                                                                                     responseType))\n+                .transform(this::processDispatchInterceptors)\n+                .flatMap(this::dispatchQuery)\n+                .flatMapMany(this::processResultsInterceptors)\n+                .<R>transform(this::getPayload)\n+                .next();\n+    }\n+\n+    @Override\n+    public <R, Q> Flux<R> scatterGather(String queryName, Q query, ResponseType<R> responseType, long timeout,\n+                                        TimeUnit timeUnit) {\n+        return Mono.<QueryMessage<?, ?>>fromCallable(() -> new GenericQueryMessage<>(asMessage(query),\n+                                                                                     queryName,\n+                                                                                     responseType))\n+                .transform(this::processDispatchInterceptors)\n+                .flatMap(q -> dispatchScatterGatherQuery(q, timeout, timeUnit))\n+                .flatMapMany(this::processResultsInterceptors)\n+                .transform(this::getPayload);\n+    }\n+\n+    @Override\n+    public <Q, I, U> Mono<SubscriptionQueryResult<I, U>> subscriptionQuery(String queryName, Q query,\n+                                                                           ResponseType<I> initialResponseType,\n+                                                                           ResponseType<U> updateResponseType,\n+                                                                           SubscriptionQueryBackpressure backpressure,\n+                                                                           int updateBufferSize) {\n+\n+        //noinspection unchecked\n+        return Mono.<QueryMessage<?, ?>>fromCallable(() -> new GenericSubscriptionQueryMessage<>(query,\n+                                                                                                 initialResponseType,\n+                                                                                                 updateResponseType))\n+                .transform(this::processDispatchInterceptors)\n+                .map(isq -> (SubscriptionQueryMessage<Q, U, I>) isq)\n+                .flatMap(isq -> dispatchSubscriptionQuery(isq, backpressure, updateBufferSize))\n+                .flatMap(processSubscriptionQueryResult());\n+    }\n+\n+\n+    private Mono<Tuple2<QueryMessage<?, ?>, Flux<ResultMessage<?>>>> dispatchQuery(QueryMessage<?, ?> queryMessage) {\n+        Flux<ResultMessage<?>> results = Flux\n+                .defer(() -> Mono.fromFuture(queryBus.query(queryMessage)));\n+\n+        return Mono.<QueryMessage<?, ?>>just(queryMessage)\n+                .zipWith(Mono.just(results));\n+    }\n+\n+    private Mono<Tuple2<QueryMessage<?, ?>, Flux<ResultMessage<?>>>> dispatchScatterGatherQuery(\n+            QueryMessage<?, ?> queryMessage, long timeout, TimeUnit timeUnit) {\n+        Flux<ResultMessage<?>> results = Flux\n+                .defer(() -> Flux.fromStream(queryBus.scatterGather(queryMessage,\n+                                                                    timeout,\n+                                                                    timeUnit)));\n+\n+        return Mono.<QueryMessage<?, ?>>just(queryMessage)\n+                .zipWith(Mono.just(results));\n+    }\n+\n+    private <Q, I, U> Mono<Tuple2<QueryMessage<Q, I>, Mono<SubscriptionQueryResult<QueryResponseMessage<I>, SubscriptionQueryUpdateMessage<U>>>>> dispatchSubscriptionQuery(", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjgxMjU3NA=="}, "originalCommit": {"oid": "98865ab1427e4d879301c1bf542842eccc8aa3c3"}, "originalPosition": 159}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODExMTQ4MA==", "bodyText": "Yep...gotcha there. Just wanted to call it out so that it (hopefully) better sticks in our minds as \"something to improve when possible\".", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r458111480", "createdAt": "2020-07-21T13:49:55Z", "author": {"login": "smcvb"}, "path": "messaging/src/main/java/org/axonframework/queryhandling/DefaultReactorQueryGateway.java", "diffHunk": "@@ -0,0 +1,318 @@\n+/*\n+ * Copyright (c) 2010-2020. Axon Framework\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.axonframework.queryhandling;\n+\n+import org.axonframework.commandhandling.CommandResultMessage;\n+import org.axonframework.common.AxonConfigurationException;\n+import org.axonframework.common.Registration;\n+import org.axonframework.messaging.ResultMessage;\n+import org.axonframework.messaging.reactive.ReactorMessageDispatchInterceptor;\n+import org.axonframework.messaging.reactive.ReactorResultHandlerInterceptor;\n+import org.axonframework.messaging.responsetypes.ResponseType;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Mono;\n+import reactor.util.function.Tuple2;\n+\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.concurrent.CopyOnWriteArrayList;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Function;\n+\n+import static java.util.Arrays.asList;\n+import static org.axonframework.common.BuilderUtils.assertNonNull;\n+import static org.axonframework.messaging.GenericMessage.asMessage;\n+\n+/**\n+ * Implementation of the {@link ReactorQueryGateway} that uses Project Reactor to achieve reactiveness.\n+ *\n+ * @author Milan Savic\n+ * @since 4.4\n+ */\n+public class DefaultReactorQueryGateway implements ReactorQueryGateway {\n+\n+    private final List<ReactorMessageDispatchInterceptor<QueryMessage<?, ?>>> dispatchInterceptors;\n+    private final List<ReactorResultHandlerInterceptor<QueryMessage<?, ?>, ResultMessage<?>>> resultInterceptors;\n+\n+    private final QueryBus queryBus;\n+\n+    /**\n+     * Creates an instance of {@link DefaultReactorQueryGateway} based on the fields contained in the {@link\n+     * Builder}.\n+     * <p>\n+     * Will assert that the {@link QueryBus} is not {@code null} and throws an {@link AxonConfigurationException} if\n+     * it is.\n+     * </p>\n+     *\n+     * @param builder the {@link Builder} used to instantiated a {@link DefaultReactorQueryGateway} instance\n+     */\n+    protected DefaultReactorQueryGateway(Builder builder) {\n+        builder.validate();\n+        this.queryBus = builder.queryBus;\n+        this.dispatchInterceptors = builder.dispatchInterceptors;\n+        this.resultInterceptors = builder.resultInterceptors;\n+    }\n+\n+    /**\n+     * Instantiate a Builder to be able to create a {@link DefaultReactorQueryGateway}.\n+     * <p>\n+     * The {@code dispatchInterceptors} are defaulted to an empty list.\n+     * The {@code resultHandlerInterceptors} are defaulted to an empty list.\n+     * The {@link QueryBus} is a <b>hard requirement</b> and as such should be provided.\n+     * </p>\n+     *\n+     * @return a Builder to be able to create a {@link DefaultReactorQueryGateway}\n+     */\n+    public static Builder builder() {\n+        return new Builder();\n+    }\n+\n+    @Override\n+    public Registration registerDispatchInterceptor(\n+            ReactorMessageDispatchInterceptor<QueryMessage<?, ?>> interceptor) {\n+        dispatchInterceptors.add(interceptor);\n+        return () -> dispatchInterceptors.remove(interceptor);\n+    }\n+\n+    @Override\n+    public Registration registerResultHandlerInterceptor(\n+            ReactorResultHandlerInterceptor<QueryMessage<?, ?>, ResultMessage<?>> interceptor) {\n+        resultInterceptors.add(interceptor);\n+        return () -> resultInterceptors.remove(interceptor);\n+    }\n+\n+    @Override\n+    public <R, Q> Mono<R> query(String queryName, Q query, ResponseType<R> responseType) {\n+        return Mono.<QueryMessage<?, ?>>fromCallable(() -> new GenericQueryMessage<>(asMessage(query),\n+                                                                                     queryName,\n+                                                                                     responseType))\n+                .transform(this::processDispatchInterceptors)\n+                .flatMap(this::dispatchQuery)\n+                .flatMapMany(this::processResultsInterceptors)\n+                .<R>transform(this::getPayload)\n+                .next();\n+    }\n+\n+    @Override\n+    public <R, Q> Flux<R> scatterGather(String queryName, Q query, ResponseType<R> responseType, long timeout,\n+                                        TimeUnit timeUnit) {\n+        return Mono.<QueryMessage<?, ?>>fromCallable(() -> new GenericQueryMessage<>(asMessage(query),\n+                                                                                     queryName,\n+                                                                                     responseType))\n+                .transform(this::processDispatchInterceptors)\n+                .flatMap(q -> dispatchScatterGatherQuery(q, timeout, timeUnit))\n+                .flatMapMany(this::processResultsInterceptors)\n+                .transform(this::getPayload);\n+    }\n+\n+    @Override\n+    public <Q, I, U> Mono<SubscriptionQueryResult<I, U>> subscriptionQuery(String queryName, Q query,\n+                                                                           ResponseType<I> initialResponseType,\n+                                                                           ResponseType<U> updateResponseType,\n+                                                                           SubscriptionQueryBackpressure backpressure,\n+                                                                           int updateBufferSize) {\n+\n+        //noinspection unchecked\n+        return Mono.<QueryMessage<?, ?>>fromCallable(() -> new GenericSubscriptionQueryMessage<>(query,\n+                                                                                                 initialResponseType,\n+                                                                                                 updateResponseType))\n+                .transform(this::processDispatchInterceptors)\n+                .map(isq -> (SubscriptionQueryMessage<Q, U, I>) isq)\n+                .flatMap(isq -> dispatchSubscriptionQuery(isq, backpressure, updateBufferSize))\n+                .flatMap(processSubscriptionQueryResult());\n+    }\n+\n+\n+    private Mono<Tuple2<QueryMessage<?, ?>, Flux<ResultMessage<?>>>> dispatchQuery(QueryMessage<?, ?> queryMessage) {\n+        Flux<ResultMessage<?>> results = Flux\n+                .defer(() -> Mono.fromFuture(queryBus.query(queryMessage)));\n+\n+        return Mono.<QueryMessage<?, ?>>just(queryMessage)\n+                .zipWith(Mono.just(results));\n+    }\n+\n+    private Mono<Tuple2<QueryMessage<?, ?>, Flux<ResultMessage<?>>>> dispatchScatterGatherQuery(\n+            QueryMessage<?, ?> queryMessage, long timeout, TimeUnit timeUnit) {\n+        Flux<ResultMessage<?>> results = Flux\n+                .defer(() -> Flux.fromStream(queryBus.scatterGather(queryMessage,\n+                                                                    timeout,\n+                                                                    timeUnit)));\n+\n+        return Mono.<QueryMessage<?, ?>>just(queryMessage)\n+                .zipWith(Mono.just(results));\n+    }\n+\n+    private <Q, I, U> Mono<Tuple2<QueryMessage<Q, I>, Mono<SubscriptionQueryResult<QueryResponseMessage<I>, SubscriptionQueryUpdateMessage<U>>>>> dispatchSubscriptionQuery(", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjgxMjU3NA=="}, "originalCommit": {"oid": "98865ab1427e4d879301c1bf542842eccc8aa3c3"}, "originalPosition": 159}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgyMzM3NTIwOnYy", "diffSide": "RIGHT", "path": "messaging/src/main/java/org/axonframework/queryhandling/DefaultReactorQueryGateway.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xMFQxMjozMzoyOVrOGv1lbg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOFQwNzo1MDo0NlrOG4A0IA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjgxNDE5MA==", "bodyText": "My personal preference would go to using subscriptionResult instead of sqr. The abbreviation forces people to think what the original author meant with the name.", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r452814190", "createdAt": "2020-07-10T12:33:29Z", "author": {"login": "smcvb"}, "path": "messaging/src/main/java/org/axonframework/queryhandling/DefaultReactorQueryGateway.java", "diffHunk": "@@ -0,0 +1,318 @@\n+/*\n+ * Copyright (c) 2010-2020. Axon Framework\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.axonframework.queryhandling;\n+\n+import org.axonframework.commandhandling.CommandResultMessage;\n+import org.axonframework.common.AxonConfigurationException;\n+import org.axonframework.common.Registration;\n+import org.axonframework.messaging.ResultMessage;\n+import org.axonframework.messaging.reactive.ReactorMessageDispatchInterceptor;\n+import org.axonframework.messaging.reactive.ReactorResultHandlerInterceptor;\n+import org.axonframework.messaging.responsetypes.ResponseType;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Mono;\n+import reactor.util.function.Tuple2;\n+\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.concurrent.CopyOnWriteArrayList;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Function;\n+\n+import static java.util.Arrays.asList;\n+import static org.axonframework.common.BuilderUtils.assertNonNull;\n+import static org.axonframework.messaging.GenericMessage.asMessage;\n+\n+/**\n+ * Implementation of the {@link ReactorQueryGateway} that uses Project Reactor to achieve reactiveness.\n+ *\n+ * @author Milan Savic\n+ * @since 4.4\n+ */\n+public class DefaultReactorQueryGateway implements ReactorQueryGateway {\n+\n+    private final List<ReactorMessageDispatchInterceptor<QueryMessage<?, ?>>> dispatchInterceptors;\n+    private final List<ReactorResultHandlerInterceptor<QueryMessage<?, ?>, ResultMessage<?>>> resultInterceptors;\n+\n+    private final QueryBus queryBus;\n+\n+    /**\n+     * Creates an instance of {@link DefaultReactorQueryGateway} based on the fields contained in the {@link\n+     * Builder}.\n+     * <p>\n+     * Will assert that the {@link QueryBus} is not {@code null} and throws an {@link AxonConfigurationException} if\n+     * it is.\n+     * </p>\n+     *\n+     * @param builder the {@link Builder} used to instantiated a {@link DefaultReactorQueryGateway} instance\n+     */\n+    protected DefaultReactorQueryGateway(Builder builder) {\n+        builder.validate();\n+        this.queryBus = builder.queryBus;\n+        this.dispatchInterceptors = builder.dispatchInterceptors;\n+        this.resultInterceptors = builder.resultInterceptors;\n+    }\n+\n+    /**\n+     * Instantiate a Builder to be able to create a {@link DefaultReactorQueryGateway}.\n+     * <p>\n+     * The {@code dispatchInterceptors} are defaulted to an empty list.\n+     * The {@code resultHandlerInterceptors} are defaulted to an empty list.\n+     * The {@link QueryBus} is a <b>hard requirement</b> and as such should be provided.\n+     * </p>\n+     *\n+     * @return a Builder to be able to create a {@link DefaultReactorQueryGateway}\n+     */\n+    public static Builder builder() {\n+        return new Builder();\n+    }\n+\n+    @Override\n+    public Registration registerDispatchInterceptor(\n+            ReactorMessageDispatchInterceptor<QueryMessage<?, ?>> interceptor) {\n+        dispatchInterceptors.add(interceptor);\n+        return () -> dispatchInterceptors.remove(interceptor);\n+    }\n+\n+    @Override\n+    public Registration registerResultHandlerInterceptor(\n+            ReactorResultHandlerInterceptor<QueryMessage<?, ?>, ResultMessage<?>> interceptor) {\n+        resultInterceptors.add(interceptor);\n+        return () -> resultInterceptors.remove(interceptor);\n+    }\n+\n+    @Override\n+    public <R, Q> Mono<R> query(String queryName, Q query, ResponseType<R> responseType) {\n+        return Mono.<QueryMessage<?, ?>>fromCallable(() -> new GenericQueryMessage<>(asMessage(query),\n+                                                                                     queryName,\n+                                                                                     responseType))\n+                .transform(this::processDispatchInterceptors)\n+                .flatMap(this::dispatchQuery)\n+                .flatMapMany(this::processResultsInterceptors)\n+                .<R>transform(this::getPayload)\n+                .next();\n+    }\n+\n+    @Override\n+    public <R, Q> Flux<R> scatterGather(String queryName, Q query, ResponseType<R> responseType, long timeout,\n+                                        TimeUnit timeUnit) {\n+        return Mono.<QueryMessage<?, ?>>fromCallable(() -> new GenericQueryMessage<>(asMessage(query),\n+                                                                                     queryName,\n+                                                                                     responseType))\n+                .transform(this::processDispatchInterceptors)\n+                .flatMap(q -> dispatchScatterGatherQuery(q, timeout, timeUnit))\n+                .flatMapMany(this::processResultsInterceptors)\n+                .transform(this::getPayload);\n+    }\n+\n+    @Override\n+    public <Q, I, U> Mono<SubscriptionQueryResult<I, U>> subscriptionQuery(String queryName, Q query,\n+                                                                           ResponseType<I> initialResponseType,\n+                                                                           ResponseType<U> updateResponseType,\n+                                                                           SubscriptionQueryBackpressure backpressure,\n+                                                                           int updateBufferSize) {\n+\n+        //noinspection unchecked\n+        return Mono.<QueryMessage<?, ?>>fromCallable(() -> new GenericSubscriptionQueryMessage<>(query,\n+                                                                                                 initialResponseType,\n+                                                                                                 updateResponseType))\n+                .transform(this::processDispatchInterceptors)\n+                .map(isq -> (SubscriptionQueryMessage<Q, U, I>) isq)\n+                .flatMap(isq -> dispatchSubscriptionQuery(isq, backpressure, updateBufferSize))\n+                .flatMap(processSubscriptionQueryResult());\n+    }\n+\n+\n+    private Mono<Tuple2<QueryMessage<?, ?>, Flux<ResultMessage<?>>>> dispatchQuery(QueryMessage<?, ?> queryMessage) {\n+        Flux<ResultMessage<?>> results = Flux\n+                .defer(() -> Mono.fromFuture(queryBus.query(queryMessage)));\n+\n+        return Mono.<QueryMessage<?, ?>>just(queryMessage)\n+                .zipWith(Mono.just(results));\n+    }\n+\n+    private Mono<Tuple2<QueryMessage<?, ?>, Flux<ResultMessage<?>>>> dispatchScatterGatherQuery(\n+            QueryMessage<?, ?> queryMessage, long timeout, TimeUnit timeUnit) {\n+        Flux<ResultMessage<?>> results = Flux\n+                .defer(() -> Flux.fromStream(queryBus.scatterGather(queryMessage,\n+                                                                    timeout,\n+                                                                    timeUnit)));\n+\n+        return Mono.<QueryMessage<?, ?>>just(queryMessage)\n+                .zipWith(Mono.just(results));\n+    }\n+\n+    private <Q, I, U> Mono<Tuple2<QueryMessage<Q, I>, Mono<SubscriptionQueryResult<QueryResponseMessage<I>, SubscriptionQueryUpdateMessage<U>>>>> dispatchSubscriptionQuery(\n+            SubscriptionQueryMessage<Q, I, U> queryMessage, SubscriptionQueryBackpressure backpressure,\n+            int updateBufferSize) {\n+        Mono<SubscriptionQueryResult<QueryResponseMessage<I>, SubscriptionQueryUpdateMessage<U>>> result = Mono\n+                .fromCallable(() -> queryBus.subscriptionQuery(queryMessage, backpressure, updateBufferSize));\n+        return Mono.<QueryMessage<Q, I>>just(queryMessage)\n+                .zipWith(Mono.just(result));\n+    }\n+\n+    private Mono<QueryMessage<?, ?>> processDispatchInterceptors(Mono<QueryMessage<?, ?>> queryMessageMono) {\n+        return Flux.fromIterable(dispatchInterceptors)\n+                   .reduce(queryMessageMono, (queryMessage, interceptor) -> interceptor.intercept(queryMessage))\n+                   .flatMap(Mono::from);\n+    }\n+\n+    private Flux<ResultMessage<?>> processResultsInterceptors(\n+            Tuple2<QueryMessage<?, ?>, Flux<ResultMessage<?>>> queryWithResponses) {\n+        QueryMessage<?, ?> queryMessage = queryWithResponses.getT1();\n+        Flux<ResultMessage<?>> queryResultMessage = queryWithResponses.getT2();\n+\n+        return Flux.fromIterable(resultInterceptors)\n+                   .reduce(queryResultMessage,\n+                           (result, interceptor) -> interceptor.intercept(queryMessage, result))\n+                   .flatMapMany(it -> it);\n+    }\n+\n+    private <Q, I, U> Function<Tuple2<QueryMessage<Q, U>,\n+            Mono<SubscriptionQueryResult<QueryResponseMessage<U>, SubscriptionQueryUpdateMessage<I>>>>,\n+            Mono<SubscriptionQueryResult<I, U>>> processSubscriptionQueryResult() {\n+\n+        return messageWithResult -> messageWithResult.getT2().map(sqr -> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "98865ab1427e4d879301c1bf542842eccc8aa3c3"}, "originalPosition": 189}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTM4Njc4NA==", "bodyText": "Sad to see this hasn't been discussed or altered, but just resolved ;-)", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r461386784", "createdAt": "2020-07-28T07:50:46Z", "author": {"login": "smcvb"}, "path": "messaging/src/main/java/org/axonframework/queryhandling/DefaultReactorQueryGateway.java", "diffHunk": "@@ -0,0 +1,318 @@\n+/*\n+ * Copyright (c) 2010-2020. Axon Framework\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.axonframework.queryhandling;\n+\n+import org.axonframework.commandhandling.CommandResultMessage;\n+import org.axonframework.common.AxonConfigurationException;\n+import org.axonframework.common.Registration;\n+import org.axonframework.messaging.ResultMessage;\n+import org.axonframework.messaging.reactive.ReactorMessageDispatchInterceptor;\n+import org.axonframework.messaging.reactive.ReactorResultHandlerInterceptor;\n+import org.axonframework.messaging.responsetypes.ResponseType;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Mono;\n+import reactor.util.function.Tuple2;\n+\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.concurrent.CopyOnWriteArrayList;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Function;\n+\n+import static java.util.Arrays.asList;\n+import static org.axonframework.common.BuilderUtils.assertNonNull;\n+import static org.axonframework.messaging.GenericMessage.asMessage;\n+\n+/**\n+ * Implementation of the {@link ReactorQueryGateway} that uses Project Reactor to achieve reactiveness.\n+ *\n+ * @author Milan Savic\n+ * @since 4.4\n+ */\n+public class DefaultReactorQueryGateway implements ReactorQueryGateway {\n+\n+    private final List<ReactorMessageDispatchInterceptor<QueryMessage<?, ?>>> dispatchInterceptors;\n+    private final List<ReactorResultHandlerInterceptor<QueryMessage<?, ?>, ResultMessage<?>>> resultInterceptors;\n+\n+    private final QueryBus queryBus;\n+\n+    /**\n+     * Creates an instance of {@link DefaultReactorQueryGateway} based on the fields contained in the {@link\n+     * Builder}.\n+     * <p>\n+     * Will assert that the {@link QueryBus} is not {@code null} and throws an {@link AxonConfigurationException} if\n+     * it is.\n+     * </p>\n+     *\n+     * @param builder the {@link Builder} used to instantiated a {@link DefaultReactorQueryGateway} instance\n+     */\n+    protected DefaultReactorQueryGateway(Builder builder) {\n+        builder.validate();\n+        this.queryBus = builder.queryBus;\n+        this.dispatchInterceptors = builder.dispatchInterceptors;\n+        this.resultInterceptors = builder.resultInterceptors;\n+    }\n+\n+    /**\n+     * Instantiate a Builder to be able to create a {@link DefaultReactorQueryGateway}.\n+     * <p>\n+     * The {@code dispatchInterceptors} are defaulted to an empty list.\n+     * The {@code resultHandlerInterceptors} are defaulted to an empty list.\n+     * The {@link QueryBus} is a <b>hard requirement</b> and as such should be provided.\n+     * </p>\n+     *\n+     * @return a Builder to be able to create a {@link DefaultReactorQueryGateway}\n+     */\n+    public static Builder builder() {\n+        return new Builder();\n+    }\n+\n+    @Override\n+    public Registration registerDispatchInterceptor(\n+            ReactorMessageDispatchInterceptor<QueryMessage<?, ?>> interceptor) {\n+        dispatchInterceptors.add(interceptor);\n+        return () -> dispatchInterceptors.remove(interceptor);\n+    }\n+\n+    @Override\n+    public Registration registerResultHandlerInterceptor(\n+            ReactorResultHandlerInterceptor<QueryMessage<?, ?>, ResultMessage<?>> interceptor) {\n+        resultInterceptors.add(interceptor);\n+        return () -> resultInterceptors.remove(interceptor);\n+    }\n+\n+    @Override\n+    public <R, Q> Mono<R> query(String queryName, Q query, ResponseType<R> responseType) {\n+        return Mono.<QueryMessage<?, ?>>fromCallable(() -> new GenericQueryMessage<>(asMessage(query),\n+                                                                                     queryName,\n+                                                                                     responseType))\n+                .transform(this::processDispatchInterceptors)\n+                .flatMap(this::dispatchQuery)\n+                .flatMapMany(this::processResultsInterceptors)\n+                .<R>transform(this::getPayload)\n+                .next();\n+    }\n+\n+    @Override\n+    public <R, Q> Flux<R> scatterGather(String queryName, Q query, ResponseType<R> responseType, long timeout,\n+                                        TimeUnit timeUnit) {\n+        return Mono.<QueryMessage<?, ?>>fromCallable(() -> new GenericQueryMessage<>(asMessage(query),\n+                                                                                     queryName,\n+                                                                                     responseType))\n+                .transform(this::processDispatchInterceptors)\n+                .flatMap(q -> dispatchScatterGatherQuery(q, timeout, timeUnit))\n+                .flatMapMany(this::processResultsInterceptors)\n+                .transform(this::getPayload);\n+    }\n+\n+    @Override\n+    public <Q, I, U> Mono<SubscriptionQueryResult<I, U>> subscriptionQuery(String queryName, Q query,\n+                                                                           ResponseType<I> initialResponseType,\n+                                                                           ResponseType<U> updateResponseType,\n+                                                                           SubscriptionQueryBackpressure backpressure,\n+                                                                           int updateBufferSize) {\n+\n+        //noinspection unchecked\n+        return Mono.<QueryMessage<?, ?>>fromCallable(() -> new GenericSubscriptionQueryMessage<>(query,\n+                                                                                                 initialResponseType,\n+                                                                                                 updateResponseType))\n+                .transform(this::processDispatchInterceptors)\n+                .map(isq -> (SubscriptionQueryMessage<Q, U, I>) isq)\n+                .flatMap(isq -> dispatchSubscriptionQuery(isq, backpressure, updateBufferSize))\n+                .flatMap(processSubscriptionQueryResult());\n+    }\n+\n+\n+    private Mono<Tuple2<QueryMessage<?, ?>, Flux<ResultMessage<?>>>> dispatchQuery(QueryMessage<?, ?> queryMessage) {\n+        Flux<ResultMessage<?>> results = Flux\n+                .defer(() -> Mono.fromFuture(queryBus.query(queryMessage)));\n+\n+        return Mono.<QueryMessage<?, ?>>just(queryMessage)\n+                .zipWith(Mono.just(results));\n+    }\n+\n+    private Mono<Tuple2<QueryMessage<?, ?>, Flux<ResultMessage<?>>>> dispatchScatterGatherQuery(\n+            QueryMessage<?, ?> queryMessage, long timeout, TimeUnit timeUnit) {\n+        Flux<ResultMessage<?>> results = Flux\n+                .defer(() -> Flux.fromStream(queryBus.scatterGather(queryMessage,\n+                                                                    timeout,\n+                                                                    timeUnit)));\n+\n+        return Mono.<QueryMessage<?, ?>>just(queryMessage)\n+                .zipWith(Mono.just(results));\n+    }\n+\n+    private <Q, I, U> Mono<Tuple2<QueryMessage<Q, I>, Mono<SubscriptionQueryResult<QueryResponseMessage<I>, SubscriptionQueryUpdateMessage<U>>>>> dispatchSubscriptionQuery(\n+            SubscriptionQueryMessage<Q, I, U> queryMessage, SubscriptionQueryBackpressure backpressure,\n+            int updateBufferSize) {\n+        Mono<SubscriptionQueryResult<QueryResponseMessage<I>, SubscriptionQueryUpdateMessage<U>>> result = Mono\n+                .fromCallable(() -> queryBus.subscriptionQuery(queryMessage, backpressure, updateBufferSize));\n+        return Mono.<QueryMessage<Q, I>>just(queryMessage)\n+                .zipWith(Mono.just(result));\n+    }\n+\n+    private Mono<QueryMessage<?, ?>> processDispatchInterceptors(Mono<QueryMessage<?, ?>> queryMessageMono) {\n+        return Flux.fromIterable(dispatchInterceptors)\n+                   .reduce(queryMessageMono, (queryMessage, interceptor) -> interceptor.intercept(queryMessage))\n+                   .flatMap(Mono::from);\n+    }\n+\n+    private Flux<ResultMessage<?>> processResultsInterceptors(\n+            Tuple2<QueryMessage<?, ?>, Flux<ResultMessage<?>>> queryWithResponses) {\n+        QueryMessage<?, ?> queryMessage = queryWithResponses.getT1();\n+        Flux<ResultMessage<?>> queryResultMessage = queryWithResponses.getT2();\n+\n+        return Flux.fromIterable(resultInterceptors)\n+                   .reduce(queryResultMessage,\n+                           (result, interceptor) -> interceptor.intercept(queryMessage, result))\n+                   .flatMapMany(it -> it);\n+    }\n+\n+    private <Q, I, U> Function<Tuple2<QueryMessage<Q, U>,\n+            Mono<SubscriptionQueryResult<QueryResponseMessage<U>, SubscriptionQueryUpdateMessage<I>>>>,\n+            Mono<SubscriptionQueryResult<I, U>>> processSubscriptionQueryResult() {\n+\n+        return messageWithResult -> messageWithResult.getT2().map(sqr -> {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjgxNDE5MA=="}, "originalCommit": {"oid": "98865ab1427e4d879301c1bf542842eccc8aa3c3"}, "originalPosition": 189}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgyMzQ4MDU5OnYy", "diffSide": "RIGHT", "path": "messaging/src/test/java/org/axonframework/queryhandling/DefaultReactorQueryGatewayTest.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xMFQxMzowNjowOFrOGv2lsA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOFQwNzo1OToxMFrOG4BG4w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjgzMDY0MA==", "bodyText": "Curious/nit: Why is the lambda variable a p for the QueryUpdateEmitter#complete call? Shouldn't that be a q too?", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r452830640", "createdAt": "2020-07-10T13:06:08Z", "author": {"login": "smcvb"}, "path": "messaging/src/test/java/org/axonframework/queryhandling/DefaultReactorQueryGatewayTest.java", "diffHunk": "@@ -0,0 +1,780 @@\n+/*\n+ * Copyright (c) 2010-2020. Axon Framework\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.axonframework.queryhandling;\n+\n+import org.axonframework.common.Registration;\n+import org.axonframework.messaging.MessageHandler;\n+import org.axonframework.messaging.ResultMessage;\n+import org.axonframework.messaging.responsetypes.ResponseTypes;\n+import org.junit.jupiter.api.*;\n+import org.junit.jupiter.api.extension.*;\n+import org.mockito.junit.jupiter.*;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Hooks;\n+import reactor.core.publisher.Mono;\n+import reactor.test.StepVerifier;\n+import reactor.util.context.Context;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+\n+import static org.axonframework.common.ReflectionUtils.methodOf;\n+import static org.junit.jupiter.api.Assertions.*;\n+import static org.mockito.Mockito.*;\n+\n+/**\n+ * Tests for {@link DefaultReactorQueryGateway}.\n+ *\n+ * @author Milan Savic\n+ */\n+@ExtendWith(MockitoExtension.class)\n+class DefaultReactorQueryGatewayTest {\n+\n+    private DefaultReactorQueryGateway reactiveQueryGateway;\n+    private QueryUpdateEmitter queryUpdateEmitter;\n+    private MessageHandler<QueryMessage<?, Object>> queryMessageHandler1;\n+    private MessageHandler<QueryMessage<?, Object>> queryMessageHandler2;\n+    private MessageHandler<QueryMessage<?, Object>> queryMessageHandler3;\n+    private SimpleQueryBus queryBus;\n+\n+    @BeforeEach\n+    void setUp() throws NoSuchMethodException {\n+        Hooks.enableContextLossTracking();\n+        Hooks.onOperatorDebug();\n+\n+        queryBus = spy(SimpleQueryBus.builder().build());\n+\n+        queryUpdateEmitter = queryBus.queryUpdateEmitter();\n+        AtomicInteger count = new AtomicInteger();\n+        queryMessageHandler1 = spy(new MessageHandler<QueryMessage<?, Object>>() {\n+\n+            @Override\n+            public Object handle(QueryMessage<?, Object> message) {\n+                if (\"backpressure\".equals(message.getPayload())) {\n+                    return count.incrementAndGet();\n+                }\n+                return \"handled\";\n+            }\n+        });\n+        queryMessageHandler2 = spy(new MessageHandler<QueryMessage<?, Object>>() {\n+            @Override\n+            public Object handle(QueryMessage<?, Object> message) {\n+                if (\"backpressure\".equals(message.getPayload())) {\n+                    return count.incrementAndGet();\n+                }\n+                return \"handled\";\n+            }\n+        });\n+\n+        queryMessageHandler3 = spy(new MessageHandler<QueryMessage<?, Object>>() {\n+            @Override\n+            public Object handle(QueryMessage<?, Object> message) {\n+                throw new RuntimeException();\n+            }\n+        });\n+\n+        queryBus.subscribe(String.class.getName(), String.class, queryMessageHandler1);\n+        queryBus.subscribe(String.class.getName(), String.class, queryMessageHandler2);\n+        queryBus.subscribe(Integer.class.getName(), Integer.class, queryMessageHandler3);\n+\n+        queryBus.subscribe(Boolean.class.getName(),\n+                           String.class,\n+                           message -> \"\" + message.getMetaData().getOrDefault(\"key1\", \"\")\n+                                   + message.getMetaData().getOrDefault(\"key2\", \"\"));\n+\n+        queryBus.subscribe(Long.class.getName(), String.class, message -> null);\n+\n+        queryBus.subscribe(Double.class.getName(),\n+                           methodOf(this.getClass(), \"stringListQueryHandler\").getGenericReturnType(),\n+                           message -> Arrays.asList(\"value1\", \"value2\", \"value3\"));\n+\n+        reactiveQueryGateway = DefaultReactorQueryGateway.builder()\n+                                                         .queryBus(queryBus)\n+                                                         .build();\n+    }\n+\n+    @SuppressWarnings(\"unused\") // Used by 'testSubscriptionQueryMany()' to generate query handler response type\n+    public List<String> stringListQueryHandler() {\n+        return new ArrayList<>();\n+    }\n+\n+    @Test\n+    void testQuery() throws Exception {\n+\n+        Mono<String> result = reactiveQueryGateway.query(\"criteria\", String.class);\n+        verifyZeroInteractions(queryMessageHandler1);\n+        verifyZeroInteractions(queryMessageHandler2);\n+        StepVerifier.create(result)\n+                    .expectNext(\"handled\")\n+                    .verifyComplete();\n+        verify(queryMessageHandler1).handle(any());\n+    }\n+\n+    @Test\n+    void testQueryWithContext() throws Exception {\n+        Context context = Context.of(\"k1\", \"v1\");\n+\n+        Mono<String> result = reactiveQueryGateway.query(\"criteria\", String.class).subscriberContext(context);\n+\n+        verifyZeroInteractions(queryMessageHandler1);\n+        verifyZeroInteractions(queryMessageHandler2);\n+        StepVerifier.create(result)\n+                    .expectNext(\"handled\")\n+                    .expectAccessibleContext()\n+                    .containsOnly(context)\n+                    .then()\n+                    .verifyComplete();\n+        verify(queryMessageHandler1).handle(any());\n+    }\n+\n+    @Test\n+    void testMultipleQueries() throws Exception {\n+        Flux<QueryMessage<?, ?>> queries = Flux.fromIterable(Arrays.asList(\n+                new GenericQueryMessage<>(\"query1\", ResponseTypes.instanceOf(String.class)),\n+                new GenericQueryMessage<>(4, ResponseTypes.instanceOf(Integer.class)),\n+                new GenericQueryMessage<>(\"query2\", ResponseTypes.instanceOf(String.class)),\n+                new GenericQueryMessage<>(5, ResponseTypes.instanceOf(Integer.class)),\n+                new GenericQueryMessage<>(true, ResponseTypes.instanceOf(String.class))));\n+\n+        Flux<Object> result = reactiveQueryGateway.query(queries);\n+        verifyZeroInteractions(queryMessageHandler1);\n+        verifyZeroInteractions(queryMessageHandler2);\n+\n+        List<Throwable> exceptions = new ArrayList<>(2);\n+        StepVerifier.create(result.onErrorContinue((t, o) -> exceptions.add(t)))\n+                    .expectNext(\"handled\", \"handled\", \"\")\n+                    .verifyComplete();\n+\n+        assertEquals(2, exceptions.size());\n+        assertTrue(exceptions.get(0) instanceof RuntimeException);\n+        assertTrue(exceptions.get(1) instanceof RuntimeException);\n+        verify(queryMessageHandler1, times(2)).handle(any());\n+    }\n+\n+    @Test\n+    void testMultipleQueriesOrdering() throws Exception {\n+        int numberOfQueries = 10_000;\n+        Flux<QueryMessage<?, ?>> queries = Flux\n+                .fromStream(IntStream.range(0, numberOfQueries)\n+                                     .mapToObj(i -> new GenericQueryMessage<>(\"backpressure\",\n+                                                                              ResponseTypes.instanceOf(String.class))));\n+        List<Integer> expectedResults = IntStream.range(1, numberOfQueries + 1)\n+                                                 .boxed()\n+                                                 .collect(Collectors.toList());\n+        Flux<Object> result = reactiveQueryGateway.query(queries);\n+        StepVerifier.create(result)\n+                    .expectNext(expectedResults.toArray(new Integer[0]))\n+                    .verifyComplete();\n+        verify(queryMessageHandler1, times(numberOfQueries)).handle(any());\n+    }\n+\n+    @Test\n+    void testQueryReturningNull() {\n+        assertNull(reactiveQueryGateway.query(0L, String.class).block());\n+        StepVerifier.create(reactiveQueryGateway.query(0L, String.class))\n+                    .expectComplete()\n+                    .verify();\n+    }\n+\n+    @Test\n+    void testQueryWithDispatchInterceptor() {\n+        reactiveQueryGateway\n+                .registerDispatchInterceptor(queryMono -> queryMono\n+                        .map(query -> query.andMetaData(Collections.singletonMap(\"key1\", \"value1\"))));\n+        Registration registration2 = reactiveQueryGateway\n+                .registerDispatchInterceptor(queryMono -> queryMono\n+                        .map(query -> query.andMetaData(Collections.singletonMap(\"key2\", \"value2\"))));\n+\n+        StepVerifier.create(reactiveQueryGateway.query(true, String.class))\n+                    .expectNext(\"value1value2\")\n+                    .verifyComplete();\n+\n+        registration2.cancel();\n+\n+        StepVerifier.create(reactiveQueryGateway.query(true, String.class))\n+                    .expectNext(\"value1\")\n+                    .verifyComplete();\n+    }\n+\n+    @Test\n+    void testQueryWithDispatchInterceptorWithContext() {\n+        Context context = Context.of(\"security\", true);\n+\n+        reactiveQueryGateway\n+                .registerDispatchInterceptor(queryMono -> queryMono\n+                        .filterWhen(v -> Mono.subscriberContext()\n+                                             .filter(ctx -> ctx.hasKey(\"security\"))\n+                                             .map(ctx -> ctx.get(\"security\")))\n+                        .map(query -> query.andMetaData(Collections.singletonMap(\"key1\", \"value1\"))));\n+\n+        StepVerifier.create(reactiveQueryGateway.query(true, String.class).subscriberContext(context))\n+                    .expectNext(\"value1\")\n+                    .expectAccessibleContext()\n+                    .containsOnly(context)\n+                    .then()\n+                    .verifyComplete();\n+    }\n+\n+    @Test\n+    void testQueryWithResultInterceptorAlterResult() throws Exception {\n+        reactiveQueryGateway.registerResultHandlerInterceptor((q, results) -> results\n+                .map(it -> new GenericQueryResponseMessage<>(\"handled-modified\")));\n+\n+        Mono<String> result = reactiveQueryGateway.query(\"criteria\", String.class);\n+        verifyZeroInteractions(queryMessageHandler1);\n+        verifyZeroInteractions(queryMessageHandler2);\n+        StepVerifier.create(result)\n+                    .expectNext(\"handled-modified\")\n+                    .verifyComplete();\n+        verify(queryMessageHandler1).handle(any());\n+    }\n+\n+    @Test\n+    void testQueryWithResultInterceptorFilterResult() throws Exception {\n+        reactiveQueryGateway.registerResultHandlerInterceptor((q, results) -> results\n+                .filter(it -> !it.getPayload().equals(\"handled\")));\n+\n+        Mono<String> result = reactiveQueryGateway.query(\"criteria\", String.class);\n+        verifyZeroInteractions(queryMessageHandler1);\n+        verifyZeroInteractions(queryMessageHandler2);\n+        StepVerifier.create(result)\n+                    .expectComplete()\n+                    .verify();\n+        verify(queryMessageHandler1).handle(any());\n+    }\n+\n+    @Test\n+    void testQueryWithDispatchInterceptorThrowingAnException() {\n+        reactiveQueryGateway\n+                .registerDispatchInterceptor(queryMono -> {\n+                    throw new RuntimeException();\n+                });\n+        StepVerifier.create(reactiveQueryGateway.query(true, String.class))\n+                    .verifyError(RuntimeException.class);\n+    }\n+\n+    @Test\n+    void testQueryWithDispatchInterceptorReturningErrorMono() {\n+        reactiveQueryGateway\n+                .registerDispatchInterceptor(queryMono -> Mono.error(new RuntimeException()));\n+        StepVerifier.create(reactiveQueryGateway.query(true, String.class))\n+                    .verifyError(RuntimeException.class);\n+    }\n+\n+    @Test\n+    void testQueryFails() {\n+        StepVerifier.create(reactiveQueryGateway.query(5, Integer.class))\n+                    .verifyError(RuntimeException.class);\n+    }\n+\n+    @Test\n+    void testQueryFailsWithRetry() throws Exception {\n+\n+        Mono<Integer> query = reactiveQueryGateway.query(5, Integer.class).retry(5);\n+\n+        StepVerifier.create(query)\n+                    .verifyError(RuntimeException.class);\n+\n+        verify(queryMessageHandler3, times(6)).handle(any());\n+    }\n+\n+\n+    @Test\n+    void testScatterGather() throws Exception {\n+        Flux<String> result = reactiveQueryGateway.scatterGather(\"criteria\",\n+                                                                 ResponseTypes.instanceOf(String.class),\n+                                                                 1,\n+                                                                 TimeUnit.SECONDS);\n+        verifyZeroInteractions(queryMessageHandler1);\n+        verifyZeroInteractions(queryMessageHandler2);\n+        StepVerifier.create(result)\n+                    .expectNext(\"handled\", \"handled\")\n+                    .verifyComplete();\n+        verify(queryMessageHandler1).handle(any());\n+        verify(queryMessageHandler2).handle(any());\n+    }\n+\n+    @Test\n+    void testMultipleScatterGather() throws Exception {\n+        Flux<QueryMessage<?, ?>> queries = Flux.fromIterable(Arrays.asList(\n+                new GenericQueryMessage<>(\"query1\", ResponseTypes.instanceOf(String.class)),\n+                new GenericQueryMessage<>(4, ResponseTypes.instanceOf(Integer.class)),\n+                new GenericQueryMessage<>(\"query2\", ResponseTypes.instanceOf(String.class)),\n+                new GenericQueryMessage<>(5, ResponseTypes.instanceOf(Integer.class)),\n+                new GenericQueryMessage<>(true, ResponseTypes.instanceOf(String.class))));\n+\n+        Flux<Object> result = reactiveQueryGateway.scatterGather(queries, 1, TimeUnit.SECONDS);\n+        verifyZeroInteractions(queryMessageHandler1);\n+        verifyZeroInteractions(queryMessageHandler2);\n+\n+        StepVerifier.create(result)\n+                    .expectNext(\"handled\", \"handled\", \"handled\", \"handled\", \"\")\n+                    .verifyComplete();\n+\n+        verify(queryMessageHandler1, times(2)).handle(any());\n+        verify(queryMessageHandler2, times(2)).handle(any());\n+    }\n+\n+    @Test\n+    void testMultipleScatterGatherOrdering() throws Exception {\n+        int numberOfQueries = 10_000;\n+        Flux<QueryMessage<?, ?>> queries = Flux\n+                .fromStream(IntStream.range(0, numberOfQueries)\n+                                     .mapToObj(i -> new GenericQueryMessage<>(\"backpressure\",\n+                                                                              ResponseTypes.instanceOf(String.class))));\n+        List<Integer> expectedResults = IntStream.range(1, 2 * numberOfQueries + 1)\n+                                                 .boxed()\n+                                                 .collect(Collectors.toList());\n+        Flux<Object> result = reactiveQueryGateway.scatterGather(queries, 1, TimeUnit.SECONDS);\n+        StepVerifier.create(result)\n+                    .expectNext(expectedResults.toArray(new Integer[0]))\n+                    .verifyComplete();\n+        verify(queryMessageHandler1, times(numberOfQueries)).handle(any());\n+        verify(queryMessageHandler2, times(numberOfQueries)).handle(any());\n+    }\n+\n+    @Test\n+    void testScatterGatherReturningNull() {\n+        assertNull(reactiveQueryGateway.scatterGather(0L, ResponseTypes.instanceOf(String.class), 1, TimeUnit.SECONDS)\n+                                       .blockFirst());\n+        StepVerifier.create(reactiveQueryGateway\n+                                    .scatterGather(0L, ResponseTypes.instanceOf(String.class), 1, TimeUnit.SECONDS))\n+                    .expectNext()\n+                    .verifyComplete();\n+    }\n+\n+    @Test\n+    void testScatterGatherWithDispatchInterceptor() {\n+        reactiveQueryGateway\n+                .registerDispatchInterceptor(queryMono -> queryMono\n+                        .map(query -> query.andMetaData(Collections.singletonMap(\"key1\", \"value1\"))));\n+        Registration registration2 = reactiveQueryGateway\n+                .registerDispatchInterceptor(queryMono -> queryMono\n+                        .map(query -> query.andMetaData(Collections.singletonMap(\"key2\", \"value2\"))));\n+\n+        StepVerifier.create(reactiveQueryGateway\n+                                    .scatterGather(true, ResponseTypes.instanceOf(String.class), 1, TimeUnit.SECONDS))\n+                    .expectNext(\"value1value2\")\n+                    .verifyComplete();\n+\n+        registration2.cancel();\n+\n+        StepVerifier.create(reactiveQueryGateway.query(true, String.class))\n+                    .expectNext(\"value1\")\n+                    .verifyComplete();\n+    }\n+\n+    @Test\n+    void testScatterGatherWithResultIntercept() throws Exception {\n+        reactiveQueryGateway\n+                .registerResultHandlerInterceptor(\n+                        (query, results) -> results\n+                                .map(it -> new GenericQueryResponseMessage<>(\"handled-modified\"))\n+                );\n+\n+        Flux<QueryMessage<?, ?>> queries = Flux.fromIterable(Arrays.asList(\n+                new GenericQueryMessage<>(\"query1\", ResponseTypes.instanceOf(String.class)),\n+                new GenericQueryMessage<>(4, ResponseTypes.instanceOf(Integer.class)),\n+                new GenericQueryMessage<>(\"query2\", ResponseTypes.instanceOf(String.class)),\n+                new GenericQueryMessage<>(5, ResponseTypes.instanceOf(Integer.class)),\n+                new GenericQueryMessage<>(true, ResponseTypes.instanceOf(String.class))));\n+\n+        Flux<Object> result = reactiveQueryGateway.scatterGather(queries, 1, TimeUnit.SECONDS);\n+        verifyZeroInteractions(queryMessageHandler1);\n+        verifyZeroInteractions(queryMessageHandler2);\n+\n+        StepVerifier.create(result)\n+                    .expectNext(\"handled-modified\",\n+                                \"handled-modified\",\n+                                \"handled-modified\",\n+                                \"handled-modified\",\n+                                \"handled-modified\")\n+                    .verifyComplete();\n+\n+        verify(queryMessageHandler1, times(2)).handle(any());\n+        verify(queryMessageHandler2, times(2)).handle(any());\n+    }\n+\n+    @Test\n+    void testQueryWithResultInterceptorModifyResultBasedOnQuery() throws Exception {\n+        reactiveQueryGateway.registerDispatchInterceptor(q -> q.map(it ->\n+                                                                            it.andMetaData(Collections.singletonMap(\n+                                                                                    \"block\",\n+                                                                                    it.getPayload() instanceof Boolean)\n+                                                                            )));\n+        reactiveQueryGateway\n+                .registerResultHandlerInterceptor((q, results) -> results\n+                        .filter(it -> !((boolean) q.getMetaData().get(\"block\")))\n+                );\n+\n+        Flux<QueryMessage<?, ?>> queries = Flux.fromIterable(Arrays.asList(\n+                new GenericQueryMessage<>(\"query1\", ResponseTypes.instanceOf(String.class)),\n+                new GenericQueryMessage<>(4, ResponseTypes.instanceOf(Integer.class)),\n+                new GenericQueryMessage<>(\"query2\", ResponseTypes.instanceOf(String.class)),\n+                new GenericQueryMessage<>(5, ResponseTypes.instanceOf(Integer.class)),\n+                new GenericQueryMessage<>(Boolean.TRUE, ResponseTypes.instanceOf(String.class))));\n+\n+        Flux<Object> result = reactiveQueryGateway.scatterGather(queries, 1, TimeUnit.SECONDS);\n+        verifyZeroInteractions(queryMessageHandler1);\n+        verifyZeroInteractions(queryMessageHandler2);\n+\n+        StepVerifier.create(result)\n+                    .expectNext(\"handled\", \"handled\", \"handled\", \"handled\")\n+                    .verifyComplete();\n+\n+        verify(queryMessageHandler1, times(2)).handle(any());\n+        verify(queryMessageHandler2, times(2)).handle(any());\n+    }\n+\n+    @Test\n+    void testScatterGatherWithResultInterceptReplacedWithError() throws Exception {\n+        reactiveQueryGateway\n+                .registerResultHandlerInterceptor(\n+                        (query, results) -> results.flatMap(r -> {\n+                            if (r.getPayload().equals(\"\")) {\n+                                return Flux.<ResultMessage<?>>error(new RuntimeException(\"no empty strings allowed\"));\n+                            } else {\n+                                return Flux.just(r);\n+                            }\n+                        })\n+                );\n+\n+        Flux<QueryMessage<?, ?>> queries = Flux.fromIterable(Arrays.asList(\n+                new GenericQueryMessage<>(\"query1\", ResponseTypes.instanceOf(String.class)),\n+                new GenericQueryMessage<>(4, ResponseTypes.instanceOf(Integer.class)),\n+                new GenericQueryMessage<>(\"query2\", ResponseTypes.instanceOf(String.class)),\n+                new GenericQueryMessage<>(5, ResponseTypes.instanceOf(Integer.class)),\n+                new GenericQueryMessage<>(true, ResponseTypes.instanceOf(String.class))));\n+\n+        Flux<Object> result = reactiveQueryGateway.scatterGather(queries, 1, TimeUnit.SECONDS);\n+        verifyZeroInteractions(queryMessageHandler1);\n+        verifyZeroInteractions(queryMessageHandler2);\n+\n+        StepVerifier.create(result)\n+                    .expectNext(\"handled\", \"handled\", \"handled\", \"handled\")\n+                    .expectError(RuntimeException.class)\n+                    .verify();\n+\n+        verify(queryMessageHandler1, times(2)).handle(any());\n+        verify(queryMessageHandler2, times(2)).handle(any());\n+    }\n+\n+    @Test\n+    void testScatterGatherWithDispatchInterceptorThrowingAnException() {\n+        reactiveQueryGateway\n+                .registerDispatchInterceptor(queryMono -> {\n+                    throw new RuntimeException();\n+                });\n+        StepVerifier.create(reactiveQueryGateway\n+                                    .scatterGather(true, ResponseTypes.instanceOf(String.class), 1, TimeUnit.SECONDS))\n+                    .verifyError(RuntimeException.class);\n+    }\n+\n+    @Test\n+    void testScatterGatherWithDispatchInterceptorReturningErrorMono() {\n+        reactiveQueryGateway\n+                .registerDispatchInterceptor(queryMono -> Mono.error(new RuntimeException()));\n+        StepVerifier.create(reactiveQueryGateway\n+                                    .scatterGather(true, ResponseTypes.instanceOf(String.class), 1, TimeUnit.SECONDS))\n+                    .verifyError(RuntimeException.class);\n+    }\n+\n+    @Test\n+    void testScatterGatherFails() {\n+        StepVerifier.create(reactiveQueryGateway.scatterGather(6,\n+                                                               ResponseTypes.instanceOf(Integer.class),\n+                                                               1,\n+                                                               TimeUnit.SECONDS))\n+                    .expectNextCount(0)\n+                    .verifyComplete();\n+    }\n+\n+    @Test\n+    void testScatterGatherFailsWithRetry() throws Exception {\n+        doThrow(new RuntimeException(\":(\")).when(queryBus).scatterGather(any(), anyLong(), any());\n+\n+        Flux<Integer> query = reactiveQueryGateway.scatterGather(6,\n+                                                                 ResponseTypes.instanceOf(Integer.class),\n+                                                                 1,\n+                                                                 TimeUnit.SECONDS).retry(5);\n+\n+        StepVerifier.create(query)\n+                    .verifyError();\n+\n+\n+        verify(queryBus, times(6)).scatterGather(any(), anyLong(), any());\n+    }\n+\n+\n+    @Test\n+    void testSubscriptionQuery() throws Exception {\n+        Mono<SubscriptionQueryResult<String, String>> monoResult = reactiveQueryGateway.subscriptionQuery(\"criteria\",\n+                                                                                                          String.class,\n+                                                                                                          String.class);\n+        verifyZeroInteractions(queryMessageHandler1);\n+        verifyZeroInteractions(queryMessageHandler2);\n+\n+        SubscriptionQueryResult<String, String> result = monoResult.block();\n+        assertNotNull(result);\n+        StepVerifier.create(result.initialResult())\n+                    .expectNext(\"handled\")\n+                    .verifyComplete();\n+        StepVerifier.create(result.updates()\n+                                  .doOnSubscribe(s -> {\n+                                      queryUpdateEmitter.emit(String.class, q -> true, \"update\");\n+                                      queryUpdateEmitter.complete(String.class, q -> true);\n+                                  }))\n+                    .expectNext(\"update\")\n+                    .verifyComplete();\n+        verify(queryMessageHandler1).handle(any());\n+    }\n+\n+    @Test\n+    void testMultipleSubscriptionQueries() throws Exception {\n+        Flux<SubscriptionQueryMessage<?, ?, ?>> queries = Flux.fromIterable(Arrays.asList(\n+                new GenericSubscriptionQueryMessage<>(\"query1\",\n+                                                      ResponseTypes.instanceOf(String.class),\n+                                                      ResponseTypes.instanceOf(String.class)),\n+                new GenericSubscriptionQueryMessage<>(4,\n+                                                      ResponseTypes.instanceOf(Integer.class),\n+                                                      ResponseTypes.instanceOf(String.class))));\n+\n+        Flux<SubscriptionQueryResult<?, ?>> result = reactiveQueryGateway.subscriptionQuery(queries);\n+        verifyZeroInteractions(queryMessageHandler1);\n+        verifyZeroInteractions(queryMessageHandler2);\n+        List<Mono<Object>> initialResults = new ArrayList<>(2);\n+        //noinspection unchecked\n+        result.subscribe(sqr -> initialResults.add((Mono<Object>) sqr.initialResult()));\n+        assertEquals(2, initialResults.size());\n+        StepVerifier.create(initialResults.get(0))\n+                    .expectNext(\"handled\")\n+                    .verifyComplete();\n+        StepVerifier.create(initialResults.get(1))\n+                    .verifyError(RuntimeException.class);\n+\n+        verify(queryMessageHandler1).handle(any());\n+    }\n+\n+    @Test\n+    void testMultipleSubscriptionQueriesOrdering() throws Exception {\n+        int numberOfQueries = 10_000;\n+        Flux<SubscriptionQueryMessage<?, ?, ?>> queries = Flux\n+                .fromStream(IntStream.range(0, numberOfQueries)\n+                                     .mapToObj(i -> new GenericSubscriptionQueryMessage<>(\"backpressure\",\n+                                                                                          ResponseTypes\n+                                                                                                  .instanceOf(String.class),\n+                                                                                          ResponseTypes\n+                                                                                                  .instanceOf(String.class))));\n+        List<Integer> expectedResults = IntStream.range(1, numberOfQueries + 1)\n+                                                 .boxed()\n+                                                 .collect(Collectors.toList());\n+        Flux<SubscriptionQueryResult<?, ?>> result = reactiveQueryGateway.subscriptionQuery(queries);\n+        List<Mono<Object>> initialResults = new ArrayList<>(numberOfQueries);\n+        //noinspection unchecked\n+        result.subscribe(sqr -> initialResults.add((Mono<Object>) sqr.initialResult()));\n+        assertEquals(numberOfQueries, initialResults.size());\n+        for (int i = 0; i < numberOfQueries; i++) {\n+            StepVerifier.create(initialResults.get(i))\n+                        .expectNext(expectedResults.get(i))\n+                        .verifyComplete();\n+        }\n+\n+        verify(queryMessageHandler1, times(numberOfQueries)).handle(any());\n+    }\n+\n+    @Test\n+    void testSubscriptionQueryReturningNull() {\n+        SubscriptionQueryResult<String, String> result = reactiveQueryGateway.subscriptionQuery(0L,\n+                                                                                                String.class,\n+                                                                                                String.class)\n+                                                                             .block();\n+        assertNotNull(result);\n+        assertNull(result.initialResult().block());\n+        StepVerifier.create(result.initialResult())\n+                    .expectNext()\n+                    .verifyComplete();\n+        StepVerifier.create(result.updates()\n+                                  .doOnSubscribe(s -> {\n+                                      queryUpdateEmitter.emit(Long.class, q -> true, (String) null);\n+                                      queryUpdateEmitter.complete(Long.class, q -> true);\n+                                  }))\n+                    .expectNext()\n+                    .verifyComplete();\n+    }\n+\n+    @Test\n+    void testSubscriptionQueryWithDispatchInterceptor() {\n+        reactiveQueryGateway\n+                .registerDispatchInterceptor(queryMono -> queryMono\n+                        .map(query -> query.andMetaData(Collections.singletonMap(\"key1\", \"value1\"))));\n+        Registration registration2 = reactiveQueryGateway\n+                .registerDispatchInterceptor(queryMono -> queryMono\n+                        .map(query -> query.andMetaData(Collections.singletonMap(\"key2\", \"value2\"))));\n+\n+        Mono<SubscriptionQueryResult<String, String>> monoResult = reactiveQueryGateway\n+                .subscriptionQuery(true, String.class, String.class);\n+        SubscriptionQueryResult<String, String> result = monoResult.block();\n+        assertNotNull(result);\n+        StepVerifier.create(result.initialResult())\n+                    .expectNext(\"value1value2\")\n+                    .verifyComplete();\n+\n+        registration2.cancel();\n+\n+        monoResult = reactiveQueryGateway.subscriptionQuery(true, String.class, String.class);\n+        result = monoResult.block();\n+        assertNotNull(result);\n+        StepVerifier.create(result.initialResult())\n+                    .expectNext(\"value1\")\n+                    .verifyComplete();\n+    }\n+\n+    @Test\n+    void testSubscriptionQueryWithDispatchInterceptorThrowingAnException() {\n+        reactiveQueryGateway\n+                .registerDispatchInterceptor(queryMono -> {\n+                    throw new RuntimeException();\n+                });\n+        StepVerifier.create(reactiveQueryGateway.subscriptionQuery(true, String.class, String.class))\n+                    .verifyError(RuntimeException.class);\n+    }\n+\n+    @Test\n+    void testSubscriptionQueryWithDispatchInterceptorReturningErrorMono() {\n+        reactiveQueryGateway\n+                .registerDispatchInterceptor(queryMono -> Mono.error(new RuntimeException()));\n+        StepVerifier.create(reactiveQueryGateway.subscriptionQuery(true, String.class, String.class))\n+                    .verifyError(RuntimeException.class);\n+    }\n+\n+    @Test\n+    void testSubscriptionQueryFails() {\n+        Mono<SubscriptionQueryResult<Integer, Integer>> monoResult = reactiveQueryGateway.subscriptionQuery(6,\n+                                                                                                            Integer.class,\n+                                                                                                            Integer.class);\n+        SubscriptionQueryResult<Integer, Integer> result = monoResult.block();\n+        assertNotNull(result);\n+        StepVerifier.create(result.initialResult())\n+                    .verifyError(RuntimeException.class);\n+    }\n+\n+    @Test\n+    void testSubscriptionQueryFailsRetryInitialDispatchQuery() throws Exception {\n+\n+        doThrow(new RuntimeException(\":(\")).when(queryBus).subscriptionQuery(any(), any(), anyInt());\n+\n+        Mono<SubscriptionQueryResult<Integer, Integer>> monoResult = reactiveQueryGateway.subscriptionQuery(6,\n+                                                                                                            Integer.class,\n+                                                                                                            Integer.class)\n+                                                                                         .retry(5);\n+\n+        StepVerifier.create(monoResult)\n+                    .verifyError(RuntimeException.class);\n+\n+        verify(queryBus, times(6)).subscriptionQuery(any(), any(), anyInt());\n+    }\n+\n+    @Test\n+    void testSubscriptionQueryFailsRetryInitialResult() throws Exception {\n+        Mono<SubscriptionQueryResult<Integer, Integer>> monoResult = reactiveQueryGateway.subscriptionQuery(6,\n+                                                                                                            Integer.class,\n+                                                                                                            Integer.class);\n+\n+        SubscriptionQueryResult<Integer, Integer> result = monoResult.block();\n+        assertNotNull(result);\n+        StepVerifier.create(result.initialResult().retry(5))\n+                    .verifyError(RuntimeException.class);\n+\n+        verify(queryMessageHandler3, times(6)).handle(any());\n+    }\n+\n+    @Test\n+    void testSubscriptionQuerySingleInitialResultAndUpdates() {\n+        Flux<String> result = reactiveQueryGateway.subscriptionQuery(\"6\", String.class);\n+        CountDownLatch countDownLatch = new CountDownLatch(1);\n+\n+        ScheduledExecutorService executorService = Executors.newSingleThreadScheduledExecutor();\n+        executorService.execute(() -> {\n+            try {\n+                countDownLatch.await();\n+            } catch (InterruptedException e) {\n+                fail(e.getMessage());\n+            }\n+            queryUpdateEmitter.emit(String.class, q -> true, \"1\");\n+            queryUpdateEmitter.emit(String.class, q -> true, \"2\");\n+            queryUpdateEmitter.emit(String.class, q -> true, \"3\");\n+            queryUpdateEmitter.emit(String.class, q -> true, \"4\");\n+            queryUpdateEmitter.emit(String.class, q -> true, \"5\");\n+            queryUpdateEmitter.complete(String.class, p -> true);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "98865ab1427e4d879301c1bf542842eccc8aa3c3"}, "originalPosition": 731}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzcwNjg4Mw==", "bodyText": "changed to p", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r453706883", "createdAt": "2020-07-13T14:50:41Z", "author": {"login": "schananas"}, "path": "messaging/src/test/java/org/axonframework/queryhandling/DefaultReactorQueryGatewayTest.java", "diffHunk": "@@ -0,0 +1,780 @@\n+/*\n+ * Copyright (c) 2010-2020. Axon Framework\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.axonframework.queryhandling;\n+\n+import org.axonframework.common.Registration;\n+import org.axonframework.messaging.MessageHandler;\n+import org.axonframework.messaging.ResultMessage;\n+import org.axonframework.messaging.responsetypes.ResponseTypes;\n+import org.junit.jupiter.api.*;\n+import org.junit.jupiter.api.extension.*;\n+import org.mockito.junit.jupiter.*;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Hooks;\n+import reactor.core.publisher.Mono;\n+import reactor.test.StepVerifier;\n+import reactor.util.context.Context;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+\n+import static org.axonframework.common.ReflectionUtils.methodOf;\n+import static org.junit.jupiter.api.Assertions.*;\n+import static org.mockito.Mockito.*;\n+\n+/**\n+ * Tests for {@link DefaultReactorQueryGateway}.\n+ *\n+ * @author Milan Savic\n+ */\n+@ExtendWith(MockitoExtension.class)\n+class DefaultReactorQueryGatewayTest {\n+\n+    private DefaultReactorQueryGateway reactiveQueryGateway;\n+    private QueryUpdateEmitter queryUpdateEmitter;\n+    private MessageHandler<QueryMessage<?, Object>> queryMessageHandler1;\n+    private MessageHandler<QueryMessage<?, Object>> queryMessageHandler2;\n+    private MessageHandler<QueryMessage<?, Object>> queryMessageHandler3;\n+    private SimpleQueryBus queryBus;\n+\n+    @BeforeEach\n+    void setUp() throws NoSuchMethodException {\n+        Hooks.enableContextLossTracking();\n+        Hooks.onOperatorDebug();\n+\n+        queryBus = spy(SimpleQueryBus.builder().build());\n+\n+        queryUpdateEmitter = queryBus.queryUpdateEmitter();\n+        AtomicInteger count = new AtomicInteger();\n+        queryMessageHandler1 = spy(new MessageHandler<QueryMessage<?, Object>>() {\n+\n+            @Override\n+            public Object handle(QueryMessage<?, Object> message) {\n+                if (\"backpressure\".equals(message.getPayload())) {\n+                    return count.incrementAndGet();\n+                }\n+                return \"handled\";\n+            }\n+        });\n+        queryMessageHandler2 = spy(new MessageHandler<QueryMessage<?, Object>>() {\n+            @Override\n+            public Object handle(QueryMessage<?, Object> message) {\n+                if (\"backpressure\".equals(message.getPayload())) {\n+                    return count.incrementAndGet();\n+                }\n+                return \"handled\";\n+            }\n+        });\n+\n+        queryMessageHandler3 = spy(new MessageHandler<QueryMessage<?, Object>>() {\n+            @Override\n+            public Object handle(QueryMessage<?, Object> message) {\n+                throw new RuntimeException();\n+            }\n+        });\n+\n+        queryBus.subscribe(String.class.getName(), String.class, queryMessageHandler1);\n+        queryBus.subscribe(String.class.getName(), String.class, queryMessageHandler2);\n+        queryBus.subscribe(Integer.class.getName(), Integer.class, queryMessageHandler3);\n+\n+        queryBus.subscribe(Boolean.class.getName(),\n+                           String.class,\n+                           message -> \"\" + message.getMetaData().getOrDefault(\"key1\", \"\")\n+                                   + message.getMetaData().getOrDefault(\"key2\", \"\"));\n+\n+        queryBus.subscribe(Long.class.getName(), String.class, message -> null);\n+\n+        queryBus.subscribe(Double.class.getName(),\n+                           methodOf(this.getClass(), \"stringListQueryHandler\").getGenericReturnType(),\n+                           message -> Arrays.asList(\"value1\", \"value2\", \"value3\"));\n+\n+        reactiveQueryGateway = DefaultReactorQueryGateway.builder()\n+                                                         .queryBus(queryBus)\n+                                                         .build();\n+    }\n+\n+    @SuppressWarnings(\"unused\") // Used by 'testSubscriptionQueryMany()' to generate query handler response type\n+    public List<String> stringListQueryHandler() {\n+        return new ArrayList<>();\n+    }\n+\n+    @Test\n+    void testQuery() throws Exception {\n+\n+        Mono<String> result = reactiveQueryGateway.query(\"criteria\", String.class);\n+        verifyZeroInteractions(queryMessageHandler1);\n+        verifyZeroInteractions(queryMessageHandler2);\n+        StepVerifier.create(result)\n+                    .expectNext(\"handled\")\n+                    .verifyComplete();\n+        verify(queryMessageHandler1).handle(any());\n+    }\n+\n+    @Test\n+    void testQueryWithContext() throws Exception {\n+        Context context = Context.of(\"k1\", \"v1\");\n+\n+        Mono<String> result = reactiveQueryGateway.query(\"criteria\", String.class).subscriberContext(context);\n+\n+        verifyZeroInteractions(queryMessageHandler1);\n+        verifyZeroInteractions(queryMessageHandler2);\n+        StepVerifier.create(result)\n+                    .expectNext(\"handled\")\n+                    .expectAccessibleContext()\n+                    .containsOnly(context)\n+                    .then()\n+                    .verifyComplete();\n+        verify(queryMessageHandler1).handle(any());\n+    }\n+\n+    @Test\n+    void testMultipleQueries() throws Exception {\n+        Flux<QueryMessage<?, ?>> queries = Flux.fromIterable(Arrays.asList(\n+                new GenericQueryMessage<>(\"query1\", ResponseTypes.instanceOf(String.class)),\n+                new GenericQueryMessage<>(4, ResponseTypes.instanceOf(Integer.class)),\n+                new GenericQueryMessage<>(\"query2\", ResponseTypes.instanceOf(String.class)),\n+                new GenericQueryMessage<>(5, ResponseTypes.instanceOf(Integer.class)),\n+                new GenericQueryMessage<>(true, ResponseTypes.instanceOf(String.class))));\n+\n+        Flux<Object> result = reactiveQueryGateway.query(queries);\n+        verifyZeroInteractions(queryMessageHandler1);\n+        verifyZeroInteractions(queryMessageHandler2);\n+\n+        List<Throwable> exceptions = new ArrayList<>(2);\n+        StepVerifier.create(result.onErrorContinue((t, o) -> exceptions.add(t)))\n+                    .expectNext(\"handled\", \"handled\", \"\")\n+                    .verifyComplete();\n+\n+        assertEquals(2, exceptions.size());\n+        assertTrue(exceptions.get(0) instanceof RuntimeException);\n+        assertTrue(exceptions.get(1) instanceof RuntimeException);\n+        verify(queryMessageHandler1, times(2)).handle(any());\n+    }\n+\n+    @Test\n+    void testMultipleQueriesOrdering() throws Exception {\n+        int numberOfQueries = 10_000;\n+        Flux<QueryMessage<?, ?>> queries = Flux\n+                .fromStream(IntStream.range(0, numberOfQueries)\n+                                     .mapToObj(i -> new GenericQueryMessage<>(\"backpressure\",\n+                                                                              ResponseTypes.instanceOf(String.class))));\n+        List<Integer> expectedResults = IntStream.range(1, numberOfQueries + 1)\n+                                                 .boxed()\n+                                                 .collect(Collectors.toList());\n+        Flux<Object> result = reactiveQueryGateway.query(queries);\n+        StepVerifier.create(result)\n+                    .expectNext(expectedResults.toArray(new Integer[0]))\n+                    .verifyComplete();\n+        verify(queryMessageHandler1, times(numberOfQueries)).handle(any());\n+    }\n+\n+    @Test\n+    void testQueryReturningNull() {\n+        assertNull(reactiveQueryGateway.query(0L, String.class).block());\n+        StepVerifier.create(reactiveQueryGateway.query(0L, String.class))\n+                    .expectComplete()\n+                    .verify();\n+    }\n+\n+    @Test\n+    void testQueryWithDispatchInterceptor() {\n+        reactiveQueryGateway\n+                .registerDispatchInterceptor(queryMono -> queryMono\n+                        .map(query -> query.andMetaData(Collections.singletonMap(\"key1\", \"value1\"))));\n+        Registration registration2 = reactiveQueryGateway\n+                .registerDispatchInterceptor(queryMono -> queryMono\n+                        .map(query -> query.andMetaData(Collections.singletonMap(\"key2\", \"value2\"))));\n+\n+        StepVerifier.create(reactiveQueryGateway.query(true, String.class))\n+                    .expectNext(\"value1value2\")\n+                    .verifyComplete();\n+\n+        registration2.cancel();\n+\n+        StepVerifier.create(reactiveQueryGateway.query(true, String.class))\n+                    .expectNext(\"value1\")\n+                    .verifyComplete();\n+    }\n+\n+    @Test\n+    void testQueryWithDispatchInterceptorWithContext() {\n+        Context context = Context.of(\"security\", true);\n+\n+        reactiveQueryGateway\n+                .registerDispatchInterceptor(queryMono -> queryMono\n+                        .filterWhen(v -> Mono.subscriberContext()\n+                                             .filter(ctx -> ctx.hasKey(\"security\"))\n+                                             .map(ctx -> ctx.get(\"security\")))\n+                        .map(query -> query.andMetaData(Collections.singletonMap(\"key1\", \"value1\"))));\n+\n+        StepVerifier.create(reactiveQueryGateway.query(true, String.class).subscriberContext(context))\n+                    .expectNext(\"value1\")\n+                    .expectAccessibleContext()\n+                    .containsOnly(context)\n+                    .then()\n+                    .verifyComplete();\n+    }\n+\n+    @Test\n+    void testQueryWithResultInterceptorAlterResult() throws Exception {\n+        reactiveQueryGateway.registerResultHandlerInterceptor((q, results) -> results\n+                .map(it -> new GenericQueryResponseMessage<>(\"handled-modified\")));\n+\n+        Mono<String> result = reactiveQueryGateway.query(\"criteria\", String.class);\n+        verifyZeroInteractions(queryMessageHandler1);\n+        verifyZeroInteractions(queryMessageHandler2);\n+        StepVerifier.create(result)\n+                    .expectNext(\"handled-modified\")\n+                    .verifyComplete();\n+        verify(queryMessageHandler1).handle(any());\n+    }\n+\n+    @Test\n+    void testQueryWithResultInterceptorFilterResult() throws Exception {\n+        reactiveQueryGateway.registerResultHandlerInterceptor((q, results) -> results\n+                .filter(it -> !it.getPayload().equals(\"handled\")));\n+\n+        Mono<String> result = reactiveQueryGateway.query(\"criteria\", String.class);\n+        verifyZeroInteractions(queryMessageHandler1);\n+        verifyZeroInteractions(queryMessageHandler2);\n+        StepVerifier.create(result)\n+                    .expectComplete()\n+                    .verify();\n+        verify(queryMessageHandler1).handle(any());\n+    }\n+\n+    @Test\n+    void testQueryWithDispatchInterceptorThrowingAnException() {\n+        reactiveQueryGateway\n+                .registerDispatchInterceptor(queryMono -> {\n+                    throw new RuntimeException();\n+                });\n+        StepVerifier.create(reactiveQueryGateway.query(true, String.class))\n+                    .verifyError(RuntimeException.class);\n+    }\n+\n+    @Test\n+    void testQueryWithDispatchInterceptorReturningErrorMono() {\n+        reactiveQueryGateway\n+                .registerDispatchInterceptor(queryMono -> Mono.error(new RuntimeException()));\n+        StepVerifier.create(reactiveQueryGateway.query(true, String.class))\n+                    .verifyError(RuntimeException.class);\n+    }\n+\n+    @Test\n+    void testQueryFails() {\n+        StepVerifier.create(reactiveQueryGateway.query(5, Integer.class))\n+                    .verifyError(RuntimeException.class);\n+    }\n+\n+    @Test\n+    void testQueryFailsWithRetry() throws Exception {\n+\n+        Mono<Integer> query = reactiveQueryGateway.query(5, Integer.class).retry(5);\n+\n+        StepVerifier.create(query)\n+                    .verifyError(RuntimeException.class);\n+\n+        verify(queryMessageHandler3, times(6)).handle(any());\n+    }\n+\n+\n+    @Test\n+    void testScatterGather() throws Exception {\n+        Flux<String> result = reactiveQueryGateway.scatterGather(\"criteria\",\n+                                                                 ResponseTypes.instanceOf(String.class),\n+                                                                 1,\n+                                                                 TimeUnit.SECONDS);\n+        verifyZeroInteractions(queryMessageHandler1);\n+        verifyZeroInteractions(queryMessageHandler2);\n+        StepVerifier.create(result)\n+                    .expectNext(\"handled\", \"handled\")\n+                    .verifyComplete();\n+        verify(queryMessageHandler1).handle(any());\n+        verify(queryMessageHandler2).handle(any());\n+    }\n+\n+    @Test\n+    void testMultipleScatterGather() throws Exception {\n+        Flux<QueryMessage<?, ?>> queries = Flux.fromIterable(Arrays.asList(\n+                new GenericQueryMessage<>(\"query1\", ResponseTypes.instanceOf(String.class)),\n+                new GenericQueryMessage<>(4, ResponseTypes.instanceOf(Integer.class)),\n+                new GenericQueryMessage<>(\"query2\", ResponseTypes.instanceOf(String.class)),\n+                new GenericQueryMessage<>(5, ResponseTypes.instanceOf(Integer.class)),\n+                new GenericQueryMessage<>(true, ResponseTypes.instanceOf(String.class))));\n+\n+        Flux<Object> result = reactiveQueryGateway.scatterGather(queries, 1, TimeUnit.SECONDS);\n+        verifyZeroInteractions(queryMessageHandler1);\n+        verifyZeroInteractions(queryMessageHandler2);\n+\n+        StepVerifier.create(result)\n+                    .expectNext(\"handled\", \"handled\", \"handled\", \"handled\", \"\")\n+                    .verifyComplete();\n+\n+        verify(queryMessageHandler1, times(2)).handle(any());\n+        verify(queryMessageHandler2, times(2)).handle(any());\n+    }\n+\n+    @Test\n+    void testMultipleScatterGatherOrdering() throws Exception {\n+        int numberOfQueries = 10_000;\n+        Flux<QueryMessage<?, ?>> queries = Flux\n+                .fromStream(IntStream.range(0, numberOfQueries)\n+                                     .mapToObj(i -> new GenericQueryMessage<>(\"backpressure\",\n+                                                                              ResponseTypes.instanceOf(String.class))));\n+        List<Integer> expectedResults = IntStream.range(1, 2 * numberOfQueries + 1)\n+                                                 .boxed()\n+                                                 .collect(Collectors.toList());\n+        Flux<Object> result = reactiveQueryGateway.scatterGather(queries, 1, TimeUnit.SECONDS);\n+        StepVerifier.create(result)\n+                    .expectNext(expectedResults.toArray(new Integer[0]))\n+                    .verifyComplete();\n+        verify(queryMessageHandler1, times(numberOfQueries)).handle(any());\n+        verify(queryMessageHandler2, times(numberOfQueries)).handle(any());\n+    }\n+\n+    @Test\n+    void testScatterGatherReturningNull() {\n+        assertNull(reactiveQueryGateway.scatterGather(0L, ResponseTypes.instanceOf(String.class), 1, TimeUnit.SECONDS)\n+                                       .blockFirst());\n+        StepVerifier.create(reactiveQueryGateway\n+                                    .scatterGather(0L, ResponseTypes.instanceOf(String.class), 1, TimeUnit.SECONDS))\n+                    .expectNext()\n+                    .verifyComplete();\n+    }\n+\n+    @Test\n+    void testScatterGatherWithDispatchInterceptor() {\n+        reactiveQueryGateway\n+                .registerDispatchInterceptor(queryMono -> queryMono\n+                        .map(query -> query.andMetaData(Collections.singletonMap(\"key1\", \"value1\"))));\n+        Registration registration2 = reactiveQueryGateway\n+                .registerDispatchInterceptor(queryMono -> queryMono\n+                        .map(query -> query.andMetaData(Collections.singletonMap(\"key2\", \"value2\"))));\n+\n+        StepVerifier.create(reactiveQueryGateway\n+                                    .scatterGather(true, ResponseTypes.instanceOf(String.class), 1, TimeUnit.SECONDS))\n+                    .expectNext(\"value1value2\")\n+                    .verifyComplete();\n+\n+        registration2.cancel();\n+\n+        StepVerifier.create(reactiveQueryGateway.query(true, String.class))\n+                    .expectNext(\"value1\")\n+                    .verifyComplete();\n+    }\n+\n+    @Test\n+    void testScatterGatherWithResultIntercept() throws Exception {\n+        reactiveQueryGateway\n+                .registerResultHandlerInterceptor(\n+                        (query, results) -> results\n+                                .map(it -> new GenericQueryResponseMessage<>(\"handled-modified\"))\n+                );\n+\n+        Flux<QueryMessage<?, ?>> queries = Flux.fromIterable(Arrays.asList(\n+                new GenericQueryMessage<>(\"query1\", ResponseTypes.instanceOf(String.class)),\n+                new GenericQueryMessage<>(4, ResponseTypes.instanceOf(Integer.class)),\n+                new GenericQueryMessage<>(\"query2\", ResponseTypes.instanceOf(String.class)),\n+                new GenericQueryMessage<>(5, ResponseTypes.instanceOf(Integer.class)),\n+                new GenericQueryMessage<>(true, ResponseTypes.instanceOf(String.class))));\n+\n+        Flux<Object> result = reactiveQueryGateway.scatterGather(queries, 1, TimeUnit.SECONDS);\n+        verifyZeroInteractions(queryMessageHandler1);\n+        verifyZeroInteractions(queryMessageHandler2);\n+\n+        StepVerifier.create(result)\n+                    .expectNext(\"handled-modified\",\n+                                \"handled-modified\",\n+                                \"handled-modified\",\n+                                \"handled-modified\",\n+                                \"handled-modified\")\n+                    .verifyComplete();\n+\n+        verify(queryMessageHandler1, times(2)).handle(any());\n+        verify(queryMessageHandler2, times(2)).handle(any());\n+    }\n+\n+    @Test\n+    void testQueryWithResultInterceptorModifyResultBasedOnQuery() throws Exception {\n+        reactiveQueryGateway.registerDispatchInterceptor(q -> q.map(it ->\n+                                                                            it.andMetaData(Collections.singletonMap(\n+                                                                                    \"block\",\n+                                                                                    it.getPayload() instanceof Boolean)\n+                                                                            )));\n+        reactiveQueryGateway\n+                .registerResultHandlerInterceptor((q, results) -> results\n+                        .filter(it -> !((boolean) q.getMetaData().get(\"block\")))\n+                );\n+\n+        Flux<QueryMessage<?, ?>> queries = Flux.fromIterable(Arrays.asList(\n+                new GenericQueryMessage<>(\"query1\", ResponseTypes.instanceOf(String.class)),\n+                new GenericQueryMessage<>(4, ResponseTypes.instanceOf(Integer.class)),\n+                new GenericQueryMessage<>(\"query2\", ResponseTypes.instanceOf(String.class)),\n+                new GenericQueryMessage<>(5, ResponseTypes.instanceOf(Integer.class)),\n+                new GenericQueryMessage<>(Boolean.TRUE, ResponseTypes.instanceOf(String.class))));\n+\n+        Flux<Object> result = reactiveQueryGateway.scatterGather(queries, 1, TimeUnit.SECONDS);\n+        verifyZeroInteractions(queryMessageHandler1);\n+        verifyZeroInteractions(queryMessageHandler2);\n+\n+        StepVerifier.create(result)\n+                    .expectNext(\"handled\", \"handled\", \"handled\", \"handled\")\n+                    .verifyComplete();\n+\n+        verify(queryMessageHandler1, times(2)).handle(any());\n+        verify(queryMessageHandler2, times(2)).handle(any());\n+    }\n+\n+    @Test\n+    void testScatterGatherWithResultInterceptReplacedWithError() throws Exception {\n+        reactiveQueryGateway\n+                .registerResultHandlerInterceptor(\n+                        (query, results) -> results.flatMap(r -> {\n+                            if (r.getPayload().equals(\"\")) {\n+                                return Flux.<ResultMessage<?>>error(new RuntimeException(\"no empty strings allowed\"));\n+                            } else {\n+                                return Flux.just(r);\n+                            }\n+                        })\n+                );\n+\n+        Flux<QueryMessage<?, ?>> queries = Flux.fromIterable(Arrays.asList(\n+                new GenericQueryMessage<>(\"query1\", ResponseTypes.instanceOf(String.class)),\n+                new GenericQueryMessage<>(4, ResponseTypes.instanceOf(Integer.class)),\n+                new GenericQueryMessage<>(\"query2\", ResponseTypes.instanceOf(String.class)),\n+                new GenericQueryMessage<>(5, ResponseTypes.instanceOf(Integer.class)),\n+                new GenericQueryMessage<>(true, ResponseTypes.instanceOf(String.class))));\n+\n+        Flux<Object> result = reactiveQueryGateway.scatterGather(queries, 1, TimeUnit.SECONDS);\n+        verifyZeroInteractions(queryMessageHandler1);\n+        verifyZeroInteractions(queryMessageHandler2);\n+\n+        StepVerifier.create(result)\n+                    .expectNext(\"handled\", \"handled\", \"handled\", \"handled\")\n+                    .expectError(RuntimeException.class)\n+                    .verify();\n+\n+        verify(queryMessageHandler1, times(2)).handle(any());\n+        verify(queryMessageHandler2, times(2)).handle(any());\n+    }\n+\n+    @Test\n+    void testScatterGatherWithDispatchInterceptorThrowingAnException() {\n+        reactiveQueryGateway\n+                .registerDispatchInterceptor(queryMono -> {\n+                    throw new RuntimeException();\n+                });\n+        StepVerifier.create(reactiveQueryGateway\n+                                    .scatterGather(true, ResponseTypes.instanceOf(String.class), 1, TimeUnit.SECONDS))\n+                    .verifyError(RuntimeException.class);\n+    }\n+\n+    @Test\n+    void testScatterGatherWithDispatchInterceptorReturningErrorMono() {\n+        reactiveQueryGateway\n+                .registerDispatchInterceptor(queryMono -> Mono.error(new RuntimeException()));\n+        StepVerifier.create(reactiveQueryGateway\n+                                    .scatterGather(true, ResponseTypes.instanceOf(String.class), 1, TimeUnit.SECONDS))\n+                    .verifyError(RuntimeException.class);\n+    }\n+\n+    @Test\n+    void testScatterGatherFails() {\n+        StepVerifier.create(reactiveQueryGateway.scatterGather(6,\n+                                                               ResponseTypes.instanceOf(Integer.class),\n+                                                               1,\n+                                                               TimeUnit.SECONDS))\n+                    .expectNextCount(0)\n+                    .verifyComplete();\n+    }\n+\n+    @Test\n+    void testScatterGatherFailsWithRetry() throws Exception {\n+        doThrow(new RuntimeException(\":(\")).when(queryBus).scatterGather(any(), anyLong(), any());\n+\n+        Flux<Integer> query = reactiveQueryGateway.scatterGather(6,\n+                                                                 ResponseTypes.instanceOf(Integer.class),\n+                                                                 1,\n+                                                                 TimeUnit.SECONDS).retry(5);\n+\n+        StepVerifier.create(query)\n+                    .verifyError();\n+\n+\n+        verify(queryBus, times(6)).scatterGather(any(), anyLong(), any());\n+    }\n+\n+\n+    @Test\n+    void testSubscriptionQuery() throws Exception {\n+        Mono<SubscriptionQueryResult<String, String>> monoResult = reactiveQueryGateway.subscriptionQuery(\"criteria\",\n+                                                                                                          String.class,\n+                                                                                                          String.class);\n+        verifyZeroInteractions(queryMessageHandler1);\n+        verifyZeroInteractions(queryMessageHandler2);\n+\n+        SubscriptionQueryResult<String, String> result = monoResult.block();\n+        assertNotNull(result);\n+        StepVerifier.create(result.initialResult())\n+                    .expectNext(\"handled\")\n+                    .verifyComplete();\n+        StepVerifier.create(result.updates()\n+                                  .doOnSubscribe(s -> {\n+                                      queryUpdateEmitter.emit(String.class, q -> true, \"update\");\n+                                      queryUpdateEmitter.complete(String.class, q -> true);\n+                                  }))\n+                    .expectNext(\"update\")\n+                    .verifyComplete();\n+        verify(queryMessageHandler1).handle(any());\n+    }\n+\n+    @Test\n+    void testMultipleSubscriptionQueries() throws Exception {\n+        Flux<SubscriptionQueryMessage<?, ?, ?>> queries = Flux.fromIterable(Arrays.asList(\n+                new GenericSubscriptionQueryMessage<>(\"query1\",\n+                                                      ResponseTypes.instanceOf(String.class),\n+                                                      ResponseTypes.instanceOf(String.class)),\n+                new GenericSubscriptionQueryMessage<>(4,\n+                                                      ResponseTypes.instanceOf(Integer.class),\n+                                                      ResponseTypes.instanceOf(String.class))));\n+\n+        Flux<SubscriptionQueryResult<?, ?>> result = reactiveQueryGateway.subscriptionQuery(queries);\n+        verifyZeroInteractions(queryMessageHandler1);\n+        verifyZeroInteractions(queryMessageHandler2);\n+        List<Mono<Object>> initialResults = new ArrayList<>(2);\n+        //noinspection unchecked\n+        result.subscribe(sqr -> initialResults.add((Mono<Object>) sqr.initialResult()));\n+        assertEquals(2, initialResults.size());\n+        StepVerifier.create(initialResults.get(0))\n+                    .expectNext(\"handled\")\n+                    .verifyComplete();\n+        StepVerifier.create(initialResults.get(1))\n+                    .verifyError(RuntimeException.class);\n+\n+        verify(queryMessageHandler1).handle(any());\n+    }\n+\n+    @Test\n+    void testMultipleSubscriptionQueriesOrdering() throws Exception {\n+        int numberOfQueries = 10_000;\n+        Flux<SubscriptionQueryMessage<?, ?, ?>> queries = Flux\n+                .fromStream(IntStream.range(0, numberOfQueries)\n+                                     .mapToObj(i -> new GenericSubscriptionQueryMessage<>(\"backpressure\",\n+                                                                                          ResponseTypes\n+                                                                                                  .instanceOf(String.class),\n+                                                                                          ResponseTypes\n+                                                                                                  .instanceOf(String.class))));\n+        List<Integer> expectedResults = IntStream.range(1, numberOfQueries + 1)\n+                                                 .boxed()\n+                                                 .collect(Collectors.toList());\n+        Flux<SubscriptionQueryResult<?, ?>> result = reactiveQueryGateway.subscriptionQuery(queries);\n+        List<Mono<Object>> initialResults = new ArrayList<>(numberOfQueries);\n+        //noinspection unchecked\n+        result.subscribe(sqr -> initialResults.add((Mono<Object>) sqr.initialResult()));\n+        assertEquals(numberOfQueries, initialResults.size());\n+        for (int i = 0; i < numberOfQueries; i++) {\n+            StepVerifier.create(initialResults.get(i))\n+                        .expectNext(expectedResults.get(i))\n+                        .verifyComplete();\n+        }\n+\n+        verify(queryMessageHandler1, times(numberOfQueries)).handle(any());\n+    }\n+\n+    @Test\n+    void testSubscriptionQueryReturningNull() {\n+        SubscriptionQueryResult<String, String> result = reactiveQueryGateway.subscriptionQuery(0L,\n+                                                                                                String.class,\n+                                                                                                String.class)\n+                                                                             .block();\n+        assertNotNull(result);\n+        assertNull(result.initialResult().block());\n+        StepVerifier.create(result.initialResult())\n+                    .expectNext()\n+                    .verifyComplete();\n+        StepVerifier.create(result.updates()\n+                                  .doOnSubscribe(s -> {\n+                                      queryUpdateEmitter.emit(Long.class, q -> true, (String) null);\n+                                      queryUpdateEmitter.complete(Long.class, q -> true);\n+                                  }))\n+                    .expectNext()\n+                    .verifyComplete();\n+    }\n+\n+    @Test\n+    void testSubscriptionQueryWithDispatchInterceptor() {\n+        reactiveQueryGateway\n+                .registerDispatchInterceptor(queryMono -> queryMono\n+                        .map(query -> query.andMetaData(Collections.singletonMap(\"key1\", \"value1\"))));\n+        Registration registration2 = reactiveQueryGateway\n+                .registerDispatchInterceptor(queryMono -> queryMono\n+                        .map(query -> query.andMetaData(Collections.singletonMap(\"key2\", \"value2\"))));\n+\n+        Mono<SubscriptionQueryResult<String, String>> monoResult = reactiveQueryGateway\n+                .subscriptionQuery(true, String.class, String.class);\n+        SubscriptionQueryResult<String, String> result = monoResult.block();\n+        assertNotNull(result);\n+        StepVerifier.create(result.initialResult())\n+                    .expectNext(\"value1value2\")\n+                    .verifyComplete();\n+\n+        registration2.cancel();\n+\n+        monoResult = reactiveQueryGateway.subscriptionQuery(true, String.class, String.class);\n+        result = monoResult.block();\n+        assertNotNull(result);\n+        StepVerifier.create(result.initialResult())\n+                    .expectNext(\"value1\")\n+                    .verifyComplete();\n+    }\n+\n+    @Test\n+    void testSubscriptionQueryWithDispatchInterceptorThrowingAnException() {\n+        reactiveQueryGateway\n+                .registerDispatchInterceptor(queryMono -> {\n+                    throw new RuntimeException();\n+                });\n+        StepVerifier.create(reactiveQueryGateway.subscriptionQuery(true, String.class, String.class))\n+                    .verifyError(RuntimeException.class);\n+    }\n+\n+    @Test\n+    void testSubscriptionQueryWithDispatchInterceptorReturningErrorMono() {\n+        reactiveQueryGateway\n+                .registerDispatchInterceptor(queryMono -> Mono.error(new RuntimeException()));\n+        StepVerifier.create(reactiveQueryGateway.subscriptionQuery(true, String.class, String.class))\n+                    .verifyError(RuntimeException.class);\n+    }\n+\n+    @Test\n+    void testSubscriptionQueryFails() {\n+        Mono<SubscriptionQueryResult<Integer, Integer>> monoResult = reactiveQueryGateway.subscriptionQuery(6,\n+                                                                                                            Integer.class,\n+                                                                                                            Integer.class);\n+        SubscriptionQueryResult<Integer, Integer> result = monoResult.block();\n+        assertNotNull(result);\n+        StepVerifier.create(result.initialResult())\n+                    .verifyError(RuntimeException.class);\n+    }\n+\n+    @Test\n+    void testSubscriptionQueryFailsRetryInitialDispatchQuery() throws Exception {\n+\n+        doThrow(new RuntimeException(\":(\")).when(queryBus).subscriptionQuery(any(), any(), anyInt());\n+\n+        Mono<SubscriptionQueryResult<Integer, Integer>> monoResult = reactiveQueryGateway.subscriptionQuery(6,\n+                                                                                                            Integer.class,\n+                                                                                                            Integer.class)\n+                                                                                         .retry(5);\n+\n+        StepVerifier.create(monoResult)\n+                    .verifyError(RuntimeException.class);\n+\n+        verify(queryBus, times(6)).subscriptionQuery(any(), any(), anyInt());\n+    }\n+\n+    @Test\n+    void testSubscriptionQueryFailsRetryInitialResult() throws Exception {\n+        Mono<SubscriptionQueryResult<Integer, Integer>> monoResult = reactiveQueryGateway.subscriptionQuery(6,\n+                                                                                                            Integer.class,\n+                                                                                                            Integer.class);\n+\n+        SubscriptionQueryResult<Integer, Integer> result = monoResult.block();\n+        assertNotNull(result);\n+        StepVerifier.create(result.initialResult().retry(5))\n+                    .verifyError(RuntimeException.class);\n+\n+        verify(queryMessageHandler3, times(6)).handle(any());\n+    }\n+\n+    @Test\n+    void testSubscriptionQuerySingleInitialResultAndUpdates() {\n+        Flux<String> result = reactiveQueryGateway.subscriptionQuery(\"6\", String.class);\n+        CountDownLatch countDownLatch = new CountDownLatch(1);\n+\n+        ScheduledExecutorService executorService = Executors.newSingleThreadScheduledExecutor();\n+        executorService.execute(() -> {\n+            try {\n+                countDownLatch.await();\n+            } catch (InterruptedException e) {\n+                fail(e.getMessage());\n+            }\n+            queryUpdateEmitter.emit(String.class, q -> true, \"1\");\n+            queryUpdateEmitter.emit(String.class, q -> true, \"2\");\n+            queryUpdateEmitter.emit(String.class, q -> true, \"3\");\n+            queryUpdateEmitter.emit(String.class, q -> true, \"4\");\n+            queryUpdateEmitter.emit(String.class, q -> true, \"5\");\n+            queryUpdateEmitter.complete(String.class, p -> true);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjgzMDY0MA=="}, "originalCommit": {"oid": "98865ab1427e4d879301c1bf542842eccc8aa3c3"}, "originalPosition": 731}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTM5MTU4Nw==", "bodyText": "My intention was to change this to q to mirror the emit calls. But as stated, this is definitely a nit.", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r461391587", "createdAt": "2020-07-28T07:59:10Z", "author": {"login": "smcvb"}, "path": "messaging/src/test/java/org/axonframework/queryhandling/DefaultReactorQueryGatewayTest.java", "diffHunk": "@@ -0,0 +1,780 @@\n+/*\n+ * Copyright (c) 2010-2020. Axon Framework\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.axonframework.queryhandling;\n+\n+import org.axonframework.common.Registration;\n+import org.axonframework.messaging.MessageHandler;\n+import org.axonframework.messaging.ResultMessage;\n+import org.axonframework.messaging.responsetypes.ResponseTypes;\n+import org.junit.jupiter.api.*;\n+import org.junit.jupiter.api.extension.*;\n+import org.mockito.junit.jupiter.*;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Hooks;\n+import reactor.core.publisher.Mono;\n+import reactor.test.StepVerifier;\n+import reactor.util.context.Context;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+\n+import static org.axonframework.common.ReflectionUtils.methodOf;\n+import static org.junit.jupiter.api.Assertions.*;\n+import static org.mockito.Mockito.*;\n+\n+/**\n+ * Tests for {@link DefaultReactorQueryGateway}.\n+ *\n+ * @author Milan Savic\n+ */\n+@ExtendWith(MockitoExtension.class)\n+class DefaultReactorQueryGatewayTest {\n+\n+    private DefaultReactorQueryGateway reactiveQueryGateway;\n+    private QueryUpdateEmitter queryUpdateEmitter;\n+    private MessageHandler<QueryMessage<?, Object>> queryMessageHandler1;\n+    private MessageHandler<QueryMessage<?, Object>> queryMessageHandler2;\n+    private MessageHandler<QueryMessage<?, Object>> queryMessageHandler3;\n+    private SimpleQueryBus queryBus;\n+\n+    @BeforeEach\n+    void setUp() throws NoSuchMethodException {\n+        Hooks.enableContextLossTracking();\n+        Hooks.onOperatorDebug();\n+\n+        queryBus = spy(SimpleQueryBus.builder().build());\n+\n+        queryUpdateEmitter = queryBus.queryUpdateEmitter();\n+        AtomicInteger count = new AtomicInteger();\n+        queryMessageHandler1 = spy(new MessageHandler<QueryMessage<?, Object>>() {\n+\n+            @Override\n+            public Object handle(QueryMessage<?, Object> message) {\n+                if (\"backpressure\".equals(message.getPayload())) {\n+                    return count.incrementAndGet();\n+                }\n+                return \"handled\";\n+            }\n+        });\n+        queryMessageHandler2 = spy(new MessageHandler<QueryMessage<?, Object>>() {\n+            @Override\n+            public Object handle(QueryMessage<?, Object> message) {\n+                if (\"backpressure\".equals(message.getPayload())) {\n+                    return count.incrementAndGet();\n+                }\n+                return \"handled\";\n+            }\n+        });\n+\n+        queryMessageHandler3 = spy(new MessageHandler<QueryMessage<?, Object>>() {\n+            @Override\n+            public Object handle(QueryMessage<?, Object> message) {\n+                throw new RuntimeException();\n+            }\n+        });\n+\n+        queryBus.subscribe(String.class.getName(), String.class, queryMessageHandler1);\n+        queryBus.subscribe(String.class.getName(), String.class, queryMessageHandler2);\n+        queryBus.subscribe(Integer.class.getName(), Integer.class, queryMessageHandler3);\n+\n+        queryBus.subscribe(Boolean.class.getName(),\n+                           String.class,\n+                           message -> \"\" + message.getMetaData().getOrDefault(\"key1\", \"\")\n+                                   + message.getMetaData().getOrDefault(\"key2\", \"\"));\n+\n+        queryBus.subscribe(Long.class.getName(), String.class, message -> null);\n+\n+        queryBus.subscribe(Double.class.getName(),\n+                           methodOf(this.getClass(), \"stringListQueryHandler\").getGenericReturnType(),\n+                           message -> Arrays.asList(\"value1\", \"value2\", \"value3\"));\n+\n+        reactiveQueryGateway = DefaultReactorQueryGateway.builder()\n+                                                         .queryBus(queryBus)\n+                                                         .build();\n+    }\n+\n+    @SuppressWarnings(\"unused\") // Used by 'testSubscriptionQueryMany()' to generate query handler response type\n+    public List<String> stringListQueryHandler() {\n+        return new ArrayList<>();\n+    }\n+\n+    @Test\n+    void testQuery() throws Exception {\n+\n+        Mono<String> result = reactiveQueryGateway.query(\"criteria\", String.class);\n+        verifyZeroInteractions(queryMessageHandler1);\n+        verifyZeroInteractions(queryMessageHandler2);\n+        StepVerifier.create(result)\n+                    .expectNext(\"handled\")\n+                    .verifyComplete();\n+        verify(queryMessageHandler1).handle(any());\n+    }\n+\n+    @Test\n+    void testQueryWithContext() throws Exception {\n+        Context context = Context.of(\"k1\", \"v1\");\n+\n+        Mono<String> result = reactiveQueryGateway.query(\"criteria\", String.class).subscriberContext(context);\n+\n+        verifyZeroInteractions(queryMessageHandler1);\n+        verifyZeroInteractions(queryMessageHandler2);\n+        StepVerifier.create(result)\n+                    .expectNext(\"handled\")\n+                    .expectAccessibleContext()\n+                    .containsOnly(context)\n+                    .then()\n+                    .verifyComplete();\n+        verify(queryMessageHandler1).handle(any());\n+    }\n+\n+    @Test\n+    void testMultipleQueries() throws Exception {\n+        Flux<QueryMessage<?, ?>> queries = Flux.fromIterable(Arrays.asList(\n+                new GenericQueryMessage<>(\"query1\", ResponseTypes.instanceOf(String.class)),\n+                new GenericQueryMessage<>(4, ResponseTypes.instanceOf(Integer.class)),\n+                new GenericQueryMessage<>(\"query2\", ResponseTypes.instanceOf(String.class)),\n+                new GenericQueryMessage<>(5, ResponseTypes.instanceOf(Integer.class)),\n+                new GenericQueryMessage<>(true, ResponseTypes.instanceOf(String.class))));\n+\n+        Flux<Object> result = reactiveQueryGateway.query(queries);\n+        verifyZeroInteractions(queryMessageHandler1);\n+        verifyZeroInteractions(queryMessageHandler2);\n+\n+        List<Throwable> exceptions = new ArrayList<>(2);\n+        StepVerifier.create(result.onErrorContinue((t, o) -> exceptions.add(t)))\n+                    .expectNext(\"handled\", \"handled\", \"\")\n+                    .verifyComplete();\n+\n+        assertEquals(2, exceptions.size());\n+        assertTrue(exceptions.get(0) instanceof RuntimeException);\n+        assertTrue(exceptions.get(1) instanceof RuntimeException);\n+        verify(queryMessageHandler1, times(2)).handle(any());\n+    }\n+\n+    @Test\n+    void testMultipleQueriesOrdering() throws Exception {\n+        int numberOfQueries = 10_000;\n+        Flux<QueryMessage<?, ?>> queries = Flux\n+                .fromStream(IntStream.range(0, numberOfQueries)\n+                                     .mapToObj(i -> new GenericQueryMessage<>(\"backpressure\",\n+                                                                              ResponseTypes.instanceOf(String.class))));\n+        List<Integer> expectedResults = IntStream.range(1, numberOfQueries + 1)\n+                                                 .boxed()\n+                                                 .collect(Collectors.toList());\n+        Flux<Object> result = reactiveQueryGateway.query(queries);\n+        StepVerifier.create(result)\n+                    .expectNext(expectedResults.toArray(new Integer[0]))\n+                    .verifyComplete();\n+        verify(queryMessageHandler1, times(numberOfQueries)).handle(any());\n+    }\n+\n+    @Test\n+    void testQueryReturningNull() {\n+        assertNull(reactiveQueryGateway.query(0L, String.class).block());\n+        StepVerifier.create(reactiveQueryGateway.query(0L, String.class))\n+                    .expectComplete()\n+                    .verify();\n+    }\n+\n+    @Test\n+    void testQueryWithDispatchInterceptor() {\n+        reactiveQueryGateway\n+                .registerDispatchInterceptor(queryMono -> queryMono\n+                        .map(query -> query.andMetaData(Collections.singletonMap(\"key1\", \"value1\"))));\n+        Registration registration2 = reactiveQueryGateway\n+                .registerDispatchInterceptor(queryMono -> queryMono\n+                        .map(query -> query.andMetaData(Collections.singletonMap(\"key2\", \"value2\"))));\n+\n+        StepVerifier.create(reactiveQueryGateway.query(true, String.class))\n+                    .expectNext(\"value1value2\")\n+                    .verifyComplete();\n+\n+        registration2.cancel();\n+\n+        StepVerifier.create(reactiveQueryGateway.query(true, String.class))\n+                    .expectNext(\"value1\")\n+                    .verifyComplete();\n+    }\n+\n+    @Test\n+    void testQueryWithDispatchInterceptorWithContext() {\n+        Context context = Context.of(\"security\", true);\n+\n+        reactiveQueryGateway\n+                .registerDispatchInterceptor(queryMono -> queryMono\n+                        .filterWhen(v -> Mono.subscriberContext()\n+                                             .filter(ctx -> ctx.hasKey(\"security\"))\n+                                             .map(ctx -> ctx.get(\"security\")))\n+                        .map(query -> query.andMetaData(Collections.singletonMap(\"key1\", \"value1\"))));\n+\n+        StepVerifier.create(reactiveQueryGateway.query(true, String.class).subscriberContext(context))\n+                    .expectNext(\"value1\")\n+                    .expectAccessibleContext()\n+                    .containsOnly(context)\n+                    .then()\n+                    .verifyComplete();\n+    }\n+\n+    @Test\n+    void testQueryWithResultInterceptorAlterResult() throws Exception {\n+        reactiveQueryGateway.registerResultHandlerInterceptor((q, results) -> results\n+                .map(it -> new GenericQueryResponseMessage<>(\"handled-modified\")));\n+\n+        Mono<String> result = reactiveQueryGateway.query(\"criteria\", String.class);\n+        verifyZeroInteractions(queryMessageHandler1);\n+        verifyZeroInteractions(queryMessageHandler2);\n+        StepVerifier.create(result)\n+                    .expectNext(\"handled-modified\")\n+                    .verifyComplete();\n+        verify(queryMessageHandler1).handle(any());\n+    }\n+\n+    @Test\n+    void testQueryWithResultInterceptorFilterResult() throws Exception {\n+        reactiveQueryGateway.registerResultHandlerInterceptor((q, results) -> results\n+                .filter(it -> !it.getPayload().equals(\"handled\")));\n+\n+        Mono<String> result = reactiveQueryGateway.query(\"criteria\", String.class);\n+        verifyZeroInteractions(queryMessageHandler1);\n+        verifyZeroInteractions(queryMessageHandler2);\n+        StepVerifier.create(result)\n+                    .expectComplete()\n+                    .verify();\n+        verify(queryMessageHandler1).handle(any());\n+    }\n+\n+    @Test\n+    void testQueryWithDispatchInterceptorThrowingAnException() {\n+        reactiveQueryGateway\n+                .registerDispatchInterceptor(queryMono -> {\n+                    throw new RuntimeException();\n+                });\n+        StepVerifier.create(reactiveQueryGateway.query(true, String.class))\n+                    .verifyError(RuntimeException.class);\n+    }\n+\n+    @Test\n+    void testQueryWithDispatchInterceptorReturningErrorMono() {\n+        reactiveQueryGateway\n+                .registerDispatchInterceptor(queryMono -> Mono.error(new RuntimeException()));\n+        StepVerifier.create(reactiveQueryGateway.query(true, String.class))\n+                    .verifyError(RuntimeException.class);\n+    }\n+\n+    @Test\n+    void testQueryFails() {\n+        StepVerifier.create(reactiveQueryGateway.query(5, Integer.class))\n+                    .verifyError(RuntimeException.class);\n+    }\n+\n+    @Test\n+    void testQueryFailsWithRetry() throws Exception {\n+\n+        Mono<Integer> query = reactiveQueryGateway.query(5, Integer.class).retry(5);\n+\n+        StepVerifier.create(query)\n+                    .verifyError(RuntimeException.class);\n+\n+        verify(queryMessageHandler3, times(6)).handle(any());\n+    }\n+\n+\n+    @Test\n+    void testScatterGather() throws Exception {\n+        Flux<String> result = reactiveQueryGateway.scatterGather(\"criteria\",\n+                                                                 ResponseTypes.instanceOf(String.class),\n+                                                                 1,\n+                                                                 TimeUnit.SECONDS);\n+        verifyZeroInteractions(queryMessageHandler1);\n+        verifyZeroInteractions(queryMessageHandler2);\n+        StepVerifier.create(result)\n+                    .expectNext(\"handled\", \"handled\")\n+                    .verifyComplete();\n+        verify(queryMessageHandler1).handle(any());\n+        verify(queryMessageHandler2).handle(any());\n+    }\n+\n+    @Test\n+    void testMultipleScatterGather() throws Exception {\n+        Flux<QueryMessage<?, ?>> queries = Flux.fromIterable(Arrays.asList(\n+                new GenericQueryMessage<>(\"query1\", ResponseTypes.instanceOf(String.class)),\n+                new GenericQueryMessage<>(4, ResponseTypes.instanceOf(Integer.class)),\n+                new GenericQueryMessage<>(\"query2\", ResponseTypes.instanceOf(String.class)),\n+                new GenericQueryMessage<>(5, ResponseTypes.instanceOf(Integer.class)),\n+                new GenericQueryMessage<>(true, ResponseTypes.instanceOf(String.class))));\n+\n+        Flux<Object> result = reactiveQueryGateway.scatterGather(queries, 1, TimeUnit.SECONDS);\n+        verifyZeroInteractions(queryMessageHandler1);\n+        verifyZeroInteractions(queryMessageHandler2);\n+\n+        StepVerifier.create(result)\n+                    .expectNext(\"handled\", \"handled\", \"handled\", \"handled\", \"\")\n+                    .verifyComplete();\n+\n+        verify(queryMessageHandler1, times(2)).handle(any());\n+        verify(queryMessageHandler2, times(2)).handle(any());\n+    }\n+\n+    @Test\n+    void testMultipleScatterGatherOrdering() throws Exception {\n+        int numberOfQueries = 10_000;\n+        Flux<QueryMessage<?, ?>> queries = Flux\n+                .fromStream(IntStream.range(0, numberOfQueries)\n+                                     .mapToObj(i -> new GenericQueryMessage<>(\"backpressure\",\n+                                                                              ResponseTypes.instanceOf(String.class))));\n+        List<Integer> expectedResults = IntStream.range(1, 2 * numberOfQueries + 1)\n+                                                 .boxed()\n+                                                 .collect(Collectors.toList());\n+        Flux<Object> result = reactiveQueryGateway.scatterGather(queries, 1, TimeUnit.SECONDS);\n+        StepVerifier.create(result)\n+                    .expectNext(expectedResults.toArray(new Integer[0]))\n+                    .verifyComplete();\n+        verify(queryMessageHandler1, times(numberOfQueries)).handle(any());\n+        verify(queryMessageHandler2, times(numberOfQueries)).handle(any());\n+    }\n+\n+    @Test\n+    void testScatterGatherReturningNull() {\n+        assertNull(reactiveQueryGateway.scatterGather(0L, ResponseTypes.instanceOf(String.class), 1, TimeUnit.SECONDS)\n+                                       .blockFirst());\n+        StepVerifier.create(reactiveQueryGateway\n+                                    .scatterGather(0L, ResponseTypes.instanceOf(String.class), 1, TimeUnit.SECONDS))\n+                    .expectNext()\n+                    .verifyComplete();\n+    }\n+\n+    @Test\n+    void testScatterGatherWithDispatchInterceptor() {\n+        reactiveQueryGateway\n+                .registerDispatchInterceptor(queryMono -> queryMono\n+                        .map(query -> query.andMetaData(Collections.singletonMap(\"key1\", \"value1\"))));\n+        Registration registration2 = reactiveQueryGateway\n+                .registerDispatchInterceptor(queryMono -> queryMono\n+                        .map(query -> query.andMetaData(Collections.singletonMap(\"key2\", \"value2\"))));\n+\n+        StepVerifier.create(reactiveQueryGateway\n+                                    .scatterGather(true, ResponseTypes.instanceOf(String.class), 1, TimeUnit.SECONDS))\n+                    .expectNext(\"value1value2\")\n+                    .verifyComplete();\n+\n+        registration2.cancel();\n+\n+        StepVerifier.create(reactiveQueryGateway.query(true, String.class))\n+                    .expectNext(\"value1\")\n+                    .verifyComplete();\n+    }\n+\n+    @Test\n+    void testScatterGatherWithResultIntercept() throws Exception {\n+        reactiveQueryGateway\n+                .registerResultHandlerInterceptor(\n+                        (query, results) -> results\n+                                .map(it -> new GenericQueryResponseMessage<>(\"handled-modified\"))\n+                );\n+\n+        Flux<QueryMessage<?, ?>> queries = Flux.fromIterable(Arrays.asList(\n+                new GenericQueryMessage<>(\"query1\", ResponseTypes.instanceOf(String.class)),\n+                new GenericQueryMessage<>(4, ResponseTypes.instanceOf(Integer.class)),\n+                new GenericQueryMessage<>(\"query2\", ResponseTypes.instanceOf(String.class)),\n+                new GenericQueryMessage<>(5, ResponseTypes.instanceOf(Integer.class)),\n+                new GenericQueryMessage<>(true, ResponseTypes.instanceOf(String.class))));\n+\n+        Flux<Object> result = reactiveQueryGateway.scatterGather(queries, 1, TimeUnit.SECONDS);\n+        verifyZeroInteractions(queryMessageHandler1);\n+        verifyZeroInteractions(queryMessageHandler2);\n+\n+        StepVerifier.create(result)\n+                    .expectNext(\"handled-modified\",\n+                                \"handled-modified\",\n+                                \"handled-modified\",\n+                                \"handled-modified\",\n+                                \"handled-modified\")\n+                    .verifyComplete();\n+\n+        verify(queryMessageHandler1, times(2)).handle(any());\n+        verify(queryMessageHandler2, times(2)).handle(any());\n+    }\n+\n+    @Test\n+    void testQueryWithResultInterceptorModifyResultBasedOnQuery() throws Exception {\n+        reactiveQueryGateway.registerDispatchInterceptor(q -> q.map(it ->\n+                                                                            it.andMetaData(Collections.singletonMap(\n+                                                                                    \"block\",\n+                                                                                    it.getPayload() instanceof Boolean)\n+                                                                            )));\n+        reactiveQueryGateway\n+                .registerResultHandlerInterceptor((q, results) -> results\n+                        .filter(it -> !((boolean) q.getMetaData().get(\"block\")))\n+                );\n+\n+        Flux<QueryMessage<?, ?>> queries = Flux.fromIterable(Arrays.asList(\n+                new GenericQueryMessage<>(\"query1\", ResponseTypes.instanceOf(String.class)),\n+                new GenericQueryMessage<>(4, ResponseTypes.instanceOf(Integer.class)),\n+                new GenericQueryMessage<>(\"query2\", ResponseTypes.instanceOf(String.class)),\n+                new GenericQueryMessage<>(5, ResponseTypes.instanceOf(Integer.class)),\n+                new GenericQueryMessage<>(Boolean.TRUE, ResponseTypes.instanceOf(String.class))));\n+\n+        Flux<Object> result = reactiveQueryGateway.scatterGather(queries, 1, TimeUnit.SECONDS);\n+        verifyZeroInteractions(queryMessageHandler1);\n+        verifyZeroInteractions(queryMessageHandler2);\n+\n+        StepVerifier.create(result)\n+                    .expectNext(\"handled\", \"handled\", \"handled\", \"handled\")\n+                    .verifyComplete();\n+\n+        verify(queryMessageHandler1, times(2)).handle(any());\n+        verify(queryMessageHandler2, times(2)).handle(any());\n+    }\n+\n+    @Test\n+    void testScatterGatherWithResultInterceptReplacedWithError() throws Exception {\n+        reactiveQueryGateway\n+                .registerResultHandlerInterceptor(\n+                        (query, results) -> results.flatMap(r -> {\n+                            if (r.getPayload().equals(\"\")) {\n+                                return Flux.<ResultMessage<?>>error(new RuntimeException(\"no empty strings allowed\"));\n+                            } else {\n+                                return Flux.just(r);\n+                            }\n+                        })\n+                );\n+\n+        Flux<QueryMessage<?, ?>> queries = Flux.fromIterable(Arrays.asList(\n+                new GenericQueryMessage<>(\"query1\", ResponseTypes.instanceOf(String.class)),\n+                new GenericQueryMessage<>(4, ResponseTypes.instanceOf(Integer.class)),\n+                new GenericQueryMessage<>(\"query2\", ResponseTypes.instanceOf(String.class)),\n+                new GenericQueryMessage<>(5, ResponseTypes.instanceOf(Integer.class)),\n+                new GenericQueryMessage<>(true, ResponseTypes.instanceOf(String.class))));\n+\n+        Flux<Object> result = reactiveQueryGateway.scatterGather(queries, 1, TimeUnit.SECONDS);\n+        verifyZeroInteractions(queryMessageHandler1);\n+        verifyZeroInteractions(queryMessageHandler2);\n+\n+        StepVerifier.create(result)\n+                    .expectNext(\"handled\", \"handled\", \"handled\", \"handled\")\n+                    .expectError(RuntimeException.class)\n+                    .verify();\n+\n+        verify(queryMessageHandler1, times(2)).handle(any());\n+        verify(queryMessageHandler2, times(2)).handle(any());\n+    }\n+\n+    @Test\n+    void testScatterGatherWithDispatchInterceptorThrowingAnException() {\n+        reactiveQueryGateway\n+                .registerDispatchInterceptor(queryMono -> {\n+                    throw new RuntimeException();\n+                });\n+        StepVerifier.create(reactiveQueryGateway\n+                                    .scatterGather(true, ResponseTypes.instanceOf(String.class), 1, TimeUnit.SECONDS))\n+                    .verifyError(RuntimeException.class);\n+    }\n+\n+    @Test\n+    void testScatterGatherWithDispatchInterceptorReturningErrorMono() {\n+        reactiveQueryGateway\n+                .registerDispatchInterceptor(queryMono -> Mono.error(new RuntimeException()));\n+        StepVerifier.create(reactiveQueryGateway\n+                                    .scatterGather(true, ResponseTypes.instanceOf(String.class), 1, TimeUnit.SECONDS))\n+                    .verifyError(RuntimeException.class);\n+    }\n+\n+    @Test\n+    void testScatterGatherFails() {\n+        StepVerifier.create(reactiveQueryGateway.scatterGather(6,\n+                                                               ResponseTypes.instanceOf(Integer.class),\n+                                                               1,\n+                                                               TimeUnit.SECONDS))\n+                    .expectNextCount(0)\n+                    .verifyComplete();\n+    }\n+\n+    @Test\n+    void testScatterGatherFailsWithRetry() throws Exception {\n+        doThrow(new RuntimeException(\":(\")).when(queryBus).scatterGather(any(), anyLong(), any());\n+\n+        Flux<Integer> query = reactiveQueryGateway.scatterGather(6,\n+                                                                 ResponseTypes.instanceOf(Integer.class),\n+                                                                 1,\n+                                                                 TimeUnit.SECONDS).retry(5);\n+\n+        StepVerifier.create(query)\n+                    .verifyError();\n+\n+\n+        verify(queryBus, times(6)).scatterGather(any(), anyLong(), any());\n+    }\n+\n+\n+    @Test\n+    void testSubscriptionQuery() throws Exception {\n+        Mono<SubscriptionQueryResult<String, String>> monoResult = reactiveQueryGateway.subscriptionQuery(\"criteria\",\n+                                                                                                          String.class,\n+                                                                                                          String.class);\n+        verifyZeroInteractions(queryMessageHandler1);\n+        verifyZeroInteractions(queryMessageHandler2);\n+\n+        SubscriptionQueryResult<String, String> result = monoResult.block();\n+        assertNotNull(result);\n+        StepVerifier.create(result.initialResult())\n+                    .expectNext(\"handled\")\n+                    .verifyComplete();\n+        StepVerifier.create(result.updates()\n+                                  .doOnSubscribe(s -> {\n+                                      queryUpdateEmitter.emit(String.class, q -> true, \"update\");\n+                                      queryUpdateEmitter.complete(String.class, q -> true);\n+                                  }))\n+                    .expectNext(\"update\")\n+                    .verifyComplete();\n+        verify(queryMessageHandler1).handle(any());\n+    }\n+\n+    @Test\n+    void testMultipleSubscriptionQueries() throws Exception {\n+        Flux<SubscriptionQueryMessage<?, ?, ?>> queries = Flux.fromIterable(Arrays.asList(\n+                new GenericSubscriptionQueryMessage<>(\"query1\",\n+                                                      ResponseTypes.instanceOf(String.class),\n+                                                      ResponseTypes.instanceOf(String.class)),\n+                new GenericSubscriptionQueryMessage<>(4,\n+                                                      ResponseTypes.instanceOf(Integer.class),\n+                                                      ResponseTypes.instanceOf(String.class))));\n+\n+        Flux<SubscriptionQueryResult<?, ?>> result = reactiveQueryGateway.subscriptionQuery(queries);\n+        verifyZeroInteractions(queryMessageHandler1);\n+        verifyZeroInteractions(queryMessageHandler2);\n+        List<Mono<Object>> initialResults = new ArrayList<>(2);\n+        //noinspection unchecked\n+        result.subscribe(sqr -> initialResults.add((Mono<Object>) sqr.initialResult()));\n+        assertEquals(2, initialResults.size());\n+        StepVerifier.create(initialResults.get(0))\n+                    .expectNext(\"handled\")\n+                    .verifyComplete();\n+        StepVerifier.create(initialResults.get(1))\n+                    .verifyError(RuntimeException.class);\n+\n+        verify(queryMessageHandler1).handle(any());\n+    }\n+\n+    @Test\n+    void testMultipleSubscriptionQueriesOrdering() throws Exception {\n+        int numberOfQueries = 10_000;\n+        Flux<SubscriptionQueryMessage<?, ?, ?>> queries = Flux\n+                .fromStream(IntStream.range(0, numberOfQueries)\n+                                     .mapToObj(i -> new GenericSubscriptionQueryMessage<>(\"backpressure\",\n+                                                                                          ResponseTypes\n+                                                                                                  .instanceOf(String.class),\n+                                                                                          ResponseTypes\n+                                                                                                  .instanceOf(String.class))));\n+        List<Integer> expectedResults = IntStream.range(1, numberOfQueries + 1)\n+                                                 .boxed()\n+                                                 .collect(Collectors.toList());\n+        Flux<SubscriptionQueryResult<?, ?>> result = reactiveQueryGateway.subscriptionQuery(queries);\n+        List<Mono<Object>> initialResults = new ArrayList<>(numberOfQueries);\n+        //noinspection unchecked\n+        result.subscribe(sqr -> initialResults.add((Mono<Object>) sqr.initialResult()));\n+        assertEquals(numberOfQueries, initialResults.size());\n+        for (int i = 0; i < numberOfQueries; i++) {\n+            StepVerifier.create(initialResults.get(i))\n+                        .expectNext(expectedResults.get(i))\n+                        .verifyComplete();\n+        }\n+\n+        verify(queryMessageHandler1, times(numberOfQueries)).handle(any());\n+    }\n+\n+    @Test\n+    void testSubscriptionQueryReturningNull() {\n+        SubscriptionQueryResult<String, String> result = reactiveQueryGateway.subscriptionQuery(0L,\n+                                                                                                String.class,\n+                                                                                                String.class)\n+                                                                             .block();\n+        assertNotNull(result);\n+        assertNull(result.initialResult().block());\n+        StepVerifier.create(result.initialResult())\n+                    .expectNext()\n+                    .verifyComplete();\n+        StepVerifier.create(result.updates()\n+                                  .doOnSubscribe(s -> {\n+                                      queryUpdateEmitter.emit(Long.class, q -> true, (String) null);\n+                                      queryUpdateEmitter.complete(Long.class, q -> true);\n+                                  }))\n+                    .expectNext()\n+                    .verifyComplete();\n+    }\n+\n+    @Test\n+    void testSubscriptionQueryWithDispatchInterceptor() {\n+        reactiveQueryGateway\n+                .registerDispatchInterceptor(queryMono -> queryMono\n+                        .map(query -> query.andMetaData(Collections.singletonMap(\"key1\", \"value1\"))));\n+        Registration registration2 = reactiveQueryGateway\n+                .registerDispatchInterceptor(queryMono -> queryMono\n+                        .map(query -> query.andMetaData(Collections.singletonMap(\"key2\", \"value2\"))));\n+\n+        Mono<SubscriptionQueryResult<String, String>> monoResult = reactiveQueryGateway\n+                .subscriptionQuery(true, String.class, String.class);\n+        SubscriptionQueryResult<String, String> result = monoResult.block();\n+        assertNotNull(result);\n+        StepVerifier.create(result.initialResult())\n+                    .expectNext(\"value1value2\")\n+                    .verifyComplete();\n+\n+        registration2.cancel();\n+\n+        monoResult = reactiveQueryGateway.subscriptionQuery(true, String.class, String.class);\n+        result = monoResult.block();\n+        assertNotNull(result);\n+        StepVerifier.create(result.initialResult())\n+                    .expectNext(\"value1\")\n+                    .verifyComplete();\n+    }\n+\n+    @Test\n+    void testSubscriptionQueryWithDispatchInterceptorThrowingAnException() {\n+        reactiveQueryGateway\n+                .registerDispatchInterceptor(queryMono -> {\n+                    throw new RuntimeException();\n+                });\n+        StepVerifier.create(reactiveQueryGateway.subscriptionQuery(true, String.class, String.class))\n+                    .verifyError(RuntimeException.class);\n+    }\n+\n+    @Test\n+    void testSubscriptionQueryWithDispatchInterceptorReturningErrorMono() {\n+        reactiveQueryGateway\n+                .registerDispatchInterceptor(queryMono -> Mono.error(new RuntimeException()));\n+        StepVerifier.create(reactiveQueryGateway.subscriptionQuery(true, String.class, String.class))\n+                    .verifyError(RuntimeException.class);\n+    }\n+\n+    @Test\n+    void testSubscriptionQueryFails() {\n+        Mono<SubscriptionQueryResult<Integer, Integer>> monoResult = reactiveQueryGateway.subscriptionQuery(6,\n+                                                                                                            Integer.class,\n+                                                                                                            Integer.class);\n+        SubscriptionQueryResult<Integer, Integer> result = monoResult.block();\n+        assertNotNull(result);\n+        StepVerifier.create(result.initialResult())\n+                    .verifyError(RuntimeException.class);\n+    }\n+\n+    @Test\n+    void testSubscriptionQueryFailsRetryInitialDispatchQuery() throws Exception {\n+\n+        doThrow(new RuntimeException(\":(\")).when(queryBus).subscriptionQuery(any(), any(), anyInt());\n+\n+        Mono<SubscriptionQueryResult<Integer, Integer>> monoResult = reactiveQueryGateway.subscriptionQuery(6,\n+                                                                                                            Integer.class,\n+                                                                                                            Integer.class)\n+                                                                                         .retry(5);\n+\n+        StepVerifier.create(monoResult)\n+                    .verifyError(RuntimeException.class);\n+\n+        verify(queryBus, times(6)).subscriptionQuery(any(), any(), anyInt());\n+    }\n+\n+    @Test\n+    void testSubscriptionQueryFailsRetryInitialResult() throws Exception {\n+        Mono<SubscriptionQueryResult<Integer, Integer>> monoResult = reactiveQueryGateway.subscriptionQuery(6,\n+                                                                                                            Integer.class,\n+                                                                                                            Integer.class);\n+\n+        SubscriptionQueryResult<Integer, Integer> result = monoResult.block();\n+        assertNotNull(result);\n+        StepVerifier.create(result.initialResult().retry(5))\n+                    .verifyError(RuntimeException.class);\n+\n+        verify(queryMessageHandler3, times(6)).handle(any());\n+    }\n+\n+    @Test\n+    void testSubscriptionQuerySingleInitialResultAndUpdates() {\n+        Flux<String> result = reactiveQueryGateway.subscriptionQuery(\"6\", String.class);\n+        CountDownLatch countDownLatch = new CountDownLatch(1);\n+\n+        ScheduledExecutorService executorService = Executors.newSingleThreadScheduledExecutor();\n+        executorService.execute(() -> {\n+            try {\n+                countDownLatch.await();\n+            } catch (InterruptedException e) {\n+                fail(e.getMessage());\n+            }\n+            queryUpdateEmitter.emit(String.class, q -> true, \"1\");\n+            queryUpdateEmitter.emit(String.class, q -> true, \"2\");\n+            queryUpdateEmitter.emit(String.class, q -> true, \"3\");\n+            queryUpdateEmitter.emit(String.class, q -> true, \"4\");\n+            queryUpdateEmitter.emit(String.class, q -> true, \"5\");\n+            queryUpdateEmitter.complete(String.class, p -> true);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjgzMDY0MA=="}, "originalCommit": {"oid": "98865ab1427e4d879301c1bf542842eccc8aa3c3"}, "originalPosition": 731}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg1MzQzNTkxOnYy", "diffSide": "RIGHT", "path": "messaging/src/main/java/org/axonframework/commandhandling/gateway/DefaultReactorCommandGateway.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMFQxMTozMjowM1rOG0HXsA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMFQxNTo1MDo0N1rOG0UaJw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzI5OTg4OA==", "bodyText": "Is a new Mono needed here, or can Function.identity() be used instead of Mono::from?", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r457299888", "createdAt": "2020-07-20T11:32:03Z", "author": {"login": "sandjelkovic"}, "path": "messaging/src/main/java/org/axonframework/commandhandling/gateway/DefaultReactorCommandGateway.java", "diffHunk": "@@ -0,0 +1,252 @@\n+/*\n+ * Copyright (c) 2010-2020. Axon Framework\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.axonframework.commandhandling.gateway;\n+\n+import org.axonframework.commandhandling.*;\n+import org.axonframework.commandhandling.callbacks.ReactorCallback;\n+import org.axonframework.common.AxonConfigurationException;\n+import org.axonframework.common.Registration;\n+import org.axonframework.messaging.reactive.ReactorMessageDispatchInterceptor;\n+import org.axonframework.messaging.reactive.ReactorResultHandlerInterceptor;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Mono;\n+import reactor.util.function.Tuple2;\n+\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.concurrent.CopyOnWriteArrayList;\n+\n+import static java.util.Arrays.asList;\n+import static org.axonframework.common.BuilderUtils.assertNonNull;\n+\n+/**\n+ * Implementation of the {@link ReactorCommandGateway} that uses Project Reactor to achieve reactiveness.\n+ *\n+ * @author Milan Savic\n+ * @since 4.4\n+ */\n+public class DefaultReactorCommandGateway implements ReactorCommandGateway {\n+\n+    private final CommandBus commandBus;\n+    private final RetryScheduler retryScheduler;\n+    private final List<ReactorMessageDispatchInterceptor<CommandMessage<?>>> dispatchInterceptors;\n+    private final List<ReactorResultHandlerInterceptor<CommandMessage<?>, CommandResultMessage<?>>> resultInterceptors;\n+\n+    /**\n+     * Creates an instance of {@link DefaultReactorCommandGateway} based on the fields contained in the {@link\n+     * Builder}.\n+     * <p>\n+     * Will assert that the {@link CommandBus} is not {@code null} and throws an {@link AxonConfigurationException} if\n+     * it is.\n+     * </p>\n+     *\n+     * @param builder the {@link Builder} used to instantiate a {@link DefaultReactorCommandGateway} instance\n+     */\n+    protected DefaultReactorCommandGateway(Builder builder) {\n+        builder.validate();\n+        this.commandBus = builder.commandBus;\n+        this.retryScheduler = builder.retryScheduler;\n+        this.dispatchInterceptors = builder.dispatchInterceptors;\n+        this.resultInterceptors = builder.resultInterceptors;\n+    }\n+\n+    /**\n+     * Instantiate a Builder to be able to create a {@link DefaultReactorCommandGateway}.\n+     * <p>\n+     * The {@code dispatchInterceptors} are defaulted to an empty list.\n+     * The {@code resultHandlerInterceptors} are defaulted to an empty list.\n+     * The {@link CommandBus} is a <b>hard requirement</b> and as such should be provided.\n+     * </p>\n+     *\n+     * @return a Builder to be able to create a {@link DefaultReactorCommandGateway}\n+     */\n+    public static Builder builder() {\n+        return new Builder();\n+    }\n+\n+    @Override\n+    public <R> Mono<R> send(Object command) {\n+        //noinspection unchecked\n+        return Mono.<CommandMessage<?>>just(GenericCommandMessage.asCommandMessage(command))\n+                .transform(this::processCommandInterceptors)\n+                .flatMap(this::dispatchCommand)\n+                .flatMap(this::processResultsInterceptors)\n+                .transform(this::getPayload);\n+    }\n+\n+    @Override\n+    public Registration registerDispatchInterceptor(ReactorMessageDispatchInterceptor<CommandMessage<?>> interceptor) {\n+        dispatchInterceptors.add(interceptor);\n+        return () -> dispatchInterceptors.remove(interceptor);\n+    }\n+\n+    @Override\n+    public Registration registerResultHandlerInterceptor(\n+            ReactorResultHandlerInterceptor<CommandMessage<?>, CommandResultMessage<?>> interceptor) {\n+        resultInterceptors.add(interceptor);\n+        return () -> resultInterceptors.remove(interceptor);\n+    }\n+\n+    private Mono<CommandMessage<?>> processCommandInterceptors(Mono<CommandMessage<?>> commandMessage) {\n+        return Flux.fromIterable(dispatchInterceptors)\n+                   .reduce(commandMessage, (command, interceptor) -> interceptor.intercept(command))\n+                   .flatMap(Mono::from);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3697d15e2f6025bbb49a23e02e7c24c79f341d2e"}, "originalPosition": 107}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzQ3NzM3OA==", "bodyText": "Not sure I follow how you'd use Function.identity() in this case. Could you provide an example?", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r457477378", "createdAt": "2020-07-20T15:10:47Z", "author": {"login": "m1l4n54v1c"}, "path": "messaging/src/main/java/org/axonframework/commandhandling/gateway/DefaultReactorCommandGateway.java", "diffHunk": "@@ -0,0 +1,252 @@\n+/*\n+ * Copyright (c) 2010-2020. Axon Framework\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.axonframework.commandhandling.gateway;\n+\n+import org.axonframework.commandhandling.*;\n+import org.axonframework.commandhandling.callbacks.ReactorCallback;\n+import org.axonframework.common.AxonConfigurationException;\n+import org.axonframework.common.Registration;\n+import org.axonframework.messaging.reactive.ReactorMessageDispatchInterceptor;\n+import org.axonframework.messaging.reactive.ReactorResultHandlerInterceptor;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Mono;\n+import reactor.util.function.Tuple2;\n+\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.concurrent.CopyOnWriteArrayList;\n+\n+import static java.util.Arrays.asList;\n+import static org.axonframework.common.BuilderUtils.assertNonNull;\n+\n+/**\n+ * Implementation of the {@link ReactorCommandGateway} that uses Project Reactor to achieve reactiveness.\n+ *\n+ * @author Milan Savic\n+ * @since 4.4\n+ */\n+public class DefaultReactorCommandGateway implements ReactorCommandGateway {\n+\n+    private final CommandBus commandBus;\n+    private final RetryScheduler retryScheduler;\n+    private final List<ReactorMessageDispatchInterceptor<CommandMessage<?>>> dispatchInterceptors;\n+    private final List<ReactorResultHandlerInterceptor<CommandMessage<?>, CommandResultMessage<?>>> resultInterceptors;\n+\n+    /**\n+     * Creates an instance of {@link DefaultReactorCommandGateway} based on the fields contained in the {@link\n+     * Builder}.\n+     * <p>\n+     * Will assert that the {@link CommandBus} is not {@code null} and throws an {@link AxonConfigurationException} if\n+     * it is.\n+     * </p>\n+     *\n+     * @param builder the {@link Builder} used to instantiate a {@link DefaultReactorCommandGateway} instance\n+     */\n+    protected DefaultReactorCommandGateway(Builder builder) {\n+        builder.validate();\n+        this.commandBus = builder.commandBus;\n+        this.retryScheduler = builder.retryScheduler;\n+        this.dispatchInterceptors = builder.dispatchInterceptors;\n+        this.resultInterceptors = builder.resultInterceptors;\n+    }\n+\n+    /**\n+     * Instantiate a Builder to be able to create a {@link DefaultReactorCommandGateway}.\n+     * <p>\n+     * The {@code dispatchInterceptors} are defaulted to an empty list.\n+     * The {@code resultHandlerInterceptors} are defaulted to an empty list.\n+     * The {@link CommandBus} is a <b>hard requirement</b> and as such should be provided.\n+     * </p>\n+     *\n+     * @return a Builder to be able to create a {@link DefaultReactorCommandGateway}\n+     */\n+    public static Builder builder() {\n+        return new Builder();\n+    }\n+\n+    @Override\n+    public <R> Mono<R> send(Object command) {\n+        //noinspection unchecked\n+        return Mono.<CommandMessage<?>>just(GenericCommandMessage.asCommandMessage(command))\n+                .transform(this::processCommandInterceptors)\n+                .flatMap(this::dispatchCommand)\n+                .flatMap(this::processResultsInterceptors)\n+                .transform(this::getPayload);\n+    }\n+\n+    @Override\n+    public Registration registerDispatchInterceptor(ReactorMessageDispatchInterceptor<CommandMessage<?>> interceptor) {\n+        dispatchInterceptors.add(interceptor);\n+        return () -> dispatchInterceptors.remove(interceptor);\n+    }\n+\n+    @Override\n+    public Registration registerResultHandlerInterceptor(\n+            ReactorResultHandlerInterceptor<CommandMessage<?>, CommandResultMessage<?>> interceptor) {\n+        resultInterceptors.add(interceptor);\n+        return () -> resultInterceptors.remove(interceptor);\n+    }\n+\n+    private Mono<CommandMessage<?>> processCommandInterceptors(Mono<CommandMessage<?>> commandMessage) {\n+        return Flux.fromIterable(dispatchInterceptors)\n+                   .reduce(commandMessage, (command, interceptor) -> interceptor.intercept(command))\n+                   .flatMap(Mono::from);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzI5OTg4OA=="}, "originalCommit": {"oid": "3697d15e2f6025bbb49a23e02e7c24c79f341d2e"}, "originalPosition": 107}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzUxMzUxMQ==", "bodyText": "Since at this point when flatMap is called, the variable is of type Mono<Mono<CommandMessage<?>>>. Unless there's a special reason to use Mono.from to create another Mono from a Mono (wrapping inner one), it can be simplified to flatMap(it -> it) to use the already existing inner Mono instance directly. In this case, Function.identity() would replace it -> it lambda expression, same as here", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r457513511", "createdAt": "2020-07-20T15:50:47Z", "author": {"login": "sandjelkovic"}, "path": "messaging/src/main/java/org/axonframework/commandhandling/gateway/DefaultReactorCommandGateway.java", "diffHunk": "@@ -0,0 +1,252 @@\n+/*\n+ * Copyright (c) 2010-2020. Axon Framework\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.axonframework.commandhandling.gateway;\n+\n+import org.axonframework.commandhandling.*;\n+import org.axonframework.commandhandling.callbacks.ReactorCallback;\n+import org.axonframework.common.AxonConfigurationException;\n+import org.axonframework.common.Registration;\n+import org.axonframework.messaging.reactive.ReactorMessageDispatchInterceptor;\n+import org.axonframework.messaging.reactive.ReactorResultHandlerInterceptor;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Mono;\n+import reactor.util.function.Tuple2;\n+\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.concurrent.CopyOnWriteArrayList;\n+\n+import static java.util.Arrays.asList;\n+import static org.axonframework.common.BuilderUtils.assertNonNull;\n+\n+/**\n+ * Implementation of the {@link ReactorCommandGateway} that uses Project Reactor to achieve reactiveness.\n+ *\n+ * @author Milan Savic\n+ * @since 4.4\n+ */\n+public class DefaultReactorCommandGateway implements ReactorCommandGateway {\n+\n+    private final CommandBus commandBus;\n+    private final RetryScheduler retryScheduler;\n+    private final List<ReactorMessageDispatchInterceptor<CommandMessage<?>>> dispatchInterceptors;\n+    private final List<ReactorResultHandlerInterceptor<CommandMessage<?>, CommandResultMessage<?>>> resultInterceptors;\n+\n+    /**\n+     * Creates an instance of {@link DefaultReactorCommandGateway} based on the fields contained in the {@link\n+     * Builder}.\n+     * <p>\n+     * Will assert that the {@link CommandBus} is not {@code null} and throws an {@link AxonConfigurationException} if\n+     * it is.\n+     * </p>\n+     *\n+     * @param builder the {@link Builder} used to instantiate a {@link DefaultReactorCommandGateway} instance\n+     */\n+    protected DefaultReactorCommandGateway(Builder builder) {\n+        builder.validate();\n+        this.commandBus = builder.commandBus;\n+        this.retryScheduler = builder.retryScheduler;\n+        this.dispatchInterceptors = builder.dispatchInterceptors;\n+        this.resultInterceptors = builder.resultInterceptors;\n+    }\n+\n+    /**\n+     * Instantiate a Builder to be able to create a {@link DefaultReactorCommandGateway}.\n+     * <p>\n+     * The {@code dispatchInterceptors} are defaulted to an empty list.\n+     * The {@code resultHandlerInterceptors} are defaulted to an empty list.\n+     * The {@link CommandBus} is a <b>hard requirement</b> and as such should be provided.\n+     * </p>\n+     *\n+     * @return a Builder to be able to create a {@link DefaultReactorCommandGateway}\n+     */\n+    public static Builder builder() {\n+        return new Builder();\n+    }\n+\n+    @Override\n+    public <R> Mono<R> send(Object command) {\n+        //noinspection unchecked\n+        return Mono.<CommandMessage<?>>just(GenericCommandMessage.asCommandMessage(command))\n+                .transform(this::processCommandInterceptors)\n+                .flatMap(this::dispatchCommand)\n+                .flatMap(this::processResultsInterceptors)\n+                .transform(this::getPayload);\n+    }\n+\n+    @Override\n+    public Registration registerDispatchInterceptor(ReactorMessageDispatchInterceptor<CommandMessage<?>> interceptor) {\n+        dispatchInterceptors.add(interceptor);\n+        return () -> dispatchInterceptors.remove(interceptor);\n+    }\n+\n+    @Override\n+    public Registration registerResultHandlerInterceptor(\n+            ReactorResultHandlerInterceptor<CommandMessage<?>, CommandResultMessage<?>> interceptor) {\n+        resultInterceptors.add(interceptor);\n+        return () -> resultInterceptors.remove(interceptor);\n+    }\n+\n+    private Mono<CommandMessage<?>> processCommandInterceptors(Mono<CommandMessage<?>> commandMessage) {\n+        return Flux.fromIterable(dispatchInterceptors)\n+                   .reduce(commandMessage, (command, interceptor) -> interceptor.intercept(command))\n+                   .flatMap(Mono::from);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzI5OTg4OA=="}, "originalCommit": {"oid": "3697d15e2f6025bbb49a23e02e7c24c79f341d2e"}, "originalPosition": 107}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg1MzQ2NjkxOnYy", "diffSide": "RIGHT", "path": "messaging/src/main/java/org/axonframework/commandhandling/gateway/DefaultReactorCommandGateway.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMFQxMTozOTo1MVrOG0HqPg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMFQxNToxMTo1MlrOG0SRqw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzMwNDYzOA==", "bodyText": "Can this be a Mono<CommandResultMessage<? extends R>> instead of Flux<CommandResultMessage<? extends R>>.\nFor a full return value signature of Mono<Tuple2<CommandMessage<C>, Mono<CommandResultMessage<? extends R>>>>", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r457304638", "createdAt": "2020-07-20T11:39:51Z", "author": {"login": "sandjelkovic"}, "path": "messaging/src/main/java/org/axonframework/commandhandling/gateway/DefaultReactorCommandGateway.java", "diffHunk": "@@ -0,0 +1,252 @@\n+/*\n+ * Copyright (c) 2010-2020. Axon Framework\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.axonframework.commandhandling.gateway;\n+\n+import org.axonframework.commandhandling.*;\n+import org.axonframework.commandhandling.callbacks.ReactorCallback;\n+import org.axonframework.common.AxonConfigurationException;\n+import org.axonframework.common.Registration;\n+import org.axonframework.messaging.reactive.ReactorMessageDispatchInterceptor;\n+import org.axonframework.messaging.reactive.ReactorResultHandlerInterceptor;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Mono;\n+import reactor.util.function.Tuple2;\n+\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.concurrent.CopyOnWriteArrayList;\n+\n+import static java.util.Arrays.asList;\n+import static org.axonframework.common.BuilderUtils.assertNonNull;\n+\n+/**\n+ * Implementation of the {@link ReactorCommandGateway} that uses Project Reactor to achieve reactiveness.\n+ *\n+ * @author Milan Savic\n+ * @since 4.4\n+ */\n+public class DefaultReactorCommandGateway implements ReactorCommandGateway {\n+\n+    private final CommandBus commandBus;\n+    private final RetryScheduler retryScheduler;\n+    private final List<ReactorMessageDispatchInterceptor<CommandMessage<?>>> dispatchInterceptors;\n+    private final List<ReactorResultHandlerInterceptor<CommandMessage<?>, CommandResultMessage<?>>> resultInterceptors;\n+\n+    /**\n+     * Creates an instance of {@link DefaultReactorCommandGateway} based on the fields contained in the {@link\n+     * Builder}.\n+     * <p>\n+     * Will assert that the {@link CommandBus} is not {@code null} and throws an {@link AxonConfigurationException} if\n+     * it is.\n+     * </p>\n+     *\n+     * @param builder the {@link Builder} used to instantiate a {@link DefaultReactorCommandGateway} instance\n+     */\n+    protected DefaultReactorCommandGateway(Builder builder) {\n+        builder.validate();\n+        this.commandBus = builder.commandBus;\n+        this.retryScheduler = builder.retryScheduler;\n+        this.dispatchInterceptors = builder.dispatchInterceptors;\n+        this.resultInterceptors = builder.resultInterceptors;\n+    }\n+\n+    /**\n+     * Instantiate a Builder to be able to create a {@link DefaultReactorCommandGateway}.\n+     * <p>\n+     * The {@code dispatchInterceptors} are defaulted to an empty list.\n+     * The {@code resultHandlerInterceptors} are defaulted to an empty list.\n+     * The {@link CommandBus} is a <b>hard requirement</b> and as such should be provided.\n+     * </p>\n+     *\n+     * @return a Builder to be able to create a {@link DefaultReactorCommandGateway}\n+     */\n+    public static Builder builder() {\n+        return new Builder();\n+    }\n+\n+    @Override\n+    public <R> Mono<R> send(Object command) {\n+        //noinspection unchecked\n+        return Mono.<CommandMessage<?>>just(GenericCommandMessage.asCommandMessage(command))\n+                .transform(this::processCommandInterceptors)\n+                .flatMap(this::dispatchCommand)\n+                .flatMap(this::processResultsInterceptors)\n+                .transform(this::getPayload);\n+    }\n+\n+    @Override\n+    public Registration registerDispatchInterceptor(ReactorMessageDispatchInterceptor<CommandMessage<?>> interceptor) {\n+        dispatchInterceptors.add(interceptor);\n+        return () -> dispatchInterceptors.remove(interceptor);\n+    }\n+\n+    @Override\n+    public Registration registerResultHandlerInterceptor(\n+            ReactorResultHandlerInterceptor<CommandMessage<?>, CommandResultMessage<?>> interceptor) {\n+        resultInterceptors.add(interceptor);\n+        return () -> resultInterceptors.remove(interceptor);\n+    }\n+\n+    private Mono<CommandMessage<?>> processCommandInterceptors(Mono<CommandMessage<?>> commandMessage) {\n+        return Flux.fromIterable(dispatchInterceptors)\n+                   .reduce(commandMessage, (command, interceptor) -> interceptor.intercept(command))\n+                   .flatMap(Mono::from);\n+    }\n+\n+    private <C, R> Mono<Tuple2<CommandMessage<C>, Flux<CommandResultMessage<? extends R>>>> dispatchCommand(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3697d15e2f6025bbb49a23e02e7c24c79f341d2e"}, "originalPosition": 110}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzQ3ODU3MQ==", "bodyText": "No, since result interceptors work with a flux.", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r457478571", "createdAt": "2020-07-20T15:11:52Z", "author": {"login": "m1l4n54v1c"}, "path": "messaging/src/main/java/org/axonframework/commandhandling/gateway/DefaultReactorCommandGateway.java", "diffHunk": "@@ -0,0 +1,252 @@\n+/*\n+ * Copyright (c) 2010-2020. Axon Framework\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.axonframework.commandhandling.gateway;\n+\n+import org.axonframework.commandhandling.*;\n+import org.axonframework.commandhandling.callbacks.ReactorCallback;\n+import org.axonframework.common.AxonConfigurationException;\n+import org.axonframework.common.Registration;\n+import org.axonframework.messaging.reactive.ReactorMessageDispatchInterceptor;\n+import org.axonframework.messaging.reactive.ReactorResultHandlerInterceptor;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Mono;\n+import reactor.util.function.Tuple2;\n+\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.concurrent.CopyOnWriteArrayList;\n+\n+import static java.util.Arrays.asList;\n+import static org.axonframework.common.BuilderUtils.assertNonNull;\n+\n+/**\n+ * Implementation of the {@link ReactorCommandGateway} that uses Project Reactor to achieve reactiveness.\n+ *\n+ * @author Milan Savic\n+ * @since 4.4\n+ */\n+public class DefaultReactorCommandGateway implements ReactorCommandGateway {\n+\n+    private final CommandBus commandBus;\n+    private final RetryScheduler retryScheduler;\n+    private final List<ReactorMessageDispatchInterceptor<CommandMessage<?>>> dispatchInterceptors;\n+    private final List<ReactorResultHandlerInterceptor<CommandMessage<?>, CommandResultMessage<?>>> resultInterceptors;\n+\n+    /**\n+     * Creates an instance of {@link DefaultReactorCommandGateway} based on the fields contained in the {@link\n+     * Builder}.\n+     * <p>\n+     * Will assert that the {@link CommandBus} is not {@code null} and throws an {@link AxonConfigurationException} if\n+     * it is.\n+     * </p>\n+     *\n+     * @param builder the {@link Builder} used to instantiate a {@link DefaultReactorCommandGateway} instance\n+     */\n+    protected DefaultReactorCommandGateway(Builder builder) {\n+        builder.validate();\n+        this.commandBus = builder.commandBus;\n+        this.retryScheduler = builder.retryScheduler;\n+        this.dispatchInterceptors = builder.dispatchInterceptors;\n+        this.resultInterceptors = builder.resultInterceptors;\n+    }\n+\n+    /**\n+     * Instantiate a Builder to be able to create a {@link DefaultReactorCommandGateway}.\n+     * <p>\n+     * The {@code dispatchInterceptors} are defaulted to an empty list.\n+     * The {@code resultHandlerInterceptors} are defaulted to an empty list.\n+     * The {@link CommandBus} is a <b>hard requirement</b> and as such should be provided.\n+     * </p>\n+     *\n+     * @return a Builder to be able to create a {@link DefaultReactorCommandGateway}\n+     */\n+    public static Builder builder() {\n+        return new Builder();\n+    }\n+\n+    @Override\n+    public <R> Mono<R> send(Object command) {\n+        //noinspection unchecked\n+        return Mono.<CommandMessage<?>>just(GenericCommandMessage.asCommandMessage(command))\n+                .transform(this::processCommandInterceptors)\n+                .flatMap(this::dispatchCommand)\n+                .flatMap(this::processResultsInterceptors)\n+                .transform(this::getPayload);\n+    }\n+\n+    @Override\n+    public Registration registerDispatchInterceptor(ReactorMessageDispatchInterceptor<CommandMessage<?>> interceptor) {\n+        dispatchInterceptors.add(interceptor);\n+        return () -> dispatchInterceptors.remove(interceptor);\n+    }\n+\n+    @Override\n+    public Registration registerResultHandlerInterceptor(\n+            ReactorResultHandlerInterceptor<CommandMessage<?>, CommandResultMessage<?>> interceptor) {\n+        resultInterceptors.add(interceptor);\n+        return () -> resultInterceptors.remove(interceptor);\n+    }\n+\n+    private Mono<CommandMessage<?>> processCommandInterceptors(Mono<CommandMessage<?>> commandMessage) {\n+        return Flux.fromIterable(dispatchInterceptors)\n+                   .reduce(commandMessage, (command, interceptor) -> interceptor.intercept(command))\n+                   .flatMap(Mono::from);\n+    }\n+\n+    private <C, R> Mono<Tuple2<CommandMessage<C>, Flux<CommandResultMessage<? extends R>>>> dispatchCommand(", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzMwNDYzOA=="}, "originalCommit": {"oid": "3697d15e2f6025bbb49a23e02e7c24c79f341d2e"}, "originalPosition": 110}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg1MzUwOTY3OnYy", "diffSide": "RIGHT", "path": "messaging/src/main/java/org/axonframework/commandhandling/gateway/DefaultReactorCommandGateway.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMFQxMTo0ODo1NVrOG0IByQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMFQxNToxMjo1OFrOG0SWKg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzMxMDY2NQ==", "bodyText": "Considering that Command handling can provide only one result, shouldn't this also be a Mono<CommandResultMessage<?>> instead of a Flux<CommandResultMessage<?>>?", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r457310665", "createdAt": "2020-07-20T11:48:55Z", "author": {"login": "sandjelkovic"}, "path": "messaging/src/main/java/org/axonframework/commandhandling/gateway/DefaultReactorCommandGateway.java", "diffHunk": "@@ -0,0 +1,252 @@\n+/*\n+ * Copyright (c) 2010-2020. Axon Framework\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.axonframework.commandhandling.gateway;\n+\n+import org.axonframework.commandhandling.*;\n+import org.axonframework.commandhandling.callbacks.ReactorCallback;\n+import org.axonframework.common.AxonConfigurationException;\n+import org.axonframework.common.Registration;\n+import org.axonframework.messaging.reactive.ReactorMessageDispatchInterceptor;\n+import org.axonframework.messaging.reactive.ReactorResultHandlerInterceptor;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Mono;\n+import reactor.util.function.Tuple2;\n+\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.concurrent.CopyOnWriteArrayList;\n+\n+import static java.util.Arrays.asList;\n+import static org.axonframework.common.BuilderUtils.assertNonNull;\n+\n+/**\n+ * Implementation of the {@link ReactorCommandGateway} that uses Project Reactor to achieve reactiveness.\n+ *\n+ * @author Milan Savic\n+ * @since 4.4\n+ */\n+public class DefaultReactorCommandGateway implements ReactorCommandGateway {\n+\n+    private final CommandBus commandBus;\n+    private final RetryScheduler retryScheduler;\n+    private final List<ReactorMessageDispatchInterceptor<CommandMessage<?>>> dispatchInterceptors;\n+    private final List<ReactorResultHandlerInterceptor<CommandMessage<?>, CommandResultMessage<?>>> resultInterceptors;\n+\n+    /**\n+     * Creates an instance of {@link DefaultReactorCommandGateway} based on the fields contained in the {@link\n+     * Builder}.\n+     * <p>\n+     * Will assert that the {@link CommandBus} is not {@code null} and throws an {@link AxonConfigurationException} if\n+     * it is.\n+     * </p>\n+     *\n+     * @param builder the {@link Builder} used to instantiate a {@link DefaultReactorCommandGateway} instance\n+     */\n+    protected DefaultReactorCommandGateway(Builder builder) {\n+        builder.validate();\n+        this.commandBus = builder.commandBus;\n+        this.retryScheduler = builder.retryScheduler;\n+        this.dispatchInterceptors = builder.dispatchInterceptors;\n+        this.resultInterceptors = builder.resultInterceptors;\n+    }\n+\n+    /**\n+     * Instantiate a Builder to be able to create a {@link DefaultReactorCommandGateway}.\n+     * <p>\n+     * The {@code dispatchInterceptors} are defaulted to an empty list.\n+     * The {@code resultHandlerInterceptors} are defaulted to an empty list.\n+     * The {@link CommandBus} is a <b>hard requirement</b> and as such should be provided.\n+     * </p>\n+     *\n+     * @return a Builder to be able to create a {@link DefaultReactorCommandGateway}\n+     */\n+    public static Builder builder() {\n+        return new Builder();\n+    }\n+\n+    @Override\n+    public <R> Mono<R> send(Object command) {\n+        //noinspection unchecked\n+        return Mono.<CommandMessage<?>>just(GenericCommandMessage.asCommandMessage(command))\n+                .transform(this::processCommandInterceptors)\n+                .flatMap(this::dispatchCommand)\n+                .flatMap(this::processResultsInterceptors)\n+                .transform(this::getPayload);\n+    }\n+\n+    @Override\n+    public Registration registerDispatchInterceptor(ReactorMessageDispatchInterceptor<CommandMessage<?>> interceptor) {\n+        dispatchInterceptors.add(interceptor);\n+        return () -> dispatchInterceptors.remove(interceptor);\n+    }\n+\n+    @Override\n+    public Registration registerResultHandlerInterceptor(\n+            ReactorResultHandlerInterceptor<CommandMessage<?>, CommandResultMessage<?>> interceptor) {\n+        resultInterceptors.add(interceptor);\n+        return () -> resultInterceptors.remove(interceptor);\n+    }\n+\n+    private Mono<CommandMessage<?>> processCommandInterceptors(Mono<CommandMessage<?>> commandMessage) {\n+        return Flux.fromIterable(dispatchInterceptors)\n+                   .reduce(commandMessage, (command, interceptor) -> interceptor.intercept(command))\n+                   .flatMap(Mono::from);\n+    }\n+\n+    private <C, R> Mono<Tuple2<CommandMessage<C>, Flux<CommandResultMessage<? extends R>>>> dispatchCommand(\n+            CommandMessage<C> commandMessage) {\n+        ReactorCallback<C, R> reactorCallback = new ReactorCallback<>();\n+        CommandCallback<C, R> callback = reactorCallback;\n+        if (retryScheduler != null) {\n+            callback = new RetryingCallback<>(callback, retryScheduler, commandBus);\n+        }\n+        commandBus.dispatch(commandMessage, callback);\n+        return Mono.just(commandMessage).zipWith(Mono.just(Flux.from(reactorCallback)));\n+    }\n+\n+    private <C> Mono<? extends CommandResultMessage<?>> processResultsInterceptors(\n+            Tuple2<CommandMessage<C>, Flux<CommandResultMessage<?>>> commandWithResults) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3697d15e2f6025bbb49a23e02e7c24c79f341d2e"}, "originalPosition": 122}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzQ3OTcyMg==", "bodyText": "The same reason I stated for the previous comment.", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r457479722", "createdAt": "2020-07-20T15:12:58Z", "author": {"login": "m1l4n54v1c"}, "path": "messaging/src/main/java/org/axonframework/commandhandling/gateway/DefaultReactorCommandGateway.java", "diffHunk": "@@ -0,0 +1,252 @@\n+/*\n+ * Copyright (c) 2010-2020. Axon Framework\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.axonframework.commandhandling.gateway;\n+\n+import org.axonframework.commandhandling.*;\n+import org.axonframework.commandhandling.callbacks.ReactorCallback;\n+import org.axonframework.common.AxonConfigurationException;\n+import org.axonframework.common.Registration;\n+import org.axonframework.messaging.reactive.ReactorMessageDispatchInterceptor;\n+import org.axonframework.messaging.reactive.ReactorResultHandlerInterceptor;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Mono;\n+import reactor.util.function.Tuple2;\n+\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.concurrent.CopyOnWriteArrayList;\n+\n+import static java.util.Arrays.asList;\n+import static org.axonframework.common.BuilderUtils.assertNonNull;\n+\n+/**\n+ * Implementation of the {@link ReactorCommandGateway} that uses Project Reactor to achieve reactiveness.\n+ *\n+ * @author Milan Savic\n+ * @since 4.4\n+ */\n+public class DefaultReactorCommandGateway implements ReactorCommandGateway {\n+\n+    private final CommandBus commandBus;\n+    private final RetryScheduler retryScheduler;\n+    private final List<ReactorMessageDispatchInterceptor<CommandMessage<?>>> dispatchInterceptors;\n+    private final List<ReactorResultHandlerInterceptor<CommandMessage<?>, CommandResultMessage<?>>> resultInterceptors;\n+\n+    /**\n+     * Creates an instance of {@link DefaultReactorCommandGateway} based on the fields contained in the {@link\n+     * Builder}.\n+     * <p>\n+     * Will assert that the {@link CommandBus} is not {@code null} and throws an {@link AxonConfigurationException} if\n+     * it is.\n+     * </p>\n+     *\n+     * @param builder the {@link Builder} used to instantiate a {@link DefaultReactorCommandGateway} instance\n+     */\n+    protected DefaultReactorCommandGateway(Builder builder) {\n+        builder.validate();\n+        this.commandBus = builder.commandBus;\n+        this.retryScheduler = builder.retryScheduler;\n+        this.dispatchInterceptors = builder.dispatchInterceptors;\n+        this.resultInterceptors = builder.resultInterceptors;\n+    }\n+\n+    /**\n+     * Instantiate a Builder to be able to create a {@link DefaultReactorCommandGateway}.\n+     * <p>\n+     * The {@code dispatchInterceptors} are defaulted to an empty list.\n+     * The {@code resultHandlerInterceptors} are defaulted to an empty list.\n+     * The {@link CommandBus} is a <b>hard requirement</b> and as such should be provided.\n+     * </p>\n+     *\n+     * @return a Builder to be able to create a {@link DefaultReactorCommandGateway}\n+     */\n+    public static Builder builder() {\n+        return new Builder();\n+    }\n+\n+    @Override\n+    public <R> Mono<R> send(Object command) {\n+        //noinspection unchecked\n+        return Mono.<CommandMessage<?>>just(GenericCommandMessage.asCommandMessage(command))\n+                .transform(this::processCommandInterceptors)\n+                .flatMap(this::dispatchCommand)\n+                .flatMap(this::processResultsInterceptors)\n+                .transform(this::getPayload);\n+    }\n+\n+    @Override\n+    public Registration registerDispatchInterceptor(ReactorMessageDispatchInterceptor<CommandMessage<?>> interceptor) {\n+        dispatchInterceptors.add(interceptor);\n+        return () -> dispatchInterceptors.remove(interceptor);\n+    }\n+\n+    @Override\n+    public Registration registerResultHandlerInterceptor(\n+            ReactorResultHandlerInterceptor<CommandMessage<?>, CommandResultMessage<?>> interceptor) {\n+        resultInterceptors.add(interceptor);\n+        return () -> resultInterceptors.remove(interceptor);\n+    }\n+\n+    private Mono<CommandMessage<?>> processCommandInterceptors(Mono<CommandMessage<?>> commandMessage) {\n+        return Flux.fromIterable(dispatchInterceptors)\n+                   .reduce(commandMessage, (command, interceptor) -> interceptor.intercept(command))\n+                   .flatMap(Mono::from);\n+    }\n+\n+    private <C, R> Mono<Tuple2<CommandMessage<C>, Flux<CommandResultMessage<? extends R>>>> dispatchCommand(\n+            CommandMessage<C> commandMessage) {\n+        ReactorCallback<C, R> reactorCallback = new ReactorCallback<>();\n+        CommandCallback<C, R> callback = reactorCallback;\n+        if (retryScheduler != null) {\n+            callback = new RetryingCallback<>(callback, retryScheduler, commandBus);\n+        }\n+        commandBus.dispatch(commandMessage, callback);\n+        return Mono.just(commandMessage).zipWith(Mono.just(Flux.from(reactorCallback)));\n+    }\n+\n+    private <C> Mono<? extends CommandResultMessage<?>> processResultsInterceptors(\n+            Tuple2<CommandMessage<C>, Flux<CommandResultMessage<?>>> commandWithResults) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzMxMDY2NQ=="}, "originalCommit": {"oid": "3697d15e2f6025bbb49a23e02e7c24c79f341d2e"}, "originalPosition": 122}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg1MzU5MDI4OnYy", "diffSide": "RIGHT", "path": "messaging/src/main/java/org/axonframework/queryhandling/DefaultReactorQueryGateway.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMFQxMjowNTo1N1rOG0IuTw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMFQxMjowNTo1N1rOG0IuTw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzMyMjA2Mw==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                               .flatMapMany(it -> it);\n          \n          \n            \n                               .flatMapMany(Function.identity());", "url": "https://github.com/AxonFramework/AxonFramework/pull/1337#discussion_r457322063", "createdAt": "2020-07-20T12:05:57Z", "author": {"login": "sandjelkovic"}, "path": "messaging/src/main/java/org/axonframework/queryhandling/DefaultReactorQueryGateway.java", "diffHunk": "@@ -0,0 +1,318 @@\n+/*\n+ * Copyright (c) 2010-2020. Axon Framework\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.axonframework.queryhandling;\n+\n+import org.axonframework.commandhandling.CommandResultMessage;\n+import org.axonframework.common.AxonConfigurationException;\n+import org.axonframework.common.Registration;\n+import org.axonframework.messaging.ResultMessage;\n+import org.axonframework.messaging.reactive.ReactorMessageDispatchInterceptor;\n+import org.axonframework.messaging.reactive.ReactorResultHandlerInterceptor;\n+import org.axonframework.messaging.responsetypes.ResponseType;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Mono;\n+import reactor.util.function.Tuple2;\n+\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.concurrent.CopyOnWriteArrayList;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Function;\n+\n+import static java.util.Arrays.asList;\n+import static org.axonframework.common.BuilderUtils.assertNonNull;\n+import static org.axonframework.messaging.GenericMessage.asMessage;\n+\n+/**\n+ * Implementation of the {@link ReactorQueryGateway} that uses Project Reactor to achieve reactiveness.\n+ *\n+ * @author Milan Savic\n+ * @since 4.4\n+ */\n+public class DefaultReactorQueryGateway implements ReactorQueryGateway {\n+\n+    private final List<ReactorMessageDispatchInterceptor<QueryMessage<?, ?>>> dispatchInterceptors;\n+    private final List<ReactorResultHandlerInterceptor<QueryMessage<?, ?>, ResultMessage<?>>> resultInterceptors;\n+\n+    private final QueryBus queryBus;\n+\n+    /**\n+     * Creates an instance of {@link DefaultReactorQueryGateway} based on the fields contained in the {@link\n+     * Builder}.\n+     * <p>\n+     * Will assert that the {@link QueryBus} is not {@code null} and throws an {@link AxonConfigurationException} if\n+     * it is.\n+     * </p>\n+     *\n+     * @param builder the {@link Builder} used to instantiated a {@link DefaultReactorQueryGateway} instance\n+     */\n+    protected DefaultReactorQueryGateway(Builder builder) {\n+        builder.validate();\n+        this.queryBus = builder.queryBus;\n+        this.dispatchInterceptors = builder.dispatchInterceptors;\n+        this.resultInterceptors = builder.resultInterceptors;\n+    }\n+\n+    /**\n+     * Instantiate a Builder to be able to create a {@link DefaultReactorQueryGateway}.\n+     * <p>\n+     * The {@code dispatchInterceptors} are defaulted to an empty list.\n+     * The {@code resultHandlerInterceptors} are defaulted to an empty list.\n+     * The {@link QueryBus} is a <b>hard requirement</b> and as such should be provided.\n+     * </p>\n+     *\n+     * @return a Builder to be able to create a {@link DefaultReactorQueryGateway}\n+     */\n+    public static Builder builder() {\n+        return new Builder();\n+    }\n+\n+    @Override\n+    public Registration registerDispatchInterceptor(\n+            ReactorMessageDispatchInterceptor<QueryMessage<?, ?>> interceptor) {\n+        dispatchInterceptors.add(interceptor);\n+        return () -> dispatchInterceptors.remove(interceptor);\n+    }\n+\n+    @Override\n+    public Registration registerResultHandlerInterceptor(\n+            ReactorResultHandlerInterceptor<QueryMessage<?, ?>, ResultMessage<?>> interceptor) {\n+        resultInterceptors.add(interceptor);\n+        return () -> resultInterceptors.remove(interceptor);\n+    }\n+\n+    @Override\n+    public <R, Q> Mono<R> query(String queryName, Q query, ResponseType<R> responseType) {\n+        return Mono.<QueryMessage<?, ?>>fromCallable(() -> new GenericQueryMessage<>(asMessage(query),\n+                                                                                     queryName,\n+                                                                                     responseType))\n+                .transform(this::processDispatchInterceptors)\n+                .flatMap(this::dispatchQuery)\n+                .flatMapMany(this::processResultsInterceptors)\n+                .<R>transform(this::getPayload)\n+                .next();\n+    }\n+\n+    @Override\n+    public <R, Q> Flux<R> scatterGather(String queryName, Q query, ResponseType<R> responseType, long timeout,\n+                                        TimeUnit timeUnit) {\n+        return Mono.<QueryMessage<?, ?>>fromCallable(() -> new GenericQueryMessage<>(asMessage(query),\n+                                                                                     queryName,\n+                                                                                     responseType))\n+                .transform(this::processDispatchInterceptors)\n+                .flatMap(q -> dispatchScatterGatherQuery(q, timeout, timeUnit))\n+                .flatMapMany(this::processResultsInterceptors)\n+                .transform(this::getPayload);\n+    }\n+\n+    @Override\n+    public <Q, I, U> Mono<SubscriptionQueryResult<I, U>> subscriptionQuery(String queryName, Q query,\n+                                                                           ResponseType<I> initialResponseType,\n+                                                                           ResponseType<U> updateResponseType,\n+                                                                           SubscriptionQueryBackpressure backpressure,\n+                                                                           int updateBufferSize) {\n+\n+        //noinspection unchecked\n+        return Mono.<QueryMessage<?, ?>>fromCallable(() -> new GenericSubscriptionQueryMessage<>(query,\n+                                                                                                 initialResponseType,\n+                                                                                                 updateResponseType))\n+                .transform(this::processDispatchInterceptors)\n+                .map(isq -> (SubscriptionQueryMessage<Q, U, I>) isq)\n+                .flatMap(isq -> dispatchSubscriptionQuery(isq, backpressure, updateBufferSize))\n+                .flatMap(processSubscriptionQueryResult());\n+    }\n+\n+\n+    private Mono<Tuple2<QueryMessage<?, ?>, Flux<ResultMessage<?>>>> dispatchQuery(QueryMessage<?, ?> queryMessage) {\n+        Flux<ResultMessage<?>> results = Flux\n+                .defer(() -> Mono.fromFuture(queryBus.query(queryMessage)));\n+\n+        return Mono.<QueryMessage<?, ?>>just(queryMessage)\n+                .zipWith(Mono.just(results));\n+    }\n+\n+    private Mono<Tuple2<QueryMessage<?, ?>, Flux<ResultMessage<?>>>> dispatchScatterGatherQuery(\n+            QueryMessage<?, ?> queryMessage, long timeout, TimeUnit timeUnit) {\n+        Flux<ResultMessage<?>> results = Flux\n+                .defer(() -> Flux.fromStream(queryBus.scatterGather(queryMessage,\n+                                                                    timeout,\n+                                                                    timeUnit)));\n+\n+        return Mono.<QueryMessage<?, ?>>just(queryMessage)\n+                .zipWith(Mono.just(results));\n+    }\n+\n+    private <Q, I, U> Mono<Tuple2<QueryMessage<Q, I>, Mono<SubscriptionQueryResult<QueryResponseMessage<I>, SubscriptionQueryUpdateMessage<U>>>>> dispatchSubscriptionQuery(\n+            SubscriptionQueryMessage<Q, I, U> queryMessage, SubscriptionQueryBackpressure backpressure,\n+            int updateBufferSize) {\n+        Mono<SubscriptionQueryResult<QueryResponseMessage<I>, SubscriptionQueryUpdateMessage<U>>> result = Mono\n+                .fromCallable(() -> queryBus.subscriptionQuery(queryMessage, backpressure, updateBufferSize));\n+        return Mono.<QueryMessage<Q, I>>just(queryMessage)\n+                .zipWith(Mono.just(result));\n+    }\n+\n+    private Mono<QueryMessage<?, ?>> processDispatchInterceptors(Mono<QueryMessage<?, ?>> queryMessageMono) {\n+        return Flux.fromIterable(dispatchInterceptors)\n+                   .reduce(queryMessageMono, (queryMessage, interceptor) -> interceptor.intercept(queryMessage))\n+                   .flatMap(Mono::from);\n+    }\n+\n+    private Flux<ResultMessage<?>> processResultsInterceptors(\n+            Tuple2<QueryMessage<?, ?>, Flux<ResultMessage<?>>> queryWithResponses) {\n+        QueryMessage<?, ?> queryMessage = queryWithResponses.getT1();\n+        Flux<ResultMessage<?>> queryResultMessage = queryWithResponses.getT2();\n+\n+        return Flux.fromIterable(resultInterceptors)\n+                   .reduce(queryResultMessage,\n+                           (result, interceptor) -> interceptor.intercept(queryMessage, result))\n+                   .flatMapMany(it -> it);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3697d15e2f6025bbb49a23e02e7c24c79f341d2e"}, "originalPosition": 182}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3295, "cost": 1, "resetAt": "2021-11-12T11:18:39Z"}}}