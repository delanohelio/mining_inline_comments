{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDcwMzMzNzc1", "number": 1493, "reviewThreads": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMFQwNToxOTo1MVrOEaT7fA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMFQwNToxOTo1MVrOEaT7fA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk2MDI0OTU2OnYy", "diffSide": "RIGHT", "path": "integrationtests/src/test/java/org/axonframework/integrationtests/eventhandling/TrackingEventProcessorTest.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMFQwNToxOTo1MVrOHDqT9Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMFQwNTo0MTo1MVrOHDrJpw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzYwMTAxMw==", "bodyText": "I don't understand this assumption. Isn't the point of the historic storage that some events will come from the historic, and some. events from the active store? At least this is the case in our production system.", "url": "https://github.com/AxonFramework/AxonFramework/pull/1493#discussion_r473601013", "createdAt": "2020-08-20T05:19:51Z", "author": {"login": "ovstetun"}, "path": "integrationtests/src/test/java/org/axonframework/integrationtests/eventhandling/TrackingEventProcessorTest.java", "diffHunk": "@@ -224,6 +251,44 @@ void tearDown() {\n         eventBus.shutDown();\n     }\n \n+    @Test\n+    void testSequenceEventStorageReceivesEachEventOnlyOnce() throws Exception {\n+        InMemoryEventStorageEngine historic = new InMemoryEventStorageEngine();\n+        InMemoryEventStorageEngine active = new InMemoryEventStorageEngine();\n+        SequenceEventStorageEngine sequenceEventStorageEngine = new SequenceEventStorageEngine(historic, active);\n+\n+        EmbeddedEventStore sequenceEventBus = EmbeddedEventStore.builder().storageEngine(sequenceEventStorageEngine).build();\n+\n+        initProcessor(TrackingEventProcessorConfiguration.forSingleThreadedProcessing()\n+                                                         .andEventAvailabilityTimeout(100, TimeUnit.MILLISECONDS),\n+                      b -> {\n+                          b.messageSource(sequenceEventBus);\n+                          return b;\n+                      });\n+\n+        historic.appendEvents(createEvent(AGGREGATE, 1L, \"message1\"), createEvent(AGGREGATE, 2L, \"message2\"));\n+        // to make sure tracking tokens match, we need to append the same number of events in the active store", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "588d0096e2a5817a96a3f4baef9cc1760d01a906"}, "originalPosition": 78}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzYxMDc5OQ==", "bodyText": "That's absolutely correct. In practice, the events are usually in either historic, or the active storage, and only occasionally/temporarily in both.\nHowever, the tokens returned from the storage engines must continue from one into the next. That means your historic storage will take the globalIndex from the events that the activeStorage has assigned to it. The in-memory storage doesn't support that, so we need to add some 'placeholder' events to make sure the index matches.", "url": "https://github.com/AxonFramework/AxonFramework/pull/1493#discussion_r473610799", "createdAt": "2020-08-20T05:35:36Z", "author": {"login": "abuijze"}, "path": "integrationtests/src/test/java/org/axonframework/integrationtests/eventhandling/TrackingEventProcessorTest.java", "diffHunk": "@@ -224,6 +251,44 @@ void tearDown() {\n         eventBus.shutDown();\n     }\n \n+    @Test\n+    void testSequenceEventStorageReceivesEachEventOnlyOnce() throws Exception {\n+        InMemoryEventStorageEngine historic = new InMemoryEventStorageEngine();\n+        InMemoryEventStorageEngine active = new InMemoryEventStorageEngine();\n+        SequenceEventStorageEngine sequenceEventStorageEngine = new SequenceEventStorageEngine(historic, active);\n+\n+        EmbeddedEventStore sequenceEventBus = EmbeddedEventStore.builder().storageEngine(sequenceEventStorageEngine).build();\n+\n+        initProcessor(TrackingEventProcessorConfiguration.forSingleThreadedProcessing()\n+                                                         .andEventAvailabilityTimeout(100, TimeUnit.MILLISECONDS),\n+                      b -> {\n+                          b.messageSource(sequenceEventBus);\n+                          return b;\n+                      });\n+\n+        historic.appendEvents(createEvent(AGGREGATE, 1L, \"message1\"), createEvent(AGGREGATE, 2L, \"message2\"));\n+        // to make sure tracking tokens match, we need to append the same number of events in the active store", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzYwMTAxMw=="}, "originalCommit": {"oid": "588d0096e2a5817a96a3f4baef9cc1760d01a906"}, "originalPosition": 78}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzYxNDc1OQ==", "bodyText": "I did a bit of digging here, and now understand what happens. The first two events from the active storage are not read in playback. Maybe it would be better as documentation to have these two with a different payload and check that only the expected messages are received in the handler?", "url": "https://github.com/AxonFramework/AxonFramework/pull/1493#discussion_r473614759", "createdAt": "2020-08-20T05:41:51Z", "author": {"login": "ovstetun"}, "path": "integrationtests/src/test/java/org/axonframework/integrationtests/eventhandling/TrackingEventProcessorTest.java", "diffHunk": "@@ -224,6 +251,44 @@ void tearDown() {\n         eventBus.shutDown();\n     }\n \n+    @Test\n+    void testSequenceEventStorageReceivesEachEventOnlyOnce() throws Exception {\n+        InMemoryEventStorageEngine historic = new InMemoryEventStorageEngine();\n+        InMemoryEventStorageEngine active = new InMemoryEventStorageEngine();\n+        SequenceEventStorageEngine sequenceEventStorageEngine = new SequenceEventStorageEngine(historic, active);\n+\n+        EmbeddedEventStore sequenceEventBus = EmbeddedEventStore.builder().storageEngine(sequenceEventStorageEngine).build();\n+\n+        initProcessor(TrackingEventProcessorConfiguration.forSingleThreadedProcessing()\n+                                                         .andEventAvailabilityTimeout(100, TimeUnit.MILLISECONDS),\n+                      b -> {\n+                          b.messageSource(sequenceEventBus);\n+                          return b;\n+                      });\n+\n+        historic.appendEvents(createEvent(AGGREGATE, 1L, \"message1\"), createEvent(AGGREGATE, 2L, \"message2\"));\n+        // to make sure tracking tokens match, we need to append the same number of events in the active store", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzYwMTAxMw=="}, "originalCommit": {"oid": "588d0096e2a5817a96a3f4baef9cc1760d01a906"}, "originalPosition": 78}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3224, "cost": 1, "resetAt": "2021-11-12T11:18:39Z"}}}