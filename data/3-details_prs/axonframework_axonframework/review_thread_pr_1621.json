{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTMwMzQ5ODU1", "number": 1621, "reviewThreads": {"totalCount": 10, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yM1QxMDozMzoxNVrOFIiGRQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0xOVQwNzo1MzowNVrOFcOYrQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ0NDkxNTg5OnYy", "diffSide": "RIGHT", "path": "messaging/src/main/java/org/axonframework/common/ObjectUtils.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yM1QxMDozMzoxNVrOIKgkzQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0zMVQxMDowMzozMFrOIM8lxw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Nzg5MDM4MQ==", "bodyText": "Nit: This looks like it belongs more to StringUtils instead of ObjectUtils", "url": "https://github.com/AxonFramework/AxonFramework/pull/1621#discussion_r547890381", "createdAt": "2020-12-23T10:33:15Z", "author": {"login": "sandjelkovic"}, "path": "messaging/src/main/java/org/axonframework/common/ObjectUtils.java", "diffHunk": "@@ -121,4 +124,16 @@ public static long getRemainingOfDeadline(long deadline) {\n         leftTimeout = leftTimeout < 0 ? 0 : leftTimeout;\n         return leftTimeout;\n     }\n+\n+    /**\n+     * Validate whether the given {@link String} {@code s} is not {@code null} and not empty (where empty is defined as\n+     * {@code \"\"}.\n+     *\n+     * @param s the {@link String} to validate whether it is not {@code null} and not empty\n+     * @return {@code true} if the given {@link String} {@code s} is not {@code null} and not empty, {@code false}\n+     * otherwise\n+     */\n+    public static boolean nonEmptyOrNull(String s) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dbfd5a163736a9db664372a2bf1ad6d4d8addcde"}, "originalPosition": 33}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDQ0NjUzNQ==", "bodyText": "Fair point, added.", "url": "https://github.com/AxonFramework/AxonFramework/pull/1621#discussion_r550446535", "createdAt": "2020-12-31T10:03:30Z", "author": {"login": "smcvb"}, "path": "messaging/src/main/java/org/axonframework/common/ObjectUtils.java", "diffHunk": "@@ -121,4 +124,16 @@ public static long getRemainingOfDeadline(long deadline) {\n         leftTimeout = leftTimeout < 0 ? 0 : leftTimeout;\n         return leftTimeout;\n     }\n+\n+    /**\n+     * Validate whether the given {@link String} {@code s} is not {@code null} and not empty (where empty is defined as\n+     * {@code \"\"}.\n+     *\n+     * @param s the {@link String} to validate whether it is not {@code null} and not empty\n+     * @return {@code true} if the given {@link String} {@code s} is not {@code null} and not empty, {@code false}\n+     * otherwise\n+     */\n+    public static boolean nonEmptyOrNull(String s) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Nzg5MDM4MQ=="}, "originalCommit": {"oid": "dbfd5a163736a9db664372a2bf1ad6d4d8addcde"}, "originalPosition": 33}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ0NDk2NDkyOnYy", "diffSide": "RIGHT", "path": "messaging/src/main/java/org/axonframework/messaging/annotation/HandlerAttributes.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yM1QxMDo1MToxMFrOIKhBbg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0zMVQxMDoxOTo1MVrOIM8y9A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Nzg5NzcxMA==", "bodyText": "If returning unmodifiable maps, inner maps should be unmodifiable as well. Or at least copied", "url": "https://github.com/AxonFramework/AxonFramework/pull/1621#discussion_r547897710", "createdAt": "2020-12-23T10:51:10Z", "author": {"login": "sandjelkovic"}, "path": "messaging/src/main/java/org/axonframework/messaging/annotation/HandlerAttributes.java", "diffHunk": "@@ -0,0 +1,138 @@\n+package org.axonframework.messaging.annotation;\n+\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * Container for message handler attributes. Can store several {@link Map}s of {@link String} to {@link Object} under\n+ * their own key, resembling a message handling method which serves several handling functions.\n+ *\n+ * @author Steven van Beelen\n+ * @since 4.5\n+ */\n+public class HandlerAttributes {\n+\n+    private final Map<String, Map<String, Object>> attributes;\n+\n+    /**\n+     * Constructs an empty handler attributes object.\n+     */\n+    public HandlerAttributes() {\n+        this(new HashMap<>());\n+    }\n+\n+    /**\n+     * Construct a handler attributes object based on the given {@code handlerAttributes} {@link Map}.\n+     *\n+     * @param attributes a {@link Map} from handler type to attributes {@code Map} to base a {@link\n+     *                          HandlerAttributes} on\n+     */\n+    public HandlerAttributes(Map<String, Map<String, Object>> attributes) {\n+        this.attributes = attributes;\n+    }\n+\n+    /**\n+     * Put new {@code attributes} for the given {@code handlerType}.\n+     *\n+     * @param handlerType the type of handler to add {@code attributes} for\n+     * @param attributes  the {@link Map} of attribute information to add for the given {@code handlerType}\n+     */\n+    public void put(String handlerType, Map<String, Object> attributes) {\n+        this.attributes.put(handlerType, attributes);\n+    }\n+\n+    /**\n+     * Retrieve the attributes for the given {@code handlerType}. Might be {@code null} if there are no attributes\n+     * present for the specified type.\n+     *\n+     * @param handlerType the type of handler to retrieve attributes for\n+     * @return the attributes for the given {@code handlerType}\n+     */\n+    public Map<String, Object> get(String handlerType) {\n+        return Collections.unmodifiableMap(attributes.get(handlerType));\n+    }\n+\n+    /**\n+     * Retrieve all attributes for all handler types stored in this {@link HandlerAttributes} object. The returned\n+     * {@link Map} contains a {@link Map} of attribute name to attribute value, per handler type present.\n+     *\n+     * @return all attributes for all handler types stored in this {@link HandlerAttributes} object\n+     */\n+    public Map<String, Map<String, Object>> getAll() {\n+        return Collections.unmodifiableMap(attributes);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dbfd5a163736a9db664372a2bf1ad6d4d8addcde"}, "originalPosition": 65}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDQ0OTkwOA==", "bodyText": "But of course, that's beneficial. Consider it changed.", "url": "https://github.com/AxonFramework/AxonFramework/pull/1621#discussion_r550449908", "createdAt": "2020-12-31T10:19:51Z", "author": {"login": "smcvb"}, "path": "messaging/src/main/java/org/axonframework/messaging/annotation/HandlerAttributes.java", "diffHunk": "@@ -0,0 +1,138 @@\n+package org.axonframework.messaging.annotation;\n+\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * Container for message handler attributes. Can store several {@link Map}s of {@link String} to {@link Object} under\n+ * their own key, resembling a message handling method which serves several handling functions.\n+ *\n+ * @author Steven van Beelen\n+ * @since 4.5\n+ */\n+public class HandlerAttributes {\n+\n+    private final Map<String, Map<String, Object>> attributes;\n+\n+    /**\n+     * Constructs an empty handler attributes object.\n+     */\n+    public HandlerAttributes() {\n+        this(new HashMap<>());\n+    }\n+\n+    /**\n+     * Construct a handler attributes object based on the given {@code handlerAttributes} {@link Map}.\n+     *\n+     * @param attributes a {@link Map} from handler type to attributes {@code Map} to base a {@link\n+     *                          HandlerAttributes} on\n+     */\n+    public HandlerAttributes(Map<String, Map<String, Object>> attributes) {\n+        this.attributes = attributes;\n+    }\n+\n+    /**\n+     * Put new {@code attributes} for the given {@code handlerType}.\n+     *\n+     * @param handlerType the type of handler to add {@code attributes} for\n+     * @param attributes  the {@link Map} of attribute information to add for the given {@code handlerType}\n+     */\n+    public void put(String handlerType, Map<String, Object> attributes) {\n+        this.attributes.put(handlerType, attributes);\n+    }\n+\n+    /**\n+     * Retrieve the attributes for the given {@code handlerType}. Might be {@code null} if there are no attributes\n+     * present for the specified type.\n+     *\n+     * @param handlerType the type of handler to retrieve attributes for\n+     * @return the attributes for the given {@code handlerType}\n+     */\n+    public Map<String, Object> get(String handlerType) {\n+        return Collections.unmodifiableMap(attributes.get(handlerType));\n+    }\n+\n+    /**\n+     * Retrieve all attributes for all handler types stored in this {@link HandlerAttributes} object. The returned\n+     * {@link Map} contains a {@link Map} of attribute name to attribute value, per handler type present.\n+     *\n+     * @return all attributes for all handler types stored in this {@link HandlerAttributes} object\n+     */\n+    public Map<String, Map<String, Object>> getAll() {\n+        return Collections.unmodifiableMap(attributes);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Nzg5NzcxMA=="}, "originalCommit": {"oid": "dbfd5a163736a9db664372a2bf1ad6d4d8addcde"}, "originalPosition": 65}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ0NTA1MTIyOnYy", "diffSide": "RIGHT", "path": "messaging/src/main/java/org/axonframework/common/annotation/AnnotationUtils.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yM1QxMToyMjozN1rOIKhzSA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xMVQxNDowNDowN1rOIRWpeg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzkxMDQ3Mg==", "bodyText": "Might be worth splitting this method into 2 or 3 specialised methods.\n\nLooking up and gathering of targets annotated with the subject can be a separate method. As this is a recursive method with state passed trough, it might be better to hide this fact (visited and annotatedWithSubject parameters) from the outside.\nisAnnotatedWith implies a boolean return value to answer if the target is annotated with the subject. This can use the method that will gather all targets annotated with the subject from the above point to do the complex work. If performance is critical, it can have its own search but short-circuit the moment the annotation is found", "url": "https://github.com/AxonFramework/AxonFramework/pull/1621#discussion_r547910472", "createdAt": "2020-12-23T11:22:37Z", "author": {"login": "sandjelkovic"}, "path": "messaging/src/main/java/org/axonframework/common/annotation/AnnotationUtils.java", "diffHunk": "@@ -179,8 +270,51 @@ private static String resolveName(Method method) {\n         return method.getName();\n     }\n \n-    private AnnotationUtils() {\n-        // utility class\n+    /**\n+     * Validate whether the given {@code target} annotation {@link Class} is meta-annotated with the given {@code\n+     * subject}. If this is the case for the {@code target} itself or any meta-annotation on any level of the {@code\n+     * target}, {@code true} will be returned.\n+     * <p>\n+     * Any {@link Annotation} classes which are directly annotated or meta-annotated with the given {@code subject} will\n+     * be stored in the {@code annotatedWithSubject} {@link Set}. The {@code visited} {@code Set} is used to ignore\n+     * annotations which have already been validated.\n+     *\n+     * @param target               the annotation {@link Class} to validate if it is annotated with the given {@code\n+     *                             subject}\n+     * @param subject              the annotation {@link Class} to check whether it is present on the given {@code\n+     *                             target}, directly or through meta-annotations\n+     * @param annotatedWithSubject a {@link Set} to store all class' in which are annotated with the {@code subject},\n+     *                             either directly or through meta-annotations\n+     * @param visited              a {@link Set} containing all annotation class' which have been visited in the process\n+     *                             to overcome an endless validation loop\n+     * @return {@code true} if the {@code target} or any meta-annotations of the {@code target} are annotated with the\n+     * {@code subject}, {@code false} otherwise\n+     */\n+    public static boolean isAnnotatedWith(Class<? extends Annotation> target,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dbfd5a163736a9db664372a2bf1ad6d4d8addcde"}, "originalPosition": 252}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDQ1MTQ1Nw==", "bodyText": "Although yes, I can create an isAnnotatedWith which does not expose visited (the second method) and/or annotatedWithSubject (the third method), there is nothing using at all at this stage. I was in doubt about doing it anyway, but it felt like premature optimization to me as long as nothing will be using that function at all.\nIf you feel strongly it clarifies things for our (future) selves and users, I'd gladly add it too. At any point, let me know. :-)", "url": "https://github.com/AxonFramework/AxonFramework/pull/1621#discussion_r550451457", "createdAt": "2020-12-31T10:27:30Z", "author": {"login": "smcvb"}, "path": "messaging/src/main/java/org/axonframework/common/annotation/AnnotationUtils.java", "diffHunk": "@@ -179,8 +270,51 @@ private static String resolveName(Method method) {\n         return method.getName();\n     }\n \n-    private AnnotationUtils() {\n-        // utility class\n+    /**\n+     * Validate whether the given {@code target} annotation {@link Class} is meta-annotated with the given {@code\n+     * subject}. If this is the case for the {@code target} itself or any meta-annotation on any level of the {@code\n+     * target}, {@code true} will be returned.\n+     * <p>\n+     * Any {@link Annotation} classes which are directly annotated or meta-annotated with the given {@code subject} will\n+     * be stored in the {@code annotatedWithSubject} {@link Set}. The {@code visited} {@code Set} is used to ignore\n+     * annotations which have already been validated.\n+     *\n+     * @param target               the annotation {@link Class} to validate if it is annotated with the given {@code\n+     *                             subject}\n+     * @param subject              the annotation {@link Class} to check whether it is present on the given {@code\n+     *                             target}, directly or through meta-annotations\n+     * @param annotatedWithSubject a {@link Set} to store all class' in which are annotated with the {@code subject},\n+     *                             either directly or through meta-annotations\n+     * @param visited              a {@link Set} containing all annotation class' which have been visited in the process\n+     *                             to overcome an endless validation loop\n+     * @return {@code true} if the {@code target} or any meta-annotations of the {@code target} are annotated with the\n+     * {@code subject}, {@code false} otherwise\n+     */\n+    public static boolean isAnnotatedWith(Class<? extends Annotation> target,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzkxMDQ3Mg=="}, "originalCommit": {"oid": "dbfd5a163736a9db664372a2bf1ad6d4d8addcde"}, "originalPosition": 252}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTA2Nzc3MA==", "bodyText": "I'm with it either way for now as long it's only used in one place. When we expand the usage to another place, it will make way more sense to at least remove mutability", "url": "https://github.com/AxonFramework/AxonFramework/pull/1621#discussion_r555067770", "createdAt": "2021-01-11T14:04:07Z", "author": {"login": "sandjelkovic"}, "path": "messaging/src/main/java/org/axonframework/common/annotation/AnnotationUtils.java", "diffHunk": "@@ -179,8 +270,51 @@ private static String resolveName(Method method) {\n         return method.getName();\n     }\n \n-    private AnnotationUtils() {\n-        // utility class\n+    /**\n+     * Validate whether the given {@code target} annotation {@link Class} is meta-annotated with the given {@code\n+     * subject}. If this is the case for the {@code target} itself or any meta-annotation on any level of the {@code\n+     * target}, {@code true} will be returned.\n+     * <p>\n+     * Any {@link Annotation} classes which are directly annotated or meta-annotated with the given {@code subject} will\n+     * be stored in the {@code annotatedWithSubject} {@link Set}. The {@code visited} {@code Set} is used to ignore\n+     * annotations which have already been validated.\n+     *\n+     * @param target               the annotation {@link Class} to validate if it is annotated with the given {@code\n+     *                             subject}\n+     * @param subject              the annotation {@link Class} to check whether it is present on the given {@code\n+     *                             target}, directly or through meta-annotations\n+     * @param annotatedWithSubject a {@link Set} to store all class' in which are annotated with the {@code subject},\n+     *                             either directly or through meta-annotations\n+     * @param visited              a {@link Set} containing all annotation class' which have been visited in the process\n+     *                             to overcome an endless validation loop\n+     * @return {@code true} if the {@code target} or any meta-annotations of the {@code target} are annotated with the\n+     * {@code subject}, {@code false} otherwise\n+     */\n+    public static boolean isAnnotatedWith(Class<? extends Annotation> target,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzkxMDQ3Mg=="}, "originalCommit": {"oid": "dbfd5a163736a9db664372a2bf1ad6d4d8addcde"}, "originalPosition": 252}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzY0ODIxMjk2OnYy", "diffSide": "RIGHT", "path": "messaging/src/main/java/org/axonframework/messaging/annotation/HandlerAttributeDictionary.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0xOFQxNToxMDozNlrOInspug==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0wMlQwODo1OTowN1rOIuQtvA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3ODQ5Njk1NA==", "bodyText": "I suggest adding these to the HandlerAttributes class, as that's where these keys are expected to be used.", "url": "https://github.com/AxonFramework/AxonFramework/pull/1621#discussion_r578496954", "createdAt": "2021-02-18T15:10:36Z", "author": {"login": "abuijze"}, "path": "messaging/src/main/java/org/axonframework/messaging/annotation/HandlerAttributeDictionary.java", "diffHunk": "@@ -0,0 +1,81 @@\n+package org.axonframework.messaging.annotation;\n+\n+/**\n+ * Dictionary containing the possible attributes a {@link MessageHandlingMember} can have. Can be used as input for\n+ * {@link MessageHandlingMember#attribute(String)}.\n+ *\n+ * @author Steven van Beelen\n+ * @since 4.5\n+ */\n+public abstract class HandlerAttributeDictionary {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e5f2c819f4dc884d185097c590c16feb52a937ef"}, "originalPosition": 10}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4NTM3OTI2MA==", "bodyText": "Make sense, will do.", "url": "https://github.com/AxonFramework/AxonFramework/pull/1621#discussion_r585379260", "createdAt": "2021-03-02T08:59:07Z", "author": {"login": "smcvb"}, "path": "messaging/src/main/java/org/axonframework/messaging/annotation/HandlerAttributeDictionary.java", "diffHunk": "@@ -0,0 +1,81 @@\n+package org.axonframework.messaging.annotation;\n+\n+/**\n+ * Dictionary containing the possible attributes a {@link MessageHandlingMember} can have. Can be used as input for\n+ * {@link MessageHandlingMember#attribute(String)}.\n+ *\n+ * @author Steven van Beelen\n+ * @since 4.5\n+ */\n+public abstract class HandlerAttributeDictionary {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3ODQ5Njk1NA=="}, "originalCommit": {"oid": "e5f2c819f4dc884d185097c590c16feb52a937ef"}, "originalPosition": 10}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzY0ODIzMTE3OnYy", "diffSide": "RIGHT", "path": "messaging/src/main/java/org/axonframework/messaging/annotation/HandlerAttributesUtils.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0xOFQxNToxNDoyOVrOIns1UQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0wMlQwODo1OTozN1rOIuQvLg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3ODQ5OTkyMQ==", "bodyText": "Shouldn't we just create a subclass of HandlerAttributes (called AnnotatedHandlerAttributes) that takes an AnnotatedElement as a constructor and populates its internal Map?\nOr otherwise, maybe HandlerAttributes should be an interface with different implementations.... \ud83e\udd37\u200d\u2642\ufe0f", "url": "https://github.com/AxonFramework/AxonFramework/pull/1621#discussion_r578499921", "createdAt": "2021-02-18T15:14:29Z", "author": {"login": "abuijze"}, "path": "messaging/src/main/java/org/axonframework/messaging/annotation/HandlerAttributesUtils.java", "diffHunk": "@@ -0,0 +1,59 @@\n+package org.axonframework.messaging.annotation;\n+\n+import org.axonframework.common.annotation.AnnotationUtils;\n+\n+import java.lang.annotation.Annotation;\n+import java.lang.reflect.AnnotatedElement;\n+import java.util.HashSet;\n+import java.util.Set;\n+\n+import static org.axonframework.common.annotation.AnnotationUtils.findAnnotationAttributes;\n+import static org.axonframework.common.annotation.AnnotationUtils.isAnnotatedWith;\n+\n+/**\n+ * Utility class which can generate a {@link HandlerAttributes} object for a given {@link AnnotatedElement}. It does so\n+ * by validating all (meta-)annotations of the given element for the presence of the {@link HasHandlerAttributes}\n+ * annotation. Each found (meta-)annotation's attributes will be included in the {@code HandlerAttributes}.\n+ * <p>\n+ * This utility can be used to support annotation driven {@link MessageHandlingMember} implementations to automatically\n+ * generate the attributes collection.\n+ *\n+ * @author Steven van Beelen\n+ * @since 4.5\n+ */\n+public abstract class HandlerAttributesUtils {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e5f2c819f4dc884d185097c590c16feb52a937ef"}, "originalPosition": 24}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4NTM3OTYzMA==", "bodyText": "Nice, liking this idea too. Gonna implement this asap.", "url": "https://github.com/AxonFramework/AxonFramework/pull/1621#discussion_r585379630", "createdAt": "2021-03-02T08:59:37Z", "author": {"login": "smcvb"}, "path": "messaging/src/main/java/org/axonframework/messaging/annotation/HandlerAttributesUtils.java", "diffHunk": "@@ -0,0 +1,59 @@\n+package org.axonframework.messaging.annotation;\n+\n+import org.axonframework.common.annotation.AnnotationUtils;\n+\n+import java.lang.annotation.Annotation;\n+import java.lang.reflect.AnnotatedElement;\n+import java.util.HashSet;\n+import java.util.Set;\n+\n+import static org.axonframework.common.annotation.AnnotationUtils.findAnnotationAttributes;\n+import static org.axonframework.common.annotation.AnnotationUtils.isAnnotatedWith;\n+\n+/**\n+ * Utility class which can generate a {@link HandlerAttributes} object for a given {@link AnnotatedElement}. It does so\n+ * by validating all (meta-)annotations of the given element for the presence of the {@link HasHandlerAttributes}\n+ * annotation. Each found (meta-)annotation's attributes will be included in the {@code HandlerAttributes}.\n+ * <p>\n+ * This utility can be used to support annotation driven {@link MessageHandlingMember} implementations to automatically\n+ * generate the attributes collection.\n+ *\n+ * @author Steven van Beelen\n+ * @since 4.5\n+ */\n+public abstract class HandlerAttributesUtils {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3ODQ5OTkyMQ=="}, "originalCommit": {"oid": "e5f2c819f4dc884d185097c590c16feb52a937ef"}, "originalPosition": 24}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzY1MTM4MTQzOnYy", "diffSide": "RIGHT", "path": "messaging/src/main/java/org/axonframework/messaging/annotation/HandlerAttributes.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0xOVQwNzo0NjoxNFrOIoKkKA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0wMlQxNDozMjoxN1rOIufBaA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3ODk4NzA0OA==", "bodyText": "Should this just be key->value mapping, instead of key->key->value?", "url": "https://github.com/AxonFramework/AxonFramework/pull/1621#discussion_r578987048", "createdAt": "2021-02-19T07:46:14Z", "author": {"login": "abuijze"}, "path": "messaging/src/main/java/org/axonframework/messaging/annotation/HandlerAttributes.java", "diffHunk": "@@ -0,0 +1,144 @@\n+package org.axonframework.messaging.annotation;\n+\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * Container for message handler attributes. Can store several {@link Map}s of {@link String} to {@link Object} under\n+ * their own key, resembling a message handling method which serves several handling functions.\n+ *\n+ * @author Steven van Beelen\n+ * @since 4.5\n+ */\n+public class HandlerAttributes {\n+\n+    private final Map<String, Map<String, Object>> attributes;\n+\n+    /**\n+     * Constructs an empty handler attributes object.\n+     */\n+    public HandlerAttributes() {\n+        this(new HashMap<>());\n+    }\n+\n+    /**\n+     * Construct a handler attributes object based on the given {@code handlerAttributes} {@link Map}.\n+     *\n+     * @param attributes a {@link Map} from handler type to attributes {@code Map} to base a {@link HandlerAttributes}\n+     *                   on\n+     */\n+    public HandlerAttributes(Map<String, Map<String, Object>> attributes) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e5f2c819f4dc884d185097c590c16feb52a937ef"}, "originalPosition": 33}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4NTYxMzY3Mg==", "bodyText": "My initial idea was \"no\", but let's adjust the API more thoroughly by no longer providing a means to retrieve all attributes for a given handler type. With that in place, I'd say \"yes\" to this.", "url": "https://github.com/AxonFramework/AxonFramework/pull/1621#discussion_r585613672", "createdAt": "2021-03-02T14:32:17Z", "author": {"login": "smcvb"}, "path": "messaging/src/main/java/org/axonframework/messaging/annotation/HandlerAttributes.java", "diffHunk": "@@ -0,0 +1,144 @@\n+package org.axonframework.messaging.annotation;\n+\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * Container for message handler attributes. Can store several {@link Map}s of {@link String} to {@link Object} under\n+ * their own key, resembling a message handling method which serves several handling functions.\n+ *\n+ * @author Steven van Beelen\n+ * @since 4.5\n+ */\n+public class HandlerAttributes {\n+\n+    private final Map<String, Map<String, Object>> attributes;\n+\n+    /**\n+     * Constructs an empty handler attributes object.\n+     */\n+    public HandlerAttributes() {\n+        this(new HashMap<>());\n+    }\n+\n+    /**\n+     * Construct a handler attributes object based on the given {@code handlerAttributes} {@link Map}.\n+     *\n+     * @param attributes a {@link Map} from handler type to attributes {@code Map} to base a {@link HandlerAttributes}\n+     *                   on\n+     */\n+    public HandlerAttributes(Map<String, Map<String, Object>> attributes) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3ODk4NzA0OA=="}, "originalCommit": {"oid": "e5f2c819f4dc884d185097c590c16feb52a937ef"}, "originalPosition": 33}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzY1MTM4NjY3OnYy", "diffSide": "RIGHT", "path": "messaging/src/main/java/org/axonframework/messaging/annotation/HandlerAttributes.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0xOVQwNzo0Nzo1NFrOIoKnNQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0xOVQwNzo0Nzo1NFrOIoKnNQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3ODk4NzgyOQ==", "bodyText": "This sentence doesn't make things much clearer. Let's remove it. It's just a bunch of key->value tuples, where we get all the tuples whose key starts with the given prefix.", "url": "https://github.com/AxonFramework/AxonFramework/pull/1621#discussion_r578987829", "createdAt": "2021-02-19T07:47:54Z", "author": {"login": "abuijze"}, "path": "messaging/src/main/java/org/axonframework/messaging/annotation/HandlerAttributes.java", "diffHunk": "@@ -0,0 +1,144 @@\n+package org.axonframework.messaging.annotation;\n+\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * Container for message handler attributes. Can store several {@link Map}s of {@link String} to {@link Object} under\n+ * their own key, resembling a message handling method which serves several handling functions.\n+ *\n+ * @author Steven van Beelen\n+ * @since 4.5\n+ */\n+public class HandlerAttributes {\n+\n+    private final Map<String, Map<String, Object>> attributes;\n+\n+    /**\n+     * Constructs an empty handler attributes object.\n+     */\n+    public HandlerAttributes() {\n+        this(new HashMap<>());\n+    }\n+\n+    /**\n+     * Construct a handler attributes object based on the given {@code handlerAttributes} {@link Map}.\n+     *\n+     * @param attributes a {@link Map} from handler type to attributes {@code Map} to base a {@link HandlerAttributes}\n+     *                   on\n+     */\n+    public HandlerAttributes(Map<String, Map<String, Object>> attributes) {\n+        this.attributes = attributes;\n+    }\n+\n+    /**\n+     * Put new {@code attributes} for the given {@code handlerType}.\n+     *\n+     * @param handlerType the type of handler to add {@code attributes} for\n+     * @param attributes  the {@link Map} of attribute information to add for the given {@code handlerType}\n+     */\n+    public void put(String handlerType, Map<String, Object> attributes) {\n+        this.attributes.put(handlerType, attributes);\n+    }\n+\n+    /**\n+     * Retrieve the attributes for the given {@code handlerType}. Might be {@code null} if there are no attributes\n+     * present for the specified type.\n+     *\n+     * @param handlerType the type of handler to retrieve attributes for\n+     * @return the attributes for the given {@code handlerType}\n+     */\n+    public Map<String, Object> get(String handlerType) {\n+        return Collections.unmodifiableMap(attributes.get(handlerType));\n+    }\n+\n+    /**\n+     * Retrieve all attributes for all handler types stored in this {@link HandlerAttributes} object. The returned\n+     * {@link Map} contains a {@link Map} of attribute name to attribute value, per handler type present.\n+     *\n+     * @return all attributes for all handler types stored in this {@link HandlerAttributes} object\n+     */\n+    public Map<String, Map<String, Object>> getAll() {\n+        return Collections.unmodifiableMap(\n+                attributes.entrySet().stream()\n+                          .collect(Collectors.toMap(\n+                                  Map.Entry::getKey,\n+                                  entry -> Collections.unmodifiableMap(entry.getValue())\n+                          ))\n+        );\n+    }\n+\n+    /**\n+     * Retrieve all attributes for all handler types stored in this {@link HandlerAttributes} object in a prefixed\n+     * format. The returned {@link Map} contains keys representing a format of {@code \"[handlerType].[attributeName]\"}\n+     * with the respective attribute value corresponding to the attribute name.\n+     * <p>\n+     * Serves the purpose a of providing a {@code Map} containing a property file like structure.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e5f2c819f4dc884d185097c590c16feb52a937ef"}, "originalPosition": 79}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzY1MTM4ODE0OnYy", "diffSide": "RIGHT", "path": "messaging/src/main/java/org/axonframework/messaging/annotation/HandlerAttributes.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0xOVQwNzo0ODozMFrOIoKoKQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0wMlQwOTozNTo1MVrOIuSaCA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3ODk4ODA3Mw==", "bodyText": "We should abstract this logic away into whatever component inspects the attributes. This still seems quite specific to the annotation approach.", "url": "https://github.com/AxonFramework/AxonFramework/pull/1621#discussion_r578988073", "createdAt": "2021-02-19T07:48:30Z", "author": {"login": "abuijze"}, "path": "messaging/src/main/java/org/axonframework/messaging/annotation/HandlerAttributes.java", "diffHunk": "@@ -0,0 +1,144 @@\n+package org.axonframework.messaging.annotation;\n+\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * Container for message handler attributes. Can store several {@link Map}s of {@link String} to {@link Object} under\n+ * their own key, resembling a message handling method which serves several handling functions.\n+ *\n+ * @author Steven van Beelen\n+ * @since 4.5\n+ */\n+public class HandlerAttributes {\n+\n+    private final Map<String, Map<String, Object>> attributes;\n+\n+    /**\n+     * Constructs an empty handler attributes object.\n+     */\n+    public HandlerAttributes() {\n+        this(new HashMap<>());\n+    }\n+\n+    /**\n+     * Construct a handler attributes object based on the given {@code handlerAttributes} {@link Map}.\n+     *\n+     * @param attributes a {@link Map} from handler type to attributes {@code Map} to base a {@link HandlerAttributes}\n+     *                   on\n+     */\n+    public HandlerAttributes(Map<String, Map<String, Object>> attributes) {\n+        this.attributes = attributes;\n+    }\n+\n+    /**\n+     * Put new {@code attributes} for the given {@code handlerType}.\n+     *\n+     * @param handlerType the type of handler to add {@code attributes} for\n+     * @param attributes  the {@link Map} of attribute information to add for the given {@code handlerType}\n+     */\n+    public void put(String handlerType, Map<String, Object> attributes) {\n+        this.attributes.put(handlerType, attributes);\n+    }\n+\n+    /**\n+     * Retrieve the attributes for the given {@code handlerType}. Might be {@code null} if there are no attributes\n+     * present for the specified type.\n+     *\n+     * @param handlerType the type of handler to retrieve attributes for\n+     * @return the attributes for the given {@code handlerType}\n+     */\n+    public Map<String, Object> get(String handlerType) {\n+        return Collections.unmodifiableMap(attributes.get(handlerType));\n+    }\n+\n+    /**\n+     * Retrieve all attributes for all handler types stored in this {@link HandlerAttributes} object. The returned\n+     * {@link Map} contains a {@link Map} of attribute name to attribute value, per handler type present.\n+     *\n+     * @return all attributes for all handler types stored in this {@link HandlerAttributes} object\n+     */\n+    public Map<String, Map<String, Object>> getAll() {\n+        return Collections.unmodifiableMap(\n+                attributes.entrySet().stream()\n+                          .collect(Collectors.toMap(\n+                                  Map.Entry::getKey,\n+                                  entry -> Collections.unmodifiableMap(entry.getValue())\n+                          ))\n+        );\n+    }\n+\n+    /**\n+     * Retrieve all attributes for all handler types stored in this {@link HandlerAttributes} object in a prefixed\n+     * format. The returned {@link Map} contains keys representing a format of {@code \"[handlerType].[attributeName]\"}\n+     * with the respective attribute value corresponding to the attribute name.\n+     * <p>\n+     * Serves the purpose a of providing a {@code Map} containing a property file like structure.\n+     *\n+     * @return all attributes for all handler types stored in this {@link HandlerAttributes} object in a prefixed format\n+     */\n+    public Map<String, Object> getAllPrefixed() {\n+        Map<String, Object> allPrefixedAttributes = new HashMap<>();\n+        for (Map.Entry<String, Map<String, Object>> attributeEntry : attributes.entrySet()) {\n+            String handlerType = attributeEntry.getKey();\n+            Map<String, Object> prefixedAttributes =\n+                    attributeEntry.getValue().entrySet().stream()\n+                                  .collect(Collectors.toMap(\n+                                          entry -> prefixedKey(handlerType, entry.getKey()),\n+                                          Map.Entry::getValue\n+                                  ));\n+            allPrefixedAttributes.putAll(prefixedAttributes);\n+        }\n+        return Collections.unmodifiableMap(allPrefixedAttributes);\n+    }\n+\n+    private String prefixedKey(String handlerType, String attributeName) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e5f2c819f4dc884d185097c590c16feb52a937ef"}, "originalPosition": 98}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4NTQwNjk4NA==", "bodyText": "I've taken your idea of constructing an AnnotatedHandlerAttributes class. It's this object which currently contains all this logic, so essentially it's abstracted away to be annotation specific right now.", "url": "https://github.com/AxonFramework/AxonFramework/pull/1621#discussion_r585406984", "createdAt": "2021-03-02T09:35:51Z", "author": {"login": "smcvb"}, "path": "messaging/src/main/java/org/axonframework/messaging/annotation/HandlerAttributes.java", "diffHunk": "@@ -0,0 +1,144 @@\n+package org.axonframework.messaging.annotation;\n+\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * Container for message handler attributes. Can store several {@link Map}s of {@link String} to {@link Object} under\n+ * their own key, resembling a message handling method which serves several handling functions.\n+ *\n+ * @author Steven van Beelen\n+ * @since 4.5\n+ */\n+public class HandlerAttributes {\n+\n+    private final Map<String, Map<String, Object>> attributes;\n+\n+    /**\n+     * Constructs an empty handler attributes object.\n+     */\n+    public HandlerAttributes() {\n+        this(new HashMap<>());\n+    }\n+\n+    /**\n+     * Construct a handler attributes object based on the given {@code handlerAttributes} {@link Map}.\n+     *\n+     * @param attributes a {@link Map} from handler type to attributes {@code Map} to base a {@link HandlerAttributes}\n+     *                   on\n+     */\n+    public HandlerAttributes(Map<String, Map<String, Object>> attributes) {\n+        this.attributes = attributes;\n+    }\n+\n+    /**\n+     * Put new {@code attributes} for the given {@code handlerType}.\n+     *\n+     * @param handlerType the type of handler to add {@code attributes} for\n+     * @param attributes  the {@link Map} of attribute information to add for the given {@code handlerType}\n+     */\n+    public void put(String handlerType, Map<String, Object> attributes) {\n+        this.attributes.put(handlerType, attributes);\n+    }\n+\n+    /**\n+     * Retrieve the attributes for the given {@code handlerType}. Might be {@code null} if there are no attributes\n+     * present for the specified type.\n+     *\n+     * @param handlerType the type of handler to retrieve attributes for\n+     * @return the attributes for the given {@code handlerType}\n+     */\n+    public Map<String, Object> get(String handlerType) {\n+        return Collections.unmodifiableMap(attributes.get(handlerType));\n+    }\n+\n+    /**\n+     * Retrieve all attributes for all handler types stored in this {@link HandlerAttributes} object. The returned\n+     * {@link Map} contains a {@link Map} of attribute name to attribute value, per handler type present.\n+     *\n+     * @return all attributes for all handler types stored in this {@link HandlerAttributes} object\n+     */\n+    public Map<String, Map<String, Object>> getAll() {\n+        return Collections.unmodifiableMap(\n+                attributes.entrySet().stream()\n+                          .collect(Collectors.toMap(\n+                                  Map.Entry::getKey,\n+                                  entry -> Collections.unmodifiableMap(entry.getValue())\n+                          ))\n+        );\n+    }\n+\n+    /**\n+     * Retrieve all attributes for all handler types stored in this {@link HandlerAttributes} object in a prefixed\n+     * format. The returned {@link Map} contains keys representing a format of {@code \"[handlerType].[attributeName]\"}\n+     * with the respective attribute value corresponding to the attribute name.\n+     * <p>\n+     * Serves the purpose a of providing a {@code Map} containing a property file like structure.\n+     *\n+     * @return all attributes for all handler types stored in this {@link HandlerAttributes} object in a prefixed format\n+     */\n+    public Map<String, Object> getAllPrefixed() {\n+        Map<String, Object> allPrefixedAttributes = new HashMap<>();\n+        for (Map.Entry<String, Map<String, Object>> attributeEntry : attributes.entrySet()) {\n+            String handlerType = attributeEntry.getKey();\n+            Map<String, Object> prefixedAttributes =\n+                    attributeEntry.getValue().entrySet().stream()\n+                                  .collect(Collectors.toMap(\n+                                          entry -> prefixedKey(handlerType, entry.getKey()),\n+                                          Map.Entry::getValue\n+                                  ));\n+            allPrefixedAttributes.putAll(prefixedAttributes);\n+        }\n+        return Collections.unmodifiableMap(allPrefixedAttributes);\n+    }\n+\n+    private String prefixedKey(String handlerType, String attributeName) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3ODk4ODA3Mw=="}, "originalCommit": {"oid": "e5f2c819f4dc884d185097c590c16feb52a937ef"}, "originalPosition": 98}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzY1MTM5NzMyOnYy", "diffSide": "RIGHT", "path": "messaging/src/main/java/org/axonframework/messaging/annotation/HandlerAttributes.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0xOVQwNzo1MTo0M1rOIoKt0w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0wMlQxNDozMjozOFrOIufClg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3ODk4OTUyMw==", "bodyText": "We should be clear about whether this method does a simple \"string prefix\" approach, or whether the prefix approach is \"dot-aware\".\nFor example, given a key \"SomeAttribute.value\", will the prefix \"Some\" match, or not?\nAlso, I wonder what the value of this method is. HandlerWrappers will generally know what keys they need to interact with. If not, they can get all the attributes and simply iterate over those, ignoring whatever they don't care about. Right?", "url": "https://github.com/AxonFramework/AxonFramework/pull/1621#discussion_r578989523", "createdAt": "2021-02-19T07:51:43Z", "author": {"login": "abuijze"}, "path": "messaging/src/main/java/org/axonframework/messaging/annotation/HandlerAttributes.java", "diffHunk": "@@ -0,0 +1,144 @@\n+package org.axonframework.messaging.annotation;\n+\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * Container for message handler attributes. Can store several {@link Map}s of {@link String} to {@link Object} under\n+ * their own key, resembling a message handling method which serves several handling functions.\n+ *\n+ * @author Steven van Beelen\n+ * @since 4.5\n+ */\n+public class HandlerAttributes {\n+\n+    private final Map<String, Map<String, Object>> attributes;\n+\n+    /**\n+     * Constructs an empty handler attributes object.\n+     */\n+    public HandlerAttributes() {\n+        this(new HashMap<>());\n+    }\n+\n+    /**\n+     * Construct a handler attributes object based on the given {@code handlerAttributes} {@link Map}.\n+     *\n+     * @param attributes a {@link Map} from handler type to attributes {@code Map} to base a {@link HandlerAttributes}\n+     *                   on\n+     */\n+    public HandlerAttributes(Map<String, Map<String, Object>> attributes) {\n+        this.attributes = attributes;\n+    }\n+\n+    /**\n+     * Put new {@code attributes} for the given {@code handlerType}.\n+     *\n+     * @param handlerType the type of handler to add {@code attributes} for\n+     * @param attributes  the {@link Map} of attribute information to add for the given {@code handlerType}\n+     */\n+    public void put(String handlerType, Map<String, Object> attributes) {\n+        this.attributes.put(handlerType, attributes);\n+    }\n+\n+    /**\n+     * Retrieve the attributes for the given {@code handlerType}. Might be {@code null} if there are no attributes\n+     * present for the specified type.\n+     *\n+     * @param handlerType the type of handler to retrieve attributes for\n+     * @return the attributes for the given {@code handlerType}\n+     */\n+    public Map<String, Object> get(String handlerType) {\n+        return Collections.unmodifiableMap(attributes.get(handlerType));\n+    }\n+\n+    /**\n+     * Retrieve all attributes for all handler types stored in this {@link HandlerAttributes} object. The returned\n+     * {@link Map} contains a {@link Map} of attribute name to attribute value, per handler type present.\n+     *\n+     * @return all attributes for all handler types stored in this {@link HandlerAttributes} object\n+     */\n+    public Map<String, Map<String, Object>> getAll() {\n+        return Collections.unmodifiableMap(\n+                attributes.entrySet().stream()\n+                          .collect(Collectors.toMap(\n+                                  Map.Entry::getKey,\n+                                  entry -> Collections.unmodifiableMap(entry.getValue())\n+                          ))\n+        );\n+    }\n+\n+    /**\n+     * Retrieve all attributes for all handler types stored in this {@link HandlerAttributes} object in a prefixed", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e5f2c819f4dc884d185097c590c16feb52a937ef"}, "originalPosition": 75}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4NTYxMzk3NA==", "bodyText": "Yep, done in the JavaDoc of the (new) AnnotatedHandlerAttributes.", "url": "https://github.com/AxonFramework/AxonFramework/pull/1621#discussion_r585613974", "createdAt": "2021-03-02T14:32:38Z", "author": {"login": "smcvb"}, "path": "messaging/src/main/java/org/axonframework/messaging/annotation/HandlerAttributes.java", "diffHunk": "@@ -0,0 +1,144 @@\n+package org.axonframework.messaging.annotation;\n+\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * Container for message handler attributes. Can store several {@link Map}s of {@link String} to {@link Object} under\n+ * their own key, resembling a message handling method which serves several handling functions.\n+ *\n+ * @author Steven van Beelen\n+ * @since 4.5\n+ */\n+public class HandlerAttributes {\n+\n+    private final Map<String, Map<String, Object>> attributes;\n+\n+    /**\n+     * Constructs an empty handler attributes object.\n+     */\n+    public HandlerAttributes() {\n+        this(new HashMap<>());\n+    }\n+\n+    /**\n+     * Construct a handler attributes object based on the given {@code handlerAttributes} {@link Map}.\n+     *\n+     * @param attributes a {@link Map} from handler type to attributes {@code Map} to base a {@link HandlerAttributes}\n+     *                   on\n+     */\n+    public HandlerAttributes(Map<String, Map<String, Object>> attributes) {\n+        this.attributes = attributes;\n+    }\n+\n+    /**\n+     * Put new {@code attributes} for the given {@code handlerType}.\n+     *\n+     * @param handlerType the type of handler to add {@code attributes} for\n+     * @param attributes  the {@link Map} of attribute information to add for the given {@code handlerType}\n+     */\n+    public void put(String handlerType, Map<String, Object> attributes) {\n+        this.attributes.put(handlerType, attributes);\n+    }\n+\n+    /**\n+     * Retrieve the attributes for the given {@code handlerType}. Might be {@code null} if there are no attributes\n+     * present for the specified type.\n+     *\n+     * @param handlerType the type of handler to retrieve attributes for\n+     * @return the attributes for the given {@code handlerType}\n+     */\n+    public Map<String, Object> get(String handlerType) {\n+        return Collections.unmodifiableMap(attributes.get(handlerType));\n+    }\n+\n+    /**\n+     * Retrieve all attributes for all handler types stored in this {@link HandlerAttributes} object. The returned\n+     * {@link Map} contains a {@link Map} of attribute name to attribute value, per handler type present.\n+     *\n+     * @return all attributes for all handler types stored in this {@link HandlerAttributes} object\n+     */\n+    public Map<String, Map<String, Object>> getAll() {\n+        return Collections.unmodifiableMap(\n+                attributes.entrySet().stream()\n+                          .collect(Collectors.toMap(\n+                                  Map.Entry::getKey,\n+                                  entry -> Collections.unmodifiableMap(entry.getValue())\n+                          ))\n+        );\n+    }\n+\n+    /**\n+     * Retrieve all attributes for all handler types stored in this {@link HandlerAttributes} object in a prefixed", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3ODk4OTUyMw=="}, "originalCommit": {"oid": "e5f2c819f4dc884d185097c590c16feb52a937ef"}, "originalPosition": 75}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzY1MTQwMTQxOnYy", "diffSide": "RIGHT", "path": "messaging/src/main/java/org/axonframework/messaging/annotation/MessageHandlingMember.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0xOVQwNzo1MzowNVrOIoKwXg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0wMlQxNDozMzoyNFrOIufE7w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3ODk5MDE3NA==", "bodyText": "Not sure about this method. Isn't this a question of checking whether expected attributes are present?", "url": "https://github.com/AxonFramework/AxonFramework/pull/1621#discussion_r578990174", "createdAt": "2021-02-19T07:53:05Z", "author": {"login": "abuijze"}, "path": "messaging/src/main/java/org/axonframework/messaging/annotation/MessageHandlingMember.java", "diffHunk": "@@ -140,9 +140,26 @@ default String signature() {\n      *\n      * @param annotationType Annotation to check for on the target method\n      * @return {@code true} if the annotation is present on the target method, {@code false} otherwise\n+     * @deprecated in favor of {@link #isA(String)}\n      */\n+    @Deprecated\n     boolean hasAnnotation(Class<? extends Annotation> annotationType);\n \n+    /**\n+     * Validates whether this {@link MessageHandlingMember} is an implementation of the given {@code handlerType}.\n+     * <p>\n+     * Note that a given message handling member can be several handler types at once. For example an Event Handler is\n+     * also a Message Handler of type Event Message.\n+     *\n+     * @param handlerType the {@link MessageHandlingMember} type to validate whether this handler is an implementation\n+     *                    of\n+     * @return {@code true} if this {@link MessageHandlingMember} is an implementation of the given {@code handlerType},\n+     * {@code false} otherwise\n+     */\n+    default boolean isA(String handlerType) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e5f2c819f4dc884d185097c590c16feb52a937ef"}, "originalPosition": 20}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4NTQwNjI3OA==", "bodyText": "That is indeed what it comes down to in the implementation. This is why the HandlerAttributes store everything as a Map<String, Map<String, Object>>.\nIt is the first key in the map which contains \"the type of handler\" since that is the annotation class name.\nIf we would combine the key of the handler and the attribute immediately, I assumed the operation would be less efficient, since we need to move through all the entries ourselves and perform a String#contains.", "url": "https://github.com/AxonFramework/AxonFramework/pull/1621#discussion_r585406278", "createdAt": "2021-03-02T09:34:53Z", "author": {"login": "smcvb"}, "path": "messaging/src/main/java/org/axonframework/messaging/annotation/MessageHandlingMember.java", "diffHunk": "@@ -140,9 +140,26 @@ default String signature() {\n      *\n      * @param annotationType Annotation to check for on the target method\n      * @return {@code true} if the annotation is present on the target method, {@code false} otherwise\n+     * @deprecated in favor of {@link #isA(String)}\n      */\n+    @Deprecated\n     boolean hasAnnotation(Class<? extends Annotation> annotationType);\n \n+    /**\n+     * Validates whether this {@link MessageHandlingMember} is an implementation of the given {@code handlerType}.\n+     * <p>\n+     * Note that a given message handling member can be several handler types at once. For example an Event Handler is\n+     * also a Message Handler of type Event Message.\n+     *\n+     * @param handlerType the {@link MessageHandlingMember} type to validate whether this handler is an implementation\n+     *                    of\n+     * @return {@code true} if this {@link MessageHandlingMember} is an implementation of the given {@code handlerType},\n+     * {@code false} otherwise\n+     */\n+    default boolean isA(String handlerType) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3ODk5MDE3NA=="}, "originalCommit": {"oid": "e5f2c819f4dc884d185097c590c16feb52a937ef"}, "originalPosition": 20}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4NTYxNDU3NQ==", "bodyText": "As stated on another comment, decided against the isA() and attributes() methods, in favour of just keeping the attribute() method.,", "url": "https://github.com/AxonFramework/AxonFramework/pull/1621#discussion_r585614575", "createdAt": "2021-03-02T14:33:24Z", "author": {"login": "smcvb"}, "path": "messaging/src/main/java/org/axonframework/messaging/annotation/MessageHandlingMember.java", "diffHunk": "@@ -140,9 +140,26 @@ default String signature() {\n      *\n      * @param annotationType Annotation to check for on the target method\n      * @return {@code true} if the annotation is present on the target method, {@code false} otherwise\n+     * @deprecated in favor of {@link #isA(String)}\n      */\n+    @Deprecated\n     boolean hasAnnotation(Class<? extends Annotation> annotationType);\n \n+    /**\n+     * Validates whether this {@link MessageHandlingMember} is an implementation of the given {@code handlerType}.\n+     * <p>\n+     * Note that a given message handling member can be several handler types at once. For example an Event Handler is\n+     * also a Message Handler of type Event Message.\n+     *\n+     * @param handlerType the {@link MessageHandlingMember} type to validate whether this handler is an implementation\n+     *                    of\n+     * @return {@code true} if this {@link MessageHandlingMember} is an implementation of the given {@code handlerType},\n+     * {@code false} otherwise\n+     */\n+    default boolean isA(String handlerType) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3ODk5MDE3NA=="}, "originalCommit": {"oid": "e5f2c819f4dc884d185097c590c16feb52a937ef"}, "originalPosition": 20}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3157, "cost": 1, "resetAt": "2021-11-12T11:18:39Z"}}}