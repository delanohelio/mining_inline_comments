{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDQxNDgwMDM5", "number": 1461, "reviewThreads": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0zMFQwNzozMjozN1rOEJ-DHw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0zMFQwNzozMjozN1rOEJ-DHw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc4ODg5MjQ3OnYy", "diffSide": "RIGHT", "path": "modelling/src/main/java/org/axonframework/modelling/command/AggregateAnnotationCommandHandler.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0zMFQwNzozMjozOFrOGqvd3w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0zMFQwOTo0MjozNVrOGq0fwQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzQ3MTA3MQ==", "bodyText": "I'd rather resolve return value if the handler is of type Void. In other situations, it's fine to return null:\n@CommandHandler\npublic MySuperAwesomeReturnType handle(MyCommand cmd) {\n  if (iDontLikeMyCmd(cmd)) {\n    return null;\n  }\n  return nonNullValue;\n}", "url": "https://github.com/AxonFramework/AxonFramework/pull/1461#discussion_r447471071", "createdAt": "2020-06-30T07:32:38Z", "author": {"login": "m1l4n54v1c"}, "path": "modelling/src/main/java/org/axonframework/modelling/command/AggregateAnnotationCommandHandler.java", "diffHunk": "@@ -393,12 +394,14 @@ private AlwaysCreateAggregateCommandHandler(MessageHandlingMember<? super T> han\n \n         @Override\n         public Object handle(CommandMessage<?> command) throws Exception {\n+            AtomicReference<Object> resultReference = new AtomicReference<>();\n             Aggregate<T> aggregate = repository.newInstance(() -> {\n                 T newInstance = factoryMethod.call();\n-                handler.handle(command, newInstance);\n+                resultReference.set(handler.handle(command, newInstance));\n                 return newInstance;\n             });\n-            return resolveReturnValue(command, aggregate);\n+            Object commandHandlingResult = resultReference.get();\n+            return commandHandlingResult != null ? commandHandlingResult : resolveReturnValue(command, aggregate);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9a2a7ec69322edaaab4ebe980c7d6228baf8d627"}, "originalPosition": 21}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzQ4NjA4OQ==", "bodyText": "Couldn't agree more, so added this just now.", "url": "https://github.com/AxonFramework/AxonFramework/pull/1461#discussion_r447486089", "createdAt": "2020-06-30T07:57:24Z", "author": {"login": "smcvb"}, "path": "modelling/src/main/java/org/axonframework/modelling/command/AggregateAnnotationCommandHandler.java", "diffHunk": "@@ -393,12 +394,14 @@ private AlwaysCreateAggregateCommandHandler(MessageHandlingMember<? super T> han\n \n         @Override\n         public Object handle(CommandMessage<?> command) throws Exception {\n+            AtomicReference<Object> resultReference = new AtomicReference<>();\n             Aggregate<T> aggregate = repository.newInstance(() -> {\n                 T newInstance = factoryMethod.call();\n-                handler.handle(command, newInstance);\n+                resultReference.set(handler.handle(command, newInstance));\n                 return newInstance;\n             });\n-            return resolveReturnValue(command, aggregate);\n+            Object commandHandlingResult = resultReference.get();\n+            return commandHandlingResult != null ? commandHandlingResult : resolveReturnValue(command, aggregate);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzQ3MTA3MQ=="}, "originalCommit": {"oid": "9a2a7ec69322edaaab4ebe980c7d6228baf8d627"}, "originalPosition": 21}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzU0OTI3Ng==", "bodyText": "I'm wondering, why do we need to \"resolve\" anything? It's a method, so the return value of that method could simply be used as the result of the command, just like any other command handler.\nIn the constructor, we didn't have a choice. The result value of a constructor is always the created instance. Since it's pretty bad practice to return an aggregate as a command's result, we added the resolver there.", "url": "https://github.com/AxonFramework/AxonFramework/pull/1461#discussion_r447549276", "createdAt": "2020-06-30T09:35:47Z", "author": {"login": "abuijze"}, "path": "modelling/src/main/java/org/axonframework/modelling/command/AggregateAnnotationCommandHandler.java", "diffHunk": "@@ -393,12 +394,14 @@ private AlwaysCreateAggregateCommandHandler(MessageHandlingMember<? super T> han\n \n         @Override\n         public Object handle(CommandMessage<?> command) throws Exception {\n+            AtomicReference<Object> resultReference = new AtomicReference<>();\n             Aggregate<T> aggregate = repository.newInstance(() -> {\n                 T newInstance = factoryMethod.call();\n-                handler.handle(command, newInstance);\n+                resultReference.set(handler.handle(command, newInstance));\n                 return newInstance;\n             });\n-            return resolveReturnValue(command, aggregate);\n+            Object commandHandlingResult = resultReference.get();\n+            return commandHandlingResult != null ? commandHandlingResult : resolveReturnValue(command, aggregate);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzQ3MTA3MQ=="}, "originalCommit": {"oid": "9a2a7ec69322edaaab4ebe980c7d6228baf8d627"}, "originalPosition": 21}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzU1MzQ3Mw==", "bodyText": "So if I follow you correctly, you wouldn't want to resolve the aggregate identifier if the return type is void?", "url": "https://github.com/AxonFramework/AxonFramework/pull/1461#discussion_r447553473", "createdAt": "2020-06-30T09:42:35Z", "author": {"login": "smcvb"}, "path": "modelling/src/main/java/org/axonframework/modelling/command/AggregateAnnotationCommandHandler.java", "diffHunk": "@@ -393,12 +394,14 @@ private AlwaysCreateAggregateCommandHandler(MessageHandlingMember<? super T> han\n \n         @Override\n         public Object handle(CommandMessage<?> command) throws Exception {\n+            AtomicReference<Object> resultReference = new AtomicReference<>();\n             Aggregate<T> aggregate = repository.newInstance(() -> {\n                 T newInstance = factoryMethod.call();\n-                handler.handle(command, newInstance);\n+                resultReference.set(handler.handle(command, newInstance));\n                 return newInstance;\n             });\n-            return resolveReturnValue(command, aggregate);\n+            Object commandHandlingResult = resultReference.get();\n+            return commandHandlingResult != null ? commandHandlingResult : resolveReturnValue(command, aggregate);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzQ3MTA3MQ=="}, "originalCommit": {"oid": "9a2a7ec69322edaaab4ebe980c7d6228baf8d627"}, "originalPosition": 21}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3214, "cost": 1, "resetAt": "2021-11-12T11:18:39Z"}}}