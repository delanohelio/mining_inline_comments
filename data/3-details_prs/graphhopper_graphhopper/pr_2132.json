{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDg3MjA1MDgy", "number": 2132, "title": "Use temporary helper graph to speed up CH preparation", "bodyText": "This PR aims at reducing the CH preparation time by changing the contraction algorithm. The idea is pretty simple: We use a helper graph which at the beginning of the contraction is more or less a copy of the base graph. The witness searches are performed on this helper graph and the CHGraph is only used to store the resulting shortcuts. When we contract a node x with neighbors p and q: p-x-q we do not insert the p-q shortcut(s) into the CHGraph directly, but instead we add it to the helper graph. When the witness searches are finished we add the x-p and x-q edges to the CHGraph (if they are shortcuts). The p-q shortcut(s) are added only later when we contract node p/q. Importantly, we can also remove all edges adjacent to the node we are contracting from the helper graph after we have performed the witness search. This is the main reason why the preparation becomes faster using this method. So far measurements show that the preparation (node- and edge-based) on this branch is about two to three times faster than master (edge-based performance seems to benefit more from the changes in this branch, also because the turn costs are cached with the helper graph).\nThe obvious downside of this approach is that we need additional memory for the helper graph. As the helper graph becomes smaller and smaller during the preparation (while the CH graph becomes bigger and bigger) we need extra memory mostly at the beginning of the contraction. The size of the helper graph is initially proportional to the size of the base graph. First I thought there are 'as many' shortcuts as there are base graph edges and thus the memory size of the helper graph will be about equal to the memory we need to store the shortcuts. Unfortunately this is not exactly true for two reasons. First, since we are using 'bidirectional' shortcuts for node-based CH there are less shortcuts than base graph edges. Second, to support efficient removal of helper graph edges during the contraction we need to use a less memory efficient representation of the helper graph (this is also partly because of Java's wasteful way of storing heap data). Thus this PR increases the overall memory requirement for CH preparation (node- and edge-based).\nI did some experiments on the Germany OSM for four (node-based) profiles (car,mtb,foot,bike) and was able to run the import with Xmx7000m (using Xmx6500m yielded an out of memory error) on master and needed Xmx8500m on this branch (using Xmx8000m yielded an out of memory error). The key thing to understand here is that the more profiles we prepare in parallel the more helper graph memory we need at the beginning of the import. So an obvious workaround would be using less threads. Another somewhat hacky possibility would be delaying the different preparations a bit such that the peak memory usages of the different threads do not happen at the same time.\nFor edge-based CH we need a lot more memory than for node-based CH because there are more shortcuts, the shortcuts are all uni-directional and each shortcut needs more memory. Therefore the helper graph does not increase the overall memory usage (the helper graph memory is less than the memory we need to reserve for the shortcuts anyway). Actually I was able to speed up the preparation for edge-based even more when using a less memory efficient helper graph than the one I am using now.\nBesides the speed up of the preparation using the approach of this PR has the following advantages:\n\n\nThe shortcuts are automatically sorted by the CH levels of their base nodes. This way we might be able to get rid of the linkA/B pointers for shortcuts (reduce the memory we need to store shortcuts) and the the shortcut storage is more cache-friendly. In fact the CH queries are faster on this branch.\n\n\nAfter the shortcuts are written to the CHGraph they will not change again. So in principle it would be possible to start flushing some of the shortcut storage to disk already during the preparation (to reduce RAM usage).\n\n\nSince we pre-calculate the base-edge weights and store them in the helper graph the preparation time is especially faster for 'expensive' weightings. I.e. if we use a custom weighting that does some costly edge-weight computations they are now done only once while the weightings get evaluated many many times during the witness searches on master. Obviously there would be other ways to 'cache' these weights, but with this PR this is already done and I checked that simply caching the weights does not nearly yield the speed up we see here.\n\n\nRelated #1565", "createdAt": "2020-09-15T10:41:57Z", "url": "https://github.com/graphhopper/graphhopper/pull/2132", "merged": true, "mergeCommit": {"oid": "63369b7405ccc3da069e54caa90c113dd6be3db7"}, "closed": true, "closedAt": "2020-09-22T11:54:44Z", "author": {"login": "easbar"}, "timelineItems": {"totalCount": 23, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdI0axUAH2gAyNDg3MjA1MDgyOmI3YTMyN2JiN2FlNzA0ZjdhMDBiNjFhMTE5ZGEzYzQ5MzJmZDhmYzc=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdLWpVsAH2gAyNDg3MjA1MDgyOjVhNjBiZTI0Mjg4NWJkYTQwNjRlOWY1MjYxOTg1YTlmZjI0MDU3Yjc=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "b7a327bb7ae704f7a00b61a119da3c4932fd8fc7", "author": {"user": {"login": "easbar", "name": "Andi"}}, "url": "https://github.com/graphhopper/graphhopper/commit/b7a327bb7ae704f7a00b61a119da3c4932fd8fc7", "committedDate": "2020-09-14T14:52:56Z", "message": "Use temporary helper graph to speed up CH preparation"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1f5211deb7cf018bff31d50d76a32e978eb0823f", "author": {"user": {"login": "easbar", "name": "Andi"}}, "url": "https://github.com/graphhopper/graphhopper/commit/1f5211deb7cf018bff31d50d76a32e978eb0823f", "committedDate": "2020-09-15T09:12:06Z", "message": "Use split Array2D"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "47e9077efff7ffe7d38e5eee6806762a934bf490", "author": {"user": {"login": "easbar", "name": "Andi"}}, "url": "https://github.com/graphhopper/graphhopper/commit/47e9077efff7ffe7d38e5eee6806762a934bf490", "committedDate": "2020-09-15T10:33:25Z", "message": "Make sure memory for CH preparation is not retained after contraction or loading"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDg5NTY2NTA5", "url": "https://github.com/graphhopper/graphhopper/pull/2132#pullrequestreview-489566509", "createdAt": "2020-09-16T12:21:47Z", "commit": {"oid": "47e9077efff7ffe7d38e5eee6806762a934bf490"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNlQxMjoyMTo0N1rOHSuMew==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNlQxMjoyMTo0N1rOHSuMew==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTM5MzI3NQ==", "bodyText": "Why do we need those 4 methods? The methods getOrigEdgeKeyLastBA and getOrigEdgeKeyFirstBA\nand then getOrigEdgeKeyFirstAB and getOrigEdgeKeyLastAB look identical and could we just omit two of them as this isn't used elsewhere? Also instead of\nif (nodeA > nodeB) keyFwd += 1;\nreturn keyFwd;\n\nwe could write:\nreturn nodeA > nodeB? keyFwd + 1 : keyFwd;\n\nbut probably this is done from the JIT already", "url": "https://github.com/graphhopper/graphhopper/pull/2132#discussion_r489393275", "createdAt": "2020-09-16T12:21:47Z", "author": {"login": "karussell"}, "path": "core/src/main/java/com/graphhopper/routing/ch/CHPreparationGraph.java", "diffHunk": "@@ -0,0 +1,870 @@\n+/*\n+ *  Licensed to GraphHopper GmbH under one or more contributor\n+ *  license agreements. See the NOTICE file distributed with this work for\n+ *  additional information regarding copyright ownership.\n+ *\n+ *  GraphHopper GmbH licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except in\n+ *  compliance with the License. You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+\n+package com.graphhopper.routing.ch;\n+\n+import com.carrotsearch.hppc.*;\n+import com.carrotsearch.hppc.sorting.IndirectComparator;\n+import com.carrotsearch.hppc.sorting.IndirectSort;\n+import com.graphhopper.routing.ev.BooleanEncodedValue;\n+import com.graphhopper.routing.ev.DecimalEncodedValue;\n+import com.graphhopper.routing.ev.TurnCost;\n+import com.graphhopper.routing.util.AllEdgesIterator;\n+import com.graphhopper.routing.util.FlagEncoder;\n+import com.graphhopper.routing.weighting.Weighting;\n+import com.graphhopper.storage.Graph;\n+import com.graphhopper.storage.TurnCostStorage;\n+import com.graphhopper.util.BitUtil;\n+import com.graphhopper.util.EdgeIterator;\n+import com.graphhopper.util.GHUtility;\n+\n+/**\n+ * Graph data structure used for CH preparation. It allows caching weights and edges that are not needed anymore\n+ * (those adjacent to contracted nodes) can be removed (see {@link #disconnect}.\n+ */\n+public class CHPreparationGraph {\n+    private final int nodes;\n+    private final int edges;\n+    private final boolean edgeBased;\n+    private final TurnCostFunction turnCostFunction;\n+    // each edge/shortcut between nodes a/b is represented as a single object and we maintain a list of references\n+    // to these objects at every node. this needs to be memory-efficient especially for node-based (because there\n+    // are less shortcuts overall so the size of the prepare graph is crucial, while for edge-based most memory is\n+    // consumed towards the end of the preparation anyway). for edge-based it would actually be better/faster to keep\n+    // separate lists of incoming/outgoing edges and even use uni-directional edge-objects.\n+    private SplitArray2D<PrepareEdge> prepareEdges;\n+    private IntSet neighborSet;\n+    private OrigGraph origGraph;\n+    private OrigGraph.Builder origGraphBuilder;\n+    private int nextShortcutId;\n+    private boolean ready;\n+\n+    public static CHPreparationGraph nodeBased(int nodes, int edges) {\n+        return new CHPreparationGraph(nodes, edges, false, (in, via, out) -> 0);\n+    }\n+\n+    public static CHPreparationGraph edgeBased(int nodes, int edges, TurnCostFunction turnCostFunction) {\n+        return new CHPreparationGraph(nodes, edges, true, turnCostFunction);\n+    }\n+\n+    /**\n+     * @param nodes (fixed) number of nodes of the graph\n+     * @param edges the maximum number of (non-shortcut) edges in this graph. edges-1 is the maximum edge id that may\n+     *              be used.\n+     */\n+    private CHPreparationGraph(int nodes, int edges, boolean edgeBased, TurnCostFunction turnCostFunction) {\n+        this.turnCostFunction = turnCostFunction;\n+        this.nodes = nodes;\n+        this.edges = edges;\n+        this.edgeBased = edgeBased;\n+        prepareEdges = new SplitArray2D<>(nodes, 2);\n+        origGraphBuilder = edgeBased ? new OrigGraph.Builder() : null;\n+        neighborSet = new IntHashSet();\n+        nextShortcutId = edges;\n+    }\n+\n+    public static void buildFromGraph(CHPreparationGraph prepareGraph, Graph graph, Weighting weighting) {\n+        if (graph.getNodes() != prepareGraph.getNodes())\n+            throw new IllegalArgumentException(\"Cannot initialize from given graph. The number of nodes does not match: \" +\n+                    graph.getNodes() + \" vs. \" + prepareGraph.getNodes());\n+        if (graph.getEdges() != prepareGraph.getOriginalEdges())\n+            throw new IllegalArgumentException(\"Cannot initialize from given graph. The number of edges does not match: \" +\n+                    graph.getEdges() + \" vs. \" + prepareGraph.getOriginalEdges());\n+        BooleanEncodedValue accessEnc = weighting.getFlagEncoder().getAccessEnc();\n+        AllEdgesIterator iter = graph.getAllEdges();\n+        while (iter.next()) {\n+            double weightFwd = iter.get(accessEnc) ? weighting.calcEdgeWeight(iter, false) : Double.POSITIVE_INFINITY;\n+            double weightBwd = iter.getReverse(accessEnc) ? weighting.calcEdgeWeight(iter, true) : Double.POSITIVE_INFINITY;\n+            prepareGraph.addEdge(iter.getBaseNode(), iter.getAdjNode(), iter.getEdge(), weightFwd, weightBwd);\n+        }\n+        prepareGraph.prepareForContraction();\n+    }\n+\n+    /**\n+     * Builds a turn cost function for a given graph('s turn cost storage) and a weighting.\n+     * The trivial implementation would be simply returning {@link Weighting#calcTurnWeight}. However, it turned out\n+     * that reading all turn costs for the current encoder and then storing them in separate arrays upfront speeds up\n+     * edge-based CH preparation by about 25%. See #2084\n+     */\n+    public static TurnCostFunction buildTurnCostFunctionFromTurnCostStorage(Graph graph, Weighting weighting) {\n+        FlagEncoder encoder = weighting.getFlagEncoder();\n+        String key = TurnCost.key(encoder.toString());\n+        if (!encoder.hasEncodedValue(key))\n+            return (inEdge, viaNode, outEdge) -> 0;\n+\n+        DecimalEncodedValue turnCostEnc = encoder.getDecimalEncodedValue(key);\n+        TurnCostStorage turnCostStorage = graph.getTurnCostStorage();\n+        // we maintain a list of inEdge/outEdge/turn-cost triples (we use two arrays for this) that is sorted by nodes\n+        LongArrayList turnCostEdgePairs = new LongArrayList();\n+        DoubleArrayList turnCosts = new DoubleArrayList();\n+        // for each node we store the index of the first turn cost entry/triple in the list\n+        final int[] turnCostNodes = new int[graph.getNodes() + 1];\n+        // todonow: get rid of this hack... / obtain the u-turn costs directly from weighting\n+        double uTurnCosts = weighting.calcTurnWeight(1, 0, 1);\n+        TurnCostStorage.TurnRelationIterator tcIter = turnCostStorage.getAllTurnRelations();\n+        int lastNode = -1;\n+        while (tcIter.next()) {\n+            int viaNode = tcIter.getViaNode();\n+            if (viaNode < lastNode)\n+                throw new IllegalStateException();\n+            long edgePair = BitUtil.LITTLE.combineIntsToLong(tcIter.getFromEdge(), tcIter.getToEdge());\n+            double turnCost = tcIter.getCost(turnCostEnc);\n+            // todonow: do not forget that for pure OSM this is always infinite currently...\n+            int index = turnCostEdgePairs.size();\n+            turnCostEdgePairs.add(edgePair);\n+            turnCosts.add(turnCost);\n+            if (viaNode != lastNode) {\n+                for (int i = lastNode + 1; i <= viaNode; i++) {\n+                    turnCostNodes[i] = index;\n+                }\n+            }\n+            lastNode = viaNode;\n+        }\n+        for (int i = lastNode + 1; i <= turnCostNodes.length - 1; i++) {\n+            turnCostNodes[i] = turnCostEdgePairs.size();\n+        }\n+        turnCostNodes[turnCostNodes.length - 1] = turnCostEdgePairs.size();\n+\n+        return (inEdge, viaNode, outEdge) -> {\n+            if (!EdgeIterator.Edge.isValid(inEdge) || !EdgeIterator.Edge.isValid(outEdge))\n+                return 0;\n+            else if (inEdge == outEdge)\n+                return uTurnCosts;\n+            // traverse all turn cost entries we have for this viaNode and return the turn costs if we find a match\n+            for (int i = turnCostNodes[viaNode]; i < turnCostNodes[viaNode + 1]; i++) {\n+                long l = turnCostEdgePairs.get(i);\n+                if (inEdge == BitUtil.LITTLE.getIntLow(l) && outEdge == BitUtil.LITTLE.getIntHigh(l))\n+                    return turnCosts.get(i);\n+            }\n+            return 0;\n+        };\n+    }\n+\n+    public int getNodes() {\n+        return nodes;\n+    }\n+\n+    public int getOriginalEdges() {\n+        return edges;\n+    }\n+\n+    public int getDegree(int node) {\n+        return prepareEdges.size(node);\n+    }\n+\n+    public void addEdge(int from, int to, int edge, double weightFwd, double weightBwd) {\n+        checkNotReady();\n+        boolean fwd = Double.isFinite(weightFwd);\n+        boolean bwd = Double.isFinite(weightBwd);\n+        if (!fwd && !bwd)\n+            return;\n+        // todonow: is it ok to cast to float? maybe add some check that asserts certain precision? especially inf?\n+        PrepareBaseEdge prepareEdge = new PrepareBaseEdge(edge, from, to, (float) weightFwd, (float) weightBwd);\n+        if (Double.isFinite(weightFwd)) {\n+            addOutEdge(from, prepareEdge);\n+            addInEdge(to, prepareEdge);\n+        }\n+        if (Double.isFinite(weightBwd) && from != to) {\n+            addOutEdge(to, prepareEdge);\n+            addInEdge(from, prepareEdge);\n+        }\n+        if (edgeBased)\n+            origGraphBuilder.addEdge(from, to, edge, fwd, bwd);\n+    }\n+\n+    public int addShortcut(int from, int to, int origEdgeKeyFirst, int origEdgeKeyLast, int skipped1,\n+                           int skipped2, double weight, int origEdgeCount) {\n+        checkReady();\n+        PrepareEdge prepareEdge = edgeBased\n+                ? new EdgeBasedPrepareShortcut(nextShortcutId, from, to, origEdgeKeyFirst, origEdgeKeyLast, weight, skipped1, skipped2, origEdgeCount)\n+                : new PrepareShortcut(nextShortcutId, from, to, weight, skipped1, skipped2, origEdgeCount);\n+        addOutEdge(from, prepareEdge);\n+        addInEdge(to, prepareEdge);\n+        return nextShortcutId++;\n+    }\n+\n+    public void prepareForContraction() {\n+        checkNotReady();\n+        origGraph = edgeBased ? origGraphBuilder.build() : null;\n+        origGraphBuilder = null;\n+        // todo: performance - maybe sort the edges in some clever way?\n+        ready = true;\n+    }\n+\n+    public PrepareGraphEdgeExplorer createOutEdgeExplorer() {\n+        checkReady();\n+        return new PrepareGraphEdgeExplorerImpl(prepareEdges, false);\n+    }\n+\n+    public PrepareGraphEdgeExplorer createInEdgeExplorer() {\n+        checkReady();\n+        return new PrepareGraphEdgeExplorerImpl(prepareEdges, true);\n+    }\n+\n+    public PrepareGraphOrigEdgeExplorer createOutOrigEdgeExplorer() {\n+        checkReady();\n+        if (!edgeBased)\n+            throw new IllegalStateException(\"orig out explorer is not available for node-based graph\");\n+        return origGraph.createOutOrigEdgeExplorer();\n+    }\n+\n+    public PrepareGraphOrigEdgeExplorer createInOrigEdgeExplorer() {\n+        checkReady();\n+        if (!edgeBased)\n+            throw new IllegalStateException(\"orig in explorer is not available for node-based graph\");\n+        return origGraph.createInOrigEdgeExplorer();\n+    }\n+\n+    public double getTurnWeight(int inEdge, int viaNode, int outEdge) {\n+        return turnCostFunction.getTurnWeight(inEdge, viaNode, outEdge);\n+    }\n+\n+    public IntContainer disconnect(int node) {\n+        checkReady();\n+        // we use this neighbor set to guarantee a deterministic order of the returned\n+        // node ids\n+        neighborSet.clear();\n+        IntArrayList neighbors = new IntArrayList(getDegree(node));\n+        for (int i = 0; i < prepareEdges.size(node); i++) {\n+            PrepareEdge prepareEdge = prepareEdges.get(node, i);\n+            int adjNode = prepareEdge.getNodeB();\n+            if (adjNode == node)\n+                adjNode = prepareEdge.getNodeA();\n+            if (adjNode == node)\n+                // this is a loop\n+                continue;\n+            prepareEdges.remove(adjNode, prepareEdge);\n+            if (neighborSet.add(adjNode))\n+                neighbors.add(adjNode);\n+        }\n+        prepareEdges.clear(node);\n+        return neighbors;\n+    }\n+\n+    public void close() {\n+        checkReady();\n+        prepareEdges = null;\n+        neighborSet = null;\n+        if (edgeBased)\n+            origGraph = null;\n+    }\n+\n+    private void addOutEdge(int node, PrepareEdge prepareEdge) {\n+        prepareEdges.addPartTwo(node, prepareEdge);\n+    }\n+\n+    private void addInEdge(int node, PrepareEdge prepareEdge) {\n+        prepareEdges.addPartOne(node, prepareEdge);\n+    }\n+\n+    private void checkReady() {\n+        if (!ready)\n+            throw new IllegalStateException(\"You need to call prepareForContraction() before calling this method\");\n+    }\n+\n+    private void checkNotReady() {\n+        if (ready)\n+            throw new IllegalStateException(\"You cannot call this method after calling prepareForContraction()\");\n+    }\n+\n+    @FunctionalInterface\n+    public interface TurnCostFunction {\n+        double getTurnWeight(int inEdge, int viaNode, int outEdge);\n+    }\n+\n+    private static class PrepareGraphEdgeExplorerImpl implements PrepareGraphEdgeExplorer, PrepareGraphEdgeIterator {\n+        private final SplitArray2D<PrepareEdge> prepareEdges;\n+        private final boolean reverse;\n+        private int node = -1;\n+        private int end;\n+        private PrepareEdge currEdge;\n+        private int index;\n+\n+        PrepareGraphEdgeExplorerImpl(SplitArray2D<PrepareEdge> prepareEdges, boolean reverse) {\n+            this.prepareEdges = prepareEdges;\n+            this.reverse = reverse;\n+        }\n+\n+        @Override\n+        public PrepareGraphEdgeIterator setBaseNode(int node) {\n+            this.node = node;\n+            // we store the in edges in the first and the out edges in the second part of the prepareEdges\n+            this.index = reverse ? -1 : (prepareEdges.mid(node) - 1);\n+            this.end = reverse ? prepareEdges.mid(node) : prepareEdges.size(node);\n+            return this;\n+        }\n+\n+        @Override\n+        public boolean next() {\n+            index++;\n+            if (index == end) {\n+                currEdge = null;\n+                return false;\n+            }\n+            currEdge = prepareEdges.get(node, index);\n+            return true;\n+        }\n+\n+        @Override\n+        public int getBaseNode() {\n+            return node;\n+        }\n+\n+        @Override\n+        public int getAdjNode() {\n+            return nodeAisBase() ? currEdge.getNodeB() : currEdge.getNodeA();\n+        }\n+\n+        @Override\n+        public int getPrepareEdge() {\n+            return currEdge.getPrepareEdge();\n+        }\n+\n+        @Override\n+        public boolean isShortcut() {\n+            return currEdge.isShortcut();\n+        }\n+\n+        @Override\n+        public int getOrigEdgeKeyFirst() {\n+            return nodeAisBase() ? currEdge.getOrigEdgeKeyFirstAB() : currEdge.getOrigEdgeKeyFirstBA();\n+        }\n+\n+        @Override\n+        public int getOrigEdgeKeyLast() {\n+            return nodeAisBase() ? currEdge.getOrigEdgeKeyLastAB() : currEdge.getOrigEdgeKeyLastBA();\n+        }\n+\n+        @Override\n+        public int getSkipped1() {\n+            return currEdge.getSkipped1();\n+        }\n+\n+        @Override\n+        public int getSkipped2() {\n+            return currEdge.getSkipped2();\n+        }\n+\n+        @Override\n+        public double getWeight() {\n+            if (nodeAisBase()) {\n+                return reverse ? currEdge.getWeightBA() : currEdge.getWeightAB();\n+            } else {\n+                return reverse ? currEdge.getWeightAB() : currEdge.getWeightBA();\n+            }\n+        }\n+\n+        @Override\n+        public int getOrigEdgeCount() {\n+            return currEdge.getOrigEdgeCount();\n+        }\n+\n+        @Override\n+        public void setSkippedEdges(int skipped1, int skipped2) {\n+            currEdge.setSkipped1(skipped1);\n+            currEdge.setSkipped2(skipped2);\n+        }\n+\n+        @Override\n+        public void setWeight(double weight) {\n+            assert Double.isFinite(weight);\n+            currEdge.setWeight(weight);\n+        }\n+\n+        @Override\n+        public void setOrigEdgeCount(int origEdgeCount) {\n+            currEdge.setOrigEdgeCount(origEdgeCount);\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return currEdge == null ? \"not_started\" : getBaseNode() + \"-\" + getAdjNode();\n+        }\n+\n+        private boolean nodeAisBase() {\n+            // in some cases we need to determine which direction of the (bidirectional) edge we want\n+            return currEdge.getNodeA() == node;\n+        }\n+    }\n+\n+    interface PrepareEdge {\n+        boolean isShortcut();\n+\n+        int getPrepareEdge();\n+\n+        int getNodeA();\n+\n+        int getNodeB();\n+\n+        double getWeightAB();\n+\n+        double getWeightBA();\n+\n+        int getOrigEdgeKeyFirstAB();\n+\n+        int getOrigEdgeKeyFirstBA();\n+\n+        int getOrigEdgeKeyLastAB();\n+\n+        int getOrigEdgeKeyLastBA();\n+\n+        int getSkipped1();\n+\n+        int getSkipped2();\n+\n+        int getOrigEdgeCount();\n+\n+        void setSkipped1(int skipped1);\n+\n+        void setSkipped2(int skipped2);\n+\n+        void setWeight(double weight);\n+\n+        void setOrigEdgeCount(int origEdgeCount);\n+    }\n+\n+    public static class PrepareBaseEdge implements PrepareEdge {\n+        private final int prepareEdge;\n+        private final int nodeA;\n+        private final int nodeB;\n+        private final float weightAB;\n+        private final float weightBA;\n+\n+        public PrepareBaseEdge(int prepareEdge, int nodeA, int nodeB, float weightAB, float weightBA) {\n+            this.prepareEdge = prepareEdge;\n+            this.nodeA = nodeA;\n+            this.nodeB = nodeB;\n+            this.weightAB = weightAB;\n+            this.weightBA = weightBA;\n+        }\n+\n+        @Override\n+        public boolean isShortcut() {\n+            return false;\n+        }\n+\n+        @Override\n+        public int getPrepareEdge() {\n+            return prepareEdge;\n+        }\n+\n+        @Override\n+        public int getNodeA() {\n+            return nodeA;\n+        }\n+\n+        @Override\n+        public int getNodeB() {\n+            return nodeB;\n+        }\n+\n+        @Override\n+        public double getWeightAB() {\n+            return weightAB;\n+        }\n+\n+        @Override\n+        public double getWeightBA() {\n+            return weightBA;\n+        }\n+\n+        @Override\n+        public int getOrigEdgeKeyFirstAB() {\n+            int keyFwd = prepareEdge << 1;\n+            if (nodeA > nodeB)\n+                keyFwd += 1;\n+            return keyFwd;\n+        }\n+\n+        @Override\n+        public int getOrigEdgeKeyFirstBA() {\n+            int keyBwd = prepareEdge << 1;\n+            if (nodeB > nodeA)\n+                keyBwd += 1;\n+            return keyBwd;\n+        }\n+\n+        @Override\n+        public int getOrigEdgeKeyLastAB() {\n+            int keyFwd = prepareEdge << 1;\n+            if (nodeA > nodeB)\n+                keyFwd += 1;\n+            return keyFwd;\n+        }\n+\n+        @Override\n+        public int getOrigEdgeKeyLastBA() {\n+            int keyBwd = prepareEdge << 1;\n+            if (nodeB > nodeA)\n+                keyBwd += 1;\n+            return keyBwd;\n+        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "47e9077efff7ffe7d38e5eee6806762a934bf490"}, "originalPosition": 516}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDg5NTY5NzY5", "url": "https://github.com/graphhopper/graphhopper/pull/2132#pullrequestreview-489569769", "createdAt": "2020-09-16T12:26:06Z", "commit": {"oid": "47e9077efff7ffe7d38e5eee6806762a934bf490"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNlQxMjoyNjowNlrOHSuWXg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNlQxMjoyNjowNlrOHSuWXg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTM5NTgwNg==", "bodyText": "This is a bit low. Can we avoid this reduction to 30 bits somehow? (we could use 5 bytes and a RAMDataAccess?)", "url": "https://github.com/graphhopper/graphhopper/pull/2132#discussion_r489395806", "createdAt": "2020-09-16T12:26:06Z", "author": {"login": "karussell"}, "path": "core/src/main/java/com/graphhopper/routing/ch/CHPreparationGraph.java", "diffHunk": "@@ -0,0 +1,870 @@\n+/*\n+ *  Licensed to GraphHopper GmbH under one or more contributor\n+ *  license agreements. See the NOTICE file distributed with this work for\n+ *  additional information regarding copyright ownership.\n+ *\n+ *  GraphHopper GmbH licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except in\n+ *  compliance with the License. You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+\n+package com.graphhopper.routing.ch;\n+\n+import com.carrotsearch.hppc.*;\n+import com.carrotsearch.hppc.sorting.IndirectComparator;\n+import com.carrotsearch.hppc.sorting.IndirectSort;\n+import com.graphhopper.routing.ev.BooleanEncodedValue;\n+import com.graphhopper.routing.ev.DecimalEncodedValue;\n+import com.graphhopper.routing.ev.TurnCost;\n+import com.graphhopper.routing.util.AllEdgesIterator;\n+import com.graphhopper.routing.util.FlagEncoder;\n+import com.graphhopper.routing.weighting.Weighting;\n+import com.graphhopper.storage.Graph;\n+import com.graphhopper.storage.TurnCostStorage;\n+import com.graphhopper.util.BitUtil;\n+import com.graphhopper.util.EdgeIterator;\n+import com.graphhopper.util.GHUtility;\n+\n+/**\n+ * Graph data structure used for CH preparation. It allows caching weights and edges that are not needed anymore\n+ * (those adjacent to contracted nodes) can be removed (see {@link #disconnect}.\n+ */\n+public class CHPreparationGraph {\n+    private final int nodes;\n+    private final int edges;\n+    private final boolean edgeBased;\n+    private final TurnCostFunction turnCostFunction;\n+    // each edge/shortcut between nodes a/b is represented as a single object and we maintain a list of references\n+    // to these objects at every node. this needs to be memory-efficient especially for node-based (because there\n+    // are less shortcuts overall so the size of the prepare graph is crucial, while for edge-based most memory is\n+    // consumed towards the end of the preparation anyway). for edge-based it would actually be better/faster to keep\n+    // separate lists of incoming/outgoing edges and even use uni-directional edge-objects.\n+    private SplitArray2D<PrepareEdge> prepareEdges;\n+    private IntSet neighborSet;\n+    private OrigGraph origGraph;\n+    private OrigGraph.Builder origGraphBuilder;\n+    private int nextShortcutId;\n+    private boolean ready;\n+\n+    public static CHPreparationGraph nodeBased(int nodes, int edges) {\n+        return new CHPreparationGraph(nodes, edges, false, (in, via, out) -> 0);\n+    }\n+\n+    public static CHPreparationGraph edgeBased(int nodes, int edges, TurnCostFunction turnCostFunction) {\n+        return new CHPreparationGraph(nodes, edges, true, turnCostFunction);\n+    }\n+\n+    /**\n+     * @param nodes (fixed) number of nodes of the graph\n+     * @param edges the maximum number of (non-shortcut) edges in this graph. edges-1 is the maximum edge id that may\n+     *              be used.\n+     */\n+    private CHPreparationGraph(int nodes, int edges, boolean edgeBased, TurnCostFunction turnCostFunction) {\n+        this.turnCostFunction = turnCostFunction;\n+        this.nodes = nodes;\n+        this.edges = edges;\n+        this.edgeBased = edgeBased;\n+        prepareEdges = new SplitArray2D<>(nodes, 2);\n+        origGraphBuilder = edgeBased ? new OrigGraph.Builder() : null;\n+        neighborSet = new IntHashSet();\n+        nextShortcutId = edges;\n+    }\n+\n+    public static void buildFromGraph(CHPreparationGraph prepareGraph, Graph graph, Weighting weighting) {\n+        if (graph.getNodes() != prepareGraph.getNodes())\n+            throw new IllegalArgumentException(\"Cannot initialize from given graph. The number of nodes does not match: \" +\n+                    graph.getNodes() + \" vs. \" + prepareGraph.getNodes());\n+        if (graph.getEdges() != prepareGraph.getOriginalEdges())\n+            throw new IllegalArgumentException(\"Cannot initialize from given graph. The number of edges does not match: \" +\n+                    graph.getEdges() + \" vs. \" + prepareGraph.getOriginalEdges());\n+        BooleanEncodedValue accessEnc = weighting.getFlagEncoder().getAccessEnc();\n+        AllEdgesIterator iter = graph.getAllEdges();\n+        while (iter.next()) {\n+            double weightFwd = iter.get(accessEnc) ? weighting.calcEdgeWeight(iter, false) : Double.POSITIVE_INFINITY;\n+            double weightBwd = iter.getReverse(accessEnc) ? weighting.calcEdgeWeight(iter, true) : Double.POSITIVE_INFINITY;\n+            prepareGraph.addEdge(iter.getBaseNode(), iter.getAdjNode(), iter.getEdge(), weightFwd, weightBwd);\n+        }\n+        prepareGraph.prepareForContraction();\n+    }\n+\n+    /**\n+     * Builds a turn cost function for a given graph('s turn cost storage) and a weighting.\n+     * The trivial implementation would be simply returning {@link Weighting#calcTurnWeight}. However, it turned out\n+     * that reading all turn costs for the current encoder and then storing them in separate arrays upfront speeds up\n+     * edge-based CH preparation by about 25%. See #2084\n+     */\n+    public static TurnCostFunction buildTurnCostFunctionFromTurnCostStorage(Graph graph, Weighting weighting) {\n+        FlagEncoder encoder = weighting.getFlagEncoder();\n+        String key = TurnCost.key(encoder.toString());\n+        if (!encoder.hasEncodedValue(key))\n+            return (inEdge, viaNode, outEdge) -> 0;\n+\n+        DecimalEncodedValue turnCostEnc = encoder.getDecimalEncodedValue(key);\n+        TurnCostStorage turnCostStorage = graph.getTurnCostStorage();\n+        // we maintain a list of inEdge/outEdge/turn-cost triples (we use two arrays for this) that is sorted by nodes\n+        LongArrayList turnCostEdgePairs = new LongArrayList();\n+        DoubleArrayList turnCosts = new DoubleArrayList();\n+        // for each node we store the index of the first turn cost entry/triple in the list\n+        final int[] turnCostNodes = new int[graph.getNodes() + 1];\n+        // todonow: get rid of this hack... / obtain the u-turn costs directly from weighting\n+        double uTurnCosts = weighting.calcTurnWeight(1, 0, 1);\n+        TurnCostStorage.TurnRelationIterator tcIter = turnCostStorage.getAllTurnRelations();\n+        int lastNode = -1;\n+        while (tcIter.next()) {\n+            int viaNode = tcIter.getViaNode();\n+            if (viaNode < lastNode)\n+                throw new IllegalStateException();\n+            long edgePair = BitUtil.LITTLE.combineIntsToLong(tcIter.getFromEdge(), tcIter.getToEdge());\n+            double turnCost = tcIter.getCost(turnCostEnc);\n+            // todonow: do not forget that for pure OSM this is always infinite currently...\n+            int index = turnCostEdgePairs.size();\n+            turnCostEdgePairs.add(edgePair);\n+            turnCosts.add(turnCost);\n+            if (viaNode != lastNode) {\n+                for (int i = lastNode + 1; i <= viaNode; i++) {\n+                    turnCostNodes[i] = index;\n+                }\n+            }\n+            lastNode = viaNode;\n+        }\n+        for (int i = lastNode + 1; i <= turnCostNodes.length - 1; i++) {\n+            turnCostNodes[i] = turnCostEdgePairs.size();\n+        }\n+        turnCostNodes[turnCostNodes.length - 1] = turnCostEdgePairs.size();\n+\n+        return (inEdge, viaNode, outEdge) -> {\n+            if (!EdgeIterator.Edge.isValid(inEdge) || !EdgeIterator.Edge.isValid(outEdge))\n+                return 0;\n+            else if (inEdge == outEdge)\n+                return uTurnCosts;\n+            // traverse all turn cost entries we have for this viaNode and return the turn costs if we find a match\n+            for (int i = turnCostNodes[viaNode]; i < turnCostNodes[viaNode + 1]; i++) {\n+                long l = turnCostEdgePairs.get(i);\n+                if (inEdge == BitUtil.LITTLE.getIntLow(l) && outEdge == BitUtil.LITTLE.getIntHigh(l))\n+                    return turnCosts.get(i);\n+            }\n+            return 0;\n+        };\n+    }\n+\n+    public int getNodes() {\n+        return nodes;\n+    }\n+\n+    public int getOriginalEdges() {\n+        return edges;\n+    }\n+\n+    public int getDegree(int node) {\n+        return prepareEdges.size(node);\n+    }\n+\n+    public void addEdge(int from, int to, int edge, double weightFwd, double weightBwd) {\n+        checkNotReady();\n+        boolean fwd = Double.isFinite(weightFwd);\n+        boolean bwd = Double.isFinite(weightBwd);\n+        if (!fwd && !bwd)\n+            return;\n+        // todonow: is it ok to cast to float? maybe add some check that asserts certain precision? especially inf?\n+        PrepareBaseEdge prepareEdge = new PrepareBaseEdge(edge, from, to, (float) weightFwd, (float) weightBwd);\n+        if (Double.isFinite(weightFwd)) {\n+            addOutEdge(from, prepareEdge);\n+            addInEdge(to, prepareEdge);\n+        }\n+        if (Double.isFinite(weightBwd) && from != to) {\n+            addOutEdge(to, prepareEdge);\n+            addInEdge(from, prepareEdge);\n+        }\n+        if (edgeBased)\n+            origGraphBuilder.addEdge(from, to, edge, fwd, bwd);\n+    }\n+\n+    public int addShortcut(int from, int to, int origEdgeKeyFirst, int origEdgeKeyLast, int skipped1,\n+                           int skipped2, double weight, int origEdgeCount) {\n+        checkReady();\n+        PrepareEdge prepareEdge = edgeBased\n+                ? new EdgeBasedPrepareShortcut(nextShortcutId, from, to, origEdgeKeyFirst, origEdgeKeyLast, weight, skipped1, skipped2, origEdgeCount)\n+                : new PrepareShortcut(nextShortcutId, from, to, weight, skipped1, skipped2, origEdgeCount);\n+        addOutEdge(from, prepareEdge);\n+        addInEdge(to, prepareEdge);\n+        return nextShortcutId++;\n+    }\n+\n+    public void prepareForContraction() {\n+        checkNotReady();\n+        origGraph = edgeBased ? origGraphBuilder.build() : null;\n+        origGraphBuilder = null;\n+        // todo: performance - maybe sort the edges in some clever way?\n+        ready = true;\n+    }\n+\n+    public PrepareGraphEdgeExplorer createOutEdgeExplorer() {\n+        checkReady();\n+        return new PrepareGraphEdgeExplorerImpl(prepareEdges, false);\n+    }\n+\n+    public PrepareGraphEdgeExplorer createInEdgeExplorer() {\n+        checkReady();\n+        return new PrepareGraphEdgeExplorerImpl(prepareEdges, true);\n+    }\n+\n+    public PrepareGraphOrigEdgeExplorer createOutOrigEdgeExplorer() {\n+        checkReady();\n+        if (!edgeBased)\n+            throw new IllegalStateException(\"orig out explorer is not available for node-based graph\");\n+        return origGraph.createOutOrigEdgeExplorer();\n+    }\n+\n+    public PrepareGraphOrigEdgeExplorer createInOrigEdgeExplorer() {\n+        checkReady();\n+        if (!edgeBased)\n+            throw new IllegalStateException(\"orig in explorer is not available for node-based graph\");\n+        return origGraph.createInOrigEdgeExplorer();\n+    }\n+\n+    public double getTurnWeight(int inEdge, int viaNode, int outEdge) {\n+        return turnCostFunction.getTurnWeight(inEdge, viaNode, outEdge);\n+    }\n+\n+    public IntContainer disconnect(int node) {\n+        checkReady();\n+        // we use this neighbor set to guarantee a deterministic order of the returned\n+        // node ids\n+        neighborSet.clear();\n+        IntArrayList neighbors = new IntArrayList(getDegree(node));\n+        for (int i = 0; i < prepareEdges.size(node); i++) {\n+            PrepareEdge prepareEdge = prepareEdges.get(node, i);\n+            int adjNode = prepareEdge.getNodeB();\n+            if (adjNode == node)\n+                adjNode = prepareEdge.getNodeA();\n+            if (adjNode == node)\n+                // this is a loop\n+                continue;\n+            prepareEdges.remove(adjNode, prepareEdge);\n+            if (neighborSet.add(adjNode))\n+                neighbors.add(adjNode);\n+        }\n+        prepareEdges.clear(node);\n+        return neighbors;\n+    }\n+\n+    public void close() {\n+        checkReady();\n+        prepareEdges = null;\n+        neighborSet = null;\n+        if (edgeBased)\n+            origGraph = null;\n+    }\n+\n+    private void addOutEdge(int node, PrepareEdge prepareEdge) {\n+        prepareEdges.addPartTwo(node, prepareEdge);\n+    }\n+\n+    private void addInEdge(int node, PrepareEdge prepareEdge) {\n+        prepareEdges.addPartOne(node, prepareEdge);\n+    }\n+\n+    private void checkReady() {\n+        if (!ready)\n+            throw new IllegalStateException(\"You need to call prepareForContraction() before calling this method\");\n+    }\n+\n+    private void checkNotReady() {\n+        if (ready)\n+            throw new IllegalStateException(\"You cannot call this method after calling prepareForContraction()\");\n+    }\n+\n+    @FunctionalInterface\n+    public interface TurnCostFunction {\n+        double getTurnWeight(int inEdge, int viaNode, int outEdge);\n+    }\n+\n+    private static class PrepareGraphEdgeExplorerImpl implements PrepareGraphEdgeExplorer, PrepareGraphEdgeIterator {\n+        private final SplitArray2D<PrepareEdge> prepareEdges;\n+        private final boolean reverse;\n+        private int node = -1;\n+        private int end;\n+        private PrepareEdge currEdge;\n+        private int index;\n+\n+        PrepareGraphEdgeExplorerImpl(SplitArray2D<PrepareEdge> prepareEdges, boolean reverse) {\n+            this.prepareEdges = prepareEdges;\n+            this.reverse = reverse;\n+        }\n+\n+        @Override\n+        public PrepareGraphEdgeIterator setBaseNode(int node) {\n+            this.node = node;\n+            // we store the in edges in the first and the out edges in the second part of the prepareEdges\n+            this.index = reverse ? -1 : (prepareEdges.mid(node) - 1);\n+            this.end = reverse ? prepareEdges.mid(node) : prepareEdges.size(node);\n+            return this;\n+        }\n+\n+        @Override\n+        public boolean next() {\n+            index++;\n+            if (index == end) {\n+                currEdge = null;\n+                return false;\n+            }\n+            currEdge = prepareEdges.get(node, index);\n+            return true;\n+        }\n+\n+        @Override\n+        public int getBaseNode() {\n+            return node;\n+        }\n+\n+        @Override\n+        public int getAdjNode() {\n+            return nodeAisBase() ? currEdge.getNodeB() : currEdge.getNodeA();\n+        }\n+\n+        @Override\n+        public int getPrepareEdge() {\n+            return currEdge.getPrepareEdge();\n+        }\n+\n+        @Override\n+        public boolean isShortcut() {\n+            return currEdge.isShortcut();\n+        }\n+\n+        @Override\n+        public int getOrigEdgeKeyFirst() {\n+            return nodeAisBase() ? currEdge.getOrigEdgeKeyFirstAB() : currEdge.getOrigEdgeKeyFirstBA();\n+        }\n+\n+        @Override\n+        public int getOrigEdgeKeyLast() {\n+            return nodeAisBase() ? currEdge.getOrigEdgeKeyLastAB() : currEdge.getOrigEdgeKeyLastBA();\n+        }\n+\n+        @Override\n+        public int getSkipped1() {\n+            return currEdge.getSkipped1();\n+        }\n+\n+        @Override\n+        public int getSkipped2() {\n+            return currEdge.getSkipped2();\n+        }\n+\n+        @Override\n+        public double getWeight() {\n+            if (nodeAisBase()) {\n+                return reverse ? currEdge.getWeightBA() : currEdge.getWeightAB();\n+            } else {\n+                return reverse ? currEdge.getWeightAB() : currEdge.getWeightBA();\n+            }\n+        }\n+\n+        @Override\n+        public int getOrigEdgeCount() {\n+            return currEdge.getOrigEdgeCount();\n+        }\n+\n+        @Override\n+        public void setSkippedEdges(int skipped1, int skipped2) {\n+            currEdge.setSkipped1(skipped1);\n+            currEdge.setSkipped2(skipped2);\n+        }\n+\n+        @Override\n+        public void setWeight(double weight) {\n+            assert Double.isFinite(weight);\n+            currEdge.setWeight(weight);\n+        }\n+\n+        @Override\n+        public void setOrigEdgeCount(int origEdgeCount) {\n+            currEdge.setOrigEdgeCount(origEdgeCount);\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return currEdge == null ? \"not_started\" : getBaseNode() + \"-\" + getAdjNode();\n+        }\n+\n+        private boolean nodeAisBase() {\n+            // in some cases we need to determine which direction of the (bidirectional) edge we want\n+            return currEdge.getNodeA() == node;\n+        }\n+    }\n+\n+    interface PrepareEdge {\n+        boolean isShortcut();\n+\n+        int getPrepareEdge();\n+\n+        int getNodeA();\n+\n+        int getNodeB();\n+\n+        double getWeightAB();\n+\n+        double getWeightBA();\n+\n+        int getOrigEdgeKeyFirstAB();\n+\n+        int getOrigEdgeKeyFirstBA();\n+\n+        int getOrigEdgeKeyLastAB();\n+\n+        int getOrigEdgeKeyLastBA();\n+\n+        int getSkipped1();\n+\n+        int getSkipped2();\n+\n+        int getOrigEdgeCount();\n+\n+        void setSkipped1(int skipped1);\n+\n+        void setSkipped2(int skipped2);\n+\n+        void setWeight(double weight);\n+\n+        void setOrigEdgeCount(int origEdgeCount);\n+    }\n+\n+    public static class PrepareBaseEdge implements PrepareEdge {\n+        private final int prepareEdge;\n+        private final int nodeA;\n+        private final int nodeB;\n+        private final float weightAB;\n+        private final float weightBA;\n+\n+        public PrepareBaseEdge(int prepareEdge, int nodeA, int nodeB, float weightAB, float weightBA) {\n+            this.prepareEdge = prepareEdge;\n+            this.nodeA = nodeA;\n+            this.nodeB = nodeB;\n+            this.weightAB = weightAB;\n+            this.weightBA = weightBA;\n+        }\n+\n+        @Override\n+        public boolean isShortcut() {\n+            return false;\n+        }\n+\n+        @Override\n+        public int getPrepareEdge() {\n+            return prepareEdge;\n+        }\n+\n+        @Override\n+        public int getNodeA() {\n+            return nodeA;\n+        }\n+\n+        @Override\n+        public int getNodeB() {\n+            return nodeB;\n+        }\n+\n+        @Override\n+        public double getWeightAB() {\n+            return weightAB;\n+        }\n+\n+        @Override\n+        public double getWeightBA() {\n+            return weightBA;\n+        }\n+\n+        @Override\n+        public int getOrigEdgeKeyFirstAB() {\n+            int keyFwd = prepareEdge << 1;\n+            if (nodeA > nodeB)\n+                keyFwd += 1;\n+            return keyFwd;\n+        }\n+\n+        @Override\n+        public int getOrigEdgeKeyFirstBA() {\n+            int keyBwd = prepareEdge << 1;\n+            if (nodeB > nodeA)\n+                keyBwd += 1;\n+            return keyBwd;\n+        }\n+\n+        @Override\n+        public int getOrigEdgeKeyLastAB() {\n+            int keyFwd = prepareEdge << 1;\n+            if (nodeA > nodeB)\n+                keyFwd += 1;\n+            return keyFwd;\n+        }\n+\n+        @Override\n+        public int getOrigEdgeKeyLastBA() {\n+            int keyBwd = prepareEdge << 1;\n+            if (nodeB > nodeA)\n+                keyBwd += 1;\n+            return keyBwd;\n+        }\n+\n+        @Override\n+        public int getSkipped1() {\n+            throw new UnsupportedOperationException();\n+        }\n+\n+        @Override\n+        public int getSkipped2() {\n+            throw new UnsupportedOperationException();\n+        }\n+\n+        @Override\n+        public int getOrigEdgeCount() {\n+            return 1;\n+        }\n+\n+        @Override\n+        public void setSkipped1(int skipped1) {\n+            throw new UnsupportedOperationException();\n+        }\n+\n+        @Override\n+        public void setSkipped2(int skipped2) {\n+            throw new UnsupportedOperationException();\n+        }\n+\n+        @Override\n+        public void setWeight(double weight) {\n+            throw new UnsupportedOperationException();\n+        }\n+\n+        @Override\n+        public void setOrigEdgeCount(int origEdgeCount) {\n+            throw new UnsupportedOperationException();\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return nodeA + \"-\" + nodeB + \" (\" + prepareEdge + \") \" + weightAB + \" \" + weightBA;\n+        }\n+    }\n+\n+    private static class PrepareShortcut implements PrepareEdge {\n+        private final int prepareEdge;\n+        private final int from;\n+        private final int to;\n+        private double weight;\n+        private int skipped1;\n+        private int skipped2;\n+        private int origEdgeCount;\n+\n+        private PrepareShortcut(int prepareEdge, int from, int to, double weight, int skipped1, int skipped2, int origEdgeCount) {\n+            this.prepareEdge = prepareEdge;\n+            this.from = from;\n+            this.to = to;\n+            assert Double.isFinite(weight);\n+            this.weight = weight;\n+            this.skipped1 = skipped1;\n+            this.skipped2 = skipped2;\n+            this.origEdgeCount = origEdgeCount;\n+        }\n+\n+        @Override\n+        public boolean isShortcut() {\n+            return true;\n+        }\n+\n+        @Override\n+        public int getPrepareEdge() {\n+            return prepareEdge;\n+        }\n+\n+        @Override\n+        public int getNodeA() {\n+            return from;\n+        }\n+\n+        @Override\n+        public int getNodeB() {\n+            return to;\n+        }\n+\n+        @Override\n+        public double getWeightAB() {\n+            return weight;\n+        }\n+\n+        @Override\n+        public double getWeightBA() {\n+            return weight;\n+        }\n+\n+        @Override\n+        public int getOrigEdgeKeyFirstAB() {\n+            throw new IllegalStateException(\"Not supported for node-based shortcuts\");\n+        }\n+\n+        @Override\n+        public int getOrigEdgeKeyFirstBA() {\n+            throw new IllegalStateException(\"Not supported for node-based shortcuts\");\n+        }\n+\n+        @Override\n+        public int getOrigEdgeKeyLastAB() {\n+            throw new IllegalStateException(\"Not supported for node-based shortcuts\");\n+        }\n+\n+        @Override\n+        public int getOrigEdgeKeyLastBA() {\n+            throw new IllegalStateException(\"Not supported for node-based shortcuts\");\n+        }\n+\n+        @Override\n+        public int getSkipped1() {\n+            return skipped1;\n+        }\n+\n+        @Override\n+        public int getSkipped2() {\n+            return skipped2;\n+        }\n+\n+        @Override\n+        public int getOrigEdgeCount() {\n+            return origEdgeCount;\n+        }\n+\n+        @Override\n+        public void setSkipped1(int skipped1) {\n+            this.skipped1 = skipped1;\n+        }\n+\n+        @Override\n+        public void setSkipped2(int skipped2) {\n+            this.skipped2 = skipped2;\n+        }\n+\n+        @Override\n+        public void setWeight(double weight) {\n+            this.weight = weight;\n+        }\n+\n+        @Override\n+        public void setOrigEdgeCount(int origEdgeCount) {\n+            this.origEdgeCount = origEdgeCount;\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return from + \"-\" + to + \" \" + weight;\n+        }\n+    }\n+\n+    private static class EdgeBasedPrepareShortcut extends PrepareShortcut {\n+        // we use this subclass to save some memory for node-based where these are not needed\n+        private final int origEdgeKeyFirst;\n+        private final int origEdgeKeyLast;\n+\n+        public EdgeBasedPrepareShortcut(int prepareEdge, int from, int to, int origEdgeKeyFirst, int origEdgeKeyLast,\n+                                        double weight, int skipped1, int skipped2, int origEdgeCount) {\n+            super(prepareEdge, from, to, weight, skipped1, skipped2, origEdgeCount);\n+            this.origEdgeKeyFirst = origEdgeKeyFirst;\n+            this.origEdgeKeyLast = origEdgeKeyLast;\n+        }\n+\n+        @Override\n+        public int getOrigEdgeKeyFirstAB() {\n+            return origEdgeKeyFirst;\n+        }\n+\n+        @Override\n+        public int getOrigEdgeKeyFirstBA() {\n+            return origEdgeKeyFirst;\n+        }\n+\n+        @Override\n+        public int getOrigEdgeKeyLastAB() {\n+            return origEdgeKeyLast;\n+        }\n+\n+        @Override\n+        public int getOrigEdgeKeyLastBA() {\n+            return origEdgeKeyLast;\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return getNodeA() + \"-\" + getNodeB() + \" (\" + origEdgeKeyFirst + \", \" + origEdgeKeyLast + \") \" + getWeightAB();\n+        }\n+    }\n+\n+    private static class OrigGraph {\n+        private final IntArrayList firstEdgesByNode;\n+        private final IntArrayList adjNodes;\n+        private final IntArrayList edgesAndFlags;\n+\n+        private OrigGraph(IntArrayList firstEdgesByNode, IntArrayList adjNodes, IntArrayList edgesAndFlags) {\n+            this.firstEdgesByNode = firstEdgesByNode;\n+            this.adjNodes = adjNodes;\n+            this.edgesAndFlags = edgesAndFlags;\n+        }\n+\n+        PrepareGraphOrigEdgeExplorer createOutOrigEdgeExplorer() {\n+            return new OrigEdgeIteratorImpl(this, false);\n+        }\n+\n+        PrepareGraphOrigEdgeExplorer createInOrigEdgeExplorer() {\n+            return new OrigEdgeIteratorImpl(this, true);\n+        }\n+\n+        static class Builder {\n+            private final IntArrayList fromNodes = new IntArrayList();\n+            private final IntArrayList toNodes = new IntArrayList();\n+            private final IntArrayList edgesAndFlags = new IntArrayList();\n+            private int maxFrom = -1;\n+            private int maxTo = -1;\n+\n+            void addEdge(int from, int to, int edge, boolean fwd, boolean bwd) {\n+                fromNodes.add(from);\n+                toNodes.add(to);\n+                edgesAndFlags.add(getEdgeWithFlags(edge, fwd, bwd));\n+                maxFrom = Math.max(maxFrom, from);\n+                maxTo = Math.max(maxTo, to);\n+\n+                fromNodes.add(to);\n+                toNodes.add(from);\n+                edgesAndFlags.add(getEdgeWithFlags(edge, bwd, fwd));\n+                maxFrom = Math.max(maxFrom, to);\n+                maxTo = Math.max(maxTo, from);\n+            }\n+\n+            OrigGraph build() {\n+                int[] sortOrder = IndirectSort.mergesort(0, fromNodes.elementsCount, new IndirectComparator.AscendingIntComparator(fromNodes.buffer));\n+                sortAndTrim(fromNodes, sortOrder);\n+                sortAndTrim(toNodes, sortOrder);\n+                sortAndTrim(edgesAndFlags, sortOrder);\n+                return new OrigGraph(buildFirstEdgesByNode(), toNodes, edgesAndFlags);\n+            }\n+\n+            private int getEdgeWithFlags(int edge, boolean fwd, boolean bwd) {\n+                // we use only 30 bits for the edge Id and store two access flags along with the same int", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "47e9077efff7ffe7d38e5eee6806762a934bf490"}, "originalPosition": 757}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5a5cdd5fa36a0318db15afe18d714db4ead5ffca", "author": {"user": {"login": "easbar", "name": "Andi"}}, "url": "https://github.com/graphhopper/graphhopper/commit/5a5cdd5fa36a0318db15afe18d714db4ead5ffca", "committedDate": "2020-09-16T16:37:24Z", "message": "Minor cleanup and docs"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a49d48944ad0825397c053c3bc77993b5f30b377", "author": {"user": {"login": "easbar", "name": "Andi"}}, "url": "https://github.com/graphhopper/graphhopper/commit/a49d48944ad0825397c053c3bc77993b5f30b377", "committedDate": "2020-09-16T16:46:26Z", "message": "Update comment"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0edb0d8ae5f6c23e6774239ff47a9f5000a3a78d", "author": {"user": {"login": "easbar", "name": "Andi"}}, "url": "https://github.com/graphhopper/graphhopper/commit/0edb0d8ae5f6c23e6774239ff47a9f5000a3a78d", "committedDate": "2020-09-16T17:01:06Z", "message": "Comment about u-turn costs"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "453d09896e7e81c64ce4078668ba4afe70611747", "author": {"user": {"login": "easbar", "name": "Andi"}}, "url": "https://github.com/graphhopper/graphhopper/commit/453d09896e7e81c64ce4078668ba4afe70611747", "committedDate": "2020-09-16T17:12:35Z", "message": "Remove todos"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "31bd5ca6fcabd5fff02771dd530143f5fcced4be", "author": {"user": {"login": "easbar", "name": "Andi"}}, "url": "https://github.com/graphhopper/graphhopper/commit/31bd5ca6fcabd5fff02771dd530143f5fcced4be", "committedDate": "2020-09-16T17:13:24Z", "message": "Enable check for equal weight witness path again"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4990f7324a69a12d59baab41e66a40147983b0ad", "author": {"user": {"login": "easbar", "name": "Andi"}}, "url": "https://github.com/graphhopper/graphhopper/commit/4990f7324a69a12d59baab41e66a40147983b0ad", "committedDate": "2020-09-16T17:19:41Z", "message": "Remove outdated comment"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDg5ODM1NDI2", "url": "https://github.com/graphhopper/graphhopper/pull/2132#pullrequestreview-489835426", "createdAt": "2020-09-16T17:16:29Z", "commit": {"oid": "453d09896e7e81c64ce4078668ba4afe70611747"}, "state": "COMMENTED", "comments": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNlQxNzoxNjozMFrOHS6opQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNlQxNzozMjo1OFrOHS7NNQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTU5NzA5Mw==", "bodyText": "Thes orig edge counts are now included in the prepare graph's edges", "url": "https://github.com/graphhopper/graphhopper/pull/2132#discussion_r489597093", "createdAt": "2020-09-16T17:16:30Z", "author": {"login": "easbar"}, "path": "core/src/main/java/com/graphhopper/routing/ch/AbstractNodeContractor.java", "diffHunk": "@@ -1,81 +0,0 @@\n-/*\n- *  Licensed to GraphHopper GmbH under one or more contributor\n- *  license agreements. See the NOTICE file distributed with this work for\n- *  additional information regarding copyright ownership.\n- *\n- *  GraphHopper GmbH licenses this file to you under the Apache License,\n- *  Version 2.0 (the \"License\"); you may not use this file except in\n- *  compliance with the License. You may obtain a copy of the License at\n- *\n- *       http://www.apache.org/licenses/LICENSE-2.0\n- *\n- *  Unless required by applicable law or agreed to in writing, software\n- *  distributed under the License is distributed on an \"AS IS\" BASIS,\n- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- *  See the License for the specific language governing permissions and\n- *  limitations under the License.\n- */\n-\n-package com.graphhopper.routing.ch;\n-\n-import com.graphhopper.storage.DAType;\n-import com.graphhopper.storage.DataAccess;\n-import com.graphhopper.storage.GHDirectory;\n-\n-abstract class AbstractNodeContractor implements NodeContractor {\n-    final PrepareCHGraph prepareGraph;\n-    PrepareCHEdgeExplorer inEdgeExplorer;\n-    PrepareCHEdgeExplorer outEdgeExplorer;\n-    private final DataAccess originalEdges;\n-    int maxLevel;\n-    private int maxEdgesCount;\n-\n-    public AbstractNodeContractor(PrepareCHGraph prepareGraph) {\n-        this.prepareGraph = prepareGraph;\n-        originalEdges = new GHDirectory(\"\", DAType.RAM_INT).find(\"\");\n-        originalEdges.create(1000);\n-    }\n-\n-    @Override\n-    public void initFromGraph() {\n-        inEdgeExplorer = prepareGraph.createInEdgeExplorer();\n-        outEdgeExplorer = prepareGraph.createOutEdgeExplorer();\n-        maxLevel = prepareGraph.getNodes();\n-        maxEdgesCount = prepareGraph.getOriginalEdges();\n-    }\n-\n-    @Override\n-    public void close() {\n-        originalEdges.close();\n-    }\n-\n-    boolean isContracted(int node) {\n-        return prepareGraph.getLevel(node) != maxLevel;\n-    }\n-\n-    void setOrigEdgeCount(int edgeId, int value) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "453d09896e7e81c64ce4078668ba4afe70611747"}, "originalPosition": 56}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTU5NzM1OQ==", "bodyText": "I removed this heuristic for now, might be worth to re-implement it later, but not sure really", "url": "https://github.com/graphhopper/graphhopper/pull/2132#discussion_r489597359", "createdAt": "2020-09-16T17:16:58Z", "author": {"login": "easbar"}, "path": "core/src/main/java/com/graphhopper/routing/ch/CHParameters.java", "diffHunk": "@@ -12,7 +12,6 @@\n     // node contraction, node-based\n     public static final String EDGE_DIFFERENCE_WEIGHT = Parameters.CH.PREPARE + \"node.edge_difference_weight\";\n     public static final String ORIGINAL_EDGE_COUNT_WEIGHT = Parameters.CH.PREPARE + \"node.original_edge_count_weight\";\n-    public static final String CONTRACTED_NEIGHBORS_WEIGHT = Parameters.CH.PREPARE + \"node.contracted_neighbors_weight\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "453d09896e7e81c64ce4078668ba4afe70611747"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTYwMTE1MA==", "bodyText": "Here we got rid of one of the int[] arrays, i.e. 4byte*N where N=2*number of base graph edges. We no longer need to store the incEdges, because we use the edge keys directly now and the index position equals the edge key for each element.", "url": "https://github.com/graphhopper/graphhopper/pull/2132#discussion_r489601150", "createdAt": "2020-09-16T17:23:31Z", "author": {"login": "easbar"}, "path": "core/src/main/java/com/graphhopper/routing/ch/EdgeBasedWitnessPathSearcher.java", "diffHunk": "@@ -87,12 +85,11 @@\n     // data structures used to build the shortest path tree\n     // we allocate memory for all possible edge keys and keep track which ones have been discovered so far\n     private double[] weights;\n-    private int[] edges;\n-    private int[] incEdges;\n+    private int[] prepareEdges;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "453d09896e7e81c64ce4078668ba4afe70611747"}, "originalPosition": 30}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTYwMzk0NA==", "bodyText": "No need for these two arrays as we never need to find the actual shortest path (we just need to check its existence). This saved 2*4byte*N where N=number of nodes of the graph", "url": "https://github.com/graphhopper/graphhopper/pull/2132#discussion_r489603944", "createdAt": "2020-09-16T17:28:29Z", "author": {"login": "easbar"}, "path": "core/src/main/java/com/graphhopper/routing/ch/NodeBasedWitnessPathSearcher.java", "diffHunk": "@@ -30,41 +29,25 @@\n  * i.e. its a Dijkstra search that allows re-using the shortest path tree for different searches with the same origin\n  * node and uses large int/double arrays instead of hash maps to store the shortest path tree (higher memory consumption,\n  * but faster query times -> better for CH preparation). Main reason we use this instead of {@link DijkstraOneToMany}\n- * is that we can use this implementation with a {@link PrepareCHGraph}.\n+ * is that we can use this implementation with a {@link CHPreparationGraph} and we are only interested in checking for\n+ * witness paths (e.g. we do not need to find the actual path).\n  */\n public class NodeBasedWitnessPathSearcher {\n-    private static final int EMPTY_PARENT = -1;\n     private static final int NOT_FOUND = -1;\n-    private final PrepareCHGraph graph;\n-    private final PrepareCHEdgeExplorer outEdgeExplorer;\n+    private PrepareGraphEdgeExplorer outEdgeExplorer;\n     private final IntArrayList changedNodes;\n-    private final int maxLevel;\n     private int maxVisitedNodes = Integer.MAX_VALUE;\n     protected double[] weights;\n-    private int[] parents;\n-    private int[] edgeIds;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "453d09896e7e81c64ce4078668ba4afe70611747"}, "originalPosition": 27}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTYwNDk3MA==", "bodyText": "Here we were allocating quite a bit of memory even when re-starting the server and just loading the preparations (no new preparation). We should really make PrepareContractionHierarchies about preparing CH and not use it as a 'handle' to the preparations available on the server...", "url": "https://github.com/graphhopper/graphhopper/pull/2132#discussion_r489604970", "createdAt": "2020-09-16T17:30:16Z", "author": {"login": "easbar"}, "path": "core/src/main/java/com/graphhopper/routing/ch/PrepareContractionHierarchies.java", "diffHunk": "@@ -77,22 +76,18 @@ public static PrepareContractionHierarchies fromGraphHopperStorage(GraphHopperSt\n     }\n \n     private PrepareContractionHierarchies(GraphHopperStorage ghStorage, CHConfig chConfig) {\n+        graph = ghStorage;\n         chGraph = ghStorage.getCHGraph(chConfig.getName());\n         if (chGraph == null)\n             throw new IllegalArgumentException(\"There is no CH graph '\" + chConfig.getName() + \"', existing: \" + ghStorage.getCHGraphNames());\n         this.chConfig = chConfig;\n         params = Params.forTraversalMode(chConfig.getTraversalMode());\n-        updatedNeighbors = new IntHashSet(50);\n+        nodes = chGraph.getNodes();\n         if (chConfig.getTraversalMode().isEdgeBased()) {\n             TurnCostStorage turnCostStorage = chGraph.getBaseGraph().getTurnCostStorage();\n             if (turnCostStorage == null) {\n                 throw new IllegalArgumentException(\"For edge-based CH you need a turn cost storage\");\n             }\n-            prepareGraph = PrepareCHGraph.edgeBased(chGraph, chConfig.getWeighting());\n-            nodeContractor = new EdgeBasedNodeContractor(prepareGraph, pMap);\n-        } else {\n-            prepareGraph = PrepareCHGraph.nodeBased(chGraph, chConfig.getWeighting());\n-            nodeContractor = new NodeBasedNodeContractor(prepareGraph, pMap);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "453d09896e7e81c64ce4078668ba4afe70611747"}, "originalPosition": 63}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTYwNTcyNg==", "bodyText": "This is no longer needed because after we wrote a shortcut to CHGraph we never change it again", "url": "https://github.com/graphhopper/graphhopper/pull/2132#discussion_r489605726", "createdAt": "2020-09-16T17:31:39Z", "author": {"login": "easbar"}, "path": "core/src/main/java/com/graphhopper/routing/ch/PrepareEncoder.java", "diffHunk": "@@ -32,46 +32,21 @@\n     /**\n      * A bitmask for two directions\n      */\n-    public static final int getScDirMask() {\n+    public static int getScDirMask() {\n         return scDirMask;\n     }\n \n     /**\n      * The bit for forward direction\n      */\n-    public static final int getScFwdDir() {\n+    public static int getScFwdDir() {\n         return scFwdDir;\n     }\n \n     /**\n      * The bit for backward direction\n      */\n-    public static final int getScBwdDir() {\n+    public static int getScBwdDir() {\n         return scBwdDir;\n     }\n-\n-    /**\n-     * Returns 1 if existingScFlags of an existing shortcut can be overwritten with a new shortcut by\n-     * newScFlags without limiting or changing the directions of the existing shortcut.\n-     * The method returns 2 for the same condition but only if the new shortcut has to be added\n-     * even if weight is higher than existing shortcut weight.\n-     * <pre>\n-     *                 | newScFlags:\n-     * existingScFlags | -> | <- | <->\n-     * ->              |  1 | 0  | 2\n-     * <-              |  0 | 1  | 2\n-     * <->             |  0 | 0  | 1\n-     * </pre>\n-     *\n-     * @return 1 if newScFlags is identical to existingScFlags for the two direction bits and 0 otherwise.\n-     * There are two special cases when it returns 2.\n-     */\n-    public static final int getScMergeStatus(int existingScFlags, int newScFlags) {\n-        if ((existingScFlags & scDirMask) == (newScFlags & scDirMask))\n-            return 1;\n-        else if ((newScFlags & scDirMask) == scDirMask)\n-            return 2;\n-\n-        return 0;\n-    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "453d09896e7e81c64ce4078668ba4afe70611747"}, "originalPosition": 48}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTYwNjQ1Mw==", "bodyText": "Any idea for a better name? I am trying to say this is an array of arrays (2D) where each of the inner arrays is split into two parts (the elements of the two parts are separated from each other). But maybe not so important as this is only a package private class used by CHPreparationGraph...", "url": "https://github.com/graphhopper/graphhopper/pull/2132#discussion_r489606453", "createdAt": "2020-09-16T17:32:58Z", "author": {"login": "easbar"}, "path": "core/src/main/java/com/graphhopper/routing/ch/SplitArray2D.java", "diffHunk": "@@ -0,0 +1,124 @@\n+/*\n+ *  Licensed to GraphHopper GmbH under one or more contributor\n+ *  license agreements. See the NOTICE file distributed with this work for\n+ *  additional information regarding copyright ownership.\n+ *\n+ *  GraphHopper GmbH licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except in\n+ *  compliance with the License. You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+\n+package com.graphhopper.routing.ch;\n+\n+import java.util.Arrays;\n+\n+/**\n+ * This is a more memory-efficient version of two equal length `ArrayList<T>[]`s, i.e. this is a fixed size array where\n+ * each element is a variable sized sub-array and each sub-array is divided into two parts.\n+ * This is more memory efficient than two arrays of `ArrayList`s, because it saves the object-overhead of using an\n+ * ArrayList object for each sub-array.\n+ * <p>\n+ * The elements in each sub-array are divided into two parts with ranges [0,mid[ and [mid,size[. We can add elements\n+ * to either of the two parts.\n+ */\n+class SplitArray2D<T> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "453d09896e7e81c64ce4078668ba4afe70611747"}, "originalPosition": 32}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8a9c5599d8fad5e67e995c5295ad0600d6a28842", "author": {"user": {"login": "easbar", "name": "Andi"}}, "url": "https://github.com/graphhopper/graphhopper/commit/8a9c5599d8fad5e67e995c5295ad0600d6a28842", "committedDate": "2020-09-16T19:41:21Z", "message": "Loop shortcuts only as out edges"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "dbcf9eec0b107925891e7f8e1c43cef48a33405b", "author": {"user": {"login": "easbar", "name": "Andi"}}, "url": "https://github.com/graphhopper/graphhopper/commit/dbcf9eec0b107925891e7f8e1c43cef48a33405b", "committedDate": "2020-09-17T17:26:48Z", "message": "Combine adjNode and isPathToCenters arrays -> reduce memory usage for edge-based CH"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6c3f2399bbf6cba7bb540be470ababdc76c0f090", "author": {"user": {"login": "easbar", "name": "Andi"}}, "url": "https://github.com/graphhopper/graphhopper/commit/6c3f2399bbf6cba7bb540be470ababdc76c0f090", "committedDate": "2020-09-21T07:18:57Z", "message": "Update comment"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4cfa7fc9d1ddf18cb6e3f0974169a3c2c8d555c2", "author": {"user": {"login": "michaz", "name": "Michael Zilske"}}, "url": "https://github.com/graphhopper/graphhopper/commit/4cfa7fc9d1ddf18cb6e3f0974169a3c2c8d555c2", "committedDate": "2020-09-21T07:19:41Z", "message": "Remove unused and suspicious GTFS route type constants\n\n(cherry picked from commit d48a941d60f028f7c5f8f4bf530abab169e988f8)"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "243e63765bd1c6a6f72bf0c1ad59a4c5aa349fff", "author": {"user": {"login": "michaz", "name": "Michael Zilske"}}, "url": "https://github.com/graphhopper/graphhopper/commit/243e63765bd1c6a6f72bf0c1ad59a4c5aa349fff", "committedDate": "2020-09-21T07:19:44Z", "message": "Public datatype is public\n\n(cherry picked from commit c0aaffae8631efb8fa23c6ab5cf26e27027efd08)"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8cffac27daad830ca8785099c0ba8d6b34dc9799", "author": {"user": {"login": "michaz", "name": "Michael Zilske"}}, "url": "https://github.com/graphhopper/graphhopper/commit/8cffac27daad830ca8785099c0ba8d6b34dc9799", "committedDate": "2020-09-21T07:19:47Z", "message": "Define how many decimal places isochrone coordinates have\n\n(cherry picked from commit 0e9461e6de94d491f2118fca20ca903f631e7288)"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1a92096a1dcabb6c0e126fb42e9b1210e6cb7bed", "author": {"user": {"login": "easbar", "name": "Andi"}}, "url": "https://github.com/graphhopper/graphhopper/commit/1a92096a1dcabb6c0e126fb42e9b1210e6cb7bed", "committedDate": "2020-09-21T07:43:02Z", "message": "Merge branch 'master' into faster_ch_prep"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1c2ca0f9c421ff36b645c31fc2d66852717911cd", "author": {"user": {"login": "easbar", "name": "Andi"}}, "url": "https://github.com/graphhopper/graphhopper/commit/1c2ca0f9c421ff36b645c31fc2d66852717911cd", "committedDate": "2020-09-21T15:33:33Z", "message": "Trim split 2d array"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c0198a6c09b3d447506ce49d8cce2b52b2fdc07d", "author": {"user": {"login": "easbar", "name": "Andi"}}, "url": "https://github.com/graphhopper/graphhopper/commit/c0198a6c09b3d447506ce49d8cce2b52b2fdc07d", "committedDate": "2020-09-21T15:36:34Z", "message": "Extract method to grow 2d array"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDkzMjA3ODMz", "url": "https://github.com/graphhopper/graphhopper/pull/2132#pullrequestreview-493207833", "createdAt": "2020-09-22T07:56:07Z", "commit": {"oid": "c0198a6c09b3d447506ce49d8cce2b52b2fdc07d"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMlQwNzo1NjowN1rOHVuRRg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMlQwNzo1NjowN1rOHVuRRg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjU0MDIzMA==", "bodyText": "How large are these sub-arrays on average? Could it make sense to initialize them with the average+20% then they do not need to grow that often and the size mismatch could be lower?", "url": "https://github.com/graphhopper/graphhopper/pull/2132#discussion_r492540230", "createdAt": "2020-09-22T07:56:07Z", "author": {"login": "karussell"}, "path": "core/src/main/java/com/graphhopper/routing/ch/SplitArray2D.java", "diffHunk": "@@ -122,4 +122,17 @@ void clear(int n) {\n         mids[n] = 0;\n     }\n \n+    private void grow(int n) {\n+        // todo: think about grow factor: trimming and then doubling the size might be not what we want, rather\n+        // increase by 50% or something?", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c0198a6c09b3d447506ce49d8cce2b52b2fdc07d"}, "originalPosition": 24}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5a60be242885bda4064e9f5261985a9ff24057b7", "author": {"user": {"login": "easbar", "name": "Andi"}}, "url": "https://github.com/graphhopper/graphhopper/commit/5a60be242885bda4064e9f5261985a9ff24057b7", "committedDate": "2020-09-22T11:53:28Z", "message": "Update changelog"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4481, "cost": 1, "resetAt": "2021-11-01T14:51:55Z"}}}