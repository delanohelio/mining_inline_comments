{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzY0MTQzOTUx", "number": 1853, "title": "Replace our polygon code with the JTS implementation", "bodyText": "I would like to have this before #1838.\nThis PR does the following:\n\navoids our custom Polygon code and uses the JTS implementation which should make the implementation more robust and make it working for more generic polygons like with inner rings\nit additionally improves the precision of the block_area feature through a new Shape.intersects(PointList) method. Now not just a single point of an edge is checked for intersection but the whole point list. Still there is more work (later) #1324.\nI discovered PackedCoordinateSequence that allows us to be memory efficient with JTS too\nI've introduced QuerySettings. Not sure if this should be done here, but the parameters for the printTimeOfRouteQuery method got more and more confusing. E.g. recent changes like f69f127#diff-cd749cc545f8b84137c2b75b2d174b72 are much easier to understand.", "createdAt": "2020-01-17T13:34:01Z", "url": "https://github.com/graphhopper/graphhopper/pull/1853", "merged": true, "mergeCommit": {"oid": "7f0a357b99c9d85c69f59f1ee0cb69c9f46a88fb"}, "closed": true, "closedAt": "2020-01-28T11:52:20Z", "author": {"login": "karussell"}, "timelineItems": {"totalCount": 16, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABb6PmkBAH2gAyMzY0MTQzOTUxOjA0NzhkYzI2OGIzNDQxNDFiOGZkOWFjZGMxNDE3OGZjMjQzNTEwMTU=", "endCursor": "Y3Vyc29yOnYyOpPPAAABb-vtZ9AH2gAyMzY0MTQzOTUxOmYyOTE2NTQ2Nzg3MGFhNTY1NTAwMjdjMjU4Y2NmNTk1N2NmNzhiZWE=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "0478dc268b344141b8fd9acdc14178fc24351015", "author": {"user": {"login": "karussell", "name": "Peter"}}, "url": "https://github.com/graphhopper/graphhopper/commit/0478dc268b344141b8fd9acdc14178fc24351015", "committedDate": "2020-01-14T11:53:14Z", "message": "add block area to measurement"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "33b693d3ab4d35bef0d0f91b3815aa82391f5206", "author": {"user": {"login": "karussell", "name": "Peter"}}, "url": "https://github.com/graphhopper/graphhopper/commit/33b693d3ab4d35bef0d0f91b3815aa82391f5206", "committedDate": "2020-01-14T11:55:02Z", "message": "allow caching LineString when converting from PointList"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d6beef0643bdde852ed8755c99b1eaedd3d06b12", "author": {"user": {"login": "karussell", "name": "Peter"}}, "url": "https://github.com/graphhopper/graphhopper/commit/d6beef0643bdde852ed8755c99b1eaedd3d06b12", "committedDate": "2020-01-14T14:09:49Z", "message": "replaced custom Polygon implementation with JTS"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f405d77065e564d45595cde0dbd89055320a5d7a", "author": {"user": {"login": "karussell", "name": "Peter"}}, "url": "https://github.com/graphhopper/graphhopper/commit/f405d77065e564d45595cde0dbd89055320a5d7a", "committedDate": "2020-01-14T21:13:49Z", "message": "measurement: use block_area in bayern/bavaria (block_area for small map) and add to LM (block_area for big map)"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0b02a5df04c1e6dc33a82e4547c5a0805f3141da", "author": {"user": {"login": "karussell", "name": "Peter"}}, "url": "https://github.com/graphhopper/graphhopper/commit/0b02a5df04c1e6dc33a82e4547c5a0805f3141da", "committedDate": "2020-01-14T23:34:40Z", "message": "fixing int. tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7a730cfcd163346c59520aed8afbc59ead35696a", "author": {"user": {"login": "karussell", "name": "Peter"}}, "url": "https://github.com/graphhopper/graphhopper/commit/7a730cfcd163346c59520aed8afbc59ead35696a", "committedDate": "2020-01-16T22:06:14Z", "message": "much better precision without big slow down"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f69f127434e2bc18a273284d4c9b8985de88353c", "author": {"user": {"login": "karussell", "name": "Peter"}}, "url": "https://github.com/graphhopper/graphhopper/commit/f69f127434e2bc18a273284d4c9b8985de88353c", "committedDate": "2020-01-17T13:44:55Z", "message": "merged master"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ0NjA2NDA1", "url": "https://github.com/graphhopper/graphhopper/pull/1853#pullrequestreview-344606405", "createdAt": "2020-01-17T14:18:37Z", "commit": {"oid": "7a730cfcd163346c59520aed8afbc59ead35696a"}, "state": "COMMENTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xN1QxNDoxODozN1rOFe6UOw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xN1QxNDoyOTowM1rOFe6o5g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzk1NzA1MQ==", "bodyText": "Wouldn't it be better to create a factory for 2D and 3D each and keep them?", "url": "https://github.com/graphhopper/graphhopper/pull/1853#discussion_r367957051", "createdAt": "2020-01-17T14:18:37Z", "author": {"login": "otbutz"}, "path": "api/src/main/java/com/graphhopper/util/PointList.java", "diffHunk": "@@ -399,7 +404,10 @@ public static PointList fromLineString(LineString lineString) {\n     }\n \n     public LineString toLineString(boolean includeElevation) {\n-        GeometryFactory gf = new GeometryFactory();\n+        return toLineString(new GeometryFactory(), includeElevation);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7a730cfcd163346c59520aed8afbc59ead35696a"}, "originalPosition": 29}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzk2MTYwNQ==", "bodyText": "We could check the envelope first.", "url": "https://github.com/graphhopper/graphhopper/pull/1853#discussion_r367961605", "createdAt": "2020-01-17T14:27:33Z", "author": {"login": "otbutz"}, "path": "api/src/main/java/com/graphhopper/util/shapes/Polygon.java", "diffHunk": "@@ -17,117 +17,72 @@\n  */\n package com.graphhopper.util.shapes;\n \n+import com.graphhopper.util.PointList;\n+import org.locationtech.jts.geom.Coordinate;\n+import org.locationtech.jts.geom.Envelope;\n+import org.locationtech.jts.geom.GeometryFactory;\n+import org.locationtech.jts.geom.Point;\n+import org.locationtech.jts.geom.impl.PackedCoordinateSequence;\n+import org.locationtech.jts.geom.prep.PreparedGeometry;\n+import org.locationtech.jts.geom.prep.PreparedPolygon;\n+\n+import java.util.Arrays;\n+\n /**\n  * This class represents a polygon that is defined by a set of points.\n  * Every point i is connected to point i-1 and i+1.\n- * <p>\n- * TODO: Howto design inner rings in the polygon?\n  *\n  * @author Robin Boldt\n  */\n public class Polygon implements Shape {\n \n-    private final double[] lat;\n-    private final double[] lon;\n+    private final GeometryFactory factory = new GeometryFactory();\n+    private final PreparedGeometry polygon;\n+    private final Envelope envelope;\n \n-    private double minLat;\n-    private double minLon;\n-    private double maxLat;\n-    private double maxLon;\n+    public Polygon(PreparedGeometry polygon) {\n+        this.polygon = polygon;\n+        this.envelope = polygon.getGeometry().getEnvelopeInternal();\n+    }\n \n-    private final double epsilon;\n+    public Polygon(double[] lats, double[] lons) {\n+        if (lats.length != lons.length)\n+            throw new IllegalArgumentException(\"Points must be of equal length but was \" + lats.length + \" vs. \" + lons.length);\n \n-    public Polygon(double[] lat, double[] lon, double growFactor) {\n-        if (lat.length != lon.length) {\n-            throw new IllegalArgumentException(\"Points must be of equal length but was \" + lat.length + \" vs. \" + lon.length);\n-        }\n-        if (lat.length == 0) {\n+        if (lats.length == 0)\n             throw new IllegalArgumentException(\"Points must not be empty\");\n-        }\n-        this.lat = lat;\n-        this.lon = lon;\n-\n-        for (int i = 0; i < lat.length; i++) {\n-            if (i == 0) {\n-                minLat = lat[i];\n-                maxLat = lat[i];\n-                minLon = lon[i];\n-                maxLon = lon[i];\n-            } else {\n-                if (lat[i] < minLat) {\n-                    minLat = lat[i];\n-                } else if (lat[i] > maxLat) {\n-                    maxLat = lat[i];\n-                }\n-                if (lon[i] < minLon) {\n-                    minLon = lon[i];\n-                } else if (lon[i] > maxLon) {\n-                    maxLon = lon[i];\n-                }\n-            }\n-        }\n \n-        minLat -= growFactor;\n-        minLon -= growFactor;\n-        maxLat += growFactor;\n-        maxLon += growFactor;\n-\n-        epsilon = (maxLat - minLat) / 10;\n-    }\n-\n-    public Polygon(double[] lat, double[] lon) {\n-        this(lat, lon, 0);\n-    }\n-\n-    /**\n-     * Lossy conversion to a GraphHopper Polygon.\n-     */\n-    public static Polygon create(org.locationtech.jts.geom.Polygon polygon) {\n-        double[] lats = new double[polygon.getNumPoints()];\n-        double[] lons = new double[polygon.getNumPoints()];\n-        for (int i = 0; i < polygon.getNumPoints(); i++) {\n-            lats[i] = polygon.getCoordinates()[i].y;\n-            lons[i] = polygon.getCoordinates()[i].x;\n+        Coordinate[] coordinates = new Coordinate[lats.length + 1];\n+        for (int i = 0; i < lats.length; i++) {\n+            coordinates[i] = new Coordinate(lons[i], lats[i]);\n         }\n-        return new Polygon(lats, lons);\n+        coordinates[lats.length] = coordinates[0];\n+        this.polygon = new PreparedPolygon(factory.createPolygon(new PackedCoordinateSequence.Double(coordinates, 2)));\n+        this.envelope = polygon.getGeometry().getEnvelopeInternal();\n     }\n \n-    /**\n-     * Wrapper method for {@link Polygon#contains(double, double)}.\n-     */\n-    public boolean contains(GHPoint point) {\n-        return contains(point.lat, point.lon);\n+    public static Polygon create(org.locationtech.jts.geom.Polygon polygon) {\n+        return new Polygon(new PreparedPolygon(polygon));\n     }\n \n     @Override\n     public boolean intersects(Shape o) {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n+        throw new IllegalArgumentException(\"Polygon.intersects: shape not supported\");\n+    }\n+\n+    public boolean intersects(PointList pointList) {\n+        return polygon.intersects(pointList.getCachedLineString(factory, false));\n     }\n \n     /**\n-     * Implements the ray casting algorithm\n-     * Code is inspired from here: http://stackoverflow.com/a/218081/1548788\n+     * Does the point in polygon check.\n      *\n      * @param lat Latitude of the point to be checked\n      * @param lon Longitude of the point to be checked\n      * @return true if point is inside polygon\n      */\n     public boolean contains(double lat, double lon) {\n-        if (lat < minLat || lat > maxLat || lon < minLon || lon > maxLon) {\n-            return false;\n-        }\n-\n-        double rayStartLat = maxLat - (minLat / 2);\n-        double rayStartLon = minLon - epsilon;\n-\n-        boolean inside = false;\n-        int len = this.lat.length;\n-        for (int i = 0; i < len; i++) {\n-            if (edgesAreIntersecting(rayStartLon, rayStartLat, lon, lat, this.lon[i], this.lat[i], this.lon[(i + 1) % len], this.lat[(i + 1) % len]))\n-                inside = !inside;\n-        }\n-        return inside;\n-\n+        return polygon.contains(factory.createPoint(new Coordinate(lon, lat)));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7a730cfcd163346c59520aed8afbc59ead35696a"}, "originalPosition": 151}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzk2MjM0Mg==", "bodyText": "The number of holes would probably be interesting, too", "url": "https://github.com/graphhopper/graphhopper/pull/1853#discussion_r367962342", "createdAt": "2020-01-17T14:29:03Z", "author": {"login": "otbutz"}, "path": "api/src/main/java/com/graphhopper/util/shapes/Polygon.java", "diffHunk": "@@ -137,115 +92,55 @@ public boolean contains(Shape s) {\n \n     @Override\n     public BBox getBounds() {\n-        return new BBox(minLon, maxLon, minLat, maxLat);\n+        return new BBox(envelope.getMinX(), envelope.getMaxX(), envelope.getMinY(), envelope.getMaxY());\n     }\n \n     @Override\n     public GHPoint getCenter() {\n-        return new GHPoint((maxLat + minLat) / 2, (maxLon + minLon) / 2);\n+        Point centroid = polygon.getGeometry().getCentroid();\n+        return new GHPoint(centroid.getY(), centroid.getX());\n     }\n \n     @Override\n     public double calculateArea() {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    private boolean edgesAreIntersecting(\n-            double v1x1, double v1y1, double v1x2, double v1y2,\n-            double v2x1, double v2y1, double v2x2, double v2y2\n-    ) {\n-\n-\n-        double d1, d2;\n-        double a1, a2, b1, b2, c1, c2;\n-\n-        // Convert vector 1 to a line (line 1) of infinite length.\n-        // We want the line in linear equation standard form: A*x + B*y + C = 0\n-        // See: http://en.wikipedia.org/wiki/Linear_equation\n-        a1 = v1y2 - v1y1;\n-        b1 = v1x1 - v1x2;\n-        c1 = (v1x2 * v1y1) - (v1x1 * v1y2);\n-\n-        // Every point (x,y), that solves the equation above, is on the line,\n-        // every point that does not solve it, is not. The equation will have a\n-        // positive result if it is on one side of the line and a negative one\n-        // if is on the other side of it. We insert (x1,y1) and (x2,y2) of vector\n-        // 2 into the equation above.\n-        d1 = (a1 * v2x1) + (b1 * v2y1) + c1;\n-        d2 = (a1 * v2x2) + (b1 * v2y2) + c1;\n-\n-        // If d1 and d2 both have the same sign, they are both on the same side\n-        // of our line 1 and in that case no intersection is possible. Careful,\n-        // 0 is a special case, that's why we don't test \">=\" and \"<=\",\n-        // but \"<\" and \">\".\n-        if (d1 > 0 && d2 > 0) return false;\n-        if (d1 < 0 && d2 < 0) return false;\n-\n-        // The fact that vector 2 intersected the infinite line 1 above doesn't\n-        // mean it also intersects the vector 1. Vector 1 is only a subset of that\n-        // infinite line 1, so it may have intersected that line before the vector\n-        // started or after it ended. To know for sure, we have to repeat the\n-        // the same test the other way round. We start by calculating the\n-        // infinite line 2 in linear equation standard form.\n-        a2 = v2y2 - v2y1;\n-        b2 = v2x1 - v2x2;\n-        c2 = (v2x2 * v2y1) - (v2x1 * v2y2);\n-\n-        // Calculate d1 and d2 again, this time using points of vector 1.\n-        d1 = (a2 * v1x1) + (b2 * v1y1) + c2;\n-        d2 = (a2 * v1x2) + (b2 * v1y2) + c2;\n-\n-        // Again, if both have the same sign (and neither one is 0),\n-        // no intersection is possible.\n-        if (d1 > 0 && d2 > 0) return false;\n-        if (d1 < 0 && d2 < 0) return false;\n-\n-        // If we get here, only two possibilities are left. Either the two\n-        // vectors intersect in exactly one point or they are collinear, which\n-        // means they intersect in any number of points from zero to infinite.\n-        if ((a1 * b2) - (a2 * b1) == 0) return false;\n-\n-        // If they are not collinear, they must intersect in exactly one point.\n-        return true;\n+        // for estimation use bounding box as reference:\n+        return getBounds().calculateArea() * envelope.getArea() / polygon.getGeometry().getArea();\n     }\n \n     public double getMinLat() {\n-        return minLat;\n+        return envelope.getMinY();\n     }\n \n     public double getMinLon() {\n-        return minLon;\n+        return envelope.getMinX();\n     }\n \n     public double getMaxLat() {\n-        return maxLat;\n+        return envelope.getMaxY();\n     }\n \n     public double getMaxLon() {\n-        return maxLon;\n+        return envelope.getMaxX();\n     }\n \n     @Override\n     public String toString() {\n-        return \"polygon (\" + lat.length + \" points)\";\n+        return \"polygon (\" + polygon.getGeometry().getNumPoints() + \" points)\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7a730cfcd163346c59520aed8afbc59ead35696a"}, "originalPosition": 259}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "314fe5c0728d4cc18cf0970a9a140bd5cbd5b2ef", "author": {"user": {"login": "karussell", "name": "Peter"}}, "url": "https://github.com/graphhopper/graphhopper/commit/314fe5c0728d4cc18cf0970a9a140bd5cbd5b2ef", "committedDate": "2020-01-17T21:51:44Z", "message": "avoid factory creation"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "dc1f44d155667a712076050f94b1b90e6a9a49fe", "author": {"user": {"login": "karussell", "name": "Peter"}}, "url": "https://github.com/graphhopper/graphhopper/commit/dc1f44d155667a712076050f94b1b90e6a9a49fe", "committedDate": "2020-01-17T21:53:55Z", "message": "more information into toString"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ1MjM2NDE1", "url": "https://github.com/graphhopper/graphhopper/pull/1853#pullrequestreview-345236415", "createdAt": "2020-01-20T11:11:48Z", "commit": {"oid": "dc1f44d155667a712076050f94b1b90e6a9a49fe"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yMFQxMToxMTo0OFrOFfbAhA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yMFQxMToyMDo1MFrOFfbONA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODQ5MjY3Ng==", "bodyText": "I think this will fail when this method is called after this object was updated with update(). BBox is mutable, so I think we can't cache the RectangleLineIntersector.", "url": "https://github.com/graphhopper/graphhopper/pull/1853#discussion_r368492676", "createdAt": "2020-01-20T11:11:48Z", "author": {"login": "michaz"}, "path": "api/src/main/java/com/graphhopper/util/shapes/BBox.java", "diffHunk": "@@ -161,6 +164,36 @@ public boolean contains(Shape s) {\n         throw new UnsupportedOperationException(\"unsupported shape\");\n     }\n \n+    private RectangleLineIntersector cachedIntersector;\n+\n+    RectangleLineIntersector getCachedRectangleLineIntersector() {\n+        if (cachedIntersector == null)\n+            cachedIntersector = new RectangleLineIntersector(toEnvelope(this));\n+        return cachedIntersector;\n+    }\n+\n+    @Override\n+    public boolean intersects(PointList pointList) {\n+        int len = pointList.getSize();\n+        if (len == 0)\n+            throw new IllegalArgumentException(\"PointList must not be empty\");\n+\n+        double lat = pointList.getLatitude(0);\n+        double lon = pointList.getLongitude(0);\n+        if (len == 1)\n+            return contains(lat, lon);\n+\n+        Coordinate coords = new Coordinate(lon, lat);\n+        RectangleLineIntersector intersector = getCachedRectangleLineIntersector();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dc1f44d155667a712076050f94b1b90e6a9a49fe"}, "originalPosition": 34}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODQ5NjE4MA==", "bodyText": "Do you think we could just remove this method, and its definition from Shape? It isn't used generically anywhere in the code, so we could easily avoid giving an \"approximate\" or fudged implementation here.", "url": "https://github.com/graphhopper/graphhopper/pull/1853#discussion_r368496180", "createdAt": "2020-01-20T11:20:50Z", "author": {"login": "michaz"}, "path": "api/src/main/java/com/graphhopper/util/shapes/Polygon.java", "diffHunk": "@@ -137,115 +92,55 @@ public boolean contains(Shape s) {\n \n     @Override\n     public BBox getBounds() {\n-        return new BBox(minLon, maxLon, minLat, maxLat);\n+        return new BBox(envelope.getMinX(), envelope.getMaxX(), envelope.getMinY(), envelope.getMaxY());\n     }\n \n     @Override\n     public GHPoint getCenter() {\n-        return new GHPoint((maxLat + minLat) / 2, (maxLon + minLon) / 2);\n+        Point centroid = polygon.getGeometry().getCentroid();\n+        return new GHPoint(centroid.getY(), centroid.getX());\n     }\n \n     @Override\n     public double calculateArea() {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    private boolean edgesAreIntersecting(\n-            double v1x1, double v1y1, double v1x2, double v1y2,\n-            double v2x1, double v2y1, double v2x2, double v2y2\n-    ) {\n-\n-\n-        double d1, d2;\n-        double a1, a2, b1, b2, c1, c2;\n-\n-        // Convert vector 1 to a line (line 1) of infinite length.\n-        // We want the line in linear equation standard form: A*x + B*y + C = 0\n-        // See: http://en.wikipedia.org/wiki/Linear_equation\n-        a1 = v1y2 - v1y1;\n-        b1 = v1x1 - v1x2;\n-        c1 = (v1x2 * v1y1) - (v1x1 * v1y2);\n-\n-        // Every point (x,y), that solves the equation above, is on the line,\n-        // every point that does not solve it, is not. The equation will have a\n-        // positive result if it is on one side of the line and a negative one\n-        // if is on the other side of it. We insert (x1,y1) and (x2,y2) of vector\n-        // 2 into the equation above.\n-        d1 = (a1 * v2x1) + (b1 * v2y1) + c1;\n-        d2 = (a1 * v2x2) + (b1 * v2y2) + c1;\n-\n-        // If d1 and d2 both have the same sign, they are both on the same side\n-        // of our line 1 and in that case no intersection is possible. Careful,\n-        // 0 is a special case, that's why we don't test \">=\" and \"<=\",\n-        // but \"<\" and \">\".\n-        if (d1 > 0 && d2 > 0) return false;\n-        if (d1 < 0 && d2 < 0) return false;\n-\n-        // The fact that vector 2 intersected the infinite line 1 above doesn't\n-        // mean it also intersects the vector 1. Vector 1 is only a subset of that\n-        // infinite line 1, so it may have intersected that line before the vector\n-        // started or after it ended. To know for sure, we have to repeat the\n-        // the same test the other way round. We start by calculating the\n-        // infinite line 2 in linear equation standard form.\n-        a2 = v2y2 - v2y1;\n-        b2 = v2x1 - v2x2;\n-        c2 = (v2x2 * v2y1) - (v2x1 * v2y2);\n-\n-        // Calculate d1 and d2 again, this time using points of vector 1.\n-        d1 = (a2 * v1x1) + (b2 * v1y1) + c2;\n-        d2 = (a2 * v1x2) + (b2 * v1y2) + c2;\n-\n-        // Again, if both have the same sign (and neither one is 0),\n-        // no intersection is possible.\n-        if (d1 > 0 && d2 > 0) return false;\n-        if (d1 < 0 && d2 < 0) return false;\n-\n-        // If we get here, only two possibilities are left. Either the two\n-        // vectors intersect in exactly one point or they are collinear, which\n-        // means they intersect in any number of points from zero to infinite.\n-        if ((a1 * b2) - (a2 * b1) == 0) return false;\n-\n-        // If they are not collinear, they must intersect in exactly one point.\n-        return true;\n+        // for estimation use bounding box as reference:\n+        return getBounds().calculateArea() * envelope.getArea() / polygon.getGeometry().getArea();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dc1f44d155667a712076050f94b1b90e6a9a49fe"}, "originalPosition": 233}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "09e3adceb5cfca022a28b6c1f868e700e9574bdf", "author": {"user": {"login": "karussell", "name": "Peter"}}, "url": "https://github.com/graphhopper/graphhopper/commit/09e3adceb5cfca022a28b6c1f868e700e9574bdf", "committedDate": "2020-01-20T14:29:52Z", "message": "minor renaming"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6920beed2e55b21ab3f1566f08102bc720a24e28", "author": {"user": {"login": "karussell", "name": "Peter"}}, "url": "https://github.com/graphhopper/graphhopper/commit/6920beed2e55b21ab3f1566f08102bc720a24e28", "committedDate": "2020-01-20T15:03:41Z", "message": "Merge branch 'master' into replace_polygon"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f1f6df149fd3741f5ca62c27d93e9ac20d6b6f0c", "author": {"user": {"login": "karussell", "name": "Peter"}}, "url": "https://github.com/graphhopper/graphhopper/commit/f1f6df149fd3741f5ca62c27d93e9ac20d6b6f0c", "committedDate": "2020-01-20T21:22:27Z", "message": "avoid BBox.getCachedRectangleLineIntersector. Use polygon.calculateArea"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ2NzA5NjAx", "url": "https://github.com/graphhopper/graphhopper/pull/1853#pullrequestreview-346709601", "createdAt": "2020-01-22T16:08:48Z", "commit": {"oid": "f1f6df149fd3741f5ca62c27d93e9ac20d6b6f0c"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yMlQxNjowODo0OFrOFgh2-w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yMlQxNjowODo0OFrOFgh2-w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTY1MzQ5OQ==", "bodyText": "I think it's great that we can remove this method! This was always a bit of a headache factor for me!", "url": "https://github.com/graphhopper/graphhopper/pull/1853#discussion_r369653499", "createdAt": "2020-01-22T16:08:48Z", "author": {"login": "boldtrn"}, "path": "api/src/main/java/com/graphhopper/util/shapes/Polygon.java", "diffHunk": "@@ -137,115 +92,55 @@ public boolean contains(Shape s) {\n \n     @Override\n     public BBox getBounds() {\n-        return new BBox(minLon, maxLon, minLat, maxLat);\n+        return new BBox(envelope.getMinX(), envelope.getMaxX(), envelope.getMinY(), envelope.getMaxY());\n     }\n \n     @Override\n     public GHPoint getCenter() {\n-        return new GHPoint((maxLat + minLat) / 2, (maxLon + minLon) / 2);\n+        Point centroid = prepPolygon.getGeometry().getCentroid();\n+        return new GHPoint(centroid.getY(), centroid.getX());\n     }\n \n     @Override\n     public double calculateArea() {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    private boolean edgesAreIntersecting(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f1f6df149fd3741f5ca62c27d93e9ac20d6b6f0c"}, "originalPosition": 175}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f29165467870aa56550027c258ccf5957cf78bea", "author": {"user": {"login": "karussell", "name": "Peter"}}, "url": "https://github.com/graphhopper/graphhopper/commit/f29165467870aa56550027c258ccf5957cf78bea", "committedDate": "2020-01-28T11:33:22Z", "message": "merged master"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4692, "cost": 1, "resetAt": "2021-11-01T14:51:55Z"}}}