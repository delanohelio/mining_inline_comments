{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzY3NzA2OTA2", "number": 1871, "reviewThreads": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yN1QyMToxNTozMlrODbBpPQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yN1QyMToxNTozMlrODbBpPQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI5NjY1MDg1OnYy", "diffSide": "RIGHT", "path": "reader-osm/src/main/java/com/graphhopper/reader/osm/OSMReader.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yN1QyMToxNTozMlrOFiRt9A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOFQxMTozMzowN1rOFihyLA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTQ4NjE5Ng==", "bodyText": "... and avoid 0 distance (as it was noted: the distance would be stored as 0 since INT_DIST_FACTOR = 1000)", "url": "https://github.com/graphhopper/graphhopper/pull/1871#discussion_r371486196", "createdAt": "2020-01-27T21:15:32Z", "author": {"login": "karussell"}, "path": "reader-osm/src/main/java/com/graphhopper/reader/osm/OSMReader.java", "diffHunk": "@@ -698,11 +698,11 @@ EdgeIteratorState addEdge(int fromIndex, int toIndex, PointList pointList, IntsR\n                     pillarNodes.add(lat, lon);\n             }\n         }\n-        if (towerNodeDistance < 0.0001) {\n+        if (towerNodeDistance < 0.001) {\n             // As investigation shows often two paths should have crossed via one identical point \n             // but end up in two very close points.\n             zeroCounter++;\n-            towerNodeDistance = 0.0001;\n+            towerNodeDistance = 0.001;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0ec1163ff57b401b6698ce2bc7d99cfae042a726"}, "originalPosition": 10}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTY2MTQ2OA==", "bodyText": "Would it make sense to define a constant for the minimum storeable distance? These kind of magic numbers always come back to hunt you.", "url": "https://github.com/graphhopper/graphhopper/pull/1871#discussion_r371661468", "createdAt": "2020-01-28T08:28:25Z", "author": {"login": "otbutz"}, "path": "reader-osm/src/main/java/com/graphhopper/reader/osm/OSMReader.java", "diffHunk": "@@ -698,11 +698,11 @@ EdgeIteratorState addEdge(int fromIndex, int toIndex, PointList pointList, IntsR\n                     pillarNodes.add(lat, lon);\n             }\n         }\n-        if (towerNodeDistance < 0.0001) {\n+        if (towerNodeDistance < 0.001) {\n             // As investigation shows often two paths should have crossed via one identical point \n             // but end up in two very close points.\n             zeroCounter++;\n-            towerNodeDistance = 0.0001;\n+            towerNodeDistance = 0.001;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTQ4NjE5Ng=="}, "originalCommit": {"oid": "0ec1163ff57b401b6698ce2bc7d99cfae042a726"}, "originalPosition": 10}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTc0NzM4OA==", "bodyText": "Yeah, I don't like it too :) . Still \"providing an API\" for this limitation is uglier IMO at least when this is only needed in one place. Will add a comment to the BaseGraph to remind us of this here when refactoring.", "url": "https://github.com/graphhopper/graphhopper/pull/1871#discussion_r371747388", "createdAt": "2020-01-28T11:28:09Z", "author": {"login": "karussell"}, "path": "reader-osm/src/main/java/com/graphhopper/reader/osm/OSMReader.java", "diffHunk": "@@ -698,11 +698,11 @@ EdgeIteratorState addEdge(int fromIndex, int toIndex, PointList pointList, IntsR\n                     pillarNodes.add(lat, lon);\n             }\n         }\n-        if (towerNodeDistance < 0.0001) {\n+        if (towerNodeDistance < 0.001) {\n             // As investigation shows often two paths should have crossed via one identical point \n             // but end up in two very close points.\n             zeroCounter++;\n-            towerNodeDistance = 0.0001;\n+            towerNodeDistance = 0.001;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTQ4NjE5Ng=="}, "originalCommit": {"oid": "0ec1163ff57b401b6698ce2bc7d99cfae042a726"}, "originalPosition": 10}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTc0OTQyMA==", "bodyText": "An API would be nice but i think that a simple MIN_STOREABLE_DISTANCE constant with a comment would be sufficient for readability.\nEdit: missed your changes", "url": "https://github.com/graphhopper/graphhopper/pull/1871#discussion_r371749420", "createdAt": "2020-01-28T11:33:07Z", "author": {"login": "otbutz"}, "path": "reader-osm/src/main/java/com/graphhopper/reader/osm/OSMReader.java", "diffHunk": "@@ -698,11 +698,11 @@ EdgeIteratorState addEdge(int fromIndex, int toIndex, PointList pointList, IntsR\n                     pillarNodes.add(lat, lon);\n             }\n         }\n-        if (towerNodeDistance < 0.0001) {\n+        if (towerNodeDistance < 0.001) {\n             // As investigation shows often two paths should have crossed via one identical point \n             // but end up in two very close points.\n             zeroCounter++;\n-            towerNodeDistance = 0.0001;\n+            towerNodeDistance = 0.001;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTQ4NjE5Ng=="}, "originalCommit": {"oid": "0ec1163ff57b401b6698ce2bc7d99cfae042a726"}, "originalPosition": 10}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4847, "cost": 1, "resetAt": "2021-11-12T20:28:25Z"}}}