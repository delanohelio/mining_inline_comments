{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzY2NDY3NzAy", "number": 1863, "reviewThreads": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yNFQxNjoxMDoxNlrODaiOdw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yNlQwOTowMTo0NVrODatTEw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI5MTUwMzI3OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/com/graphhopper/GraphHopper.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yNFQxNjoxMDoxNlrOFhinbA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yNFQxNjoxMDoxNlrOFhinbA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDcxNDQ3Ng==", "bodyText": "Yes, this is intended. In a separate issue we could try if this would have any negative consequences.", "url": "https://github.com/graphhopper/graphhopper/pull/1863#discussion_r370714476", "createdAt": "2020-01-24T16:10:16Z", "author": {"login": "karussell"}, "path": "core/src/main/java/com/graphhopper/GraphHopper.java", "diffHunk": "@@ -847,7 +847,8 @@ private void initLMAlgoFactoryDecorator() {\n \n         for (FlagEncoder encoder : encodingManager.fetchEdgeEncoders()) {\n             for (String lmWeightingStr : lmFactoryDecorator.getWeightingsAsStrings()) {\n-                Weighting weighting = createWeighting(new HintsMap(lmWeightingStr), encoder, null);\n+                // note that we do not consider turn costs during LM preparation?\n+                Weighting weighting = createWeighting(new HintsMap(lmWeightingStr), encoder, null, new NoTurnCostProvider());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2fc0bcf031e2e7eb53ad796e6386d843c04446e1"}, "originalPosition": 19}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI5MTUxMzEyOnYy", "diffSide": "RIGHT", "path": "core/src/main/java/com/graphhopper/routing/InstructionsFromEdges.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yNFQxNjoxMzoyNFrOFhitpQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yNlQwOTowOToxNVrOFhzDfg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDcxNjA2OQ==", "bodyText": "Should we create an issue as reminder for this?", "url": "https://github.com/graphhopper/graphhopper/pull/1863#discussion_r370716069", "createdAt": "2020-01-24T16:13:24Z", "author": {"login": "karussell"}, "path": "core/src/main/java/com/graphhopper/routing/InstructionsFromEdges.java", "diffHunk": "@@ -508,7 +508,7 @@ private void updatePointsAndInstruction(EdgeIteratorState edge, PointList pl) {\n         }\n         double newDist = edge.getDistance();\n         prevInstruction.setDistance(newDist + prevInstruction.getDistance());\n-        // todonow: why do we not account for turn times here ?\n+        // todo: why do we not account for turn times here ?", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2fc0bcf031e2e7eb53ad796e6386d843c04446e1"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDk4MzgwNg==", "bodyText": "#1867", "url": "https://github.com/graphhopper/graphhopper/pull/1863#discussion_r370983806", "createdAt": "2020-01-26T09:09:15Z", "author": {"login": "easbar"}, "path": "core/src/main/java/com/graphhopper/routing/InstructionsFromEdges.java", "diffHunk": "@@ -508,7 +508,7 @@ private void updatePointsAndInstruction(EdgeIteratorState edge, PointList pl) {\n         }\n         double newDist = edge.getDistance();\n         prevInstruction.setDistance(newDist + prevInstruction.getDistance());\n-        // todonow: why do we not account for turn times here ?\n+        // todo: why do we not account for turn times here ?", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDcxNjA2OQ=="}, "originalCommit": {"oid": "2fc0bcf031e2e7eb53ad796e6386d843c04446e1"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI5MTU0NTQ2OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/com/graphhopper/routing/weighting/DefaultTurnCostProvider.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yNFQxNjoyMzo0MFrOFhjBxg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOFQwOTo1Njo1M1rOFie_dA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDcyMTIyMg==", "bodyText": "Shouldn't it include the FlagEncoder too? Because without it, then different providers will have the same name.\n(and in weighting.matches we could adapt the equals)", "url": "https://github.com/graphhopper/graphhopper/pull/1863#discussion_r370721222", "createdAt": "2020-01-24T16:23:40Z", "author": {"login": "karussell"}, "path": "core/src/main/java/com/graphhopper/routing/weighting/DefaultTurnCostProvider.java", "diffHunk": "@@ -0,0 +1,92 @@\n+/*\n+ *  Licensed to GraphHopper GmbH under one or more contributor\n+ *  license agreements. See the NOTICE file distributed with this work for\n+ *  additional information regarding copyright ownership.\n+ *\n+ *  GraphHopper GmbH licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except in\n+ *  compliance with the License. You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+\n+package com.graphhopper.routing.weighting;\n+\n+import com.graphhopper.routing.profiles.DecimalEncodedValue;\n+import com.graphhopper.routing.profiles.TurnCost;\n+import com.graphhopper.routing.util.FlagEncoder;\n+import com.graphhopper.storage.IntsRef;\n+import com.graphhopper.storage.TurnCostStorage;\n+import com.graphhopper.util.EdgeIterator;\n+\n+import static com.graphhopper.routing.profiles.TurnCost.EV_SUFFIX;\n+import static com.graphhopper.routing.util.EncodingManager.getKey;\n+import static com.graphhopper.routing.weighting.Weighting.INFINITE_U_TURN_COSTS;\n+\n+public class DefaultTurnCostProvider implements TurnCostProvider {\n+    private final DecimalEncodedValue turnCostEnc;\n+    private final TurnCostStorage turnCostStorage;\n+    private final int uTurnCostsInt;\n+    private final double uTurnCosts;\n+    private final IntsRef tcFlags = TurnCost.createFlags();\n+\n+    public DefaultTurnCostProvider(FlagEncoder encoder, TurnCostStorage turnCostStorage) {\n+        this(encoder, turnCostStorage, Weighting.INFINITE_U_TURN_COSTS);\n+    }\n+\n+    /**\n+     * @param uTurnCosts the costs of a u-turn in seconds, for {@link Weighting#INFINITE_U_TURN_COSTS} the u-turn costs\n+     *                   will be infinite\n+     */\n+    public DefaultTurnCostProvider(FlagEncoder encoder, TurnCostStorage turnCostStorage, int uTurnCosts) {\n+        if (uTurnCosts < 0 && uTurnCosts != INFINITE_U_TURN_COSTS) {\n+            throw new IllegalArgumentException(\"u-turn costs must be positive, or equal to \" + INFINITE_U_TURN_COSTS + \" (=infinite costs)\");\n+        }\n+        this.uTurnCostsInt = uTurnCosts;\n+        this.uTurnCosts = uTurnCosts < 0 ? Double.POSITIVE_INFINITY : uTurnCosts;\n+        if (turnCostStorage == null) {\n+            throw new IllegalArgumentException(\"No storage set to calculate turn weight\");\n+        }\n+        String key = getKey(encoder.toString(), EV_SUFFIX);\n+        // if null the TurnCostProvider can be still useful for edge-based routing\n+        this.turnCostEnc = encoder.hasEncodedValue(key) ? encoder.getDecimalEncodedValue(key) : null;\n+        this.turnCostStorage = turnCostStorage;\n+    }\n+\n+    @Override\n+    public double calcTurnWeight(int edgeFrom, int nodeVia, int edgeTo) {\n+        if (!EdgeIterator.Edge.isValid(edgeFrom) || !EdgeIterator.Edge.isValid(edgeTo)) {\n+            return 0;\n+        }\n+        double tCost = 0;\n+        if (turnCostStorage.isUTurn(edgeFrom, edgeTo)) {\n+            // note that the u-turn costs overwrite any turn costs set in TurnCostStorage\n+            tCost = turnCostStorage.isUTurnAllowed(nodeVia) ? uTurnCosts : Double.POSITIVE_INFINITY;\n+        } else {\n+            if (turnCostEnc != null)\n+                tCost = turnCostStorage.get(turnCostEnc, tcFlags, edgeFrom, nodeVia, edgeTo);\n+        }\n+        return tCost;\n+    }\n+\n+    @Override\n+    public long calcTurnMillis(int inEdge, int viaNode, int outEdge) {\n+        return (long) (1000 * calcTurnWeight(inEdge, viaNode, outEdge));\n+    }\n+\n+    @Override\n+    public String getName() {\n+        return toString();\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return \"\" + uTurnCostsInt;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2fc0bcf031e2e7eb53ad796e6386d843c04446e1"}, "originalPosition": 90}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDk4MTgxNg==", "bodyText": "Hmm, the FlagEncoder belongs to the Weighting and the DefaultTurnCostProvider in a way.. Right now its included in the Weighting name only (and it probably always has to be the same).", "url": "https://github.com/graphhopper/graphhopper/pull/1863#discussion_r370981816", "createdAt": "2020-01-26T08:33:47Z", "author": {"login": "easbar"}, "path": "core/src/main/java/com/graphhopper/routing/weighting/DefaultTurnCostProvider.java", "diffHunk": "@@ -0,0 +1,92 @@\n+/*\n+ *  Licensed to GraphHopper GmbH under one or more contributor\n+ *  license agreements. See the NOTICE file distributed with this work for\n+ *  additional information regarding copyright ownership.\n+ *\n+ *  GraphHopper GmbH licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except in\n+ *  compliance with the License. You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+\n+package com.graphhopper.routing.weighting;\n+\n+import com.graphhopper.routing.profiles.DecimalEncodedValue;\n+import com.graphhopper.routing.profiles.TurnCost;\n+import com.graphhopper.routing.util.FlagEncoder;\n+import com.graphhopper.storage.IntsRef;\n+import com.graphhopper.storage.TurnCostStorage;\n+import com.graphhopper.util.EdgeIterator;\n+\n+import static com.graphhopper.routing.profiles.TurnCost.EV_SUFFIX;\n+import static com.graphhopper.routing.util.EncodingManager.getKey;\n+import static com.graphhopper.routing.weighting.Weighting.INFINITE_U_TURN_COSTS;\n+\n+public class DefaultTurnCostProvider implements TurnCostProvider {\n+    private final DecimalEncodedValue turnCostEnc;\n+    private final TurnCostStorage turnCostStorage;\n+    private final int uTurnCostsInt;\n+    private final double uTurnCosts;\n+    private final IntsRef tcFlags = TurnCost.createFlags();\n+\n+    public DefaultTurnCostProvider(FlagEncoder encoder, TurnCostStorage turnCostStorage) {\n+        this(encoder, turnCostStorage, Weighting.INFINITE_U_TURN_COSTS);\n+    }\n+\n+    /**\n+     * @param uTurnCosts the costs of a u-turn in seconds, for {@link Weighting#INFINITE_U_TURN_COSTS} the u-turn costs\n+     *                   will be infinite\n+     */\n+    public DefaultTurnCostProvider(FlagEncoder encoder, TurnCostStorage turnCostStorage, int uTurnCosts) {\n+        if (uTurnCosts < 0 && uTurnCosts != INFINITE_U_TURN_COSTS) {\n+            throw new IllegalArgumentException(\"u-turn costs must be positive, or equal to \" + INFINITE_U_TURN_COSTS + \" (=infinite costs)\");\n+        }\n+        this.uTurnCostsInt = uTurnCosts;\n+        this.uTurnCosts = uTurnCosts < 0 ? Double.POSITIVE_INFINITY : uTurnCosts;\n+        if (turnCostStorage == null) {\n+            throw new IllegalArgumentException(\"No storage set to calculate turn weight\");\n+        }\n+        String key = getKey(encoder.toString(), EV_SUFFIX);\n+        // if null the TurnCostProvider can be still useful for edge-based routing\n+        this.turnCostEnc = encoder.hasEncodedValue(key) ? encoder.getDecimalEncodedValue(key) : null;\n+        this.turnCostStorage = turnCostStorage;\n+    }\n+\n+    @Override\n+    public double calcTurnWeight(int edgeFrom, int nodeVia, int edgeTo) {\n+        if (!EdgeIterator.Edge.isValid(edgeFrom) || !EdgeIterator.Edge.isValid(edgeTo)) {\n+            return 0;\n+        }\n+        double tCost = 0;\n+        if (turnCostStorage.isUTurn(edgeFrom, edgeTo)) {\n+            // note that the u-turn costs overwrite any turn costs set in TurnCostStorage\n+            tCost = turnCostStorage.isUTurnAllowed(nodeVia) ? uTurnCosts : Double.POSITIVE_INFINITY;\n+        } else {\n+            if (turnCostEnc != null)\n+                tCost = turnCostStorage.get(turnCostEnc, tcFlags, edgeFrom, nodeVia, edgeTo);\n+        }\n+        return tCost;\n+    }\n+\n+    @Override\n+    public long calcTurnMillis(int inEdge, int viaNode, int outEdge) {\n+        return (long) (1000 * calcTurnWeight(inEdge, viaNode, outEdge));\n+    }\n+\n+    @Override\n+    public String getName() {\n+        return toString();\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return \"\" + uTurnCostsInt;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDcyMTIyMg=="}, "originalCommit": {"oid": "2fc0bcf031e2e7eb53ad796e6386d843c04446e1"}, "originalPosition": 90}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTI4MjM3Mg==", "bodyText": "I see, this would be a bit of a circular dependency then. Still it feels strange that there will be different turn cost providers with the same name as soon as multiple vehicles are imported.", "url": "https://github.com/graphhopper/graphhopper/pull/1863#discussion_r371282372", "createdAt": "2020-01-27T14:48:34Z", "author": {"login": "karussell"}, "path": "core/src/main/java/com/graphhopper/routing/weighting/DefaultTurnCostProvider.java", "diffHunk": "@@ -0,0 +1,92 @@\n+/*\n+ *  Licensed to GraphHopper GmbH under one or more contributor\n+ *  license agreements. See the NOTICE file distributed with this work for\n+ *  additional information regarding copyright ownership.\n+ *\n+ *  GraphHopper GmbH licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except in\n+ *  compliance with the License. You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+\n+package com.graphhopper.routing.weighting;\n+\n+import com.graphhopper.routing.profiles.DecimalEncodedValue;\n+import com.graphhopper.routing.profiles.TurnCost;\n+import com.graphhopper.routing.util.FlagEncoder;\n+import com.graphhopper.storage.IntsRef;\n+import com.graphhopper.storage.TurnCostStorage;\n+import com.graphhopper.util.EdgeIterator;\n+\n+import static com.graphhopper.routing.profiles.TurnCost.EV_SUFFIX;\n+import static com.graphhopper.routing.util.EncodingManager.getKey;\n+import static com.graphhopper.routing.weighting.Weighting.INFINITE_U_TURN_COSTS;\n+\n+public class DefaultTurnCostProvider implements TurnCostProvider {\n+    private final DecimalEncodedValue turnCostEnc;\n+    private final TurnCostStorage turnCostStorage;\n+    private final int uTurnCostsInt;\n+    private final double uTurnCosts;\n+    private final IntsRef tcFlags = TurnCost.createFlags();\n+\n+    public DefaultTurnCostProvider(FlagEncoder encoder, TurnCostStorage turnCostStorage) {\n+        this(encoder, turnCostStorage, Weighting.INFINITE_U_TURN_COSTS);\n+    }\n+\n+    /**\n+     * @param uTurnCosts the costs of a u-turn in seconds, for {@link Weighting#INFINITE_U_TURN_COSTS} the u-turn costs\n+     *                   will be infinite\n+     */\n+    public DefaultTurnCostProvider(FlagEncoder encoder, TurnCostStorage turnCostStorage, int uTurnCosts) {\n+        if (uTurnCosts < 0 && uTurnCosts != INFINITE_U_TURN_COSTS) {\n+            throw new IllegalArgumentException(\"u-turn costs must be positive, or equal to \" + INFINITE_U_TURN_COSTS + \" (=infinite costs)\");\n+        }\n+        this.uTurnCostsInt = uTurnCosts;\n+        this.uTurnCosts = uTurnCosts < 0 ? Double.POSITIVE_INFINITY : uTurnCosts;\n+        if (turnCostStorage == null) {\n+            throw new IllegalArgumentException(\"No storage set to calculate turn weight\");\n+        }\n+        String key = getKey(encoder.toString(), EV_SUFFIX);\n+        // if null the TurnCostProvider can be still useful for edge-based routing\n+        this.turnCostEnc = encoder.hasEncodedValue(key) ? encoder.getDecimalEncodedValue(key) : null;\n+        this.turnCostStorage = turnCostStorage;\n+    }\n+\n+    @Override\n+    public double calcTurnWeight(int edgeFrom, int nodeVia, int edgeTo) {\n+        if (!EdgeIterator.Edge.isValid(edgeFrom) || !EdgeIterator.Edge.isValid(edgeTo)) {\n+            return 0;\n+        }\n+        double tCost = 0;\n+        if (turnCostStorage.isUTurn(edgeFrom, edgeTo)) {\n+            // note that the u-turn costs overwrite any turn costs set in TurnCostStorage\n+            tCost = turnCostStorage.isUTurnAllowed(nodeVia) ? uTurnCosts : Double.POSITIVE_INFINITY;\n+        } else {\n+            if (turnCostEnc != null)\n+                tCost = turnCostStorage.get(turnCostEnc, tcFlags, edgeFrom, nodeVia, edgeTo);\n+        }\n+        return tCost;\n+    }\n+\n+    @Override\n+    public long calcTurnMillis(int inEdge, int viaNode, int outEdge) {\n+        return (long) (1000 * calcTurnWeight(inEdge, viaNode, outEdge));\n+    }\n+\n+    @Override\n+    public String getName() {\n+        return toString();\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return \"\" + uTurnCostsInt;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDcyMTIyMg=="}, "originalCommit": {"oid": "2fc0bcf031e2e7eb53ad796e6386d843c04446e1"}, "originalPosition": 90}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTcwMzY2OA==", "bodyText": "Hmm yes this is not ideal. DefaultTurnCostProvider and AbstractWeighting are both using a FlagEncoder (and it most likely always has to be the same), so maybe the most correct way to assign the names would be using the FlagEncoder name for both? But then the weighting name would be something like car|fastest|car|40, which seems bad as well.\n\nhere will be different turn cost providers with the same name\n\nMaybe the question here is a turn cost provider is something that can exist without a weighting?", "url": "https://github.com/graphhopper/graphhopper/pull/1863#discussion_r371703668", "createdAt": "2020-01-28T09:56:53Z", "author": {"login": "easbar"}, "path": "core/src/main/java/com/graphhopper/routing/weighting/DefaultTurnCostProvider.java", "diffHunk": "@@ -0,0 +1,92 @@\n+/*\n+ *  Licensed to GraphHopper GmbH under one or more contributor\n+ *  license agreements. See the NOTICE file distributed with this work for\n+ *  additional information regarding copyright ownership.\n+ *\n+ *  GraphHopper GmbH licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except in\n+ *  compliance with the License. You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+\n+package com.graphhopper.routing.weighting;\n+\n+import com.graphhopper.routing.profiles.DecimalEncodedValue;\n+import com.graphhopper.routing.profiles.TurnCost;\n+import com.graphhopper.routing.util.FlagEncoder;\n+import com.graphhopper.storage.IntsRef;\n+import com.graphhopper.storage.TurnCostStorage;\n+import com.graphhopper.util.EdgeIterator;\n+\n+import static com.graphhopper.routing.profiles.TurnCost.EV_SUFFIX;\n+import static com.graphhopper.routing.util.EncodingManager.getKey;\n+import static com.graphhopper.routing.weighting.Weighting.INFINITE_U_TURN_COSTS;\n+\n+public class DefaultTurnCostProvider implements TurnCostProvider {\n+    private final DecimalEncodedValue turnCostEnc;\n+    private final TurnCostStorage turnCostStorage;\n+    private final int uTurnCostsInt;\n+    private final double uTurnCosts;\n+    private final IntsRef tcFlags = TurnCost.createFlags();\n+\n+    public DefaultTurnCostProvider(FlagEncoder encoder, TurnCostStorage turnCostStorage) {\n+        this(encoder, turnCostStorage, Weighting.INFINITE_U_TURN_COSTS);\n+    }\n+\n+    /**\n+     * @param uTurnCosts the costs of a u-turn in seconds, for {@link Weighting#INFINITE_U_TURN_COSTS} the u-turn costs\n+     *                   will be infinite\n+     */\n+    public DefaultTurnCostProvider(FlagEncoder encoder, TurnCostStorage turnCostStorage, int uTurnCosts) {\n+        if (uTurnCosts < 0 && uTurnCosts != INFINITE_U_TURN_COSTS) {\n+            throw new IllegalArgumentException(\"u-turn costs must be positive, or equal to \" + INFINITE_U_TURN_COSTS + \" (=infinite costs)\");\n+        }\n+        this.uTurnCostsInt = uTurnCosts;\n+        this.uTurnCosts = uTurnCosts < 0 ? Double.POSITIVE_INFINITY : uTurnCosts;\n+        if (turnCostStorage == null) {\n+            throw new IllegalArgumentException(\"No storage set to calculate turn weight\");\n+        }\n+        String key = getKey(encoder.toString(), EV_SUFFIX);\n+        // if null the TurnCostProvider can be still useful for edge-based routing\n+        this.turnCostEnc = encoder.hasEncodedValue(key) ? encoder.getDecimalEncodedValue(key) : null;\n+        this.turnCostStorage = turnCostStorage;\n+    }\n+\n+    @Override\n+    public double calcTurnWeight(int edgeFrom, int nodeVia, int edgeTo) {\n+        if (!EdgeIterator.Edge.isValid(edgeFrom) || !EdgeIterator.Edge.isValid(edgeTo)) {\n+            return 0;\n+        }\n+        double tCost = 0;\n+        if (turnCostStorage.isUTurn(edgeFrom, edgeTo)) {\n+            // note that the u-turn costs overwrite any turn costs set in TurnCostStorage\n+            tCost = turnCostStorage.isUTurnAllowed(nodeVia) ? uTurnCosts : Double.POSITIVE_INFINITY;\n+        } else {\n+            if (turnCostEnc != null)\n+                tCost = turnCostStorage.get(turnCostEnc, tcFlags, edgeFrom, nodeVia, edgeTo);\n+        }\n+        return tCost;\n+    }\n+\n+    @Override\n+    public long calcTurnMillis(int inEdge, int viaNode, int outEdge) {\n+        return (long) (1000 * calcTurnWeight(inEdge, viaNode, outEdge));\n+    }\n+\n+    @Override\n+    public String getName() {\n+        return toString();\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return \"\" + uTurnCostsInt;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDcyMTIyMg=="}, "originalCommit": {"oid": "2fc0bcf031e2e7eb53ad796e6386d843c04446e1"}, "originalPosition": 90}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI5MTU1MTg5OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/com/graphhopper/routing/weighting/NoTurnCostProvider.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yNFQxNjoyNTo1MFrOFhjF5Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yNlQwODozMTo0MVrOFhy7QA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDcyMjI3Nw==", "bodyText": "Maybe we should avoid instantiating this provider and create a singleton from it? Or even remove this class and create a variable \"NO_TURN_COST\" in TurnCostProvider?", "url": "https://github.com/graphhopper/graphhopper/pull/1863#discussion_r370722277", "createdAt": "2020-01-24T16:25:50Z", "author": {"login": "karussell"}, "path": "core/src/main/java/com/graphhopper/routing/weighting/NoTurnCostProvider.java", "diffHunk": "@@ -0,0 +1,36 @@\n+/*\n+ *  Licensed to GraphHopper GmbH under one or more contributor\n+ *  license agreements. See the NOTICE file distributed with this work for\n+ *  additional information regarding copyright ownership.\n+ *\n+ *  GraphHopper GmbH licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except in\n+ *  compliance with the License. You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+\n+package com.graphhopper.routing.weighting;\n+\n+public class NoTurnCostProvider implements TurnCostProvider {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2fc0bcf031e2e7eb53ad796e6386d843c04446e1"}, "originalPosition": 21}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDk4MTY5Ng==", "bodyText": "Ok, done.", "url": "https://github.com/graphhopper/graphhopper/pull/1863#discussion_r370981696", "createdAt": "2020-01-26T08:31:41Z", "author": {"login": "easbar"}, "path": "core/src/main/java/com/graphhopper/routing/weighting/NoTurnCostProvider.java", "diffHunk": "@@ -0,0 +1,36 @@\n+/*\n+ *  Licensed to GraphHopper GmbH under one or more contributor\n+ *  license agreements. See the NOTICE file distributed with this work for\n+ *  additional information regarding copyright ownership.\n+ *\n+ *  GraphHopper GmbH licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except in\n+ *  compliance with the License. You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+\n+package com.graphhopper.routing.weighting;\n+\n+public class NoTurnCostProvider implements TurnCostProvider {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDcyMjI3Nw=="}, "originalCommit": {"oid": "2fc0bcf031e2e7eb53ad796e6386d843c04446e1"}, "originalPosition": 21}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI5MTU2Nzg4OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/com/graphhopper/util/Constants.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yNFQxNjozMDo1M1rOFhjQIA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yN1QxNDo1MToyOFrOFiFYlw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDcyNDg5Ng==", "bodyText": "Do you think this is required? (similar question applies to the method where you kept the CH file names compatible)\nWe never kept backward compatibility for our files as they are recreated due to every OSM data update. I do not see value until we officially support offline routing support (maybe something for 3.0 ;) )", "url": "https://github.com/graphhopper/graphhopper/pull/1863#discussion_r370724896", "createdAt": "2020-01-24T16:30:53Z", "author": {"login": "karussell"}, "path": "core/src/main/java/com/graphhopper/util/Constants.java", "diffHunk": "@@ -66,6 +66,7 @@\n     private static final int JVM_MAJOR_VERSION;\n     private static final int JVM_MINOR_VERSION;\n \n+    // todonow: make sure this version is compatible also for older imports!", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2fc0bcf031e2e7eb53ad796e6386d843c04446e1"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDk4MTYyMg==", "bodyText": "Its probably not required because (?) I kept the old file names. I thought it would be ugly to change the filenames now and then change them again soon in #1708. Do you want to remove this complexity and just change the filenames now also? Otherwise we probably do not need to change the data versions, but I left this comment to double check.", "url": "https://github.com/graphhopper/graphhopper/pull/1863#discussion_r370981622", "createdAt": "2020-01-26T08:30:33Z", "author": {"login": "easbar"}, "path": "core/src/main/java/com/graphhopper/util/Constants.java", "diffHunk": "@@ -66,6 +66,7 @@\n     private static final int JVM_MAJOR_VERSION;\n     private static final int JVM_MINOR_VERSION;\n \n+    // todonow: make sure this version is compatible also for older imports!", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDcyNDg5Ng=="}, "originalCommit": {"oid": "2fc0bcf031e2e7eb53ad796e6386d843c04446e1"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTAyOTM4Mw==", "bodyText": "With my most recent commits this PR should be compatible with current master. On the other hand there is string manipulation logic to achieve this. I think its ok like this and this will be changed with #1708 again. If you prefer removing the string manipulation and not being compatible this is also totally fine for me.", "url": "https://github.com/graphhopper/graphhopper/pull/1863#discussion_r371029383", "createdAt": "2020-01-26T21:07:36Z", "author": {"login": "easbar"}, "path": "core/src/main/java/com/graphhopper/util/Constants.java", "diffHunk": "@@ -66,6 +66,7 @@\n     private static final int JVM_MAJOR_VERSION;\n     private static final int JVM_MINOR_VERSION;\n \n+    // todonow: make sure this version is compatible also for older imports!", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDcyNDg5Ng=="}, "originalCommit": {"oid": "2fc0bcf031e2e7eb53ad796e6386d843c04446e1"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTI4NDExOQ==", "bodyText": "\ud83d\udc4d I have no strong opinion here :)", "url": "https://github.com/graphhopper/graphhopper/pull/1863#discussion_r371284119", "createdAt": "2020-01-27T14:51:28Z", "author": {"login": "karussell"}, "path": "core/src/main/java/com/graphhopper/util/Constants.java", "diffHunk": "@@ -66,6 +66,7 @@\n     private static final int JVM_MAJOR_VERSION;\n     private static final int JVM_MINOR_VERSION;\n \n+    // todonow: make sure this version is compatible also for older imports!", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDcyNDg5Ng=="}, "originalCommit": {"oid": "2fc0bcf031e2e7eb53ad796e6386d843c04446e1"}, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI5MzMxNjgwOnYy", "diffSide": "RIGHT", "path": "core/src/main/java/com/graphhopper/storage/CHProfile.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yNlQwOTowMDo1OFrOFhzBeQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yNlQyMTowODoxMVrOFh11sg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDk4MzI4OQ==", "bodyText": "Any opinion here? Its no longer easy to do this check, we would need something like weighting.hasTurnCosts() (and maybe check if TurnCostProvider is a NoTurnCostProvider. But that doesn't seem very clean. Also using a TurnCostProvider and then choosing nodeBased is not necessarily an error (but might be useful to receive a warning...).", "url": "https://github.com/graphhopper/graphhopper/pull/1863#discussion_r370983289", "createdAt": "2020-01-26T09:00:58Z", "author": {"login": "easbar"}, "path": "core/src/main/java/com/graphhopper/storage/CHProfile.java", "diffHunk": "@@ -20,14 +20,18 @@\n public class CHProfile {\n     private final Weighting weighting;\n     private final boolean edgeBased;\n-    private final int uTurnCosts;\n \n     public static CHProfile nodeBased(Weighting weighting) {\n-        return new CHProfile(weighting, TraversalMode.NODE_BASED, INFINITE_U_TURN_COSTS);\n+        // todonow: should we do such a check (check if the weighting has turn costs ?)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2fc0bcf031e2e7eb53ad796e6386d843c04446e1"}, "originalPosition": 19}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTAyOTQyNg==", "bodyText": "I removed the check, it would be nice to have, but not really important either imo.", "url": "https://github.com/graphhopper/graphhopper/pull/1863#discussion_r371029426", "createdAt": "2020-01-26T21:08:11Z", "author": {"login": "easbar"}, "path": "core/src/main/java/com/graphhopper/storage/CHProfile.java", "diffHunk": "@@ -20,14 +20,18 @@\n public class CHProfile {\n     private final Weighting weighting;\n     private final boolean edgeBased;\n-    private final int uTurnCosts;\n \n     public static CHProfile nodeBased(Weighting weighting) {\n-        return new CHProfile(weighting, TraversalMode.NODE_BASED, INFINITE_U_TURN_COSTS);\n+        // todonow: should we do such a check (check if the weighting has turn costs ?)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDk4MzI4OQ=="}, "originalCommit": {"oid": "2fc0bcf031e2e7eb53ad796e6386d843c04446e1"}, "originalPosition": 19}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI5MzMxNzMxOnYy", "diffSide": "RIGHT", "path": "core/src/main/java/com/graphhopper/storage/CHProfile.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yNlQwOTowMTo0NVrOFhzBtg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yN1QxNDo1NDoxOVrOFiFfEA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDk4MzM1MA==", "bodyText": "Similar question here. But maybe we even want edge-based without turn costs for some(?) reason. #1702", "url": "https://github.com/graphhopper/graphhopper/pull/1863#discussion_r370983350", "createdAt": "2020-01-26T09:01:45Z", "author": {"login": "easbar"}, "path": "core/src/main/java/com/graphhopper/storage/CHProfile.java", "diffHunk": "@@ -20,14 +20,18 @@\n public class CHProfile {\n     private final Weighting weighting;\n     private final boolean edgeBased;\n-    private final int uTurnCosts;\n \n     public static CHProfile nodeBased(Weighting weighting) {\n-        return new CHProfile(weighting, TraversalMode.NODE_BASED, INFINITE_U_TURN_COSTS);\n+        // todonow: should we do such a check (check if the weighting has turn costs ?)\n+//        if (!edgeBased && uTurnCosts != INFINITE_U_TURN_COSTS) {\n+//            throw new IllegalArgumentException(\"Finite u-turn costs are only allowed for edge-based CH\");\n+//        }\n+        return new CHProfile(weighting, TraversalMode.NODE_BASED);\n     }\n \n-    public static CHProfile edgeBased(Weighting weighting, int uTurnCosts) {\n-        return new CHProfile(weighting, TraversalMode.EDGE_BASED, uTurnCosts);\n+    public static CHProfile edgeBased(Weighting weighting) {\n+        // todonow: should we check/assure that the weighting must have some valid turn costs ?", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2fc0bcf031e2e7eb53ad796e6386d843c04446e1"}, "originalPosition": 29}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTAyOTQ0OQ==", "bodyText": "I removed the check, here I actually think it'd be bad to do it because of #1702.", "url": "https://github.com/graphhopper/graphhopper/pull/1863#discussion_r371029449", "createdAt": "2020-01-26T21:08:36Z", "author": {"login": "easbar"}, "path": "core/src/main/java/com/graphhopper/storage/CHProfile.java", "diffHunk": "@@ -20,14 +20,18 @@\n public class CHProfile {\n     private final Weighting weighting;\n     private final boolean edgeBased;\n-    private final int uTurnCosts;\n \n     public static CHProfile nodeBased(Weighting weighting) {\n-        return new CHProfile(weighting, TraversalMode.NODE_BASED, INFINITE_U_TURN_COSTS);\n+        // todonow: should we do such a check (check if the weighting has turn costs ?)\n+//        if (!edgeBased && uTurnCosts != INFINITE_U_TURN_COSTS) {\n+//            throw new IllegalArgumentException(\"Finite u-turn costs are only allowed for edge-based CH\");\n+//        }\n+        return new CHProfile(weighting, TraversalMode.NODE_BASED);\n     }\n \n-    public static CHProfile edgeBased(Weighting weighting, int uTurnCosts) {\n-        return new CHProfile(weighting, TraversalMode.EDGE_BASED, uTurnCosts);\n+    public static CHProfile edgeBased(Weighting weighting) {\n+        // todonow: should we check/assure that the weighting must have some valid turn costs ?", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDk4MzM1MA=="}, "originalCommit": {"oid": "2fc0bcf031e2e7eb53ad796e6386d843c04446e1"}, "originalPosition": 29}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTI4NTc3Ng==", "bodyText": "Ok", "url": "https://github.com/graphhopper/graphhopper/pull/1863#discussion_r371285776", "createdAt": "2020-01-27T14:54:19Z", "author": {"login": "karussell"}, "path": "core/src/main/java/com/graphhopper/storage/CHProfile.java", "diffHunk": "@@ -20,14 +20,18 @@\n public class CHProfile {\n     private final Weighting weighting;\n     private final boolean edgeBased;\n-    private final int uTurnCosts;\n \n     public static CHProfile nodeBased(Weighting weighting) {\n-        return new CHProfile(weighting, TraversalMode.NODE_BASED, INFINITE_U_TURN_COSTS);\n+        // todonow: should we do such a check (check if the weighting has turn costs ?)\n+//        if (!edgeBased && uTurnCosts != INFINITE_U_TURN_COSTS) {\n+//            throw new IllegalArgumentException(\"Finite u-turn costs are only allowed for edge-based CH\");\n+//        }\n+        return new CHProfile(weighting, TraversalMode.NODE_BASED);\n     }\n \n-    public static CHProfile edgeBased(Weighting weighting, int uTurnCosts) {\n-        return new CHProfile(weighting, TraversalMode.EDGE_BASED, uTurnCosts);\n+    public static CHProfile edgeBased(Weighting weighting) {\n+        // todonow: should we check/assure that the weighting must have some valid turn costs ?", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDk4MzM1MA=="}, "originalCommit": {"oid": "2fc0bcf031e2e7eb53ad796e6386d843c04446e1"}, "originalPosition": 29}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4845, "cost": 1, "resetAt": "2021-11-12T20:28:25Z"}}}