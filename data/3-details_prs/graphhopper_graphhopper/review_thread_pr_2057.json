{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDI5MjE2MzMw", "number": 2057, "reviewThreads": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOVQxMzo0NjozNFrOED4wgQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOVQyMToyMToyM1rOEED7Bw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcyNTExMTA1OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/com/graphhopper/routing/MultiException.java", "isResolved": true, "comments": {"totalCount": 9, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOVQxMzo0NjozNFrOGhKs2w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMFQxNzowMTo1NVrOGh-SRA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzQzMTUxNQ==", "bodyText": "We should remove MultiException from web-api module now (?) and avoid two identical named classes.", "url": "https://github.com/graphhopper/graphhopper/pull/2057#discussion_r437431515", "createdAt": "2020-06-09T13:46:34Z", "author": {"login": "karussell"}, "path": "core/src/main/java/com/graphhopper/routing/MultiException.java", "diffHunk": "@@ -0,0 +1,35 @@\n+/*\n+ *  Licensed to GraphHopper GmbH under one or more contributor\n+ *  license agreements. See the NOTICE file distributed with this work for\n+ *  additional information regarding copyright ownership.\n+ *\n+ *  GraphHopper GmbH licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except in\n+ *  compliance with the License. You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+\n+package com.graphhopper.routing;\n+\n+import java.util.List;\n+\n+public class MultiException extends RuntimeException {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ee613b1352673023367f0dc8b14788a7b7887a36"}, "originalPosition": 23}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzY4ODc2OA==", "bodyText": "How would you remove it? Its still being used. This new MultiException is also a bit of a workaround only used so we are able to return all points not found.", "url": "https://github.com/graphhopper/graphhopper/pull/2057#discussion_r437688768", "createdAt": "2020-06-09T20:09:55Z", "author": {"login": "easbar"}, "path": "core/src/main/java/com/graphhopper/routing/MultiException.java", "diffHunk": "@@ -0,0 +1,35 @@\n+/*\n+ *  Licensed to GraphHopper GmbH under one or more contributor\n+ *  license agreements. See the NOTICE file distributed with this work for\n+ *  additional information regarding copyright ownership.\n+ *\n+ *  GraphHopper GmbH licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except in\n+ *  compliance with the License. You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+\n+package com.graphhopper.routing;\n+\n+import java.util.List;\n+\n+public class MultiException extends RuntimeException {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzQzMTUxNQ=="}, "originalCommit": {"oid": "ee613b1352673023367f0dc8b14788a7b7887a36"}, "originalPosition": 23}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzcyMDQ4OQ==", "bodyText": "We could get rid of it by returning some kind of Result type (that includes a list of errors) for ViaRouting#lookup as well... Or we use a less generic name like MultiPointsNotFoundException and catch it right after calling ViaRouting#lookup.", "url": "https://github.com/graphhopper/graphhopper/pull/2057#discussion_r437720489", "createdAt": "2020-06-09T21:01:49Z", "author": {"login": "easbar"}, "path": "core/src/main/java/com/graphhopper/routing/MultiException.java", "diffHunk": "@@ -0,0 +1,35 @@\n+/*\n+ *  Licensed to GraphHopper GmbH under one or more contributor\n+ *  license agreements. See the NOTICE file distributed with this work for\n+ *  additional information regarding copyright ownership.\n+ *\n+ *  GraphHopper GmbH licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except in\n+ *  compliance with the License. You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+\n+package com.graphhopper.routing;\n+\n+import java.util.List;\n+\n+public class MultiException extends RuntimeException {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzQzMTUxNQ=="}, "originalCommit": {"oid": "ee613b1352673023367f0dc8b14788a7b7887a36"}, "originalPosition": 23}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODEzMjE2NA==", "bodyText": "Couldn't we always use this new com.graphhopper.routing.MultiException class instead of com.graphhopper.MultiException? (see https://github.com/graphhopper/graphhopper/blob/master/web-api/src/main/java/com/graphhopper/MultiException.java)", "url": "https://github.com/graphhopper/graphhopper/pull/2057#discussion_r438132164", "createdAt": "2020-06-10T13:43:25Z", "author": {"login": "karussell"}, "path": "core/src/main/java/com/graphhopper/routing/MultiException.java", "diffHunk": "@@ -0,0 +1,35 @@\n+/*\n+ *  Licensed to GraphHopper GmbH under one or more contributor\n+ *  license agreements. See the NOTICE file distributed with this work for\n+ *  additional information regarding copyright ownership.\n+ *\n+ *  GraphHopper GmbH licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except in\n+ *  compliance with the License. You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+\n+package com.graphhopper.routing;\n+\n+import java.util.List;\n+\n+public class MultiException extends RuntimeException {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzQzMTUxNQ=="}, "originalCommit": {"oid": "ee613b1352673023367f0dc8b14788a7b7887a36"}, "originalPosition": 23}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODE0NTA4Nw==", "bodyText": "The reason I did not want to use the existing MultiException class is that the existing one is used at the web boundary (there is a MultiExceptionMapper), but all I wanted to achieve here is to make it possible for ViaRouting#lookup to report that multiple points could not be found. We could just call it MultiPointsNotFoundException, but since its just a list of Throwable this does not seem to be right either. We could make it more specific and attach to it the point indices and point coordinates instead, but this seemed a bit overkill at first (but now I think maybe this would be a bit better).", "url": "https://github.com/graphhopper/graphhopper/pull/2057#discussion_r438145087", "createdAt": "2020-06-10T14:00:35Z", "author": {"login": "easbar"}, "path": "core/src/main/java/com/graphhopper/routing/MultiException.java", "diffHunk": "@@ -0,0 +1,35 @@\n+/*\n+ *  Licensed to GraphHopper GmbH under one or more contributor\n+ *  license agreements. See the NOTICE file distributed with this work for\n+ *  additional information regarding copyright ownership.\n+ *\n+ *  GraphHopper GmbH licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except in\n+ *  compliance with the License. You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+\n+package com.graphhopper.routing;\n+\n+import java.util.List;\n+\n+public class MultiException extends RuntimeException {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzQzMTUxNQ=="}, "originalCommit": {"oid": "ee613b1352673023367f0dc8b14788a7b7887a36"}, "originalPosition": 23}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODIzNzk1Mw==", "bodyText": "The reason I did not want to use the existing MultiException class is that the existing one is used at the web boundary\n\nWhat do you mean here? What would be the problem if web-api uses a core class instead?\n\nWe could just call it MultiPointsNotFoundException, but since its just a list of Throwable this does not seem to be right either.\n\nYes, this sounds wrong.\nHow was this done before the refactoring?", "url": "https://github.com/graphhopper/graphhopper/pull/2057#discussion_r438237953", "createdAt": "2020-06-10T16:02:58Z", "author": {"login": "karussell"}, "path": "core/src/main/java/com/graphhopper/routing/MultiException.java", "diffHunk": "@@ -0,0 +1,35 @@\n+/*\n+ *  Licensed to GraphHopper GmbH under one or more contributor\n+ *  license agreements. See the NOTICE file distributed with this work for\n+ *  additional information regarding copyright ownership.\n+ *\n+ *  GraphHopper GmbH licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except in\n+ *  compliance with the License. You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+\n+package com.graphhopper.routing;\n+\n+import java.util.List;\n+\n+public class MultiException extends RuntimeException {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzQzMTUxNQ=="}, "originalCommit": {"oid": "ee613b1352673023367f0dc8b14788a7b7887a36"}, "originalPosition": 23}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODI0MTkwMw==", "bodyText": "Ah you mean the other way around: Use the new MultiException also for web... Sorry I misread this. Ok yes we could also do this. I have already renamed it to MultiplePointsNotFound exception carrying the point indices of the points that were not found though. How do you like this? For example if we wrote a test for ViaRouting#lookup I think this would be useful.\n\nHow was this done before the refactoring?\n\nBefore the refactoring the GHResponse object was accessible by the code that does the lookup and the errors were added to it right away (but then the calling code had to check for errors and return). So there was no boundary at all which I think is bad (from a testing perspective for example).", "url": "https://github.com/graphhopper/graphhopper/pull/2057#discussion_r438241903", "createdAt": "2020-06-10T16:08:13Z", "author": {"login": "easbar"}, "path": "core/src/main/java/com/graphhopper/routing/MultiException.java", "diffHunk": "@@ -0,0 +1,35 @@\n+/*\n+ *  Licensed to GraphHopper GmbH under one or more contributor\n+ *  license agreements. See the NOTICE file distributed with this work for\n+ *  additional information regarding copyright ownership.\n+ *\n+ *  GraphHopper GmbH licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except in\n+ *  compliance with the License. You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+\n+package com.graphhopper.routing;\n+\n+import java.util.List;\n+\n+public class MultiException extends RuntimeException {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzQzMTUxNQ=="}, "originalCommit": {"oid": "ee613b1352673023367f0dc8b14788a7b7887a36"}, "originalPosition": 23}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODI3MTk5OQ==", "bodyText": "I have already renamed it to MultiplePointsNotFound exception carrying the point indices of the points that were not found though. How do you like this?\n\nLooks also fine. Ah ... shouldn't it be possible to remove the \"public\" of the class?\n\nBefore the refactoring the GHResponse object was accessible by the code that does the lookup and the errors were added to it right away (but then the calling code had to check for errors and return).\n\nOk, makes sense.", "url": "https://github.com/graphhopper/graphhopper/pull/2057#discussion_r438271999", "createdAt": "2020-06-10T16:54:14Z", "author": {"login": "karussell"}, "path": "core/src/main/java/com/graphhopper/routing/MultiException.java", "diffHunk": "@@ -0,0 +1,35 @@\n+/*\n+ *  Licensed to GraphHopper GmbH under one or more contributor\n+ *  license agreements. See the NOTICE file distributed with this work for\n+ *  additional information regarding copyright ownership.\n+ *\n+ *  GraphHopper GmbH licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except in\n+ *  compliance with the License. You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+\n+package com.graphhopper.routing;\n+\n+import java.util.List;\n+\n+public class MultiException extends RuntimeException {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzQzMTUxNQ=="}, "originalCommit": {"oid": "ee613b1352673023367f0dc8b14788a7b7887a36"}, "originalPosition": 23}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODI3NjY3Ng==", "bodyText": "Looks also fine. Ah ... shouldn't it be possible to remove the \"public\" of the class?\n\nAh yes, its in this big routing package, but still better than public \ud83d\udc4d", "url": "https://github.com/graphhopper/graphhopper/pull/2057#discussion_r438276676", "createdAt": "2020-06-10T17:01:55Z", "author": {"login": "easbar"}, "path": "core/src/main/java/com/graphhopper/routing/MultiException.java", "diffHunk": "@@ -0,0 +1,35 @@\n+/*\n+ *  Licensed to GraphHopper GmbH under one or more contributor\n+ *  license agreements. See the NOTICE file distributed with this work for\n+ *  additional information regarding copyright ownership.\n+ *\n+ *  GraphHopper GmbH licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except in\n+ *  compliance with the License. You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+\n+package com.graphhopper.routing;\n+\n+import java.util.List;\n+\n+public class MultiException extends RuntimeException {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzQzMTUxNQ=="}, "originalCommit": {"oid": "ee613b1352673023367f0dc8b14788a7b7887a36"}, "originalPosition": 23}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcyNTEyMzExOnYy", "diffSide": "RIGHT", "path": "core/src/main/java/com/graphhopper/routing/PathCalculatorWithAvoidedEdges.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOVQxMzo0ODoyNFrOGhK0Sg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOVQyMDoxNjo1NFrOGhaoJA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzQzMzQxOA==", "bodyText": "I know naming is hard but having it named PathCalculator without implementing PathCalculator seems suboptimal.\nOr maybe we make this class and the static method only package protected and hide it a bit from public usage?", "url": "https://github.com/graphhopper/graphhopper/pull/2057#discussion_r437433418", "createdAt": "2020-06-09T13:48:24Z", "author": {"login": "karussell"}, "path": "core/src/main/java/com/graphhopper/routing/PathCalculatorWithAvoidedEdges.java", "diffHunk": "@@ -0,0 +1,52 @@\n+/*\n+ *  Licensed to GraphHopper GmbH under one or more contributor\n+ *  license agreements. See the NOTICE file distributed with this work for\n+ *  additional information regarding copyright ownership.\n+ *\n+ *  GraphHopper GmbH licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except in\n+ *  compliance with the License. You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+\n+package com.graphhopper.routing;\n+\n+import com.carrotsearch.hppc.IntSet;\n+import com.graphhopper.routing.weighting.AvoidEdgesWeighting;\n+\n+/**\n+ * This path calculator allows calculating a path with a set of avoided edges\n+ */\n+public class PathCalculatorWithAvoidedEdges {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ee613b1352673023367f0dc8b14788a7b7887a36"}, "originalPosition": 27}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzY5MjQ1Mg==", "bodyText": "Ok good idea I made it a private inner class in RoundTripRouting. I do not have an idea for a much better name though :) I just named it RoundTripCalculator.", "url": "https://github.com/graphhopper/graphhopper/pull/2057#discussion_r437692452", "createdAt": "2020-06-09T20:16:54Z", "author": {"login": "easbar"}, "path": "core/src/main/java/com/graphhopper/routing/PathCalculatorWithAvoidedEdges.java", "diffHunk": "@@ -0,0 +1,52 @@\n+/*\n+ *  Licensed to GraphHopper GmbH under one or more contributor\n+ *  license agreements. See the NOTICE file distributed with this work for\n+ *  additional information regarding copyright ownership.\n+ *\n+ *  GraphHopper GmbH licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except in\n+ *  compliance with the License. You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+\n+package com.graphhopper.routing;\n+\n+import com.carrotsearch.hppc.IntSet;\n+import com.graphhopper.routing.weighting.AvoidEdgesWeighting;\n+\n+/**\n+ * This path calculator allows calculating a path with a set of avoided edges\n+ */\n+public class PathCalculatorWithAvoidedEdges {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzQzMzQxOA=="}, "originalCommit": {"oid": "ee613b1352673023367f0dc8b14788a7b7887a36"}, "originalPosition": 27}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcyNTE2MjczOnYy", "diffSide": "RIGHT", "path": "core/src/main/java/com/graphhopper/routing/Router.java", "isResolved": true, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOVQxMzo1NDoxMVrOGhLNDA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMFQxNToxMzo0MFrOGh5sig==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzQzOTc1Ng==", "bodyText": "Should we create a common \"Result\" class (it is very similar anyway), so we would avoid repeating these two lines here? Or do you plan to move other objects into it?\nWe could even refactor the PathCalculator interface and remove the getter methods and only return Result for calcPaths.", "url": "https://github.com/graphhopper/graphhopper/pull/2057#discussion_r437439756", "createdAt": "2020-06-09T13:54:11Z", "author": {"login": "karussell"}, "path": "core/src/main/java/com/graphhopper/routing/Router.java", "diffHunk": "@@ -102,111 +102,210 @@ public Router(GraphHopperStorage ghStorage, LocationIndex locationIndex,\n             if (!profile.isTurnCosts() && !request.getCurbsides().isEmpty())\n                 throw new IllegalArgumentException(\"To make use of the \" + CURBSIDE + \" parameter you need to use a profile that supports turn costs\" +\n                         \"\\nThe following profiles do support turn costs: \" + getTurnCostProfiles());\n-\n             // todo later: should we be able to control this using the edge_based parameter?\n-            TraversalMode tMode = profile.isTurnCosts() ? TraversalMode.EDGE_BASED : TraversalMode.NODE_BASED;\n-            RoutingAlgorithmFactory algorithmFactory = getAlgorithmFactory(profile.getName(), disableCH, disableLM);\n-            Weighting weighting;\n-            Graph graph = ghStorage;\n-            if (chEnabled && !disableCH) {\n-                if (!(algorithmFactory instanceof CHRoutingAlgorithmFactory))\n-                    throw new IllegalStateException(\"Although CH was enabled a non-CH algorithm factory was returned \" + algorithmFactory);\n-\n-                if (request.getHints().has(Parameters.Routing.BLOCK_AREA))\n-                    throw new IllegalArgumentException(\"When CH is enabled the \" + Parameters.Routing.BLOCK_AREA + \" cannot be specified\");\n-\n-                CHConfig chConfig = ((CHRoutingAlgorithmFactory) algorithmFactory).getCHConfig();\n-                weighting = chConfig.getWeighting();\n-                graph = chGraphs.get(chConfig.getName());\n-                // we know this exists because we already got the algorithm factory this way -> will be cleaned up soon\n-            } else {\n-                checkNonChMaxWaypointDistance(request.getPoints());\n-                final int uTurnCostsInt = request.getHints().getInt(Parameters.Routing.U_TURN_COSTS, INFINITE_U_TURN_COSTS);\n-                if (uTurnCostsInt != INFINITE_U_TURN_COSTS && !tMode.isEdgeBased()) {\n-                    throw new IllegalArgumentException(\"Finite u-turn costs can only be used for edge-based routing, you need to use a profile that\" +\n-                            \" supports turn costs. Currently the following profiles that support turn costs are available: \" + getTurnCostProfiles());\n-                }\n-                FlagEncoder encoder = encodingManager.getEncoder(profile.getVehicle());\n-                weighting = weightingFactory.createWeighting(profile, request.getHints(), false);\n-                if (request.getHints().has(Parameters.Routing.BLOCK_AREA))\n-                    weighting = new BlockAreaWeighting(weighting, GraphEdgeIdFinder.createBlockArea(ghStorage, locationIndex,\n-                            request.getPoints(), request.getHints(), DefaultEdgeFilter.allEdges(encoder)));\n+            TraversalMode traversalMode = profile.isTurnCosts() ? TraversalMode.EDGE_BASED : TraversalMode.NODE_BASED;\n+            final int uTurnCostsInt = request.getHints().getInt(Parameters.Routing.U_TURN_COSTS, INFINITE_U_TURN_COSTS);\n+            if (uTurnCostsInt != INFINITE_U_TURN_COSTS && !traversalMode.isEdgeBased()) {\n+                throw new IllegalArgumentException(\"Finite u-turn costs can only be used for edge-based routing, you need to use a profile that\" +\n+                        \" supports turn costs. Currently the following profiles that support turn costs are available: \" + getTurnCostProfiles());\n             }\n-            ghRsp.addDebugInfo(\"tmode:\" + tMode.toString());\n-\n-            RoutingTemplate routingTemplate = createRoutingTemplate(request, ghRsp, request.getAlgorithm(), weighting);\n-\n-            StopWatch sw = new StopWatch().start();\n-            List<QueryResult> qResults = routingTemplate.lookup(request.getPoints());\n-            ghRsp.addDebugInfo(\"idLookup:\" + sw.stop().getSeconds() + \"s\");\n-            if (ghRsp.hasErrors())\n-                return Collections.emptyList();\n-\n-            QueryGraph queryGraph = QueryGraph.create(graph, qResults);\n+            ghRsp.addDebugInfo(\"traversal-mode:\" + traversalMode.toString());\n+            final boolean passThrough = getPassThrough(request.getHints());\n+            final boolean forceCurbsides = request.getHints().getBool(FORCE_CURBSIDE, true);\n             int maxVisitedNodesForRequest = request.getHints().getInt(Parameters.Routing.MAX_VISITED_NODES, routerConfig.getMaxVisitedNodes());\n             if (maxVisitedNodesForRequest > routerConfig.getMaxVisitedNodes())\n                 throw new IllegalArgumentException(\"The max_visited_nodes parameter has to be below or equal to:\" + routerConfig.getMaxVisitedNodes());\n \n+            // determine weighting\n+            final boolean useCH = chEnabled && !disableCH;\n+            Weighting weighting = createWeighting(profile, request.getHints(), request.getPoints(), useCH);\n+\n             AlgorithmOptions algoOpts = AlgorithmOptions.start().\n                     algorithm(request.getAlgorithm()).\n-                    traversalMode(tMode).\n+                    traversalMode(traversalMode).\n                     weighting(weighting).\n                     maxVisitedNodes(maxVisitedNodesForRequest).\n                     hints(request.getHints()).\n                     build();\n \n-            // do the actual route calculation !\n-            List<Path> altPaths = routingTemplate.calcPaths(queryGraph, algorithmFactory, algoOpts);\n-\n-            boolean tmpEnableInstructions = request.getHints().getBool(Parameters.Routing.INSTRUCTIONS, encodingManager.isEnableInstructions());\n-            boolean tmpCalcPoints = request.getHints().getBool(Parameters.Routing.CALC_POINTS, routerConfig.isCalcPoints());\n-            double wayPointMaxDistance = request.getHints().getDouble(Parameters.Routing.WAY_POINT_MAX_DISTANCE, 1d);\n-\n-            DouglasPeucker peucker = new DouglasPeucker().setMaxDistance(wayPointMaxDistance);\n-            PathMerger pathMerger = new PathMerger(queryGraph.getBaseGraph(), weighting).\n-                    setCalcPoints(tmpCalcPoints).\n-                    setDouglasPeucker(peucker).\n-                    setEnableInstructions(tmpEnableInstructions).\n-                    setPathDetailsBuilders(pathDetailsBuilderFactory, request.getPathDetails()).\n-                    setSimplifyResponse(routerConfig.isSimplifyResponse() && wayPointMaxDistance > 0);\n-\n-            if (!request.getHeadings().isEmpty())\n-                pathMerger.setFavoredHeading(request.getHeadings().get(0));\n-\n-            routingTemplate.finish(pathMerger, translationMap.getWithFallBack(request.getLocale()));\n-            return altPaths;\n+            if (ROUND_TRIP.equalsIgnoreCase(request.getAlgorithm())) {\n+                // ROUND TRIP\n+                StopWatch sw = new StopWatch().start();\n+                double startHeading = request.getHeadings().isEmpty() ? Double.NaN : request.getHeadings().get(0);\n+                RoundTripRouting.Params params = new RoundTripRouting.Params(request.getHints(), startHeading, routerConfig.getMaxRoundTripRetries());\n+                List<QueryResult> qResults = RoundTripRouting.lookup(request.getPoints(), weighting, locationIndex, params);\n+                ghRsp.addDebugInfo(\"idLookup:\" + sw.stop().getSeconds() + \"s\");\n+\n+                // use A* for round trips\n+                AlgorithmOptions roundTripAlgoOpts = AlgorithmOptions\n+                        .start(algoOpts)\n+                        .algorithm(Parameters.Algorithms.ASTAR_BI)\n+                        .build();\n+                roundTripAlgoOpts.getHints().putObject(Parameters.Algorithms.AStarBi.EPSILON, 2);\n+                FlexiblePathCalculator pathCalculator = createFlexiblePathCalculator(qResults, profile, roundTripAlgoOpts, disableLM);\n+                QueryGraph queryGraph = QueryGraph.create(ghStorage, qResults);\n+\n+                PathCalculatorWithAvoidedEdges roundTripPathCalculator = new PathCalculatorWithAvoidedEdges(pathCalculator);\n+                RoundTripRouting.Result result = RoundTripRouting.calcPaths(qResults, roundTripPathCalculator);\n+                // we merge the different legs of the roundtrip into one response path\n+                ResponsePath responsePath = concatenatePaths(request, weighting, queryGraph, result.paths, getWaypoints(qResults));\n+                ghRsp.add(responsePath);\n+                ghRsp.getHints().putObject(\"visited_nodes.sum\", result.visitedNodes);\n+                ghRsp.getHints().putObject(\"visited_nodes.average\", (float) result.visitedNodes / (qResults.size() - 1));\n+                return result.paths;\n+            } else if (ALT_ROUTE.equalsIgnoreCase(request.getAlgorithm())) {\n+                // ALTERNATIVE ROUTES\n+                if (request.getPoints().size() > 2)\n+                    throw new IllegalArgumentException(\"Currently alternative routes work only with start and end point. You tried to use: \" + request.getPoints().size() + \" points\");\n+                StopWatch sw = new StopWatch().start();\n+                List<QueryResult> qResults = ViaRouting.lookup(encodingManager, request.getPoints(), weighting, locationIndex, request.getSnapPreventions(), request.getPointHints());\n+                ghRsp.addDebugInfo(\"idLookup:\" + sw.stop().getSeconds() + \"s\");\n+                PathCalculator pathCalculator = createPathCalculator(qResults, profile, algoOpts, disableCH, disableLM);\n+                QueryGraph queryGraph = QueryGraph.create(ghStorage, qResults);\n+\n+                if (passThrough)\n+                    throw new IllegalArgumentException(\"Alternative paths and \" + PASS_THROUGH + \" at the same time is currently not supported\");\n+                if (!request.getCurbsides().isEmpty())\n+                    throw new IllegalArgumentException(\"Alternative paths do not support the \" + CURBSIDE + \" parameter yet\");\n+\n+                ViaRouting.Result result = ViaRouting.calcPaths(request.getPoints(), queryGraph, qResults, weighting.getFlagEncoder().getAccessEnc(), pathCalculator, request.getCurbsides(), forceCurbsides, request.getHeadings(), passThrough);\n+                if (result.paths.isEmpty())\n+                    throw new RuntimeException(\"Empty paths for alternative route calculation not expected\");\n+\n+                // each path represents a different alternative and we do the path merging for each of them\n+                PathMerger pathMerger = createPathMerger(request, weighting, queryGraph);\n+                for (Path path : result.paths) {\n+                    ResponsePath responsePath = new ResponsePath();\n+                    responsePath.setWaypoints(getWaypoints(qResults));\n+                    pathMerger.doWork(responsePath, Collections.singletonList(path), encodingManager, translationMap.getWithFallBack(request.getLocale()));\n+                    ghRsp.add(responsePath);\n+                }\n+                ghRsp.getHints().putObject(\"visited_nodes.sum\", result.visitedNodes);\n+                ghRsp.getHints().putObject(\"visited_nodes.average\", (float) result.visitedNodes / (qResults.size() - 1));\n+                return result.paths;\n+            } else {\n+                StopWatch sw = new StopWatch().start();\n+                List<QueryResult> qResults = ViaRouting.lookup(encodingManager, request.getPoints(), weighting, locationIndex, request.getSnapPreventions(), request.getPointHints());\n+                ghRsp.addDebugInfo(\"idLookup:\" + sw.stop().getSeconds() + \"s\");\n+                PathCalculator pathCalculator = createPathCalculator(qResults, profile, algoOpts, disableCH, disableLM);\n+                // (base) query graph used to resolve headings, curbsides etc. this is not necessarily the same thing as\n+                // the (possibly implementation specific) query graph used by PathCalculator\n+                QueryGraph queryGraph = QueryGraph.create(ghStorage, qResults);\n+                ViaRouting.Result result = ViaRouting.calcPaths(request.getPoints(), queryGraph, qResults, weighting.getFlagEncoder().getAccessEnc(), pathCalculator, request.getCurbsides(), forceCurbsides, request.getHeadings(), passThrough);\n+\n+                if (request.getPoints().size() != result.paths.size() + 1)\n+                    throw new RuntimeException(\"There should be exactly one more point than paths. points:\" + request.getPoints().size() + \", paths:\" + result.paths.size());\n+\n+                // here each path represents one leg of the via-route and we merge them all together into one response path\n+                ResponsePath responsePath = concatenatePaths(request, weighting, queryGraph, result.paths, getWaypoints(qResults));\n+                responsePath.addDebugInfo(result.debug);\n+                ghRsp.add(responsePath);\n+                ghRsp.getHints().putObject(\"visited_nodes.sum\", result.visitedNodes);\n+                ghRsp.getHints().putObject(\"visited_nodes.average\", (float) result.visitedNodes / (qResults.size() - 1));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ee613b1352673023367f0dc8b14788a7b7887a36"}, "originalPosition": 202}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzcxNzM0NA==", "bodyText": "Returning some kind of Result type from PathCalculator makes a lot of sense to me yes. For RoundTripRouting and ViaRouting I am not so sure. Should they also use the same Result class we would use in PathCalculator then? And how do you want to avoid these two lines this way? At some point we have to put the stuff from the result into the GHResponse. Ah you mean when the Results are the same we can do the same in all three cases? Or should we go back to manipulating the GHResponse inside ViaRouting etc.? I was trying to reduce side effects here, but not sure about this (and also this wasn't the focus here/there is definitely room for improvements architecture-wise here). Should we use some kind of generic Result type for such purposes (something like a `class Result that can carry T=List plus a debug string and some hash map or something)?", "url": "https://github.com/graphhopper/graphhopper/pull/2057#discussion_r437717344", "createdAt": "2020-06-09T20:57:21Z", "author": {"login": "easbar"}, "path": "core/src/main/java/com/graphhopper/routing/Router.java", "diffHunk": "@@ -102,111 +102,210 @@ public Router(GraphHopperStorage ghStorage, LocationIndex locationIndex,\n             if (!profile.isTurnCosts() && !request.getCurbsides().isEmpty())\n                 throw new IllegalArgumentException(\"To make use of the \" + CURBSIDE + \" parameter you need to use a profile that supports turn costs\" +\n                         \"\\nThe following profiles do support turn costs: \" + getTurnCostProfiles());\n-\n             // todo later: should we be able to control this using the edge_based parameter?\n-            TraversalMode tMode = profile.isTurnCosts() ? TraversalMode.EDGE_BASED : TraversalMode.NODE_BASED;\n-            RoutingAlgorithmFactory algorithmFactory = getAlgorithmFactory(profile.getName(), disableCH, disableLM);\n-            Weighting weighting;\n-            Graph graph = ghStorage;\n-            if (chEnabled && !disableCH) {\n-                if (!(algorithmFactory instanceof CHRoutingAlgorithmFactory))\n-                    throw new IllegalStateException(\"Although CH was enabled a non-CH algorithm factory was returned \" + algorithmFactory);\n-\n-                if (request.getHints().has(Parameters.Routing.BLOCK_AREA))\n-                    throw new IllegalArgumentException(\"When CH is enabled the \" + Parameters.Routing.BLOCK_AREA + \" cannot be specified\");\n-\n-                CHConfig chConfig = ((CHRoutingAlgorithmFactory) algorithmFactory).getCHConfig();\n-                weighting = chConfig.getWeighting();\n-                graph = chGraphs.get(chConfig.getName());\n-                // we know this exists because we already got the algorithm factory this way -> will be cleaned up soon\n-            } else {\n-                checkNonChMaxWaypointDistance(request.getPoints());\n-                final int uTurnCostsInt = request.getHints().getInt(Parameters.Routing.U_TURN_COSTS, INFINITE_U_TURN_COSTS);\n-                if (uTurnCostsInt != INFINITE_U_TURN_COSTS && !tMode.isEdgeBased()) {\n-                    throw new IllegalArgumentException(\"Finite u-turn costs can only be used for edge-based routing, you need to use a profile that\" +\n-                            \" supports turn costs. Currently the following profiles that support turn costs are available: \" + getTurnCostProfiles());\n-                }\n-                FlagEncoder encoder = encodingManager.getEncoder(profile.getVehicle());\n-                weighting = weightingFactory.createWeighting(profile, request.getHints(), false);\n-                if (request.getHints().has(Parameters.Routing.BLOCK_AREA))\n-                    weighting = new BlockAreaWeighting(weighting, GraphEdgeIdFinder.createBlockArea(ghStorage, locationIndex,\n-                            request.getPoints(), request.getHints(), DefaultEdgeFilter.allEdges(encoder)));\n+            TraversalMode traversalMode = profile.isTurnCosts() ? TraversalMode.EDGE_BASED : TraversalMode.NODE_BASED;\n+            final int uTurnCostsInt = request.getHints().getInt(Parameters.Routing.U_TURN_COSTS, INFINITE_U_TURN_COSTS);\n+            if (uTurnCostsInt != INFINITE_U_TURN_COSTS && !traversalMode.isEdgeBased()) {\n+                throw new IllegalArgumentException(\"Finite u-turn costs can only be used for edge-based routing, you need to use a profile that\" +\n+                        \" supports turn costs. Currently the following profiles that support turn costs are available: \" + getTurnCostProfiles());\n             }\n-            ghRsp.addDebugInfo(\"tmode:\" + tMode.toString());\n-\n-            RoutingTemplate routingTemplate = createRoutingTemplate(request, ghRsp, request.getAlgorithm(), weighting);\n-\n-            StopWatch sw = new StopWatch().start();\n-            List<QueryResult> qResults = routingTemplate.lookup(request.getPoints());\n-            ghRsp.addDebugInfo(\"idLookup:\" + sw.stop().getSeconds() + \"s\");\n-            if (ghRsp.hasErrors())\n-                return Collections.emptyList();\n-\n-            QueryGraph queryGraph = QueryGraph.create(graph, qResults);\n+            ghRsp.addDebugInfo(\"traversal-mode:\" + traversalMode.toString());\n+            final boolean passThrough = getPassThrough(request.getHints());\n+            final boolean forceCurbsides = request.getHints().getBool(FORCE_CURBSIDE, true);\n             int maxVisitedNodesForRequest = request.getHints().getInt(Parameters.Routing.MAX_VISITED_NODES, routerConfig.getMaxVisitedNodes());\n             if (maxVisitedNodesForRequest > routerConfig.getMaxVisitedNodes())\n                 throw new IllegalArgumentException(\"The max_visited_nodes parameter has to be below or equal to:\" + routerConfig.getMaxVisitedNodes());\n \n+            // determine weighting\n+            final boolean useCH = chEnabled && !disableCH;\n+            Weighting weighting = createWeighting(profile, request.getHints(), request.getPoints(), useCH);\n+\n             AlgorithmOptions algoOpts = AlgorithmOptions.start().\n                     algorithm(request.getAlgorithm()).\n-                    traversalMode(tMode).\n+                    traversalMode(traversalMode).\n                     weighting(weighting).\n                     maxVisitedNodes(maxVisitedNodesForRequest).\n                     hints(request.getHints()).\n                     build();\n \n-            // do the actual route calculation !\n-            List<Path> altPaths = routingTemplate.calcPaths(queryGraph, algorithmFactory, algoOpts);\n-\n-            boolean tmpEnableInstructions = request.getHints().getBool(Parameters.Routing.INSTRUCTIONS, encodingManager.isEnableInstructions());\n-            boolean tmpCalcPoints = request.getHints().getBool(Parameters.Routing.CALC_POINTS, routerConfig.isCalcPoints());\n-            double wayPointMaxDistance = request.getHints().getDouble(Parameters.Routing.WAY_POINT_MAX_DISTANCE, 1d);\n-\n-            DouglasPeucker peucker = new DouglasPeucker().setMaxDistance(wayPointMaxDistance);\n-            PathMerger pathMerger = new PathMerger(queryGraph.getBaseGraph(), weighting).\n-                    setCalcPoints(tmpCalcPoints).\n-                    setDouglasPeucker(peucker).\n-                    setEnableInstructions(tmpEnableInstructions).\n-                    setPathDetailsBuilders(pathDetailsBuilderFactory, request.getPathDetails()).\n-                    setSimplifyResponse(routerConfig.isSimplifyResponse() && wayPointMaxDistance > 0);\n-\n-            if (!request.getHeadings().isEmpty())\n-                pathMerger.setFavoredHeading(request.getHeadings().get(0));\n-\n-            routingTemplate.finish(pathMerger, translationMap.getWithFallBack(request.getLocale()));\n-            return altPaths;\n+            if (ROUND_TRIP.equalsIgnoreCase(request.getAlgorithm())) {\n+                // ROUND TRIP\n+                StopWatch sw = new StopWatch().start();\n+                double startHeading = request.getHeadings().isEmpty() ? Double.NaN : request.getHeadings().get(0);\n+                RoundTripRouting.Params params = new RoundTripRouting.Params(request.getHints(), startHeading, routerConfig.getMaxRoundTripRetries());\n+                List<QueryResult> qResults = RoundTripRouting.lookup(request.getPoints(), weighting, locationIndex, params);\n+                ghRsp.addDebugInfo(\"idLookup:\" + sw.stop().getSeconds() + \"s\");\n+\n+                // use A* for round trips\n+                AlgorithmOptions roundTripAlgoOpts = AlgorithmOptions\n+                        .start(algoOpts)\n+                        .algorithm(Parameters.Algorithms.ASTAR_BI)\n+                        .build();\n+                roundTripAlgoOpts.getHints().putObject(Parameters.Algorithms.AStarBi.EPSILON, 2);\n+                FlexiblePathCalculator pathCalculator = createFlexiblePathCalculator(qResults, profile, roundTripAlgoOpts, disableLM);\n+                QueryGraph queryGraph = QueryGraph.create(ghStorage, qResults);\n+\n+                PathCalculatorWithAvoidedEdges roundTripPathCalculator = new PathCalculatorWithAvoidedEdges(pathCalculator);\n+                RoundTripRouting.Result result = RoundTripRouting.calcPaths(qResults, roundTripPathCalculator);\n+                // we merge the different legs of the roundtrip into one response path\n+                ResponsePath responsePath = concatenatePaths(request, weighting, queryGraph, result.paths, getWaypoints(qResults));\n+                ghRsp.add(responsePath);\n+                ghRsp.getHints().putObject(\"visited_nodes.sum\", result.visitedNodes);\n+                ghRsp.getHints().putObject(\"visited_nodes.average\", (float) result.visitedNodes / (qResults.size() - 1));\n+                return result.paths;\n+            } else if (ALT_ROUTE.equalsIgnoreCase(request.getAlgorithm())) {\n+                // ALTERNATIVE ROUTES\n+                if (request.getPoints().size() > 2)\n+                    throw new IllegalArgumentException(\"Currently alternative routes work only with start and end point. You tried to use: \" + request.getPoints().size() + \" points\");\n+                StopWatch sw = new StopWatch().start();\n+                List<QueryResult> qResults = ViaRouting.lookup(encodingManager, request.getPoints(), weighting, locationIndex, request.getSnapPreventions(), request.getPointHints());\n+                ghRsp.addDebugInfo(\"idLookup:\" + sw.stop().getSeconds() + \"s\");\n+                PathCalculator pathCalculator = createPathCalculator(qResults, profile, algoOpts, disableCH, disableLM);\n+                QueryGraph queryGraph = QueryGraph.create(ghStorage, qResults);\n+\n+                if (passThrough)\n+                    throw new IllegalArgumentException(\"Alternative paths and \" + PASS_THROUGH + \" at the same time is currently not supported\");\n+                if (!request.getCurbsides().isEmpty())\n+                    throw new IllegalArgumentException(\"Alternative paths do not support the \" + CURBSIDE + \" parameter yet\");\n+\n+                ViaRouting.Result result = ViaRouting.calcPaths(request.getPoints(), queryGraph, qResults, weighting.getFlagEncoder().getAccessEnc(), pathCalculator, request.getCurbsides(), forceCurbsides, request.getHeadings(), passThrough);\n+                if (result.paths.isEmpty())\n+                    throw new RuntimeException(\"Empty paths for alternative route calculation not expected\");\n+\n+                // each path represents a different alternative and we do the path merging for each of them\n+                PathMerger pathMerger = createPathMerger(request, weighting, queryGraph);\n+                for (Path path : result.paths) {\n+                    ResponsePath responsePath = new ResponsePath();\n+                    responsePath.setWaypoints(getWaypoints(qResults));\n+                    pathMerger.doWork(responsePath, Collections.singletonList(path), encodingManager, translationMap.getWithFallBack(request.getLocale()));\n+                    ghRsp.add(responsePath);\n+                }\n+                ghRsp.getHints().putObject(\"visited_nodes.sum\", result.visitedNodes);\n+                ghRsp.getHints().putObject(\"visited_nodes.average\", (float) result.visitedNodes / (qResults.size() - 1));\n+                return result.paths;\n+            } else {\n+                StopWatch sw = new StopWatch().start();\n+                List<QueryResult> qResults = ViaRouting.lookup(encodingManager, request.getPoints(), weighting, locationIndex, request.getSnapPreventions(), request.getPointHints());\n+                ghRsp.addDebugInfo(\"idLookup:\" + sw.stop().getSeconds() + \"s\");\n+                PathCalculator pathCalculator = createPathCalculator(qResults, profile, algoOpts, disableCH, disableLM);\n+                // (base) query graph used to resolve headings, curbsides etc. this is not necessarily the same thing as\n+                // the (possibly implementation specific) query graph used by PathCalculator\n+                QueryGraph queryGraph = QueryGraph.create(ghStorage, qResults);\n+                ViaRouting.Result result = ViaRouting.calcPaths(request.getPoints(), queryGraph, qResults, weighting.getFlagEncoder().getAccessEnc(), pathCalculator, request.getCurbsides(), forceCurbsides, request.getHeadings(), passThrough);\n+\n+                if (request.getPoints().size() != result.paths.size() + 1)\n+                    throw new RuntimeException(\"There should be exactly one more point than paths. points:\" + request.getPoints().size() + \", paths:\" + result.paths.size());\n+\n+                // here each path represents one leg of the via-route and we merge them all together into one response path\n+                ResponsePath responsePath = concatenatePaths(request, weighting, queryGraph, result.paths, getWaypoints(qResults));\n+                responsePath.addDebugInfo(result.debug);\n+                ghRsp.add(responsePath);\n+                ghRsp.getHints().putObject(\"visited_nodes.sum\", result.visitedNodes);\n+                ghRsp.getHints().putObject(\"visited_nodes.average\", (float) result.visitedNodes / (qResults.size() - 1));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzQzOTc1Ng=="}, "originalCommit": {"oid": "ee613b1352673023367f0dc8b14788a7b7887a36"}, "originalPosition": 202}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzkzNjU2Mg==", "bodyText": "I tried using a result type for PathCalculator here: 5c7c22d, but I am not sure if this is really an improvement. WDYT?", "url": "https://github.com/graphhopper/graphhopper/pull/2057#discussion_r437936562", "createdAt": "2020-06-10T08:04:44Z", "author": {"login": "easbar"}, "path": "core/src/main/java/com/graphhopper/routing/Router.java", "diffHunk": "@@ -102,111 +102,210 @@ public Router(GraphHopperStorage ghStorage, LocationIndex locationIndex,\n             if (!profile.isTurnCosts() && !request.getCurbsides().isEmpty())\n                 throw new IllegalArgumentException(\"To make use of the \" + CURBSIDE + \" parameter you need to use a profile that supports turn costs\" +\n                         \"\\nThe following profiles do support turn costs: \" + getTurnCostProfiles());\n-\n             // todo later: should we be able to control this using the edge_based parameter?\n-            TraversalMode tMode = profile.isTurnCosts() ? TraversalMode.EDGE_BASED : TraversalMode.NODE_BASED;\n-            RoutingAlgorithmFactory algorithmFactory = getAlgorithmFactory(profile.getName(), disableCH, disableLM);\n-            Weighting weighting;\n-            Graph graph = ghStorage;\n-            if (chEnabled && !disableCH) {\n-                if (!(algorithmFactory instanceof CHRoutingAlgorithmFactory))\n-                    throw new IllegalStateException(\"Although CH was enabled a non-CH algorithm factory was returned \" + algorithmFactory);\n-\n-                if (request.getHints().has(Parameters.Routing.BLOCK_AREA))\n-                    throw new IllegalArgumentException(\"When CH is enabled the \" + Parameters.Routing.BLOCK_AREA + \" cannot be specified\");\n-\n-                CHConfig chConfig = ((CHRoutingAlgorithmFactory) algorithmFactory).getCHConfig();\n-                weighting = chConfig.getWeighting();\n-                graph = chGraphs.get(chConfig.getName());\n-                // we know this exists because we already got the algorithm factory this way -> will be cleaned up soon\n-            } else {\n-                checkNonChMaxWaypointDistance(request.getPoints());\n-                final int uTurnCostsInt = request.getHints().getInt(Parameters.Routing.U_TURN_COSTS, INFINITE_U_TURN_COSTS);\n-                if (uTurnCostsInt != INFINITE_U_TURN_COSTS && !tMode.isEdgeBased()) {\n-                    throw new IllegalArgumentException(\"Finite u-turn costs can only be used for edge-based routing, you need to use a profile that\" +\n-                            \" supports turn costs. Currently the following profiles that support turn costs are available: \" + getTurnCostProfiles());\n-                }\n-                FlagEncoder encoder = encodingManager.getEncoder(profile.getVehicle());\n-                weighting = weightingFactory.createWeighting(profile, request.getHints(), false);\n-                if (request.getHints().has(Parameters.Routing.BLOCK_AREA))\n-                    weighting = new BlockAreaWeighting(weighting, GraphEdgeIdFinder.createBlockArea(ghStorage, locationIndex,\n-                            request.getPoints(), request.getHints(), DefaultEdgeFilter.allEdges(encoder)));\n+            TraversalMode traversalMode = profile.isTurnCosts() ? TraversalMode.EDGE_BASED : TraversalMode.NODE_BASED;\n+            final int uTurnCostsInt = request.getHints().getInt(Parameters.Routing.U_TURN_COSTS, INFINITE_U_TURN_COSTS);\n+            if (uTurnCostsInt != INFINITE_U_TURN_COSTS && !traversalMode.isEdgeBased()) {\n+                throw new IllegalArgumentException(\"Finite u-turn costs can only be used for edge-based routing, you need to use a profile that\" +\n+                        \" supports turn costs. Currently the following profiles that support turn costs are available: \" + getTurnCostProfiles());\n             }\n-            ghRsp.addDebugInfo(\"tmode:\" + tMode.toString());\n-\n-            RoutingTemplate routingTemplate = createRoutingTemplate(request, ghRsp, request.getAlgorithm(), weighting);\n-\n-            StopWatch sw = new StopWatch().start();\n-            List<QueryResult> qResults = routingTemplate.lookup(request.getPoints());\n-            ghRsp.addDebugInfo(\"idLookup:\" + sw.stop().getSeconds() + \"s\");\n-            if (ghRsp.hasErrors())\n-                return Collections.emptyList();\n-\n-            QueryGraph queryGraph = QueryGraph.create(graph, qResults);\n+            ghRsp.addDebugInfo(\"traversal-mode:\" + traversalMode.toString());\n+            final boolean passThrough = getPassThrough(request.getHints());\n+            final boolean forceCurbsides = request.getHints().getBool(FORCE_CURBSIDE, true);\n             int maxVisitedNodesForRequest = request.getHints().getInt(Parameters.Routing.MAX_VISITED_NODES, routerConfig.getMaxVisitedNodes());\n             if (maxVisitedNodesForRequest > routerConfig.getMaxVisitedNodes())\n                 throw new IllegalArgumentException(\"The max_visited_nodes parameter has to be below or equal to:\" + routerConfig.getMaxVisitedNodes());\n \n+            // determine weighting\n+            final boolean useCH = chEnabled && !disableCH;\n+            Weighting weighting = createWeighting(profile, request.getHints(), request.getPoints(), useCH);\n+\n             AlgorithmOptions algoOpts = AlgorithmOptions.start().\n                     algorithm(request.getAlgorithm()).\n-                    traversalMode(tMode).\n+                    traversalMode(traversalMode).\n                     weighting(weighting).\n                     maxVisitedNodes(maxVisitedNodesForRequest).\n                     hints(request.getHints()).\n                     build();\n \n-            // do the actual route calculation !\n-            List<Path> altPaths = routingTemplate.calcPaths(queryGraph, algorithmFactory, algoOpts);\n-\n-            boolean tmpEnableInstructions = request.getHints().getBool(Parameters.Routing.INSTRUCTIONS, encodingManager.isEnableInstructions());\n-            boolean tmpCalcPoints = request.getHints().getBool(Parameters.Routing.CALC_POINTS, routerConfig.isCalcPoints());\n-            double wayPointMaxDistance = request.getHints().getDouble(Parameters.Routing.WAY_POINT_MAX_DISTANCE, 1d);\n-\n-            DouglasPeucker peucker = new DouglasPeucker().setMaxDistance(wayPointMaxDistance);\n-            PathMerger pathMerger = new PathMerger(queryGraph.getBaseGraph(), weighting).\n-                    setCalcPoints(tmpCalcPoints).\n-                    setDouglasPeucker(peucker).\n-                    setEnableInstructions(tmpEnableInstructions).\n-                    setPathDetailsBuilders(pathDetailsBuilderFactory, request.getPathDetails()).\n-                    setSimplifyResponse(routerConfig.isSimplifyResponse() && wayPointMaxDistance > 0);\n-\n-            if (!request.getHeadings().isEmpty())\n-                pathMerger.setFavoredHeading(request.getHeadings().get(0));\n-\n-            routingTemplate.finish(pathMerger, translationMap.getWithFallBack(request.getLocale()));\n-            return altPaths;\n+            if (ROUND_TRIP.equalsIgnoreCase(request.getAlgorithm())) {\n+                // ROUND TRIP\n+                StopWatch sw = new StopWatch().start();\n+                double startHeading = request.getHeadings().isEmpty() ? Double.NaN : request.getHeadings().get(0);\n+                RoundTripRouting.Params params = new RoundTripRouting.Params(request.getHints(), startHeading, routerConfig.getMaxRoundTripRetries());\n+                List<QueryResult> qResults = RoundTripRouting.lookup(request.getPoints(), weighting, locationIndex, params);\n+                ghRsp.addDebugInfo(\"idLookup:\" + sw.stop().getSeconds() + \"s\");\n+\n+                // use A* for round trips\n+                AlgorithmOptions roundTripAlgoOpts = AlgorithmOptions\n+                        .start(algoOpts)\n+                        .algorithm(Parameters.Algorithms.ASTAR_BI)\n+                        .build();\n+                roundTripAlgoOpts.getHints().putObject(Parameters.Algorithms.AStarBi.EPSILON, 2);\n+                FlexiblePathCalculator pathCalculator = createFlexiblePathCalculator(qResults, profile, roundTripAlgoOpts, disableLM);\n+                QueryGraph queryGraph = QueryGraph.create(ghStorage, qResults);\n+\n+                PathCalculatorWithAvoidedEdges roundTripPathCalculator = new PathCalculatorWithAvoidedEdges(pathCalculator);\n+                RoundTripRouting.Result result = RoundTripRouting.calcPaths(qResults, roundTripPathCalculator);\n+                // we merge the different legs of the roundtrip into one response path\n+                ResponsePath responsePath = concatenatePaths(request, weighting, queryGraph, result.paths, getWaypoints(qResults));\n+                ghRsp.add(responsePath);\n+                ghRsp.getHints().putObject(\"visited_nodes.sum\", result.visitedNodes);\n+                ghRsp.getHints().putObject(\"visited_nodes.average\", (float) result.visitedNodes / (qResults.size() - 1));\n+                return result.paths;\n+            } else if (ALT_ROUTE.equalsIgnoreCase(request.getAlgorithm())) {\n+                // ALTERNATIVE ROUTES\n+                if (request.getPoints().size() > 2)\n+                    throw new IllegalArgumentException(\"Currently alternative routes work only with start and end point. You tried to use: \" + request.getPoints().size() + \" points\");\n+                StopWatch sw = new StopWatch().start();\n+                List<QueryResult> qResults = ViaRouting.lookup(encodingManager, request.getPoints(), weighting, locationIndex, request.getSnapPreventions(), request.getPointHints());\n+                ghRsp.addDebugInfo(\"idLookup:\" + sw.stop().getSeconds() + \"s\");\n+                PathCalculator pathCalculator = createPathCalculator(qResults, profile, algoOpts, disableCH, disableLM);\n+                QueryGraph queryGraph = QueryGraph.create(ghStorage, qResults);\n+\n+                if (passThrough)\n+                    throw new IllegalArgumentException(\"Alternative paths and \" + PASS_THROUGH + \" at the same time is currently not supported\");\n+                if (!request.getCurbsides().isEmpty())\n+                    throw new IllegalArgumentException(\"Alternative paths do not support the \" + CURBSIDE + \" parameter yet\");\n+\n+                ViaRouting.Result result = ViaRouting.calcPaths(request.getPoints(), queryGraph, qResults, weighting.getFlagEncoder().getAccessEnc(), pathCalculator, request.getCurbsides(), forceCurbsides, request.getHeadings(), passThrough);\n+                if (result.paths.isEmpty())\n+                    throw new RuntimeException(\"Empty paths for alternative route calculation not expected\");\n+\n+                // each path represents a different alternative and we do the path merging for each of them\n+                PathMerger pathMerger = createPathMerger(request, weighting, queryGraph);\n+                for (Path path : result.paths) {\n+                    ResponsePath responsePath = new ResponsePath();\n+                    responsePath.setWaypoints(getWaypoints(qResults));\n+                    pathMerger.doWork(responsePath, Collections.singletonList(path), encodingManager, translationMap.getWithFallBack(request.getLocale()));\n+                    ghRsp.add(responsePath);\n+                }\n+                ghRsp.getHints().putObject(\"visited_nodes.sum\", result.visitedNodes);\n+                ghRsp.getHints().putObject(\"visited_nodes.average\", (float) result.visitedNodes / (qResults.size() - 1));\n+                return result.paths;\n+            } else {\n+                StopWatch sw = new StopWatch().start();\n+                List<QueryResult> qResults = ViaRouting.lookup(encodingManager, request.getPoints(), weighting, locationIndex, request.getSnapPreventions(), request.getPointHints());\n+                ghRsp.addDebugInfo(\"idLookup:\" + sw.stop().getSeconds() + \"s\");\n+                PathCalculator pathCalculator = createPathCalculator(qResults, profile, algoOpts, disableCH, disableLM);\n+                // (base) query graph used to resolve headings, curbsides etc. this is not necessarily the same thing as\n+                // the (possibly implementation specific) query graph used by PathCalculator\n+                QueryGraph queryGraph = QueryGraph.create(ghStorage, qResults);\n+                ViaRouting.Result result = ViaRouting.calcPaths(request.getPoints(), queryGraph, qResults, weighting.getFlagEncoder().getAccessEnc(), pathCalculator, request.getCurbsides(), forceCurbsides, request.getHeadings(), passThrough);\n+\n+                if (request.getPoints().size() != result.paths.size() + 1)\n+                    throw new RuntimeException(\"There should be exactly one more point than paths. points:\" + request.getPoints().size() + \", paths:\" + result.paths.size());\n+\n+                // here each path represents one leg of the via-route and we merge them all together into one response path\n+                ResponsePath responsePath = concatenatePaths(request, weighting, queryGraph, result.paths, getWaypoints(qResults));\n+                responsePath.addDebugInfo(result.debug);\n+                ghRsp.add(responsePath);\n+                ghRsp.getHints().putObject(\"visited_nodes.sum\", result.visitedNodes);\n+                ghRsp.getHints().putObject(\"visited_nodes.average\", (float) result.visitedNodes / (qResults.size() - 1));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzQzOTc1Ng=="}, "originalCommit": {"oid": "ee613b1352673023367f0dc8b14788a7b7887a36"}, "originalPosition": 202}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODEzMDMwOA==", "bodyText": "Ah you mean when the Results are the same we can do the same in all three cases?\n\nYes, I meant only this and indeed I'm now unsure too if this is an improvement.", "url": "https://github.com/graphhopper/graphhopper/pull/2057#discussion_r438130308", "createdAt": "2020-06-10T13:40:52Z", "author": {"login": "karussell"}, "path": "core/src/main/java/com/graphhopper/routing/Router.java", "diffHunk": "@@ -102,111 +102,210 @@ public Router(GraphHopperStorage ghStorage, LocationIndex locationIndex,\n             if (!profile.isTurnCosts() && !request.getCurbsides().isEmpty())\n                 throw new IllegalArgumentException(\"To make use of the \" + CURBSIDE + \" parameter you need to use a profile that supports turn costs\" +\n                         \"\\nThe following profiles do support turn costs: \" + getTurnCostProfiles());\n-\n             // todo later: should we be able to control this using the edge_based parameter?\n-            TraversalMode tMode = profile.isTurnCosts() ? TraversalMode.EDGE_BASED : TraversalMode.NODE_BASED;\n-            RoutingAlgorithmFactory algorithmFactory = getAlgorithmFactory(profile.getName(), disableCH, disableLM);\n-            Weighting weighting;\n-            Graph graph = ghStorage;\n-            if (chEnabled && !disableCH) {\n-                if (!(algorithmFactory instanceof CHRoutingAlgorithmFactory))\n-                    throw new IllegalStateException(\"Although CH was enabled a non-CH algorithm factory was returned \" + algorithmFactory);\n-\n-                if (request.getHints().has(Parameters.Routing.BLOCK_AREA))\n-                    throw new IllegalArgumentException(\"When CH is enabled the \" + Parameters.Routing.BLOCK_AREA + \" cannot be specified\");\n-\n-                CHConfig chConfig = ((CHRoutingAlgorithmFactory) algorithmFactory).getCHConfig();\n-                weighting = chConfig.getWeighting();\n-                graph = chGraphs.get(chConfig.getName());\n-                // we know this exists because we already got the algorithm factory this way -> will be cleaned up soon\n-            } else {\n-                checkNonChMaxWaypointDistance(request.getPoints());\n-                final int uTurnCostsInt = request.getHints().getInt(Parameters.Routing.U_TURN_COSTS, INFINITE_U_TURN_COSTS);\n-                if (uTurnCostsInt != INFINITE_U_TURN_COSTS && !tMode.isEdgeBased()) {\n-                    throw new IllegalArgumentException(\"Finite u-turn costs can only be used for edge-based routing, you need to use a profile that\" +\n-                            \" supports turn costs. Currently the following profiles that support turn costs are available: \" + getTurnCostProfiles());\n-                }\n-                FlagEncoder encoder = encodingManager.getEncoder(profile.getVehicle());\n-                weighting = weightingFactory.createWeighting(profile, request.getHints(), false);\n-                if (request.getHints().has(Parameters.Routing.BLOCK_AREA))\n-                    weighting = new BlockAreaWeighting(weighting, GraphEdgeIdFinder.createBlockArea(ghStorage, locationIndex,\n-                            request.getPoints(), request.getHints(), DefaultEdgeFilter.allEdges(encoder)));\n+            TraversalMode traversalMode = profile.isTurnCosts() ? TraversalMode.EDGE_BASED : TraversalMode.NODE_BASED;\n+            final int uTurnCostsInt = request.getHints().getInt(Parameters.Routing.U_TURN_COSTS, INFINITE_U_TURN_COSTS);\n+            if (uTurnCostsInt != INFINITE_U_TURN_COSTS && !traversalMode.isEdgeBased()) {\n+                throw new IllegalArgumentException(\"Finite u-turn costs can only be used for edge-based routing, you need to use a profile that\" +\n+                        \" supports turn costs. Currently the following profiles that support turn costs are available: \" + getTurnCostProfiles());\n             }\n-            ghRsp.addDebugInfo(\"tmode:\" + tMode.toString());\n-\n-            RoutingTemplate routingTemplate = createRoutingTemplate(request, ghRsp, request.getAlgorithm(), weighting);\n-\n-            StopWatch sw = new StopWatch().start();\n-            List<QueryResult> qResults = routingTemplate.lookup(request.getPoints());\n-            ghRsp.addDebugInfo(\"idLookup:\" + sw.stop().getSeconds() + \"s\");\n-            if (ghRsp.hasErrors())\n-                return Collections.emptyList();\n-\n-            QueryGraph queryGraph = QueryGraph.create(graph, qResults);\n+            ghRsp.addDebugInfo(\"traversal-mode:\" + traversalMode.toString());\n+            final boolean passThrough = getPassThrough(request.getHints());\n+            final boolean forceCurbsides = request.getHints().getBool(FORCE_CURBSIDE, true);\n             int maxVisitedNodesForRequest = request.getHints().getInt(Parameters.Routing.MAX_VISITED_NODES, routerConfig.getMaxVisitedNodes());\n             if (maxVisitedNodesForRequest > routerConfig.getMaxVisitedNodes())\n                 throw new IllegalArgumentException(\"The max_visited_nodes parameter has to be below or equal to:\" + routerConfig.getMaxVisitedNodes());\n \n+            // determine weighting\n+            final boolean useCH = chEnabled && !disableCH;\n+            Weighting weighting = createWeighting(profile, request.getHints(), request.getPoints(), useCH);\n+\n             AlgorithmOptions algoOpts = AlgorithmOptions.start().\n                     algorithm(request.getAlgorithm()).\n-                    traversalMode(tMode).\n+                    traversalMode(traversalMode).\n                     weighting(weighting).\n                     maxVisitedNodes(maxVisitedNodesForRequest).\n                     hints(request.getHints()).\n                     build();\n \n-            // do the actual route calculation !\n-            List<Path> altPaths = routingTemplate.calcPaths(queryGraph, algorithmFactory, algoOpts);\n-\n-            boolean tmpEnableInstructions = request.getHints().getBool(Parameters.Routing.INSTRUCTIONS, encodingManager.isEnableInstructions());\n-            boolean tmpCalcPoints = request.getHints().getBool(Parameters.Routing.CALC_POINTS, routerConfig.isCalcPoints());\n-            double wayPointMaxDistance = request.getHints().getDouble(Parameters.Routing.WAY_POINT_MAX_DISTANCE, 1d);\n-\n-            DouglasPeucker peucker = new DouglasPeucker().setMaxDistance(wayPointMaxDistance);\n-            PathMerger pathMerger = new PathMerger(queryGraph.getBaseGraph(), weighting).\n-                    setCalcPoints(tmpCalcPoints).\n-                    setDouglasPeucker(peucker).\n-                    setEnableInstructions(tmpEnableInstructions).\n-                    setPathDetailsBuilders(pathDetailsBuilderFactory, request.getPathDetails()).\n-                    setSimplifyResponse(routerConfig.isSimplifyResponse() && wayPointMaxDistance > 0);\n-\n-            if (!request.getHeadings().isEmpty())\n-                pathMerger.setFavoredHeading(request.getHeadings().get(0));\n-\n-            routingTemplate.finish(pathMerger, translationMap.getWithFallBack(request.getLocale()));\n-            return altPaths;\n+            if (ROUND_TRIP.equalsIgnoreCase(request.getAlgorithm())) {\n+                // ROUND TRIP\n+                StopWatch sw = new StopWatch().start();\n+                double startHeading = request.getHeadings().isEmpty() ? Double.NaN : request.getHeadings().get(0);\n+                RoundTripRouting.Params params = new RoundTripRouting.Params(request.getHints(), startHeading, routerConfig.getMaxRoundTripRetries());\n+                List<QueryResult> qResults = RoundTripRouting.lookup(request.getPoints(), weighting, locationIndex, params);\n+                ghRsp.addDebugInfo(\"idLookup:\" + sw.stop().getSeconds() + \"s\");\n+\n+                // use A* for round trips\n+                AlgorithmOptions roundTripAlgoOpts = AlgorithmOptions\n+                        .start(algoOpts)\n+                        .algorithm(Parameters.Algorithms.ASTAR_BI)\n+                        .build();\n+                roundTripAlgoOpts.getHints().putObject(Parameters.Algorithms.AStarBi.EPSILON, 2);\n+                FlexiblePathCalculator pathCalculator = createFlexiblePathCalculator(qResults, profile, roundTripAlgoOpts, disableLM);\n+                QueryGraph queryGraph = QueryGraph.create(ghStorage, qResults);\n+\n+                PathCalculatorWithAvoidedEdges roundTripPathCalculator = new PathCalculatorWithAvoidedEdges(pathCalculator);\n+                RoundTripRouting.Result result = RoundTripRouting.calcPaths(qResults, roundTripPathCalculator);\n+                // we merge the different legs of the roundtrip into one response path\n+                ResponsePath responsePath = concatenatePaths(request, weighting, queryGraph, result.paths, getWaypoints(qResults));\n+                ghRsp.add(responsePath);\n+                ghRsp.getHints().putObject(\"visited_nodes.sum\", result.visitedNodes);\n+                ghRsp.getHints().putObject(\"visited_nodes.average\", (float) result.visitedNodes / (qResults.size() - 1));\n+                return result.paths;\n+            } else if (ALT_ROUTE.equalsIgnoreCase(request.getAlgorithm())) {\n+                // ALTERNATIVE ROUTES\n+                if (request.getPoints().size() > 2)\n+                    throw new IllegalArgumentException(\"Currently alternative routes work only with start and end point. You tried to use: \" + request.getPoints().size() + \" points\");\n+                StopWatch sw = new StopWatch().start();\n+                List<QueryResult> qResults = ViaRouting.lookup(encodingManager, request.getPoints(), weighting, locationIndex, request.getSnapPreventions(), request.getPointHints());\n+                ghRsp.addDebugInfo(\"idLookup:\" + sw.stop().getSeconds() + \"s\");\n+                PathCalculator pathCalculator = createPathCalculator(qResults, profile, algoOpts, disableCH, disableLM);\n+                QueryGraph queryGraph = QueryGraph.create(ghStorage, qResults);\n+\n+                if (passThrough)\n+                    throw new IllegalArgumentException(\"Alternative paths and \" + PASS_THROUGH + \" at the same time is currently not supported\");\n+                if (!request.getCurbsides().isEmpty())\n+                    throw new IllegalArgumentException(\"Alternative paths do not support the \" + CURBSIDE + \" parameter yet\");\n+\n+                ViaRouting.Result result = ViaRouting.calcPaths(request.getPoints(), queryGraph, qResults, weighting.getFlagEncoder().getAccessEnc(), pathCalculator, request.getCurbsides(), forceCurbsides, request.getHeadings(), passThrough);\n+                if (result.paths.isEmpty())\n+                    throw new RuntimeException(\"Empty paths for alternative route calculation not expected\");\n+\n+                // each path represents a different alternative and we do the path merging for each of them\n+                PathMerger pathMerger = createPathMerger(request, weighting, queryGraph);\n+                for (Path path : result.paths) {\n+                    ResponsePath responsePath = new ResponsePath();\n+                    responsePath.setWaypoints(getWaypoints(qResults));\n+                    pathMerger.doWork(responsePath, Collections.singletonList(path), encodingManager, translationMap.getWithFallBack(request.getLocale()));\n+                    ghRsp.add(responsePath);\n+                }\n+                ghRsp.getHints().putObject(\"visited_nodes.sum\", result.visitedNodes);\n+                ghRsp.getHints().putObject(\"visited_nodes.average\", (float) result.visitedNodes / (qResults.size() - 1));\n+                return result.paths;\n+            } else {\n+                StopWatch sw = new StopWatch().start();\n+                List<QueryResult> qResults = ViaRouting.lookup(encodingManager, request.getPoints(), weighting, locationIndex, request.getSnapPreventions(), request.getPointHints());\n+                ghRsp.addDebugInfo(\"idLookup:\" + sw.stop().getSeconds() + \"s\");\n+                PathCalculator pathCalculator = createPathCalculator(qResults, profile, algoOpts, disableCH, disableLM);\n+                // (base) query graph used to resolve headings, curbsides etc. this is not necessarily the same thing as\n+                // the (possibly implementation specific) query graph used by PathCalculator\n+                QueryGraph queryGraph = QueryGraph.create(ghStorage, qResults);\n+                ViaRouting.Result result = ViaRouting.calcPaths(request.getPoints(), queryGraph, qResults, weighting.getFlagEncoder().getAccessEnc(), pathCalculator, request.getCurbsides(), forceCurbsides, request.getHeadings(), passThrough);\n+\n+                if (request.getPoints().size() != result.paths.size() + 1)\n+                    throw new RuntimeException(\"There should be exactly one more point than paths. points:\" + request.getPoints().size() + \", paths:\" + result.paths.size());\n+\n+                // here each path represents one leg of the via-route and we merge them all together into one response path\n+                ResponsePath responsePath = concatenatePaths(request, weighting, queryGraph, result.paths, getWaypoints(qResults));\n+                responsePath.addDebugInfo(result.debug);\n+                ghRsp.add(responsePath);\n+                ghRsp.getHints().putObject(\"visited_nodes.sum\", result.visitedNodes);\n+                ghRsp.getHints().putObject(\"visited_nodes.average\", (float) result.visitedNodes / (qResults.size() - 1));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzQzOTc1Ng=="}, "originalCommit": {"oid": "ee613b1352673023367f0dc8b14788a7b7887a36"}, "originalPosition": 202}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODIwMTQ4Mg==", "bodyText": "Ok lets leave it as it is for now and consider this later again", "url": "https://github.com/graphhopper/graphhopper/pull/2057#discussion_r438201482", "createdAt": "2020-06-10T15:13:40Z", "author": {"login": "easbar"}, "path": "core/src/main/java/com/graphhopper/routing/Router.java", "diffHunk": "@@ -102,111 +102,210 @@ public Router(GraphHopperStorage ghStorage, LocationIndex locationIndex,\n             if (!profile.isTurnCosts() && !request.getCurbsides().isEmpty())\n                 throw new IllegalArgumentException(\"To make use of the \" + CURBSIDE + \" parameter you need to use a profile that supports turn costs\" +\n                         \"\\nThe following profiles do support turn costs: \" + getTurnCostProfiles());\n-\n             // todo later: should we be able to control this using the edge_based parameter?\n-            TraversalMode tMode = profile.isTurnCosts() ? TraversalMode.EDGE_BASED : TraversalMode.NODE_BASED;\n-            RoutingAlgorithmFactory algorithmFactory = getAlgorithmFactory(profile.getName(), disableCH, disableLM);\n-            Weighting weighting;\n-            Graph graph = ghStorage;\n-            if (chEnabled && !disableCH) {\n-                if (!(algorithmFactory instanceof CHRoutingAlgorithmFactory))\n-                    throw new IllegalStateException(\"Although CH was enabled a non-CH algorithm factory was returned \" + algorithmFactory);\n-\n-                if (request.getHints().has(Parameters.Routing.BLOCK_AREA))\n-                    throw new IllegalArgumentException(\"When CH is enabled the \" + Parameters.Routing.BLOCK_AREA + \" cannot be specified\");\n-\n-                CHConfig chConfig = ((CHRoutingAlgorithmFactory) algorithmFactory).getCHConfig();\n-                weighting = chConfig.getWeighting();\n-                graph = chGraphs.get(chConfig.getName());\n-                // we know this exists because we already got the algorithm factory this way -> will be cleaned up soon\n-            } else {\n-                checkNonChMaxWaypointDistance(request.getPoints());\n-                final int uTurnCostsInt = request.getHints().getInt(Parameters.Routing.U_TURN_COSTS, INFINITE_U_TURN_COSTS);\n-                if (uTurnCostsInt != INFINITE_U_TURN_COSTS && !tMode.isEdgeBased()) {\n-                    throw new IllegalArgumentException(\"Finite u-turn costs can only be used for edge-based routing, you need to use a profile that\" +\n-                            \" supports turn costs. Currently the following profiles that support turn costs are available: \" + getTurnCostProfiles());\n-                }\n-                FlagEncoder encoder = encodingManager.getEncoder(profile.getVehicle());\n-                weighting = weightingFactory.createWeighting(profile, request.getHints(), false);\n-                if (request.getHints().has(Parameters.Routing.BLOCK_AREA))\n-                    weighting = new BlockAreaWeighting(weighting, GraphEdgeIdFinder.createBlockArea(ghStorage, locationIndex,\n-                            request.getPoints(), request.getHints(), DefaultEdgeFilter.allEdges(encoder)));\n+            TraversalMode traversalMode = profile.isTurnCosts() ? TraversalMode.EDGE_BASED : TraversalMode.NODE_BASED;\n+            final int uTurnCostsInt = request.getHints().getInt(Parameters.Routing.U_TURN_COSTS, INFINITE_U_TURN_COSTS);\n+            if (uTurnCostsInt != INFINITE_U_TURN_COSTS && !traversalMode.isEdgeBased()) {\n+                throw new IllegalArgumentException(\"Finite u-turn costs can only be used for edge-based routing, you need to use a profile that\" +\n+                        \" supports turn costs. Currently the following profiles that support turn costs are available: \" + getTurnCostProfiles());\n             }\n-            ghRsp.addDebugInfo(\"tmode:\" + tMode.toString());\n-\n-            RoutingTemplate routingTemplate = createRoutingTemplate(request, ghRsp, request.getAlgorithm(), weighting);\n-\n-            StopWatch sw = new StopWatch().start();\n-            List<QueryResult> qResults = routingTemplate.lookup(request.getPoints());\n-            ghRsp.addDebugInfo(\"idLookup:\" + sw.stop().getSeconds() + \"s\");\n-            if (ghRsp.hasErrors())\n-                return Collections.emptyList();\n-\n-            QueryGraph queryGraph = QueryGraph.create(graph, qResults);\n+            ghRsp.addDebugInfo(\"traversal-mode:\" + traversalMode.toString());\n+            final boolean passThrough = getPassThrough(request.getHints());\n+            final boolean forceCurbsides = request.getHints().getBool(FORCE_CURBSIDE, true);\n             int maxVisitedNodesForRequest = request.getHints().getInt(Parameters.Routing.MAX_VISITED_NODES, routerConfig.getMaxVisitedNodes());\n             if (maxVisitedNodesForRequest > routerConfig.getMaxVisitedNodes())\n                 throw new IllegalArgumentException(\"The max_visited_nodes parameter has to be below or equal to:\" + routerConfig.getMaxVisitedNodes());\n \n+            // determine weighting\n+            final boolean useCH = chEnabled && !disableCH;\n+            Weighting weighting = createWeighting(profile, request.getHints(), request.getPoints(), useCH);\n+\n             AlgorithmOptions algoOpts = AlgorithmOptions.start().\n                     algorithm(request.getAlgorithm()).\n-                    traversalMode(tMode).\n+                    traversalMode(traversalMode).\n                     weighting(weighting).\n                     maxVisitedNodes(maxVisitedNodesForRequest).\n                     hints(request.getHints()).\n                     build();\n \n-            // do the actual route calculation !\n-            List<Path> altPaths = routingTemplate.calcPaths(queryGraph, algorithmFactory, algoOpts);\n-\n-            boolean tmpEnableInstructions = request.getHints().getBool(Parameters.Routing.INSTRUCTIONS, encodingManager.isEnableInstructions());\n-            boolean tmpCalcPoints = request.getHints().getBool(Parameters.Routing.CALC_POINTS, routerConfig.isCalcPoints());\n-            double wayPointMaxDistance = request.getHints().getDouble(Parameters.Routing.WAY_POINT_MAX_DISTANCE, 1d);\n-\n-            DouglasPeucker peucker = new DouglasPeucker().setMaxDistance(wayPointMaxDistance);\n-            PathMerger pathMerger = new PathMerger(queryGraph.getBaseGraph(), weighting).\n-                    setCalcPoints(tmpCalcPoints).\n-                    setDouglasPeucker(peucker).\n-                    setEnableInstructions(tmpEnableInstructions).\n-                    setPathDetailsBuilders(pathDetailsBuilderFactory, request.getPathDetails()).\n-                    setSimplifyResponse(routerConfig.isSimplifyResponse() && wayPointMaxDistance > 0);\n-\n-            if (!request.getHeadings().isEmpty())\n-                pathMerger.setFavoredHeading(request.getHeadings().get(0));\n-\n-            routingTemplate.finish(pathMerger, translationMap.getWithFallBack(request.getLocale()));\n-            return altPaths;\n+            if (ROUND_TRIP.equalsIgnoreCase(request.getAlgorithm())) {\n+                // ROUND TRIP\n+                StopWatch sw = new StopWatch().start();\n+                double startHeading = request.getHeadings().isEmpty() ? Double.NaN : request.getHeadings().get(0);\n+                RoundTripRouting.Params params = new RoundTripRouting.Params(request.getHints(), startHeading, routerConfig.getMaxRoundTripRetries());\n+                List<QueryResult> qResults = RoundTripRouting.lookup(request.getPoints(), weighting, locationIndex, params);\n+                ghRsp.addDebugInfo(\"idLookup:\" + sw.stop().getSeconds() + \"s\");\n+\n+                // use A* for round trips\n+                AlgorithmOptions roundTripAlgoOpts = AlgorithmOptions\n+                        .start(algoOpts)\n+                        .algorithm(Parameters.Algorithms.ASTAR_BI)\n+                        .build();\n+                roundTripAlgoOpts.getHints().putObject(Parameters.Algorithms.AStarBi.EPSILON, 2);\n+                FlexiblePathCalculator pathCalculator = createFlexiblePathCalculator(qResults, profile, roundTripAlgoOpts, disableLM);\n+                QueryGraph queryGraph = QueryGraph.create(ghStorage, qResults);\n+\n+                PathCalculatorWithAvoidedEdges roundTripPathCalculator = new PathCalculatorWithAvoidedEdges(pathCalculator);\n+                RoundTripRouting.Result result = RoundTripRouting.calcPaths(qResults, roundTripPathCalculator);\n+                // we merge the different legs of the roundtrip into one response path\n+                ResponsePath responsePath = concatenatePaths(request, weighting, queryGraph, result.paths, getWaypoints(qResults));\n+                ghRsp.add(responsePath);\n+                ghRsp.getHints().putObject(\"visited_nodes.sum\", result.visitedNodes);\n+                ghRsp.getHints().putObject(\"visited_nodes.average\", (float) result.visitedNodes / (qResults.size() - 1));\n+                return result.paths;\n+            } else if (ALT_ROUTE.equalsIgnoreCase(request.getAlgorithm())) {\n+                // ALTERNATIVE ROUTES\n+                if (request.getPoints().size() > 2)\n+                    throw new IllegalArgumentException(\"Currently alternative routes work only with start and end point. You tried to use: \" + request.getPoints().size() + \" points\");\n+                StopWatch sw = new StopWatch().start();\n+                List<QueryResult> qResults = ViaRouting.lookup(encodingManager, request.getPoints(), weighting, locationIndex, request.getSnapPreventions(), request.getPointHints());\n+                ghRsp.addDebugInfo(\"idLookup:\" + sw.stop().getSeconds() + \"s\");\n+                PathCalculator pathCalculator = createPathCalculator(qResults, profile, algoOpts, disableCH, disableLM);\n+                QueryGraph queryGraph = QueryGraph.create(ghStorage, qResults);\n+\n+                if (passThrough)\n+                    throw new IllegalArgumentException(\"Alternative paths and \" + PASS_THROUGH + \" at the same time is currently not supported\");\n+                if (!request.getCurbsides().isEmpty())\n+                    throw new IllegalArgumentException(\"Alternative paths do not support the \" + CURBSIDE + \" parameter yet\");\n+\n+                ViaRouting.Result result = ViaRouting.calcPaths(request.getPoints(), queryGraph, qResults, weighting.getFlagEncoder().getAccessEnc(), pathCalculator, request.getCurbsides(), forceCurbsides, request.getHeadings(), passThrough);\n+                if (result.paths.isEmpty())\n+                    throw new RuntimeException(\"Empty paths for alternative route calculation not expected\");\n+\n+                // each path represents a different alternative and we do the path merging for each of them\n+                PathMerger pathMerger = createPathMerger(request, weighting, queryGraph);\n+                for (Path path : result.paths) {\n+                    ResponsePath responsePath = new ResponsePath();\n+                    responsePath.setWaypoints(getWaypoints(qResults));\n+                    pathMerger.doWork(responsePath, Collections.singletonList(path), encodingManager, translationMap.getWithFallBack(request.getLocale()));\n+                    ghRsp.add(responsePath);\n+                }\n+                ghRsp.getHints().putObject(\"visited_nodes.sum\", result.visitedNodes);\n+                ghRsp.getHints().putObject(\"visited_nodes.average\", (float) result.visitedNodes / (qResults.size() - 1));\n+                return result.paths;\n+            } else {\n+                StopWatch sw = new StopWatch().start();\n+                List<QueryResult> qResults = ViaRouting.lookup(encodingManager, request.getPoints(), weighting, locationIndex, request.getSnapPreventions(), request.getPointHints());\n+                ghRsp.addDebugInfo(\"idLookup:\" + sw.stop().getSeconds() + \"s\");\n+                PathCalculator pathCalculator = createPathCalculator(qResults, profile, algoOpts, disableCH, disableLM);\n+                // (base) query graph used to resolve headings, curbsides etc. this is not necessarily the same thing as\n+                // the (possibly implementation specific) query graph used by PathCalculator\n+                QueryGraph queryGraph = QueryGraph.create(ghStorage, qResults);\n+                ViaRouting.Result result = ViaRouting.calcPaths(request.getPoints(), queryGraph, qResults, weighting.getFlagEncoder().getAccessEnc(), pathCalculator, request.getCurbsides(), forceCurbsides, request.getHeadings(), passThrough);\n+\n+                if (request.getPoints().size() != result.paths.size() + 1)\n+                    throw new RuntimeException(\"There should be exactly one more point than paths. points:\" + request.getPoints().size() + \", paths:\" + result.paths.size());\n+\n+                // here each path represents one leg of the via-route and we merge them all together into one response path\n+                ResponsePath responsePath = concatenatePaths(request, weighting, queryGraph, result.paths, getWaypoints(qResults));\n+                responsePath.addDebugInfo(result.debug);\n+                ghRsp.add(responsePath);\n+                ghRsp.getHints().putObject(\"visited_nodes.sum\", result.visitedNodes);\n+                ghRsp.getHints().putObject(\"visited_nodes.average\", (float) result.visitedNodes / (qResults.size() - 1));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzQzOTc1Ng=="}, "originalCommit": {"oid": "ee613b1352673023367f0dc8b14788a7b7887a36"}, "originalPosition": 202}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcyNTE5NjEwOnYy", "diffSide": "RIGHT", "path": "core/src/main/java/com/graphhopper/routing/Router.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOVQxNDowMDowOFrOGhLiuA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMFQxMzo0NDozM1rOGh1hBA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzQ0NTMwNA==", "bodyText": "Can we somehow use this Router class (or something else in the future) to avoid the BlockAreaWeighting creation in SPTResource and IsochroneResource? (not really related to this PR)", "url": "https://github.com/graphhopper/graphhopper/pull/2057#discussion_r437445304", "createdAt": "2020-06-09T14:00:08Z", "author": {"login": "karussell"}, "path": "core/src/main/java/com/graphhopper/routing/Router.java", "diffHunk": "@@ -102,111 +102,210 @@ public Router(GraphHopperStorage ghStorage, LocationIndex locationIndex,\n             if (!profile.isTurnCosts() && !request.getCurbsides().isEmpty())\n                 throw new IllegalArgumentException(\"To make use of the \" + CURBSIDE + \" parameter you need to use a profile that supports turn costs\" +\n                         \"\\nThe following profiles do support turn costs: \" + getTurnCostProfiles());\n-\n             // todo later: should we be able to control this using the edge_based parameter?\n-            TraversalMode tMode = profile.isTurnCosts() ? TraversalMode.EDGE_BASED : TraversalMode.NODE_BASED;\n-            RoutingAlgorithmFactory algorithmFactory = getAlgorithmFactory(profile.getName(), disableCH, disableLM);\n-            Weighting weighting;\n-            Graph graph = ghStorage;\n-            if (chEnabled && !disableCH) {\n-                if (!(algorithmFactory instanceof CHRoutingAlgorithmFactory))\n-                    throw new IllegalStateException(\"Although CH was enabled a non-CH algorithm factory was returned \" + algorithmFactory);\n-\n-                if (request.getHints().has(Parameters.Routing.BLOCK_AREA))\n-                    throw new IllegalArgumentException(\"When CH is enabled the \" + Parameters.Routing.BLOCK_AREA + \" cannot be specified\");\n-\n-                CHConfig chConfig = ((CHRoutingAlgorithmFactory) algorithmFactory).getCHConfig();\n-                weighting = chConfig.getWeighting();\n-                graph = chGraphs.get(chConfig.getName());\n-                // we know this exists because we already got the algorithm factory this way -> will be cleaned up soon\n-            } else {\n-                checkNonChMaxWaypointDistance(request.getPoints());\n-                final int uTurnCostsInt = request.getHints().getInt(Parameters.Routing.U_TURN_COSTS, INFINITE_U_TURN_COSTS);\n-                if (uTurnCostsInt != INFINITE_U_TURN_COSTS && !tMode.isEdgeBased()) {\n-                    throw new IllegalArgumentException(\"Finite u-turn costs can only be used for edge-based routing, you need to use a profile that\" +\n-                            \" supports turn costs. Currently the following profiles that support turn costs are available: \" + getTurnCostProfiles());\n-                }\n-                FlagEncoder encoder = encodingManager.getEncoder(profile.getVehicle());\n-                weighting = weightingFactory.createWeighting(profile, request.getHints(), false);\n-                if (request.getHints().has(Parameters.Routing.BLOCK_AREA))\n-                    weighting = new BlockAreaWeighting(weighting, GraphEdgeIdFinder.createBlockArea(ghStorage, locationIndex,\n-                            request.getPoints(), request.getHints(), DefaultEdgeFilter.allEdges(encoder)));\n+            TraversalMode traversalMode = profile.isTurnCosts() ? TraversalMode.EDGE_BASED : TraversalMode.NODE_BASED;\n+            final int uTurnCostsInt = request.getHints().getInt(Parameters.Routing.U_TURN_COSTS, INFINITE_U_TURN_COSTS);\n+            if (uTurnCostsInt != INFINITE_U_TURN_COSTS && !traversalMode.isEdgeBased()) {\n+                throw new IllegalArgumentException(\"Finite u-turn costs can only be used for edge-based routing, you need to use a profile that\" +\n+                        \" supports turn costs. Currently the following profiles that support turn costs are available: \" + getTurnCostProfiles());\n             }\n-            ghRsp.addDebugInfo(\"tmode:\" + tMode.toString());\n-\n-            RoutingTemplate routingTemplate = createRoutingTemplate(request, ghRsp, request.getAlgorithm(), weighting);\n-\n-            StopWatch sw = new StopWatch().start();\n-            List<QueryResult> qResults = routingTemplate.lookup(request.getPoints());\n-            ghRsp.addDebugInfo(\"idLookup:\" + sw.stop().getSeconds() + \"s\");\n-            if (ghRsp.hasErrors())\n-                return Collections.emptyList();\n-\n-            QueryGraph queryGraph = QueryGraph.create(graph, qResults);\n+            ghRsp.addDebugInfo(\"traversal-mode:\" + traversalMode.toString());\n+            final boolean passThrough = getPassThrough(request.getHints());\n+            final boolean forceCurbsides = request.getHints().getBool(FORCE_CURBSIDE, true);\n             int maxVisitedNodesForRequest = request.getHints().getInt(Parameters.Routing.MAX_VISITED_NODES, routerConfig.getMaxVisitedNodes());\n             if (maxVisitedNodesForRequest > routerConfig.getMaxVisitedNodes())\n                 throw new IllegalArgumentException(\"The max_visited_nodes parameter has to be below or equal to:\" + routerConfig.getMaxVisitedNodes());\n \n+            // determine weighting\n+            final boolean useCH = chEnabled && !disableCH;\n+            Weighting weighting = createWeighting(profile, request.getHints(), request.getPoints(), useCH);\n+\n             AlgorithmOptions algoOpts = AlgorithmOptions.start().\n                     algorithm(request.getAlgorithm()).\n-                    traversalMode(tMode).\n+                    traversalMode(traversalMode).\n                     weighting(weighting).\n                     maxVisitedNodes(maxVisitedNodesForRequest).\n                     hints(request.getHints()).\n                     build();\n \n-            // do the actual route calculation !\n-            List<Path> altPaths = routingTemplate.calcPaths(queryGraph, algorithmFactory, algoOpts);\n-\n-            boolean tmpEnableInstructions = request.getHints().getBool(Parameters.Routing.INSTRUCTIONS, encodingManager.isEnableInstructions());\n-            boolean tmpCalcPoints = request.getHints().getBool(Parameters.Routing.CALC_POINTS, routerConfig.isCalcPoints());\n-            double wayPointMaxDistance = request.getHints().getDouble(Parameters.Routing.WAY_POINT_MAX_DISTANCE, 1d);\n-\n-            DouglasPeucker peucker = new DouglasPeucker().setMaxDistance(wayPointMaxDistance);\n-            PathMerger pathMerger = new PathMerger(queryGraph.getBaseGraph(), weighting).\n-                    setCalcPoints(tmpCalcPoints).\n-                    setDouglasPeucker(peucker).\n-                    setEnableInstructions(tmpEnableInstructions).\n-                    setPathDetailsBuilders(pathDetailsBuilderFactory, request.getPathDetails()).\n-                    setSimplifyResponse(routerConfig.isSimplifyResponse() && wayPointMaxDistance > 0);\n-\n-            if (!request.getHeadings().isEmpty())\n-                pathMerger.setFavoredHeading(request.getHeadings().get(0));\n-\n-            routingTemplate.finish(pathMerger, translationMap.getWithFallBack(request.getLocale()));\n-            return altPaths;\n+            if (ROUND_TRIP.equalsIgnoreCase(request.getAlgorithm())) {\n+                // ROUND TRIP\n+                StopWatch sw = new StopWatch().start();\n+                double startHeading = request.getHeadings().isEmpty() ? Double.NaN : request.getHeadings().get(0);\n+                RoundTripRouting.Params params = new RoundTripRouting.Params(request.getHints(), startHeading, routerConfig.getMaxRoundTripRetries());\n+                List<QueryResult> qResults = RoundTripRouting.lookup(request.getPoints(), weighting, locationIndex, params);\n+                ghRsp.addDebugInfo(\"idLookup:\" + sw.stop().getSeconds() + \"s\");\n+\n+                // use A* for round trips\n+                AlgorithmOptions roundTripAlgoOpts = AlgorithmOptions\n+                        .start(algoOpts)\n+                        .algorithm(Parameters.Algorithms.ASTAR_BI)\n+                        .build();\n+                roundTripAlgoOpts.getHints().putObject(Parameters.Algorithms.AStarBi.EPSILON, 2);\n+                FlexiblePathCalculator pathCalculator = createFlexiblePathCalculator(qResults, profile, roundTripAlgoOpts, disableLM);\n+                QueryGraph queryGraph = QueryGraph.create(ghStorage, qResults);\n+\n+                PathCalculatorWithAvoidedEdges roundTripPathCalculator = new PathCalculatorWithAvoidedEdges(pathCalculator);\n+                RoundTripRouting.Result result = RoundTripRouting.calcPaths(qResults, roundTripPathCalculator);\n+                // we merge the different legs of the roundtrip into one response path\n+                ResponsePath responsePath = concatenatePaths(request, weighting, queryGraph, result.paths, getWaypoints(qResults));\n+                ghRsp.add(responsePath);\n+                ghRsp.getHints().putObject(\"visited_nodes.sum\", result.visitedNodes);\n+                ghRsp.getHints().putObject(\"visited_nodes.average\", (float) result.visitedNodes / (qResults.size() - 1));\n+                return result.paths;\n+            } else if (ALT_ROUTE.equalsIgnoreCase(request.getAlgorithm())) {\n+                // ALTERNATIVE ROUTES\n+                if (request.getPoints().size() > 2)\n+                    throw new IllegalArgumentException(\"Currently alternative routes work only with start and end point. You tried to use: \" + request.getPoints().size() + \" points\");\n+                StopWatch sw = new StopWatch().start();\n+                List<QueryResult> qResults = ViaRouting.lookup(encodingManager, request.getPoints(), weighting, locationIndex, request.getSnapPreventions(), request.getPointHints());\n+                ghRsp.addDebugInfo(\"idLookup:\" + sw.stop().getSeconds() + \"s\");\n+                PathCalculator pathCalculator = createPathCalculator(qResults, profile, algoOpts, disableCH, disableLM);\n+                QueryGraph queryGraph = QueryGraph.create(ghStorage, qResults);\n+\n+                if (passThrough)\n+                    throw new IllegalArgumentException(\"Alternative paths and \" + PASS_THROUGH + \" at the same time is currently not supported\");\n+                if (!request.getCurbsides().isEmpty())\n+                    throw new IllegalArgumentException(\"Alternative paths do not support the \" + CURBSIDE + \" parameter yet\");\n+\n+                ViaRouting.Result result = ViaRouting.calcPaths(request.getPoints(), queryGraph, qResults, weighting.getFlagEncoder().getAccessEnc(), pathCalculator, request.getCurbsides(), forceCurbsides, request.getHeadings(), passThrough);\n+                if (result.paths.isEmpty())\n+                    throw new RuntimeException(\"Empty paths for alternative route calculation not expected\");\n+\n+                // each path represents a different alternative and we do the path merging for each of them\n+                PathMerger pathMerger = createPathMerger(request, weighting, queryGraph);\n+                for (Path path : result.paths) {\n+                    ResponsePath responsePath = new ResponsePath();\n+                    responsePath.setWaypoints(getWaypoints(qResults));\n+                    pathMerger.doWork(responsePath, Collections.singletonList(path), encodingManager, translationMap.getWithFallBack(request.getLocale()));\n+                    ghRsp.add(responsePath);\n+                }\n+                ghRsp.getHints().putObject(\"visited_nodes.sum\", result.visitedNodes);\n+                ghRsp.getHints().putObject(\"visited_nodes.average\", (float) result.visitedNodes / (qResults.size() - 1));\n+                return result.paths;\n+            } else {\n+                StopWatch sw = new StopWatch().start();\n+                List<QueryResult> qResults = ViaRouting.lookup(encodingManager, request.getPoints(), weighting, locationIndex, request.getSnapPreventions(), request.getPointHints());\n+                ghRsp.addDebugInfo(\"idLookup:\" + sw.stop().getSeconds() + \"s\");\n+                PathCalculator pathCalculator = createPathCalculator(qResults, profile, algoOpts, disableCH, disableLM);\n+                // (base) query graph used to resolve headings, curbsides etc. this is not necessarily the same thing as\n+                // the (possibly implementation specific) query graph used by PathCalculator\n+                QueryGraph queryGraph = QueryGraph.create(ghStorage, qResults);\n+                ViaRouting.Result result = ViaRouting.calcPaths(request.getPoints(), queryGraph, qResults, weighting.getFlagEncoder().getAccessEnc(), pathCalculator, request.getCurbsides(), forceCurbsides, request.getHeadings(), passThrough);\n+\n+                if (request.getPoints().size() != result.paths.size() + 1)\n+                    throw new RuntimeException(\"There should be exactly one more point than paths. points:\" + request.getPoints().size() + \", paths:\" + result.paths.size());\n+\n+                // here each path represents one leg of the via-route and we merge them all together into one response path\n+                ResponsePath responsePath = concatenatePaths(request, weighting, queryGraph, result.paths, getWaypoints(qResults));\n+                responsePath.addDebugInfo(result.debug);\n+                ghRsp.add(responsePath);\n+                ghRsp.getHints().putObject(\"visited_nodes.sum\", result.visitedNodes);\n+                ghRsp.getHints().putObject(\"visited_nodes.average\", (float) result.visitedNodes / (qResults.size() - 1));\n+                return result.paths;\n+            }\n+        } catch (MultiException ex) {\n+            for (Throwable t : ex.getErrors()) {\n+                ghRsp.addError(t);\n+            }\n+            return emptyList();\n         } catch (IllegalArgumentException ex) {\n             ghRsp.addError(ex);\n-            return Collections.emptyList();\n+            return emptyList();\n         }\n     }\n \n-    public RoutingAlgorithmFactory getAlgorithmFactory(String profile, boolean disableCH, boolean disableLM) {\n-        if (chEnabled && disableCH && !routerConfig.isCHDisablingAllowed()) {\n-            throw new IllegalArgumentException(\"Disabling CH is not allowed on the server side\");\n+    private Weighting createWeighting(Profile profile, PMap requestHints, List<GHPoint> points, boolean forCH) {\n+        if (forCH) {\n+            // todo: do not allow things like short_fastest.distance_factor or u_turn_costs unless CH is disabled\n+            // and only under certain conditions for LM\n+\n+            // the request hints are ignored for CH as we cannot change the profile after the preparation like this.\n+            // the weighting here has to be created the same way as we did when we created the weighting for the preparation\n+            return weightingFactory.createWeighting(profile, new PMap(), false);\n+        } else {\n+            Weighting weighting = weightingFactory.createWeighting(profile, requestHints, false);\n+            if (requestHints.has(Parameters.Routing.BLOCK_AREA)) {\n+                FlagEncoder encoder = encodingManager.getEncoder(profile.getVehicle());\n+                GraphEdgeIdFinder.BlockArea blockArea = GraphEdgeIdFinder.createBlockArea(ghStorage, locationIndex,\n+                        points, requestHints, DefaultEdgeFilter.allEdges(encoder));\n+                weighting = new BlockAreaWeighting(weighting, blockArea);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ee613b1352673023367f0dc8b14788a7b7887a36"}, "originalPosition": 234}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzcxODIzMQ==", "bodyText": "To me it looks like the block area stuff seems to belong to the weighting factory (but of course its not entirely clear because we need the 'points' here...). If all this was in weighting factory SPT/Isochrone could just use it.\nRouter is kind of 'the thing that does routing when everything is ready', so in theory it might be the right place to do map matching, isochrone etc. as well. Or maybe not and we will just have similar classes next to Router (MapMatcher, Isochrone*thing* etc.). They all have in common that they need to have access to the same 'infrastructure' like the routing graphs, profiles etc.", "url": "https://github.com/graphhopper/graphhopper/pull/2057#discussion_r437718231", "createdAt": "2020-06-09T20:58:26Z", "author": {"login": "easbar"}, "path": "core/src/main/java/com/graphhopper/routing/Router.java", "diffHunk": "@@ -102,111 +102,210 @@ public Router(GraphHopperStorage ghStorage, LocationIndex locationIndex,\n             if (!profile.isTurnCosts() && !request.getCurbsides().isEmpty())\n                 throw new IllegalArgumentException(\"To make use of the \" + CURBSIDE + \" parameter you need to use a profile that supports turn costs\" +\n                         \"\\nThe following profiles do support turn costs: \" + getTurnCostProfiles());\n-\n             // todo later: should we be able to control this using the edge_based parameter?\n-            TraversalMode tMode = profile.isTurnCosts() ? TraversalMode.EDGE_BASED : TraversalMode.NODE_BASED;\n-            RoutingAlgorithmFactory algorithmFactory = getAlgorithmFactory(profile.getName(), disableCH, disableLM);\n-            Weighting weighting;\n-            Graph graph = ghStorage;\n-            if (chEnabled && !disableCH) {\n-                if (!(algorithmFactory instanceof CHRoutingAlgorithmFactory))\n-                    throw new IllegalStateException(\"Although CH was enabled a non-CH algorithm factory was returned \" + algorithmFactory);\n-\n-                if (request.getHints().has(Parameters.Routing.BLOCK_AREA))\n-                    throw new IllegalArgumentException(\"When CH is enabled the \" + Parameters.Routing.BLOCK_AREA + \" cannot be specified\");\n-\n-                CHConfig chConfig = ((CHRoutingAlgorithmFactory) algorithmFactory).getCHConfig();\n-                weighting = chConfig.getWeighting();\n-                graph = chGraphs.get(chConfig.getName());\n-                // we know this exists because we already got the algorithm factory this way -> will be cleaned up soon\n-            } else {\n-                checkNonChMaxWaypointDistance(request.getPoints());\n-                final int uTurnCostsInt = request.getHints().getInt(Parameters.Routing.U_TURN_COSTS, INFINITE_U_TURN_COSTS);\n-                if (uTurnCostsInt != INFINITE_U_TURN_COSTS && !tMode.isEdgeBased()) {\n-                    throw new IllegalArgumentException(\"Finite u-turn costs can only be used for edge-based routing, you need to use a profile that\" +\n-                            \" supports turn costs. Currently the following profiles that support turn costs are available: \" + getTurnCostProfiles());\n-                }\n-                FlagEncoder encoder = encodingManager.getEncoder(profile.getVehicle());\n-                weighting = weightingFactory.createWeighting(profile, request.getHints(), false);\n-                if (request.getHints().has(Parameters.Routing.BLOCK_AREA))\n-                    weighting = new BlockAreaWeighting(weighting, GraphEdgeIdFinder.createBlockArea(ghStorage, locationIndex,\n-                            request.getPoints(), request.getHints(), DefaultEdgeFilter.allEdges(encoder)));\n+            TraversalMode traversalMode = profile.isTurnCosts() ? TraversalMode.EDGE_BASED : TraversalMode.NODE_BASED;\n+            final int uTurnCostsInt = request.getHints().getInt(Parameters.Routing.U_TURN_COSTS, INFINITE_U_TURN_COSTS);\n+            if (uTurnCostsInt != INFINITE_U_TURN_COSTS && !traversalMode.isEdgeBased()) {\n+                throw new IllegalArgumentException(\"Finite u-turn costs can only be used for edge-based routing, you need to use a profile that\" +\n+                        \" supports turn costs. Currently the following profiles that support turn costs are available: \" + getTurnCostProfiles());\n             }\n-            ghRsp.addDebugInfo(\"tmode:\" + tMode.toString());\n-\n-            RoutingTemplate routingTemplate = createRoutingTemplate(request, ghRsp, request.getAlgorithm(), weighting);\n-\n-            StopWatch sw = new StopWatch().start();\n-            List<QueryResult> qResults = routingTemplate.lookup(request.getPoints());\n-            ghRsp.addDebugInfo(\"idLookup:\" + sw.stop().getSeconds() + \"s\");\n-            if (ghRsp.hasErrors())\n-                return Collections.emptyList();\n-\n-            QueryGraph queryGraph = QueryGraph.create(graph, qResults);\n+            ghRsp.addDebugInfo(\"traversal-mode:\" + traversalMode.toString());\n+            final boolean passThrough = getPassThrough(request.getHints());\n+            final boolean forceCurbsides = request.getHints().getBool(FORCE_CURBSIDE, true);\n             int maxVisitedNodesForRequest = request.getHints().getInt(Parameters.Routing.MAX_VISITED_NODES, routerConfig.getMaxVisitedNodes());\n             if (maxVisitedNodesForRequest > routerConfig.getMaxVisitedNodes())\n                 throw new IllegalArgumentException(\"The max_visited_nodes parameter has to be below or equal to:\" + routerConfig.getMaxVisitedNodes());\n \n+            // determine weighting\n+            final boolean useCH = chEnabled && !disableCH;\n+            Weighting weighting = createWeighting(profile, request.getHints(), request.getPoints(), useCH);\n+\n             AlgorithmOptions algoOpts = AlgorithmOptions.start().\n                     algorithm(request.getAlgorithm()).\n-                    traversalMode(tMode).\n+                    traversalMode(traversalMode).\n                     weighting(weighting).\n                     maxVisitedNodes(maxVisitedNodesForRequest).\n                     hints(request.getHints()).\n                     build();\n \n-            // do the actual route calculation !\n-            List<Path> altPaths = routingTemplate.calcPaths(queryGraph, algorithmFactory, algoOpts);\n-\n-            boolean tmpEnableInstructions = request.getHints().getBool(Parameters.Routing.INSTRUCTIONS, encodingManager.isEnableInstructions());\n-            boolean tmpCalcPoints = request.getHints().getBool(Parameters.Routing.CALC_POINTS, routerConfig.isCalcPoints());\n-            double wayPointMaxDistance = request.getHints().getDouble(Parameters.Routing.WAY_POINT_MAX_DISTANCE, 1d);\n-\n-            DouglasPeucker peucker = new DouglasPeucker().setMaxDistance(wayPointMaxDistance);\n-            PathMerger pathMerger = new PathMerger(queryGraph.getBaseGraph(), weighting).\n-                    setCalcPoints(tmpCalcPoints).\n-                    setDouglasPeucker(peucker).\n-                    setEnableInstructions(tmpEnableInstructions).\n-                    setPathDetailsBuilders(pathDetailsBuilderFactory, request.getPathDetails()).\n-                    setSimplifyResponse(routerConfig.isSimplifyResponse() && wayPointMaxDistance > 0);\n-\n-            if (!request.getHeadings().isEmpty())\n-                pathMerger.setFavoredHeading(request.getHeadings().get(0));\n-\n-            routingTemplate.finish(pathMerger, translationMap.getWithFallBack(request.getLocale()));\n-            return altPaths;\n+            if (ROUND_TRIP.equalsIgnoreCase(request.getAlgorithm())) {\n+                // ROUND TRIP\n+                StopWatch sw = new StopWatch().start();\n+                double startHeading = request.getHeadings().isEmpty() ? Double.NaN : request.getHeadings().get(0);\n+                RoundTripRouting.Params params = new RoundTripRouting.Params(request.getHints(), startHeading, routerConfig.getMaxRoundTripRetries());\n+                List<QueryResult> qResults = RoundTripRouting.lookup(request.getPoints(), weighting, locationIndex, params);\n+                ghRsp.addDebugInfo(\"idLookup:\" + sw.stop().getSeconds() + \"s\");\n+\n+                // use A* for round trips\n+                AlgorithmOptions roundTripAlgoOpts = AlgorithmOptions\n+                        .start(algoOpts)\n+                        .algorithm(Parameters.Algorithms.ASTAR_BI)\n+                        .build();\n+                roundTripAlgoOpts.getHints().putObject(Parameters.Algorithms.AStarBi.EPSILON, 2);\n+                FlexiblePathCalculator pathCalculator = createFlexiblePathCalculator(qResults, profile, roundTripAlgoOpts, disableLM);\n+                QueryGraph queryGraph = QueryGraph.create(ghStorage, qResults);\n+\n+                PathCalculatorWithAvoidedEdges roundTripPathCalculator = new PathCalculatorWithAvoidedEdges(pathCalculator);\n+                RoundTripRouting.Result result = RoundTripRouting.calcPaths(qResults, roundTripPathCalculator);\n+                // we merge the different legs of the roundtrip into one response path\n+                ResponsePath responsePath = concatenatePaths(request, weighting, queryGraph, result.paths, getWaypoints(qResults));\n+                ghRsp.add(responsePath);\n+                ghRsp.getHints().putObject(\"visited_nodes.sum\", result.visitedNodes);\n+                ghRsp.getHints().putObject(\"visited_nodes.average\", (float) result.visitedNodes / (qResults.size() - 1));\n+                return result.paths;\n+            } else if (ALT_ROUTE.equalsIgnoreCase(request.getAlgorithm())) {\n+                // ALTERNATIVE ROUTES\n+                if (request.getPoints().size() > 2)\n+                    throw new IllegalArgumentException(\"Currently alternative routes work only with start and end point. You tried to use: \" + request.getPoints().size() + \" points\");\n+                StopWatch sw = new StopWatch().start();\n+                List<QueryResult> qResults = ViaRouting.lookup(encodingManager, request.getPoints(), weighting, locationIndex, request.getSnapPreventions(), request.getPointHints());\n+                ghRsp.addDebugInfo(\"idLookup:\" + sw.stop().getSeconds() + \"s\");\n+                PathCalculator pathCalculator = createPathCalculator(qResults, profile, algoOpts, disableCH, disableLM);\n+                QueryGraph queryGraph = QueryGraph.create(ghStorage, qResults);\n+\n+                if (passThrough)\n+                    throw new IllegalArgumentException(\"Alternative paths and \" + PASS_THROUGH + \" at the same time is currently not supported\");\n+                if (!request.getCurbsides().isEmpty())\n+                    throw new IllegalArgumentException(\"Alternative paths do not support the \" + CURBSIDE + \" parameter yet\");\n+\n+                ViaRouting.Result result = ViaRouting.calcPaths(request.getPoints(), queryGraph, qResults, weighting.getFlagEncoder().getAccessEnc(), pathCalculator, request.getCurbsides(), forceCurbsides, request.getHeadings(), passThrough);\n+                if (result.paths.isEmpty())\n+                    throw new RuntimeException(\"Empty paths for alternative route calculation not expected\");\n+\n+                // each path represents a different alternative and we do the path merging for each of them\n+                PathMerger pathMerger = createPathMerger(request, weighting, queryGraph);\n+                for (Path path : result.paths) {\n+                    ResponsePath responsePath = new ResponsePath();\n+                    responsePath.setWaypoints(getWaypoints(qResults));\n+                    pathMerger.doWork(responsePath, Collections.singletonList(path), encodingManager, translationMap.getWithFallBack(request.getLocale()));\n+                    ghRsp.add(responsePath);\n+                }\n+                ghRsp.getHints().putObject(\"visited_nodes.sum\", result.visitedNodes);\n+                ghRsp.getHints().putObject(\"visited_nodes.average\", (float) result.visitedNodes / (qResults.size() - 1));\n+                return result.paths;\n+            } else {\n+                StopWatch sw = new StopWatch().start();\n+                List<QueryResult> qResults = ViaRouting.lookup(encodingManager, request.getPoints(), weighting, locationIndex, request.getSnapPreventions(), request.getPointHints());\n+                ghRsp.addDebugInfo(\"idLookup:\" + sw.stop().getSeconds() + \"s\");\n+                PathCalculator pathCalculator = createPathCalculator(qResults, profile, algoOpts, disableCH, disableLM);\n+                // (base) query graph used to resolve headings, curbsides etc. this is not necessarily the same thing as\n+                // the (possibly implementation specific) query graph used by PathCalculator\n+                QueryGraph queryGraph = QueryGraph.create(ghStorage, qResults);\n+                ViaRouting.Result result = ViaRouting.calcPaths(request.getPoints(), queryGraph, qResults, weighting.getFlagEncoder().getAccessEnc(), pathCalculator, request.getCurbsides(), forceCurbsides, request.getHeadings(), passThrough);\n+\n+                if (request.getPoints().size() != result.paths.size() + 1)\n+                    throw new RuntimeException(\"There should be exactly one more point than paths. points:\" + request.getPoints().size() + \", paths:\" + result.paths.size());\n+\n+                // here each path represents one leg of the via-route and we merge them all together into one response path\n+                ResponsePath responsePath = concatenatePaths(request, weighting, queryGraph, result.paths, getWaypoints(qResults));\n+                responsePath.addDebugInfo(result.debug);\n+                ghRsp.add(responsePath);\n+                ghRsp.getHints().putObject(\"visited_nodes.sum\", result.visitedNodes);\n+                ghRsp.getHints().putObject(\"visited_nodes.average\", (float) result.visitedNodes / (qResults.size() - 1));\n+                return result.paths;\n+            }\n+        } catch (MultiException ex) {\n+            for (Throwable t : ex.getErrors()) {\n+                ghRsp.addError(t);\n+            }\n+            return emptyList();\n         } catch (IllegalArgumentException ex) {\n             ghRsp.addError(ex);\n-            return Collections.emptyList();\n+            return emptyList();\n         }\n     }\n \n-    public RoutingAlgorithmFactory getAlgorithmFactory(String profile, boolean disableCH, boolean disableLM) {\n-        if (chEnabled && disableCH && !routerConfig.isCHDisablingAllowed()) {\n-            throw new IllegalArgumentException(\"Disabling CH is not allowed on the server side\");\n+    private Weighting createWeighting(Profile profile, PMap requestHints, List<GHPoint> points, boolean forCH) {\n+        if (forCH) {\n+            // todo: do not allow things like short_fastest.distance_factor or u_turn_costs unless CH is disabled\n+            // and only under certain conditions for LM\n+\n+            // the request hints are ignored for CH as we cannot change the profile after the preparation like this.\n+            // the weighting here has to be created the same way as we did when we created the weighting for the preparation\n+            return weightingFactory.createWeighting(profile, new PMap(), false);\n+        } else {\n+            Weighting weighting = weightingFactory.createWeighting(profile, requestHints, false);\n+            if (requestHints.has(Parameters.Routing.BLOCK_AREA)) {\n+                FlagEncoder encoder = encodingManager.getEncoder(profile.getVehicle());\n+                GraphEdgeIdFinder.BlockArea blockArea = GraphEdgeIdFinder.createBlockArea(ghStorage, locationIndex,\n+                        points, requestHints, DefaultEdgeFilter.allEdges(encoder));\n+                weighting = new BlockAreaWeighting(weighting, blockArea);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzQ0NTMwNA=="}, "originalCommit": {"oid": "ee613b1352673023367f0dc8b14788a7b7887a36"}, "originalPosition": 234}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODEzMjk5Ng==", "bodyText": "Yes, it is a bit ugly (-> unrelated to this PR -> will resolve conversation)", "url": "https://github.com/graphhopper/graphhopper/pull/2057#discussion_r438132996", "createdAt": "2020-06-10T13:44:33Z", "author": {"login": "karussell"}, "path": "core/src/main/java/com/graphhopper/routing/Router.java", "diffHunk": "@@ -102,111 +102,210 @@ public Router(GraphHopperStorage ghStorage, LocationIndex locationIndex,\n             if (!profile.isTurnCosts() && !request.getCurbsides().isEmpty())\n                 throw new IllegalArgumentException(\"To make use of the \" + CURBSIDE + \" parameter you need to use a profile that supports turn costs\" +\n                         \"\\nThe following profiles do support turn costs: \" + getTurnCostProfiles());\n-\n             // todo later: should we be able to control this using the edge_based parameter?\n-            TraversalMode tMode = profile.isTurnCosts() ? TraversalMode.EDGE_BASED : TraversalMode.NODE_BASED;\n-            RoutingAlgorithmFactory algorithmFactory = getAlgorithmFactory(profile.getName(), disableCH, disableLM);\n-            Weighting weighting;\n-            Graph graph = ghStorage;\n-            if (chEnabled && !disableCH) {\n-                if (!(algorithmFactory instanceof CHRoutingAlgorithmFactory))\n-                    throw new IllegalStateException(\"Although CH was enabled a non-CH algorithm factory was returned \" + algorithmFactory);\n-\n-                if (request.getHints().has(Parameters.Routing.BLOCK_AREA))\n-                    throw new IllegalArgumentException(\"When CH is enabled the \" + Parameters.Routing.BLOCK_AREA + \" cannot be specified\");\n-\n-                CHConfig chConfig = ((CHRoutingAlgorithmFactory) algorithmFactory).getCHConfig();\n-                weighting = chConfig.getWeighting();\n-                graph = chGraphs.get(chConfig.getName());\n-                // we know this exists because we already got the algorithm factory this way -> will be cleaned up soon\n-            } else {\n-                checkNonChMaxWaypointDistance(request.getPoints());\n-                final int uTurnCostsInt = request.getHints().getInt(Parameters.Routing.U_TURN_COSTS, INFINITE_U_TURN_COSTS);\n-                if (uTurnCostsInt != INFINITE_U_TURN_COSTS && !tMode.isEdgeBased()) {\n-                    throw new IllegalArgumentException(\"Finite u-turn costs can only be used for edge-based routing, you need to use a profile that\" +\n-                            \" supports turn costs. Currently the following profiles that support turn costs are available: \" + getTurnCostProfiles());\n-                }\n-                FlagEncoder encoder = encodingManager.getEncoder(profile.getVehicle());\n-                weighting = weightingFactory.createWeighting(profile, request.getHints(), false);\n-                if (request.getHints().has(Parameters.Routing.BLOCK_AREA))\n-                    weighting = new BlockAreaWeighting(weighting, GraphEdgeIdFinder.createBlockArea(ghStorage, locationIndex,\n-                            request.getPoints(), request.getHints(), DefaultEdgeFilter.allEdges(encoder)));\n+            TraversalMode traversalMode = profile.isTurnCosts() ? TraversalMode.EDGE_BASED : TraversalMode.NODE_BASED;\n+            final int uTurnCostsInt = request.getHints().getInt(Parameters.Routing.U_TURN_COSTS, INFINITE_U_TURN_COSTS);\n+            if (uTurnCostsInt != INFINITE_U_TURN_COSTS && !traversalMode.isEdgeBased()) {\n+                throw new IllegalArgumentException(\"Finite u-turn costs can only be used for edge-based routing, you need to use a profile that\" +\n+                        \" supports turn costs. Currently the following profiles that support turn costs are available: \" + getTurnCostProfiles());\n             }\n-            ghRsp.addDebugInfo(\"tmode:\" + tMode.toString());\n-\n-            RoutingTemplate routingTemplate = createRoutingTemplate(request, ghRsp, request.getAlgorithm(), weighting);\n-\n-            StopWatch sw = new StopWatch().start();\n-            List<QueryResult> qResults = routingTemplate.lookup(request.getPoints());\n-            ghRsp.addDebugInfo(\"idLookup:\" + sw.stop().getSeconds() + \"s\");\n-            if (ghRsp.hasErrors())\n-                return Collections.emptyList();\n-\n-            QueryGraph queryGraph = QueryGraph.create(graph, qResults);\n+            ghRsp.addDebugInfo(\"traversal-mode:\" + traversalMode.toString());\n+            final boolean passThrough = getPassThrough(request.getHints());\n+            final boolean forceCurbsides = request.getHints().getBool(FORCE_CURBSIDE, true);\n             int maxVisitedNodesForRequest = request.getHints().getInt(Parameters.Routing.MAX_VISITED_NODES, routerConfig.getMaxVisitedNodes());\n             if (maxVisitedNodesForRequest > routerConfig.getMaxVisitedNodes())\n                 throw new IllegalArgumentException(\"The max_visited_nodes parameter has to be below or equal to:\" + routerConfig.getMaxVisitedNodes());\n \n+            // determine weighting\n+            final boolean useCH = chEnabled && !disableCH;\n+            Weighting weighting = createWeighting(profile, request.getHints(), request.getPoints(), useCH);\n+\n             AlgorithmOptions algoOpts = AlgorithmOptions.start().\n                     algorithm(request.getAlgorithm()).\n-                    traversalMode(tMode).\n+                    traversalMode(traversalMode).\n                     weighting(weighting).\n                     maxVisitedNodes(maxVisitedNodesForRequest).\n                     hints(request.getHints()).\n                     build();\n \n-            // do the actual route calculation !\n-            List<Path> altPaths = routingTemplate.calcPaths(queryGraph, algorithmFactory, algoOpts);\n-\n-            boolean tmpEnableInstructions = request.getHints().getBool(Parameters.Routing.INSTRUCTIONS, encodingManager.isEnableInstructions());\n-            boolean tmpCalcPoints = request.getHints().getBool(Parameters.Routing.CALC_POINTS, routerConfig.isCalcPoints());\n-            double wayPointMaxDistance = request.getHints().getDouble(Parameters.Routing.WAY_POINT_MAX_DISTANCE, 1d);\n-\n-            DouglasPeucker peucker = new DouglasPeucker().setMaxDistance(wayPointMaxDistance);\n-            PathMerger pathMerger = new PathMerger(queryGraph.getBaseGraph(), weighting).\n-                    setCalcPoints(tmpCalcPoints).\n-                    setDouglasPeucker(peucker).\n-                    setEnableInstructions(tmpEnableInstructions).\n-                    setPathDetailsBuilders(pathDetailsBuilderFactory, request.getPathDetails()).\n-                    setSimplifyResponse(routerConfig.isSimplifyResponse() && wayPointMaxDistance > 0);\n-\n-            if (!request.getHeadings().isEmpty())\n-                pathMerger.setFavoredHeading(request.getHeadings().get(0));\n-\n-            routingTemplate.finish(pathMerger, translationMap.getWithFallBack(request.getLocale()));\n-            return altPaths;\n+            if (ROUND_TRIP.equalsIgnoreCase(request.getAlgorithm())) {\n+                // ROUND TRIP\n+                StopWatch sw = new StopWatch().start();\n+                double startHeading = request.getHeadings().isEmpty() ? Double.NaN : request.getHeadings().get(0);\n+                RoundTripRouting.Params params = new RoundTripRouting.Params(request.getHints(), startHeading, routerConfig.getMaxRoundTripRetries());\n+                List<QueryResult> qResults = RoundTripRouting.lookup(request.getPoints(), weighting, locationIndex, params);\n+                ghRsp.addDebugInfo(\"idLookup:\" + sw.stop().getSeconds() + \"s\");\n+\n+                // use A* for round trips\n+                AlgorithmOptions roundTripAlgoOpts = AlgorithmOptions\n+                        .start(algoOpts)\n+                        .algorithm(Parameters.Algorithms.ASTAR_BI)\n+                        .build();\n+                roundTripAlgoOpts.getHints().putObject(Parameters.Algorithms.AStarBi.EPSILON, 2);\n+                FlexiblePathCalculator pathCalculator = createFlexiblePathCalculator(qResults, profile, roundTripAlgoOpts, disableLM);\n+                QueryGraph queryGraph = QueryGraph.create(ghStorage, qResults);\n+\n+                PathCalculatorWithAvoidedEdges roundTripPathCalculator = new PathCalculatorWithAvoidedEdges(pathCalculator);\n+                RoundTripRouting.Result result = RoundTripRouting.calcPaths(qResults, roundTripPathCalculator);\n+                // we merge the different legs of the roundtrip into one response path\n+                ResponsePath responsePath = concatenatePaths(request, weighting, queryGraph, result.paths, getWaypoints(qResults));\n+                ghRsp.add(responsePath);\n+                ghRsp.getHints().putObject(\"visited_nodes.sum\", result.visitedNodes);\n+                ghRsp.getHints().putObject(\"visited_nodes.average\", (float) result.visitedNodes / (qResults.size() - 1));\n+                return result.paths;\n+            } else if (ALT_ROUTE.equalsIgnoreCase(request.getAlgorithm())) {\n+                // ALTERNATIVE ROUTES\n+                if (request.getPoints().size() > 2)\n+                    throw new IllegalArgumentException(\"Currently alternative routes work only with start and end point. You tried to use: \" + request.getPoints().size() + \" points\");\n+                StopWatch sw = new StopWatch().start();\n+                List<QueryResult> qResults = ViaRouting.lookup(encodingManager, request.getPoints(), weighting, locationIndex, request.getSnapPreventions(), request.getPointHints());\n+                ghRsp.addDebugInfo(\"idLookup:\" + sw.stop().getSeconds() + \"s\");\n+                PathCalculator pathCalculator = createPathCalculator(qResults, profile, algoOpts, disableCH, disableLM);\n+                QueryGraph queryGraph = QueryGraph.create(ghStorage, qResults);\n+\n+                if (passThrough)\n+                    throw new IllegalArgumentException(\"Alternative paths and \" + PASS_THROUGH + \" at the same time is currently not supported\");\n+                if (!request.getCurbsides().isEmpty())\n+                    throw new IllegalArgumentException(\"Alternative paths do not support the \" + CURBSIDE + \" parameter yet\");\n+\n+                ViaRouting.Result result = ViaRouting.calcPaths(request.getPoints(), queryGraph, qResults, weighting.getFlagEncoder().getAccessEnc(), pathCalculator, request.getCurbsides(), forceCurbsides, request.getHeadings(), passThrough);\n+                if (result.paths.isEmpty())\n+                    throw new RuntimeException(\"Empty paths for alternative route calculation not expected\");\n+\n+                // each path represents a different alternative and we do the path merging for each of them\n+                PathMerger pathMerger = createPathMerger(request, weighting, queryGraph);\n+                for (Path path : result.paths) {\n+                    ResponsePath responsePath = new ResponsePath();\n+                    responsePath.setWaypoints(getWaypoints(qResults));\n+                    pathMerger.doWork(responsePath, Collections.singletonList(path), encodingManager, translationMap.getWithFallBack(request.getLocale()));\n+                    ghRsp.add(responsePath);\n+                }\n+                ghRsp.getHints().putObject(\"visited_nodes.sum\", result.visitedNodes);\n+                ghRsp.getHints().putObject(\"visited_nodes.average\", (float) result.visitedNodes / (qResults.size() - 1));\n+                return result.paths;\n+            } else {\n+                StopWatch sw = new StopWatch().start();\n+                List<QueryResult> qResults = ViaRouting.lookup(encodingManager, request.getPoints(), weighting, locationIndex, request.getSnapPreventions(), request.getPointHints());\n+                ghRsp.addDebugInfo(\"idLookup:\" + sw.stop().getSeconds() + \"s\");\n+                PathCalculator pathCalculator = createPathCalculator(qResults, profile, algoOpts, disableCH, disableLM);\n+                // (base) query graph used to resolve headings, curbsides etc. this is not necessarily the same thing as\n+                // the (possibly implementation specific) query graph used by PathCalculator\n+                QueryGraph queryGraph = QueryGraph.create(ghStorage, qResults);\n+                ViaRouting.Result result = ViaRouting.calcPaths(request.getPoints(), queryGraph, qResults, weighting.getFlagEncoder().getAccessEnc(), pathCalculator, request.getCurbsides(), forceCurbsides, request.getHeadings(), passThrough);\n+\n+                if (request.getPoints().size() != result.paths.size() + 1)\n+                    throw new RuntimeException(\"There should be exactly one more point than paths. points:\" + request.getPoints().size() + \", paths:\" + result.paths.size());\n+\n+                // here each path represents one leg of the via-route and we merge them all together into one response path\n+                ResponsePath responsePath = concatenatePaths(request, weighting, queryGraph, result.paths, getWaypoints(qResults));\n+                responsePath.addDebugInfo(result.debug);\n+                ghRsp.add(responsePath);\n+                ghRsp.getHints().putObject(\"visited_nodes.sum\", result.visitedNodes);\n+                ghRsp.getHints().putObject(\"visited_nodes.average\", (float) result.visitedNodes / (qResults.size() - 1));\n+                return result.paths;\n+            }\n+        } catch (MultiException ex) {\n+            for (Throwable t : ex.getErrors()) {\n+                ghRsp.addError(t);\n+            }\n+            return emptyList();\n         } catch (IllegalArgumentException ex) {\n             ghRsp.addError(ex);\n-            return Collections.emptyList();\n+            return emptyList();\n         }\n     }\n \n-    public RoutingAlgorithmFactory getAlgorithmFactory(String profile, boolean disableCH, boolean disableLM) {\n-        if (chEnabled && disableCH && !routerConfig.isCHDisablingAllowed()) {\n-            throw new IllegalArgumentException(\"Disabling CH is not allowed on the server side\");\n+    private Weighting createWeighting(Profile profile, PMap requestHints, List<GHPoint> points, boolean forCH) {\n+        if (forCH) {\n+            // todo: do not allow things like short_fastest.distance_factor or u_turn_costs unless CH is disabled\n+            // and only under certain conditions for LM\n+\n+            // the request hints are ignored for CH as we cannot change the profile after the preparation like this.\n+            // the weighting here has to be created the same way as we did when we created the weighting for the preparation\n+            return weightingFactory.createWeighting(profile, new PMap(), false);\n+        } else {\n+            Weighting weighting = weightingFactory.createWeighting(profile, requestHints, false);\n+            if (requestHints.has(Parameters.Routing.BLOCK_AREA)) {\n+                FlagEncoder encoder = encodingManager.getEncoder(profile.getVehicle());\n+                GraphEdgeIdFinder.BlockArea blockArea = GraphEdgeIdFinder.createBlockArea(ghStorage, locationIndex,\n+                        points, requestHints, DefaultEdgeFilter.allEdges(encoder));\n+                weighting = new BlockAreaWeighting(weighting, blockArea);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzQ0NTMwNA=="}, "originalCommit": {"oid": "ee613b1352673023367f0dc8b14788a7b7887a36"}, "originalPosition": 234}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcyNTIwMzM1OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/com/graphhopper/routing/CHPathCalculator.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOVQxNDowMTo0M1rOGhLnTQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMFQxMzo0NTo0M1rOGh1knA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzQ0NjQ3Nw==", "bodyText": "I know you only copied this, but we should make it consistent. E.g. in Measurement we use us instead of micros. Or use \u00b5s :) ?", "url": "https://github.com/graphhopper/graphhopper/pull/2057#discussion_r437446477", "createdAt": "2020-06-09T14:01:43Z", "author": {"login": "karussell"}, "path": "core/src/main/java/com/graphhopper/routing/CHPathCalculator.java", "diffHunk": "@@ -0,0 +1,91 @@\n+/*\n+ *  Licensed to GraphHopper GmbH under one or more contributor\n+ *  license agreements. See the NOTICE file distributed with this work for\n+ *  additional information regarding copyright ownership.\n+ *\n+ *  GraphHopper GmbH licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except in\n+ *  compliance with the License. You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+\n+package com.graphhopper.routing;\n+\n+import com.graphhopper.routing.ch.CHRoutingAlgorithmFactory;\n+import com.graphhopper.routing.querygraph.QueryGraph;\n+import com.graphhopper.util.PMap;\n+import com.graphhopper.util.Parameters;\n+import com.graphhopper.util.StopWatch;\n+\n+import java.util.Collections;\n+import java.util.List;\n+\n+import static com.graphhopper.util.EdgeIterator.ANY_EDGE;\n+import static com.graphhopper.util.Parameters.Routing.MAX_VISITED_NODES;\n+\n+public class CHPathCalculator implements PathCalculator {\n+    private final QueryGraph queryGraph;\n+    private final CHRoutingAlgorithmFactory algoFactory;\n+    private final PMap algoOpts;\n+    private String debug;\n+    private int visitedNodes;\n+\n+    public CHPathCalculator(QueryGraph queryGraph, CHRoutingAlgorithmFactory algoFactory, PMap algoOpts) {\n+        this.queryGraph = queryGraph;\n+        this.algoFactory = algoFactory;\n+        this.algoOpts = algoOpts;\n+    }\n+\n+    @Override\n+    public List<Path> calcPaths(int from, int to, EdgeRestrictions edgeRestrictions) {\n+        if (!edgeRestrictions.getUnfavoredEdges().isEmpty())\n+            throw new IllegalArgumentException(\"Using unfavored edges is currently not supported for CH\");\n+        RoutingAlgorithm algo = createAlgo();\n+        return calcPaths(from, to, edgeRestrictions, algo);\n+    }\n+\n+    private RoutingAlgorithm createAlgo() {\n+        StopWatch sw = new StopWatch().start();\n+        RoutingAlgorithm algo = algoFactory.createAlgo(queryGraph, algoOpts);\n+        debug = \", algoInit:\" + (sw.stop().getNanos() / 1000) + \" micros\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ee613b1352673023367f0dc8b14788a7b7887a36"}, "originalPosition": 57}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzcxODM0Mg==", "bodyText": "I like using the actual greek letter, I just need to figure out how to type it on my keyboard :) There shouldn't be any problem using it?", "url": "https://github.com/graphhopper/graphhopper/pull/2057#discussion_r437718342", "createdAt": "2020-06-09T20:58:34Z", "author": {"login": "easbar"}, "path": "core/src/main/java/com/graphhopper/routing/CHPathCalculator.java", "diffHunk": "@@ -0,0 +1,91 @@\n+/*\n+ *  Licensed to GraphHopper GmbH under one or more contributor\n+ *  license agreements. See the NOTICE file distributed with this work for\n+ *  additional information regarding copyright ownership.\n+ *\n+ *  GraphHopper GmbH licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except in\n+ *  compliance with the License. You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+\n+package com.graphhopper.routing;\n+\n+import com.graphhopper.routing.ch.CHRoutingAlgorithmFactory;\n+import com.graphhopper.routing.querygraph.QueryGraph;\n+import com.graphhopper.util.PMap;\n+import com.graphhopper.util.Parameters;\n+import com.graphhopper.util.StopWatch;\n+\n+import java.util.Collections;\n+import java.util.List;\n+\n+import static com.graphhopper.util.EdgeIterator.ANY_EDGE;\n+import static com.graphhopper.util.Parameters.Routing.MAX_VISITED_NODES;\n+\n+public class CHPathCalculator implements PathCalculator {\n+    private final QueryGraph queryGraph;\n+    private final CHRoutingAlgorithmFactory algoFactory;\n+    private final PMap algoOpts;\n+    private String debug;\n+    private int visitedNodes;\n+\n+    public CHPathCalculator(QueryGraph queryGraph, CHRoutingAlgorithmFactory algoFactory, PMap algoOpts) {\n+        this.queryGraph = queryGraph;\n+        this.algoFactory = algoFactory;\n+        this.algoOpts = algoOpts;\n+    }\n+\n+    @Override\n+    public List<Path> calcPaths(int from, int to, EdgeRestrictions edgeRestrictions) {\n+        if (!edgeRestrictions.getUnfavoredEdges().isEmpty())\n+            throw new IllegalArgumentException(\"Using unfavored edges is currently not supported for CH\");\n+        RoutingAlgorithm algo = createAlgo();\n+        return calcPaths(from, to, edgeRestrictions, algo);\n+    }\n+\n+    private RoutingAlgorithm createAlgo() {\n+        StopWatch sw = new StopWatch().start();\n+        RoutingAlgorithm algo = algoFactory.createAlgo(queryGraph, algoOpts);\n+        debug = \", algoInit:\" + (sw.stop().getNanos() / 1000) + \" micros\";", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzQ0NjQ3Nw=="}, "originalCommit": {"oid": "ee613b1352673023367f0dc8b14788a7b7887a36"}, "originalPosition": 57}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODEzMzkxNg==", "bodyText": "I was able to create it via AltGr+m", "url": "https://github.com/graphhopper/graphhopper/pull/2057#discussion_r438133916", "createdAt": "2020-06-10T13:45:43Z", "author": {"login": "karussell"}, "path": "core/src/main/java/com/graphhopper/routing/CHPathCalculator.java", "diffHunk": "@@ -0,0 +1,91 @@\n+/*\n+ *  Licensed to GraphHopper GmbH under one or more contributor\n+ *  license agreements. See the NOTICE file distributed with this work for\n+ *  additional information regarding copyright ownership.\n+ *\n+ *  GraphHopper GmbH licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except in\n+ *  compliance with the License. You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+\n+package com.graphhopper.routing;\n+\n+import com.graphhopper.routing.ch.CHRoutingAlgorithmFactory;\n+import com.graphhopper.routing.querygraph.QueryGraph;\n+import com.graphhopper.util.PMap;\n+import com.graphhopper.util.Parameters;\n+import com.graphhopper.util.StopWatch;\n+\n+import java.util.Collections;\n+import java.util.List;\n+\n+import static com.graphhopper.util.EdgeIterator.ANY_EDGE;\n+import static com.graphhopper.util.Parameters.Routing.MAX_VISITED_NODES;\n+\n+public class CHPathCalculator implements PathCalculator {\n+    private final QueryGraph queryGraph;\n+    private final CHRoutingAlgorithmFactory algoFactory;\n+    private final PMap algoOpts;\n+    private String debug;\n+    private int visitedNodes;\n+\n+    public CHPathCalculator(QueryGraph queryGraph, CHRoutingAlgorithmFactory algoFactory, PMap algoOpts) {\n+        this.queryGraph = queryGraph;\n+        this.algoFactory = algoFactory;\n+        this.algoOpts = algoOpts;\n+    }\n+\n+    @Override\n+    public List<Path> calcPaths(int from, int to, EdgeRestrictions edgeRestrictions) {\n+        if (!edgeRestrictions.getUnfavoredEdges().isEmpty())\n+            throw new IllegalArgumentException(\"Using unfavored edges is currently not supported for CH\");\n+        RoutingAlgorithm algo = createAlgo();\n+        return calcPaths(from, to, edgeRestrictions, algo);\n+    }\n+\n+    private RoutingAlgorithm createAlgo() {\n+        StopWatch sw = new StopWatch().start();\n+        RoutingAlgorithm algo = algoFactory.createAlgo(queryGraph, algoOpts);\n+        debug = \", algoInit:\" + (sw.stop().getNanos() / 1000) + \" micros\";", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzQ0NjQ3Nw=="}, "originalCommit": {"oid": "ee613b1352673023367f0dc8b14788a7b7887a36"}, "originalPosition": 57}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcyNjk0MDIzOnYy", "diffSide": "RIGHT", "path": "core/src/main/java/com/graphhopper/routing/querygraph/QueryGraph.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOVQyMToyMToyM1rOGhc6Pw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMFQxMzo0NjowM1rOGh1lzA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzcyOTg1NQ==", "bodyText": "Ok yes this needs a better name and maybe more documentation, but we can consider this work in progress and it will be removed again soon anyway :)", "url": "https://github.com/graphhopper/graphhopper/pull/2057#discussion_r437729855", "createdAt": "2020-06-09T21:21:23Z", "author": {"login": "easbar"}, "path": "core/src/main/java/com/graphhopper/routing/querygraph/QueryGraph.java", "diffHunk": "@@ -340,4 +340,16 @@ private UnsupportedOperationException exc() {\n     public Graph getMainGraph() {\n         return mainGraph;\n     }\n+\n+    public int shiftEdgeId(int edgeId) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f1454953448bf98da8c886b133cd45a3d5d35928"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODEzNDIyMA==", "bodyText": "Ok, sure.", "url": "https://github.com/graphhopper/graphhopper/pull/2057#discussion_r438134220", "createdAt": "2020-06-10T13:46:03Z", "author": {"login": "karussell"}, "path": "core/src/main/java/com/graphhopper/routing/querygraph/QueryGraph.java", "diffHunk": "@@ -340,4 +340,16 @@ private UnsupportedOperationException exc() {\n     public Graph getMainGraph() {\n         return mainGraph;\n     }\n+\n+    public int shiftEdgeId(int edgeId) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzcyOTg1NQ=="}, "originalCommit": {"oid": "f1454953448bf98da8c886b133cd45a3d5d35928"}, "originalPosition": 5}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4812, "cost": 1, "resetAt": "2021-11-12T20:28:25Z"}}}