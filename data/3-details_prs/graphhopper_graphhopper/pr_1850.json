{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzYxMzg2MzU0", "number": 1850, "title": "Use RoutingCHGraph adapter for CH query algorithms", "bodyText": "This is more or less a follow up of #1818 and part of #1780. There is a new interface RoutingCHGraph (with corresponding implementation) that is used by all CH algorithms. Internally it still uses BaseGraph/CHGraphImpl, but this is no longer (as) exposed to the algorithms, which can now retrieve the edge weights via edge.getWeight(). It also helps for #1835/#1776, because all access flag checks are run immediately before calcWeight already and only need to be moved into Weighting in #1835.\nSo far the query speed seems to decrease by about 10%, I could not find out why exactly this is, but I am assuming its because we are wrapping the routing ch graph iterators around the base/ch graph iterators. Not sure, but since this will later be removed anyway I'd say this is ok for now ?", "createdAt": "2020-01-10T10:37:40Z", "url": "https://github.com/graphhopper/graphhopper/pull/1850", "merged": true, "mergeCommit": {"oid": "85f8801d6fa15284bf8acde09ac954f7464a8313"}, "closed": true, "closedAt": "2020-01-19T08:29:31Z", "author": {"login": "easbar"}, "timelineItems": {"totalCount": 20, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABb4TrFwgH2gAyMzYxMzg2MzU0OjhjNTA1NzhhZGEwZWFhODMzMTZhN2JkNzdkYjY0Y2E5NjFhY2ZkODE=", "endCursor": "Y3Vyc29yOnYyOpPPAAABb7zJABgH2gAyMzYxMzg2MzU0OjdkNDE2OTQxOGE5YTVmNWRiNjBjMGFlODBmMzE1NmVlZmZiMWJjYzE=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "8c50578ada0eaa83316a7bd77db64ca961acfd81", "author": {"user": {"login": "easbar", "name": "Andi"}}, "url": "https://github.com/graphhopper/graphhopper/commit/8c50578ada0eaa83316a7bd77db64ca961acfd81", "committedDate": "2020-01-08T11:29:57Z", "message": "Add CHRoutingGraph to be used for CH query algorithms"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f2dab52ea2546d9b636da12819f697ad8ee500fa", "author": {"user": {"login": "easbar", "name": "Andi"}}, "url": "https://github.com/graphhopper/graphhopper/commit/f2dab52ea2546d9b636da12819f697ad8ee500fa", "committedDate": "2020-01-09T18:09:57Z", "message": "Try inlining edgeState()"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "26149076d921886d7f09a9e0e174e4e39f9e0f8e", "author": {"user": {"login": "easbar", "name": "Andi"}}, "url": "https://github.com/graphhopper/graphhopper/commit/26149076d921886d7f09a9e0e174e4e39f9e0f8e", "committedDate": "2020-01-09T18:12:36Z", "message": "Remove comment"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d00ac4731b175cdb6cdd7e41ae4c9622abd1007a", "author": {"user": {"login": "easbar", "name": "Andi"}}, "url": "https://github.com/graphhopper/graphhopper/commit/d00ac4731b175cdb6cdd7e41ae4c9622abd1007a", "committedDate": "2020-01-10T08:33:14Z", "message": "Move comment"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0cef7ad8087f0c871a554627f98c7d2b3095a014", "author": {"user": {"login": "easbar", "name": "Andi"}}, "url": "https://github.com/graphhopper/graphhopper/commit/0cef7ad8087f0c871a554627f98c7d2b3095a014", "committedDate": "2020-01-10T10:19:28Z", "message": "Undo inlining of edgeState(), its not faster"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQxMDg5ODI5", "url": "https://github.com/graphhopper/graphhopper/pull/1850#pullrequestreview-341089829", "createdAt": "2020-01-10T10:55:43Z", "commit": {"oid": "0cef7ad8087f0c871a554627f98c7d2b3095a014"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xMFQxMDo1NTo0M1rOFcQxqg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xMFQxMDo1NTo0M1rOFcQxqg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTE3OTMwNg==", "bodyText": "@michaz ? Do we want the BaseGraph, the QueryGraph (of the CHGraph) or the CHGraph ?", "url": "https://github.com/graphhopper/graphhopper/pull/1850#discussion_r365179306", "createdAt": "2020-01-10T10:55:43Z", "author": {"login": "easbar"}, "path": "core/src/main/java/com/graphhopper/routing/AlternativeRouteCH.java", "diffHunk": "@@ -76,22 +76,21 @@ public boolean apply(final int v, final SPTEntry fromSPTEntry) {\n                 // s -> v and v -> t need not be shortest paths. In fact, they can sometimes be pretty strange.\n                 // We still use this preliminary path to filter for shared path length with other alternatives,\n                 // so we don't have to work so much.\n-                Path preliminaryRoute = createPathExtractor(graph, weighting).extract(fromSPTEntry, toSPTEntry, fromSPTEntry.getWeightOfVisitedPath() + toSPTEntry.getWeightOfVisitedPath());\n+                Path preliminaryRoute = createPathExtractor(graph).extract(fromSPTEntry, toSPTEntry, fromSPTEntry.getWeightOfVisitedPath() + toSPTEntry.getWeightOfVisitedPath());\n                 double preliminaryShare = calculateShare(preliminaryRoute);\n                 if (preliminaryShare > maxShareFactor) {\n                     return true;\n                 }\n \n                 // Okay, now we want the s -> v -> t shortest via-path, so we route s -> v and v -> t\n                 // and glue them together.\n-                DijkstraBidirectionCHNoSOD svRouter = new DijkstraBidirectionCHNoSOD(graph, weighting);\n-                svRouter.setEdgeFilter(additionalEdgeFilter);\n+                DijkstraBidirectionCHNoSOD svRouter = new DijkstraBidirectionCHNoSOD(graph);\n                 final Path svPath = svRouter.calcPath(s, v);\n                 final IntIndexedContainer svNodes = svPath.calcNodes();\n-                DijkstraBidirectionCHNoSOD vtRouter = new DijkstraBidirectionCHNoSOD(graph, weighting);\n-                vtRouter.setEdgeFilter(additionalEdgeFilter);\n+                DijkstraBidirectionCHNoSOD vtRouter = new DijkstraBidirectionCHNoSOD(graph);\n                 final Path vtPath = vtRouter.calcPath(v, t);\n                 final IntIndexedContainer vtNodes = vtPath.calcNodes();\n+                // todonow: which graph do we want here ?", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0cef7ad8087f0c871a554627f98c7d2b3095a014"}, "originalPosition": 60}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQxMDkxMDQ3", "url": "https://github.com/graphhopper/graphhopper/pull/1850#pullrequestreview-341091047", "createdAt": "2020-01-10T10:57:58Z", "commit": {"oid": "0cef7ad8087f0c871a554627f98c7d2b3095a014"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xMFQxMDo1Nzo1OFrOFcQ1WA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xMFQxMDo1Nzo1OFrOFcQ1WA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTE4MDI0OA==", "bodyText": "I already removed the in/outEdgeExplorer for #1835 here. I left a few todos where we can simply move the access flags into the weighting for #1835.", "url": "https://github.com/graphhopper/graphhopper/pull/1850#discussion_r365180248", "createdAt": "2020-01-10T10:57:58Z", "author": {"login": "easbar"}, "path": "core/src/main/java/com/graphhopper/routing/AbstractRoutingAlgorithm.java", "diffHunk": "@@ -56,8 +57,9 @@ public AbstractRoutingAlgorithm(Graph graph, Weighting weighting, TraversalMode\n         this.traversalMode = traversalMode;\n         this.graph = graph;\n         this.nodeAccess = graph.getNodeAccess();\n-        outEdgeExplorer = graph.createEdgeExplorer(DefaultEdgeFilter.outEdges(flagEncoder));\n-        inEdgeExplorer = graph.createEdgeExplorer(DefaultEdgeFilter.inEdges(flagEncoder));\n+        inEdgeFilter = DefaultEdgeFilter.inEdges(flagEncoder.getAccessEnc());\n+        outEdgeFilter = DefaultEdgeFilter.outEdges(flagEncoder.getAccessEnc());\n+        edgeExplorer = graph.createEdgeExplorer();\n     }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0cef7ad8087f0c871a554627f98c7d2b3095a014"}, "originalPosition": 21}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQxMDkxNTkx", "url": "https://github.com/graphhopper/graphhopper/pull/1850#pullrequestreview-341091591", "createdAt": "2020-01-10T10:59:01Z", "commit": {"oid": "0cef7ad8087f0c871a554627f98c7d2b3095a014"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xMFQxMDo1OTowMVrOFcQ3Xg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xMFQxMDo1OTowMVrOFcQ3Xg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTE4MDc2Ng==", "bodyText": "In #1835 we can remove outEdgeFilter here and strictly rely on the returned weight from Weighting", "url": "https://github.com/graphhopper/graphhopper/pull/1850#discussion_r365180766", "createdAt": "2020-01-10T10:59:01Z", "author": {"login": "easbar"}, "path": "core/src/main/java/com/graphhopper/routing/Dijkstra.java", "diffHunk": "@@ -68,19 +67,19 @@ public Path calcPath(int from, int to) {\n     }\n \n     protected void runAlgo() {\n-        EdgeExplorer explorer = outEdgeExplorer;\n         while (true) {\n             visitedNodes++;\n             if (isMaxVisitedNodesExceeded() || finished())\n                 break;\n \n             int currNode = currEdge.adjNode;\n-            EdgeIterator iter = explorer.setBaseNode(currNode);\n+            EdgeIterator iter = edgeExplorer.setBaseNode(currNode);\n             while (iter.next()) {\n                 if (!accept(iter, currEdge.edge))\n                     continue;\n \n-                double tmpWeight = weighting.calcWeight(iter, false, currEdge.edge) + currEdge.weight;\n+                // todo: for #1776/#1835 move the access check into weighting\n+                double tmpWeight = !outEdgeFilter.accept(iter) ? Double.POSITIVE_INFINITY : weighting.calcWeight(iter, false, currEdge.edge) + currEdge.weight;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0cef7ad8087f0c871a554627f98c7d2b3095a014"}, "originalPosition": 27}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "889dc79f94f079687b8d0592e401c12086f6c87c", "author": {"user": {"login": "easbar", "name": "Andi"}}, "url": "https://github.com/graphhopper/graphhopper/commit/889dc79f94f079687b8d0592e401c12086f6c87c", "committedDate": "2020-01-10T11:28:28Z", "message": "Use Graph (including virtual edges+nodes in AlternativeRouteCH)."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a853ee7d16daed971ce31df124b23061e217d4de", "author": {"user": {"login": "easbar", "name": "Andi"}}, "url": "https://github.com/graphhopper/graphhopper/commit/a853ee7d16daed971ce31df124b23061e217d4de", "committedDate": "2020-01-10T11:42:01Z", "message": "Add some javadocs"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8bb33af68ff32fc2287de824e1e5b4cae64f0749", "author": {"user": {"login": "easbar", "name": "Andi"}}, "url": "https://github.com/graphhopper/graphhopper/commit/8bb33af68ff32fc2287de824e1e5b4cae64f0749", "committedDate": "2020-01-10T17:16:06Z", "message": "Merge branch 'master' into ch_routing_graph_2\n\n# Conflicts:\n#\tcore/src/main/java/com/graphhopper/routing/AbstractBidirAlgo.java\n#\tcore/src/main/java/com/graphhopper/routing/DijkstraBidirectionCH.java\n#\tcore/src/main/java/com/graphhopper/routing/ch/CHWeighting.java\n#\tcore/src/main/java/com/graphhopper/routing/ch/NodeBasedCHBidirPathExtractor.java"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d52495a81a317738251d41dadc824405ab8845fe", "author": {"user": {"login": "easbar", "name": "Andi"}}, "url": "https://github.com/graphhopper/graphhopper/commit/d52495a81a317738251d41dadc824405ab8845fe", "committedDate": "2020-01-15T08:38:42Z", "message": "Merge branch 'master' into ch_routing_graph_2\n\n# Conflicts:\n#\tcore/src/main/java/com/graphhopper/routing/AlternativeRouteCH.java"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQzMDgyMTc0", "url": "https://github.com/graphhopper/graphhopper/pull/1850#pullrequestreview-343082174", "createdAt": "2020-01-15T09:26:47Z", "commit": {"oid": "d52495a81a317738251d41dadc824405ab8845fe"}, "state": "COMMENTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNVQwOToyNjo0N1rOFdx2xw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNVQwOTozNTowNVrOFdyF-w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Njc2OTg2Mw==", "bodyText": "Here the calcWeight operation is done although it could happen that the backward search has no entry and the weight is not used. Might be related to (not very likely):\n\nSo far the query speed seems to decrease by about 10%, I could not find out why exactly this is,\n\nBTW: does this slowdown occur for edge- and node-based queries?", "url": "https://github.com/graphhopper/graphhopper/pull/1850#discussion_r366769863", "createdAt": "2020-01-15T09:26:47Z", "author": {"login": "karussell"}, "path": "core/src/main/java/com/graphhopper/routing/AbstractBidirCHAlgo.java", "diffHunk": "@@ -0,0 +1,308 @@\n+/*\n+ *  Licensed to GraphHopper GmbH under one or more contributor\n+ *  license agreements. See the NOTICE file distributed with this work for\n+ *  additional information regarding copyright ownership.\n+ *\n+ *  GraphHopper GmbH licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except in\n+ *  compliance with the License. You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package com.graphhopper.routing;\n+\n+import com.carrotsearch.hppc.IntObjectMap;\n+import com.graphhopper.routing.ch.NodeBasedCHBidirPathExtractor;\n+import com.graphhopper.routing.util.TraversalMode;\n+import com.graphhopper.storage.*;\n+\n+import java.util.PriorityQueue;\n+\n+import static com.graphhopper.util.EdgeIterator.ANY_EDGE;\n+import static com.graphhopper.util.EdgeIterator.NO_EDGE;\n+\n+/**\n+ * Common subclass for bidirectional CH algorithms.\n+ * <p>\n+ *\n+ * @author Peter Karich\n+ * @author easbar\n+ * @see AbstractNonCHBidirAlgo for non-CH bidirectional algorithms\n+ */\n+public abstract class AbstractBidirCHAlgo extends AbstractBidirAlgo implements BidirRoutingAlgorithm {\n+    protected final RoutingCHGraph graph;\n+    protected RoutingCHEdgeExplorer allEdgeExplorer;\n+    protected RoutingCHEdgeExplorer inEdgeExplorer;\n+    protected RoutingCHEdgeExplorer outEdgeExplorer;\n+    protected CHEdgeFilter levelEdgeFilter;\n+\n+    public AbstractBidirCHAlgo(RoutingCHGraph graph, TraversalMode tMode) {\n+        super(tMode);\n+        this.graph = graph;\n+        this.nodeAccess = graph.getGraph().getNodeAccess();\n+        allEdgeExplorer = graph.createAllEdgeExplorer();\n+        outEdgeExplorer = graph.createOutEdgeExplorer();\n+        inEdgeExplorer = graph.createInEdgeExplorer();\n+        levelEdgeFilter = new CHLevelEdgeFilter(graph);\n+        int size = Math.min(Math.max(200, graph.getNodes() / 10), 150_000);\n+        initCollections(size);\n+    }\n+\n+    @Override\n+    protected void initCollections(int size) {\n+        super.initCollections(Math.min(size, 2000));\n+    }\n+\n+    /**\n+     * Creates a new entry of the shortest path tree (a {@link SPTEntry} or one of its subclasses) during a dijkstra\n+     * expansion.\n+     *\n+     * @param edge    the edge that is currently processed for the expansion\n+     * @param incEdge the id of the edge that is incoming to the node the edge is pointed at. usually this is the same as\n+     *                edge.getEdge(), but for edge-based CH and in case edge is a shortcut incEdge is the original edge\n+     *                that is incoming to the node\n+     * @param weight  the weight the shortest path three entry should carry\n+     * @param parent  the parent entry of in the shortest path tree\n+     * @param reverse true if we are currently looking at the backward search, false otherwise\n+     */\n+    protected abstract SPTEntry createEntry(RoutingCHEdgeIteratorState edge, int incEdge, double weight, SPTEntry parent, boolean reverse);\n+\n+    protected BidirPathExtractor createPathExtractor(RoutingCHGraph graph) {\n+        return new NodeBasedCHBidirPathExtractor(graph);\n+    }\n+\n+    @Override\n+    protected void postInitFrom() {\n+        if (fromOutEdge == ANY_EDGE) {\n+            fillEdgesFromUsingFilter(levelEdgeFilter);\n+        } else {\n+            // need to use a local reference here, because additionalEdgeFilter is modified when calling fillEdgesFromUsingFilter\n+            final CHEdgeFilter tmpFilter = levelEdgeFilter;\n+            fillEdgesFromUsingFilter(new CHEdgeFilter() {\n+                @Override\n+                public boolean accept(RoutingCHEdgeIteratorState edgeState) {\n+                    return (tmpFilter == null || tmpFilter.accept(edgeState)) && edgeState.getOrigEdgeFirst() == fromOutEdge;\n+                }\n+            });\n+        }\n+    }\n+\n+    @Override\n+    protected void postInitTo() {\n+        if (toInEdge == ANY_EDGE) {\n+            fillEdgesToUsingFilter(levelEdgeFilter);\n+        } else {\n+            final CHEdgeFilter tmpFilter = levelEdgeFilter;\n+            fillEdgesToUsingFilter(new CHEdgeFilter() {\n+                @Override\n+                public boolean accept(RoutingCHEdgeIteratorState edgeState) {\n+                    return (tmpFilter == null || tmpFilter.accept(edgeState)) && edgeState.getOrigEdgeLast() == toInEdge;\n+                }\n+            });\n+        }\n+    }\n+\n+    /**\n+     * @param edgeFilter edge filter used to fill edges. the {@link #levelEdgeFilter} reference will be set to\n+     *                   edgeFilter by this method, so make sure edgeFilter does not use it directly.\n+     */\n+    protected void fillEdgesFromUsingFilter(CHEdgeFilter edgeFilter) {\n+        // we temporarily ignore the additionalEdgeFilter\n+        CHEdgeFilter tmpFilter = levelEdgeFilter;\n+        levelEdgeFilter = edgeFilter;\n+        finishedFrom = !fillEdgesFrom();\n+        levelEdgeFilter = tmpFilter;\n+    }\n+\n+    /**\n+     * @see #fillEdgesFromUsingFilter(CHEdgeFilter)\n+     */\n+    protected void fillEdgesToUsingFilter(CHEdgeFilter edgeFilter) {\n+        // we temporarily ignore the additionalEdgeFilter\n+        CHEdgeFilter tmpFilter = levelEdgeFilter;\n+        levelEdgeFilter = edgeFilter;\n+        finishedTo = !fillEdgesTo();\n+        levelEdgeFilter = tmpFilter;\n+    }\n+\n+    @Override\n+    public boolean finished() {\n+        // we need to finish BOTH searches for CH!\n+        if (finishedFrom && finishedTo)\n+            return true;\n+\n+        // changed also the final finish condition for CH\n+        return currFrom.weight >= bestWeight && currTo.weight >= bestWeight;\n+    }\n+\n+    @Override\n+    boolean fillEdgesFrom() {\n+        if (pqOpenSetFrom.isEmpty()) {\n+            return false;\n+        }\n+        currFrom = pqOpenSetFrom.poll();\n+        visitedCountFrom++;\n+        if (fromEntryCanBeSkipped()) {\n+            return true;\n+        }\n+        if (fwdSearchCanBeStopped()) {\n+            return false;\n+        }\n+        bestWeightMapOther = bestWeightMapTo;\n+        fillEdges(currFrom, pqOpenSetFrom, bestWeightMapFrom, outEdgeExplorer, false);\n+        return true;\n+    }\n+\n+    @Override\n+    boolean fillEdgesTo() {\n+        if (pqOpenSetTo.isEmpty()) {\n+            return false;\n+        }\n+        currTo = pqOpenSetTo.poll();\n+        visitedCountTo++;\n+        if (toEntryCanBeSkipped()) {\n+            return true;\n+        }\n+        if (bwdSearchCanBeStopped()) {\n+            return false;\n+        }\n+        bestWeightMapOther = bestWeightMapFrom;\n+        fillEdges(currTo, pqOpenSetTo, bestWeightMapTo, inEdgeExplorer, true);\n+        return true;\n+    }\n+\n+    private void fillEdges(SPTEntry currEdge, PriorityQueue<SPTEntry> prioQueue,\n+                           IntObjectMap<SPTEntry> bestWeightMap, RoutingCHEdgeExplorer explorer, boolean reverse) {\n+        RoutingCHEdgeIterator iter = explorer.setBaseNode(currEdge.adjNode);\n+        while (iter.next()) {\n+            if (!accept(iter, currEdge, reverse))\n+                continue;\n+\n+            final double weight = calcWeight(iter, currEdge, reverse);\n+            if (Double.isInfinite(weight)) {\n+                continue;\n+            }\n+            final int origEdgeId = getOrigEdgeId(iter, reverse);\n+            final int traversalId = getTraversalId(iter, origEdgeId, reverse);\n+            SPTEntry entry = bestWeightMap.get(traversalId);\n+            if (entry == null) {\n+                entry = createEntry(iter, origEdgeId, weight, currEdge, reverse);\n+                bestWeightMap.put(traversalId, entry);\n+                prioQueue.add(entry);\n+            } else if (entry.getWeightOfVisitedPath() > weight) {\n+                prioQueue.remove(entry);\n+                updateEntry(entry, iter, origEdgeId, weight, currEdge, reverse);\n+                prioQueue.add(entry);\n+            } else\n+                continue;\n+\n+            if (updateBestPath) {\n+                // only needed for edge-based -> skip the calculation and use dummy value otherwise\n+                double edgeWeight = traversalMode.isEdgeBased() ? calcWeight(iter, reverse, NO_EDGE) : Double.POSITIVE_INFINITY;\n+                updateBestPath(edgeWeight, entry, origEdgeId, traversalId, reverse);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d52495a81a317738251d41dadc824405ab8845fe"}, "originalPosition": 208}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Njc3MDc1MA==", "bodyText": "For clarity it should be better:\n!outEdgeFilter.accept(iter) ? Double.POSITIVE_INFINITY : (weighting.calcWeight(iter, false, currEdge.edge) + currEdge.weightOfVisitedPath);", "url": "https://github.com/graphhopper/graphhopper/pull/1850#discussion_r366770750", "createdAt": "2020-01-15T09:28:38Z", "author": {"login": "karussell"}, "path": "core/src/main/java/com/graphhopper/routing/AStar.java", "diffHunk": "@@ -83,19 +86,19 @@ public Path calcPath(int from, int to) {\n \n     private void runAlgo() {\n         double currWeightToGoal, estimationFullWeight;\n-        EdgeExplorer explorer = outEdgeExplorer;\n         while (true) {\n             visitedNodes++;\n             if (isMaxVisitedNodesExceeded() || finished())\n                 break;\n \n             int currNode = currEdge.adjNode;\n-            EdgeIterator iter = explorer.setBaseNode(currNode);\n+            EdgeIterator iter = edgeExplorer.setBaseNode(currNode);\n             while (iter.next()) {\n                 if (!accept(iter, currEdge.edge))\n                     continue;\n \n-                double tmpWeight = weighting.calcWeight(iter, false, currEdge.edge) + currEdge.weightOfVisitedPath;\n+                // todo: for #1776/#1835 move the access check into weighting\n+                double tmpWeight = !outEdgeFilter.accept(iter) ? Double.POSITIVE_INFINITY : weighting.calcWeight(iter, false, currEdge.edge) + currEdge.weightOfVisitedPath;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d52495a81a317738251d41dadc824405ab8845fe"}, "originalPosition": 31}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Njc3Mzc1NQ==", "bodyText": "What are the use cases for the EdgeFilter for non-CH algos? (For CH there is the CHLevelEdgeFilter, but here?)\nIs it just regarding the vehicle edge and we can remove this code with #1835 ?", "url": "https://github.com/graphhopper/graphhopper/pull/1850#discussion_r366773755", "createdAt": "2020-01-15T09:35:05Z", "author": {"login": "karussell"}, "path": "core/src/main/java/com/graphhopper/routing/AbstractNonCHBidirAlgo.java", "diffHunk": "@@ -0,0 +1,271 @@\n+/*\n+ *  Licensed to GraphHopper GmbH under one or more contributor\n+ *  license agreements. See the NOTICE file distributed with this work for\n+ *  additional information regarding copyright ownership.\n+ *\n+ *  GraphHopper GmbH licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except in\n+ *  compliance with the License. You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package com.graphhopper.routing;\n+\n+import com.carrotsearch.hppc.IntObjectMap;\n+import com.graphhopper.routing.util.DefaultEdgeFilter;\n+import com.graphhopper.routing.util.EdgeFilter;\n+import com.graphhopper.routing.util.FlagEncoder;\n+import com.graphhopper.routing.util.TraversalMode;\n+import com.graphhopper.routing.weighting.Weighting;\n+import com.graphhopper.storage.Graph;\n+import com.graphhopper.storage.SPTEntry;\n+import com.graphhopper.util.EdgeExplorer;\n+import com.graphhopper.util.EdgeIterator;\n+import com.graphhopper.util.EdgeIteratorState;\n+\n+import java.util.PriorityQueue;\n+\n+import static com.graphhopper.util.EdgeIterator.ANY_EDGE;\n+\n+/**\n+ * Common subclass for bidirectional algorithms.\n+ *\n+ * @author Peter Karich\n+ * @author easbar\n+ * @see AbstractBidirCHAlgo for bidirectional CH algorithms\n+ */\n+public abstract class AbstractNonCHBidirAlgo extends AbstractBidirAlgo implements BidirRoutingAlgorithm {\n+    protected final Graph graph;\n+    protected final Weighting weighting;\n+    protected final FlagEncoder flagEncoder;\n+    protected EdgeExplorer edgeExplorer;\n+    protected EdgeFilter inEdgeFilter;\n+    protected EdgeFilter outEdgeFilter;\n+    protected EdgeFilter additionalEdgeFilter;\n+\n+    public AbstractNonCHBidirAlgo(Graph graph, Weighting weighting, TraversalMode tMode) {\n+        super(tMode);\n+        this.weighting = weighting;\n+        this.flagEncoder = weighting.getFlagEncoder();\n+        this.graph = graph;\n+        this.nodeAccess = graph.getNodeAccess();\n+        edgeExplorer = graph.createEdgeExplorer();\n+        outEdgeFilter = DefaultEdgeFilter.outEdges(flagEncoder.getAccessEnc());\n+        inEdgeFilter = DefaultEdgeFilter.inEdges(flagEncoder.getAccessEnc());\n+        int size = Math.min(Math.max(200, graph.getNodes() / 10), 150_000);\n+        initCollections(size);\n+    }\n+\n+    /**\n+     * Creates a new entry of the shortest path tree (a {@link SPTEntry} or one of its subclasses) during a dijkstra\n+     * expansion.\n+     *\n+     * @param edge    the edge that is currently processed for the expansion\n+     * @param incEdge the id of the edge that is incoming to the node the edge is pointed at. usually this is the same as\n+     *                edge.getEdge(), but for edge-based CH and in case edge is a shortcut incEdge is the original edge\n+     *                that is incoming to the node\n+     * @param weight  the weight the shortest path three entry should carry\n+     * @param parent  the parent entry of in the shortest path tree\n+     * @param reverse true if we are currently looking at the backward search, false otherwise\n+     */\n+    protected abstract SPTEntry createEntry(EdgeIteratorState edge, int incEdge, double weight, SPTEntry parent, boolean reverse);\n+\n+    protected BidirPathExtractor createPathExtractor(Graph graph, Weighting weighting) {\n+        return new BidirPathExtractor(graph, weighting);\n+    }\n+\n+    protected void postInitFrom() {\n+        if (fromOutEdge == ANY_EDGE) {\n+            fillEdgesFromUsingFilter(additionalEdgeFilter);\n+        } else {\n+            // need to use a local reference here, because additionalEdgeFilter is modified when calling fillEdgesFromUsingFilter\n+            final EdgeFilter tmpFilter = additionalEdgeFilter;\n+            fillEdgesFromUsingFilter(new EdgeFilter() {\n+                @Override\n+                public boolean accept(EdgeIteratorState edgeState) {\n+                    return (tmpFilter == null || tmpFilter.accept(edgeState)) && edgeState.getOrigEdgeFirst() == fromOutEdge;\n+                }\n+            });\n+        }\n+    }\n+\n+    protected void postInitTo() {\n+        if (toInEdge == ANY_EDGE) {\n+            fillEdgesToUsingFilter(additionalEdgeFilter);\n+        } else {\n+            final EdgeFilter tmpFilter = additionalEdgeFilter;\n+            fillEdgesToUsingFilter(new EdgeFilter() {\n+                @Override\n+                public boolean accept(EdgeIteratorState edgeState) {\n+                    return (tmpFilter == null || tmpFilter.accept(edgeState)) && edgeState.getOrigEdgeLast() == toInEdge;\n+                }\n+            });\n+        }\n+    }\n+\n+    /**\n+     * @param edgeFilter edge filter used to fill edges. the {@link #additionalEdgeFilter} reference will be set to\n+     *                   edgeFilter by this method, so make sure edgeFilter does not use it directly.\n+     */\n+    protected void fillEdgesFromUsingFilter(EdgeFilter edgeFilter) {\n+        // we temporarily ignore the additionalEdgeFilter\n+        EdgeFilter tmpFilter = additionalEdgeFilter;\n+        additionalEdgeFilter = edgeFilter;\n+        finishedFrom = !fillEdgesFrom();\n+        additionalEdgeFilter = tmpFilter;\n+    }\n+\n+    /**\n+     * @see #fillEdgesFromUsingFilter(EdgeFilter)\n+     */\n+    protected void fillEdgesToUsingFilter(EdgeFilter edgeFilter) {\n+        // we temporarily ignore the additionalEdgeFilter\n+        EdgeFilter tmpFilter = additionalEdgeFilter;\n+        additionalEdgeFilter = edgeFilter;\n+        finishedTo = !fillEdgesTo();\n+        additionalEdgeFilter = tmpFilter;\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d52495a81a317738251d41dadc824405ab8845fe"}, "originalPosition": 133}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c5f8bdc28f75cfe90a6befd6187f5e0066f25dd7", "author": {"user": {"login": "easbar", "name": "Andi"}}, "url": "https://github.com/graphhopper/graphhopper/commit/c5f8bdc28f75cfe90a6befd6187f5e0066f25dd7", "committedDate": "2020-01-15T11:19:51Z", "message": "Add some clarifying parentheses"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f6cf858a5a03f5ba03d1293a37b479d01d9db184", "author": {"user": {"login": "easbar", "name": "Andi"}}, "url": "https://github.com/graphhopper/graphhopper/commit/f6cf858a5a03f5ba03d1293a37b479d01d9db184", "committedDate": "2020-01-15T11:42:28Z", "message": "Skip edge weight calculation for edge-based CH"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8858e1088243cdf7397fa02efebae5e804d0ac7d", "author": {"user": {"login": "easbar", "name": "Andi"}}, "url": "https://github.com/graphhopper/graphhopper/commit/8858e1088243cdf7397fa02efebae5e804d0ac7d", "committedDate": "2020-01-15T11:51:13Z", "message": "Add todo"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "62dacb24a8bf53da5550fdcd447803d85094ad10", "author": {"user": {"login": "easbar", "name": "Andi"}}, "url": "https://github.com/graphhopper/graphhopper/commit/62dacb24a8bf53da5550fdcd447803d85094ad10", "committedDate": "2020-01-16T13:38:44Z", "message": "Downgrade todo"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e1996be127502e647694af8286b6709b9c94be0c", "author": {"user": {"login": "easbar", "name": "Andi"}}, "url": "https://github.com/graphhopper/graphhopper/commit/e1996be127502e647694af8286b6709b9c94be0c", "committedDate": "2020-01-16T14:07:18Z", "message": "Remove RoutingAlgo#setEdgeFilter methods, filter is only used internally now"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "51e72828196e8d458c63f5afd94a0473db7cc23d", "author": {"user": {"login": "easbar", "name": "Andi"}}, "url": "https://github.com/graphhopper/graphhopper/commit/51e72828196e8d458c63f5afd94a0473db7cc23d", "committedDate": "2020-01-16T16:34:34Z", "message": "Merge branch 'master' into ch_routing_graph_2"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7d4169418a9a5f5db60c0ae80f3156eeffb1bcc1", "author": {"user": {"login": "easbar", "name": "Andi"}}, "url": "https://github.com/graphhopper/graphhopper/commit/7d4169418a9a5f5db60c0ae80f3156eeffb1bcc1", "committedDate": "2020-01-19T07:51:27Z", "message": "Merge branch 'master' into ch_routing_graph_2"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4689, "cost": 1, "resetAt": "2021-11-01T14:51:55Z"}}}