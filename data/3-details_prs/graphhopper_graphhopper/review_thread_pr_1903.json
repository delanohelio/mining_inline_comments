{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzc0MjI5Mzg4", "number": 1903, "reviewThreads": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMFQxMzowNDowN1rODmqy-A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yNFQxNDozNDowOVrOD1zhdA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQxODczNjU2OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/com/graphhopper/routing/util/spatialrules/SpatialRuleLookupJTS.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMFQxMzowNDowN1rOF0Nz-w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMVQxMDowNDoyNFrOF0wSkQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDI5NjU3MQ==", "bodyText": "Why is sorting necessary?\nSee https://github.com/graphhopper/graphhopper/pull/1911/files#diff-e313449003aba3db12b92952cd486e32L85-L87 where I had to remove it to avoid problems.", "url": "https://github.com/graphhopper/graphhopper/pull/1903#discussion_r390296571", "createdAt": "2020-03-10T13:04:07Z", "author": {"login": "karussell"}, "path": "core/src/main/java/com/graphhopper/routing/util/spatialrules/SpatialRuleLookupJTS.java", "diffHunk": "@@ -17,110 +17,113 @@\n  */\n package com.graphhopper.routing.util.spatialrules;\n \n-import com.graphhopper.util.shapes.GHPoint;\n+import java.util.*;\n+\n import org.locationtech.jts.geom.*;\n import org.locationtech.jts.index.strtree.STRtree;\n \n-import java.util.*;\n-\n /**\n  * @author Thomas Butz\n  */\n public class SpatialRuleLookupJTS implements SpatialRuleLookup {\n-\n+    \n+    private static final Comparator<SpatialRule> RULE_COMP = new Comparator<SpatialRule>() {\n+\n+        @Override\n+        public int compare(SpatialRule o1, SpatialRule o2) {\n+            int comp = Integer.compare(o1.getPriority(), o2.getPriority());\n+            if (comp != 0) {\n+                return comp;\n+            }\n+            \n+            return o1.getId().compareTo(o2.getId());\n+        }\n+    };\n+    \n     private final GeometryFactory geometryFactory = new GeometryFactory();\n     private final List<SpatialRule> rules;\n     private final Envelope maxBounds;\n     private final STRtree index;\n-\n+    \n     public SpatialRuleLookupJTS(List<SpatialRule> spatialRules, Envelope maxBounds) {\n         this.index = new STRtree();\n-\n+        \n         Map<Polygon, SpatialRuleContainer> containerMap = new HashMap<>();\n+        List<SpatialRule> registeredRules = new ArrayList<>();\n         Set<String> ruleIDs = new HashSet<>();\n         for (SpatialRule rule : spatialRules) {\n             if (rule == null)\n                 throw new IllegalArgumentException(\"rule cannot be null\");\n-\n-            if (rule.equals(SpatialRule.EMPTY))\n-                throw new IllegalArgumentException(\"rule cannot be EMPTY\");\n-\n+            \n             if (!ruleIDs.add(rule.getId()))\n                 throw new IllegalArgumentException(\"Duplicate rule ID: \\\"\" + rule.getId() + \"\\\"\");\n-\n+            \n+            boolean registered = false;\n             for (Polygon border : rule.getBorders()) {\n                 Envelope borderEnvelope = border.getEnvelopeInternal();\n                 if (!maxBounds.intersects(borderEnvelope)) {\n                     continue;\n                 }\n-\n+                \n                 SpatialRuleContainer container = containerMap.get(border);\n                 if (container == null) {\n                     container = new SpatialRuleContainer(border);\n                     containerMap.put(border, container);\n                     index.insert(borderEnvelope, container);\n                 }\n                 container.addRule(rule);\n+                registered = true;\n+            }\n+            \n+            if (registered) {\n+                registeredRules.add(rule);\n             }\n         }\n \n         index.build();\n \n-        this.rules = new ArrayList<>();\n-        rules.add(SpatialRule.EMPTY);\n-        rules.addAll(spatialRules);\n+        Collections.sort(registeredRules, RULE_COMP); // keep the spatial id stable", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "affbc05bc34a3c49e763300bc57572f1e9e4aa7f"}, "originalPosition": 84}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDg2MTQ1Nw==", "bodyText": "I think we can drop it here as we're already passing in a sorted collection.", "url": "https://github.com/graphhopper/graphhopper/pull/1903#discussion_r390861457", "createdAt": "2020-03-11T10:04:24Z", "author": {"login": "otbutz"}, "path": "core/src/main/java/com/graphhopper/routing/util/spatialrules/SpatialRuleLookupJTS.java", "diffHunk": "@@ -17,110 +17,113 @@\n  */\n package com.graphhopper.routing.util.spatialrules;\n \n-import com.graphhopper.util.shapes.GHPoint;\n+import java.util.*;\n+\n import org.locationtech.jts.geom.*;\n import org.locationtech.jts.index.strtree.STRtree;\n \n-import java.util.*;\n-\n /**\n  * @author Thomas Butz\n  */\n public class SpatialRuleLookupJTS implements SpatialRuleLookup {\n-\n+    \n+    private static final Comparator<SpatialRule> RULE_COMP = new Comparator<SpatialRule>() {\n+\n+        @Override\n+        public int compare(SpatialRule o1, SpatialRule o2) {\n+            int comp = Integer.compare(o1.getPriority(), o2.getPriority());\n+            if (comp != 0) {\n+                return comp;\n+            }\n+            \n+            return o1.getId().compareTo(o2.getId());\n+        }\n+    };\n+    \n     private final GeometryFactory geometryFactory = new GeometryFactory();\n     private final List<SpatialRule> rules;\n     private final Envelope maxBounds;\n     private final STRtree index;\n-\n+    \n     public SpatialRuleLookupJTS(List<SpatialRule> spatialRules, Envelope maxBounds) {\n         this.index = new STRtree();\n-\n+        \n         Map<Polygon, SpatialRuleContainer> containerMap = new HashMap<>();\n+        List<SpatialRule> registeredRules = new ArrayList<>();\n         Set<String> ruleIDs = new HashSet<>();\n         for (SpatialRule rule : spatialRules) {\n             if (rule == null)\n                 throw new IllegalArgumentException(\"rule cannot be null\");\n-\n-            if (rule.equals(SpatialRule.EMPTY))\n-                throw new IllegalArgumentException(\"rule cannot be EMPTY\");\n-\n+            \n             if (!ruleIDs.add(rule.getId()))\n                 throw new IllegalArgumentException(\"Duplicate rule ID: \\\"\" + rule.getId() + \"\\\"\");\n-\n+            \n+            boolean registered = false;\n             for (Polygon border : rule.getBorders()) {\n                 Envelope borderEnvelope = border.getEnvelopeInternal();\n                 if (!maxBounds.intersects(borderEnvelope)) {\n                     continue;\n                 }\n-\n+                \n                 SpatialRuleContainer container = containerMap.get(border);\n                 if (container == null) {\n                     container = new SpatialRuleContainer(border);\n                     containerMap.put(border, container);\n                     index.insert(borderEnvelope, container);\n                 }\n                 container.addRule(rule);\n+                registered = true;\n+            }\n+            \n+            if (registered) {\n+                registeredRules.add(rule);\n             }\n         }\n \n         index.build();\n \n-        this.rules = new ArrayList<>();\n-        rules.add(SpatialRule.EMPTY);\n-        rules.addAll(spatialRules);\n+        Collections.sort(registeredRules, RULE_COMP); // keep the spatial id stable", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDI5NjU3MQ=="}, "originalCommit": {"oid": "affbc05bc34a3c49e763300bc57572f1e9e4aa7f"}, "originalPosition": 84}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQzNTY5MTE3OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/com/graphhopper/routing/util/spatialrules/SpatialRuleSet.java", "isResolved": true, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xNlQxMToxMjowMVrOF2vZKw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yM1QxMTo0NjoxMlrOF6B1EQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Mjk0MzkxNQ==", "bodyText": "Why do we need to add 1 when storing it into the edge? Also we should state it returns \"EMPTY.getSpatialId\" if it doesn't contain any rules.", "url": "https://github.com/graphhopper/graphhopper/pull/1903#discussion_r392943915", "createdAt": "2020-03-16T11:12:01Z", "author": {"login": "karussell"}, "path": "core/src/main/java/com/graphhopper/routing/util/spatialrules/SpatialRuleSet.java", "diffHunk": "@@ -0,0 +1,101 @@\n+/*\n+ *  Licensed to GraphHopper GmbH under one or more contributor\n+ *  license agreements. See the NOTICE file distributed with this work for\n+ *  additional information regarding copyright ownership.\n+ *\n+ *  GraphHopper GmbH licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except in\n+ *  compliance with the License. You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package com.graphhopper.routing.util.spatialrules;\n+\n+import java.util.Collections;\n+import java.util.List;\n+\n+import com.graphhopper.routing.profiles.RoadAccess;\n+import com.graphhopper.routing.profiles.RoadClass;\n+\n+/**\n+ * Contains all rules which are applicable for a certain position.\n+ * \n+ * @author Thomas Butz\n+ */\n+public class SpatialRuleSet {\n+    public static final SpatialRuleSet EMPTY = new SpatialRuleSet(Collections.<SpatialRule>emptyList(), -1);\n+    \n+    private final List<SpatialRule> rules;\n+    private final int spatialId;\n+\n+    /**\n+     * @param rules     a List of rules, ordered according to how they are to be applied\n+     * @param spatialId the index of the rule with the highest priority\n+     */\n+    public SpatialRuleSet(List<SpatialRule> rules, int spatialId) {\n+        this.rules = Collections.unmodifiableList(rules);\n+        this.spatialId = spatialId;\n+    }\n+    \n+    /**\n+     * Return the max speed for a certain road class.\n+     *\n+     * @param roadClass       The highway type, e.g. {@link RoadClass#MOTORWAY}\n+     * @param transport       The mode of transportation\n+     * @param currentMaxSpeed The current max speed value or -1 if no value has been set yet\n+     * @return the maximum speed value to be used\n+     */\n+    public double getMaxSpeed(RoadClass roadClass, TransportationMode transport, double currentMaxSpeed) {\n+        double value = currentMaxSpeed;\n+        for (SpatialRule rule : rules) {\n+            value = rule.getMaxSpeed(roadClass, transport, value);\n+        }\n+        return value;\n+    }\n+\n+    /**\n+     * Returns the {@link RoadAccess} for a certain highway type and transportation mode.\n+     *\n+     * @param roadClass          The highway type, e.g. {@link RoadClass#MOTORWAY}\n+     * @param transport          The mode of transportation\n+     * @param currentRoadAccess  The current road access value (default: {@link RoadAccess#YES})\n+     * @return the type of access to be used\n+     */\n+    public RoadAccess getAccess(RoadClass roadClass, TransportationMode transport, RoadAccess currentRoadAccess) {\n+        RoadAccess value = currentRoadAccess;\n+        for (SpatialRule rule : rules) {\n+            value = rule.getAccess(roadClass, transport, value);\n+        }\n+        return value;\n+    }\n+    \n+    /**\n+     * @return the rules in this set\n+     */\n+    public List<SpatialRule> getRules() {\n+        return rules;\n+    }\n+\n+    /**\n+     * @return the index of the rule with the highest priority or\n+     *         <i>-1</i> if the set doesn't contain any rules\n+     */\n+    public int getSpatialId() {\n+        return spatialId;\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3a55d9eedb354a7fcd920c2ab9838dc8dc1a94b8"}, "originalPosition": 91}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzUxODM5NQ==", "bodyText": "The spatial ID is stored as an IntEncodedValue and therefor needs to be unsigned. As -1 is used to indicate \"no rules applied\" i'm adding 1 to avoid signed values. But i'm open for suggestions \ud83d\ude09\nIMHO the Javadoc of SpatialRuleSet.getSpatialId() is pretty clear about this:\n\nthe index of the rule with the highest priority or -1 if the set doesn't contain any rules", "url": "https://github.com/graphhopper/graphhopper/pull/1903#discussion_r393518395", "createdAt": "2020-03-17T08:41:36Z", "author": {"login": "otbutz"}, "path": "core/src/main/java/com/graphhopper/routing/util/spatialrules/SpatialRuleSet.java", "diffHunk": "@@ -0,0 +1,101 @@\n+/*\n+ *  Licensed to GraphHopper GmbH under one or more contributor\n+ *  license agreements. See the NOTICE file distributed with this work for\n+ *  additional information regarding copyright ownership.\n+ *\n+ *  GraphHopper GmbH licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except in\n+ *  compliance with the License. You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package com.graphhopper.routing.util.spatialrules;\n+\n+import java.util.Collections;\n+import java.util.List;\n+\n+import com.graphhopper.routing.profiles.RoadAccess;\n+import com.graphhopper.routing.profiles.RoadClass;\n+\n+/**\n+ * Contains all rules which are applicable for a certain position.\n+ * \n+ * @author Thomas Butz\n+ */\n+public class SpatialRuleSet {\n+    public static final SpatialRuleSet EMPTY = new SpatialRuleSet(Collections.<SpatialRule>emptyList(), -1);\n+    \n+    private final List<SpatialRule> rules;\n+    private final int spatialId;\n+\n+    /**\n+     * @param rules     a List of rules, ordered according to how they are to be applied\n+     * @param spatialId the index of the rule with the highest priority\n+     */\n+    public SpatialRuleSet(List<SpatialRule> rules, int spatialId) {\n+        this.rules = Collections.unmodifiableList(rules);\n+        this.spatialId = spatialId;\n+    }\n+    \n+    /**\n+     * Return the max speed for a certain road class.\n+     *\n+     * @param roadClass       The highway type, e.g. {@link RoadClass#MOTORWAY}\n+     * @param transport       The mode of transportation\n+     * @param currentMaxSpeed The current max speed value or -1 if no value has been set yet\n+     * @return the maximum speed value to be used\n+     */\n+    public double getMaxSpeed(RoadClass roadClass, TransportationMode transport, double currentMaxSpeed) {\n+        double value = currentMaxSpeed;\n+        for (SpatialRule rule : rules) {\n+            value = rule.getMaxSpeed(roadClass, transport, value);\n+        }\n+        return value;\n+    }\n+\n+    /**\n+     * Returns the {@link RoadAccess} for a certain highway type and transportation mode.\n+     *\n+     * @param roadClass          The highway type, e.g. {@link RoadClass#MOTORWAY}\n+     * @param transport          The mode of transportation\n+     * @param currentRoadAccess  The current road access value (default: {@link RoadAccess#YES})\n+     * @return the type of access to be used\n+     */\n+    public RoadAccess getAccess(RoadClass roadClass, TransportationMode transport, RoadAccess currentRoadAccess) {\n+        RoadAccess value = currentRoadAccess;\n+        for (SpatialRule rule : rules) {\n+            value = rule.getAccess(roadClass, transport, value);\n+        }\n+        return value;\n+    }\n+    \n+    /**\n+     * @return the rules in this set\n+     */\n+    public List<SpatialRule> getRules() {\n+        return rules;\n+    }\n+\n+    /**\n+     * @return the index of the rule with the highest priority or\n+     *         <i>-1</i> if the set doesn't contain any rules\n+     */\n+    public int getSpatialId() {\n+        return spatialId;\n+    }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Mjk0MzkxNQ=="}, "originalCommit": {"oid": "3a55d9eedb354a7fcd920c2ab9838dc8dc1a94b8"}, "originalPosition": 91}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjM3MDIyMA==", "bodyText": "Could we also use 0 for this \"on rule\" indicator? Like we currently seem to do:\nspatialRuleEnc.setInt(false, edgeFlags, spatialRuleLookup.getSpatialId(rule));", "url": "https://github.com/graphhopper/graphhopper/pull/1903#discussion_r396370220", "createdAt": "2020-03-23T11:05:46Z", "author": {"login": "karussell"}, "path": "core/src/main/java/com/graphhopper/routing/util/spatialrules/SpatialRuleSet.java", "diffHunk": "@@ -0,0 +1,101 @@\n+/*\n+ *  Licensed to GraphHopper GmbH under one or more contributor\n+ *  license agreements. See the NOTICE file distributed with this work for\n+ *  additional information regarding copyright ownership.\n+ *\n+ *  GraphHopper GmbH licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except in\n+ *  compliance with the License. You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package com.graphhopper.routing.util.spatialrules;\n+\n+import java.util.Collections;\n+import java.util.List;\n+\n+import com.graphhopper.routing.profiles.RoadAccess;\n+import com.graphhopper.routing.profiles.RoadClass;\n+\n+/**\n+ * Contains all rules which are applicable for a certain position.\n+ * \n+ * @author Thomas Butz\n+ */\n+public class SpatialRuleSet {\n+    public static final SpatialRuleSet EMPTY = new SpatialRuleSet(Collections.<SpatialRule>emptyList(), -1);\n+    \n+    private final List<SpatialRule> rules;\n+    private final int spatialId;\n+\n+    /**\n+     * @param rules     a List of rules, ordered according to how they are to be applied\n+     * @param spatialId the index of the rule with the highest priority\n+     */\n+    public SpatialRuleSet(List<SpatialRule> rules, int spatialId) {\n+        this.rules = Collections.unmodifiableList(rules);\n+        this.spatialId = spatialId;\n+    }\n+    \n+    /**\n+     * Return the max speed for a certain road class.\n+     *\n+     * @param roadClass       The highway type, e.g. {@link RoadClass#MOTORWAY}\n+     * @param transport       The mode of transportation\n+     * @param currentMaxSpeed The current max speed value or -1 if no value has been set yet\n+     * @return the maximum speed value to be used\n+     */\n+    public double getMaxSpeed(RoadClass roadClass, TransportationMode transport, double currentMaxSpeed) {\n+        double value = currentMaxSpeed;\n+        for (SpatialRule rule : rules) {\n+            value = rule.getMaxSpeed(roadClass, transport, value);\n+        }\n+        return value;\n+    }\n+\n+    /**\n+     * Returns the {@link RoadAccess} for a certain highway type and transportation mode.\n+     *\n+     * @param roadClass          The highway type, e.g. {@link RoadClass#MOTORWAY}\n+     * @param transport          The mode of transportation\n+     * @param currentRoadAccess  The current road access value (default: {@link RoadAccess#YES})\n+     * @return the type of access to be used\n+     */\n+    public RoadAccess getAccess(RoadClass roadClass, TransportationMode transport, RoadAccess currentRoadAccess) {\n+        RoadAccess value = currentRoadAccess;\n+        for (SpatialRule rule : rules) {\n+            value = rule.getAccess(roadClass, transport, value);\n+        }\n+        return value;\n+    }\n+    \n+    /**\n+     * @return the rules in this set\n+     */\n+    public List<SpatialRule> getRules() {\n+        return rules;\n+    }\n+\n+    /**\n+     * @return the index of the rule with the highest priority or\n+     *         <i>-1</i> if the set doesn't contain any rules\n+     */\n+    public int getSpatialId() {\n+        return spatialId;\n+    }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Mjk0MzkxNQ=="}, "originalCommit": {"oid": "3a55d9eedb354a7fcd920c2ab9838dc8dc1a94b8"}, "originalPosition": 91}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjM4Mjk0OA==", "bodyText": "I think it's a matter of personal preference. -1 is a widely acknowledged default to indicate a missing element (e.g Javas List.indexOf()). The limitation to use non-negative numbers is enforced by the graph storage and should therefore be handled there.", "url": "https://github.com/graphhopper/graphhopper/pull/1903#discussion_r396382948", "createdAt": "2020-03-23T11:28:55Z", "author": {"login": "otbutz"}, "path": "core/src/main/java/com/graphhopper/routing/util/spatialrules/SpatialRuleSet.java", "diffHunk": "@@ -0,0 +1,101 @@\n+/*\n+ *  Licensed to GraphHopper GmbH under one or more contributor\n+ *  license agreements. See the NOTICE file distributed with this work for\n+ *  additional information regarding copyright ownership.\n+ *\n+ *  GraphHopper GmbH licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except in\n+ *  compliance with the License. You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package com.graphhopper.routing.util.spatialrules;\n+\n+import java.util.Collections;\n+import java.util.List;\n+\n+import com.graphhopper.routing.profiles.RoadAccess;\n+import com.graphhopper.routing.profiles.RoadClass;\n+\n+/**\n+ * Contains all rules which are applicable for a certain position.\n+ * \n+ * @author Thomas Butz\n+ */\n+public class SpatialRuleSet {\n+    public static final SpatialRuleSet EMPTY = new SpatialRuleSet(Collections.<SpatialRule>emptyList(), -1);\n+    \n+    private final List<SpatialRule> rules;\n+    private final int spatialId;\n+\n+    /**\n+     * @param rules     a List of rules, ordered according to how they are to be applied\n+     * @param spatialId the index of the rule with the highest priority\n+     */\n+    public SpatialRuleSet(List<SpatialRule> rules, int spatialId) {\n+        this.rules = Collections.unmodifiableList(rules);\n+        this.spatialId = spatialId;\n+    }\n+    \n+    /**\n+     * Return the max speed for a certain road class.\n+     *\n+     * @param roadClass       The highway type, e.g. {@link RoadClass#MOTORWAY}\n+     * @param transport       The mode of transportation\n+     * @param currentMaxSpeed The current max speed value or -1 if no value has been set yet\n+     * @return the maximum speed value to be used\n+     */\n+    public double getMaxSpeed(RoadClass roadClass, TransportationMode transport, double currentMaxSpeed) {\n+        double value = currentMaxSpeed;\n+        for (SpatialRule rule : rules) {\n+            value = rule.getMaxSpeed(roadClass, transport, value);\n+        }\n+        return value;\n+    }\n+\n+    /**\n+     * Returns the {@link RoadAccess} for a certain highway type and transportation mode.\n+     *\n+     * @param roadClass          The highway type, e.g. {@link RoadClass#MOTORWAY}\n+     * @param transport          The mode of transportation\n+     * @param currentRoadAccess  The current road access value (default: {@link RoadAccess#YES})\n+     * @return the type of access to be used\n+     */\n+    public RoadAccess getAccess(RoadClass roadClass, TransportationMode transport, RoadAccess currentRoadAccess) {\n+        RoadAccess value = currentRoadAccess;\n+        for (SpatialRule rule : rules) {\n+            value = rule.getAccess(roadClass, transport, value);\n+        }\n+        return value;\n+    }\n+    \n+    /**\n+     * @return the rules in this set\n+     */\n+    public List<SpatialRule> getRules() {\n+        return rules;\n+    }\n+\n+    /**\n+     * @return the index of the rule with the highest priority or\n+     *         <i>-1</i> if the set doesn't contain any rules\n+     */\n+    public int getSpatialId() {\n+        return spatialId;\n+    }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Mjk0MzkxNQ=="}, "originalCommit": {"oid": "3a55d9eedb354a7fcd920c2ab9838dc8dc1a94b8"}, "originalPosition": 91}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjM5MTY5Nw==", "bodyText": "It is certainly a limitation of the storage and also the normal return value for a search is -1, but 0 is also the \"Java default\" for all numbers and \"no rule\" can be seen as the default value. Also I'm unsure why we should introduce this change when \"empty\" worked as 0 before.", "url": "https://github.com/graphhopper/graphhopper/pull/1903#discussion_r396391697", "createdAt": "2020-03-23T11:46:12Z", "author": {"login": "karussell"}, "path": "core/src/main/java/com/graphhopper/routing/util/spatialrules/SpatialRuleSet.java", "diffHunk": "@@ -0,0 +1,101 @@\n+/*\n+ *  Licensed to GraphHopper GmbH under one or more contributor\n+ *  license agreements. See the NOTICE file distributed with this work for\n+ *  additional information regarding copyright ownership.\n+ *\n+ *  GraphHopper GmbH licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except in\n+ *  compliance with the License. You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package com.graphhopper.routing.util.spatialrules;\n+\n+import java.util.Collections;\n+import java.util.List;\n+\n+import com.graphhopper.routing.profiles.RoadAccess;\n+import com.graphhopper.routing.profiles.RoadClass;\n+\n+/**\n+ * Contains all rules which are applicable for a certain position.\n+ * \n+ * @author Thomas Butz\n+ */\n+public class SpatialRuleSet {\n+    public static final SpatialRuleSet EMPTY = new SpatialRuleSet(Collections.<SpatialRule>emptyList(), -1);\n+    \n+    private final List<SpatialRule> rules;\n+    private final int spatialId;\n+\n+    /**\n+     * @param rules     a List of rules, ordered according to how they are to be applied\n+     * @param spatialId the index of the rule with the highest priority\n+     */\n+    public SpatialRuleSet(List<SpatialRule> rules, int spatialId) {\n+        this.rules = Collections.unmodifiableList(rules);\n+        this.spatialId = spatialId;\n+    }\n+    \n+    /**\n+     * Return the max speed for a certain road class.\n+     *\n+     * @param roadClass       The highway type, e.g. {@link RoadClass#MOTORWAY}\n+     * @param transport       The mode of transportation\n+     * @param currentMaxSpeed The current max speed value or -1 if no value has been set yet\n+     * @return the maximum speed value to be used\n+     */\n+    public double getMaxSpeed(RoadClass roadClass, TransportationMode transport, double currentMaxSpeed) {\n+        double value = currentMaxSpeed;\n+        for (SpatialRule rule : rules) {\n+            value = rule.getMaxSpeed(roadClass, transport, value);\n+        }\n+        return value;\n+    }\n+\n+    /**\n+     * Returns the {@link RoadAccess} for a certain highway type and transportation mode.\n+     *\n+     * @param roadClass          The highway type, e.g. {@link RoadClass#MOTORWAY}\n+     * @param transport          The mode of transportation\n+     * @param currentRoadAccess  The current road access value (default: {@link RoadAccess#YES})\n+     * @return the type of access to be used\n+     */\n+    public RoadAccess getAccess(RoadClass roadClass, TransportationMode transport, RoadAccess currentRoadAccess) {\n+        RoadAccess value = currentRoadAccess;\n+        for (SpatialRule rule : rules) {\n+            value = rule.getAccess(roadClass, transport, value);\n+        }\n+        return value;\n+    }\n+    \n+    /**\n+     * @return the rules in this set\n+     */\n+    public List<SpatialRule> getRules() {\n+        return rules;\n+    }\n+\n+    /**\n+     * @return the index of the rule with the highest priority or\n+     *         <i>-1</i> if the set doesn't contain any rules\n+     */\n+    public int getSpatialId() {\n+        return spatialId;\n+    }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Mjk0MzkxNQ=="}, "originalCommit": {"oid": "3a55d9eedb354a7fcd920c2ab9838dc8dc1a94b8"}, "originalPosition": 91}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU3NzQ1MjY4OnYy", "diffSide": "LEFT", "path": "core/src/main/java/com/graphhopper/routing/lm/LandmarkStorage.java", "isResolved": false, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yNFQxNDozNDowOVrOGLaoXw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yN1QxNDoyNTozM1rOGMl9zg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDYyMzgzOQ==", "bodyText": "@otbutz if the first SpatialRule is always available should we provide a convenient method for this? Or will it be rather rare use case?", "url": "https://github.com/graphhopper/graphhopper/pull/1903#discussion_r414623839", "createdAt": "2020-04-24T14:34:09Z", "author": {"login": "karussell"}, "path": "core/src/main/java/com/graphhopper/routing/lm/LandmarkStorage.java", "diffHunk": "@@ -464,10 +464,10 @@ protected IntHashSet findBorderEdgeIds(SpatialRuleLookup ruleLookup) {\n         IntHashSet inaccessible = new IntHashSet();\n         while (allEdgesIterator.next()) {\n             int adjNode = allEdgesIterator.getAdjNode();\n-            SpatialRule ruleAdj = ruleLookup.lookupRule(nodeAccess.getLatitude(adjNode), nodeAccess.getLongitude(adjNode));\n+            SpatialRule ruleAdj = ruleLookup.lookupRules(nodeAccess.getLatitude(adjNode), nodeAccess.getLongitude(adjNode)).getRules().get(0);\n \n             int baseNode = allEdgesIterator.getBaseNode();\n-            SpatialRule ruleBase = ruleLookup.lookupRule(nodeAccess.getLatitude(baseNode), nodeAccess.getLongitude(baseNode));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "159602212a4d0893d5ad3fadf4c5c3b4ae2350cd"}, "originalPosition": 26}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDYzMDgwNQ==", "bodyText": "No, it is not always available per se. The landmark use case is a bit special in that respect.", "url": "https://github.com/graphhopper/graphhopper/pull/1903#discussion_r414630805", "createdAt": "2020-04-24T14:43:08Z", "author": {"login": "otbutz"}, "path": "core/src/main/java/com/graphhopper/routing/lm/LandmarkStorage.java", "diffHunk": "@@ -464,10 +464,10 @@ protected IntHashSet findBorderEdgeIds(SpatialRuleLookup ruleLookup) {\n         IntHashSet inaccessible = new IntHashSet();\n         while (allEdgesIterator.next()) {\n             int adjNode = allEdgesIterator.getAdjNode();\n-            SpatialRule ruleAdj = ruleLookup.lookupRule(nodeAccess.getLatitude(adjNode), nodeAccess.getLongitude(adjNode));\n+            SpatialRule ruleAdj = ruleLookup.lookupRules(nodeAccess.getLatitude(adjNode), nodeAccess.getLongitude(adjNode)).getRules().get(0);\n \n             int baseNode = allEdgesIterator.getBaseNode();\n-            SpatialRule ruleBase = ruleLookup.lookupRule(nodeAccess.getLatitude(baseNode), nodeAccess.getLongitude(baseNode));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDYyMzgzOQ=="}, "originalCommit": {"oid": "159602212a4d0893d5ad3fadf4c5c3b4ae2350cd"}, "originalPosition": 26}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDY0NTc5Ng==", "bodyText": "Ok, so if no rule is available the list could be empty (unlike before where you got SpatialRule.EMPTY?)", "url": "https://github.com/graphhopper/graphhopper/pull/1903#discussion_r414645796", "createdAt": "2020-04-24T15:02:30Z", "author": {"login": "karussell"}, "path": "core/src/main/java/com/graphhopper/routing/lm/LandmarkStorage.java", "diffHunk": "@@ -464,10 +464,10 @@ protected IntHashSet findBorderEdgeIds(SpatialRuleLookup ruleLookup) {\n         IntHashSet inaccessible = new IntHashSet();\n         while (allEdgesIterator.next()) {\n             int adjNode = allEdgesIterator.getAdjNode();\n-            SpatialRule ruleAdj = ruleLookup.lookupRule(nodeAccess.getLatitude(adjNode), nodeAccess.getLongitude(adjNode));\n+            SpatialRule ruleAdj = ruleLookup.lookupRules(nodeAccess.getLatitude(adjNode), nodeAccess.getLongitude(adjNode)).getRules().get(0);\n \n             int baseNode = allEdgesIterator.getBaseNode();\n-            SpatialRule ruleBase = ruleLookup.lookupRule(nodeAccess.getLatitude(baseNode), nodeAccess.getLongitude(baseNode));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDYyMzgzOQ=="}, "originalCommit": {"oid": "159602212a4d0893d5ad3fadf4c5c3b4ae2350cd"}, "originalPosition": 26}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTU0MzY5NQ==", "bodyText": "Correct. If no rules apply, an empty List is returned.", "url": "https://github.com/graphhopper/graphhopper/pull/1903#discussion_r415543695", "createdAt": "2020-04-27T06:27:58Z", "author": {"login": "otbutz"}, "path": "core/src/main/java/com/graphhopper/routing/lm/LandmarkStorage.java", "diffHunk": "@@ -464,10 +464,10 @@ protected IntHashSet findBorderEdgeIds(SpatialRuleLookup ruleLookup) {\n         IntHashSet inaccessible = new IntHashSet();\n         while (allEdgesIterator.next()) {\n             int adjNode = allEdgesIterator.getAdjNode();\n-            SpatialRule ruleAdj = ruleLookup.lookupRule(nodeAccess.getLatitude(adjNode), nodeAccess.getLongitude(adjNode));\n+            SpatialRule ruleAdj = ruleLookup.lookupRules(nodeAccess.getLatitude(adjNode), nodeAccess.getLongitude(adjNode)).getRules().get(0);\n \n             int baseNode = allEdgesIterator.getBaseNode();\n-            SpatialRule ruleBase = ruleLookup.lookupRule(nodeAccess.getLatitude(baseNode), nodeAccess.getLongitude(baseNode));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDYyMzgzOQ=="}, "originalCommit": {"oid": "159602212a4d0893d5ad3fadf4c5c3b4ae2350cd"}, "originalPosition": 26}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTg1ODEyNg==", "bodyText": "There seems to be a problem with this code: #2020", "url": "https://github.com/graphhopper/graphhopper/pull/1903#discussion_r415858126", "createdAt": "2020-04-27T14:25:33Z", "author": {"login": "karussell"}, "path": "core/src/main/java/com/graphhopper/routing/lm/LandmarkStorage.java", "diffHunk": "@@ -464,10 +464,10 @@ protected IntHashSet findBorderEdgeIds(SpatialRuleLookup ruleLookup) {\n         IntHashSet inaccessible = new IntHashSet();\n         while (allEdgesIterator.next()) {\n             int adjNode = allEdgesIterator.getAdjNode();\n-            SpatialRule ruleAdj = ruleLookup.lookupRule(nodeAccess.getLatitude(adjNode), nodeAccess.getLongitude(adjNode));\n+            SpatialRule ruleAdj = ruleLookup.lookupRules(nodeAccess.getLatitude(adjNode), nodeAccess.getLongitude(adjNode)).getRules().get(0);\n \n             int baseNode = allEdgesIterator.getBaseNode();\n-            SpatialRule ruleBase = ruleLookup.lookupRule(nodeAccess.getLatitude(baseNode), nodeAccess.getLongitude(baseNode));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDYyMzgzOQ=="}, "originalCommit": {"oid": "159602212a4d0893d5ad3fadf4c5c3b4ae2350cd"}, "originalPosition": 26}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4706, "cost": 1, "resetAt": "2021-11-12T20:28:25Z"}}}