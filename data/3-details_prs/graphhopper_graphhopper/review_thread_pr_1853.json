{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzY0MTQzOTUx", "number": 1853, "reviewThreads": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xN1QxNDoxODozN1rODY1KCw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yMlQxNjowODo0OFrODZ41gQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI3MzYzMzM5OnYy", "diffSide": "RIGHT", "path": "api/src/main/java/com/graphhopper/util/PointList.java", "isResolved": false, "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xN1QxNDoxODozN1rOFe6UOw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yMFQxNDo1NTo1NFrOFfg59A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzk1NzA1MQ==", "bodyText": "Wouldn't it be better to create a factory for 2D and 3D each and keep them?", "url": "https://github.com/graphhopper/graphhopper/pull/1853#discussion_r367957051", "createdAt": "2020-01-17T14:18:37Z", "author": {"login": "otbutz"}, "path": "api/src/main/java/com/graphhopper/util/PointList.java", "diffHunk": "@@ -399,7 +404,10 @@ public static PointList fromLineString(LineString lineString) {\n     }\n \n     public LineString toLineString(boolean includeElevation) {\n-        GeometryFactory gf = new GeometryFactory();\n+        return toLineString(new GeometryFactory(), includeElevation);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7a730cfcd163346c59520aed8afbc59ead35696a"}, "originalPosition": 29}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODE1MTM4Mg==", "bodyText": "Have done this (one static factory). Or why would we want 2?", "url": "https://github.com/graphhopper/graphhopper/pull/1853#discussion_r368151382", "createdAt": "2020-01-17T21:51:56Z", "author": {"login": "karussell"}, "path": "api/src/main/java/com/graphhopper/util/PointList.java", "diffHunk": "@@ -399,7 +404,10 @@ public static PointList fromLineString(LineString lineString) {\n     }\n \n     public LineString toLineString(boolean includeElevation) {\n-        GeometryFactory gf = new GeometryFactory();\n+        return toLineString(new GeometryFactory(), includeElevation);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzk1NzA1MQ=="}, "originalCommit": {"oid": "7a730cfcd163346c59520aed8afbc59ead35696a"}, "originalPosition": 29}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODQ1MDU2MQ==", "bodyText": "GeometryFactory FAC_2D = new GeometryFactory(new PackedCoordinateSequenceFactory(DOUBLE, 2));\nGeometryFactory FAC_3D = new GeometryFactory(new PackedCoordinateSequenceFactory(DOUBLE, 3));\nincludeElevation would just toggle which one of the two is being passed to the function. No need to create new objects here.", "url": "https://github.com/graphhopper/graphhopper/pull/1853#discussion_r368450561", "createdAt": "2020-01-20T09:43:35Z", "author": {"login": "otbutz"}, "path": "api/src/main/java/com/graphhopper/util/PointList.java", "diffHunk": "@@ -399,7 +404,10 @@ public static PointList fromLineString(LineString lineString) {\n     }\n \n     public LineString toLineString(boolean includeElevation) {\n-        GeometryFactory gf = new GeometryFactory();\n+        return toLineString(new GeometryFactory(), includeElevation);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzk1NzA1MQ=="}, "originalCommit": {"oid": "7a730cfcd163346c59520aed8afbc59ead35696a"}, "originalPosition": 29}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODU2ODg0OA==", "bodyText": "Have adapted the current code (via a single factory). Or will there be something different with your proposed change?", "url": "https://github.com/graphhopper/graphhopper/pull/1853#discussion_r368568848", "createdAt": "2020-01-20T14:15:15Z", "author": {"login": "karussell"}, "path": "api/src/main/java/com/graphhopper/util/PointList.java", "diffHunk": "@@ -399,7 +404,10 @@ public static PointList fromLineString(LineString lineString) {\n     }\n \n     public LineString toLineString(boolean includeElevation) {\n-        GeometryFactory gf = new GeometryFactory();\n+        return toLineString(new GeometryFactory(), includeElevation);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzk1NzA1MQ=="}, "originalCommit": {"oid": "7a730cfcd163346c59520aed8afbc59ead35696a"}, "originalPosition": 29}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODU3NTk3NA==", "bodyText": "You can drop all new PackedCoordinateSequence(...) calls:\n2D_FAC.createPolygon(coordinates);", "url": "https://github.com/graphhopper/graphhopper/pull/1853#discussion_r368575974", "createdAt": "2020-01-20T14:29:47Z", "author": {"login": "otbutz"}, "path": "api/src/main/java/com/graphhopper/util/PointList.java", "diffHunk": "@@ -399,7 +404,10 @@ public static PointList fromLineString(LineString lineString) {\n     }\n \n     public LineString toLineString(boolean includeElevation) {\n-        GeometryFactory gf = new GeometryFactory();\n+        return toLineString(new GeometryFactory(), includeElevation);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzk1NzA1MQ=="}, "originalCommit": {"oid": "7a730cfcd163346c59520aed8afbc59ead35696a"}, "originalPosition": 29}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODU4OTMwMA==", "bodyText": "Hmmh, maybe you mean something else? There is just one call and it is:\nreturn factory.createLineString(new PackedCoordinateSequence.Double(coordinates, includeElevation ? 3 : 2));", "url": "https://github.com/graphhopper/graphhopper/pull/1853#discussion_r368589300", "createdAt": "2020-01-20T14:55:54Z", "author": {"login": "karussell"}, "path": "api/src/main/java/com/graphhopper/util/PointList.java", "diffHunk": "@@ -399,7 +404,10 @@ public static PointList fromLineString(LineString lineString) {\n     }\n \n     public LineString toLineString(boolean includeElevation) {\n-        GeometryFactory gf = new GeometryFactory();\n+        return toLineString(new GeometryFactory(), includeElevation);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzk1NzA1MQ=="}, "originalCommit": {"oid": "7a730cfcd163346c59520aed8afbc59ead35696a"}, "originalPosition": 29}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI3MzY2MjA4OnYy", "diffSide": "RIGHT", "path": "api/src/main/java/com/graphhopper/util/shapes/Polygon.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xN1QxNDoyNzozM1rOFe6mBQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yMFQxNDoxMzoxNlrOFffmOQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzk2MTYwNQ==", "bodyText": "We could check the envelope first.", "url": "https://github.com/graphhopper/graphhopper/pull/1853#discussion_r367961605", "createdAt": "2020-01-17T14:27:33Z", "author": {"login": "otbutz"}, "path": "api/src/main/java/com/graphhopper/util/shapes/Polygon.java", "diffHunk": "@@ -17,117 +17,72 @@\n  */\n package com.graphhopper.util.shapes;\n \n+import com.graphhopper.util.PointList;\n+import org.locationtech.jts.geom.Coordinate;\n+import org.locationtech.jts.geom.Envelope;\n+import org.locationtech.jts.geom.GeometryFactory;\n+import org.locationtech.jts.geom.Point;\n+import org.locationtech.jts.geom.impl.PackedCoordinateSequence;\n+import org.locationtech.jts.geom.prep.PreparedGeometry;\n+import org.locationtech.jts.geom.prep.PreparedPolygon;\n+\n+import java.util.Arrays;\n+\n /**\n  * This class represents a polygon that is defined by a set of points.\n  * Every point i is connected to point i-1 and i+1.\n- * <p>\n- * TODO: Howto design inner rings in the polygon?\n  *\n  * @author Robin Boldt\n  */\n public class Polygon implements Shape {\n \n-    private final double[] lat;\n-    private final double[] lon;\n+    private final GeometryFactory factory = new GeometryFactory();\n+    private final PreparedGeometry polygon;\n+    private final Envelope envelope;\n \n-    private double minLat;\n-    private double minLon;\n-    private double maxLat;\n-    private double maxLon;\n+    public Polygon(PreparedGeometry polygon) {\n+        this.polygon = polygon;\n+        this.envelope = polygon.getGeometry().getEnvelopeInternal();\n+    }\n \n-    private final double epsilon;\n+    public Polygon(double[] lats, double[] lons) {\n+        if (lats.length != lons.length)\n+            throw new IllegalArgumentException(\"Points must be of equal length but was \" + lats.length + \" vs. \" + lons.length);\n \n-    public Polygon(double[] lat, double[] lon, double growFactor) {\n-        if (lat.length != lon.length) {\n-            throw new IllegalArgumentException(\"Points must be of equal length but was \" + lat.length + \" vs. \" + lon.length);\n-        }\n-        if (lat.length == 0) {\n+        if (lats.length == 0)\n             throw new IllegalArgumentException(\"Points must not be empty\");\n-        }\n-        this.lat = lat;\n-        this.lon = lon;\n-\n-        for (int i = 0; i < lat.length; i++) {\n-            if (i == 0) {\n-                minLat = lat[i];\n-                maxLat = lat[i];\n-                minLon = lon[i];\n-                maxLon = lon[i];\n-            } else {\n-                if (lat[i] < minLat) {\n-                    minLat = lat[i];\n-                } else if (lat[i] > maxLat) {\n-                    maxLat = lat[i];\n-                }\n-                if (lon[i] < minLon) {\n-                    minLon = lon[i];\n-                } else if (lon[i] > maxLon) {\n-                    maxLon = lon[i];\n-                }\n-            }\n-        }\n \n-        minLat -= growFactor;\n-        minLon -= growFactor;\n-        maxLat += growFactor;\n-        maxLon += growFactor;\n-\n-        epsilon = (maxLat - minLat) / 10;\n-    }\n-\n-    public Polygon(double[] lat, double[] lon) {\n-        this(lat, lon, 0);\n-    }\n-\n-    /**\n-     * Lossy conversion to a GraphHopper Polygon.\n-     */\n-    public static Polygon create(org.locationtech.jts.geom.Polygon polygon) {\n-        double[] lats = new double[polygon.getNumPoints()];\n-        double[] lons = new double[polygon.getNumPoints()];\n-        for (int i = 0; i < polygon.getNumPoints(); i++) {\n-            lats[i] = polygon.getCoordinates()[i].y;\n-            lons[i] = polygon.getCoordinates()[i].x;\n+        Coordinate[] coordinates = new Coordinate[lats.length + 1];\n+        for (int i = 0; i < lats.length; i++) {\n+            coordinates[i] = new Coordinate(lons[i], lats[i]);\n         }\n-        return new Polygon(lats, lons);\n+        coordinates[lats.length] = coordinates[0];\n+        this.polygon = new PreparedPolygon(factory.createPolygon(new PackedCoordinateSequence.Double(coordinates, 2)));\n+        this.envelope = polygon.getGeometry().getEnvelopeInternal();\n     }\n \n-    /**\n-     * Wrapper method for {@link Polygon#contains(double, double)}.\n-     */\n-    public boolean contains(GHPoint point) {\n-        return contains(point.lat, point.lon);\n+    public static Polygon create(org.locationtech.jts.geom.Polygon polygon) {\n+        return new Polygon(new PreparedPolygon(polygon));\n     }\n \n     @Override\n     public boolean intersects(Shape o) {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n+        throw new IllegalArgumentException(\"Polygon.intersects: shape not supported\");\n+    }\n+\n+    public boolean intersects(PointList pointList) {\n+        return polygon.intersects(pointList.getCachedLineString(factory, false));\n     }\n \n     /**\n-     * Implements the ray casting algorithm\n-     * Code is inspired from here: http://stackoverflow.com/a/218081/1548788\n+     * Does the point in polygon check.\n      *\n      * @param lat Latitude of the point to be checked\n      * @param lon Longitude of the point to be checked\n      * @return true if point is inside polygon\n      */\n     public boolean contains(double lat, double lon) {\n-        if (lat < minLat || lat > maxLat || lon < minLon || lon > maxLon) {\n-            return false;\n-        }\n-\n-        double rayStartLat = maxLat - (minLat / 2);\n-        double rayStartLon = minLon - epsilon;\n-\n-        boolean inside = false;\n-        int len = this.lat.length;\n-        for (int i = 0; i < len; i++) {\n-            if (edgesAreIntersecting(rayStartLon, rayStartLat, lon, lat, this.lon[i], this.lat[i], this.lon[(i + 1) % len], this.lat[(i + 1) % len]))\n-                inside = !inside;\n-        }\n-        return inside;\n-\n+        return polygon.contains(factory.createPoint(new Coordinate(lon, lat)));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7a730cfcd163346c59520aed8afbc59ead35696a"}, "originalPosition": 151}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODE1MTkxOA==", "bodyText": "This should be done from JTS.", "url": "https://github.com/graphhopper/graphhopper/pull/1853#discussion_r368151918", "createdAt": "2020-01-17T21:53:39Z", "author": {"login": "karussell"}, "path": "api/src/main/java/com/graphhopper/util/shapes/Polygon.java", "diffHunk": "@@ -17,117 +17,72 @@\n  */\n package com.graphhopper.util.shapes;\n \n+import com.graphhopper.util.PointList;\n+import org.locationtech.jts.geom.Coordinate;\n+import org.locationtech.jts.geom.Envelope;\n+import org.locationtech.jts.geom.GeometryFactory;\n+import org.locationtech.jts.geom.Point;\n+import org.locationtech.jts.geom.impl.PackedCoordinateSequence;\n+import org.locationtech.jts.geom.prep.PreparedGeometry;\n+import org.locationtech.jts.geom.prep.PreparedPolygon;\n+\n+import java.util.Arrays;\n+\n /**\n  * This class represents a polygon that is defined by a set of points.\n  * Every point i is connected to point i-1 and i+1.\n- * <p>\n- * TODO: Howto design inner rings in the polygon?\n  *\n  * @author Robin Boldt\n  */\n public class Polygon implements Shape {\n \n-    private final double[] lat;\n-    private final double[] lon;\n+    private final GeometryFactory factory = new GeometryFactory();\n+    private final PreparedGeometry polygon;\n+    private final Envelope envelope;\n \n-    private double minLat;\n-    private double minLon;\n-    private double maxLat;\n-    private double maxLon;\n+    public Polygon(PreparedGeometry polygon) {\n+        this.polygon = polygon;\n+        this.envelope = polygon.getGeometry().getEnvelopeInternal();\n+    }\n \n-    private final double epsilon;\n+    public Polygon(double[] lats, double[] lons) {\n+        if (lats.length != lons.length)\n+            throw new IllegalArgumentException(\"Points must be of equal length but was \" + lats.length + \" vs. \" + lons.length);\n \n-    public Polygon(double[] lat, double[] lon, double growFactor) {\n-        if (lat.length != lon.length) {\n-            throw new IllegalArgumentException(\"Points must be of equal length but was \" + lat.length + \" vs. \" + lon.length);\n-        }\n-        if (lat.length == 0) {\n+        if (lats.length == 0)\n             throw new IllegalArgumentException(\"Points must not be empty\");\n-        }\n-        this.lat = lat;\n-        this.lon = lon;\n-\n-        for (int i = 0; i < lat.length; i++) {\n-            if (i == 0) {\n-                minLat = lat[i];\n-                maxLat = lat[i];\n-                minLon = lon[i];\n-                maxLon = lon[i];\n-            } else {\n-                if (lat[i] < minLat) {\n-                    minLat = lat[i];\n-                } else if (lat[i] > maxLat) {\n-                    maxLat = lat[i];\n-                }\n-                if (lon[i] < minLon) {\n-                    minLon = lon[i];\n-                } else if (lon[i] > maxLon) {\n-                    maxLon = lon[i];\n-                }\n-            }\n-        }\n \n-        minLat -= growFactor;\n-        minLon -= growFactor;\n-        maxLat += growFactor;\n-        maxLon += growFactor;\n-\n-        epsilon = (maxLat - minLat) / 10;\n-    }\n-\n-    public Polygon(double[] lat, double[] lon) {\n-        this(lat, lon, 0);\n-    }\n-\n-    /**\n-     * Lossy conversion to a GraphHopper Polygon.\n-     */\n-    public static Polygon create(org.locationtech.jts.geom.Polygon polygon) {\n-        double[] lats = new double[polygon.getNumPoints()];\n-        double[] lons = new double[polygon.getNumPoints()];\n-        for (int i = 0; i < polygon.getNumPoints(); i++) {\n-            lats[i] = polygon.getCoordinates()[i].y;\n-            lons[i] = polygon.getCoordinates()[i].x;\n+        Coordinate[] coordinates = new Coordinate[lats.length + 1];\n+        for (int i = 0; i < lats.length; i++) {\n+            coordinates[i] = new Coordinate(lons[i], lats[i]);\n         }\n-        return new Polygon(lats, lons);\n+        coordinates[lats.length] = coordinates[0];\n+        this.polygon = new PreparedPolygon(factory.createPolygon(new PackedCoordinateSequence.Double(coordinates, 2)));\n+        this.envelope = polygon.getGeometry().getEnvelopeInternal();\n     }\n \n-    /**\n-     * Wrapper method for {@link Polygon#contains(double, double)}.\n-     */\n-    public boolean contains(GHPoint point) {\n-        return contains(point.lat, point.lon);\n+    public static Polygon create(org.locationtech.jts.geom.Polygon polygon) {\n+        return new Polygon(new PreparedPolygon(polygon));\n     }\n \n     @Override\n     public boolean intersects(Shape o) {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n+        throw new IllegalArgumentException(\"Polygon.intersects: shape not supported\");\n+    }\n+\n+    public boolean intersects(PointList pointList) {\n+        return polygon.intersects(pointList.getCachedLineString(factory, false));\n     }\n \n     /**\n-     * Implements the ray casting algorithm\n-     * Code is inspired from here: http://stackoverflow.com/a/218081/1548788\n+     * Does the point in polygon check.\n      *\n      * @param lat Latitude of the point to be checked\n      * @param lon Longitude of the point to be checked\n      * @return true if point is inside polygon\n      */\n     public boolean contains(double lat, double lon) {\n-        if (lat < minLat || lat > maxLat || lon < minLon || lon > maxLon) {\n-            return false;\n-        }\n-\n-        double rayStartLat = maxLat - (minLat / 2);\n-        double rayStartLon = minLon - epsilon;\n-\n-        boolean inside = false;\n-        int len = this.lat.length;\n-        for (int i = 0; i < len; i++) {\n-            if (edgesAreIntersecting(rayStartLon, rayStartLat, lon, lat, this.lon[i], this.lat[i], this.lon[(i + 1) % len], this.lat[(i + 1) % len]))\n-                inside = !inside;\n-        }\n-        return inside;\n-\n+        return polygon.contains(factory.createPoint(new Coordinate(lon, lat)));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzk2MTYwNQ=="}, "originalCommit": {"oid": "7a730cfcd163346c59520aed8afbc59ead35696a"}, "originalPosition": 151}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODQ1MjY0MA==", "bodyText": "Ah, i missed that polygon is already a PreparedGeometry. I would recommend to rename it accordingly e.g prepPolygon", "url": "https://github.com/graphhopper/graphhopper/pull/1853#discussion_r368452640", "createdAt": "2020-01-20T09:47:53Z", "author": {"login": "otbutz"}, "path": "api/src/main/java/com/graphhopper/util/shapes/Polygon.java", "diffHunk": "@@ -17,117 +17,72 @@\n  */\n package com.graphhopper.util.shapes;\n \n+import com.graphhopper.util.PointList;\n+import org.locationtech.jts.geom.Coordinate;\n+import org.locationtech.jts.geom.Envelope;\n+import org.locationtech.jts.geom.GeometryFactory;\n+import org.locationtech.jts.geom.Point;\n+import org.locationtech.jts.geom.impl.PackedCoordinateSequence;\n+import org.locationtech.jts.geom.prep.PreparedGeometry;\n+import org.locationtech.jts.geom.prep.PreparedPolygon;\n+\n+import java.util.Arrays;\n+\n /**\n  * This class represents a polygon that is defined by a set of points.\n  * Every point i is connected to point i-1 and i+1.\n- * <p>\n- * TODO: Howto design inner rings in the polygon?\n  *\n  * @author Robin Boldt\n  */\n public class Polygon implements Shape {\n \n-    private final double[] lat;\n-    private final double[] lon;\n+    private final GeometryFactory factory = new GeometryFactory();\n+    private final PreparedGeometry polygon;\n+    private final Envelope envelope;\n \n-    private double minLat;\n-    private double minLon;\n-    private double maxLat;\n-    private double maxLon;\n+    public Polygon(PreparedGeometry polygon) {\n+        this.polygon = polygon;\n+        this.envelope = polygon.getGeometry().getEnvelopeInternal();\n+    }\n \n-    private final double epsilon;\n+    public Polygon(double[] lats, double[] lons) {\n+        if (lats.length != lons.length)\n+            throw new IllegalArgumentException(\"Points must be of equal length but was \" + lats.length + \" vs. \" + lons.length);\n \n-    public Polygon(double[] lat, double[] lon, double growFactor) {\n-        if (lat.length != lon.length) {\n-            throw new IllegalArgumentException(\"Points must be of equal length but was \" + lat.length + \" vs. \" + lon.length);\n-        }\n-        if (lat.length == 0) {\n+        if (lats.length == 0)\n             throw new IllegalArgumentException(\"Points must not be empty\");\n-        }\n-        this.lat = lat;\n-        this.lon = lon;\n-\n-        for (int i = 0; i < lat.length; i++) {\n-            if (i == 0) {\n-                minLat = lat[i];\n-                maxLat = lat[i];\n-                minLon = lon[i];\n-                maxLon = lon[i];\n-            } else {\n-                if (lat[i] < minLat) {\n-                    minLat = lat[i];\n-                } else if (lat[i] > maxLat) {\n-                    maxLat = lat[i];\n-                }\n-                if (lon[i] < minLon) {\n-                    minLon = lon[i];\n-                } else if (lon[i] > maxLon) {\n-                    maxLon = lon[i];\n-                }\n-            }\n-        }\n \n-        minLat -= growFactor;\n-        minLon -= growFactor;\n-        maxLat += growFactor;\n-        maxLon += growFactor;\n-\n-        epsilon = (maxLat - minLat) / 10;\n-    }\n-\n-    public Polygon(double[] lat, double[] lon) {\n-        this(lat, lon, 0);\n-    }\n-\n-    /**\n-     * Lossy conversion to a GraphHopper Polygon.\n-     */\n-    public static Polygon create(org.locationtech.jts.geom.Polygon polygon) {\n-        double[] lats = new double[polygon.getNumPoints()];\n-        double[] lons = new double[polygon.getNumPoints()];\n-        for (int i = 0; i < polygon.getNumPoints(); i++) {\n-            lats[i] = polygon.getCoordinates()[i].y;\n-            lons[i] = polygon.getCoordinates()[i].x;\n+        Coordinate[] coordinates = new Coordinate[lats.length + 1];\n+        for (int i = 0; i < lats.length; i++) {\n+            coordinates[i] = new Coordinate(lons[i], lats[i]);\n         }\n-        return new Polygon(lats, lons);\n+        coordinates[lats.length] = coordinates[0];\n+        this.polygon = new PreparedPolygon(factory.createPolygon(new PackedCoordinateSequence.Double(coordinates, 2)));\n+        this.envelope = polygon.getGeometry().getEnvelopeInternal();\n     }\n \n-    /**\n-     * Wrapper method for {@link Polygon#contains(double, double)}.\n-     */\n-    public boolean contains(GHPoint point) {\n-        return contains(point.lat, point.lon);\n+    public static Polygon create(org.locationtech.jts.geom.Polygon polygon) {\n+        return new Polygon(new PreparedPolygon(polygon));\n     }\n \n     @Override\n     public boolean intersects(Shape o) {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n+        throw new IllegalArgumentException(\"Polygon.intersects: shape not supported\");\n+    }\n+\n+    public boolean intersects(PointList pointList) {\n+        return polygon.intersects(pointList.getCachedLineString(factory, false));\n     }\n \n     /**\n-     * Implements the ray casting algorithm\n-     * Code is inspired from here: http://stackoverflow.com/a/218081/1548788\n+     * Does the point in polygon check.\n      *\n      * @param lat Latitude of the point to be checked\n      * @param lon Longitude of the point to be checked\n      * @return true if point is inside polygon\n      */\n     public boolean contains(double lat, double lon) {\n-        if (lat < minLat || lat > maxLat || lon < minLon || lon > maxLon) {\n-            return false;\n-        }\n-\n-        double rayStartLat = maxLat - (minLat / 2);\n-        double rayStartLon = minLon - epsilon;\n-\n-        boolean inside = false;\n-        int len = this.lat.length;\n-        for (int i = 0; i < len; i++) {\n-            if (edgesAreIntersecting(rayStartLon, rayStartLat, lon, lat, this.lon[i], this.lat[i], this.lon[(i + 1) % len], this.lat[(i + 1) % len]))\n-                inside = !inside;\n-        }\n-        return inside;\n-\n+        return polygon.contains(factory.createPoint(new Coordinate(lon, lat)));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzk2MTYwNQ=="}, "originalCommit": {"oid": "7a730cfcd163346c59520aed8afbc59ead35696a"}, "originalPosition": 151}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODU2Nzg2NQ==", "bodyText": "Done", "url": "https://github.com/graphhopper/graphhopper/pull/1853#discussion_r368567865", "createdAt": "2020-01-20T14:13:16Z", "author": {"login": "karussell"}, "path": "api/src/main/java/com/graphhopper/util/shapes/Polygon.java", "diffHunk": "@@ -17,117 +17,72 @@\n  */\n package com.graphhopper.util.shapes;\n \n+import com.graphhopper.util.PointList;\n+import org.locationtech.jts.geom.Coordinate;\n+import org.locationtech.jts.geom.Envelope;\n+import org.locationtech.jts.geom.GeometryFactory;\n+import org.locationtech.jts.geom.Point;\n+import org.locationtech.jts.geom.impl.PackedCoordinateSequence;\n+import org.locationtech.jts.geom.prep.PreparedGeometry;\n+import org.locationtech.jts.geom.prep.PreparedPolygon;\n+\n+import java.util.Arrays;\n+\n /**\n  * This class represents a polygon that is defined by a set of points.\n  * Every point i is connected to point i-1 and i+1.\n- * <p>\n- * TODO: Howto design inner rings in the polygon?\n  *\n  * @author Robin Boldt\n  */\n public class Polygon implements Shape {\n \n-    private final double[] lat;\n-    private final double[] lon;\n+    private final GeometryFactory factory = new GeometryFactory();\n+    private final PreparedGeometry polygon;\n+    private final Envelope envelope;\n \n-    private double minLat;\n-    private double minLon;\n-    private double maxLat;\n-    private double maxLon;\n+    public Polygon(PreparedGeometry polygon) {\n+        this.polygon = polygon;\n+        this.envelope = polygon.getGeometry().getEnvelopeInternal();\n+    }\n \n-    private final double epsilon;\n+    public Polygon(double[] lats, double[] lons) {\n+        if (lats.length != lons.length)\n+            throw new IllegalArgumentException(\"Points must be of equal length but was \" + lats.length + \" vs. \" + lons.length);\n \n-    public Polygon(double[] lat, double[] lon, double growFactor) {\n-        if (lat.length != lon.length) {\n-            throw new IllegalArgumentException(\"Points must be of equal length but was \" + lat.length + \" vs. \" + lon.length);\n-        }\n-        if (lat.length == 0) {\n+        if (lats.length == 0)\n             throw new IllegalArgumentException(\"Points must not be empty\");\n-        }\n-        this.lat = lat;\n-        this.lon = lon;\n-\n-        for (int i = 0; i < lat.length; i++) {\n-            if (i == 0) {\n-                minLat = lat[i];\n-                maxLat = lat[i];\n-                minLon = lon[i];\n-                maxLon = lon[i];\n-            } else {\n-                if (lat[i] < minLat) {\n-                    minLat = lat[i];\n-                } else if (lat[i] > maxLat) {\n-                    maxLat = lat[i];\n-                }\n-                if (lon[i] < minLon) {\n-                    minLon = lon[i];\n-                } else if (lon[i] > maxLon) {\n-                    maxLon = lon[i];\n-                }\n-            }\n-        }\n \n-        minLat -= growFactor;\n-        minLon -= growFactor;\n-        maxLat += growFactor;\n-        maxLon += growFactor;\n-\n-        epsilon = (maxLat - minLat) / 10;\n-    }\n-\n-    public Polygon(double[] lat, double[] lon) {\n-        this(lat, lon, 0);\n-    }\n-\n-    /**\n-     * Lossy conversion to a GraphHopper Polygon.\n-     */\n-    public static Polygon create(org.locationtech.jts.geom.Polygon polygon) {\n-        double[] lats = new double[polygon.getNumPoints()];\n-        double[] lons = new double[polygon.getNumPoints()];\n-        for (int i = 0; i < polygon.getNumPoints(); i++) {\n-            lats[i] = polygon.getCoordinates()[i].y;\n-            lons[i] = polygon.getCoordinates()[i].x;\n+        Coordinate[] coordinates = new Coordinate[lats.length + 1];\n+        for (int i = 0; i < lats.length; i++) {\n+            coordinates[i] = new Coordinate(lons[i], lats[i]);\n         }\n-        return new Polygon(lats, lons);\n+        coordinates[lats.length] = coordinates[0];\n+        this.polygon = new PreparedPolygon(factory.createPolygon(new PackedCoordinateSequence.Double(coordinates, 2)));\n+        this.envelope = polygon.getGeometry().getEnvelopeInternal();\n     }\n \n-    /**\n-     * Wrapper method for {@link Polygon#contains(double, double)}.\n-     */\n-    public boolean contains(GHPoint point) {\n-        return contains(point.lat, point.lon);\n+    public static Polygon create(org.locationtech.jts.geom.Polygon polygon) {\n+        return new Polygon(new PreparedPolygon(polygon));\n     }\n \n     @Override\n     public boolean intersects(Shape o) {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n+        throw new IllegalArgumentException(\"Polygon.intersects: shape not supported\");\n+    }\n+\n+    public boolean intersects(PointList pointList) {\n+        return polygon.intersects(pointList.getCachedLineString(factory, false));\n     }\n \n     /**\n-     * Implements the ray casting algorithm\n-     * Code is inspired from here: http://stackoverflow.com/a/218081/1548788\n+     * Does the point in polygon check.\n      *\n      * @param lat Latitude of the point to be checked\n      * @param lon Longitude of the point to be checked\n      * @return true if point is inside polygon\n      */\n     public boolean contains(double lat, double lon) {\n-        if (lat < minLat || lat > maxLat || lon < minLon || lon > maxLon) {\n-            return false;\n-        }\n-\n-        double rayStartLat = maxLat - (minLat / 2);\n-        double rayStartLon = minLon - epsilon;\n-\n-        boolean inside = false;\n-        int len = this.lat.length;\n-        for (int i = 0; i < len; i++) {\n-            if (edgesAreIntersecting(rayStartLon, rayStartLat, lon, lat, this.lon[i], this.lat[i], this.lon[(i + 1) % len], this.lat[(i + 1) % len]))\n-                inside = !inside;\n-        }\n-        return inside;\n-\n+        return polygon.contains(factory.createPoint(new Coordinate(lon, lat)));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzk2MTYwNQ=="}, "originalCommit": {"oid": "7a730cfcd163346c59520aed8afbc59ead35696a"}, "originalPosition": 151}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI3MzY2Njk4OnYy", "diffSide": "RIGHT", "path": "api/src/main/java/com/graphhopper/util/shapes/Polygon.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xN1QxNDoyOTowM1rOFe6o5g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xN1QxNDoyOTowM1rOFe6o5g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzk2MjM0Mg==", "bodyText": "The number of holes would probably be interesting, too", "url": "https://github.com/graphhopper/graphhopper/pull/1853#discussion_r367962342", "createdAt": "2020-01-17T14:29:03Z", "author": {"login": "otbutz"}, "path": "api/src/main/java/com/graphhopper/util/shapes/Polygon.java", "diffHunk": "@@ -137,115 +92,55 @@ public boolean contains(Shape s) {\n \n     @Override\n     public BBox getBounds() {\n-        return new BBox(minLon, maxLon, minLat, maxLat);\n+        return new BBox(envelope.getMinX(), envelope.getMaxX(), envelope.getMinY(), envelope.getMaxY());\n     }\n \n     @Override\n     public GHPoint getCenter() {\n-        return new GHPoint((maxLat + minLat) / 2, (maxLon + minLon) / 2);\n+        Point centroid = polygon.getGeometry().getCentroid();\n+        return new GHPoint(centroid.getY(), centroid.getX());\n     }\n \n     @Override\n     public double calculateArea() {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    private boolean edgesAreIntersecting(\n-            double v1x1, double v1y1, double v1x2, double v1y2,\n-            double v2x1, double v2y1, double v2x2, double v2y2\n-    ) {\n-\n-\n-        double d1, d2;\n-        double a1, a2, b1, b2, c1, c2;\n-\n-        // Convert vector 1 to a line (line 1) of infinite length.\n-        // We want the line in linear equation standard form: A*x + B*y + C = 0\n-        // See: http://en.wikipedia.org/wiki/Linear_equation\n-        a1 = v1y2 - v1y1;\n-        b1 = v1x1 - v1x2;\n-        c1 = (v1x2 * v1y1) - (v1x1 * v1y2);\n-\n-        // Every point (x,y), that solves the equation above, is on the line,\n-        // every point that does not solve it, is not. The equation will have a\n-        // positive result if it is on one side of the line and a negative one\n-        // if is on the other side of it. We insert (x1,y1) and (x2,y2) of vector\n-        // 2 into the equation above.\n-        d1 = (a1 * v2x1) + (b1 * v2y1) + c1;\n-        d2 = (a1 * v2x2) + (b1 * v2y2) + c1;\n-\n-        // If d1 and d2 both have the same sign, they are both on the same side\n-        // of our line 1 and in that case no intersection is possible. Careful,\n-        // 0 is a special case, that's why we don't test \">=\" and \"<=\",\n-        // but \"<\" and \">\".\n-        if (d1 > 0 && d2 > 0) return false;\n-        if (d1 < 0 && d2 < 0) return false;\n-\n-        // The fact that vector 2 intersected the infinite line 1 above doesn't\n-        // mean it also intersects the vector 1. Vector 1 is only a subset of that\n-        // infinite line 1, so it may have intersected that line before the vector\n-        // started or after it ended. To know for sure, we have to repeat the\n-        // the same test the other way round. We start by calculating the\n-        // infinite line 2 in linear equation standard form.\n-        a2 = v2y2 - v2y1;\n-        b2 = v2x1 - v2x2;\n-        c2 = (v2x2 * v2y1) - (v2x1 * v2y2);\n-\n-        // Calculate d1 and d2 again, this time using points of vector 1.\n-        d1 = (a2 * v1x1) + (b2 * v1y1) + c2;\n-        d2 = (a2 * v1x2) + (b2 * v1y2) + c2;\n-\n-        // Again, if both have the same sign (and neither one is 0),\n-        // no intersection is possible.\n-        if (d1 > 0 && d2 > 0) return false;\n-        if (d1 < 0 && d2 < 0) return false;\n-\n-        // If we get here, only two possibilities are left. Either the two\n-        // vectors intersect in exactly one point or they are collinear, which\n-        // means they intersect in any number of points from zero to infinite.\n-        if ((a1 * b2) - (a2 * b1) == 0) return false;\n-\n-        // If they are not collinear, they must intersect in exactly one point.\n-        return true;\n+        // for estimation use bounding box as reference:\n+        return getBounds().calculateArea() * envelope.getArea() / polygon.getGeometry().getArea();\n     }\n \n     public double getMinLat() {\n-        return minLat;\n+        return envelope.getMinY();\n     }\n \n     public double getMinLon() {\n-        return minLon;\n+        return envelope.getMinX();\n     }\n \n     public double getMaxLat() {\n-        return maxLat;\n+        return envelope.getMaxY();\n     }\n \n     public double getMaxLon() {\n-        return maxLon;\n+        return envelope.getMaxX();\n     }\n \n     @Override\n     public String toString() {\n-        return \"polygon (\" + lat.length + \" points)\";\n+        return \"polygon (\" + polygon.getGeometry().getNumPoints() + \" points)\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7a730cfcd163346c59520aed8afbc59ead35696a"}, "originalPosition": 259}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI3NzI1MzMyOnYy", "diffSide": "RIGHT", "path": "api/src/main/java/com/graphhopper/util/shapes/BBox.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yMFQxMToxMTo0OFrOFfbAhA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yMVQwODowMTo1NlrOFfxF3A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODQ5MjY3Ng==", "bodyText": "I think this will fail when this method is called after this object was updated with update(). BBox is mutable, so I think we can't cache the RectangleLineIntersector.", "url": "https://github.com/graphhopper/graphhopper/pull/1853#discussion_r368492676", "createdAt": "2020-01-20T11:11:48Z", "author": {"login": "michaz"}, "path": "api/src/main/java/com/graphhopper/util/shapes/BBox.java", "diffHunk": "@@ -161,6 +164,36 @@ public boolean contains(Shape s) {\n         throw new UnsupportedOperationException(\"unsupported shape\");\n     }\n \n+    private RectangleLineIntersector cachedIntersector;\n+\n+    RectangleLineIntersector getCachedRectangleLineIntersector() {\n+        if (cachedIntersector == null)\n+            cachedIntersector = new RectangleLineIntersector(toEnvelope(this));\n+        return cachedIntersector;\n+    }\n+\n+    @Override\n+    public boolean intersects(PointList pointList) {\n+        int len = pointList.getSize();\n+        if (len == 0)\n+            throw new IllegalArgumentException(\"PointList must not be empty\");\n+\n+        double lat = pointList.getLatitude(0);\n+        double lon = pointList.getLongitude(0);\n+        if (len == 1)\n+            return contains(lat, lon);\n+\n+        Coordinate coords = new Coordinate(lon, lat);\n+        RectangleLineIntersector intersector = getCachedRectangleLineIntersector();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dc1f44d155667a712076050f94b1b90e6a9a49fe"}, "originalPosition": 34}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODU2NjY3Mg==", "bodyText": "Yeah, will see if this is critical for speed and if there is a different possibility.", "url": "https://github.com/graphhopper/graphhopper/pull/1853#discussion_r368566672", "createdAt": "2020-01-20T14:10:52Z", "author": {"login": "karussell"}, "path": "api/src/main/java/com/graphhopper/util/shapes/BBox.java", "diffHunk": "@@ -161,6 +164,36 @@ public boolean contains(Shape s) {\n         throw new UnsupportedOperationException(\"unsupported shape\");\n     }\n \n+    private RectangleLineIntersector cachedIntersector;\n+\n+    RectangleLineIntersector getCachedRectangleLineIntersector() {\n+        if (cachedIntersector == null)\n+            cachedIntersector = new RectangleLineIntersector(toEnvelope(this));\n+        return cachedIntersector;\n+    }\n+\n+    @Override\n+    public boolean intersects(PointList pointList) {\n+        int len = pointList.getSize();\n+        if (len == 0)\n+            throw new IllegalArgumentException(\"PointList must not be empty\");\n+\n+        double lat = pointList.getLatitude(0);\n+        double lon = pointList.getLongitude(0);\n+        if (len == 1)\n+            return contains(lat, lon);\n+\n+        Coordinate coords = new Coordinate(lon, lat);\n+        RectangleLineIntersector intersector = getCachedRectangleLineIntersector();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODQ5MjY3Ng=="}, "originalCommit": {"oid": "dc1f44d155667a712076050f94b1b90e6a9a49fe"}, "originalPosition": 34}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODU4ODE5NA==", "bodyText": "Oh, without it is 50% slower. (just this operation not the whole routing)", "url": "https://github.com/graphhopper/graphhopper/pull/1853#discussion_r368588194", "createdAt": "2020-01-20T14:53:42Z", "author": {"login": "karussell"}, "path": "api/src/main/java/com/graphhopper/util/shapes/BBox.java", "diffHunk": "@@ -161,6 +164,36 @@ public boolean contains(Shape s) {\n         throw new UnsupportedOperationException(\"unsupported shape\");\n     }\n \n+    private RectangleLineIntersector cachedIntersector;\n+\n+    RectangleLineIntersector getCachedRectangleLineIntersector() {\n+        if (cachedIntersector == null)\n+            cachedIntersector = new RectangleLineIntersector(toEnvelope(this));\n+        return cachedIntersector;\n+    }\n+\n+    @Override\n+    public boolean intersects(PointList pointList) {\n+        int len = pointList.getSize();\n+        if (len == 0)\n+            throw new IllegalArgumentException(\"PointList must not be empty\");\n+\n+        double lat = pointList.getLatitude(0);\n+        double lon = pointList.getLongitude(0);\n+        if (len == 1)\n+            return contains(lat, lon);\n+\n+        Coordinate coords = new Coordinate(lon, lat);\n+        RectangleLineIntersector intersector = getCachedRectangleLineIntersector();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODQ5MjY3Ng=="}, "originalCommit": {"oid": "dc1f44d155667a712076050f94b1b90e6a9a49fe"}, "originalPosition": 34}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODg1NDQ5Mg==", "bodyText": "Have moved the cached RectangleLineIntersector upwards to GraphEdgeIdFinder.parseBlockArea", "url": "https://github.com/graphhopper/graphhopper/pull/1853#discussion_r368854492", "createdAt": "2020-01-21T08:01:56Z", "author": {"login": "karussell"}, "path": "api/src/main/java/com/graphhopper/util/shapes/BBox.java", "diffHunk": "@@ -161,6 +164,36 @@ public boolean contains(Shape s) {\n         throw new UnsupportedOperationException(\"unsupported shape\");\n     }\n \n+    private RectangleLineIntersector cachedIntersector;\n+\n+    RectangleLineIntersector getCachedRectangleLineIntersector() {\n+        if (cachedIntersector == null)\n+            cachedIntersector = new RectangleLineIntersector(toEnvelope(this));\n+        return cachedIntersector;\n+    }\n+\n+    @Override\n+    public boolean intersects(PointList pointList) {\n+        int len = pointList.getSize();\n+        if (len == 0)\n+            throw new IllegalArgumentException(\"PointList must not be empty\");\n+\n+        double lat = pointList.getLatitude(0);\n+        double lon = pointList.getLongitude(0);\n+        if (len == 1)\n+            return contains(lat, lon);\n+\n+        Coordinate coords = new Coordinate(lon, lat);\n+        RectangleLineIntersector intersector = getCachedRectangleLineIntersector();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODQ5MjY3Ng=="}, "originalCommit": {"oid": "dc1f44d155667a712076050f94b1b90e6a9a49fe"}, "originalPosition": 34}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI3NzI3NTc2OnYy", "diffSide": "RIGHT", "path": "api/src/main/java/com/graphhopper/util/shapes/Polygon.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yMFQxMToyMDo1MFrOFfbONA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yMVQwODowMDoyMVrOFfxDug==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODQ5NjE4MA==", "bodyText": "Do you think we could just remove this method, and its definition from Shape? It isn't used generically anywhere in the code, so we could easily avoid giving an \"approximate\" or fudged implementation here.", "url": "https://github.com/graphhopper/graphhopper/pull/1853#discussion_r368496180", "createdAt": "2020-01-20T11:20:50Z", "author": {"login": "michaz"}, "path": "api/src/main/java/com/graphhopper/util/shapes/Polygon.java", "diffHunk": "@@ -137,115 +92,55 @@ public boolean contains(Shape s) {\n \n     @Override\n     public BBox getBounds() {\n-        return new BBox(minLon, maxLon, minLat, maxLat);\n+        return new BBox(envelope.getMinX(), envelope.getMaxX(), envelope.getMinY(), envelope.getMaxY());\n     }\n \n     @Override\n     public GHPoint getCenter() {\n-        return new GHPoint((maxLat + minLat) / 2, (maxLon + minLon) / 2);\n+        Point centroid = polygon.getGeometry().getCentroid();\n+        return new GHPoint(centroid.getY(), centroid.getX());\n     }\n \n     @Override\n     public double calculateArea() {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    private boolean edgesAreIntersecting(\n-            double v1x1, double v1y1, double v1x2, double v1y2,\n-            double v2x1, double v2y1, double v2x2, double v2y2\n-    ) {\n-\n-\n-        double d1, d2;\n-        double a1, a2, b1, b2, c1, c2;\n-\n-        // Convert vector 1 to a line (line 1) of infinite length.\n-        // We want the line in linear equation standard form: A*x + B*y + C = 0\n-        // See: http://en.wikipedia.org/wiki/Linear_equation\n-        a1 = v1y2 - v1y1;\n-        b1 = v1x1 - v1x2;\n-        c1 = (v1x2 * v1y1) - (v1x1 * v1y2);\n-\n-        // Every point (x,y), that solves the equation above, is on the line,\n-        // every point that does not solve it, is not. The equation will have a\n-        // positive result if it is on one side of the line and a negative one\n-        // if is on the other side of it. We insert (x1,y1) and (x2,y2) of vector\n-        // 2 into the equation above.\n-        d1 = (a1 * v2x1) + (b1 * v2y1) + c1;\n-        d2 = (a1 * v2x2) + (b1 * v2y2) + c1;\n-\n-        // If d1 and d2 both have the same sign, they are both on the same side\n-        // of our line 1 and in that case no intersection is possible. Careful,\n-        // 0 is a special case, that's why we don't test \">=\" and \"<=\",\n-        // but \"<\" and \">\".\n-        if (d1 > 0 && d2 > 0) return false;\n-        if (d1 < 0 && d2 < 0) return false;\n-\n-        // The fact that vector 2 intersected the infinite line 1 above doesn't\n-        // mean it also intersects the vector 1. Vector 1 is only a subset of that\n-        // infinite line 1, so it may have intersected that line before the vector\n-        // started or after it ended. To know for sure, we have to repeat the\n-        // the same test the other way round. We start by calculating the\n-        // infinite line 2 in linear equation standard form.\n-        a2 = v2y2 - v2y1;\n-        b2 = v2x1 - v2x2;\n-        c2 = (v2x2 * v2y1) - (v2x1 * v2y2);\n-\n-        // Calculate d1 and d2 again, this time using points of vector 1.\n-        d1 = (a2 * v1x1) + (b2 * v1y1) + c2;\n-        d2 = (a2 * v1x2) + (b2 * v1y2) + c2;\n-\n-        // Again, if both have the same sign (and neither one is 0),\n-        // no intersection is possible.\n-        if (d1 > 0 && d2 > 0) return false;\n-        if (d1 < 0 && d2 < 0) return false;\n-\n-        // If we get here, only two possibilities are left. Either the two\n-        // vectors intersect in exactly one point or they are collinear, which\n-        // means they intersect in any number of points from zero to infinite.\n-        if ((a1 * b2) - (a2 * b1) == 0) return false;\n-\n-        // If they are not collinear, they must intersect in exactly one point.\n-        return true;\n+        // for estimation use bounding box as reference:\n+        return getBounds().calculateArea() * envelope.getArea() / polygon.getGeometry().getArea();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dc1f44d155667a712076050f94b1b90e6a9a49fe"}, "originalPosition": 233}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODU2NjI1Mw==", "bodyText": "Unfortunately it is used in GraphEdgeIdFinder.parseBlockArea", "url": "https://github.com/graphhopper/graphhopper/pull/1853#discussion_r368566253", "createdAt": "2020-01-20T14:10:02Z", "author": {"login": "karussell"}, "path": "api/src/main/java/com/graphhopper/util/shapes/Polygon.java", "diffHunk": "@@ -137,115 +92,55 @@ public boolean contains(Shape s) {\n \n     @Override\n     public BBox getBounds() {\n-        return new BBox(minLon, maxLon, minLat, maxLat);\n+        return new BBox(envelope.getMinX(), envelope.getMaxX(), envelope.getMinY(), envelope.getMaxY());\n     }\n \n     @Override\n     public GHPoint getCenter() {\n-        return new GHPoint((maxLat + minLat) / 2, (maxLon + minLon) / 2);\n+        Point centroid = polygon.getGeometry().getCentroid();\n+        return new GHPoint(centroid.getY(), centroid.getX());\n     }\n \n     @Override\n     public double calculateArea() {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    private boolean edgesAreIntersecting(\n-            double v1x1, double v1y1, double v1x2, double v1y2,\n-            double v2x1, double v2y1, double v2x2, double v2y2\n-    ) {\n-\n-\n-        double d1, d2;\n-        double a1, a2, b1, b2, c1, c2;\n-\n-        // Convert vector 1 to a line (line 1) of infinite length.\n-        // We want the line in linear equation standard form: A*x + B*y + C = 0\n-        // See: http://en.wikipedia.org/wiki/Linear_equation\n-        a1 = v1y2 - v1y1;\n-        b1 = v1x1 - v1x2;\n-        c1 = (v1x2 * v1y1) - (v1x1 * v1y2);\n-\n-        // Every point (x,y), that solves the equation above, is on the line,\n-        // every point that does not solve it, is not. The equation will have a\n-        // positive result if it is on one side of the line and a negative one\n-        // if is on the other side of it. We insert (x1,y1) and (x2,y2) of vector\n-        // 2 into the equation above.\n-        d1 = (a1 * v2x1) + (b1 * v2y1) + c1;\n-        d2 = (a1 * v2x2) + (b1 * v2y2) + c1;\n-\n-        // If d1 and d2 both have the same sign, they are both on the same side\n-        // of our line 1 and in that case no intersection is possible. Careful,\n-        // 0 is a special case, that's why we don't test \">=\" and \"<=\",\n-        // but \"<\" and \">\".\n-        if (d1 > 0 && d2 > 0) return false;\n-        if (d1 < 0 && d2 < 0) return false;\n-\n-        // The fact that vector 2 intersected the infinite line 1 above doesn't\n-        // mean it also intersects the vector 1. Vector 1 is only a subset of that\n-        // infinite line 1, so it may have intersected that line before the vector\n-        // started or after it ended. To know for sure, we have to repeat the\n-        // the same test the other way round. We start by calculating the\n-        // infinite line 2 in linear equation standard form.\n-        a2 = v2y2 - v2y1;\n-        b2 = v2x1 - v2x2;\n-        c2 = (v2x2 * v2y1) - (v2x1 * v2y2);\n-\n-        // Calculate d1 and d2 again, this time using points of vector 1.\n-        d1 = (a2 * v1x1) + (b2 * v1y1) + c2;\n-        d2 = (a2 * v1x2) + (b2 * v1y2) + c2;\n-\n-        // Again, if both have the same sign (and neither one is 0),\n-        // no intersection is possible.\n-        if (d1 > 0 && d2 > 0) return false;\n-        if (d1 < 0 && d2 < 0) return false;\n-\n-        // If we get here, only two possibilities are left. Either the two\n-        // vectors intersect in exactly one point or they are collinear, which\n-        // means they intersect in any number of points from zero to infinite.\n-        if ((a1 * b2) - (a2 * b1) == 0) return false;\n-\n-        // If they are not collinear, they must intersect in exactly one point.\n-        return true;\n+        // for estimation use bounding box as reference:\n+        return getBounds().calculateArea() * envelope.getArea() / polygon.getGeometry().getArea();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODQ5NjE4MA=="}, "originalCommit": {"oid": "dc1f44d155667a712076050f94b1b90e6a9a49fe"}, "originalPosition": 233}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODg1Mzk0Ng==", "bodyText": "Ok, wasn't used before (seems like a bug), but is now :)\nI.e. for smaller polygons edgeIds should be used and for bigger polygons we expect that the edgeId lookup is slower than calling the polygon.intersect for every edge of the traversed graph.", "url": "https://github.com/graphhopper/graphhopper/pull/1853#discussion_r368853946", "createdAt": "2020-01-21T08:00:21Z", "author": {"login": "karussell"}, "path": "api/src/main/java/com/graphhopper/util/shapes/Polygon.java", "diffHunk": "@@ -137,115 +92,55 @@ public boolean contains(Shape s) {\n \n     @Override\n     public BBox getBounds() {\n-        return new BBox(minLon, maxLon, minLat, maxLat);\n+        return new BBox(envelope.getMinX(), envelope.getMaxX(), envelope.getMinY(), envelope.getMaxY());\n     }\n \n     @Override\n     public GHPoint getCenter() {\n-        return new GHPoint((maxLat + minLat) / 2, (maxLon + minLon) / 2);\n+        Point centroid = polygon.getGeometry().getCentroid();\n+        return new GHPoint(centroid.getY(), centroid.getX());\n     }\n \n     @Override\n     public double calculateArea() {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    private boolean edgesAreIntersecting(\n-            double v1x1, double v1y1, double v1x2, double v1y2,\n-            double v2x1, double v2y1, double v2x2, double v2y2\n-    ) {\n-\n-\n-        double d1, d2;\n-        double a1, a2, b1, b2, c1, c2;\n-\n-        // Convert vector 1 to a line (line 1) of infinite length.\n-        // We want the line in linear equation standard form: A*x + B*y + C = 0\n-        // See: http://en.wikipedia.org/wiki/Linear_equation\n-        a1 = v1y2 - v1y1;\n-        b1 = v1x1 - v1x2;\n-        c1 = (v1x2 * v1y1) - (v1x1 * v1y2);\n-\n-        // Every point (x,y), that solves the equation above, is on the line,\n-        // every point that does not solve it, is not. The equation will have a\n-        // positive result if it is on one side of the line and a negative one\n-        // if is on the other side of it. We insert (x1,y1) and (x2,y2) of vector\n-        // 2 into the equation above.\n-        d1 = (a1 * v2x1) + (b1 * v2y1) + c1;\n-        d2 = (a1 * v2x2) + (b1 * v2y2) + c1;\n-\n-        // If d1 and d2 both have the same sign, they are both on the same side\n-        // of our line 1 and in that case no intersection is possible. Careful,\n-        // 0 is a special case, that's why we don't test \">=\" and \"<=\",\n-        // but \"<\" and \">\".\n-        if (d1 > 0 && d2 > 0) return false;\n-        if (d1 < 0 && d2 < 0) return false;\n-\n-        // The fact that vector 2 intersected the infinite line 1 above doesn't\n-        // mean it also intersects the vector 1. Vector 1 is only a subset of that\n-        // infinite line 1, so it may have intersected that line before the vector\n-        // started or after it ended. To know for sure, we have to repeat the\n-        // the same test the other way round. We start by calculating the\n-        // infinite line 2 in linear equation standard form.\n-        a2 = v2y2 - v2y1;\n-        b2 = v2x1 - v2x2;\n-        c2 = (v2x2 * v2y1) - (v2x1 * v2y2);\n-\n-        // Calculate d1 and d2 again, this time using points of vector 1.\n-        d1 = (a2 * v1x1) + (b2 * v1y1) + c2;\n-        d2 = (a2 * v1x2) + (b2 * v1y2) + c2;\n-\n-        // Again, if both have the same sign (and neither one is 0),\n-        // no intersection is possible.\n-        if (d1 > 0 && d2 > 0) return false;\n-        if (d1 < 0 && d2 < 0) return false;\n-\n-        // If we get here, only two possibilities are left. Either the two\n-        // vectors intersect in exactly one point or they are collinear, which\n-        // means they intersect in any number of points from zero to infinite.\n-        if ((a1 * b2) - (a2 * b1) == 0) return false;\n-\n-        // If they are not collinear, they must intersect in exactly one point.\n-        return true;\n+        // for estimation use bounding box as reference:\n+        return getBounds().calculateArea() * envelope.getArea() / polygon.getGeometry().getArea();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODQ5NjE4MA=="}, "originalCommit": {"oid": "dc1f44d155667a712076050f94b1b90e6a9a49fe"}, "originalPosition": 233}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI4NDcyMTkzOnYy", "diffSide": "LEFT", "path": "api/src/main/java/com/graphhopper/util/shapes/Polygon.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yMlQxNjowODo0OFrOFgh2-w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yMlQxNjowODo0OFrOFgh2-w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTY1MzQ5OQ==", "bodyText": "I think it's great that we can remove this method! This was always a bit of a headache factor for me!", "url": "https://github.com/graphhopper/graphhopper/pull/1853#discussion_r369653499", "createdAt": "2020-01-22T16:08:48Z", "author": {"login": "boldtrn"}, "path": "api/src/main/java/com/graphhopper/util/shapes/Polygon.java", "diffHunk": "@@ -137,115 +92,55 @@ public boolean contains(Shape s) {\n \n     @Override\n     public BBox getBounds() {\n-        return new BBox(minLon, maxLon, minLat, maxLat);\n+        return new BBox(envelope.getMinX(), envelope.getMaxX(), envelope.getMinY(), envelope.getMaxY());\n     }\n \n     @Override\n     public GHPoint getCenter() {\n-        return new GHPoint((maxLat + minLat) / 2, (maxLon + minLon) / 2);\n+        Point centroid = prepPolygon.getGeometry().getCentroid();\n+        return new GHPoint(centroid.getY(), centroid.getX());\n     }\n \n     @Override\n     public double calculateArea() {\n-        throw new UnsupportedOperationException(\"Not supported yet.\");\n-    }\n-\n-    private boolean edgesAreIntersecting(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f1f6df149fd3741f5ca62c27d93e9ac20d6b6f0c"}, "originalPosition": 175}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4839, "cost": 1, "resetAt": "2021-11-12T20:28:25Z"}}}