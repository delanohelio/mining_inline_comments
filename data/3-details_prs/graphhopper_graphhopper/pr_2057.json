{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDI5MjE2MzMw", "number": 2057, "title": "Remove routing templates, remove RoutingAlgorithmFactory interface for CH", "bodyText": "This is work towards #1780. PathCalculator now provides an abstraction that does not 'leak' CH details (like RoutingAlgorithmFactory) and in CHPathCalculator we will now be able to build and use something similar to QueryGraph that does not have to implement the Graph interface.\nI inlined the routing templates (more or less) as they were tightly coupled with QueryGraph and did not provide a lot of benefits IMO. Maybe we can try to remove some of the code redundancies between roundtrip-,via- and alternative-routing at a later stage again.", "createdAt": "2020-06-06T13:55:20Z", "url": "https://github.com/graphhopper/graphhopper/pull/2057", "merged": true, "mergeCommit": {"oid": "d831dbf6763b55cdd1f8469ffacbef417b874330"}, "closed": true, "closedAt": "2020-06-10T17:19:59Z", "author": {"login": "easbar"}, "timelineItems": {"totalCount": 39, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcmyaKXAH2gAyNDI5MjE2MzMwOjdkZDVkNjcwNzZlODBhNTFiZmUwOThiMjhkZjcyZjY4YzY5YzcxYzY=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcp8umjgH2gAyNDI5MjE2MzMwOjJmNjgyZWM0MzQxMjI4NTM1ODg2ODUyZmY0YzU5MGZkYmM3OTliOTA=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "7dd5d67076e80a51bfe098b28df72f68c69c71c6", "author": {"user": {"login": "easbar", "name": "Andi"}}, "url": "https://github.com/graphhopper/graphhopper/commit/7dd5d67076e80a51bfe098b28df72f68c69c71c6", "committedDate": "2020-05-31T21:19:02Z", "message": "Big refactoring to make CHGraph an implementation detail of the route calculation, remove routing templates as well"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "485625c9bb3c0271c6a44440199046f6b2d20f22", "author": {"user": {"login": "easbar", "name": "Andi"}}, "url": "https://github.com/graphhopper/graphhopper/commit/485625c9bb3c0271c6a44440199046f6b2d20f22", "committedDate": "2020-06-01T07:39:21Z", "message": "Respect algorithm parameter also for alternatives, clean up a bit"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c223f61271ea017d6b810f91de2f1ed42acdbebd", "author": {"user": {"login": "easbar", "name": "Andi"}}, "url": "https://github.com/graphhopper/graphhopper/commit/c223f61271ea017d6b810f91de2f1ed42acdbebd", "committedDate": "2020-06-01T11:39:35Z", "message": "Fix for LM+empty algo"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d8c5b9b5932649a7df9364ac72c805f1793b97e9", "author": {"user": {"login": "easbar", "name": "Andi"}}, "url": "https://github.com/graphhopper/graphhopper/commit/d8c5b9b5932649a7df9364ac72c805f1793b97e9", "committedDate": "2020-06-01T21:33:38Z", "message": "Fix also for simple algo factory"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "edece63251684ea16073ea5c16c97c9c34c62fc1", "author": {"user": {"login": "easbar", "name": "Andi"}}, "url": "https://github.com/graphhopper/graphhopper/commit/edece63251684ea16073ea5c16c97c9c34c62fc1", "committedDate": "2020-06-02T06:54:37Z", "message": "Include sources for GitHub Packages deployments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1c57aaf7dedbe8696e2b46d7aeb2abf6aef80fed", "author": {"user": {"login": "easbar", "name": "Andi"}}, "url": "https://github.com/graphhopper/graphhopper/commit/1c57aaf7dedbe8696e2b46d7aeb2abf6aef80fed", "committedDate": "2020-06-02T16:54:20Z", "message": "Extract PathCalculator interface"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1ecd26ea967306fc89900faee815cbf330740bf3", "author": {"user": {"login": "easbar", "name": "Andi"}}, "url": "https://github.com/graphhopper/graphhopper/commit/1ecd26ea967306fc89900faee815cbf330740bf3", "committedDate": "2020-06-02T16:56:23Z", "message": "Inline template package"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "32ad2fb059836ef3ab26b949922f7e1d089d00a2", "author": {"user": {"login": "easbar", "name": "Andi"}}, "url": "https://github.com/graphhopper/graphhopper/commit/32ad2fb059836ef3ab26b949922f7e1d089d00a2", "committedDate": "2020-06-02T17:58:20Z", "message": "Add measurement for via-routing"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0e92a825e0839e94d1ba43a33971fb156441f59a", "author": {"user": {"login": "easbar", "name": "Andi"}}, "url": "https://github.com/graphhopper/graphhopper/commit/0e92a825e0839e94d1ba43a33971fb156441f59a", "committedDate": "2020-06-02T19:09:38Z", "message": "Clean up some remaining todos"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "65bb269f5217b78c2a3026e874da8543d107456c", "author": {"user": {"login": "easbar", "name": "Andi"}}, "url": "https://github.com/graphhopper/graphhopper/commit/65bb269f5217b78c2a3026e874da8543d107456c", "committedDate": "2020-06-03T05:45:45Z", "message": "Fix"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6c9a47a2a0e2596903ed639f0e31440cd723b9e6", "author": {"user": {"login": "easbar", "name": "Andi"}}, "url": "https://github.com/graphhopper/graphhopper/commit/6c9a47a2a0e2596903ed639f0e31440cd723b9e6", "committedDate": "2020-06-04T14:39:54Z", "message": "Merge branch 'master' into hide_ch_graph"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2d93005f0d4f3c23b01fafcd8e7975b5d19fd98a", "author": {"user": {"login": "easbar", "name": "Andi"}}, "url": "https://github.com/graphhopper/graphhopper/commit/2d93005f0d4f3c23b01fafcd8e7975b5d19fd98a", "committedDate": "2020-06-04T15:47:25Z", "message": "Merge branch 'master' into via_measurement"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "cac1006828c7fd2892329bc9cd4d3dfe731dcf09", "author": {"user": {"login": "easbar", "name": "Andi"}}, "url": "https://github.com/graphhopper/graphhopper/commit/cac1006828c7fd2892329bc9cd4d3dfe731dcf09", "committedDate": "2020-06-05T06:07:22Z", "message": "Merge branch 'master' into via_measurement"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a376cff699240c81e06bafe19124a63ff1d79259", "author": {"user": {"login": "easbar", "name": "Andi"}}, "url": "https://github.com/graphhopper/graphhopper/commit/a376cff699240c81e06bafe19124a63ff1d79259", "committedDate": "2020-06-05T06:07:55Z", "message": "Merge branch 'master' into hide_ch_graph"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "bb527edab61b7b5573e40522a3e792a4493b9ecb", "author": {"user": {"login": "easbar", "name": "Andi"}}, "url": "https://github.com/graphhopper/graphhopper/commit/bb527edab61b7b5573e40522a3e792a4493b9ecb", "committedDate": "2020-06-05T19:13:30Z", "message": "Merge branch 'master' into via_measurement"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c0e7afdf5620f3f09d3cb785de00198d7bfc1b42", "author": {"user": {"login": "easbar", "name": "Andi"}}, "url": "https://github.com/graphhopper/graphhopper/commit/c0e7afdf5620f3f09d3cb785de00198d7bfc1b42", "committedDate": "2020-06-05T19:20:10Z", "message": "Merge branch 'master' into hide_ch_graph\n\n# Conflicts:\n#\tcore/src/main/java/com/graphhopper/routing/Router.java\n#\tcore/src/main/java/com/graphhopper/routing/RoutingAlgorithmFactorySimple.java\n#\tcore/src/main/java/com/graphhopper/routing/ch/CHRoutingAlgorithmFactory.java\n#\tcore/src/main/java/com/graphhopper/routing/lm/LMRoutingAlgorithmFactory.java"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d77d3cbfa022239ecb655eb13868f761b221d0c8", "author": {"user": {"login": "easbar", "name": "Andi"}}, "url": "https://github.com/graphhopper/graphhopper/commit/d77d3cbfa022239ecb655eb13868f761b221d0c8", "committedDate": "2020-06-05T19:21:28Z", "message": "Merge branch 'via_measurement' into hide_ch_graph"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b028238e34e896333cbe4f4f2b1956af7acc1ebf", "author": {"user": {"login": "easbar", "name": "Andi"}}, "url": "https://github.com/graphhopper/graphhopper/commit/b028238e34e896333cbe4f4f2b1956af7acc1ebf", "committedDate": "2020-06-05T19:34:53Z", "message": "Merge branch 'master' into via_measurement"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "665da36713768acca185e6828a40f1dcd451369b", "author": {"user": {"login": "easbar", "name": "Andi"}}, "url": "https://github.com/graphhopper/graphhopper/commit/665da36713768acca185e6828a40f1dcd451369b", "committedDate": "2020-06-05T19:35:03Z", "message": "Merge branch 'via_measurement' into hide_ch_graph"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "243472851c9f979e3252d95a38763a210e856023", "author": {"user": {"login": "easbar", "name": "Andi"}}, "url": "https://github.com/graphhopper/graphhopper/commit/243472851c9f979e3252d95a38763a210e856023", "committedDate": "2020-06-06T07:47:46Z", "message": "Remove get/setAlgoOpts from PathCalculator interface"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "42487d43f255f5e21064b18ab596c6d45e423129", "author": {"user": {"login": "easbar", "name": "Andi"}}, "url": "https://github.com/graphhopper/graphhopper/commit/42487d43f255f5e21064b18ab596c6d45e423129", "committedDate": "2020-06-06T07:53:23Z", "message": "Minor cleanup"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "510c2e87d83415747791c0f07c0e36ae40a441d1", "author": {"user": {"login": "easbar", "name": "Andi"}}, "url": "https://github.com/graphhopper/graphhopper/commit/510c2e87d83415747791c0f07c0e36ae40a441d1", "committedDate": "2020-06-06T08:18:51Z", "message": "Move setting of algorithm for round trip"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "bcd8eb668e1f72ac1e2ffb0b8374f1fe42facae0", "author": {"user": {"login": "easbar", "name": "Andi"}}, "url": "https://github.com/graphhopper/graphhopper/commit/bcd8eb668e1f72ac1e2ffb0b8374f1fe42facae0", "committedDate": "2020-06-06T08:21:26Z", "message": "Remove RoutingAlgorithmFactory interface from CHRoutingAlgorithmFactory"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0076e973e9b98ff0cf586558e99b2676fd70ae6f", "author": {"user": {"login": "easbar", "name": "Andi"}}, "url": "https://github.com/graphhopper/graphhopper/commit/0076e973e9b98ff0cf586558e99b2676fd70ae6f", "committedDate": "2020-06-06T10:17:17Z", "message": "Use PMap instead of AlgoOpts for CHRoutingAlgorithmFactory"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "123abd922680667e0dcd616b454082780e2afb45", "author": {"user": {"login": "easbar", "name": "Andi"}}, "url": "https://github.com/graphhopper/graphhopper/commit/123abd922680667e0dcd616b454082780e2afb45", "committedDate": "2020-06-06T10:34:04Z", "message": "Merge branch 'master' into hide_ch_graph\n\n# Conflicts:\n#\ttools/src/main/java/com/graphhopper/tools/Measurement.java"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8ab3445907a8b3d4302bbcca3af6c6f5e4feff93", "author": {"user": {"login": "easbar", "name": "Andi"}}, "url": "https://github.com/graphhopper/graphhopper/commit/8ab3445907a8b3d4302bbcca3af6c6f5e4feff93", "committedDate": "2020-06-06T11:41:14Z", "message": "Merge branch 'master' into hide_ch_graph\n\n# Conflicts:\n#\tcore/src/main/java/com/graphhopper/routing/Router.java\n#\tcore/src/main/java/com/graphhopper/routing/template/RoundTripRoutingTemplate.java\n#\tcore/src/main/java/com/graphhopper/routing/template/ViaRoutingTemplate.java\n#\tcore/src/test/java/com/graphhopper/routing/ch/CHTurnCostTest.java"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3a366ba8e3c9f014e6e98936ee27e7f621dca6fb", "author": {"user": {"login": "easbar", "name": "Andi"}}, "url": "https://github.com/graphhopper/graphhopper/commit/3a366ba8e3c9f014e6e98936ee27e7f621dca6fb", "committedDate": "2020-06-06T11:54:08Z", "message": "Minor/docs"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ee613b1352673023367f0dc8b14788a7b7887a36", "author": {"user": {"login": "easbar", "name": "Andi"}}, "url": "https://github.com/graphhopper/graphhopper/commit/ee613b1352673023367f0dc8b14788a7b7887a36", "committedDate": "2020-06-06T12:15:03Z", "message": "Move shiftEdgeId method"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI3MTUzMjA1", "url": "https://github.com/graphhopper/graphhopper/pull/2057#pullrequestreview-427153205", "createdAt": "2020-06-09T13:35:59Z", "commit": {"oid": "ee613b1352673023367f0dc8b14788a7b7887a36"}, "state": "APPROVED", "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOVQxMzo0NjozNFrOGhKs2w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOVQxNDowMTo0M1rOGhLnTQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzQzMTUxNQ==", "bodyText": "We should remove MultiException from web-api module now (?) and avoid two identical named classes.", "url": "https://github.com/graphhopper/graphhopper/pull/2057#discussion_r437431515", "createdAt": "2020-06-09T13:46:34Z", "author": {"login": "karussell"}, "path": "core/src/main/java/com/graphhopper/routing/MultiException.java", "diffHunk": "@@ -0,0 +1,35 @@\n+/*\n+ *  Licensed to GraphHopper GmbH under one or more contributor\n+ *  license agreements. See the NOTICE file distributed with this work for\n+ *  additional information regarding copyright ownership.\n+ *\n+ *  GraphHopper GmbH licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except in\n+ *  compliance with the License. You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+\n+package com.graphhopper.routing;\n+\n+import java.util.List;\n+\n+public class MultiException extends RuntimeException {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ee613b1352673023367f0dc8b14788a7b7887a36"}, "originalPosition": 23}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzQzMzQxOA==", "bodyText": "I know naming is hard but having it named PathCalculator without implementing PathCalculator seems suboptimal.\nOr maybe we make this class and the static method only package protected and hide it a bit from public usage?", "url": "https://github.com/graphhopper/graphhopper/pull/2057#discussion_r437433418", "createdAt": "2020-06-09T13:48:24Z", "author": {"login": "karussell"}, "path": "core/src/main/java/com/graphhopper/routing/PathCalculatorWithAvoidedEdges.java", "diffHunk": "@@ -0,0 +1,52 @@\n+/*\n+ *  Licensed to GraphHopper GmbH under one or more contributor\n+ *  license agreements. See the NOTICE file distributed with this work for\n+ *  additional information regarding copyright ownership.\n+ *\n+ *  GraphHopper GmbH licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except in\n+ *  compliance with the License. You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+\n+package com.graphhopper.routing;\n+\n+import com.carrotsearch.hppc.IntSet;\n+import com.graphhopper.routing.weighting.AvoidEdgesWeighting;\n+\n+/**\n+ * This path calculator allows calculating a path with a set of avoided edges\n+ */\n+public class PathCalculatorWithAvoidedEdges {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ee613b1352673023367f0dc8b14788a7b7887a36"}, "originalPosition": 27}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzQzOTc1Ng==", "bodyText": "Should we create a common \"Result\" class (it is very similar anyway), so we would avoid repeating these two lines here? Or do you plan to move other objects into it?\nWe could even refactor the PathCalculator interface and remove the getter methods and only return Result for calcPaths.", "url": "https://github.com/graphhopper/graphhopper/pull/2057#discussion_r437439756", "createdAt": "2020-06-09T13:54:11Z", "author": {"login": "karussell"}, "path": "core/src/main/java/com/graphhopper/routing/Router.java", "diffHunk": "@@ -102,111 +102,210 @@ public Router(GraphHopperStorage ghStorage, LocationIndex locationIndex,\n             if (!profile.isTurnCosts() && !request.getCurbsides().isEmpty())\n                 throw new IllegalArgumentException(\"To make use of the \" + CURBSIDE + \" parameter you need to use a profile that supports turn costs\" +\n                         \"\\nThe following profiles do support turn costs: \" + getTurnCostProfiles());\n-\n             // todo later: should we be able to control this using the edge_based parameter?\n-            TraversalMode tMode = profile.isTurnCosts() ? TraversalMode.EDGE_BASED : TraversalMode.NODE_BASED;\n-            RoutingAlgorithmFactory algorithmFactory = getAlgorithmFactory(profile.getName(), disableCH, disableLM);\n-            Weighting weighting;\n-            Graph graph = ghStorage;\n-            if (chEnabled && !disableCH) {\n-                if (!(algorithmFactory instanceof CHRoutingAlgorithmFactory))\n-                    throw new IllegalStateException(\"Although CH was enabled a non-CH algorithm factory was returned \" + algorithmFactory);\n-\n-                if (request.getHints().has(Parameters.Routing.BLOCK_AREA))\n-                    throw new IllegalArgumentException(\"When CH is enabled the \" + Parameters.Routing.BLOCK_AREA + \" cannot be specified\");\n-\n-                CHConfig chConfig = ((CHRoutingAlgorithmFactory) algorithmFactory).getCHConfig();\n-                weighting = chConfig.getWeighting();\n-                graph = chGraphs.get(chConfig.getName());\n-                // we know this exists because we already got the algorithm factory this way -> will be cleaned up soon\n-            } else {\n-                checkNonChMaxWaypointDistance(request.getPoints());\n-                final int uTurnCostsInt = request.getHints().getInt(Parameters.Routing.U_TURN_COSTS, INFINITE_U_TURN_COSTS);\n-                if (uTurnCostsInt != INFINITE_U_TURN_COSTS && !tMode.isEdgeBased()) {\n-                    throw new IllegalArgumentException(\"Finite u-turn costs can only be used for edge-based routing, you need to use a profile that\" +\n-                            \" supports turn costs. Currently the following profiles that support turn costs are available: \" + getTurnCostProfiles());\n-                }\n-                FlagEncoder encoder = encodingManager.getEncoder(profile.getVehicle());\n-                weighting = weightingFactory.createWeighting(profile, request.getHints(), false);\n-                if (request.getHints().has(Parameters.Routing.BLOCK_AREA))\n-                    weighting = new BlockAreaWeighting(weighting, GraphEdgeIdFinder.createBlockArea(ghStorage, locationIndex,\n-                            request.getPoints(), request.getHints(), DefaultEdgeFilter.allEdges(encoder)));\n+            TraversalMode traversalMode = profile.isTurnCosts() ? TraversalMode.EDGE_BASED : TraversalMode.NODE_BASED;\n+            final int uTurnCostsInt = request.getHints().getInt(Parameters.Routing.U_TURN_COSTS, INFINITE_U_TURN_COSTS);\n+            if (uTurnCostsInt != INFINITE_U_TURN_COSTS && !traversalMode.isEdgeBased()) {\n+                throw new IllegalArgumentException(\"Finite u-turn costs can only be used for edge-based routing, you need to use a profile that\" +\n+                        \" supports turn costs. Currently the following profiles that support turn costs are available: \" + getTurnCostProfiles());\n             }\n-            ghRsp.addDebugInfo(\"tmode:\" + tMode.toString());\n-\n-            RoutingTemplate routingTemplate = createRoutingTemplate(request, ghRsp, request.getAlgorithm(), weighting);\n-\n-            StopWatch sw = new StopWatch().start();\n-            List<QueryResult> qResults = routingTemplate.lookup(request.getPoints());\n-            ghRsp.addDebugInfo(\"idLookup:\" + sw.stop().getSeconds() + \"s\");\n-            if (ghRsp.hasErrors())\n-                return Collections.emptyList();\n-\n-            QueryGraph queryGraph = QueryGraph.create(graph, qResults);\n+            ghRsp.addDebugInfo(\"traversal-mode:\" + traversalMode.toString());\n+            final boolean passThrough = getPassThrough(request.getHints());\n+            final boolean forceCurbsides = request.getHints().getBool(FORCE_CURBSIDE, true);\n             int maxVisitedNodesForRequest = request.getHints().getInt(Parameters.Routing.MAX_VISITED_NODES, routerConfig.getMaxVisitedNodes());\n             if (maxVisitedNodesForRequest > routerConfig.getMaxVisitedNodes())\n                 throw new IllegalArgumentException(\"The max_visited_nodes parameter has to be below or equal to:\" + routerConfig.getMaxVisitedNodes());\n \n+            // determine weighting\n+            final boolean useCH = chEnabled && !disableCH;\n+            Weighting weighting = createWeighting(profile, request.getHints(), request.getPoints(), useCH);\n+\n             AlgorithmOptions algoOpts = AlgorithmOptions.start().\n                     algorithm(request.getAlgorithm()).\n-                    traversalMode(tMode).\n+                    traversalMode(traversalMode).\n                     weighting(weighting).\n                     maxVisitedNodes(maxVisitedNodesForRequest).\n                     hints(request.getHints()).\n                     build();\n \n-            // do the actual route calculation !\n-            List<Path> altPaths = routingTemplate.calcPaths(queryGraph, algorithmFactory, algoOpts);\n-\n-            boolean tmpEnableInstructions = request.getHints().getBool(Parameters.Routing.INSTRUCTIONS, encodingManager.isEnableInstructions());\n-            boolean tmpCalcPoints = request.getHints().getBool(Parameters.Routing.CALC_POINTS, routerConfig.isCalcPoints());\n-            double wayPointMaxDistance = request.getHints().getDouble(Parameters.Routing.WAY_POINT_MAX_DISTANCE, 1d);\n-\n-            DouglasPeucker peucker = new DouglasPeucker().setMaxDistance(wayPointMaxDistance);\n-            PathMerger pathMerger = new PathMerger(queryGraph.getBaseGraph(), weighting).\n-                    setCalcPoints(tmpCalcPoints).\n-                    setDouglasPeucker(peucker).\n-                    setEnableInstructions(tmpEnableInstructions).\n-                    setPathDetailsBuilders(pathDetailsBuilderFactory, request.getPathDetails()).\n-                    setSimplifyResponse(routerConfig.isSimplifyResponse() && wayPointMaxDistance > 0);\n-\n-            if (!request.getHeadings().isEmpty())\n-                pathMerger.setFavoredHeading(request.getHeadings().get(0));\n-\n-            routingTemplate.finish(pathMerger, translationMap.getWithFallBack(request.getLocale()));\n-            return altPaths;\n+            if (ROUND_TRIP.equalsIgnoreCase(request.getAlgorithm())) {\n+                // ROUND TRIP\n+                StopWatch sw = new StopWatch().start();\n+                double startHeading = request.getHeadings().isEmpty() ? Double.NaN : request.getHeadings().get(0);\n+                RoundTripRouting.Params params = new RoundTripRouting.Params(request.getHints(), startHeading, routerConfig.getMaxRoundTripRetries());\n+                List<QueryResult> qResults = RoundTripRouting.lookup(request.getPoints(), weighting, locationIndex, params);\n+                ghRsp.addDebugInfo(\"idLookup:\" + sw.stop().getSeconds() + \"s\");\n+\n+                // use A* for round trips\n+                AlgorithmOptions roundTripAlgoOpts = AlgorithmOptions\n+                        .start(algoOpts)\n+                        .algorithm(Parameters.Algorithms.ASTAR_BI)\n+                        .build();\n+                roundTripAlgoOpts.getHints().putObject(Parameters.Algorithms.AStarBi.EPSILON, 2);\n+                FlexiblePathCalculator pathCalculator = createFlexiblePathCalculator(qResults, profile, roundTripAlgoOpts, disableLM);\n+                QueryGraph queryGraph = QueryGraph.create(ghStorage, qResults);\n+\n+                PathCalculatorWithAvoidedEdges roundTripPathCalculator = new PathCalculatorWithAvoidedEdges(pathCalculator);\n+                RoundTripRouting.Result result = RoundTripRouting.calcPaths(qResults, roundTripPathCalculator);\n+                // we merge the different legs of the roundtrip into one response path\n+                ResponsePath responsePath = concatenatePaths(request, weighting, queryGraph, result.paths, getWaypoints(qResults));\n+                ghRsp.add(responsePath);\n+                ghRsp.getHints().putObject(\"visited_nodes.sum\", result.visitedNodes);\n+                ghRsp.getHints().putObject(\"visited_nodes.average\", (float) result.visitedNodes / (qResults.size() - 1));\n+                return result.paths;\n+            } else if (ALT_ROUTE.equalsIgnoreCase(request.getAlgorithm())) {\n+                // ALTERNATIVE ROUTES\n+                if (request.getPoints().size() > 2)\n+                    throw new IllegalArgumentException(\"Currently alternative routes work only with start and end point. You tried to use: \" + request.getPoints().size() + \" points\");\n+                StopWatch sw = new StopWatch().start();\n+                List<QueryResult> qResults = ViaRouting.lookup(encodingManager, request.getPoints(), weighting, locationIndex, request.getSnapPreventions(), request.getPointHints());\n+                ghRsp.addDebugInfo(\"idLookup:\" + sw.stop().getSeconds() + \"s\");\n+                PathCalculator pathCalculator = createPathCalculator(qResults, profile, algoOpts, disableCH, disableLM);\n+                QueryGraph queryGraph = QueryGraph.create(ghStorage, qResults);\n+\n+                if (passThrough)\n+                    throw new IllegalArgumentException(\"Alternative paths and \" + PASS_THROUGH + \" at the same time is currently not supported\");\n+                if (!request.getCurbsides().isEmpty())\n+                    throw new IllegalArgumentException(\"Alternative paths do not support the \" + CURBSIDE + \" parameter yet\");\n+\n+                ViaRouting.Result result = ViaRouting.calcPaths(request.getPoints(), queryGraph, qResults, weighting.getFlagEncoder().getAccessEnc(), pathCalculator, request.getCurbsides(), forceCurbsides, request.getHeadings(), passThrough);\n+                if (result.paths.isEmpty())\n+                    throw new RuntimeException(\"Empty paths for alternative route calculation not expected\");\n+\n+                // each path represents a different alternative and we do the path merging for each of them\n+                PathMerger pathMerger = createPathMerger(request, weighting, queryGraph);\n+                for (Path path : result.paths) {\n+                    ResponsePath responsePath = new ResponsePath();\n+                    responsePath.setWaypoints(getWaypoints(qResults));\n+                    pathMerger.doWork(responsePath, Collections.singletonList(path), encodingManager, translationMap.getWithFallBack(request.getLocale()));\n+                    ghRsp.add(responsePath);\n+                }\n+                ghRsp.getHints().putObject(\"visited_nodes.sum\", result.visitedNodes);\n+                ghRsp.getHints().putObject(\"visited_nodes.average\", (float) result.visitedNodes / (qResults.size() - 1));\n+                return result.paths;\n+            } else {\n+                StopWatch sw = new StopWatch().start();\n+                List<QueryResult> qResults = ViaRouting.lookup(encodingManager, request.getPoints(), weighting, locationIndex, request.getSnapPreventions(), request.getPointHints());\n+                ghRsp.addDebugInfo(\"idLookup:\" + sw.stop().getSeconds() + \"s\");\n+                PathCalculator pathCalculator = createPathCalculator(qResults, profile, algoOpts, disableCH, disableLM);\n+                // (base) query graph used to resolve headings, curbsides etc. this is not necessarily the same thing as\n+                // the (possibly implementation specific) query graph used by PathCalculator\n+                QueryGraph queryGraph = QueryGraph.create(ghStorage, qResults);\n+                ViaRouting.Result result = ViaRouting.calcPaths(request.getPoints(), queryGraph, qResults, weighting.getFlagEncoder().getAccessEnc(), pathCalculator, request.getCurbsides(), forceCurbsides, request.getHeadings(), passThrough);\n+\n+                if (request.getPoints().size() != result.paths.size() + 1)\n+                    throw new RuntimeException(\"There should be exactly one more point than paths. points:\" + request.getPoints().size() + \", paths:\" + result.paths.size());\n+\n+                // here each path represents one leg of the via-route and we merge them all together into one response path\n+                ResponsePath responsePath = concatenatePaths(request, weighting, queryGraph, result.paths, getWaypoints(qResults));\n+                responsePath.addDebugInfo(result.debug);\n+                ghRsp.add(responsePath);\n+                ghRsp.getHints().putObject(\"visited_nodes.sum\", result.visitedNodes);\n+                ghRsp.getHints().putObject(\"visited_nodes.average\", (float) result.visitedNodes / (qResults.size() - 1));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ee613b1352673023367f0dc8b14788a7b7887a36"}, "originalPosition": 202}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzQ0NTMwNA==", "bodyText": "Can we somehow use this Router class (or something else in the future) to avoid the BlockAreaWeighting creation in SPTResource and IsochroneResource? (not really related to this PR)", "url": "https://github.com/graphhopper/graphhopper/pull/2057#discussion_r437445304", "createdAt": "2020-06-09T14:00:08Z", "author": {"login": "karussell"}, "path": "core/src/main/java/com/graphhopper/routing/Router.java", "diffHunk": "@@ -102,111 +102,210 @@ public Router(GraphHopperStorage ghStorage, LocationIndex locationIndex,\n             if (!profile.isTurnCosts() && !request.getCurbsides().isEmpty())\n                 throw new IllegalArgumentException(\"To make use of the \" + CURBSIDE + \" parameter you need to use a profile that supports turn costs\" +\n                         \"\\nThe following profiles do support turn costs: \" + getTurnCostProfiles());\n-\n             // todo later: should we be able to control this using the edge_based parameter?\n-            TraversalMode tMode = profile.isTurnCosts() ? TraversalMode.EDGE_BASED : TraversalMode.NODE_BASED;\n-            RoutingAlgorithmFactory algorithmFactory = getAlgorithmFactory(profile.getName(), disableCH, disableLM);\n-            Weighting weighting;\n-            Graph graph = ghStorage;\n-            if (chEnabled && !disableCH) {\n-                if (!(algorithmFactory instanceof CHRoutingAlgorithmFactory))\n-                    throw new IllegalStateException(\"Although CH was enabled a non-CH algorithm factory was returned \" + algorithmFactory);\n-\n-                if (request.getHints().has(Parameters.Routing.BLOCK_AREA))\n-                    throw new IllegalArgumentException(\"When CH is enabled the \" + Parameters.Routing.BLOCK_AREA + \" cannot be specified\");\n-\n-                CHConfig chConfig = ((CHRoutingAlgorithmFactory) algorithmFactory).getCHConfig();\n-                weighting = chConfig.getWeighting();\n-                graph = chGraphs.get(chConfig.getName());\n-                // we know this exists because we already got the algorithm factory this way -> will be cleaned up soon\n-            } else {\n-                checkNonChMaxWaypointDistance(request.getPoints());\n-                final int uTurnCostsInt = request.getHints().getInt(Parameters.Routing.U_TURN_COSTS, INFINITE_U_TURN_COSTS);\n-                if (uTurnCostsInt != INFINITE_U_TURN_COSTS && !tMode.isEdgeBased()) {\n-                    throw new IllegalArgumentException(\"Finite u-turn costs can only be used for edge-based routing, you need to use a profile that\" +\n-                            \" supports turn costs. Currently the following profiles that support turn costs are available: \" + getTurnCostProfiles());\n-                }\n-                FlagEncoder encoder = encodingManager.getEncoder(profile.getVehicle());\n-                weighting = weightingFactory.createWeighting(profile, request.getHints(), false);\n-                if (request.getHints().has(Parameters.Routing.BLOCK_AREA))\n-                    weighting = new BlockAreaWeighting(weighting, GraphEdgeIdFinder.createBlockArea(ghStorage, locationIndex,\n-                            request.getPoints(), request.getHints(), DefaultEdgeFilter.allEdges(encoder)));\n+            TraversalMode traversalMode = profile.isTurnCosts() ? TraversalMode.EDGE_BASED : TraversalMode.NODE_BASED;\n+            final int uTurnCostsInt = request.getHints().getInt(Parameters.Routing.U_TURN_COSTS, INFINITE_U_TURN_COSTS);\n+            if (uTurnCostsInt != INFINITE_U_TURN_COSTS && !traversalMode.isEdgeBased()) {\n+                throw new IllegalArgumentException(\"Finite u-turn costs can only be used for edge-based routing, you need to use a profile that\" +\n+                        \" supports turn costs. Currently the following profiles that support turn costs are available: \" + getTurnCostProfiles());\n             }\n-            ghRsp.addDebugInfo(\"tmode:\" + tMode.toString());\n-\n-            RoutingTemplate routingTemplate = createRoutingTemplate(request, ghRsp, request.getAlgorithm(), weighting);\n-\n-            StopWatch sw = new StopWatch().start();\n-            List<QueryResult> qResults = routingTemplate.lookup(request.getPoints());\n-            ghRsp.addDebugInfo(\"idLookup:\" + sw.stop().getSeconds() + \"s\");\n-            if (ghRsp.hasErrors())\n-                return Collections.emptyList();\n-\n-            QueryGraph queryGraph = QueryGraph.create(graph, qResults);\n+            ghRsp.addDebugInfo(\"traversal-mode:\" + traversalMode.toString());\n+            final boolean passThrough = getPassThrough(request.getHints());\n+            final boolean forceCurbsides = request.getHints().getBool(FORCE_CURBSIDE, true);\n             int maxVisitedNodesForRequest = request.getHints().getInt(Parameters.Routing.MAX_VISITED_NODES, routerConfig.getMaxVisitedNodes());\n             if (maxVisitedNodesForRequest > routerConfig.getMaxVisitedNodes())\n                 throw new IllegalArgumentException(\"The max_visited_nodes parameter has to be below or equal to:\" + routerConfig.getMaxVisitedNodes());\n \n+            // determine weighting\n+            final boolean useCH = chEnabled && !disableCH;\n+            Weighting weighting = createWeighting(profile, request.getHints(), request.getPoints(), useCH);\n+\n             AlgorithmOptions algoOpts = AlgorithmOptions.start().\n                     algorithm(request.getAlgorithm()).\n-                    traversalMode(tMode).\n+                    traversalMode(traversalMode).\n                     weighting(weighting).\n                     maxVisitedNodes(maxVisitedNodesForRequest).\n                     hints(request.getHints()).\n                     build();\n \n-            // do the actual route calculation !\n-            List<Path> altPaths = routingTemplate.calcPaths(queryGraph, algorithmFactory, algoOpts);\n-\n-            boolean tmpEnableInstructions = request.getHints().getBool(Parameters.Routing.INSTRUCTIONS, encodingManager.isEnableInstructions());\n-            boolean tmpCalcPoints = request.getHints().getBool(Parameters.Routing.CALC_POINTS, routerConfig.isCalcPoints());\n-            double wayPointMaxDistance = request.getHints().getDouble(Parameters.Routing.WAY_POINT_MAX_DISTANCE, 1d);\n-\n-            DouglasPeucker peucker = new DouglasPeucker().setMaxDistance(wayPointMaxDistance);\n-            PathMerger pathMerger = new PathMerger(queryGraph.getBaseGraph(), weighting).\n-                    setCalcPoints(tmpCalcPoints).\n-                    setDouglasPeucker(peucker).\n-                    setEnableInstructions(tmpEnableInstructions).\n-                    setPathDetailsBuilders(pathDetailsBuilderFactory, request.getPathDetails()).\n-                    setSimplifyResponse(routerConfig.isSimplifyResponse() && wayPointMaxDistance > 0);\n-\n-            if (!request.getHeadings().isEmpty())\n-                pathMerger.setFavoredHeading(request.getHeadings().get(0));\n-\n-            routingTemplate.finish(pathMerger, translationMap.getWithFallBack(request.getLocale()));\n-            return altPaths;\n+            if (ROUND_TRIP.equalsIgnoreCase(request.getAlgorithm())) {\n+                // ROUND TRIP\n+                StopWatch sw = new StopWatch().start();\n+                double startHeading = request.getHeadings().isEmpty() ? Double.NaN : request.getHeadings().get(0);\n+                RoundTripRouting.Params params = new RoundTripRouting.Params(request.getHints(), startHeading, routerConfig.getMaxRoundTripRetries());\n+                List<QueryResult> qResults = RoundTripRouting.lookup(request.getPoints(), weighting, locationIndex, params);\n+                ghRsp.addDebugInfo(\"idLookup:\" + sw.stop().getSeconds() + \"s\");\n+\n+                // use A* for round trips\n+                AlgorithmOptions roundTripAlgoOpts = AlgorithmOptions\n+                        .start(algoOpts)\n+                        .algorithm(Parameters.Algorithms.ASTAR_BI)\n+                        .build();\n+                roundTripAlgoOpts.getHints().putObject(Parameters.Algorithms.AStarBi.EPSILON, 2);\n+                FlexiblePathCalculator pathCalculator = createFlexiblePathCalculator(qResults, profile, roundTripAlgoOpts, disableLM);\n+                QueryGraph queryGraph = QueryGraph.create(ghStorage, qResults);\n+\n+                PathCalculatorWithAvoidedEdges roundTripPathCalculator = new PathCalculatorWithAvoidedEdges(pathCalculator);\n+                RoundTripRouting.Result result = RoundTripRouting.calcPaths(qResults, roundTripPathCalculator);\n+                // we merge the different legs of the roundtrip into one response path\n+                ResponsePath responsePath = concatenatePaths(request, weighting, queryGraph, result.paths, getWaypoints(qResults));\n+                ghRsp.add(responsePath);\n+                ghRsp.getHints().putObject(\"visited_nodes.sum\", result.visitedNodes);\n+                ghRsp.getHints().putObject(\"visited_nodes.average\", (float) result.visitedNodes / (qResults.size() - 1));\n+                return result.paths;\n+            } else if (ALT_ROUTE.equalsIgnoreCase(request.getAlgorithm())) {\n+                // ALTERNATIVE ROUTES\n+                if (request.getPoints().size() > 2)\n+                    throw new IllegalArgumentException(\"Currently alternative routes work only with start and end point. You tried to use: \" + request.getPoints().size() + \" points\");\n+                StopWatch sw = new StopWatch().start();\n+                List<QueryResult> qResults = ViaRouting.lookup(encodingManager, request.getPoints(), weighting, locationIndex, request.getSnapPreventions(), request.getPointHints());\n+                ghRsp.addDebugInfo(\"idLookup:\" + sw.stop().getSeconds() + \"s\");\n+                PathCalculator pathCalculator = createPathCalculator(qResults, profile, algoOpts, disableCH, disableLM);\n+                QueryGraph queryGraph = QueryGraph.create(ghStorage, qResults);\n+\n+                if (passThrough)\n+                    throw new IllegalArgumentException(\"Alternative paths and \" + PASS_THROUGH + \" at the same time is currently not supported\");\n+                if (!request.getCurbsides().isEmpty())\n+                    throw new IllegalArgumentException(\"Alternative paths do not support the \" + CURBSIDE + \" parameter yet\");\n+\n+                ViaRouting.Result result = ViaRouting.calcPaths(request.getPoints(), queryGraph, qResults, weighting.getFlagEncoder().getAccessEnc(), pathCalculator, request.getCurbsides(), forceCurbsides, request.getHeadings(), passThrough);\n+                if (result.paths.isEmpty())\n+                    throw new RuntimeException(\"Empty paths for alternative route calculation not expected\");\n+\n+                // each path represents a different alternative and we do the path merging for each of them\n+                PathMerger pathMerger = createPathMerger(request, weighting, queryGraph);\n+                for (Path path : result.paths) {\n+                    ResponsePath responsePath = new ResponsePath();\n+                    responsePath.setWaypoints(getWaypoints(qResults));\n+                    pathMerger.doWork(responsePath, Collections.singletonList(path), encodingManager, translationMap.getWithFallBack(request.getLocale()));\n+                    ghRsp.add(responsePath);\n+                }\n+                ghRsp.getHints().putObject(\"visited_nodes.sum\", result.visitedNodes);\n+                ghRsp.getHints().putObject(\"visited_nodes.average\", (float) result.visitedNodes / (qResults.size() - 1));\n+                return result.paths;\n+            } else {\n+                StopWatch sw = new StopWatch().start();\n+                List<QueryResult> qResults = ViaRouting.lookup(encodingManager, request.getPoints(), weighting, locationIndex, request.getSnapPreventions(), request.getPointHints());\n+                ghRsp.addDebugInfo(\"idLookup:\" + sw.stop().getSeconds() + \"s\");\n+                PathCalculator pathCalculator = createPathCalculator(qResults, profile, algoOpts, disableCH, disableLM);\n+                // (base) query graph used to resolve headings, curbsides etc. this is not necessarily the same thing as\n+                // the (possibly implementation specific) query graph used by PathCalculator\n+                QueryGraph queryGraph = QueryGraph.create(ghStorage, qResults);\n+                ViaRouting.Result result = ViaRouting.calcPaths(request.getPoints(), queryGraph, qResults, weighting.getFlagEncoder().getAccessEnc(), pathCalculator, request.getCurbsides(), forceCurbsides, request.getHeadings(), passThrough);\n+\n+                if (request.getPoints().size() != result.paths.size() + 1)\n+                    throw new RuntimeException(\"There should be exactly one more point than paths. points:\" + request.getPoints().size() + \", paths:\" + result.paths.size());\n+\n+                // here each path represents one leg of the via-route and we merge them all together into one response path\n+                ResponsePath responsePath = concatenatePaths(request, weighting, queryGraph, result.paths, getWaypoints(qResults));\n+                responsePath.addDebugInfo(result.debug);\n+                ghRsp.add(responsePath);\n+                ghRsp.getHints().putObject(\"visited_nodes.sum\", result.visitedNodes);\n+                ghRsp.getHints().putObject(\"visited_nodes.average\", (float) result.visitedNodes / (qResults.size() - 1));\n+                return result.paths;\n+            }\n+        } catch (MultiException ex) {\n+            for (Throwable t : ex.getErrors()) {\n+                ghRsp.addError(t);\n+            }\n+            return emptyList();\n         } catch (IllegalArgumentException ex) {\n             ghRsp.addError(ex);\n-            return Collections.emptyList();\n+            return emptyList();\n         }\n     }\n \n-    public RoutingAlgorithmFactory getAlgorithmFactory(String profile, boolean disableCH, boolean disableLM) {\n-        if (chEnabled && disableCH && !routerConfig.isCHDisablingAllowed()) {\n-            throw new IllegalArgumentException(\"Disabling CH is not allowed on the server side\");\n+    private Weighting createWeighting(Profile profile, PMap requestHints, List<GHPoint> points, boolean forCH) {\n+        if (forCH) {\n+            // todo: do not allow things like short_fastest.distance_factor or u_turn_costs unless CH is disabled\n+            // and only under certain conditions for LM\n+\n+            // the request hints are ignored for CH as we cannot change the profile after the preparation like this.\n+            // the weighting here has to be created the same way as we did when we created the weighting for the preparation\n+            return weightingFactory.createWeighting(profile, new PMap(), false);\n+        } else {\n+            Weighting weighting = weightingFactory.createWeighting(profile, requestHints, false);\n+            if (requestHints.has(Parameters.Routing.BLOCK_AREA)) {\n+                FlagEncoder encoder = encodingManager.getEncoder(profile.getVehicle());\n+                GraphEdgeIdFinder.BlockArea blockArea = GraphEdgeIdFinder.createBlockArea(ghStorage, locationIndex,\n+                        points, requestHints, DefaultEdgeFilter.allEdges(encoder));\n+                weighting = new BlockAreaWeighting(weighting, blockArea);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ee613b1352673023367f0dc8b14788a7b7887a36"}, "originalPosition": 234}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzQ0NjQ3Nw==", "bodyText": "I know you only copied this, but we should make it consistent. E.g. in Measurement we use us instead of micros. Or use \u00b5s :) ?", "url": "https://github.com/graphhopper/graphhopper/pull/2057#discussion_r437446477", "createdAt": "2020-06-09T14:01:43Z", "author": {"login": "karussell"}, "path": "core/src/main/java/com/graphhopper/routing/CHPathCalculator.java", "diffHunk": "@@ -0,0 +1,91 @@\n+/*\n+ *  Licensed to GraphHopper GmbH under one or more contributor\n+ *  license agreements. See the NOTICE file distributed with this work for\n+ *  additional information regarding copyright ownership.\n+ *\n+ *  GraphHopper GmbH licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except in\n+ *  compliance with the License. You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+\n+package com.graphhopper.routing;\n+\n+import com.graphhopper.routing.ch.CHRoutingAlgorithmFactory;\n+import com.graphhopper.routing.querygraph.QueryGraph;\n+import com.graphhopper.util.PMap;\n+import com.graphhopper.util.Parameters;\n+import com.graphhopper.util.StopWatch;\n+\n+import java.util.Collections;\n+import java.util.List;\n+\n+import static com.graphhopper.util.EdgeIterator.ANY_EDGE;\n+import static com.graphhopper.util.Parameters.Routing.MAX_VISITED_NODES;\n+\n+public class CHPathCalculator implements PathCalculator {\n+    private final QueryGraph queryGraph;\n+    private final CHRoutingAlgorithmFactory algoFactory;\n+    private final PMap algoOpts;\n+    private String debug;\n+    private int visitedNodes;\n+\n+    public CHPathCalculator(QueryGraph queryGraph, CHRoutingAlgorithmFactory algoFactory, PMap algoOpts) {\n+        this.queryGraph = queryGraph;\n+        this.algoFactory = algoFactory;\n+        this.algoOpts = algoOpts;\n+    }\n+\n+    @Override\n+    public List<Path> calcPaths(int from, int to, EdgeRestrictions edgeRestrictions) {\n+        if (!edgeRestrictions.getUnfavoredEdges().isEmpty())\n+            throw new IllegalArgumentException(\"Using unfavored edges is currently not supported for CH\");\n+        RoutingAlgorithm algo = createAlgo();\n+        return calcPaths(from, to, edgeRestrictions, algo);\n+    }\n+\n+    private RoutingAlgorithm createAlgo() {\n+        StopWatch sw = new StopWatch().start();\n+        RoutingAlgorithm algo = algoFactory.createAlgo(queryGraph, algoOpts);\n+        debug = \", algoInit:\" + (sw.stop().getNanos() / 1000) + \" micros\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ee613b1352673023367f0dc8b14788a7b7887a36"}, "originalPosition": 57}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "abd85ebedc00d5ad60a6ced8a8f41112b655eb87", "author": {"user": {"login": "easbar", "name": "Andi"}}, "url": "https://github.com/graphhopper/graphhopper/commit/abd85ebedc00d5ad60a6ced8a8f41112b655eb87", "committedDate": "2020-06-09T20:15:26Z", "message": "Move round trip calculator into RoundTripRouting"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6c182d08cbc96ac86ec07128f3d758b73de7ace8", "author": {"user": {"login": "easbar", "name": "Andi"}}, "url": "https://github.com/graphhopper/graphhopper/commit/6c182d08cbc96ac86ec07128f3d758b73de7ace8", "committedDate": "2020-06-09T21:18:44Z", "message": "Move previous edge set inside RoundTripCalculator"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f1454953448bf98da8c886b133cd45a3d5d35928", "author": {"user": {"login": "easbar", "name": "Andi"}}, "url": "https://github.com/graphhopper/graphhopper/commit/f1454953448bf98da8c886b133cd45a3d5d35928", "committedDate": "2020-06-09T21:19:30Z", "message": "Merge branch 'master' into hide_ch_graph"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI3NTU0NTc4", "url": "https://github.com/graphhopper/graphhopper/pull/2057#pullrequestreview-427554578", "createdAt": "2020-06-09T21:21:23Z", "commit": {"oid": "f1454953448bf98da8c886b133cd45a3d5d35928"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOVQyMToyMToyM1rOGhc6Pw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOVQyMToyMToyM1rOGhc6Pw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzcyOTg1NQ==", "bodyText": "Ok yes this needs a better name and maybe more documentation, but we can consider this work in progress and it will be removed again soon anyway :)", "url": "https://github.com/graphhopper/graphhopper/pull/2057#discussion_r437729855", "createdAt": "2020-06-09T21:21:23Z", "author": {"login": "easbar"}, "path": "core/src/main/java/com/graphhopper/routing/querygraph/QueryGraph.java", "diffHunk": "@@ -340,4 +340,16 @@ private UnsupportedOperationException exc() {\n     public Graph getMainGraph() {\n         return mainGraph;\n     }\n+\n+    public int shiftEdgeId(int edgeId) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f1454953448bf98da8c886b133cd45a3d5d35928"}, "originalPosition": 5}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d98edc35d38add6962a6f93071be2b1bde82c89e", "author": {"user": {"login": "easbar", "name": "Andi"}}, "url": "https://github.com/graphhopper/graphhopper/commit/d98edc35d38add6962a6f93071be2b1bde82c89e", "committedDate": "2020-06-10T08:07:29Z", "message": "Merge branch 'master' into hide_ch_graph\n\n# Conflicts:\n#\tcore/src/main/java/com/graphhopper/routing/ch/CHRoutingAlgorithmFactory.java"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c836432a629dab369c4a6bd9f52a3a421fca88da", "author": {"user": {"login": "easbar", "name": "Andi"}}, "url": "https://github.com/graphhopper/graphhopper/commit/c836432a629dab369c4a6bd9f52a3a421fca88da", "committedDate": "2020-06-10T12:35:21Z", "message": "Merge branch 'master' into hide_ch_graph"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e6e4c74d18150d9f117f10ff3555aefe5b9b6a49", "author": {"user": {"login": "easbar", "name": "Andi"}}, "url": "https://github.com/graphhopper/graphhopper/commit/e6e4c74d18150d9f117f10ff3555aefe5b9b6a49", "committedDate": "2020-06-10T14:10:57Z", "message": "micros -> \u03bcs"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0079941592d8642fcaecc25e0d2026a047221759", "author": {"user": {"login": "easbar", "name": "Andi"}}, "url": "https://github.com/graphhopper/graphhopper/commit/0079941592d8642fcaecc25e0d2026a047221759", "committedDate": "2020-06-10T15:56:01Z", "message": "Rename exception to MultiplePointsNotFoundException"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a519ed1bdf5501f8301b7d5042bca329e1cd3404", "author": {"user": {"login": "easbar", "name": "Andi"}}, "url": "https://github.com/graphhopper/graphhopper/commit/a519ed1bdf5501f8301b7d5042bca329e1cd3404", "committedDate": "2020-06-10T16:14:39Z", "message": "Merge branch 'master' into hide_ch_graph"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2f682ec4341228535886852ff4c590fdbc799b90", "author": {"user": {"login": "easbar", "name": "Andi"}}, "url": "https://github.com/graphhopper/graphhopper/commit/2f682ec4341228535886852ff4c590fdbc799b90", "committedDate": "2020-06-10T17:02:11Z", "message": "Make exception  package private"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4663, "cost": 1, "resetAt": "2021-11-01T14:51:55Z"}}}