{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTM1Nzk1Mzg4", "number": 2209, "reviewThreads": {"totalCount": 45, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMVQwOToxMjowM1rOFD42Kg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wOFQxOTozNzo1N1rOFMpNVg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM5NjIxNDE4OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/com/graphhopper/routing/util/CustomModel.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMVQwOToxMjowM1rOIDvrPQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMlQxODowMjoyOFrOIEmo3A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDc5Nzc1Nw==", "bodyText": "You could add @FunctionalInterface", "url": "https://github.com/graphhopper/graphhopper/pull/2209#discussion_r540797757", "createdAt": "2020-12-11T09:12:03Z", "author": {"login": "otbutz"}, "path": "core/src/main/java/com/graphhopper/routing/util/CustomModel.java", "diffHunk": "@@ -175,92 +183,46 @@ public static CustomModel merge(CustomModel baseModel, CustomModel queryModel) {\n         return mergedCM;\n     }\n \n-    private static void applyChange(Map<String, Object> mergedSuperMap,\n-                                    Object mergedObj, Map.Entry<String, Object> querySuperEntry) {\n-        if (mergedObj == null) {\n-            // no need for a merge\n-            mergedSuperMap.put(querySuperEntry.getKey(), querySuperEntry.getValue());\n-            return;\n-        }\n-        if (!(mergedObj instanceof Map))\n-            throw new IllegalArgumentException(querySuperEntry.getKey() + \": entry is not a map: \" + mergedObj);\n-        Object queryObj = querySuperEntry.getValue();\n-        if (!(queryObj instanceof Map))\n-            throw new IllegalArgumentException(querySuperEntry.getKey() + \": query entry is not a map: \" + queryObj);\n+    private interface MergeOp {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5cb073c89e7badcdb4e8aa42997f9b5a447e89ed"}, "originalPosition": 60}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTY5ODI2OA==", "bodyText": "It is only used internally so it wouldn't add value.", "url": "https://github.com/graphhopper/graphhopper/pull/2209#discussion_r541698268", "createdAt": "2020-12-12T18:02:28Z", "author": {"login": "karussell"}, "path": "core/src/main/java/com/graphhopper/routing/util/CustomModel.java", "diffHunk": "@@ -175,92 +183,46 @@ public static CustomModel merge(CustomModel baseModel, CustomModel queryModel) {\n         return mergedCM;\n     }\n \n-    private static void applyChange(Map<String, Object> mergedSuperMap,\n-                                    Object mergedObj, Map.Entry<String, Object> querySuperEntry) {\n-        if (mergedObj == null) {\n-            // no need for a merge\n-            mergedSuperMap.put(querySuperEntry.getKey(), querySuperEntry.getValue());\n-            return;\n-        }\n-        if (!(mergedObj instanceof Map))\n-            throw new IllegalArgumentException(querySuperEntry.getKey() + \": entry is not a map: \" + mergedObj);\n-        Object queryObj = querySuperEntry.getValue();\n-        if (!(queryObj instanceof Map))\n-            throw new IllegalArgumentException(querySuperEntry.getKey() + \": query entry is not a map: \" + queryObj);\n+    private interface MergeOp {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDc5Nzc1Nw=="}, "originalCommit": {"oid": "5cb073c89e7badcdb4e8aa42997f9b5a447e89ed"}, "originalPosition": 60}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM5NjQwNTQ0OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/com/graphhopper/routing/weighting/custom/ExpressionVisitor.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMVQwOTo1NjowNlrOIDxZwg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNFQxMTozNzozMFrOIFMdJQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDgyNjA1MA==", "bodyText": "If we expect a specific Map implementation here, maybe we should already make that clear in the method definition.", "url": "https://github.com/graphhopper/graphhopper/pull/2209#discussion_r540826050", "createdAt": "2020-12-11T09:56:06Z", "author": {"login": "otbutz"}, "path": "core/src/main/java/com/graphhopper/routing/weighting/custom/ExpressionVisitor.java", "diffHunk": "@@ -0,0 +1,198 @@\n+/*\n+ *  Licensed to GraphHopper GmbH under one or more contributor\n+ *  license agreements. See the NOTICE file distributed with this work for\n+ *  additional information regarding copyright ownership.\n+ *\n+ *  GraphHopper GmbH licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except in\n+ *  compliance with the License. You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package com.graphhopper.routing.weighting.custom;\n+\n+import com.graphhopper.routing.ev.RouteNetwork;\n+import com.graphhopper.util.Helper;\n+import org.codehaus.janino.Scanner;\n+import org.codehaus.janino.*;\n+\n+import java.io.StringReader;\n+import java.util.*;\n+\n+import static com.graphhopper.routing.weighting.custom.CustomWeighting.FIRST_MATCH;\n+\n+class ExpressionVisitor implements Visitor.AtomVisitor<Boolean, Exception> {\n+\n+    private final ParseResult result;\n+    private final TreeMap<Integer, String> injects = new TreeMap<>();\n+    private final NameValidator nameValidator;\n+    private final Set<String> allowedMethods = new HashSet<>(Arrays.asList(\"ordinal\", \"getDistance\", \"getName\",\n+            \"contains\", \"sqrt\", \"abs\"));\n+\n+    public ExpressionVisitor(ParseResult result, NameValidator nameValidator) {\n+        this.result = result;\n+        this.nameValidator = nameValidator;\n+    }\n+\n+    // allow only methods and other identifiers (constants and encoded values)\n+    boolean isValidIdentifier(String identifier) {\n+        if (nameValidator.isValid(identifier)) {\n+            if (!Character.isUpperCase(identifier.charAt(0)))\n+                result.guessedVariables.add(identifier);\n+            return true;\n+        }\n+        return false;\n+    }\n+\n+    @Override\n+    public Boolean visitRvalue(Java.Rvalue rv) throws Exception {\n+        if (rv instanceof Java.AmbiguousName) {\n+            Java.AmbiguousName n = (Java.AmbiguousName) rv;\n+            if (n.identifiers.length == 1)\n+                // e.g. like road_class\n+                return isValidIdentifier(n.identifiers[0]);\n+            return false;\n+        }\n+        if (rv instanceof Java.Literal)\n+            return true;\n+        if (rv instanceof Java.MethodInvocation) {\n+            Java.MethodInvocation mi = (Java.MethodInvocation) rv;\n+            if (allowedMethods.contains(mi.methodName)) {\n+                // skip methods like this.in() for now\n+                if (mi.target == null)\n+                    return false;\n+                // edge.getDistance, Math.sqrt => check target name (edge or Math)\n+                Java.AmbiguousName n = (Java.AmbiguousName) mi.target.toRvalue();\n+                return n.identifiers.length == 2 && isValidIdentifier(n.identifiers[0]);\n+            }\n+            return false;\n+        }\n+        if (rv instanceof Java.BinaryOperation) {\n+            Java.BinaryOperation binOp = (Java.BinaryOperation) rv;\n+            if (binOp.lhs instanceof Java.AmbiguousName && binOp.rhs instanceof Java.AmbiguousName\n+                    && (binOp.operator.equals(\"==\") || binOp.operator.equals(\"!=\"))) {\n+                Java.AmbiguousName lhs = (Java.AmbiguousName) binOp.lhs;\n+                Java.AmbiguousName rhs = (Java.AmbiguousName) binOp.rhs;\n+                // Make enum explicit as NO or OTHER can occur in other enums so convert \"toll == NO\" to \"toll == Toll.NO\"\n+                if (rhs.identifiers.length == 1 && lhs.identifiers.length == 1 && nameValidator.isValid(lhs.identifiers[0])\n+                        && rhs.identifiers[0].toUpperCase(Locale.ROOT).equals(rhs.identifiers[0])) {\n+                    String value = toEncodedValueClassName(binOp.lhs.toString());\n+                    injects.put(binOp.rhs.getLocation().getColumnNumber() - 1, value + \".\");\n+                }\n+            }\n+            return binOp.lhs.accept(this) && binOp.rhs.accept(this);\n+        }\n+        return false;\n+    }\n+\n+    @Override\n+    public Boolean visitPackage(Java.Package p) {\n+        return false;\n+    }\n+\n+    @Override\n+    public Boolean visitType(Java.Type t) {\n+        return false;\n+    }\n+\n+    @Override\n+    public Boolean visitConstructorInvocation(Java.ConstructorInvocation ci) {\n+        return false;\n+    }\n+\n+    static void parseExpressions(StringBuilder expressions, NameValidator nameInConditionValidator, String exceptionInfo,\n+                                 Set<String> createObjects, Map<String, Object> map,\n+                                 ExpressionBuilder.CodeBuilder codeBuilder, String lastStmt, String firstMatch) {\n+        if (!(map instanceof LinkedHashMap))", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5cb073c89e7badcdb4e8aa42997f9b5a447e89ed"}, "originalPosition": 112}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTY5ODQ3MA==", "bodyText": "Yes. Still this is unrelated to this PR as it is already the case without janino.", "url": "https://github.com/graphhopper/graphhopper/pull/2209#discussion_r541698470", "createdAt": "2020-12-12T18:03:08Z", "author": {"login": "karussell"}, "path": "core/src/main/java/com/graphhopper/routing/weighting/custom/ExpressionVisitor.java", "diffHunk": "@@ -0,0 +1,198 @@\n+/*\n+ *  Licensed to GraphHopper GmbH under one or more contributor\n+ *  license agreements. See the NOTICE file distributed with this work for\n+ *  additional information regarding copyright ownership.\n+ *\n+ *  GraphHopper GmbH licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except in\n+ *  compliance with the License. You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package com.graphhopper.routing.weighting.custom;\n+\n+import com.graphhopper.routing.ev.RouteNetwork;\n+import com.graphhopper.util.Helper;\n+import org.codehaus.janino.Scanner;\n+import org.codehaus.janino.*;\n+\n+import java.io.StringReader;\n+import java.util.*;\n+\n+import static com.graphhopper.routing.weighting.custom.CustomWeighting.FIRST_MATCH;\n+\n+class ExpressionVisitor implements Visitor.AtomVisitor<Boolean, Exception> {\n+\n+    private final ParseResult result;\n+    private final TreeMap<Integer, String> injects = new TreeMap<>();\n+    private final NameValidator nameValidator;\n+    private final Set<String> allowedMethods = new HashSet<>(Arrays.asList(\"ordinal\", \"getDistance\", \"getName\",\n+            \"contains\", \"sqrt\", \"abs\"));\n+\n+    public ExpressionVisitor(ParseResult result, NameValidator nameValidator) {\n+        this.result = result;\n+        this.nameValidator = nameValidator;\n+    }\n+\n+    // allow only methods and other identifiers (constants and encoded values)\n+    boolean isValidIdentifier(String identifier) {\n+        if (nameValidator.isValid(identifier)) {\n+            if (!Character.isUpperCase(identifier.charAt(0)))\n+                result.guessedVariables.add(identifier);\n+            return true;\n+        }\n+        return false;\n+    }\n+\n+    @Override\n+    public Boolean visitRvalue(Java.Rvalue rv) throws Exception {\n+        if (rv instanceof Java.AmbiguousName) {\n+            Java.AmbiguousName n = (Java.AmbiguousName) rv;\n+            if (n.identifiers.length == 1)\n+                // e.g. like road_class\n+                return isValidIdentifier(n.identifiers[0]);\n+            return false;\n+        }\n+        if (rv instanceof Java.Literal)\n+            return true;\n+        if (rv instanceof Java.MethodInvocation) {\n+            Java.MethodInvocation mi = (Java.MethodInvocation) rv;\n+            if (allowedMethods.contains(mi.methodName)) {\n+                // skip methods like this.in() for now\n+                if (mi.target == null)\n+                    return false;\n+                // edge.getDistance, Math.sqrt => check target name (edge or Math)\n+                Java.AmbiguousName n = (Java.AmbiguousName) mi.target.toRvalue();\n+                return n.identifiers.length == 2 && isValidIdentifier(n.identifiers[0]);\n+            }\n+            return false;\n+        }\n+        if (rv instanceof Java.BinaryOperation) {\n+            Java.BinaryOperation binOp = (Java.BinaryOperation) rv;\n+            if (binOp.lhs instanceof Java.AmbiguousName && binOp.rhs instanceof Java.AmbiguousName\n+                    && (binOp.operator.equals(\"==\") || binOp.operator.equals(\"!=\"))) {\n+                Java.AmbiguousName lhs = (Java.AmbiguousName) binOp.lhs;\n+                Java.AmbiguousName rhs = (Java.AmbiguousName) binOp.rhs;\n+                // Make enum explicit as NO or OTHER can occur in other enums so convert \"toll == NO\" to \"toll == Toll.NO\"\n+                if (rhs.identifiers.length == 1 && lhs.identifiers.length == 1 && nameValidator.isValid(lhs.identifiers[0])\n+                        && rhs.identifiers[0].toUpperCase(Locale.ROOT).equals(rhs.identifiers[0])) {\n+                    String value = toEncodedValueClassName(binOp.lhs.toString());\n+                    injects.put(binOp.rhs.getLocation().getColumnNumber() - 1, value + \".\");\n+                }\n+            }\n+            return binOp.lhs.accept(this) && binOp.rhs.accept(this);\n+        }\n+        return false;\n+    }\n+\n+    @Override\n+    public Boolean visitPackage(Java.Package p) {\n+        return false;\n+    }\n+\n+    @Override\n+    public Boolean visitType(Java.Type t) {\n+        return false;\n+    }\n+\n+    @Override\n+    public Boolean visitConstructorInvocation(Java.ConstructorInvocation ci) {\n+        return false;\n+    }\n+\n+    static void parseExpressions(StringBuilder expressions, NameValidator nameInConditionValidator, String exceptionInfo,\n+                                 Set<String> createObjects, Map<String, Object> map,\n+                                 ExpressionBuilder.CodeBuilder codeBuilder, String lastStmt, String firstMatch) {\n+        if (!(map instanceof LinkedHashMap))", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDgyNjA1MA=="}, "originalCommit": {"oid": "5cb073c89e7badcdb4e8aa42997f9b5a447e89ed"}, "originalPosition": 112}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjMxNzg2MQ==", "bodyText": "This will be fixed via the proposed new format. Not sure yet if here or in a separate PR.", "url": "https://github.com/graphhopper/graphhopper/pull/2209#discussion_r542317861", "createdAt": "2020-12-14T11:37:30Z", "author": {"login": "karussell"}, "path": "core/src/main/java/com/graphhopper/routing/weighting/custom/ExpressionVisitor.java", "diffHunk": "@@ -0,0 +1,198 @@\n+/*\n+ *  Licensed to GraphHopper GmbH under one or more contributor\n+ *  license agreements. See the NOTICE file distributed with this work for\n+ *  additional information regarding copyright ownership.\n+ *\n+ *  GraphHopper GmbH licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except in\n+ *  compliance with the License. You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package com.graphhopper.routing.weighting.custom;\n+\n+import com.graphhopper.routing.ev.RouteNetwork;\n+import com.graphhopper.util.Helper;\n+import org.codehaus.janino.Scanner;\n+import org.codehaus.janino.*;\n+\n+import java.io.StringReader;\n+import java.util.*;\n+\n+import static com.graphhopper.routing.weighting.custom.CustomWeighting.FIRST_MATCH;\n+\n+class ExpressionVisitor implements Visitor.AtomVisitor<Boolean, Exception> {\n+\n+    private final ParseResult result;\n+    private final TreeMap<Integer, String> injects = new TreeMap<>();\n+    private final NameValidator nameValidator;\n+    private final Set<String> allowedMethods = new HashSet<>(Arrays.asList(\"ordinal\", \"getDistance\", \"getName\",\n+            \"contains\", \"sqrt\", \"abs\"));\n+\n+    public ExpressionVisitor(ParseResult result, NameValidator nameValidator) {\n+        this.result = result;\n+        this.nameValidator = nameValidator;\n+    }\n+\n+    // allow only methods and other identifiers (constants and encoded values)\n+    boolean isValidIdentifier(String identifier) {\n+        if (nameValidator.isValid(identifier)) {\n+            if (!Character.isUpperCase(identifier.charAt(0)))\n+                result.guessedVariables.add(identifier);\n+            return true;\n+        }\n+        return false;\n+    }\n+\n+    @Override\n+    public Boolean visitRvalue(Java.Rvalue rv) throws Exception {\n+        if (rv instanceof Java.AmbiguousName) {\n+            Java.AmbiguousName n = (Java.AmbiguousName) rv;\n+            if (n.identifiers.length == 1)\n+                // e.g. like road_class\n+                return isValidIdentifier(n.identifiers[0]);\n+            return false;\n+        }\n+        if (rv instanceof Java.Literal)\n+            return true;\n+        if (rv instanceof Java.MethodInvocation) {\n+            Java.MethodInvocation mi = (Java.MethodInvocation) rv;\n+            if (allowedMethods.contains(mi.methodName)) {\n+                // skip methods like this.in() for now\n+                if (mi.target == null)\n+                    return false;\n+                // edge.getDistance, Math.sqrt => check target name (edge or Math)\n+                Java.AmbiguousName n = (Java.AmbiguousName) mi.target.toRvalue();\n+                return n.identifiers.length == 2 && isValidIdentifier(n.identifiers[0]);\n+            }\n+            return false;\n+        }\n+        if (rv instanceof Java.BinaryOperation) {\n+            Java.BinaryOperation binOp = (Java.BinaryOperation) rv;\n+            if (binOp.lhs instanceof Java.AmbiguousName && binOp.rhs instanceof Java.AmbiguousName\n+                    && (binOp.operator.equals(\"==\") || binOp.operator.equals(\"!=\"))) {\n+                Java.AmbiguousName lhs = (Java.AmbiguousName) binOp.lhs;\n+                Java.AmbiguousName rhs = (Java.AmbiguousName) binOp.rhs;\n+                // Make enum explicit as NO or OTHER can occur in other enums so convert \"toll == NO\" to \"toll == Toll.NO\"\n+                if (rhs.identifiers.length == 1 && lhs.identifiers.length == 1 && nameValidator.isValid(lhs.identifiers[0])\n+                        && rhs.identifiers[0].toUpperCase(Locale.ROOT).equals(rhs.identifiers[0])) {\n+                    String value = toEncodedValueClassName(binOp.lhs.toString());\n+                    injects.put(binOp.rhs.getLocation().getColumnNumber() - 1, value + \".\");\n+                }\n+            }\n+            return binOp.lhs.accept(this) && binOp.rhs.accept(this);\n+        }\n+        return false;\n+    }\n+\n+    @Override\n+    public Boolean visitPackage(Java.Package p) {\n+        return false;\n+    }\n+\n+    @Override\n+    public Boolean visitType(Java.Type t) {\n+        return false;\n+    }\n+\n+    @Override\n+    public Boolean visitConstructorInvocation(Java.ConstructorInvocation ci) {\n+        return false;\n+    }\n+\n+    static void parseExpressions(StringBuilder expressions, NameValidator nameInConditionValidator, String exceptionInfo,\n+                                 Set<String> createObjects, Map<String, Object> map,\n+                                 ExpressionBuilder.CodeBuilder codeBuilder, String lastStmt, String firstMatch) {\n+        if (!(map instanceof LinkedHashMap))", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDgyNjA1MA=="}, "originalCommit": {"oid": "5cb073c89e7badcdb4e8aa42997f9b5a447e89ed"}, "originalPosition": 112}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM5NjU3NDMxOnYy", "diffSide": "RIGHT", "path": "core/src/main/java/com/graphhopper/routing/weighting/custom/ExpressionBuilder.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMVQxMDozNTo1NVrOIDy6Vg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMlQxODowNDoyMlrOIEmrcA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDg1MDc3NA==", "bodyText": "StringBuilder?", "url": "https://github.com/graphhopper/graphhopper/pull/2209#discussion_r540850774", "createdAt": "2020-12-11T10:35:55Z", "author": {"login": "otbutz"}, "path": "core/src/main/java/com/graphhopper/routing/weighting/custom/ExpressionBuilder.java", "diffHunk": "@@ -0,0 +1,382 @@\n+/*\n+ *  Licensed to GraphHopper GmbH under one or more contributor\n+ *  license agreements. See the NOTICE file distributed with this work for\n+ *  additional information regarding copyright ownership.\n+ *\n+ *  GraphHopper GmbH licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except in\n+ *  compliance with the License. You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package com.graphhopper.routing.weighting.custom;\n+\n+import com.graphhopper.json.geo.JsonFeature;\n+import com.graphhopper.routing.ev.DecimalEncodedValue;\n+import com.graphhopper.routing.ev.EncodedValue;\n+import com.graphhopper.routing.ev.EncodedValueLookup;\n+import com.graphhopper.routing.util.CustomModel;\n+import com.graphhopper.routing.util.EncodingManager;\n+import com.graphhopper.util.EdgeIteratorState;\n+import com.graphhopper.util.GHUtility;\n+import com.graphhopper.util.shapes.BBox;\n+import com.graphhopper.util.shapes.Polygon;\n+import org.codehaus.commons.compiler.CompileException;\n+import org.codehaus.commons.compiler.Location;\n+import org.codehaus.commons.compiler.io.Readers;\n+import org.codehaus.janino.Scanner;\n+import org.codehaus.janino.*;\n+import org.codehaus.janino.util.DeepCopier;\n+import org.locationtech.jts.geom.prep.PreparedGeometryFactory;\n+\n+import java.io.*;\n+import java.util.*;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+class ExpressionBuilder {\n+    private static final AtomicLong longVal = new AtomicLong(1);\n+    private static final String AREA_PREFIX = \"in_area_\";\n+    private static final Set<String> allowedNames = new HashSet<>(Arrays.asList(\"edge\", \"Math\"));\n+    private static final boolean JANINO_DEBUG = Boolean.getBoolean(Scanner.SYSTEM_PROPERTY_SOURCE_DEBUGGING_ENABLE);\n+\n+    // TODO without a cache we get X% slower routing and Y% slower routingLM8. CH requests and preparation is unaffected\n+    // as cached weighting from preparation is used. This cache ensures that the first Weighting classes, typically the\n+    // ones specified in the profiles, are never removed regardless of how frequent other Weightings are created and accessed.\n+    // We only need to synchronize the get and put methods alone. E.g. we do not care for the race condition where\n+    // two identical classes are requested and one of them is overwritten. We could use CachingJavaSourceClassLoader from\n+    // Janino but 1. we would need to use a single compiler across threads and 2. the statements (for priority and speed)\n+    // are still unnecessarily created.\n+    private static final int CACHE_SIZE = Integer.getInteger(\"graphhopper.custom_weighting.cache_size\", 10);\n+    // TODO perf compare with ConcurrentHashMap, but I guess, if there is a difference at all, it is not big for small maps\n+    private static final Map<String, Class> CACHE = Collections.synchronizedMap(new HashMap<>(CACHE_SIZE));\n+\n+    // Introduce a dynamic cache to remember different Weighting classes, but throw away less frequently used classes.\n+    // Use accessOrder==true to remove oldest accessed entry, not oldest inserted.\n+    private static final int DYN_CACHE_SIZE = Integer.getInteger(\"graphhopper.custom_weighting.dynamic_cache_size\", 1000);\n+    private static final Map<String, Class> DYN_CACHE = Collections.synchronizedMap(\n+            new LinkedHashMap<String, Class>(DYN_CACHE_SIZE, 0.75f, true) {\n+                protected boolean removeEldestEntry(Map.Entry eldest) {\n+                    return size() > DYN_CACHE_SIZE;\n+                }\n+            });\n+\n+    /**\n+     * This method compiles a new subclass of CustomWeightingHelper composed from the provided CustomModel caches this\n+     * and returns an instance.\n+     */\n+    static CustomWeightingHelper create(CustomModel customModel, EncodedValueLookup lookup,\n+                                        double globalMaxSpeed, double maxSpeedFallback, DecimalEncodedValue avgSpeedEnc) {\n+        Java.CompilationUnit cu;\n+        try {\n+            String key = customModel.toString() + \",global:\" + globalMaxSpeed + \",fallback:\" + maxSpeedFallback;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5cb073c89e7badcdb4e8aa42997f9b5a447e89ed"}, "originalPosition": 77}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTY5ODkyOA==", "bodyText": "I do not like StringBuilder. It makes everything less readable and JIT is able to optimize string concatenation into it if \"hot code\". And in this case here I'm pretty sure it is not \"hot code\".", "url": "https://github.com/graphhopper/graphhopper/pull/2209#discussion_r541698928", "createdAt": "2020-12-12T18:04:22Z", "author": {"login": "karussell"}, "path": "core/src/main/java/com/graphhopper/routing/weighting/custom/ExpressionBuilder.java", "diffHunk": "@@ -0,0 +1,382 @@\n+/*\n+ *  Licensed to GraphHopper GmbH under one or more contributor\n+ *  license agreements. See the NOTICE file distributed with this work for\n+ *  additional information regarding copyright ownership.\n+ *\n+ *  GraphHopper GmbH licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except in\n+ *  compliance with the License. You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package com.graphhopper.routing.weighting.custom;\n+\n+import com.graphhopper.json.geo.JsonFeature;\n+import com.graphhopper.routing.ev.DecimalEncodedValue;\n+import com.graphhopper.routing.ev.EncodedValue;\n+import com.graphhopper.routing.ev.EncodedValueLookup;\n+import com.graphhopper.routing.util.CustomModel;\n+import com.graphhopper.routing.util.EncodingManager;\n+import com.graphhopper.util.EdgeIteratorState;\n+import com.graphhopper.util.GHUtility;\n+import com.graphhopper.util.shapes.BBox;\n+import com.graphhopper.util.shapes.Polygon;\n+import org.codehaus.commons.compiler.CompileException;\n+import org.codehaus.commons.compiler.Location;\n+import org.codehaus.commons.compiler.io.Readers;\n+import org.codehaus.janino.Scanner;\n+import org.codehaus.janino.*;\n+import org.codehaus.janino.util.DeepCopier;\n+import org.locationtech.jts.geom.prep.PreparedGeometryFactory;\n+\n+import java.io.*;\n+import java.util.*;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+class ExpressionBuilder {\n+    private static final AtomicLong longVal = new AtomicLong(1);\n+    private static final String AREA_PREFIX = \"in_area_\";\n+    private static final Set<String> allowedNames = new HashSet<>(Arrays.asList(\"edge\", \"Math\"));\n+    private static final boolean JANINO_DEBUG = Boolean.getBoolean(Scanner.SYSTEM_PROPERTY_SOURCE_DEBUGGING_ENABLE);\n+\n+    // TODO without a cache we get X% slower routing and Y% slower routingLM8. CH requests and preparation is unaffected\n+    // as cached weighting from preparation is used. This cache ensures that the first Weighting classes, typically the\n+    // ones specified in the profiles, are never removed regardless of how frequent other Weightings are created and accessed.\n+    // We only need to synchronize the get and put methods alone. E.g. we do not care for the race condition where\n+    // two identical classes are requested and one of them is overwritten. We could use CachingJavaSourceClassLoader from\n+    // Janino but 1. we would need to use a single compiler across threads and 2. the statements (for priority and speed)\n+    // are still unnecessarily created.\n+    private static final int CACHE_SIZE = Integer.getInteger(\"graphhopper.custom_weighting.cache_size\", 10);\n+    // TODO perf compare with ConcurrentHashMap, but I guess, if there is a difference at all, it is not big for small maps\n+    private static final Map<String, Class> CACHE = Collections.synchronizedMap(new HashMap<>(CACHE_SIZE));\n+\n+    // Introduce a dynamic cache to remember different Weighting classes, but throw away less frequently used classes.\n+    // Use accessOrder==true to remove oldest accessed entry, not oldest inserted.\n+    private static final int DYN_CACHE_SIZE = Integer.getInteger(\"graphhopper.custom_weighting.dynamic_cache_size\", 1000);\n+    private static final Map<String, Class> DYN_CACHE = Collections.synchronizedMap(\n+            new LinkedHashMap<String, Class>(DYN_CACHE_SIZE, 0.75f, true) {\n+                protected boolean removeEldestEntry(Map.Entry eldest) {\n+                    return size() > DYN_CACHE_SIZE;\n+                }\n+            });\n+\n+    /**\n+     * This method compiles a new subclass of CustomWeightingHelper composed from the provided CustomModel caches this\n+     * and returns an instance.\n+     */\n+    static CustomWeightingHelper create(CustomModel customModel, EncodedValueLookup lookup,\n+                                        double globalMaxSpeed, double maxSpeedFallback, DecimalEncodedValue avgSpeedEnc) {\n+        Java.CompilationUnit cu;\n+        try {\n+            String key = customModel.toString() + \",global:\" + globalMaxSpeed + \",fallback:\" + maxSpeedFallback;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDg1MDc3NA=="}, "originalCommit": {"oid": "5cb073c89e7badcdb4e8aa42997f9b5a447e89ed"}, "originalPosition": 77}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM5NjU4OTcxOnYy", "diffSide": "RIGHT", "path": "core/src/main/java/com/graphhopper/routing/weighting/custom/ExpressionBuilder.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMVQxMDozOTozNlrOIDzDCg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMlQxODowNTowNVrOIEmspg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDg1MzAwMg==", "bodyText": "Is it possible to detect models used by profiles and use the static cache only for those?", "url": "https://github.com/graphhopper/graphhopper/pull/2209#discussion_r540853002", "createdAt": "2020-12-11T10:39:36Z", "author": {"login": "otbutz"}, "path": "core/src/main/java/com/graphhopper/routing/weighting/custom/ExpressionBuilder.java", "diffHunk": "@@ -0,0 +1,382 @@\n+/*\n+ *  Licensed to GraphHopper GmbH under one or more contributor\n+ *  license agreements. See the NOTICE file distributed with this work for\n+ *  additional information regarding copyright ownership.\n+ *\n+ *  GraphHopper GmbH licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except in\n+ *  compliance with the License. You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package com.graphhopper.routing.weighting.custom;\n+\n+import com.graphhopper.json.geo.JsonFeature;\n+import com.graphhopper.routing.ev.DecimalEncodedValue;\n+import com.graphhopper.routing.ev.EncodedValue;\n+import com.graphhopper.routing.ev.EncodedValueLookup;\n+import com.graphhopper.routing.util.CustomModel;\n+import com.graphhopper.routing.util.EncodingManager;\n+import com.graphhopper.util.EdgeIteratorState;\n+import com.graphhopper.util.GHUtility;\n+import com.graphhopper.util.shapes.BBox;\n+import com.graphhopper.util.shapes.Polygon;\n+import org.codehaus.commons.compiler.CompileException;\n+import org.codehaus.commons.compiler.Location;\n+import org.codehaus.commons.compiler.io.Readers;\n+import org.codehaus.janino.Scanner;\n+import org.codehaus.janino.*;\n+import org.codehaus.janino.util.DeepCopier;\n+import org.locationtech.jts.geom.prep.PreparedGeometryFactory;\n+\n+import java.io.*;\n+import java.util.*;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+class ExpressionBuilder {\n+    private static final AtomicLong longVal = new AtomicLong(1);\n+    private static final String AREA_PREFIX = \"in_area_\";\n+    private static final Set<String> allowedNames = new HashSet<>(Arrays.asList(\"edge\", \"Math\"));\n+    private static final boolean JANINO_DEBUG = Boolean.getBoolean(Scanner.SYSTEM_PROPERTY_SOURCE_DEBUGGING_ENABLE);\n+\n+    // TODO without a cache we get X% slower routing and Y% slower routingLM8. CH requests and preparation is unaffected\n+    // as cached weighting from preparation is used. This cache ensures that the first Weighting classes, typically the\n+    // ones specified in the profiles, are never removed regardless of how frequent other Weightings are created and accessed.\n+    // We only need to synchronize the get and put methods alone. E.g. we do not care for the race condition where\n+    // two identical classes are requested and one of them is overwritten. We could use CachingJavaSourceClassLoader from\n+    // Janino but 1. we would need to use a single compiler across threads and 2. the statements (for priority and speed)\n+    // are still unnecessarily created.\n+    private static final int CACHE_SIZE = Integer.getInteger(\"graphhopper.custom_weighting.cache_size\", 10);\n+    // TODO perf compare with ConcurrentHashMap, but I guess, if there is a difference at all, it is not big for small maps\n+    private static final Map<String, Class> CACHE = Collections.synchronizedMap(new HashMap<>(CACHE_SIZE));\n+\n+    // Introduce a dynamic cache to remember different Weighting classes, but throw away less frequently used classes.\n+    // Use accessOrder==true to remove oldest accessed entry, not oldest inserted.\n+    private static final int DYN_CACHE_SIZE = Integer.getInteger(\"graphhopper.custom_weighting.dynamic_cache_size\", 1000);\n+    private static final Map<String, Class> DYN_CACHE = Collections.synchronizedMap(\n+            new LinkedHashMap<String, Class>(DYN_CACHE_SIZE, 0.75f, true) {\n+                protected boolean removeEldestEntry(Map.Entry eldest) {\n+                    return size() > DYN_CACHE_SIZE;\n+                }\n+            });\n+\n+    /**\n+     * This method compiles a new subclass of CustomWeightingHelper composed from the provided CustomModel caches this\n+     * and returns an instance.\n+     */\n+    static CustomWeightingHelper create(CustomModel customModel, EncodedValueLookup lookup,\n+                                        double globalMaxSpeed, double maxSpeedFallback, DecimalEncodedValue avgSpeedEnc) {\n+        Java.CompilationUnit cu;\n+        try {\n+            String key = customModel.toString() + \",global:\" + globalMaxSpeed + \",fallback:\" + maxSpeedFallback;\n+            if (key.length() > 400_000) throw new IllegalArgumentException(\"Custom Model too big: \" + key.length());\n+\n+            Class clazz = CACHE.get(key);\n+            if (DYN_CACHE_SIZE > 0 && clazz == null)\n+                clazz = DYN_CACHE.get(key);\n+            if (clazz == null) {\n+                HashSet<String> priorityVariables = new LinkedHashSet<>();\n+                List<Java.BlockStatement> priorityStatements = createGetPriorityStatements(priorityVariables, customModel, lookup);\n+                HashSet<String> speedVariables = new LinkedHashSet<>();\n+                List<Java.BlockStatement> speedStatements = createGetSpeedStatements(speedVariables, customModel, lookup, globalMaxSpeed, maxSpeedFallback);\n+                // Create different class name, which is required only for debugging.\n+                // TODO does it improve performance too? I.e. it could be that the JIT is confused if different classes\n+                //  have the same name and it mixes performance stats. See https://github.com/janino-compiler/janino/issues/137\n+                long counter = longVal.incrementAndGet();\n+                String classTemplate = createClassTemplate(counter, priorityVariables, speedVariables, lookup);\n+                cu = (Java.CompilationUnit) new Parser(new org.codehaus.janino.Scanner(\"source\", new StringReader(classTemplate))).\n+                        parseAbstractCompilationUnit();\n+                cu = injectStatements(priorityStatements, speedStatements, cu);\n+                SimpleCompiler sc = createCompiler(counter, cu);\n+                clazz = sc.getClassLoader().loadClass(\"com.graphhopper.Test\" + counter);\n+                if (CACHE.size() < CACHE_SIZE)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5cb073c89e7badcdb4e8aa42997f9b5a447e89ed"}, "originalPosition": 98}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTY5OTIzOA==", "bodyText": "Not sure how, but it would be nice, yes.", "url": "https://github.com/graphhopper/graphhopper/pull/2209#discussion_r541699238", "createdAt": "2020-12-12T18:05:05Z", "author": {"login": "karussell"}, "path": "core/src/main/java/com/graphhopper/routing/weighting/custom/ExpressionBuilder.java", "diffHunk": "@@ -0,0 +1,382 @@\n+/*\n+ *  Licensed to GraphHopper GmbH under one or more contributor\n+ *  license agreements. See the NOTICE file distributed with this work for\n+ *  additional information regarding copyright ownership.\n+ *\n+ *  GraphHopper GmbH licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except in\n+ *  compliance with the License. You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package com.graphhopper.routing.weighting.custom;\n+\n+import com.graphhopper.json.geo.JsonFeature;\n+import com.graphhopper.routing.ev.DecimalEncodedValue;\n+import com.graphhopper.routing.ev.EncodedValue;\n+import com.graphhopper.routing.ev.EncodedValueLookup;\n+import com.graphhopper.routing.util.CustomModel;\n+import com.graphhopper.routing.util.EncodingManager;\n+import com.graphhopper.util.EdgeIteratorState;\n+import com.graphhopper.util.GHUtility;\n+import com.graphhopper.util.shapes.BBox;\n+import com.graphhopper.util.shapes.Polygon;\n+import org.codehaus.commons.compiler.CompileException;\n+import org.codehaus.commons.compiler.Location;\n+import org.codehaus.commons.compiler.io.Readers;\n+import org.codehaus.janino.Scanner;\n+import org.codehaus.janino.*;\n+import org.codehaus.janino.util.DeepCopier;\n+import org.locationtech.jts.geom.prep.PreparedGeometryFactory;\n+\n+import java.io.*;\n+import java.util.*;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+class ExpressionBuilder {\n+    private static final AtomicLong longVal = new AtomicLong(1);\n+    private static final String AREA_PREFIX = \"in_area_\";\n+    private static final Set<String> allowedNames = new HashSet<>(Arrays.asList(\"edge\", \"Math\"));\n+    private static final boolean JANINO_DEBUG = Boolean.getBoolean(Scanner.SYSTEM_PROPERTY_SOURCE_DEBUGGING_ENABLE);\n+\n+    // TODO without a cache we get X% slower routing and Y% slower routingLM8. CH requests and preparation is unaffected\n+    // as cached weighting from preparation is used. This cache ensures that the first Weighting classes, typically the\n+    // ones specified in the profiles, are never removed regardless of how frequent other Weightings are created and accessed.\n+    // We only need to synchronize the get and put methods alone. E.g. we do not care for the race condition where\n+    // two identical classes are requested and one of them is overwritten. We could use CachingJavaSourceClassLoader from\n+    // Janino but 1. we would need to use a single compiler across threads and 2. the statements (for priority and speed)\n+    // are still unnecessarily created.\n+    private static final int CACHE_SIZE = Integer.getInteger(\"graphhopper.custom_weighting.cache_size\", 10);\n+    // TODO perf compare with ConcurrentHashMap, but I guess, if there is a difference at all, it is not big for small maps\n+    private static final Map<String, Class> CACHE = Collections.synchronizedMap(new HashMap<>(CACHE_SIZE));\n+\n+    // Introduce a dynamic cache to remember different Weighting classes, but throw away less frequently used classes.\n+    // Use accessOrder==true to remove oldest accessed entry, not oldest inserted.\n+    private static final int DYN_CACHE_SIZE = Integer.getInteger(\"graphhopper.custom_weighting.dynamic_cache_size\", 1000);\n+    private static final Map<String, Class> DYN_CACHE = Collections.synchronizedMap(\n+            new LinkedHashMap<String, Class>(DYN_CACHE_SIZE, 0.75f, true) {\n+                protected boolean removeEldestEntry(Map.Entry eldest) {\n+                    return size() > DYN_CACHE_SIZE;\n+                }\n+            });\n+\n+    /**\n+     * This method compiles a new subclass of CustomWeightingHelper composed from the provided CustomModel caches this\n+     * and returns an instance.\n+     */\n+    static CustomWeightingHelper create(CustomModel customModel, EncodedValueLookup lookup,\n+                                        double globalMaxSpeed, double maxSpeedFallback, DecimalEncodedValue avgSpeedEnc) {\n+        Java.CompilationUnit cu;\n+        try {\n+            String key = customModel.toString() + \",global:\" + globalMaxSpeed + \",fallback:\" + maxSpeedFallback;\n+            if (key.length() > 400_000) throw new IllegalArgumentException(\"Custom Model too big: \" + key.length());\n+\n+            Class clazz = CACHE.get(key);\n+            if (DYN_CACHE_SIZE > 0 && clazz == null)\n+                clazz = DYN_CACHE.get(key);\n+            if (clazz == null) {\n+                HashSet<String> priorityVariables = new LinkedHashSet<>();\n+                List<Java.BlockStatement> priorityStatements = createGetPriorityStatements(priorityVariables, customModel, lookup);\n+                HashSet<String> speedVariables = new LinkedHashSet<>();\n+                List<Java.BlockStatement> speedStatements = createGetSpeedStatements(speedVariables, customModel, lookup, globalMaxSpeed, maxSpeedFallback);\n+                // Create different class name, which is required only for debugging.\n+                // TODO does it improve performance too? I.e. it could be that the JIT is confused if different classes\n+                //  have the same name and it mixes performance stats. See https://github.com/janino-compiler/janino/issues/137\n+                long counter = longVal.incrementAndGet();\n+                String classTemplate = createClassTemplate(counter, priorityVariables, speedVariables, lookup);\n+                cu = (Java.CompilationUnit) new Parser(new org.codehaus.janino.Scanner(\"source\", new StringReader(classTemplate))).\n+                        parseAbstractCompilationUnit();\n+                cu = injectStatements(priorityStatements, speedStatements, cu);\n+                SimpleCompiler sc = createCompiler(counter, cu);\n+                clazz = sc.getClassLoader().loadClass(\"com.graphhopper.Test\" + counter);\n+                if (CACHE.size() < CACHE_SIZE)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDg1MzAwMg=="}, "originalCommit": {"oid": "5cb073c89e7badcdb4e8aa42997f9b5a447e89ed"}, "originalPosition": 98}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM5NjYwNDA2OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/com/graphhopper/routing/weighting/custom/ExpressionBuilder.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMVQxMDo0Mjo1OFrOIDzK5A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMVQxMDo0Mjo1OFrOIDzK5A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDg1NTAxMg==", "bodyText": "StringBuilder?", "url": "https://github.com/graphhopper/graphhopper/pull/2209#discussion_r540855012", "createdAt": "2020-12-11T10:42:58Z", "author": {"login": "otbutz"}, "path": "core/src/main/java/com/graphhopper/routing/weighting/custom/ExpressionBuilder.java", "diffHunk": "@@ -0,0 +1,382 @@\n+/*\n+ *  Licensed to GraphHopper GmbH under one or more contributor\n+ *  license agreements. See the NOTICE file distributed with this work for\n+ *  additional information regarding copyright ownership.\n+ *\n+ *  GraphHopper GmbH licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except in\n+ *  compliance with the License. You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package com.graphhopper.routing.weighting.custom;\n+\n+import com.graphhopper.json.geo.JsonFeature;\n+import com.graphhopper.routing.ev.DecimalEncodedValue;\n+import com.graphhopper.routing.ev.EncodedValue;\n+import com.graphhopper.routing.ev.EncodedValueLookup;\n+import com.graphhopper.routing.util.CustomModel;\n+import com.graphhopper.routing.util.EncodingManager;\n+import com.graphhopper.util.EdgeIteratorState;\n+import com.graphhopper.util.GHUtility;\n+import com.graphhopper.util.shapes.BBox;\n+import com.graphhopper.util.shapes.Polygon;\n+import org.codehaus.commons.compiler.CompileException;\n+import org.codehaus.commons.compiler.Location;\n+import org.codehaus.commons.compiler.io.Readers;\n+import org.codehaus.janino.Scanner;\n+import org.codehaus.janino.*;\n+import org.codehaus.janino.util.DeepCopier;\n+import org.locationtech.jts.geom.prep.PreparedGeometryFactory;\n+\n+import java.io.*;\n+import java.util.*;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+class ExpressionBuilder {\n+    private static final AtomicLong longVal = new AtomicLong(1);\n+    private static final String AREA_PREFIX = \"in_area_\";\n+    private static final Set<String> allowedNames = new HashSet<>(Arrays.asList(\"edge\", \"Math\"));\n+    private static final boolean JANINO_DEBUG = Boolean.getBoolean(Scanner.SYSTEM_PROPERTY_SOURCE_DEBUGGING_ENABLE);\n+\n+    // TODO without a cache we get X% slower routing and Y% slower routingLM8. CH requests and preparation is unaffected\n+    // as cached weighting from preparation is used. This cache ensures that the first Weighting classes, typically the\n+    // ones specified in the profiles, are never removed regardless of how frequent other Weightings are created and accessed.\n+    // We only need to synchronize the get and put methods alone. E.g. we do not care for the race condition where\n+    // two identical classes are requested and one of them is overwritten. We could use CachingJavaSourceClassLoader from\n+    // Janino but 1. we would need to use a single compiler across threads and 2. the statements (for priority and speed)\n+    // are still unnecessarily created.\n+    private static final int CACHE_SIZE = Integer.getInteger(\"graphhopper.custom_weighting.cache_size\", 10);\n+    // TODO perf compare with ConcurrentHashMap, but I guess, if there is a difference at all, it is not big for small maps\n+    private static final Map<String, Class> CACHE = Collections.synchronizedMap(new HashMap<>(CACHE_SIZE));\n+\n+    // Introduce a dynamic cache to remember different Weighting classes, but throw away less frequently used classes.\n+    // Use accessOrder==true to remove oldest accessed entry, not oldest inserted.\n+    private static final int DYN_CACHE_SIZE = Integer.getInteger(\"graphhopper.custom_weighting.dynamic_cache_size\", 1000);\n+    private static final Map<String, Class> DYN_CACHE = Collections.synchronizedMap(\n+            new LinkedHashMap<String, Class>(DYN_CACHE_SIZE, 0.75f, true) {\n+                protected boolean removeEldestEntry(Map.Entry eldest) {\n+                    return size() > DYN_CACHE_SIZE;\n+                }\n+            });\n+\n+    /**\n+     * This method compiles a new subclass of CustomWeightingHelper composed from the provided CustomModel caches this\n+     * and returns an instance.\n+     */\n+    static CustomWeightingHelper create(CustomModel customModel, EncodedValueLookup lookup,\n+                                        double globalMaxSpeed, double maxSpeedFallback, DecimalEncodedValue avgSpeedEnc) {\n+        Java.CompilationUnit cu;\n+        try {\n+            String key = customModel.toString() + \",global:\" + globalMaxSpeed + \",fallback:\" + maxSpeedFallback;\n+            if (key.length() > 400_000) throw new IllegalArgumentException(\"Custom Model too big: \" + key.length());\n+\n+            Class clazz = CACHE.get(key);\n+            if (DYN_CACHE_SIZE > 0 && clazz == null)\n+                clazz = DYN_CACHE.get(key);\n+            if (clazz == null) {\n+                HashSet<String> priorityVariables = new LinkedHashSet<>();\n+                List<Java.BlockStatement> priorityStatements = createGetPriorityStatements(priorityVariables, customModel, lookup);\n+                HashSet<String> speedVariables = new LinkedHashSet<>();\n+                List<Java.BlockStatement> speedStatements = createGetSpeedStatements(speedVariables, customModel, lookup, globalMaxSpeed, maxSpeedFallback);\n+                // Create different class name, which is required only for debugging.\n+                // TODO does it improve performance too? I.e. it could be that the JIT is confused if different classes\n+                //  have the same name and it mixes performance stats. See https://github.com/janino-compiler/janino/issues/137\n+                long counter = longVal.incrementAndGet();\n+                String classTemplate = createClassTemplate(counter, priorityVariables, speedVariables, lookup);\n+                cu = (Java.CompilationUnit) new Parser(new org.codehaus.janino.Scanner(\"source\", new StringReader(classTemplate))).\n+                        parseAbstractCompilationUnit();\n+                cu = injectStatements(priorityStatements, speedStatements, cu);\n+                SimpleCompiler sc = createCompiler(counter, cu);\n+                clazz = sc.getClassLoader().loadClass(\"com.graphhopper.Test\" + counter);\n+                if (CACHE.size() < CACHE_SIZE)\n+                    CACHE.put(key, clazz);\n+                else if (DYN_CACHE_SIZE > 0)\n+                    DYN_CACHE.put(key, clazz);\n+            }\n+\n+            // The class does not need to be thread-safe as we create an instance per request\n+            CustomWeightingHelper prio = (CustomWeightingHelper) clazz.getDeclaredConstructor().newInstance();\n+            prio.init(lookup, avgSpeedEnc, customModel.getAreas());\n+            return prio;\n+        } catch (Exception ex) {\n+            String location = \"\";\n+            if (ex instanceof CompileException)\n+                location = \" in \" + ((CompileException) ex).getLocation().getFileName();\n+            throw new IllegalArgumentException(\"Cannot compile expression \" + location + \", \" + ex.getMessage(), ex);\n+        }\n+    }\n+\n+    /**\n+     * Parse the expressions from CustomModel relevant for the method getSpeed - see createClassTemplate.\n+     *\n+     * @return the created statements (parsed expressions)\n+     */\n+    private static List<Java.BlockStatement> createGetSpeedStatements(Set<String> speedVariables,\n+                                                                      CustomModel customModel, EncodedValueLookup lookup,\n+                                                                      double globalMaxSpeed, double maxSpeedFallback) throws Exception {\n+        List<Java.BlockStatement> speedStatements = new ArrayList<>();\n+        speedStatements.addAll(verifyExpressions(new StringBuilder(), \"speed_factor_user_statements\", speedVariables,\n+                customModel.getSpeedFactor(), lookup,\n+                num -> \"speed *= \" + num + \";\\n\", \"\"));\n+        StringBuilder codeSB = new StringBuilder(\"boolean applied = false;\\n\");\n+        speedStatements.addAll(verifyExpressions(codeSB, \"max_speed_user_statements\",\n+                speedVariables, customModel.getMaxSpeed(), lookup,\n+                num -> \"applied = true; speed = Math.min(speed,\" + num + \");\",\n+                \"if (!applied && speed > \" + maxSpeedFallback + \") return \" + maxSpeedFallback + \";\\n\" +\n+                        \"return Math.min(speed, \" + globalMaxSpeed + \");\\n\"));\n+        String speedMethodStartBlock = \"double speed = super.getRawSpeed(edge, reverse);\\n\";\n+        // a bit inefficient to possibly define variables twice, but for now we have two separate methods\n+        for (String arg : speedVariables) {\n+            speedMethodStartBlock += getVariableDeclaration(lookup, arg);\n+        }\n+        speedStatements.addAll(0, new Parser(new org.codehaus.janino.Scanner(\"getSpeed\", new StringReader(speedMethodStartBlock))).\n+                parseBlockStatements());\n+        return speedStatements;\n+    }\n+\n+    /**\n+     * Parse the expressions from CustomModel relevant for the method getPriority - see createClassTemplate.\n+     *\n+     * @return the created statements (parsed expressions)\n+     */\n+    private static List<Java.BlockStatement> createGetPriorityStatements(Set<String> priorityVariables,\n+                                                                         CustomModel customModel, EncodedValueLookup lookup) throws Exception {\n+        List<Java.BlockStatement> priorityStatements = new ArrayList<>();\n+        priorityStatements.addAll(verifyExpressions(new StringBuilder(\"double value = 1;\\n\"), \"priority_user_statements\",\n+                priorityVariables, customModel.getPriority(), lookup,\n+                num -> \"value *= \" + num + \";\\n\", \"return value;\"));\n+        String priorityMethodStartBlock = \"\";\n+        for (String arg : priorityVariables) {\n+            priorityMethodStartBlock += getVariableDeclaration(lookup, arg);\n+        }\n+        priorityStatements.addAll(0, new Parser(new org.codehaus.janino.Scanner(\"getPriority\", new StringReader(priorityMethodStartBlock))).\n+                parseBlockStatements());\n+        return priorityStatements;\n+    }\n+\n+    static boolean isValidVariableName(String name) {\n+        return name.startsWith(AREA_PREFIX) || allowedNames.contains(name);\n+    }\n+\n+    /**\n+     * For the methods getSpeed and getPriority we declare variables that contain the encoded value of the current edge\n+     * or if an area contains the current edge.\n+     */\n+    private static String getVariableDeclaration(EncodedValueLookup lookup, String arg) {\n+        if (arg.startsWith(AREA_PREFIX)) {\n+            String id = arg.substring(AREA_PREFIX.length());\n+            return \"boolean \" + arg + \" = \" + CustomWeightingHelper.class.getSimpleName() + \".in(this.area_\" + id + \", edge);\\n\";\n+        } else if (lookup.hasEncodedValue(arg)) {\n+            check(arg);\n+            EncodedValue enc = lookup.getEncodedValue(arg, EncodedValue.class);\n+            return getReturnType(enc) + \" \" + arg + \" = reverse ? \" +", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5cb073c89e7badcdb4e8aa42997f9b5a447e89ed"}, "originalPosition": 179}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM5NjY1NzE5OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/com/graphhopper/routing/weighting/custom/ExpressionBuilder.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMVQxMDo1NTo0MlrOIDzoow==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMlQyMDozMjoxM1rOIErWMQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDg2MjYyNw==", "bodyText": "Could we move this into the EncodedValue interface?\ne.g\npublic interface EncodedValue {\n    Class<?> getReturnType();\npublic interface BooleanEncodedValue extends EncodedValue {\n\n    default Class<?> getReturnType() {\n        return boolean.class;\n    }", "url": "https://github.com/graphhopper/graphhopper/pull/2209#discussion_r540862627", "createdAt": "2020-12-11T10:55:42Z", "author": {"login": "otbutz"}, "path": "core/src/main/java/com/graphhopper/routing/weighting/custom/ExpressionBuilder.java", "diffHunk": "@@ -0,0 +1,382 @@\n+/*\n+ *  Licensed to GraphHopper GmbH under one or more contributor\n+ *  license agreements. See the NOTICE file distributed with this work for\n+ *  additional information regarding copyright ownership.\n+ *\n+ *  GraphHopper GmbH licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except in\n+ *  compliance with the License. You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package com.graphhopper.routing.weighting.custom;\n+\n+import com.graphhopper.json.geo.JsonFeature;\n+import com.graphhopper.routing.ev.DecimalEncodedValue;\n+import com.graphhopper.routing.ev.EncodedValue;\n+import com.graphhopper.routing.ev.EncodedValueLookup;\n+import com.graphhopper.routing.util.CustomModel;\n+import com.graphhopper.routing.util.EncodingManager;\n+import com.graphhopper.util.EdgeIteratorState;\n+import com.graphhopper.util.GHUtility;\n+import com.graphhopper.util.shapes.BBox;\n+import com.graphhopper.util.shapes.Polygon;\n+import org.codehaus.commons.compiler.CompileException;\n+import org.codehaus.commons.compiler.Location;\n+import org.codehaus.commons.compiler.io.Readers;\n+import org.codehaus.janino.Scanner;\n+import org.codehaus.janino.*;\n+import org.codehaus.janino.util.DeepCopier;\n+import org.locationtech.jts.geom.prep.PreparedGeometryFactory;\n+\n+import java.io.*;\n+import java.util.*;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+class ExpressionBuilder {\n+    private static final AtomicLong longVal = new AtomicLong(1);\n+    private static final String AREA_PREFIX = \"in_area_\";\n+    private static final Set<String> allowedNames = new HashSet<>(Arrays.asList(\"edge\", \"Math\"));\n+    private static final boolean JANINO_DEBUG = Boolean.getBoolean(Scanner.SYSTEM_PROPERTY_SOURCE_DEBUGGING_ENABLE);\n+\n+    // TODO without a cache we get X% slower routing and Y% slower routingLM8. CH requests and preparation is unaffected\n+    // as cached weighting from preparation is used. This cache ensures that the first Weighting classes, typically the\n+    // ones specified in the profiles, are never removed regardless of how frequent other Weightings are created and accessed.\n+    // We only need to synchronize the get and put methods alone. E.g. we do not care for the race condition where\n+    // two identical classes are requested and one of them is overwritten. We could use CachingJavaSourceClassLoader from\n+    // Janino but 1. we would need to use a single compiler across threads and 2. the statements (for priority and speed)\n+    // are still unnecessarily created.\n+    private static final int CACHE_SIZE = Integer.getInteger(\"graphhopper.custom_weighting.cache_size\", 10);\n+    // TODO perf compare with ConcurrentHashMap, but I guess, if there is a difference at all, it is not big for small maps\n+    private static final Map<String, Class> CACHE = Collections.synchronizedMap(new HashMap<>(CACHE_SIZE));\n+\n+    // Introduce a dynamic cache to remember different Weighting classes, but throw away less frequently used classes.\n+    // Use accessOrder==true to remove oldest accessed entry, not oldest inserted.\n+    private static final int DYN_CACHE_SIZE = Integer.getInteger(\"graphhopper.custom_weighting.dynamic_cache_size\", 1000);\n+    private static final Map<String, Class> DYN_CACHE = Collections.synchronizedMap(\n+            new LinkedHashMap<String, Class>(DYN_CACHE_SIZE, 0.75f, true) {\n+                protected boolean removeEldestEntry(Map.Entry eldest) {\n+                    return size() > DYN_CACHE_SIZE;\n+                }\n+            });\n+\n+    /**\n+     * This method compiles a new subclass of CustomWeightingHelper composed from the provided CustomModel caches this\n+     * and returns an instance.\n+     */\n+    static CustomWeightingHelper create(CustomModel customModel, EncodedValueLookup lookup,\n+                                        double globalMaxSpeed, double maxSpeedFallback, DecimalEncodedValue avgSpeedEnc) {\n+        Java.CompilationUnit cu;\n+        try {\n+            String key = customModel.toString() + \",global:\" + globalMaxSpeed + \",fallback:\" + maxSpeedFallback;\n+            if (key.length() > 400_000) throw new IllegalArgumentException(\"Custom Model too big: \" + key.length());\n+\n+            Class clazz = CACHE.get(key);\n+            if (DYN_CACHE_SIZE > 0 && clazz == null)\n+                clazz = DYN_CACHE.get(key);\n+            if (clazz == null) {\n+                HashSet<String> priorityVariables = new LinkedHashSet<>();\n+                List<Java.BlockStatement> priorityStatements = createGetPriorityStatements(priorityVariables, customModel, lookup);\n+                HashSet<String> speedVariables = new LinkedHashSet<>();\n+                List<Java.BlockStatement> speedStatements = createGetSpeedStatements(speedVariables, customModel, lookup, globalMaxSpeed, maxSpeedFallback);\n+                // Create different class name, which is required only for debugging.\n+                // TODO does it improve performance too? I.e. it could be that the JIT is confused if different classes\n+                //  have the same name and it mixes performance stats. See https://github.com/janino-compiler/janino/issues/137\n+                long counter = longVal.incrementAndGet();\n+                String classTemplate = createClassTemplate(counter, priorityVariables, speedVariables, lookup);\n+                cu = (Java.CompilationUnit) new Parser(new org.codehaus.janino.Scanner(\"source\", new StringReader(classTemplate))).\n+                        parseAbstractCompilationUnit();\n+                cu = injectStatements(priorityStatements, speedStatements, cu);\n+                SimpleCompiler sc = createCompiler(counter, cu);\n+                clazz = sc.getClassLoader().loadClass(\"com.graphhopper.Test\" + counter);\n+                if (CACHE.size() < CACHE_SIZE)\n+                    CACHE.put(key, clazz);\n+                else if (DYN_CACHE_SIZE > 0)\n+                    DYN_CACHE.put(key, clazz);\n+            }\n+\n+            // The class does not need to be thread-safe as we create an instance per request\n+            CustomWeightingHelper prio = (CustomWeightingHelper) clazz.getDeclaredConstructor().newInstance();\n+            prio.init(lookup, avgSpeedEnc, customModel.getAreas());\n+            return prio;\n+        } catch (Exception ex) {\n+            String location = \"\";\n+            if (ex instanceof CompileException)\n+                location = \" in \" + ((CompileException) ex).getLocation().getFileName();\n+            throw new IllegalArgumentException(\"Cannot compile expression \" + location + \", \" + ex.getMessage(), ex);\n+        }\n+    }\n+\n+    /**\n+     * Parse the expressions from CustomModel relevant for the method getSpeed - see createClassTemplate.\n+     *\n+     * @return the created statements (parsed expressions)\n+     */\n+    private static List<Java.BlockStatement> createGetSpeedStatements(Set<String> speedVariables,\n+                                                                      CustomModel customModel, EncodedValueLookup lookup,\n+                                                                      double globalMaxSpeed, double maxSpeedFallback) throws Exception {\n+        List<Java.BlockStatement> speedStatements = new ArrayList<>();\n+        speedStatements.addAll(verifyExpressions(new StringBuilder(), \"speed_factor_user_statements\", speedVariables,\n+                customModel.getSpeedFactor(), lookup,\n+                num -> \"speed *= \" + num + \";\\n\", \"\"));\n+        StringBuilder codeSB = new StringBuilder(\"boolean applied = false;\\n\");\n+        speedStatements.addAll(verifyExpressions(codeSB, \"max_speed_user_statements\",\n+                speedVariables, customModel.getMaxSpeed(), lookup,\n+                num -> \"applied = true; speed = Math.min(speed,\" + num + \");\",\n+                \"if (!applied && speed > \" + maxSpeedFallback + \") return \" + maxSpeedFallback + \";\\n\" +\n+                        \"return Math.min(speed, \" + globalMaxSpeed + \");\\n\"));\n+        String speedMethodStartBlock = \"double speed = super.getRawSpeed(edge, reverse);\\n\";\n+        // a bit inefficient to possibly define variables twice, but for now we have two separate methods\n+        for (String arg : speedVariables) {\n+            speedMethodStartBlock += getVariableDeclaration(lookup, arg);\n+        }\n+        speedStatements.addAll(0, new Parser(new org.codehaus.janino.Scanner(\"getSpeed\", new StringReader(speedMethodStartBlock))).\n+                parseBlockStatements());\n+        return speedStatements;\n+    }\n+\n+    /**\n+     * Parse the expressions from CustomModel relevant for the method getPriority - see createClassTemplate.\n+     *\n+     * @return the created statements (parsed expressions)\n+     */\n+    private static List<Java.BlockStatement> createGetPriorityStatements(Set<String> priorityVariables,\n+                                                                         CustomModel customModel, EncodedValueLookup lookup) throws Exception {\n+        List<Java.BlockStatement> priorityStatements = new ArrayList<>();\n+        priorityStatements.addAll(verifyExpressions(new StringBuilder(\"double value = 1;\\n\"), \"priority_user_statements\",\n+                priorityVariables, customModel.getPriority(), lookup,\n+                num -> \"value *= \" + num + \";\\n\", \"return value;\"));\n+        String priorityMethodStartBlock = \"\";\n+        for (String arg : priorityVariables) {\n+            priorityMethodStartBlock += getVariableDeclaration(lookup, arg);\n+        }\n+        priorityStatements.addAll(0, new Parser(new org.codehaus.janino.Scanner(\"getPriority\", new StringReader(priorityMethodStartBlock))).\n+                parseBlockStatements());\n+        return priorityStatements;\n+    }\n+\n+    static boolean isValidVariableName(String name) {\n+        return name.startsWith(AREA_PREFIX) || allowedNames.contains(name);\n+    }\n+\n+    /**\n+     * For the methods getSpeed and getPriority we declare variables that contain the encoded value of the current edge\n+     * or if an area contains the current edge.\n+     */\n+    private static String getVariableDeclaration(EncodedValueLookup lookup, String arg) {\n+        if (arg.startsWith(AREA_PREFIX)) {\n+            String id = arg.substring(AREA_PREFIX.length());\n+            return \"boolean \" + arg + \" = \" + CustomWeightingHelper.class.getSimpleName() + \".in(this.area_\" + id + \", edge);\\n\";\n+        } else if (lookup.hasEncodedValue(arg)) {\n+            check(arg);\n+            EncodedValue enc = lookup.getEncodedValue(arg, EncodedValue.class);\n+            return getReturnType(enc) + \" \" + arg + \" = reverse ? \" +\n+                    \"edge.getReverse((\" + getInterface(enc) + \") this.\" + arg + \"_enc) : \" +\n+                    \"edge.get((\" + getInterface(enc) + \") this.\" + arg + \"_enc);\\n\";\n+        } else if (isValidVariableName(arg)) {\n+            return \"\";\n+        } else {\n+            throw new IllegalArgumentException(\"Not supported \" + arg);\n+        }\n+    }\n+\n+    /**\n+     * @return the interface as string of the provided EncodedValue, e.g. IntEncodedValue (only interface) or BooleanEncodedValue (first interface)\n+     */\n+    private static String getInterface(EncodedValue enc) {\n+        if (enc.getClass().getInterfaces().length == 0) return enc.getClass().getSimpleName();\n+        return enc.getClass().getInterfaces()[0].getSimpleName();\n+    }\n+\n+    private static String getReturnType(EncodedValue encodedValue) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5cb073c89e7badcdb4e8aa42997f9b5a447e89ed"}, "originalPosition": 197}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTc3NTQwOQ==", "bodyText": "For now I would keep this feature private", "url": "https://github.com/graphhopper/graphhopper/pull/2209#discussion_r541775409", "createdAt": "2020-12-12T20:32:13Z", "author": {"login": "karussell"}, "path": "core/src/main/java/com/graphhopper/routing/weighting/custom/ExpressionBuilder.java", "diffHunk": "@@ -0,0 +1,382 @@\n+/*\n+ *  Licensed to GraphHopper GmbH under one or more contributor\n+ *  license agreements. See the NOTICE file distributed with this work for\n+ *  additional information regarding copyright ownership.\n+ *\n+ *  GraphHopper GmbH licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except in\n+ *  compliance with the License. You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package com.graphhopper.routing.weighting.custom;\n+\n+import com.graphhopper.json.geo.JsonFeature;\n+import com.graphhopper.routing.ev.DecimalEncodedValue;\n+import com.graphhopper.routing.ev.EncodedValue;\n+import com.graphhopper.routing.ev.EncodedValueLookup;\n+import com.graphhopper.routing.util.CustomModel;\n+import com.graphhopper.routing.util.EncodingManager;\n+import com.graphhopper.util.EdgeIteratorState;\n+import com.graphhopper.util.GHUtility;\n+import com.graphhopper.util.shapes.BBox;\n+import com.graphhopper.util.shapes.Polygon;\n+import org.codehaus.commons.compiler.CompileException;\n+import org.codehaus.commons.compiler.Location;\n+import org.codehaus.commons.compiler.io.Readers;\n+import org.codehaus.janino.Scanner;\n+import org.codehaus.janino.*;\n+import org.codehaus.janino.util.DeepCopier;\n+import org.locationtech.jts.geom.prep.PreparedGeometryFactory;\n+\n+import java.io.*;\n+import java.util.*;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+class ExpressionBuilder {\n+    private static final AtomicLong longVal = new AtomicLong(1);\n+    private static final String AREA_PREFIX = \"in_area_\";\n+    private static final Set<String> allowedNames = new HashSet<>(Arrays.asList(\"edge\", \"Math\"));\n+    private static final boolean JANINO_DEBUG = Boolean.getBoolean(Scanner.SYSTEM_PROPERTY_SOURCE_DEBUGGING_ENABLE);\n+\n+    // TODO without a cache we get X% slower routing and Y% slower routingLM8. CH requests and preparation is unaffected\n+    // as cached weighting from preparation is used. This cache ensures that the first Weighting classes, typically the\n+    // ones specified in the profiles, are never removed regardless of how frequent other Weightings are created and accessed.\n+    // We only need to synchronize the get and put methods alone. E.g. we do not care for the race condition where\n+    // two identical classes are requested and one of them is overwritten. We could use CachingJavaSourceClassLoader from\n+    // Janino but 1. we would need to use a single compiler across threads and 2. the statements (for priority and speed)\n+    // are still unnecessarily created.\n+    private static final int CACHE_SIZE = Integer.getInteger(\"graphhopper.custom_weighting.cache_size\", 10);\n+    // TODO perf compare with ConcurrentHashMap, but I guess, if there is a difference at all, it is not big for small maps\n+    private static final Map<String, Class> CACHE = Collections.synchronizedMap(new HashMap<>(CACHE_SIZE));\n+\n+    // Introduce a dynamic cache to remember different Weighting classes, but throw away less frequently used classes.\n+    // Use accessOrder==true to remove oldest accessed entry, not oldest inserted.\n+    private static final int DYN_CACHE_SIZE = Integer.getInteger(\"graphhopper.custom_weighting.dynamic_cache_size\", 1000);\n+    private static final Map<String, Class> DYN_CACHE = Collections.synchronizedMap(\n+            new LinkedHashMap<String, Class>(DYN_CACHE_SIZE, 0.75f, true) {\n+                protected boolean removeEldestEntry(Map.Entry eldest) {\n+                    return size() > DYN_CACHE_SIZE;\n+                }\n+            });\n+\n+    /**\n+     * This method compiles a new subclass of CustomWeightingHelper composed from the provided CustomModel caches this\n+     * and returns an instance.\n+     */\n+    static CustomWeightingHelper create(CustomModel customModel, EncodedValueLookup lookup,\n+                                        double globalMaxSpeed, double maxSpeedFallback, DecimalEncodedValue avgSpeedEnc) {\n+        Java.CompilationUnit cu;\n+        try {\n+            String key = customModel.toString() + \",global:\" + globalMaxSpeed + \",fallback:\" + maxSpeedFallback;\n+            if (key.length() > 400_000) throw new IllegalArgumentException(\"Custom Model too big: \" + key.length());\n+\n+            Class clazz = CACHE.get(key);\n+            if (DYN_CACHE_SIZE > 0 && clazz == null)\n+                clazz = DYN_CACHE.get(key);\n+            if (clazz == null) {\n+                HashSet<String> priorityVariables = new LinkedHashSet<>();\n+                List<Java.BlockStatement> priorityStatements = createGetPriorityStatements(priorityVariables, customModel, lookup);\n+                HashSet<String> speedVariables = new LinkedHashSet<>();\n+                List<Java.BlockStatement> speedStatements = createGetSpeedStatements(speedVariables, customModel, lookup, globalMaxSpeed, maxSpeedFallback);\n+                // Create different class name, which is required only for debugging.\n+                // TODO does it improve performance too? I.e. it could be that the JIT is confused if different classes\n+                //  have the same name and it mixes performance stats. See https://github.com/janino-compiler/janino/issues/137\n+                long counter = longVal.incrementAndGet();\n+                String classTemplate = createClassTemplate(counter, priorityVariables, speedVariables, lookup);\n+                cu = (Java.CompilationUnit) new Parser(new org.codehaus.janino.Scanner(\"source\", new StringReader(classTemplate))).\n+                        parseAbstractCompilationUnit();\n+                cu = injectStatements(priorityStatements, speedStatements, cu);\n+                SimpleCompiler sc = createCompiler(counter, cu);\n+                clazz = sc.getClassLoader().loadClass(\"com.graphhopper.Test\" + counter);\n+                if (CACHE.size() < CACHE_SIZE)\n+                    CACHE.put(key, clazz);\n+                else if (DYN_CACHE_SIZE > 0)\n+                    DYN_CACHE.put(key, clazz);\n+            }\n+\n+            // The class does not need to be thread-safe as we create an instance per request\n+            CustomWeightingHelper prio = (CustomWeightingHelper) clazz.getDeclaredConstructor().newInstance();\n+            prio.init(lookup, avgSpeedEnc, customModel.getAreas());\n+            return prio;\n+        } catch (Exception ex) {\n+            String location = \"\";\n+            if (ex instanceof CompileException)\n+                location = \" in \" + ((CompileException) ex).getLocation().getFileName();\n+            throw new IllegalArgumentException(\"Cannot compile expression \" + location + \", \" + ex.getMessage(), ex);\n+        }\n+    }\n+\n+    /**\n+     * Parse the expressions from CustomModel relevant for the method getSpeed - see createClassTemplate.\n+     *\n+     * @return the created statements (parsed expressions)\n+     */\n+    private static List<Java.BlockStatement> createGetSpeedStatements(Set<String> speedVariables,\n+                                                                      CustomModel customModel, EncodedValueLookup lookup,\n+                                                                      double globalMaxSpeed, double maxSpeedFallback) throws Exception {\n+        List<Java.BlockStatement> speedStatements = new ArrayList<>();\n+        speedStatements.addAll(verifyExpressions(new StringBuilder(), \"speed_factor_user_statements\", speedVariables,\n+                customModel.getSpeedFactor(), lookup,\n+                num -> \"speed *= \" + num + \";\\n\", \"\"));\n+        StringBuilder codeSB = new StringBuilder(\"boolean applied = false;\\n\");\n+        speedStatements.addAll(verifyExpressions(codeSB, \"max_speed_user_statements\",\n+                speedVariables, customModel.getMaxSpeed(), lookup,\n+                num -> \"applied = true; speed = Math.min(speed,\" + num + \");\",\n+                \"if (!applied && speed > \" + maxSpeedFallback + \") return \" + maxSpeedFallback + \";\\n\" +\n+                        \"return Math.min(speed, \" + globalMaxSpeed + \");\\n\"));\n+        String speedMethodStartBlock = \"double speed = super.getRawSpeed(edge, reverse);\\n\";\n+        // a bit inefficient to possibly define variables twice, but for now we have two separate methods\n+        for (String arg : speedVariables) {\n+            speedMethodStartBlock += getVariableDeclaration(lookup, arg);\n+        }\n+        speedStatements.addAll(0, new Parser(new org.codehaus.janino.Scanner(\"getSpeed\", new StringReader(speedMethodStartBlock))).\n+                parseBlockStatements());\n+        return speedStatements;\n+    }\n+\n+    /**\n+     * Parse the expressions from CustomModel relevant for the method getPriority - see createClassTemplate.\n+     *\n+     * @return the created statements (parsed expressions)\n+     */\n+    private static List<Java.BlockStatement> createGetPriorityStatements(Set<String> priorityVariables,\n+                                                                         CustomModel customModel, EncodedValueLookup lookup) throws Exception {\n+        List<Java.BlockStatement> priorityStatements = new ArrayList<>();\n+        priorityStatements.addAll(verifyExpressions(new StringBuilder(\"double value = 1;\\n\"), \"priority_user_statements\",\n+                priorityVariables, customModel.getPriority(), lookup,\n+                num -> \"value *= \" + num + \";\\n\", \"return value;\"));\n+        String priorityMethodStartBlock = \"\";\n+        for (String arg : priorityVariables) {\n+            priorityMethodStartBlock += getVariableDeclaration(lookup, arg);\n+        }\n+        priorityStatements.addAll(0, new Parser(new org.codehaus.janino.Scanner(\"getPriority\", new StringReader(priorityMethodStartBlock))).\n+                parseBlockStatements());\n+        return priorityStatements;\n+    }\n+\n+    static boolean isValidVariableName(String name) {\n+        return name.startsWith(AREA_PREFIX) || allowedNames.contains(name);\n+    }\n+\n+    /**\n+     * For the methods getSpeed and getPriority we declare variables that contain the encoded value of the current edge\n+     * or if an area contains the current edge.\n+     */\n+    private static String getVariableDeclaration(EncodedValueLookup lookup, String arg) {\n+        if (arg.startsWith(AREA_PREFIX)) {\n+            String id = arg.substring(AREA_PREFIX.length());\n+            return \"boolean \" + arg + \" = \" + CustomWeightingHelper.class.getSimpleName() + \".in(this.area_\" + id + \", edge);\\n\";\n+        } else if (lookup.hasEncodedValue(arg)) {\n+            check(arg);\n+            EncodedValue enc = lookup.getEncodedValue(arg, EncodedValue.class);\n+            return getReturnType(enc) + \" \" + arg + \" = reverse ? \" +\n+                    \"edge.getReverse((\" + getInterface(enc) + \") this.\" + arg + \"_enc) : \" +\n+                    \"edge.get((\" + getInterface(enc) + \") this.\" + arg + \"_enc);\\n\";\n+        } else if (isValidVariableName(arg)) {\n+            return \"\";\n+        } else {\n+            throw new IllegalArgumentException(\"Not supported \" + arg);\n+        }\n+    }\n+\n+    /**\n+     * @return the interface as string of the provided EncodedValue, e.g. IntEncodedValue (only interface) or BooleanEncodedValue (first interface)\n+     */\n+    private static String getInterface(EncodedValue enc) {\n+        if (enc.getClass().getInterfaces().length == 0) return enc.getClass().getSimpleName();\n+        return enc.getClass().getInterfaces()[0].getSimpleName();\n+    }\n+\n+    private static String getReturnType(EncodedValue encodedValue) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDg2MjYyNw=="}, "originalCommit": {"oid": "5cb073c89e7badcdb4e8aa42997f9b5a447e89ed"}, "originalPosition": 197}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM5NjY3NDU0OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/com/graphhopper/routing/weighting/custom/ExpressionBuilder.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMVQxMDo1OTo0OVrOIDzyXw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMVQxMDo1OTo0OVrOIDzyXw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDg2NTExOQ==", "bodyText": "StringBuilder?", "url": "https://github.com/graphhopper/graphhopper/pull/2209#discussion_r540865119", "createdAt": "2020-12-11T10:59:49Z", "author": {"login": "otbutz"}, "path": "core/src/main/java/com/graphhopper/routing/weighting/custom/ExpressionBuilder.java", "diffHunk": "@@ -0,0 +1,382 @@\n+/*\n+ *  Licensed to GraphHopper GmbH under one or more contributor\n+ *  license agreements. See the NOTICE file distributed with this work for\n+ *  additional information regarding copyright ownership.\n+ *\n+ *  GraphHopper GmbH licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except in\n+ *  compliance with the License. You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package com.graphhopper.routing.weighting.custom;\n+\n+import com.graphhopper.json.geo.JsonFeature;\n+import com.graphhopper.routing.ev.DecimalEncodedValue;\n+import com.graphhopper.routing.ev.EncodedValue;\n+import com.graphhopper.routing.ev.EncodedValueLookup;\n+import com.graphhopper.routing.util.CustomModel;\n+import com.graphhopper.routing.util.EncodingManager;\n+import com.graphhopper.util.EdgeIteratorState;\n+import com.graphhopper.util.GHUtility;\n+import com.graphhopper.util.shapes.BBox;\n+import com.graphhopper.util.shapes.Polygon;\n+import org.codehaus.commons.compiler.CompileException;\n+import org.codehaus.commons.compiler.Location;\n+import org.codehaus.commons.compiler.io.Readers;\n+import org.codehaus.janino.Scanner;\n+import org.codehaus.janino.*;\n+import org.codehaus.janino.util.DeepCopier;\n+import org.locationtech.jts.geom.prep.PreparedGeometryFactory;\n+\n+import java.io.*;\n+import java.util.*;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+class ExpressionBuilder {\n+    private static final AtomicLong longVal = new AtomicLong(1);\n+    private static final String AREA_PREFIX = \"in_area_\";\n+    private static final Set<String> allowedNames = new HashSet<>(Arrays.asList(\"edge\", \"Math\"));\n+    private static final boolean JANINO_DEBUG = Boolean.getBoolean(Scanner.SYSTEM_PROPERTY_SOURCE_DEBUGGING_ENABLE);\n+\n+    // TODO without a cache we get X% slower routing and Y% slower routingLM8. CH requests and preparation is unaffected\n+    // as cached weighting from preparation is used. This cache ensures that the first Weighting classes, typically the\n+    // ones specified in the profiles, are never removed regardless of how frequent other Weightings are created and accessed.\n+    // We only need to synchronize the get and put methods alone. E.g. we do not care for the race condition where\n+    // two identical classes are requested and one of them is overwritten. We could use CachingJavaSourceClassLoader from\n+    // Janino but 1. we would need to use a single compiler across threads and 2. the statements (for priority and speed)\n+    // are still unnecessarily created.\n+    private static final int CACHE_SIZE = Integer.getInteger(\"graphhopper.custom_weighting.cache_size\", 10);\n+    // TODO perf compare with ConcurrentHashMap, but I guess, if there is a difference at all, it is not big for small maps\n+    private static final Map<String, Class> CACHE = Collections.synchronizedMap(new HashMap<>(CACHE_SIZE));\n+\n+    // Introduce a dynamic cache to remember different Weighting classes, but throw away less frequently used classes.\n+    // Use accessOrder==true to remove oldest accessed entry, not oldest inserted.\n+    private static final int DYN_CACHE_SIZE = Integer.getInteger(\"graphhopper.custom_weighting.dynamic_cache_size\", 1000);\n+    private static final Map<String, Class> DYN_CACHE = Collections.synchronizedMap(\n+            new LinkedHashMap<String, Class>(DYN_CACHE_SIZE, 0.75f, true) {\n+                protected boolean removeEldestEntry(Map.Entry eldest) {\n+                    return size() > DYN_CACHE_SIZE;\n+                }\n+            });\n+\n+    /**\n+     * This method compiles a new subclass of CustomWeightingHelper composed from the provided CustomModel caches this\n+     * and returns an instance.\n+     */\n+    static CustomWeightingHelper create(CustomModel customModel, EncodedValueLookup lookup,\n+                                        double globalMaxSpeed, double maxSpeedFallback, DecimalEncodedValue avgSpeedEnc) {\n+        Java.CompilationUnit cu;\n+        try {\n+            String key = customModel.toString() + \",global:\" + globalMaxSpeed + \",fallback:\" + maxSpeedFallback;\n+            if (key.length() > 400_000) throw new IllegalArgumentException(\"Custom Model too big: \" + key.length());\n+\n+            Class clazz = CACHE.get(key);\n+            if (DYN_CACHE_SIZE > 0 && clazz == null)\n+                clazz = DYN_CACHE.get(key);\n+            if (clazz == null) {\n+                HashSet<String> priorityVariables = new LinkedHashSet<>();\n+                List<Java.BlockStatement> priorityStatements = createGetPriorityStatements(priorityVariables, customModel, lookup);\n+                HashSet<String> speedVariables = new LinkedHashSet<>();\n+                List<Java.BlockStatement> speedStatements = createGetSpeedStatements(speedVariables, customModel, lookup, globalMaxSpeed, maxSpeedFallback);\n+                // Create different class name, which is required only for debugging.\n+                // TODO does it improve performance too? I.e. it could be that the JIT is confused if different classes\n+                //  have the same name and it mixes performance stats. See https://github.com/janino-compiler/janino/issues/137\n+                long counter = longVal.incrementAndGet();\n+                String classTemplate = createClassTemplate(counter, priorityVariables, speedVariables, lookup);\n+                cu = (Java.CompilationUnit) new Parser(new org.codehaus.janino.Scanner(\"source\", new StringReader(classTemplate))).\n+                        parseAbstractCompilationUnit();\n+                cu = injectStatements(priorityStatements, speedStatements, cu);\n+                SimpleCompiler sc = createCompiler(counter, cu);\n+                clazz = sc.getClassLoader().loadClass(\"com.graphhopper.Test\" + counter);\n+                if (CACHE.size() < CACHE_SIZE)\n+                    CACHE.put(key, clazz);\n+                else if (DYN_CACHE_SIZE > 0)\n+                    DYN_CACHE.put(key, clazz);\n+            }\n+\n+            // The class does not need to be thread-safe as we create an instance per request\n+            CustomWeightingHelper prio = (CustomWeightingHelper) clazz.getDeclaredConstructor().newInstance();\n+            prio.init(lookup, avgSpeedEnc, customModel.getAreas());\n+            return prio;\n+        } catch (Exception ex) {\n+            String location = \"\";\n+            if (ex instanceof CompileException)\n+                location = \" in \" + ((CompileException) ex).getLocation().getFileName();\n+            throw new IllegalArgumentException(\"Cannot compile expression \" + location + \", \" + ex.getMessage(), ex);\n+        }\n+    }\n+\n+    /**\n+     * Parse the expressions from CustomModel relevant for the method getSpeed - see createClassTemplate.\n+     *\n+     * @return the created statements (parsed expressions)\n+     */\n+    private static List<Java.BlockStatement> createGetSpeedStatements(Set<String> speedVariables,\n+                                                                      CustomModel customModel, EncodedValueLookup lookup,\n+                                                                      double globalMaxSpeed, double maxSpeedFallback) throws Exception {\n+        List<Java.BlockStatement> speedStatements = new ArrayList<>();\n+        speedStatements.addAll(verifyExpressions(new StringBuilder(), \"speed_factor_user_statements\", speedVariables,\n+                customModel.getSpeedFactor(), lookup,\n+                num -> \"speed *= \" + num + \";\\n\", \"\"));\n+        StringBuilder codeSB = new StringBuilder(\"boolean applied = false;\\n\");\n+        speedStatements.addAll(verifyExpressions(codeSB, \"max_speed_user_statements\",\n+                speedVariables, customModel.getMaxSpeed(), lookup,\n+                num -> \"applied = true; speed = Math.min(speed,\" + num + \");\",\n+                \"if (!applied && speed > \" + maxSpeedFallback + \") return \" + maxSpeedFallback + \";\\n\" +\n+                        \"return Math.min(speed, \" + globalMaxSpeed + \");\\n\"));\n+        String speedMethodStartBlock = \"double speed = super.getRawSpeed(edge, reverse);\\n\";\n+        // a bit inefficient to possibly define variables twice, but for now we have two separate methods\n+        for (String arg : speedVariables) {\n+            speedMethodStartBlock += getVariableDeclaration(lookup, arg);\n+        }\n+        speedStatements.addAll(0, new Parser(new org.codehaus.janino.Scanner(\"getSpeed\", new StringReader(speedMethodStartBlock))).\n+                parseBlockStatements());\n+        return speedStatements;\n+    }\n+\n+    /**\n+     * Parse the expressions from CustomModel relevant for the method getPriority - see createClassTemplate.\n+     *\n+     * @return the created statements (parsed expressions)\n+     */\n+    private static List<Java.BlockStatement> createGetPriorityStatements(Set<String> priorityVariables,\n+                                                                         CustomModel customModel, EncodedValueLookup lookup) throws Exception {\n+        List<Java.BlockStatement> priorityStatements = new ArrayList<>();\n+        priorityStatements.addAll(verifyExpressions(new StringBuilder(\"double value = 1;\\n\"), \"priority_user_statements\",\n+                priorityVariables, customModel.getPriority(), lookup,\n+                num -> \"value *= \" + num + \";\\n\", \"return value;\"));\n+        String priorityMethodStartBlock = \"\";\n+        for (String arg : priorityVariables) {\n+            priorityMethodStartBlock += getVariableDeclaration(lookup, arg);\n+        }\n+        priorityStatements.addAll(0, new Parser(new org.codehaus.janino.Scanner(\"getPriority\", new StringReader(priorityMethodStartBlock))).\n+                parseBlockStatements());\n+        return priorityStatements;\n+    }\n+\n+    static boolean isValidVariableName(String name) {\n+        return name.startsWith(AREA_PREFIX) || allowedNames.contains(name);\n+    }\n+\n+    /**\n+     * For the methods getSpeed and getPriority we declare variables that contain the encoded value of the current edge\n+     * or if an area contains the current edge.\n+     */\n+    private static String getVariableDeclaration(EncodedValueLookup lookup, String arg) {\n+        if (arg.startsWith(AREA_PREFIX)) {\n+            String id = arg.substring(AREA_PREFIX.length());\n+            return \"boolean \" + arg + \" = \" + CustomWeightingHelper.class.getSimpleName() + \".in(this.area_\" + id + \", edge);\\n\";\n+        } else if (lookup.hasEncodedValue(arg)) {\n+            check(arg);\n+            EncodedValue enc = lookup.getEncodedValue(arg, EncodedValue.class);\n+            return getReturnType(enc) + \" \" + arg + \" = reverse ? \" +\n+                    \"edge.getReverse((\" + getInterface(enc) + \") this.\" + arg + \"_enc) : \" +\n+                    \"edge.get((\" + getInterface(enc) + \") this.\" + arg + \"_enc);\\n\";\n+        } else if (isValidVariableName(arg)) {\n+            return \"\";\n+        } else {\n+            throw new IllegalArgumentException(\"Not supported \" + arg);\n+        }\n+    }\n+\n+    /**\n+     * @return the interface as string of the provided EncodedValue, e.g. IntEncodedValue (only interface) or BooleanEncodedValue (first interface)\n+     */\n+    private static String getInterface(EncodedValue enc) {\n+        if (enc.getClass().getInterfaces().length == 0) return enc.getClass().getSimpleName();\n+        return enc.getClass().getInterfaces()[0].getSimpleName();\n+    }\n+\n+    private static String getReturnType(EncodedValue encodedValue) {\n+        String name = encodedValue.getClass().getSimpleName();\n+        if (name.contains(\"Enum\")) return \"Enum\";\n+        if (name.contains(\"Decimal\")) return \"double\";\n+        if (name.contains(\"Int\")) return \"int\";\n+        if (name.contains(\"Boolean\")) return \"boolean\";\n+        throw new IllegalArgumentException(\"Unsupported EncodedValue \" + name);\n+    }\n+\n+    static void check(String encValue) {\n+        if(encValue.contains(\".\")) throw new IllegalArgumentException(\"encoded value with invalid name: \" + encValue);\n+    }\n+\n+    /**\n+     * Create the class source file from the detected variables (priorityVariables and speedVariables). We assume that\n+     * these variables are safe although they are user input because we collected them from parsing via Janino. This\n+     * means that the source file is free from user input and could be directly compiled. Before we do this we still\n+     * have to inject that parsed and safe user expressions in a later step.\n+     */\n+    private static String createClassTemplate(long counter, Set<String> priorityVariables, Set<String> speedVariables, EncodedValueLookup lookup) {\n+        final StringBuilder importSourceCode = new StringBuilder(\"import com.graphhopper.routing.ev.*;\\n\");\n+        importSourceCode.append(\"import java.util.Map;\\n\");\n+        final StringBuilder classSourceCode = new StringBuilder(100);\n+        boolean includedAreaImports = false;\n+\n+        final StringBuilder initSourceCode = new StringBuilder(\"this.avg_speed_enc = avgSpeedEnc;\\n\");\n+        Set<String> set = new HashSet<>(priorityVariables);\n+        set.addAll(speedVariables);\n+        for (String arg : set) {\n+            if (lookup.hasEncodedValue(arg)) {\n+                check(arg);\n+                EncodedValue enc = lookup.getEncodedValue(arg, EncodedValue.class);\n+                classSourceCode.append(\"protected \" + enc.getClass().getSimpleName() + \" \" + arg + \"_enc;\\n\");\n+                initSourceCode.append(\"if (lookup.hasEncodedValue(\\\"\" + arg + \"\\\")) \");\n+                initSourceCode.append(\"this.\" + arg + \"_enc = (\" + enc.getClass().getSimpleName()\n+                        + \") lookup.getEncodedValue(\\\"\" + arg + \"\\\", EncodedValue.class);\\n\");\n+            } else if (arg.startsWith(AREA_PREFIX)) {\n+                if (!includedAreaImports) {\n+                    importSourceCode.append(\"import \" + BBox.class.getName() + \";\\n\");\n+                    importSourceCode.append(\"import \" + GHUtility.class.getName() + \";\\n\");\n+                    importSourceCode.append(\"import \" + PreparedGeometryFactory.class.getName() + \";\\n\");\n+                    importSourceCode.append(\"import \" + JsonFeature.class.getName() + \";\\n\");\n+                    importSourceCode.append(\"import \" + Polygon.class.getName() + \";\\n\");\n+                    includedAreaImports = true;\n+                }\n+\n+                String id = arg.substring(AREA_PREFIX.length());\n+                String varName = \"area_\" + id;\n+                classSourceCode.append(\"protected \" + Polygon.class.getSimpleName() + \" \" + varName + \";\\n\");\n+                initSourceCode.append(\"JsonFeature feature = (JsonFeature) areas.get(\\\"\" + id + \"\\\");\\n\");\n+                initSourceCode.append(\"if(feature == null) throw new IllegalArgumentException(\\\"Area '\" + id + \"' wasn't found\\\");\\n\");\n+                initSourceCode.append(\"this.\" + varName + \" = new Polygon(new PreparedGeometryFactory().create(feature.getGeometry()));\\n\");\n+            } else {\n+                if (!isValidVariableName(arg))\n+                    throw new IllegalArgumentException(\"Variable not supported: \" + arg);\n+            }\n+        }\n+\n+        return \"\"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5cb073c89e7badcdb4e8aa42997f9b5a447e89ed"}, "originalPosition": 255}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM5NjY4OTk3OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/com/graphhopper/routing/weighting/custom/ExpressionBuilder.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMVQxMTowMzo0MFrOIDz7Bg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMlQyMDozNDoyNVrOIErXew==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDg2NzMzNA==", "bodyText": "I wouldn't expect the injectStatements method to clear the collection here.", "url": "https://github.com/graphhopper/graphhopper/pull/2209#discussion_r540867334", "createdAt": "2020-12-11T11:03:40Z", "author": {"login": "otbutz"}, "path": "core/src/main/java/com/graphhopper/routing/weighting/custom/ExpressionBuilder.java", "diffHunk": "@@ -0,0 +1,382 @@\n+/*\n+ *  Licensed to GraphHopper GmbH under one or more contributor\n+ *  license agreements. See the NOTICE file distributed with this work for\n+ *  additional information regarding copyright ownership.\n+ *\n+ *  GraphHopper GmbH licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except in\n+ *  compliance with the License. You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package com.graphhopper.routing.weighting.custom;\n+\n+import com.graphhopper.json.geo.JsonFeature;\n+import com.graphhopper.routing.ev.DecimalEncodedValue;\n+import com.graphhopper.routing.ev.EncodedValue;\n+import com.graphhopper.routing.ev.EncodedValueLookup;\n+import com.graphhopper.routing.util.CustomModel;\n+import com.graphhopper.routing.util.EncodingManager;\n+import com.graphhopper.util.EdgeIteratorState;\n+import com.graphhopper.util.GHUtility;\n+import com.graphhopper.util.shapes.BBox;\n+import com.graphhopper.util.shapes.Polygon;\n+import org.codehaus.commons.compiler.CompileException;\n+import org.codehaus.commons.compiler.Location;\n+import org.codehaus.commons.compiler.io.Readers;\n+import org.codehaus.janino.Scanner;\n+import org.codehaus.janino.*;\n+import org.codehaus.janino.util.DeepCopier;\n+import org.locationtech.jts.geom.prep.PreparedGeometryFactory;\n+\n+import java.io.*;\n+import java.util.*;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+class ExpressionBuilder {\n+    private static final AtomicLong longVal = new AtomicLong(1);\n+    private static final String AREA_PREFIX = \"in_area_\";\n+    private static final Set<String> allowedNames = new HashSet<>(Arrays.asList(\"edge\", \"Math\"));\n+    private static final boolean JANINO_DEBUG = Boolean.getBoolean(Scanner.SYSTEM_PROPERTY_SOURCE_DEBUGGING_ENABLE);\n+\n+    // TODO without a cache we get X% slower routing and Y% slower routingLM8. CH requests and preparation is unaffected\n+    // as cached weighting from preparation is used. This cache ensures that the first Weighting classes, typically the\n+    // ones specified in the profiles, are never removed regardless of how frequent other Weightings are created and accessed.\n+    // We only need to synchronize the get and put methods alone. E.g. we do not care for the race condition where\n+    // two identical classes are requested and one of them is overwritten. We could use CachingJavaSourceClassLoader from\n+    // Janino but 1. we would need to use a single compiler across threads and 2. the statements (for priority and speed)\n+    // are still unnecessarily created.\n+    private static final int CACHE_SIZE = Integer.getInteger(\"graphhopper.custom_weighting.cache_size\", 10);\n+    // TODO perf compare with ConcurrentHashMap, but I guess, if there is a difference at all, it is not big for small maps\n+    private static final Map<String, Class> CACHE = Collections.synchronizedMap(new HashMap<>(CACHE_SIZE));\n+\n+    // Introduce a dynamic cache to remember different Weighting classes, but throw away less frequently used classes.\n+    // Use accessOrder==true to remove oldest accessed entry, not oldest inserted.\n+    private static final int DYN_CACHE_SIZE = Integer.getInteger(\"graphhopper.custom_weighting.dynamic_cache_size\", 1000);\n+    private static final Map<String, Class> DYN_CACHE = Collections.synchronizedMap(\n+            new LinkedHashMap<String, Class>(DYN_CACHE_SIZE, 0.75f, true) {\n+                protected boolean removeEldestEntry(Map.Entry eldest) {\n+                    return size() > DYN_CACHE_SIZE;\n+                }\n+            });\n+\n+    /**\n+     * This method compiles a new subclass of CustomWeightingHelper composed from the provided CustomModel caches this\n+     * and returns an instance.\n+     */\n+    static CustomWeightingHelper create(CustomModel customModel, EncodedValueLookup lookup,\n+                                        double globalMaxSpeed, double maxSpeedFallback, DecimalEncodedValue avgSpeedEnc) {\n+        Java.CompilationUnit cu;\n+        try {\n+            String key = customModel.toString() + \",global:\" + globalMaxSpeed + \",fallback:\" + maxSpeedFallback;\n+            if (key.length() > 400_000) throw new IllegalArgumentException(\"Custom Model too big: \" + key.length());\n+\n+            Class clazz = CACHE.get(key);\n+            if (DYN_CACHE_SIZE > 0 && clazz == null)\n+                clazz = DYN_CACHE.get(key);\n+            if (clazz == null) {\n+                HashSet<String> priorityVariables = new LinkedHashSet<>();\n+                List<Java.BlockStatement> priorityStatements = createGetPriorityStatements(priorityVariables, customModel, lookup);\n+                HashSet<String> speedVariables = new LinkedHashSet<>();\n+                List<Java.BlockStatement> speedStatements = createGetSpeedStatements(speedVariables, customModel, lookup, globalMaxSpeed, maxSpeedFallback);\n+                // Create different class name, which is required only for debugging.\n+                // TODO does it improve performance too? I.e. it could be that the JIT is confused if different classes\n+                //  have the same name and it mixes performance stats. See https://github.com/janino-compiler/janino/issues/137\n+                long counter = longVal.incrementAndGet();\n+                String classTemplate = createClassTemplate(counter, priorityVariables, speedVariables, lookup);\n+                cu = (Java.CompilationUnit) new Parser(new org.codehaus.janino.Scanner(\"source\", new StringReader(classTemplate))).\n+                        parseAbstractCompilationUnit();\n+                cu = injectStatements(priorityStatements, speedStatements, cu);\n+                SimpleCompiler sc = createCompiler(counter, cu);\n+                clazz = sc.getClassLoader().loadClass(\"com.graphhopper.Test\" + counter);\n+                if (CACHE.size() < CACHE_SIZE)\n+                    CACHE.put(key, clazz);\n+                else if (DYN_CACHE_SIZE > 0)\n+                    DYN_CACHE.put(key, clazz);\n+            }\n+\n+            // The class does not need to be thread-safe as we create an instance per request\n+            CustomWeightingHelper prio = (CustomWeightingHelper) clazz.getDeclaredConstructor().newInstance();\n+            prio.init(lookup, avgSpeedEnc, customModel.getAreas());\n+            return prio;\n+        } catch (Exception ex) {\n+            String location = \"\";\n+            if (ex instanceof CompileException)\n+                location = \" in \" + ((CompileException) ex).getLocation().getFileName();\n+            throw new IllegalArgumentException(\"Cannot compile expression \" + location + \", \" + ex.getMessage(), ex);\n+        }\n+    }\n+\n+    /**\n+     * Parse the expressions from CustomModel relevant for the method getSpeed - see createClassTemplate.\n+     *\n+     * @return the created statements (parsed expressions)\n+     */\n+    private static List<Java.BlockStatement> createGetSpeedStatements(Set<String> speedVariables,\n+                                                                      CustomModel customModel, EncodedValueLookup lookup,\n+                                                                      double globalMaxSpeed, double maxSpeedFallback) throws Exception {\n+        List<Java.BlockStatement> speedStatements = new ArrayList<>();\n+        speedStatements.addAll(verifyExpressions(new StringBuilder(), \"speed_factor_user_statements\", speedVariables,\n+                customModel.getSpeedFactor(), lookup,\n+                num -> \"speed *= \" + num + \";\\n\", \"\"));\n+        StringBuilder codeSB = new StringBuilder(\"boolean applied = false;\\n\");\n+        speedStatements.addAll(verifyExpressions(codeSB, \"max_speed_user_statements\",\n+                speedVariables, customModel.getMaxSpeed(), lookup,\n+                num -> \"applied = true; speed = Math.min(speed,\" + num + \");\",\n+                \"if (!applied && speed > \" + maxSpeedFallback + \") return \" + maxSpeedFallback + \";\\n\" +\n+                        \"return Math.min(speed, \" + globalMaxSpeed + \");\\n\"));\n+        String speedMethodStartBlock = \"double speed = super.getRawSpeed(edge, reverse);\\n\";\n+        // a bit inefficient to possibly define variables twice, but for now we have two separate methods\n+        for (String arg : speedVariables) {\n+            speedMethodStartBlock += getVariableDeclaration(lookup, arg);\n+        }\n+        speedStatements.addAll(0, new Parser(new org.codehaus.janino.Scanner(\"getSpeed\", new StringReader(speedMethodStartBlock))).\n+                parseBlockStatements());\n+        return speedStatements;\n+    }\n+\n+    /**\n+     * Parse the expressions from CustomModel relevant for the method getPriority - see createClassTemplate.\n+     *\n+     * @return the created statements (parsed expressions)\n+     */\n+    private static List<Java.BlockStatement> createGetPriorityStatements(Set<String> priorityVariables,\n+                                                                         CustomModel customModel, EncodedValueLookup lookup) throws Exception {\n+        List<Java.BlockStatement> priorityStatements = new ArrayList<>();\n+        priorityStatements.addAll(verifyExpressions(new StringBuilder(\"double value = 1;\\n\"), \"priority_user_statements\",\n+                priorityVariables, customModel.getPriority(), lookup,\n+                num -> \"value *= \" + num + \";\\n\", \"return value;\"));\n+        String priorityMethodStartBlock = \"\";\n+        for (String arg : priorityVariables) {\n+            priorityMethodStartBlock += getVariableDeclaration(lookup, arg);\n+        }\n+        priorityStatements.addAll(0, new Parser(new org.codehaus.janino.Scanner(\"getPriority\", new StringReader(priorityMethodStartBlock))).\n+                parseBlockStatements());\n+        return priorityStatements;\n+    }\n+\n+    static boolean isValidVariableName(String name) {\n+        return name.startsWith(AREA_PREFIX) || allowedNames.contains(name);\n+    }\n+\n+    /**\n+     * For the methods getSpeed and getPriority we declare variables that contain the encoded value of the current edge\n+     * or if an area contains the current edge.\n+     */\n+    private static String getVariableDeclaration(EncodedValueLookup lookup, String arg) {\n+        if (arg.startsWith(AREA_PREFIX)) {\n+            String id = arg.substring(AREA_PREFIX.length());\n+            return \"boolean \" + arg + \" = \" + CustomWeightingHelper.class.getSimpleName() + \".in(this.area_\" + id + \", edge);\\n\";\n+        } else if (lookup.hasEncodedValue(arg)) {\n+            check(arg);\n+            EncodedValue enc = lookup.getEncodedValue(arg, EncodedValue.class);\n+            return getReturnType(enc) + \" \" + arg + \" = reverse ? \" +\n+                    \"edge.getReverse((\" + getInterface(enc) + \") this.\" + arg + \"_enc) : \" +\n+                    \"edge.get((\" + getInterface(enc) + \") this.\" + arg + \"_enc);\\n\";\n+        } else if (isValidVariableName(arg)) {\n+            return \"\";\n+        } else {\n+            throw new IllegalArgumentException(\"Not supported \" + arg);\n+        }\n+    }\n+\n+    /**\n+     * @return the interface as string of the provided EncodedValue, e.g. IntEncodedValue (only interface) or BooleanEncodedValue (first interface)\n+     */\n+    private static String getInterface(EncodedValue enc) {\n+        if (enc.getClass().getInterfaces().length == 0) return enc.getClass().getSimpleName();\n+        return enc.getClass().getInterfaces()[0].getSimpleName();\n+    }\n+\n+    private static String getReturnType(EncodedValue encodedValue) {\n+        String name = encodedValue.getClass().getSimpleName();\n+        if (name.contains(\"Enum\")) return \"Enum\";\n+        if (name.contains(\"Decimal\")) return \"double\";\n+        if (name.contains(\"Int\")) return \"int\";\n+        if (name.contains(\"Boolean\")) return \"boolean\";\n+        throw new IllegalArgumentException(\"Unsupported EncodedValue \" + name);\n+    }\n+\n+    static void check(String encValue) {\n+        if(encValue.contains(\".\")) throw new IllegalArgumentException(\"encoded value with invalid name: \" + encValue);\n+    }\n+\n+    /**\n+     * Create the class source file from the detected variables (priorityVariables and speedVariables). We assume that\n+     * these variables are safe although they are user input because we collected them from parsing via Janino. This\n+     * means that the source file is free from user input and could be directly compiled. Before we do this we still\n+     * have to inject that parsed and safe user expressions in a later step.\n+     */\n+    private static String createClassTemplate(long counter, Set<String> priorityVariables, Set<String> speedVariables, EncodedValueLookup lookup) {\n+        final StringBuilder importSourceCode = new StringBuilder(\"import com.graphhopper.routing.ev.*;\\n\");\n+        importSourceCode.append(\"import java.util.Map;\\n\");\n+        final StringBuilder classSourceCode = new StringBuilder(100);\n+        boolean includedAreaImports = false;\n+\n+        final StringBuilder initSourceCode = new StringBuilder(\"this.avg_speed_enc = avgSpeedEnc;\\n\");\n+        Set<String> set = new HashSet<>(priorityVariables);\n+        set.addAll(speedVariables);\n+        for (String arg : set) {\n+            if (lookup.hasEncodedValue(arg)) {\n+                check(arg);\n+                EncodedValue enc = lookup.getEncodedValue(arg, EncodedValue.class);\n+                classSourceCode.append(\"protected \" + enc.getClass().getSimpleName() + \" \" + arg + \"_enc;\\n\");\n+                initSourceCode.append(\"if (lookup.hasEncodedValue(\\\"\" + arg + \"\\\")) \");\n+                initSourceCode.append(\"this.\" + arg + \"_enc = (\" + enc.getClass().getSimpleName()\n+                        + \") lookup.getEncodedValue(\\\"\" + arg + \"\\\", EncodedValue.class);\\n\");\n+            } else if (arg.startsWith(AREA_PREFIX)) {\n+                if (!includedAreaImports) {\n+                    importSourceCode.append(\"import \" + BBox.class.getName() + \";\\n\");\n+                    importSourceCode.append(\"import \" + GHUtility.class.getName() + \";\\n\");\n+                    importSourceCode.append(\"import \" + PreparedGeometryFactory.class.getName() + \";\\n\");\n+                    importSourceCode.append(\"import \" + JsonFeature.class.getName() + \";\\n\");\n+                    importSourceCode.append(\"import \" + Polygon.class.getName() + \";\\n\");\n+                    includedAreaImports = true;\n+                }\n+\n+                String id = arg.substring(AREA_PREFIX.length());\n+                String varName = \"area_\" + id;\n+                classSourceCode.append(\"protected \" + Polygon.class.getSimpleName() + \" \" + varName + \";\\n\");\n+                initSourceCode.append(\"JsonFeature feature = (JsonFeature) areas.get(\\\"\" + id + \"\\\");\\n\");\n+                initSourceCode.append(\"if(feature == null) throw new IllegalArgumentException(\\\"Area '\" + id + \"' wasn't found\\\");\\n\");\n+                initSourceCode.append(\"this.\" + varName + \" = new Polygon(new PreparedGeometryFactory().create(feature.getGeometry()));\\n\");\n+            } else {\n+                if (!isValidVariableName(arg))\n+                    throw new IllegalArgumentException(\"Variable not supported: \" + arg);\n+            }\n+        }\n+\n+        return \"\"\n+                + \"package com.graphhopper;\"\n+                + \"import \" + CustomWeightingHelper.class.getName() + \";\\n\"\n+                + \"import \" + EncodedValueLookup.class.getName() + \";\\n\"\n+                + \"import \" + EdgeIteratorState.class.getName() + \";\\n\"\n+                + importSourceCode\n+                + \"\\npublic class Test\" + counter + \" extends \" + CustomWeightingHelper.class.getSimpleName() + \" {\\n\"\n+                + classSourceCode\n+                + \"   @Override\\n\"\n+                + \"   public void init(EncodedValueLookup lookup, \"\n+                + DecimalEncodedValue.class.getName() + \" avgSpeedEnc, Map<String, com.graphhopper.json.geo.JsonFeature> areas) {\\n\"\n+                + initSourceCode\n+                + \"   }\\n\\n\"\n+                // we need these placeholder methods so that the hooks in DeepCopier are invoked\n+                + \"   @Override\\n\"\n+                + \"   public double getPriority(EdgeIteratorState edge, boolean reverse) {\\n\"\n+                + \"      return 1; //will be overwritten by code injected in DeepCopier\\n\"\n+                + \"   }\\n\"\n+                + \"   @Override\\n\"\n+                + \"   public double getSpeed(EdgeIteratorState edge, boolean reverse) {\\n\"\n+                + \"      return getRawSpeed(edge, reverse); //will be overwritten by code injected in DeepCopier\\n\"\n+                + \"   }\\n\"\n+                + \"}\";\n+    }\n+\n+    /**\n+     * This method does:\n+     * 1. check user expressions via Parser.parseConditionalExpression and only allow whitelisted variables and methods.\n+     * 2. while this check it also guesses the variable names and stores it in createObjects\n+     * 3. creates if-then-elseif expressions from the checks and returns them as BlockStatements\n+     *\n+     * @return the created if-then (and elseif) expressions\n+     */\n+    private static List<Java.BlockStatement> verifyExpressions(StringBuilder expressions, String info, Set<String> createObjects,\n+                                                               Map<String, Object> map, EncodedValueLookup lookup,\n+                                                               CodeBuilder codeBuilder, String lastStmt) throws Exception {\n+        // allow variables, all encoded values, constants\n+        ExpressionVisitor.NameValidator nameInConditionValidator = name -> lookup.hasEncodedValue(name)\n+                || name.toUpperCase(Locale.ROOT).equals(name) || isValidVariableName(name);\n+        ExpressionVisitor.parseExpressions(expressions, nameInConditionValidator, info, createObjects, map, codeBuilder, lastStmt, \"\");\n+        return new Parser(new org.codehaus.janino.Scanner(info, new StringReader(expressions.toString()))).\n+                parseBlockStatements();\n+    }\n+\n+    interface CodeBuilder {\n+        String create(Number n);\n+    }\n+\n+    /**\n+     * Injects the already parsed expressions (converted to BlockStatement) via janinos DeepCopier to the provided\n+     * CompilationUnit cu (a class file).\n+     */\n+    private static Java.CompilationUnit injectStatements(List<Java.BlockStatement> priorityStatements,\n+                                                         List<Java.BlockStatement> speedStatements,\n+                                                         Java.CompilationUnit cu) throws CompileException {\n+        cu = new DeepCopier() {\n+            @Override\n+            public Java.FieldDeclaration copyFieldDeclaration(Java.FieldDeclaration subject) throws CompileException {\n+                // for https://github.com/janino-compiler/janino/issues/135\n+                Java.FieldDeclaration fd = super.copyFieldDeclaration(subject);\n+                fd.setEnclosingScope(subject.getEnclosingScope());\n+                return fd;\n+            }\n+\n+            @Override\n+            public Java.MethodDeclarator copyMethodDeclarator(Java.MethodDeclarator subject) throws CompileException {\n+                if (subject.name.equals(\"getSpeed\") && !speedStatements.isEmpty()) {\n+                    return injectStatements(subject, this, speedStatements);\n+                } else if (subject.name.equals(\"getPriority\")) {\n+                    return injectStatements(subject, this, priorityStatements);\n+                } else {\n+                    return super.copyMethodDeclarator(subject);\n+                }\n+            }\n+        }.copyCompilationUnit(cu);\n+        return cu;\n+    }\n+\n+    private static Java.MethodDeclarator injectStatements(Java.MethodDeclarator subject, DeepCopier deepCopier,\n+                                                          List<Java.BlockStatement> statements) {\n+        try {\n+            if (statements.isEmpty())\n+                throw new IllegalArgumentException(\"Statements cannot be empty when copying method\");\n+            Java.MethodDeclarator methodDecl = new Java.MethodDeclarator(\n+                    new Location(\"m1\", 1, 1),\n+                    subject.getDocComment(),\n+                    deepCopier.copyModifiers(subject.getModifiers()),\n+                    deepCopier.copyOptionalTypeParameters(subject.typeParameters),\n+                    deepCopier.copyType(subject.type),\n+                    subject.name,\n+                    deepCopier.copyFormalParameters(subject.formalParameters),\n+                    deepCopier.copyTypes(subject.thrownExceptions),\n+                    deepCopier.copyOptionalElementValue(subject.defaultValue),\n+                    deepCopier.copyOptionalStatements(statements)\n+            );\n+            statements.forEach(st -> st.setEnclosingScope(methodDecl));\n+            statements.clear();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5cb073c89e7badcdb4e8aa42997f9b5a447e89ed"}, "originalPosition": 351}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTc3NTczOQ==", "bodyText": "It just makes sure the statements are not injected twice. But it is surely confusing. Will try something else.", "url": "https://github.com/graphhopper/graphhopper/pull/2209#discussion_r541775739", "createdAt": "2020-12-12T20:34:25Z", "author": {"login": "karussell"}, "path": "core/src/main/java/com/graphhopper/routing/weighting/custom/ExpressionBuilder.java", "diffHunk": "@@ -0,0 +1,382 @@\n+/*\n+ *  Licensed to GraphHopper GmbH under one or more contributor\n+ *  license agreements. See the NOTICE file distributed with this work for\n+ *  additional information regarding copyright ownership.\n+ *\n+ *  GraphHopper GmbH licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except in\n+ *  compliance with the License. You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package com.graphhopper.routing.weighting.custom;\n+\n+import com.graphhopper.json.geo.JsonFeature;\n+import com.graphhopper.routing.ev.DecimalEncodedValue;\n+import com.graphhopper.routing.ev.EncodedValue;\n+import com.graphhopper.routing.ev.EncodedValueLookup;\n+import com.graphhopper.routing.util.CustomModel;\n+import com.graphhopper.routing.util.EncodingManager;\n+import com.graphhopper.util.EdgeIteratorState;\n+import com.graphhopper.util.GHUtility;\n+import com.graphhopper.util.shapes.BBox;\n+import com.graphhopper.util.shapes.Polygon;\n+import org.codehaus.commons.compiler.CompileException;\n+import org.codehaus.commons.compiler.Location;\n+import org.codehaus.commons.compiler.io.Readers;\n+import org.codehaus.janino.Scanner;\n+import org.codehaus.janino.*;\n+import org.codehaus.janino.util.DeepCopier;\n+import org.locationtech.jts.geom.prep.PreparedGeometryFactory;\n+\n+import java.io.*;\n+import java.util.*;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+class ExpressionBuilder {\n+    private static final AtomicLong longVal = new AtomicLong(1);\n+    private static final String AREA_PREFIX = \"in_area_\";\n+    private static final Set<String> allowedNames = new HashSet<>(Arrays.asList(\"edge\", \"Math\"));\n+    private static final boolean JANINO_DEBUG = Boolean.getBoolean(Scanner.SYSTEM_PROPERTY_SOURCE_DEBUGGING_ENABLE);\n+\n+    // TODO without a cache we get X% slower routing and Y% slower routingLM8. CH requests and preparation is unaffected\n+    // as cached weighting from preparation is used. This cache ensures that the first Weighting classes, typically the\n+    // ones specified in the profiles, are never removed regardless of how frequent other Weightings are created and accessed.\n+    // We only need to synchronize the get and put methods alone. E.g. we do not care for the race condition where\n+    // two identical classes are requested and one of them is overwritten. We could use CachingJavaSourceClassLoader from\n+    // Janino but 1. we would need to use a single compiler across threads and 2. the statements (for priority and speed)\n+    // are still unnecessarily created.\n+    private static final int CACHE_SIZE = Integer.getInteger(\"graphhopper.custom_weighting.cache_size\", 10);\n+    // TODO perf compare with ConcurrentHashMap, but I guess, if there is a difference at all, it is not big for small maps\n+    private static final Map<String, Class> CACHE = Collections.synchronizedMap(new HashMap<>(CACHE_SIZE));\n+\n+    // Introduce a dynamic cache to remember different Weighting classes, but throw away less frequently used classes.\n+    // Use accessOrder==true to remove oldest accessed entry, not oldest inserted.\n+    private static final int DYN_CACHE_SIZE = Integer.getInteger(\"graphhopper.custom_weighting.dynamic_cache_size\", 1000);\n+    private static final Map<String, Class> DYN_CACHE = Collections.synchronizedMap(\n+            new LinkedHashMap<String, Class>(DYN_CACHE_SIZE, 0.75f, true) {\n+                protected boolean removeEldestEntry(Map.Entry eldest) {\n+                    return size() > DYN_CACHE_SIZE;\n+                }\n+            });\n+\n+    /**\n+     * This method compiles a new subclass of CustomWeightingHelper composed from the provided CustomModel caches this\n+     * and returns an instance.\n+     */\n+    static CustomWeightingHelper create(CustomModel customModel, EncodedValueLookup lookup,\n+                                        double globalMaxSpeed, double maxSpeedFallback, DecimalEncodedValue avgSpeedEnc) {\n+        Java.CompilationUnit cu;\n+        try {\n+            String key = customModel.toString() + \",global:\" + globalMaxSpeed + \",fallback:\" + maxSpeedFallback;\n+            if (key.length() > 400_000) throw new IllegalArgumentException(\"Custom Model too big: \" + key.length());\n+\n+            Class clazz = CACHE.get(key);\n+            if (DYN_CACHE_SIZE > 0 && clazz == null)\n+                clazz = DYN_CACHE.get(key);\n+            if (clazz == null) {\n+                HashSet<String> priorityVariables = new LinkedHashSet<>();\n+                List<Java.BlockStatement> priorityStatements = createGetPriorityStatements(priorityVariables, customModel, lookup);\n+                HashSet<String> speedVariables = new LinkedHashSet<>();\n+                List<Java.BlockStatement> speedStatements = createGetSpeedStatements(speedVariables, customModel, lookup, globalMaxSpeed, maxSpeedFallback);\n+                // Create different class name, which is required only for debugging.\n+                // TODO does it improve performance too? I.e. it could be that the JIT is confused if different classes\n+                //  have the same name and it mixes performance stats. See https://github.com/janino-compiler/janino/issues/137\n+                long counter = longVal.incrementAndGet();\n+                String classTemplate = createClassTemplate(counter, priorityVariables, speedVariables, lookup);\n+                cu = (Java.CompilationUnit) new Parser(new org.codehaus.janino.Scanner(\"source\", new StringReader(classTemplate))).\n+                        parseAbstractCompilationUnit();\n+                cu = injectStatements(priorityStatements, speedStatements, cu);\n+                SimpleCompiler sc = createCompiler(counter, cu);\n+                clazz = sc.getClassLoader().loadClass(\"com.graphhopper.Test\" + counter);\n+                if (CACHE.size() < CACHE_SIZE)\n+                    CACHE.put(key, clazz);\n+                else if (DYN_CACHE_SIZE > 0)\n+                    DYN_CACHE.put(key, clazz);\n+            }\n+\n+            // The class does not need to be thread-safe as we create an instance per request\n+            CustomWeightingHelper prio = (CustomWeightingHelper) clazz.getDeclaredConstructor().newInstance();\n+            prio.init(lookup, avgSpeedEnc, customModel.getAreas());\n+            return prio;\n+        } catch (Exception ex) {\n+            String location = \"\";\n+            if (ex instanceof CompileException)\n+                location = \" in \" + ((CompileException) ex).getLocation().getFileName();\n+            throw new IllegalArgumentException(\"Cannot compile expression \" + location + \", \" + ex.getMessage(), ex);\n+        }\n+    }\n+\n+    /**\n+     * Parse the expressions from CustomModel relevant for the method getSpeed - see createClassTemplate.\n+     *\n+     * @return the created statements (parsed expressions)\n+     */\n+    private static List<Java.BlockStatement> createGetSpeedStatements(Set<String> speedVariables,\n+                                                                      CustomModel customModel, EncodedValueLookup lookup,\n+                                                                      double globalMaxSpeed, double maxSpeedFallback) throws Exception {\n+        List<Java.BlockStatement> speedStatements = new ArrayList<>();\n+        speedStatements.addAll(verifyExpressions(new StringBuilder(), \"speed_factor_user_statements\", speedVariables,\n+                customModel.getSpeedFactor(), lookup,\n+                num -> \"speed *= \" + num + \";\\n\", \"\"));\n+        StringBuilder codeSB = new StringBuilder(\"boolean applied = false;\\n\");\n+        speedStatements.addAll(verifyExpressions(codeSB, \"max_speed_user_statements\",\n+                speedVariables, customModel.getMaxSpeed(), lookup,\n+                num -> \"applied = true; speed = Math.min(speed,\" + num + \");\",\n+                \"if (!applied && speed > \" + maxSpeedFallback + \") return \" + maxSpeedFallback + \";\\n\" +\n+                        \"return Math.min(speed, \" + globalMaxSpeed + \");\\n\"));\n+        String speedMethodStartBlock = \"double speed = super.getRawSpeed(edge, reverse);\\n\";\n+        // a bit inefficient to possibly define variables twice, but for now we have two separate methods\n+        for (String arg : speedVariables) {\n+            speedMethodStartBlock += getVariableDeclaration(lookup, arg);\n+        }\n+        speedStatements.addAll(0, new Parser(new org.codehaus.janino.Scanner(\"getSpeed\", new StringReader(speedMethodStartBlock))).\n+                parseBlockStatements());\n+        return speedStatements;\n+    }\n+\n+    /**\n+     * Parse the expressions from CustomModel relevant for the method getPriority - see createClassTemplate.\n+     *\n+     * @return the created statements (parsed expressions)\n+     */\n+    private static List<Java.BlockStatement> createGetPriorityStatements(Set<String> priorityVariables,\n+                                                                         CustomModel customModel, EncodedValueLookup lookup) throws Exception {\n+        List<Java.BlockStatement> priorityStatements = new ArrayList<>();\n+        priorityStatements.addAll(verifyExpressions(new StringBuilder(\"double value = 1;\\n\"), \"priority_user_statements\",\n+                priorityVariables, customModel.getPriority(), lookup,\n+                num -> \"value *= \" + num + \";\\n\", \"return value;\"));\n+        String priorityMethodStartBlock = \"\";\n+        for (String arg : priorityVariables) {\n+            priorityMethodStartBlock += getVariableDeclaration(lookup, arg);\n+        }\n+        priorityStatements.addAll(0, new Parser(new org.codehaus.janino.Scanner(\"getPriority\", new StringReader(priorityMethodStartBlock))).\n+                parseBlockStatements());\n+        return priorityStatements;\n+    }\n+\n+    static boolean isValidVariableName(String name) {\n+        return name.startsWith(AREA_PREFIX) || allowedNames.contains(name);\n+    }\n+\n+    /**\n+     * For the methods getSpeed and getPriority we declare variables that contain the encoded value of the current edge\n+     * or if an area contains the current edge.\n+     */\n+    private static String getVariableDeclaration(EncodedValueLookup lookup, String arg) {\n+        if (arg.startsWith(AREA_PREFIX)) {\n+            String id = arg.substring(AREA_PREFIX.length());\n+            return \"boolean \" + arg + \" = \" + CustomWeightingHelper.class.getSimpleName() + \".in(this.area_\" + id + \", edge);\\n\";\n+        } else if (lookup.hasEncodedValue(arg)) {\n+            check(arg);\n+            EncodedValue enc = lookup.getEncodedValue(arg, EncodedValue.class);\n+            return getReturnType(enc) + \" \" + arg + \" = reverse ? \" +\n+                    \"edge.getReverse((\" + getInterface(enc) + \") this.\" + arg + \"_enc) : \" +\n+                    \"edge.get((\" + getInterface(enc) + \") this.\" + arg + \"_enc);\\n\";\n+        } else if (isValidVariableName(arg)) {\n+            return \"\";\n+        } else {\n+            throw new IllegalArgumentException(\"Not supported \" + arg);\n+        }\n+    }\n+\n+    /**\n+     * @return the interface as string of the provided EncodedValue, e.g. IntEncodedValue (only interface) or BooleanEncodedValue (first interface)\n+     */\n+    private static String getInterface(EncodedValue enc) {\n+        if (enc.getClass().getInterfaces().length == 0) return enc.getClass().getSimpleName();\n+        return enc.getClass().getInterfaces()[0].getSimpleName();\n+    }\n+\n+    private static String getReturnType(EncodedValue encodedValue) {\n+        String name = encodedValue.getClass().getSimpleName();\n+        if (name.contains(\"Enum\")) return \"Enum\";\n+        if (name.contains(\"Decimal\")) return \"double\";\n+        if (name.contains(\"Int\")) return \"int\";\n+        if (name.contains(\"Boolean\")) return \"boolean\";\n+        throw new IllegalArgumentException(\"Unsupported EncodedValue \" + name);\n+    }\n+\n+    static void check(String encValue) {\n+        if(encValue.contains(\".\")) throw new IllegalArgumentException(\"encoded value with invalid name: \" + encValue);\n+    }\n+\n+    /**\n+     * Create the class source file from the detected variables (priorityVariables and speedVariables). We assume that\n+     * these variables are safe although they are user input because we collected them from parsing via Janino. This\n+     * means that the source file is free from user input and could be directly compiled. Before we do this we still\n+     * have to inject that parsed and safe user expressions in a later step.\n+     */\n+    private static String createClassTemplate(long counter, Set<String> priorityVariables, Set<String> speedVariables, EncodedValueLookup lookup) {\n+        final StringBuilder importSourceCode = new StringBuilder(\"import com.graphhopper.routing.ev.*;\\n\");\n+        importSourceCode.append(\"import java.util.Map;\\n\");\n+        final StringBuilder classSourceCode = new StringBuilder(100);\n+        boolean includedAreaImports = false;\n+\n+        final StringBuilder initSourceCode = new StringBuilder(\"this.avg_speed_enc = avgSpeedEnc;\\n\");\n+        Set<String> set = new HashSet<>(priorityVariables);\n+        set.addAll(speedVariables);\n+        for (String arg : set) {\n+            if (lookup.hasEncodedValue(arg)) {\n+                check(arg);\n+                EncodedValue enc = lookup.getEncodedValue(arg, EncodedValue.class);\n+                classSourceCode.append(\"protected \" + enc.getClass().getSimpleName() + \" \" + arg + \"_enc;\\n\");\n+                initSourceCode.append(\"if (lookup.hasEncodedValue(\\\"\" + arg + \"\\\")) \");\n+                initSourceCode.append(\"this.\" + arg + \"_enc = (\" + enc.getClass().getSimpleName()\n+                        + \") lookup.getEncodedValue(\\\"\" + arg + \"\\\", EncodedValue.class);\\n\");\n+            } else if (arg.startsWith(AREA_PREFIX)) {\n+                if (!includedAreaImports) {\n+                    importSourceCode.append(\"import \" + BBox.class.getName() + \";\\n\");\n+                    importSourceCode.append(\"import \" + GHUtility.class.getName() + \";\\n\");\n+                    importSourceCode.append(\"import \" + PreparedGeometryFactory.class.getName() + \";\\n\");\n+                    importSourceCode.append(\"import \" + JsonFeature.class.getName() + \";\\n\");\n+                    importSourceCode.append(\"import \" + Polygon.class.getName() + \";\\n\");\n+                    includedAreaImports = true;\n+                }\n+\n+                String id = arg.substring(AREA_PREFIX.length());\n+                String varName = \"area_\" + id;\n+                classSourceCode.append(\"protected \" + Polygon.class.getSimpleName() + \" \" + varName + \";\\n\");\n+                initSourceCode.append(\"JsonFeature feature = (JsonFeature) areas.get(\\\"\" + id + \"\\\");\\n\");\n+                initSourceCode.append(\"if(feature == null) throw new IllegalArgumentException(\\\"Area '\" + id + \"' wasn't found\\\");\\n\");\n+                initSourceCode.append(\"this.\" + varName + \" = new Polygon(new PreparedGeometryFactory().create(feature.getGeometry()));\\n\");\n+            } else {\n+                if (!isValidVariableName(arg))\n+                    throw new IllegalArgumentException(\"Variable not supported: \" + arg);\n+            }\n+        }\n+\n+        return \"\"\n+                + \"package com.graphhopper;\"\n+                + \"import \" + CustomWeightingHelper.class.getName() + \";\\n\"\n+                + \"import \" + EncodedValueLookup.class.getName() + \";\\n\"\n+                + \"import \" + EdgeIteratorState.class.getName() + \";\\n\"\n+                + importSourceCode\n+                + \"\\npublic class Test\" + counter + \" extends \" + CustomWeightingHelper.class.getSimpleName() + \" {\\n\"\n+                + classSourceCode\n+                + \"   @Override\\n\"\n+                + \"   public void init(EncodedValueLookup lookup, \"\n+                + DecimalEncodedValue.class.getName() + \" avgSpeedEnc, Map<String, com.graphhopper.json.geo.JsonFeature> areas) {\\n\"\n+                + initSourceCode\n+                + \"   }\\n\\n\"\n+                // we need these placeholder methods so that the hooks in DeepCopier are invoked\n+                + \"   @Override\\n\"\n+                + \"   public double getPriority(EdgeIteratorState edge, boolean reverse) {\\n\"\n+                + \"      return 1; //will be overwritten by code injected in DeepCopier\\n\"\n+                + \"   }\\n\"\n+                + \"   @Override\\n\"\n+                + \"   public double getSpeed(EdgeIteratorState edge, boolean reverse) {\\n\"\n+                + \"      return getRawSpeed(edge, reverse); //will be overwritten by code injected in DeepCopier\\n\"\n+                + \"   }\\n\"\n+                + \"}\";\n+    }\n+\n+    /**\n+     * This method does:\n+     * 1. check user expressions via Parser.parseConditionalExpression and only allow whitelisted variables and methods.\n+     * 2. while this check it also guesses the variable names and stores it in createObjects\n+     * 3. creates if-then-elseif expressions from the checks and returns them as BlockStatements\n+     *\n+     * @return the created if-then (and elseif) expressions\n+     */\n+    private static List<Java.BlockStatement> verifyExpressions(StringBuilder expressions, String info, Set<String> createObjects,\n+                                                               Map<String, Object> map, EncodedValueLookup lookup,\n+                                                               CodeBuilder codeBuilder, String lastStmt) throws Exception {\n+        // allow variables, all encoded values, constants\n+        ExpressionVisitor.NameValidator nameInConditionValidator = name -> lookup.hasEncodedValue(name)\n+                || name.toUpperCase(Locale.ROOT).equals(name) || isValidVariableName(name);\n+        ExpressionVisitor.parseExpressions(expressions, nameInConditionValidator, info, createObjects, map, codeBuilder, lastStmt, \"\");\n+        return new Parser(new org.codehaus.janino.Scanner(info, new StringReader(expressions.toString()))).\n+                parseBlockStatements();\n+    }\n+\n+    interface CodeBuilder {\n+        String create(Number n);\n+    }\n+\n+    /**\n+     * Injects the already parsed expressions (converted to BlockStatement) via janinos DeepCopier to the provided\n+     * CompilationUnit cu (a class file).\n+     */\n+    private static Java.CompilationUnit injectStatements(List<Java.BlockStatement> priorityStatements,\n+                                                         List<Java.BlockStatement> speedStatements,\n+                                                         Java.CompilationUnit cu) throws CompileException {\n+        cu = new DeepCopier() {\n+            @Override\n+            public Java.FieldDeclaration copyFieldDeclaration(Java.FieldDeclaration subject) throws CompileException {\n+                // for https://github.com/janino-compiler/janino/issues/135\n+                Java.FieldDeclaration fd = super.copyFieldDeclaration(subject);\n+                fd.setEnclosingScope(subject.getEnclosingScope());\n+                return fd;\n+            }\n+\n+            @Override\n+            public Java.MethodDeclarator copyMethodDeclarator(Java.MethodDeclarator subject) throws CompileException {\n+                if (subject.name.equals(\"getSpeed\") && !speedStatements.isEmpty()) {\n+                    return injectStatements(subject, this, speedStatements);\n+                } else if (subject.name.equals(\"getPriority\")) {\n+                    return injectStatements(subject, this, priorityStatements);\n+                } else {\n+                    return super.copyMethodDeclarator(subject);\n+                }\n+            }\n+        }.copyCompilationUnit(cu);\n+        return cu;\n+    }\n+\n+    private static Java.MethodDeclarator injectStatements(Java.MethodDeclarator subject, DeepCopier deepCopier,\n+                                                          List<Java.BlockStatement> statements) {\n+        try {\n+            if (statements.isEmpty())\n+                throw new IllegalArgumentException(\"Statements cannot be empty when copying method\");\n+            Java.MethodDeclarator methodDecl = new Java.MethodDeclarator(\n+                    new Location(\"m1\", 1, 1),\n+                    subject.getDocComment(),\n+                    deepCopier.copyModifiers(subject.getModifiers()),\n+                    deepCopier.copyOptionalTypeParameters(subject.typeParameters),\n+                    deepCopier.copyType(subject.type),\n+                    subject.name,\n+                    deepCopier.copyFormalParameters(subject.formalParameters),\n+                    deepCopier.copyTypes(subject.thrownExceptions),\n+                    deepCopier.copyOptionalElementValue(subject.defaultValue),\n+                    deepCopier.copyOptionalStatements(statements)\n+            );\n+            statements.forEach(st -> st.setEnclosingScope(methodDecl));\n+            statements.clear();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDg2NzMzNA=="}, "originalCommit": {"oid": "5cb073c89e7badcdb4e8aa42997f9b5a447e89ed"}, "originalPosition": 351}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM5ODUyMTE1OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/com/graphhopper/routing/weighting/custom/CustomWeighting.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMVQxODoyMDoyOVrOIEEhbQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xM1QwODo1MzowMlrOIExubA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTEzOTMwOQ==", "bodyText": "I think this is wrong. Look at this (failing) test in CustomWeightingTest:\n    @Test\n    public void testMaxSpeedFallBack() {\n        assertEquals(140, carFE.getMaxSpeed(), 0.1);\n        String message = assertThrows(IllegalArgumentException.class, () -> createWeighting(new CustomModel().setMaxSpeedFallback(150.)))\n                .getMessage();\n        assertTrue(message.contains(\"max_speed_fallback cannot be bigger than max_speed 140\"));\n        assertEquals(50+30, createWeighting(new CustomModel().setMaxSpeedFallback(72.).setDistanceInfluence(30)).getMinWeight(1000));\n    }\nIt should be something like this instead:\n   if (customModel.getMaxSpeedFallback() != null && customModel.getMaxSpeedFallback() > baseFlagEncoder.getMaxSpeed())\n            throw new IllegalArgumentException(\"max_speed_fallback cannot be bigger than max_speed \" + baseFlagEncoder.getMaxSpeed());\n        double maxSpeedTmp = customModel.getMaxSpeedFallback() == null ? baseFlagEncoder.getMaxSpeed() : customModel.getMaxSpeedFallback();", "url": "https://github.com/graphhopper/graphhopper/pull/2209#discussion_r541139309", "createdAt": "2020-12-11T18:20:29Z", "author": {"login": "easbar"}, "path": "core/src/main/java/com/graphhopper/routing/weighting/custom/CustomWeighting.java", "diffHunk": "@@ -86,26 +86,40 @@\n     private final double maxSpeed;\n     private final double distanceInfluence;\n     private final double headingPenaltySeconds;\n-    private final SpeedCalculator speedCalculator;\n-    private final PriorityCalculator priorityCalculator;\n+    private final CustomWeightingHelper cwHelper;\n \n-    public CustomWeighting(FlagEncoder baseFlagEncoder, EncodedValueLookup lookup,\n-                           TurnCostProvider turnCostProvider, CustomModel customModel) {\n+    public CustomWeighting(FlagEncoder baseFlagEncoder, EncodedValueLookup lookup, TurnCostProvider turnCostProvider,\n+                           CustomModel customModel) {\n         super(baseFlagEncoder, turnCostProvider);\n         if (customModel == null)\n             throw new IllegalStateException(\"CustomModel cannot be null\");\n \n         headingPenaltySeconds = customModel.getHeadingPenalty();\n         baseVehicleAccessEnc = baseFlagEncoder.getAccessEnc();\n-        speedCalculator = new SpeedCalculator(baseFlagEncoder.getMaxSpeed(), customModel, baseFlagEncoder.getAverageSpeedEnc(), lookup);\n-        maxSpeed = speedCalculator.getMaxSpeed() / SPEED_CONV;\n+        double maxSpeedTmp = customModel.getMaxSpeedFallback() == null ? baseFlagEncoder.getMaxSpeed() : customModel.getMaxSpeedFallback();\n+        if (customModel.getMaxSpeedFallback() != null && customModel.getMaxSpeedFallback() > maxSpeedTmp)\n+            throw new IllegalArgumentException(\"max_speed_fallback cannot be bigger than max_speed \" + maxSpeedTmp);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5cb073c89e7badcdb4e8aa42997f9b5a447e89ed"}, "originalPosition": 42}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTY5ODA4MQ==", "bodyText": "Ups, indeed.", "url": "https://github.com/graphhopper/graphhopper/pull/2209#discussion_r541698081", "createdAt": "2020-12-12T18:01:50Z", "author": {"login": "karussell"}, "path": "core/src/main/java/com/graphhopper/routing/weighting/custom/CustomWeighting.java", "diffHunk": "@@ -86,26 +86,40 @@\n     private final double maxSpeed;\n     private final double distanceInfluence;\n     private final double headingPenaltySeconds;\n-    private final SpeedCalculator speedCalculator;\n-    private final PriorityCalculator priorityCalculator;\n+    private final CustomWeightingHelper cwHelper;\n \n-    public CustomWeighting(FlagEncoder baseFlagEncoder, EncodedValueLookup lookup,\n-                           TurnCostProvider turnCostProvider, CustomModel customModel) {\n+    public CustomWeighting(FlagEncoder baseFlagEncoder, EncodedValueLookup lookup, TurnCostProvider turnCostProvider,\n+                           CustomModel customModel) {\n         super(baseFlagEncoder, turnCostProvider);\n         if (customModel == null)\n             throw new IllegalStateException(\"CustomModel cannot be null\");\n \n         headingPenaltySeconds = customModel.getHeadingPenalty();\n         baseVehicleAccessEnc = baseFlagEncoder.getAccessEnc();\n-        speedCalculator = new SpeedCalculator(baseFlagEncoder.getMaxSpeed(), customModel, baseFlagEncoder.getAverageSpeedEnc(), lookup);\n-        maxSpeed = speedCalculator.getMaxSpeed() / SPEED_CONV;\n+        double maxSpeedTmp = customModel.getMaxSpeedFallback() == null ? baseFlagEncoder.getMaxSpeed() : customModel.getMaxSpeedFallback();\n+        if (customModel.getMaxSpeedFallback() != null && customModel.getMaxSpeedFallback() > maxSpeedTmp)\n+            throw new IllegalArgumentException(\"max_speed_fallback cannot be bigger than max_speed \" + maxSpeedTmp);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTEzOTMwOQ=="}, "originalCommit": {"oid": "5cb073c89e7badcdb4e8aa42997f9b5a447e89ed"}, "originalPosition": 42}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTg3OTkxNg==", "bodyText": "Fixed", "url": "https://github.com/graphhopper/graphhopper/pull/2209#discussion_r541879916", "createdAt": "2020-12-13T08:53:02Z", "author": {"login": "easbar"}, "path": "core/src/main/java/com/graphhopper/routing/weighting/custom/CustomWeighting.java", "diffHunk": "@@ -86,26 +86,40 @@\n     private final double maxSpeed;\n     private final double distanceInfluence;\n     private final double headingPenaltySeconds;\n-    private final SpeedCalculator speedCalculator;\n-    private final PriorityCalculator priorityCalculator;\n+    private final CustomWeightingHelper cwHelper;\n \n-    public CustomWeighting(FlagEncoder baseFlagEncoder, EncodedValueLookup lookup,\n-                           TurnCostProvider turnCostProvider, CustomModel customModel) {\n+    public CustomWeighting(FlagEncoder baseFlagEncoder, EncodedValueLookup lookup, TurnCostProvider turnCostProvider,\n+                           CustomModel customModel) {\n         super(baseFlagEncoder, turnCostProvider);\n         if (customModel == null)\n             throw new IllegalStateException(\"CustomModel cannot be null\");\n \n         headingPenaltySeconds = customModel.getHeadingPenalty();\n         baseVehicleAccessEnc = baseFlagEncoder.getAccessEnc();\n-        speedCalculator = new SpeedCalculator(baseFlagEncoder.getMaxSpeed(), customModel, baseFlagEncoder.getAverageSpeedEnc(), lookup);\n-        maxSpeed = speedCalculator.getMaxSpeed() / SPEED_CONV;\n+        double maxSpeedTmp = customModel.getMaxSpeedFallback() == null ? baseFlagEncoder.getMaxSpeed() : customModel.getMaxSpeedFallback();\n+        if (customModel.getMaxSpeedFallback() != null && customModel.getMaxSpeedFallback() > maxSpeedTmp)\n+            throw new IllegalArgumentException(\"max_speed_fallback cannot be bigger than max_speed \" + maxSpeedTmp);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTEzOTMwOQ=="}, "originalCommit": {"oid": "5cb073c89e7badcdb4e8aa42997f9b5a447e89ed"}, "originalPosition": 42}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM5ODU0MzUwOnYy", "diffSide": "RIGHT", "path": "core/src/main/java/com/graphhopper/routing/weighting/custom/CustomWeighting.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMVQxODoyNjowOVrOIEEubg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMVQxODoyNjowOVrOIEEubg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTE0MjYzOA==", "bodyText": "This constructor is unused so maybe we can remove it. If not we should add a test that uses it and also chain the two constructors if possible. But I like the idea of CustomWeighting not being directly coupled to CustomModel and maybe we should turn CustomWeightingHelper into an interface (call it SpeedAndPriorityProvider for example) and remove the other constructor instead. In this case we would use some helper method to create the speed/priority provider from a custom model, but otherwise CustomWeighting would not depend on it.", "url": "https://github.com/graphhopper/graphhopper/pull/2209#discussion_r541142638", "createdAt": "2020-12-11T18:26:09Z", "author": {"login": "easbar"}, "path": "core/src/main/java/com/graphhopper/routing/weighting/custom/CustomWeighting.java", "diffHunk": "@@ -86,26 +86,40 @@\n     private final double maxSpeed;\n     private final double distanceInfluence;\n     private final double headingPenaltySeconds;\n-    private final SpeedCalculator speedCalculator;\n-    private final PriorityCalculator priorityCalculator;\n+    private final CustomWeightingHelper cwHelper;\n \n-    public CustomWeighting(FlagEncoder baseFlagEncoder, EncodedValueLookup lookup,\n-                           TurnCostProvider turnCostProvider, CustomModel customModel) {\n+    public CustomWeighting(FlagEncoder baseFlagEncoder, EncodedValueLookup lookup, TurnCostProvider turnCostProvider,\n+                           CustomModel customModel) {\n         super(baseFlagEncoder, turnCostProvider);\n         if (customModel == null)\n             throw new IllegalStateException(\"CustomModel cannot be null\");\n \n         headingPenaltySeconds = customModel.getHeadingPenalty();\n         baseVehicleAccessEnc = baseFlagEncoder.getAccessEnc();\n-        speedCalculator = new SpeedCalculator(baseFlagEncoder.getMaxSpeed(), customModel, baseFlagEncoder.getAverageSpeedEnc(), lookup);\n-        maxSpeed = speedCalculator.getMaxSpeed() / SPEED_CONV;\n+        double maxSpeedTmp = customModel.getMaxSpeedFallback() == null ? baseFlagEncoder.getMaxSpeed() : customModel.getMaxSpeedFallback();\n+        if (customModel.getMaxSpeedFallback() != null && customModel.getMaxSpeedFallback() > maxSpeedTmp)\n+            throw new IllegalArgumentException(\"max_speed_fallback cannot be bigger than max_speed \" + maxSpeedTmp);\n+        cwHelper = ExpressionBuilder.create(customModel, lookup, baseFlagEncoder.getMaxSpeed(), maxSpeedTmp, baseFlagEncoder.getAverageSpeedEnc());\n+        maxSpeed = maxSpeedTmp / SPEED_CONV;\n \n-        priorityCalculator = new PriorityCalculator(customModel, lookup);\n+        // given unit is s/km -> convert to s/m\n+        this.distanceInfluence = customModel.getDistanceInfluence() / 1000.0;\n+        if (this.distanceInfluence < 0)\n+            throw new IllegalArgumentException(\"maximum distance_influence cannot be negative \" + this.distanceInfluence);\n+    }\n+\n+    public CustomWeighting(FlagEncoder baseFlagEncoder, TurnCostProvider turnCostProvider, CustomWeightingHelper cwHelper,\n+                           double maxSpeed, double distanceInfluence, double headingPenaltySeconds) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5cb073c89e7badcdb4e8aa42997f9b5a447e89ed"}, "originalPosition": 54}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM5ODU1NjI3OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/com/graphhopper/routing/weighting/custom/CustomWeightingHelper.java", "isResolved": true, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMVQxODoyOToyMlrOIEE10g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xM1QxMjozOTo1MVrOIE0BDQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTE0NDUzMA==", "bodyText": "Hm not sure about this class really. It should probably be an interface (see my other comment). Its really not clear how to use it. For example how is one supposed to know init needs to be called and avg_speed_enc is null otherwise (NPE in getRawSpeed)? lookup is not used at all. The static in method seems very unrelated and can probably go to GHUtilities?", "url": "https://github.com/graphhopper/graphhopper/pull/2209#discussion_r541144530", "createdAt": "2020-12-11T18:29:22Z", "author": {"login": "easbar"}, "path": "core/src/main/java/com/graphhopper/routing/weighting/custom/CustomWeightingHelper.java", "diffHunk": "@@ -0,0 +1,65 @@\n+/*\n+ *  Licensed to GraphHopper GmbH under one or more contributor\n+ *  license agreements. See the NOTICE file distributed with this work for\n+ *  additional information regarding copyright ownership.\n+ *\n+ *  GraphHopper GmbH licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except in\n+ *  compliance with the License. You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package com.graphhopper.routing.weighting.custom;\n+\n+import com.graphhopper.json.geo.JsonFeature;\n+import com.graphhopper.routing.ev.DecimalEncodedValue;\n+import com.graphhopper.routing.ev.EncodedValueLookup;\n+import com.graphhopper.util.EdgeIteratorState;\n+import com.graphhopper.util.FetchMode;\n+import com.graphhopper.util.GHUtility;\n+import com.graphhopper.util.shapes.BBox;\n+import com.graphhopper.util.shapes.Polygon;\n+\n+import java.util.Map;\n+\n+/**\n+ * This class makes it easy to control priority and speed for the CustomWeighting.\n+ */\n+public class CustomWeightingHelper {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5cb073c89e7badcdb4e8aa42997f9b5a447e89ed"}, "originalPosition": 34}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTE2ODc1MA==", "bodyText": "Ah ok the default constructor + init method is probably required to create an instance via reflection in ExpressionBuilder? But to me this sounds like just another reason to have some kind of SpeedAndPriorityProvider interface in CustomWeighting and encapsulate the ugly part of creating such a thing from a custom model. I mean CustomWeighting should not be coupled to this ugly part? One goal would be to be able to test CustomModel->janino->SpeedAndPriortyProvider independently from SpeedAndPriorityProvider->CustomWeighting->calcWeight.", "url": "https://github.com/graphhopper/graphhopper/pull/2209#discussion_r541168750", "createdAt": "2020-12-11T19:04:59Z", "author": {"login": "easbar"}, "path": "core/src/main/java/com/graphhopper/routing/weighting/custom/CustomWeightingHelper.java", "diffHunk": "@@ -0,0 +1,65 @@\n+/*\n+ *  Licensed to GraphHopper GmbH under one or more contributor\n+ *  license agreements. See the NOTICE file distributed with this work for\n+ *  additional information regarding copyright ownership.\n+ *\n+ *  GraphHopper GmbH licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except in\n+ *  compliance with the License. You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package com.graphhopper.routing.weighting.custom;\n+\n+import com.graphhopper.json.geo.JsonFeature;\n+import com.graphhopper.routing.ev.DecimalEncodedValue;\n+import com.graphhopper.routing.ev.EncodedValueLookup;\n+import com.graphhopper.util.EdgeIteratorState;\n+import com.graphhopper.util.FetchMode;\n+import com.graphhopper.util.GHUtility;\n+import com.graphhopper.util.shapes.BBox;\n+import com.graphhopper.util.shapes.Polygon;\n+\n+import java.util.Map;\n+\n+/**\n+ * This class makes it easy to control priority and speed for the CustomWeighting.\n+ */\n+public class CustomWeightingHelper {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTE0NDUzMA=="}, "originalCommit": {"oid": "5cb073c89e7badcdb4e8aa42997f9b5a447e89ed"}, "originalPosition": 34}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTY5Nzk1Ng==", "bodyText": "I can try to make it private or protected and see if Janino can work with it. It should not be used from outside - only for internal purposes.\n\nThe static in method seems very unrelated and can probably go to GHUtilities?\n\nIMO it could make sense to have all methods that we allow for scripting there directly instead of GHUtilities?\n\nAh ok the default constructor + init method is probably required to create an instance via reflection in ExpressionBuilder?\n\nYes, I was just too lazy too look how to call the correct constructor and used the explicit init method.\n\nOne goal would be to be able to test\n\nNot sure if this is necessary. What purpose would this have?", "url": "https://github.com/graphhopper/graphhopper/pull/2209#discussion_r541697956", "createdAt": "2020-12-12T18:01:29Z", "author": {"login": "karussell"}, "path": "core/src/main/java/com/graphhopper/routing/weighting/custom/CustomWeightingHelper.java", "diffHunk": "@@ -0,0 +1,65 @@\n+/*\n+ *  Licensed to GraphHopper GmbH under one or more contributor\n+ *  license agreements. See the NOTICE file distributed with this work for\n+ *  additional information regarding copyright ownership.\n+ *\n+ *  GraphHopper GmbH licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except in\n+ *  compliance with the License. You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package com.graphhopper.routing.weighting.custom;\n+\n+import com.graphhopper.json.geo.JsonFeature;\n+import com.graphhopper.routing.ev.DecimalEncodedValue;\n+import com.graphhopper.routing.ev.EncodedValueLookup;\n+import com.graphhopper.util.EdgeIteratorState;\n+import com.graphhopper.util.FetchMode;\n+import com.graphhopper.util.GHUtility;\n+import com.graphhopper.util.shapes.BBox;\n+import com.graphhopper.util.shapes.Polygon;\n+\n+import java.util.Map;\n+\n+/**\n+ * This class makes it easy to control priority and speed for the CustomWeighting.\n+ */\n+public class CustomWeightingHelper {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTE0NDUzMA=="}, "originalCommit": {"oid": "5cb073c89e7badcdb4e8aa42997f9b5a447e89ed"}, "originalPosition": 34}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTg5OTg0Ng==", "bodyText": "IMO it could make sense to have all methods that we allow for scripting there directly instead of GHUtilities?\n\nYes if its specific to custom model scripting better keep it closer to that code, but the method that decides whether an edge lies within a polygon seems general and useful enough to go to GHUtilities?\n\nNot sure if this is necessary. What purpose would this have?\n\nTo me there just seem to be two 'stories' here and it makes the code easier to understand, test and change when we keep them separated. One story is about interpreting our custom model language and extracting a mapping between edges and speeds/priorities. This is already quite a complex task which involves janino and giving a meaning to the keys and values we define in the custom model. The other story is about taking the edge->speed/priority mapping and calculating edge weights from this (applying the formula we use in CustomWeighting). To me this seems to be independent from creating this mapping and for example we should be able to use CustomWeighting with some mapping that does not use yaml, janino and our custom model language at all. This also becomes clear when we think about testing : Right now its hard to test the first story in isolation (and I guess this is why we do not have such tests yet). We cannot really test the custom model language, janino and all this without creating a CustomWeighting. We also cannot create a CustomWeighting without using ExpressionBuilder or CustomWeightingHelper which are both related to janino. At the same time this coupling seems easily avoidable, because the edge->speed/priority mapping provides a very small boundary between the CustomWeighting and the custom model language interpreting code.\nHave a look at this test in CustomWeightingTest:\n       EdgeIteratorState primary = graph.edge(0, 1).setDistance(10).\n                set(roadClassEnc, PRIMARY).set(avSpeedEnc, 80).set(accessEnc, true, true);\n        EdgeIteratorState secondary = graph.edge(1, 2).setDistance(10).\n                set(roadClassEnc, SECONDARY).set(avSpeedEnc, 70).set(accessEnc, true, true);\n\n        CustomModel vehicleModel = new CustomModel();\n        vehicleModel.getPriority().put(\"road_class != PRIMARY\", 0.5);\n\n        assertEquals(1.15, createWeighting(vehicleModel).calcEdgeWeight(primary, false), 0.01);\n        assertEquals(1.73, createWeighting(vehicleModel).calcEdgeWeight(secondary, false), 0.01);\nHere we create some edges and a custom model and what we really want to do is testing if our custom model rules yield the right speed/priority. But we cannot test this directly so we create a CustomWeighting and have to check the outcome of our custom model indirectly (we have to know the formula in CustomWeighting). So we need to compare the weight we get to some magic numbers like 1.15 and 1.73.\nI will try to refactor this a bit so you can see what I mean exactly.", "url": "https://github.com/graphhopper/graphhopper/pull/2209#discussion_r541899846", "createdAt": "2020-12-13T10:54:27Z", "author": {"login": "easbar"}, "path": "core/src/main/java/com/graphhopper/routing/weighting/custom/CustomWeightingHelper.java", "diffHunk": "@@ -0,0 +1,65 @@\n+/*\n+ *  Licensed to GraphHopper GmbH under one or more contributor\n+ *  license agreements. See the NOTICE file distributed with this work for\n+ *  additional information regarding copyright ownership.\n+ *\n+ *  GraphHopper GmbH licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except in\n+ *  compliance with the License. You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package com.graphhopper.routing.weighting.custom;\n+\n+import com.graphhopper.json.geo.JsonFeature;\n+import com.graphhopper.routing.ev.DecimalEncodedValue;\n+import com.graphhopper.routing.ev.EncodedValueLookup;\n+import com.graphhopper.util.EdgeIteratorState;\n+import com.graphhopper.util.FetchMode;\n+import com.graphhopper.util.GHUtility;\n+import com.graphhopper.util.shapes.BBox;\n+import com.graphhopper.util.shapes.Polygon;\n+\n+import java.util.Map;\n+\n+/**\n+ * This class makes it easy to control priority and speed for the CustomWeighting.\n+ */\n+public class CustomWeightingHelper {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTE0NDUzMA=="}, "originalCommit": {"oid": "5cb073c89e7badcdb4e8aa42997f9b5a447e89ed"}, "originalPosition": 34}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTkxNzQ1Mw==", "bodyText": "See this draft: #2211", "url": "https://github.com/graphhopper/graphhopper/pull/2209#discussion_r541917453", "createdAt": "2020-12-13T12:39:51Z", "author": {"login": "easbar"}, "path": "core/src/main/java/com/graphhopper/routing/weighting/custom/CustomWeightingHelper.java", "diffHunk": "@@ -0,0 +1,65 @@\n+/*\n+ *  Licensed to GraphHopper GmbH under one or more contributor\n+ *  license agreements. See the NOTICE file distributed with this work for\n+ *  additional information regarding copyright ownership.\n+ *\n+ *  GraphHopper GmbH licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except in\n+ *  compliance with the License. You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package com.graphhopper.routing.weighting.custom;\n+\n+import com.graphhopper.json.geo.JsonFeature;\n+import com.graphhopper.routing.ev.DecimalEncodedValue;\n+import com.graphhopper.routing.ev.EncodedValueLookup;\n+import com.graphhopper.util.EdgeIteratorState;\n+import com.graphhopper.util.FetchMode;\n+import com.graphhopper.util.GHUtility;\n+import com.graphhopper.util.shapes.BBox;\n+import com.graphhopper.util.shapes.Polygon;\n+\n+import java.util.Map;\n+\n+/**\n+ * This class makes it easy to control priority and speed for the CustomWeighting.\n+ */\n+public class CustomWeightingHelper {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTE0NDUzMA=="}, "originalCommit": {"oid": "5cb073c89e7badcdb4e8aa42997f9b5a447e89ed"}, "originalPosition": 34}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM5ODU2MTcyOnYy", "diffSide": "RIGHT", "path": "core/src/main/java/com/graphhopper/routing/weighting/custom/CustomWeighting.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMVQxODozMDo0NVrOIEE5HA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMVQxODozMDo0NVrOIEE5HA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTE0NTM3Mg==", "bodyText": "Why 'maximum' distance_influence? Its just that distance_influence must be positive right?", "url": "https://github.com/graphhopper/graphhopper/pull/2209#discussion_r541145372", "createdAt": "2020-12-11T18:30:45Z", "author": {"login": "easbar"}, "path": "core/src/main/java/com/graphhopper/routing/weighting/custom/CustomWeighting.java", "diffHunk": "@@ -86,26 +86,40 @@\n     private final double maxSpeed;\n     private final double distanceInfluence;\n     private final double headingPenaltySeconds;\n-    private final SpeedCalculator speedCalculator;\n-    private final PriorityCalculator priorityCalculator;\n+    private final CustomWeightingHelper cwHelper;\n \n-    public CustomWeighting(FlagEncoder baseFlagEncoder, EncodedValueLookup lookup,\n-                           TurnCostProvider turnCostProvider, CustomModel customModel) {\n+    public CustomWeighting(FlagEncoder baseFlagEncoder, EncodedValueLookup lookup, TurnCostProvider turnCostProvider,\n+                           CustomModel customModel) {\n         super(baseFlagEncoder, turnCostProvider);\n         if (customModel == null)\n             throw new IllegalStateException(\"CustomModel cannot be null\");\n \n         headingPenaltySeconds = customModel.getHeadingPenalty();\n         baseVehicleAccessEnc = baseFlagEncoder.getAccessEnc();\n-        speedCalculator = new SpeedCalculator(baseFlagEncoder.getMaxSpeed(), customModel, baseFlagEncoder.getAverageSpeedEnc(), lookup);\n-        maxSpeed = speedCalculator.getMaxSpeed() / SPEED_CONV;\n+        double maxSpeedTmp = customModel.getMaxSpeedFallback() == null ? baseFlagEncoder.getMaxSpeed() : customModel.getMaxSpeedFallback();\n+        if (customModel.getMaxSpeedFallback() != null && customModel.getMaxSpeedFallback() > maxSpeedTmp)\n+            throw new IllegalArgumentException(\"max_speed_fallback cannot be bigger than max_speed \" + maxSpeedTmp);\n+        cwHelper = ExpressionBuilder.create(customModel, lookup, baseFlagEncoder.getMaxSpeed(), maxSpeedTmp, baseFlagEncoder.getAverageSpeedEnc());\n+        maxSpeed = maxSpeedTmp / SPEED_CONV;\n \n-        priorityCalculator = new PriorityCalculator(customModel, lookup);\n+        // given unit is s/km -> convert to s/m\n+        this.distanceInfluence = customModel.getDistanceInfluence() / 1000.0;\n+        if (this.distanceInfluence < 0)\n+            throw new IllegalArgumentException(\"maximum distance_influence cannot be negative \" + this.distanceInfluence);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5cb073c89e7badcdb4e8aa42997f9b5a447e89ed"}, "originalPosition": 50}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM5ODY2ODcxOnYy", "diffSide": "RIGHT", "path": "core/src/main/java/com/graphhopper/routing/weighting/custom/ExpressionBuilder.java", "isResolved": true, "comments": {"totalCount": 15, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMVQxODo1ODoxOVrOIEF36A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNlQyMjozMDo1MlrOIHcBTQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTE2MTQ0OA==", "bodyText": "Can we find a better name here? This thing takes a custom model, does some janino magic and returns two functions that return the speed and priority for an edge. I called this SpeedAndPriorityProvider in some of the other comments. Its certainly not building expressions. Its rather interpreting expressions (like road_class == MOTORWAY) and builds these two functions.", "url": "https://github.com/graphhopper/graphhopper/pull/2209#discussion_r541161448", "createdAt": "2020-12-11T18:58:19Z", "author": {"login": "easbar"}, "path": "core/src/main/java/com/graphhopper/routing/weighting/custom/ExpressionBuilder.java", "diffHunk": "@@ -0,0 +1,382 @@\n+/*\n+ *  Licensed to GraphHopper GmbH under one or more contributor\n+ *  license agreements. See the NOTICE file distributed with this work for\n+ *  additional information regarding copyright ownership.\n+ *\n+ *  GraphHopper GmbH licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except in\n+ *  compliance with the License. You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package com.graphhopper.routing.weighting.custom;\n+\n+import com.graphhopper.json.geo.JsonFeature;\n+import com.graphhopper.routing.ev.DecimalEncodedValue;\n+import com.graphhopper.routing.ev.EncodedValue;\n+import com.graphhopper.routing.ev.EncodedValueLookup;\n+import com.graphhopper.routing.util.CustomModel;\n+import com.graphhopper.routing.util.EncodingManager;\n+import com.graphhopper.util.EdgeIteratorState;\n+import com.graphhopper.util.GHUtility;\n+import com.graphhopper.util.shapes.BBox;\n+import com.graphhopper.util.shapes.Polygon;\n+import org.codehaus.commons.compiler.CompileException;\n+import org.codehaus.commons.compiler.Location;\n+import org.codehaus.commons.compiler.io.Readers;\n+import org.codehaus.janino.Scanner;\n+import org.codehaus.janino.*;\n+import org.codehaus.janino.util.DeepCopier;\n+import org.locationtech.jts.geom.prep.PreparedGeometryFactory;\n+\n+import java.io.*;\n+import java.util.*;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+class ExpressionBuilder {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5cb073c89e7badcdb4e8aa42997f9b5a447e89ed"}, "originalPosition": 42}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTY5NTk0Nw==", "bodyText": "Sure, this evolved a lot and can call it differently. The only reason for this class was to avoid \"polluting\" CustomWeighting", "url": "https://github.com/graphhopper/graphhopper/pull/2209#discussion_r541695947", "createdAt": "2020-12-12T17:56:47Z", "author": {"login": "karussell"}, "path": "core/src/main/java/com/graphhopper/routing/weighting/custom/ExpressionBuilder.java", "diffHunk": "@@ -0,0 +1,382 @@\n+/*\n+ *  Licensed to GraphHopper GmbH under one or more contributor\n+ *  license agreements. See the NOTICE file distributed with this work for\n+ *  additional information regarding copyright ownership.\n+ *\n+ *  GraphHopper GmbH licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except in\n+ *  compliance with the License. You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package com.graphhopper.routing.weighting.custom;\n+\n+import com.graphhopper.json.geo.JsonFeature;\n+import com.graphhopper.routing.ev.DecimalEncodedValue;\n+import com.graphhopper.routing.ev.EncodedValue;\n+import com.graphhopper.routing.ev.EncodedValueLookup;\n+import com.graphhopper.routing.util.CustomModel;\n+import com.graphhopper.routing.util.EncodingManager;\n+import com.graphhopper.util.EdgeIteratorState;\n+import com.graphhopper.util.GHUtility;\n+import com.graphhopper.util.shapes.BBox;\n+import com.graphhopper.util.shapes.Polygon;\n+import org.codehaus.commons.compiler.CompileException;\n+import org.codehaus.commons.compiler.Location;\n+import org.codehaus.commons.compiler.io.Readers;\n+import org.codehaus.janino.Scanner;\n+import org.codehaus.janino.*;\n+import org.codehaus.janino.util.DeepCopier;\n+import org.locationtech.jts.geom.prep.PreparedGeometryFactory;\n+\n+import java.io.*;\n+import java.util.*;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+class ExpressionBuilder {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTE2MTQ0OA=="}, "originalCommit": {"oid": "5cb073c89e7badcdb4e8aa42997f9b5a447e89ed"}, "originalPosition": 42}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTc3Njg3Mw==", "bodyText": "Should we name CustomWeightingHelper something like SpeedAndPriorityProvider and ExpressionBuilder then SpeedAndPriorityProviderBuilder? (Hmmh, don't like it too much :D )", "url": "https://github.com/graphhopper/graphhopper/pull/2209#discussion_r541776873", "createdAt": "2020-12-12T20:41:40Z", "author": {"login": "karussell"}, "path": "core/src/main/java/com/graphhopper/routing/weighting/custom/ExpressionBuilder.java", "diffHunk": "@@ -0,0 +1,382 @@\n+/*\n+ *  Licensed to GraphHopper GmbH under one or more contributor\n+ *  license agreements. See the NOTICE file distributed with this work for\n+ *  additional information regarding copyright ownership.\n+ *\n+ *  GraphHopper GmbH licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except in\n+ *  compliance with the License. You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package com.graphhopper.routing.weighting.custom;\n+\n+import com.graphhopper.json.geo.JsonFeature;\n+import com.graphhopper.routing.ev.DecimalEncodedValue;\n+import com.graphhopper.routing.ev.EncodedValue;\n+import com.graphhopper.routing.ev.EncodedValueLookup;\n+import com.graphhopper.routing.util.CustomModel;\n+import com.graphhopper.routing.util.EncodingManager;\n+import com.graphhopper.util.EdgeIteratorState;\n+import com.graphhopper.util.GHUtility;\n+import com.graphhopper.util.shapes.BBox;\n+import com.graphhopper.util.shapes.Polygon;\n+import org.codehaus.commons.compiler.CompileException;\n+import org.codehaus.commons.compiler.Location;\n+import org.codehaus.commons.compiler.io.Readers;\n+import org.codehaus.janino.Scanner;\n+import org.codehaus.janino.*;\n+import org.codehaus.janino.util.DeepCopier;\n+import org.locationtech.jts.geom.prep.PreparedGeometryFactory;\n+\n+import java.io.*;\n+import java.util.*;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+class ExpressionBuilder {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTE2MTQ0OA=="}, "originalCommit": {"oid": "5cb073c89e7badcdb4e8aa42997f9b5a447e89ed"}, "originalPosition": 42}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTkxNDA5OA==", "bodyText": "Yeah I do not like SpeedAndPriorityProviderBuilder either. Especially the XAndY part. We could call it CustomModelInterpreter maybe? Basically it takes a custom model and returns something we can use to calculate a speed and priority for an edge. Actually I wish this were two methods: one for speed and one for priority, but that probably does not work because we need janino to create/cache one class that does both and otherwise we would have to create two classes which would be worse for performance?", "url": "https://github.com/graphhopper/graphhopper/pull/2209#discussion_r541914098", "createdAt": "2020-12-13T12:19:14Z", "author": {"login": "easbar"}, "path": "core/src/main/java/com/graphhopper/routing/weighting/custom/ExpressionBuilder.java", "diffHunk": "@@ -0,0 +1,382 @@\n+/*\n+ *  Licensed to GraphHopper GmbH under one or more contributor\n+ *  license agreements. See the NOTICE file distributed with this work for\n+ *  additional information regarding copyright ownership.\n+ *\n+ *  GraphHopper GmbH licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except in\n+ *  compliance with the License. You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package com.graphhopper.routing.weighting.custom;\n+\n+import com.graphhopper.json.geo.JsonFeature;\n+import com.graphhopper.routing.ev.DecimalEncodedValue;\n+import com.graphhopper.routing.ev.EncodedValue;\n+import com.graphhopper.routing.ev.EncodedValueLookup;\n+import com.graphhopper.routing.util.CustomModel;\n+import com.graphhopper.routing.util.EncodingManager;\n+import com.graphhopper.util.EdgeIteratorState;\n+import com.graphhopper.util.GHUtility;\n+import com.graphhopper.util.shapes.BBox;\n+import com.graphhopper.util.shapes.Polygon;\n+import org.codehaus.commons.compiler.CompileException;\n+import org.codehaus.commons.compiler.Location;\n+import org.codehaus.commons.compiler.io.Readers;\n+import org.codehaus.janino.Scanner;\n+import org.codehaus.janino.*;\n+import org.codehaus.janino.util.DeepCopier;\n+import org.locationtech.jts.geom.prep.PreparedGeometryFactory;\n+\n+import java.io.*;\n+import java.util.*;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+class ExpressionBuilder {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTE2MTQ0OA=="}, "originalCommit": {"oid": "5cb073c89e7badcdb4e8aa42997f9b5a447e89ed"}, "originalPosition": 42}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjMxNzEzNQ==", "bodyText": "I'm not sure if it would be worse for performance but we would need two classes, two caches, two init calls and more. I currently prefer the variation you have in your PR where the interface uses two separate interfaces but our janino implementation can remain via one class.", "url": "https://github.com/graphhopper/graphhopper/pull/2209#discussion_r542317135", "createdAt": "2020-12-14T11:36:17Z", "author": {"login": "karussell"}, "path": "core/src/main/java/com/graphhopper/routing/weighting/custom/ExpressionBuilder.java", "diffHunk": "@@ -0,0 +1,382 @@\n+/*\n+ *  Licensed to GraphHopper GmbH under one or more contributor\n+ *  license agreements. See the NOTICE file distributed with this work for\n+ *  additional information regarding copyright ownership.\n+ *\n+ *  GraphHopper GmbH licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except in\n+ *  compliance with the License. You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package com.graphhopper.routing.weighting.custom;\n+\n+import com.graphhopper.json.geo.JsonFeature;\n+import com.graphhopper.routing.ev.DecimalEncodedValue;\n+import com.graphhopper.routing.ev.EncodedValue;\n+import com.graphhopper.routing.ev.EncodedValueLookup;\n+import com.graphhopper.routing.util.CustomModel;\n+import com.graphhopper.routing.util.EncodingManager;\n+import com.graphhopper.util.EdgeIteratorState;\n+import com.graphhopper.util.GHUtility;\n+import com.graphhopper.util.shapes.BBox;\n+import com.graphhopper.util.shapes.Polygon;\n+import org.codehaus.commons.compiler.CompileException;\n+import org.codehaus.commons.compiler.Location;\n+import org.codehaus.commons.compiler.io.Readers;\n+import org.codehaus.janino.Scanner;\n+import org.codehaus.janino.*;\n+import org.codehaus.janino.util.DeepCopier;\n+import org.locationtech.jts.geom.prep.PreparedGeometryFactory;\n+\n+import java.io.*;\n+import java.util.*;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+class ExpressionBuilder {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTE2MTQ0OA=="}, "originalCommit": {"oid": "5cb073c89e7badcdb4e8aa42997f9b5a447e89ed"}, "originalPosition": 42}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjMyODMyMg==", "bodyText": "Ok that makes sense. Another thing that came to my mind: Could we limit Janino to parsing boolean expressions entirely? I mean instead of creating one subclass per custom weighting create one subclass per boolean expression and cache all these expressions (and share between custom weightings). Instead of functions like (edge, reverse)->double for speed, priority etc. we would only get functions like (edge, reverse)->boolean and everything else would be plain Java (without Janino). I did not really look at details about Janino and caching, so this is just a thought...", "url": "https://github.com/graphhopper/graphhopper/pull/2209#discussion_r542328322", "createdAt": "2020-12-14T11:55:54Z", "author": {"login": "easbar"}, "path": "core/src/main/java/com/graphhopper/routing/weighting/custom/ExpressionBuilder.java", "diffHunk": "@@ -0,0 +1,382 @@\n+/*\n+ *  Licensed to GraphHopper GmbH under one or more contributor\n+ *  license agreements. See the NOTICE file distributed with this work for\n+ *  additional information regarding copyright ownership.\n+ *\n+ *  GraphHopper GmbH licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except in\n+ *  compliance with the License. You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package com.graphhopper.routing.weighting.custom;\n+\n+import com.graphhopper.json.geo.JsonFeature;\n+import com.graphhopper.routing.ev.DecimalEncodedValue;\n+import com.graphhopper.routing.ev.EncodedValue;\n+import com.graphhopper.routing.ev.EncodedValueLookup;\n+import com.graphhopper.routing.util.CustomModel;\n+import com.graphhopper.routing.util.EncodingManager;\n+import com.graphhopper.util.EdgeIteratorState;\n+import com.graphhopper.util.GHUtility;\n+import com.graphhopper.util.shapes.BBox;\n+import com.graphhopper.util.shapes.Polygon;\n+import org.codehaus.commons.compiler.CompileException;\n+import org.codehaus.commons.compiler.Location;\n+import org.codehaus.commons.compiler.io.Readers;\n+import org.codehaus.janino.Scanner;\n+import org.codehaus.janino.*;\n+import org.codehaus.janino.util.DeepCopier;\n+import org.locationtech.jts.geom.prep.PreparedGeometryFactory;\n+\n+import java.io.*;\n+import java.util.*;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+class ExpressionBuilder {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTE2MTQ0OA=="}, "originalCommit": {"oid": "5cb073c89e7badcdb4e8aa42997f9b5a447e89ed"}, "originalPosition": 42}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjM0ODM2Ng==", "bodyText": "In general this is possible as Janino allows parsing also only single expressions, but we would need to set up every single expression manually (like telling janino where to get the constants via imports and the variables etc) and what to do with the result. So this will not only be very tedious, but might also have a negative impact on speed due to this overhead of \"context switch\".", "url": "https://github.com/graphhopper/graphhopper/pull/2209#discussion_r542348366", "createdAt": "2020-12-14T12:33:22Z", "author": {"login": "karussell"}, "path": "core/src/main/java/com/graphhopper/routing/weighting/custom/ExpressionBuilder.java", "diffHunk": "@@ -0,0 +1,382 @@\n+/*\n+ *  Licensed to GraphHopper GmbH under one or more contributor\n+ *  license agreements. See the NOTICE file distributed with this work for\n+ *  additional information regarding copyright ownership.\n+ *\n+ *  GraphHopper GmbH licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except in\n+ *  compliance with the License. You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package com.graphhopper.routing.weighting.custom;\n+\n+import com.graphhopper.json.geo.JsonFeature;\n+import com.graphhopper.routing.ev.DecimalEncodedValue;\n+import com.graphhopper.routing.ev.EncodedValue;\n+import com.graphhopper.routing.ev.EncodedValueLookup;\n+import com.graphhopper.routing.util.CustomModel;\n+import com.graphhopper.routing.util.EncodingManager;\n+import com.graphhopper.util.EdgeIteratorState;\n+import com.graphhopper.util.GHUtility;\n+import com.graphhopper.util.shapes.BBox;\n+import com.graphhopper.util.shapes.Polygon;\n+import org.codehaus.commons.compiler.CompileException;\n+import org.codehaus.commons.compiler.Location;\n+import org.codehaus.commons.compiler.io.Readers;\n+import org.codehaus.janino.Scanner;\n+import org.codehaus.janino.*;\n+import org.codehaus.janino.util.DeepCopier;\n+import org.locationtech.jts.geom.prep.PreparedGeometryFactory;\n+\n+import java.io.*;\n+import java.util.*;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+class ExpressionBuilder {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTE2MTQ0OA=="}, "originalCommit": {"oid": "5cb073c89e7badcdb4e8aa42997f9b5a447e89ed"}, "originalPosition": 42}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjM1MjM0Mw==", "bodyText": "Actually we already parse every single expression but it would not compile (missing context like imports and the encoded values are unknown etc) and so we would need to inject the encoded values on every call dynamically somehow. This would be also limiting as we would know the number of operators and currently we could theoretically even do a * b > 10 or call (whitelisted) methods or Math operations etc.", "url": "https://github.com/graphhopper/graphhopper/pull/2209#discussion_r542352343", "createdAt": "2020-12-14T12:40:10Z", "author": {"login": "karussell"}, "path": "core/src/main/java/com/graphhopper/routing/weighting/custom/ExpressionBuilder.java", "diffHunk": "@@ -0,0 +1,382 @@\n+/*\n+ *  Licensed to GraphHopper GmbH under one or more contributor\n+ *  license agreements. See the NOTICE file distributed with this work for\n+ *  additional information regarding copyright ownership.\n+ *\n+ *  GraphHopper GmbH licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except in\n+ *  compliance with the License. You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package com.graphhopper.routing.weighting.custom;\n+\n+import com.graphhopper.json.geo.JsonFeature;\n+import com.graphhopper.routing.ev.DecimalEncodedValue;\n+import com.graphhopper.routing.ev.EncodedValue;\n+import com.graphhopper.routing.ev.EncodedValueLookup;\n+import com.graphhopper.routing.util.CustomModel;\n+import com.graphhopper.routing.util.EncodingManager;\n+import com.graphhopper.util.EdgeIteratorState;\n+import com.graphhopper.util.GHUtility;\n+import com.graphhopper.util.shapes.BBox;\n+import com.graphhopper.util.shapes.Polygon;\n+import org.codehaus.commons.compiler.CompileException;\n+import org.codehaus.commons.compiler.Location;\n+import org.codehaus.commons.compiler.io.Readers;\n+import org.codehaus.janino.Scanner;\n+import org.codehaus.janino.*;\n+import org.codehaus.janino.util.DeepCopier;\n+import org.locationtech.jts.geom.prep.PreparedGeometryFactory;\n+\n+import java.io.*;\n+import java.util.*;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+class ExpressionBuilder {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTE2MTQ0OA=="}, "originalCommit": {"oid": "5cb073c89e7badcdb4e8aa42997f9b5a447e89ed"}, "originalPosition": 42}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjM1MjQ2NA==", "bodyText": "Hm I don't understand this yet. Yes the Janino class needs all the imports and constants to parse the different possible expressions, but for the current CustomWeightingHelperSubclass its the same? Why do we need to setup the single expressions manually? I meant we could simply feed the expressions (the current keys of the custom model) to Janino and build a cache containing these. So for example if multiple custom weightings use road_class == PRIMARY it will be shared between these custom weightings. But I am not sure if this is even 'better' or faster. To me it just seems simpler and easier to think about that there is some parser that converts boolean expressions to compiled (edge,reverse)->boolean functions than to think of a parser that knows about all the rules of the custom model language.", "url": "https://github.com/graphhopper/graphhopper/pull/2209#discussion_r542352464", "createdAt": "2020-12-14T12:40:23Z", "author": {"login": "easbar"}, "path": "core/src/main/java/com/graphhopper/routing/weighting/custom/ExpressionBuilder.java", "diffHunk": "@@ -0,0 +1,382 @@\n+/*\n+ *  Licensed to GraphHopper GmbH under one or more contributor\n+ *  license agreements. See the NOTICE file distributed with this work for\n+ *  additional information regarding copyright ownership.\n+ *\n+ *  GraphHopper GmbH licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except in\n+ *  compliance with the License. You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package com.graphhopper.routing.weighting.custom;\n+\n+import com.graphhopper.json.geo.JsonFeature;\n+import com.graphhopper.routing.ev.DecimalEncodedValue;\n+import com.graphhopper.routing.ev.EncodedValue;\n+import com.graphhopper.routing.ev.EncodedValueLookup;\n+import com.graphhopper.routing.util.CustomModel;\n+import com.graphhopper.routing.util.EncodingManager;\n+import com.graphhopper.util.EdgeIteratorState;\n+import com.graphhopper.util.GHUtility;\n+import com.graphhopper.util.shapes.BBox;\n+import com.graphhopper.util.shapes.Polygon;\n+import org.codehaus.commons.compiler.CompileException;\n+import org.codehaus.commons.compiler.Location;\n+import org.codehaus.commons.compiler.io.Readers;\n+import org.codehaus.janino.Scanner;\n+import org.codehaus.janino.*;\n+import org.codehaus.janino.util.DeepCopier;\n+import org.locationtech.jts.geom.prep.PreparedGeometryFactory;\n+\n+import java.io.*;\n+import java.util.*;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+class ExpressionBuilder {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTE2MTQ0OA=="}, "originalCommit": {"oid": "5cb073c89e7badcdb4e8aa42997f9b5a447e89ed"}, "originalPosition": 42}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjM2MTU3MQ==", "bodyText": "I meant we could simply feed the expressions (the current keys of the custom model) to Janino and build a cache containing these\n\nParsed statements still needs to be compiled. So only because I know that e.g. road_class is some token we would have to tell the compiled expression the value of road_class so that janino then evaluates the boolean expression for us. E.g. for: road_class == PRIMARY this is something like\nloop over compiledExpressions:\n  compiledExpression.setArgument(0, edge.get(road_class_enc)) // loop over all arguments\n  if(compiledExpression.evaluate()) // continue or break depending on the operator (`&&` or `||`) or more complicated if there are `()` brakets etc.\n\nSo basically we would do part of the job why we introduced Janino :)\n\nthan to think of a parser that knows about all the rules of the custom model language.\n\nI think of Janino as some Java code that calculates the speed and the priority based on some simple if-clauses. E.g. you can always print the Java code via\nStringWriter sw = new StringWriter();\nUnparser.unparse(cu, sw);", "url": "https://github.com/graphhopper/graphhopper/pull/2209#discussion_r542361571", "createdAt": "2020-12-14T12:55:59Z", "author": {"login": "karussell"}, "path": "core/src/main/java/com/graphhopper/routing/weighting/custom/ExpressionBuilder.java", "diffHunk": "@@ -0,0 +1,382 @@\n+/*\n+ *  Licensed to GraphHopper GmbH under one or more contributor\n+ *  license agreements. See the NOTICE file distributed with this work for\n+ *  additional information regarding copyright ownership.\n+ *\n+ *  GraphHopper GmbH licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except in\n+ *  compliance with the License. You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package com.graphhopper.routing.weighting.custom;\n+\n+import com.graphhopper.json.geo.JsonFeature;\n+import com.graphhopper.routing.ev.DecimalEncodedValue;\n+import com.graphhopper.routing.ev.EncodedValue;\n+import com.graphhopper.routing.ev.EncodedValueLookup;\n+import com.graphhopper.routing.util.CustomModel;\n+import com.graphhopper.routing.util.EncodingManager;\n+import com.graphhopper.util.EdgeIteratorState;\n+import com.graphhopper.util.GHUtility;\n+import com.graphhopper.util.shapes.BBox;\n+import com.graphhopper.util.shapes.Polygon;\n+import org.codehaus.commons.compiler.CompileException;\n+import org.codehaus.commons.compiler.Location;\n+import org.codehaus.commons.compiler.io.Readers;\n+import org.codehaus.janino.Scanner;\n+import org.codehaus.janino.*;\n+import org.codehaus.janino.util.DeepCopier;\n+import org.locationtech.jts.geom.prep.PreparedGeometryFactory;\n+\n+import java.io.*;\n+import java.util.*;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+class ExpressionBuilder {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTE2MTQ0OA=="}, "originalCommit": {"oid": "5cb073c89e7badcdb4e8aa42997f9b5a447e89ed"}, "originalPosition": 42}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjM3NjY2Mw==", "bodyText": "I think of Janino as some Java code that calculates the speed and the priority based on some simple if-clauses.\n\nBut Janino can only understand the parts of custom_model.yml that are Java right? To me it looks like we create a Janino subclass that knows about the structure of custom_model.yml (our custom model language) such that it can map edges to speeds and priorities. I would have expected we use Janino to map edges to booleans (only parse the Java parts of custom_model.yml) and then apply our custom model language using these boolean functions. But maybe I have some misunderstanding here and I will have a closer look at Janino to understand it better.", "url": "https://github.com/graphhopper/graphhopper/pull/2209#discussion_r542376663", "createdAt": "2020-12-14T13:19:41Z", "author": {"login": "easbar"}, "path": "core/src/main/java/com/graphhopper/routing/weighting/custom/ExpressionBuilder.java", "diffHunk": "@@ -0,0 +1,382 @@\n+/*\n+ *  Licensed to GraphHopper GmbH under one or more contributor\n+ *  license agreements. See the NOTICE file distributed with this work for\n+ *  additional information regarding copyright ownership.\n+ *\n+ *  GraphHopper GmbH licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except in\n+ *  compliance with the License. You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package com.graphhopper.routing.weighting.custom;\n+\n+import com.graphhopper.json.geo.JsonFeature;\n+import com.graphhopper.routing.ev.DecimalEncodedValue;\n+import com.graphhopper.routing.ev.EncodedValue;\n+import com.graphhopper.routing.ev.EncodedValueLookup;\n+import com.graphhopper.routing.util.CustomModel;\n+import com.graphhopper.routing.util.EncodingManager;\n+import com.graphhopper.util.EdgeIteratorState;\n+import com.graphhopper.util.GHUtility;\n+import com.graphhopper.util.shapes.BBox;\n+import com.graphhopper.util.shapes.Polygon;\n+import org.codehaus.commons.compiler.CompileException;\n+import org.codehaus.commons.compiler.Location;\n+import org.codehaus.commons.compiler.io.Readers;\n+import org.codehaus.janino.Scanner;\n+import org.codehaus.janino.*;\n+import org.codehaus.janino.util.DeepCopier;\n+import org.locationtech.jts.geom.prep.PreparedGeometryFactory;\n+\n+import java.io.*;\n+import java.util.*;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+class ExpressionBuilder {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTE2MTQ0OA=="}, "originalCommit": {"oid": "5cb073c89e7badcdb4e8aa42997f9b5a447e89ed"}, "originalPosition": 42}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjM4ODI4MQ==", "bodyText": "Let's say we have this custom model:\nspeed:\n   - if: road_class == PRIMARY && surface == GRAVEL\n     factor: 0.5\n   - if: road_environment == TUNNEL\n     factor: 0.9\nI thought we could create two subclasses of some interface like EdgeToBooleanMapping with janino and then use this to build our custom language around this like this:\nList<EdgeToBooleanMapping> mappings = new ArrayList<>();\nfor (Entry entry : customModel.getSpeedFactor().values()) {\n    mappings.add(janino.compileOrLoadFromCache(createJaninoSubclass(entry.get(\"if\"), entry.get(\"factor\"));\n}\n// now we are done with parsing the custom model, all we need to keep here is the list of mappings so now we\n// can call the following code for all edges we need to calculate the speed for:\ndouble speed = 1;\nfor (EdgeToBooleanMapping mapping : mappings) {\n    speed *= mapping.get(edge, reverse);\n}\ncreateJaninoSubclass would work exactly the same way as the code that currently creates a subclass of CustomWeightingHelper. We would probably use the same imports and context and include the code that extracts, e.g. road_class from the given edge and all this.  The only difference is that it produces something that returns a boolean for a single expression instead of a speed or priority.\nSo this would work similar to what we do right now, doesn't it?\nBut I am not sure if this is even better, because in this case we need to compile multiple subclasses for every custom weighting. But on the other hand we can share some of them between custom weightings. Also the code above would only be compiled once and run for all custom weightings (not sure if this is better for JIT optimization).", "url": "https://github.com/graphhopper/graphhopper/pull/2209#discussion_r542388281", "createdAt": "2020-12-14T13:37:00Z", "author": {"login": "easbar"}, "path": "core/src/main/java/com/graphhopper/routing/weighting/custom/ExpressionBuilder.java", "diffHunk": "@@ -0,0 +1,382 @@\n+/*\n+ *  Licensed to GraphHopper GmbH under one or more contributor\n+ *  license agreements. See the NOTICE file distributed with this work for\n+ *  additional information regarding copyright ownership.\n+ *\n+ *  GraphHopper GmbH licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except in\n+ *  compliance with the License. You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package com.graphhopper.routing.weighting.custom;\n+\n+import com.graphhopper.json.geo.JsonFeature;\n+import com.graphhopper.routing.ev.DecimalEncodedValue;\n+import com.graphhopper.routing.ev.EncodedValue;\n+import com.graphhopper.routing.ev.EncodedValueLookup;\n+import com.graphhopper.routing.util.CustomModel;\n+import com.graphhopper.routing.util.EncodingManager;\n+import com.graphhopper.util.EdgeIteratorState;\n+import com.graphhopper.util.GHUtility;\n+import com.graphhopper.util.shapes.BBox;\n+import com.graphhopper.util.shapes.Polygon;\n+import org.codehaus.commons.compiler.CompileException;\n+import org.codehaus.commons.compiler.Location;\n+import org.codehaus.commons.compiler.io.Readers;\n+import org.codehaus.janino.Scanner;\n+import org.codehaus.janino.*;\n+import org.codehaus.janino.util.DeepCopier;\n+import org.locationtech.jts.geom.prep.PreparedGeometryFactory;\n+\n+import java.io.*;\n+import java.util.*;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+class ExpressionBuilder {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTE2MTQ0OA=="}, "originalCommit": {"oid": "5cb073c89e7badcdb4e8aa42997f9b5a447e89ed"}, "originalPosition": 42}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjQzODk2MA==", "bodyText": "Ok, I see.\n\nSo this would work similar to what we do right now, doesn't it?\n\nNote that we currently fetch e.g. road_class once in getSpeed and can then use it in all of the following expressions. If the expressions are separate we would need some local cache (Map) for this or fetch this value multiple times (or introduce the cache inside the BaseGraph). So both is currently more work compared to only using a variable inside the same method. Also the for-loops are currently not existent, so this would also introduce slightly more work.\n\nBut I am not sure if this is even better\n\nI'm also unsure if this is better. But good to keep in mind as it would reduce the complexity a bit as we only need to compile the previously scanned expressions and we won't need DeepCopier and probably also no SimpleCompiler, but IMO this is only an implementation detail (for now).", "url": "https://github.com/graphhopper/graphhopper/pull/2209#discussion_r542438960", "createdAt": "2020-12-14T14:45:09Z", "author": {"login": "karussell"}, "path": "core/src/main/java/com/graphhopper/routing/weighting/custom/ExpressionBuilder.java", "diffHunk": "@@ -0,0 +1,382 @@\n+/*\n+ *  Licensed to GraphHopper GmbH under one or more contributor\n+ *  license agreements. See the NOTICE file distributed with this work for\n+ *  additional information regarding copyright ownership.\n+ *\n+ *  GraphHopper GmbH licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except in\n+ *  compliance with the License. You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package com.graphhopper.routing.weighting.custom;\n+\n+import com.graphhopper.json.geo.JsonFeature;\n+import com.graphhopper.routing.ev.DecimalEncodedValue;\n+import com.graphhopper.routing.ev.EncodedValue;\n+import com.graphhopper.routing.ev.EncodedValueLookup;\n+import com.graphhopper.routing.util.CustomModel;\n+import com.graphhopper.routing.util.EncodingManager;\n+import com.graphhopper.util.EdgeIteratorState;\n+import com.graphhopper.util.GHUtility;\n+import com.graphhopper.util.shapes.BBox;\n+import com.graphhopper.util.shapes.Polygon;\n+import org.codehaus.commons.compiler.CompileException;\n+import org.codehaus.commons.compiler.Location;\n+import org.codehaus.commons.compiler.io.Readers;\n+import org.codehaus.janino.Scanner;\n+import org.codehaus.janino.*;\n+import org.codehaus.janino.util.DeepCopier;\n+import org.locationtech.jts.geom.prep.PreparedGeometryFactory;\n+\n+import java.io.*;\n+import java.util.*;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+class ExpressionBuilder {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTE2MTQ0OA=="}, "originalCommit": {"oid": "5cb073c89e7badcdb4e8aa42997f9b5a447e89ed"}, "originalPosition": 42}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjU3NDY3MQ==", "bodyText": "Note that we currently fetch e.g. road_class once in getSpeed and can then use it in all of the following expressions.\n\nYes good point, this might be important. What exactly does fetching mean here? The flags are cached in the EdgeIteratorState anyway, right?\n\nAlso the for-loops are currently not existent, so this would also introduce slightly more work\n\nOk just the fact that you already did it the way it is now is reason enough to keep it as it is for now. Especially, because so far we can only speculate which approach is faster and if this even matters. But I am pretty sure it would be a bit cleaner code (unless we need some complicated workarounds to achieve the same performance).\n\n, but IMO this is only an implementation detail (for now).\n\nYes, totally. So let's just keep this in mind and leave as is for now.", "url": "https://github.com/graphhopper/graphhopper/pull/2209#discussion_r542574671", "createdAt": "2020-12-14T17:36:51Z", "author": {"login": "easbar"}, "path": "core/src/main/java/com/graphhopper/routing/weighting/custom/ExpressionBuilder.java", "diffHunk": "@@ -0,0 +1,382 @@\n+/*\n+ *  Licensed to GraphHopper GmbH under one or more contributor\n+ *  license agreements. See the NOTICE file distributed with this work for\n+ *  additional information regarding copyright ownership.\n+ *\n+ *  GraphHopper GmbH licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except in\n+ *  compliance with the License. You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package com.graphhopper.routing.weighting.custom;\n+\n+import com.graphhopper.json.geo.JsonFeature;\n+import com.graphhopper.routing.ev.DecimalEncodedValue;\n+import com.graphhopper.routing.ev.EncodedValue;\n+import com.graphhopper.routing.ev.EncodedValueLookup;\n+import com.graphhopper.routing.util.CustomModel;\n+import com.graphhopper.routing.util.EncodingManager;\n+import com.graphhopper.util.EdgeIteratorState;\n+import com.graphhopper.util.GHUtility;\n+import com.graphhopper.util.shapes.BBox;\n+import com.graphhopper.util.shapes.Polygon;\n+import org.codehaus.commons.compiler.CompileException;\n+import org.codehaus.commons.compiler.Location;\n+import org.codehaus.commons.compiler.io.Readers;\n+import org.codehaus.janino.Scanner;\n+import org.codehaus.janino.*;\n+import org.codehaus.janino.util.DeepCopier;\n+import org.locationtech.jts.geom.prep.PreparedGeometryFactory;\n+\n+import java.io.*;\n+import java.util.*;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+class ExpressionBuilder {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTE2MTQ0OA=="}, "originalCommit": {"oid": "5cb073c89e7badcdb4e8aa42997f9b5a447e89ed"}, "originalPosition": 42}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDY3MDAyOQ==", "bodyText": "What exactly does fetching mean here?\n\nYes, flags are cached but \"extracting\" the int or double number from the flags via bit shifting is a tiny overhead. And probably the bigger overhead is to set the arguments and get the result and pipe this through the other expressions.\n\nBut I am pretty sure it would be a bit cleaner code (unless we need some complicated workarounds to achieve the same performance)\n\nOk. This code will be cleaner to read, yes. But it might be harder to set up with Janino, not sure.", "url": "https://github.com/graphhopper/graphhopper/pull/2209#discussion_r544670029", "createdAt": "2020-12-16T22:30:52Z", "author": {"login": "karussell"}, "path": "core/src/main/java/com/graphhopper/routing/weighting/custom/ExpressionBuilder.java", "diffHunk": "@@ -0,0 +1,382 @@\n+/*\n+ *  Licensed to GraphHopper GmbH under one or more contributor\n+ *  license agreements. See the NOTICE file distributed with this work for\n+ *  additional information regarding copyright ownership.\n+ *\n+ *  GraphHopper GmbH licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except in\n+ *  compliance with the License. You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package com.graphhopper.routing.weighting.custom;\n+\n+import com.graphhopper.json.geo.JsonFeature;\n+import com.graphhopper.routing.ev.DecimalEncodedValue;\n+import com.graphhopper.routing.ev.EncodedValue;\n+import com.graphhopper.routing.ev.EncodedValueLookup;\n+import com.graphhopper.routing.util.CustomModel;\n+import com.graphhopper.routing.util.EncodingManager;\n+import com.graphhopper.util.EdgeIteratorState;\n+import com.graphhopper.util.GHUtility;\n+import com.graphhopper.util.shapes.BBox;\n+import com.graphhopper.util.shapes.Polygon;\n+import org.codehaus.commons.compiler.CompileException;\n+import org.codehaus.commons.compiler.Location;\n+import org.codehaus.commons.compiler.io.Readers;\n+import org.codehaus.janino.Scanner;\n+import org.codehaus.janino.*;\n+import org.codehaus.janino.util.DeepCopier;\n+import org.locationtech.jts.geom.prep.PreparedGeometryFactory;\n+\n+import java.io.*;\n+import java.util.*;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+class ExpressionBuilder {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTE2MTQ0OA=="}, "originalCommit": {"oid": "5cb073c89e7badcdb4e8aa42997f9b5a447e89ed"}, "originalPosition": 42}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM5ODcwMjYxOnYy", "diffSide": "RIGHT", "path": "core/src/main/java/com/graphhopper/routing/weighting/custom/ExpressionBuilder.java", "isResolved": true, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMVQxOTowMzozNVrOIEGOqA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNFQxMjowOTo0M1rOIFNizA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTE2NzI3Mg==", "bodyText": "Can we move the try statement a bit further down? Its unrelated to the cache lookup, right?", "url": "https://github.com/graphhopper/graphhopper/pull/2209#discussion_r541167272", "createdAt": "2020-12-11T19:03:35Z", "author": {"login": "easbar"}, "path": "core/src/main/java/com/graphhopper/routing/weighting/custom/ExpressionBuilder.java", "diffHunk": "@@ -0,0 +1,382 @@\n+/*\n+ *  Licensed to GraphHopper GmbH under one or more contributor\n+ *  license agreements. See the NOTICE file distributed with this work for\n+ *  additional information regarding copyright ownership.\n+ *\n+ *  GraphHopper GmbH licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except in\n+ *  compliance with the License. You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package com.graphhopper.routing.weighting.custom;\n+\n+import com.graphhopper.json.geo.JsonFeature;\n+import com.graphhopper.routing.ev.DecimalEncodedValue;\n+import com.graphhopper.routing.ev.EncodedValue;\n+import com.graphhopper.routing.ev.EncodedValueLookup;\n+import com.graphhopper.routing.util.CustomModel;\n+import com.graphhopper.routing.util.EncodingManager;\n+import com.graphhopper.util.EdgeIteratorState;\n+import com.graphhopper.util.GHUtility;\n+import com.graphhopper.util.shapes.BBox;\n+import com.graphhopper.util.shapes.Polygon;\n+import org.codehaus.commons.compiler.CompileException;\n+import org.codehaus.commons.compiler.Location;\n+import org.codehaus.commons.compiler.io.Readers;\n+import org.codehaus.janino.Scanner;\n+import org.codehaus.janino.*;\n+import org.codehaus.janino.util.DeepCopier;\n+import org.locationtech.jts.geom.prep.PreparedGeometryFactory;\n+\n+import java.io.*;\n+import java.util.*;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+class ExpressionBuilder {\n+    private static final AtomicLong longVal = new AtomicLong(1);\n+    private static final String AREA_PREFIX = \"in_area_\";\n+    private static final Set<String> allowedNames = new HashSet<>(Arrays.asList(\"edge\", \"Math\"));\n+    private static final boolean JANINO_DEBUG = Boolean.getBoolean(Scanner.SYSTEM_PROPERTY_SOURCE_DEBUGGING_ENABLE);\n+\n+    // TODO without a cache we get X% slower routing and Y% slower routingLM8. CH requests and preparation is unaffected\n+    // as cached weighting from preparation is used. This cache ensures that the first Weighting classes, typically the\n+    // ones specified in the profiles, are never removed regardless of how frequent other Weightings are created and accessed.\n+    // We only need to synchronize the get and put methods alone. E.g. we do not care for the race condition where\n+    // two identical classes are requested and one of them is overwritten. We could use CachingJavaSourceClassLoader from\n+    // Janino but 1. we would need to use a single compiler across threads and 2. the statements (for priority and speed)\n+    // are still unnecessarily created.\n+    private static final int CACHE_SIZE = Integer.getInteger(\"graphhopper.custom_weighting.cache_size\", 10);\n+    // TODO perf compare with ConcurrentHashMap, but I guess, if there is a difference at all, it is not big for small maps\n+    private static final Map<String, Class> CACHE = Collections.synchronizedMap(new HashMap<>(CACHE_SIZE));\n+\n+    // Introduce a dynamic cache to remember different Weighting classes, but throw away less frequently used classes.\n+    // Use accessOrder==true to remove oldest accessed entry, not oldest inserted.\n+    private static final int DYN_CACHE_SIZE = Integer.getInteger(\"graphhopper.custom_weighting.dynamic_cache_size\", 1000);\n+    private static final Map<String, Class> DYN_CACHE = Collections.synchronizedMap(\n+            new LinkedHashMap<String, Class>(DYN_CACHE_SIZE, 0.75f, true) {\n+                protected boolean removeEldestEntry(Map.Entry eldest) {\n+                    return size() > DYN_CACHE_SIZE;\n+                }\n+            });\n+\n+    /**\n+     * This method compiles a new subclass of CustomWeightingHelper composed from the provided CustomModel caches this\n+     * and returns an instance.\n+     */\n+    static CustomWeightingHelper create(CustomModel customModel, EncodedValueLookup lookup,\n+                                        double globalMaxSpeed, double maxSpeedFallback, DecimalEncodedValue avgSpeedEnc) {\n+        Java.CompilationUnit cu;\n+        try {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5cb073c89e7badcdb4e8aa42997f9b5a447e89ed"}, "originalPosition": 76}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTY5NTM3NQ==", "bodyText": "Unfortunately this is not possible as there is an uncatched exception in clazz.getDeclaredConstructor().newInstance()", "url": "https://github.com/graphhopper/graphhopper/pull/2209#discussion_r541695375", "createdAt": "2020-12-12T17:55:42Z", "author": {"login": "karussell"}, "path": "core/src/main/java/com/graphhopper/routing/weighting/custom/ExpressionBuilder.java", "diffHunk": "@@ -0,0 +1,382 @@\n+/*\n+ *  Licensed to GraphHopper GmbH under one or more contributor\n+ *  license agreements. See the NOTICE file distributed with this work for\n+ *  additional information regarding copyright ownership.\n+ *\n+ *  GraphHopper GmbH licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except in\n+ *  compliance with the License. You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package com.graphhopper.routing.weighting.custom;\n+\n+import com.graphhopper.json.geo.JsonFeature;\n+import com.graphhopper.routing.ev.DecimalEncodedValue;\n+import com.graphhopper.routing.ev.EncodedValue;\n+import com.graphhopper.routing.ev.EncodedValueLookup;\n+import com.graphhopper.routing.util.CustomModel;\n+import com.graphhopper.routing.util.EncodingManager;\n+import com.graphhopper.util.EdgeIteratorState;\n+import com.graphhopper.util.GHUtility;\n+import com.graphhopper.util.shapes.BBox;\n+import com.graphhopper.util.shapes.Polygon;\n+import org.codehaus.commons.compiler.CompileException;\n+import org.codehaus.commons.compiler.Location;\n+import org.codehaus.commons.compiler.io.Readers;\n+import org.codehaus.janino.Scanner;\n+import org.codehaus.janino.*;\n+import org.codehaus.janino.util.DeepCopier;\n+import org.locationtech.jts.geom.prep.PreparedGeometryFactory;\n+\n+import java.io.*;\n+import java.util.*;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+class ExpressionBuilder {\n+    private static final AtomicLong longVal = new AtomicLong(1);\n+    private static final String AREA_PREFIX = \"in_area_\";\n+    private static final Set<String> allowedNames = new HashSet<>(Arrays.asList(\"edge\", \"Math\"));\n+    private static final boolean JANINO_DEBUG = Boolean.getBoolean(Scanner.SYSTEM_PROPERTY_SOURCE_DEBUGGING_ENABLE);\n+\n+    // TODO without a cache we get X% slower routing and Y% slower routingLM8. CH requests and preparation is unaffected\n+    // as cached weighting from preparation is used. This cache ensures that the first Weighting classes, typically the\n+    // ones specified in the profiles, are never removed regardless of how frequent other Weightings are created and accessed.\n+    // We only need to synchronize the get and put methods alone. E.g. we do not care for the race condition where\n+    // two identical classes are requested and one of them is overwritten. We could use CachingJavaSourceClassLoader from\n+    // Janino but 1. we would need to use a single compiler across threads and 2. the statements (for priority and speed)\n+    // are still unnecessarily created.\n+    private static final int CACHE_SIZE = Integer.getInteger(\"graphhopper.custom_weighting.cache_size\", 10);\n+    // TODO perf compare with ConcurrentHashMap, but I guess, if there is a difference at all, it is not big for small maps\n+    private static final Map<String, Class> CACHE = Collections.synchronizedMap(new HashMap<>(CACHE_SIZE));\n+\n+    // Introduce a dynamic cache to remember different Weighting classes, but throw away less frequently used classes.\n+    // Use accessOrder==true to remove oldest accessed entry, not oldest inserted.\n+    private static final int DYN_CACHE_SIZE = Integer.getInteger(\"graphhopper.custom_weighting.dynamic_cache_size\", 1000);\n+    private static final Map<String, Class> DYN_CACHE = Collections.synchronizedMap(\n+            new LinkedHashMap<String, Class>(DYN_CACHE_SIZE, 0.75f, true) {\n+                protected boolean removeEldestEntry(Map.Entry eldest) {\n+                    return size() > DYN_CACHE_SIZE;\n+                }\n+            });\n+\n+    /**\n+     * This method compiles a new subclass of CustomWeightingHelper composed from the provided CustomModel caches this\n+     * and returns an instance.\n+     */\n+    static CustomWeightingHelper create(CustomModel customModel, EncodedValueLookup lookup,\n+                                        double globalMaxSpeed, double maxSpeedFallback, DecimalEncodedValue avgSpeedEnc) {\n+        Java.CompilationUnit cu;\n+        try {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTE2NzI3Mg=="}, "originalCommit": {"oid": "5cb073c89e7badcdb4e8aa42997f9b5a447e89ed"}, "originalPosition": 76}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTkyNDA3NA==", "bodyText": "Yes but this line is much further down. Hm it depends a bit on how fine-grained one wants to handle the exceptions, but I think this commit 66e4197 makes it cleaner, because the cache-logic is separated from the createClazz logic.", "url": "https://github.com/graphhopper/graphhopper/pull/2209#discussion_r541924074", "createdAt": "2020-12-13T13:18:47Z", "author": {"login": "easbar"}, "path": "core/src/main/java/com/graphhopper/routing/weighting/custom/ExpressionBuilder.java", "diffHunk": "@@ -0,0 +1,382 @@\n+/*\n+ *  Licensed to GraphHopper GmbH under one or more contributor\n+ *  license agreements. See the NOTICE file distributed with this work for\n+ *  additional information regarding copyright ownership.\n+ *\n+ *  GraphHopper GmbH licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except in\n+ *  compliance with the License. You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package com.graphhopper.routing.weighting.custom;\n+\n+import com.graphhopper.json.geo.JsonFeature;\n+import com.graphhopper.routing.ev.DecimalEncodedValue;\n+import com.graphhopper.routing.ev.EncodedValue;\n+import com.graphhopper.routing.ev.EncodedValueLookup;\n+import com.graphhopper.routing.util.CustomModel;\n+import com.graphhopper.routing.util.EncodingManager;\n+import com.graphhopper.util.EdgeIteratorState;\n+import com.graphhopper.util.GHUtility;\n+import com.graphhopper.util.shapes.BBox;\n+import com.graphhopper.util.shapes.Polygon;\n+import org.codehaus.commons.compiler.CompileException;\n+import org.codehaus.commons.compiler.Location;\n+import org.codehaus.commons.compiler.io.Readers;\n+import org.codehaus.janino.Scanner;\n+import org.codehaus.janino.*;\n+import org.codehaus.janino.util.DeepCopier;\n+import org.locationtech.jts.geom.prep.PreparedGeometryFactory;\n+\n+import java.io.*;\n+import java.util.*;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+class ExpressionBuilder {\n+    private static final AtomicLong longVal = new AtomicLong(1);\n+    private static final String AREA_PREFIX = \"in_area_\";\n+    private static final Set<String> allowedNames = new HashSet<>(Arrays.asList(\"edge\", \"Math\"));\n+    private static final boolean JANINO_DEBUG = Boolean.getBoolean(Scanner.SYSTEM_PROPERTY_SOURCE_DEBUGGING_ENABLE);\n+\n+    // TODO without a cache we get X% slower routing and Y% slower routingLM8. CH requests and preparation is unaffected\n+    // as cached weighting from preparation is used. This cache ensures that the first Weighting classes, typically the\n+    // ones specified in the profiles, are never removed regardless of how frequent other Weightings are created and accessed.\n+    // We only need to synchronize the get and put methods alone. E.g. we do not care for the race condition where\n+    // two identical classes are requested and one of them is overwritten. We could use CachingJavaSourceClassLoader from\n+    // Janino but 1. we would need to use a single compiler across threads and 2. the statements (for priority and speed)\n+    // are still unnecessarily created.\n+    private static final int CACHE_SIZE = Integer.getInteger(\"graphhopper.custom_weighting.cache_size\", 10);\n+    // TODO perf compare with ConcurrentHashMap, but I guess, if there is a difference at all, it is not big for small maps\n+    private static final Map<String, Class> CACHE = Collections.synchronizedMap(new HashMap<>(CACHE_SIZE));\n+\n+    // Introduce a dynamic cache to remember different Weighting classes, but throw away less frequently used classes.\n+    // Use accessOrder==true to remove oldest accessed entry, not oldest inserted.\n+    private static final int DYN_CACHE_SIZE = Integer.getInteger(\"graphhopper.custom_weighting.dynamic_cache_size\", 1000);\n+    private static final Map<String, Class> DYN_CACHE = Collections.synchronizedMap(\n+            new LinkedHashMap<String, Class>(DYN_CACHE_SIZE, 0.75f, true) {\n+                protected boolean removeEldestEntry(Map.Entry eldest) {\n+                    return size() > DYN_CACHE_SIZE;\n+                }\n+            });\n+\n+    /**\n+     * This method compiles a new subclass of CustomWeightingHelper composed from the provided CustomModel caches this\n+     * and returns an instance.\n+     */\n+    static CustomWeightingHelper create(CustomModel customModel, EncodedValueLookup lookup,\n+                                        double globalMaxSpeed, double maxSpeedFallback, DecimalEncodedValue avgSpeedEnc) {\n+        Java.CompilationUnit cu;\n+        try {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTE2NzI3Mg=="}, "originalCommit": {"oid": "5cb073c89e7badcdb4e8aa42997f9b5a447e89ed"}, "originalPosition": 76}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjMxNTU0OA==", "bodyText": "Ok, yes. Feel free to append this here.", "url": "https://github.com/graphhopper/graphhopper/pull/2209#discussion_r542315548", "createdAt": "2020-12-14T11:33:41Z", "author": {"login": "karussell"}, "path": "core/src/main/java/com/graphhopper/routing/weighting/custom/ExpressionBuilder.java", "diffHunk": "@@ -0,0 +1,382 @@\n+/*\n+ *  Licensed to GraphHopper GmbH under one or more contributor\n+ *  license agreements. See the NOTICE file distributed with this work for\n+ *  additional information regarding copyright ownership.\n+ *\n+ *  GraphHopper GmbH licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except in\n+ *  compliance with the License. You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package com.graphhopper.routing.weighting.custom;\n+\n+import com.graphhopper.json.geo.JsonFeature;\n+import com.graphhopper.routing.ev.DecimalEncodedValue;\n+import com.graphhopper.routing.ev.EncodedValue;\n+import com.graphhopper.routing.ev.EncodedValueLookup;\n+import com.graphhopper.routing.util.CustomModel;\n+import com.graphhopper.routing.util.EncodingManager;\n+import com.graphhopper.util.EdgeIteratorState;\n+import com.graphhopper.util.GHUtility;\n+import com.graphhopper.util.shapes.BBox;\n+import com.graphhopper.util.shapes.Polygon;\n+import org.codehaus.commons.compiler.CompileException;\n+import org.codehaus.commons.compiler.Location;\n+import org.codehaus.commons.compiler.io.Readers;\n+import org.codehaus.janino.Scanner;\n+import org.codehaus.janino.*;\n+import org.codehaus.janino.util.DeepCopier;\n+import org.locationtech.jts.geom.prep.PreparedGeometryFactory;\n+\n+import java.io.*;\n+import java.util.*;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+class ExpressionBuilder {\n+    private static final AtomicLong longVal = new AtomicLong(1);\n+    private static final String AREA_PREFIX = \"in_area_\";\n+    private static final Set<String> allowedNames = new HashSet<>(Arrays.asList(\"edge\", \"Math\"));\n+    private static final boolean JANINO_DEBUG = Boolean.getBoolean(Scanner.SYSTEM_PROPERTY_SOURCE_DEBUGGING_ENABLE);\n+\n+    // TODO without a cache we get X% slower routing and Y% slower routingLM8. CH requests and preparation is unaffected\n+    // as cached weighting from preparation is used. This cache ensures that the first Weighting classes, typically the\n+    // ones specified in the profiles, are never removed regardless of how frequent other Weightings are created and accessed.\n+    // We only need to synchronize the get and put methods alone. E.g. we do not care for the race condition where\n+    // two identical classes are requested and one of them is overwritten. We could use CachingJavaSourceClassLoader from\n+    // Janino but 1. we would need to use a single compiler across threads and 2. the statements (for priority and speed)\n+    // are still unnecessarily created.\n+    private static final int CACHE_SIZE = Integer.getInteger(\"graphhopper.custom_weighting.cache_size\", 10);\n+    // TODO perf compare with ConcurrentHashMap, but I guess, if there is a difference at all, it is not big for small maps\n+    private static final Map<String, Class> CACHE = Collections.synchronizedMap(new HashMap<>(CACHE_SIZE));\n+\n+    // Introduce a dynamic cache to remember different Weighting classes, but throw away less frequently used classes.\n+    // Use accessOrder==true to remove oldest accessed entry, not oldest inserted.\n+    private static final int DYN_CACHE_SIZE = Integer.getInteger(\"graphhopper.custom_weighting.dynamic_cache_size\", 1000);\n+    private static final Map<String, Class> DYN_CACHE = Collections.synchronizedMap(\n+            new LinkedHashMap<String, Class>(DYN_CACHE_SIZE, 0.75f, true) {\n+                protected boolean removeEldestEntry(Map.Entry eldest) {\n+                    return size() > DYN_CACHE_SIZE;\n+                }\n+            });\n+\n+    /**\n+     * This method compiles a new subclass of CustomWeightingHelper composed from the provided CustomModel caches this\n+     * and returns an instance.\n+     */\n+    static CustomWeightingHelper create(CustomModel customModel, EncodedValueLookup lookup,\n+                                        double globalMaxSpeed, double maxSpeedFallback, DecimalEncodedValue avgSpeedEnc) {\n+        Java.CompilationUnit cu;\n+        try {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTE2NzI3Mg=="}, "originalCommit": {"oid": "5cb073c89e7badcdb4e8aa42997f9b5a447e89ed"}, "originalPosition": 76}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjMzNTY5Mg==", "bodyText": "Done", "url": "https://github.com/graphhopper/graphhopper/pull/2209#discussion_r542335692", "createdAt": "2020-12-14T12:09:43Z", "author": {"login": "easbar"}, "path": "core/src/main/java/com/graphhopper/routing/weighting/custom/ExpressionBuilder.java", "diffHunk": "@@ -0,0 +1,382 @@\n+/*\n+ *  Licensed to GraphHopper GmbH under one or more contributor\n+ *  license agreements. See the NOTICE file distributed with this work for\n+ *  additional information regarding copyright ownership.\n+ *\n+ *  GraphHopper GmbH licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except in\n+ *  compliance with the License. You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package com.graphhopper.routing.weighting.custom;\n+\n+import com.graphhopper.json.geo.JsonFeature;\n+import com.graphhopper.routing.ev.DecimalEncodedValue;\n+import com.graphhopper.routing.ev.EncodedValue;\n+import com.graphhopper.routing.ev.EncodedValueLookup;\n+import com.graphhopper.routing.util.CustomModel;\n+import com.graphhopper.routing.util.EncodingManager;\n+import com.graphhopper.util.EdgeIteratorState;\n+import com.graphhopper.util.GHUtility;\n+import com.graphhopper.util.shapes.BBox;\n+import com.graphhopper.util.shapes.Polygon;\n+import org.codehaus.commons.compiler.CompileException;\n+import org.codehaus.commons.compiler.Location;\n+import org.codehaus.commons.compiler.io.Readers;\n+import org.codehaus.janino.Scanner;\n+import org.codehaus.janino.*;\n+import org.codehaus.janino.util.DeepCopier;\n+import org.locationtech.jts.geom.prep.PreparedGeometryFactory;\n+\n+import java.io.*;\n+import java.util.*;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+class ExpressionBuilder {\n+    private static final AtomicLong longVal = new AtomicLong(1);\n+    private static final String AREA_PREFIX = \"in_area_\";\n+    private static final Set<String> allowedNames = new HashSet<>(Arrays.asList(\"edge\", \"Math\"));\n+    private static final boolean JANINO_DEBUG = Boolean.getBoolean(Scanner.SYSTEM_PROPERTY_SOURCE_DEBUGGING_ENABLE);\n+\n+    // TODO without a cache we get X% slower routing and Y% slower routingLM8. CH requests and preparation is unaffected\n+    // as cached weighting from preparation is used. This cache ensures that the first Weighting classes, typically the\n+    // ones specified in the profiles, are never removed regardless of how frequent other Weightings are created and accessed.\n+    // We only need to synchronize the get and put methods alone. E.g. we do not care for the race condition where\n+    // two identical classes are requested and one of them is overwritten. We could use CachingJavaSourceClassLoader from\n+    // Janino but 1. we would need to use a single compiler across threads and 2. the statements (for priority and speed)\n+    // are still unnecessarily created.\n+    private static final int CACHE_SIZE = Integer.getInteger(\"graphhopper.custom_weighting.cache_size\", 10);\n+    // TODO perf compare with ConcurrentHashMap, but I guess, if there is a difference at all, it is not big for small maps\n+    private static final Map<String, Class> CACHE = Collections.synchronizedMap(new HashMap<>(CACHE_SIZE));\n+\n+    // Introduce a dynamic cache to remember different Weighting classes, but throw away less frequently used classes.\n+    // Use accessOrder==true to remove oldest accessed entry, not oldest inserted.\n+    private static final int DYN_CACHE_SIZE = Integer.getInteger(\"graphhopper.custom_weighting.dynamic_cache_size\", 1000);\n+    private static final Map<String, Class> DYN_CACHE = Collections.synchronizedMap(\n+            new LinkedHashMap<String, Class>(DYN_CACHE_SIZE, 0.75f, true) {\n+                protected boolean removeEldestEntry(Map.Entry eldest) {\n+                    return size() > DYN_CACHE_SIZE;\n+                }\n+            });\n+\n+    /**\n+     * This method compiles a new subclass of CustomWeightingHelper composed from the provided CustomModel caches this\n+     * and returns an instance.\n+     */\n+    static CustomWeightingHelper create(CustomModel customModel, EncodedValueLookup lookup,\n+                                        double globalMaxSpeed, double maxSpeedFallback, DecimalEncodedValue avgSpeedEnc) {\n+        Java.CompilationUnit cu;\n+        try {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTE2NzI3Mg=="}, "originalCommit": {"oid": "5cb073c89e7badcdb4e8aa42997f9b5a447e89ed"}, "originalPosition": 76}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM5ODkwNjE1OnYy", "diffSide": "RIGHT", "path": "docs/core/profiles.md", "isResolved": true, "comments": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMVQxOTozMzo0OFrOIEISSQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNFQxMjo0ODowMFrOIFO1Tg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTIwMDk2OQ==", "bodyText": "What do you mean here?", "url": "https://github.com/graphhopper/graphhopper/pull/2209#discussion_r541200969", "createdAt": "2020-12-11T19:33:48Z", "author": {"login": "easbar"}, "path": "docs/core/profiles.md", "diffHunk": "@@ -151,96 +153,112 @@ can be influenced by the different fields of such a custom model.\n   \n #### Customizing `speed`\n \n-For every edge a default speed is inherited from the base vehicle, but you have multiple options to adjust it.\n+For every road segment a default speed is inherited from the base vehicle, but you have multiple options to adjust it.\n The first thing you can do is rescaling the default speeds using the `speed_factor` section. For example this is how you\n-can reduce the the speed of every edge that has the value 'motorway' for the category 'road_class' to fifty percent of \n+can reduce the speed of every road segment that has the value MOTORWAY for the category 'road_class' to fifty percent of \n the default speed that is normally used by the base vehicle for this road class:\n ```yaml\n speed_factor:\n-  road_class: {motorway: 0.5}\n-```  \n-Note that `road_class: {motorway: 0.5}` is an alternative YAML notation that is equivalent to:\n+  road_class == MOTORWAY: 0.5\n+```\n+\n+You can also change the speed factor for multiple road classes like this\n ```yaml\n speed_factor:\n-  road_class:\n-    motorway: 0.5\n+  road_class == MOTORWAY: 0.5\n+  road_class == PRIMARY || road_class == TERTIARY: 0.7\n ```\n \n-You can also setup speed factors for multiple road classes like this\n+Please note the OR operator `||` that says that if one of the expressions is true the value 0.7 is used.\n+\n+or use multiple categories to influence the speed factor\n ```yaml\n speed_factor:\n-  road_class: {motorway: 0.5, primary: 0.7, tertiary: 0.9}\n+  road_class == MOTORWAY: 0.5\n+  road_environment == TUNNEL: 0.8\n ```\n \n-and use multiple categories to influence the speed factor\n+You can use only two operators `==` (equality) and `!=` inequality.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5cb073c89e7badcdb4e8aa42997f9b5a447e89ed"}, "originalPosition": 79}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTY5NTAxNw==", "bodyText": "encoded values cannot be used with other operators like > or <. See the updated documentation.", "url": "https://github.com/graphhopper/graphhopper/pull/2209#discussion_r541695017", "createdAt": "2020-12-12T17:54:49Z", "author": {"login": "karussell"}, "path": "docs/core/profiles.md", "diffHunk": "@@ -151,96 +153,112 @@ can be influenced by the different fields of such a custom model.\n   \n #### Customizing `speed`\n \n-For every edge a default speed is inherited from the base vehicle, but you have multiple options to adjust it.\n+For every road segment a default speed is inherited from the base vehicle, but you have multiple options to adjust it.\n The first thing you can do is rescaling the default speeds using the `speed_factor` section. For example this is how you\n-can reduce the the speed of every edge that has the value 'motorway' for the category 'road_class' to fifty percent of \n+can reduce the speed of every road segment that has the value MOTORWAY for the category 'road_class' to fifty percent of \n the default speed that is normally used by the base vehicle for this road class:\n ```yaml\n speed_factor:\n-  road_class: {motorway: 0.5}\n-```  \n-Note that `road_class: {motorway: 0.5}` is an alternative YAML notation that is equivalent to:\n+  road_class == MOTORWAY: 0.5\n+```\n+\n+You can also change the speed factor for multiple road classes like this\n ```yaml\n speed_factor:\n-  road_class:\n-    motorway: 0.5\n+  road_class == MOTORWAY: 0.5\n+  road_class == PRIMARY || road_class == TERTIARY: 0.7\n ```\n \n-You can also setup speed factors for multiple road classes like this\n+Please note the OR operator `||` that says that if one of the expressions is true the value 0.7 is used.\n+\n+or use multiple categories to influence the speed factor\n ```yaml\n speed_factor:\n-  road_class: {motorway: 0.5, primary: 0.7, tertiary: 0.9}\n+  road_class == MOTORWAY: 0.5\n+  road_environment == TUNNEL: 0.8\n ```\n \n-and use multiple categories to influence the speed factor\n+You can use only two operators `==` (equality) and `!=` inequality.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTIwMDk2OQ=="}, "originalCommit": {"oid": "5cb073c89e7badcdb4e8aa42997f9b5a447e89ed"}, "originalPosition": 79}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTkxODUzNA==", "bodyText": "Ah ok but I can still use || and &&? I was a bit confused because this sentence sounds a bit like all I can do is use one condition with == or != even though in the example above there is || as well.", "url": "https://github.com/graphhopper/graphhopper/pull/2209#discussion_r541918534", "createdAt": "2020-12-13T12:46:32Z", "author": {"login": "easbar"}, "path": "docs/core/profiles.md", "diffHunk": "@@ -151,96 +153,112 @@ can be influenced by the different fields of such a custom model.\n   \n #### Customizing `speed`\n \n-For every edge a default speed is inherited from the base vehicle, but you have multiple options to adjust it.\n+For every road segment a default speed is inherited from the base vehicle, but you have multiple options to adjust it.\n The first thing you can do is rescaling the default speeds using the `speed_factor` section. For example this is how you\n-can reduce the the speed of every edge that has the value 'motorway' for the category 'road_class' to fifty percent of \n+can reduce the speed of every road segment that has the value MOTORWAY for the category 'road_class' to fifty percent of \n the default speed that is normally used by the base vehicle for this road class:\n ```yaml\n speed_factor:\n-  road_class: {motorway: 0.5}\n-```  \n-Note that `road_class: {motorway: 0.5}` is an alternative YAML notation that is equivalent to:\n+  road_class == MOTORWAY: 0.5\n+```\n+\n+You can also change the speed factor for multiple road classes like this\n ```yaml\n speed_factor:\n-  road_class:\n-    motorway: 0.5\n+  road_class == MOTORWAY: 0.5\n+  road_class == PRIMARY || road_class == TERTIARY: 0.7\n ```\n \n-You can also setup speed factors for multiple road classes like this\n+Please note the OR operator `||` that says that if one of the expressions is true the value 0.7 is used.\n+\n+or use multiple categories to influence the speed factor\n ```yaml\n speed_factor:\n-  road_class: {motorway: 0.5, primary: 0.7, tertiary: 0.9}\n+  road_class == MOTORWAY: 0.5\n+  road_environment == TUNNEL: 0.8\n ```\n \n-and use multiple categories to influence the speed factor\n+You can use only two operators `==` (equality) and `!=` inequality.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTIwMDk2OQ=="}, "originalCommit": {"oid": "5cb073c89e7badcdb4e8aa42997f9b5a447e89ed"}, "originalPosition": 79}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjMxNDQ0Mg==", "bodyText": "Ah, yes boolean ops are still possible for all boolean operands.", "url": "https://github.com/graphhopper/graphhopper/pull/2209#discussion_r542314442", "createdAt": "2020-12-14T11:31:43Z", "author": {"login": "karussell"}, "path": "docs/core/profiles.md", "diffHunk": "@@ -151,96 +153,112 @@ can be influenced by the different fields of such a custom model.\n   \n #### Customizing `speed`\n \n-For every edge a default speed is inherited from the base vehicle, but you have multiple options to adjust it.\n+For every road segment a default speed is inherited from the base vehicle, but you have multiple options to adjust it.\n The first thing you can do is rescaling the default speeds using the `speed_factor` section. For example this is how you\n-can reduce the the speed of every edge that has the value 'motorway' for the category 'road_class' to fifty percent of \n+can reduce the speed of every road segment that has the value MOTORWAY for the category 'road_class' to fifty percent of \n the default speed that is normally used by the base vehicle for this road class:\n ```yaml\n speed_factor:\n-  road_class: {motorway: 0.5}\n-```  \n-Note that `road_class: {motorway: 0.5}` is an alternative YAML notation that is equivalent to:\n+  road_class == MOTORWAY: 0.5\n+```\n+\n+You can also change the speed factor for multiple road classes like this\n ```yaml\n speed_factor:\n-  road_class:\n-    motorway: 0.5\n+  road_class == MOTORWAY: 0.5\n+  road_class == PRIMARY || road_class == TERTIARY: 0.7\n ```\n \n-You can also setup speed factors for multiple road classes like this\n+Please note the OR operator `||` that says that if one of the expressions is true the value 0.7 is used.\n+\n+or use multiple categories to influence the speed factor\n ```yaml\n speed_factor:\n-  road_class: {motorway: 0.5, primary: 0.7, tertiary: 0.9}\n+  road_class == MOTORWAY: 0.5\n+  road_environment == TUNNEL: 0.8\n ```\n \n-and use multiple categories to influence the speed factor\n+You can use only two operators `==` (equality) and `!=` inequality.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTIwMDk2OQ=="}, "originalCommit": {"oid": "5cb073c89e7badcdb4e8aa42997f9b5a447e89ed"}, "originalPosition": 79}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjM0MzMwMQ==", "bodyText": "And brackets () and negation ! are also fine?", "url": "https://github.com/graphhopper/graphhopper/pull/2209#discussion_r542343301", "createdAt": "2020-12-14T12:23:55Z", "author": {"login": "easbar"}, "path": "docs/core/profiles.md", "diffHunk": "@@ -151,96 +153,112 @@ can be influenced by the different fields of such a custom model.\n   \n #### Customizing `speed`\n \n-For every edge a default speed is inherited from the base vehicle, but you have multiple options to adjust it.\n+For every road segment a default speed is inherited from the base vehicle, but you have multiple options to adjust it.\n The first thing you can do is rescaling the default speeds using the `speed_factor` section. For example this is how you\n-can reduce the the speed of every edge that has the value 'motorway' for the category 'road_class' to fifty percent of \n+can reduce the speed of every road segment that has the value MOTORWAY for the category 'road_class' to fifty percent of \n the default speed that is normally used by the base vehicle for this road class:\n ```yaml\n speed_factor:\n-  road_class: {motorway: 0.5}\n-```  \n-Note that `road_class: {motorway: 0.5}` is an alternative YAML notation that is equivalent to:\n+  road_class == MOTORWAY: 0.5\n+```\n+\n+You can also change the speed factor for multiple road classes like this\n ```yaml\n speed_factor:\n-  road_class:\n-    motorway: 0.5\n+  road_class == MOTORWAY: 0.5\n+  road_class == PRIMARY || road_class == TERTIARY: 0.7\n ```\n \n-You can also setup speed factors for multiple road classes like this\n+Please note the OR operator `||` that says that if one of the expressions is true the value 0.7 is used.\n+\n+or use multiple categories to influence the speed factor\n ```yaml\n speed_factor:\n-  road_class: {motorway: 0.5, primary: 0.7, tertiary: 0.9}\n+  road_class == MOTORWAY: 0.5\n+  road_environment == TUNNEL: 0.8\n ```\n \n-and use multiple categories to influence the speed factor\n+You can use only two operators `==` (equality) and `!=` inequality.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTIwMDk2OQ=="}, "originalCommit": {"oid": "5cb073c89e7badcdb4e8aa42997f9b5a447e89ed"}, "originalPosition": 79}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjM1MzM3NA==", "bodyText": "Yes :) ... any Java stuff. Should we remove this sentence as it seems to be confusing?", "url": "https://github.com/graphhopper/graphhopper/pull/2209#discussion_r542353374", "createdAt": "2020-12-14T12:42:03Z", "author": {"login": "karussell"}, "path": "docs/core/profiles.md", "diffHunk": "@@ -151,96 +153,112 @@ can be influenced by the different fields of such a custom model.\n   \n #### Customizing `speed`\n \n-For every edge a default speed is inherited from the base vehicle, but you have multiple options to adjust it.\n+For every road segment a default speed is inherited from the base vehicle, but you have multiple options to adjust it.\n The first thing you can do is rescaling the default speeds using the `speed_factor` section. For example this is how you\n-can reduce the the speed of every edge that has the value 'motorway' for the category 'road_class' to fifty percent of \n+can reduce the speed of every road segment that has the value MOTORWAY for the category 'road_class' to fifty percent of \n the default speed that is normally used by the base vehicle for this road class:\n ```yaml\n speed_factor:\n-  road_class: {motorway: 0.5}\n-```  \n-Note that `road_class: {motorway: 0.5}` is an alternative YAML notation that is equivalent to:\n+  road_class == MOTORWAY: 0.5\n+```\n+\n+You can also change the speed factor for multiple road classes like this\n ```yaml\n speed_factor:\n-  road_class:\n-    motorway: 0.5\n+  road_class == MOTORWAY: 0.5\n+  road_class == PRIMARY || road_class == TERTIARY: 0.7\n ```\n \n-You can also setup speed factors for multiple road classes like this\n+Please note the OR operator `||` that says that if one of the expressions is true the value 0.7 is used.\n+\n+or use multiple categories to influence the speed factor\n ```yaml\n speed_factor:\n-  road_class: {motorway: 0.5, primary: 0.7, tertiary: 0.9}\n+  road_class == MOTORWAY: 0.5\n+  road_environment == TUNNEL: 0.8\n ```\n \n-and use multiple categories to influence the speed factor\n+You can use only two operators `==` (equality) and `!=` inequality.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTIwMDk2OQ=="}, "originalCommit": {"oid": "5cb073c89e7badcdb4e8aa42997f9b5a447e89ed"}, "originalPosition": 79}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjM1NjgxNA==", "bodyText": "Yes, maybe better remove it. To me it would have been clear if the docs said that the keys in the yaml file are boolean conditions written in Java language. For people who do not know Java we could add a short section that briefly explains ==,!=,&& and || to get them started.", "url": "https://github.com/graphhopper/graphhopper/pull/2209#discussion_r542356814", "createdAt": "2020-12-14T12:48:00Z", "author": {"login": "easbar"}, "path": "docs/core/profiles.md", "diffHunk": "@@ -151,96 +153,112 @@ can be influenced by the different fields of such a custom model.\n   \n #### Customizing `speed`\n \n-For every edge a default speed is inherited from the base vehicle, but you have multiple options to adjust it.\n+For every road segment a default speed is inherited from the base vehicle, but you have multiple options to adjust it.\n The first thing you can do is rescaling the default speeds using the `speed_factor` section. For example this is how you\n-can reduce the the speed of every edge that has the value 'motorway' for the category 'road_class' to fifty percent of \n+can reduce the speed of every road segment that has the value MOTORWAY for the category 'road_class' to fifty percent of \n the default speed that is normally used by the base vehicle for this road class:\n ```yaml\n speed_factor:\n-  road_class: {motorway: 0.5}\n-```  \n-Note that `road_class: {motorway: 0.5}` is an alternative YAML notation that is equivalent to:\n+  road_class == MOTORWAY: 0.5\n+```\n+\n+You can also change the speed factor for multiple road classes like this\n ```yaml\n speed_factor:\n-  road_class:\n-    motorway: 0.5\n+  road_class == MOTORWAY: 0.5\n+  road_class == PRIMARY || road_class == TERTIARY: 0.7\n ```\n \n-You can also setup speed factors for multiple road classes like this\n+Please note the OR operator `||` that says that if one of the expressions is true the value 0.7 is used.\n+\n+or use multiple categories to influence the speed factor\n ```yaml\n speed_factor:\n-  road_class: {motorway: 0.5, primary: 0.7, tertiary: 0.9}\n+  road_class == MOTORWAY: 0.5\n+  road_environment == TUNNEL: 0.8\n ```\n \n-and use multiple categories to influence the speed factor\n+You can use only two operators `==` (equality) and `!=` inequality.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTIwMDk2OQ=="}, "originalCommit": {"oid": "5cb073c89e7badcdb4e8aa42997f9b5a447e89ed"}, "originalPosition": 79}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM5ODk2NzE1OnYy", "diffSide": "RIGHT", "path": "docs/core/profiles.md", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMVQxOTo0Mzo0OFrOIEI4Nw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMlQxNzo0ODozMVrOIEmSbw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTIxMDY3OQ==", "bodyText": "I find this hard to understand. First you introduce first_match as something that can be used to avoid the multiplication rule, but in this example we multiply everything with 0.5 again. Would you not rather set\nfirst_match:\n    road_environment == TUNNEL: 0.4\n    true: 0.3\n?\nMaybe we can find a better example where it makes sense to combine the default expressions with first_match?", "url": "https://github.com/graphhopper/graphhopper/pull/2209#discussion_r541210679", "createdAt": "2020-12-11T19:43:48Z", "author": {"login": "easbar"}, "path": "docs/core/profiles.md", "diffHunk": "@@ -151,96 +153,112 @@ can be influenced by the different fields of such a custom model.\n   \n #### Customizing `speed`\n \n-For every edge a default speed is inherited from the base vehicle, but you have multiple options to adjust it.\n+For every road segment a default speed is inherited from the base vehicle, but you have multiple options to adjust it.\n The first thing you can do is rescaling the default speeds using the `speed_factor` section. For example this is how you\n-can reduce the the speed of every edge that has the value 'motorway' for the category 'road_class' to fifty percent of \n+can reduce the speed of every road segment that has the value MOTORWAY for the category 'road_class' to fifty percent of \n the default speed that is normally used by the base vehicle for this road class:\n ```yaml\n speed_factor:\n-  road_class: {motorway: 0.5}\n-```  \n-Note that `road_class: {motorway: 0.5}` is an alternative YAML notation that is equivalent to:\n+  road_class == MOTORWAY: 0.5\n+```\n+\n+You can also change the speed factor for multiple road classes like this\n ```yaml\n speed_factor:\n-  road_class:\n-    motorway: 0.5\n+  road_class == MOTORWAY: 0.5\n+  road_class == PRIMARY || road_class == TERTIARY: 0.7\n ```\n \n-You can also setup speed factors for multiple road classes like this\n+Please note the OR operator `||` that says that if one of the expressions is true the value 0.7 is used.\n+\n+or use multiple categories to influence the speed factor\n ```yaml\n speed_factor:\n-  road_class: {motorway: 0.5, primary: 0.7, tertiary: 0.9}\n+  road_class == MOTORWAY: 0.5\n+  road_environment == TUNNEL: 0.8\n ```\n \n-and use multiple categories to influence the speed factor\n+You can use only two operators `==` (equality) and `!=` inequality.\n+\n+If a road segment matches multiple expressions the speed factor values will be multiplied. For example, here the speed factor of\n+a road segment that has `road_class==MOTORWAY` will be `0.5`, the speed factor of a road segment that additionally has\n+`road_environment==TUNNEL` will be `0.4` and the speed factor of a road segment that has `road_class==SECONDARY` and\n+`road_environment==TUNNEL` will be `0.8`. You can avoid this by using the \"first_match\" directive:\n+\n ```yaml\n speed_factor:\n-  road_class: {motorway: 0.5}\n-  road_environment: {tunnel: 0.8}\n+  first_match:\n+    road_class == MOTORWAY: 0.5\n+    road_environment == TUNNEL: 0.8\n ```\n \n-If an edge matches multiple rules the speed factor values will be multiplied. For example, here the speed factor of \n-a road segment that has `road_class=motorway` will be `0.5`, the speed factor of a road segment that additionally has \n-`road_environment=tunnel` will be `0.4` and the speed factor of a road segment that has `road_class=secondary` and \n-`road_environment=tunnel` will be `0.8`.\n+Now even if a road segment fulfills both conditions only the first will be used and no multiplication happens. If you\n+know a programming language than the previous statements are \"if\" clauses and expressions under \"first_match\" are\n+\"if-then-else-if\" clauses.\n \n-Instead of setting the speed factors for certain values you can instead set the speed factors for all *other* values using\n-as special key (`\"*\"`), like this:\n+Instead of setting the speed factors for certain values you can instead set the speed factors for all *other* values\n+using the unconditional expression `true`:\n ```yaml\n-speed_factor: \n-  road_class: {\"*\": 0.5}\n-  road_environment: {tunnel: 0.8, \"*\": 0.6}\n+speed_factor:\n+  true: 0.5\n+  first_match:\n+    road_environment == TUNNEL: 0.8\n+    true: 0.6\n ```\n \n-So in this example we set a speed factor of `0.5` regardless of the `road_class` and all `road_environment` values yield\n-a speed factor of `0.6` *except* `tunnel` which gets a speed factor of `0.8`. And as mentioned above for edges that match\n-multiple of these rules the different factors get multiplied.\n+This is usually used in the `first_match' directive.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5cb073c89e7badcdb4e8aa42997f9b5a447e89ed"}, "originalPosition": 121}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTIxNjY4NQ==", "bodyText": "Also I wonder why we only have first_match? What if we need multiple explicit rules, like\nfirst_match:\n    road_environment == TUNNEL: 0.4\nfirst_match:\n    surface == GRAVEL: 0.7", "url": "https://github.com/graphhopper/graphhopper/pull/2209#discussion_r541216685", "createdAt": "2020-12-11T19:49:56Z", "author": {"login": "easbar"}, "path": "docs/core/profiles.md", "diffHunk": "@@ -151,96 +153,112 @@ can be influenced by the different fields of such a custom model.\n   \n #### Customizing `speed`\n \n-For every edge a default speed is inherited from the base vehicle, but you have multiple options to adjust it.\n+For every road segment a default speed is inherited from the base vehicle, but you have multiple options to adjust it.\n The first thing you can do is rescaling the default speeds using the `speed_factor` section. For example this is how you\n-can reduce the the speed of every edge that has the value 'motorway' for the category 'road_class' to fifty percent of \n+can reduce the speed of every road segment that has the value MOTORWAY for the category 'road_class' to fifty percent of \n the default speed that is normally used by the base vehicle for this road class:\n ```yaml\n speed_factor:\n-  road_class: {motorway: 0.5}\n-```  \n-Note that `road_class: {motorway: 0.5}` is an alternative YAML notation that is equivalent to:\n+  road_class == MOTORWAY: 0.5\n+```\n+\n+You can also change the speed factor for multiple road classes like this\n ```yaml\n speed_factor:\n-  road_class:\n-    motorway: 0.5\n+  road_class == MOTORWAY: 0.5\n+  road_class == PRIMARY || road_class == TERTIARY: 0.7\n ```\n \n-You can also setup speed factors for multiple road classes like this\n+Please note the OR operator `||` that says that if one of the expressions is true the value 0.7 is used.\n+\n+or use multiple categories to influence the speed factor\n ```yaml\n speed_factor:\n-  road_class: {motorway: 0.5, primary: 0.7, tertiary: 0.9}\n+  road_class == MOTORWAY: 0.5\n+  road_environment == TUNNEL: 0.8\n ```\n \n-and use multiple categories to influence the speed factor\n+You can use only two operators `==` (equality) and `!=` inequality.\n+\n+If a road segment matches multiple expressions the speed factor values will be multiplied. For example, here the speed factor of\n+a road segment that has `road_class==MOTORWAY` will be `0.5`, the speed factor of a road segment that additionally has\n+`road_environment==TUNNEL` will be `0.4` and the speed factor of a road segment that has `road_class==SECONDARY` and\n+`road_environment==TUNNEL` will be `0.8`. You can avoid this by using the \"first_match\" directive:\n+\n ```yaml\n speed_factor:\n-  road_class: {motorway: 0.5}\n-  road_environment: {tunnel: 0.8}\n+  first_match:\n+    road_class == MOTORWAY: 0.5\n+    road_environment == TUNNEL: 0.8\n ```\n \n-If an edge matches multiple rules the speed factor values will be multiplied. For example, here the speed factor of \n-a road segment that has `road_class=motorway` will be `0.5`, the speed factor of a road segment that additionally has \n-`road_environment=tunnel` will be `0.4` and the speed factor of a road segment that has `road_class=secondary` and \n-`road_environment=tunnel` will be `0.8`.\n+Now even if a road segment fulfills both conditions only the first will be used and no multiplication happens. If you\n+know a programming language than the previous statements are \"if\" clauses and expressions under \"first_match\" are\n+\"if-then-else-if\" clauses.\n \n-Instead of setting the speed factors for certain values you can instead set the speed factors for all *other* values using\n-as special key (`\"*\"`), like this:\n+Instead of setting the speed factors for certain values you can instead set the speed factors for all *other* values\n+using the unconditional expression `true`:\n ```yaml\n-speed_factor: \n-  road_class: {\"*\": 0.5}\n-  road_environment: {tunnel: 0.8, \"*\": 0.6}\n+speed_factor:\n+  true: 0.5\n+  first_match:\n+    road_environment == TUNNEL: 0.8\n+    true: 0.6\n ```\n \n-So in this example we set a speed factor of `0.5` regardless of the `road_class` and all `road_environment` values yield\n-a speed factor of `0.6` *except* `tunnel` which gets a speed factor of `0.8`. And as mentioned above for edges that match\n-multiple of these rules the different factors get multiplied.\n+This is usually used in the `first_match' directive.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTIxMDY3OQ=="}, "originalCommit": {"oid": "5cb073c89e7badcdb4e8aa42997f9b5a447e89ed"}, "originalPosition": 121}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTY5MjUyNw==", "bodyText": "Oh, you are right the example in profiles.md is ugly. Have a look into very_custom.yml where this makes more sense. Basically instead of:\npriority:\n  max_height < 3.8: 0\n  max_width < 2.5: 0\n  road_class == MOTORWAY: 1\n  road_class == PRIMARY: 0.5\n  road_class != MOTORWAY && road_class != PRIMARY: 0.9\n  toll != NO: 0.5\nyou can do:\npriority:\n  max_height < 3.8: 0\n  max_width < 2.5: 0\n  first_match:\n    road_class == MOTORWAY: 1\n    road_class == PRIMARY: 0.5\n    true: 0.9\n  toll != NO: 0.5\n(would default instead of true make it more readable?)\n\nAlso I wonder why we only have first_match? What if we need multiple explicit rules, like\n\nWhat do you have for a use case in mind? Your specific example could be converted into:\nroad_environment == TUNNEL: 0.4\nsurface == GRAVEL: 0.7\nMultiple first_matches are possible via:\nfirst_match_1:\n    road_environment == TUNNEL: 0.4\n    some_other_expression: 0.3\nfirst_match_2:\n    surface == GRAVEL: 0.7\n    some_other_expression_2: 0.3\nSee the updated documentation", "url": "https://github.com/graphhopper/graphhopper/pull/2209#discussion_r541692527", "createdAt": "2020-12-12T17:48:31Z", "author": {"login": "karussell"}, "path": "docs/core/profiles.md", "diffHunk": "@@ -151,96 +153,112 @@ can be influenced by the different fields of such a custom model.\n   \n #### Customizing `speed`\n \n-For every edge a default speed is inherited from the base vehicle, but you have multiple options to adjust it.\n+For every road segment a default speed is inherited from the base vehicle, but you have multiple options to adjust it.\n The first thing you can do is rescaling the default speeds using the `speed_factor` section. For example this is how you\n-can reduce the the speed of every edge that has the value 'motorway' for the category 'road_class' to fifty percent of \n+can reduce the speed of every road segment that has the value MOTORWAY for the category 'road_class' to fifty percent of \n the default speed that is normally used by the base vehicle for this road class:\n ```yaml\n speed_factor:\n-  road_class: {motorway: 0.5}\n-```  \n-Note that `road_class: {motorway: 0.5}` is an alternative YAML notation that is equivalent to:\n+  road_class == MOTORWAY: 0.5\n+```\n+\n+You can also change the speed factor for multiple road classes like this\n ```yaml\n speed_factor:\n-  road_class:\n-    motorway: 0.5\n+  road_class == MOTORWAY: 0.5\n+  road_class == PRIMARY || road_class == TERTIARY: 0.7\n ```\n \n-You can also setup speed factors for multiple road classes like this\n+Please note the OR operator `||` that says that if one of the expressions is true the value 0.7 is used.\n+\n+or use multiple categories to influence the speed factor\n ```yaml\n speed_factor:\n-  road_class: {motorway: 0.5, primary: 0.7, tertiary: 0.9}\n+  road_class == MOTORWAY: 0.5\n+  road_environment == TUNNEL: 0.8\n ```\n \n-and use multiple categories to influence the speed factor\n+You can use only two operators `==` (equality) and `!=` inequality.\n+\n+If a road segment matches multiple expressions the speed factor values will be multiplied. For example, here the speed factor of\n+a road segment that has `road_class==MOTORWAY` will be `0.5`, the speed factor of a road segment that additionally has\n+`road_environment==TUNNEL` will be `0.4` and the speed factor of a road segment that has `road_class==SECONDARY` and\n+`road_environment==TUNNEL` will be `0.8`. You can avoid this by using the \"first_match\" directive:\n+\n ```yaml\n speed_factor:\n-  road_class: {motorway: 0.5}\n-  road_environment: {tunnel: 0.8}\n+  first_match:\n+    road_class == MOTORWAY: 0.5\n+    road_environment == TUNNEL: 0.8\n ```\n \n-If an edge matches multiple rules the speed factor values will be multiplied. For example, here the speed factor of \n-a road segment that has `road_class=motorway` will be `0.5`, the speed factor of a road segment that additionally has \n-`road_environment=tunnel` will be `0.4` and the speed factor of a road segment that has `road_class=secondary` and \n-`road_environment=tunnel` will be `0.8`.\n+Now even if a road segment fulfills both conditions only the first will be used and no multiplication happens. If you\n+know a programming language than the previous statements are \"if\" clauses and expressions under \"first_match\" are\n+\"if-then-else-if\" clauses.\n \n-Instead of setting the speed factors for certain values you can instead set the speed factors for all *other* values using\n-as special key (`\"*\"`), like this:\n+Instead of setting the speed factors for certain values you can instead set the speed factors for all *other* values\n+using the unconditional expression `true`:\n ```yaml\n-speed_factor: \n-  road_class: {\"*\": 0.5}\n-  road_environment: {tunnel: 0.8, \"*\": 0.6}\n+speed_factor:\n+  true: 0.5\n+  first_match:\n+    road_environment == TUNNEL: 0.8\n+    true: 0.6\n ```\n \n-So in this example we set a speed factor of `0.5` regardless of the `road_class` and all `road_environment` values yield\n-a speed factor of `0.6` *except* `tunnel` which gets a speed factor of `0.8`. And as mentioned above for edges that match\n-multiple of these rules the different factors get multiplied.\n+This is usually used in the `first_match' directive.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTIxMDY3OQ=="}, "originalCommit": {"oid": "5cb073c89e7badcdb4e8aa42997f9b5a447e89ed"}, "originalPosition": 121}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM5ODk4MjQ5OnYy", "diffSide": "RIGHT", "path": "docs/core/profiles.md", "isResolved": true, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMVQxOTo0NjoyMVrOIEJB-Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNFQxMTozODoxMlrOIFMewQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTIxMzE3Nw==", "bodyText": "Using true as unconditional expression probably makes sense for a programmer who understood that the left side of each entry is a boolean expression, but otherwise its probably hard to understand (compared to something like default: 0.5, but of course this requires another pre-processor (which could also convert || -> OR, && -> AND.. Not sure...", "url": "https://github.com/graphhopper/graphhopper/pull/2209#discussion_r541213177", "createdAt": "2020-12-11T19:46:21Z", "author": {"login": "easbar"}, "path": "docs/core/profiles.md", "diffHunk": "@@ -151,96 +153,112 @@ can be influenced by the different fields of such a custom model.\n   \n #### Customizing `speed`\n \n-For every edge a default speed is inherited from the base vehicle, but you have multiple options to adjust it.\n+For every road segment a default speed is inherited from the base vehicle, but you have multiple options to adjust it.\n The first thing you can do is rescaling the default speeds using the `speed_factor` section. For example this is how you\n-can reduce the the speed of every edge that has the value 'motorway' for the category 'road_class' to fifty percent of \n+can reduce the speed of every road segment that has the value MOTORWAY for the category 'road_class' to fifty percent of \n the default speed that is normally used by the base vehicle for this road class:\n ```yaml\n speed_factor:\n-  road_class: {motorway: 0.5}\n-```  \n-Note that `road_class: {motorway: 0.5}` is an alternative YAML notation that is equivalent to:\n+  road_class == MOTORWAY: 0.5\n+```\n+\n+You can also change the speed factor for multiple road classes like this\n ```yaml\n speed_factor:\n-  road_class:\n-    motorway: 0.5\n+  road_class == MOTORWAY: 0.5\n+  road_class == PRIMARY || road_class == TERTIARY: 0.7\n ```\n \n-You can also setup speed factors for multiple road classes like this\n+Please note the OR operator `||` that says that if one of the expressions is true the value 0.7 is used.\n+\n+or use multiple categories to influence the speed factor\n ```yaml\n speed_factor:\n-  road_class: {motorway: 0.5, primary: 0.7, tertiary: 0.9}\n+  road_class == MOTORWAY: 0.5\n+  road_environment == TUNNEL: 0.8\n ```\n \n-and use multiple categories to influence the speed factor\n+You can use only two operators `==` (equality) and `!=` inequality.\n+\n+If a road segment matches multiple expressions the speed factor values will be multiplied. For example, here the speed factor of\n+a road segment that has `road_class==MOTORWAY` will be `0.5`, the speed factor of a road segment that additionally has\n+`road_environment==TUNNEL` will be `0.4` and the speed factor of a road segment that has `road_class==SECONDARY` and\n+`road_environment==TUNNEL` will be `0.8`. You can avoid this by using the \"first_match\" directive:\n+\n ```yaml\n speed_factor:\n-  road_class: {motorway: 0.5}\n-  road_environment: {tunnel: 0.8}\n+  first_match:\n+    road_class == MOTORWAY: 0.5\n+    road_environment == TUNNEL: 0.8\n ```\n \n-If an edge matches multiple rules the speed factor values will be multiplied. For example, here the speed factor of \n-a road segment that has `road_class=motorway` will be `0.5`, the speed factor of a road segment that additionally has \n-`road_environment=tunnel` will be `0.4` and the speed factor of a road segment that has `road_class=secondary` and \n-`road_environment=tunnel` will be `0.8`.\n+Now even if a road segment fulfills both conditions only the first will be used and no multiplication happens. If you\n+know a programming language than the previous statements are \"if\" clauses and expressions under \"first_match\" are\n+\"if-then-else-if\" clauses.\n \n-Instead of setting the speed factors for certain values you can instead set the speed factors for all *other* values using\n-as special key (`\"*\"`), like this:\n+Instead of setting the speed factors for certain values you can instead set the speed factors for all *other* values\n+using the unconditional expression `true`:\n ```yaml\n-speed_factor: \n-  road_class: {\"*\": 0.5}\n-  road_environment: {tunnel: 0.8, \"*\": 0.6}\n+speed_factor:\n+  true: 0.5", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5cb073c89e7badcdb4e8aa42997f9b5a447e89ed"}, "originalPosition": 112}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTY5MDUxOA==", "bodyText": "Also not sure. I only chose the consistent approach, i.e. \"Java-alike unconditional\".", "url": "https://github.com/graphhopper/graphhopper/pull/2209#discussion_r541690518", "createdAt": "2020-12-12T17:44:32Z", "author": {"login": "karussell"}, "path": "docs/core/profiles.md", "diffHunk": "@@ -151,96 +153,112 @@ can be influenced by the different fields of such a custom model.\n   \n #### Customizing `speed`\n \n-For every edge a default speed is inherited from the base vehicle, but you have multiple options to adjust it.\n+For every road segment a default speed is inherited from the base vehicle, but you have multiple options to adjust it.\n The first thing you can do is rescaling the default speeds using the `speed_factor` section. For example this is how you\n-can reduce the the speed of every edge that has the value 'motorway' for the category 'road_class' to fifty percent of \n+can reduce the speed of every road segment that has the value MOTORWAY for the category 'road_class' to fifty percent of \n the default speed that is normally used by the base vehicle for this road class:\n ```yaml\n speed_factor:\n-  road_class: {motorway: 0.5}\n-```  \n-Note that `road_class: {motorway: 0.5}` is an alternative YAML notation that is equivalent to:\n+  road_class == MOTORWAY: 0.5\n+```\n+\n+You can also change the speed factor for multiple road classes like this\n ```yaml\n speed_factor:\n-  road_class:\n-    motorway: 0.5\n+  road_class == MOTORWAY: 0.5\n+  road_class == PRIMARY || road_class == TERTIARY: 0.7\n ```\n \n-You can also setup speed factors for multiple road classes like this\n+Please note the OR operator `||` that says that if one of the expressions is true the value 0.7 is used.\n+\n+or use multiple categories to influence the speed factor\n ```yaml\n speed_factor:\n-  road_class: {motorway: 0.5, primary: 0.7, tertiary: 0.9}\n+  road_class == MOTORWAY: 0.5\n+  road_environment == TUNNEL: 0.8\n ```\n \n-and use multiple categories to influence the speed factor\n+You can use only two operators `==` (equality) and `!=` inequality.\n+\n+If a road segment matches multiple expressions the speed factor values will be multiplied. For example, here the speed factor of\n+a road segment that has `road_class==MOTORWAY` will be `0.5`, the speed factor of a road segment that additionally has\n+`road_environment==TUNNEL` will be `0.4` and the speed factor of a road segment that has `road_class==SECONDARY` and\n+`road_environment==TUNNEL` will be `0.8`. You can avoid this by using the \"first_match\" directive:\n+\n ```yaml\n speed_factor:\n-  road_class: {motorway: 0.5}\n-  road_environment: {tunnel: 0.8}\n+  first_match:\n+    road_class == MOTORWAY: 0.5\n+    road_environment == TUNNEL: 0.8\n ```\n \n-If an edge matches multiple rules the speed factor values will be multiplied. For example, here the speed factor of \n-a road segment that has `road_class=motorway` will be `0.5`, the speed factor of a road segment that additionally has \n-`road_environment=tunnel` will be `0.4` and the speed factor of a road segment that has `road_class=secondary` and \n-`road_environment=tunnel` will be `0.8`.\n+Now even if a road segment fulfills both conditions only the first will be used and no multiplication happens. If you\n+know a programming language than the previous statements are \"if\" clauses and expressions under \"first_match\" are\n+\"if-then-else-if\" clauses.\n \n-Instead of setting the speed factors for certain values you can instead set the speed factors for all *other* values using\n-as special key (`\"*\"`), like this:\n+Instead of setting the speed factors for certain values you can instead set the speed factors for all *other* values\n+using the unconditional expression `true`:\n ```yaml\n-speed_factor: \n-  road_class: {\"*\": 0.5}\n-  road_environment: {tunnel: 0.8, \"*\": 0.6}\n+speed_factor:\n+  true: 0.5", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTIxMzE3Nw=="}, "originalCommit": {"oid": "5cb073c89e7badcdb4e8aa42997f9b5a447e89ed"}, "originalPosition": 112}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTc3NzE4NQ==", "bodyText": "Have introduce a simple static variable ala boolean DEFAULT = true - is this better?", "url": "https://github.com/graphhopper/graphhopper/pull/2209#discussion_r541777185", "createdAt": "2020-12-12T20:43:55Z", "author": {"login": "karussell"}, "path": "docs/core/profiles.md", "diffHunk": "@@ -151,96 +153,112 @@ can be influenced by the different fields of such a custom model.\n   \n #### Customizing `speed`\n \n-For every edge a default speed is inherited from the base vehicle, but you have multiple options to adjust it.\n+For every road segment a default speed is inherited from the base vehicle, but you have multiple options to adjust it.\n The first thing you can do is rescaling the default speeds using the `speed_factor` section. For example this is how you\n-can reduce the the speed of every edge that has the value 'motorway' for the category 'road_class' to fifty percent of \n+can reduce the speed of every road segment that has the value MOTORWAY for the category 'road_class' to fifty percent of \n the default speed that is normally used by the base vehicle for this road class:\n ```yaml\n speed_factor:\n-  road_class: {motorway: 0.5}\n-```  \n-Note that `road_class: {motorway: 0.5}` is an alternative YAML notation that is equivalent to:\n+  road_class == MOTORWAY: 0.5\n+```\n+\n+You can also change the speed factor for multiple road classes like this\n ```yaml\n speed_factor:\n-  road_class:\n-    motorway: 0.5\n+  road_class == MOTORWAY: 0.5\n+  road_class == PRIMARY || road_class == TERTIARY: 0.7\n ```\n \n-You can also setup speed factors for multiple road classes like this\n+Please note the OR operator `||` that says that if one of the expressions is true the value 0.7 is used.\n+\n+or use multiple categories to influence the speed factor\n ```yaml\n speed_factor:\n-  road_class: {motorway: 0.5, primary: 0.7, tertiary: 0.9}\n+  road_class == MOTORWAY: 0.5\n+  road_environment == TUNNEL: 0.8\n ```\n \n-and use multiple categories to influence the speed factor\n+You can use only two operators `==` (equality) and `!=` inequality.\n+\n+If a road segment matches multiple expressions the speed factor values will be multiplied. For example, here the speed factor of\n+a road segment that has `road_class==MOTORWAY` will be `0.5`, the speed factor of a road segment that additionally has\n+`road_environment==TUNNEL` will be `0.4` and the speed factor of a road segment that has `road_class==SECONDARY` and\n+`road_environment==TUNNEL` will be `0.8`. You can avoid this by using the \"first_match\" directive:\n+\n ```yaml\n speed_factor:\n-  road_class: {motorway: 0.5}\n-  road_environment: {tunnel: 0.8}\n+  first_match:\n+    road_class == MOTORWAY: 0.5\n+    road_environment == TUNNEL: 0.8\n ```\n \n-If an edge matches multiple rules the speed factor values will be multiplied. For example, here the speed factor of \n-a road segment that has `road_class=motorway` will be `0.5`, the speed factor of a road segment that additionally has \n-`road_environment=tunnel` will be `0.4` and the speed factor of a road segment that has `road_class=secondary` and \n-`road_environment=tunnel` will be `0.8`.\n+Now even if a road segment fulfills both conditions only the first will be used and no multiplication happens. If you\n+know a programming language than the previous statements are \"if\" clauses and expressions under \"first_match\" are\n+\"if-then-else-if\" clauses.\n \n-Instead of setting the speed factors for certain values you can instead set the speed factors for all *other* values using\n-as special key (`\"*\"`), like this:\n+Instead of setting the speed factors for certain values you can instead set the speed factors for all *other* values\n+using the unconditional expression `true`:\n ```yaml\n-speed_factor: \n-  road_class: {\"*\": 0.5}\n-  road_environment: {tunnel: 0.8, \"*\": 0.6}\n+speed_factor:\n+  true: 0.5", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTIxMzE3Nw=="}, "originalCommit": {"oid": "5cb073c89e7badcdb4e8aa42997f9b5a447e89ed"}, "originalPosition": 112}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTkzMDE5MQ==", "bodyText": "Hm let's not introduce more syntactic sugar here until we have finalized the format?", "url": "https://github.com/graphhopper/graphhopper/pull/2209#discussion_r541930191", "createdAt": "2020-12-13T13:53:44Z", "author": {"login": "easbar"}, "path": "docs/core/profiles.md", "diffHunk": "@@ -151,96 +153,112 @@ can be influenced by the different fields of such a custom model.\n   \n #### Customizing `speed`\n \n-For every edge a default speed is inherited from the base vehicle, but you have multiple options to adjust it.\n+For every road segment a default speed is inherited from the base vehicle, but you have multiple options to adjust it.\n The first thing you can do is rescaling the default speeds using the `speed_factor` section. For example this is how you\n-can reduce the the speed of every edge that has the value 'motorway' for the category 'road_class' to fifty percent of \n+can reduce the speed of every road segment that has the value MOTORWAY for the category 'road_class' to fifty percent of \n the default speed that is normally used by the base vehicle for this road class:\n ```yaml\n speed_factor:\n-  road_class: {motorway: 0.5}\n-```  \n-Note that `road_class: {motorway: 0.5}` is an alternative YAML notation that is equivalent to:\n+  road_class == MOTORWAY: 0.5\n+```\n+\n+You can also change the speed factor for multiple road classes like this\n ```yaml\n speed_factor:\n-  road_class:\n-    motorway: 0.5\n+  road_class == MOTORWAY: 0.5\n+  road_class == PRIMARY || road_class == TERTIARY: 0.7\n ```\n \n-You can also setup speed factors for multiple road classes like this\n+Please note the OR operator `||` that says that if one of the expressions is true the value 0.7 is used.\n+\n+or use multiple categories to influence the speed factor\n ```yaml\n speed_factor:\n-  road_class: {motorway: 0.5, primary: 0.7, tertiary: 0.9}\n+  road_class == MOTORWAY: 0.5\n+  road_environment == TUNNEL: 0.8\n ```\n \n-and use multiple categories to influence the speed factor\n+You can use only two operators `==` (equality) and `!=` inequality.\n+\n+If a road segment matches multiple expressions the speed factor values will be multiplied. For example, here the speed factor of\n+a road segment that has `road_class==MOTORWAY` will be `0.5`, the speed factor of a road segment that additionally has\n+`road_environment==TUNNEL` will be `0.4` and the speed factor of a road segment that has `road_class==SECONDARY` and\n+`road_environment==TUNNEL` will be `0.8`. You can avoid this by using the \"first_match\" directive:\n+\n ```yaml\n speed_factor:\n-  road_class: {motorway: 0.5}\n-  road_environment: {tunnel: 0.8}\n+  first_match:\n+    road_class == MOTORWAY: 0.5\n+    road_environment == TUNNEL: 0.8\n ```\n \n-If an edge matches multiple rules the speed factor values will be multiplied. For example, here the speed factor of \n-a road segment that has `road_class=motorway` will be `0.5`, the speed factor of a road segment that additionally has \n-`road_environment=tunnel` will be `0.4` and the speed factor of a road segment that has `road_class=secondary` and \n-`road_environment=tunnel` will be `0.8`.\n+Now even if a road segment fulfills both conditions only the first will be used and no multiplication happens. If you\n+know a programming language than the previous statements are \"if\" clauses and expressions under \"first_match\" are\n+\"if-then-else-if\" clauses.\n \n-Instead of setting the speed factors for certain values you can instead set the speed factors for all *other* values using\n-as special key (`\"*\"`), like this:\n+Instead of setting the speed factors for certain values you can instead set the speed factors for all *other* values\n+using the unconditional expression `true`:\n ```yaml\n-speed_factor: \n-  road_class: {\"*\": 0.5}\n-  road_environment: {tunnel: 0.8, \"*\": 0.6}\n+speed_factor:\n+  true: 0.5", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTIxMzE3Nw=="}, "originalCommit": {"oid": "5cb073c89e7badcdb4e8aa42997f9b5a447e89ed"}, "originalPosition": 112}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjMxODI3Mw==", "bodyText": "Ok, will revert :)", "url": "https://github.com/graphhopper/graphhopper/pull/2209#discussion_r542318273", "createdAt": "2020-12-14T11:38:12Z", "author": {"login": "karussell"}, "path": "docs/core/profiles.md", "diffHunk": "@@ -151,96 +153,112 @@ can be influenced by the different fields of such a custom model.\n   \n #### Customizing `speed`\n \n-For every edge a default speed is inherited from the base vehicle, but you have multiple options to adjust it.\n+For every road segment a default speed is inherited from the base vehicle, but you have multiple options to adjust it.\n The first thing you can do is rescaling the default speeds using the `speed_factor` section. For example this is how you\n-can reduce the the speed of every edge that has the value 'motorway' for the category 'road_class' to fifty percent of \n+can reduce the speed of every road segment that has the value MOTORWAY for the category 'road_class' to fifty percent of \n the default speed that is normally used by the base vehicle for this road class:\n ```yaml\n speed_factor:\n-  road_class: {motorway: 0.5}\n-```  \n-Note that `road_class: {motorway: 0.5}` is an alternative YAML notation that is equivalent to:\n+  road_class == MOTORWAY: 0.5\n+```\n+\n+You can also change the speed factor for multiple road classes like this\n ```yaml\n speed_factor:\n-  road_class:\n-    motorway: 0.5\n+  road_class == MOTORWAY: 0.5\n+  road_class == PRIMARY || road_class == TERTIARY: 0.7\n ```\n \n-You can also setup speed factors for multiple road classes like this\n+Please note the OR operator `||` that says that if one of the expressions is true the value 0.7 is used.\n+\n+or use multiple categories to influence the speed factor\n ```yaml\n speed_factor:\n-  road_class: {motorway: 0.5, primary: 0.7, tertiary: 0.9}\n+  road_class == MOTORWAY: 0.5\n+  road_environment == TUNNEL: 0.8\n ```\n \n-and use multiple categories to influence the speed factor\n+You can use only two operators `==` (equality) and `!=` inequality.\n+\n+If a road segment matches multiple expressions the speed factor values will be multiplied. For example, here the speed factor of\n+a road segment that has `road_class==MOTORWAY` will be `0.5`, the speed factor of a road segment that additionally has\n+`road_environment==TUNNEL` will be `0.4` and the speed factor of a road segment that has `road_class==SECONDARY` and\n+`road_environment==TUNNEL` will be `0.8`. You can avoid this by using the \"first_match\" directive:\n+\n ```yaml\n speed_factor:\n-  road_class: {motorway: 0.5}\n-  road_environment: {tunnel: 0.8}\n+  first_match:\n+    road_class == MOTORWAY: 0.5\n+    road_environment == TUNNEL: 0.8\n ```\n \n-If an edge matches multiple rules the speed factor values will be multiplied. For example, here the speed factor of \n-a road segment that has `road_class=motorway` will be `0.5`, the speed factor of a road segment that additionally has \n-`road_environment=tunnel` will be `0.4` and the speed factor of a road segment that has `road_class=secondary` and \n-`road_environment=tunnel` will be `0.8`.\n+Now even if a road segment fulfills both conditions only the first will be used and no multiplication happens. If you\n+know a programming language than the previous statements are \"if\" clauses and expressions under \"first_match\" are\n+\"if-then-else-if\" clauses.\n \n-Instead of setting the speed factors for certain values you can instead set the speed factors for all *other* values using\n-as special key (`\"*\"`), like this:\n+Instead of setting the speed factors for certain values you can instead set the speed factors for all *other* values\n+using the unconditional expression `true`:\n ```yaml\n-speed_factor: \n-  road_class: {\"*\": 0.5}\n-  road_environment: {tunnel: 0.8, \"*\": 0.6}\n+speed_factor:\n+  true: 0.5", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTIxMzE3Nw=="}, "originalCommit": {"oid": "5cb073c89e7badcdb4e8aa42997f9b5a447e89ed"}, "originalPosition": 112}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM5OTAyMjM5OnYy", "diffSide": "RIGHT", "path": "docs/core/profiles.md", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMVQxOTo1Mjo1OVrOIEJbcg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMVQxOTo1Mjo1OVrOIEJbcg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTIxOTY5OA==", "bodyText": "Nice, in_area makes this more readable.", "url": "https://github.com/graphhopper/graphhopper/pull/2209#discussion_r541219698", "createdAt": "2020-12-11T19:52:59Z", "author": {"login": "easbar"}, "path": "docs/core/profiles.md", "diffHunk": "@@ -151,96 +153,112 @@ can be influenced by the different fields of such a custom model.\n   \n #### Customizing `speed`\n \n-For every edge a default speed is inherited from the base vehicle, but you have multiple options to adjust it.\n+For every road segment a default speed is inherited from the base vehicle, but you have multiple options to adjust it.\n The first thing you can do is rescaling the default speeds using the `speed_factor` section. For example this is how you\n-can reduce the the speed of every edge that has the value 'motorway' for the category 'road_class' to fifty percent of \n+can reduce the speed of every road segment that has the value MOTORWAY for the category 'road_class' to fifty percent of \n the default speed that is normally used by the base vehicle for this road class:\n ```yaml\n speed_factor:\n-  road_class: {motorway: 0.5}\n-```  \n-Note that `road_class: {motorway: 0.5}` is an alternative YAML notation that is equivalent to:\n+  road_class == MOTORWAY: 0.5\n+```\n+\n+You can also change the speed factor for multiple road classes like this\n ```yaml\n speed_factor:\n-  road_class:\n-    motorway: 0.5\n+  road_class == MOTORWAY: 0.5\n+  road_class == PRIMARY || road_class == TERTIARY: 0.7\n ```\n \n-You can also setup speed factors for multiple road classes like this\n+Please note the OR operator `||` that says that if one of the expressions is true the value 0.7 is used.\n+\n+or use multiple categories to influence the speed factor\n ```yaml\n speed_factor:\n-  road_class: {motorway: 0.5, primary: 0.7, tertiary: 0.9}\n+  road_class == MOTORWAY: 0.5\n+  road_environment == TUNNEL: 0.8\n ```\n \n-and use multiple categories to influence the speed factor\n+You can use only two operators `==` (equality) and `!=` inequality.\n+\n+If a road segment matches multiple expressions the speed factor values will be multiplied. For example, here the speed factor of\n+a road segment that has `road_class==MOTORWAY` will be `0.5`, the speed factor of a road segment that additionally has\n+`road_environment==TUNNEL` will be `0.4` and the speed factor of a road segment that has `road_class==SECONDARY` and\n+`road_environment==TUNNEL` will be `0.8`. You can avoid this by using the \"first_match\" directive:\n+\n ```yaml\n speed_factor:\n-  road_class: {motorway: 0.5}\n-  road_environment: {tunnel: 0.8}\n+  first_match:\n+    road_class == MOTORWAY: 0.5\n+    road_environment == TUNNEL: 0.8\n ```\n \n-If an edge matches multiple rules the speed factor values will be multiplied. For example, here the speed factor of \n-a road segment that has `road_class=motorway` will be `0.5`, the speed factor of a road segment that additionally has \n-`road_environment=tunnel` will be `0.4` and the speed factor of a road segment that has `road_class=secondary` and \n-`road_environment=tunnel` will be `0.8`.\n+Now even if a road segment fulfills both conditions only the first will be used and no multiplication happens. If you\n+know a programming language than the previous statements are \"if\" clauses and expressions under \"first_match\" are\n+\"if-then-else-if\" clauses.\n \n-Instead of setting the speed factors for certain values you can instead set the speed factors for all *other* values using\n-as special key (`\"*\"`), like this:\n+Instead of setting the speed factors for certain values you can instead set the speed factors for all *other* values\n+using the unconditional expression `true`:\n ```yaml\n-speed_factor: \n-  road_class: {\"*\": 0.5}\n-  road_environment: {tunnel: 0.8, \"*\": 0.6}\n+speed_factor:\n+  true: 0.5\n+  first_match:\n+    road_environment == TUNNEL: 0.8\n+    true: 0.6\n ```\n \n-So in this example we set a speed factor of `0.5` regardless of the `road_class` and all `road_environment` values yield\n-a speed factor of `0.6` *except* `tunnel` which gets a speed factor of `0.8`. And as mentioned above for edges that match\n-multiple of these rules the different factors get multiplied.\n+This is usually used in the `first_match' directive.\n+\n+So in this example we set a speed factor of `0.5` independent of any category or value and all `road_environment`\n+values yield a speed factor of `0.6` *except* `TUNNEL` which gets a speed factor of `0.8`. And as mentioned above\n+for road segments that match multiple of these rules the different factors get multiplied, i.e. `0.5*0.6` or `0.5*0.8`.\n \n For encoded values with boolean values, like `get_off_bike` you set the speed factor like this:\n ```yaml\n speed_factor:\n-  get_off_bike: {true: 0.6, false: 1.0}\n+  first_match:\n+    get_off_bike: 0.6\n+    true: 0.9\n ```\n-which means that for edges with `get_off_bike=true` the speed factor will be `0.6` and otherwise it will be `1.0`.\n+which means that for edges with `get_off_bike==true` the speed factor will be `0.6` and otherwise it will be `0.9`.\n You can skip any of these values to retain the default.\n \n-For encoded values with numeric values, like `max_width` you use the `<` and `>` operators, like this:\n+For encoded values with numeric values, like `max_width` you should not use \"equality\" or \"inequality\" but the\n+comparison operators \"bigger\" `>`, \"bigger or equals\" `>=`, \"smaller\" `<` or \"smaller or equals\" `<=`, e.g.:\n ```yaml\n speed_factor:\n-  max_width: {\"<2.5\": 0.8}\n+  max_width < 2.5: 0.8\n ``` \n which means that for all edges with `max_width` smaller than `2.5m` the speed factor is `0.8`.\n \n-In any case values of `speed_factor` have to be in the range `[0,1]` and it is not possible to *increase* the speed for\n-edges of certain types. \n-\n Another way to change the speed is using the `max_speed` section, for example:\n ```yaml\n max_speed:\n-  surface: {gravel: 60}\n+  surface != GRAVEL: 60\n ```\n \n-implies that on all road segments with `surface=gravel` the speed will be at most `60km/h`, regardless of the default \n-speed of this edge or the adjustments made by the `speed_factor` section. Just like with `speed_factor` you can setup\n-`max_speed` values for multiple category values and different categories. If multiple rules match for a given edge the\n-most restrictive rule will determine the speed (the minimum `max_speed` will be applied). \n+This implies that on all road segments with no `GRAVEL` value for `surface` the speed will be at most `60km/h`,\n+regardless of the default speed of this road segment or the adjustments made by the `speed_factor` section. Just like\n+with `speed_factor` you can use multiple category values and different categories in the expressions of the `max_speed`\n+entry. If multiple rules match for a given edge the most restrictive rule will determine the speed, i.e. the minimum\n+`max_speed` will be applied.\n+\n Values for `max_speed` must be in the range `[0,max_vehicle_speed]` where `max_vehicle_speed` is the maximum speed that\n-is set for the base vehicle (which you cannot change).\n+is set for the base vehicle, and you cannot change.\n \n-You can also modify the speed for all edges in a certain area. To do this first add some areas to the `areas` section\n-of the custom model and then use this name to set a `speed_factor` or `max_speed` for this area. In the following\n-example we set the `speed_factor` of an area called `my_area` to `0.7`. For `max_speed` it works the same way. All area\n-names need to be prefixed with `area_`.  \n+You can also modify the speed for all road segments in a certain area. To do this first add some areas to the `areas`\n+section of the custom model and then use this name to set a `speed_factor` or `max_speed` for this area. In the following\n+example we set the `speed_factor` of an area called `custom1` to `0.7`. For `max_speed` it works the same way. All area\n+names need to be prefixed with `in_area_`.\n \n ```yaml\n speed_factor:\n-  area_my_area: 0.7\n+  in_area_custom1: 0.7", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5cb073c89e7badcdb4e8aa42997f9b5a447e89ed"}, "originalPosition": 185}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQwNDAxNzgzOnYy", "diffSide": "RIGHT", "path": "core/src/main/java/com/graphhopper/routing/weighting/custom/ExpressionBuilder.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xM1QxMDo1NjoyNlrOIEy9TQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xM1QxMDo1NjoyNlrOIEy9TQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTkwMDEwOQ==", "bodyText": "Can we use a bit more meaningful name than Test? Something like JaninoAutoGeneratedCustomWeighting or something (if this is what it is)?", "url": "https://github.com/graphhopper/graphhopper/pull/2209#discussion_r541900109", "createdAt": "2020-12-13T10:56:26Z", "author": {"login": "easbar"}, "path": "core/src/main/java/com/graphhopper/routing/weighting/custom/ExpressionBuilder.java", "diffHunk": "@@ -0,0 +1,379 @@\n+/*\n+ *  Licensed to GraphHopper GmbH under one or more contributor\n+ *  license agreements. See the NOTICE file distributed with this work for\n+ *  additional information regarding copyright ownership.\n+ *\n+ *  GraphHopper GmbH licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except in\n+ *  compliance with the License. You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package com.graphhopper.routing.weighting.custom;\n+\n+import com.graphhopper.json.geo.JsonFeature;\n+import com.graphhopper.routing.ev.DecimalEncodedValue;\n+import com.graphhopper.routing.ev.EncodedValue;\n+import com.graphhopper.routing.ev.EncodedValueLookup;\n+import com.graphhopper.routing.util.CustomModel;\n+import com.graphhopper.routing.util.EncodingManager;\n+import com.graphhopper.util.EdgeIteratorState;\n+import com.graphhopper.util.GHUtility;\n+import com.graphhopper.util.shapes.BBox;\n+import com.graphhopper.util.shapes.Polygon;\n+import org.codehaus.commons.compiler.CompileException;\n+import org.codehaus.commons.compiler.Location;\n+import org.codehaus.commons.compiler.io.Readers;\n+import org.codehaus.janino.Scanner;\n+import org.codehaus.janino.*;\n+import org.codehaus.janino.util.DeepCopier;\n+import org.locationtech.jts.geom.prep.PreparedGeometryFactory;\n+\n+import java.io.*;\n+import java.util.*;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+class ExpressionBuilder {\n+    private static final AtomicLong longVal = new AtomicLong(1);\n+    static final String IN_AREA_PREFIX = \"in_area_\";\n+    private static final Set<String> allowedNames = new HashSet<>(Arrays.asList(\"edge\", \"Math\"));\n+    private static final boolean JANINO_DEBUG = Boolean.getBoolean(Scanner.SYSTEM_PROPERTY_SOURCE_DEBUGGING_ENABLE);\n+\n+    // TODO without a cache we get X% slower routing and Y% slower routingLM8. CH requests and preparation is unaffected\n+    // as cached weighting from preparation is used. This cache ensures that the first Weighting classes, typically the\n+    // ones specified in the profiles, are never removed regardless of how frequent other Weightings are created and accessed.\n+    // We only need to synchronize the get and put methods alone. E.g. we do not care for the race condition where\n+    // two identical classes are requested and one of them is overwritten. We could use CachingJavaSourceClassLoader from\n+    // Janino but 1. we would need to use a single compiler across threads and 2. the statements (for priority and speed)\n+    // are still unnecessarily created.\n+    private static final int CACHE_SIZE = Integer.getInteger(\"graphhopper.custom_weighting.cache_size\", 10);\n+    // TODO perf compare with ConcurrentHashMap, but I guess, if there is a difference at all, it is not big for small maps\n+    private static final Map<String, Class> CACHE = Collections.synchronizedMap(new HashMap<>(CACHE_SIZE));\n+\n+    // Introduce a dynamic cache to remember different Weighting classes, but throw away less frequently used classes.\n+    // Use accessOrder==true to remove oldest accessed entry, not oldest inserted.\n+    private static final int DYN_CACHE_SIZE = Integer.getInteger(\"graphhopper.custom_weighting.dynamic_cache_size\", 1000);\n+    private static final Map<String, Class> DYN_CACHE = Collections.synchronizedMap(\n+            new LinkedHashMap<String, Class>(DYN_CACHE_SIZE, 0.75f, true) {\n+                protected boolean removeEldestEntry(Map.Entry eldest) {\n+                    return size() > DYN_CACHE_SIZE;\n+                }\n+            });\n+\n+    /**\n+     * This method compiles a new subclass of CustomWeightingHelper composed from the provided CustomModel caches this\n+     * and returns an instance.\n+     */\n+    static CustomWeightingHelper create(CustomModel customModel, EncodedValueLookup lookup,\n+                                        double globalMaxSpeed, double maxSpeedFallback, DecimalEncodedValue avgSpeedEnc) {\n+        Java.CompilationUnit cu;\n+        try {\n+            String key = customModel.toString() + \",global:\" + globalMaxSpeed + \",fallback:\" + maxSpeedFallback;\n+            if (key.length() > 400_000) throw new IllegalArgumentException(\"Custom Model too big: \" + key.length());\n+\n+            Class clazz = CACHE.get(key);\n+            if (DYN_CACHE_SIZE > 0 && clazz == null)\n+                clazz = DYN_CACHE.get(key);\n+            if (clazz == null) {\n+                HashSet<String> priorityVariables = new LinkedHashSet<>();\n+                List<Java.BlockStatement> priorityStatements = createGetPriorityStatements(priorityVariables, customModel, lookup);\n+                HashSet<String> speedVariables = new LinkedHashSet<>();\n+                List<Java.BlockStatement> speedStatements = createGetSpeedStatements(speedVariables, customModel, lookup, globalMaxSpeed, maxSpeedFallback);\n+                // Create different class name, which is required only for debugging.\n+                // TODO does it improve performance too? I.e. it could be that the JIT is confused if different classes\n+                //  have the same name and it mixes performance stats. See https://github.com/janino-compiler/janino/issues/137\n+                long counter = longVal.incrementAndGet();\n+                String classTemplate = createClassTemplate(counter, priorityVariables, speedVariables, lookup, customModel);\n+                cu = (Java.CompilationUnit) new Parser(new org.codehaus.janino.Scanner(\"source\", new StringReader(classTemplate))).\n+                        parseAbstractCompilationUnit();\n+                cu = injectStatements(priorityStatements, speedStatements, cu);\n+                SimpleCompiler sc = createCompiler(counter, cu);\n+                clazz = sc.getClassLoader().loadClass(\"com.graphhopper.Test\" + counter);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f4478bb97c3d7585b21c39eadf45d80e57436cb3"}, "originalPosition": 97}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQwNDEzMTY2OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/com/graphhopper/routing/weighting/custom/ExpressionBuilder.java", "isResolved": true, "comments": {"totalCount": 43, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xM1QxMjoxMzowOVrOIEzv2A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0zMVQwODowODo1N1rOIM7OtA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTkxMzA0OA==", "bodyText": "This is kind of hard to read. Can you explain what the applied flag does and why there are two speed values (maxSpeedFallback and globalMaxSpeed)?", "url": "https://github.com/graphhopper/graphhopper/pull/2209#discussion_r541913048", "createdAt": "2020-12-13T12:13:09Z", "author": {"login": "easbar"}, "path": "core/src/main/java/com/graphhopper/routing/weighting/custom/ExpressionBuilder.java", "diffHunk": "@@ -0,0 +1,379 @@\n+/*\n+ *  Licensed to GraphHopper GmbH under one or more contributor\n+ *  license agreements. See the NOTICE file distributed with this work for\n+ *  additional information regarding copyright ownership.\n+ *\n+ *  GraphHopper GmbH licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except in\n+ *  compliance with the License. You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package com.graphhopper.routing.weighting.custom;\n+\n+import com.graphhopper.json.geo.JsonFeature;\n+import com.graphhopper.routing.ev.DecimalEncodedValue;\n+import com.graphhopper.routing.ev.EncodedValue;\n+import com.graphhopper.routing.ev.EncodedValueLookup;\n+import com.graphhopper.routing.util.CustomModel;\n+import com.graphhopper.routing.util.EncodingManager;\n+import com.graphhopper.util.EdgeIteratorState;\n+import com.graphhopper.util.GHUtility;\n+import com.graphhopper.util.shapes.BBox;\n+import com.graphhopper.util.shapes.Polygon;\n+import org.codehaus.commons.compiler.CompileException;\n+import org.codehaus.commons.compiler.Location;\n+import org.codehaus.commons.compiler.io.Readers;\n+import org.codehaus.janino.Scanner;\n+import org.codehaus.janino.*;\n+import org.codehaus.janino.util.DeepCopier;\n+import org.locationtech.jts.geom.prep.PreparedGeometryFactory;\n+\n+import java.io.*;\n+import java.util.*;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+class ExpressionBuilder {\n+    private static final AtomicLong longVal = new AtomicLong(1);\n+    static final String IN_AREA_PREFIX = \"in_area_\";\n+    private static final Set<String> allowedNames = new HashSet<>(Arrays.asList(\"edge\", \"Math\"));\n+    private static final boolean JANINO_DEBUG = Boolean.getBoolean(Scanner.SYSTEM_PROPERTY_SOURCE_DEBUGGING_ENABLE);\n+\n+    // TODO without a cache we get X% slower routing and Y% slower routingLM8. CH requests and preparation is unaffected\n+    // as cached weighting from preparation is used. This cache ensures that the first Weighting classes, typically the\n+    // ones specified in the profiles, are never removed regardless of how frequent other Weightings are created and accessed.\n+    // We only need to synchronize the get and put methods alone. E.g. we do not care for the race condition where\n+    // two identical classes are requested and one of them is overwritten. We could use CachingJavaSourceClassLoader from\n+    // Janino but 1. we would need to use a single compiler across threads and 2. the statements (for priority and speed)\n+    // are still unnecessarily created.\n+    private static final int CACHE_SIZE = Integer.getInteger(\"graphhopper.custom_weighting.cache_size\", 10);\n+    // TODO perf compare with ConcurrentHashMap, but I guess, if there is a difference at all, it is not big for small maps\n+    private static final Map<String, Class> CACHE = Collections.synchronizedMap(new HashMap<>(CACHE_SIZE));\n+\n+    // Introduce a dynamic cache to remember different Weighting classes, but throw away less frequently used classes.\n+    // Use accessOrder==true to remove oldest accessed entry, not oldest inserted.\n+    private static final int DYN_CACHE_SIZE = Integer.getInteger(\"graphhopper.custom_weighting.dynamic_cache_size\", 1000);\n+    private static final Map<String, Class> DYN_CACHE = Collections.synchronizedMap(\n+            new LinkedHashMap<String, Class>(DYN_CACHE_SIZE, 0.75f, true) {\n+                protected boolean removeEldestEntry(Map.Entry eldest) {\n+                    return size() > DYN_CACHE_SIZE;\n+                }\n+            });\n+\n+    /**\n+     * This method compiles a new subclass of CustomWeightingHelper composed from the provided CustomModel caches this\n+     * and returns an instance.\n+     */\n+    static CustomWeightingHelper create(CustomModel customModel, EncodedValueLookup lookup,\n+                                        double globalMaxSpeed, double maxSpeedFallback, DecimalEncodedValue avgSpeedEnc) {\n+        Java.CompilationUnit cu;\n+        try {\n+            String key = customModel.toString() + \",global:\" + globalMaxSpeed + \",fallback:\" + maxSpeedFallback;\n+            if (key.length() > 400_000) throw new IllegalArgumentException(\"Custom Model too big: \" + key.length());\n+\n+            Class clazz = CACHE.get(key);\n+            if (DYN_CACHE_SIZE > 0 && clazz == null)\n+                clazz = DYN_CACHE.get(key);\n+            if (clazz == null) {\n+                HashSet<String> priorityVariables = new LinkedHashSet<>();\n+                List<Java.BlockStatement> priorityStatements = createGetPriorityStatements(priorityVariables, customModel, lookup);\n+                HashSet<String> speedVariables = new LinkedHashSet<>();\n+                List<Java.BlockStatement> speedStatements = createGetSpeedStatements(speedVariables, customModel, lookup, globalMaxSpeed, maxSpeedFallback);\n+                // Create different class name, which is required only for debugging.\n+                // TODO does it improve performance too? I.e. it could be that the JIT is confused if different classes\n+                //  have the same name and it mixes performance stats. See https://github.com/janino-compiler/janino/issues/137\n+                long counter = longVal.incrementAndGet();\n+                String classTemplate = createClassTemplate(counter, priorityVariables, speedVariables, lookup, customModel);\n+                cu = (Java.CompilationUnit) new Parser(new org.codehaus.janino.Scanner(\"source\", new StringReader(classTemplate))).\n+                        parseAbstractCompilationUnit();\n+                cu = injectStatements(priorityStatements, speedStatements, cu);\n+                SimpleCompiler sc = createCompiler(counter, cu);\n+                clazz = sc.getClassLoader().loadClass(\"com.graphhopper.Test\" + counter);\n+                if (CACHE.size() < CACHE_SIZE)\n+                    CACHE.put(key, clazz);\n+                else if (DYN_CACHE_SIZE > 0)\n+                    DYN_CACHE.put(key, clazz);\n+            }\n+\n+            // The class does not need to be thread-safe as we create an instance per request\n+            CustomWeightingHelper prio = (CustomWeightingHelper) clazz.getDeclaredConstructor().newInstance();\n+            prio.init(lookup, avgSpeedEnc, customModel.getAreas());\n+            return prio;\n+        } catch (Exception ex) {\n+            String location = \"\";\n+            if (ex instanceof CompileException)\n+                location = \" in \" + ((CompileException) ex).getLocation().getFileName();\n+            throw new IllegalArgumentException(\"Cannot compile expression \" + location + \", \" + ex.getMessage(), ex);\n+        }\n+    }\n+\n+    /**\n+     * Parse the expressions from CustomModel relevant for the method getSpeed - see createClassTemplate.\n+     *\n+     * @return the created statements (parsed expressions)\n+     */\n+    private static List<Java.BlockStatement> createGetSpeedStatements(Set<String> speedVariables,\n+                                                                      CustomModel customModel, EncodedValueLookup lookup,\n+                                                                      double globalMaxSpeed, double maxSpeedFallback) throws Exception {\n+        List<Java.BlockStatement> speedStatements = new ArrayList<>();\n+        speedStatements.addAll(verifyExpressions(new StringBuilder(), \"speed_factor_user_statements\", speedVariables,\n+                customModel.getSpeedFactor(), lookup,\n+                num -> \"speed *= \" + num + \";\\n\", \"\"));\n+        StringBuilder codeSB = new StringBuilder(\"boolean applied = false;\\n\");\n+        speedStatements.addAll(verifyExpressions(codeSB, \"max_speed_user_statements\",\n+                speedVariables, customModel.getMaxSpeed(), lookup,\n+                num -> \"applied = true; speed = Math.min(speed,\" + num + \");\",\n+                \"if (!applied && speed > \" + maxSpeedFallback + \") return \" + maxSpeedFallback + \";\\n\" +\n+                        \"return Math.min(speed, \" + globalMaxSpeed + \");\\n\"));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f4478bb97c3d7585b21c39eadf45d80e57436cb3"}, "originalPosition": 133}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTkxNDI0Mg==", "bodyText": "This is basically what we do in master: https://github.com/graphhopper/graphhopper/blob/master/core/src/main/java/com/graphhopper/routing/weighting/custom/SpeedCalculator.java#L155", "url": "https://github.com/graphhopper/graphhopper/pull/2209#discussion_r541914242", "createdAt": "2020-12-13T12:20:10Z", "author": {"login": "karussell"}, "path": "core/src/main/java/com/graphhopper/routing/weighting/custom/ExpressionBuilder.java", "diffHunk": "@@ -0,0 +1,379 @@\n+/*\n+ *  Licensed to GraphHopper GmbH under one or more contributor\n+ *  license agreements. See the NOTICE file distributed with this work for\n+ *  additional information regarding copyright ownership.\n+ *\n+ *  GraphHopper GmbH licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except in\n+ *  compliance with the License. You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package com.graphhopper.routing.weighting.custom;\n+\n+import com.graphhopper.json.geo.JsonFeature;\n+import com.graphhopper.routing.ev.DecimalEncodedValue;\n+import com.graphhopper.routing.ev.EncodedValue;\n+import com.graphhopper.routing.ev.EncodedValueLookup;\n+import com.graphhopper.routing.util.CustomModel;\n+import com.graphhopper.routing.util.EncodingManager;\n+import com.graphhopper.util.EdgeIteratorState;\n+import com.graphhopper.util.GHUtility;\n+import com.graphhopper.util.shapes.BBox;\n+import com.graphhopper.util.shapes.Polygon;\n+import org.codehaus.commons.compiler.CompileException;\n+import org.codehaus.commons.compiler.Location;\n+import org.codehaus.commons.compiler.io.Readers;\n+import org.codehaus.janino.Scanner;\n+import org.codehaus.janino.*;\n+import org.codehaus.janino.util.DeepCopier;\n+import org.locationtech.jts.geom.prep.PreparedGeometryFactory;\n+\n+import java.io.*;\n+import java.util.*;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+class ExpressionBuilder {\n+    private static final AtomicLong longVal = new AtomicLong(1);\n+    static final String IN_AREA_PREFIX = \"in_area_\";\n+    private static final Set<String> allowedNames = new HashSet<>(Arrays.asList(\"edge\", \"Math\"));\n+    private static final boolean JANINO_DEBUG = Boolean.getBoolean(Scanner.SYSTEM_PROPERTY_SOURCE_DEBUGGING_ENABLE);\n+\n+    // TODO without a cache we get X% slower routing and Y% slower routingLM8. CH requests and preparation is unaffected\n+    // as cached weighting from preparation is used. This cache ensures that the first Weighting classes, typically the\n+    // ones specified in the profiles, are never removed regardless of how frequent other Weightings are created and accessed.\n+    // We only need to synchronize the get and put methods alone. E.g. we do not care for the race condition where\n+    // two identical classes are requested and one of them is overwritten. We could use CachingJavaSourceClassLoader from\n+    // Janino but 1. we would need to use a single compiler across threads and 2. the statements (for priority and speed)\n+    // are still unnecessarily created.\n+    private static final int CACHE_SIZE = Integer.getInteger(\"graphhopper.custom_weighting.cache_size\", 10);\n+    // TODO perf compare with ConcurrentHashMap, but I guess, if there is a difference at all, it is not big for small maps\n+    private static final Map<String, Class> CACHE = Collections.synchronizedMap(new HashMap<>(CACHE_SIZE));\n+\n+    // Introduce a dynamic cache to remember different Weighting classes, but throw away less frequently used classes.\n+    // Use accessOrder==true to remove oldest accessed entry, not oldest inserted.\n+    private static final int DYN_CACHE_SIZE = Integer.getInteger(\"graphhopper.custom_weighting.dynamic_cache_size\", 1000);\n+    private static final Map<String, Class> DYN_CACHE = Collections.synchronizedMap(\n+            new LinkedHashMap<String, Class>(DYN_CACHE_SIZE, 0.75f, true) {\n+                protected boolean removeEldestEntry(Map.Entry eldest) {\n+                    return size() > DYN_CACHE_SIZE;\n+                }\n+            });\n+\n+    /**\n+     * This method compiles a new subclass of CustomWeightingHelper composed from the provided CustomModel caches this\n+     * and returns an instance.\n+     */\n+    static CustomWeightingHelper create(CustomModel customModel, EncodedValueLookup lookup,\n+                                        double globalMaxSpeed, double maxSpeedFallback, DecimalEncodedValue avgSpeedEnc) {\n+        Java.CompilationUnit cu;\n+        try {\n+            String key = customModel.toString() + \",global:\" + globalMaxSpeed + \",fallback:\" + maxSpeedFallback;\n+            if (key.length() > 400_000) throw new IllegalArgumentException(\"Custom Model too big: \" + key.length());\n+\n+            Class clazz = CACHE.get(key);\n+            if (DYN_CACHE_SIZE > 0 && clazz == null)\n+                clazz = DYN_CACHE.get(key);\n+            if (clazz == null) {\n+                HashSet<String> priorityVariables = new LinkedHashSet<>();\n+                List<Java.BlockStatement> priorityStatements = createGetPriorityStatements(priorityVariables, customModel, lookup);\n+                HashSet<String> speedVariables = new LinkedHashSet<>();\n+                List<Java.BlockStatement> speedStatements = createGetSpeedStatements(speedVariables, customModel, lookup, globalMaxSpeed, maxSpeedFallback);\n+                // Create different class name, which is required only for debugging.\n+                // TODO does it improve performance too? I.e. it could be that the JIT is confused if different classes\n+                //  have the same name and it mixes performance stats. See https://github.com/janino-compiler/janino/issues/137\n+                long counter = longVal.incrementAndGet();\n+                String classTemplate = createClassTemplate(counter, priorityVariables, speedVariables, lookup, customModel);\n+                cu = (Java.CompilationUnit) new Parser(new org.codehaus.janino.Scanner(\"source\", new StringReader(classTemplate))).\n+                        parseAbstractCompilationUnit();\n+                cu = injectStatements(priorityStatements, speedStatements, cu);\n+                SimpleCompiler sc = createCompiler(counter, cu);\n+                clazz = sc.getClassLoader().loadClass(\"com.graphhopper.Test\" + counter);\n+                if (CACHE.size() < CACHE_SIZE)\n+                    CACHE.put(key, clazz);\n+                else if (DYN_CACHE_SIZE > 0)\n+                    DYN_CACHE.put(key, clazz);\n+            }\n+\n+            // The class does not need to be thread-safe as we create an instance per request\n+            CustomWeightingHelper prio = (CustomWeightingHelper) clazz.getDeclaredConstructor().newInstance();\n+            prio.init(lookup, avgSpeedEnc, customModel.getAreas());\n+            return prio;\n+        } catch (Exception ex) {\n+            String location = \"\";\n+            if (ex instanceof CompileException)\n+                location = \" in \" + ((CompileException) ex).getLocation().getFileName();\n+            throw new IllegalArgumentException(\"Cannot compile expression \" + location + \", \" + ex.getMessage(), ex);\n+        }\n+    }\n+\n+    /**\n+     * Parse the expressions from CustomModel relevant for the method getSpeed - see createClassTemplate.\n+     *\n+     * @return the created statements (parsed expressions)\n+     */\n+    private static List<Java.BlockStatement> createGetSpeedStatements(Set<String> speedVariables,\n+                                                                      CustomModel customModel, EncodedValueLookup lookup,\n+                                                                      double globalMaxSpeed, double maxSpeedFallback) throws Exception {\n+        List<Java.BlockStatement> speedStatements = new ArrayList<>();\n+        speedStatements.addAll(verifyExpressions(new StringBuilder(), \"speed_factor_user_statements\", speedVariables,\n+                customModel.getSpeedFactor(), lookup,\n+                num -> \"speed *= \" + num + \";\\n\", \"\"));\n+        StringBuilder codeSB = new StringBuilder(\"boolean applied = false;\\n\");\n+        speedStatements.addAll(verifyExpressions(codeSB, \"max_speed_user_statements\",\n+                speedVariables, customModel.getMaxSpeed(), lookup,\n+                num -> \"applied = true; speed = Math.min(speed,\" + num + \");\",\n+                \"if (!applied && speed > \" + maxSpeedFallback + \") return \" + maxSpeedFallback + \";\\n\" +\n+                        \"return Math.min(speed, \" + globalMaxSpeed + \");\\n\"));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTkxMzA0OA=="}, "originalCommit": {"oid": "f4478bb97c3d7585b21c39eadf45d80e57436cb3"}, "originalPosition": 133}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTkxNDUwOA==", "bodyText": "But I'm unsure if we really need this. I think we could replace maxSpeedFallback with max_speed and first_match.", "url": "https://github.com/graphhopper/graphhopper/pull/2209#discussion_r541914508", "createdAt": "2020-12-13T12:21:40Z", "author": {"login": "karussell"}, "path": "core/src/main/java/com/graphhopper/routing/weighting/custom/ExpressionBuilder.java", "diffHunk": "@@ -0,0 +1,379 @@\n+/*\n+ *  Licensed to GraphHopper GmbH under one or more contributor\n+ *  license agreements. See the NOTICE file distributed with this work for\n+ *  additional information regarding copyright ownership.\n+ *\n+ *  GraphHopper GmbH licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except in\n+ *  compliance with the License. You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package com.graphhopper.routing.weighting.custom;\n+\n+import com.graphhopper.json.geo.JsonFeature;\n+import com.graphhopper.routing.ev.DecimalEncodedValue;\n+import com.graphhopper.routing.ev.EncodedValue;\n+import com.graphhopper.routing.ev.EncodedValueLookup;\n+import com.graphhopper.routing.util.CustomModel;\n+import com.graphhopper.routing.util.EncodingManager;\n+import com.graphhopper.util.EdgeIteratorState;\n+import com.graphhopper.util.GHUtility;\n+import com.graphhopper.util.shapes.BBox;\n+import com.graphhopper.util.shapes.Polygon;\n+import org.codehaus.commons.compiler.CompileException;\n+import org.codehaus.commons.compiler.Location;\n+import org.codehaus.commons.compiler.io.Readers;\n+import org.codehaus.janino.Scanner;\n+import org.codehaus.janino.*;\n+import org.codehaus.janino.util.DeepCopier;\n+import org.locationtech.jts.geom.prep.PreparedGeometryFactory;\n+\n+import java.io.*;\n+import java.util.*;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+class ExpressionBuilder {\n+    private static final AtomicLong longVal = new AtomicLong(1);\n+    static final String IN_AREA_PREFIX = \"in_area_\";\n+    private static final Set<String> allowedNames = new HashSet<>(Arrays.asList(\"edge\", \"Math\"));\n+    private static final boolean JANINO_DEBUG = Boolean.getBoolean(Scanner.SYSTEM_PROPERTY_SOURCE_DEBUGGING_ENABLE);\n+\n+    // TODO without a cache we get X% slower routing and Y% slower routingLM8. CH requests and preparation is unaffected\n+    // as cached weighting from preparation is used. This cache ensures that the first Weighting classes, typically the\n+    // ones specified in the profiles, are never removed regardless of how frequent other Weightings are created and accessed.\n+    // We only need to synchronize the get and put methods alone. E.g. we do not care for the race condition where\n+    // two identical classes are requested and one of them is overwritten. We could use CachingJavaSourceClassLoader from\n+    // Janino but 1. we would need to use a single compiler across threads and 2. the statements (for priority and speed)\n+    // are still unnecessarily created.\n+    private static final int CACHE_SIZE = Integer.getInteger(\"graphhopper.custom_weighting.cache_size\", 10);\n+    // TODO perf compare with ConcurrentHashMap, but I guess, if there is a difference at all, it is not big for small maps\n+    private static final Map<String, Class> CACHE = Collections.synchronizedMap(new HashMap<>(CACHE_SIZE));\n+\n+    // Introduce a dynamic cache to remember different Weighting classes, but throw away less frequently used classes.\n+    // Use accessOrder==true to remove oldest accessed entry, not oldest inserted.\n+    private static final int DYN_CACHE_SIZE = Integer.getInteger(\"graphhopper.custom_weighting.dynamic_cache_size\", 1000);\n+    private static final Map<String, Class> DYN_CACHE = Collections.synchronizedMap(\n+            new LinkedHashMap<String, Class>(DYN_CACHE_SIZE, 0.75f, true) {\n+                protected boolean removeEldestEntry(Map.Entry eldest) {\n+                    return size() > DYN_CACHE_SIZE;\n+                }\n+            });\n+\n+    /**\n+     * This method compiles a new subclass of CustomWeightingHelper composed from the provided CustomModel caches this\n+     * and returns an instance.\n+     */\n+    static CustomWeightingHelper create(CustomModel customModel, EncodedValueLookup lookup,\n+                                        double globalMaxSpeed, double maxSpeedFallback, DecimalEncodedValue avgSpeedEnc) {\n+        Java.CompilationUnit cu;\n+        try {\n+            String key = customModel.toString() + \",global:\" + globalMaxSpeed + \",fallback:\" + maxSpeedFallback;\n+            if (key.length() > 400_000) throw new IllegalArgumentException(\"Custom Model too big: \" + key.length());\n+\n+            Class clazz = CACHE.get(key);\n+            if (DYN_CACHE_SIZE > 0 && clazz == null)\n+                clazz = DYN_CACHE.get(key);\n+            if (clazz == null) {\n+                HashSet<String> priorityVariables = new LinkedHashSet<>();\n+                List<Java.BlockStatement> priorityStatements = createGetPriorityStatements(priorityVariables, customModel, lookup);\n+                HashSet<String> speedVariables = new LinkedHashSet<>();\n+                List<Java.BlockStatement> speedStatements = createGetSpeedStatements(speedVariables, customModel, lookup, globalMaxSpeed, maxSpeedFallback);\n+                // Create different class name, which is required only for debugging.\n+                // TODO does it improve performance too? I.e. it could be that the JIT is confused if different classes\n+                //  have the same name and it mixes performance stats. See https://github.com/janino-compiler/janino/issues/137\n+                long counter = longVal.incrementAndGet();\n+                String classTemplate = createClassTemplate(counter, priorityVariables, speedVariables, lookup, customModel);\n+                cu = (Java.CompilationUnit) new Parser(new org.codehaus.janino.Scanner(\"source\", new StringReader(classTemplate))).\n+                        parseAbstractCompilationUnit();\n+                cu = injectStatements(priorityStatements, speedStatements, cu);\n+                SimpleCompiler sc = createCompiler(counter, cu);\n+                clazz = sc.getClassLoader().loadClass(\"com.graphhopper.Test\" + counter);\n+                if (CACHE.size() < CACHE_SIZE)\n+                    CACHE.put(key, clazz);\n+                else if (DYN_CACHE_SIZE > 0)\n+                    DYN_CACHE.put(key, clazz);\n+            }\n+\n+            // The class does not need to be thread-safe as we create an instance per request\n+            CustomWeightingHelper prio = (CustomWeightingHelper) clazz.getDeclaredConstructor().newInstance();\n+            prio.init(lookup, avgSpeedEnc, customModel.getAreas());\n+            return prio;\n+        } catch (Exception ex) {\n+            String location = \"\";\n+            if (ex instanceof CompileException)\n+                location = \" in \" + ((CompileException) ex).getLocation().getFileName();\n+            throw new IllegalArgumentException(\"Cannot compile expression \" + location + \", \" + ex.getMessage(), ex);\n+        }\n+    }\n+\n+    /**\n+     * Parse the expressions from CustomModel relevant for the method getSpeed - see createClassTemplate.\n+     *\n+     * @return the created statements (parsed expressions)\n+     */\n+    private static List<Java.BlockStatement> createGetSpeedStatements(Set<String> speedVariables,\n+                                                                      CustomModel customModel, EncodedValueLookup lookup,\n+                                                                      double globalMaxSpeed, double maxSpeedFallback) throws Exception {\n+        List<Java.BlockStatement> speedStatements = new ArrayList<>();\n+        speedStatements.addAll(verifyExpressions(new StringBuilder(), \"speed_factor_user_statements\", speedVariables,\n+                customModel.getSpeedFactor(), lookup,\n+                num -> \"speed *= \" + num + \";\\n\", \"\"));\n+        StringBuilder codeSB = new StringBuilder(\"boolean applied = false;\\n\");\n+        speedStatements.addAll(verifyExpressions(codeSB, \"max_speed_user_statements\",\n+                speedVariables, customModel.getMaxSpeed(), lookup,\n+                num -> \"applied = true; speed = Math.min(speed,\" + num + \");\",\n+                \"if (!applied && speed > \" + maxSpeedFallback + \") return \" + maxSpeedFallback + \";\\n\" +\n+                        \"return Math.min(speed, \" + globalMaxSpeed + \");\\n\"));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTkxMzA0OA=="}, "originalCommit": {"oid": "f4478bb97c3d7585b21c39eadf45d80e57436cb3"}, "originalPosition": 133}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTkyOTMzMw==", "bodyText": "Ah ok wow this logic is already not so easy to understand in master :) So we have the max_speed section we can use to set max speeds and then a global max speed fallback that always applies. Yes it seems like we can set a global max speed fallback using the else clause:\nmax_speed:\n   - if: road_class == PRIMARY\n     value: 80\n   - else: 60\nNote that here we should call the value value (or at least not factor).\nSetting only a fallback (but no other max speeds) works like this:\nmax_speed:\n   - if: false\n     factor: 999 # does not matter?!\n   - else: 60", "url": "https://github.com/graphhopper/graphhopper/pull/2209#discussion_r541929333", "createdAt": "2020-12-13T13:48:49Z", "author": {"login": "easbar"}, "path": "core/src/main/java/com/graphhopper/routing/weighting/custom/ExpressionBuilder.java", "diffHunk": "@@ -0,0 +1,379 @@\n+/*\n+ *  Licensed to GraphHopper GmbH under one or more contributor\n+ *  license agreements. See the NOTICE file distributed with this work for\n+ *  additional information regarding copyright ownership.\n+ *\n+ *  GraphHopper GmbH licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except in\n+ *  compliance with the License. You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package com.graphhopper.routing.weighting.custom;\n+\n+import com.graphhopper.json.geo.JsonFeature;\n+import com.graphhopper.routing.ev.DecimalEncodedValue;\n+import com.graphhopper.routing.ev.EncodedValue;\n+import com.graphhopper.routing.ev.EncodedValueLookup;\n+import com.graphhopper.routing.util.CustomModel;\n+import com.graphhopper.routing.util.EncodingManager;\n+import com.graphhopper.util.EdgeIteratorState;\n+import com.graphhopper.util.GHUtility;\n+import com.graphhopper.util.shapes.BBox;\n+import com.graphhopper.util.shapes.Polygon;\n+import org.codehaus.commons.compiler.CompileException;\n+import org.codehaus.commons.compiler.Location;\n+import org.codehaus.commons.compiler.io.Readers;\n+import org.codehaus.janino.Scanner;\n+import org.codehaus.janino.*;\n+import org.codehaus.janino.util.DeepCopier;\n+import org.locationtech.jts.geom.prep.PreparedGeometryFactory;\n+\n+import java.io.*;\n+import java.util.*;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+class ExpressionBuilder {\n+    private static final AtomicLong longVal = new AtomicLong(1);\n+    static final String IN_AREA_PREFIX = \"in_area_\";\n+    private static final Set<String> allowedNames = new HashSet<>(Arrays.asList(\"edge\", \"Math\"));\n+    private static final boolean JANINO_DEBUG = Boolean.getBoolean(Scanner.SYSTEM_PROPERTY_SOURCE_DEBUGGING_ENABLE);\n+\n+    // TODO without a cache we get X% slower routing and Y% slower routingLM8. CH requests and preparation is unaffected\n+    // as cached weighting from preparation is used. This cache ensures that the first Weighting classes, typically the\n+    // ones specified in the profiles, are never removed regardless of how frequent other Weightings are created and accessed.\n+    // We only need to synchronize the get and put methods alone. E.g. we do not care for the race condition where\n+    // two identical classes are requested and one of them is overwritten. We could use CachingJavaSourceClassLoader from\n+    // Janino but 1. we would need to use a single compiler across threads and 2. the statements (for priority and speed)\n+    // are still unnecessarily created.\n+    private static final int CACHE_SIZE = Integer.getInteger(\"graphhopper.custom_weighting.cache_size\", 10);\n+    // TODO perf compare with ConcurrentHashMap, but I guess, if there is a difference at all, it is not big for small maps\n+    private static final Map<String, Class> CACHE = Collections.synchronizedMap(new HashMap<>(CACHE_SIZE));\n+\n+    // Introduce a dynamic cache to remember different Weighting classes, but throw away less frequently used classes.\n+    // Use accessOrder==true to remove oldest accessed entry, not oldest inserted.\n+    private static final int DYN_CACHE_SIZE = Integer.getInteger(\"graphhopper.custom_weighting.dynamic_cache_size\", 1000);\n+    private static final Map<String, Class> DYN_CACHE = Collections.synchronizedMap(\n+            new LinkedHashMap<String, Class>(DYN_CACHE_SIZE, 0.75f, true) {\n+                protected boolean removeEldestEntry(Map.Entry eldest) {\n+                    return size() > DYN_CACHE_SIZE;\n+                }\n+            });\n+\n+    /**\n+     * This method compiles a new subclass of CustomWeightingHelper composed from the provided CustomModel caches this\n+     * and returns an instance.\n+     */\n+    static CustomWeightingHelper create(CustomModel customModel, EncodedValueLookup lookup,\n+                                        double globalMaxSpeed, double maxSpeedFallback, DecimalEncodedValue avgSpeedEnc) {\n+        Java.CompilationUnit cu;\n+        try {\n+            String key = customModel.toString() + \",global:\" + globalMaxSpeed + \",fallback:\" + maxSpeedFallback;\n+            if (key.length() > 400_000) throw new IllegalArgumentException(\"Custom Model too big: \" + key.length());\n+\n+            Class clazz = CACHE.get(key);\n+            if (DYN_CACHE_SIZE > 0 && clazz == null)\n+                clazz = DYN_CACHE.get(key);\n+            if (clazz == null) {\n+                HashSet<String> priorityVariables = new LinkedHashSet<>();\n+                List<Java.BlockStatement> priorityStatements = createGetPriorityStatements(priorityVariables, customModel, lookup);\n+                HashSet<String> speedVariables = new LinkedHashSet<>();\n+                List<Java.BlockStatement> speedStatements = createGetSpeedStatements(speedVariables, customModel, lookup, globalMaxSpeed, maxSpeedFallback);\n+                // Create different class name, which is required only for debugging.\n+                // TODO does it improve performance too? I.e. it could be that the JIT is confused if different classes\n+                //  have the same name and it mixes performance stats. See https://github.com/janino-compiler/janino/issues/137\n+                long counter = longVal.incrementAndGet();\n+                String classTemplate = createClassTemplate(counter, priorityVariables, speedVariables, lookup, customModel);\n+                cu = (Java.CompilationUnit) new Parser(new org.codehaus.janino.Scanner(\"source\", new StringReader(classTemplate))).\n+                        parseAbstractCompilationUnit();\n+                cu = injectStatements(priorityStatements, speedStatements, cu);\n+                SimpleCompiler sc = createCompiler(counter, cu);\n+                clazz = sc.getClassLoader().loadClass(\"com.graphhopper.Test\" + counter);\n+                if (CACHE.size() < CACHE_SIZE)\n+                    CACHE.put(key, clazz);\n+                else if (DYN_CACHE_SIZE > 0)\n+                    DYN_CACHE.put(key, clazz);\n+            }\n+\n+            // The class does not need to be thread-safe as we create an instance per request\n+            CustomWeightingHelper prio = (CustomWeightingHelper) clazz.getDeclaredConstructor().newInstance();\n+            prio.init(lookup, avgSpeedEnc, customModel.getAreas());\n+            return prio;\n+        } catch (Exception ex) {\n+            String location = \"\";\n+            if (ex instanceof CompileException)\n+                location = \" in \" + ((CompileException) ex).getLocation().getFileName();\n+            throw new IllegalArgumentException(\"Cannot compile expression \" + location + \", \" + ex.getMessage(), ex);\n+        }\n+    }\n+\n+    /**\n+     * Parse the expressions from CustomModel relevant for the method getSpeed - see createClassTemplate.\n+     *\n+     * @return the created statements (parsed expressions)\n+     */\n+    private static List<Java.BlockStatement> createGetSpeedStatements(Set<String> speedVariables,\n+                                                                      CustomModel customModel, EncodedValueLookup lookup,\n+                                                                      double globalMaxSpeed, double maxSpeedFallback) throws Exception {\n+        List<Java.BlockStatement> speedStatements = new ArrayList<>();\n+        speedStatements.addAll(verifyExpressions(new StringBuilder(), \"speed_factor_user_statements\", speedVariables,\n+                customModel.getSpeedFactor(), lookup,\n+                num -> \"speed *= \" + num + \";\\n\", \"\"));\n+        StringBuilder codeSB = new StringBuilder(\"boolean applied = false;\\n\");\n+        speedStatements.addAll(verifyExpressions(codeSB, \"max_speed_user_statements\",\n+                speedVariables, customModel.getMaxSpeed(), lookup,\n+                num -> \"applied = true; speed = Math.min(speed,\" + num + \");\",\n+                \"if (!applied && speed > \" + maxSpeedFallback + \") return \" + maxSpeedFallback + \";\\n\" +\n+                        \"return Math.min(speed, \" + globalMaxSpeed + \");\\n\"));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTkxMzA0OA=="}, "originalCommit": {"oid": "f4478bb97c3d7585b21c39eadf45d80e57436cb3"}, "originalPosition": 133}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjMwNjUxMQ==", "bodyText": "Note that here we should call the value value (or at least not factor).\n\n\ud83d\udc4d\n\nSetting only a fallback (but no other max speeds) works like this:\n\nWouldn't this better work?\nmax_speed:\n   - if: true\n     value: 60\n(and was it intentional to use factor in this example?)", "url": "https://github.com/graphhopper/graphhopper/pull/2209#discussion_r542306511", "createdAt": "2020-12-14T11:18:11Z", "author": {"login": "karussell"}, "path": "core/src/main/java/com/graphhopper/routing/weighting/custom/ExpressionBuilder.java", "diffHunk": "@@ -0,0 +1,379 @@\n+/*\n+ *  Licensed to GraphHopper GmbH under one or more contributor\n+ *  license agreements. See the NOTICE file distributed with this work for\n+ *  additional information regarding copyright ownership.\n+ *\n+ *  GraphHopper GmbH licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except in\n+ *  compliance with the License. You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package com.graphhopper.routing.weighting.custom;\n+\n+import com.graphhopper.json.geo.JsonFeature;\n+import com.graphhopper.routing.ev.DecimalEncodedValue;\n+import com.graphhopper.routing.ev.EncodedValue;\n+import com.graphhopper.routing.ev.EncodedValueLookup;\n+import com.graphhopper.routing.util.CustomModel;\n+import com.graphhopper.routing.util.EncodingManager;\n+import com.graphhopper.util.EdgeIteratorState;\n+import com.graphhopper.util.GHUtility;\n+import com.graphhopper.util.shapes.BBox;\n+import com.graphhopper.util.shapes.Polygon;\n+import org.codehaus.commons.compiler.CompileException;\n+import org.codehaus.commons.compiler.Location;\n+import org.codehaus.commons.compiler.io.Readers;\n+import org.codehaus.janino.Scanner;\n+import org.codehaus.janino.*;\n+import org.codehaus.janino.util.DeepCopier;\n+import org.locationtech.jts.geom.prep.PreparedGeometryFactory;\n+\n+import java.io.*;\n+import java.util.*;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+class ExpressionBuilder {\n+    private static final AtomicLong longVal = new AtomicLong(1);\n+    static final String IN_AREA_PREFIX = \"in_area_\";\n+    private static final Set<String> allowedNames = new HashSet<>(Arrays.asList(\"edge\", \"Math\"));\n+    private static final boolean JANINO_DEBUG = Boolean.getBoolean(Scanner.SYSTEM_PROPERTY_SOURCE_DEBUGGING_ENABLE);\n+\n+    // TODO without a cache we get X% slower routing and Y% slower routingLM8. CH requests and preparation is unaffected\n+    // as cached weighting from preparation is used. This cache ensures that the first Weighting classes, typically the\n+    // ones specified in the profiles, are never removed regardless of how frequent other Weightings are created and accessed.\n+    // We only need to synchronize the get and put methods alone. E.g. we do not care for the race condition where\n+    // two identical classes are requested and one of them is overwritten. We could use CachingJavaSourceClassLoader from\n+    // Janino but 1. we would need to use a single compiler across threads and 2. the statements (for priority and speed)\n+    // are still unnecessarily created.\n+    private static final int CACHE_SIZE = Integer.getInteger(\"graphhopper.custom_weighting.cache_size\", 10);\n+    // TODO perf compare with ConcurrentHashMap, but I guess, if there is a difference at all, it is not big for small maps\n+    private static final Map<String, Class> CACHE = Collections.synchronizedMap(new HashMap<>(CACHE_SIZE));\n+\n+    // Introduce a dynamic cache to remember different Weighting classes, but throw away less frequently used classes.\n+    // Use accessOrder==true to remove oldest accessed entry, not oldest inserted.\n+    private static final int DYN_CACHE_SIZE = Integer.getInteger(\"graphhopper.custom_weighting.dynamic_cache_size\", 1000);\n+    private static final Map<String, Class> DYN_CACHE = Collections.synchronizedMap(\n+            new LinkedHashMap<String, Class>(DYN_CACHE_SIZE, 0.75f, true) {\n+                protected boolean removeEldestEntry(Map.Entry eldest) {\n+                    return size() > DYN_CACHE_SIZE;\n+                }\n+            });\n+\n+    /**\n+     * This method compiles a new subclass of CustomWeightingHelper composed from the provided CustomModel caches this\n+     * and returns an instance.\n+     */\n+    static CustomWeightingHelper create(CustomModel customModel, EncodedValueLookup lookup,\n+                                        double globalMaxSpeed, double maxSpeedFallback, DecimalEncodedValue avgSpeedEnc) {\n+        Java.CompilationUnit cu;\n+        try {\n+            String key = customModel.toString() + \",global:\" + globalMaxSpeed + \",fallback:\" + maxSpeedFallback;\n+            if (key.length() > 400_000) throw new IllegalArgumentException(\"Custom Model too big: \" + key.length());\n+\n+            Class clazz = CACHE.get(key);\n+            if (DYN_CACHE_SIZE > 0 && clazz == null)\n+                clazz = DYN_CACHE.get(key);\n+            if (clazz == null) {\n+                HashSet<String> priorityVariables = new LinkedHashSet<>();\n+                List<Java.BlockStatement> priorityStatements = createGetPriorityStatements(priorityVariables, customModel, lookup);\n+                HashSet<String> speedVariables = new LinkedHashSet<>();\n+                List<Java.BlockStatement> speedStatements = createGetSpeedStatements(speedVariables, customModel, lookup, globalMaxSpeed, maxSpeedFallback);\n+                // Create different class name, which is required only for debugging.\n+                // TODO does it improve performance too? I.e. it could be that the JIT is confused if different classes\n+                //  have the same name and it mixes performance stats. See https://github.com/janino-compiler/janino/issues/137\n+                long counter = longVal.incrementAndGet();\n+                String classTemplate = createClassTemplate(counter, priorityVariables, speedVariables, lookup, customModel);\n+                cu = (Java.CompilationUnit) new Parser(new org.codehaus.janino.Scanner(\"source\", new StringReader(classTemplate))).\n+                        parseAbstractCompilationUnit();\n+                cu = injectStatements(priorityStatements, speedStatements, cu);\n+                SimpleCompiler sc = createCompiler(counter, cu);\n+                clazz = sc.getClassLoader().loadClass(\"com.graphhopper.Test\" + counter);\n+                if (CACHE.size() < CACHE_SIZE)\n+                    CACHE.put(key, clazz);\n+                else if (DYN_CACHE_SIZE > 0)\n+                    DYN_CACHE.put(key, clazz);\n+            }\n+\n+            // The class does not need to be thread-safe as we create an instance per request\n+            CustomWeightingHelper prio = (CustomWeightingHelper) clazz.getDeclaredConstructor().newInstance();\n+            prio.init(lookup, avgSpeedEnc, customModel.getAreas());\n+            return prio;\n+        } catch (Exception ex) {\n+            String location = \"\";\n+            if (ex instanceof CompileException)\n+                location = \" in \" + ((CompileException) ex).getLocation().getFileName();\n+            throw new IllegalArgumentException(\"Cannot compile expression \" + location + \", \" + ex.getMessage(), ex);\n+        }\n+    }\n+\n+    /**\n+     * Parse the expressions from CustomModel relevant for the method getSpeed - see createClassTemplate.\n+     *\n+     * @return the created statements (parsed expressions)\n+     */\n+    private static List<Java.BlockStatement> createGetSpeedStatements(Set<String> speedVariables,\n+                                                                      CustomModel customModel, EncodedValueLookup lookup,\n+                                                                      double globalMaxSpeed, double maxSpeedFallback) throws Exception {\n+        List<Java.BlockStatement> speedStatements = new ArrayList<>();\n+        speedStatements.addAll(verifyExpressions(new StringBuilder(), \"speed_factor_user_statements\", speedVariables,\n+                customModel.getSpeedFactor(), lookup,\n+                num -> \"speed *= \" + num + \";\\n\", \"\"));\n+        StringBuilder codeSB = new StringBuilder(\"boolean applied = false;\\n\");\n+        speedStatements.addAll(verifyExpressions(codeSB, \"max_speed_user_statements\",\n+                speedVariables, customModel.getMaxSpeed(), lookup,\n+                num -> \"applied = true; speed = Math.min(speed,\" + num + \");\",\n+                \"if (!applied && speed > \" + maxSpeedFallback + \") return \" + maxSpeedFallback + \";\\n\" +\n+                        \"return Math.min(speed, \" + globalMaxSpeed + \");\\n\"));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTkxMzA0OA=="}, "originalCommit": {"oid": "f4478bb97c3d7585b21c39eadf45d80e57436cb3"}, "originalPosition": 133}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjMyMjA4NA==", "bodyText": "Wouldn't this better work?\n\nOh of course yes :)\n\n(and was it intentional to use factor in this example?)\n\nNo this should also be value (or similar)", "url": "https://github.com/graphhopper/graphhopper/pull/2209#discussion_r542322084", "createdAt": "2020-12-14T11:45:00Z", "author": {"login": "easbar"}, "path": "core/src/main/java/com/graphhopper/routing/weighting/custom/ExpressionBuilder.java", "diffHunk": "@@ -0,0 +1,379 @@\n+/*\n+ *  Licensed to GraphHopper GmbH under one or more contributor\n+ *  license agreements. See the NOTICE file distributed with this work for\n+ *  additional information regarding copyright ownership.\n+ *\n+ *  GraphHopper GmbH licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except in\n+ *  compliance with the License. You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package com.graphhopper.routing.weighting.custom;\n+\n+import com.graphhopper.json.geo.JsonFeature;\n+import com.graphhopper.routing.ev.DecimalEncodedValue;\n+import com.graphhopper.routing.ev.EncodedValue;\n+import com.graphhopper.routing.ev.EncodedValueLookup;\n+import com.graphhopper.routing.util.CustomModel;\n+import com.graphhopper.routing.util.EncodingManager;\n+import com.graphhopper.util.EdgeIteratorState;\n+import com.graphhopper.util.GHUtility;\n+import com.graphhopper.util.shapes.BBox;\n+import com.graphhopper.util.shapes.Polygon;\n+import org.codehaus.commons.compiler.CompileException;\n+import org.codehaus.commons.compiler.Location;\n+import org.codehaus.commons.compiler.io.Readers;\n+import org.codehaus.janino.Scanner;\n+import org.codehaus.janino.*;\n+import org.codehaus.janino.util.DeepCopier;\n+import org.locationtech.jts.geom.prep.PreparedGeometryFactory;\n+\n+import java.io.*;\n+import java.util.*;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+class ExpressionBuilder {\n+    private static final AtomicLong longVal = new AtomicLong(1);\n+    static final String IN_AREA_PREFIX = \"in_area_\";\n+    private static final Set<String> allowedNames = new HashSet<>(Arrays.asList(\"edge\", \"Math\"));\n+    private static final boolean JANINO_DEBUG = Boolean.getBoolean(Scanner.SYSTEM_PROPERTY_SOURCE_DEBUGGING_ENABLE);\n+\n+    // TODO without a cache we get X% slower routing and Y% slower routingLM8. CH requests and preparation is unaffected\n+    // as cached weighting from preparation is used. This cache ensures that the first Weighting classes, typically the\n+    // ones specified in the profiles, are never removed regardless of how frequent other Weightings are created and accessed.\n+    // We only need to synchronize the get and put methods alone. E.g. we do not care for the race condition where\n+    // two identical classes are requested and one of them is overwritten. We could use CachingJavaSourceClassLoader from\n+    // Janino but 1. we would need to use a single compiler across threads and 2. the statements (for priority and speed)\n+    // are still unnecessarily created.\n+    private static final int CACHE_SIZE = Integer.getInteger(\"graphhopper.custom_weighting.cache_size\", 10);\n+    // TODO perf compare with ConcurrentHashMap, but I guess, if there is a difference at all, it is not big for small maps\n+    private static final Map<String, Class> CACHE = Collections.synchronizedMap(new HashMap<>(CACHE_SIZE));\n+\n+    // Introduce a dynamic cache to remember different Weighting classes, but throw away less frequently used classes.\n+    // Use accessOrder==true to remove oldest accessed entry, not oldest inserted.\n+    private static final int DYN_CACHE_SIZE = Integer.getInteger(\"graphhopper.custom_weighting.dynamic_cache_size\", 1000);\n+    private static final Map<String, Class> DYN_CACHE = Collections.synchronizedMap(\n+            new LinkedHashMap<String, Class>(DYN_CACHE_SIZE, 0.75f, true) {\n+                protected boolean removeEldestEntry(Map.Entry eldest) {\n+                    return size() > DYN_CACHE_SIZE;\n+                }\n+            });\n+\n+    /**\n+     * This method compiles a new subclass of CustomWeightingHelper composed from the provided CustomModel caches this\n+     * and returns an instance.\n+     */\n+    static CustomWeightingHelper create(CustomModel customModel, EncodedValueLookup lookup,\n+                                        double globalMaxSpeed, double maxSpeedFallback, DecimalEncodedValue avgSpeedEnc) {\n+        Java.CompilationUnit cu;\n+        try {\n+            String key = customModel.toString() + \",global:\" + globalMaxSpeed + \",fallback:\" + maxSpeedFallback;\n+            if (key.length() > 400_000) throw new IllegalArgumentException(\"Custom Model too big: \" + key.length());\n+\n+            Class clazz = CACHE.get(key);\n+            if (DYN_CACHE_SIZE > 0 && clazz == null)\n+                clazz = DYN_CACHE.get(key);\n+            if (clazz == null) {\n+                HashSet<String> priorityVariables = new LinkedHashSet<>();\n+                List<Java.BlockStatement> priorityStatements = createGetPriorityStatements(priorityVariables, customModel, lookup);\n+                HashSet<String> speedVariables = new LinkedHashSet<>();\n+                List<Java.BlockStatement> speedStatements = createGetSpeedStatements(speedVariables, customModel, lookup, globalMaxSpeed, maxSpeedFallback);\n+                // Create different class name, which is required only for debugging.\n+                // TODO does it improve performance too? I.e. it could be that the JIT is confused if different classes\n+                //  have the same name and it mixes performance stats. See https://github.com/janino-compiler/janino/issues/137\n+                long counter = longVal.incrementAndGet();\n+                String classTemplate = createClassTemplate(counter, priorityVariables, speedVariables, lookup, customModel);\n+                cu = (Java.CompilationUnit) new Parser(new org.codehaus.janino.Scanner(\"source\", new StringReader(classTemplate))).\n+                        parseAbstractCompilationUnit();\n+                cu = injectStatements(priorityStatements, speedStatements, cu);\n+                SimpleCompiler sc = createCompiler(counter, cu);\n+                clazz = sc.getClassLoader().loadClass(\"com.graphhopper.Test\" + counter);\n+                if (CACHE.size() < CACHE_SIZE)\n+                    CACHE.put(key, clazz);\n+                else if (DYN_CACHE_SIZE > 0)\n+                    DYN_CACHE.put(key, clazz);\n+            }\n+\n+            // The class does not need to be thread-safe as we create an instance per request\n+            CustomWeightingHelper prio = (CustomWeightingHelper) clazz.getDeclaredConstructor().newInstance();\n+            prio.init(lookup, avgSpeedEnc, customModel.getAreas());\n+            return prio;\n+        } catch (Exception ex) {\n+            String location = \"\";\n+            if (ex instanceof CompileException)\n+                location = \" in \" + ((CompileException) ex).getLocation().getFileName();\n+            throw new IllegalArgumentException(\"Cannot compile expression \" + location + \", \" + ex.getMessage(), ex);\n+        }\n+    }\n+\n+    /**\n+     * Parse the expressions from CustomModel relevant for the method getSpeed - see createClassTemplate.\n+     *\n+     * @return the created statements (parsed expressions)\n+     */\n+    private static List<Java.BlockStatement> createGetSpeedStatements(Set<String> speedVariables,\n+                                                                      CustomModel customModel, EncodedValueLookup lookup,\n+                                                                      double globalMaxSpeed, double maxSpeedFallback) throws Exception {\n+        List<Java.BlockStatement> speedStatements = new ArrayList<>();\n+        speedStatements.addAll(verifyExpressions(new StringBuilder(), \"speed_factor_user_statements\", speedVariables,\n+                customModel.getSpeedFactor(), lookup,\n+                num -> \"speed *= \" + num + \";\\n\", \"\"));\n+        StringBuilder codeSB = new StringBuilder(\"boolean applied = false;\\n\");\n+        speedStatements.addAll(verifyExpressions(codeSB, \"max_speed_user_statements\",\n+                speedVariables, customModel.getMaxSpeed(), lookup,\n+                num -> \"applied = true; speed = Math.min(speed,\" + num + \");\",\n+                \"if (!applied && speed > \" + maxSpeedFallback + \") return \" + maxSpeedFallback + \";\\n\" +\n+                        \"return Math.min(speed, \" + globalMaxSpeed + \");\\n\"));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTkxMzA0OA=="}, "originalCommit": {"oid": "f4478bb97c3d7585b21c39eadf45d80e57436cb3"}, "originalPosition": 133}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjMyNDcyOA==", "bodyText": "Ok, will remove getMaxSpeedFallback after you merged #2211.", "url": "https://github.com/graphhopper/graphhopper/pull/2209#discussion_r542324728", "createdAt": "2020-12-14T11:49:36Z", "author": {"login": "karussell"}, "path": "core/src/main/java/com/graphhopper/routing/weighting/custom/ExpressionBuilder.java", "diffHunk": "@@ -0,0 +1,379 @@\n+/*\n+ *  Licensed to GraphHopper GmbH under one or more contributor\n+ *  license agreements. See the NOTICE file distributed with this work for\n+ *  additional information regarding copyright ownership.\n+ *\n+ *  GraphHopper GmbH licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except in\n+ *  compliance with the License. You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package com.graphhopper.routing.weighting.custom;\n+\n+import com.graphhopper.json.geo.JsonFeature;\n+import com.graphhopper.routing.ev.DecimalEncodedValue;\n+import com.graphhopper.routing.ev.EncodedValue;\n+import com.graphhopper.routing.ev.EncodedValueLookup;\n+import com.graphhopper.routing.util.CustomModel;\n+import com.graphhopper.routing.util.EncodingManager;\n+import com.graphhopper.util.EdgeIteratorState;\n+import com.graphhopper.util.GHUtility;\n+import com.graphhopper.util.shapes.BBox;\n+import com.graphhopper.util.shapes.Polygon;\n+import org.codehaus.commons.compiler.CompileException;\n+import org.codehaus.commons.compiler.Location;\n+import org.codehaus.commons.compiler.io.Readers;\n+import org.codehaus.janino.Scanner;\n+import org.codehaus.janino.*;\n+import org.codehaus.janino.util.DeepCopier;\n+import org.locationtech.jts.geom.prep.PreparedGeometryFactory;\n+\n+import java.io.*;\n+import java.util.*;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+class ExpressionBuilder {\n+    private static final AtomicLong longVal = new AtomicLong(1);\n+    static final String IN_AREA_PREFIX = \"in_area_\";\n+    private static final Set<String> allowedNames = new HashSet<>(Arrays.asList(\"edge\", \"Math\"));\n+    private static final boolean JANINO_DEBUG = Boolean.getBoolean(Scanner.SYSTEM_PROPERTY_SOURCE_DEBUGGING_ENABLE);\n+\n+    // TODO without a cache we get X% slower routing and Y% slower routingLM8. CH requests and preparation is unaffected\n+    // as cached weighting from preparation is used. This cache ensures that the first Weighting classes, typically the\n+    // ones specified in the profiles, are never removed regardless of how frequent other Weightings are created and accessed.\n+    // We only need to synchronize the get and put methods alone. E.g. we do not care for the race condition where\n+    // two identical classes are requested and one of them is overwritten. We could use CachingJavaSourceClassLoader from\n+    // Janino but 1. we would need to use a single compiler across threads and 2. the statements (for priority and speed)\n+    // are still unnecessarily created.\n+    private static final int CACHE_SIZE = Integer.getInteger(\"graphhopper.custom_weighting.cache_size\", 10);\n+    // TODO perf compare with ConcurrentHashMap, but I guess, if there is a difference at all, it is not big for small maps\n+    private static final Map<String, Class> CACHE = Collections.synchronizedMap(new HashMap<>(CACHE_SIZE));\n+\n+    // Introduce a dynamic cache to remember different Weighting classes, but throw away less frequently used classes.\n+    // Use accessOrder==true to remove oldest accessed entry, not oldest inserted.\n+    private static final int DYN_CACHE_SIZE = Integer.getInteger(\"graphhopper.custom_weighting.dynamic_cache_size\", 1000);\n+    private static final Map<String, Class> DYN_CACHE = Collections.synchronizedMap(\n+            new LinkedHashMap<String, Class>(DYN_CACHE_SIZE, 0.75f, true) {\n+                protected boolean removeEldestEntry(Map.Entry eldest) {\n+                    return size() > DYN_CACHE_SIZE;\n+                }\n+            });\n+\n+    /**\n+     * This method compiles a new subclass of CustomWeightingHelper composed from the provided CustomModel caches this\n+     * and returns an instance.\n+     */\n+    static CustomWeightingHelper create(CustomModel customModel, EncodedValueLookup lookup,\n+                                        double globalMaxSpeed, double maxSpeedFallback, DecimalEncodedValue avgSpeedEnc) {\n+        Java.CompilationUnit cu;\n+        try {\n+            String key = customModel.toString() + \",global:\" + globalMaxSpeed + \",fallback:\" + maxSpeedFallback;\n+            if (key.length() > 400_000) throw new IllegalArgumentException(\"Custom Model too big: \" + key.length());\n+\n+            Class clazz = CACHE.get(key);\n+            if (DYN_CACHE_SIZE > 0 && clazz == null)\n+                clazz = DYN_CACHE.get(key);\n+            if (clazz == null) {\n+                HashSet<String> priorityVariables = new LinkedHashSet<>();\n+                List<Java.BlockStatement> priorityStatements = createGetPriorityStatements(priorityVariables, customModel, lookup);\n+                HashSet<String> speedVariables = new LinkedHashSet<>();\n+                List<Java.BlockStatement> speedStatements = createGetSpeedStatements(speedVariables, customModel, lookup, globalMaxSpeed, maxSpeedFallback);\n+                // Create different class name, which is required only for debugging.\n+                // TODO does it improve performance too? I.e. it could be that the JIT is confused if different classes\n+                //  have the same name and it mixes performance stats. See https://github.com/janino-compiler/janino/issues/137\n+                long counter = longVal.incrementAndGet();\n+                String classTemplate = createClassTemplate(counter, priorityVariables, speedVariables, lookup, customModel);\n+                cu = (Java.CompilationUnit) new Parser(new org.codehaus.janino.Scanner(\"source\", new StringReader(classTemplate))).\n+                        parseAbstractCompilationUnit();\n+                cu = injectStatements(priorityStatements, speedStatements, cu);\n+                SimpleCompiler sc = createCompiler(counter, cu);\n+                clazz = sc.getClassLoader().loadClass(\"com.graphhopper.Test\" + counter);\n+                if (CACHE.size() < CACHE_SIZE)\n+                    CACHE.put(key, clazz);\n+                else if (DYN_CACHE_SIZE > 0)\n+                    DYN_CACHE.put(key, clazz);\n+            }\n+\n+            // The class does not need to be thread-safe as we create an instance per request\n+            CustomWeightingHelper prio = (CustomWeightingHelper) clazz.getDeclaredConstructor().newInstance();\n+            prio.init(lookup, avgSpeedEnc, customModel.getAreas());\n+            return prio;\n+        } catch (Exception ex) {\n+            String location = \"\";\n+            if (ex instanceof CompileException)\n+                location = \" in \" + ((CompileException) ex).getLocation().getFileName();\n+            throw new IllegalArgumentException(\"Cannot compile expression \" + location + \", \" + ex.getMessage(), ex);\n+        }\n+    }\n+\n+    /**\n+     * Parse the expressions from CustomModel relevant for the method getSpeed - see createClassTemplate.\n+     *\n+     * @return the created statements (parsed expressions)\n+     */\n+    private static List<Java.BlockStatement> createGetSpeedStatements(Set<String> speedVariables,\n+                                                                      CustomModel customModel, EncodedValueLookup lookup,\n+                                                                      double globalMaxSpeed, double maxSpeedFallback) throws Exception {\n+        List<Java.BlockStatement> speedStatements = new ArrayList<>();\n+        speedStatements.addAll(verifyExpressions(new StringBuilder(), \"speed_factor_user_statements\", speedVariables,\n+                customModel.getSpeedFactor(), lookup,\n+                num -> \"speed *= \" + num + \";\\n\", \"\"));\n+        StringBuilder codeSB = new StringBuilder(\"boolean applied = false;\\n\");\n+        speedStatements.addAll(verifyExpressions(codeSB, \"max_speed_user_statements\",\n+                speedVariables, customModel.getMaxSpeed(), lookup,\n+                num -> \"applied = true; speed = Math.min(speed,\" + num + \");\",\n+                \"if (!applied && speed > \" + maxSpeedFallback + \") return \" + maxSpeedFallback + \";\\n\" +\n+                        \"return Math.min(speed, \" + globalMaxSpeed + \");\\n\"));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTkxMzA0OA=="}, "originalCommit": {"oid": "f4478bb97c3d7585b21c39eadf45d80e57436cb3"}, "originalPosition": 133}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjMzMzc3MA==", "bodyText": "Ah you mean in the current format we can already do:\nmax_speed:\n   true: 60\n?", "url": "https://github.com/graphhopper/graphhopper/pull/2209#discussion_r542333770", "createdAt": "2020-12-14T12:05:59Z", "author": {"login": "easbar"}, "path": "core/src/main/java/com/graphhopper/routing/weighting/custom/ExpressionBuilder.java", "diffHunk": "@@ -0,0 +1,379 @@\n+/*\n+ *  Licensed to GraphHopper GmbH under one or more contributor\n+ *  license agreements. See the NOTICE file distributed with this work for\n+ *  additional information regarding copyright ownership.\n+ *\n+ *  GraphHopper GmbH licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except in\n+ *  compliance with the License. You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package com.graphhopper.routing.weighting.custom;\n+\n+import com.graphhopper.json.geo.JsonFeature;\n+import com.graphhopper.routing.ev.DecimalEncodedValue;\n+import com.graphhopper.routing.ev.EncodedValue;\n+import com.graphhopper.routing.ev.EncodedValueLookup;\n+import com.graphhopper.routing.util.CustomModel;\n+import com.graphhopper.routing.util.EncodingManager;\n+import com.graphhopper.util.EdgeIteratorState;\n+import com.graphhopper.util.GHUtility;\n+import com.graphhopper.util.shapes.BBox;\n+import com.graphhopper.util.shapes.Polygon;\n+import org.codehaus.commons.compiler.CompileException;\n+import org.codehaus.commons.compiler.Location;\n+import org.codehaus.commons.compiler.io.Readers;\n+import org.codehaus.janino.Scanner;\n+import org.codehaus.janino.*;\n+import org.codehaus.janino.util.DeepCopier;\n+import org.locationtech.jts.geom.prep.PreparedGeometryFactory;\n+\n+import java.io.*;\n+import java.util.*;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+class ExpressionBuilder {\n+    private static final AtomicLong longVal = new AtomicLong(1);\n+    static final String IN_AREA_PREFIX = \"in_area_\";\n+    private static final Set<String> allowedNames = new HashSet<>(Arrays.asList(\"edge\", \"Math\"));\n+    private static final boolean JANINO_DEBUG = Boolean.getBoolean(Scanner.SYSTEM_PROPERTY_SOURCE_DEBUGGING_ENABLE);\n+\n+    // TODO without a cache we get X% slower routing and Y% slower routingLM8. CH requests and preparation is unaffected\n+    // as cached weighting from preparation is used. This cache ensures that the first Weighting classes, typically the\n+    // ones specified in the profiles, are never removed regardless of how frequent other Weightings are created and accessed.\n+    // We only need to synchronize the get and put methods alone. E.g. we do not care for the race condition where\n+    // two identical classes are requested and one of them is overwritten. We could use CachingJavaSourceClassLoader from\n+    // Janino but 1. we would need to use a single compiler across threads and 2. the statements (for priority and speed)\n+    // are still unnecessarily created.\n+    private static final int CACHE_SIZE = Integer.getInteger(\"graphhopper.custom_weighting.cache_size\", 10);\n+    // TODO perf compare with ConcurrentHashMap, but I guess, if there is a difference at all, it is not big for small maps\n+    private static final Map<String, Class> CACHE = Collections.synchronizedMap(new HashMap<>(CACHE_SIZE));\n+\n+    // Introduce a dynamic cache to remember different Weighting classes, but throw away less frequently used classes.\n+    // Use accessOrder==true to remove oldest accessed entry, not oldest inserted.\n+    private static final int DYN_CACHE_SIZE = Integer.getInteger(\"graphhopper.custom_weighting.dynamic_cache_size\", 1000);\n+    private static final Map<String, Class> DYN_CACHE = Collections.synchronizedMap(\n+            new LinkedHashMap<String, Class>(DYN_CACHE_SIZE, 0.75f, true) {\n+                protected boolean removeEldestEntry(Map.Entry eldest) {\n+                    return size() > DYN_CACHE_SIZE;\n+                }\n+            });\n+\n+    /**\n+     * This method compiles a new subclass of CustomWeightingHelper composed from the provided CustomModel caches this\n+     * and returns an instance.\n+     */\n+    static CustomWeightingHelper create(CustomModel customModel, EncodedValueLookup lookup,\n+                                        double globalMaxSpeed, double maxSpeedFallback, DecimalEncodedValue avgSpeedEnc) {\n+        Java.CompilationUnit cu;\n+        try {\n+            String key = customModel.toString() + \",global:\" + globalMaxSpeed + \",fallback:\" + maxSpeedFallback;\n+            if (key.length() > 400_000) throw new IllegalArgumentException(\"Custom Model too big: \" + key.length());\n+\n+            Class clazz = CACHE.get(key);\n+            if (DYN_CACHE_SIZE > 0 && clazz == null)\n+                clazz = DYN_CACHE.get(key);\n+            if (clazz == null) {\n+                HashSet<String> priorityVariables = new LinkedHashSet<>();\n+                List<Java.BlockStatement> priorityStatements = createGetPriorityStatements(priorityVariables, customModel, lookup);\n+                HashSet<String> speedVariables = new LinkedHashSet<>();\n+                List<Java.BlockStatement> speedStatements = createGetSpeedStatements(speedVariables, customModel, lookup, globalMaxSpeed, maxSpeedFallback);\n+                // Create different class name, which is required only for debugging.\n+                // TODO does it improve performance too? I.e. it could be that the JIT is confused if different classes\n+                //  have the same name and it mixes performance stats. See https://github.com/janino-compiler/janino/issues/137\n+                long counter = longVal.incrementAndGet();\n+                String classTemplate = createClassTemplate(counter, priorityVariables, speedVariables, lookup, customModel);\n+                cu = (Java.CompilationUnit) new Parser(new org.codehaus.janino.Scanner(\"source\", new StringReader(classTemplate))).\n+                        parseAbstractCompilationUnit();\n+                cu = injectStatements(priorityStatements, speedStatements, cu);\n+                SimpleCompiler sc = createCompiler(counter, cu);\n+                clazz = sc.getClassLoader().loadClass(\"com.graphhopper.Test\" + counter);\n+                if (CACHE.size() < CACHE_SIZE)\n+                    CACHE.put(key, clazz);\n+                else if (DYN_CACHE_SIZE > 0)\n+                    DYN_CACHE.put(key, clazz);\n+            }\n+\n+            // The class does not need to be thread-safe as we create an instance per request\n+            CustomWeightingHelper prio = (CustomWeightingHelper) clazz.getDeclaredConstructor().newInstance();\n+            prio.init(lookup, avgSpeedEnc, customModel.getAreas());\n+            return prio;\n+        } catch (Exception ex) {\n+            String location = \"\";\n+            if (ex instanceof CompileException)\n+                location = \" in \" + ((CompileException) ex).getLocation().getFileName();\n+            throw new IllegalArgumentException(\"Cannot compile expression \" + location + \", \" + ex.getMessage(), ex);\n+        }\n+    }\n+\n+    /**\n+     * Parse the expressions from CustomModel relevant for the method getSpeed - see createClassTemplate.\n+     *\n+     * @return the created statements (parsed expressions)\n+     */\n+    private static List<Java.BlockStatement> createGetSpeedStatements(Set<String> speedVariables,\n+                                                                      CustomModel customModel, EncodedValueLookup lookup,\n+                                                                      double globalMaxSpeed, double maxSpeedFallback) throws Exception {\n+        List<Java.BlockStatement> speedStatements = new ArrayList<>();\n+        speedStatements.addAll(verifyExpressions(new StringBuilder(), \"speed_factor_user_statements\", speedVariables,\n+                customModel.getSpeedFactor(), lookup,\n+                num -> \"speed *= \" + num + \";\\n\", \"\"));\n+        StringBuilder codeSB = new StringBuilder(\"boolean applied = false;\\n\");\n+        speedStatements.addAll(verifyExpressions(codeSB, \"max_speed_user_statements\",\n+                speedVariables, customModel.getMaxSpeed(), lookup,\n+                num -> \"applied = true; speed = Math.min(speed,\" + num + \");\",\n+                \"if (!applied && speed > \" + maxSpeedFallback + \") return \" + maxSpeedFallback + \";\\n\" +\n+                        \"return Math.min(speed, \" + globalMaxSpeed + \");\\n\"));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTkxMzA0OA=="}, "originalCommit": {"oid": "f4478bb97c3d7585b21c39eadf45d80e57436cb3"}, "originalPosition": 133}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjM0NDQ5OQ==", "bodyText": "Yes", "url": "https://github.com/graphhopper/graphhopper/pull/2209#discussion_r542344499", "createdAt": "2020-12-14T12:26:09Z", "author": {"login": "karussell"}, "path": "core/src/main/java/com/graphhopper/routing/weighting/custom/ExpressionBuilder.java", "diffHunk": "@@ -0,0 +1,379 @@\n+/*\n+ *  Licensed to GraphHopper GmbH under one or more contributor\n+ *  license agreements. See the NOTICE file distributed with this work for\n+ *  additional information regarding copyright ownership.\n+ *\n+ *  GraphHopper GmbH licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except in\n+ *  compliance with the License. You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package com.graphhopper.routing.weighting.custom;\n+\n+import com.graphhopper.json.geo.JsonFeature;\n+import com.graphhopper.routing.ev.DecimalEncodedValue;\n+import com.graphhopper.routing.ev.EncodedValue;\n+import com.graphhopper.routing.ev.EncodedValueLookup;\n+import com.graphhopper.routing.util.CustomModel;\n+import com.graphhopper.routing.util.EncodingManager;\n+import com.graphhopper.util.EdgeIteratorState;\n+import com.graphhopper.util.GHUtility;\n+import com.graphhopper.util.shapes.BBox;\n+import com.graphhopper.util.shapes.Polygon;\n+import org.codehaus.commons.compiler.CompileException;\n+import org.codehaus.commons.compiler.Location;\n+import org.codehaus.commons.compiler.io.Readers;\n+import org.codehaus.janino.Scanner;\n+import org.codehaus.janino.*;\n+import org.codehaus.janino.util.DeepCopier;\n+import org.locationtech.jts.geom.prep.PreparedGeometryFactory;\n+\n+import java.io.*;\n+import java.util.*;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+class ExpressionBuilder {\n+    private static final AtomicLong longVal = new AtomicLong(1);\n+    static final String IN_AREA_PREFIX = \"in_area_\";\n+    private static final Set<String> allowedNames = new HashSet<>(Arrays.asList(\"edge\", \"Math\"));\n+    private static final boolean JANINO_DEBUG = Boolean.getBoolean(Scanner.SYSTEM_PROPERTY_SOURCE_DEBUGGING_ENABLE);\n+\n+    // TODO without a cache we get X% slower routing and Y% slower routingLM8. CH requests and preparation is unaffected\n+    // as cached weighting from preparation is used. This cache ensures that the first Weighting classes, typically the\n+    // ones specified in the profiles, are never removed regardless of how frequent other Weightings are created and accessed.\n+    // We only need to synchronize the get and put methods alone. E.g. we do not care for the race condition where\n+    // two identical classes are requested and one of them is overwritten. We could use CachingJavaSourceClassLoader from\n+    // Janino but 1. we would need to use a single compiler across threads and 2. the statements (for priority and speed)\n+    // are still unnecessarily created.\n+    private static final int CACHE_SIZE = Integer.getInteger(\"graphhopper.custom_weighting.cache_size\", 10);\n+    // TODO perf compare with ConcurrentHashMap, but I guess, if there is a difference at all, it is not big for small maps\n+    private static final Map<String, Class> CACHE = Collections.synchronizedMap(new HashMap<>(CACHE_SIZE));\n+\n+    // Introduce a dynamic cache to remember different Weighting classes, but throw away less frequently used classes.\n+    // Use accessOrder==true to remove oldest accessed entry, not oldest inserted.\n+    private static final int DYN_CACHE_SIZE = Integer.getInteger(\"graphhopper.custom_weighting.dynamic_cache_size\", 1000);\n+    private static final Map<String, Class> DYN_CACHE = Collections.synchronizedMap(\n+            new LinkedHashMap<String, Class>(DYN_CACHE_SIZE, 0.75f, true) {\n+                protected boolean removeEldestEntry(Map.Entry eldest) {\n+                    return size() > DYN_CACHE_SIZE;\n+                }\n+            });\n+\n+    /**\n+     * This method compiles a new subclass of CustomWeightingHelper composed from the provided CustomModel caches this\n+     * and returns an instance.\n+     */\n+    static CustomWeightingHelper create(CustomModel customModel, EncodedValueLookup lookup,\n+                                        double globalMaxSpeed, double maxSpeedFallback, DecimalEncodedValue avgSpeedEnc) {\n+        Java.CompilationUnit cu;\n+        try {\n+            String key = customModel.toString() + \",global:\" + globalMaxSpeed + \",fallback:\" + maxSpeedFallback;\n+            if (key.length() > 400_000) throw new IllegalArgumentException(\"Custom Model too big: \" + key.length());\n+\n+            Class clazz = CACHE.get(key);\n+            if (DYN_CACHE_SIZE > 0 && clazz == null)\n+                clazz = DYN_CACHE.get(key);\n+            if (clazz == null) {\n+                HashSet<String> priorityVariables = new LinkedHashSet<>();\n+                List<Java.BlockStatement> priorityStatements = createGetPriorityStatements(priorityVariables, customModel, lookup);\n+                HashSet<String> speedVariables = new LinkedHashSet<>();\n+                List<Java.BlockStatement> speedStatements = createGetSpeedStatements(speedVariables, customModel, lookup, globalMaxSpeed, maxSpeedFallback);\n+                // Create different class name, which is required only for debugging.\n+                // TODO does it improve performance too? I.e. it could be that the JIT is confused if different classes\n+                //  have the same name and it mixes performance stats. See https://github.com/janino-compiler/janino/issues/137\n+                long counter = longVal.incrementAndGet();\n+                String classTemplate = createClassTemplate(counter, priorityVariables, speedVariables, lookup, customModel);\n+                cu = (Java.CompilationUnit) new Parser(new org.codehaus.janino.Scanner(\"source\", new StringReader(classTemplate))).\n+                        parseAbstractCompilationUnit();\n+                cu = injectStatements(priorityStatements, speedStatements, cu);\n+                SimpleCompiler sc = createCompiler(counter, cu);\n+                clazz = sc.getClassLoader().loadClass(\"com.graphhopper.Test\" + counter);\n+                if (CACHE.size() < CACHE_SIZE)\n+                    CACHE.put(key, clazz);\n+                else if (DYN_CACHE_SIZE > 0)\n+                    DYN_CACHE.put(key, clazz);\n+            }\n+\n+            // The class does not need to be thread-safe as we create an instance per request\n+            CustomWeightingHelper prio = (CustomWeightingHelper) clazz.getDeclaredConstructor().newInstance();\n+            prio.init(lookup, avgSpeedEnc, customModel.getAreas());\n+            return prio;\n+        } catch (Exception ex) {\n+            String location = \"\";\n+            if (ex instanceof CompileException)\n+                location = \" in \" + ((CompileException) ex).getLocation().getFileName();\n+            throw new IllegalArgumentException(\"Cannot compile expression \" + location + \", \" + ex.getMessage(), ex);\n+        }\n+    }\n+\n+    /**\n+     * Parse the expressions from CustomModel relevant for the method getSpeed - see createClassTemplate.\n+     *\n+     * @return the created statements (parsed expressions)\n+     */\n+    private static List<Java.BlockStatement> createGetSpeedStatements(Set<String> speedVariables,\n+                                                                      CustomModel customModel, EncodedValueLookup lookup,\n+                                                                      double globalMaxSpeed, double maxSpeedFallback) throws Exception {\n+        List<Java.BlockStatement> speedStatements = new ArrayList<>();\n+        speedStatements.addAll(verifyExpressions(new StringBuilder(), \"speed_factor_user_statements\", speedVariables,\n+                customModel.getSpeedFactor(), lookup,\n+                num -> \"speed *= \" + num + \";\\n\", \"\"));\n+        StringBuilder codeSB = new StringBuilder(\"boolean applied = false;\\n\");\n+        speedStatements.addAll(verifyExpressions(codeSB, \"max_speed_user_statements\",\n+                speedVariables, customModel.getMaxSpeed(), lookup,\n+                num -> \"applied = true; speed = Math.min(speed,\" + num + \");\",\n+                \"if (!applied && speed > \" + maxSpeedFallback + \") return \" + maxSpeedFallback + \";\\n\" +\n+                        \"return Math.min(speed, \" + globalMaxSpeed + \");\\n\"));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTkxMzA0OA=="}, "originalCommit": {"oid": "f4478bb97c3d7585b21c39eadf45d80e57436cb3"}, "originalPosition": 133}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjQ1MzI3OQ==", "bodyText": "Ah, the reason we have this separate entry is that this improves speed. (A better estimate is possible in getMinWeight => less visited nodes)\nBut instead of the \"applied\" logic we could just add it (and throw an exception if true already exists)?", "url": "https://github.com/graphhopper/graphhopper/pull/2209#discussion_r542453279", "createdAt": "2020-12-14T15:03:16Z", "author": {"login": "karussell"}, "path": "core/src/main/java/com/graphhopper/routing/weighting/custom/ExpressionBuilder.java", "diffHunk": "@@ -0,0 +1,379 @@\n+/*\n+ *  Licensed to GraphHopper GmbH under one or more contributor\n+ *  license agreements. See the NOTICE file distributed with this work for\n+ *  additional information regarding copyright ownership.\n+ *\n+ *  GraphHopper GmbH licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except in\n+ *  compliance with the License. You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package com.graphhopper.routing.weighting.custom;\n+\n+import com.graphhopper.json.geo.JsonFeature;\n+import com.graphhopper.routing.ev.DecimalEncodedValue;\n+import com.graphhopper.routing.ev.EncodedValue;\n+import com.graphhopper.routing.ev.EncodedValueLookup;\n+import com.graphhopper.routing.util.CustomModel;\n+import com.graphhopper.routing.util.EncodingManager;\n+import com.graphhopper.util.EdgeIteratorState;\n+import com.graphhopper.util.GHUtility;\n+import com.graphhopper.util.shapes.BBox;\n+import com.graphhopper.util.shapes.Polygon;\n+import org.codehaus.commons.compiler.CompileException;\n+import org.codehaus.commons.compiler.Location;\n+import org.codehaus.commons.compiler.io.Readers;\n+import org.codehaus.janino.Scanner;\n+import org.codehaus.janino.*;\n+import org.codehaus.janino.util.DeepCopier;\n+import org.locationtech.jts.geom.prep.PreparedGeometryFactory;\n+\n+import java.io.*;\n+import java.util.*;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+class ExpressionBuilder {\n+    private static final AtomicLong longVal = new AtomicLong(1);\n+    static final String IN_AREA_PREFIX = \"in_area_\";\n+    private static final Set<String> allowedNames = new HashSet<>(Arrays.asList(\"edge\", \"Math\"));\n+    private static final boolean JANINO_DEBUG = Boolean.getBoolean(Scanner.SYSTEM_PROPERTY_SOURCE_DEBUGGING_ENABLE);\n+\n+    // TODO without a cache we get X% slower routing and Y% slower routingLM8. CH requests and preparation is unaffected\n+    // as cached weighting from preparation is used. This cache ensures that the first Weighting classes, typically the\n+    // ones specified in the profiles, are never removed regardless of how frequent other Weightings are created and accessed.\n+    // We only need to synchronize the get and put methods alone. E.g. we do not care for the race condition where\n+    // two identical classes are requested and one of them is overwritten. We could use CachingJavaSourceClassLoader from\n+    // Janino but 1. we would need to use a single compiler across threads and 2. the statements (for priority and speed)\n+    // are still unnecessarily created.\n+    private static final int CACHE_SIZE = Integer.getInteger(\"graphhopper.custom_weighting.cache_size\", 10);\n+    // TODO perf compare with ConcurrentHashMap, but I guess, if there is a difference at all, it is not big for small maps\n+    private static final Map<String, Class> CACHE = Collections.synchronizedMap(new HashMap<>(CACHE_SIZE));\n+\n+    // Introduce a dynamic cache to remember different Weighting classes, but throw away less frequently used classes.\n+    // Use accessOrder==true to remove oldest accessed entry, not oldest inserted.\n+    private static final int DYN_CACHE_SIZE = Integer.getInteger(\"graphhopper.custom_weighting.dynamic_cache_size\", 1000);\n+    private static final Map<String, Class> DYN_CACHE = Collections.synchronizedMap(\n+            new LinkedHashMap<String, Class>(DYN_CACHE_SIZE, 0.75f, true) {\n+                protected boolean removeEldestEntry(Map.Entry eldest) {\n+                    return size() > DYN_CACHE_SIZE;\n+                }\n+            });\n+\n+    /**\n+     * This method compiles a new subclass of CustomWeightingHelper composed from the provided CustomModel caches this\n+     * and returns an instance.\n+     */\n+    static CustomWeightingHelper create(CustomModel customModel, EncodedValueLookup lookup,\n+                                        double globalMaxSpeed, double maxSpeedFallback, DecimalEncodedValue avgSpeedEnc) {\n+        Java.CompilationUnit cu;\n+        try {\n+            String key = customModel.toString() + \",global:\" + globalMaxSpeed + \",fallback:\" + maxSpeedFallback;\n+            if (key.length() > 400_000) throw new IllegalArgumentException(\"Custom Model too big: \" + key.length());\n+\n+            Class clazz = CACHE.get(key);\n+            if (DYN_CACHE_SIZE > 0 && clazz == null)\n+                clazz = DYN_CACHE.get(key);\n+            if (clazz == null) {\n+                HashSet<String> priorityVariables = new LinkedHashSet<>();\n+                List<Java.BlockStatement> priorityStatements = createGetPriorityStatements(priorityVariables, customModel, lookup);\n+                HashSet<String> speedVariables = new LinkedHashSet<>();\n+                List<Java.BlockStatement> speedStatements = createGetSpeedStatements(speedVariables, customModel, lookup, globalMaxSpeed, maxSpeedFallback);\n+                // Create different class name, which is required only for debugging.\n+                // TODO does it improve performance too? I.e. it could be that the JIT is confused if different classes\n+                //  have the same name and it mixes performance stats. See https://github.com/janino-compiler/janino/issues/137\n+                long counter = longVal.incrementAndGet();\n+                String classTemplate = createClassTemplate(counter, priorityVariables, speedVariables, lookup, customModel);\n+                cu = (Java.CompilationUnit) new Parser(new org.codehaus.janino.Scanner(\"source\", new StringReader(classTemplate))).\n+                        parseAbstractCompilationUnit();\n+                cu = injectStatements(priorityStatements, speedStatements, cu);\n+                SimpleCompiler sc = createCompiler(counter, cu);\n+                clazz = sc.getClassLoader().loadClass(\"com.graphhopper.Test\" + counter);\n+                if (CACHE.size() < CACHE_SIZE)\n+                    CACHE.put(key, clazz);\n+                else if (DYN_CACHE_SIZE > 0)\n+                    DYN_CACHE.put(key, clazz);\n+            }\n+\n+            // The class does not need to be thread-safe as we create an instance per request\n+            CustomWeightingHelper prio = (CustomWeightingHelper) clazz.getDeclaredConstructor().newInstance();\n+            prio.init(lookup, avgSpeedEnc, customModel.getAreas());\n+            return prio;\n+        } catch (Exception ex) {\n+            String location = \"\";\n+            if (ex instanceof CompileException)\n+                location = \" in \" + ((CompileException) ex).getLocation().getFileName();\n+            throw new IllegalArgumentException(\"Cannot compile expression \" + location + \", \" + ex.getMessage(), ex);\n+        }\n+    }\n+\n+    /**\n+     * Parse the expressions from CustomModel relevant for the method getSpeed - see createClassTemplate.\n+     *\n+     * @return the created statements (parsed expressions)\n+     */\n+    private static List<Java.BlockStatement> createGetSpeedStatements(Set<String> speedVariables,\n+                                                                      CustomModel customModel, EncodedValueLookup lookup,\n+                                                                      double globalMaxSpeed, double maxSpeedFallback) throws Exception {\n+        List<Java.BlockStatement> speedStatements = new ArrayList<>();\n+        speedStatements.addAll(verifyExpressions(new StringBuilder(), \"speed_factor_user_statements\", speedVariables,\n+                customModel.getSpeedFactor(), lookup,\n+                num -> \"speed *= \" + num + \";\\n\", \"\"));\n+        StringBuilder codeSB = new StringBuilder(\"boolean applied = false;\\n\");\n+        speedStatements.addAll(verifyExpressions(codeSB, \"max_speed_user_statements\",\n+                speedVariables, customModel.getMaxSpeed(), lookup,\n+                num -> \"applied = true; speed = Math.min(speed,\" + num + \");\",\n+                \"if (!applied && speed > \" + maxSpeedFallback + \") return \" + maxSpeedFallback + \";\\n\" +\n+                        \"return Math.min(speed, \" + globalMaxSpeed + \");\\n\"));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTkxMzA0OA=="}, "originalCommit": {"oid": "f4478bb97c3d7585b21c39eadf45d80e57436cb3"}, "originalPosition": 133}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjU3OTA1MA==", "bodyText": "But can we not derive the global maximum speed from the custom model? It's just the maximum over all max_speed entries and the encoder's base speed.", "url": "https://github.com/graphhopper/graphhopper/pull/2209#discussion_r542579050", "createdAt": "2020-12-14T17:43:15Z", "author": {"login": "easbar"}, "path": "core/src/main/java/com/graphhopper/routing/weighting/custom/ExpressionBuilder.java", "diffHunk": "@@ -0,0 +1,379 @@\n+/*\n+ *  Licensed to GraphHopper GmbH under one or more contributor\n+ *  license agreements. See the NOTICE file distributed with this work for\n+ *  additional information regarding copyright ownership.\n+ *\n+ *  GraphHopper GmbH licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except in\n+ *  compliance with the License. You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package com.graphhopper.routing.weighting.custom;\n+\n+import com.graphhopper.json.geo.JsonFeature;\n+import com.graphhopper.routing.ev.DecimalEncodedValue;\n+import com.graphhopper.routing.ev.EncodedValue;\n+import com.graphhopper.routing.ev.EncodedValueLookup;\n+import com.graphhopper.routing.util.CustomModel;\n+import com.graphhopper.routing.util.EncodingManager;\n+import com.graphhopper.util.EdgeIteratorState;\n+import com.graphhopper.util.GHUtility;\n+import com.graphhopper.util.shapes.BBox;\n+import com.graphhopper.util.shapes.Polygon;\n+import org.codehaus.commons.compiler.CompileException;\n+import org.codehaus.commons.compiler.Location;\n+import org.codehaus.commons.compiler.io.Readers;\n+import org.codehaus.janino.Scanner;\n+import org.codehaus.janino.*;\n+import org.codehaus.janino.util.DeepCopier;\n+import org.locationtech.jts.geom.prep.PreparedGeometryFactory;\n+\n+import java.io.*;\n+import java.util.*;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+class ExpressionBuilder {\n+    private static final AtomicLong longVal = new AtomicLong(1);\n+    static final String IN_AREA_PREFIX = \"in_area_\";\n+    private static final Set<String> allowedNames = new HashSet<>(Arrays.asList(\"edge\", \"Math\"));\n+    private static final boolean JANINO_DEBUG = Boolean.getBoolean(Scanner.SYSTEM_PROPERTY_SOURCE_DEBUGGING_ENABLE);\n+\n+    // TODO without a cache we get X% slower routing and Y% slower routingLM8. CH requests and preparation is unaffected\n+    // as cached weighting from preparation is used. This cache ensures that the first Weighting classes, typically the\n+    // ones specified in the profiles, are never removed regardless of how frequent other Weightings are created and accessed.\n+    // We only need to synchronize the get and put methods alone. E.g. we do not care for the race condition where\n+    // two identical classes are requested and one of them is overwritten. We could use CachingJavaSourceClassLoader from\n+    // Janino but 1. we would need to use a single compiler across threads and 2. the statements (for priority and speed)\n+    // are still unnecessarily created.\n+    private static final int CACHE_SIZE = Integer.getInteger(\"graphhopper.custom_weighting.cache_size\", 10);\n+    // TODO perf compare with ConcurrentHashMap, but I guess, if there is a difference at all, it is not big for small maps\n+    private static final Map<String, Class> CACHE = Collections.synchronizedMap(new HashMap<>(CACHE_SIZE));\n+\n+    // Introduce a dynamic cache to remember different Weighting classes, but throw away less frequently used classes.\n+    // Use accessOrder==true to remove oldest accessed entry, not oldest inserted.\n+    private static final int DYN_CACHE_SIZE = Integer.getInteger(\"graphhopper.custom_weighting.dynamic_cache_size\", 1000);\n+    private static final Map<String, Class> DYN_CACHE = Collections.synchronizedMap(\n+            new LinkedHashMap<String, Class>(DYN_CACHE_SIZE, 0.75f, true) {\n+                protected boolean removeEldestEntry(Map.Entry eldest) {\n+                    return size() > DYN_CACHE_SIZE;\n+                }\n+            });\n+\n+    /**\n+     * This method compiles a new subclass of CustomWeightingHelper composed from the provided CustomModel caches this\n+     * and returns an instance.\n+     */\n+    static CustomWeightingHelper create(CustomModel customModel, EncodedValueLookup lookup,\n+                                        double globalMaxSpeed, double maxSpeedFallback, DecimalEncodedValue avgSpeedEnc) {\n+        Java.CompilationUnit cu;\n+        try {\n+            String key = customModel.toString() + \",global:\" + globalMaxSpeed + \",fallback:\" + maxSpeedFallback;\n+            if (key.length() > 400_000) throw new IllegalArgumentException(\"Custom Model too big: \" + key.length());\n+\n+            Class clazz = CACHE.get(key);\n+            if (DYN_CACHE_SIZE > 0 && clazz == null)\n+                clazz = DYN_CACHE.get(key);\n+            if (clazz == null) {\n+                HashSet<String> priorityVariables = new LinkedHashSet<>();\n+                List<Java.BlockStatement> priorityStatements = createGetPriorityStatements(priorityVariables, customModel, lookup);\n+                HashSet<String> speedVariables = new LinkedHashSet<>();\n+                List<Java.BlockStatement> speedStatements = createGetSpeedStatements(speedVariables, customModel, lookup, globalMaxSpeed, maxSpeedFallback);\n+                // Create different class name, which is required only for debugging.\n+                // TODO does it improve performance too? I.e. it could be that the JIT is confused if different classes\n+                //  have the same name and it mixes performance stats. See https://github.com/janino-compiler/janino/issues/137\n+                long counter = longVal.incrementAndGet();\n+                String classTemplate = createClassTemplate(counter, priorityVariables, speedVariables, lookup, customModel);\n+                cu = (Java.CompilationUnit) new Parser(new org.codehaus.janino.Scanner(\"source\", new StringReader(classTemplate))).\n+                        parseAbstractCompilationUnit();\n+                cu = injectStatements(priorityStatements, speedStatements, cu);\n+                SimpleCompiler sc = createCompiler(counter, cu);\n+                clazz = sc.getClassLoader().loadClass(\"com.graphhopper.Test\" + counter);\n+                if (CACHE.size() < CACHE_SIZE)\n+                    CACHE.put(key, clazz);\n+                else if (DYN_CACHE_SIZE > 0)\n+                    DYN_CACHE.put(key, clazz);\n+            }\n+\n+            // The class does not need to be thread-safe as we create an instance per request\n+            CustomWeightingHelper prio = (CustomWeightingHelper) clazz.getDeclaredConstructor().newInstance();\n+            prio.init(lookup, avgSpeedEnc, customModel.getAreas());\n+            return prio;\n+        } catch (Exception ex) {\n+            String location = \"\";\n+            if (ex instanceof CompileException)\n+                location = \" in \" + ((CompileException) ex).getLocation().getFileName();\n+            throw new IllegalArgumentException(\"Cannot compile expression \" + location + \", \" + ex.getMessage(), ex);\n+        }\n+    }\n+\n+    /**\n+     * Parse the expressions from CustomModel relevant for the method getSpeed - see createClassTemplate.\n+     *\n+     * @return the created statements (parsed expressions)\n+     */\n+    private static List<Java.BlockStatement> createGetSpeedStatements(Set<String> speedVariables,\n+                                                                      CustomModel customModel, EncodedValueLookup lookup,\n+                                                                      double globalMaxSpeed, double maxSpeedFallback) throws Exception {\n+        List<Java.BlockStatement> speedStatements = new ArrayList<>();\n+        speedStatements.addAll(verifyExpressions(new StringBuilder(), \"speed_factor_user_statements\", speedVariables,\n+                customModel.getSpeedFactor(), lookup,\n+                num -> \"speed *= \" + num + \";\\n\", \"\"));\n+        StringBuilder codeSB = new StringBuilder(\"boolean applied = false;\\n\");\n+        speedStatements.addAll(verifyExpressions(codeSB, \"max_speed_user_statements\",\n+                speedVariables, customModel.getMaxSpeed(), lookup,\n+                num -> \"applied = true; speed = Math.min(speed,\" + num + \");\",\n+                \"if (!applied && speed > \" + maxSpeedFallback + \") return \" + maxSpeedFallback + \";\\n\" +\n+                        \"return Math.min(speed, \" + globalMaxSpeed + \");\\n\"));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTkxMzA0OA=="}, "originalCommit": {"oid": "f4478bb97c3d7585b21c39eadf45d80e57436cb3"}, "originalPosition": 133}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mjc0NjMzMA==", "bodyText": "I think what we need is the smallest (unconditional) max_speed - as we already know the maximum, which is the max_speed of the encoder. And e.g. a value with a condition like max_speed: { road_class == PRIMARY: 60 } is not sufficient to lower the maximum speed of the encoder, which is required to improve our getMinWeight estimate.\nSo we would need to loop over all entries and e.g. compare to true (?) and pick the smallest value or allow only one unconditional value? We could document this special thing as a performance improvement and avoid the special handling variable maxSpeedFallback. From the user perspective this would not be much more complicated and for us it would improve the situation a bit?", "url": "https://github.com/graphhopper/graphhopper/pull/2209#discussion_r542746330", "createdAt": "2020-12-14T20:28:18Z", "author": {"login": "karussell"}, "path": "core/src/main/java/com/graphhopper/routing/weighting/custom/ExpressionBuilder.java", "diffHunk": "@@ -0,0 +1,379 @@\n+/*\n+ *  Licensed to GraphHopper GmbH under one or more contributor\n+ *  license agreements. See the NOTICE file distributed with this work for\n+ *  additional information regarding copyright ownership.\n+ *\n+ *  GraphHopper GmbH licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except in\n+ *  compliance with the License. You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package com.graphhopper.routing.weighting.custom;\n+\n+import com.graphhopper.json.geo.JsonFeature;\n+import com.graphhopper.routing.ev.DecimalEncodedValue;\n+import com.graphhopper.routing.ev.EncodedValue;\n+import com.graphhopper.routing.ev.EncodedValueLookup;\n+import com.graphhopper.routing.util.CustomModel;\n+import com.graphhopper.routing.util.EncodingManager;\n+import com.graphhopper.util.EdgeIteratorState;\n+import com.graphhopper.util.GHUtility;\n+import com.graphhopper.util.shapes.BBox;\n+import com.graphhopper.util.shapes.Polygon;\n+import org.codehaus.commons.compiler.CompileException;\n+import org.codehaus.commons.compiler.Location;\n+import org.codehaus.commons.compiler.io.Readers;\n+import org.codehaus.janino.Scanner;\n+import org.codehaus.janino.*;\n+import org.codehaus.janino.util.DeepCopier;\n+import org.locationtech.jts.geom.prep.PreparedGeometryFactory;\n+\n+import java.io.*;\n+import java.util.*;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+class ExpressionBuilder {\n+    private static final AtomicLong longVal = new AtomicLong(1);\n+    static final String IN_AREA_PREFIX = \"in_area_\";\n+    private static final Set<String> allowedNames = new HashSet<>(Arrays.asList(\"edge\", \"Math\"));\n+    private static final boolean JANINO_DEBUG = Boolean.getBoolean(Scanner.SYSTEM_PROPERTY_SOURCE_DEBUGGING_ENABLE);\n+\n+    // TODO without a cache we get X% slower routing and Y% slower routingLM8. CH requests and preparation is unaffected\n+    // as cached weighting from preparation is used. This cache ensures that the first Weighting classes, typically the\n+    // ones specified in the profiles, are never removed regardless of how frequent other Weightings are created and accessed.\n+    // We only need to synchronize the get and put methods alone. E.g. we do not care for the race condition where\n+    // two identical classes are requested and one of them is overwritten. We could use CachingJavaSourceClassLoader from\n+    // Janino but 1. we would need to use a single compiler across threads and 2. the statements (for priority and speed)\n+    // are still unnecessarily created.\n+    private static final int CACHE_SIZE = Integer.getInteger(\"graphhopper.custom_weighting.cache_size\", 10);\n+    // TODO perf compare with ConcurrentHashMap, but I guess, if there is a difference at all, it is not big for small maps\n+    private static final Map<String, Class> CACHE = Collections.synchronizedMap(new HashMap<>(CACHE_SIZE));\n+\n+    // Introduce a dynamic cache to remember different Weighting classes, but throw away less frequently used classes.\n+    // Use accessOrder==true to remove oldest accessed entry, not oldest inserted.\n+    private static final int DYN_CACHE_SIZE = Integer.getInteger(\"graphhopper.custom_weighting.dynamic_cache_size\", 1000);\n+    private static final Map<String, Class> DYN_CACHE = Collections.synchronizedMap(\n+            new LinkedHashMap<String, Class>(DYN_CACHE_SIZE, 0.75f, true) {\n+                protected boolean removeEldestEntry(Map.Entry eldest) {\n+                    return size() > DYN_CACHE_SIZE;\n+                }\n+            });\n+\n+    /**\n+     * This method compiles a new subclass of CustomWeightingHelper composed from the provided CustomModel caches this\n+     * and returns an instance.\n+     */\n+    static CustomWeightingHelper create(CustomModel customModel, EncodedValueLookup lookup,\n+                                        double globalMaxSpeed, double maxSpeedFallback, DecimalEncodedValue avgSpeedEnc) {\n+        Java.CompilationUnit cu;\n+        try {\n+            String key = customModel.toString() + \",global:\" + globalMaxSpeed + \",fallback:\" + maxSpeedFallback;\n+            if (key.length() > 400_000) throw new IllegalArgumentException(\"Custom Model too big: \" + key.length());\n+\n+            Class clazz = CACHE.get(key);\n+            if (DYN_CACHE_SIZE > 0 && clazz == null)\n+                clazz = DYN_CACHE.get(key);\n+            if (clazz == null) {\n+                HashSet<String> priorityVariables = new LinkedHashSet<>();\n+                List<Java.BlockStatement> priorityStatements = createGetPriorityStatements(priorityVariables, customModel, lookup);\n+                HashSet<String> speedVariables = new LinkedHashSet<>();\n+                List<Java.BlockStatement> speedStatements = createGetSpeedStatements(speedVariables, customModel, lookup, globalMaxSpeed, maxSpeedFallback);\n+                // Create different class name, which is required only for debugging.\n+                // TODO does it improve performance too? I.e. it could be that the JIT is confused if different classes\n+                //  have the same name and it mixes performance stats. See https://github.com/janino-compiler/janino/issues/137\n+                long counter = longVal.incrementAndGet();\n+                String classTemplate = createClassTemplate(counter, priorityVariables, speedVariables, lookup, customModel);\n+                cu = (Java.CompilationUnit) new Parser(new org.codehaus.janino.Scanner(\"source\", new StringReader(classTemplate))).\n+                        parseAbstractCompilationUnit();\n+                cu = injectStatements(priorityStatements, speedStatements, cu);\n+                SimpleCompiler sc = createCompiler(counter, cu);\n+                clazz = sc.getClassLoader().loadClass(\"com.graphhopper.Test\" + counter);\n+                if (CACHE.size() < CACHE_SIZE)\n+                    CACHE.put(key, clazz);\n+                else if (DYN_CACHE_SIZE > 0)\n+                    DYN_CACHE.put(key, clazz);\n+            }\n+\n+            // The class does not need to be thread-safe as we create an instance per request\n+            CustomWeightingHelper prio = (CustomWeightingHelper) clazz.getDeclaredConstructor().newInstance();\n+            prio.init(lookup, avgSpeedEnc, customModel.getAreas());\n+            return prio;\n+        } catch (Exception ex) {\n+            String location = \"\";\n+            if (ex instanceof CompileException)\n+                location = \" in \" + ((CompileException) ex).getLocation().getFileName();\n+            throw new IllegalArgumentException(\"Cannot compile expression \" + location + \", \" + ex.getMessage(), ex);\n+        }\n+    }\n+\n+    /**\n+     * Parse the expressions from CustomModel relevant for the method getSpeed - see createClassTemplate.\n+     *\n+     * @return the created statements (parsed expressions)\n+     */\n+    private static List<Java.BlockStatement> createGetSpeedStatements(Set<String> speedVariables,\n+                                                                      CustomModel customModel, EncodedValueLookup lookup,\n+                                                                      double globalMaxSpeed, double maxSpeedFallback) throws Exception {\n+        List<Java.BlockStatement> speedStatements = new ArrayList<>();\n+        speedStatements.addAll(verifyExpressions(new StringBuilder(), \"speed_factor_user_statements\", speedVariables,\n+                customModel.getSpeedFactor(), lookup,\n+                num -> \"speed *= \" + num + \";\\n\", \"\"));\n+        StringBuilder codeSB = new StringBuilder(\"boolean applied = false;\\n\");\n+        speedStatements.addAll(verifyExpressions(codeSB, \"max_speed_user_statements\",\n+                speedVariables, customModel.getMaxSpeed(), lookup,\n+                num -> \"applied = true; speed = Math.min(speed,\" + num + \");\",\n+                \"if (!applied && speed > \" + maxSpeedFallback + \") return \" + maxSpeedFallback + \";\\n\" +\n+                        \"return Math.min(speed, \" + globalMaxSpeed + \");\\n\"));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTkxMzA0OA=="}, "originalCommit": {"oid": "f4478bb97c3d7585b21c39eadf45d80e57436cb3"}, "originalPosition": 133}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDEwMjMxMQ==", "bodyText": "I think what we need is the smallest (unconditional) max_speed\n\nYes, I was wrong here. We need to find the maximum speed that can occur across all edges. Maximum values that only apply to some edges do not matter.\n\nSo we would need to loop over all entries and e.g. compare to true (?)\n\nYes. The maximum speed is the base speed for the encoder unless there is some max speed rule that applies to all edges, for example one with an else clause or condition true.\n\nand pick the smallest value or allow only one unconditional value?\n\nRight. I think we should only allow one such rule. Otherwise it will depend on the order of the rules which might be not intuitive:\nmax_speed:\n    - if: road_class == MOTORWAY\n      value: 100\n      else: 50\n    - if: surface == GRAVEL\n      value: 70\n      # ouch, this will never be applied anyway, because the road_class rule comes first\n      else:  30 \n    - if: true\n      # same here...\n      value: 80\nAnd note that this is different to speed/priority where multiple else clauses can make sense because the corresponding factors all contribute to the combined result.\n\nWe could document this special thing as a performance improvement\n\nCan we postpone this performance improvement and use the encoder speed as max speed for now so we can finalize the format and answer the other questions first? Its only an improvement for those custom models that actually reduce the global speed, right?", "url": "https://github.com/graphhopper/graphhopper/pull/2209#discussion_r544102311", "createdAt": "2020-12-16T08:26:48Z", "author": {"login": "easbar"}, "path": "core/src/main/java/com/graphhopper/routing/weighting/custom/ExpressionBuilder.java", "diffHunk": "@@ -0,0 +1,379 @@\n+/*\n+ *  Licensed to GraphHopper GmbH under one or more contributor\n+ *  license agreements. See the NOTICE file distributed with this work for\n+ *  additional information regarding copyright ownership.\n+ *\n+ *  GraphHopper GmbH licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except in\n+ *  compliance with the License. You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package com.graphhopper.routing.weighting.custom;\n+\n+import com.graphhopper.json.geo.JsonFeature;\n+import com.graphhopper.routing.ev.DecimalEncodedValue;\n+import com.graphhopper.routing.ev.EncodedValue;\n+import com.graphhopper.routing.ev.EncodedValueLookup;\n+import com.graphhopper.routing.util.CustomModel;\n+import com.graphhopper.routing.util.EncodingManager;\n+import com.graphhopper.util.EdgeIteratorState;\n+import com.graphhopper.util.GHUtility;\n+import com.graphhopper.util.shapes.BBox;\n+import com.graphhopper.util.shapes.Polygon;\n+import org.codehaus.commons.compiler.CompileException;\n+import org.codehaus.commons.compiler.Location;\n+import org.codehaus.commons.compiler.io.Readers;\n+import org.codehaus.janino.Scanner;\n+import org.codehaus.janino.*;\n+import org.codehaus.janino.util.DeepCopier;\n+import org.locationtech.jts.geom.prep.PreparedGeometryFactory;\n+\n+import java.io.*;\n+import java.util.*;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+class ExpressionBuilder {\n+    private static final AtomicLong longVal = new AtomicLong(1);\n+    static final String IN_AREA_PREFIX = \"in_area_\";\n+    private static final Set<String> allowedNames = new HashSet<>(Arrays.asList(\"edge\", \"Math\"));\n+    private static final boolean JANINO_DEBUG = Boolean.getBoolean(Scanner.SYSTEM_PROPERTY_SOURCE_DEBUGGING_ENABLE);\n+\n+    // TODO without a cache we get X% slower routing and Y% slower routingLM8. CH requests and preparation is unaffected\n+    // as cached weighting from preparation is used. This cache ensures that the first Weighting classes, typically the\n+    // ones specified in the profiles, are never removed regardless of how frequent other Weightings are created and accessed.\n+    // We only need to synchronize the get and put methods alone. E.g. we do not care for the race condition where\n+    // two identical classes are requested and one of them is overwritten. We could use CachingJavaSourceClassLoader from\n+    // Janino but 1. we would need to use a single compiler across threads and 2. the statements (for priority and speed)\n+    // are still unnecessarily created.\n+    private static final int CACHE_SIZE = Integer.getInteger(\"graphhopper.custom_weighting.cache_size\", 10);\n+    // TODO perf compare with ConcurrentHashMap, but I guess, if there is a difference at all, it is not big for small maps\n+    private static final Map<String, Class> CACHE = Collections.synchronizedMap(new HashMap<>(CACHE_SIZE));\n+\n+    // Introduce a dynamic cache to remember different Weighting classes, but throw away less frequently used classes.\n+    // Use accessOrder==true to remove oldest accessed entry, not oldest inserted.\n+    private static final int DYN_CACHE_SIZE = Integer.getInteger(\"graphhopper.custom_weighting.dynamic_cache_size\", 1000);\n+    private static final Map<String, Class> DYN_CACHE = Collections.synchronizedMap(\n+            new LinkedHashMap<String, Class>(DYN_CACHE_SIZE, 0.75f, true) {\n+                protected boolean removeEldestEntry(Map.Entry eldest) {\n+                    return size() > DYN_CACHE_SIZE;\n+                }\n+            });\n+\n+    /**\n+     * This method compiles a new subclass of CustomWeightingHelper composed from the provided CustomModel caches this\n+     * and returns an instance.\n+     */\n+    static CustomWeightingHelper create(CustomModel customModel, EncodedValueLookup lookup,\n+                                        double globalMaxSpeed, double maxSpeedFallback, DecimalEncodedValue avgSpeedEnc) {\n+        Java.CompilationUnit cu;\n+        try {\n+            String key = customModel.toString() + \",global:\" + globalMaxSpeed + \",fallback:\" + maxSpeedFallback;\n+            if (key.length() > 400_000) throw new IllegalArgumentException(\"Custom Model too big: \" + key.length());\n+\n+            Class clazz = CACHE.get(key);\n+            if (DYN_CACHE_SIZE > 0 && clazz == null)\n+                clazz = DYN_CACHE.get(key);\n+            if (clazz == null) {\n+                HashSet<String> priorityVariables = new LinkedHashSet<>();\n+                List<Java.BlockStatement> priorityStatements = createGetPriorityStatements(priorityVariables, customModel, lookup);\n+                HashSet<String> speedVariables = new LinkedHashSet<>();\n+                List<Java.BlockStatement> speedStatements = createGetSpeedStatements(speedVariables, customModel, lookup, globalMaxSpeed, maxSpeedFallback);\n+                // Create different class name, which is required only for debugging.\n+                // TODO does it improve performance too? I.e. it could be that the JIT is confused if different classes\n+                //  have the same name and it mixes performance stats. See https://github.com/janino-compiler/janino/issues/137\n+                long counter = longVal.incrementAndGet();\n+                String classTemplate = createClassTemplate(counter, priorityVariables, speedVariables, lookup, customModel);\n+                cu = (Java.CompilationUnit) new Parser(new org.codehaus.janino.Scanner(\"source\", new StringReader(classTemplate))).\n+                        parseAbstractCompilationUnit();\n+                cu = injectStatements(priorityStatements, speedStatements, cu);\n+                SimpleCompiler sc = createCompiler(counter, cu);\n+                clazz = sc.getClassLoader().loadClass(\"com.graphhopper.Test\" + counter);\n+                if (CACHE.size() < CACHE_SIZE)\n+                    CACHE.put(key, clazz);\n+                else if (DYN_CACHE_SIZE > 0)\n+                    DYN_CACHE.put(key, clazz);\n+            }\n+\n+            // The class does not need to be thread-safe as we create an instance per request\n+            CustomWeightingHelper prio = (CustomWeightingHelper) clazz.getDeclaredConstructor().newInstance();\n+            prio.init(lookup, avgSpeedEnc, customModel.getAreas());\n+            return prio;\n+        } catch (Exception ex) {\n+            String location = \"\";\n+            if (ex instanceof CompileException)\n+                location = \" in \" + ((CompileException) ex).getLocation().getFileName();\n+            throw new IllegalArgumentException(\"Cannot compile expression \" + location + \", \" + ex.getMessage(), ex);\n+        }\n+    }\n+\n+    /**\n+     * Parse the expressions from CustomModel relevant for the method getSpeed - see createClassTemplate.\n+     *\n+     * @return the created statements (parsed expressions)\n+     */\n+    private static List<Java.BlockStatement> createGetSpeedStatements(Set<String> speedVariables,\n+                                                                      CustomModel customModel, EncodedValueLookup lookup,\n+                                                                      double globalMaxSpeed, double maxSpeedFallback) throws Exception {\n+        List<Java.BlockStatement> speedStatements = new ArrayList<>();\n+        speedStatements.addAll(verifyExpressions(new StringBuilder(), \"speed_factor_user_statements\", speedVariables,\n+                customModel.getSpeedFactor(), lookup,\n+                num -> \"speed *= \" + num + \";\\n\", \"\"));\n+        StringBuilder codeSB = new StringBuilder(\"boolean applied = false;\\n\");\n+        speedStatements.addAll(verifyExpressions(codeSB, \"max_speed_user_statements\",\n+                speedVariables, customModel.getMaxSpeed(), lookup,\n+                num -> \"applied = true; speed = Math.min(speed,\" + num + \");\",\n+                \"if (!applied && speed > \" + maxSpeedFallback + \") return \" + maxSpeedFallback + \";\\n\" +\n+                        \"return Math.min(speed, \" + globalMaxSpeed + \");\\n\"));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTkxMzA0OA=="}, "originalCommit": {"oid": "f4478bb97c3d7585b21c39eadf45d80e57436cb3"}, "originalPosition": 133}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDY2NzU1MA==", "bodyText": "for example one with an else clause or condition true\n\nNot all else-clauses - only for the else clause of false (?)\n\nOtherwise it will depend on the order of the rules which might be not intuitive:\nsame here...\n\nYou probably meant an if-clause block like:\nmax_speed:\n - if: road_class == MOTORWAY\n   value: 100\n - else if: surface == GRAVEL\n   value: 70\n - else if: true\n   value: 80\nBecause for max_speed the order does not matter as we go through all if expressions and instead of multiplication speed = factor* speed we do speed = Math.min(max_speed, speed). In your example the value 80 will still be picked in case of road_class==MOTORWAY.\nSo if we scan for if: true this should work? (And maybe also if: false -> else)\n\nAnd note that this is different to speed/priority where multiple else clauses can make sense because the corresponding factors all contribute to the combined result.\n\nWhy? Can you explain this? Maybe this is the reason I read your above example incorrectly.\nIn master the max_speed expressions are applied multiple times: \n  \n    \n      graphhopper/core/src/main/java/com/graphhopper/routing/weighting/custom/SpeedCalculator.java\n    \n    \n         Line 146\n      in\n      a78f871\n    \n    \n    \n    \n\n        \n          \n           for (int i = 0; i < maxSpeedList.size(); i++) { \n        \n    \n  \n\n\n\nCan we postpone this performance improvement\n\nIt exists in master (via the max_speed_fallback) and it shouldn't be hard due to your observation above?\n\nIts only an improvement for those custom models that actually reduce the global speed, right?\n\nI'm unsure if real world examples would be impacted by a lot, but a too loose getMinWeight approximation can have a big impact on A* speed. And it is not uncommon to reduce the overall max_speed e.g. base your work on car and say you can never drive more than 100km/h.", "url": "https://github.com/graphhopper/graphhopper/pull/2209#discussion_r544667550", "createdAt": "2020-12-16T22:26:12Z", "author": {"login": "karussell"}, "path": "core/src/main/java/com/graphhopper/routing/weighting/custom/ExpressionBuilder.java", "diffHunk": "@@ -0,0 +1,379 @@\n+/*\n+ *  Licensed to GraphHopper GmbH under one or more contributor\n+ *  license agreements. See the NOTICE file distributed with this work for\n+ *  additional information regarding copyright ownership.\n+ *\n+ *  GraphHopper GmbH licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except in\n+ *  compliance with the License. You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package com.graphhopper.routing.weighting.custom;\n+\n+import com.graphhopper.json.geo.JsonFeature;\n+import com.graphhopper.routing.ev.DecimalEncodedValue;\n+import com.graphhopper.routing.ev.EncodedValue;\n+import com.graphhopper.routing.ev.EncodedValueLookup;\n+import com.graphhopper.routing.util.CustomModel;\n+import com.graphhopper.routing.util.EncodingManager;\n+import com.graphhopper.util.EdgeIteratorState;\n+import com.graphhopper.util.GHUtility;\n+import com.graphhopper.util.shapes.BBox;\n+import com.graphhopper.util.shapes.Polygon;\n+import org.codehaus.commons.compiler.CompileException;\n+import org.codehaus.commons.compiler.Location;\n+import org.codehaus.commons.compiler.io.Readers;\n+import org.codehaus.janino.Scanner;\n+import org.codehaus.janino.*;\n+import org.codehaus.janino.util.DeepCopier;\n+import org.locationtech.jts.geom.prep.PreparedGeometryFactory;\n+\n+import java.io.*;\n+import java.util.*;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+class ExpressionBuilder {\n+    private static final AtomicLong longVal = new AtomicLong(1);\n+    static final String IN_AREA_PREFIX = \"in_area_\";\n+    private static final Set<String> allowedNames = new HashSet<>(Arrays.asList(\"edge\", \"Math\"));\n+    private static final boolean JANINO_DEBUG = Boolean.getBoolean(Scanner.SYSTEM_PROPERTY_SOURCE_DEBUGGING_ENABLE);\n+\n+    // TODO without a cache we get X% slower routing and Y% slower routingLM8. CH requests and preparation is unaffected\n+    // as cached weighting from preparation is used. This cache ensures that the first Weighting classes, typically the\n+    // ones specified in the profiles, are never removed regardless of how frequent other Weightings are created and accessed.\n+    // We only need to synchronize the get and put methods alone. E.g. we do not care for the race condition where\n+    // two identical classes are requested and one of them is overwritten. We could use CachingJavaSourceClassLoader from\n+    // Janino but 1. we would need to use a single compiler across threads and 2. the statements (for priority and speed)\n+    // are still unnecessarily created.\n+    private static final int CACHE_SIZE = Integer.getInteger(\"graphhopper.custom_weighting.cache_size\", 10);\n+    // TODO perf compare with ConcurrentHashMap, but I guess, if there is a difference at all, it is not big for small maps\n+    private static final Map<String, Class> CACHE = Collections.synchronizedMap(new HashMap<>(CACHE_SIZE));\n+\n+    // Introduce a dynamic cache to remember different Weighting classes, but throw away less frequently used classes.\n+    // Use accessOrder==true to remove oldest accessed entry, not oldest inserted.\n+    private static final int DYN_CACHE_SIZE = Integer.getInteger(\"graphhopper.custom_weighting.dynamic_cache_size\", 1000);\n+    private static final Map<String, Class> DYN_CACHE = Collections.synchronizedMap(\n+            new LinkedHashMap<String, Class>(DYN_CACHE_SIZE, 0.75f, true) {\n+                protected boolean removeEldestEntry(Map.Entry eldest) {\n+                    return size() > DYN_CACHE_SIZE;\n+                }\n+            });\n+\n+    /**\n+     * This method compiles a new subclass of CustomWeightingHelper composed from the provided CustomModel caches this\n+     * and returns an instance.\n+     */\n+    static CustomWeightingHelper create(CustomModel customModel, EncodedValueLookup lookup,\n+                                        double globalMaxSpeed, double maxSpeedFallback, DecimalEncodedValue avgSpeedEnc) {\n+        Java.CompilationUnit cu;\n+        try {\n+            String key = customModel.toString() + \",global:\" + globalMaxSpeed + \",fallback:\" + maxSpeedFallback;\n+            if (key.length() > 400_000) throw new IllegalArgumentException(\"Custom Model too big: \" + key.length());\n+\n+            Class clazz = CACHE.get(key);\n+            if (DYN_CACHE_SIZE > 0 && clazz == null)\n+                clazz = DYN_CACHE.get(key);\n+            if (clazz == null) {\n+                HashSet<String> priorityVariables = new LinkedHashSet<>();\n+                List<Java.BlockStatement> priorityStatements = createGetPriorityStatements(priorityVariables, customModel, lookup);\n+                HashSet<String> speedVariables = new LinkedHashSet<>();\n+                List<Java.BlockStatement> speedStatements = createGetSpeedStatements(speedVariables, customModel, lookup, globalMaxSpeed, maxSpeedFallback);\n+                // Create different class name, which is required only for debugging.\n+                // TODO does it improve performance too? I.e. it could be that the JIT is confused if different classes\n+                //  have the same name and it mixes performance stats. See https://github.com/janino-compiler/janino/issues/137\n+                long counter = longVal.incrementAndGet();\n+                String classTemplate = createClassTemplate(counter, priorityVariables, speedVariables, lookup, customModel);\n+                cu = (Java.CompilationUnit) new Parser(new org.codehaus.janino.Scanner(\"source\", new StringReader(classTemplate))).\n+                        parseAbstractCompilationUnit();\n+                cu = injectStatements(priorityStatements, speedStatements, cu);\n+                SimpleCompiler sc = createCompiler(counter, cu);\n+                clazz = sc.getClassLoader().loadClass(\"com.graphhopper.Test\" + counter);\n+                if (CACHE.size() < CACHE_SIZE)\n+                    CACHE.put(key, clazz);\n+                else if (DYN_CACHE_SIZE > 0)\n+                    DYN_CACHE.put(key, clazz);\n+            }\n+\n+            // The class does not need to be thread-safe as we create an instance per request\n+            CustomWeightingHelper prio = (CustomWeightingHelper) clazz.getDeclaredConstructor().newInstance();\n+            prio.init(lookup, avgSpeedEnc, customModel.getAreas());\n+            return prio;\n+        } catch (Exception ex) {\n+            String location = \"\";\n+            if (ex instanceof CompileException)\n+                location = \" in \" + ((CompileException) ex).getLocation().getFileName();\n+            throw new IllegalArgumentException(\"Cannot compile expression \" + location + \", \" + ex.getMessage(), ex);\n+        }\n+    }\n+\n+    /**\n+     * Parse the expressions from CustomModel relevant for the method getSpeed - see createClassTemplate.\n+     *\n+     * @return the created statements (parsed expressions)\n+     */\n+    private static List<Java.BlockStatement> createGetSpeedStatements(Set<String> speedVariables,\n+                                                                      CustomModel customModel, EncodedValueLookup lookup,\n+                                                                      double globalMaxSpeed, double maxSpeedFallback) throws Exception {\n+        List<Java.BlockStatement> speedStatements = new ArrayList<>();\n+        speedStatements.addAll(verifyExpressions(new StringBuilder(), \"speed_factor_user_statements\", speedVariables,\n+                customModel.getSpeedFactor(), lookup,\n+                num -> \"speed *= \" + num + \";\\n\", \"\"));\n+        StringBuilder codeSB = new StringBuilder(\"boolean applied = false;\\n\");\n+        speedStatements.addAll(verifyExpressions(codeSB, \"max_speed_user_statements\",\n+                speedVariables, customModel.getMaxSpeed(), lookup,\n+                num -> \"applied = true; speed = Math.min(speed,\" + num + \");\",\n+                \"if (!applied && speed > \" + maxSpeedFallback + \") return \" + maxSpeedFallback + \";\\n\" +\n+                        \"return Math.min(speed, \" + globalMaxSpeed + \");\\n\"));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTkxMzA0OA=="}, "originalCommit": {"oid": "f4478bb97c3d7585b21c39eadf45d80e57436cb3"}, "originalPosition": 133}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDk0MjM1OA==", "bodyText": "Hm yeah this is a bit confusing. Right now this comes down to the following question for me, and before this is clear I think I cannot answer your questions properly. Let's say we have a custom model with these 'rules.\n- road_class == MOTORWAY --> 100\n- surface == GRAVEL --> 70\n- road_environment == TUNNEL --> 80\nFor an edge that has all three attributes what do we expect:\n\n100, because this is the first rule that matches (order matters)\n80, because it is the last rule that matches (order matters). this sounds weird, but that would be the result if we had single if statements with no return (see below)\n70, because out of all matches this is the most restrictive speed limit (I think this is done in master currently)\n100, because we take the most restrictive speed limit but stop after the first match (sounds extra weird, but this is kind of what the last yaml with the if else looks like, see below)\n\nIn Java it would be this:\n// 1\nif (road_class == MOTORWAY)\n   return 100;\nif (surface == GRAVEL)\n   return 70;\nif (road_environment == TUNNEL)\n   return 80;\n\n// 2\ndouble result;\nif (road_class == MOTORWAY)\n   result = 100;\nif (surface == GRAVEL)\n   result = 70;\nif (road_environment == TUNNEL)\n   result = 80;\nreturn result;\n\n// 3\ndouble maxSpeed = encoder.maxSpeed();\nif (road_class == MOTORWAY)\n    maxSpeed = Math.min(maxSpeed, 100);\nif (surface == GRAVEL)\n    maxSpeed = Math.min(maxSpeed, 100);\nif (road_environment == TUNNEL)\n    maxSpeed = Math.min(maxSpeed, 100);\n\n// 4\ndouble maxSpeed = encoder.maxSpeed();\nif (road_class == MOTORWAY)\n    maxSpeed = Math.min(maxSpeed, 100);\nelse if (surface == GRAVEL)\n    maxSpeed = Math.min(maxSpeed, 100);\nelse if (road_environment == TUNNEL)\n    maxSpeed = Math.min(maxSpeed, 100);\nI guess the problem is that the logic we see in Java here gets 'lost' when converting this to yaml, or at least we have to be careful to make the yaml clear, but let's decide which Java logic we want first... And maybe we even need another option than the four I mentioned, e.g. combinations of these.\nAnd note that I intentionally left out 'else' and 'maxSpeedFallback' here, because already without these its not clear to me at the moment.", "url": "https://github.com/graphhopper/graphhopper/pull/2209#discussion_r544942358", "createdAt": "2020-12-17T09:34:52Z", "author": {"login": "easbar"}, "path": "core/src/main/java/com/graphhopper/routing/weighting/custom/ExpressionBuilder.java", "diffHunk": "@@ -0,0 +1,379 @@\n+/*\n+ *  Licensed to GraphHopper GmbH under one or more contributor\n+ *  license agreements. See the NOTICE file distributed with this work for\n+ *  additional information regarding copyright ownership.\n+ *\n+ *  GraphHopper GmbH licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except in\n+ *  compliance with the License. You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package com.graphhopper.routing.weighting.custom;\n+\n+import com.graphhopper.json.geo.JsonFeature;\n+import com.graphhopper.routing.ev.DecimalEncodedValue;\n+import com.graphhopper.routing.ev.EncodedValue;\n+import com.graphhopper.routing.ev.EncodedValueLookup;\n+import com.graphhopper.routing.util.CustomModel;\n+import com.graphhopper.routing.util.EncodingManager;\n+import com.graphhopper.util.EdgeIteratorState;\n+import com.graphhopper.util.GHUtility;\n+import com.graphhopper.util.shapes.BBox;\n+import com.graphhopper.util.shapes.Polygon;\n+import org.codehaus.commons.compiler.CompileException;\n+import org.codehaus.commons.compiler.Location;\n+import org.codehaus.commons.compiler.io.Readers;\n+import org.codehaus.janino.Scanner;\n+import org.codehaus.janino.*;\n+import org.codehaus.janino.util.DeepCopier;\n+import org.locationtech.jts.geom.prep.PreparedGeometryFactory;\n+\n+import java.io.*;\n+import java.util.*;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+class ExpressionBuilder {\n+    private static final AtomicLong longVal = new AtomicLong(1);\n+    static final String IN_AREA_PREFIX = \"in_area_\";\n+    private static final Set<String> allowedNames = new HashSet<>(Arrays.asList(\"edge\", \"Math\"));\n+    private static final boolean JANINO_DEBUG = Boolean.getBoolean(Scanner.SYSTEM_PROPERTY_SOURCE_DEBUGGING_ENABLE);\n+\n+    // TODO without a cache we get X% slower routing and Y% slower routingLM8. CH requests and preparation is unaffected\n+    // as cached weighting from preparation is used. This cache ensures that the first Weighting classes, typically the\n+    // ones specified in the profiles, are never removed regardless of how frequent other Weightings are created and accessed.\n+    // We only need to synchronize the get and put methods alone. E.g. we do not care for the race condition where\n+    // two identical classes are requested and one of them is overwritten. We could use CachingJavaSourceClassLoader from\n+    // Janino but 1. we would need to use a single compiler across threads and 2. the statements (for priority and speed)\n+    // are still unnecessarily created.\n+    private static final int CACHE_SIZE = Integer.getInteger(\"graphhopper.custom_weighting.cache_size\", 10);\n+    // TODO perf compare with ConcurrentHashMap, but I guess, if there is a difference at all, it is not big for small maps\n+    private static final Map<String, Class> CACHE = Collections.synchronizedMap(new HashMap<>(CACHE_SIZE));\n+\n+    // Introduce a dynamic cache to remember different Weighting classes, but throw away less frequently used classes.\n+    // Use accessOrder==true to remove oldest accessed entry, not oldest inserted.\n+    private static final int DYN_CACHE_SIZE = Integer.getInteger(\"graphhopper.custom_weighting.dynamic_cache_size\", 1000);\n+    private static final Map<String, Class> DYN_CACHE = Collections.synchronizedMap(\n+            new LinkedHashMap<String, Class>(DYN_CACHE_SIZE, 0.75f, true) {\n+                protected boolean removeEldestEntry(Map.Entry eldest) {\n+                    return size() > DYN_CACHE_SIZE;\n+                }\n+            });\n+\n+    /**\n+     * This method compiles a new subclass of CustomWeightingHelper composed from the provided CustomModel caches this\n+     * and returns an instance.\n+     */\n+    static CustomWeightingHelper create(CustomModel customModel, EncodedValueLookup lookup,\n+                                        double globalMaxSpeed, double maxSpeedFallback, DecimalEncodedValue avgSpeedEnc) {\n+        Java.CompilationUnit cu;\n+        try {\n+            String key = customModel.toString() + \",global:\" + globalMaxSpeed + \",fallback:\" + maxSpeedFallback;\n+            if (key.length() > 400_000) throw new IllegalArgumentException(\"Custom Model too big: \" + key.length());\n+\n+            Class clazz = CACHE.get(key);\n+            if (DYN_CACHE_SIZE > 0 && clazz == null)\n+                clazz = DYN_CACHE.get(key);\n+            if (clazz == null) {\n+                HashSet<String> priorityVariables = new LinkedHashSet<>();\n+                List<Java.BlockStatement> priorityStatements = createGetPriorityStatements(priorityVariables, customModel, lookup);\n+                HashSet<String> speedVariables = new LinkedHashSet<>();\n+                List<Java.BlockStatement> speedStatements = createGetSpeedStatements(speedVariables, customModel, lookup, globalMaxSpeed, maxSpeedFallback);\n+                // Create different class name, which is required only for debugging.\n+                // TODO does it improve performance too? I.e. it could be that the JIT is confused if different classes\n+                //  have the same name and it mixes performance stats. See https://github.com/janino-compiler/janino/issues/137\n+                long counter = longVal.incrementAndGet();\n+                String classTemplate = createClassTemplate(counter, priorityVariables, speedVariables, lookup, customModel);\n+                cu = (Java.CompilationUnit) new Parser(new org.codehaus.janino.Scanner(\"source\", new StringReader(classTemplate))).\n+                        parseAbstractCompilationUnit();\n+                cu = injectStatements(priorityStatements, speedStatements, cu);\n+                SimpleCompiler sc = createCompiler(counter, cu);\n+                clazz = sc.getClassLoader().loadClass(\"com.graphhopper.Test\" + counter);\n+                if (CACHE.size() < CACHE_SIZE)\n+                    CACHE.put(key, clazz);\n+                else if (DYN_CACHE_SIZE > 0)\n+                    DYN_CACHE.put(key, clazz);\n+            }\n+\n+            // The class does not need to be thread-safe as we create an instance per request\n+            CustomWeightingHelper prio = (CustomWeightingHelper) clazz.getDeclaredConstructor().newInstance();\n+            prio.init(lookup, avgSpeedEnc, customModel.getAreas());\n+            return prio;\n+        } catch (Exception ex) {\n+            String location = \"\";\n+            if (ex instanceof CompileException)\n+                location = \" in \" + ((CompileException) ex).getLocation().getFileName();\n+            throw new IllegalArgumentException(\"Cannot compile expression \" + location + \", \" + ex.getMessage(), ex);\n+        }\n+    }\n+\n+    /**\n+     * Parse the expressions from CustomModel relevant for the method getSpeed - see createClassTemplate.\n+     *\n+     * @return the created statements (parsed expressions)\n+     */\n+    private static List<Java.BlockStatement> createGetSpeedStatements(Set<String> speedVariables,\n+                                                                      CustomModel customModel, EncodedValueLookup lookup,\n+                                                                      double globalMaxSpeed, double maxSpeedFallback) throws Exception {\n+        List<Java.BlockStatement> speedStatements = new ArrayList<>();\n+        speedStatements.addAll(verifyExpressions(new StringBuilder(), \"speed_factor_user_statements\", speedVariables,\n+                customModel.getSpeedFactor(), lookup,\n+                num -> \"speed *= \" + num + \";\\n\", \"\"));\n+        StringBuilder codeSB = new StringBuilder(\"boolean applied = false;\\n\");\n+        speedStatements.addAll(verifyExpressions(codeSB, \"max_speed_user_statements\",\n+                speedVariables, customModel.getMaxSpeed(), lookup,\n+                num -> \"applied = true; speed = Math.min(speed,\" + num + \");\",\n+                \"if (!applied && speed > \" + maxSpeedFallback + \") return \" + maxSpeedFallback + \";\\n\" +\n+                        \"return Math.min(speed, \" + globalMaxSpeed + \");\\n\"));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTkxMzA0OA=="}, "originalCommit": {"oid": "f4478bb97c3d7585b21c39eadf45d80e57436cb3"}, "originalPosition": 133}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDk0NDE2OA==", "bodyText": "Btw for speed/priority I think its more clear, because in this case we simply want the product of all matching rules, but let's discuss this after max_speed is clear.", "url": "https://github.com/graphhopper/graphhopper/pull/2209#discussion_r544944168", "createdAt": "2020-12-17T09:37:24Z", "author": {"login": "easbar"}, "path": "core/src/main/java/com/graphhopper/routing/weighting/custom/ExpressionBuilder.java", "diffHunk": "@@ -0,0 +1,379 @@\n+/*\n+ *  Licensed to GraphHopper GmbH under one or more contributor\n+ *  license agreements. See the NOTICE file distributed with this work for\n+ *  additional information regarding copyright ownership.\n+ *\n+ *  GraphHopper GmbH licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except in\n+ *  compliance with the License. You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package com.graphhopper.routing.weighting.custom;\n+\n+import com.graphhopper.json.geo.JsonFeature;\n+import com.graphhopper.routing.ev.DecimalEncodedValue;\n+import com.graphhopper.routing.ev.EncodedValue;\n+import com.graphhopper.routing.ev.EncodedValueLookup;\n+import com.graphhopper.routing.util.CustomModel;\n+import com.graphhopper.routing.util.EncodingManager;\n+import com.graphhopper.util.EdgeIteratorState;\n+import com.graphhopper.util.GHUtility;\n+import com.graphhopper.util.shapes.BBox;\n+import com.graphhopper.util.shapes.Polygon;\n+import org.codehaus.commons.compiler.CompileException;\n+import org.codehaus.commons.compiler.Location;\n+import org.codehaus.commons.compiler.io.Readers;\n+import org.codehaus.janino.Scanner;\n+import org.codehaus.janino.*;\n+import org.codehaus.janino.util.DeepCopier;\n+import org.locationtech.jts.geom.prep.PreparedGeometryFactory;\n+\n+import java.io.*;\n+import java.util.*;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+class ExpressionBuilder {\n+    private static final AtomicLong longVal = new AtomicLong(1);\n+    static final String IN_AREA_PREFIX = \"in_area_\";\n+    private static final Set<String> allowedNames = new HashSet<>(Arrays.asList(\"edge\", \"Math\"));\n+    private static final boolean JANINO_DEBUG = Boolean.getBoolean(Scanner.SYSTEM_PROPERTY_SOURCE_DEBUGGING_ENABLE);\n+\n+    // TODO without a cache we get X% slower routing and Y% slower routingLM8. CH requests and preparation is unaffected\n+    // as cached weighting from preparation is used. This cache ensures that the first Weighting classes, typically the\n+    // ones specified in the profiles, are never removed regardless of how frequent other Weightings are created and accessed.\n+    // We only need to synchronize the get and put methods alone. E.g. we do not care for the race condition where\n+    // two identical classes are requested and one of them is overwritten. We could use CachingJavaSourceClassLoader from\n+    // Janino but 1. we would need to use a single compiler across threads and 2. the statements (for priority and speed)\n+    // are still unnecessarily created.\n+    private static final int CACHE_SIZE = Integer.getInteger(\"graphhopper.custom_weighting.cache_size\", 10);\n+    // TODO perf compare with ConcurrentHashMap, but I guess, if there is a difference at all, it is not big for small maps\n+    private static final Map<String, Class> CACHE = Collections.synchronizedMap(new HashMap<>(CACHE_SIZE));\n+\n+    // Introduce a dynamic cache to remember different Weighting classes, but throw away less frequently used classes.\n+    // Use accessOrder==true to remove oldest accessed entry, not oldest inserted.\n+    private static final int DYN_CACHE_SIZE = Integer.getInteger(\"graphhopper.custom_weighting.dynamic_cache_size\", 1000);\n+    private static final Map<String, Class> DYN_CACHE = Collections.synchronizedMap(\n+            new LinkedHashMap<String, Class>(DYN_CACHE_SIZE, 0.75f, true) {\n+                protected boolean removeEldestEntry(Map.Entry eldest) {\n+                    return size() > DYN_CACHE_SIZE;\n+                }\n+            });\n+\n+    /**\n+     * This method compiles a new subclass of CustomWeightingHelper composed from the provided CustomModel caches this\n+     * and returns an instance.\n+     */\n+    static CustomWeightingHelper create(CustomModel customModel, EncodedValueLookup lookup,\n+                                        double globalMaxSpeed, double maxSpeedFallback, DecimalEncodedValue avgSpeedEnc) {\n+        Java.CompilationUnit cu;\n+        try {\n+            String key = customModel.toString() + \",global:\" + globalMaxSpeed + \",fallback:\" + maxSpeedFallback;\n+            if (key.length() > 400_000) throw new IllegalArgumentException(\"Custom Model too big: \" + key.length());\n+\n+            Class clazz = CACHE.get(key);\n+            if (DYN_CACHE_SIZE > 0 && clazz == null)\n+                clazz = DYN_CACHE.get(key);\n+            if (clazz == null) {\n+                HashSet<String> priorityVariables = new LinkedHashSet<>();\n+                List<Java.BlockStatement> priorityStatements = createGetPriorityStatements(priorityVariables, customModel, lookup);\n+                HashSet<String> speedVariables = new LinkedHashSet<>();\n+                List<Java.BlockStatement> speedStatements = createGetSpeedStatements(speedVariables, customModel, lookup, globalMaxSpeed, maxSpeedFallback);\n+                // Create different class name, which is required only for debugging.\n+                // TODO does it improve performance too? I.e. it could be that the JIT is confused if different classes\n+                //  have the same name and it mixes performance stats. See https://github.com/janino-compiler/janino/issues/137\n+                long counter = longVal.incrementAndGet();\n+                String classTemplate = createClassTemplate(counter, priorityVariables, speedVariables, lookup, customModel);\n+                cu = (Java.CompilationUnit) new Parser(new org.codehaus.janino.Scanner(\"source\", new StringReader(classTemplate))).\n+                        parseAbstractCompilationUnit();\n+                cu = injectStatements(priorityStatements, speedStatements, cu);\n+                SimpleCompiler sc = createCompiler(counter, cu);\n+                clazz = sc.getClassLoader().loadClass(\"com.graphhopper.Test\" + counter);\n+                if (CACHE.size() < CACHE_SIZE)\n+                    CACHE.put(key, clazz);\n+                else if (DYN_CACHE_SIZE > 0)\n+                    DYN_CACHE.put(key, clazz);\n+            }\n+\n+            // The class does not need to be thread-safe as we create an instance per request\n+            CustomWeightingHelper prio = (CustomWeightingHelper) clazz.getDeclaredConstructor().newInstance();\n+            prio.init(lookup, avgSpeedEnc, customModel.getAreas());\n+            return prio;\n+        } catch (Exception ex) {\n+            String location = \"\";\n+            if (ex instanceof CompileException)\n+                location = \" in \" + ((CompileException) ex).getLocation().getFileName();\n+            throw new IllegalArgumentException(\"Cannot compile expression \" + location + \", \" + ex.getMessage(), ex);\n+        }\n+    }\n+\n+    /**\n+     * Parse the expressions from CustomModel relevant for the method getSpeed - see createClassTemplate.\n+     *\n+     * @return the created statements (parsed expressions)\n+     */\n+    private static List<Java.BlockStatement> createGetSpeedStatements(Set<String> speedVariables,\n+                                                                      CustomModel customModel, EncodedValueLookup lookup,\n+                                                                      double globalMaxSpeed, double maxSpeedFallback) throws Exception {\n+        List<Java.BlockStatement> speedStatements = new ArrayList<>();\n+        speedStatements.addAll(verifyExpressions(new StringBuilder(), \"speed_factor_user_statements\", speedVariables,\n+                customModel.getSpeedFactor(), lookup,\n+                num -> \"speed *= \" + num + \";\\n\", \"\"));\n+        StringBuilder codeSB = new StringBuilder(\"boolean applied = false;\\n\");\n+        speedStatements.addAll(verifyExpressions(codeSB, \"max_speed_user_statements\",\n+                speedVariables, customModel.getMaxSpeed(), lookup,\n+                num -> \"applied = true; speed = Math.min(speed,\" + num + \");\",\n+                \"if (!applied && speed > \" + maxSpeedFallback + \") return \" + maxSpeedFallback + \";\\n\" +\n+                        \"return Math.min(speed, \" + globalMaxSpeed + \");\\n\"));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTkxMzA0OA=="}, "originalCommit": {"oid": "f4478bb97c3d7585b21c39eadf45d80e57436cb3"}, "originalPosition": 133}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDk1OTY0OQ==", "bodyText": "To me 1) and 3) both make sense.\nNumber 1) is very easy to understand. there can be cases where some rules are overruled by others. not even sure if this is a good or bad thing.\nIn yaml it would be literally:\nmax_speed:\n - if: road_class == MOTORWAY\n   value: 100\n - else if: surface == GRAVEL\n   value: 70\n - else if: road_surface == TUNNEL\n   value: 80\nNumber 3) is what we do in master, but gets very confusing when we use the format with if in yaml I think.\nFor 3) a possible yaml could look like this:\nmax_speed:\n  - condition: road_class == MOTORWAY\n    value: 100\n  - condition: surface == GRAVEL\n    value: 70\n  - condition: road_environment == TUNNEL\n    value: 80\nAvoiding if (or at least avoiding if with the various possible combinations with else) hopefully makes it clear that all conditions are equivalent and maybe also separates this from the (different) logic we use for speed/priority. We could even make it extra clear like this:\nmax_speed:\n   minimum_of:\n     - condition: road_class == MOTORWAY\n       value: 100\n     - condition: surface == GRAVEL\n       value: 70\n     - condition: road_environment == TUNNEL\n       value: 80\nOk and now that we are at it: How to handle max speed fallback in these two cases? For 1) its very simple: we just add\nmax_speed:\n   # see above\n   ...\n   - else: 90\nFor 3) its also easy, just add it as special value (works better if we have the minimum_of field)\nmax_speed:\n   minimum_of:\n       # see above\n       ...\n   otherwise: 90\nIn case one only wants to limit the maximum speed I would allow setting only - else for 1) or only otherwise for 3) and in both cases this would be the only option to reduce the global speed in a way that a-star makes use of it. I would not parse for unconditional rules for simplicity (my opinion). In case else or otherwise are used using a speed higher than the value set by these in one of the other rules or higher than encoder.maxspeed() should be an error.", "url": "https://github.com/graphhopper/graphhopper/pull/2209#discussion_r544959649", "createdAt": "2020-12-17T09:59:43Z", "author": {"login": "easbar"}, "path": "core/src/main/java/com/graphhopper/routing/weighting/custom/ExpressionBuilder.java", "diffHunk": "@@ -0,0 +1,379 @@\n+/*\n+ *  Licensed to GraphHopper GmbH under one or more contributor\n+ *  license agreements. See the NOTICE file distributed with this work for\n+ *  additional information regarding copyright ownership.\n+ *\n+ *  GraphHopper GmbH licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except in\n+ *  compliance with the License. You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package com.graphhopper.routing.weighting.custom;\n+\n+import com.graphhopper.json.geo.JsonFeature;\n+import com.graphhopper.routing.ev.DecimalEncodedValue;\n+import com.graphhopper.routing.ev.EncodedValue;\n+import com.graphhopper.routing.ev.EncodedValueLookup;\n+import com.graphhopper.routing.util.CustomModel;\n+import com.graphhopper.routing.util.EncodingManager;\n+import com.graphhopper.util.EdgeIteratorState;\n+import com.graphhopper.util.GHUtility;\n+import com.graphhopper.util.shapes.BBox;\n+import com.graphhopper.util.shapes.Polygon;\n+import org.codehaus.commons.compiler.CompileException;\n+import org.codehaus.commons.compiler.Location;\n+import org.codehaus.commons.compiler.io.Readers;\n+import org.codehaus.janino.Scanner;\n+import org.codehaus.janino.*;\n+import org.codehaus.janino.util.DeepCopier;\n+import org.locationtech.jts.geom.prep.PreparedGeometryFactory;\n+\n+import java.io.*;\n+import java.util.*;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+class ExpressionBuilder {\n+    private static final AtomicLong longVal = new AtomicLong(1);\n+    static final String IN_AREA_PREFIX = \"in_area_\";\n+    private static final Set<String> allowedNames = new HashSet<>(Arrays.asList(\"edge\", \"Math\"));\n+    private static final boolean JANINO_DEBUG = Boolean.getBoolean(Scanner.SYSTEM_PROPERTY_SOURCE_DEBUGGING_ENABLE);\n+\n+    // TODO without a cache we get X% slower routing and Y% slower routingLM8. CH requests and preparation is unaffected\n+    // as cached weighting from preparation is used. This cache ensures that the first Weighting classes, typically the\n+    // ones specified in the profiles, are never removed regardless of how frequent other Weightings are created and accessed.\n+    // We only need to synchronize the get and put methods alone. E.g. we do not care for the race condition where\n+    // two identical classes are requested and one of them is overwritten. We could use CachingJavaSourceClassLoader from\n+    // Janino but 1. we would need to use a single compiler across threads and 2. the statements (for priority and speed)\n+    // are still unnecessarily created.\n+    private static final int CACHE_SIZE = Integer.getInteger(\"graphhopper.custom_weighting.cache_size\", 10);\n+    // TODO perf compare with ConcurrentHashMap, but I guess, if there is a difference at all, it is not big for small maps\n+    private static final Map<String, Class> CACHE = Collections.synchronizedMap(new HashMap<>(CACHE_SIZE));\n+\n+    // Introduce a dynamic cache to remember different Weighting classes, but throw away less frequently used classes.\n+    // Use accessOrder==true to remove oldest accessed entry, not oldest inserted.\n+    private static final int DYN_CACHE_SIZE = Integer.getInteger(\"graphhopper.custom_weighting.dynamic_cache_size\", 1000);\n+    private static final Map<String, Class> DYN_CACHE = Collections.synchronizedMap(\n+            new LinkedHashMap<String, Class>(DYN_CACHE_SIZE, 0.75f, true) {\n+                protected boolean removeEldestEntry(Map.Entry eldest) {\n+                    return size() > DYN_CACHE_SIZE;\n+                }\n+            });\n+\n+    /**\n+     * This method compiles a new subclass of CustomWeightingHelper composed from the provided CustomModel caches this\n+     * and returns an instance.\n+     */\n+    static CustomWeightingHelper create(CustomModel customModel, EncodedValueLookup lookup,\n+                                        double globalMaxSpeed, double maxSpeedFallback, DecimalEncodedValue avgSpeedEnc) {\n+        Java.CompilationUnit cu;\n+        try {\n+            String key = customModel.toString() + \",global:\" + globalMaxSpeed + \",fallback:\" + maxSpeedFallback;\n+            if (key.length() > 400_000) throw new IllegalArgumentException(\"Custom Model too big: \" + key.length());\n+\n+            Class clazz = CACHE.get(key);\n+            if (DYN_CACHE_SIZE > 0 && clazz == null)\n+                clazz = DYN_CACHE.get(key);\n+            if (clazz == null) {\n+                HashSet<String> priorityVariables = new LinkedHashSet<>();\n+                List<Java.BlockStatement> priorityStatements = createGetPriorityStatements(priorityVariables, customModel, lookup);\n+                HashSet<String> speedVariables = new LinkedHashSet<>();\n+                List<Java.BlockStatement> speedStatements = createGetSpeedStatements(speedVariables, customModel, lookup, globalMaxSpeed, maxSpeedFallback);\n+                // Create different class name, which is required only for debugging.\n+                // TODO does it improve performance too? I.e. it could be that the JIT is confused if different classes\n+                //  have the same name and it mixes performance stats. See https://github.com/janino-compiler/janino/issues/137\n+                long counter = longVal.incrementAndGet();\n+                String classTemplate = createClassTemplate(counter, priorityVariables, speedVariables, lookup, customModel);\n+                cu = (Java.CompilationUnit) new Parser(new org.codehaus.janino.Scanner(\"source\", new StringReader(classTemplate))).\n+                        parseAbstractCompilationUnit();\n+                cu = injectStatements(priorityStatements, speedStatements, cu);\n+                SimpleCompiler sc = createCompiler(counter, cu);\n+                clazz = sc.getClassLoader().loadClass(\"com.graphhopper.Test\" + counter);\n+                if (CACHE.size() < CACHE_SIZE)\n+                    CACHE.put(key, clazz);\n+                else if (DYN_CACHE_SIZE > 0)\n+                    DYN_CACHE.put(key, clazz);\n+            }\n+\n+            // The class does not need to be thread-safe as we create an instance per request\n+            CustomWeightingHelper prio = (CustomWeightingHelper) clazz.getDeclaredConstructor().newInstance();\n+            prio.init(lookup, avgSpeedEnc, customModel.getAreas());\n+            return prio;\n+        } catch (Exception ex) {\n+            String location = \"\";\n+            if (ex instanceof CompileException)\n+                location = \" in \" + ((CompileException) ex).getLocation().getFileName();\n+            throw new IllegalArgumentException(\"Cannot compile expression \" + location + \", \" + ex.getMessage(), ex);\n+        }\n+    }\n+\n+    /**\n+     * Parse the expressions from CustomModel relevant for the method getSpeed - see createClassTemplate.\n+     *\n+     * @return the created statements (parsed expressions)\n+     */\n+    private static List<Java.BlockStatement> createGetSpeedStatements(Set<String> speedVariables,\n+                                                                      CustomModel customModel, EncodedValueLookup lookup,\n+                                                                      double globalMaxSpeed, double maxSpeedFallback) throws Exception {\n+        List<Java.BlockStatement> speedStatements = new ArrayList<>();\n+        speedStatements.addAll(verifyExpressions(new StringBuilder(), \"speed_factor_user_statements\", speedVariables,\n+                customModel.getSpeedFactor(), lookup,\n+                num -> \"speed *= \" + num + \";\\n\", \"\"));\n+        StringBuilder codeSB = new StringBuilder(\"boolean applied = false;\\n\");\n+        speedStatements.addAll(verifyExpressions(codeSB, \"max_speed_user_statements\",\n+                speedVariables, customModel.getMaxSpeed(), lookup,\n+                num -> \"applied = true; speed = Math.min(speed,\" + num + \");\",\n+                \"if (!applied && speed > \" + maxSpeedFallback + \") return \" + maxSpeedFallback + \";\\n\" +\n+                        \"return Math.min(speed, \" + globalMaxSpeed + \");\\n\"));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTkxMzA0OA=="}, "originalCommit": {"oid": "f4478bb97c3d7585b21c39eadf45d80e57436cb3"}, "originalPosition": 133}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTE0Nzc4Mw==", "bodyText": "Currently we allow an arbitrary combination of 3+4: if-then-else-if blocks (aka first_match) and also just a collection of if-clauses (default). To play with this and make this clear I implemented the new syntax :) . To me this feels natural (1:1 to Java) and we do not have something different for the max_speed compared to the factors. I.e. it is speed = speed <op> value where for factors it is <op> = multiply and for max_speed it is <op> = min.\nNow when it comes to the fallback max_speed I think we only need to loop through all if blocks and pick the minimum value and within one if block (including else-if and else) we pick the maximum. If one if block has no else we can skip it i.e. use the flagEncoder max_speed. A special case is \"if: true\" and \"if: false\".", "url": "https://github.com/graphhopper/graphhopper/pull/2209#discussion_r545147783", "createdAt": "2020-12-17T14:49:49Z", "author": {"login": "karussell"}, "path": "core/src/main/java/com/graphhopper/routing/weighting/custom/ExpressionBuilder.java", "diffHunk": "@@ -0,0 +1,379 @@\n+/*\n+ *  Licensed to GraphHopper GmbH under one or more contributor\n+ *  license agreements. See the NOTICE file distributed with this work for\n+ *  additional information regarding copyright ownership.\n+ *\n+ *  GraphHopper GmbH licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except in\n+ *  compliance with the License. You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package com.graphhopper.routing.weighting.custom;\n+\n+import com.graphhopper.json.geo.JsonFeature;\n+import com.graphhopper.routing.ev.DecimalEncodedValue;\n+import com.graphhopper.routing.ev.EncodedValue;\n+import com.graphhopper.routing.ev.EncodedValueLookup;\n+import com.graphhopper.routing.util.CustomModel;\n+import com.graphhopper.routing.util.EncodingManager;\n+import com.graphhopper.util.EdgeIteratorState;\n+import com.graphhopper.util.GHUtility;\n+import com.graphhopper.util.shapes.BBox;\n+import com.graphhopper.util.shapes.Polygon;\n+import org.codehaus.commons.compiler.CompileException;\n+import org.codehaus.commons.compiler.Location;\n+import org.codehaus.commons.compiler.io.Readers;\n+import org.codehaus.janino.Scanner;\n+import org.codehaus.janino.*;\n+import org.codehaus.janino.util.DeepCopier;\n+import org.locationtech.jts.geom.prep.PreparedGeometryFactory;\n+\n+import java.io.*;\n+import java.util.*;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+class ExpressionBuilder {\n+    private static final AtomicLong longVal = new AtomicLong(1);\n+    static final String IN_AREA_PREFIX = \"in_area_\";\n+    private static final Set<String> allowedNames = new HashSet<>(Arrays.asList(\"edge\", \"Math\"));\n+    private static final boolean JANINO_DEBUG = Boolean.getBoolean(Scanner.SYSTEM_PROPERTY_SOURCE_DEBUGGING_ENABLE);\n+\n+    // TODO without a cache we get X% slower routing and Y% slower routingLM8. CH requests and preparation is unaffected\n+    // as cached weighting from preparation is used. This cache ensures that the first Weighting classes, typically the\n+    // ones specified in the profiles, are never removed regardless of how frequent other Weightings are created and accessed.\n+    // We only need to synchronize the get and put methods alone. E.g. we do not care for the race condition where\n+    // two identical classes are requested and one of them is overwritten. We could use CachingJavaSourceClassLoader from\n+    // Janino but 1. we would need to use a single compiler across threads and 2. the statements (for priority and speed)\n+    // are still unnecessarily created.\n+    private static final int CACHE_SIZE = Integer.getInteger(\"graphhopper.custom_weighting.cache_size\", 10);\n+    // TODO perf compare with ConcurrentHashMap, but I guess, if there is a difference at all, it is not big for small maps\n+    private static final Map<String, Class> CACHE = Collections.synchronizedMap(new HashMap<>(CACHE_SIZE));\n+\n+    // Introduce a dynamic cache to remember different Weighting classes, but throw away less frequently used classes.\n+    // Use accessOrder==true to remove oldest accessed entry, not oldest inserted.\n+    private static final int DYN_CACHE_SIZE = Integer.getInteger(\"graphhopper.custom_weighting.dynamic_cache_size\", 1000);\n+    private static final Map<String, Class> DYN_CACHE = Collections.synchronizedMap(\n+            new LinkedHashMap<String, Class>(DYN_CACHE_SIZE, 0.75f, true) {\n+                protected boolean removeEldestEntry(Map.Entry eldest) {\n+                    return size() > DYN_CACHE_SIZE;\n+                }\n+            });\n+\n+    /**\n+     * This method compiles a new subclass of CustomWeightingHelper composed from the provided CustomModel caches this\n+     * and returns an instance.\n+     */\n+    static CustomWeightingHelper create(CustomModel customModel, EncodedValueLookup lookup,\n+                                        double globalMaxSpeed, double maxSpeedFallback, DecimalEncodedValue avgSpeedEnc) {\n+        Java.CompilationUnit cu;\n+        try {\n+            String key = customModel.toString() + \",global:\" + globalMaxSpeed + \",fallback:\" + maxSpeedFallback;\n+            if (key.length() > 400_000) throw new IllegalArgumentException(\"Custom Model too big: \" + key.length());\n+\n+            Class clazz = CACHE.get(key);\n+            if (DYN_CACHE_SIZE > 0 && clazz == null)\n+                clazz = DYN_CACHE.get(key);\n+            if (clazz == null) {\n+                HashSet<String> priorityVariables = new LinkedHashSet<>();\n+                List<Java.BlockStatement> priorityStatements = createGetPriorityStatements(priorityVariables, customModel, lookup);\n+                HashSet<String> speedVariables = new LinkedHashSet<>();\n+                List<Java.BlockStatement> speedStatements = createGetSpeedStatements(speedVariables, customModel, lookup, globalMaxSpeed, maxSpeedFallback);\n+                // Create different class name, which is required only for debugging.\n+                // TODO does it improve performance too? I.e. it could be that the JIT is confused if different classes\n+                //  have the same name and it mixes performance stats. See https://github.com/janino-compiler/janino/issues/137\n+                long counter = longVal.incrementAndGet();\n+                String classTemplate = createClassTemplate(counter, priorityVariables, speedVariables, lookup, customModel);\n+                cu = (Java.CompilationUnit) new Parser(new org.codehaus.janino.Scanner(\"source\", new StringReader(classTemplate))).\n+                        parseAbstractCompilationUnit();\n+                cu = injectStatements(priorityStatements, speedStatements, cu);\n+                SimpleCompiler sc = createCompiler(counter, cu);\n+                clazz = sc.getClassLoader().loadClass(\"com.graphhopper.Test\" + counter);\n+                if (CACHE.size() < CACHE_SIZE)\n+                    CACHE.put(key, clazz);\n+                else if (DYN_CACHE_SIZE > 0)\n+                    DYN_CACHE.put(key, clazz);\n+            }\n+\n+            // The class does not need to be thread-safe as we create an instance per request\n+            CustomWeightingHelper prio = (CustomWeightingHelper) clazz.getDeclaredConstructor().newInstance();\n+            prio.init(lookup, avgSpeedEnc, customModel.getAreas());\n+            return prio;\n+        } catch (Exception ex) {\n+            String location = \"\";\n+            if (ex instanceof CompileException)\n+                location = \" in \" + ((CompileException) ex).getLocation().getFileName();\n+            throw new IllegalArgumentException(\"Cannot compile expression \" + location + \", \" + ex.getMessage(), ex);\n+        }\n+    }\n+\n+    /**\n+     * Parse the expressions from CustomModel relevant for the method getSpeed - see createClassTemplate.\n+     *\n+     * @return the created statements (parsed expressions)\n+     */\n+    private static List<Java.BlockStatement> createGetSpeedStatements(Set<String> speedVariables,\n+                                                                      CustomModel customModel, EncodedValueLookup lookup,\n+                                                                      double globalMaxSpeed, double maxSpeedFallback) throws Exception {\n+        List<Java.BlockStatement> speedStatements = new ArrayList<>();\n+        speedStatements.addAll(verifyExpressions(new StringBuilder(), \"speed_factor_user_statements\", speedVariables,\n+                customModel.getSpeedFactor(), lookup,\n+                num -> \"speed *= \" + num + \";\\n\", \"\"));\n+        StringBuilder codeSB = new StringBuilder(\"boolean applied = false;\\n\");\n+        speedStatements.addAll(verifyExpressions(codeSB, \"max_speed_user_statements\",\n+                speedVariables, customModel.getMaxSpeed(), lookup,\n+                num -> \"applied = true; speed = Math.min(speed,\" + num + \");\",\n+                \"if (!applied && speed > \" + maxSpeedFallback + \") return \" + maxSpeedFallback + \";\\n\" +\n+                        \"return Math.min(speed, \" + globalMaxSpeed + \");\\n\"));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTkxMzA0OA=="}, "originalCommit": {"oid": "f4478bb97c3d7585b21c39eadf45d80e57436cb3"}, "originalPosition": 133}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTI3NjYxMw==", "bodyText": "So this\nmax_speed:\n  - if: road_class == MOTORWAY\n    then: 100\n  - else if: surface == GRAVEL\n    then: 70\n  - else if: road_environment == TUNNEL\n    then: 80\nmeans:\ndouble maxSpeed = encoder.getMaxSpeed();\nif (road_class == MOTORWAY)\n   maxSpeed = Math.min(maxSpeed, 100);\nelse if (surface == GRAVEL)\n   maxSpeed = Math.min(maxSpeed, 70);\nelse if (road_environment == TUNNEL)\n   maxSpeed = Math.min(maxSpeed, 80);\nand this\nmax_speed:\n  - if: road_class == MOTORWAY\n    then: 100\n  - if: surface == GRAVEL\n    then: 70\n  - if: road_environment == TUNNEL\n    then: 80\nmeans:\ndouble maxSpeed = encoder.getMaxSpeed();\nif (road_class == MOTORWAY)\n   maxSpeed = Math.min(maxSpeed, 100);\nif (surface == GRAVEL)\n   maxSpeed = Math.min(maxSpeed, 70);\nif (road_environment == TUNNEL)\n   maxSpeed = Math.min(maxSpeed, 80);\n?", "url": "https://github.com/graphhopper/graphhopper/pull/2209#discussion_r545276613", "createdAt": "2020-12-17T17:39:22Z", "author": {"login": "easbar"}, "path": "core/src/main/java/com/graphhopper/routing/weighting/custom/ExpressionBuilder.java", "diffHunk": "@@ -0,0 +1,379 @@\n+/*\n+ *  Licensed to GraphHopper GmbH under one or more contributor\n+ *  license agreements. See the NOTICE file distributed with this work for\n+ *  additional information regarding copyright ownership.\n+ *\n+ *  GraphHopper GmbH licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except in\n+ *  compliance with the License. You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package com.graphhopper.routing.weighting.custom;\n+\n+import com.graphhopper.json.geo.JsonFeature;\n+import com.graphhopper.routing.ev.DecimalEncodedValue;\n+import com.graphhopper.routing.ev.EncodedValue;\n+import com.graphhopper.routing.ev.EncodedValueLookup;\n+import com.graphhopper.routing.util.CustomModel;\n+import com.graphhopper.routing.util.EncodingManager;\n+import com.graphhopper.util.EdgeIteratorState;\n+import com.graphhopper.util.GHUtility;\n+import com.graphhopper.util.shapes.BBox;\n+import com.graphhopper.util.shapes.Polygon;\n+import org.codehaus.commons.compiler.CompileException;\n+import org.codehaus.commons.compiler.Location;\n+import org.codehaus.commons.compiler.io.Readers;\n+import org.codehaus.janino.Scanner;\n+import org.codehaus.janino.*;\n+import org.codehaus.janino.util.DeepCopier;\n+import org.locationtech.jts.geom.prep.PreparedGeometryFactory;\n+\n+import java.io.*;\n+import java.util.*;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+class ExpressionBuilder {\n+    private static final AtomicLong longVal = new AtomicLong(1);\n+    static final String IN_AREA_PREFIX = \"in_area_\";\n+    private static final Set<String> allowedNames = new HashSet<>(Arrays.asList(\"edge\", \"Math\"));\n+    private static final boolean JANINO_DEBUG = Boolean.getBoolean(Scanner.SYSTEM_PROPERTY_SOURCE_DEBUGGING_ENABLE);\n+\n+    // TODO without a cache we get X% slower routing and Y% slower routingLM8. CH requests and preparation is unaffected\n+    // as cached weighting from preparation is used. This cache ensures that the first Weighting classes, typically the\n+    // ones specified in the profiles, are never removed regardless of how frequent other Weightings are created and accessed.\n+    // We only need to synchronize the get and put methods alone. E.g. we do not care for the race condition where\n+    // two identical classes are requested and one of them is overwritten. We could use CachingJavaSourceClassLoader from\n+    // Janino but 1. we would need to use a single compiler across threads and 2. the statements (for priority and speed)\n+    // are still unnecessarily created.\n+    private static final int CACHE_SIZE = Integer.getInteger(\"graphhopper.custom_weighting.cache_size\", 10);\n+    // TODO perf compare with ConcurrentHashMap, but I guess, if there is a difference at all, it is not big for small maps\n+    private static final Map<String, Class> CACHE = Collections.synchronizedMap(new HashMap<>(CACHE_SIZE));\n+\n+    // Introduce a dynamic cache to remember different Weighting classes, but throw away less frequently used classes.\n+    // Use accessOrder==true to remove oldest accessed entry, not oldest inserted.\n+    private static final int DYN_CACHE_SIZE = Integer.getInteger(\"graphhopper.custom_weighting.dynamic_cache_size\", 1000);\n+    private static final Map<String, Class> DYN_CACHE = Collections.synchronizedMap(\n+            new LinkedHashMap<String, Class>(DYN_CACHE_SIZE, 0.75f, true) {\n+                protected boolean removeEldestEntry(Map.Entry eldest) {\n+                    return size() > DYN_CACHE_SIZE;\n+                }\n+            });\n+\n+    /**\n+     * This method compiles a new subclass of CustomWeightingHelper composed from the provided CustomModel caches this\n+     * and returns an instance.\n+     */\n+    static CustomWeightingHelper create(CustomModel customModel, EncodedValueLookup lookup,\n+                                        double globalMaxSpeed, double maxSpeedFallback, DecimalEncodedValue avgSpeedEnc) {\n+        Java.CompilationUnit cu;\n+        try {\n+            String key = customModel.toString() + \",global:\" + globalMaxSpeed + \",fallback:\" + maxSpeedFallback;\n+            if (key.length() > 400_000) throw new IllegalArgumentException(\"Custom Model too big: \" + key.length());\n+\n+            Class clazz = CACHE.get(key);\n+            if (DYN_CACHE_SIZE > 0 && clazz == null)\n+                clazz = DYN_CACHE.get(key);\n+            if (clazz == null) {\n+                HashSet<String> priorityVariables = new LinkedHashSet<>();\n+                List<Java.BlockStatement> priorityStatements = createGetPriorityStatements(priorityVariables, customModel, lookup);\n+                HashSet<String> speedVariables = new LinkedHashSet<>();\n+                List<Java.BlockStatement> speedStatements = createGetSpeedStatements(speedVariables, customModel, lookup, globalMaxSpeed, maxSpeedFallback);\n+                // Create different class name, which is required only for debugging.\n+                // TODO does it improve performance too? I.e. it could be that the JIT is confused if different classes\n+                //  have the same name and it mixes performance stats. See https://github.com/janino-compiler/janino/issues/137\n+                long counter = longVal.incrementAndGet();\n+                String classTemplate = createClassTemplate(counter, priorityVariables, speedVariables, lookup, customModel);\n+                cu = (Java.CompilationUnit) new Parser(new org.codehaus.janino.Scanner(\"source\", new StringReader(classTemplate))).\n+                        parseAbstractCompilationUnit();\n+                cu = injectStatements(priorityStatements, speedStatements, cu);\n+                SimpleCompiler sc = createCompiler(counter, cu);\n+                clazz = sc.getClassLoader().loadClass(\"com.graphhopper.Test\" + counter);\n+                if (CACHE.size() < CACHE_SIZE)\n+                    CACHE.put(key, clazz);\n+                else if (DYN_CACHE_SIZE > 0)\n+                    DYN_CACHE.put(key, clazz);\n+            }\n+\n+            // The class does not need to be thread-safe as we create an instance per request\n+            CustomWeightingHelper prio = (CustomWeightingHelper) clazz.getDeclaredConstructor().newInstance();\n+            prio.init(lookup, avgSpeedEnc, customModel.getAreas());\n+            return prio;\n+        } catch (Exception ex) {\n+            String location = \"\";\n+            if (ex instanceof CompileException)\n+                location = \" in \" + ((CompileException) ex).getLocation().getFileName();\n+            throw new IllegalArgumentException(\"Cannot compile expression \" + location + \", \" + ex.getMessage(), ex);\n+        }\n+    }\n+\n+    /**\n+     * Parse the expressions from CustomModel relevant for the method getSpeed - see createClassTemplate.\n+     *\n+     * @return the created statements (parsed expressions)\n+     */\n+    private static List<Java.BlockStatement> createGetSpeedStatements(Set<String> speedVariables,\n+                                                                      CustomModel customModel, EncodedValueLookup lookup,\n+                                                                      double globalMaxSpeed, double maxSpeedFallback) throws Exception {\n+        List<Java.BlockStatement> speedStatements = new ArrayList<>();\n+        speedStatements.addAll(verifyExpressions(new StringBuilder(), \"speed_factor_user_statements\", speedVariables,\n+                customModel.getSpeedFactor(), lookup,\n+                num -> \"speed *= \" + num + \";\\n\", \"\"));\n+        StringBuilder codeSB = new StringBuilder(\"boolean applied = false;\\n\");\n+        speedStatements.addAll(verifyExpressions(codeSB, \"max_speed_user_statements\",\n+                speedVariables, customModel.getMaxSpeed(), lookup,\n+                num -> \"applied = true; speed = Math.min(speed,\" + num + \");\",\n+                \"if (!applied && speed > \" + maxSpeedFallback + \") return \" + maxSpeedFallback + \";\\n\" +\n+                        \"return Math.min(speed, \" + globalMaxSpeed + \");\\n\"));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTkxMzA0OA=="}, "originalCommit": {"oid": "f4478bb97c3d7585b21c39eadf45d80e57436cb3"}, "originalPosition": 133}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTMzMzM2OA==", "bodyText": "Yes", "url": "https://github.com/graphhopper/graphhopper/pull/2209#discussion_r545333368", "createdAt": "2020-12-17T19:05:20Z", "author": {"login": "karussell"}, "path": "core/src/main/java/com/graphhopper/routing/weighting/custom/ExpressionBuilder.java", "diffHunk": "@@ -0,0 +1,379 @@\n+/*\n+ *  Licensed to GraphHopper GmbH under one or more contributor\n+ *  license agreements. See the NOTICE file distributed with this work for\n+ *  additional information regarding copyright ownership.\n+ *\n+ *  GraphHopper GmbH licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except in\n+ *  compliance with the License. You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package com.graphhopper.routing.weighting.custom;\n+\n+import com.graphhopper.json.geo.JsonFeature;\n+import com.graphhopper.routing.ev.DecimalEncodedValue;\n+import com.graphhopper.routing.ev.EncodedValue;\n+import com.graphhopper.routing.ev.EncodedValueLookup;\n+import com.graphhopper.routing.util.CustomModel;\n+import com.graphhopper.routing.util.EncodingManager;\n+import com.graphhopper.util.EdgeIteratorState;\n+import com.graphhopper.util.GHUtility;\n+import com.graphhopper.util.shapes.BBox;\n+import com.graphhopper.util.shapes.Polygon;\n+import org.codehaus.commons.compiler.CompileException;\n+import org.codehaus.commons.compiler.Location;\n+import org.codehaus.commons.compiler.io.Readers;\n+import org.codehaus.janino.Scanner;\n+import org.codehaus.janino.*;\n+import org.codehaus.janino.util.DeepCopier;\n+import org.locationtech.jts.geom.prep.PreparedGeometryFactory;\n+\n+import java.io.*;\n+import java.util.*;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+class ExpressionBuilder {\n+    private static final AtomicLong longVal = new AtomicLong(1);\n+    static final String IN_AREA_PREFIX = \"in_area_\";\n+    private static final Set<String> allowedNames = new HashSet<>(Arrays.asList(\"edge\", \"Math\"));\n+    private static final boolean JANINO_DEBUG = Boolean.getBoolean(Scanner.SYSTEM_PROPERTY_SOURCE_DEBUGGING_ENABLE);\n+\n+    // TODO without a cache we get X% slower routing and Y% slower routingLM8. CH requests and preparation is unaffected\n+    // as cached weighting from preparation is used. This cache ensures that the first Weighting classes, typically the\n+    // ones specified in the profiles, are never removed regardless of how frequent other Weightings are created and accessed.\n+    // We only need to synchronize the get and put methods alone. E.g. we do not care for the race condition where\n+    // two identical classes are requested and one of them is overwritten. We could use CachingJavaSourceClassLoader from\n+    // Janino but 1. we would need to use a single compiler across threads and 2. the statements (for priority and speed)\n+    // are still unnecessarily created.\n+    private static final int CACHE_SIZE = Integer.getInteger(\"graphhopper.custom_weighting.cache_size\", 10);\n+    // TODO perf compare with ConcurrentHashMap, but I guess, if there is a difference at all, it is not big for small maps\n+    private static final Map<String, Class> CACHE = Collections.synchronizedMap(new HashMap<>(CACHE_SIZE));\n+\n+    // Introduce a dynamic cache to remember different Weighting classes, but throw away less frequently used classes.\n+    // Use accessOrder==true to remove oldest accessed entry, not oldest inserted.\n+    private static final int DYN_CACHE_SIZE = Integer.getInteger(\"graphhopper.custom_weighting.dynamic_cache_size\", 1000);\n+    private static final Map<String, Class> DYN_CACHE = Collections.synchronizedMap(\n+            new LinkedHashMap<String, Class>(DYN_CACHE_SIZE, 0.75f, true) {\n+                protected boolean removeEldestEntry(Map.Entry eldest) {\n+                    return size() > DYN_CACHE_SIZE;\n+                }\n+            });\n+\n+    /**\n+     * This method compiles a new subclass of CustomWeightingHelper composed from the provided CustomModel caches this\n+     * and returns an instance.\n+     */\n+    static CustomWeightingHelper create(CustomModel customModel, EncodedValueLookup lookup,\n+                                        double globalMaxSpeed, double maxSpeedFallback, DecimalEncodedValue avgSpeedEnc) {\n+        Java.CompilationUnit cu;\n+        try {\n+            String key = customModel.toString() + \",global:\" + globalMaxSpeed + \",fallback:\" + maxSpeedFallback;\n+            if (key.length() > 400_000) throw new IllegalArgumentException(\"Custom Model too big: \" + key.length());\n+\n+            Class clazz = CACHE.get(key);\n+            if (DYN_CACHE_SIZE > 0 && clazz == null)\n+                clazz = DYN_CACHE.get(key);\n+            if (clazz == null) {\n+                HashSet<String> priorityVariables = new LinkedHashSet<>();\n+                List<Java.BlockStatement> priorityStatements = createGetPriorityStatements(priorityVariables, customModel, lookup);\n+                HashSet<String> speedVariables = new LinkedHashSet<>();\n+                List<Java.BlockStatement> speedStatements = createGetSpeedStatements(speedVariables, customModel, lookup, globalMaxSpeed, maxSpeedFallback);\n+                // Create different class name, which is required only for debugging.\n+                // TODO does it improve performance too? I.e. it could be that the JIT is confused if different classes\n+                //  have the same name and it mixes performance stats. See https://github.com/janino-compiler/janino/issues/137\n+                long counter = longVal.incrementAndGet();\n+                String classTemplate = createClassTemplate(counter, priorityVariables, speedVariables, lookup, customModel);\n+                cu = (Java.CompilationUnit) new Parser(new org.codehaus.janino.Scanner(\"source\", new StringReader(classTemplate))).\n+                        parseAbstractCompilationUnit();\n+                cu = injectStatements(priorityStatements, speedStatements, cu);\n+                SimpleCompiler sc = createCompiler(counter, cu);\n+                clazz = sc.getClassLoader().loadClass(\"com.graphhopper.Test\" + counter);\n+                if (CACHE.size() < CACHE_SIZE)\n+                    CACHE.put(key, clazz);\n+                else if (DYN_CACHE_SIZE > 0)\n+                    DYN_CACHE.put(key, clazz);\n+            }\n+\n+            // The class does not need to be thread-safe as we create an instance per request\n+            CustomWeightingHelper prio = (CustomWeightingHelper) clazz.getDeclaredConstructor().newInstance();\n+            prio.init(lookup, avgSpeedEnc, customModel.getAreas());\n+            return prio;\n+        } catch (Exception ex) {\n+            String location = \"\";\n+            if (ex instanceof CompileException)\n+                location = \" in \" + ((CompileException) ex).getLocation().getFileName();\n+            throw new IllegalArgumentException(\"Cannot compile expression \" + location + \", \" + ex.getMessage(), ex);\n+        }\n+    }\n+\n+    /**\n+     * Parse the expressions from CustomModel relevant for the method getSpeed - see createClassTemplate.\n+     *\n+     * @return the created statements (parsed expressions)\n+     */\n+    private static List<Java.BlockStatement> createGetSpeedStatements(Set<String> speedVariables,\n+                                                                      CustomModel customModel, EncodedValueLookup lookup,\n+                                                                      double globalMaxSpeed, double maxSpeedFallback) throws Exception {\n+        List<Java.BlockStatement> speedStatements = new ArrayList<>();\n+        speedStatements.addAll(verifyExpressions(new StringBuilder(), \"speed_factor_user_statements\", speedVariables,\n+                customModel.getSpeedFactor(), lookup,\n+                num -> \"speed *= \" + num + \";\\n\", \"\"));\n+        StringBuilder codeSB = new StringBuilder(\"boolean applied = false;\\n\");\n+        speedStatements.addAll(verifyExpressions(codeSB, \"max_speed_user_statements\",\n+                speedVariables, customModel.getMaxSpeed(), lookup,\n+                num -> \"applied = true; speed = Math.min(speed,\" + num + \");\",\n+                \"if (!applied && speed > \" + maxSpeedFallback + \") return \" + maxSpeedFallback + \";\\n\" +\n+                        \"return Math.min(speed, \" + globalMaxSpeed + \");\\n\"));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTkxMzA0OA=="}, "originalCommit": {"oid": "f4478bb97c3d7585b21c39eadf45d80e57436cb3"}, "originalPosition": 133}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTMzOTA0Mg==", "bodyText": "Currently we allow an arbitrary combination of 3+4: if-then-else-if blocks\n\nWhat do you mean 3+4?\nAnd where would do you think we should allow 'else'?", "url": "https://github.com/graphhopper/graphhopper/pull/2209#discussion_r545339042", "createdAt": "2020-12-17T19:15:15Z", "author": {"login": "easbar"}, "path": "core/src/main/java/com/graphhopper/routing/weighting/custom/ExpressionBuilder.java", "diffHunk": "@@ -0,0 +1,379 @@\n+/*\n+ *  Licensed to GraphHopper GmbH under one or more contributor\n+ *  license agreements. See the NOTICE file distributed with this work for\n+ *  additional information regarding copyright ownership.\n+ *\n+ *  GraphHopper GmbH licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except in\n+ *  compliance with the License. You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package com.graphhopper.routing.weighting.custom;\n+\n+import com.graphhopper.json.geo.JsonFeature;\n+import com.graphhopper.routing.ev.DecimalEncodedValue;\n+import com.graphhopper.routing.ev.EncodedValue;\n+import com.graphhopper.routing.ev.EncodedValueLookup;\n+import com.graphhopper.routing.util.CustomModel;\n+import com.graphhopper.routing.util.EncodingManager;\n+import com.graphhopper.util.EdgeIteratorState;\n+import com.graphhopper.util.GHUtility;\n+import com.graphhopper.util.shapes.BBox;\n+import com.graphhopper.util.shapes.Polygon;\n+import org.codehaus.commons.compiler.CompileException;\n+import org.codehaus.commons.compiler.Location;\n+import org.codehaus.commons.compiler.io.Readers;\n+import org.codehaus.janino.Scanner;\n+import org.codehaus.janino.*;\n+import org.codehaus.janino.util.DeepCopier;\n+import org.locationtech.jts.geom.prep.PreparedGeometryFactory;\n+\n+import java.io.*;\n+import java.util.*;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+class ExpressionBuilder {\n+    private static final AtomicLong longVal = new AtomicLong(1);\n+    static final String IN_AREA_PREFIX = \"in_area_\";\n+    private static final Set<String> allowedNames = new HashSet<>(Arrays.asList(\"edge\", \"Math\"));\n+    private static final boolean JANINO_DEBUG = Boolean.getBoolean(Scanner.SYSTEM_PROPERTY_SOURCE_DEBUGGING_ENABLE);\n+\n+    // TODO without a cache we get X% slower routing and Y% slower routingLM8. CH requests and preparation is unaffected\n+    // as cached weighting from preparation is used. This cache ensures that the first Weighting classes, typically the\n+    // ones specified in the profiles, are never removed regardless of how frequent other Weightings are created and accessed.\n+    // We only need to synchronize the get and put methods alone. E.g. we do not care for the race condition where\n+    // two identical classes are requested and one of them is overwritten. We could use CachingJavaSourceClassLoader from\n+    // Janino but 1. we would need to use a single compiler across threads and 2. the statements (for priority and speed)\n+    // are still unnecessarily created.\n+    private static final int CACHE_SIZE = Integer.getInteger(\"graphhopper.custom_weighting.cache_size\", 10);\n+    // TODO perf compare with ConcurrentHashMap, but I guess, if there is a difference at all, it is not big for small maps\n+    private static final Map<String, Class> CACHE = Collections.synchronizedMap(new HashMap<>(CACHE_SIZE));\n+\n+    // Introduce a dynamic cache to remember different Weighting classes, but throw away less frequently used classes.\n+    // Use accessOrder==true to remove oldest accessed entry, not oldest inserted.\n+    private static final int DYN_CACHE_SIZE = Integer.getInteger(\"graphhopper.custom_weighting.dynamic_cache_size\", 1000);\n+    private static final Map<String, Class> DYN_CACHE = Collections.synchronizedMap(\n+            new LinkedHashMap<String, Class>(DYN_CACHE_SIZE, 0.75f, true) {\n+                protected boolean removeEldestEntry(Map.Entry eldest) {\n+                    return size() > DYN_CACHE_SIZE;\n+                }\n+            });\n+\n+    /**\n+     * This method compiles a new subclass of CustomWeightingHelper composed from the provided CustomModel caches this\n+     * and returns an instance.\n+     */\n+    static CustomWeightingHelper create(CustomModel customModel, EncodedValueLookup lookup,\n+                                        double globalMaxSpeed, double maxSpeedFallback, DecimalEncodedValue avgSpeedEnc) {\n+        Java.CompilationUnit cu;\n+        try {\n+            String key = customModel.toString() + \",global:\" + globalMaxSpeed + \",fallback:\" + maxSpeedFallback;\n+            if (key.length() > 400_000) throw new IllegalArgumentException(\"Custom Model too big: \" + key.length());\n+\n+            Class clazz = CACHE.get(key);\n+            if (DYN_CACHE_SIZE > 0 && clazz == null)\n+                clazz = DYN_CACHE.get(key);\n+            if (clazz == null) {\n+                HashSet<String> priorityVariables = new LinkedHashSet<>();\n+                List<Java.BlockStatement> priorityStatements = createGetPriorityStatements(priorityVariables, customModel, lookup);\n+                HashSet<String> speedVariables = new LinkedHashSet<>();\n+                List<Java.BlockStatement> speedStatements = createGetSpeedStatements(speedVariables, customModel, lookup, globalMaxSpeed, maxSpeedFallback);\n+                // Create different class name, which is required only for debugging.\n+                // TODO does it improve performance too? I.e. it could be that the JIT is confused if different classes\n+                //  have the same name and it mixes performance stats. See https://github.com/janino-compiler/janino/issues/137\n+                long counter = longVal.incrementAndGet();\n+                String classTemplate = createClassTemplate(counter, priorityVariables, speedVariables, lookup, customModel);\n+                cu = (Java.CompilationUnit) new Parser(new org.codehaus.janino.Scanner(\"source\", new StringReader(classTemplate))).\n+                        parseAbstractCompilationUnit();\n+                cu = injectStatements(priorityStatements, speedStatements, cu);\n+                SimpleCompiler sc = createCompiler(counter, cu);\n+                clazz = sc.getClassLoader().loadClass(\"com.graphhopper.Test\" + counter);\n+                if (CACHE.size() < CACHE_SIZE)\n+                    CACHE.put(key, clazz);\n+                else if (DYN_CACHE_SIZE > 0)\n+                    DYN_CACHE.put(key, clazz);\n+            }\n+\n+            // The class does not need to be thread-safe as we create an instance per request\n+            CustomWeightingHelper prio = (CustomWeightingHelper) clazz.getDeclaredConstructor().newInstance();\n+            prio.init(lookup, avgSpeedEnc, customModel.getAreas());\n+            return prio;\n+        } catch (Exception ex) {\n+            String location = \"\";\n+            if (ex instanceof CompileException)\n+                location = \" in \" + ((CompileException) ex).getLocation().getFileName();\n+            throw new IllegalArgumentException(\"Cannot compile expression \" + location + \", \" + ex.getMessage(), ex);\n+        }\n+    }\n+\n+    /**\n+     * Parse the expressions from CustomModel relevant for the method getSpeed - see createClassTemplate.\n+     *\n+     * @return the created statements (parsed expressions)\n+     */\n+    private static List<Java.BlockStatement> createGetSpeedStatements(Set<String> speedVariables,\n+                                                                      CustomModel customModel, EncodedValueLookup lookup,\n+                                                                      double globalMaxSpeed, double maxSpeedFallback) throws Exception {\n+        List<Java.BlockStatement> speedStatements = new ArrayList<>();\n+        speedStatements.addAll(verifyExpressions(new StringBuilder(), \"speed_factor_user_statements\", speedVariables,\n+                customModel.getSpeedFactor(), lookup,\n+                num -> \"speed *= \" + num + \";\\n\", \"\"));\n+        StringBuilder codeSB = new StringBuilder(\"boolean applied = false;\\n\");\n+        speedStatements.addAll(verifyExpressions(codeSB, \"max_speed_user_statements\",\n+                speedVariables, customModel.getMaxSpeed(), lookup,\n+                num -> \"applied = true; speed = Math.min(speed,\" + num + \");\",\n+                \"if (!applied && speed > \" + maxSpeedFallback + \") return \" + maxSpeedFallback + \";\\n\" +\n+                        \"return Math.min(speed, \" + globalMaxSpeed + \");\\n\"));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTkxMzA0OA=="}, "originalCommit": {"oid": "f4478bb97c3d7585b21c39eadf45d80e57436cb3"}, "originalPosition": 133}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTM0MzU0Ng==", "bodyText": "What do you mean 3+4?\n\nYou had these examples 3) and 4). Where 3) had three if-blocks and 4) had one if-then-else-if block.\n\nAnd where would do you think we should allow 'else'?\n\nDo you mean why we should allow else? Why not? So e.g. a truck should get a max speed of 100km/h for primary and motorway roads but only 90km/h for everything else.", "url": "https://github.com/graphhopper/graphhopper/pull/2209#discussion_r545343546", "createdAt": "2020-12-17T19:22:36Z", "author": {"login": "karussell"}, "path": "core/src/main/java/com/graphhopper/routing/weighting/custom/ExpressionBuilder.java", "diffHunk": "@@ -0,0 +1,379 @@\n+/*\n+ *  Licensed to GraphHopper GmbH under one or more contributor\n+ *  license agreements. See the NOTICE file distributed with this work for\n+ *  additional information regarding copyright ownership.\n+ *\n+ *  GraphHopper GmbH licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except in\n+ *  compliance with the License. You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package com.graphhopper.routing.weighting.custom;\n+\n+import com.graphhopper.json.geo.JsonFeature;\n+import com.graphhopper.routing.ev.DecimalEncodedValue;\n+import com.graphhopper.routing.ev.EncodedValue;\n+import com.graphhopper.routing.ev.EncodedValueLookup;\n+import com.graphhopper.routing.util.CustomModel;\n+import com.graphhopper.routing.util.EncodingManager;\n+import com.graphhopper.util.EdgeIteratorState;\n+import com.graphhopper.util.GHUtility;\n+import com.graphhopper.util.shapes.BBox;\n+import com.graphhopper.util.shapes.Polygon;\n+import org.codehaus.commons.compiler.CompileException;\n+import org.codehaus.commons.compiler.Location;\n+import org.codehaus.commons.compiler.io.Readers;\n+import org.codehaus.janino.Scanner;\n+import org.codehaus.janino.*;\n+import org.codehaus.janino.util.DeepCopier;\n+import org.locationtech.jts.geom.prep.PreparedGeometryFactory;\n+\n+import java.io.*;\n+import java.util.*;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+class ExpressionBuilder {\n+    private static final AtomicLong longVal = new AtomicLong(1);\n+    static final String IN_AREA_PREFIX = \"in_area_\";\n+    private static final Set<String> allowedNames = new HashSet<>(Arrays.asList(\"edge\", \"Math\"));\n+    private static final boolean JANINO_DEBUG = Boolean.getBoolean(Scanner.SYSTEM_PROPERTY_SOURCE_DEBUGGING_ENABLE);\n+\n+    // TODO without a cache we get X% slower routing and Y% slower routingLM8. CH requests and preparation is unaffected\n+    // as cached weighting from preparation is used. This cache ensures that the first Weighting classes, typically the\n+    // ones specified in the profiles, are never removed regardless of how frequent other Weightings are created and accessed.\n+    // We only need to synchronize the get and put methods alone. E.g. we do not care for the race condition where\n+    // two identical classes are requested and one of them is overwritten. We could use CachingJavaSourceClassLoader from\n+    // Janino but 1. we would need to use a single compiler across threads and 2. the statements (for priority and speed)\n+    // are still unnecessarily created.\n+    private static final int CACHE_SIZE = Integer.getInteger(\"graphhopper.custom_weighting.cache_size\", 10);\n+    // TODO perf compare with ConcurrentHashMap, but I guess, if there is a difference at all, it is not big for small maps\n+    private static final Map<String, Class> CACHE = Collections.synchronizedMap(new HashMap<>(CACHE_SIZE));\n+\n+    // Introduce a dynamic cache to remember different Weighting classes, but throw away less frequently used classes.\n+    // Use accessOrder==true to remove oldest accessed entry, not oldest inserted.\n+    private static final int DYN_CACHE_SIZE = Integer.getInteger(\"graphhopper.custom_weighting.dynamic_cache_size\", 1000);\n+    private static final Map<String, Class> DYN_CACHE = Collections.synchronizedMap(\n+            new LinkedHashMap<String, Class>(DYN_CACHE_SIZE, 0.75f, true) {\n+                protected boolean removeEldestEntry(Map.Entry eldest) {\n+                    return size() > DYN_CACHE_SIZE;\n+                }\n+            });\n+\n+    /**\n+     * This method compiles a new subclass of CustomWeightingHelper composed from the provided CustomModel caches this\n+     * and returns an instance.\n+     */\n+    static CustomWeightingHelper create(CustomModel customModel, EncodedValueLookup lookup,\n+                                        double globalMaxSpeed, double maxSpeedFallback, DecimalEncodedValue avgSpeedEnc) {\n+        Java.CompilationUnit cu;\n+        try {\n+            String key = customModel.toString() + \",global:\" + globalMaxSpeed + \",fallback:\" + maxSpeedFallback;\n+            if (key.length() > 400_000) throw new IllegalArgumentException(\"Custom Model too big: \" + key.length());\n+\n+            Class clazz = CACHE.get(key);\n+            if (DYN_CACHE_SIZE > 0 && clazz == null)\n+                clazz = DYN_CACHE.get(key);\n+            if (clazz == null) {\n+                HashSet<String> priorityVariables = new LinkedHashSet<>();\n+                List<Java.BlockStatement> priorityStatements = createGetPriorityStatements(priorityVariables, customModel, lookup);\n+                HashSet<String> speedVariables = new LinkedHashSet<>();\n+                List<Java.BlockStatement> speedStatements = createGetSpeedStatements(speedVariables, customModel, lookup, globalMaxSpeed, maxSpeedFallback);\n+                // Create different class name, which is required only for debugging.\n+                // TODO does it improve performance too? I.e. it could be that the JIT is confused if different classes\n+                //  have the same name and it mixes performance stats. See https://github.com/janino-compiler/janino/issues/137\n+                long counter = longVal.incrementAndGet();\n+                String classTemplate = createClassTemplate(counter, priorityVariables, speedVariables, lookup, customModel);\n+                cu = (Java.CompilationUnit) new Parser(new org.codehaus.janino.Scanner(\"source\", new StringReader(classTemplate))).\n+                        parseAbstractCompilationUnit();\n+                cu = injectStatements(priorityStatements, speedStatements, cu);\n+                SimpleCompiler sc = createCompiler(counter, cu);\n+                clazz = sc.getClassLoader().loadClass(\"com.graphhopper.Test\" + counter);\n+                if (CACHE.size() < CACHE_SIZE)\n+                    CACHE.put(key, clazz);\n+                else if (DYN_CACHE_SIZE > 0)\n+                    DYN_CACHE.put(key, clazz);\n+            }\n+\n+            // The class does not need to be thread-safe as we create an instance per request\n+            CustomWeightingHelper prio = (CustomWeightingHelper) clazz.getDeclaredConstructor().newInstance();\n+            prio.init(lookup, avgSpeedEnc, customModel.getAreas());\n+            return prio;\n+        } catch (Exception ex) {\n+            String location = \"\";\n+            if (ex instanceof CompileException)\n+                location = \" in \" + ((CompileException) ex).getLocation().getFileName();\n+            throw new IllegalArgumentException(\"Cannot compile expression \" + location + \", \" + ex.getMessage(), ex);\n+        }\n+    }\n+\n+    /**\n+     * Parse the expressions from CustomModel relevant for the method getSpeed - see createClassTemplate.\n+     *\n+     * @return the created statements (parsed expressions)\n+     */\n+    private static List<Java.BlockStatement> createGetSpeedStatements(Set<String> speedVariables,\n+                                                                      CustomModel customModel, EncodedValueLookup lookup,\n+                                                                      double globalMaxSpeed, double maxSpeedFallback) throws Exception {\n+        List<Java.BlockStatement> speedStatements = new ArrayList<>();\n+        speedStatements.addAll(verifyExpressions(new StringBuilder(), \"speed_factor_user_statements\", speedVariables,\n+                customModel.getSpeedFactor(), lookup,\n+                num -> \"speed *= \" + num + \";\\n\", \"\"));\n+        StringBuilder codeSB = new StringBuilder(\"boolean applied = false;\\n\");\n+        speedStatements.addAll(verifyExpressions(codeSB, \"max_speed_user_statements\",\n+                speedVariables, customModel.getMaxSpeed(), lookup,\n+                num -> \"applied = true; speed = Math.min(speed,\" + num + \");\",\n+                \"if (!applied && speed > \" + maxSpeedFallback + \") return \" + maxSpeedFallback + \";\\n\" +\n+                        \"return Math.min(speed, \" + globalMaxSpeed + \");\\n\"));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTkxMzA0OA=="}, "originalCommit": {"oid": "f4478bb97c3d7585b21c39eadf45d80e57436cb3"}, "originalPosition": 133}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTM1MzI0Mw==", "bodyText": "You had these examples 3) and 4). Where 3) had three if-blocks and 4) had one if-then-else-if block.\n\nOh ok :) I thought this means: \"currently we allow an arbitrary combination of 7 if-then-else-if blocks... but nevermind ;)\n\nDo you mean why we should allow else?\n\nNo, I was just trying to find out how it is used, e.g. like this:\n- if: road_class == MOTORWAY\n  then: 100\n  else: 50\nor this:\n- if: road_class == MOTORWAY\n  then: 100\n- else: 50\nBut I guess you mean the latter? And do you want to allow else without preceding if?", "url": "https://github.com/graphhopper/graphhopper/pull/2209#discussion_r545353243", "createdAt": "2020-12-17T19:38:25Z", "author": {"login": "easbar"}, "path": "core/src/main/java/com/graphhopper/routing/weighting/custom/ExpressionBuilder.java", "diffHunk": "@@ -0,0 +1,379 @@\n+/*\n+ *  Licensed to GraphHopper GmbH under one or more contributor\n+ *  license agreements. See the NOTICE file distributed with this work for\n+ *  additional information regarding copyright ownership.\n+ *\n+ *  GraphHopper GmbH licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except in\n+ *  compliance with the License. You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package com.graphhopper.routing.weighting.custom;\n+\n+import com.graphhopper.json.geo.JsonFeature;\n+import com.graphhopper.routing.ev.DecimalEncodedValue;\n+import com.graphhopper.routing.ev.EncodedValue;\n+import com.graphhopper.routing.ev.EncodedValueLookup;\n+import com.graphhopper.routing.util.CustomModel;\n+import com.graphhopper.routing.util.EncodingManager;\n+import com.graphhopper.util.EdgeIteratorState;\n+import com.graphhopper.util.GHUtility;\n+import com.graphhopper.util.shapes.BBox;\n+import com.graphhopper.util.shapes.Polygon;\n+import org.codehaus.commons.compiler.CompileException;\n+import org.codehaus.commons.compiler.Location;\n+import org.codehaus.commons.compiler.io.Readers;\n+import org.codehaus.janino.Scanner;\n+import org.codehaus.janino.*;\n+import org.codehaus.janino.util.DeepCopier;\n+import org.locationtech.jts.geom.prep.PreparedGeometryFactory;\n+\n+import java.io.*;\n+import java.util.*;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+class ExpressionBuilder {\n+    private static final AtomicLong longVal = new AtomicLong(1);\n+    static final String IN_AREA_PREFIX = \"in_area_\";\n+    private static final Set<String> allowedNames = new HashSet<>(Arrays.asList(\"edge\", \"Math\"));\n+    private static final boolean JANINO_DEBUG = Boolean.getBoolean(Scanner.SYSTEM_PROPERTY_SOURCE_DEBUGGING_ENABLE);\n+\n+    // TODO without a cache we get X% slower routing and Y% slower routingLM8. CH requests and preparation is unaffected\n+    // as cached weighting from preparation is used. This cache ensures that the first Weighting classes, typically the\n+    // ones specified in the profiles, are never removed regardless of how frequent other Weightings are created and accessed.\n+    // We only need to synchronize the get and put methods alone. E.g. we do not care for the race condition where\n+    // two identical classes are requested and one of them is overwritten. We could use CachingJavaSourceClassLoader from\n+    // Janino but 1. we would need to use a single compiler across threads and 2. the statements (for priority and speed)\n+    // are still unnecessarily created.\n+    private static final int CACHE_SIZE = Integer.getInteger(\"graphhopper.custom_weighting.cache_size\", 10);\n+    // TODO perf compare with ConcurrentHashMap, but I guess, if there is a difference at all, it is not big for small maps\n+    private static final Map<String, Class> CACHE = Collections.synchronizedMap(new HashMap<>(CACHE_SIZE));\n+\n+    // Introduce a dynamic cache to remember different Weighting classes, but throw away less frequently used classes.\n+    // Use accessOrder==true to remove oldest accessed entry, not oldest inserted.\n+    private static final int DYN_CACHE_SIZE = Integer.getInteger(\"graphhopper.custom_weighting.dynamic_cache_size\", 1000);\n+    private static final Map<String, Class> DYN_CACHE = Collections.synchronizedMap(\n+            new LinkedHashMap<String, Class>(DYN_CACHE_SIZE, 0.75f, true) {\n+                protected boolean removeEldestEntry(Map.Entry eldest) {\n+                    return size() > DYN_CACHE_SIZE;\n+                }\n+            });\n+\n+    /**\n+     * This method compiles a new subclass of CustomWeightingHelper composed from the provided CustomModel caches this\n+     * and returns an instance.\n+     */\n+    static CustomWeightingHelper create(CustomModel customModel, EncodedValueLookup lookup,\n+                                        double globalMaxSpeed, double maxSpeedFallback, DecimalEncodedValue avgSpeedEnc) {\n+        Java.CompilationUnit cu;\n+        try {\n+            String key = customModel.toString() + \",global:\" + globalMaxSpeed + \",fallback:\" + maxSpeedFallback;\n+            if (key.length() > 400_000) throw new IllegalArgumentException(\"Custom Model too big: \" + key.length());\n+\n+            Class clazz = CACHE.get(key);\n+            if (DYN_CACHE_SIZE > 0 && clazz == null)\n+                clazz = DYN_CACHE.get(key);\n+            if (clazz == null) {\n+                HashSet<String> priorityVariables = new LinkedHashSet<>();\n+                List<Java.BlockStatement> priorityStatements = createGetPriorityStatements(priorityVariables, customModel, lookup);\n+                HashSet<String> speedVariables = new LinkedHashSet<>();\n+                List<Java.BlockStatement> speedStatements = createGetSpeedStatements(speedVariables, customModel, lookup, globalMaxSpeed, maxSpeedFallback);\n+                // Create different class name, which is required only for debugging.\n+                // TODO does it improve performance too? I.e. it could be that the JIT is confused if different classes\n+                //  have the same name and it mixes performance stats. See https://github.com/janino-compiler/janino/issues/137\n+                long counter = longVal.incrementAndGet();\n+                String classTemplate = createClassTemplate(counter, priorityVariables, speedVariables, lookup, customModel);\n+                cu = (Java.CompilationUnit) new Parser(new org.codehaus.janino.Scanner(\"source\", new StringReader(classTemplate))).\n+                        parseAbstractCompilationUnit();\n+                cu = injectStatements(priorityStatements, speedStatements, cu);\n+                SimpleCompiler sc = createCompiler(counter, cu);\n+                clazz = sc.getClassLoader().loadClass(\"com.graphhopper.Test\" + counter);\n+                if (CACHE.size() < CACHE_SIZE)\n+                    CACHE.put(key, clazz);\n+                else if (DYN_CACHE_SIZE > 0)\n+                    DYN_CACHE.put(key, clazz);\n+            }\n+\n+            // The class does not need to be thread-safe as we create an instance per request\n+            CustomWeightingHelper prio = (CustomWeightingHelper) clazz.getDeclaredConstructor().newInstance();\n+            prio.init(lookup, avgSpeedEnc, customModel.getAreas());\n+            return prio;\n+        } catch (Exception ex) {\n+            String location = \"\";\n+            if (ex instanceof CompileException)\n+                location = \" in \" + ((CompileException) ex).getLocation().getFileName();\n+            throw new IllegalArgumentException(\"Cannot compile expression \" + location + \", \" + ex.getMessage(), ex);\n+        }\n+    }\n+\n+    /**\n+     * Parse the expressions from CustomModel relevant for the method getSpeed - see createClassTemplate.\n+     *\n+     * @return the created statements (parsed expressions)\n+     */\n+    private static List<Java.BlockStatement> createGetSpeedStatements(Set<String> speedVariables,\n+                                                                      CustomModel customModel, EncodedValueLookup lookup,\n+                                                                      double globalMaxSpeed, double maxSpeedFallback) throws Exception {\n+        List<Java.BlockStatement> speedStatements = new ArrayList<>();\n+        speedStatements.addAll(verifyExpressions(new StringBuilder(), \"speed_factor_user_statements\", speedVariables,\n+                customModel.getSpeedFactor(), lookup,\n+                num -> \"speed *= \" + num + \";\\n\", \"\"));\n+        StringBuilder codeSB = new StringBuilder(\"boolean applied = false;\\n\");\n+        speedStatements.addAll(verifyExpressions(codeSB, \"max_speed_user_statements\",\n+                speedVariables, customModel.getMaxSpeed(), lookup,\n+                num -> \"applied = true; speed = Math.min(speed,\" + num + \");\",\n+                \"if (!applied && speed > \" + maxSpeedFallback + \") return \" + maxSpeedFallback + \";\\n\" +\n+                        \"return Math.min(speed, \" + globalMaxSpeed + \");\\n\"));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTkxMzA0OA=="}, "originalCommit": {"oid": "f4478bb97c3d7585b21c39eadf45d80e57436cb3"}, "originalPosition": 133}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTM1OTc3Nw==", "bodyText": "To me this syntax is still confusing, because I just keep reading 'then'  as return. It was even worse with 'value'.\nWhat would not be confusing to me would be this:\nmax_speed:\n   - if: road_class == MOTORWAY\n     reduce_to: 100  \n   - else if: surface == GRAVEL\n     reduce_to: 70\n   - else:\n     reduce_to: 80\npriority:\n  - if: road_class == MOTORWAY\n    multiply_with: 0.5\n  - else if: surface == GRAVEL\n    multiply_with: 0.3\n  - else:\n    multiply_with: 0.9\nAnd I see it as an advantage not a drawback that we have different keywords for max_speed and priority/speed, because after all a different operator is used to combine the matching values.", "url": "https://github.com/graphhopper/graphhopper/pull/2209#discussion_r545359777", "createdAt": "2020-12-17T19:49:21Z", "author": {"login": "easbar"}, "path": "core/src/main/java/com/graphhopper/routing/weighting/custom/ExpressionBuilder.java", "diffHunk": "@@ -0,0 +1,379 @@\n+/*\n+ *  Licensed to GraphHopper GmbH under one or more contributor\n+ *  license agreements. See the NOTICE file distributed with this work for\n+ *  additional information regarding copyright ownership.\n+ *\n+ *  GraphHopper GmbH licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except in\n+ *  compliance with the License. You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package com.graphhopper.routing.weighting.custom;\n+\n+import com.graphhopper.json.geo.JsonFeature;\n+import com.graphhopper.routing.ev.DecimalEncodedValue;\n+import com.graphhopper.routing.ev.EncodedValue;\n+import com.graphhopper.routing.ev.EncodedValueLookup;\n+import com.graphhopper.routing.util.CustomModel;\n+import com.graphhopper.routing.util.EncodingManager;\n+import com.graphhopper.util.EdgeIteratorState;\n+import com.graphhopper.util.GHUtility;\n+import com.graphhopper.util.shapes.BBox;\n+import com.graphhopper.util.shapes.Polygon;\n+import org.codehaus.commons.compiler.CompileException;\n+import org.codehaus.commons.compiler.Location;\n+import org.codehaus.commons.compiler.io.Readers;\n+import org.codehaus.janino.Scanner;\n+import org.codehaus.janino.*;\n+import org.codehaus.janino.util.DeepCopier;\n+import org.locationtech.jts.geom.prep.PreparedGeometryFactory;\n+\n+import java.io.*;\n+import java.util.*;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+class ExpressionBuilder {\n+    private static final AtomicLong longVal = new AtomicLong(1);\n+    static final String IN_AREA_PREFIX = \"in_area_\";\n+    private static final Set<String> allowedNames = new HashSet<>(Arrays.asList(\"edge\", \"Math\"));\n+    private static final boolean JANINO_DEBUG = Boolean.getBoolean(Scanner.SYSTEM_PROPERTY_SOURCE_DEBUGGING_ENABLE);\n+\n+    // TODO without a cache we get X% slower routing and Y% slower routingLM8. CH requests and preparation is unaffected\n+    // as cached weighting from preparation is used. This cache ensures that the first Weighting classes, typically the\n+    // ones specified in the profiles, are never removed regardless of how frequent other Weightings are created and accessed.\n+    // We only need to synchronize the get and put methods alone. E.g. we do not care for the race condition where\n+    // two identical classes are requested and one of them is overwritten. We could use CachingJavaSourceClassLoader from\n+    // Janino but 1. we would need to use a single compiler across threads and 2. the statements (for priority and speed)\n+    // are still unnecessarily created.\n+    private static final int CACHE_SIZE = Integer.getInteger(\"graphhopper.custom_weighting.cache_size\", 10);\n+    // TODO perf compare with ConcurrentHashMap, but I guess, if there is a difference at all, it is not big for small maps\n+    private static final Map<String, Class> CACHE = Collections.synchronizedMap(new HashMap<>(CACHE_SIZE));\n+\n+    // Introduce a dynamic cache to remember different Weighting classes, but throw away less frequently used classes.\n+    // Use accessOrder==true to remove oldest accessed entry, not oldest inserted.\n+    private static final int DYN_CACHE_SIZE = Integer.getInteger(\"graphhopper.custom_weighting.dynamic_cache_size\", 1000);\n+    private static final Map<String, Class> DYN_CACHE = Collections.synchronizedMap(\n+            new LinkedHashMap<String, Class>(DYN_CACHE_SIZE, 0.75f, true) {\n+                protected boolean removeEldestEntry(Map.Entry eldest) {\n+                    return size() > DYN_CACHE_SIZE;\n+                }\n+            });\n+\n+    /**\n+     * This method compiles a new subclass of CustomWeightingHelper composed from the provided CustomModel caches this\n+     * and returns an instance.\n+     */\n+    static CustomWeightingHelper create(CustomModel customModel, EncodedValueLookup lookup,\n+                                        double globalMaxSpeed, double maxSpeedFallback, DecimalEncodedValue avgSpeedEnc) {\n+        Java.CompilationUnit cu;\n+        try {\n+            String key = customModel.toString() + \",global:\" + globalMaxSpeed + \",fallback:\" + maxSpeedFallback;\n+            if (key.length() > 400_000) throw new IllegalArgumentException(\"Custom Model too big: \" + key.length());\n+\n+            Class clazz = CACHE.get(key);\n+            if (DYN_CACHE_SIZE > 0 && clazz == null)\n+                clazz = DYN_CACHE.get(key);\n+            if (clazz == null) {\n+                HashSet<String> priorityVariables = new LinkedHashSet<>();\n+                List<Java.BlockStatement> priorityStatements = createGetPriorityStatements(priorityVariables, customModel, lookup);\n+                HashSet<String> speedVariables = new LinkedHashSet<>();\n+                List<Java.BlockStatement> speedStatements = createGetSpeedStatements(speedVariables, customModel, lookup, globalMaxSpeed, maxSpeedFallback);\n+                // Create different class name, which is required only for debugging.\n+                // TODO does it improve performance too? I.e. it could be that the JIT is confused if different classes\n+                //  have the same name and it mixes performance stats. See https://github.com/janino-compiler/janino/issues/137\n+                long counter = longVal.incrementAndGet();\n+                String classTemplate = createClassTemplate(counter, priorityVariables, speedVariables, lookup, customModel);\n+                cu = (Java.CompilationUnit) new Parser(new org.codehaus.janino.Scanner(\"source\", new StringReader(classTemplate))).\n+                        parseAbstractCompilationUnit();\n+                cu = injectStatements(priorityStatements, speedStatements, cu);\n+                SimpleCompiler sc = createCompiler(counter, cu);\n+                clazz = sc.getClassLoader().loadClass(\"com.graphhopper.Test\" + counter);\n+                if (CACHE.size() < CACHE_SIZE)\n+                    CACHE.put(key, clazz);\n+                else if (DYN_CACHE_SIZE > 0)\n+                    DYN_CACHE.put(key, clazz);\n+            }\n+\n+            // The class does not need to be thread-safe as we create an instance per request\n+            CustomWeightingHelper prio = (CustomWeightingHelper) clazz.getDeclaredConstructor().newInstance();\n+            prio.init(lookup, avgSpeedEnc, customModel.getAreas());\n+            return prio;\n+        } catch (Exception ex) {\n+            String location = \"\";\n+            if (ex instanceof CompileException)\n+                location = \" in \" + ((CompileException) ex).getLocation().getFileName();\n+            throw new IllegalArgumentException(\"Cannot compile expression \" + location + \", \" + ex.getMessage(), ex);\n+        }\n+    }\n+\n+    /**\n+     * Parse the expressions from CustomModel relevant for the method getSpeed - see createClassTemplate.\n+     *\n+     * @return the created statements (parsed expressions)\n+     */\n+    private static List<Java.BlockStatement> createGetSpeedStatements(Set<String> speedVariables,\n+                                                                      CustomModel customModel, EncodedValueLookup lookup,\n+                                                                      double globalMaxSpeed, double maxSpeedFallback) throws Exception {\n+        List<Java.BlockStatement> speedStatements = new ArrayList<>();\n+        speedStatements.addAll(verifyExpressions(new StringBuilder(), \"speed_factor_user_statements\", speedVariables,\n+                customModel.getSpeedFactor(), lookup,\n+                num -> \"speed *= \" + num + \";\\n\", \"\"));\n+        StringBuilder codeSB = new StringBuilder(\"boolean applied = false;\\n\");\n+        speedStatements.addAll(verifyExpressions(codeSB, \"max_speed_user_statements\",\n+                speedVariables, customModel.getMaxSpeed(), lookup,\n+                num -> \"applied = true; speed = Math.min(speed,\" + num + \");\",\n+                \"if (!applied && speed > \" + maxSpeedFallback + \") return \" + maxSpeedFallback + \";\\n\" +\n+                        \"return Math.min(speed, \" + globalMaxSpeed + \");\\n\"));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTkxMzA0OA=="}, "originalCommit": {"oid": "f4478bb97c3d7585b21c39eadf45d80e57436cb3"}, "originalPosition": 133}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTM5ODYzNQ==", "bodyText": "But I guess you mean the latter?\n\nYes, every list entry has only a single operation and so a single number.\n\nAnd do you want to allow else without preceding if?\n\nThe checking is done from janino :)\nBasically every Java block requires a new list entry via -.\n\nAnd I see it as an advantage not a drawback that we have different keywords for max_speed and priority/speed\n\nIndeed, this reads better. Maybe replace the underscores with spaces similar to else if?", "url": "https://github.com/graphhopper/graphhopper/pull/2209#discussion_r545398635", "createdAt": "2020-12-17T20:57:10Z", "author": {"login": "karussell"}, "path": "core/src/main/java/com/graphhopper/routing/weighting/custom/ExpressionBuilder.java", "diffHunk": "@@ -0,0 +1,379 @@\n+/*\n+ *  Licensed to GraphHopper GmbH under one or more contributor\n+ *  license agreements. See the NOTICE file distributed with this work for\n+ *  additional information regarding copyright ownership.\n+ *\n+ *  GraphHopper GmbH licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except in\n+ *  compliance with the License. You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package com.graphhopper.routing.weighting.custom;\n+\n+import com.graphhopper.json.geo.JsonFeature;\n+import com.graphhopper.routing.ev.DecimalEncodedValue;\n+import com.graphhopper.routing.ev.EncodedValue;\n+import com.graphhopper.routing.ev.EncodedValueLookup;\n+import com.graphhopper.routing.util.CustomModel;\n+import com.graphhopper.routing.util.EncodingManager;\n+import com.graphhopper.util.EdgeIteratorState;\n+import com.graphhopper.util.GHUtility;\n+import com.graphhopper.util.shapes.BBox;\n+import com.graphhopper.util.shapes.Polygon;\n+import org.codehaus.commons.compiler.CompileException;\n+import org.codehaus.commons.compiler.Location;\n+import org.codehaus.commons.compiler.io.Readers;\n+import org.codehaus.janino.Scanner;\n+import org.codehaus.janino.*;\n+import org.codehaus.janino.util.DeepCopier;\n+import org.locationtech.jts.geom.prep.PreparedGeometryFactory;\n+\n+import java.io.*;\n+import java.util.*;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+class ExpressionBuilder {\n+    private static final AtomicLong longVal = new AtomicLong(1);\n+    static final String IN_AREA_PREFIX = \"in_area_\";\n+    private static final Set<String> allowedNames = new HashSet<>(Arrays.asList(\"edge\", \"Math\"));\n+    private static final boolean JANINO_DEBUG = Boolean.getBoolean(Scanner.SYSTEM_PROPERTY_SOURCE_DEBUGGING_ENABLE);\n+\n+    // TODO without a cache we get X% slower routing and Y% slower routingLM8. CH requests and preparation is unaffected\n+    // as cached weighting from preparation is used. This cache ensures that the first Weighting classes, typically the\n+    // ones specified in the profiles, are never removed regardless of how frequent other Weightings are created and accessed.\n+    // We only need to synchronize the get and put methods alone. E.g. we do not care for the race condition where\n+    // two identical classes are requested and one of them is overwritten. We could use CachingJavaSourceClassLoader from\n+    // Janino but 1. we would need to use a single compiler across threads and 2. the statements (for priority and speed)\n+    // are still unnecessarily created.\n+    private static final int CACHE_SIZE = Integer.getInteger(\"graphhopper.custom_weighting.cache_size\", 10);\n+    // TODO perf compare with ConcurrentHashMap, but I guess, if there is a difference at all, it is not big for small maps\n+    private static final Map<String, Class> CACHE = Collections.synchronizedMap(new HashMap<>(CACHE_SIZE));\n+\n+    // Introduce a dynamic cache to remember different Weighting classes, but throw away less frequently used classes.\n+    // Use accessOrder==true to remove oldest accessed entry, not oldest inserted.\n+    private static final int DYN_CACHE_SIZE = Integer.getInteger(\"graphhopper.custom_weighting.dynamic_cache_size\", 1000);\n+    private static final Map<String, Class> DYN_CACHE = Collections.synchronizedMap(\n+            new LinkedHashMap<String, Class>(DYN_CACHE_SIZE, 0.75f, true) {\n+                protected boolean removeEldestEntry(Map.Entry eldest) {\n+                    return size() > DYN_CACHE_SIZE;\n+                }\n+            });\n+\n+    /**\n+     * This method compiles a new subclass of CustomWeightingHelper composed from the provided CustomModel caches this\n+     * and returns an instance.\n+     */\n+    static CustomWeightingHelper create(CustomModel customModel, EncodedValueLookup lookup,\n+                                        double globalMaxSpeed, double maxSpeedFallback, DecimalEncodedValue avgSpeedEnc) {\n+        Java.CompilationUnit cu;\n+        try {\n+            String key = customModel.toString() + \",global:\" + globalMaxSpeed + \",fallback:\" + maxSpeedFallback;\n+            if (key.length() > 400_000) throw new IllegalArgumentException(\"Custom Model too big: \" + key.length());\n+\n+            Class clazz = CACHE.get(key);\n+            if (DYN_CACHE_SIZE > 0 && clazz == null)\n+                clazz = DYN_CACHE.get(key);\n+            if (clazz == null) {\n+                HashSet<String> priorityVariables = new LinkedHashSet<>();\n+                List<Java.BlockStatement> priorityStatements = createGetPriorityStatements(priorityVariables, customModel, lookup);\n+                HashSet<String> speedVariables = new LinkedHashSet<>();\n+                List<Java.BlockStatement> speedStatements = createGetSpeedStatements(speedVariables, customModel, lookup, globalMaxSpeed, maxSpeedFallback);\n+                // Create different class name, which is required only for debugging.\n+                // TODO does it improve performance too? I.e. it could be that the JIT is confused if different classes\n+                //  have the same name and it mixes performance stats. See https://github.com/janino-compiler/janino/issues/137\n+                long counter = longVal.incrementAndGet();\n+                String classTemplate = createClassTemplate(counter, priorityVariables, speedVariables, lookup, customModel);\n+                cu = (Java.CompilationUnit) new Parser(new org.codehaus.janino.Scanner(\"source\", new StringReader(classTemplate))).\n+                        parseAbstractCompilationUnit();\n+                cu = injectStatements(priorityStatements, speedStatements, cu);\n+                SimpleCompiler sc = createCompiler(counter, cu);\n+                clazz = sc.getClassLoader().loadClass(\"com.graphhopper.Test\" + counter);\n+                if (CACHE.size() < CACHE_SIZE)\n+                    CACHE.put(key, clazz);\n+                else if (DYN_CACHE_SIZE > 0)\n+                    DYN_CACHE.put(key, clazz);\n+            }\n+\n+            // The class does not need to be thread-safe as we create an instance per request\n+            CustomWeightingHelper prio = (CustomWeightingHelper) clazz.getDeclaredConstructor().newInstance();\n+            prio.init(lookup, avgSpeedEnc, customModel.getAreas());\n+            return prio;\n+        } catch (Exception ex) {\n+            String location = \"\";\n+            if (ex instanceof CompileException)\n+                location = \" in \" + ((CompileException) ex).getLocation().getFileName();\n+            throw new IllegalArgumentException(\"Cannot compile expression \" + location + \", \" + ex.getMessage(), ex);\n+        }\n+    }\n+\n+    /**\n+     * Parse the expressions from CustomModel relevant for the method getSpeed - see createClassTemplate.\n+     *\n+     * @return the created statements (parsed expressions)\n+     */\n+    private static List<Java.BlockStatement> createGetSpeedStatements(Set<String> speedVariables,\n+                                                                      CustomModel customModel, EncodedValueLookup lookup,\n+                                                                      double globalMaxSpeed, double maxSpeedFallback) throws Exception {\n+        List<Java.BlockStatement> speedStatements = new ArrayList<>();\n+        speedStatements.addAll(verifyExpressions(new StringBuilder(), \"speed_factor_user_statements\", speedVariables,\n+                customModel.getSpeedFactor(), lookup,\n+                num -> \"speed *= \" + num + \";\\n\", \"\"));\n+        StringBuilder codeSB = new StringBuilder(\"boolean applied = false;\\n\");\n+        speedStatements.addAll(verifyExpressions(codeSB, \"max_speed_user_statements\",\n+                speedVariables, customModel.getMaxSpeed(), lookup,\n+                num -> \"applied = true; speed = Math.min(speed,\" + num + \");\",\n+                \"if (!applied && speed > \" + maxSpeedFallback + \") return \" + maxSpeedFallback + \";\\n\" +\n+                        \"return Math.min(speed, \" + globalMaxSpeed + \");\\n\"));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTkxMzA0OA=="}, "originalCommit": {"oid": "f4478bb97c3d7585b21c39eadf45d80e57436cb3"}, "originalPosition": 133}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTQxOTU5OA==", "bodyText": "Maybe replace the underscores with spaces similar to else if?\n\nEither way is fine for me, but lets make it consistent: Either use space for 'else if' and 'multiply with' or use underscores for both. As you seem to prefer space lets take this (I did not think about it when I put the underscore).\nDo you think its a problem that reduce to is a no-op for example when 'reducing' 60 to 90? minimize_to might be a bit more precise, but maybe also too technical. I'm a bit undecided, but I think reduce to sounds good.\n\nThe checking is done from janino :) Basically every Java block requires a new list entry via -.\n\nDoes this mean an else block without if is not possible, just like in Java we cannot use a single else?\n# invalid\nmax_speed:\n  - else:\n    reduce_to: 65\n\n# valid\nmax_speed:\n  -if: true\n   reduce_to: 65\nHm, the second version seems better anyway...\nOk I think now we are converging, so let's talk about the max speed fallback again :)\n\nNow when it comes to the fallback max_speed I think we only need to loop through all if blocks and pick the minimum value and within one if block (including else-if and else) we pick the maximum. If one if block has no else we can skip it i.e. use the flagEncoder max_speed. A special case is \"if: true\" and \"if: false\".\n\nYes, I think you are right. For every 'statement' (if/else if/else chain) that has an 'else' (and therefore applies to all edges) we take the maximum and out of these maxima the minimum. This way we can be sure that the speed is never higher than the value we obtain and that we chose the max speed fallback as tight as possible.\nSorry for the little detour, I just kept reading value/then as 'return' and got all confused about this. But now the format makes a lot of sense to me.", "url": "https://github.com/graphhopper/graphhopper/pull/2209#discussion_r545419598", "createdAt": "2020-12-17T21:37:41Z", "author": {"login": "easbar"}, "path": "core/src/main/java/com/graphhopper/routing/weighting/custom/ExpressionBuilder.java", "diffHunk": "@@ -0,0 +1,379 @@\n+/*\n+ *  Licensed to GraphHopper GmbH under one or more contributor\n+ *  license agreements. See the NOTICE file distributed with this work for\n+ *  additional information regarding copyright ownership.\n+ *\n+ *  GraphHopper GmbH licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except in\n+ *  compliance with the License. You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package com.graphhopper.routing.weighting.custom;\n+\n+import com.graphhopper.json.geo.JsonFeature;\n+import com.graphhopper.routing.ev.DecimalEncodedValue;\n+import com.graphhopper.routing.ev.EncodedValue;\n+import com.graphhopper.routing.ev.EncodedValueLookup;\n+import com.graphhopper.routing.util.CustomModel;\n+import com.graphhopper.routing.util.EncodingManager;\n+import com.graphhopper.util.EdgeIteratorState;\n+import com.graphhopper.util.GHUtility;\n+import com.graphhopper.util.shapes.BBox;\n+import com.graphhopper.util.shapes.Polygon;\n+import org.codehaus.commons.compiler.CompileException;\n+import org.codehaus.commons.compiler.Location;\n+import org.codehaus.commons.compiler.io.Readers;\n+import org.codehaus.janino.Scanner;\n+import org.codehaus.janino.*;\n+import org.codehaus.janino.util.DeepCopier;\n+import org.locationtech.jts.geom.prep.PreparedGeometryFactory;\n+\n+import java.io.*;\n+import java.util.*;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+class ExpressionBuilder {\n+    private static final AtomicLong longVal = new AtomicLong(1);\n+    static final String IN_AREA_PREFIX = \"in_area_\";\n+    private static final Set<String> allowedNames = new HashSet<>(Arrays.asList(\"edge\", \"Math\"));\n+    private static final boolean JANINO_DEBUG = Boolean.getBoolean(Scanner.SYSTEM_PROPERTY_SOURCE_DEBUGGING_ENABLE);\n+\n+    // TODO without a cache we get X% slower routing and Y% slower routingLM8. CH requests and preparation is unaffected\n+    // as cached weighting from preparation is used. This cache ensures that the first Weighting classes, typically the\n+    // ones specified in the profiles, are never removed regardless of how frequent other Weightings are created and accessed.\n+    // We only need to synchronize the get and put methods alone. E.g. we do not care for the race condition where\n+    // two identical classes are requested and one of them is overwritten. We could use CachingJavaSourceClassLoader from\n+    // Janino but 1. we would need to use a single compiler across threads and 2. the statements (for priority and speed)\n+    // are still unnecessarily created.\n+    private static final int CACHE_SIZE = Integer.getInteger(\"graphhopper.custom_weighting.cache_size\", 10);\n+    // TODO perf compare with ConcurrentHashMap, but I guess, if there is a difference at all, it is not big for small maps\n+    private static final Map<String, Class> CACHE = Collections.synchronizedMap(new HashMap<>(CACHE_SIZE));\n+\n+    // Introduce a dynamic cache to remember different Weighting classes, but throw away less frequently used classes.\n+    // Use accessOrder==true to remove oldest accessed entry, not oldest inserted.\n+    private static final int DYN_CACHE_SIZE = Integer.getInteger(\"graphhopper.custom_weighting.dynamic_cache_size\", 1000);\n+    private static final Map<String, Class> DYN_CACHE = Collections.synchronizedMap(\n+            new LinkedHashMap<String, Class>(DYN_CACHE_SIZE, 0.75f, true) {\n+                protected boolean removeEldestEntry(Map.Entry eldest) {\n+                    return size() > DYN_CACHE_SIZE;\n+                }\n+            });\n+\n+    /**\n+     * This method compiles a new subclass of CustomWeightingHelper composed from the provided CustomModel caches this\n+     * and returns an instance.\n+     */\n+    static CustomWeightingHelper create(CustomModel customModel, EncodedValueLookup lookup,\n+                                        double globalMaxSpeed, double maxSpeedFallback, DecimalEncodedValue avgSpeedEnc) {\n+        Java.CompilationUnit cu;\n+        try {\n+            String key = customModel.toString() + \",global:\" + globalMaxSpeed + \",fallback:\" + maxSpeedFallback;\n+            if (key.length() > 400_000) throw new IllegalArgumentException(\"Custom Model too big: \" + key.length());\n+\n+            Class clazz = CACHE.get(key);\n+            if (DYN_CACHE_SIZE > 0 && clazz == null)\n+                clazz = DYN_CACHE.get(key);\n+            if (clazz == null) {\n+                HashSet<String> priorityVariables = new LinkedHashSet<>();\n+                List<Java.BlockStatement> priorityStatements = createGetPriorityStatements(priorityVariables, customModel, lookup);\n+                HashSet<String> speedVariables = new LinkedHashSet<>();\n+                List<Java.BlockStatement> speedStatements = createGetSpeedStatements(speedVariables, customModel, lookup, globalMaxSpeed, maxSpeedFallback);\n+                // Create different class name, which is required only for debugging.\n+                // TODO does it improve performance too? I.e. it could be that the JIT is confused if different classes\n+                //  have the same name and it mixes performance stats. See https://github.com/janino-compiler/janino/issues/137\n+                long counter = longVal.incrementAndGet();\n+                String classTemplate = createClassTemplate(counter, priorityVariables, speedVariables, lookup, customModel);\n+                cu = (Java.CompilationUnit) new Parser(new org.codehaus.janino.Scanner(\"source\", new StringReader(classTemplate))).\n+                        parseAbstractCompilationUnit();\n+                cu = injectStatements(priorityStatements, speedStatements, cu);\n+                SimpleCompiler sc = createCompiler(counter, cu);\n+                clazz = sc.getClassLoader().loadClass(\"com.graphhopper.Test\" + counter);\n+                if (CACHE.size() < CACHE_SIZE)\n+                    CACHE.put(key, clazz);\n+                else if (DYN_CACHE_SIZE > 0)\n+                    DYN_CACHE.put(key, clazz);\n+            }\n+\n+            // The class does not need to be thread-safe as we create an instance per request\n+            CustomWeightingHelper prio = (CustomWeightingHelper) clazz.getDeclaredConstructor().newInstance();\n+            prio.init(lookup, avgSpeedEnc, customModel.getAreas());\n+            return prio;\n+        } catch (Exception ex) {\n+            String location = \"\";\n+            if (ex instanceof CompileException)\n+                location = \" in \" + ((CompileException) ex).getLocation().getFileName();\n+            throw new IllegalArgumentException(\"Cannot compile expression \" + location + \", \" + ex.getMessage(), ex);\n+        }\n+    }\n+\n+    /**\n+     * Parse the expressions from CustomModel relevant for the method getSpeed - see createClassTemplate.\n+     *\n+     * @return the created statements (parsed expressions)\n+     */\n+    private static List<Java.BlockStatement> createGetSpeedStatements(Set<String> speedVariables,\n+                                                                      CustomModel customModel, EncodedValueLookup lookup,\n+                                                                      double globalMaxSpeed, double maxSpeedFallback) throws Exception {\n+        List<Java.BlockStatement> speedStatements = new ArrayList<>();\n+        speedStatements.addAll(verifyExpressions(new StringBuilder(), \"speed_factor_user_statements\", speedVariables,\n+                customModel.getSpeedFactor(), lookup,\n+                num -> \"speed *= \" + num + \";\\n\", \"\"));\n+        StringBuilder codeSB = new StringBuilder(\"boolean applied = false;\\n\");\n+        speedStatements.addAll(verifyExpressions(codeSB, \"max_speed_user_statements\",\n+                speedVariables, customModel.getMaxSpeed(), lookup,\n+                num -> \"applied = true; speed = Math.min(speed,\" + num + \");\",\n+                \"if (!applied && speed > \" + maxSpeedFallback + \") return \" + maxSpeedFallback + \";\\n\" +\n+                        \"return Math.min(speed, \" + globalMaxSpeed + \");\\n\"));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTkxMzA0OA=="}, "originalCommit": {"oid": "f4478bb97c3d7585b21c39eadf45d80e57436cb3"}, "originalPosition": 133}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTc3ODMyMQ==", "bodyText": "I just thought about this and now we could even merge speed_factor and max_speed! Like:\nspeed:\n - if: road_class == TERTIARY\n   multiply with: 0.8\n - if: surface != ASPHALT\n   reduce to: 100    \n\nDo you think its a problem that reduce to is a no-op for example when 'reducing' 60 to 90\n\nNo.\nI'm not yet 100% satisfied with the name. I like minimize to or maybe lower to ... not sure.\n\nDoes this mean an else block without if is not possible, just like in Java we cannot use a single else?\n\nYes\n\nwe take the maximum and out of these maxima the minimum\nThis way we can be sure that the speed is never higher than the value we obtain and that we chose the max speed fallback as tight as possible.\n\n\ud83d\udc4d\n\nSorry for the little detour,\n\nIt was worth a lot I guess :)\n\nI just kept reading value/then as 'return' and got all confused about this. But now the format makes a lot of sense to me.\n\nYes!", "url": "https://github.com/graphhopper/graphhopper/pull/2209#discussion_r545778321", "createdAt": "2020-12-18T11:42:13Z", "author": {"login": "karussell"}, "path": "core/src/main/java/com/graphhopper/routing/weighting/custom/ExpressionBuilder.java", "diffHunk": "@@ -0,0 +1,379 @@\n+/*\n+ *  Licensed to GraphHopper GmbH under one or more contributor\n+ *  license agreements. See the NOTICE file distributed with this work for\n+ *  additional information regarding copyright ownership.\n+ *\n+ *  GraphHopper GmbH licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except in\n+ *  compliance with the License. You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package com.graphhopper.routing.weighting.custom;\n+\n+import com.graphhopper.json.geo.JsonFeature;\n+import com.graphhopper.routing.ev.DecimalEncodedValue;\n+import com.graphhopper.routing.ev.EncodedValue;\n+import com.graphhopper.routing.ev.EncodedValueLookup;\n+import com.graphhopper.routing.util.CustomModel;\n+import com.graphhopper.routing.util.EncodingManager;\n+import com.graphhopper.util.EdgeIteratorState;\n+import com.graphhopper.util.GHUtility;\n+import com.graphhopper.util.shapes.BBox;\n+import com.graphhopper.util.shapes.Polygon;\n+import org.codehaus.commons.compiler.CompileException;\n+import org.codehaus.commons.compiler.Location;\n+import org.codehaus.commons.compiler.io.Readers;\n+import org.codehaus.janino.Scanner;\n+import org.codehaus.janino.*;\n+import org.codehaus.janino.util.DeepCopier;\n+import org.locationtech.jts.geom.prep.PreparedGeometryFactory;\n+\n+import java.io.*;\n+import java.util.*;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+class ExpressionBuilder {\n+    private static final AtomicLong longVal = new AtomicLong(1);\n+    static final String IN_AREA_PREFIX = \"in_area_\";\n+    private static final Set<String> allowedNames = new HashSet<>(Arrays.asList(\"edge\", \"Math\"));\n+    private static final boolean JANINO_DEBUG = Boolean.getBoolean(Scanner.SYSTEM_PROPERTY_SOURCE_DEBUGGING_ENABLE);\n+\n+    // TODO without a cache we get X% slower routing and Y% slower routingLM8. CH requests and preparation is unaffected\n+    // as cached weighting from preparation is used. This cache ensures that the first Weighting classes, typically the\n+    // ones specified in the profiles, are never removed regardless of how frequent other Weightings are created and accessed.\n+    // We only need to synchronize the get and put methods alone. E.g. we do not care for the race condition where\n+    // two identical classes are requested and one of them is overwritten. We could use CachingJavaSourceClassLoader from\n+    // Janino but 1. we would need to use a single compiler across threads and 2. the statements (for priority and speed)\n+    // are still unnecessarily created.\n+    private static final int CACHE_SIZE = Integer.getInteger(\"graphhopper.custom_weighting.cache_size\", 10);\n+    // TODO perf compare with ConcurrentHashMap, but I guess, if there is a difference at all, it is not big for small maps\n+    private static final Map<String, Class> CACHE = Collections.synchronizedMap(new HashMap<>(CACHE_SIZE));\n+\n+    // Introduce a dynamic cache to remember different Weighting classes, but throw away less frequently used classes.\n+    // Use accessOrder==true to remove oldest accessed entry, not oldest inserted.\n+    private static final int DYN_CACHE_SIZE = Integer.getInteger(\"graphhopper.custom_weighting.dynamic_cache_size\", 1000);\n+    private static final Map<String, Class> DYN_CACHE = Collections.synchronizedMap(\n+            new LinkedHashMap<String, Class>(DYN_CACHE_SIZE, 0.75f, true) {\n+                protected boolean removeEldestEntry(Map.Entry eldest) {\n+                    return size() > DYN_CACHE_SIZE;\n+                }\n+            });\n+\n+    /**\n+     * This method compiles a new subclass of CustomWeightingHelper composed from the provided CustomModel caches this\n+     * and returns an instance.\n+     */\n+    static CustomWeightingHelper create(CustomModel customModel, EncodedValueLookup lookup,\n+                                        double globalMaxSpeed, double maxSpeedFallback, DecimalEncodedValue avgSpeedEnc) {\n+        Java.CompilationUnit cu;\n+        try {\n+            String key = customModel.toString() + \",global:\" + globalMaxSpeed + \",fallback:\" + maxSpeedFallback;\n+            if (key.length() > 400_000) throw new IllegalArgumentException(\"Custom Model too big: \" + key.length());\n+\n+            Class clazz = CACHE.get(key);\n+            if (DYN_CACHE_SIZE > 0 && clazz == null)\n+                clazz = DYN_CACHE.get(key);\n+            if (clazz == null) {\n+                HashSet<String> priorityVariables = new LinkedHashSet<>();\n+                List<Java.BlockStatement> priorityStatements = createGetPriorityStatements(priorityVariables, customModel, lookup);\n+                HashSet<String> speedVariables = new LinkedHashSet<>();\n+                List<Java.BlockStatement> speedStatements = createGetSpeedStatements(speedVariables, customModel, lookup, globalMaxSpeed, maxSpeedFallback);\n+                // Create different class name, which is required only for debugging.\n+                // TODO does it improve performance too? I.e. it could be that the JIT is confused if different classes\n+                //  have the same name and it mixes performance stats. See https://github.com/janino-compiler/janino/issues/137\n+                long counter = longVal.incrementAndGet();\n+                String classTemplate = createClassTemplate(counter, priorityVariables, speedVariables, lookup, customModel);\n+                cu = (Java.CompilationUnit) new Parser(new org.codehaus.janino.Scanner(\"source\", new StringReader(classTemplate))).\n+                        parseAbstractCompilationUnit();\n+                cu = injectStatements(priorityStatements, speedStatements, cu);\n+                SimpleCompiler sc = createCompiler(counter, cu);\n+                clazz = sc.getClassLoader().loadClass(\"com.graphhopper.Test\" + counter);\n+                if (CACHE.size() < CACHE_SIZE)\n+                    CACHE.put(key, clazz);\n+                else if (DYN_CACHE_SIZE > 0)\n+                    DYN_CACHE.put(key, clazz);\n+            }\n+\n+            // The class does not need to be thread-safe as we create an instance per request\n+            CustomWeightingHelper prio = (CustomWeightingHelper) clazz.getDeclaredConstructor().newInstance();\n+            prio.init(lookup, avgSpeedEnc, customModel.getAreas());\n+            return prio;\n+        } catch (Exception ex) {\n+            String location = \"\";\n+            if (ex instanceof CompileException)\n+                location = \" in \" + ((CompileException) ex).getLocation().getFileName();\n+            throw new IllegalArgumentException(\"Cannot compile expression \" + location + \", \" + ex.getMessage(), ex);\n+        }\n+    }\n+\n+    /**\n+     * Parse the expressions from CustomModel relevant for the method getSpeed - see createClassTemplate.\n+     *\n+     * @return the created statements (parsed expressions)\n+     */\n+    private static List<Java.BlockStatement> createGetSpeedStatements(Set<String> speedVariables,\n+                                                                      CustomModel customModel, EncodedValueLookup lookup,\n+                                                                      double globalMaxSpeed, double maxSpeedFallback) throws Exception {\n+        List<Java.BlockStatement> speedStatements = new ArrayList<>();\n+        speedStatements.addAll(verifyExpressions(new StringBuilder(), \"speed_factor_user_statements\", speedVariables,\n+                customModel.getSpeedFactor(), lookup,\n+                num -> \"speed *= \" + num + \";\\n\", \"\"));\n+        StringBuilder codeSB = new StringBuilder(\"boolean applied = false;\\n\");\n+        speedStatements.addAll(verifyExpressions(codeSB, \"max_speed_user_statements\",\n+                speedVariables, customModel.getMaxSpeed(), lookup,\n+                num -> \"applied = true; speed = Math.min(speed,\" + num + \");\",\n+                \"if (!applied && speed > \" + maxSpeedFallback + \") return \" + maxSpeedFallback + \";\\n\" +\n+                        \"return Math.min(speed, \" + globalMaxSpeed + \");\\n\"));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTkxMzA0OA=="}, "originalCommit": {"oid": "f4478bb97c3d7585b21c39eadf45d80e57436cb3"}, "originalPosition": 133}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTc5NDQyMQ==", "bodyText": "I just thought about this and now we could even merge speed_factor and max_speed! Like:\n\nOh interesting yes. But maybe we have to be a bit careful, because then the order becomes important again? For example 100 multiply with 0.8 reduce to 50 = 50, but 100 reduce to 50 multiply with 0.8 = 40. Hm, not sure if this is easier or harder to use this way. Having all speed-related modifications in one section also seems nice.\n\nI'm not yet 100% satisfied with the name. I like minimize to or maybe lower to ... not sure.\n\nA few other options would be: max, set max, limit or limit at, especially if we remove the speed category.\nspeed:\n- if: road_class == MOTORWAY\n  limit: 70\nWe probably should find out whether or not we keep the max_speed section or not first.\nI also thought there might be room for other operators, for example setting the speed to a certain value instead of multiplying the default speed with some factor. Something like a set to operator. But maybe we should just make sure the format is flexible enough and decide this later.\nMaybe it would be more generic to use the operator as value instead of key:\npriority\n- if: road_class == MOTORWAY\n  operator: multiply_with\n  value: 0.8\nIts more verbose and a bit harder to read, but I guess it is more generic so the datatype stays the same for the different operators.", "url": "https://github.com/graphhopper/graphhopper/pull/2209#discussion_r545794421", "createdAt": "2020-12-18T12:16:21Z", "author": {"login": "easbar"}, "path": "core/src/main/java/com/graphhopper/routing/weighting/custom/ExpressionBuilder.java", "diffHunk": "@@ -0,0 +1,379 @@\n+/*\n+ *  Licensed to GraphHopper GmbH under one or more contributor\n+ *  license agreements. See the NOTICE file distributed with this work for\n+ *  additional information regarding copyright ownership.\n+ *\n+ *  GraphHopper GmbH licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except in\n+ *  compliance with the License. You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package com.graphhopper.routing.weighting.custom;\n+\n+import com.graphhopper.json.geo.JsonFeature;\n+import com.graphhopper.routing.ev.DecimalEncodedValue;\n+import com.graphhopper.routing.ev.EncodedValue;\n+import com.graphhopper.routing.ev.EncodedValueLookup;\n+import com.graphhopper.routing.util.CustomModel;\n+import com.graphhopper.routing.util.EncodingManager;\n+import com.graphhopper.util.EdgeIteratorState;\n+import com.graphhopper.util.GHUtility;\n+import com.graphhopper.util.shapes.BBox;\n+import com.graphhopper.util.shapes.Polygon;\n+import org.codehaus.commons.compiler.CompileException;\n+import org.codehaus.commons.compiler.Location;\n+import org.codehaus.commons.compiler.io.Readers;\n+import org.codehaus.janino.Scanner;\n+import org.codehaus.janino.*;\n+import org.codehaus.janino.util.DeepCopier;\n+import org.locationtech.jts.geom.prep.PreparedGeometryFactory;\n+\n+import java.io.*;\n+import java.util.*;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+class ExpressionBuilder {\n+    private static final AtomicLong longVal = new AtomicLong(1);\n+    static final String IN_AREA_PREFIX = \"in_area_\";\n+    private static final Set<String> allowedNames = new HashSet<>(Arrays.asList(\"edge\", \"Math\"));\n+    private static final boolean JANINO_DEBUG = Boolean.getBoolean(Scanner.SYSTEM_PROPERTY_SOURCE_DEBUGGING_ENABLE);\n+\n+    // TODO without a cache we get X% slower routing and Y% slower routingLM8. CH requests and preparation is unaffected\n+    // as cached weighting from preparation is used. This cache ensures that the first Weighting classes, typically the\n+    // ones specified in the profiles, are never removed regardless of how frequent other Weightings are created and accessed.\n+    // We only need to synchronize the get and put methods alone. E.g. we do not care for the race condition where\n+    // two identical classes are requested and one of them is overwritten. We could use CachingJavaSourceClassLoader from\n+    // Janino but 1. we would need to use a single compiler across threads and 2. the statements (for priority and speed)\n+    // are still unnecessarily created.\n+    private static final int CACHE_SIZE = Integer.getInteger(\"graphhopper.custom_weighting.cache_size\", 10);\n+    // TODO perf compare with ConcurrentHashMap, but I guess, if there is a difference at all, it is not big for small maps\n+    private static final Map<String, Class> CACHE = Collections.synchronizedMap(new HashMap<>(CACHE_SIZE));\n+\n+    // Introduce a dynamic cache to remember different Weighting classes, but throw away less frequently used classes.\n+    // Use accessOrder==true to remove oldest accessed entry, not oldest inserted.\n+    private static final int DYN_CACHE_SIZE = Integer.getInteger(\"graphhopper.custom_weighting.dynamic_cache_size\", 1000);\n+    private static final Map<String, Class> DYN_CACHE = Collections.synchronizedMap(\n+            new LinkedHashMap<String, Class>(DYN_CACHE_SIZE, 0.75f, true) {\n+                protected boolean removeEldestEntry(Map.Entry eldest) {\n+                    return size() > DYN_CACHE_SIZE;\n+                }\n+            });\n+\n+    /**\n+     * This method compiles a new subclass of CustomWeightingHelper composed from the provided CustomModel caches this\n+     * and returns an instance.\n+     */\n+    static CustomWeightingHelper create(CustomModel customModel, EncodedValueLookup lookup,\n+                                        double globalMaxSpeed, double maxSpeedFallback, DecimalEncodedValue avgSpeedEnc) {\n+        Java.CompilationUnit cu;\n+        try {\n+            String key = customModel.toString() + \",global:\" + globalMaxSpeed + \",fallback:\" + maxSpeedFallback;\n+            if (key.length() > 400_000) throw new IllegalArgumentException(\"Custom Model too big: \" + key.length());\n+\n+            Class clazz = CACHE.get(key);\n+            if (DYN_CACHE_SIZE > 0 && clazz == null)\n+                clazz = DYN_CACHE.get(key);\n+            if (clazz == null) {\n+                HashSet<String> priorityVariables = new LinkedHashSet<>();\n+                List<Java.BlockStatement> priorityStatements = createGetPriorityStatements(priorityVariables, customModel, lookup);\n+                HashSet<String> speedVariables = new LinkedHashSet<>();\n+                List<Java.BlockStatement> speedStatements = createGetSpeedStatements(speedVariables, customModel, lookup, globalMaxSpeed, maxSpeedFallback);\n+                // Create different class name, which is required only for debugging.\n+                // TODO does it improve performance too? I.e. it could be that the JIT is confused if different classes\n+                //  have the same name and it mixes performance stats. See https://github.com/janino-compiler/janino/issues/137\n+                long counter = longVal.incrementAndGet();\n+                String classTemplate = createClassTemplate(counter, priorityVariables, speedVariables, lookup, customModel);\n+                cu = (Java.CompilationUnit) new Parser(new org.codehaus.janino.Scanner(\"source\", new StringReader(classTemplate))).\n+                        parseAbstractCompilationUnit();\n+                cu = injectStatements(priorityStatements, speedStatements, cu);\n+                SimpleCompiler sc = createCompiler(counter, cu);\n+                clazz = sc.getClassLoader().loadClass(\"com.graphhopper.Test\" + counter);\n+                if (CACHE.size() < CACHE_SIZE)\n+                    CACHE.put(key, clazz);\n+                else if (DYN_CACHE_SIZE > 0)\n+                    DYN_CACHE.put(key, clazz);\n+            }\n+\n+            // The class does not need to be thread-safe as we create an instance per request\n+            CustomWeightingHelper prio = (CustomWeightingHelper) clazz.getDeclaredConstructor().newInstance();\n+            prio.init(lookup, avgSpeedEnc, customModel.getAreas());\n+            return prio;\n+        } catch (Exception ex) {\n+            String location = \"\";\n+            if (ex instanceof CompileException)\n+                location = \" in \" + ((CompileException) ex).getLocation().getFileName();\n+            throw new IllegalArgumentException(\"Cannot compile expression \" + location + \", \" + ex.getMessage(), ex);\n+        }\n+    }\n+\n+    /**\n+     * Parse the expressions from CustomModel relevant for the method getSpeed - see createClassTemplate.\n+     *\n+     * @return the created statements (parsed expressions)\n+     */\n+    private static List<Java.BlockStatement> createGetSpeedStatements(Set<String> speedVariables,\n+                                                                      CustomModel customModel, EncodedValueLookup lookup,\n+                                                                      double globalMaxSpeed, double maxSpeedFallback) throws Exception {\n+        List<Java.BlockStatement> speedStatements = new ArrayList<>();\n+        speedStatements.addAll(verifyExpressions(new StringBuilder(), \"speed_factor_user_statements\", speedVariables,\n+                customModel.getSpeedFactor(), lookup,\n+                num -> \"speed *= \" + num + \";\\n\", \"\"));\n+        StringBuilder codeSB = new StringBuilder(\"boolean applied = false;\\n\");\n+        speedStatements.addAll(verifyExpressions(codeSB, \"max_speed_user_statements\",\n+                speedVariables, customModel.getMaxSpeed(), lookup,\n+                num -> \"applied = true; speed = Math.min(speed,\" + num + \");\",\n+                \"if (!applied && speed > \" + maxSpeedFallback + \") return \" + maxSpeedFallback + \";\\n\" +\n+                        \"return Math.min(speed, \" + globalMaxSpeed + \");\\n\"));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTkxMzA0OA=="}, "originalCommit": {"oid": "f4478bb97c3d7585b21c39eadf45d80e57436cb3"}, "originalPosition": 133}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTgwMDY2OQ==", "bodyText": "Oh interesting yes. But maybe we have to be a bit careful, because then the order becomes important again?\n\nAh, indeed. Hmmh, we could argue that this is the responsibility of the user and only document this?\n\nSomething like a set to operator.\n\nYes \ud83d\udc4d\n\nA few other options would be: max, set max, limit or limit at\n\nInteresting & nice :)\n\nIts more verbose and a bit harder to read, but I guess it is more generic so the datatype stays the same for the different operators\n\nYes, it is harder to read. Can you explain the advantage you see - why would this be more generic?", "url": "https://github.com/graphhopper/graphhopper/pull/2209#discussion_r545800669", "createdAt": "2020-12-18T12:29:45Z", "author": {"login": "karussell"}, "path": "core/src/main/java/com/graphhopper/routing/weighting/custom/ExpressionBuilder.java", "diffHunk": "@@ -0,0 +1,379 @@\n+/*\n+ *  Licensed to GraphHopper GmbH under one or more contributor\n+ *  license agreements. See the NOTICE file distributed with this work for\n+ *  additional information regarding copyright ownership.\n+ *\n+ *  GraphHopper GmbH licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except in\n+ *  compliance with the License. You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package com.graphhopper.routing.weighting.custom;\n+\n+import com.graphhopper.json.geo.JsonFeature;\n+import com.graphhopper.routing.ev.DecimalEncodedValue;\n+import com.graphhopper.routing.ev.EncodedValue;\n+import com.graphhopper.routing.ev.EncodedValueLookup;\n+import com.graphhopper.routing.util.CustomModel;\n+import com.graphhopper.routing.util.EncodingManager;\n+import com.graphhopper.util.EdgeIteratorState;\n+import com.graphhopper.util.GHUtility;\n+import com.graphhopper.util.shapes.BBox;\n+import com.graphhopper.util.shapes.Polygon;\n+import org.codehaus.commons.compiler.CompileException;\n+import org.codehaus.commons.compiler.Location;\n+import org.codehaus.commons.compiler.io.Readers;\n+import org.codehaus.janino.Scanner;\n+import org.codehaus.janino.*;\n+import org.codehaus.janino.util.DeepCopier;\n+import org.locationtech.jts.geom.prep.PreparedGeometryFactory;\n+\n+import java.io.*;\n+import java.util.*;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+class ExpressionBuilder {\n+    private static final AtomicLong longVal = new AtomicLong(1);\n+    static final String IN_AREA_PREFIX = \"in_area_\";\n+    private static final Set<String> allowedNames = new HashSet<>(Arrays.asList(\"edge\", \"Math\"));\n+    private static final boolean JANINO_DEBUG = Boolean.getBoolean(Scanner.SYSTEM_PROPERTY_SOURCE_DEBUGGING_ENABLE);\n+\n+    // TODO without a cache we get X% slower routing and Y% slower routingLM8. CH requests and preparation is unaffected\n+    // as cached weighting from preparation is used. This cache ensures that the first Weighting classes, typically the\n+    // ones specified in the profiles, are never removed regardless of how frequent other Weightings are created and accessed.\n+    // We only need to synchronize the get and put methods alone. E.g. we do not care for the race condition where\n+    // two identical classes are requested and one of them is overwritten. We could use CachingJavaSourceClassLoader from\n+    // Janino but 1. we would need to use a single compiler across threads and 2. the statements (for priority and speed)\n+    // are still unnecessarily created.\n+    private static final int CACHE_SIZE = Integer.getInteger(\"graphhopper.custom_weighting.cache_size\", 10);\n+    // TODO perf compare with ConcurrentHashMap, but I guess, if there is a difference at all, it is not big for small maps\n+    private static final Map<String, Class> CACHE = Collections.synchronizedMap(new HashMap<>(CACHE_SIZE));\n+\n+    // Introduce a dynamic cache to remember different Weighting classes, but throw away less frequently used classes.\n+    // Use accessOrder==true to remove oldest accessed entry, not oldest inserted.\n+    private static final int DYN_CACHE_SIZE = Integer.getInteger(\"graphhopper.custom_weighting.dynamic_cache_size\", 1000);\n+    private static final Map<String, Class> DYN_CACHE = Collections.synchronizedMap(\n+            new LinkedHashMap<String, Class>(DYN_CACHE_SIZE, 0.75f, true) {\n+                protected boolean removeEldestEntry(Map.Entry eldest) {\n+                    return size() > DYN_CACHE_SIZE;\n+                }\n+            });\n+\n+    /**\n+     * This method compiles a new subclass of CustomWeightingHelper composed from the provided CustomModel caches this\n+     * and returns an instance.\n+     */\n+    static CustomWeightingHelper create(CustomModel customModel, EncodedValueLookup lookup,\n+                                        double globalMaxSpeed, double maxSpeedFallback, DecimalEncodedValue avgSpeedEnc) {\n+        Java.CompilationUnit cu;\n+        try {\n+            String key = customModel.toString() + \",global:\" + globalMaxSpeed + \",fallback:\" + maxSpeedFallback;\n+            if (key.length() > 400_000) throw new IllegalArgumentException(\"Custom Model too big: \" + key.length());\n+\n+            Class clazz = CACHE.get(key);\n+            if (DYN_CACHE_SIZE > 0 && clazz == null)\n+                clazz = DYN_CACHE.get(key);\n+            if (clazz == null) {\n+                HashSet<String> priorityVariables = new LinkedHashSet<>();\n+                List<Java.BlockStatement> priorityStatements = createGetPriorityStatements(priorityVariables, customModel, lookup);\n+                HashSet<String> speedVariables = new LinkedHashSet<>();\n+                List<Java.BlockStatement> speedStatements = createGetSpeedStatements(speedVariables, customModel, lookup, globalMaxSpeed, maxSpeedFallback);\n+                // Create different class name, which is required only for debugging.\n+                // TODO does it improve performance too? I.e. it could be that the JIT is confused if different classes\n+                //  have the same name and it mixes performance stats. See https://github.com/janino-compiler/janino/issues/137\n+                long counter = longVal.incrementAndGet();\n+                String classTemplate = createClassTemplate(counter, priorityVariables, speedVariables, lookup, customModel);\n+                cu = (Java.CompilationUnit) new Parser(new org.codehaus.janino.Scanner(\"source\", new StringReader(classTemplate))).\n+                        parseAbstractCompilationUnit();\n+                cu = injectStatements(priorityStatements, speedStatements, cu);\n+                SimpleCompiler sc = createCompiler(counter, cu);\n+                clazz = sc.getClassLoader().loadClass(\"com.graphhopper.Test\" + counter);\n+                if (CACHE.size() < CACHE_SIZE)\n+                    CACHE.put(key, clazz);\n+                else if (DYN_CACHE_SIZE > 0)\n+                    DYN_CACHE.put(key, clazz);\n+            }\n+\n+            // The class does not need to be thread-safe as we create an instance per request\n+            CustomWeightingHelper prio = (CustomWeightingHelper) clazz.getDeclaredConstructor().newInstance();\n+            prio.init(lookup, avgSpeedEnc, customModel.getAreas());\n+            return prio;\n+        } catch (Exception ex) {\n+            String location = \"\";\n+            if (ex instanceof CompileException)\n+                location = \" in \" + ((CompileException) ex).getLocation().getFileName();\n+            throw new IllegalArgumentException(\"Cannot compile expression \" + location + \", \" + ex.getMessage(), ex);\n+        }\n+    }\n+\n+    /**\n+     * Parse the expressions from CustomModel relevant for the method getSpeed - see createClassTemplate.\n+     *\n+     * @return the created statements (parsed expressions)\n+     */\n+    private static List<Java.BlockStatement> createGetSpeedStatements(Set<String> speedVariables,\n+                                                                      CustomModel customModel, EncodedValueLookup lookup,\n+                                                                      double globalMaxSpeed, double maxSpeedFallback) throws Exception {\n+        List<Java.BlockStatement> speedStatements = new ArrayList<>();\n+        speedStatements.addAll(verifyExpressions(new StringBuilder(), \"speed_factor_user_statements\", speedVariables,\n+                customModel.getSpeedFactor(), lookup,\n+                num -> \"speed *= \" + num + \";\\n\", \"\"));\n+        StringBuilder codeSB = new StringBuilder(\"boolean applied = false;\\n\");\n+        speedStatements.addAll(verifyExpressions(codeSB, \"max_speed_user_statements\",\n+                speedVariables, customModel.getMaxSpeed(), lookup,\n+                num -> \"applied = true; speed = Math.min(speed,\" + num + \");\",\n+                \"if (!applied && speed > \" + maxSpeedFallback + \") return \" + maxSpeedFallback + \";\\n\" +\n+                        \"return Math.min(speed, \" + globalMaxSpeed + \");\\n\"));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTkxMzA0OA=="}, "originalCommit": {"oid": "f4478bb97c3d7585b21c39eadf45d80e57436cb3"}, "originalPosition": 133}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTgwNDQzNw==", "bodyText": "Ah, indeed. Hmmh, we could argue that this is the responsibility of the user and only document this?\n\nYes its more responsibility for the user, but that is also why I am wondering if combining everything into speed is really an improvement. An alternative could be a speed section with two sub-sections: speed_factor and max_speed?\n\nYes, it is harder to read. Can you explain the advantage you see - why would this be more generic?\n\nNot so many advantages. The datatype behind this could be more generic, but to me readability seems more important here. And to make the datatype fully generic we would also have to put the if key as value of some clause key. This was just a thought, as far as I am concerned we can just keep multiply with: 0.8.", "url": "https://github.com/graphhopper/graphhopper/pull/2209#discussion_r545804437", "createdAt": "2020-12-18T12:37:16Z", "author": {"login": "easbar"}, "path": "core/src/main/java/com/graphhopper/routing/weighting/custom/ExpressionBuilder.java", "diffHunk": "@@ -0,0 +1,379 @@\n+/*\n+ *  Licensed to GraphHopper GmbH under one or more contributor\n+ *  license agreements. See the NOTICE file distributed with this work for\n+ *  additional information regarding copyright ownership.\n+ *\n+ *  GraphHopper GmbH licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except in\n+ *  compliance with the License. You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package com.graphhopper.routing.weighting.custom;\n+\n+import com.graphhopper.json.geo.JsonFeature;\n+import com.graphhopper.routing.ev.DecimalEncodedValue;\n+import com.graphhopper.routing.ev.EncodedValue;\n+import com.graphhopper.routing.ev.EncodedValueLookup;\n+import com.graphhopper.routing.util.CustomModel;\n+import com.graphhopper.routing.util.EncodingManager;\n+import com.graphhopper.util.EdgeIteratorState;\n+import com.graphhopper.util.GHUtility;\n+import com.graphhopper.util.shapes.BBox;\n+import com.graphhopper.util.shapes.Polygon;\n+import org.codehaus.commons.compiler.CompileException;\n+import org.codehaus.commons.compiler.Location;\n+import org.codehaus.commons.compiler.io.Readers;\n+import org.codehaus.janino.Scanner;\n+import org.codehaus.janino.*;\n+import org.codehaus.janino.util.DeepCopier;\n+import org.locationtech.jts.geom.prep.PreparedGeometryFactory;\n+\n+import java.io.*;\n+import java.util.*;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+class ExpressionBuilder {\n+    private static final AtomicLong longVal = new AtomicLong(1);\n+    static final String IN_AREA_PREFIX = \"in_area_\";\n+    private static final Set<String> allowedNames = new HashSet<>(Arrays.asList(\"edge\", \"Math\"));\n+    private static final boolean JANINO_DEBUG = Boolean.getBoolean(Scanner.SYSTEM_PROPERTY_SOURCE_DEBUGGING_ENABLE);\n+\n+    // TODO without a cache we get X% slower routing and Y% slower routingLM8. CH requests and preparation is unaffected\n+    // as cached weighting from preparation is used. This cache ensures that the first Weighting classes, typically the\n+    // ones specified in the profiles, are never removed regardless of how frequent other Weightings are created and accessed.\n+    // We only need to synchronize the get and put methods alone. E.g. we do not care for the race condition where\n+    // two identical classes are requested and one of them is overwritten. We could use CachingJavaSourceClassLoader from\n+    // Janino but 1. we would need to use a single compiler across threads and 2. the statements (for priority and speed)\n+    // are still unnecessarily created.\n+    private static final int CACHE_SIZE = Integer.getInteger(\"graphhopper.custom_weighting.cache_size\", 10);\n+    // TODO perf compare with ConcurrentHashMap, but I guess, if there is a difference at all, it is not big for small maps\n+    private static final Map<String, Class> CACHE = Collections.synchronizedMap(new HashMap<>(CACHE_SIZE));\n+\n+    // Introduce a dynamic cache to remember different Weighting classes, but throw away less frequently used classes.\n+    // Use accessOrder==true to remove oldest accessed entry, not oldest inserted.\n+    private static final int DYN_CACHE_SIZE = Integer.getInteger(\"graphhopper.custom_weighting.dynamic_cache_size\", 1000);\n+    private static final Map<String, Class> DYN_CACHE = Collections.synchronizedMap(\n+            new LinkedHashMap<String, Class>(DYN_CACHE_SIZE, 0.75f, true) {\n+                protected boolean removeEldestEntry(Map.Entry eldest) {\n+                    return size() > DYN_CACHE_SIZE;\n+                }\n+            });\n+\n+    /**\n+     * This method compiles a new subclass of CustomWeightingHelper composed from the provided CustomModel caches this\n+     * and returns an instance.\n+     */\n+    static CustomWeightingHelper create(CustomModel customModel, EncodedValueLookup lookup,\n+                                        double globalMaxSpeed, double maxSpeedFallback, DecimalEncodedValue avgSpeedEnc) {\n+        Java.CompilationUnit cu;\n+        try {\n+            String key = customModel.toString() + \",global:\" + globalMaxSpeed + \",fallback:\" + maxSpeedFallback;\n+            if (key.length() > 400_000) throw new IllegalArgumentException(\"Custom Model too big: \" + key.length());\n+\n+            Class clazz = CACHE.get(key);\n+            if (DYN_CACHE_SIZE > 0 && clazz == null)\n+                clazz = DYN_CACHE.get(key);\n+            if (clazz == null) {\n+                HashSet<String> priorityVariables = new LinkedHashSet<>();\n+                List<Java.BlockStatement> priorityStatements = createGetPriorityStatements(priorityVariables, customModel, lookup);\n+                HashSet<String> speedVariables = new LinkedHashSet<>();\n+                List<Java.BlockStatement> speedStatements = createGetSpeedStatements(speedVariables, customModel, lookup, globalMaxSpeed, maxSpeedFallback);\n+                // Create different class name, which is required only for debugging.\n+                // TODO does it improve performance too? I.e. it could be that the JIT is confused if different classes\n+                //  have the same name and it mixes performance stats. See https://github.com/janino-compiler/janino/issues/137\n+                long counter = longVal.incrementAndGet();\n+                String classTemplate = createClassTemplate(counter, priorityVariables, speedVariables, lookup, customModel);\n+                cu = (Java.CompilationUnit) new Parser(new org.codehaus.janino.Scanner(\"source\", new StringReader(classTemplate))).\n+                        parseAbstractCompilationUnit();\n+                cu = injectStatements(priorityStatements, speedStatements, cu);\n+                SimpleCompiler sc = createCompiler(counter, cu);\n+                clazz = sc.getClassLoader().loadClass(\"com.graphhopper.Test\" + counter);\n+                if (CACHE.size() < CACHE_SIZE)\n+                    CACHE.put(key, clazz);\n+                else if (DYN_CACHE_SIZE > 0)\n+                    DYN_CACHE.put(key, clazz);\n+            }\n+\n+            // The class does not need to be thread-safe as we create an instance per request\n+            CustomWeightingHelper prio = (CustomWeightingHelper) clazz.getDeclaredConstructor().newInstance();\n+            prio.init(lookup, avgSpeedEnc, customModel.getAreas());\n+            return prio;\n+        } catch (Exception ex) {\n+            String location = \"\";\n+            if (ex instanceof CompileException)\n+                location = \" in \" + ((CompileException) ex).getLocation().getFileName();\n+            throw new IllegalArgumentException(\"Cannot compile expression \" + location + \", \" + ex.getMessage(), ex);\n+        }\n+    }\n+\n+    /**\n+     * Parse the expressions from CustomModel relevant for the method getSpeed - see createClassTemplate.\n+     *\n+     * @return the created statements (parsed expressions)\n+     */\n+    private static List<Java.BlockStatement> createGetSpeedStatements(Set<String> speedVariables,\n+                                                                      CustomModel customModel, EncodedValueLookup lookup,\n+                                                                      double globalMaxSpeed, double maxSpeedFallback) throws Exception {\n+        List<Java.BlockStatement> speedStatements = new ArrayList<>();\n+        speedStatements.addAll(verifyExpressions(new StringBuilder(), \"speed_factor_user_statements\", speedVariables,\n+                customModel.getSpeedFactor(), lookup,\n+                num -> \"speed *= \" + num + \";\\n\", \"\"));\n+        StringBuilder codeSB = new StringBuilder(\"boolean applied = false;\\n\");\n+        speedStatements.addAll(verifyExpressions(codeSB, \"max_speed_user_statements\",\n+                speedVariables, customModel.getMaxSpeed(), lookup,\n+                num -> \"applied = true; speed = Math.min(speed,\" + num + \");\",\n+                \"if (!applied && speed > \" + maxSpeedFallback + \") return \" + maxSpeedFallback + \";\\n\" +\n+                        \"return Math.min(speed, \" + globalMaxSpeed + \");\\n\"));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTkxMzA0OA=="}, "originalCommit": {"oid": "f4478bb97c3d7585b21c39eadf45d80e57436cb3"}, "originalPosition": 133}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTgyODYzMw==", "bodyText": "Yes its more responsibility for the user\n\nHmmh maybe not only more responsibility but maybe could it cover more use cases? Also with separate sections the user would need to study the docs on how we do this and with his own code it would be obvious. But yeah ... not sure.\n\nAn alternative could be a speed section with two sub-sections: speed_factor and max_speed?\n\nI would keep it as it is or merge it into just one speed-section :)", "url": "https://github.com/graphhopper/graphhopper/pull/2209#discussion_r545828633", "createdAt": "2020-12-18T13:25:10Z", "author": {"login": "karussell"}, "path": "core/src/main/java/com/graphhopper/routing/weighting/custom/ExpressionBuilder.java", "diffHunk": "@@ -0,0 +1,379 @@\n+/*\n+ *  Licensed to GraphHopper GmbH under one or more contributor\n+ *  license agreements. See the NOTICE file distributed with this work for\n+ *  additional information regarding copyright ownership.\n+ *\n+ *  GraphHopper GmbH licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except in\n+ *  compliance with the License. You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package com.graphhopper.routing.weighting.custom;\n+\n+import com.graphhopper.json.geo.JsonFeature;\n+import com.graphhopper.routing.ev.DecimalEncodedValue;\n+import com.graphhopper.routing.ev.EncodedValue;\n+import com.graphhopper.routing.ev.EncodedValueLookup;\n+import com.graphhopper.routing.util.CustomModel;\n+import com.graphhopper.routing.util.EncodingManager;\n+import com.graphhopper.util.EdgeIteratorState;\n+import com.graphhopper.util.GHUtility;\n+import com.graphhopper.util.shapes.BBox;\n+import com.graphhopper.util.shapes.Polygon;\n+import org.codehaus.commons.compiler.CompileException;\n+import org.codehaus.commons.compiler.Location;\n+import org.codehaus.commons.compiler.io.Readers;\n+import org.codehaus.janino.Scanner;\n+import org.codehaus.janino.*;\n+import org.codehaus.janino.util.DeepCopier;\n+import org.locationtech.jts.geom.prep.PreparedGeometryFactory;\n+\n+import java.io.*;\n+import java.util.*;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+class ExpressionBuilder {\n+    private static final AtomicLong longVal = new AtomicLong(1);\n+    static final String IN_AREA_PREFIX = \"in_area_\";\n+    private static final Set<String> allowedNames = new HashSet<>(Arrays.asList(\"edge\", \"Math\"));\n+    private static final boolean JANINO_DEBUG = Boolean.getBoolean(Scanner.SYSTEM_PROPERTY_SOURCE_DEBUGGING_ENABLE);\n+\n+    // TODO without a cache we get X% slower routing and Y% slower routingLM8. CH requests and preparation is unaffected\n+    // as cached weighting from preparation is used. This cache ensures that the first Weighting classes, typically the\n+    // ones specified in the profiles, are never removed regardless of how frequent other Weightings are created and accessed.\n+    // We only need to synchronize the get and put methods alone. E.g. we do not care for the race condition where\n+    // two identical classes are requested and one of them is overwritten. We could use CachingJavaSourceClassLoader from\n+    // Janino but 1. we would need to use a single compiler across threads and 2. the statements (for priority and speed)\n+    // are still unnecessarily created.\n+    private static final int CACHE_SIZE = Integer.getInteger(\"graphhopper.custom_weighting.cache_size\", 10);\n+    // TODO perf compare with ConcurrentHashMap, but I guess, if there is a difference at all, it is not big for small maps\n+    private static final Map<String, Class> CACHE = Collections.synchronizedMap(new HashMap<>(CACHE_SIZE));\n+\n+    // Introduce a dynamic cache to remember different Weighting classes, but throw away less frequently used classes.\n+    // Use accessOrder==true to remove oldest accessed entry, not oldest inserted.\n+    private static final int DYN_CACHE_SIZE = Integer.getInteger(\"graphhopper.custom_weighting.dynamic_cache_size\", 1000);\n+    private static final Map<String, Class> DYN_CACHE = Collections.synchronizedMap(\n+            new LinkedHashMap<String, Class>(DYN_CACHE_SIZE, 0.75f, true) {\n+                protected boolean removeEldestEntry(Map.Entry eldest) {\n+                    return size() > DYN_CACHE_SIZE;\n+                }\n+            });\n+\n+    /**\n+     * This method compiles a new subclass of CustomWeightingHelper composed from the provided CustomModel caches this\n+     * and returns an instance.\n+     */\n+    static CustomWeightingHelper create(CustomModel customModel, EncodedValueLookup lookup,\n+                                        double globalMaxSpeed, double maxSpeedFallback, DecimalEncodedValue avgSpeedEnc) {\n+        Java.CompilationUnit cu;\n+        try {\n+            String key = customModel.toString() + \",global:\" + globalMaxSpeed + \",fallback:\" + maxSpeedFallback;\n+            if (key.length() > 400_000) throw new IllegalArgumentException(\"Custom Model too big: \" + key.length());\n+\n+            Class clazz = CACHE.get(key);\n+            if (DYN_CACHE_SIZE > 0 && clazz == null)\n+                clazz = DYN_CACHE.get(key);\n+            if (clazz == null) {\n+                HashSet<String> priorityVariables = new LinkedHashSet<>();\n+                List<Java.BlockStatement> priorityStatements = createGetPriorityStatements(priorityVariables, customModel, lookup);\n+                HashSet<String> speedVariables = new LinkedHashSet<>();\n+                List<Java.BlockStatement> speedStatements = createGetSpeedStatements(speedVariables, customModel, lookup, globalMaxSpeed, maxSpeedFallback);\n+                // Create different class name, which is required only for debugging.\n+                // TODO does it improve performance too? I.e. it could be that the JIT is confused if different classes\n+                //  have the same name and it mixes performance stats. See https://github.com/janino-compiler/janino/issues/137\n+                long counter = longVal.incrementAndGet();\n+                String classTemplate = createClassTemplate(counter, priorityVariables, speedVariables, lookup, customModel);\n+                cu = (Java.CompilationUnit) new Parser(new org.codehaus.janino.Scanner(\"source\", new StringReader(classTemplate))).\n+                        parseAbstractCompilationUnit();\n+                cu = injectStatements(priorityStatements, speedStatements, cu);\n+                SimpleCompiler sc = createCompiler(counter, cu);\n+                clazz = sc.getClassLoader().loadClass(\"com.graphhopper.Test\" + counter);\n+                if (CACHE.size() < CACHE_SIZE)\n+                    CACHE.put(key, clazz);\n+                else if (DYN_CACHE_SIZE > 0)\n+                    DYN_CACHE.put(key, clazz);\n+            }\n+\n+            // The class does not need to be thread-safe as we create an instance per request\n+            CustomWeightingHelper prio = (CustomWeightingHelper) clazz.getDeclaredConstructor().newInstance();\n+            prio.init(lookup, avgSpeedEnc, customModel.getAreas());\n+            return prio;\n+        } catch (Exception ex) {\n+            String location = \"\";\n+            if (ex instanceof CompileException)\n+                location = \" in \" + ((CompileException) ex).getLocation().getFileName();\n+            throw new IllegalArgumentException(\"Cannot compile expression \" + location + \", \" + ex.getMessage(), ex);\n+        }\n+    }\n+\n+    /**\n+     * Parse the expressions from CustomModel relevant for the method getSpeed - see createClassTemplate.\n+     *\n+     * @return the created statements (parsed expressions)\n+     */\n+    private static List<Java.BlockStatement> createGetSpeedStatements(Set<String> speedVariables,\n+                                                                      CustomModel customModel, EncodedValueLookup lookup,\n+                                                                      double globalMaxSpeed, double maxSpeedFallback) throws Exception {\n+        List<Java.BlockStatement> speedStatements = new ArrayList<>();\n+        speedStatements.addAll(verifyExpressions(new StringBuilder(), \"speed_factor_user_statements\", speedVariables,\n+                customModel.getSpeedFactor(), lookup,\n+                num -> \"speed *= \" + num + \";\\n\", \"\"));\n+        StringBuilder codeSB = new StringBuilder(\"boolean applied = false;\\n\");\n+        speedStatements.addAll(verifyExpressions(codeSB, \"max_speed_user_statements\",\n+                speedVariables, customModel.getMaxSpeed(), lookup,\n+                num -> \"applied = true; speed = Math.min(speed,\" + num + \");\",\n+                \"if (!applied && speed > \" + maxSpeedFallback + \") return \" + maxSpeedFallback + \";\\n\" +\n+                        \"return Math.min(speed, \" + globalMaxSpeed + \");\\n\"));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTkxMzA0OA=="}, "originalCommit": {"oid": "f4478bb97c3d7585b21c39eadf45d80e57436cb3"}, "originalPosition": 133}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTg1MjE2NA==", "bodyText": "Let's merge it into one speed section. As long as the logic is as simple as 'apply the operators with matching conditions from top to bottom' this should be easy enough. For example if users want the previous behavior where the max_speed limitations are applied after the speed factors were calculated they can simply move all clauses with reduce_to to the bottom of the speed section.\nBtw we could now also use other clauses than reduce_to to find the max speed fallback, but since this is just an optimization we can probably postpone this.", "url": "https://github.com/graphhopper/graphhopper/pull/2209#discussion_r545852164", "createdAt": "2020-12-18T14:07:15Z", "author": {"login": "easbar"}, "path": "core/src/main/java/com/graphhopper/routing/weighting/custom/ExpressionBuilder.java", "diffHunk": "@@ -0,0 +1,379 @@\n+/*\n+ *  Licensed to GraphHopper GmbH under one or more contributor\n+ *  license agreements. See the NOTICE file distributed with this work for\n+ *  additional information regarding copyright ownership.\n+ *\n+ *  GraphHopper GmbH licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except in\n+ *  compliance with the License. You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package com.graphhopper.routing.weighting.custom;\n+\n+import com.graphhopper.json.geo.JsonFeature;\n+import com.graphhopper.routing.ev.DecimalEncodedValue;\n+import com.graphhopper.routing.ev.EncodedValue;\n+import com.graphhopper.routing.ev.EncodedValueLookup;\n+import com.graphhopper.routing.util.CustomModel;\n+import com.graphhopper.routing.util.EncodingManager;\n+import com.graphhopper.util.EdgeIteratorState;\n+import com.graphhopper.util.GHUtility;\n+import com.graphhopper.util.shapes.BBox;\n+import com.graphhopper.util.shapes.Polygon;\n+import org.codehaus.commons.compiler.CompileException;\n+import org.codehaus.commons.compiler.Location;\n+import org.codehaus.commons.compiler.io.Readers;\n+import org.codehaus.janino.Scanner;\n+import org.codehaus.janino.*;\n+import org.codehaus.janino.util.DeepCopier;\n+import org.locationtech.jts.geom.prep.PreparedGeometryFactory;\n+\n+import java.io.*;\n+import java.util.*;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+class ExpressionBuilder {\n+    private static final AtomicLong longVal = new AtomicLong(1);\n+    static final String IN_AREA_PREFIX = \"in_area_\";\n+    private static final Set<String> allowedNames = new HashSet<>(Arrays.asList(\"edge\", \"Math\"));\n+    private static final boolean JANINO_DEBUG = Boolean.getBoolean(Scanner.SYSTEM_PROPERTY_SOURCE_DEBUGGING_ENABLE);\n+\n+    // TODO without a cache we get X% slower routing and Y% slower routingLM8. CH requests and preparation is unaffected\n+    // as cached weighting from preparation is used. This cache ensures that the first Weighting classes, typically the\n+    // ones specified in the profiles, are never removed regardless of how frequent other Weightings are created and accessed.\n+    // We only need to synchronize the get and put methods alone. E.g. we do not care for the race condition where\n+    // two identical classes are requested and one of them is overwritten. We could use CachingJavaSourceClassLoader from\n+    // Janino but 1. we would need to use a single compiler across threads and 2. the statements (for priority and speed)\n+    // are still unnecessarily created.\n+    private static final int CACHE_SIZE = Integer.getInteger(\"graphhopper.custom_weighting.cache_size\", 10);\n+    // TODO perf compare with ConcurrentHashMap, but I guess, if there is a difference at all, it is not big for small maps\n+    private static final Map<String, Class> CACHE = Collections.synchronizedMap(new HashMap<>(CACHE_SIZE));\n+\n+    // Introduce a dynamic cache to remember different Weighting classes, but throw away less frequently used classes.\n+    // Use accessOrder==true to remove oldest accessed entry, not oldest inserted.\n+    private static final int DYN_CACHE_SIZE = Integer.getInteger(\"graphhopper.custom_weighting.dynamic_cache_size\", 1000);\n+    private static final Map<String, Class> DYN_CACHE = Collections.synchronizedMap(\n+            new LinkedHashMap<String, Class>(DYN_CACHE_SIZE, 0.75f, true) {\n+                protected boolean removeEldestEntry(Map.Entry eldest) {\n+                    return size() > DYN_CACHE_SIZE;\n+                }\n+            });\n+\n+    /**\n+     * This method compiles a new subclass of CustomWeightingHelper composed from the provided CustomModel caches this\n+     * and returns an instance.\n+     */\n+    static CustomWeightingHelper create(CustomModel customModel, EncodedValueLookup lookup,\n+                                        double globalMaxSpeed, double maxSpeedFallback, DecimalEncodedValue avgSpeedEnc) {\n+        Java.CompilationUnit cu;\n+        try {\n+            String key = customModel.toString() + \",global:\" + globalMaxSpeed + \",fallback:\" + maxSpeedFallback;\n+            if (key.length() > 400_000) throw new IllegalArgumentException(\"Custom Model too big: \" + key.length());\n+\n+            Class clazz = CACHE.get(key);\n+            if (DYN_CACHE_SIZE > 0 && clazz == null)\n+                clazz = DYN_CACHE.get(key);\n+            if (clazz == null) {\n+                HashSet<String> priorityVariables = new LinkedHashSet<>();\n+                List<Java.BlockStatement> priorityStatements = createGetPriorityStatements(priorityVariables, customModel, lookup);\n+                HashSet<String> speedVariables = new LinkedHashSet<>();\n+                List<Java.BlockStatement> speedStatements = createGetSpeedStatements(speedVariables, customModel, lookup, globalMaxSpeed, maxSpeedFallback);\n+                // Create different class name, which is required only for debugging.\n+                // TODO does it improve performance too? I.e. it could be that the JIT is confused if different classes\n+                //  have the same name and it mixes performance stats. See https://github.com/janino-compiler/janino/issues/137\n+                long counter = longVal.incrementAndGet();\n+                String classTemplate = createClassTemplate(counter, priorityVariables, speedVariables, lookup, customModel);\n+                cu = (Java.CompilationUnit) new Parser(new org.codehaus.janino.Scanner(\"source\", new StringReader(classTemplate))).\n+                        parseAbstractCompilationUnit();\n+                cu = injectStatements(priorityStatements, speedStatements, cu);\n+                SimpleCompiler sc = createCompiler(counter, cu);\n+                clazz = sc.getClassLoader().loadClass(\"com.graphhopper.Test\" + counter);\n+                if (CACHE.size() < CACHE_SIZE)\n+                    CACHE.put(key, clazz);\n+                else if (DYN_CACHE_SIZE > 0)\n+                    DYN_CACHE.put(key, clazz);\n+            }\n+\n+            // The class does not need to be thread-safe as we create an instance per request\n+            CustomWeightingHelper prio = (CustomWeightingHelper) clazz.getDeclaredConstructor().newInstance();\n+            prio.init(lookup, avgSpeedEnc, customModel.getAreas());\n+            return prio;\n+        } catch (Exception ex) {\n+            String location = \"\";\n+            if (ex instanceof CompileException)\n+                location = \" in \" + ((CompileException) ex).getLocation().getFileName();\n+            throw new IllegalArgumentException(\"Cannot compile expression \" + location + \", \" + ex.getMessage(), ex);\n+        }\n+    }\n+\n+    /**\n+     * Parse the expressions from CustomModel relevant for the method getSpeed - see createClassTemplate.\n+     *\n+     * @return the created statements (parsed expressions)\n+     */\n+    private static List<Java.BlockStatement> createGetSpeedStatements(Set<String> speedVariables,\n+                                                                      CustomModel customModel, EncodedValueLookup lookup,\n+                                                                      double globalMaxSpeed, double maxSpeedFallback) throws Exception {\n+        List<Java.BlockStatement> speedStatements = new ArrayList<>();\n+        speedStatements.addAll(verifyExpressions(new StringBuilder(), \"speed_factor_user_statements\", speedVariables,\n+                customModel.getSpeedFactor(), lookup,\n+                num -> \"speed *= \" + num + \";\\n\", \"\"));\n+        StringBuilder codeSB = new StringBuilder(\"boolean applied = false;\\n\");\n+        speedStatements.addAll(verifyExpressions(codeSB, \"max_speed_user_statements\",\n+                speedVariables, customModel.getMaxSpeed(), lookup,\n+                num -> \"applied = true; speed = Math.min(speed,\" + num + \");\",\n+                \"if (!applied && speed > \" + maxSpeedFallback + \") return \" + maxSpeedFallback + \";\\n\" +\n+                        \"return Math.min(speed, \" + globalMaxSpeed + \");\\n\"));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTkxMzA0OA=="}, "originalCommit": {"oid": "f4478bb97c3d7585b21c39eadf45d80e57436cb3"}, "originalPosition": 133}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTg1NTQ4Ng==", "bodyText": "One problem could be that merging the speed sections makes merging custom models harder? Same with adding more operators maybe?", "url": "https://github.com/graphhopper/graphhopper/pull/2209#discussion_r545855486", "createdAt": "2020-12-18T14:12:59Z", "author": {"login": "easbar"}, "path": "core/src/main/java/com/graphhopper/routing/weighting/custom/ExpressionBuilder.java", "diffHunk": "@@ -0,0 +1,379 @@\n+/*\n+ *  Licensed to GraphHopper GmbH under one or more contributor\n+ *  license agreements. See the NOTICE file distributed with this work for\n+ *  additional information regarding copyright ownership.\n+ *\n+ *  GraphHopper GmbH licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except in\n+ *  compliance with the License. You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package com.graphhopper.routing.weighting.custom;\n+\n+import com.graphhopper.json.geo.JsonFeature;\n+import com.graphhopper.routing.ev.DecimalEncodedValue;\n+import com.graphhopper.routing.ev.EncodedValue;\n+import com.graphhopper.routing.ev.EncodedValueLookup;\n+import com.graphhopper.routing.util.CustomModel;\n+import com.graphhopper.routing.util.EncodingManager;\n+import com.graphhopper.util.EdgeIteratorState;\n+import com.graphhopper.util.GHUtility;\n+import com.graphhopper.util.shapes.BBox;\n+import com.graphhopper.util.shapes.Polygon;\n+import org.codehaus.commons.compiler.CompileException;\n+import org.codehaus.commons.compiler.Location;\n+import org.codehaus.commons.compiler.io.Readers;\n+import org.codehaus.janino.Scanner;\n+import org.codehaus.janino.*;\n+import org.codehaus.janino.util.DeepCopier;\n+import org.locationtech.jts.geom.prep.PreparedGeometryFactory;\n+\n+import java.io.*;\n+import java.util.*;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+class ExpressionBuilder {\n+    private static final AtomicLong longVal = new AtomicLong(1);\n+    static final String IN_AREA_PREFIX = \"in_area_\";\n+    private static final Set<String> allowedNames = new HashSet<>(Arrays.asList(\"edge\", \"Math\"));\n+    private static final boolean JANINO_DEBUG = Boolean.getBoolean(Scanner.SYSTEM_PROPERTY_SOURCE_DEBUGGING_ENABLE);\n+\n+    // TODO without a cache we get X% slower routing and Y% slower routingLM8. CH requests and preparation is unaffected\n+    // as cached weighting from preparation is used. This cache ensures that the first Weighting classes, typically the\n+    // ones specified in the profiles, are never removed regardless of how frequent other Weightings are created and accessed.\n+    // We only need to synchronize the get and put methods alone. E.g. we do not care for the race condition where\n+    // two identical classes are requested and one of them is overwritten. We could use CachingJavaSourceClassLoader from\n+    // Janino but 1. we would need to use a single compiler across threads and 2. the statements (for priority and speed)\n+    // are still unnecessarily created.\n+    private static final int CACHE_SIZE = Integer.getInteger(\"graphhopper.custom_weighting.cache_size\", 10);\n+    // TODO perf compare with ConcurrentHashMap, but I guess, if there is a difference at all, it is not big for small maps\n+    private static final Map<String, Class> CACHE = Collections.synchronizedMap(new HashMap<>(CACHE_SIZE));\n+\n+    // Introduce a dynamic cache to remember different Weighting classes, but throw away less frequently used classes.\n+    // Use accessOrder==true to remove oldest accessed entry, not oldest inserted.\n+    private static final int DYN_CACHE_SIZE = Integer.getInteger(\"graphhopper.custom_weighting.dynamic_cache_size\", 1000);\n+    private static final Map<String, Class> DYN_CACHE = Collections.synchronizedMap(\n+            new LinkedHashMap<String, Class>(DYN_CACHE_SIZE, 0.75f, true) {\n+                protected boolean removeEldestEntry(Map.Entry eldest) {\n+                    return size() > DYN_CACHE_SIZE;\n+                }\n+            });\n+\n+    /**\n+     * This method compiles a new subclass of CustomWeightingHelper composed from the provided CustomModel caches this\n+     * and returns an instance.\n+     */\n+    static CustomWeightingHelper create(CustomModel customModel, EncodedValueLookup lookup,\n+                                        double globalMaxSpeed, double maxSpeedFallback, DecimalEncodedValue avgSpeedEnc) {\n+        Java.CompilationUnit cu;\n+        try {\n+            String key = customModel.toString() + \",global:\" + globalMaxSpeed + \",fallback:\" + maxSpeedFallback;\n+            if (key.length() > 400_000) throw new IllegalArgumentException(\"Custom Model too big: \" + key.length());\n+\n+            Class clazz = CACHE.get(key);\n+            if (DYN_CACHE_SIZE > 0 && clazz == null)\n+                clazz = DYN_CACHE.get(key);\n+            if (clazz == null) {\n+                HashSet<String> priorityVariables = new LinkedHashSet<>();\n+                List<Java.BlockStatement> priorityStatements = createGetPriorityStatements(priorityVariables, customModel, lookup);\n+                HashSet<String> speedVariables = new LinkedHashSet<>();\n+                List<Java.BlockStatement> speedStatements = createGetSpeedStatements(speedVariables, customModel, lookup, globalMaxSpeed, maxSpeedFallback);\n+                // Create different class name, which is required only for debugging.\n+                // TODO does it improve performance too? I.e. it could be that the JIT is confused if different classes\n+                //  have the same name and it mixes performance stats. See https://github.com/janino-compiler/janino/issues/137\n+                long counter = longVal.incrementAndGet();\n+                String classTemplate = createClassTemplate(counter, priorityVariables, speedVariables, lookup, customModel);\n+                cu = (Java.CompilationUnit) new Parser(new org.codehaus.janino.Scanner(\"source\", new StringReader(classTemplate))).\n+                        parseAbstractCompilationUnit();\n+                cu = injectStatements(priorityStatements, speedStatements, cu);\n+                SimpleCompiler sc = createCompiler(counter, cu);\n+                clazz = sc.getClassLoader().loadClass(\"com.graphhopper.Test\" + counter);\n+                if (CACHE.size() < CACHE_SIZE)\n+                    CACHE.put(key, clazz);\n+                else if (DYN_CACHE_SIZE > 0)\n+                    DYN_CACHE.put(key, clazz);\n+            }\n+\n+            // The class does not need to be thread-safe as we create an instance per request\n+            CustomWeightingHelper prio = (CustomWeightingHelper) clazz.getDeclaredConstructor().newInstance();\n+            prio.init(lookup, avgSpeedEnc, customModel.getAreas());\n+            return prio;\n+        } catch (Exception ex) {\n+            String location = \"\";\n+            if (ex instanceof CompileException)\n+                location = \" in \" + ((CompileException) ex).getLocation().getFileName();\n+            throw new IllegalArgumentException(\"Cannot compile expression \" + location + \", \" + ex.getMessage(), ex);\n+        }\n+    }\n+\n+    /**\n+     * Parse the expressions from CustomModel relevant for the method getSpeed - see createClassTemplate.\n+     *\n+     * @return the created statements (parsed expressions)\n+     */\n+    private static List<Java.BlockStatement> createGetSpeedStatements(Set<String> speedVariables,\n+                                                                      CustomModel customModel, EncodedValueLookup lookup,\n+                                                                      double globalMaxSpeed, double maxSpeedFallback) throws Exception {\n+        List<Java.BlockStatement> speedStatements = new ArrayList<>();\n+        speedStatements.addAll(verifyExpressions(new StringBuilder(), \"speed_factor_user_statements\", speedVariables,\n+                customModel.getSpeedFactor(), lookup,\n+                num -> \"speed *= \" + num + \";\\n\", \"\"));\n+        StringBuilder codeSB = new StringBuilder(\"boolean applied = false;\\n\");\n+        speedStatements.addAll(verifyExpressions(codeSB, \"max_speed_user_statements\",\n+                speedVariables, customModel.getMaxSpeed(), lookup,\n+                num -> \"applied = true; speed = Math.min(speed,\" + num + \");\",\n+                \"if (!applied && speed > \" + maxSpeedFallback + \") return \" + maxSpeedFallback + \";\\n\" +\n+                        \"return Math.min(speed, \" + globalMaxSpeed + \");\\n\"));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTkxMzA0OA=="}, "originalCommit": {"oid": "f4478bb97c3d7585b21c39eadf45d80e57436cb3"}, "originalPosition": 133}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTg4Nzk4OQ==", "bodyText": "Let's merge it into one speed section\n\nOk :)\n\nBtw we could now also use other clauses than reduce_to to find the max speed fallback, but since this is just an optimization we can probably postpone this.\n\nYes and yes, let's apply the max speed fallback to reduce to.\nAnd shall we rename this to limit to?\n\nOne problem could be that merging the speed sections makes merging custom models harder? Same with adding more operators maybe?\n\nMerging custom models is currently very simplistic: we just append the expressions. This is easy to understand and should also never lead to a bigger speed or priority as long as we check the values for every operator (I think?).\nThe only downside is that it might be a lit bit inefficient e.g. if the server-side model defines\nif road_class == PRIMARY multiply with 0.5\nand the query comes with\nif road_class == PRIMARY multiply with 0.8\nwe could create an optimized model with\nif road_class == PRIMARY multiply with 0.4\ninstead of two separate expressions.", "url": "https://github.com/graphhopper/graphhopper/pull/2209#discussion_r545887989", "createdAt": "2020-12-18T14:57:20Z", "author": {"login": "karussell"}, "path": "core/src/main/java/com/graphhopper/routing/weighting/custom/ExpressionBuilder.java", "diffHunk": "@@ -0,0 +1,379 @@\n+/*\n+ *  Licensed to GraphHopper GmbH under one or more contributor\n+ *  license agreements. See the NOTICE file distributed with this work for\n+ *  additional information regarding copyright ownership.\n+ *\n+ *  GraphHopper GmbH licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except in\n+ *  compliance with the License. You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package com.graphhopper.routing.weighting.custom;\n+\n+import com.graphhopper.json.geo.JsonFeature;\n+import com.graphhopper.routing.ev.DecimalEncodedValue;\n+import com.graphhopper.routing.ev.EncodedValue;\n+import com.graphhopper.routing.ev.EncodedValueLookup;\n+import com.graphhopper.routing.util.CustomModel;\n+import com.graphhopper.routing.util.EncodingManager;\n+import com.graphhopper.util.EdgeIteratorState;\n+import com.graphhopper.util.GHUtility;\n+import com.graphhopper.util.shapes.BBox;\n+import com.graphhopper.util.shapes.Polygon;\n+import org.codehaus.commons.compiler.CompileException;\n+import org.codehaus.commons.compiler.Location;\n+import org.codehaus.commons.compiler.io.Readers;\n+import org.codehaus.janino.Scanner;\n+import org.codehaus.janino.*;\n+import org.codehaus.janino.util.DeepCopier;\n+import org.locationtech.jts.geom.prep.PreparedGeometryFactory;\n+\n+import java.io.*;\n+import java.util.*;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+class ExpressionBuilder {\n+    private static final AtomicLong longVal = new AtomicLong(1);\n+    static final String IN_AREA_PREFIX = \"in_area_\";\n+    private static final Set<String> allowedNames = new HashSet<>(Arrays.asList(\"edge\", \"Math\"));\n+    private static final boolean JANINO_DEBUG = Boolean.getBoolean(Scanner.SYSTEM_PROPERTY_SOURCE_DEBUGGING_ENABLE);\n+\n+    // TODO without a cache we get X% slower routing and Y% slower routingLM8. CH requests and preparation is unaffected\n+    // as cached weighting from preparation is used. This cache ensures that the first Weighting classes, typically the\n+    // ones specified in the profiles, are never removed regardless of how frequent other Weightings are created and accessed.\n+    // We only need to synchronize the get and put methods alone. E.g. we do not care for the race condition where\n+    // two identical classes are requested and one of them is overwritten. We could use CachingJavaSourceClassLoader from\n+    // Janino but 1. we would need to use a single compiler across threads and 2. the statements (for priority and speed)\n+    // are still unnecessarily created.\n+    private static final int CACHE_SIZE = Integer.getInteger(\"graphhopper.custom_weighting.cache_size\", 10);\n+    // TODO perf compare with ConcurrentHashMap, but I guess, if there is a difference at all, it is not big for small maps\n+    private static final Map<String, Class> CACHE = Collections.synchronizedMap(new HashMap<>(CACHE_SIZE));\n+\n+    // Introduce a dynamic cache to remember different Weighting classes, but throw away less frequently used classes.\n+    // Use accessOrder==true to remove oldest accessed entry, not oldest inserted.\n+    private static final int DYN_CACHE_SIZE = Integer.getInteger(\"graphhopper.custom_weighting.dynamic_cache_size\", 1000);\n+    private static final Map<String, Class> DYN_CACHE = Collections.synchronizedMap(\n+            new LinkedHashMap<String, Class>(DYN_CACHE_SIZE, 0.75f, true) {\n+                protected boolean removeEldestEntry(Map.Entry eldest) {\n+                    return size() > DYN_CACHE_SIZE;\n+                }\n+            });\n+\n+    /**\n+     * This method compiles a new subclass of CustomWeightingHelper composed from the provided CustomModel caches this\n+     * and returns an instance.\n+     */\n+    static CustomWeightingHelper create(CustomModel customModel, EncodedValueLookup lookup,\n+                                        double globalMaxSpeed, double maxSpeedFallback, DecimalEncodedValue avgSpeedEnc) {\n+        Java.CompilationUnit cu;\n+        try {\n+            String key = customModel.toString() + \",global:\" + globalMaxSpeed + \",fallback:\" + maxSpeedFallback;\n+            if (key.length() > 400_000) throw new IllegalArgumentException(\"Custom Model too big: \" + key.length());\n+\n+            Class clazz = CACHE.get(key);\n+            if (DYN_CACHE_SIZE > 0 && clazz == null)\n+                clazz = DYN_CACHE.get(key);\n+            if (clazz == null) {\n+                HashSet<String> priorityVariables = new LinkedHashSet<>();\n+                List<Java.BlockStatement> priorityStatements = createGetPriorityStatements(priorityVariables, customModel, lookup);\n+                HashSet<String> speedVariables = new LinkedHashSet<>();\n+                List<Java.BlockStatement> speedStatements = createGetSpeedStatements(speedVariables, customModel, lookup, globalMaxSpeed, maxSpeedFallback);\n+                // Create different class name, which is required only for debugging.\n+                // TODO does it improve performance too? I.e. it could be that the JIT is confused if different classes\n+                //  have the same name and it mixes performance stats. See https://github.com/janino-compiler/janino/issues/137\n+                long counter = longVal.incrementAndGet();\n+                String classTemplate = createClassTemplate(counter, priorityVariables, speedVariables, lookup, customModel);\n+                cu = (Java.CompilationUnit) new Parser(new org.codehaus.janino.Scanner(\"source\", new StringReader(classTemplate))).\n+                        parseAbstractCompilationUnit();\n+                cu = injectStatements(priorityStatements, speedStatements, cu);\n+                SimpleCompiler sc = createCompiler(counter, cu);\n+                clazz = sc.getClassLoader().loadClass(\"com.graphhopper.Test\" + counter);\n+                if (CACHE.size() < CACHE_SIZE)\n+                    CACHE.put(key, clazz);\n+                else if (DYN_CACHE_SIZE > 0)\n+                    DYN_CACHE.put(key, clazz);\n+            }\n+\n+            // The class does not need to be thread-safe as we create an instance per request\n+            CustomWeightingHelper prio = (CustomWeightingHelper) clazz.getDeclaredConstructor().newInstance();\n+            prio.init(lookup, avgSpeedEnc, customModel.getAreas());\n+            return prio;\n+        } catch (Exception ex) {\n+            String location = \"\";\n+            if (ex instanceof CompileException)\n+                location = \" in \" + ((CompileException) ex).getLocation().getFileName();\n+            throw new IllegalArgumentException(\"Cannot compile expression \" + location + \", \" + ex.getMessage(), ex);\n+        }\n+    }\n+\n+    /**\n+     * Parse the expressions from CustomModel relevant for the method getSpeed - see createClassTemplate.\n+     *\n+     * @return the created statements (parsed expressions)\n+     */\n+    private static List<Java.BlockStatement> createGetSpeedStatements(Set<String> speedVariables,\n+                                                                      CustomModel customModel, EncodedValueLookup lookup,\n+                                                                      double globalMaxSpeed, double maxSpeedFallback) throws Exception {\n+        List<Java.BlockStatement> speedStatements = new ArrayList<>();\n+        speedStatements.addAll(verifyExpressions(new StringBuilder(), \"speed_factor_user_statements\", speedVariables,\n+                customModel.getSpeedFactor(), lookup,\n+                num -> \"speed *= \" + num + \";\\n\", \"\"));\n+        StringBuilder codeSB = new StringBuilder(\"boolean applied = false;\\n\");\n+        speedStatements.addAll(verifyExpressions(codeSB, \"max_speed_user_statements\",\n+                speedVariables, customModel.getMaxSpeed(), lookup,\n+                num -> \"applied = true; speed = Math.min(speed,\" + num + \");\",\n+                \"if (!applied && speed > \" + maxSpeedFallback + \") return \" + maxSpeedFallback + \";\\n\" +\n+                        \"return Math.min(speed, \" + globalMaxSpeed + \");\\n\"));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTkxMzA0OA=="}, "originalCommit": {"oid": "f4478bb97c3d7585b21c39eadf45d80e57436cb3"}, "originalPosition": 133}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTg5ODAzMQ==", "bodyText": "And shall we rename this to limit to?\n\nYes (if you ask me)\n\nMerging custom models is currently very simplistic: we just append the expressions. This is easy to understand and should also never lead to a bigger speed or priority as long as we check the values for every operator (I think?).\n\nOk. Yes if alll factors are < 1 the overall factor will be < 1 as well (or what are you worried about?). I am more concerned about a server side model with some multiply_with and some subsequent limit to rules. If we append a similar client model we will apply the factors to the already limited speeds/priorities? Simply appending the models is easy to understand, but not sure if this is powerful enough? For example should it be possible to 'revert' or override a rule?", "url": "https://github.com/graphhopper/graphhopper/pull/2209#discussion_r545898031", "createdAt": "2020-12-18T15:10:47Z", "author": {"login": "easbar"}, "path": "core/src/main/java/com/graphhopper/routing/weighting/custom/ExpressionBuilder.java", "diffHunk": "@@ -0,0 +1,379 @@\n+/*\n+ *  Licensed to GraphHopper GmbH under one or more contributor\n+ *  license agreements. See the NOTICE file distributed with this work for\n+ *  additional information regarding copyright ownership.\n+ *\n+ *  GraphHopper GmbH licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except in\n+ *  compliance with the License. You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package com.graphhopper.routing.weighting.custom;\n+\n+import com.graphhopper.json.geo.JsonFeature;\n+import com.graphhopper.routing.ev.DecimalEncodedValue;\n+import com.graphhopper.routing.ev.EncodedValue;\n+import com.graphhopper.routing.ev.EncodedValueLookup;\n+import com.graphhopper.routing.util.CustomModel;\n+import com.graphhopper.routing.util.EncodingManager;\n+import com.graphhopper.util.EdgeIteratorState;\n+import com.graphhopper.util.GHUtility;\n+import com.graphhopper.util.shapes.BBox;\n+import com.graphhopper.util.shapes.Polygon;\n+import org.codehaus.commons.compiler.CompileException;\n+import org.codehaus.commons.compiler.Location;\n+import org.codehaus.commons.compiler.io.Readers;\n+import org.codehaus.janino.Scanner;\n+import org.codehaus.janino.*;\n+import org.codehaus.janino.util.DeepCopier;\n+import org.locationtech.jts.geom.prep.PreparedGeometryFactory;\n+\n+import java.io.*;\n+import java.util.*;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+class ExpressionBuilder {\n+    private static final AtomicLong longVal = new AtomicLong(1);\n+    static final String IN_AREA_PREFIX = \"in_area_\";\n+    private static final Set<String> allowedNames = new HashSet<>(Arrays.asList(\"edge\", \"Math\"));\n+    private static final boolean JANINO_DEBUG = Boolean.getBoolean(Scanner.SYSTEM_PROPERTY_SOURCE_DEBUGGING_ENABLE);\n+\n+    // TODO without a cache we get X% slower routing and Y% slower routingLM8. CH requests and preparation is unaffected\n+    // as cached weighting from preparation is used. This cache ensures that the first Weighting classes, typically the\n+    // ones specified in the profiles, are never removed regardless of how frequent other Weightings are created and accessed.\n+    // We only need to synchronize the get and put methods alone. E.g. we do not care for the race condition where\n+    // two identical classes are requested and one of them is overwritten. We could use CachingJavaSourceClassLoader from\n+    // Janino but 1. we would need to use a single compiler across threads and 2. the statements (for priority and speed)\n+    // are still unnecessarily created.\n+    private static final int CACHE_SIZE = Integer.getInteger(\"graphhopper.custom_weighting.cache_size\", 10);\n+    // TODO perf compare with ConcurrentHashMap, but I guess, if there is a difference at all, it is not big for small maps\n+    private static final Map<String, Class> CACHE = Collections.synchronizedMap(new HashMap<>(CACHE_SIZE));\n+\n+    // Introduce a dynamic cache to remember different Weighting classes, but throw away less frequently used classes.\n+    // Use accessOrder==true to remove oldest accessed entry, not oldest inserted.\n+    private static final int DYN_CACHE_SIZE = Integer.getInteger(\"graphhopper.custom_weighting.dynamic_cache_size\", 1000);\n+    private static final Map<String, Class> DYN_CACHE = Collections.synchronizedMap(\n+            new LinkedHashMap<String, Class>(DYN_CACHE_SIZE, 0.75f, true) {\n+                protected boolean removeEldestEntry(Map.Entry eldest) {\n+                    return size() > DYN_CACHE_SIZE;\n+                }\n+            });\n+\n+    /**\n+     * This method compiles a new subclass of CustomWeightingHelper composed from the provided CustomModel caches this\n+     * and returns an instance.\n+     */\n+    static CustomWeightingHelper create(CustomModel customModel, EncodedValueLookup lookup,\n+                                        double globalMaxSpeed, double maxSpeedFallback, DecimalEncodedValue avgSpeedEnc) {\n+        Java.CompilationUnit cu;\n+        try {\n+            String key = customModel.toString() + \",global:\" + globalMaxSpeed + \",fallback:\" + maxSpeedFallback;\n+            if (key.length() > 400_000) throw new IllegalArgumentException(\"Custom Model too big: \" + key.length());\n+\n+            Class clazz = CACHE.get(key);\n+            if (DYN_CACHE_SIZE > 0 && clazz == null)\n+                clazz = DYN_CACHE.get(key);\n+            if (clazz == null) {\n+                HashSet<String> priorityVariables = new LinkedHashSet<>();\n+                List<Java.BlockStatement> priorityStatements = createGetPriorityStatements(priorityVariables, customModel, lookup);\n+                HashSet<String> speedVariables = new LinkedHashSet<>();\n+                List<Java.BlockStatement> speedStatements = createGetSpeedStatements(speedVariables, customModel, lookup, globalMaxSpeed, maxSpeedFallback);\n+                // Create different class name, which is required only for debugging.\n+                // TODO does it improve performance too? I.e. it could be that the JIT is confused if different classes\n+                //  have the same name and it mixes performance stats. See https://github.com/janino-compiler/janino/issues/137\n+                long counter = longVal.incrementAndGet();\n+                String classTemplate = createClassTemplate(counter, priorityVariables, speedVariables, lookup, customModel);\n+                cu = (Java.CompilationUnit) new Parser(new org.codehaus.janino.Scanner(\"source\", new StringReader(classTemplate))).\n+                        parseAbstractCompilationUnit();\n+                cu = injectStatements(priorityStatements, speedStatements, cu);\n+                SimpleCompiler sc = createCompiler(counter, cu);\n+                clazz = sc.getClassLoader().loadClass(\"com.graphhopper.Test\" + counter);\n+                if (CACHE.size() < CACHE_SIZE)\n+                    CACHE.put(key, clazz);\n+                else if (DYN_CACHE_SIZE > 0)\n+                    DYN_CACHE.put(key, clazz);\n+            }\n+\n+            // The class does not need to be thread-safe as we create an instance per request\n+            CustomWeightingHelper prio = (CustomWeightingHelper) clazz.getDeclaredConstructor().newInstance();\n+            prio.init(lookup, avgSpeedEnc, customModel.getAreas());\n+            return prio;\n+        } catch (Exception ex) {\n+            String location = \"\";\n+            if (ex instanceof CompileException)\n+                location = \" in \" + ((CompileException) ex).getLocation().getFileName();\n+            throw new IllegalArgumentException(\"Cannot compile expression \" + location + \", \" + ex.getMessage(), ex);\n+        }\n+    }\n+\n+    /**\n+     * Parse the expressions from CustomModel relevant for the method getSpeed - see createClassTemplate.\n+     *\n+     * @return the created statements (parsed expressions)\n+     */\n+    private static List<Java.BlockStatement> createGetSpeedStatements(Set<String> speedVariables,\n+                                                                      CustomModel customModel, EncodedValueLookup lookup,\n+                                                                      double globalMaxSpeed, double maxSpeedFallback) throws Exception {\n+        List<Java.BlockStatement> speedStatements = new ArrayList<>();\n+        speedStatements.addAll(verifyExpressions(new StringBuilder(), \"speed_factor_user_statements\", speedVariables,\n+                customModel.getSpeedFactor(), lookup,\n+                num -> \"speed *= \" + num + \";\\n\", \"\"));\n+        StringBuilder codeSB = new StringBuilder(\"boolean applied = false;\\n\");\n+        speedStatements.addAll(verifyExpressions(codeSB, \"max_speed_user_statements\",\n+                speedVariables, customModel.getMaxSpeed(), lookup,\n+                num -> \"applied = true; speed = Math.min(speed,\" + num + \");\",\n+                \"if (!applied && speed > \" + maxSpeedFallback + \") return \" + maxSpeedFallback + \";\\n\" +\n+                        \"return Math.min(speed, \" + globalMaxSpeed + \");\\n\"));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTkxMzA0OA=="}, "originalCommit": {"oid": "f4478bb97c3d7585b21c39eadf45d80e57436cb3"}, "originalPosition": 133}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjIyNzA1Nw==", "bodyText": "If we append a similar client model we will apply the factors to the already limited speeds/priorities?\n\nYes. This makes the most sense to me.\n\nFor example should it be possible to 'revert' or override a rule?\n\nFor client-side models I would say no (e.g. the LM preparation would not be usable).\nAnd for extending a server-side model on the server-side then yes, the current approach is not sufficient. But currently this is not supported anyway. But I'm not sure if we should make reverting or overriding rules possible at all. Imagine we have a truckA profile with a 90km/h speed limit and we want a new truckB profile that extends truckA but increases this speed to 100km/h. To solve this we can use truckA with 90km/h to extend truckA with 100km/h, which would also make it possible to use the same LM preparation. This won't work if you want one property stricter and another property less strict, but in such a case copying all the rules into a third base profile truckC could work (and then extending truckA from truckC and truckB from truckC). Do you know what I mean :) ?", "url": "https://github.com/graphhopper/graphhopper/pull/2209#discussion_r546227057", "createdAt": "2020-12-19T11:24:20Z", "author": {"login": "karussell"}, "path": "core/src/main/java/com/graphhopper/routing/weighting/custom/ExpressionBuilder.java", "diffHunk": "@@ -0,0 +1,379 @@\n+/*\n+ *  Licensed to GraphHopper GmbH under one or more contributor\n+ *  license agreements. See the NOTICE file distributed with this work for\n+ *  additional information regarding copyright ownership.\n+ *\n+ *  GraphHopper GmbH licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except in\n+ *  compliance with the License. You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package com.graphhopper.routing.weighting.custom;\n+\n+import com.graphhopper.json.geo.JsonFeature;\n+import com.graphhopper.routing.ev.DecimalEncodedValue;\n+import com.graphhopper.routing.ev.EncodedValue;\n+import com.graphhopper.routing.ev.EncodedValueLookup;\n+import com.graphhopper.routing.util.CustomModel;\n+import com.graphhopper.routing.util.EncodingManager;\n+import com.graphhopper.util.EdgeIteratorState;\n+import com.graphhopper.util.GHUtility;\n+import com.graphhopper.util.shapes.BBox;\n+import com.graphhopper.util.shapes.Polygon;\n+import org.codehaus.commons.compiler.CompileException;\n+import org.codehaus.commons.compiler.Location;\n+import org.codehaus.commons.compiler.io.Readers;\n+import org.codehaus.janino.Scanner;\n+import org.codehaus.janino.*;\n+import org.codehaus.janino.util.DeepCopier;\n+import org.locationtech.jts.geom.prep.PreparedGeometryFactory;\n+\n+import java.io.*;\n+import java.util.*;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+class ExpressionBuilder {\n+    private static final AtomicLong longVal = new AtomicLong(1);\n+    static final String IN_AREA_PREFIX = \"in_area_\";\n+    private static final Set<String> allowedNames = new HashSet<>(Arrays.asList(\"edge\", \"Math\"));\n+    private static final boolean JANINO_DEBUG = Boolean.getBoolean(Scanner.SYSTEM_PROPERTY_SOURCE_DEBUGGING_ENABLE);\n+\n+    // TODO without a cache we get X% slower routing and Y% slower routingLM8. CH requests and preparation is unaffected\n+    // as cached weighting from preparation is used. This cache ensures that the first Weighting classes, typically the\n+    // ones specified in the profiles, are never removed regardless of how frequent other Weightings are created and accessed.\n+    // We only need to synchronize the get and put methods alone. E.g. we do not care for the race condition where\n+    // two identical classes are requested and one of them is overwritten. We could use CachingJavaSourceClassLoader from\n+    // Janino but 1. we would need to use a single compiler across threads and 2. the statements (for priority and speed)\n+    // are still unnecessarily created.\n+    private static final int CACHE_SIZE = Integer.getInteger(\"graphhopper.custom_weighting.cache_size\", 10);\n+    // TODO perf compare with ConcurrentHashMap, but I guess, if there is a difference at all, it is not big for small maps\n+    private static final Map<String, Class> CACHE = Collections.synchronizedMap(new HashMap<>(CACHE_SIZE));\n+\n+    // Introduce a dynamic cache to remember different Weighting classes, but throw away less frequently used classes.\n+    // Use accessOrder==true to remove oldest accessed entry, not oldest inserted.\n+    private static final int DYN_CACHE_SIZE = Integer.getInteger(\"graphhopper.custom_weighting.dynamic_cache_size\", 1000);\n+    private static final Map<String, Class> DYN_CACHE = Collections.synchronizedMap(\n+            new LinkedHashMap<String, Class>(DYN_CACHE_SIZE, 0.75f, true) {\n+                protected boolean removeEldestEntry(Map.Entry eldest) {\n+                    return size() > DYN_CACHE_SIZE;\n+                }\n+            });\n+\n+    /**\n+     * This method compiles a new subclass of CustomWeightingHelper composed from the provided CustomModel caches this\n+     * and returns an instance.\n+     */\n+    static CustomWeightingHelper create(CustomModel customModel, EncodedValueLookup lookup,\n+                                        double globalMaxSpeed, double maxSpeedFallback, DecimalEncodedValue avgSpeedEnc) {\n+        Java.CompilationUnit cu;\n+        try {\n+            String key = customModel.toString() + \",global:\" + globalMaxSpeed + \",fallback:\" + maxSpeedFallback;\n+            if (key.length() > 400_000) throw new IllegalArgumentException(\"Custom Model too big: \" + key.length());\n+\n+            Class clazz = CACHE.get(key);\n+            if (DYN_CACHE_SIZE > 0 && clazz == null)\n+                clazz = DYN_CACHE.get(key);\n+            if (clazz == null) {\n+                HashSet<String> priorityVariables = new LinkedHashSet<>();\n+                List<Java.BlockStatement> priorityStatements = createGetPriorityStatements(priorityVariables, customModel, lookup);\n+                HashSet<String> speedVariables = new LinkedHashSet<>();\n+                List<Java.BlockStatement> speedStatements = createGetSpeedStatements(speedVariables, customModel, lookup, globalMaxSpeed, maxSpeedFallback);\n+                // Create different class name, which is required only for debugging.\n+                // TODO does it improve performance too? I.e. it could be that the JIT is confused if different classes\n+                //  have the same name and it mixes performance stats. See https://github.com/janino-compiler/janino/issues/137\n+                long counter = longVal.incrementAndGet();\n+                String classTemplate = createClassTemplate(counter, priorityVariables, speedVariables, lookup, customModel);\n+                cu = (Java.CompilationUnit) new Parser(new org.codehaus.janino.Scanner(\"source\", new StringReader(classTemplate))).\n+                        parseAbstractCompilationUnit();\n+                cu = injectStatements(priorityStatements, speedStatements, cu);\n+                SimpleCompiler sc = createCompiler(counter, cu);\n+                clazz = sc.getClassLoader().loadClass(\"com.graphhopper.Test\" + counter);\n+                if (CACHE.size() < CACHE_SIZE)\n+                    CACHE.put(key, clazz);\n+                else if (DYN_CACHE_SIZE > 0)\n+                    DYN_CACHE.put(key, clazz);\n+            }\n+\n+            // The class does not need to be thread-safe as we create an instance per request\n+            CustomWeightingHelper prio = (CustomWeightingHelper) clazz.getDeclaredConstructor().newInstance();\n+            prio.init(lookup, avgSpeedEnc, customModel.getAreas());\n+            return prio;\n+        } catch (Exception ex) {\n+            String location = \"\";\n+            if (ex instanceof CompileException)\n+                location = \" in \" + ((CompileException) ex).getLocation().getFileName();\n+            throw new IllegalArgumentException(\"Cannot compile expression \" + location + \", \" + ex.getMessage(), ex);\n+        }\n+    }\n+\n+    /**\n+     * Parse the expressions from CustomModel relevant for the method getSpeed - see createClassTemplate.\n+     *\n+     * @return the created statements (parsed expressions)\n+     */\n+    private static List<Java.BlockStatement> createGetSpeedStatements(Set<String> speedVariables,\n+                                                                      CustomModel customModel, EncodedValueLookup lookup,\n+                                                                      double globalMaxSpeed, double maxSpeedFallback) throws Exception {\n+        List<Java.BlockStatement> speedStatements = new ArrayList<>();\n+        speedStatements.addAll(verifyExpressions(new StringBuilder(), \"speed_factor_user_statements\", speedVariables,\n+                customModel.getSpeedFactor(), lookup,\n+                num -> \"speed *= \" + num + \";\\n\", \"\"));\n+        StringBuilder codeSB = new StringBuilder(\"boolean applied = false;\\n\");\n+        speedStatements.addAll(verifyExpressions(codeSB, \"max_speed_user_statements\",\n+                speedVariables, customModel.getMaxSpeed(), lookup,\n+                num -> \"applied = true; speed = Math.min(speed,\" + num + \");\",\n+                \"if (!applied && speed > \" + maxSpeedFallback + \") return \" + maxSpeedFallback + \";\\n\" +\n+                        \"return Math.min(speed, \" + globalMaxSpeed + \");\\n\"));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTkxMzA0OA=="}, "originalCommit": {"oid": "f4478bb97c3d7585b21c39eadf45d80e57436cb3"}, "originalPosition": 133}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjIzOTYxMg==", "bodyText": "Yes. This makes the most sense to me.\n\nOk its probably simple to implement and easy to understand.\n\nFor client-side models I would say no (e.g. the LM preparation would not be usable).\n\nOk. Still not 100% convinced this is powerful enough, but we can keep it simple until we feel the need for an advanced merging mechanism.\n\nAnd for extending a server-side model on the server-side then yes, the current approach is not sufficient. But currently this is not supported anyway.\n\nOk I was just wondering if the changed format provides a problem to do this in the future.\n\nDo you know what I mean :\n\nI'm not sure \ud83e\udd23\n\nTo solve this we can use truckA with 90km/h to extend truckA with 100km/h, which would also make it possible to use the same LM preparation\n\nYou said truckA has speed limit 90km/h, but what do you mean 'we can use truckA with 90km/h to extend truckA with 100km/h'? And why can we use the same LM preparation when we increase the speed (reduce the weight)? Isn't it the other way around: Re-using the same landmarks is only possible as long as we increase the weights?\nTo extend custom models on the server side I think LM compatibility is less important, because we can always enforce using certain landmarks (at our own responsibility) using preparation_profile and even more so because the custom models shall be used with AStar or CH as well. This is more about how we can share code/yaml between custom models for example when we have a complex configuration and need multiple similar variations of it. But we can probably solve this with some kind of 'include' mechanism just like you proposed: truckA and truckB use some common configuration from truckC (I think I understood this part).", "url": "https://github.com/graphhopper/graphhopper/pull/2209#discussion_r546239612", "createdAt": "2020-12-19T13:39:35Z", "author": {"login": "easbar"}, "path": "core/src/main/java/com/graphhopper/routing/weighting/custom/ExpressionBuilder.java", "diffHunk": "@@ -0,0 +1,379 @@\n+/*\n+ *  Licensed to GraphHopper GmbH under one or more contributor\n+ *  license agreements. See the NOTICE file distributed with this work for\n+ *  additional information regarding copyright ownership.\n+ *\n+ *  GraphHopper GmbH licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except in\n+ *  compliance with the License. You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package com.graphhopper.routing.weighting.custom;\n+\n+import com.graphhopper.json.geo.JsonFeature;\n+import com.graphhopper.routing.ev.DecimalEncodedValue;\n+import com.graphhopper.routing.ev.EncodedValue;\n+import com.graphhopper.routing.ev.EncodedValueLookup;\n+import com.graphhopper.routing.util.CustomModel;\n+import com.graphhopper.routing.util.EncodingManager;\n+import com.graphhopper.util.EdgeIteratorState;\n+import com.graphhopper.util.GHUtility;\n+import com.graphhopper.util.shapes.BBox;\n+import com.graphhopper.util.shapes.Polygon;\n+import org.codehaus.commons.compiler.CompileException;\n+import org.codehaus.commons.compiler.Location;\n+import org.codehaus.commons.compiler.io.Readers;\n+import org.codehaus.janino.Scanner;\n+import org.codehaus.janino.*;\n+import org.codehaus.janino.util.DeepCopier;\n+import org.locationtech.jts.geom.prep.PreparedGeometryFactory;\n+\n+import java.io.*;\n+import java.util.*;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+class ExpressionBuilder {\n+    private static final AtomicLong longVal = new AtomicLong(1);\n+    static final String IN_AREA_PREFIX = \"in_area_\";\n+    private static final Set<String> allowedNames = new HashSet<>(Arrays.asList(\"edge\", \"Math\"));\n+    private static final boolean JANINO_DEBUG = Boolean.getBoolean(Scanner.SYSTEM_PROPERTY_SOURCE_DEBUGGING_ENABLE);\n+\n+    // TODO without a cache we get X% slower routing and Y% slower routingLM8. CH requests and preparation is unaffected\n+    // as cached weighting from preparation is used. This cache ensures that the first Weighting classes, typically the\n+    // ones specified in the profiles, are never removed regardless of how frequent other Weightings are created and accessed.\n+    // We only need to synchronize the get and put methods alone. E.g. we do not care for the race condition where\n+    // two identical classes are requested and one of them is overwritten. We could use CachingJavaSourceClassLoader from\n+    // Janino but 1. we would need to use a single compiler across threads and 2. the statements (for priority and speed)\n+    // are still unnecessarily created.\n+    private static final int CACHE_SIZE = Integer.getInteger(\"graphhopper.custom_weighting.cache_size\", 10);\n+    // TODO perf compare with ConcurrentHashMap, but I guess, if there is a difference at all, it is not big for small maps\n+    private static final Map<String, Class> CACHE = Collections.synchronizedMap(new HashMap<>(CACHE_SIZE));\n+\n+    // Introduce a dynamic cache to remember different Weighting classes, but throw away less frequently used classes.\n+    // Use accessOrder==true to remove oldest accessed entry, not oldest inserted.\n+    private static final int DYN_CACHE_SIZE = Integer.getInteger(\"graphhopper.custom_weighting.dynamic_cache_size\", 1000);\n+    private static final Map<String, Class> DYN_CACHE = Collections.synchronizedMap(\n+            new LinkedHashMap<String, Class>(DYN_CACHE_SIZE, 0.75f, true) {\n+                protected boolean removeEldestEntry(Map.Entry eldest) {\n+                    return size() > DYN_CACHE_SIZE;\n+                }\n+            });\n+\n+    /**\n+     * This method compiles a new subclass of CustomWeightingHelper composed from the provided CustomModel caches this\n+     * and returns an instance.\n+     */\n+    static CustomWeightingHelper create(CustomModel customModel, EncodedValueLookup lookup,\n+                                        double globalMaxSpeed, double maxSpeedFallback, DecimalEncodedValue avgSpeedEnc) {\n+        Java.CompilationUnit cu;\n+        try {\n+            String key = customModel.toString() + \",global:\" + globalMaxSpeed + \",fallback:\" + maxSpeedFallback;\n+            if (key.length() > 400_000) throw new IllegalArgumentException(\"Custom Model too big: \" + key.length());\n+\n+            Class clazz = CACHE.get(key);\n+            if (DYN_CACHE_SIZE > 0 && clazz == null)\n+                clazz = DYN_CACHE.get(key);\n+            if (clazz == null) {\n+                HashSet<String> priorityVariables = new LinkedHashSet<>();\n+                List<Java.BlockStatement> priorityStatements = createGetPriorityStatements(priorityVariables, customModel, lookup);\n+                HashSet<String> speedVariables = new LinkedHashSet<>();\n+                List<Java.BlockStatement> speedStatements = createGetSpeedStatements(speedVariables, customModel, lookup, globalMaxSpeed, maxSpeedFallback);\n+                // Create different class name, which is required only for debugging.\n+                // TODO does it improve performance too? I.e. it could be that the JIT is confused if different classes\n+                //  have the same name and it mixes performance stats. See https://github.com/janino-compiler/janino/issues/137\n+                long counter = longVal.incrementAndGet();\n+                String classTemplate = createClassTemplate(counter, priorityVariables, speedVariables, lookup, customModel);\n+                cu = (Java.CompilationUnit) new Parser(new org.codehaus.janino.Scanner(\"source\", new StringReader(classTemplate))).\n+                        parseAbstractCompilationUnit();\n+                cu = injectStatements(priorityStatements, speedStatements, cu);\n+                SimpleCompiler sc = createCompiler(counter, cu);\n+                clazz = sc.getClassLoader().loadClass(\"com.graphhopper.Test\" + counter);\n+                if (CACHE.size() < CACHE_SIZE)\n+                    CACHE.put(key, clazz);\n+                else if (DYN_CACHE_SIZE > 0)\n+                    DYN_CACHE.put(key, clazz);\n+            }\n+\n+            // The class does not need to be thread-safe as we create an instance per request\n+            CustomWeightingHelper prio = (CustomWeightingHelper) clazz.getDeclaredConstructor().newInstance();\n+            prio.init(lookup, avgSpeedEnc, customModel.getAreas());\n+            return prio;\n+        } catch (Exception ex) {\n+            String location = \"\";\n+            if (ex instanceof CompileException)\n+                location = \" in \" + ((CompileException) ex).getLocation().getFileName();\n+            throw new IllegalArgumentException(\"Cannot compile expression \" + location + \", \" + ex.getMessage(), ex);\n+        }\n+    }\n+\n+    /**\n+     * Parse the expressions from CustomModel relevant for the method getSpeed - see createClassTemplate.\n+     *\n+     * @return the created statements (parsed expressions)\n+     */\n+    private static List<Java.BlockStatement> createGetSpeedStatements(Set<String> speedVariables,\n+                                                                      CustomModel customModel, EncodedValueLookup lookup,\n+                                                                      double globalMaxSpeed, double maxSpeedFallback) throws Exception {\n+        List<Java.BlockStatement> speedStatements = new ArrayList<>();\n+        speedStatements.addAll(verifyExpressions(new StringBuilder(), \"speed_factor_user_statements\", speedVariables,\n+                customModel.getSpeedFactor(), lookup,\n+                num -> \"speed *= \" + num + \";\\n\", \"\"));\n+        StringBuilder codeSB = new StringBuilder(\"boolean applied = false;\\n\");\n+        speedStatements.addAll(verifyExpressions(codeSB, \"max_speed_user_statements\",\n+                speedVariables, customModel.getMaxSpeed(), lookup,\n+                num -> \"applied = true; speed = Math.min(speed,\" + num + \");\",\n+                \"if (!applied && speed > \" + maxSpeedFallback + \") return \" + maxSpeedFallback + \";\\n\" +\n+                        \"return Math.min(speed, \" + globalMaxSpeed + \");\\n\"));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTkxMzA0OA=="}, "originalCommit": {"oid": "f4478bb97c3d7585b21c39eadf45d80e57436cb3"}, "originalPosition": 133}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjI1NzgyMQ==", "bodyText": "we can use truckA with 90km/h to extend truckA\n\nUps, I messed up my example :D ... I meant: we have truckB with 100km/h as base and now we want truckA with the same properties (i.e. extending truckB) but with 90km/h, i.e. increasing the weight.\n\nTo extend custom models on the server side I think LM compatibility is less important, because we can always enforce using certain landmarks (at our own responsibility) using preparation_profile and even more so because the custom models shall be used with AStar or CH as well.\n\nYes, server-side models do not need to have these limitations also because we could create a separate LM preparation or allow a different preparation_profile at our own responsibility.\n\nThis is more about how we can share code/yaml between custom models for example when we have a complex configuration\n\nYes. Looking into other routing engines this does not seem to be a solved thing and they copy&paste the config.\nI thought a bit about this how we could do this and one way to approach this is to explicitly name a set of if-statements (\"define a method\") so that it can be included later (in the same model and) externally:\nexport:\n- avoidSmallRoads:\n  - if: road_class == LIVING_STREET || road_class == TERTIARY || road_class == RESIDENTIAL\n    multiply with: 0.5\n\npriority:\n- run: avoidSmallRoads()\nThis way it is up to the one who writes the new custom model if it is included before or after some other statements. Also in theory a method could be used for speed and priority although it was intended only for priority. Not sure if we need to limit this.", "url": "https://github.com/graphhopper/graphhopper/pull/2209#discussion_r546257821", "createdAt": "2020-12-19T16:42:19Z", "author": {"login": "karussell"}, "path": "core/src/main/java/com/graphhopper/routing/weighting/custom/ExpressionBuilder.java", "diffHunk": "@@ -0,0 +1,379 @@\n+/*\n+ *  Licensed to GraphHopper GmbH under one or more contributor\n+ *  license agreements. See the NOTICE file distributed with this work for\n+ *  additional information regarding copyright ownership.\n+ *\n+ *  GraphHopper GmbH licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except in\n+ *  compliance with the License. You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package com.graphhopper.routing.weighting.custom;\n+\n+import com.graphhopper.json.geo.JsonFeature;\n+import com.graphhopper.routing.ev.DecimalEncodedValue;\n+import com.graphhopper.routing.ev.EncodedValue;\n+import com.graphhopper.routing.ev.EncodedValueLookup;\n+import com.graphhopper.routing.util.CustomModel;\n+import com.graphhopper.routing.util.EncodingManager;\n+import com.graphhopper.util.EdgeIteratorState;\n+import com.graphhopper.util.GHUtility;\n+import com.graphhopper.util.shapes.BBox;\n+import com.graphhopper.util.shapes.Polygon;\n+import org.codehaus.commons.compiler.CompileException;\n+import org.codehaus.commons.compiler.Location;\n+import org.codehaus.commons.compiler.io.Readers;\n+import org.codehaus.janino.Scanner;\n+import org.codehaus.janino.*;\n+import org.codehaus.janino.util.DeepCopier;\n+import org.locationtech.jts.geom.prep.PreparedGeometryFactory;\n+\n+import java.io.*;\n+import java.util.*;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+class ExpressionBuilder {\n+    private static final AtomicLong longVal = new AtomicLong(1);\n+    static final String IN_AREA_PREFIX = \"in_area_\";\n+    private static final Set<String> allowedNames = new HashSet<>(Arrays.asList(\"edge\", \"Math\"));\n+    private static final boolean JANINO_DEBUG = Boolean.getBoolean(Scanner.SYSTEM_PROPERTY_SOURCE_DEBUGGING_ENABLE);\n+\n+    // TODO without a cache we get X% slower routing and Y% slower routingLM8. CH requests and preparation is unaffected\n+    // as cached weighting from preparation is used. This cache ensures that the first Weighting classes, typically the\n+    // ones specified in the profiles, are never removed regardless of how frequent other Weightings are created and accessed.\n+    // We only need to synchronize the get and put methods alone. E.g. we do not care for the race condition where\n+    // two identical classes are requested and one of them is overwritten. We could use CachingJavaSourceClassLoader from\n+    // Janino but 1. we would need to use a single compiler across threads and 2. the statements (for priority and speed)\n+    // are still unnecessarily created.\n+    private static final int CACHE_SIZE = Integer.getInteger(\"graphhopper.custom_weighting.cache_size\", 10);\n+    // TODO perf compare with ConcurrentHashMap, but I guess, if there is a difference at all, it is not big for small maps\n+    private static final Map<String, Class> CACHE = Collections.synchronizedMap(new HashMap<>(CACHE_SIZE));\n+\n+    // Introduce a dynamic cache to remember different Weighting classes, but throw away less frequently used classes.\n+    // Use accessOrder==true to remove oldest accessed entry, not oldest inserted.\n+    private static final int DYN_CACHE_SIZE = Integer.getInteger(\"graphhopper.custom_weighting.dynamic_cache_size\", 1000);\n+    private static final Map<String, Class> DYN_CACHE = Collections.synchronizedMap(\n+            new LinkedHashMap<String, Class>(DYN_CACHE_SIZE, 0.75f, true) {\n+                protected boolean removeEldestEntry(Map.Entry eldest) {\n+                    return size() > DYN_CACHE_SIZE;\n+                }\n+            });\n+\n+    /**\n+     * This method compiles a new subclass of CustomWeightingHelper composed from the provided CustomModel caches this\n+     * and returns an instance.\n+     */\n+    static CustomWeightingHelper create(CustomModel customModel, EncodedValueLookup lookup,\n+                                        double globalMaxSpeed, double maxSpeedFallback, DecimalEncodedValue avgSpeedEnc) {\n+        Java.CompilationUnit cu;\n+        try {\n+            String key = customModel.toString() + \",global:\" + globalMaxSpeed + \",fallback:\" + maxSpeedFallback;\n+            if (key.length() > 400_000) throw new IllegalArgumentException(\"Custom Model too big: \" + key.length());\n+\n+            Class clazz = CACHE.get(key);\n+            if (DYN_CACHE_SIZE > 0 && clazz == null)\n+                clazz = DYN_CACHE.get(key);\n+            if (clazz == null) {\n+                HashSet<String> priorityVariables = new LinkedHashSet<>();\n+                List<Java.BlockStatement> priorityStatements = createGetPriorityStatements(priorityVariables, customModel, lookup);\n+                HashSet<String> speedVariables = new LinkedHashSet<>();\n+                List<Java.BlockStatement> speedStatements = createGetSpeedStatements(speedVariables, customModel, lookup, globalMaxSpeed, maxSpeedFallback);\n+                // Create different class name, which is required only for debugging.\n+                // TODO does it improve performance too? I.e. it could be that the JIT is confused if different classes\n+                //  have the same name and it mixes performance stats. See https://github.com/janino-compiler/janino/issues/137\n+                long counter = longVal.incrementAndGet();\n+                String classTemplate = createClassTemplate(counter, priorityVariables, speedVariables, lookup, customModel);\n+                cu = (Java.CompilationUnit) new Parser(new org.codehaus.janino.Scanner(\"source\", new StringReader(classTemplate))).\n+                        parseAbstractCompilationUnit();\n+                cu = injectStatements(priorityStatements, speedStatements, cu);\n+                SimpleCompiler sc = createCompiler(counter, cu);\n+                clazz = sc.getClassLoader().loadClass(\"com.graphhopper.Test\" + counter);\n+                if (CACHE.size() < CACHE_SIZE)\n+                    CACHE.put(key, clazz);\n+                else if (DYN_CACHE_SIZE > 0)\n+                    DYN_CACHE.put(key, clazz);\n+            }\n+\n+            // The class does not need to be thread-safe as we create an instance per request\n+            CustomWeightingHelper prio = (CustomWeightingHelper) clazz.getDeclaredConstructor().newInstance();\n+            prio.init(lookup, avgSpeedEnc, customModel.getAreas());\n+            return prio;\n+        } catch (Exception ex) {\n+            String location = \"\";\n+            if (ex instanceof CompileException)\n+                location = \" in \" + ((CompileException) ex).getLocation().getFileName();\n+            throw new IllegalArgumentException(\"Cannot compile expression \" + location + \", \" + ex.getMessage(), ex);\n+        }\n+    }\n+\n+    /**\n+     * Parse the expressions from CustomModel relevant for the method getSpeed - see createClassTemplate.\n+     *\n+     * @return the created statements (parsed expressions)\n+     */\n+    private static List<Java.BlockStatement> createGetSpeedStatements(Set<String> speedVariables,\n+                                                                      CustomModel customModel, EncodedValueLookup lookup,\n+                                                                      double globalMaxSpeed, double maxSpeedFallback) throws Exception {\n+        List<Java.BlockStatement> speedStatements = new ArrayList<>();\n+        speedStatements.addAll(verifyExpressions(new StringBuilder(), \"speed_factor_user_statements\", speedVariables,\n+                customModel.getSpeedFactor(), lookup,\n+                num -> \"speed *= \" + num + \";\\n\", \"\"));\n+        StringBuilder codeSB = new StringBuilder(\"boolean applied = false;\\n\");\n+        speedStatements.addAll(verifyExpressions(codeSB, \"max_speed_user_statements\",\n+                speedVariables, customModel.getMaxSpeed(), lookup,\n+                num -> \"applied = true; speed = Math.min(speed,\" + num + \");\",\n+                \"if (!applied && speed > \" + maxSpeedFallback + \") return \" + maxSpeedFallback + \";\\n\" +\n+                        \"return Math.min(speed, \" + globalMaxSpeed + \");\\n\"));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTkxMzA0OA=="}, "originalCommit": {"oid": "f4478bb97c3d7585b21c39eadf45d80e57436cb3"}, "originalPosition": 133}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjI1OTU5MQ==", "bodyText": "Should we already introduce this nesting to make the configs forward compatible? I mean just push the if statements one level down like you did with avoidSmallRoads to introduce a 'namespace'? Then again we can also later introduce the 'default' namespace that uses no nesting. Having such namespaces we could also specify what to include/exclude when merging or re-using models. This seems to be a rather complex topic, but just giving names to single or a group of Statements probably makes this a lot easier, regardless about how we will do this in detail.", "url": "https://github.com/graphhopper/graphhopper/pull/2209#discussion_r546259591", "createdAt": "2020-12-19T16:59:29Z", "author": {"login": "easbar"}, "path": "core/src/main/java/com/graphhopper/routing/weighting/custom/ExpressionBuilder.java", "diffHunk": "@@ -0,0 +1,379 @@\n+/*\n+ *  Licensed to GraphHopper GmbH under one or more contributor\n+ *  license agreements. See the NOTICE file distributed with this work for\n+ *  additional information regarding copyright ownership.\n+ *\n+ *  GraphHopper GmbH licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except in\n+ *  compliance with the License. You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package com.graphhopper.routing.weighting.custom;\n+\n+import com.graphhopper.json.geo.JsonFeature;\n+import com.graphhopper.routing.ev.DecimalEncodedValue;\n+import com.graphhopper.routing.ev.EncodedValue;\n+import com.graphhopper.routing.ev.EncodedValueLookup;\n+import com.graphhopper.routing.util.CustomModel;\n+import com.graphhopper.routing.util.EncodingManager;\n+import com.graphhopper.util.EdgeIteratorState;\n+import com.graphhopper.util.GHUtility;\n+import com.graphhopper.util.shapes.BBox;\n+import com.graphhopper.util.shapes.Polygon;\n+import org.codehaus.commons.compiler.CompileException;\n+import org.codehaus.commons.compiler.Location;\n+import org.codehaus.commons.compiler.io.Readers;\n+import org.codehaus.janino.Scanner;\n+import org.codehaus.janino.*;\n+import org.codehaus.janino.util.DeepCopier;\n+import org.locationtech.jts.geom.prep.PreparedGeometryFactory;\n+\n+import java.io.*;\n+import java.util.*;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+class ExpressionBuilder {\n+    private static final AtomicLong longVal = new AtomicLong(1);\n+    static final String IN_AREA_PREFIX = \"in_area_\";\n+    private static final Set<String> allowedNames = new HashSet<>(Arrays.asList(\"edge\", \"Math\"));\n+    private static final boolean JANINO_DEBUG = Boolean.getBoolean(Scanner.SYSTEM_PROPERTY_SOURCE_DEBUGGING_ENABLE);\n+\n+    // TODO without a cache we get X% slower routing and Y% slower routingLM8. CH requests and preparation is unaffected\n+    // as cached weighting from preparation is used. This cache ensures that the first Weighting classes, typically the\n+    // ones specified in the profiles, are never removed regardless of how frequent other Weightings are created and accessed.\n+    // We only need to synchronize the get and put methods alone. E.g. we do not care for the race condition where\n+    // two identical classes are requested and one of them is overwritten. We could use CachingJavaSourceClassLoader from\n+    // Janino but 1. we would need to use a single compiler across threads and 2. the statements (for priority and speed)\n+    // are still unnecessarily created.\n+    private static final int CACHE_SIZE = Integer.getInteger(\"graphhopper.custom_weighting.cache_size\", 10);\n+    // TODO perf compare with ConcurrentHashMap, but I guess, if there is a difference at all, it is not big for small maps\n+    private static final Map<String, Class> CACHE = Collections.synchronizedMap(new HashMap<>(CACHE_SIZE));\n+\n+    // Introduce a dynamic cache to remember different Weighting classes, but throw away less frequently used classes.\n+    // Use accessOrder==true to remove oldest accessed entry, not oldest inserted.\n+    private static final int DYN_CACHE_SIZE = Integer.getInteger(\"graphhopper.custom_weighting.dynamic_cache_size\", 1000);\n+    private static final Map<String, Class> DYN_CACHE = Collections.synchronizedMap(\n+            new LinkedHashMap<String, Class>(DYN_CACHE_SIZE, 0.75f, true) {\n+                protected boolean removeEldestEntry(Map.Entry eldest) {\n+                    return size() > DYN_CACHE_SIZE;\n+                }\n+            });\n+\n+    /**\n+     * This method compiles a new subclass of CustomWeightingHelper composed from the provided CustomModel caches this\n+     * and returns an instance.\n+     */\n+    static CustomWeightingHelper create(CustomModel customModel, EncodedValueLookup lookup,\n+                                        double globalMaxSpeed, double maxSpeedFallback, DecimalEncodedValue avgSpeedEnc) {\n+        Java.CompilationUnit cu;\n+        try {\n+            String key = customModel.toString() + \",global:\" + globalMaxSpeed + \",fallback:\" + maxSpeedFallback;\n+            if (key.length() > 400_000) throw new IllegalArgumentException(\"Custom Model too big: \" + key.length());\n+\n+            Class clazz = CACHE.get(key);\n+            if (DYN_CACHE_SIZE > 0 && clazz == null)\n+                clazz = DYN_CACHE.get(key);\n+            if (clazz == null) {\n+                HashSet<String> priorityVariables = new LinkedHashSet<>();\n+                List<Java.BlockStatement> priorityStatements = createGetPriorityStatements(priorityVariables, customModel, lookup);\n+                HashSet<String> speedVariables = new LinkedHashSet<>();\n+                List<Java.BlockStatement> speedStatements = createGetSpeedStatements(speedVariables, customModel, lookup, globalMaxSpeed, maxSpeedFallback);\n+                // Create different class name, which is required only for debugging.\n+                // TODO does it improve performance too? I.e. it could be that the JIT is confused if different classes\n+                //  have the same name and it mixes performance stats. See https://github.com/janino-compiler/janino/issues/137\n+                long counter = longVal.incrementAndGet();\n+                String classTemplate = createClassTemplate(counter, priorityVariables, speedVariables, lookup, customModel);\n+                cu = (Java.CompilationUnit) new Parser(new org.codehaus.janino.Scanner(\"source\", new StringReader(classTemplate))).\n+                        parseAbstractCompilationUnit();\n+                cu = injectStatements(priorityStatements, speedStatements, cu);\n+                SimpleCompiler sc = createCompiler(counter, cu);\n+                clazz = sc.getClassLoader().loadClass(\"com.graphhopper.Test\" + counter);\n+                if (CACHE.size() < CACHE_SIZE)\n+                    CACHE.put(key, clazz);\n+                else if (DYN_CACHE_SIZE > 0)\n+                    DYN_CACHE.put(key, clazz);\n+            }\n+\n+            // The class does not need to be thread-safe as we create an instance per request\n+            CustomWeightingHelper prio = (CustomWeightingHelper) clazz.getDeclaredConstructor().newInstance();\n+            prio.init(lookup, avgSpeedEnc, customModel.getAreas());\n+            return prio;\n+        } catch (Exception ex) {\n+            String location = \"\";\n+            if (ex instanceof CompileException)\n+                location = \" in \" + ((CompileException) ex).getLocation().getFileName();\n+            throw new IllegalArgumentException(\"Cannot compile expression \" + location + \", \" + ex.getMessage(), ex);\n+        }\n+    }\n+\n+    /**\n+     * Parse the expressions from CustomModel relevant for the method getSpeed - see createClassTemplate.\n+     *\n+     * @return the created statements (parsed expressions)\n+     */\n+    private static List<Java.BlockStatement> createGetSpeedStatements(Set<String> speedVariables,\n+                                                                      CustomModel customModel, EncodedValueLookup lookup,\n+                                                                      double globalMaxSpeed, double maxSpeedFallback) throws Exception {\n+        List<Java.BlockStatement> speedStatements = new ArrayList<>();\n+        speedStatements.addAll(verifyExpressions(new StringBuilder(), \"speed_factor_user_statements\", speedVariables,\n+                customModel.getSpeedFactor(), lookup,\n+                num -> \"speed *= \" + num + \";\\n\", \"\"));\n+        StringBuilder codeSB = new StringBuilder(\"boolean applied = false;\\n\");\n+        speedStatements.addAll(verifyExpressions(codeSB, \"max_speed_user_statements\",\n+                speedVariables, customModel.getMaxSpeed(), lookup,\n+                num -> \"applied = true; speed = Math.min(speed,\" + num + \");\",\n+                \"if (!applied && speed > \" + maxSpeedFallback + \") return \" + maxSpeedFallback + \";\\n\" +\n+                        \"return Math.min(speed, \" + globalMaxSpeed + \");\\n\"));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTkxMzA0OA=="}, "originalCommit": {"oid": "f4478bb97c3d7585b21c39eadf45d80e57436cb3"}, "originalPosition": 133}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjI2MTEyNg==", "bodyText": "I would prefer it if only certain statements are usable in \"subclasses\" not automatically all statements of priority and speed (is this what you meant with 'default' namespace?). This way the super class is only responsible for those \"exported\" statements and also does not need to give everything a name.", "url": "https://github.com/graphhopper/graphhopper/pull/2209#discussion_r546261126", "createdAt": "2020-12-19T17:15:49Z", "author": {"login": "karussell"}, "path": "core/src/main/java/com/graphhopper/routing/weighting/custom/ExpressionBuilder.java", "diffHunk": "@@ -0,0 +1,379 @@\n+/*\n+ *  Licensed to GraphHopper GmbH under one or more contributor\n+ *  license agreements. See the NOTICE file distributed with this work for\n+ *  additional information regarding copyright ownership.\n+ *\n+ *  GraphHopper GmbH licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except in\n+ *  compliance with the License. You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package com.graphhopper.routing.weighting.custom;\n+\n+import com.graphhopper.json.geo.JsonFeature;\n+import com.graphhopper.routing.ev.DecimalEncodedValue;\n+import com.graphhopper.routing.ev.EncodedValue;\n+import com.graphhopper.routing.ev.EncodedValueLookup;\n+import com.graphhopper.routing.util.CustomModel;\n+import com.graphhopper.routing.util.EncodingManager;\n+import com.graphhopper.util.EdgeIteratorState;\n+import com.graphhopper.util.GHUtility;\n+import com.graphhopper.util.shapes.BBox;\n+import com.graphhopper.util.shapes.Polygon;\n+import org.codehaus.commons.compiler.CompileException;\n+import org.codehaus.commons.compiler.Location;\n+import org.codehaus.commons.compiler.io.Readers;\n+import org.codehaus.janino.Scanner;\n+import org.codehaus.janino.*;\n+import org.codehaus.janino.util.DeepCopier;\n+import org.locationtech.jts.geom.prep.PreparedGeometryFactory;\n+\n+import java.io.*;\n+import java.util.*;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+class ExpressionBuilder {\n+    private static final AtomicLong longVal = new AtomicLong(1);\n+    static final String IN_AREA_PREFIX = \"in_area_\";\n+    private static final Set<String> allowedNames = new HashSet<>(Arrays.asList(\"edge\", \"Math\"));\n+    private static final boolean JANINO_DEBUG = Boolean.getBoolean(Scanner.SYSTEM_PROPERTY_SOURCE_DEBUGGING_ENABLE);\n+\n+    // TODO without a cache we get X% slower routing and Y% slower routingLM8. CH requests and preparation is unaffected\n+    // as cached weighting from preparation is used. This cache ensures that the first Weighting classes, typically the\n+    // ones specified in the profiles, are never removed regardless of how frequent other Weightings are created and accessed.\n+    // We only need to synchronize the get and put methods alone. E.g. we do not care for the race condition where\n+    // two identical classes are requested and one of them is overwritten. We could use CachingJavaSourceClassLoader from\n+    // Janino but 1. we would need to use a single compiler across threads and 2. the statements (for priority and speed)\n+    // are still unnecessarily created.\n+    private static final int CACHE_SIZE = Integer.getInteger(\"graphhopper.custom_weighting.cache_size\", 10);\n+    // TODO perf compare with ConcurrentHashMap, but I guess, if there is a difference at all, it is not big for small maps\n+    private static final Map<String, Class> CACHE = Collections.synchronizedMap(new HashMap<>(CACHE_SIZE));\n+\n+    // Introduce a dynamic cache to remember different Weighting classes, but throw away less frequently used classes.\n+    // Use accessOrder==true to remove oldest accessed entry, not oldest inserted.\n+    private static final int DYN_CACHE_SIZE = Integer.getInteger(\"graphhopper.custom_weighting.dynamic_cache_size\", 1000);\n+    private static final Map<String, Class> DYN_CACHE = Collections.synchronizedMap(\n+            new LinkedHashMap<String, Class>(DYN_CACHE_SIZE, 0.75f, true) {\n+                protected boolean removeEldestEntry(Map.Entry eldest) {\n+                    return size() > DYN_CACHE_SIZE;\n+                }\n+            });\n+\n+    /**\n+     * This method compiles a new subclass of CustomWeightingHelper composed from the provided CustomModel caches this\n+     * and returns an instance.\n+     */\n+    static CustomWeightingHelper create(CustomModel customModel, EncodedValueLookup lookup,\n+                                        double globalMaxSpeed, double maxSpeedFallback, DecimalEncodedValue avgSpeedEnc) {\n+        Java.CompilationUnit cu;\n+        try {\n+            String key = customModel.toString() + \",global:\" + globalMaxSpeed + \",fallback:\" + maxSpeedFallback;\n+            if (key.length() > 400_000) throw new IllegalArgumentException(\"Custom Model too big: \" + key.length());\n+\n+            Class clazz = CACHE.get(key);\n+            if (DYN_CACHE_SIZE > 0 && clazz == null)\n+                clazz = DYN_CACHE.get(key);\n+            if (clazz == null) {\n+                HashSet<String> priorityVariables = new LinkedHashSet<>();\n+                List<Java.BlockStatement> priorityStatements = createGetPriorityStatements(priorityVariables, customModel, lookup);\n+                HashSet<String> speedVariables = new LinkedHashSet<>();\n+                List<Java.BlockStatement> speedStatements = createGetSpeedStatements(speedVariables, customModel, lookup, globalMaxSpeed, maxSpeedFallback);\n+                // Create different class name, which is required only for debugging.\n+                // TODO does it improve performance too? I.e. it could be that the JIT is confused if different classes\n+                //  have the same name and it mixes performance stats. See https://github.com/janino-compiler/janino/issues/137\n+                long counter = longVal.incrementAndGet();\n+                String classTemplate = createClassTemplate(counter, priorityVariables, speedVariables, lookup, customModel);\n+                cu = (Java.CompilationUnit) new Parser(new org.codehaus.janino.Scanner(\"source\", new StringReader(classTemplate))).\n+                        parseAbstractCompilationUnit();\n+                cu = injectStatements(priorityStatements, speedStatements, cu);\n+                SimpleCompiler sc = createCompiler(counter, cu);\n+                clazz = sc.getClassLoader().loadClass(\"com.graphhopper.Test\" + counter);\n+                if (CACHE.size() < CACHE_SIZE)\n+                    CACHE.put(key, clazz);\n+                else if (DYN_CACHE_SIZE > 0)\n+                    DYN_CACHE.put(key, clazz);\n+            }\n+\n+            // The class does not need to be thread-safe as we create an instance per request\n+            CustomWeightingHelper prio = (CustomWeightingHelper) clazz.getDeclaredConstructor().newInstance();\n+            prio.init(lookup, avgSpeedEnc, customModel.getAreas());\n+            return prio;\n+        } catch (Exception ex) {\n+            String location = \"\";\n+            if (ex instanceof CompileException)\n+                location = \" in \" + ((CompileException) ex).getLocation().getFileName();\n+            throw new IllegalArgumentException(\"Cannot compile expression \" + location + \", \" + ex.getMessage(), ex);\n+        }\n+    }\n+\n+    /**\n+     * Parse the expressions from CustomModel relevant for the method getSpeed - see createClassTemplate.\n+     *\n+     * @return the created statements (parsed expressions)\n+     */\n+    private static List<Java.BlockStatement> createGetSpeedStatements(Set<String> speedVariables,\n+                                                                      CustomModel customModel, EncodedValueLookup lookup,\n+                                                                      double globalMaxSpeed, double maxSpeedFallback) throws Exception {\n+        List<Java.BlockStatement> speedStatements = new ArrayList<>();\n+        speedStatements.addAll(verifyExpressions(new StringBuilder(), \"speed_factor_user_statements\", speedVariables,\n+                customModel.getSpeedFactor(), lookup,\n+                num -> \"speed *= \" + num + \";\\n\", \"\"));\n+        StringBuilder codeSB = new StringBuilder(\"boolean applied = false;\\n\");\n+        speedStatements.addAll(verifyExpressions(codeSB, \"max_speed_user_statements\",\n+                speedVariables, customModel.getMaxSpeed(), lookup,\n+                num -> \"applied = true; speed = Math.min(speed,\" + num + \");\",\n+                \"if (!applied && speed > \" + maxSpeedFallback + \") return \" + maxSpeedFallback + \";\\n\" +\n+                        \"return Math.min(speed, \" + globalMaxSpeed + \");\\n\"));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTkxMzA0OA=="}, "originalCommit": {"oid": "f4478bb97c3d7585b21c39eadf45d80e57436cb3"}, "originalPosition": 133}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjI2Mzk5OA==", "bodyText": "Ok I see its more comfortable if we do not always have to specify a name. That is what I meant with 'default' namespace: It is allowed to put statements without nesting and choosing a label. But if we ever wanted to 'import' or exclude such statements in the future we could define that importing 'default' means we import everything from the top level.\nWhy do you think it would be better if super classes had to explicitly 'export' something?\nAnother thing we should consider is that currently speed and priority are lists in yaml, but what if we add the labels or need to add some special keys like:\nspeed:\n   # do we need this someday?\n   parent: ../some/other/car.yml\n   - if: ... # as before\n   # here comes a labeled group of if statements\n   avoidSmallRoads:\n       - if: #...\nDo you think we can keep speed/priority as list, but simply parse the single entries as different types, i.e.:\nspeed:\n   - parent: #...\n   - if: #...\n   - avoidSmallRoads: #...\nAh ok, but with the export/run syntax maybe this is already solved. This seems like a good idea: using a separate export section and already use it in the super model. Then using it in a sub model is just the same except it references another file. Maybe just rename run -> include then including just means text replacement.\nAre you planning to add this to this PR already?", "url": "https://github.com/graphhopper/graphhopper/pull/2209#discussion_r546263998", "createdAt": "2020-12-19T17:44:53Z", "author": {"login": "easbar"}, "path": "core/src/main/java/com/graphhopper/routing/weighting/custom/ExpressionBuilder.java", "diffHunk": "@@ -0,0 +1,379 @@\n+/*\n+ *  Licensed to GraphHopper GmbH under one or more contributor\n+ *  license agreements. See the NOTICE file distributed with this work for\n+ *  additional information regarding copyright ownership.\n+ *\n+ *  GraphHopper GmbH licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except in\n+ *  compliance with the License. You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package com.graphhopper.routing.weighting.custom;\n+\n+import com.graphhopper.json.geo.JsonFeature;\n+import com.graphhopper.routing.ev.DecimalEncodedValue;\n+import com.graphhopper.routing.ev.EncodedValue;\n+import com.graphhopper.routing.ev.EncodedValueLookup;\n+import com.graphhopper.routing.util.CustomModel;\n+import com.graphhopper.routing.util.EncodingManager;\n+import com.graphhopper.util.EdgeIteratorState;\n+import com.graphhopper.util.GHUtility;\n+import com.graphhopper.util.shapes.BBox;\n+import com.graphhopper.util.shapes.Polygon;\n+import org.codehaus.commons.compiler.CompileException;\n+import org.codehaus.commons.compiler.Location;\n+import org.codehaus.commons.compiler.io.Readers;\n+import org.codehaus.janino.Scanner;\n+import org.codehaus.janino.*;\n+import org.codehaus.janino.util.DeepCopier;\n+import org.locationtech.jts.geom.prep.PreparedGeometryFactory;\n+\n+import java.io.*;\n+import java.util.*;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+class ExpressionBuilder {\n+    private static final AtomicLong longVal = new AtomicLong(1);\n+    static final String IN_AREA_PREFIX = \"in_area_\";\n+    private static final Set<String> allowedNames = new HashSet<>(Arrays.asList(\"edge\", \"Math\"));\n+    private static final boolean JANINO_DEBUG = Boolean.getBoolean(Scanner.SYSTEM_PROPERTY_SOURCE_DEBUGGING_ENABLE);\n+\n+    // TODO without a cache we get X% slower routing and Y% slower routingLM8. CH requests and preparation is unaffected\n+    // as cached weighting from preparation is used. This cache ensures that the first Weighting classes, typically the\n+    // ones specified in the profiles, are never removed regardless of how frequent other Weightings are created and accessed.\n+    // We only need to synchronize the get and put methods alone. E.g. we do not care for the race condition where\n+    // two identical classes are requested and one of them is overwritten. We could use CachingJavaSourceClassLoader from\n+    // Janino but 1. we would need to use a single compiler across threads and 2. the statements (for priority and speed)\n+    // are still unnecessarily created.\n+    private static final int CACHE_SIZE = Integer.getInteger(\"graphhopper.custom_weighting.cache_size\", 10);\n+    // TODO perf compare with ConcurrentHashMap, but I guess, if there is a difference at all, it is not big for small maps\n+    private static final Map<String, Class> CACHE = Collections.synchronizedMap(new HashMap<>(CACHE_SIZE));\n+\n+    // Introduce a dynamic cache to remember different Weighting classes, but throw away less frequently used classes.\n+    // Use accessOrder==true to remove oldest accessed entry, not oldest inserted.\n+    private static final int DYN_CACHE_SIZE = Integer.getInteger(\"graphhopper.custom_weighting.dynamic_cache_size\", 1000);\n+    private static final Map<String, Class> DYN_CACHE = Collections.synchronizedMap(\n+            new LinkedHashMap<String, Class>(DYN_CACHE_SIZE, 0.75f, true) {\n+                protected boolean removeEldestEntry(Map.Entry eldest) {\n+                    return size() > DYN_CACHE_SIZE;\n+                }\n+            });\n+\n+    /**\n+     * This method compiles a new subclass of CustomWeightingHelper composed from the provided CustomModel caches this\n+     * and returns an instance.\n+     */\n+    static CustomWeightingHelper create(CustomModel customModel, EncodedValueLookup lookup,\n+                                        double globalMaxSpeed, double maxSpeedFallback, DecimalEncodedValue avgSpeedEnc) {\n+        Java.CompilationUnit cu;\n+        try {\n+            String key = customModel.toString() + \",global:\" + globalMaxSpeed + \",fallback:\" + maxSpeedFallback;\n+            if (key.length() > 400_000) throw new IllegalArgumentException(\"Custom Model too big: \" + key.length());\n+\n+            Class clazz = CACHE.get(key);\n+            if (DYN_CACHE_SIZE > 0 && clazz == null)\n+                clazz = DYN_CACHE.get(key);\n+            if (clazz == null) {\n+                HashSet<String> priorityVariables = new LinkedHashSet<>();\n+                List<Java.BlockStatement> priorityStatements = createGetPriorityStatements(priorityVariables, customModel, lookup);\n+                HashSet<String> speedVariables = new LinkedHashSet<>();\n+                List<Java.BlockStatement> speedStatements = createGetSpeedStatements(speedVariables, customModel, lookup, globalMaxSpeed, maxSpeedFallback);\n+                // Create different class name, which is required only for debugging.\n+                // TODO does it improve performance too? I.e. it could be that the JIT is confused if different classes\n+                //  have the same name and it mixes performance stats. See https://github.com/janino-compiler/janino/issues/137\n+                long counter = longVal.incrementAndGet();\n+                String classTemplate = createClassTemplate(counter, priorityVariables, speedVariables, lookup, customModel);\n+                cu = (Java.CompilationUnit) new Parser(new org.codehaus.janino.Scanner(\"source\", new StringReader(classTemplate))).\n+                        parseAbstractCompilationUnit();\n+                cu = injectStatements(priorityStatements, speedStatements, cu);\n+                SimpleCompiler sc = createCompiler(counter, cu);\n+                clazz = sc.getClassLoader().loadClass(\"com.graphhopper.Test\" + counter);\n+                if (CACHE.size() < CACHE_SIZE)\n+                    CACHE.put(key, clazz);\n+                else if (DYN_CACHE_SIZE > 0)\n+                    DYN_CACHE.put(key, clazz);\n+            }\n+\n+            // The class does not need to be thread-safe as we create an instance per request\n+            CustomWeightingHelper prio = (CustomWeightingHelper) clazz.getDeclaredConstructor().newInstance();\n+            prio.init(lookup, avgSpeedEnc, customModel.getAreas());\n+            return prio;\n+        } catch (Exception ex) {\n+            String location = \"\";\n+            if (ex instanceof CompileException)\n+                location = \" in \" + ((CompileException) ex).getLocation().getFileName();\n+            throw new IllegalArgumentException(\"Cannot compile expression \" + location + \", \" + ex.getMessage(), ex);\n+        }\n+    }\n+\n+    /**\n+     * Parse the expressions from CustomModel relevant for the method getSpeed - see createClassTemplate.\n+     *\n+     * @return the created statements (parsed expressions)\n+     */\n+    private static List<Java.BlockStatement> createGetSpeedStatements(Set<String> speedVariables,\n+                                                                      CustomModel customModel, EncodedValueLookup lookup,\n+                                                                      double globalMaxSpeed, double maxSpeedFallback) throws Exception {\n+        List<Java.BlockStatement> speedStatements = new ArrayList<>();\n+        speedStatements.addAll(verifyExpressions(new StringBuilder(), \"speed_factor_user_statements\", speedVariables,\n+                customModel.getSpeedFactor(), lookup,\n+                num -> \"speed *= \" + num + \";\\n\", \"\"));\n+        StringBuilder codeSB = new StringBuilder(\"boolean applied = false;\\n\");\n+        speedStatements.addAll(verifyExpressions(codeSB, \"max_speed_user_statements\",\n+                speedVariables, customModel.getMaxSpeed(), lookup,\n+                num -> \"applied = true; speed = Math.min(speed,\" + num + \");\",\n+                \"if (!applied && speed > \" + maxSpeedFallback + \") return \" + maxSpeedFallback + \";\\n\" +\n+                        \"return Math.min(speed, \" + globalMaxSpeed + \");\\n\"));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTkxMzA0OA=="}, "originalCommit": {"oid": "f4478bb97c3d7585b21c39eadf45d80e57436cb3"}, "originalPosition": 133}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODk3MzQ5Ng==", "bodyText": "Why do you think it would be better if super classes had to explicitly 'export' something?\n\nIf something is not intended for extension IMO it should not be extended or reused. Otherwise the profile author cannot make changes in speed or priority as it will likely brake something in extending profiles. (for the same reason I would prefer that the default of a class should be final ... unfortunately it isn't in Java :))\n\ndo we need this someday?\nparent: ../some/other/car.yml\n\nA better notation would be probably to include a more explicit pointer to the statement list directly like parent: car->speed or something? Because otherwise which statements should it import, from speed or priority? And due to the reason above I would allow pointing only to named statements explicitly intended for reusage like car->avoid_bridges.\n\nAh ok, but with the export/run syntax maybe this is already solved.\n\nYes\n\nMaybe just rename run -> include then including just means text replacement.\n\nYes, sounds good \ud83d\udc4d\n\nAre you planning to add this to this PR already?\n\nIMO this PR is already quite big and I would prefer to fix the missing bits. And maybe introduce the extension possibility in the next version. (One important feature before should be probably to define custom models without a separate file.)", "url": "https://github.com/graphhopper/graphhopper/pull/2209#discussion_r548973496", "createdAt": "2020-12-26T11:32:28Z", "author": {"login": "karussell"}, "path": "core/src/main/java/com/graphhopper/routing/weighting/custom/ExpressionBuilder.java", "diffHunk": "@@ -0,0 +1,379 @@\n+/*\n+ *  Licensed to GraphHopper GmbH under one or more contributor\n+ *  license agreements. See the NOTICE file distributed with this work for\n+ *  additional information regarding copyright ownership.\n+ *\n+ *  GraphHopper GmbH licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except in\n+ *  compliance with the License. You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package com.graphhopper.routing.weighting.custom;\n+\n+import com.graphhopper.json.geo.JsonFeature;\n+import com.graphhopper.routing.ev.DecimalEncodedValue;\n+import com.graphhopper.routing.ev.EncodedValue;\n+import com.graphhopper.routing.ev.EncodedValueLookup;\n+import com.graphhopper.routing.util.CustomModel;\n+import com.graphhopper.routing.util.EncodingManager;\n+import com.graphhopper.util.EdgeIteratorState;\n+import com.graphhopper.util.GHUtility;\n+import com.graphhopper.util.shapes.BBox;\n+import com.graphhopper.util.shapes.Polygon;\n+import org.codehaus.commons.compiler.CompileException;\n+import org.codehaus.commons.compiler.Location;\n+import org.codehaus.commons.compiler.io.Readers;\n+import org.codehaus.janino.Scanner;\n+import org.codehaus.janino.*;\n+import org.codehaus.janino.util.DeepCopier;\n+import org.locationtech.jts.geom.prep.PreparedGeometryFactory;\n+\n+import java.io.*;\n+import java.util.*;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+class ExpressionBuilder {\n+    private static final AtomicLong longVal = new AtomicLong(1);\n+    static final String IN_AREA_PREFIX = \"in_area_\";\n+    private static final Set<String> allowedNames = new HashSet<>(Arrays.asList(\"edge\", \"Math\"));\n+    private static final boolean JANINO_DEBUG = Boolean.getBoolean(Scanner.SYSTEM_PROPERTY_SOURCE_DEBUGGING_ENABLE);\n+\n+    // TODO without a cache we get X% slower routing and Y% slower routingLM8. CH requests and preparation is unaffected\n+    // as cached weighting from preparation is used. This cache ensures that the first Weighting classes, typically the\n+    // ones specified in the profiles, are never removed regardless of how frequent other Weightings are created and accessed.\n+    // We only need to synchronize the get and put methods alone. E.g. we do not care for the race condition where\n+    // two identical classes are requested and one of them is overwritten. We could use CachingJavaSourceClassLoader from\n+    // Janino but 1. we would need to use a single compiler across threads and 2. the statements (for priority and speed)\n+    // are still unnecessarily created.\n+    private static final int CACHE_SIZE = Integer.getInteger(\"graphhopper.custom_weighting.cache_size\", 10);\n+    // TODO perf compare with ConcurrentHashMap, but I guess, if there is a difference at all, it is not big for small maps\n+    private static final Map<String, Class> CACHE = Collections.synchronizedMap(new HashMap<>(CACHE_SIZE));\n+\n+    // Introduce a dynamic cache to remember different Weighting classes, but throw away less frequently used classes.\n+    // Use accessOrder==true to remove oldest accessed entry, not oldest inserted.\n+    private static final int DYN_CACHE_SIZE = Integer.getInteger(\"graphhopper.custom_weighting.dynamic_cache_size\", 1000);\n+    private static final Map<String, Class> DYN_CACHE = Collections.synchronizedMap(\n+            new LinkedHashMap<String, Class>(DYN_CACHE_SIZE, 0.75f, true) {\n+                protected boolean removeEldestEntry(Map.Entry eldest) {\n+                    return size() > DYN_CACHE_SIZE;\n+                }\n+            });\n+\n+    /**\n+     * This method compiles a new subclass of CustomWeightingHelper composed from the provided CustomModel caches this\n+     * and returns an instance.\n+     */\n+    static CustomWeightingHelper create(CustomModel customModel, EncodedValueLookup lookup,\n+                                        double globalMaxSpeed, double maxSpeedFallback, DecimalEncodedValue avgSpeedEnc) {\n+        Java.CompilationUnit cu;\n+        try {\n+            String key = customModel.toString() + \",global:\" + globalMaxSpeed + \",fallback:\" + maxSpeedFallback;\n+            if (key.length() > 400_000) throw new IllegalArgumentException(\"Custom Model too big: \" + key.length());\n+\n+            Class clazz = CACHE.get(key);\n+            if (DYN_CACHE_SIZE > 0 && clazz == null)\n+                clazz = DYN_CACHE.get(key);\n+            if (clazz == null) {\n+                HashSet<String> priorityVariables = new LinkedHashSet<>();\n+                List<Java.BlockStatement> priorityStatements = createGetPriorityStatements(priorityVariables, customModel, lookup);\n+                HashSet<String> speedVariables = new LinkedHashSet<>();\n+                List<Java.BlockStatement> speedStatements = createGetSpeedStatements(speedVariables, customModel, lookup, globalMaxSpeed, maxSpeedFallback);\n+                // Create different class name, which is required only for debugging.\n+                // TODO does it improve performance too? I.e. it could be that the JIT is confused if different classes\n+                //  have the same name and it mixes performance stats. See https://github.com/janino-compiler/janino/issues/137\n+                long counter = longVal.incrementAndGet();\n+                String classTemplate = createClassTemplate(counter, priorityVariables, speedVariables, lookup, customModel);\n+                cu = (Java.CompilationUnit) new Parser(new org.codehaus.janino.Scanner(\"source\", new StringReader(classTemplate))).\n+                        parseAbstractCompilationUnit();\n+                cu = injectStatements(priorityStatements, speedStatements, cu);\n+                SimpleCompiler sc = createCompiler(counter, cu);\n+                clazz = sc.getClassLoader().loadClass(\"com.graphhopper.Test\" + counter);\n+                if (CACHE.size() < CACHE_SIZE)\n+                    CACHE.put(key, clazz);\n+                else if (DYN_CACHE_SIZE > 0)\n+                    DYN_CACHE.put(key, clazz);\n+            }\n+\n+            // The class does not need to be thread-safe as we create an instance per request\n+            CustomWeightingHelper prio = (CustomWeightingHelper) clazz.getDeclaredConstructor().newInstance();\n+            prio.init(lookup, avgSpeedEnc, customModel.getAreas());\n+            return prio;\n+        } catch (Exception ex) {\n+            String location = \"\";\n+            if (ex instanceof CompileException)\n+                location = \" in \" + ((CompileException) ex).getLocation().getFileName();\n+            throw new IllegalArgumentException(\"Cannot compile expression \" + location + \", \" + ex.getMessage(), ex);\n+        }\n+    }\n+\n+    /**\n+     * Parse the expressions from CustomModel relevant for the method getSpeed - see createClassTemplate.\n+     *\n+     * @return the created statements (parsed expressions)\n+     */\n+    private static List<Java.BlockStatement> createGetSpeedStatements(Set<String> speedVariables,\n+                                                                      CustomModel customModel, EncodedValueLookup lookup,\n+                                                                      double globalMaxSpeed, double maxSpeedFallback) throws Exception {\n+        List<Java.BlockStatement> speedStatements = new ArrayList<>();\n+        speedStatements.addAll(verifyExpressions(new StringBuilder(), \"speed_factor_user_statements\", speedVariables,\n+                customModel.getSpeedFactor(), lookup,\n+                num -> \"speed *= \" + num + \";\\n\", \"\"));\n+        StringBuilder codeSB = new StringBuilder(\"boolean applied = false;\\n\");\n+        speedStatements.addAll(verifyExpressions(codeSB, \"max_speed_user_statements\",\n+                speedVariables, customModel.getMaxSpeed(), lookup,\n+                num -> \"applied = true; speed = Math.min(speed,\" + num + \");\",\n+                \"if (!applied && speed > \" + maxSpeedFallback + \") return \" + maxSpeedFallback + \";\\n\" +\n+                        \"return Math.min(speed, \" + globalMaxSpeed + \");\\n\"));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTkxMzA0OA=="}, "originalCommit": {"oid": "f4478bb97c3d7585b21c39eadf45d80e57436cb3"}, "originalPosition": 133}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDQyNDI0NA==", "bodyText": "Sounds good!\n\n(for the same reason I would prefer that the default of a class should be final ... unfortunately it isn't in Java :))\n\nJava 9 modules would allow being more explicit what does and what does not belong to the 'public' API.", "url": "https://github.com/graphhopper/graphhopper/pull/2209#discussion_r550424244", "createdAt": "2020-12-31T08:08:57Z", "author": {"login": "easbar"}, "path": "core/src/main/java/com/graphhopper/routing/weighting/custom/ExpressionBuilder.java", "diffHunk": "@@ -0,0 +1,379 @@\n+/*\n+ *  Licensed to GraphHopper GmbH under one or more contributor\n+ *  license agreements. See the NOTICE file distributed with this work for\n+ *  additional information regarding copyright ownership.\n+ *\n+ *  GraphHopper GmbH licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except in\n+ *  compliance with the License. You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package com.graphhopper.routing.weighting.custom;\n+\n+import com.graphhopper.json.geo.JsonFeature;\n+import com.graphhopper.routing.ev.DecimalEncodedValue;\n+import com.graphhopper.routing.ev.EncodedValue;\n+import com.graphhopper.routing.ev.EncodedValueLookup;\n+import com.graphhopper.routing.util.CustomModel;\n+import com.graphhopper.routing.util.EncodingManager;\n+import com.graphhopper.util.EdgeIteratorState;\n+import com.graphhopper.util.GHUtility;\n+import com.graphhopper.util.shapes.BBox;\n+import com.graphhopper.util.shapes.Polygon;\n+import org.codehaus.commons.compiler.CompileException;\n+import org.codehaus.commons.compiler.Location;\n+import org.codehaus.commons.compiler.io.Readers;\n+import org.codehaus.janino.Scanner;\n+import org.codehaus.janino.*;\n+import org.codehaus.janino.util.DeepCopier;\n+import org.locationtech.jts.geom.prep.PreparedGeometryFactory;\n+\n+import java.io.*;\n+import java.util.*;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+class ExpressionBuilder {\n+    private static final AtomicLong longVal = new AtomicLong(1);\n+    static final String IN_AREA_PREFIX = \"in_area_\";\n+    private static final Set<String> allowedNames = new HashSet<>(Arrays.asList(\"edge\", \"Math\"));\n+    private static final boolean JANINO_DEBUG = Boolean.getBoolean(Scanner.SYSTEM_PROPERTY_SOURCE_DEBUGGING_ENABLE);\n+\n+    // TODO without a cache we get X% slower routing and Y% slower routingLM8. CH requests and preparation is unaffected\n+    // as cached weighting from preparation is used. This cache ensures that the first Weighting classes, typically the\n+    // ones specified in the profiles, are never removed regardless of how frequent other Weightings are created and accessed.\n+    // We only need to synchronize the get and put methods alone. E.g. we do not care for the race condition where\n+    // two identical classes are requested and one of them is overwritten. We could use CachingJavaSourceClassLoader from\n+    // Janino but 1. we would need to use a single compiler across threads and 2. the statements (for priority and speed)\n+    // are still unnecessarily created.\n+    private static final int CACHE_SIZE = Integer.getInteger(\"graphhopper.custom_weighting.cache_size\", 10);\n+    // TODO perf compare with ConcurrentHashMap, but I guess, if there is a difference at all, it is not big for small maps\n+    private static final Map<String, Class> CACHE = Collections.synchronizedMap(new HashMap<>(CACHE_SIZE));\n+\n+    // Introduce a dynamic cache to remember different Weighting classes, but throw away less frequently used classes.\n+    // Use accessOrder==true to remove oldest accessed entry, not oldest inserted.\n+    private static final int DYN_CACHE_SIZE = Integer.getInteger(\"graphhopper.custom_weighting.dynamic_cache_size\", 1000);\n+    private static final Map<String, Class> DYN_CACHE = Collections.synchronizedMap(\n+            new LinkedHashMap<String, Class>(DYN_CACHE_SIZE, 0.75f, true) {\n+                protected boolean removeEldestEntry(Map.Entry eldest) {\n+                    return size() > DYN_CACHE_SIZE;\n+                }\n+            });\n+\n+    /**\n+     * This method compiles a new subclass of CustomWeightingHelper composed from the provided CustomModel caches this\n+     * and returns an instance.\n+     */\n+    static CustomWeightingHelper create(CustomModel customModel, EncodedValueLookup lookup,\n+                                        double globalMaxSpeed, double maxSpeedFallback, DecimalEncodedValue avgSpeedEnc) {\n+        Java.CompilationUnit cu;\n+        try {\n+            String key = customModel.toString() + \",global:\" + globalMaxSpeed + \",fallback:\" + maxSpeedFallback;\n+            if (key.length() > 400_000) throw new IllegalArgumentException(\"Custom Model too big: \" + key.length());\n+\n+            Class clazz = CACHE.get(key);\n+            if (DYN_CACHE_SIZE > 0 && clazz == null)\n+                clazz = DYN_CACHE.get(key);\n+            if (clazz == null) {\n+                HashSet<String> priorityVariables = new LinkedHashSet<>();\n+                List<Java.BlockStatement> priorityStatements = createGetPriorityStatements(priorityVariables, customModel, lookup);\n+                HashSet<String> speedVariables = new LinkedHashSet<>();\n+                List<Java.BlockStatement> speedStatements = createGetSpeedStatements(speedVariables, customModel, lookup, globalMaxSpeed, maxSpeedFallback);\n+                // Create different class name, which is required only for debugging.\n+                // TODO does it improve performance too? I.e. it could be that the JIT is confused if different classes\n+                //  have the same name and it mixes performance stats. See https://github.com/janino-compiler/janino/issues/137\n+                long counter = longVal.incrementAndGet();\n+                String classTemplate = createClassTemplate(counter, priorityVariables, speedVariables, lookup, customModel);\n+                cu = (Java.CompilationUnit) new Parser(new org.codehaus.janino.Scanner(\"source\", new StringReader(classTemplate))).\n+                        parseAbstractCompilationUnit();\n+                cu = injectStatements(priorityStatements, speedStatements, cu);\n+                SimpleCompiler sc = createCompiler(counter, cu);\n+                clazz = sc.getClassLoader().loadClass(\"com.graphhopper.Test\" + counter);\n+                if (CACHE.size() < CACHE_SIZE)\n+                    CACHE.put(key, clazz);\n+                else if (DYN_CACHE_SIZE > 0)\n+                    DYN_CACHE.put(key, clazz);\n+            }\n+\n+            // The class does not need to be thread-safe as we create an instance per request\n+            CustomWeightingHelper prio = (CustomWeightingHelper) clazz.getDeclaredConstructor().newInstance();\n+            prio.init(lookup, avgSpeedEnc, customModel.getAreas());\n+            return prio;\n+        } catch (Exception ex) {\n+            String location = \"\";\n+            if (ex instanceof CompileException)\n+                location = \" in \" + ((CompileException) ex).getLocation().getFileName();\n+            throw new IllegalArgumentException(\"Cannot compile expression \" + location + \", \" + ex.getMessage(), ex);\n+        }\n+    }\n+\n+    /**\n+     * Parse the expressions from CustomModel relevant for the method getSpeed - see createClassTemplate.\n+     *\n+     * @return the created statements (parsed expressions)\n+     */\n+    private static List<Java.BlockStatement> createGetSpeedStatements(Set<String> speedVariables,\n+                                                                      CustomModel customModel, EncodedValueLookup lookup,\n+                                                                      double globalMaxSpeed, double maxSpeedFallback) throws Exception {\n+        List<Java.BlockStatement> speedStatements = new ArrayList<>();\n+        speedStatements.addAll(verifyExpressions(new StringBuilder(), \"speed_factor_user_statements\", speedVariables,\n+                customModel.getSpeedFactor(), lookup,\n+                num -> \"speed *= \" + num + \";\\n\", \"\"));\n+        StringBuilder codeSB = new StringBuilder(\"boolean applied = false;\\n\");\n+        speedStatements.addAll(verifyExpressions(codeSB, \"max_speed_user_statements\",\n+                speedVariables, customModel.getMaxSpeed(), lookup,\n+                num -> \"applied = true; speed = Math.min(speed,\" + num + \");\",\n+                \"if (!applied && speed > \" + maxSpeedFallback + \") return \" + maxSpeedFallback + \";\\n\" +\n+                        \"return Math.min(speed, \" + globalMaxSpeed + \");\\n\"));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTkxMzA0OA=="}, "originalCommit": {"oid": "f4478bb97c3d7585b21c39eadf45d80e57436cb3"}, "originalPosition": 133}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQwNDE3MTU4OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/com/graphhopper/routing/weighting/custom/ExpressionBuilder.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xM1QxMjo0MDo1OVrOIE0Btg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xM1QxMjo0MDo1OVrOIE0Btg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTkxNzYyMg==", "bodyText": "I would put a private constructor here to make it clear that this class is just a collection of static methods (if this is what it is supposed to be).", "url": "https://github.com/graphhopper/graphhopper/pull/2209#discussion_r541917622", "createdAt": "2020-12-13T12:40:59Z", "author": {"login": "easbar"}, "path": "core/src/main/java/com/graphhopper/routing/weighting/custom/ExpressionBuilder.java", "diffHunk": "@@ -0,0 +1,379 @@\n+/*\n+ *  Licensed to GraphHopper GmbH under one or more contributor\n+ *  license agreements. See the NOTICE file distributed with this work for\n+ *  additional information regarding copyright ownership.\n+ *\n+ *  GraphHopper GmbH licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except in\n+ *  compliance with the License. You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package com.graphhopper.routing.weighting.custom;\n+\n+import com.graphhopper.json.geo.JsonFeature;\n+import com.graphhopper.routing.ev.DecimalEncodedValue;\n+import com.graphhopper.routing.ev.EncodedValue;\n+import com.graphhopper.routing.ev.EncodedValueLookup;\n+import com.graphhopper.routing.util.CustomModel;\n+import com.graphhopper.routing.util.EncodingManager;\n+import com.graphhopper.util.EdgeIteratorState;\n+import com.graphhopper.util.GHUtility;\n+import com.graphhopper.util.shapes.BBox;\n+import com.graphhopper.util.shapes.Polygon;\n+import org.codehaus.commons.compiler.CompileException;\n+import org.codehaus.commons.compiler.Location;\n+import org.codehaus.commons.compiler.io.Readers;\n+import org.codehaus.janino.Scanner;\n+import org.codehaus.janino.*;\n+import org.codehaus.janino.util.DeepCopier;\n+import org.locationtech.jts.geom.prep.PreparedGeometryFactory;\n+\n+import java.io.*;\n+import java.util.*;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+class ExpressionBuilder {\n+    private static final AtomicLong longVal = new AtomicLong(1);\n+    static final String IN_AREA_PREFIX = \"in_area_\";\n+    private static final Set<String> allowedNames = new HashSet<>(Arrays.asList(\"edge\", \"Math\"));\n+    private static final boolean JANINO_DEBUG = Boolean.getBoolean(Scanner.SYSTEM_PROPERTY_SOURCE_DEBUGGING_ENABLE);\n+\n+    // TODO without a cache we get X% slower routing and Y% slower routingLM8. CH requests and preparation is unaffected\n+    // as cached weighting from preparation is used. This cache ensures that the first Weighting classes, typically the\n+    // ones specified in the profiles, are never removed regardless of how frequent other Weightings are created and accessed.\n+    // We only need to synchronize the get and put methods alone. E.g. we do not care for the race condition where\n+    // two identical classes are requested and one of them is overwritten. We could use CachingJavaSourceClassLoader from\n+    // Janino but 1. we would need to use a single compiler across threads and 2. the statements (for priority and speed)\n+    // are still unnecessarily created.\n+    private static final int CACHE_SIZE = Integer.getInteger(\"graphhopper.custom_weighting.cache_size\", 10);\n+    // TODO perf compare with ConcurrentHashMap, but I guess, if there is a difference at all, it is not big for small maps\n+    private static final Map<String, Class> CACHE = Collections.synchronizedMap(new HashMap<>(CACHE_SIZE));\n+\n+    // Introduce a dynamic cache to remember different Weighting classes, but throw away less frequently used classes.\n+    // Use accessOrder==true to remove oldest accessed entry, not oldest inserted.\n+    private static final int DYN_CACHE_SIZE = Integer.getInteger(\"graphhopper.custom_weighting.dynamic_cache_size\", 1000);\n+    private static final Map<String, Class> DYN_CACHE = Collections.synchronizedMap(\n+            new LinkedHashMap<String, Class>(DYN_CACHE_SIZE, 0.75f, true) {\n+                protected boolean removeEldestEntry(Map.Entry eldest) {\n+                    return size() > DYN_CACHE_SIZE;\n+                }\n+            });\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f4478bb97c3d7585b21c39eadf45d80e57436cb3"}, "originalPosition": 68}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQwNDIwMDc4OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/com/graphhopper/routing/weighting/custom/CustomWeightingHelper.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xM1QxMzowMDozNlrOIE0OtA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNFQxMTo1ODo1M1rOIFNMhg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTkyMDk0OA==", "bodyText": "We discussed where to place this method in another comment, but it seems this is not even used?", "url": "https://github.com/graphhopper/graphhopper/pull/2209#discussion_r541920948", "createdAt": "2020-12-13T13:00:36Z", "author": {"login": "easbar"}, "path": "core/src/main/java/com/graphhopper/routing/weighting/custom/CustomWeightingHelper.java", "diffHunk": "@@ -0,0 +1,67 @@\n+/*\n+ *  Licensed to GraphHopper GmbH under one or more contributor\n+ *  license agreements. See the NOTICE file distributed with this work for\n+ *  additional information regarding copyright ownership.\n+ *\n+ *  GraphHopper GmbH licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except in\n+ *  compliance with the License. You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package com.graphhopper.routing.weighting.custom;\n+\n+import com.graphhopper.json.geo.JsonFeature;\n+import com.graphhopper.routing.ev.DecimalEncodedValue;\n+import com.graphhopper.routing.ev.EncodedValueLookup;\n+import com.graphhopper.util.EdgeIteratorState;\n+import com.graphhopper.util.FetchMode;\n+import com.graphhopper.util.GHUtility;\n+import com.graphhopper.util.shapes.BBox;\n+import com.graphhopper.util.shapes.Polygon;\n+\n+import java.util.Map;\n+\n+/**\n+ * This class is for internal usage only. It is subclassed by Janino, then special expressions are injected into init,\n+ * getSpeed and getPriority. At the end an instance is created and used in CustomWeighting.\n+ */\n+public class CustomWeightingHelper {\n+    protected DecimalEncodedValue avg_speed_enc;\n+    protected static boolean DEFAULT = true;\n+\n+    protected CustomWeightingHelper() {\n+    }\n+\n+    public void init(EncodedValueLookup lookup, DecimalEncodedValue avgSpeedEnc, Map<String, JsonFeature> areas) {\n+        this.avg_speed_enc = avgSpeedEnc;\n+    }\n+\n+    public double getPriority(EdgeIteratorState edge, boolean reverse) {\n+        return 1;\n+    }\n+\n+    public double getSpeed(EdgeIteratorState edge, boolean reverse) {\n+        return getRawSpeed(edge, reverse);\n+    }\n+\n+    protected final double getRawSpeed(EdgeIteratorState edge, boolean reverse) {\n+        double speed = reverse ? edge.getReverse(avg_speed_enc) : edge.get(avg_speed_enc);\n+        if (Double.isInfinite(speed) || Double.isNaN(speed) || speed < 0)\n+            throw new IllegalStateException(\"Invalid estimated speed \" + speed);\n+        return speed;\n+    }\n+\n+    public static boolean in(Polygon p, EdgeIteratorState edge) {\n+        BBox bbox = GHUtility.createBBox(edge);\n+        if (p.getBounds().intersects(bbox))\n+            return p.intersects(edge.fetchWayGeometry(FetchMode.ALL).makeImmutable()); // TODO PERF: cache bbox and edge wayGeometry for multiple area\n+        return false;\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f4478bb97c3d7585b21c39eadf45d80e57436cb3"}, "originalPosition": 66}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjMwNzgyMg==", "bodyText": "It is used inside the generated script when areas are involved. And the script has access to this method because it is a subclass. The \"script\" is currently called Test -> will rename it to CustomWeightingHelperSubclass?", "url": "https://github.com/graphhopper/graphhopper/pull/2209#discussion_r542307822", "createdAt": "2020-12-14T11:20:20Z", "author": {"login": "karussell"}, "path": "core/src/main/java/com/graphhopper/routing/weighting/custom/CustomWeightingHelper.java", "diffHunk": "@@ -0,0 +1,67 @@\n+/*\n+ *  Licensed to GraphHopper GmbH under one or more contributor\n+ *  license agreements. See the NOTICE file distributed with this work for\n+ *  additional information regarding copyright ownership.\n+ *\n+ *  GraphHopper GmbH licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except in\n+ *  compliance with the License. You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package com.graphhopper.routing.weighting.custom;\n+\n+import com.graphhopper.json.geo.JsonFeature;\n+import com.graphhopper.routing.ev.DecimalEncodedValue;\n+import com.graphhopper.routing.ev.EncodedValueLookup;\n+import com.graphhopper.util.EdgeIteratorState;\n+import com.graphhopper.util.FetchMode;\n+import com.graphhopper.util.GHUtility;\n+import com.graphhopper.util.shapes.BBox;\n+import com.graphhopper.util.shapes.Polygon;\n+\n+import java.util.Map;\n+\n+/**\n+ * This class is for internal usage only. It is subclassed by Janino, then special expressions are injected into init,\n+ * getSpeed and getPriority. At the end an instance is created and used in CustomWeighting.\n+ */\n+public class CustomWeightingHelper {\n+    protected DecimalEncodedValue avg_speed_enc;\n+    protected static boolean DEFAULT = true;\n+\n+    protected CustomWeightingHelper() {\n+    }\n+\n+    public void init(EncodedValueLookup lookup, DecimalEncodedValue avgSpeedEnc, Map<String, JsonFeature> areas) {\n+        this.avg_speed_enc = avgSpeedEnc;\n+    }\n+\n+    public double getPriority(EdgeIteratorState edge, boolean reverse) {\n+        return 1;\n+    }\n+\n+    public double getSpeed(EdgeIteratorState edge, boolean reverse) {\n+        return getRawSpeed(edge, reverse);\n+    }\n+\n+    protected final double getRawSpeed(EdgeIteratorState edge, boolean reverse) {\n+        double speed = reverse ? edge.getReverse(avg_speed_enc) : edge.get(avg_speed_enc);\n+        if (Double.isInfinite(speed) || Double.isNaN(speed) || speed < 0)\n+            throw new IllegalStateException(\"Invalid estimated speed \" + speed);\n+        return speed;\n+    }\n+\n+    public static boolean in(Polygon p, EdgeIteratorState edge) {\n+        BBox bbox = GHUtility.createBBox(edge);\n+        if (p.getBounds().intersects(bbox))\n+            return p.intersects(edge.fetchWayGeometry(FetchMode.ALL).makeImmutable()); // TODO PERF: cache bbox and edge wayGeometry for multiple area\n+        return false;\n+    }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTkyMDk0OA=="}, "originalCommit": {"oid": "f4478bb97c3d7585b21c39eadf45d80e57436cb3"}, "originalPosition": 66}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjMyMzUzMA==", "bodyText": "Where? I tried finding this via text search but could not find it.\n\nCustomWeightingHelperSubclass\n\nI like this better than Test but it still doesn't say much. Maybe include Janino?", "url": "https://github.com/graphhopper/graphhopper/pull/2209#discussion_r542323530", "createdAt": "2020-12-14T11:47:29Z", "author": {"login": "easbar"}, "path": "core/src/main/java/com/graphhopper/routing/weighting/custom/CustomWeightingHelper.java", "diffHunk": "@@ -0,0 +1,67 @@\n+/*\n+ *  Licensed to GraphHopper GmbH under one or more contributor\n+ *  license agreements. See the NOTICE file distributed with this work for\n+ *  additional information regarding copyright ownership.\n+ *\n+ *  GraphHopper GmbH licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except in\n+ *  compliance with the License. You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package com.graphhopper.routing.weighting.custom;\n+\n+import com.graphhopper.json.geo.JsonFeature;\n+import com.graphhopper.routing.ev.DecimalEncodedValue;\n+import com.graphhopper.routing.ev.EncodedValueLookup;\n+import com.graphhopper.util.EdgeIteratorState;\n+import com.graphhopper.util.FetchMode;\n+import com.graphhopper.util.GHUtility;\n+import com.graphhopper.util.shapes.BBox;\n+import com.graphhopper.util.shapes.Polygon;\n+\n+import java.util.Map;\n+\n+/**\n+ * This class is for internal usage only. It is subclassed by Janino, then special expressions are injected into init,\n+ * getSpeed and getPriority. At the end an instance is created and used in CustomWeighting.\n+ */\n+public class CustomWeightingHelper {\n+    protected DecimalEncodedValue avg_speed_enc;\n+    protected static boolean DEFAULT = true;\n+\n+    protected CustomWeightingHelper() {\n+    }\n+\n+    public void init(EncodedValueLookup lookup, DecimalEncodedValue avgSpeedEnc, Map<String, JsonFeature> areas) {\n+        this.avg_speed_enc = avgSpeedEnc;\n+    }\n+\n+    public double getPriority(EdgeIteratorState edge, boolean reverse) {\n+        return 1;\n+    }\n+\n+    public double getSpeed(EdgeIteratorState edge, boolean reverse) {\n+        return getRawSpeed(edge, reverse);\n+    }\n+\n+    protected final double getRawSpeed(EdgeIteratorState edge, boolean reverse) {\n+        double speed = reverse ? edge.getReverse(avg_speed_enc) : edge.get(avg_speed_enc);\n+        if (Double.isInfinite(speed) || Double.isNaN(speed) || speed < 0)\n+            throw new IllegalStateException(\"Invalid estimated speed \" + speed);\n+        return speed;\n+    }\n+\n+    public static boolean in(Polygon p, EdgeIteratorState edge) {\n+        BBox bbox = GHUtility.createBBox(edge);\n+        if (p.getBounds().intersects(bbox))\n+            return p.intersects(edge.fetchWayGeometry(FetchMode.ALL).makeImmutable()); // TODO PERF: cache bbox and edge wayGeometry for multiple area\n+        return false;\n+    }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTkyMDk0OA=="}, "originalCommit": {"oid": "f4478bb97c3d7585b21c39eadf45d80e57436cb3"}, "originalPosition": 66}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjMyOTk5MA==", "bodyText": "Ok\n\nWhere? I tried finding this via text search but could not find it.\n\nSee e.g. CustomWeightingTest.testArea there we use in_area_custom1 and such a variable is replaced with the method call, see ExpressionVisitor -> injects. See also dc4268a where I moved from:\ngetSpeed(...) {\n  boolean in_area_custom1 = areas.get(\"custom1\"); // area_custom1 is initialized in the init method via areas.get(\"custom1\")\n  double speed = /*getSpeed from edge*/;\n\n  // now in_area_custom1 can be used as boolean variable\n  if (some_expression && in_area_custom1) \n     speed *= 0.5;\n\n  return speed;\n}\nto\ngetSpeed(...) {\n  double speed = /*getSpeed from edge*/;\n\n  // call in method directly so we call it only if some_expression == true\n  if (some_expression && in(in_area_custom1, edge)) \n    speed *= 0.5;\n\n  return speed;\n}", "url": "https://github.com/graphhopper/graphhopper/pull/2209#discussion_r542329990", "createdAt": "2020-12-14T11:58:53Z", "author": {"login": "karussell"}, "path": "core/src/main/java/com/graphhopper/routing/weighting/custom/CustomWeightingHelper.java", "diffHunk": "@@ -0,0 +1,67 @@\n+/*\n+ *  Licensed to GraphHopper GmbH under one or more contributor\n+ *  license agreements. See the NOTICE file distributed with this work for\n+ *  additional information regarding copyright ownership.\n+ *\n+ *  GraphHopper GmbH licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except in\n+ *  compliance with the License. You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package com.graphhopper.routing.weighting.custom;\n+\n+import com.graphhopper.json.geo.JsonFeature;\n+import com.graphhopper.routing.ev.DecimalEncodedValue;\n+import com.graphhopper.routing.ev.EncodedValueLookup;\n+import com.graphhopper.util.EdgeIteratorState;\n+import com.graphhopper.util.FetchMode;\n+import com.graphhopper.util.GHUtility;\n+import com.graphhopper.util.shapes.BBox;\n+import com.graphhopper.util.shapes.Polygon;\n+\n+import java.util.Map;\n+\n+/**\n+ * This class is for internal usage only. It is subclassed by Janino, then special expressions are injected into init,\n+ * getSpeed and getPriority. At the end an instance is created and used in CustomWeighting.\n+ */\n+public class CustomWeightingHelper {\n+    protected DecimalEncodedValue avg_speed_enc;\n+    protected static boolean DEFAULT = true;\n+\n+    protected CustomWeightingHelper() {\n+    }\n+\n+    public void init(EncodedValueLookup lookup, DecimalEncodedValue avgSpeedEnc, Map<String, JsonFeature> areas) {\n+        this.avg_speed_enc = avgSpeedEnc;\n+    }\n+\n+    public double getPriority(EdgeIteratorState edge, boolean reverse) {\n+        return 1;\n+    }\n+\n+    public double getSpeed(EdgeIteratorState edge, boolean reverse) {\n+        return getRawSpeed(edge, reverse);\n+    }\n+\n+    protected final double getRawSpeed(EdgeIteratorState edge, boolean reverse) {\n+        double speed = reverse ? edge.getReverse(avg_speed_enc) : edge.get(avg_speed_enc);\n+        if (Double.isInfinite(speed) || Double.isNaN(speed) || speed < 0)\n+            throw new IllegalStateException(\"Invalid estimated speed \" + speed);\n+        return speed;\n+    }\n+\n+    public static boolean in(Polygon p, EdgeIteratorState edge) {\n+        BBox bbox = GHUtility.createBBox(edge);\n+        if (p.getBounds().intersects(bbox))\n+            return p.intersects(edge.fetchWayGeometry(FetchMode.ALL).makeImmutable()); // TODO PERF: cache bbox and edge wayGeometry for multiple area\n+        return false;\n+    }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTkyMDk0OA=="}, "originalCommit": {"oid": "f4478bb97c3d7585b21c39eadf45d80e57436cb3"}, "originalPosition": 66}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQwODE5MTE0OnYy", "diffSide": "LEFT", "path": "core/src/test/java/com/graphhopper/routing/weighting/custom/ExpressionBuilderTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNFQxNTowOToyMVrOIFVBRg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNFQxNzo0Nzo1N1rOIFcmEA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjQ1ODE4Mg==", "bodyText": "Any special reason you included this code in test too?", "url": "https://github.com/graphhopper/graphhopper/pull/2209#discussion_r542458182", "createdAt": "2020-12-14T15:09:21Z", "author": {"login": "karussell"}, "path": "core/src/test/java/com/graphhopper/routing/weighting/custom/ExpressionBuilderTest.java", "diffHunk": "@@ -37,9 +37,8 @@ void setPriorityForRoadClass() {\n         EncodingManager encodingManager = EncodingManager.create(encoder);\n         CustomModel customModel = new CustomModel();\n         customModel.getPriority().put(\"road_class == PRIMARY\", 0.5);\n-        // todo: can we get rid of this line here?\n-        double maxSpeedFallback = customModel.getMaxSpeedFallback() == null ? encoder.getMaxSpeed() : customModel.getMaxSpeedFallback();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "449278b6ffa7652b0633383fe3ee9fbe7ee437ee"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjU4MjI4OA==", "bodyText": "Yes this line is in CustomWeighting#create currently. I was hoping to be able to move it into ExpressionBuilder#create so I do not have to repeat it here.\nThese two lines:\ndouble maxSpeedTmp = customModel.getMaxSpeedFallback() == null ? baseFlagEncoder.getMaxSpeed() : customModel.getMaxSpeedFallback();\nSpeedAndAccessProvider speedAndAccessProvider = ExpressionBuilder.create(customModel, lookup, baseFlagEncoder.getMaxSpeed(), maxSpeedTmp, baseFlagEncoder.getAverageSpeedEnc());\nlook like redundant information is passed to ExpressionBuilder#create: maxSpeedTmp is just a combination of customModel and baseFlagEncoder.getMaxSpeed(). But we pass all three to ExpressionBuilder. I think I wanted to clean this up, but then we were not sure anymore if maxSpeedFallback is even needed (see other comment).", "url": "https://github.com/graphhopper/graphhopper/pull/2209#discussion_r542582288", "createdAt": "2020-12-14T17:47:57Z", "author": {"login": "easbar"}, "path": "core/src/test/java/com/graphhopper/routing/weighting/custom/ExpressionBuilderTest.java", "diffHunk": "@@ -37,9 +37,8 @@ void setPriorityForRoadClass() {\n         EncodingManager encodingManager = EncodingManager.create(encoder);\n         CustomModel customModel = new CustomModel();\n         customModel.getPriority().put(\"road_class == PRIMARY\", 0.5);\n-        // todo: can we get rid of this line here?\n-        double maxSpeedFallback = customModel.getMaxSpeedFallback() == null ? encoder.getMaxSpeed() : customModel.getMaxSpeedFallback();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjQ1ODE4Mg=="}, "originalCommit": {"oid": "449278b6ffa7652b0633383fe3ee9fbe7ee437ee"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQwODI3ODkyOnYy", "diffSide": "RIGHT", "path": "core/src/main/java/com/graphhopper/routing/weighting/custom/CustomWeighting.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNFQxNToyNTo0N1rOIFV1yA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNFQxNToyNTo0N1rOIFV1yA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjQ3MTYyNA==", "bodyText": "much simpler now - thanks :)\nNot sure why I used this applied stuff before", "url": "https://github.com/graphhopper/graphhopper/pull/2209#discussion_r542471624", "createdAt": "2020-12-14T15:25:47Z", "author": {"login": "karussell"}, "path": "core/src/main/java/com/graphhopper/routing/weighting/custom/CustomWeighting.java", "diffHunk": "@@ -93,12 +93,16 @@ public static CustomWeighting create(FlagEncoder baseFlagEncoder, EncodedValueLo\n                                          CustomModel customModel) {\n         if (customModel == null)\n             throw new IllegalStateException(\"CustomModel cannot be null\");\n-        if (customModel.getMaxSpeedFallback() != null && customModel.getMaxSpeedFallback() > baseFlagEncoder.getMaxSpeed())\n-            throw new IllegalArgumentException(\"max_speed_fallback cannot be bigger than max_speed \" + baseFlagEncoder.getMaxSpeed());\n-        double maxSpeedTmp = customModel.getMaxSpeedFallback() == null ? baseFlagEncoder.getMaxSpeed() : customModel.getMaxSpeedFallback();\n-        SpeedAndAccessProvider speedAndAccessProvider = ExpressionBuilder.create(customModel, lookup, baseFlagEncoder.getMaxSpeed(), maxSpeedTmp, baseFlagEncoder.getAverageSpeedEnc());\n+        double globalMaxSpeed = baseFlagEncoder.getMaxSpeed();\n+        if (customModel.getMaxSpeedFallback() != null) {\n+            if (customModel.getMaxSpeedFallback() > globalMaxSpeed)\n+                throw new IllegalArgumentException(\"max_speed_fallback cannot be bigger than max_speed \" + globalMaxSpeed);\n+            globalMaxSpeed = customModel.getMaxSpeedFallback();\n+        }\n+\n+        SpeedAndAccessProvider speedAndAccessProvider = ExpressionBuilder.create(customModel, lookup, globalMaxSpeed, baseFlagEncoder.getAverageSpeedEnc());\n         Parameters parameters = new Parameters(speedAndAccessProvider::getSpeed, speedAndAccessProvider::getPriority,\n-                maxSpeedTmp, customModel.getDistanceInfluence(), customModel.getHeadingPenalty());\n+                globalMaxSpeed, customModel.getDistanceInfluence(), customModel.getHeadingPenalty());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7bf5b21c100ccd7db7fcb21424dba044b5f4d9fa"}, "originalPosition": 18}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQwODI4ODczOnYy", "diffSide": "RIGHT", "path": "core/src/main/java/com/graphhopper/routing/weighting/custom/CustomWeighting.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNFQxNToyNzoyM1rOIFV7VA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNlQwODo0OToyOVrOIG6PJA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjQ3MzA0NA==", "bodyText": "Should we throw an exception at all or just ignore MaxSpeedFallback in that case?", "url": "https://github.com/graphhopper/graphhopper/pull/2209#discussion_r542473044", "createdAt": "2020-12-14T15:27:23Z", "author": {"login": "karussell"}, "path": "core/src/main/java/com/graphhopper/routing/weighting/custom/CustomWeighting.java", "diffHunk": "@@ -93,12 +93,16 @@ public static CustomWeighting create(FlagEncoder baseFlagEncoder, EncodedValueLo\n                                          CustomModel customModel) {\n         if (customModel == null)\n             throw new IllegalStateException(\"CustomModel cannot be null\");\n-        if (customModel.getMaxSpeedFallback() != null && customModel.getMaxSpeedFallback() > baseFlagEncoder.getMaxSpeed())\n-            throw new IllegalArgumentException(\"max_speed_fallback cannot be bigger than max_speed \" + baseFlagEncoder.getMaxSpeed());\n-        double maxSpeedTmp = customModel.getMaxSpeedFallback() == null ? baseFlagEncoder.getMaxSpeed() : customModel.getMaxSpeedFallback();\n-        SpeedAndAccessProvider speedAndAccessProvider = ExpressionBuilder.create(customModel, lookup, baseFlagEncoder.getMaxSpeed(), maxSpeedTmp, baseFlagEncoder.getAverageSpeedEnc());\n+        double globalMaxSpeed = baseFlagEncoder.getMaxSpeed();\n+        if (customModel.getMaxSpeedFallback() != null) {\n+            if (customModel.getMaxSpeedFallback() > globalMaxSpeed)\n+                throw new IllegalArgumentException(\"max_speed_fallback cannot be bigger than max_speed \" + globalMaxSpeed);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7bf5b21c100ccd7db7fcb21424dba044b5f4d9fa"}, "originalPosition": 11}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjU4Mzk4Ng==", "bodyText": "I still think we should remove maxSpeedFallback entirely and derive it from the custom model (see other comment).", "url": "https://github.com/graphhopper/graphhopper/pull/2209#discussion_r542583986", "createdAt": "2020-12-14T17:50:28Z", "author": {"login": "easbar"}, "path": "core/src/main/java/com/graphhopper/routing/weighting/custom/CustomWeighting.java", "diffHunk": "@@ -93,12 +93,16 @@ public static CustomWeighting create(FlagEncoder baseFlagEncoder, EncodedValueLo\n                                          CustomModel customModel) {\n         if (customModel == null)\n             throw new IllegalStateException(\"CustomModel cannot be null\");\n-        if (customModel.getMaxSpeedFallback() != null && customModel.getMaxSpeedFallback() > baseFlagEncoder.getMaxSpeed())\n-            throw new IllegalArgumentException(\"max_speed_fallback cannot be bigger than max_speed \" + baseFlagEncoder.getMaxSpeed());\n-        double maxSpeedTmp = customModel.getMaxSpeedFallback() == null ? baseFlagEncoder.getMaxSpeed() : customModel.getMaxSpeedFallback();\n-        SpeedAndAccessProvider speedAndAccessProvider = ExpressionBuilder.create(customModel, lookup, baseFlagEncoder.getMaxSpeed(), maxSpeedTmp, baseFlagEncoder.getAverageSpeedEnc());\n+        double globalMaxSpeed = baseFlagEncoder.getMaxSpeed();\n+        if (customModel.getMaxSpeedFallback() != null) {\n+            if (customModel.getMaxSpeedFallback() > globalMaxSpeed)\n+                throw new IllegalArgumentException(\"max_speed_fallback cannot be bigger than max_speed \" + globalMaxSpeed);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjQ3MzA0NA=="}, "originalCommit": {"oid": "7bf5b21c100ccd7db7fcb21424dba044b5f4d9fa"}, "originalPosition": 11}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDExNjUxNg==", "bodyText": "Ah but in case a speed larger than the base encoder speed  is specified we should raise an error I think. Otherwise it would be hard to understand why setting a too high speed yields no effect?", "url": "https://github.com/graphhopper/graphhopper/pull/2209#discussion_r544116516", "createdAt": "2020-12-16T08:49:29Z", "author": {"login": "easbar"}, "path": "core/src/main/java/com/graphhopper/routing/weighting/custom/CustomWeighting.java", "diffHunk": "@@ -93,12 +93,16 @@ public static CustomWeighting create(FlagEncoder baseFlagEncoder, EncodedValueLo\n                                          CustomModel customModel) {\n         if (customModel == null)\n             throw new IllegalStateException(\"CustomModel cannot be null\");\n-        if (customModel.getMaxSpeedFallback() != null && customModel.getMaxSpeedFallback() > baseFlagEncoder.getMaxSpeed())\n-            throw new IllegalArgumentException(\"max_speed_fallback cannot be bigger than max_speed \" + baseFlagEncoder.getMaxSpeed());\n-        double maxSpeedTmp = customModel.getMaxSpeedFallback() == null ? baseFlagEncoder.getMaxSpeed() : customModel.getMaxSpeedFallback();\n-        SpeedAndAccessProvider speedAndAccessProvider = ExpressionBuilder.create(customModel, lookup, baseFlagEncoder.getMaxSpeed(), maxSpeedTmp, baseFlagEncoder.getAverageSpeedEnc());\n+        double globalMaxSpeed = baseFlagEncoder.getMaxSpeed();\n+        if (customModel.getMaxSpeedFallback() != null) {\n+            if (customModel.getMaxSpeedFallback() > globalMaxSpeed)\n+                throw new IllegalArgumentException(\"max_speed_fallback cannot be bigger than max_speed \" + globalMaxSpeed);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjQ3MzA0NA=="}, "originalCommit": {"oid": "7bf5b21c100ccd7db7fcb21424dba044b5f4d9fa"}, "originalPosition": 11}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQzMDk0NDQzOnYy", "diffSide": "RIGHT", "path": "core/src/test/java/com/graphhopper/routing/util/CustomModelTest.java", "isResolved": true, "comments": {"totalCount": 10, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xOFQxNDoxNDo1M1rOIIkcUA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xOFQxNzowNzowOFrOIIrP4Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTg1NjU5Mg==", "bodyText": "Can we use shorter method names here: Clause.if instead of Clause.createIf etc.? Since this will be used a lot in a rather repetitive way when setting up custom models via Java shorter is better here IMO.", "url": "https://github.com/graphhopper/graphhopper/pull/2209#discussion_r545856592", "createdAt": "2020-12-18T14:14:53Z", "author": {"login": "easbar"}, "path": "core/src/test/java/com/graphhopper/routing/util/CustomModelTest.java", "diffHunk": "@@ -18,94 +18,66 @@\n \n package com.graphhopper.routing.util;\n \n+import com.graphhopper.json.Clause;\n import org.junit.jupiter.api.Test;\n \n-import java.util.HashMap;\n-import java.util.Map;\n+import java.util.Iterator;\n \n-import static org.junit.jupiter.api.Assertions.*;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n \n public class CustomModelTest {\n \n-    static CustomModel setValue(CustomModel model, String op, String encodedValue, double value) {\n-        Map<String, Object> map = new HashMap<>();\n-        map.put(op + value, 0);\n-        model.getPriority().put(encodedValue, map);\n-        return model;\n-    }\n-\n-    Object getValue(CustomModel model, String encodedValue) {\n-        Map map = (Map) model.getPriority().get(encodedValue);\n-        if (map == null || map.isEmpty())\n-            return null;\n-        return map.keySet().iterator().next();\n+    @Test\n+    public void testTooBigFactor() {\n+        CustomModel truck = new CustomModel();\n+        truck.getPriority().add(Clause.createIf(\"max_width < 3\", 10));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "97d6be58a7381cfbe306d2571e2f1ff3fc45e858"}, "originalPosition": 32}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTg2MzMwMQ==", "bodyText": "This is only this ugly because if is not possible as a method name (if is a keyword). Also e.g. new IfClause is not much shorter but could be better because you can use autocomplete for the rest?\nAnother idea is to move the methods into CustomModel: truck.addPriorityIf(\"max_width < 3\", 10) but method count will increase a lot, especially when we would create more root entries in the future.", "url": "https://github.com/graphhopper/graphhopper/pull/2209#discussion_r545863301", "createdAt": "2020-12-18T14:26:08Z", "author": {"login": "karussell"}, "path": "core/src/test/java/com/graphhopper/routing/util/CustomModelTest.java", "diffHunk": "@@ -18,94 +18,66 @@\n \n package com.graphhopper.routing.util;\n \n+import com.graphhopper.json.Clause;\n import org.junit.jupiter.api.Test;\n \n-import java.util.HashMap;\n-import java.util.Map;\n+import java.util.Iterator;\n \n-import static org.junit.jupiter.api.Assertions.*;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n \n public class CustomModelTest {\n \n-    static CustomModel setValue(CustomModel model, String op, String encodedValue, double value) {\n-        Map<String, Object> map = new HashMap<>();\n-        map.put(op + value, 0);\n-        model.getPriority().put(encodedValue, map);\n-        return model;\n-    }\n-\n-    Object getValue(CustomModel model, String encodedValue) {\n-        Map map = (Map) model.getPriority().get(encodedValue);\n-        if (map == null || map.isEmpty())\n-            return null;\n-        return map.keySet().iterator().next();\n+    @Test\n+    public void testTooBigFactor() {\n+        CustomModel truck = new CustomModel();\n+        truck.getPriority().add(Clause.createIf(\"max_width < 3\", 10));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTg1NjU5Mg=="}, "originalCommit": {"oid": "97d6be58a7381cfbe306d2571e2f1ff3fc45e858"}, "originalPosition": 32}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTg2NjA1Mw==", "bodyText": "Oh.. right ;) Maybe Clause.ifClause? Then with static import for Clause we can write: getPriority().add(ifClause(\"max_width < 3\", 10)); Its not really shorter, but create is not very helpful here?\n\nespecially when we would create more root entries in the future.\n\nand with increasing operator count as well...\nIf we merge the speed sections we also need to pass the operator here?", "url": "https://github.com/graphhopper/graphhopper/pull/2209#discussion_r545866053", "createdAt": "2020-12-18T14:30:17Z", "author": {"login": "easbar"}, "path": "core/src/test/java/com/graphhopper/routing/util/CustomModelTest.java", "diffHunk": "@@ -18,94 +18,66 @@\n \n package com.graphhopper.routing.util;\n \n+import com.graphhopper.json.Clause;\n import org.junit.jupiter.api.Test;\n \n-import java.util.HashMap;\n-import java.util.Map;\n+import java.util.Iterator;\n \n-import static org.junit.jupiter.api.Assertions.*;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n \n public class CustomModelTest {\n \n-    static CustomModel setValue(CustomModel model, String op, String encodedValue, double value) {\n-        Map<String, Object> map = new HashMap<>();\n-        map.put(op + value, 0);\n-        model.getPriority().put(encodedValue, map);\n-        return model;\n-    }\n-\n-    Object getValue(CustomModel model, String encodedValue) {\n-        Map map = (Map) model.getPriority().get(encodedValue);\n-        if (map == null || map.isEmpty())\n-            return null;\n-        return map.keySet().iterator().next();\n+    @Test\n+    public void testTooBigFactor() {\n+        CustomModel truck = new CustomModel();\n+        truck.getPriority().add(Clause.createIf(\"max_width < 3\", 10));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTg1NjU5Mg=="}, "originalCommit": {"oid": "97d6be58a7381cfbe306d2571e2f1ff3fc45e858"}, "originalPosition": 32}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTg2ODAyOQ==", "bodyText": "Clause.cond ?", "url": "https://github.com/graphhopper/graphhopper/pull/2209#discussion_r545868029", "createdAt": "2020-12-18T14:33:39Z", "author": {"login": "otbutz"}, "path": "core/src/test/java/com/graphhopper/routing/util/CustomModelTest.java", "diffHunk": "@@ -18,94 +18,66 @@\n \n package com.graphhopper.routing.util;\n \n+import com.graphhopper.json.Clause;\n import org.junit.jupiter.api.Test;\n \n-import java.util.HashMap;\n-import java.util.Map;\n+import java.util.Iterator;\n \n-import static org.junit.jupiter.api.Assertions.*;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n \n public class CustomModelTest {\n \n-    static CustomModel setValue(CustomModel model, String op, String encodedValue, double value) {\n-        Map<String, Object> map = new HashMap<>();\n-        map.put(op + value, 0);\n-        model.getPriority().put(encodedValue, map);\n-        return model;\n-    }\n-\n-    Object getValue(CustomModel model, String encodedValue) {\n-        Map map = (Map) model.getPriority().get(encodedValue);\n-        if (map == null || map.isEmpty())\n-            return null;\n-        return map.keySet().iterator().next();\n+    @Test\n+    public void testTooBigFactor() {\n+        CustomModel truck = new CustomModel();\n+        truck.getPriority().add(Clause.createIf(\"max_width < 3\", 10));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTg1NjU5Mg=="}, "originalCommit": {"oid": "97d6be58a7381cfbe306d2571e2f1ff3fc45e858"}, "originalPosition": 32}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTg3MDQ1MQ==", "bodyText": "You mean\nClause.cond(\"if\", \"max_width < 3\", \"multiply_with\", 0.8);\nClause.cond(\"else if\", \"max_width < 5\", \"multiply_with\", 0.7);\nClause.cond(\"else\", \"\", \"multiply_with\", 0.7);\nI think in this case we could just as well use new Clause(...)?", "url": "https://github.com/graphhopper/graphhopper/pull/2209#discussion_r545870451", "createdAt": "2020-12-18T14:37:41Z", "author": {"login": "easbar"}, "path": "core/src/test/java/com/graphhopper/routing/util/CustomModelTest.java", "diffHunk": "@@ -18,94 +18,66 @@\n \n package com.graphhopper.routing.util;\n \n+import com.graphhopper.json.Clause;\n import org.junit.jupiter.api.Test;\n \n-import java.util.HashMap;\n-import java.util.Map;\n+import java.util.Iterator;\n \n-import static org.junit.jupiter.api.Assertions.*;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n \n public class CustomModelTest {\n \n-    static CustomModel setValue(CustomModel model, String op, String encodedValue, double value) {\n-        Map<String, Object> map = new HashMap<>();\n-        map.put(op + value, 0);\n-        model.getPriority().put(encodedValue, map);\n-        return model;\n-    }\n-\n-    Object getValue(CustomModel model, String encodedValue) {\n-        Map map = (Map) model.getPriority().get(encodedValue);\n-        if (map == null || map.isEmpty())\n-            return null;\n-        return map.keySet().iterator().next();\n+    @Test\n+    public void testTooBigFactor() {\n+        CustomModel truck = new CustomModel();\n+        truck.getPriority().add(Clause.createIf(\"max_width < 3\", 10));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTg1NjU5Mg=="}, "originalCommit": {"oid": "97d6be58a7381cfbe306d2571e2f1ff3fc45e858"}, "originalPosition": 32}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTg5MjI1Ng==", "bodyText": "Do we even need to distinguish three cases? else if is just syntactic sugar\nif (cond1) {\n} else if (cond2) {\n} else if (cond3) {\n} else {\n}\nis equivalent to:\nif (cond1) {\n} else {\n   if (cond2) {\n   } else {\n      if (cond3) {\n      } else {\n      }\n   }\n}\nSo we would end up with:\nClause.cond(\"max_width < 3\", \"multiply_with\", 0.8)\nClause.cond(\"max_width < 5\", \"multiply_with\", 0.7);\nClause.cond(\"multiply_with\", 0.7);", "url": "https://github.com/graphhopper/graphhopper/pull/2209#discussion_r545892256", "createdAt": "2020-12-18T15:01:38Z", "author": {"login": "otbutz"}, "path": "core/src/test/java/com/graphhopper/routing/util/CustomModelTest.java", "diffHunk": "@@ -18,94 +18,66 @@\n \n package com.graphhopper.routing.util;\n \n+import com.graphhopper.json.Clause;\n import org.junit.jupiter.api.Test;\n \n-import java.util.HashMap;\n-import java.util.Map;\n+import java.util.Iterator;\n \n-import static org.junit.jupiter.api.Assertions.*;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n \n public class CustomModelTest {\n \n-    static CustomModel setValue(CustomModel model, String op, String encodedValue, double value) {\n-        Map<String, Object> map = new HashMap<>();\n-        map.put(op + value, 0);\n-        model.getPriority().put(encodedValue, map);\n-        return model;\n-    }\n-\n-    Object getValue(CustomModel model, String encodedValue) {\n-        Map map = (Map) model.getPriority().get(encodedValue);\n-        if (map == null || map.isEmpty())\n-            return null;\n-        return map.keySet().iterator().next();\n+    @Test\n+    public void testTooBigFactor() {\n+        CustomModel truck = new CustomModel();\n+        truck.getPriority().add(Clause.createIf(\"max_width < 3\", 10));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTg1NjU5Mg=="}, "originalCommit": {"oid": "97d6be58a7381cfbe306d2571e2f1ff3fc45e858"}, "originalPosition": 32}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTg5NzYzNg==", "bodyText": "Maybe Clause.ifClause?\n\nOr Clause.IF ;) or Clause.ifThen?\n\nClause.cond ?\nI think in this case we could just as well use new Clause(...)?\n\nCurrently I tend towards new IfClause() or static import and some short method name.\nAnother idea is to create static methods ala:\nClause.addIf(model.getPriority(), \"max_width < 3\", \"multiply_with\", 0.8);\n\nIMO it would be nice if it also would be chainable (and make the operator less dynamic?):\nClause.addIf(model.getPriority(), \"max_width < 3\", MultiplyOp.class, 0.8).\n       addElse(MultiplyOp.class, 0.4)\n\nor something.", "url": "https://github.com/graphhopper/graphhopper/pull/2209#discussion_r545897636", "createdAt": "2020-12-18T15:10:08Z", "author": {"login": "karussell"}, "path": "core/src/test/java/com/graphhopper/routing/util/CustomModelTest.java", "diffHunk": "@@ -18,94 +18,66 @@\n \n package com.graphhopper.routing.util;\n \n+import com.graphhopper.json.Clause;\n import org.junit.jupiter.api.Test;\n \n-import java.util.HashMap;\n-import java.util.Map;\n+import java.util.Iterator;\n \n-import static org.junit.jupiter.api.Assertions.*;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n \n public class CustomModelTest {\n \n-    static CustomModel setValue(CustomModel model, String op, String encodedValue, double value) {\n-        Map<String, Object> map = new HashMap<>();\n-        map.put(op + value, 0);\n-        model.getPriority().put(encodedValue, map);\n-        return model;\n-    }\n-\n-    Object getValue(CustomModel model, String encodedValue) {\n-        Map map = (Map) model.getPriority().get(encodedValue);\n-        if (map == null || map.isEmpty())\n-            return null;\n-        return map.keySet().iterator().next();\n+    @Test\n+    public void testTooBigFactor() {\n+        CustomModel truck = new CustomModel();\n+        truck.getPriority().add(Clause.createIf(\"max_width < 3\", 10));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTg1NjU5Mg=="}, "originalCommit": {"oid": "97d6be58a7381cfbe306d2571e2f1ff3fc45e858"}, "originalPosition": 32}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTkwNDYxOA==", "bodyText": "IMO it would be nice if it also would be chainable (and make the operator less dynamic?):\nClause.addIf(model.getPriority(), \"max_width < 3\", MultiplyOp.class, 0.8).\n       addElse(MultiplyOp.class, 0.4)\n\nor something.\n\nA StepBuilder would be nice:\nClause.If(\"max_width < 3\", MultiplyOp.class, 0.8)\n            .Else(MultiplyOp.class, 0.4)\n            .build();", "url": "https://github.com/graphhopper/graphhopper/pull/2209#discussion_r545904618", "createdAt": "2020-12-18T15:21:50Z", "author": {"login": "otbutz"}, "path": "core/src/test/java/com/graphhopper/routing/util/CustomModelTest.java", "diffHunk": "@@ -18,94 +18,66 @@\n \n package com.graphhopper.routing.util;\n \n+import com.graphhopper.json.Clause;\n import org.junit.jupiter.api.Test;\n \n-import java.util.HashMap;\n-import java.util.Map;\n+import java.util.Iterator;\n \n-import static org.junit.jupiter.api.Assertions.*;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n \n public class CustomModelTest {\n \n-    static CustomModel setValue(CustomModel model, String op, String encodedValue, double value) {\n-        Map<String, Object> map = new HashMap<>();\n-        map.put(op + value, 0);\n-        model.getPriority().put(encodedValue, map);\n-        return model;\n-    }\n-\n-    Object getValue(CustomModel model, String encodedValue) {\n-        Map map = (Map) model.getPriority().get(encodedValue);\n-        if (map == null || map.isEmpty())\n-            return null;\n-        return map.keySet().iterator().next();\n+    @Test\n+    public void testTooBigFactor() {\n+        CustomModel truck = new CustomModel();\n+        truck.getPriority().add(Clause.createIf(\"max_width < 3\", 10));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTg1NjU5Mg=="}, "originalCommit": {"oid": "97d6be58a7381cfbe306d2571e2f1ff3fc45e858"}, "originalPosition": 32}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTkwNDcwNw==", "bodyText": "is equivalent to:\n\nWe do not support nested if blocks\n\nOr Clause.IF ;) or Clause.ifThen?\n\nYes why not uppercase? Maybe Clause.If to distinguish the method from some static constant (which would normally be all uppercase)?. I don't like ifThen as much because it looks like there is something more going on when really all we do is create a data class.\n\nnew IfClause()\n\nOk\n\nAnother idea is to create static methods ala:\n\nWhy would this be better?\n\nIMO it would be nice if it also would be chainable\n\nThis can be achieved with a simple helper method in custom model:\nCustomModel addPriority(Clause clause) {\n    getPriority().add(clause);\n    return this;\n}\n\nand make the operator less dynamic\n\nWhat do you mean? And why .class in MultiplyOp.class? I thought we could just use static constants or an enum for the operator name?", "url": "https://github.com/graphhopper/graphhopper/pull/2209#discussion_r545904707", "createdAt": "2020-12-18T15:21:59Z", "author": {"login": "easbar"}, "path": "core/src/test/java/com/graphhopper/routing/util/CustomModelTest.java", "diffHunk": "@@ -18,94 +18,66 @@\n \n package com.graphhopper.routing.util;\n \n+import com.graphhopper.json.Clause;\n import org.junit.jupiter.api.Test;\n \n-import java.util.HashMap;\n-import java.util.Map;\n+import java.util.Iterator;\n \n-import static org.junit.jupiter.api.Assertions.*;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n \n public class CustomModelTest {\n \n-    static CustomModel setValue(CustomModel model, String op, String encodedValue, double value) {\n-        Map<String, Object> map = new HashMap<>();\n-        map.put(op + value, 0);\n-        model.getPriority().put(encodedValue, map);\n-        return model;\n-    }\n-\n-    Object getValue(CustomModel model, String encodedValue) {\n-        Map map = (Map) model.getPriority().get(encodedValue);\n-        if (map == null || map.isEmpty())\n-            return null;\n-        return map.keySet().iterator().next();\n+    @Test\n+    public void testTooBigFactor() {\n+        CustomModel truck = new CustomModel();\n+        truck.getPriority().add(Clause.createIf(\"max_width < 3\", 10));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTg1NjU5Mg=="}, "originalCommit": {"oid": "97d6be58a7381cfbe306d2571e2f1ff3fc45e858"}, "originalPosition": 32}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTk2ODA5Nw==", "bodyText": "Maybe Clause.If to distinguish the method from some static constant\n\nGood idea \ud83d\udc4d\n\nThis can be achieved with a simple helper method in custom model:\n\n\ud83d\udc4d\n\nWhat do you mean? And why .class in MultiplyOp.class? I thought we could just use static constants or an enum for the operator name?\n\nYes, static constants or enum is better. Just so that we do not have to correctly spell strings and maybe introduce operator specific functionality or similar.", "url": "https://github.com/graphhopper/graphhopper/pull/2209#discussion_r545968097", "createdAt": "2020-12-18T17:07:08Z", "author": {"login": "karussell"}, "path": "core/src/test/java/com/graphhopper/routing/util/CustomModelTest.java", "diffHunk": "@@ -18,94 +18,66 @@\n \n package com.graphhopper.routing.util;\n \n+import com.graphhopper.json.Clause;\n import org.junit.jupiter.api.Test;\n \n-import java.util.HashMap;\n-import java.util.Map;\n+import java.util.Iterator;\n \n-import static org.junit.jupiter.api.Assertions.*;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n \n public class CustomModelTest {\n \n-    static CustomModel setValue(CustomModel model, String op, String encodedValue, double value) {\n-        Map<String, Object> map = new HashMap<>();\n-        map.put(op + value, 0);\n-        model.getPriority().put(encodedValue, map);\n-        return model;\n-    }\n-\n-    Object getValue(CustomModel model, String encodedValue) {\n-        Map map = (Map) model.getPriority().get(encodedValue);\n-        if (map == null || map.isEmpty())\n-            return null;\n-        return map.keySet().iterator().next();\n+    @Test\n+    public void testTooBigFactor() {\n+        CustomModel truck = new CustomModel();\n+        truck.getPriority().add(Clause.createIf(\"max_width < 3\", 10));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTg1NjU5Mg=="}, "originalCommit": {"oid": "97d6be58a7381cfbe306d2571e2f1ff3fc45e858"}, "originalPosition": 32}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQzMzc0MTkxOnYy", "diffSide": "RIGHT", "path": "api/src/main/java/com/graphhopper/json/Clause.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xOVQxNjoyMjoxOFrOII8z0w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xOVQxNjo0NDozNFrOII88iw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjI1NTgyNw==", "bodyText": "Isn't expression the 'condition' here and condition is a ... hmmm ... 'clause' :-D I mean if/else are 'clauses' (they aren't really 'conditions') and something like road_class == MOTORWAY is a 'condition'. Ok the latter is also an 'expression', but 'condition' is more specific, it always evaluates to a boolean.", "url": "https://github.com/graphhopper/graphhopper/pull/2209#discussion_r546255827", "createdAt": "2020-12-19T16:22:18Z", "author": {"login": "easbar"}, "path": "api/src/main/java/com/graphhopper/json/Clause.java", "diffHunk": "@@ -18,65 +18,61 @@\n package com.graphhopper.json;\n \n public class Clause {\n-    // either if or else-if with thenValue\n-    private String ifClause;\n-    private String elseIfClause;\n-    private Double thenValue;\n-    // or just elseValue\n-    private Double elseValue;\n+    private final Cond condition;\n+    private final String expression;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2f087cc060aab8a4bd0da67615bdda35ca0ed579"}, "originalPosition": 11}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjI1ODA1OQ==", "bodyText": "Yeah, it was a bit confusing. But the current state is better I think?", "url": "https://github.com/graphhopper/graphhopper/pull/2209#discussion_r546258059", "createdAt": "2020-12-19T16:44:34Z", "author": {"login": "karussell"}, "path": "api/src/main/java/com/graphhopper/json/Clause.java", "diffHunk": "@@ -18,65 +18,61 @@\n package com.graphhopper.json;\n \n public class Clause {\n-    // either if or else-if with thenValue\n-    private String ifClause;\n-    private String elseIfClause;\n-    private Double thenValue;\n-    // or just elseValue\n-    private Double elseValue;\n+    private final Cond condition;\n+    private final String expression;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjI1NTgyNw=="}, "originalCommit": {"oid": "2f087cc060aab8a4bd0da67615bdda35ca0ed579"}, "originalPosition": 11}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQzMzc0MzU4OnYy", "diffSide": "RIGHT", "path": "api/src/main/java/com/graphhopper/json/Statement.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xOVQxNjoyNDoyOVrOII80og==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xOVQxNjoyNDoyOVrOII80og==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjI1NjAzNA==", "bodyText": "Ah nice \ud83d\udc4d. I also like Statement better than Clause and Keyword is better than Cond.", "url": "https://github.com/graphhopper/graphhopper/pull/2209#discussion_r546256034", "createdAt": "2020-12-19T16:24:29Z", "author": {"login": "easbar"}, "path": "api/src/main/java/com/graphhopper/json/Statement.java", "diffHunk": "@@ -0,0 +1,104 @@\n+/*\n+ *  Licensed to GraphHopper GmbH under one or more contributor\n+ *  license agreements. See the NOTICE file distributed with this work for\n+ *  additional information regarding copyright ownership.\n+ *\n+ *  GraphHopper GmbH licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except in\n+ *  compliance with the License. You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package com.graphhopper.json;\n+\n+public class Statement {\n+    private final Keyword keyword;\n+    private final String expression;\n+    private final Op operation;\n+    private final double value;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "66bbb9cbed315a15075bb0928daae14cfd7497db"}, "originalPosition": 24}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQzMzc0NDgyOnYy", "diffSide": "RIGHT", "path": "web/src/test/resources/com/graphhopper/http/resources/cargo_bike.yml", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xOVQxNjoyNTo1MFrOII81MA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xOVQyMDowNDo1OVrOII-HmA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjI1NjE3Ng==", "bodyText": "Nice! With this branch custom models not only become more powerful but also easier to use \u2764\ufe0f", "url": "https://github.com/graphhopper/graphhopper/pull/2209#discussion_r546256176", "createdAt": "2020-12-19T16:25:50Z", "author": {"login": "easbar"}, "path": "web/src/test/resources/com/graphhopper/http/resources/cargo_bike.yml", "diffHunk": "@@ -2,7 +2,7 @@\n # profile: bike\n \n # let's assume cargo bikes are e-bikes and we should lower speed to prefer shorter and not faster routes automatically\n-max_speed:\n+speed:", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "66bbb9cbed315a15075bb0928daae14cfd7497db"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjI3NjcwMg==", "bodyText": "See also the latest commit where I removed the max speed fallback :)\nAnd do you think we could/should make multiply witha bit shorter as it is so frequently used? And is it correct or should it be multiply by?", "url": "https://github.com/graphhopper/graphhopper/pull/2209#discussion_r546276702", "createdAt": "2020-12-19T19:58:25Z", "author": {"login": "karussell"}, "path": "web/src/test/resources/com/graphhopper/http/resources/cargo_bike.yml", "diffHunk": "@@ -2,7 +2,7 @@\n # profile: bike\n \n # let's assume cargo bikes are e-bikes and we should lower speed to prefer shorter and not faster routes automatically\n-max_speed:\n+speed:", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjI1NjE3Ng=="}, "originalCommit": {"oid": "66bbb9cbed315a15075bb0928daae14cfd7497db"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjI3NzI3Mg==", "bodyText": "And is it correct or should it be multiply by?\n\nNice catch! Yes it seems like it should be multiply by. So this is already two characters shorter ;).", "url": "https://github.com/graphhopper/graphhopper/pull/2209#discussion_r546277272", "createdAt": "2020-12-19T20:04:59Z", "author": {"login": "easbar"}, "path": "web/src/test/resources/com/graphhopper/http/resources/cargo_bike.yml", "diffHunk": "@@ -2,7 +2,7 @@\n # profile: bike\n \n # let's assume cargo bikes are e-bikes and we should lower speed to prefer shorter and not faster routes automatically\n-max_speed:\n+speed:", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjI1NjE3Ng=="}, "originalCommit": {"oid": "66bbb9cbed315a15075bb0928daae14cfd7497db"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ1MjU1NjY1OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/com/graphhopper/routing/weighting/custom/CustomProfile.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yNlQxNDo1MzoyMlrOILkWMQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0zMVQxMDoyNjozNFrOIM84EQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTAwMDc1Mw==", "bodyText": "Not sure if I like this too much \ud83d\ude04 but the static cache size was also not optimal.", "url": "https://github.com/graphhopper/graphhopper/pull/2209#discussion_r549000753", "createdAt": "2020-12-26T14:53:22Z", "author": {"login": "karussell"}, "path": "core/src/main/java/com/graphhopper/routing/weighting/custom/CustomProfile.java", "diffHunk": "@@ -18,6 +35,7 @@ public CustomProfile(String name) {\n     }\n \n     public CustomProfile setCustomModel(CustomModel customModel) {\n+        customModel.__internal();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6bb9fd01d77cc21d552f58fb6ed010cefb461405"}, "originalPosition": 25}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDQ1MTIxNw==", "bodyText": "Maybe leave a comment so its clear what this is for?", "url": "https://github.com/graphhopper/graphhopper/pull/2209#discussion_r550451217", "createdAt": "2020-12-31T10:26:34Z", "author": {"login": "easbar"}, "path": "core/src/main/java/com/graphhopper/routing/weighting/custom/CustomProfile.java", "diffHunk": "@@ -18,6 +35,7 @@ public CustomProfile(String name) {\n     }\n \n     public CustomProfile setCustomModel(CustomModel customModel) {\n+        customModel.__internal();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTAwMDc1Mw=="}, "originalCommit": {"oid": "6bb9fd01d77cc21d552f58fb6ed010cefb461405"}, "originalPosition": 25}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ1Nzk3ODc0OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/com/graphhopper/routing/weighting/custom/SpeedAndAccessProvider.java", "isResolved": true, "comments": {"totalCount": 16, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yOVQxMzo1NTowMFrOIMP1wg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0zMVQxNzozMDo0M1rOINE7Rg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTcxMzM0Ng==", "bodyText": "Should we rename to SpeedAndPriorityProvider or even something else :) ?", "url": "https://github.com/graphhopper/graphhopper/pull/2209#discussion_r549713346", "createdAt": "2020-12-29T13:55:00Z", "author": {"login": "karussell"}, "path": "core/src/main/java/com/graphhopper/routing/weighting/custom/SpeedAndAccessProvider.java", "diffHunk": "@@ -15,19 +15,13 @@\n  *  See the License for the specific language governing permissions and\n  *  limitations under the License.\n  */\n+\n package com.graphhopper.routing.weighting.custom;\n \n-import com.graphhopper.routing.ev.EncodedValue;\n import com.graphhopper.util.EdgeIteratorState;\n \n-/**\n- * Implementations of this internal interface represent the conversion rules we use to map {@link EncodedValue}s to\n- * numerical values when determining the different parameters for {@link CustomWeighting}.\n- */\n-interface EdgeToValueEntry {\n+interface SpeedAndAccessProvider {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ac46dada9df721a8ea9abeddb2df42d90852ee4e"}, "originalPosition": 15}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDQyMjk3Mw==", "bodyText": "Oh yes, no idea why its called SpeedAndAccess...\n\nor even something else\n\nDo you have an idea?", "url": "https://github.com/graphhopper/graphhopper/pull/2209#discussion_r550422973", "createdAt": "2020-12-31T08:01:38Z", "author": {"login": "easbar"}, "path": "core/src/main/java/com/graphhopper/routing/weighting/custom/SpeedAndAccessProvider.java", "diffHunk": "@@ -15,19 +15,13 @@\n  *  See the License for the specific language governing permissions and\n  *  limitations under the License.\n  */\n+\n package com.graphhopper.routing.weighting.custom;\n \n-import com.graphhopper.routing.ev.EncodedValue;\n import com.graphhopper.util.EdgeIteratorState;\n \n-/**\n- * Implementations of this internal interface represent the conversion rules we use to map {@link EncodedValue}s to\n- * numerical values when determining the different parameters for {@link CustomWeighting}.\n- */\n-interface EdgeToValueEntry {\n+interface SpeedAndAccessProvider {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTcxMzM0Ng=="}, "originalCommit": {"oid": "ac46dada9df721a8ea9abeddb2df42d90852ee4e"}, "originalPosition": 15}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDQ0ODU3OA==", "bodyText": "We can delete it without much pain it seems :)", "url": "https://github.com/graphhopper/graphhopper/pull/2209#discussion_r550448578", "createdAt": "2020-12-31T10:13:35Z", "author": {"login": "karussell"}, "path": "core/src/main/java/com/graphhopper/routing/weighting/custom/SpeedAndAccessProvider.java", "diffHunk": "@@ -15,19 +15,13 @@\n  *  See the License for the specific language governing permissions and\n  *  limitations under the License.\n  */\n+\n package com.graphhopper.routing.weighting.custom;\n \n-import com.graphhopper.routing.ev.EncodedValue;\n import com.graphhopper.util.EdgeIteratorState;\n \n-/**\n- * Implementations of this internal interface represent the conversion rules we use to map {@link EncodedValue}s to\n- * numerical values when determining the different parameters for {@link CustomWeighting}.\n- */\n-interface EdgeToValueEntry {\n+interface SpeedAndAccessProvider {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTcxMzM0Ng=="}, "originalCommit": {"oid": "ac46dada9df721a8ea9abeddb2df42d90852ee4e"}, "originalPosition": 15}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDQ1MDg4Mg==", "bodyText": "Ok good :) So ExpressionBuilder now knows about CustomWeighting.Parameters but CustomWeighting is still decoupled from CustomWeightingHelper and janino stuff \ud83d\udc4d. We can probably now move the static CustomWeighting#create into ExpressionBuilder?\nAnd can we rename ExpressionBuilder?", "url": "https://github.com/graphhopper/graphhopper/pull/2209#discussion_r550450882", "createdAt": "2020-12-31T10:24:58Z", "author": {"login": "easbar"}, "path": "core/src/main/java/com/graphhopper/routing/weighting/custom/SpeedAndAccessProvider.java", "diffHunk": "@@ -15,19 +15,13 @@\n  *  See the License for the specific language governing permissions and\n  *  limitations under the License.\n  */\n+\n package com.graphhopper.routing.weighting.custom;\n \n-import com.graphhopper.routing.ev.EncodedValue;\n import com.graphhopper.util.EdgeIteratorState;\n \n-/**\n- * Implementations of this internal interface represent the conversion rules we use to map {@link EncodedValue}s to\n- * numerical values when determining the different parameters for {@link CustomWeighting}.\n- */\n-interface EdgeToValueEntry {\n+interface SpeedAndAccessProvider {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTcxMzM0Ng=="}, "originalCommit": {"oid": "ac46dada9df721a8ea9abeddb2df42d90852ee4e"}, "originalPosition": 15}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDQ1MTg5Nw==", "bodyText": "We can probably now move the static CustomWeighting#create into ExpressionBuilder?\n\nSure.\n\nAnd can we rename ExpressionBuilder?\n\nDo you have a suggestion? SpeedAndPriorityProvider :D ?", "url": "https://github.com/graphhopper/graphhopper/pull/2209#discussion_r550451897", "createdAt": "2020-12-31T10:29:32Z", "author": {"login": "karussell"}, "path": "core/src/main/java/com/graphhopper/routing/weighting/custom/SpeedAndAccessProvider.java", "diffHunk": "@@ -15,19 +15,13 @@\n  *  See the License for the specific language governing permissions and\n  *  limitations under the License.\n  */\n+\n package com.graphhopper.routing.weighting.custom;\n \n-import com.graphhopper.routing.ev.EncodedValue;\n import com.graphhopper.util.EdgeIteratorState;\n \n-/**\n- * Implementations of this internal interface represent the conversion rules we use to map {@link EncodedValue}s to\n- * numerical values when determining the different parameters for {@link CustomWeighting}.\n- */\n-interface EdgeToValueEntry {\n+interface SpeedAndAccessProvider {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTcxMzM0Ng=="}, "originalCommit": {"oid": "ac46dada9df721a8ea9abeddb2df42d90852ee4e"}, "originalPosition": 15}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDQ1MjY4OQ==", "bodyText": "Haha :D\nOn this level it would be the CustomWeightingParameterCreator, but that is not helpful at all. This class seems to be the one that takes a custom model and gives a meaning to it so I like something like CustomModelParser or JaninoInterpreter or something. I do not like ExpressionBuilder because 'expression' seems very unspecific and even more it is not building expressions :)", "url": "https://github.com/graphhopper/graphhopper/pull/2209#discussion_r550452689", "createdAt": "2020-12-31T10:33:16Z", "author": {"login": "easbar"}, "path": "core/src/main/java/com/graphhopper/routing/weighting/custom/SpeedAndAccessProvider.java", "diffHunk": "@@ -15,19 +15,13 @@\n  *  See the License for the specific language governing permissions and\n  *  limitations under the License.\n  */\n+\n package com.graphhopper.routing.weighting.custom;\n \n-import com.graphhopper.routing.ev.EncodedValue;\n import com.graphhopper.util.EdgeIteratorState;\n \n-/**\n- * Implementations of this internal interface represent the conversion rules we use to map {@link EncodedValue}s to\n- * numerical values when determining the different parameters for {@link CustomWeighting}.\n- */\n-interface EdgeToValueEntry {\n+interface SpeedAndAccessProvider {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTcxMzM0Ng=="}, "originalCommit": {"oid": "ac46dada9df721a8ea9abeddb2df42d90852ee4e"}, "originalPosition": 15}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDQ1Mjk5Mg==", "bodyText": "We can probably now move the static CustomWeighting#create into ExpressionBuilder?\n\nHmmh, it seems this method is used in DefaultWeightingFactory and so the ExpressionBuilder class would need to be public which would be suboptimal.", "url": "https://github.com/graphhopper/graphhopper/pull/2209#discussion_r550452992", "createdAt": "2020-12-31T10:35:02Z", "author": {"login": "karussell"}, "path": "core/src/main/java/com/graphhopper/routing/weighting/custom/SpeedAndAccessProvider.java", "diffHunk": "@@ -15,19 +15,13 @@\n  *  See the License for the specific language governing permissions and\n  *  limitations under the License.\n  */\n+\n package com.graphhopper.routing.weighting.custom;\n \n-import com.graphhopper.routing.ev.EncodedValue;\n import com.graphhopper.util.EdgeIteratorState;\n \n-/**\n- * Implementations of this internal interface represent the conversion rules we use to map {@link EncodedValue}s to\n- * numerical values when determining the different parameters for {@link CustomWeighting}.\n- */\n-interface EdgeToValueEntry {\n+interface SpeedAndAccessProvider {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTcxMzM0Ng=="}, "originalCommit": {"oid": "ac46dada9df721a8ea9abeddb2df42d90852ee4e"}, "originalPosition": 15}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDQ1MzY4NQ==", "bodyText": "Would it? The weighting factory already knows there is a custom model so why should it not know how to create a weighting from it (thats its job really)? I rather think CustomWeighting should not know about janino etc. so actually CustomWeighting should not know about ExpressionBuilder. Maybe its just in the wrong package then? Ah but I see you want to keep it package private because it has all the gory Janino details. Hm the custom 'package' should maybe just have some kind of public interface that gives access to its functionality. Currently we basically 'mis-use' CustomWeighting for this purpose: Because it is public anyway we can put the static method there, but this is rather by accident :) Btw did you try to make CustomWeightingHelper package level or at least protected? That one really seems to be an implementation detail.", "url": "https://github.com/graphhopper/graphhopper/pull/2209#discussion_r550453685", "createdAt": "2020-12-31T10:38:17Z", "author": {"login": "easbar"}, "path": "core/src/main/java/com/graphhopper/routing/weighting/custom/SpeedAndAccessProvider.java", "diffHunk": "@@ -15,19 +15,13 @@\n  *  See the License for the specific language governing permissions and\n  *  limitations under the License.\n  */\n+\n package com.graphhopper.routing.weighting.custom;\n \n-import com.graphhopper.routing.ev.EncodedValue;\n import com.graphhopper.util.EdgeIteratorState;\n \n-/**\n- * Implementations of this internal interface represent the conversion rules we use to map {@link EncodedValue}s to\n- * numerical values when determining the different parameters for {@link CustomWeighting}.\n- */\n-interface EdgeToValueEntry {\n+interface SpeedAndAccessProvider {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTcxMzM0Ng=="}, "originalCommit": {"oid": "ac46dada9df721a8ea9abeddb2df42d90852ee4e"}, "originalPosition": 15}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDQ2NDM2MQ==", "bodyText": "I like CustomModelParser :)\n\nI rather think CustomWeighting should not know about janino etc. so actually CustomWeighting should not know about ExpressionBuilder.\n\nOk, yes :)\n\nBtw did you try to make CustomWeightingHelper package level or at least protected? That one really seems to be an implementation detail.\n\nYes, unfortunately it wasn't possible due to janino magic :/", "url": "https://github.com/graphhopper/graphhopper/pull/2209#discussion_r550464361", "createdAt": "2020-12-31T11:36:28Z", "author": {"login": "karussell"}, "path": "core/src/main/java/com/graphhopper/routing/weighting/custom/SpeedAndAccessProvider.java", "diffHunk": "@@ -15,19 +15,13 @@\n  *  See the License for the specific language governing permissions and\n  *  limitations under the License.\n  */\n+\n package com.graphhopper.routing.weighting.custom;\n \n-import com.graphhopper.routing.ev.EncodedValue;\n import com.graphhopper.util.EdgeIteratorState;\n \n-/**\n- * Implementations of this internal interface represent the conversion rules we use to map {@link EncodedValue}s to\n- * numerical values when determining the different parameters for {@link CustomWeighting}.\n- */\n-interface EdgeToValueEntry {\n+interface SpeedAndAccessProvider {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTcxMzM0Ng=="}, "originalCommit": {"oid": "ac46dada9df721a8ea9abeddb2df42d90852ee4e"}, "originalPosition": 15}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDQ2NjI0Mg==", "bodyText": "Btw did you try to make CustomWeightingHelper package level or at least protected?\n\nWhen package protected it says something like:\njava.lang.IllegalAccessError: class com.graphhopper.routing.weighting.custom.JaninoCustomWeightingHelperSubclass2 cannot access its superclass com.graphhopper.routing.weighting.custom.CustomWeightingHelper (com.graphhopper.routing.weighting.custom.JaninoCustomWeightingHelperSubclass2 is in unnamed module of loader org.codehaus.commons.compiler.util.reflect.ByteArrayClassLoader @5c86dbc5; com.graphhopper.routing.weighting.custom.CustomWeightingHelper is in unnamed module of loader 'app')\n\nand classes cannot be protected it seems.", "url": "https://github.com/graphhopper/graphhopper/pull/2209#discussion_r550466242", "createdAt": "2020-12-31T11:47:12Z", "author": {"login": "karussell"}, "path": "core/src/main/java/com/graphhopper/routing/weighting/custom/SpeedAndAccessProvider.java", "diffHunk": "@@ -15,19 +15,13 @@\n  *  See the License for the specific language governing permissions and\n  *  limitations under the License.\n  */\n+\n package com.graphhopper.routing.weighting.custom;\n \n-import com.graphhopper.routing.ev.EncodedValue;\n import com.graphhopper.util.EdgeIteratorState;\n \n-/**\n- * Implementations of this internal interface represent the conversion rules we use to map {@link EncodedValue}s to\n- * numerical values when determining the different parameters for {@link CustomWeighting}.\n- */\n-interface EdgeToValueEntry {\n+interface SpeedAndAccessProvider {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTcxMzM0Ng=="}, "originalCommit": {"oid": "ac46dada9df721a8ea9abeddb2df42d90852ee4e"}, "originalPosition": 15}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDQ2OTM5MA==", "bodyText": "Haved renamed ExpressionBuilder to CustomModelParser, made it public and moved the create method there. Is this better?", "url": "https://github.com/graphhopper/graphhopper/pull/2209#discussion_r550469390", "createdAt": "2020-12-31T12:05:06Z", "author": {"login": "karussell"}, "path": "core/src/main/java/com/graphhopper/routing/weighting/custom/SpeedAndAccessProvider.java", "diffHunk": "@@ -15,19 +15,13 @@\n  *  See the License for the specific language governing permissions and\n  *  limitations under the License.\n  */\n+\n package com.graphhopper.routing.weighting.custom;\n \n-import com.graphhopper.routing.ev.EncodedValue;\n import com.graphhopper.util.EdgeIteratorState;\n \n-/**\n- * Implementations of this internal interface represent the conversion rules we use to map {@link EncodedValue}s to\n- * numerical values when determining the different parameters for {@link CustomWeighting}.\n- */\n-interface EdgeToValueEntry {\n+interface SpeedAndAccessProvider {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTcxMzM0Ng=="}, "originalCommit": {"oid": "ac46dada9df721a8ea9abeddb2df42d90852ee4e"}, "originalPosition": 15}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDUyOTEyMw==", "bodyText": "Yes I think so \ud83d\udc4d\nJust two minor things:\n\n\nYou probably tried this, but does the __internal_cache method affect json/yaml serialization? Or is this the reason for the __ prefix?\n\n\nMaybe rename CustomModelParser#create to CustomModelParser#createWeighting?", "url": "https://github.com/graphhopper/graphhopper/pull/2209#discussion_r550529123", "createdAt": "2020-12-31T16:21:58Z", "author": {"login": "easbar"}, "path": "core/src/main/java/com/graphhopper/routing/weighting/custom/SpeedAndAccessProvider.java", "diffHunk": "@@ -15,19 +15,13 @@\n  *  See the License for the specific language governing permissions and\n  *  limitations under the License.\n  */\n+\n package com.graphhopper.routing.weighting.custom;\n \n-import com.graphhopper.routing.ev.EncodedValue;\n import com.graphhopper.util.EdgeIteratorState;\n \n-/**\n- * Implementations of this internal interface represent the conversion rules we use to map {@link EncodedValue}s to\n- * numerical values when determining the different parameters for {@link CustomWeighting}.\n- */\n-interface EdgeToValueEntry {\n+interface SpeedAndAccessProvider {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTcxMzM0Ng=="}, "originalCommit": {"oid": "ac46dada9df721a8ea9abeddb2df42d90852ee4e"}, "originalPosition": 15}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDU0NjUyNQ==", "bodyText": "You probably tried this, but does the __internal_cache method affect json/yaml serialization?\n\nIt is not a setter or getter so I do not think it is affected and the tests are still passing. Or are you worried that the \"internal_cache\" attribute could be set via a deserialization i.e. via a request?\n\nOr is this the reason for the __ prefix?\n\nThe reason is more that it is not suggested in an auto completion and looking ugly so it should force a \"responsible\" developer using it to look into the javadocs :) ?\nHmmh, or should we move CustomModel to the com.graphhopper.routing.weighting.custom package and make this method package protected?", "url": "https://github.com/graphhopper/graphhopper/pull/2209#discussion_r550546525", "createdAt": "2020-12-31T16:44:24Z", "author": {"login": "karussell"}, "path": "core/src/main/java/com/graphhopper/routing/weighting/custom/SpeedAndAccessProvider.java", "diffHunk": "@@ -15,19 +15,13 @@\n  *  See the License for the specific language governing permissions and\n  *  limitations under the License.\n  */\n+\n package com.graphhopper.routing.weighting.custom;\n \n-import com.graphhopper.routing.ev.EncodedValue;\n import com.graphhopper.util.EdgeIteratorState;\n \n-/**\n- * Implementations of this internal interface represent the conversion rules we use to map {@link EncodedValue}s to\n- * numerical values when determining the different parameters for {@link CustomWeighting}.\n- */\n-interface EdgeToValueEntry {\n+interface SpeedAndAccessProvider {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTcxMzM0Ng=="}, "originalCommit": {"oid": "ac46dada9df721a8ea9abeddb2df42d90852ee4e"}, "originalPosition": 15}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDU1MjA5NA==", "bodyText": "Jackson either uses a naming convention and assumes there is a field when ever there are setters/getters, or it looks at the fields directly (I don't know what the default is).\n\nOr are you worried that the \"internal_cache\" attribute could be set via a deserialization i.e. via a request?\n\nNo I was not, as long as Jackson uses method access and the getters/setters do not follow the naming convention it should not be a problem.\n\nThe reason is more that it is not suggested in an auto completion and looking ugly so it should force a \"responsible\" developer using it to look into the javadocs :) ?\n\nOk yes makes sense to me.\n\nHmmh, or should we move CustomModel to the com.graphhopper.routing.weighting.custom package and make this method package protected?\n\nWhich method?", "url": "https://github.com/graphhopper/graphhopper/pull/2209#discussion_r550552094", "createdAt": "2020-12-31T16:51:18Z", "author": {"login": "easbar"}, "path": "core/src/main/java/com/graphhopper/routing/weighting/custom/SpeedAndAccessProvider.java", "diffHunk": "@@ -15,19 +15,13 @@\n  *  See the License for the specific language governing permissions and\n  *  limitations under the License.\n  */\n+\n package com.graphhopper.routing.weighting.custom;\n \n-import com.graphhopper.routing.ev.EncodedValue;\n import com.graphhopper.util.EdgeIteratorState;\n \n-/**\n- * Implementations of this internal interface represent the conversion rules we use to map {@link EncodedValue}s to\n- * numerical values when determining the different parameters for {@link CustomWeighting}.\n- */\n-interface EdgeToValueEntry {\n+interface SpeedAndAccessProvider {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTcxMzM0Ng=="}, "originalCommit": {"oid": "ac46dada9df721a8ea9abeddb2df42d90852ee4e"}, "originalPosition": 15}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDU1OTA3Mw==", "bodyText": "Which method?\n\nWe could hide both: CustomModel.__internal_cache and __shouldBeCached. And CustomProfile and CustomModelParser are already in that package. Then we could remove the ugly underscores.", "url": "https://github.com/graphhopper/graphhopper/pull/2209#discussion_r550559073", "createdAt": "2020-12-31T16:59:45Z", "author": {"login": "karussell"}, "path": "core/src/main/java/com/graphhopper/routing/weighting/custom/SpeedAndAccessProvider.java", "diffHunk": "@@ -15,19 +15,13 @@\n  *  See the License for the specific language governing permissions and\n  *  limitations under the License.\n  */\n+\n package com.graphhopper.routing.weighting.custom;\n \n-import com.graphhopper.routing.ev.EncodedValue;\n import com.graphhopper.util.EdgeIteratorState;\n \n-/**\n- * Implementations of this internal interface represent the conversion rules we use to map {@link EncodedValue}s to\n- * numerical values when determining the different parameters for {@link CustomWeighting}.\n- */\n-interface EdgeToValueEntry {\n+interface SpeedAndAccessProvider {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTcxMzM0Ng=="}, "originalCommit": {"oid": "ac46dada9df721a8ea9abeddb2df42d90852ee4e"}, "originalPosition": 15}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDU4MzExMA==", "bodyText": "I actually like this - see latest commit.", "url": "https://github.com/graphhopper/graphhopper/pull/2209#discussion_r550583110", "createdAt": "2020-12-31T17:30:43Z", "author": {"login": "karussell"}, "path": "core/src/main/java/com/graphhopper/routing/weighting/custom/SpeedAndAccessProvider.java", "diffHunk": "@@ -15,19 +15,13 @@\n  *  See the License for the specific language governing permissions and\n  *  limitations under the License.\n  */\n+\n package com.graphhopper.routing.weighting.custom;\n \n-import com.graphhopper.routing.ev.EncodedValue;\n import com.graphhopper.util.EdgeIteratorState;\n \n-/**\n- * Implementations of this internal interface represent the conversion rules we use to map {@link EncodedValue}s to\n- * numerical values when determining the different parameters for {@link CustomWeighting}.\n- */\n-interface EdgeToValueEntry {\n+interface SpeedAndAccessProvider {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTcxMzM0Ng=="}, "originalCommit": {"oid": "ac46dada9df721a8ea9abeddb2df42d90852ee4e"}, "originalPosition": 15}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ4MjQ0OTMzOnYy", "diffSide": "RIGHT", "path": "api/src/main/java/com/graphhopper/util/CustomModel.java", "isResolved": true, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wN1QxMjoxNzo0MVrOIPqVAA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wOFQxMTo0OToxMlrOIQPX_w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzI5MzA1Ng==", "bodyText": "hmmh, how should we solve this when CustomModel and CustomProfile are in different modules?", "url": "https://github.com/graphhopper/graphhopper/pull/2209#discussion_r553293056", "createdAt": "2021-01-07T12:17:41Z", "author": {"login": "karussell"}, "path": "api/src/main/java/com/graphhopper/util/CustomModel.java", "diffHunk": "@@ -58,12 +56,12 @@ public CustomModel(CustomModel toCopy) {\n      * especially important for fast landmark queries (hybrid mode). Now this method ensures that all server-side custom\n      * models are cached in a special internal cache which does not remove seldom accessed entries.\n      */\n-    CustomModel useInternalCache() {\n+    public CustomModel useInternalCache() {\n         this.cached = true;\n         return this;\n     }\n \n-    boolean shouldUseInternalCache() {\n+    public boolean shouldUseInternalCache() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "17f764e091372b6ea850714969d1687a8c4e549e"}, "originalPosition": 24}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzgxMTU1Mw==", "bodyText": "You mean how can we make it not public?", "url": "https://github.com/graphhopper/graphhopper/pull/2209#discussion_r553811553", "createdAt": "2021-01-08T08:44:14Z", "author": {"login": "easbar"}, "path": "api/src/main/java/com/graphhopper/util/CustomModel.java", "diffHunk": "@@ -58,12 +56,12 @@ public CustomModel(CustomModel toCopy) {\n      * especially important for fast landmark queries (hybrid mode). Now this method ensures that all server-side custom\n      * models are cached in a special internal cache which does not remove seldom accessed entries.\n      */\n-    CustomModel useInternalCache() {\n+    public CustomModel useInternalCache() {\n         this.cached = true;\n         return this;\n     }\n \n-    boolean shouldUseInternalCache() {\n+    public boolean shouldUseInternalCache() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzI5MzA1Ng=="}, "originalCommit": {"oid": "17f764e091372b6ea850714969d1687a8c4e549e"}, "originalPosition": 24}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mzg3NTI5Ng==", "bodyText": "Yes", "url": "https://github.com/graphhopper/graphhopper/pull/2209#discussion_r553875296", "createdAt": "2021-01-08T10:52:45Z", "author": {"login": "karussell"}, "path": "api/src/main/java/com/graphhopper/util/CustomModel.java", "diffHunk": "@@ -58,12 +56,12 @@ public CustomModel(CustomModel toCopy) {\n      * especially important for fast landmark queries (hybrid mode). Now this method ensures that all server-side custom\n      * models are cached in a special internal cache which does not remove seldom accessed entries.\n      */\n-    CustomModel useInternalCache() {\n+    public CustomModel useInternalCache() {\n         this.cached = true;\n         return this;\n     }\n \n-    boolean shouldUseInternalCache() {\n+    public boolean shouldUseInternalCache() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzI5MzA1Ng=="}, "originalCommit": {"oid": "17f764e091372b6ea850714969d1687a8c4e549e"}, "originalPosition": 24}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mzg3OTY2Mg==", "bodyText": "I don't really think it needs to be private. We could prefix it with _ to make it more clear that people who use it should know what they are doing. It was prefixed like this before \ud83d\ude06", "url": "https://github.com/graphhopper/graphhopper/pull/2209#discussion_r553879662", "createdAt": "2021-01-08T11:02:10Z", "author": {"login": "easbar"}, "path": "api/src/main/java/com/graphhopper/util/CustomModel.java", "diffHunk": "@@ -58,12 +56,12 @@ public CustomModel(CustomModel toCopy) {\n      * especially important for fast landmark queries (hybrid mode). Now this method ensures that all server-side custom\n      * models are cached in a special internal cache which does not remove seldom accessed entries.\n      */\n-    CustomModel useInternalCache() {\n+    public CustomModel useInternalCache() {\n         this.cached = true;\n         return this;\n     }\n \n-    boolean shouldUseInternalCache() {\n+    public boolean shouldUseInternalCache() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzI5MzA1Ng=="}, "originalCommit": {"oid": "17f764e091372b6ea850714969d1687a8c4e549e"}, "originalPosition": 24}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzkwMDAzMQ==", "bodyText": "I think we can keep it public and only throw an exception if queryCustomModel has it set to true.", "url": "https://github.com/graphhopper/graphhopper/pull/2209#discussion_r553900031", "createdAt": "2021-01-08T11:49:12Z", "author": {"login": "karussell"}, "path": "api/src/main/java/com/graphhopper/util/CustomModel.java", "diffHunk": "@@ -58,12 +56,12 @@ public CustomModel(CustomModel toCopy) {\n      * especially important for fast landmark queries (hybrid mode). Now this method ensures that all server-side custom\n      * models are cached in a special internal cache which does not remove seldom accessed entries.\n      */\n-    CustomModel useInternalCache() {\n+    public CustomModel useInternalCache() {\n         this.cached = true;\n         return this;\n     }\n \n-    boolean shouldUseInternalCache() {\n+    public boolean shouldUseInternalCache() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzI5MzA1Ng=="}, "originalCommit": {"oid": "17f764e091372b6ea850714969d1687a8c4e549e"}, "originalPosition": 24}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ4NTkxOTg0OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/com/graphhopper/routing/weighting/custom/CustomModelParser.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wOFQwOTowODozN1rOIQKtrA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wOFQxMTo0Njo1OFrOIQPUQg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzgyMzY2MA==", "bodyText": "Why would we ever clear the internal cache? And why would it grow larger than 100? Isn't it like only custom models specified in the profiles (config.yml) should end up in this internal cache and afterwards no new classes can be added?\nI am also not sure about the naming yet. Basically we have custom models that are specified on the server-side (in config.yml) and custom models coming in via custom routing requests. The first kind should always be cached, but the second kind is more dynamic and we need to make sure to only keep the most recent ones right?\nSo first of all I would rename the CustomModel#cached field to something like CustomModel#permanent/internal/isServerModel or similar, because 'cached' does not really distinguish between custom models that are cached because they are 'server-side' models and custom models that are cached because they were used recently. We can then also rename the getter/setter accordingly and as long as it is not possible to set this flag from the client side there is no need to somehow 'hide' this method? There are simply two kinds of custom models and this is ok.", "url": "https://github.com/graphhopper/graphhopper/pull/2209#discussion_r553823660", "createdAt": "2021-01-08T09:08:37Z", "author": {"login": "easbar"}, "path": "core/src/main/java/com/graphhopper/routing/weighting/custom/CustomModelParser.java", "diffHunk": "@@ -0,0 +1,434 @@\n+/*\n+ *  Licensed to GraphHopper GmbH under one or more contributor\n+ *  license agreements. See the NOTICE file distributed with this work for\n+ *  additional information regarding copyright ownership.\n+ *\n+ *  GraphHopper GmbH licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except in\n+ *  compliance with the License. You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package com.graphhopper.routing.weighting.custom;\n+\n+import com.graphhopper.json.Statement;\n+import com.graphhopper.routing.ev.*;\n+import com.graphhopper.routing.util.EncodingManager;\n+import com.graphhopper.routing.util.FlagEncoder;\n+import com.graphhopper.routing.weighting.TurnCostProvider;\n+import com.graphhopper.util.CustomModel;\n+import com.graphhopper.util.EdgeIteratorState;\n+import com.graphhopper.util.GHUtility;\n+import com.graphhopper.util.JsonFeature;\n+import com.graphhopper.util.shapes.BBox;\n+import com.graphhopper.util.shapes.Polygon;\n+import org.codehaus.commons.compiler.CompileException;\n+import org.codehaus.commons.compiler.Location;\n+import org.codehaus.commons.compiler.io.Readers;\n+import org.codehaus.janino.Scanner;\n+import org.codehaus.janino.*;\n+import org.codehaus.janino.util.DeepCopier;\n+import org.locationtech.jts.geom.prep.PreparedGeometryFactory;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.*;\n+import java.util.*;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+public class CustomModelParser {\n+    private static final AtomicLong longVal = new AtomicLong(1);\n+    static final String IN_AREA_PREFIX = \"in_area_\";\n+    private static final Set<String> allowedNames = new HashSet<>(Arrays.asList(\"edge\", \"Math\"));\n+    private static final boolean JANINO_DEBUG = Boolean.getBoolean(Scanner.SYSTEM_PROPERTY_SOURCE_DEBUGGING_ENABLE);\n+\n+    // Without a cache the class creation takes 10-40ms which makes routingLM8 requests 20% slower on average.\n+    // CH requests and preparation is unaffected as cached weighting from preparation is used.\n+    // Use accessOrder==true to remove oldest accessed entry, not oldest inserted.\n+    private static final int CACHE_SIZE = Integer.getInteger(\"graphhopper.custom_weighting.cache_size\", 1000);\n+    private static final Map<String, Class<?>> CACHE = Collections.synchronizedMap(\n+            new LinkedHashMap<String, Class<?>>(CACHE_SIZE, 0.75f, true) {\n+                protected boolean removeEldestEntry(Map.Entry eldest) {\n+                    return size() > CACHE_SIZE;\n+                }\n+            });\n+\n+    // This internal cache ensures that the \"internal\" Weighting classes specified in the profiles, are never removed regardless\n+    // of how frequent other Weightings are created and accessed. We only need to synchronize the get and put methods alone.\n+    // E.g. we do not care for the race condition where two identical classes are requested and one of them is overwritten.\n+    // TODO perf compare with ConcurrentHashMap, but I guess, if there is a difference at all, it is not big for small maps\n+    private static final Map<String, Class<?>> INTERNAL_CACHE = Collections.synchronizedMap(new HashMap<>());\n+\n+    private CustomModelParser() {\n+        // utility class\n+    }\n+\n+    public static CustomWeighting createWeighting(FlagEncoder baseFlagEncoder, EncodedValueLookup lookup, TurnCostProvider turnCostProvider,\n+                                                  CustomModel customModel) {\n+        if (customModel == null)\n+            throw new IllegalStateException(\"CustomModel cannot be null\");\n+        CustomWeighting.Parameters parameters = create(customModel, lookup, baseFlagEncoder.getMaxSpeed(), baseFlagEncoder.getAverageSpeedEnc());\n+        return new CustomWeighting(baseFlagEncoder, turnCostProvider, parameters);\n+    }\n+\n+    /**\n+     * This method compiles a new subclass of CustomWeightingHelper composed from the provided CustomModel caches this\n+     * and returns an instance.\n+     */\n+    static CustomWeighting.Parameters create(CustomModel customModel, EncodedValueLookup lookup, double globalMaxSpeed,\n+                                             DecimalEncodedValue avgSpeedEnc) {\n+        String key = customModel.toString() + \",global:\" + globalMaxSpeed;\n+        if (key.length() > 100_000) throw new IllegalArgumentException(\"Custom Model too big: \" + key.length());\n+\n+        Class<?> clazz = customModel.shouldUseInternalCache() ? INTERNAL_CACHE.get(key) : null;\n+        if (CACHE_SIZE > 0 && clazz == null)\n+            clazz = CACHE.get(key);\n+        if (clazz == null) {\n+            clazz = createClazz(customModel, lookup, globalMaxSpeed);\n+            if (customModel.shouldUseInternalCache()) {\n+                INTERNAL_CACHE.put(key, clazz);\n+                if (INTERNAL_CACHE.size() > 100) {\n+                    CACHE.putAll(INTERNAL_CACHE);\n+                    INTERNAL_CACHE.clear();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ca6b7360a5044b100468b6c28a7456e375a75690"}, "originalPosition": 97}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mzg3NjgwMg==", "bodyText": "And why would it grow larger than 100?\n\nIt shouldn't, but to avoid memory issues in case of bugs I thought this is the best solution. Not sure.\n\nSo first of all I would rename the CustomModel#cached field to something like CustomModel#permanent/internal/isServerModel\n\nAh, yes. Internal or serverModel sounds good\n\nas long as it is not possible to set this flag from the client side\n\nYes, I do not know how to do this safely :)", "url": "https://github.com/graphhopper/graphhopper/pull/2209#discussion_r553876802", "createdAt": "2021-01-08T10:55:57Z", "author": {"login": "karussell"}, "path": "core/src/main/java/com/graphhopper/routing/weighting/custom/CustomModelParser.java", "diffHunk": "@@ -0,0 +1,434 @@\n+/*\n+ *  Licensed to GraphHopper GmbH under one or more contributor\n+ *  license agreements. See the NOTICE file distributed with this work for\n+ *  additional information regarding copyright ownership.\n+ *\n+ *  GraphHopper GmbH licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except in\n+ *  compliance with the License. You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package com.graphhopper.routing.weighting.custom;\n+\n+import com.graphhopper.json.Statement;\n+import com.graphhopper.routing.ev.*;\n+import com.graphhopper.routing.util.EncodingManager;\n+import com.graphhopper.routing.util.FlagEncoder;\n+import com.graphhopper.routing.weighting.TurnCostProvider;\n+import com.graphhopper.util.CustomModel;\n+import com.graphhopper.util.EdgeIteratorState;\n+import com.graphhopper.util.GHUtility;\n+import com.graphhopper.util.JsonFeature;\n+import com.graphhopper.util.shapes.BBox;\n+import com.graphhopper.util.shapes.Polygon;\n+import org.codehaus.commons.compiler.CompileException;\n+import org.codehaus.commons.compiler.Location;\n+import org.codehaus.commons.compiler.io.Readers;\n+import org.codehaus.janino.Scanner;\n+import org.codehaus.janino.*;\n+import org.codehaus.janino.util.DeepCopier;\n+import org.locationtech.jts.geom.prep.PreparedGeometryFactory;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.*;\n+import java.util.*;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+public class CustomModelParser {\n+    private static final AtomicLong longVal = new AtomicLong(1);\n+    static final String IN_AREA_PREFIX = \"in_area_\";\n+    private static final Set<String> allowedNames = new HashSet<>(Arrays.asList(\"edge\", \"Math\"));\n+    private static final boolean JANINO_DEBUG = Boolean.getBoolean(Scanner.SYSTEM_PROPERTY_SOURCE_DEBUGGING_ENABLE);\n+\n+    // Without a cache the class creation takes 10-40ms which makes routingLM8 requests 20% slower on average.\n+    // CH requests and preparation is unaffected as cached weighting from preparation is used.\n+    // Use accessOrder==true to remove oldest accessed entry, not oldest inserted.\n+    private static final int CACHE_SIZE = Integer.getInteger(\"graphhopper.custom_weighting.cache_size\", 1000);\n+    private static final Map<String, Class<?>> CACHE = Collections.synchronizedMap(\n+            new LinkedHashMap<String, Class<?>>(CACHE_SIZE, 0.75f, true) {\n+                protected boolean removeEldestEntry(Map.Entry eldest) {\n+                    return size() > CACHE_SIZE;\n+                }\n+            });\n+\n+    // This internal cache ensures that the \"internal\" Weighting classes specified in the profiles, are never removed regardless\n+    // of how frequent other Weightings are created and accessed. We only need to synchronize the get and put methods alone.\n+    // E.g. we do not care for the race condition where two identical classes are requested and one of them is overwritten.\n+    // TODO perf compare with ConcurrentHashMap, but I guess, if there is a difference at all, it is not big for small maps\n+    private static final Map<String, Class<?>> INTERNAL_CACHE = Collections.synchronizedMap(new HashMap<>());\n+\n+    private CustomModelParser() {\n+        // utility class\n+    }\n+\n+    public static CustomWeighting createWeighting(FlagEncoder baseFlagEncoder, EncodedValueLookup lookup, TurnCostProvider turnCostProvider,\n+                                                  CustomModel customModel) {\n+        if (customModel == null)\n+            throw new IllegalStateException(\"CustomModel cannot be null\");\n+        CustomWeighting.Parameters parameters = create(customModel, lookup, baseFlagEncoder.getMaxSpeed(), baseFlagEncoder.getAverageSpeedEnc());\n+        return new CustomWeighting(baseFlagEncoder, turnCostProvider, parameters);\n+    }\n+\n+    /**\n+     * This method compiles a new subclass of CustomWeightingHelper composed from the provided CustomModel caches this\n+     * and returns an instance.\n+     */\n+    static CustomWeighting.Parameters create(CustomModel customModel, EncodedValueLookup lookup, double globalMaxSpeed,\n+                                             DecimalEncodedValue avgSpeedEnc) {\n+        String key = customModel.toString() + \",global:\" + globalMaxSpeed;\n+        if (key.length() > 100_000) throw new IllegalArgumentException(\"Custom Model too big: \" + key.length());\n+\n+        Class<?> clazz = customModel.shouldUseInternalCache() ? INTERNAL_CACHE.get(key) : null;\n+        if (CACHE_SIZE > 0 && clazz == null)\n+            clazz = CACHE.get(key);\n+        if (clazz == null) {\n+            clazz = createClazz(customModel, lookup, globalMaxSpeed);\n+            if (customModel.shouldUseInternalCache()) {\n+                INTERNAL_CACHE.put(key, clazz);\n+                if (INTERNAL_CACHE.size() > 100) {\n+                    CACHE.putAll(INTERNAL_CACHE);\n+                    INTERNAL_CACHE.clear();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzgyMzY2MA=="}, "originalCommit": {"oid": "ca6b7360a5044b100468b6c28a7456e375a75690"}, "originalPosition": 97}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mzg4MDc0Ng==", "bodyText": "It shouldn't, but to avoid memory issues in case of bugs I thought this is the best solution. Not sure.\n\nHm, but to detect bugs it would be better to throw an exception. And why do you think there could be bugs? Maybe the internal custom models should not be obtained via some cache key in the first place and instead they should be created when the server starts and later be retrieved directly via the profile name for example.\n\nYes, I do not know how to do this safely :)\n\nWell, first of all we can throw an error if it is set to true on a queryCustomModel. But then we can probably also exclude it from Jackson deserialization.", "url": "https://github.com/graphhopper/graphhopper/pull/2209#discussion_r553880746", "createdAt": "2021-01-08T11:04:33Z", "author": {"login": "easbar"}, "path": "core/src/main/java/com/graphhopper/routing/weighting/custom/CustomModelParser.java", "diffHunk": "@@ -0,0 +1,434 @@\n+/*\n+ *  Licensed to GraphHopper GmbH under one or more contributor\n+ *  license agreements. See the NOTICE file distributed with this work for\n+ *  additional information regarding copyright ownership.\n+ *\n+ *  GraphHopper GmbH licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except in\n+ *  compliance with the License. You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package com.graphhopper.routing.weighting.custom;\n+\n+import com.graphhopper.json.Statement;\n+import com.graphhopper.routing.ev.*;\n+import com.graphhopper.routing.util.EncodingManager;\n+import com.graphhopper.routing.util.FlagEncoder;\n+import com.graphhopper.routing.weighting.TurnCostProvider;\n+import com.graphhopper.util.CustomModel;\n+import com.graphhopper.util.EdgeIteratorState;\n+import com.graphhopper.util.GHUtility;\n+import com.graphhopper.util.JsonFeature;\n+import com.graphhopper.util.shapes.BBox;\n+import com.graphhopper.util.shapes.Polygon;\n+import org.codehaus.commons.compiler.CompileException;\n+import org.codehaus.commons.compiler.Location;\n+import org.codehaus.commons.compiler.io.Readers;\n+import org.codehaus.janino.Scanner;\n+import org.codehaus.janino.*;\n+import org.codehaus.janino.util.DeepCopier;\n+import org.locationtech.jts.geom.prep.PreparedGeometryFactory;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.*;\n+import java.util.*;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+public class CustomModelParser {\n+    private static final AtomicLong longVal = new AtomicLong(1);\n+    static final String IN_AREA_PREFIX = \"in_area_\";\n+    private static final Set<String> allowedNames = new HashSet<>(Arrays.asList(\"edge\", \"Math\"));\n+    private static final boolean JANINO_DEBUG = Boolean.getBoolean(Scanner.SYSTEM_PROPERTY_SOURCE_DEBUGGING_ENABLE);\n+\n+    // Without a cache the class creation takes 10-40ms which makes routingLM8 requests 20% slower on average.\n+    // CH requests and preparation is unaffected as cached weighting from preparation is used.\n+    // Use accessOrder==true to remove oldest accessed entry, not oldest inserted.\n+    private static final int CACHE_SIZE = Integer.getInteger(\"graphhopper.custom_weighting.cache_size\", 1000);\n+    private static final Map<String, Class<?>> CACHE = Collections.synchronizedMap(\n+            new LinkedHashMap<String, Class<?>>(CACHE_SIZE, 0.75f, true) {\n+                protected boolean removeEldestEntry(Map.Entry eldest) {\n+                    return size() > CACHE_SIZE;\n+                }\n+            });\n+\n+    // This internal cache ensures that the \"internal\" Weighting classes specified in the profiles, are never removed regardless\n+    // of how frequent other Weightings are created and accessed. We only need to synchronize the get and put methods alone.\n+    // E.g. we do not care for the race condition where two identical classes are requested and one of them is overwritten.\n+    // TODO perf compare with ConcurrentHashMap, but I guess, if there is a difference at all, it is not big for small maps\n+    private static final Map<String, Class<?>> INTERNAL_CACHE = Collections.synchronizedMap(new HashMap<>());\n+\n+    private CustomModelParser() {\n+        // utility class\n+    }\n+\n+    public static CustomWeighting createWeighting(FlagEncoder baseFlagEncoder, EncodedValueLookup lookup, TurnCostProvider turnCostProvider,\n+                                                  CustomModel customModel) {\n+        if (customModel == null)\n+            throw new IllegalStateException(\"CustomModel cannot be null\");\n+        CustomWeighting.Parameters parameters = create(customModel, lookup, baseFlagEncoder.getMaxSpeed(), baseFlagEncoder.getAverageSpeedEnc());\n+        return new CustomWeighting(baseFlagEncoder, turnCostProvider, parameters);\n+    }\n+\n+    /**\n+     * This method compiles a new subclass of CustomWeightingHelper composed from the provided CustomModel caches this\n+     * and returns an instance.\n+     */\n+    static CustomWeighting.Parameters create(CustomModel customModel, EncodedValueLookup lookup, double globalMaxSpeed,\n+                                             DecimalEncodedValue avgSpeedEnc) {\n+        String key = customModel.toString() + \",global:\" + globalMaxSpeed;\n+        if (key.length() > 100_000) throw new IllegalArgumentException(\"Custom Model too big: \" + key.length());\n+\n+        Class<?> clazz = customModel.shouldUseInternalCache() ? INTERNAL_CACHE.get(key) : null;\n+        if (CACHE_SIZE > 0 && clazz == null)\n+            clazz = CACHE.get(key);\n+        if (clazz == null) {\n+            clazz = createClazz(customModel, lookup, globalMaxSpeed);\n+            if (customModel.shouldUseInternalCache()) {\n+                INTERNAL_CACHE.put(key, clazz);\n+                if (INTERNAL_CACHE.size() > 100) {\n+                    CACHE.putAll(INTERNAL_CACHE);\n+                    INTERNAL_CACHE.clear();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzgyMzY2MA=="}, "originalCommit": {"oid": "ca6b7360a5044b100468b6c28a7456e375a75690"}, "originalPosition": 97}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mzg5OTA3NA==", "bodyText": "Hm, but to detect bugs it would be better to throw an exception\n\nOk, yes. You are right. Let us throw an exception!\n\nMaybe the internal custom models should not be obtained via some cache key in the first place and instead they should be created when the server starts and later be retrieved directly via the profile name for example.\n\nSounds also good, yes. But for now throw an exception :)\n\nWell, first of all we can throw an error if it is set to true on a queryCustomModel\n\nAh, nice. I tried the opposite, enforce server-side to be true, but this was ugly in tests.", "url": "https://github.com/graphhopper/graphhopper/pull/2209#discussion_r553899074", "createdAt": "2021-01-08T11:46:58Z", "author": {"login": "karussell"}, "path": "core/src/main/java/com/graphhopper/routing/weighting/custom/CustomModelParser.java", "diffHunk": "@@ -0,0 +1,434 @@\n+/*\n+ *  Licensed to GraphHopper GmbH under one or more contributor\n+ *  license agreements. See the NOTICE file distributed with this work for\n+ *  additional information regarding copyright ownership.\n+ *\n+ *  GraphHopper GmbH licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except in\n+ *  compliance with the License. You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package com.graphhopper.routing.weighting.custom;\n+\n+import com.graphhopper.json.Statement;\n+import com.graphhopper.routing.ev.*;\n+import com.graphhopper.routing.util.EncodingManager;\n+import com.graphhopper.routing.util.FlagEncoder;\n+import com.graphhopper.routing.weighting.TurnCostProvider;\n+import com.graphhopper.util.CustomModel;\n+import com.graphhopper.util.EdgeIteratorState;\n+import com.graphhopper.util.GHUtility;\n+import com.graphhopper.util.JsonFeature;\n+import com.graphhopper.util.shapes.BBox;\n+import com.graphhopper.util.shapes.Polygon;\n+import org.codehaus.commons.compiler.CompileException;\n+import org.codehaus.commons.compiler.Location;\n+import org.codehaus.commons.compiler.io.Readers;\n+import org.codehaus.janino.Scanner;\n+import org.codehaus.janino.*;\n+import org.codehaus.janino.util.DeepCopier;\n+import org.locationtech.jts.geom.prep.PreparedGeometryFactory;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.*;\n+import java.util.*;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+public class CustomModelParser {\n+    private static final AtomicLong longVal = new AtomicLong(1);\n+    static final String IN_AREA_PREFIX = \"in_area_\";\n+    private static final Set<String> allowedNames = new HashSet<>(Arrays.asList(\"edge\", \"Math\"));\n+    private static final boolean JANINO_DEBUG = Boolean.getBoolean(Scanner.SYSTEM_PROPERTY_SOURCE_DEBUGGING_ENABLE);\n+\n+    // Without a cache the class creation takes 10-40ms which makes routingLM8 requests 20% slower on average.\n+    // CH requests and preparation is unaffected as cached weighting from preparation is used.\n+    // Use accessOrder==true to remove oldest accessed entry, not oldest inserted.\n+    private static final int CACHE_SIZE = Integer.getInteger(\"graphhopper.custom_weighting.cache_size\", 1000);\n+    private static final Map<String, Class<?>> CACHE = Collections.synchronizedMap(\n+            new LinkedHashMap<String, Class<?>>(CACHE_SIZE, 0.75f, true) {\n+                protected boolean removeEldestEntry(Map.Entry eldest) {\n+                    return size() > CACHE_SIZE;\n+                }\n+            });\n+\n+    // This internal cache ensures that the \"internal\" Weighting classes specified in the profiles, are never removed regardless\n+    // of how frequent other Weightings are created and accessed. We only need to synchronize the get and put methods alone.\n+    // E.g. we do not care for the race condition where two identical classes are requested and one of them is overwritten.\n+    // TODO perf compare with ConcurrentHashMap, but I guess, if there is a difference at all, it is not big for small maps\n+    private static final Map<String, Class<?>> INTERNAL_CACHE = Collections.synchronizedMap(new HashMap<>());\n+\n+    private CustomModelParser() {\n+        // utility class\n+    }\n+\n+    public static CustomWeighting createWeighting(FlagEncoder baseFlagEncoder, EncodedValueLookup lookup, TurnCostProvider turnCostProvider,\n+                                                  CustomModel customModel) {\n+        if (customModel == null)\n+            throw new IllegalStateException(\"CustomModel cannot be null\");\n+        CustomWeighting.Parameters parameters = create(customModel, lookup, baseFlagEncoder.getMaxSpeed(), baseFlagEncoder.getAverageSpeedEnc());\n+        return new CustomWeighting(baseFlagEncoder, turnCostProvider, parameters);\n+    }\n+\n+    /**\n+     * This method compiles a new subclass of CustomWeightingHelper composed from the provided CustomModel caches this\n+     * and returns an instance.\n+     */\n+    static CustomWeighting.Parameters create(CustomModel customModel, EncodedValueLookup lookup, double globalMaxSpeed,\n+                                             DecimalEncodedValue avgSpeedEnc) {\n+        String key = customModel.toString() + \",global:\" + globalMaxSpeed;\n+        if (key.length() > 100_000) throw new IllegalArgumentException(\"Custom Model too big: \" + key.length());\n+\n+        Class<?> clazz = customModel.shouldUseInternalCache() ? INTERNAL_CACHE.get(key) : null;\n+        if (CACHE_SIZE > 0 && clazz == null)\n+            clazz = CACHE.get(key);\n+        if (clazz == null) {\n+            clazz = createClazz(customModel, lookup, globalMaxSpeed);\n+            if (customModel.shouldUseInternalCache()) {\n+                INTERNAL_CACHE.put(key, clazz);\n+                if (INTERNAL_CACHE.size() > 100) {\n+                    CACHE.putAll(INTERNAL_CACHE);\n+                    INTERNAL_CACHE.clear();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzgyMzY2MA=="}, "originalCommit": {"oid": "ca6b7360a5044b100468b6c28a7456e375a75690"}, "originalPosition": 97}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ4NTk3NDk3OnYy", "diffSide": "RIGHT", "path": "api/src/main/java/com/graphhopper/util/CustomModel.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wOFQwOToyNTozOVrOIQLOag==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wOFQxMDo1NjoxM1rOIQN92A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzgzMjA0Mg==", "bodyText": "Maybe call it speed/priorityStatements instead of speedFactor/priorityMap now?", "url": "https://github.com/graphhopper/graphhopper/pull/2209#discussion_r553832042", "createdAt": "2021-01-08T09:25:39Z", "author": {"login": "easbar"}, "path": "api/src/main/java/com/graphhopper/util/CustomModel.java", "diffHunk": "@@ -126,43 +136,32 @@ public String toString() {\n \n     private String createContentString() {\n         // used to check against stored custom models, see #2026\n-        return \"distanceInfluence=\" + distanceInfluence + \"|speedFactor=\" + speedFactorMap + \"|maxSpeed=\" + maxSpeedMap +\n-                \"|maxSpeedFallback=\" + maxSpeedFallback + \"|priorityMap=\" + priorityMap + \"|areas=\" + areas;\n+        return \"distanceInfluence=\" + distanceInfluence + \"|speedFactor=\" + speedStatements +\n+                \"|priorityMap=\" + priorityStatements + \"|areas=\" + areas;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ca6b7360a5044b100468b6c28a7456e375a75690"}, "originalPosition": 104}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mzg3Njk1Mg==", "bodyText": "Ah, sure \ud83d\udc4d", "url": "https://github.com/graphhopper/graphhopper/pull/2209#discussion_r553876952", "createdAt": "2021-01-08T10:56:13Z", "author": {"login": "karussell"}, "path": "api/src/main/java/com/graphhopper/util/CustomModel.java", "diffHunk": "@@ -126,43 +136,32 @@ public String toString() {\n \n     private String createContentString() {\n         // used to check against stored custom models, see #2026\n-        return \"distanceInfluence=\" + distanceInfluence + \"|speedFactor=\" + speedFactorMap + \"|maxSpeed=\" + maxSpeedMap +\n-                \"|maxSpeedFallback=\" + maxSpeedFallback + \"|priorityMap=\" + priorityMap + \"|areas=\" + areas;\n+        return \"distanceInfluence=\" + distanceInfluence + \"|speedFactor=\" + speedStatements +\n+                \"|priorityMap=\" + priorityStatements + \"|areas=\" + areas;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzgzMjA0Mg=="}, "originalCommit": {"oid": "ca6b7360a5044b100468b6c28a7456e375a75690"}, "originalPosition": 104}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ4NjE4NDg2OnYy", "diffSide": "RIGHT", "path": "docs/core/profiles.md", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wOFQxMDoyOTozN1rOIQNMYQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wOFQxMDoyOTozN1rOIQNMYQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mzg2NDI4OQ==", "bodyText": "We should state somewhere the expressions can be any boolean expression in Java", "url": "https://github.com/graphhopper/graphhopper/pull/2209#discussion_r553864289", "createdAt": "2021-01-08T10:29:37Z", "author": {"login": "easbar"}, "path": "docs/core/profiles.md", "diffHunk": "@@ -139,108 +141,152 @@ And there are others that take on a numeric value, like:\n - max_weight\n - max_width\n \n-*Important note: Whenever you want to use any of these categories for a custom profile you need to add them to \n+*Important note: Whenever you want to use any of these categories for a custom profile you need to add them to\n `graph.encoded_values` in `config.yml`.*\n \n ### Setting up a Custom Model\n \n As mentioned above, the custom weighting function has three parameters that you can adjust: speed, priority and\n distance_influence. You can set up rules that determine these parameters from the edge's properties. A set of such rules\n-is called a 'custom model' and it is written in a dedicated YAML format. We will now see how the cost function parameters\n-can be influenced by the different fields of such a custom model.\n+is called a 'custom model' and it is written in a dedicated YAML or JSON format. We will now see how the cost function \n+parameters can be influenced by the different fields of such a custom model.\n   \n #### Customizing `speed`\n \n-For every edge a default speed is inherited from the base vehicle, but you have multiple options to adjust it.\n-The first thing you can do is rescaling the default speeds using the `speed_factor` section. For example this is how you\n-can reduce the the speed of every edge that has the value 'motorway' for the category 'road_class' to fifty percent of \n+For every road segment a default speed is inherited from the base vehicle and you have multiple options to adjust it.\n+The first thing you can do is rescaling the default speeds using `multiply by`. For example this is how you\n+can reduce the speed of every road segment that has the value `MOTORWAY` for the category 'road_class' to fifty percent of \n the default speed that is normally used by the base vehicle for this road class:\n ```yaml\n-speed_factor:\n-  road_class: {motorway: 0.5}\n-```  \n-Note that `road_class: {motorway: 0.5}` is an alternative YAML notation that is equivalent to:\n-```yaml\n-speed_factor:\n-  road_class:\n-    motorway: 0.5\n+speed:\n+  - if: road_class == MOTORWAY\n+    multiply by: 0.5\n ```\n \n-You can also setup speed factors for multiple road classes like this\n+You can also change the speed in case of different road classes like this\n ```yaml\n-speed_factor:\n-  road_class: {motorway: 0.5, primary: 0.7, tertiary: 0.9}\n+speed:\n+  - if: road_class == MOTORWAY\n+    multiply by: 0.5\n+  - if: road_class == PRIMARY || road_class == TERTIARY\n+    multiply by: 0.7\n ```\n \n-and use multiple categories to influence the speed factor\n+The OR-operator `||` means if the left **or** right expressions is true then the value `0.7` is used.\n+You can also use multiple categories in the expressions:", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a4324f5e2a621aa09930022b3bf5db353da6b0c3"}, "originalPosition": 85}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ4NjE4ODc5OnYy", "diffSide": "RIGHT", "path": "docs/core/profiles.md", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wOFQxMDozMDo1N1rOIQNOzQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xMVQwOTo0NzoxOFrOIRN7-g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mzg2NDkwOQ==", "bodyText": "Maybe we should only use the same notation everywhere here and instead add a separate section that explains how one can also use this more JSON style notation (after the reader understood the yaml format). I found it distracting to see two different notations here.", "url": "https://github.com/graphhopper/graphhopper/pull/2209#discussion_r553864909", "createdAt": "2021-01-08T10:30:57Z", "author": {"login": "easbar"}, "path": "docs/core/profiles.md", "diffHunk": "@@ -139,108 +141,152 @@ And there are others that take on a numeric value, like:\n - max_weight\n - max_width\n \n-*Important note: Whenever you want to use any of these categories for a custom profile you need to add them to \n+*Important note: Whenever you want to use any of these categories for a custom profile you need to add them to\n `graph.encoded_values` in `config.yml`.*\n \n ### Setting up a Custom Model\n \n As mentioned above, the custom weighting function has three parameters that you can adjust: speed, priority and\n distance_influence. You can set up rules that determine these parameters from the edge's properties. A set of such rules\n-is called a 'custom model' and it is written in a dedicated YAML format. We will now see how the cost function parameters\n-can be influenced by the different fields of such a custom model.\n+is called a 'custom model' and it is written in a dedicated YAML or JSON format. We will now see how the cost function \n+parameters can be influenced by the different fields of such a custom model.\n   \n #### Customizing `speed`\n \n-For every edge a default speed is inherited from the base vehicle, but you have multiple options to adjust it.\n-The first thing you can do is rescaling the default speeds using the `speed_factor` section. For example this is how you\n-can reduce the the speed of every edge that has the value 'motorway' for the category 'road_class' to fifty percent of \n+For every road segment a default speed is inherited from the base vehicle and you have multiple options to adjust it.\n+The first thing you can do is rescaling the default speeds using `multiply by`. For example this is how you\n+can reduce the speed of every road segment that has the value `MOTORWAY` for the category 'road_class' to fifty percent of \n the default speed that is normally used by the base vehicle for this road class:\n ```yaml\n-speed_factor:\n-  road_class: {motorway: 0.5}\n-```  \n-Note that `road_class: {motorway: 0.5}` is an alternative YAML notation that is equivalent to:\n-```yaml\n-speed_factor:\n-  road_class:\n-    motorway: 0.5\n+speed:\n+  - if: road_class == MOTORWAY\n+    multiply by: 0.5\n ```\n \n-You can also setup speed factors for multiple road classes like this\n+You can also change the speed in case of different road classes like this\n ```yaml\n-speed_factor:\n-  road_class: {motorway: 0.5, primary: 0.7, tertiary: 0.9}\n+speed:\n+  - if: road_class == MOTORWAY\n+    multiply by: 0.5\n+  - if: road_class == PRIMARY || road_class == TERTIARY\n+    multiply by: 0.7\n ```\n \n-and use multiple categories to influence the speed factor\n+The OR-operator `||` means if the left **or** right expressions is true then the value `0.7` is used.\n+You can also use multiple categories in the expressions:\n+\n ```yaml\n-speed_factor:\n-  road_class: {motorway: 0.5}\n-  road_environment: {tunnel: 0.8}\n+speed:\n+  - if: \"road_class == MOTORWAY\",     multiply by: 0.5\n+  - if: \"road_environment == TUNNEL\", multiply by: 0.8", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a4324f5e2a621aa09930022b3bf5db353da6b0c3"}, "originalPosition": 93}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDExMTExNg==", "bodyText": "One thing that bothers me a bit is that more (?) users will do client side custom models than server side ones and the current profiles.md (after my edits) focuses on the yaml format even though for cusom-route requests you need JSON. But really that should not be too hard to translate?", "url": "https://github.com/graphhopper/graphhopper/pull/2209#discussion_r554111116", "createdAt": "2021-01-08T18:15:09Z", "author": {"login": "easbar"}, "path": "docs/core/profiles.md", "diffHunk": "@@ -139,108 +141,152 @@ And there are others that take on a numeric value, like:\n - max_weight\n - max_width\n \n-*Important note: Whenever you want to use any of these categories for a custom profile you need to add them to \n+*Important note: Whenever you want to use any of these categories for a custom profile you need to add them to\n `graph.encoded_values` in `config.yml`.*\n \n ### Setting up a Custom Model\n \n As mentioned above, the custom weighting function has three parameters that you can adjust: speed, priority and\n distance_influence. You can set up rules that determine these parameters from the edge's properties. A set of such rules\n-is called a 'custom model' and it is written in a dedicated YAML format. We will now see how the cost function parameters\n-can be influenced by the different fields of such a custom model.\n+is called a 'custom model' and it is written in a dedicated YAML or JSON format. We will now see how the cost function \n+parameters can be influenced by the different fields of such a custom model.\n   \n #### Customizing `speed`\n \n-For every edge a default speed is inherited from the base vehicle, but you have multiple options to adjust it.\n-The first thing you can do is rescaling the default speeds using the `speed_factor` section. For example this is how you\n-can reduce the the speed of every edge that has the value 'motorway' for the category 'road_class' to fifty percent of \n+For every road segment a default speed is inherited from the base vehicle and you have multiple options to adjust it.\n+The first thing you can do is rescaling the default speeds using `multiply by`. For example this is how you\n+can reduce the speed of every road segment that has the value `MOTORWAY` for the category 'road_class' to fifty percent of \n the default speed that is normally used by the base vehicle for this road class:\n ```yaml\n-speed_factor:\n-  road_class: {motorway: 0.5}\n-```  \n-Note that `road_class: {motorway: 0.5}` is an alternative YAML notation that is equivalent to:\n-```yaml\n-speed_factor:\n-  road_class:\n-    motorway: 0.5\n+speed:\n+  - if: road_class == MOTORWAY\n+    multiply by: 0.5\n ```\n \n-You can also setup speed factors for multiple road classes like this\n+You can also change the speed in case of different road classes like this\n ```yaml\n-speed_factor:\n-  road_class: {motorway: 0.5, primary: 0.7, tertiary: 0.9}\n+speed:\n+  - if: road_class == MOTORWAY\n+    multiply by: 0.5\n+  - if: road_class == PRIMARY || road_class == TERTIARY\n+    multiply by: 0.7\n ```\n \n-and use multiple categories to influence the speed factor\n+The OR-operator `||` means if the left **or** right expressions is true then the value `0.7` is used.\n+You can also use multiple categories in the expressions:\n+\n ```yaml\n-speed_factor:\n-  road_class: {motorway: 0.5}\n-  road_environment: {tunnel: 0.8}\n+speed:\n+  - if: \"road_class == MOTORWAY\",     multiply by: 0.5\n+  - if: \"road_environment == TUNNEL\", multiply by: 0.8", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mzg2NDkwOQ=="}, "originalCommit": {"oid": "a4324f5e2a621aa09930022b3bf5db353da6b0c3"}, "originalPosition": 93}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDkyNTA1MA==", "bodyText": "Hmmh, yes. I created a follow up issue where we should clarify this and some more points: #2232", "url": "https://github.com/graphhopper/graphhopper/pull/2209#discussion_r554925050", "createdAt": "2021-01-11T09:47:18Z", "author": {"login": "karussell"}, "path": "docs/core/profiles.md", "diffHunk": "@@ -139,108 +141,152 @@ And there are others that take on a numeric value, like:\n - max_weight\n - max_width\n \n-*Important note: Whenever you want to use any of these categories for a custom profile you need to add them to \n+*Important note: Whenever you want to use any of these categories for a custom profile you need to add them to\n `graph.encoded_values` in `config.yml`.*\n \n ### Setting up a Custom Model\n \n As mentioned above, the custom weighting function has three parameters that you can adjust: speed, priority and\n distance_influence. You can set up rules that determine these parameters from the edge's properties. A set of such rules\n-is called a 'custom model' and it is written in a dedicated YAML format. We will now see how the cost function parameters\n-can be influenced by the different fields of such a custom model.\n+is called a 'custom model' and it is written in a dedicated YAML or JSON format. We will now see how the cost function \n+parameters can be influenced by the different fields of such a custom model.\n   \n #### Customizing `speed`\n \n-For every edge a default speed is inherited from the base vehicle, but you have multiple options to adjust it.\n-The first thing you can do is rescaling the default speeds using the `speed_factor` section. For example this is how you\n-can reduce the the speed of every edge that has the value 'motorway' for the category 'road_class' to fifty percent of \n+For every road segment a default speed is inherited from the base vehicle and you have multiple options to adjust it.\n+The first thing you can do is rescaling the default speeds using `multiply by`. For example this is how you\n+can reduce the speed of every road segment that has the value `MOTORWAY` for the category 'road_class' to fifty percent of \n the default speed that is normally used by the base vehicle for this road class:\n ```yaml\n-speed_factor:\n-  road_class: {motorway: 0.5}\n-```  \n-Note that `road_class: {motorway: 0.5}` is an alternative YAML notation that is equivalent to:\n-```yaml\n-speed_factor:\n-  road_class:\n-    motorway: 0.5\n+speed:\n+  - if: road_class == MOTORWAY\n+    multiply by: 0.5\n ```\n \n-You can also setup speed factors for multiple road classes like this\n+You can also change the speed in case of different road classes like this\n ```yaml\n-speed_factor:\n-  road_class: {motorway: 0.5, primary: 0.7, tertiary: 0.9}\n+speed:\n+  - if: road_class == MOTORWAY\n+    multiply by: 0.5\n+  - if: road_class == PRIMARY || road_class == TERTIARY\n+    multiply by: 0.7\n ```\n \n-and use multiple categories to influence the speed factor\n+The OR-operator `||` means if the left **or** right expressions is true then the value `0.7` is used.\n+You can also use multiple categories in the expressions:\n+\n ```yaml\n-speed_factor:\n-  road_class: {motorway: 0.5}\n-  road_environment: {tunnel: 0.8}\n+speed:\n+  - if: \"road_class == MOTORWAY\",     multiply by: 0.5\n+  - if: \"road_environment == TUNNEL\", multiply by: 0.8", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mzg2NDkwOQ=="}, "originalCommit": {"oid": "a4324f5e2a621aa09930022b3bf5db353da6b0c3"}, "originalPosition": 93}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ4NjE5MzA3OnYy", "diffSide": "RIGHT", "path": "docs/core/profiles.md", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wOFQxMDozMjoxOVrOIQNRaA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wOFQxMDozMjoxOVrOIQNRaA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mzg2NTU3Ng==", "bodyText": "you should not use == (equality) or != (inequality)", "url": "https://github.com/graphhopper/graphhopper/pull/2209#discussion_r553865576", "createdAt": "2021-01-08T10:32:19Z", "author": {"login": "easbar"}, "path": "docs/core/profiles.md", "diffHunk": "@@ -139,108 +141,152 @@ And there are others that take on a numeric value, like:\n - max_weight\n - max_width\n \n-*Important note: Whenever you want to use any of these categories for a custom profile you need to add them to \n+*Important note: Whenever you want to use any of these categories for a custom profile you need to add them to\n `graph.encoded_values` in `config.yml`.*\n \n ### Setting up a Custom Model\n \n As mentioned above, the custom weighting function has three parameters that you can adjust: speed, priority and\n distance_influence. You can set up rules that determine these parameters from the edge's properties. A set of such rules\n-is called a 'custom model' and it is written in a dedicated YAML format. We will now see how the cost function parameters\n-can be influenced by the different fields of such a custom model.\n+is called a 'custom model' and it is written in a dedicated YAML or JSON format. We will now see how the cost function \n+parameters can be influenced by the different fields of such a custom model.\n   \n #### Customizing `speed`\n \n-For every edge a default speed is inherited from the base vehicle, but you have multiple options to adjust it.\n-The first thing you can do is rescaling the default speeds using the `speed_factor` section. For example this is how you\n-can reduce the the speed of every edge that has the value 'motorway' for the category 'road_class' to fifty percent of \n+For every road segment a default speed is inherited from the base vehicle and you have multiple options to adjust it.\n+The first thing you can do is rescaling the default speeds using `multiply by`. For example this is how you\n+can reduce the speed of every road segment that has the value `MOTORWAY` for the category 'road_class' to fifty percent of \n the default speed that is normally used by the base vehicle for this road class:\n ```yaml\n-speed_factor:\n-  road_class: {motorway: 0.5}\n-```  \n-Note that `road_class: {motorway: 0.5}` is an alternative YAML notation that is equivalent to:\n-```yaml\n-speed_factor:\n-  road_class:\n-    motorway: 0.5\n+speed:\n+  - if: road_class == MOTORWAY\n+    multiply by: 0.5\n ```\n \n-You can also setup speed factors for multiple road classes like this\n+You can also change the speed in case of different road classes like this\n ```yaml\n-speed_factor:\n-  road_class: {motorway: 0.5, primary: 0.7, tertiary: 0.9}\n+speed:\n+  - if: road_class == MOTORWAY\n+    multiply by: 0.5\n+  - if: road_class == PRIMARY || road_class == TERTIARY\n+    multiply by: 0.7\n ```\n \n-and use multiple categories to influence the speed factor\n+The OR-operator `||` means if the left **or** right expressions is true then the value `0.7` is used.\n+You can also use multiple categories in the expressions:\n+\n ```yaml\n-speed_factor:\n-  road_class: {motorway: 0.5}\n-  road_environment: {tunnel: 0.8}\n+speed:\n+  - if: \"road_class == MOTORWAY\",     multiply by: 0.5\n+  - if: \"road_environment == TUNNEL\", multiply by: 0.8\n ```\n \n-If an edge matches multiple rules the speed factor values will be multiplied. For example, here the speed factor of \n-a road segment that has `road_class=motorway` will be `0.5`, the speed factor of a road segment that additionally has \n-`road_environment=tunnel` will be `0.4` and the speed factor of a road segment that has `road_class=secondary` and \n-`road_environment=tunnel` will be `0.8`.\n+Here also quotes around every expression and a comma is used to write one statement per YAML line. \n+Which looks more like JSON which is also possible for server-side profiles and the only way to write custom models at \n+query time:\n \n-Instead of setting the speed factors for certain values you can instead set the speed factors for all *other* values using\n-as special key (`\"*\"`), like this:\n-```yaml\n-speed_factor: \n-  road_class: {\"*\": 0.5}\n-  road_environment: {tunnel: 0.8, \"*\": 0.6}\n+```json\n+{ \"speed\": [\n+    { \"if\": \"road_class == MOTORWAY\", \"multiply by\": 0.5 },\n+    { \"if\": \"road_environment == TUNNEL\", \"multiply by\": 0.8 }\n+  ]\n+}\n ```\n \n-So in this example we set a speed factor of `0.5` regardless of the `road_class` and all `road_environment` values yield\n-a speed factor of `0.6` *except* `tunnel` which gets a speed factor of `0.8`. And as mentioned above for edges that match\n-multiple of these rules the different factors get multiplied.\n+There are other categories like `get_off_bike` that are of `boolean` type. You use them via:\n \n-For encoded values with boolean values, like `get_off_bike` you set the speed factor like this:\n ```yaml\n-speed_factor:\n-  get_off_bike: {true: 0.6, false: 1.0}\n+speed:\n+  - if: get_off_bike\n+    multiply by: 0.6\n ```\n-which means that for edges with `get_off_bike=true` the speed factor will be `0.6` and otherwise it will be `1.0`.\n-You can skip any of these values to retain the default.\n \n-For encoded values with numeric values, like `max_width` you use the `<` and `>` operators, like this:\n+which means that for edges with `get_off_bike==true` the speed factor will be `0.6`.\n+\n+For encoded values with numeric values, like `max_width` you should not use \"equality\" or \"inequality\" but the", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a4324f5e2a621aa09930022b3bf5db353da6b0c3"}, "originalPosition": 137}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ4NjE5ODMwOnYy", "diffSide": "RIGHT", "path": "docs/core/profiles.md", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wOFQxMDozNDowMlrOIQNUmg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wOFQxMTowOToyMFrOIQOVEQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mzg2NjM5NA==", "bodyText": "I found this more confusing than helpful. Maybe we should add this at the end of the else section, because this is only needed if one wants the same effect as 'else', but without preceding 'if' statements.", "url": "https://github.com/graphhopper/graphhopper/pull/2209#discussion_r553866394", "createdAt": "2021-01-08T10:34:02Z", "author": {"login": "easbar"}, "path": "docs/core/profiles.md", "diffHunk": "@@ -139,108 +141,152 @@ And there are others that take on a numeric value, like:\n - max_weight\n - max_width\n \n-*Important note: Whenever you want to use any of these categories for a custom profile you need to add them to \n+*Important note: Whenever you want to use any of these categories for a custom profile you need to add them to\n `graph.encoded_values` in `config.yml`.*\n \n ### Setting up a Custom Model\n \n As mentioned above, the custom weighting function has three parameters that you can adjust: speed, priority and\n distance_influence. You can set up rules that determine these parameters from the edge's properties. A set of such rules\n-is called a 'custom model' and it is written in a dedicated YAML format. We will now see how the cost function parameters\n-can be influenced by the different fields of such a custom model.\n+is called a 'custom model' and it is written in a dedicated YAML or JSON format. We will now see how the cost function \n+parameters can be influenced by the different fields of such a custom model.\n   \n #### Customizing `speed`\n \n-For every edge a default speed is inherited from the base vehicle, but you have multiple options to adjust it.\n-The first thing you can do is rescaling the default speeds using the `speed_factor` section. For example this is how you\n-can reduce the the speed of every edge that has the value 'motorway' for the category 'road_class' to fifty percent of \n+For every road segment a default speed is inherited from the base vehicle and you have multiple options to adjust it.\n+The first thing you can do is rescaling the default speeds using `multiply by`. For example this is how you\n+can reduce the speed of every road segment that has the value `MOTORWAY` for the category 'road_class' to fifty percent of \n the default speed that is normally used by the base vehicle for this road class:\n ```yaml\n-speed_factor:\n-  road_class: {motorway: 0.5}\n-```  \n-Note that `road_class: {motorway: 0.5}` is an alternative YAML notation that is equivalent to:\n-```yaml\n-speed_factor:\n-  road_class:\n-    motorway: 0.5\n+speed:\n+  - if: road_class == MOTORWAY\n+    multiply by: 0.5\n ```\n \n-You can also setup speed factors for multiple road classes like this\n+You can also change the speed in case of different road classes like this\n ```yaml\n-speed_factor:\n-  road_class: {motorway: 0.5, primary: 0.7, tertiary: 0.9}\n+speed:\n+  - if: road_class == MOTORWAY\n+    multiply by: 0.5\n+  - if: road_class == PRIMARY || road_class == TERTIARY\n+    multiply by: 0.7\n ```\n \n-and use multiple categories to influence the speed factor\n+The OR-operator `||` means if the left **or** right expressions is true then the value `0.7` is used.\n+You can also use multiple categories in the expressions:\n+\n ```yaml\n-speed_factor:\n-  road_class: {motorway: 0.5}\n-  road_environment: {tunnel: 0.8}\n+speed:\n+  - if: \"road_class == MOTORWAY\",     multiply by: 0.5\n+  - if: \"road_environment == TUNNEL\", multiply by: 0.8\n ```\n \n-If an edge matches multiple rules the speed factor values will be multiplied. For example, here the speed factor of \n-a road segment that has `road_class=motorway` will be `0.5`, the speed factor of a road segment that additionally has \n-`road_environment=tunnel` will be `0.4` and the speed factor of a road segment that has `road_class=secondary` and \n-`road_environment=tunnel` will be `0.8`.\n+Here also quotes around every expression and a comma is used to write one statement per YAML line. \n+Which looks more like JSON which is also possible for server-side profiles and the only way to write custom models at \n+query time:\n \n-Instead of setting the speed factors for certain values you can instead set the speed factors for all *other* values using\n-as special key (`\"*\"`), like this:\n-```yaml\n-speed_factor: \n-  road_class: {\"*\": 0.5}\n-  road_environment: {tunnel: 0.8, \"*\": 0.6}\n+```json\n+{ \"speed\": [\n+    { \"if\": \"road_class == MOTORWAY\", \"multiply by\": 0.5 },\n+    { \"if\": \"road_environment == TUNNEL\", \"multiply by\": 0.8 }\n+  ]\n+}\n ```\n \n-So in this example we set a speed factor of `0.5` regardless of the `road_class` and all `road_environment` values yield\n-a speed factor of `0.6` *except* `tunnel` which gets a speed factor of `0.8`. And as mentioned above for edges that match\n-multiple of these rules the different factors get multiplied.\n+There are other categories like `get_off_bike` that are of `boolean` type. You use them via:\n \n-For encoded values with boolean values, like `get_off_bike` you set the speed factor like this:\n ```yaml\n-speed_factor:\n-  get_off_bike: {true: 0.6, false: 1.0}\n+speed:\n+  - if: get_off_bike\n+    multiply by: 0.6\n ```\n-which means that for edges with `get_off_bike=true` the speed factor will be `0.6` and otherwise it will be `1.0`.\n-You can skip any of these values to retain the default.\n \n-For encoded values with numeric values, like `max_width` you use the `<` and `>` operators, like this:\n+which means that for edges with `get_off_bike==true` the speed factor will be `0.6`.\n+\n+For encoded values with numeric values, like `max_width` you should not use \"equality\" or \"inequality\" but the\n+comparison operators \"bigger\" `>`, \"bigger or equals\" `>=`, \"smaller\" `<` or \"smaller or equals\" `<=`, e.g.:\n ```yaml\n-speed_factor:\n-  max_width: {\"<2.5\": 0.8}\n+speed:\n+  - if: \"max_width < 2.5\", multiply by: 0.8\n ``` \n-which means that for all edges with `max_width` smaller than `2.5m` the speed factor is `0.8`.\n+which means that for all edges with `max_width` smaller than `2.5m` the speed is multiplied by `0.8`.\n \n-In any case values of `speed_factor` have to be in the range `[0,1]` and it is not possible to *increase* the speed for\n-edges of certain types. \n+Then there are categories of `string` type. You use them via:\n \n-Another way to change the speed is using the `max_speed` section, for example:\n ```yaml\n-max_speed:\n-  surface: {gravel: 60}\n+speed:\n+- if: country == \"DEU\"\n+  multiply by: 0\n ```\n \n-implies that on all road segments with `surface=gravel` the speed will be at most `60km/h`, regardless of the default \n-speed of this edge or the adjustments made by the `speed_factor` section. Just like with `speed_factor` you can setup\n-`max_speed` values for multiple category values and different categories. If multiple rules match for a given edge the\n-most restrictive rule will determine the speed (the minimum `max_speed` will be applied). \n-Values for `max_speed` must be in the range `[0,max_vehicle_speed]` where `max_vehicle_speed` is the maximum speed that\n-is set for the base vehicle (which you cannot change).\n+Another way to change the speed is using `limit to`:\n+```yaml\n+speed:\n+  - if: \"surface != GRAVEL\", limit to: 60\n+```\n+\n+This implies that on all road segments with no `GRAVEL` value for `surface` the speed will be at most `60km/h`,\n+regardless of the default speed of this road segment or the previous `multiply by` statements. Just like\n+with `multiply by` you can use multiple category values and different categories in the expressions for `limit to`. \n+If multiple statements match for a given edge the most restrictive statement will determine the speed.\n+\n+Values for `limit to` must be in the range `[0, max_vehicle_speed]` where `max_vehicle_speed` is the maximum speed that\n+is set for the base vehicle, and you cannot change it.\n+\n+An unconditional statement can be used as the last statement to limit the speed to a certain value under all conditions:\n+```yaml\n+speed:\n+  - if: \"true\", limit to: 90\n+```", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a4324f5e2a621aa09930022b3bf5db353da6b0c3"}, "originalPosition": 185}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mzg3NzY2Mw==", "bodyText": "Ok. I wanted to mention this explicitly because of the max_speed_fallback we had before", "url": "https://github.com/graphhopper/graphhopper/pull/2209#discussion_r553877663", "createdAt": "2021-01-08T10:57:44Z", "author": {"login": "karussell"}, "path": "docs/core/profiles.md", "diffHunk": "@@ -139,108 +141,152 @@ And there are others that take on a numeric value, like:\n - max_weight\n - max_width\n \n-*Important note: Whenever you want to use any of these categories for a custom profile you need to add them to \n+*Important note: Whenever you want to use any of these categories for a custom profile you need to add them to\n `graph.encoded_values` in `config.yml`.*\n \n ### Setting up a Custom Model\n \n As mentioned above, the custom weighting function has three parameters that you can adjust: speed, priority and\n distance_influence. You can set up rules that determine these parameters from the edge's properties. A set of such rules\n-is called a 'custom model' and it is written in a dedicated YAML format. We will now see how the cost function parameters\n-can be influenced by the different fields of such a custom model.\n+is called a 'custom model' and it is written in a dedicated YAML or JSON format. We will now see how the cost function \n+parameters can be influenced by the different fields of such a custom model.\n   \n #### Customizing `speed`\n \n-For every edge a default speed is inherited from the base vehicle, but you have multiple options to adjust it.\n-The first thing you can do is rescaling the default speeds using the `speed_factor` section. For example this is how you\n-can reduce the the speed of every edge that has the value 'motorway' for the category 'road_class' to fifty percent of \n+For every road segment a default speed is inherited from the base vehicle and you have multiple options to adjust it.\n+The first thing you can do is rescaling the default speeds using `multiply by`. For example this is how you\n+can reduce the speed of every road segment that has the value `MOTORWAY` for the category 'road_class' to fifty percent of \n the default speed that is normally used by the base vehicle for this road class:\n ```yaml\n-speed_factor:\n-  road_class: {motorway: 0.5}\n-```  \n-Note that `road_class: {motorway: 0.5}` is an alternative YAML notation that is equivalent to:\n-```yaml\n-speed_factor:\n-  road_class:\n-    motorway: 0.5\n+speed:\n+  - if: road_class == MOTORWAY\n+    multiply by: 0.5\n ```\n \n-You can also setup speed factors for multiple road classes like this\n+You can also change the speed in case of different road classes like this\n ```yaml\n-speed_factor:\n-  road_class: {motorway: 0.5, primary: 0.7, tertiary: 0.9}\n+speed:\n+  - if: road_class == MOTORWAY\n+    multiply by: 0.5\n+  - if: road_class == PRIMARY || road_class == TERTIARY\n+    multiply by: 0.7\n ```\n \n-and use multiple categories to influence the speed factor\n+The OR-operator `||` means if the left **or** right expressions is true then the value `0.7` is used.\n+You can also use multiple categories in the expressions:\n+\n ```yaml\n-speed_factor:\n-  road_class: {motorway: 0.5}\n-  road_environment: {tunnel: 0.8}\n+speed:\n+  - if: \"road_class == MOTORWAY\",     multiply by: 0.5\n+  - if: \"road_environment == TUNNEL\", multiply by: 0.8\n ```\n \n-If an edge matches multiple rules the speed factor values will be multiplied. For example, here the speed factor of \n-a road segment that has `road_class=motorway` will be `0.5`, the speed factor of a road segment that additionally has \n-`road_environment=tunnel` will be `0.4` and the speed factor of a road segment that has `road_class=secondary` and \n-`road_environment=tunnel` will be `0.8`.\n+Here also quotes around every expression and a comma is used to write one statement per YAML line. \n+Which looks more like JSON which is also possible for server-side profiles and the only way to write custom models at \n+query time:\n \n-Instead of setting the speed factors for certain values you can instead set the speed factors for all *other* values using\n-as special key (`\"*\"`), like this:\n-```yaml\n-speed_factor: \n-  road_class: {\"*\": 0.5}\n-  road_environment: {tunnel: 0.8, \"*\": 0.6}\n+```json\n+{ \"speed\": [\n+    { \"if\": \"road_class == MOTORWAY\", \"multiply by\": 0.5 },\n+    { \"if\": \"road_environment == TUNNEL\", \"multiply by\": 0.8 }\n+  ]\n+}\n ```\n \n-So in this example we set a speed factor of `0.5` regardless of the `road_class` and all `road_environment` values yield\n-a speed factor of `0.6` *except* `tunnel` which gets a speed factor of `0.8`. And as mentioned above for edges that match\n-multiple of these rules the different factors get multiplied.\n+There are other categories like `get_off_bike` that are of `boolean` type. You use them via:\n \n-For encoded values with boolean values, like `get_off_bike` you set the speed factor like this:\n ```yaml\n-speed_factor:\n-  get_off_bike: {true: 0.6, false: 1.0}\n+speed:\n+  - if: get_off_bike\n+    multiply by: 0.6\n ```\n-which means that for edges with `get_off_bike=true` the speed factor will be `0.6` and otherwise it will be `1.0`.\n-You can skip any of these values to retain the default.\n \n-For encoded values with numeric values, like `max_width` you use the `<` and `>` operators, like this:\n+which means that for edges with `get_off_bike==true` the speed factor will be `0.6`.\n+\n+For encoded values with numeric values, like `max_width` you should not use \"equality\" or \"inequality\" but the\n+comparison operators \"bigger\" `>`, \"bigger or equals\" `>=`, \"smaller\" `<` or \"smaller or equals\" `<=`, e.g.:\n ```yaml\n-speed_factor:\n-  max_width: {\"<2.5\": 0.8}\n+speed:\n+  - if: \"max_width < 2.5\", multiply by: 0.8\n ``` \n-which means that for all edges with `max_width` smaller than `2.5m` the speed factor is `0.8`.\n+which means that for all edges with `max_width` smaller than `2.5m` the speed is multiplied by `0.8`.\n \n-In any case values of `speed_factor` have to be in the range `[0,1]` and it is not possible to *increase* the speed for\n-edges of certain types. \n+Then there are categories of `string` type. You use them via:\n \n-Another way to change the speed is using the `max_speed` section, for example:\n ```yaml\n-max_speed:\n-  surface: {gravel: 60}\n+speed:\n+- if: country == \"DEU\"\n+  multiply by: 0\n ```\n \n-implies that on all road segments with `surface=gravel` the speed will be at most `60km/h`, regardless of the default \n-speed of this edge or the adjustments made by the `speed_factor` section. Just like with `speed_factor` you can setup\n-`max_speed` values for multiple category values and different categories. If multiple rules match for a given edge the\n-most restrictive rule will determine the speed (the minimum `max_speed` will be applied). \n-Values for `max_speed` must be in the range `[0,max_vehicle_speed]` where `max_vehicle_speed` is the maximum speed that\n-is set for the base vehicle (which you cannot change).\n+Another way to change the speed is using `limit to`:\n+```yaml\n+speed:\n+  - if: \"surface != GRAVEL\", limit to: 60\n+```\n+\n+This implies that on all road segments with no `GRAVEL` value for `surface` the speed will be at most `60km/h`,\n+regardless of the default speed of this road segment or the previous `multiply by` statements. Just like\n+with `multiply by` you can use multiple category values and different categories in the expressions for `limit to`. \n+If multiple statements match for a given edge the most restrictive statement will determine the speed.\n+\n+Values for `limit to` must be in the range `[0, max_vehicle_speed]` where `max_vehicle_speed` is the maximum speed that\n+is set for the base vehicle, and you cannot change it.\n+\n+An unconditional statement can be used as the last statement to limit the speed to a certain value under all conditions:\n+```yaml\n+speed:\n+  - if: \"true\", limit to: 90\n+```", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mzg2NjM5NA=="}, "originalCommit": {"oid": "a4324f5e2a621aa09930022b3bf5db353da6b0c3"}, "originalPosition": 185}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mzg4Mjg5Nw==", "bodyText": "Yes sure I just meant I would have found it easier to understand if first the else clause was explained. if (true) is just a shorter notation of if (condition) else in case condition==false.", "url": "https://github.com/graphhopper/graphhopper/pull/2209#discussion_r553882897", "createdAt": "2021-01-08T11:09:20Z", "author": {"login": "easbar"}, "path": "docs/core/profiles.md", "diffHunk": "@@ -139,108 +141,152 @@ And there are others that take on a numeric value, like:\n - max_weight\n - max_width\n \n-*Important note: Whenever you want to use any of these categories for a custom profile you need to add them to \n+*Important note: Whenever you want to use any of these categories for a custom profile you need to add them to\n `graph.encoded_values` in `config.yml`.*\n \n ### Setting up a Custom Model\n \n As mentioned above, the custom weighting function has three parameters that you can adjust: speed, priority and\n distance_influence. You can set up rules that determine these parameters from the edge's properties. A set of such rules\n-is called a 'custom model' and it is written in a dedicated YAML format. We will now see how the cost function parameters\n-can be influenced by the different fields of such a custom model.\n+is called a 'custom model' and it is written in a dedicated YAML or JSON format. We will now see how the cost function \n+parameters can be influenced by the different fields of such a custom model.\n   \n #### Customizing `speed`\n \n-For every edge a default speed is inherited from the base vehicle, but you have multiple options to adjust it.\n-The first thing you can do is rescaling the default speeds using the `speed_factor` section. For example this is how you\n-can reduce the the speed of every edge that has the value 'motorway' for the category 'road_class' to fifty percent of \n+For every road segment a default speed is inherited from the base vehicle and you have multiple options to adjust it.\n+The first thing you can do is rescaling the default speeds using `multiply by`. For example this is how you\n+can reduce the speed of every road segment that has the value `MOTORWAY` for the category 'road_class' to fifty percent of \n the default speed that is normally used by the base vehicle for this road class:\n ```yaml\n-speed_factor:\n-  road_class: {motorway: 0.5}\n-```  \n-Note that `road_class: {motorway: 0.5}` is an alternative YAML notation that is equivalent to:\n-```yaml\n-speed_factor:\n-  road_class:\n-    motorway: 0.5\n+speed:\n+  - if: road_class == MOTORWAY\n+    multiply by: 0.5\n ```\n \n-You can also setup speed factors for multiple road classes like this\n+You can also change the speed in case of different road classes like this\n ```yaml\n-speed_factor:\n-  road_class: {motorway: 0.5, primary: 0.7, tertiary: 0.9}\n+speed:\n+  - if: road_class == MOTORWAY\n+    multiply by: 0.5\n+  - if: road_class == PRIMARY || road_class == TERTIARY\n+    multiply by: 0.7\n ```\n \n-and use multiple categories to influence the speed factor\n+The OR-operator `||` means if the left **or** right expressions is true then the value `0.7` is used.\n+You can also use multiple categories in the expressions:\n+\n ```yaml\n-speed_factor:\n-  road_class: {motorway: 0.5}\n-  road_environment: {tunnel: 0.8}\n+speed:\n+  - if: \"road_class == MOTORWAY\",     multiply by: 0.5\n+  - if: \"road_environment == TUNNEL\", multiply by: 0.8\n ```\n \n-If an edge matches multiple rules the speed factor values will be multiplied. For example, here the speed factor of \n-a road segment that has `road_class=motorway` will be `0.5`, the speed factor of a road segment that additionally has \n-`road_environment=tunnel` will be `0.4` and the speed factor of a road segment that has `road_class=secondary` and \n-`road_environment=tunnel` will be `0.8`.\n+Here also quotes around every expression and a comma is used to write one statement per YAML line. \n+Which looks more like JSON which is also possible for server-side profiles and the only way to write custom models at \n+query time:\n \n-Instead of setting the speed factors for certain values you can instead set the speed factors for all *other* values using\n-as special key (`\"*\"`), like this:\n-```yaml\n-speed_factor: \n-  road_class: {\"*\": 0.5}\n-  road_environment: {tunnel: 0.8, \"*\": 0.6}\n+```json\n+{ \"speed\": [\n+    { \"if\": \"road_class == MOTORWAY\", \"multiply by\": 0.5 },\n+    { \"if\": \"road_environment == TUNNEL\", \"multiply by\": 0.8 }\n+  ]\n+}\n ```\n \n-So in this example we set a speed factor of `0.5` regardless of the `road_class` and all `road_environment` values yield\n-a speed factor of `0.6` *except* `tunnel` which gets a speed factor of `0.8`. And as mentioned above for edges that match\n-multiple of these rules the different factors get multiplied.\n+There are other categories like `get_off_bike` that are of `boolean` type. You use them via:\n \n-For encoded values with boolean values, like `get_off_bike` you set the speed factor like this:\n ```yaml\n-speed_factor:\n-  get_off_bike: {true: 0.6, false: 1.0}\n+speed:\n+  - if: get_off_bike\n+    multiply by: 0.6\n ```\n-which means that for edges with `get_off_bike=true` the speed factor will be `0.6` and otherwise it will be `1.0`.\n-You can skip any of these values to retain the default.\n \n-For encoded values with numeric values, like `max_width` you use the `<` and `>` operators, like this:\n+which means that for edges with `get_off_bike==true` the speed factor will be `0.6`.\n+\n+For encoded values with numeric values, like `max_width` you should not use \"equality\" or \"inequality\" but the\n+comparison operators \"bigger\" `>`, \"bigger or equals\" `>=`, \"smaller\" `<` or \"smaller or equals\" `<=`, e.g.:\n ```yaml\n-speed_factor:\n-  max_width: {\"<2.5\": 0.8}\n+speed:\n+  - if: \"max_width < 2.5\", multiply by: 0.8\n ``` \n-which means that for all edges with `max_width` smaller than `2.5m` the speed factor is `0.8`.\n+which means that for all edges with `max_width` smaller than `2.5m` the speed is multiplied by `0.8`.\n \n-In any case values of `speed_factor` have to be in the range `[0,1]` and it is not possible to *increase* the speed for\n-edges of certain types. \n+Then there are categories of `string` type. You use them via:\n \n-Another way to change the speed is using the `max_speed` section, for example:\n ```yaml\n-max_speed:\n-  surface: {gravel: 60}\n+speed:\n+- if: country == \"DEU\"\n+  multiply by: 0\n ```\n \n-implies that on all road segments with `surface=gravel` the speed will be at most `60km/h`, regardless of the default \n-speed of this edge or the adjustments made by the `speed_factor` section. Just like with `speed_factor` you can setup\n-`max_speed` values for multiple category values and different categories. If multiple rules match for a given edge the\n-most restrictive rule will determine the speed (the minimum `max_speed` will be applied). \n-Values for `max_speed` must be in the range `[0,max_vehicle_speed]` where `max_vehicle_speed` is the maximum speed that\n-is set for the base vehicle (which you cannot change).\n+Another way to change the speed is using `limit to`:\n+```yaml\n+speed:\n+  - if: \"surface != GRAVEL\", limit to: 60\n+```\n+\n+This implies that on all road segments with no `GRAVEL` value for `surface` the speed will be at most `60km/h`,\n+regardless of the default speed of this road segment or the previous `multiply by` statements. Just like\n+with `multiply by` you can use multiple category values and different categories in the expressions for `limit to`. \n+If multiple statements match for a given edge the most restrictive statement will determine the speed.\n+\n+Values for `limit to` must be in the range `[0, max_vehicle_speed]` where `max_vehicle_speed` is the maximum speed that\n+is set for the base vehicle, and you cannot change it.\n+\n+An unconditional statement can be used as the last statement to limit the speed to a certain value under all conditions:\n+```yaml\n+speed:\n+  - if: \"true\", limit to: 90\n+```", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mzg2NjM5NA=="}, "originalCommit": {"oid": "a4324f5e2a621aa09930022b3bf5db353da6b0c3"}, "originalPosition": 185}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ4NjIwMjMyOnYy", "diffSide": "RIGHT", "path": "docs/core/profiles.md", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wOFQxMDozNToxN1rOIQNW7Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wOFQxMDozNToxN1rOIQNW7Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mzg2Njk4OQ==", "bodyText": "I would find it more helpful to learn that all the statements are simply applied from top to bottom. Here it means that multiple factors are applied, but that is just a special case of the more general rule.", "url": "https://github.com/graphhopper/graphhopper/pull/2209#discussion_r553866989", "createdAt": "2021-01-08T10:35:17Z", "author": {"login": "easbar"}, "path": "docs/core/profiles.md", "diffHunk": "@@ -139,108 +141,152 @@ And there are others that take on a numeric value, like:\n - max_weight\n - max_width\n \n-*Important note: Whenever you want to use any of these categories for a custom profile you need to add them to \n+*Important note: Whenever you want to use any of these categories for a custom profile you need to add them to\n `graph.encoded_values` in `config.yml`.*\n \n ### Setting up a Custom Model\n \n As mentioned above, the custom weighting function has three parameters that you can adjust: speed, priority and\n distance_influence. You can set up rules that determine these parameters from the edge's properties. A set of such rules\n-is called a 'custom model' and it is written in a dedicated YAML format. We will now see how the cost function parameters\n-can be influenced by the different fields of such a custom model.\n+is called a 'custom model' and it is written in a dedicated YAML or JSON format. We will now see how the cost function \n+parameters can be influenced by the different fields of such a custom model.\n   \n #### Customizing `speed`\n \n-For every edge a default speed is inherited from the base vehicle, but you have multiple options to adjust it.\n-The first thing you can do is rescaling the default speeds using the `speed_factor` section. For example this is how you\n-can reduce the the speed of every edge that has the value 'motorway' for the category 'road_class' to fifty percent of \n+For every road segment a default speed is inherited from the base vehicle and you have multiple options to adjust it.\n+The first thing you can do is rescaling the default speeds using `multiply by`. For example this is how you\n+can reduce the speed of every road segment that has the value `MOTORWAY` for the category 'road_class' to fifty percent of \n the default speed that is normally used by the base vehicle for this road class:\n ```yaml\n-speed_factor:\n-  road_class: {motorway: 0.5}\n-```  \n-Note that `road_class: {motorway: 0.5}` is an alternative YAML notation that is equivalent to:\n-```yaml\n-speed_factor:\n-  road_class:\n-    motorway: 0.5\n+speed:\n+  - if: road_class == MOTORWAY\n+    multiply by: 0.5\n ```\n \n-You can also setup speed factors for multiple road classes like this\n+You can also change the speed in case of different road classes like this\n ```yaml\n-speed_factor:\n-  road_class: {motorway: 0.5, primary: 0.7, tertiary: 0.9}\n+speed:\n+  - if: road_class == MOTORWAY\n+    multiply by: 0.5\n+  - if: road_class == PRIMARY || road_class == TERTIARY\n+    multiply by: 0.7\n ```\n \n-and use multiple categories to influence the speed factor\n+The OR-operator `||` means if the left **or** right expressions is true then the value `0.7` is used.\n+You can also use multiple categories in the expressions:\n+\n ```yaml\n-speed_factor:\n-  road_class: {motorway: 0.5}\n-  road_environment: {tunnel: 0.8}\n+speed:\n+  - if: \"road_class == MOTORWAY\",     multiply by: 0.5\n+  - if: \"road_environment == TUNNEL\", multiply by: 0.8\n ```\n \n-If an edge matches multiple rules the speed factor values will be multiplied. For example, here the speed factor of \n-a road segment that has `road_class=motorway` will be `0.5`, the speed factor of a road segment that additionally has \n-`road_environment=tunnel` will be `0.4` and the speed factor of a road segment that has `road_class=secondary` and \n-`road_environment=tunnel` will be `0.8`.\n+Here also quotes around every expression and a comma is used to write one statement per YAML line. \n+Which looks more like JSON which is also possible for server-side profiles and the only way to write custom models at \n+query time:\n \n-Instead of setting the speed factors for certain values you can instead set the speed factors for all *other* values using\n-as special key (`\"*\"`), like this:\n-```yaml\n-speed_factor: \n-  road_class: {\"*\": 0.5}\n-  road_environment: {tunnel: 0.8, \"*\": 0.6}\n+```json\n+{ \"speed\": [\n+    { \"if\": \"road_class == MOTORWAY\", \"multiply by\": 0.5 },\n+    { \"if\": \"road_environment == TUNNEL\", \"multiply by\": 0.8 }\n+  ]\n+}\n ```\n \n-So in this example we set a speed factor of `0.5` regardless of the `road_class` and all `road_environment` values yield\n-a speed factor of `0.6` *except* `tunnel` which gets a speed factor of `0.8`. And as mentioned above for edges that match\n-multiple of these rules the different factors get multiplied.\n+There are other categories like `get_off_bike` that are of `boolean` type. You use them via:\n \n-For encoded values with boolean values, like `get_off_bike` you set the speed factor like this:\n ```yaml\n-speed_factor:\n-  get_off_bike: {true: 0.6, false: 1.0}\n+speed:\n+  - if: get_off_bike\n+    multiply by: 0.6\n ```\n-which means that for edges with `get_off_bike=true` the speed factor will be `0.6` and otherwise it will be `1.0`.\n-You can skip any of these values to retain the default.\n \n-For encoded values with numeric values, like `max_width` you use the `<` and `>` operators, like this:\n+which means that for edges with `get_off_bike==true` the speed factor will be `0.6`.\n+\n+For encoded values with numeric values, like `max_width` you should not use \"equality\" or \"inequality\" but the\n+comparison operators \"bigger\" `>`, \"bigger or equals\" `>=`, \"smaller\" `<` or \"smaller or equals\" `<=`, e.g.:\n ```yaml\n-speed_factor:\n-  max_width: {\"<2.5\": 0.8}\n+speed:\n+  - if: \"max_width < 2.5\", multiply by: 0.8\n ``` \n-which means that for all edges with `max_width` smaller than `2.5m` the speed factor is `0.8`.\n+which means that for all edges with `max_width` smaller than `2.5m` the speed is multiplied by `0.8`.\n \n-In any case values of `speed_factor` have to be in the range `[0,1]` and it is not possible to *increase* the speed for\n-edges of certain types. \n+Then there are categories of `string` type. You use them via:\n \n-Another way to change the speed is using the `max_speed` section, for example:\n ```yaml\n-max_speed:\n-  surface: {gravel: 60}\n+speed:\n+- if: country == \"DEU\"\n+  multiply by: 0\n ```\n \n-implies that on all road segments with `surface=gravel` the speed will be at most `60km/h`, regardless of the default \n-speed of this edge or the adjustments made by the `speed_factor` section. Just like with `speed_factor` you can setup\n-`max_speed` values for multiple category values and different categories. If multiple rules match for a given edge the\n-most restrictive rule will determine the speed (the minimum `max_speed` will be applied). \n-Values for `max_speed` must be in the range `[0,max_vehicle_speed]` where `max_vehicle_speed` is the maximum speed that\n-is set for the base vehicle (which you cannot change).\n+Another way to change the speed is using `limit to`:\n+```yaml\n+speed:\n+  - if: \"surface != GRAVEL\", limit to: 60\n+```\n+\n+This implies that on all road segments with no `GRAVEL` value for `surface` the speed will be at most `60km/h`,\n+regardless of the default speed of this road segment or the previous `multiply by` statements. Just like\n+with `multiply by` you can use multiple category values and different categories in the expressions for `limit to`. \n+If multiple statements match for a given edge the most restrictive statement will determine the speed.\n+\n+Values for `limit to` must be in the range `[0, max_vehicle_speed]` where `max_vehicle_speed` is the maximum speed that\n+is set for the base vehicle, and you cannot change it.\n+\n+An unconditional statement can be used as the last statement to limit the speed to a certain value under all conditions:\n+```yaml\n+speed:\n+  - if: \"true\", limit to: 90\n+```\n+\n+This means that the speed is at most `90km/h` for any road segments regardless of its properties.\n+\n+#### `else`\n+\n+Every `if` statement can have an `else` statement which is evaluated only when the `if`-condition is `false`.\n+\n+#### `else if`\n \n-You can also modify the speed for all edges in a certain area. To do this first add some areas to the `areas` section\n-of the custom model and then use this name to set a `speed_factor` or `max_speed` for this area. In the following\n-example we set the `speed_factor` of an area called `my_area` to `0.7`. For `max_speed` it works the same way. All area\n-names need to be prefixed with `area_`.  \n+If a road segment matches multiple expressions the speed will be multiplied. In this example:", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a4324f5e2a621aa09930022b3bf5db353da6b0c3"}, "originalPosition": 199}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ4NjIwNDE1OnYy", "diffSide": "RIGHT", "path": "docs/core/profiles.md", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wOFQxMDozNTo1NFrOIQNYEw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wOFQxMDozNTo1NFrOIQNYEw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mzg2NzI4Mw==", "bodyText": "0.8*0.5=0.4 to make it more clear why 0.4.", "url": "https://github.com/graphhopper/graphhopper/pull/2209#discussion_r553867283", "createdAt": "2021-01-08T10:35:54Z", "author": {"login": "easbar"}, "path": "docs/core/profiles.md", "diffHunk": "@@ -139,108 +141,152 @@ And there are others that take on a numeric value, like:\n - max_weight\n - max_width\n \n-*Important note: Whenever you want to use any of these categories for a custom profile you need to add them to \n+*Important note: Whenever you want to use any of these categories for a custom profile you need to add them to\n `graph.encoded_values` in `config.yml`.*\n \n ### Setting up a Custom Model\n \n As mentioned above, the custom weighting function has three parameters that you can adjust: speed, priority and\n distance_influence. You can set up rules that determine these parameters from the edge's properties. A set of such rules\n-is called a 'custom model' and it is written in a dedicated YAML format. We will now see how the cost function parameters\n-can be influenced by the different fields of such a custom model.\n+is called a 'custom model' and it is written in a dedicated YAML or JSON format. We will now see how the cost function \n+parameters can be influenced by the different fields of such a custom model.\n   \n #### Customizing `speed`\n \n-For every edge a default speed is inherited from the base vehicle, but you have multiple options to adjust it.\n-The first thing you can do is rescaling the default speeds using the `speed_factor` section. For example this is how you\n-can reduce the the speed of every edge that has the value 'motorway' for the category 'road_class' to fifty percent of \n+For every road segment a default speed is inherited from the base vehicle and you have multiple options to adjust it.\n+The first thing you can do is rescaling the default speeds using `multiply by`. For example this is how you\n+can reduce the speed of every road segment that has the value `MOTORWAY` for the category 'road_class' to fifty percent of \n the default speed that is normally used by the base vehicle for this road class:\n ```yaml\n-speed_factor:\n-  road_class: {motorway: 0.5}\n-```  \n-Note that `road_class: {motorway: 0.5}` is an alternative YAML notation that is equivalent to:\n-```yaml\n-speed_factor:\n-  road_class:\n-    motorway: 0.5\n+speed:\n+  - if: road_class == MOTORWAY\n+    multiply by: 0.5\n ```\n \n-You can also setup speed factors for multiple road classes like this\n+You can also change the speed in case of different road classes like this\n ```yaml\n-speed_factor:\n-  road_class: {motorway: 0.5, primary: 0.7, tertiary: 0.9}\n+speed:\n+  - if: road_class == MOTORWAY\n+    multiply by: 0.5\n+  - if: road_class == PRIMARY || road_class == TERTIARY\n+    multiply by: 0.7\n ```\n \n-and use multiple categories to influence the speed factor\n+The OR-operator `||` means if the left **or** right expressions is true then the value `0.7` is used.\n+You can also use multiple categories in the expressions:\n+\n ```yaml\n-speed_factor:\n-  road_class: {motorway: 0.5}\n-  road_environment: {tunnel: 0.8}\n+speed:\n+  - if: \"road_class == MOTORWAY\",     multiply by: 0.5\n+  - if: \"road_environment == TUNNEL\", multiply by: 0.8\n ```\n \n-If an edge matches multiple rules the speed factor values will be multiplied. For example, here the speed factor of \n-a road segment that has `road_class=motorway` will be `0.5`, the speed factor of a road segment that additionally has \n-`road_environment=tunnel` will be `0.4` and the speed factor of a road segment that has `road_class=secondary` and \n-`road_environment=tunnel` will be `0.8`.\n+Here also quotes around every expression and a comma is used to write one statement per YAML line. \n+Which looks more like JSON which is also possible for server-side profiles and the only way to write custom models at \n+query time:\n \n-Instead of setting the speed factors for certain values you can instead set the speed factors for all *other* values using\n-as special key (`\"*\"`), like this:\n-```yaml\n-speed_factor: \n-  road_class: {\"*\": 0.5}\n-  road_environment: {tunnel: 0.8, \"*\": 0.6}\n+```json\n+{ \"speed\": [\n+    { \"if\": \"road_class == MOTORWAY\", \"multiply by\": 0.5 },\n+    { \"if\": \"road_environment == TUNNEL\", \"multiply by\": 0.8 }\n+  ]\n+}\n ```\n \n-So in this example we set a speed factor of `0.5` regardless of the `road_class` and all `road_environment` values yield\n-a speed factor of `0.6` *except* `tunnel` which gets a speed factor of `0.8`. And as mentioned above for edges that match\n-multiple of these rules the different factors get multiplied.\n+There are other categories like `get_off_bike` that are of `boolean` type. You use them via:\n \n-For encoded values with boolean values, like `get_off_bike` you set the speed factor like this:\n ```yaml\n-speed_factor:\n-  get_off_bike: {true: 0.6, false: 1.0}\n+speed:\n+  - if: get_off_bike\n+    multiply by: 0.6\n ```\n-which means that for edges with `get_off_bike=true` the speed factor will be `0.6` and otherwise it will be `1.0`.\n-You can skip any of these values to retain the default.\n \n-For encoded values with numeric values, like `max_width` you use the `<` and `>` operators, like this:\n+which means that for edges with `get_off_bike==true` the speed factor will be `0.6`.\n+\n+For encoded values with numeric values, like `max_width` you should not use \"equality\" or \"inequality\" but the\n+comparison operators \"bigger\" `>`, \"bigger or equals\" `>=`, \"smaller\" `<` or \"smaller or equals\" `<=`, e.g.:\n ```yaml\n-speed_factor:\n-  max_width: {\"<2.5\": 0.8}\n+speed:\n+  - if: \"max_width < 2.5\", multiply by: 0.8\n ``` \n-which means that for all edges with `max_width` smaller than `2.5m` the speed factor is `0.8`.\n+which means that for all edges with `max_width` smaller than `2.5m` the speed is multiplied by `0.8`.\n \n-In any case values of `speed_factor` have to be in the range `[0,1]` and it is not possible to *increase* the speed for\n-edges of certain types. \n+Then there are categories of `string` type. You use them via:\n \n-Another way to change the speed is using the `max_speed` section, for example:\n ```yaml\n-max_speed:\n-  surface: {gravel: 60}\n+speed:\n+- if: country == \"DEU\"\n+  multiply by: 0\n ```\n \n-implies that on all road segments with `surface=gravel` the speed will be at most `60km/h`, regardless of the default \n-speed of this edge or the adjustments made by the `speed_factor` section. Just like with `speed_factor` you can setup\n-`max_speed` values for multiple category values and different categories. If multiple rules match for a given edge the\n-most restrictive rule will determine the speed (the minimum `max_speed` will be applied). \n-Values for `max_speed` must be in the range `[0,max_vehicle_speed]` where `max_vehicle_speed` is the maximum speed that\n-is set for the base vehicle (which you cannot change).\n+Another way to change the speed is using `limit to`:\n+```yaml\n+speed:\n+  - if: \"surface != GRAVEL\", limit to: 60\n+```\n+\n+This implies that on all road segments with no `GRAVEL` value for `surface` the speed will be at most `60km/h`,\n+regardless of the default speed of this road segment or the previous `multiply by` statements. Just like\n+with `multiply by` you can use multiple category values and different categories in the expressions for `limit to`. \n+If multiple statements match for a given edge the most restrictive statement will determine the speed.\n+\n+Values for `limit to` must be in the range `[0, max_vehicle_speed]` where `max_vehicle_speed` is the maximum speed that\n+is set for the base vehicle, and you cannot change it.\n+\n+An unconditional statement can be used as the last statement to limit the speed to a certain value under all conditions:\n+```yaml\n+speed:\n+  - if: \"true\", limit to: 90\n+```\n+\n+This means that the speed is at most `90km/h` for any road segments regardless of its properties.\n+\n+#### `else`\n+\n+Every `if` statement can have an `else` statement which is evaluated only when the `if`-condition is `false`.\n+\n+#### `else if`\n \n-You can also modify the speed for all edges in a certain area. To do this first add some areas to the `areas` section\n-of the custom model and then use this name to set a `speed_factor` or `max_speed` for this area. In the following\n-example we set the `speed_factor` of an area called `my_area` to `0.7`. For `max_speed` it works the same way. All area\n-names need to be prefixed with `area_`.  \n+If a road segment matches multiple expressions the speed will be multiplied. In this example:\n \n ```yaml\n-speed_factor:\n-  area_my_area: 0.7\n+speed:\n+- if: road_class == MOTORWAY\n+  multiply by: 0.5\n+- if: road_environment == TUNNEL\n+  multiply by: 0.8\n+```\n+\n+the speed of a road segment that has `road_class == MOTORWAY` will be multiplied by `0.5`, for a road segment\n+that additionally has `road_environment == TUNNEL` it will be multiplied by `0.4` and for a road segment that has", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a4324f5e2a621aa09930022b3bf5db353da6b0c3"}, "originalPosition": 212}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ4NjIwNjY0OnYy", "diffSide": "RIGHT", "path": "docs/core/profiles.md", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wOFQxMDozNjozMFrOIQNZdA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wOFQxODoxMzoxNlrOIQcNMQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mzg2NzYzNg==", "bodyText": "road_environment == TUNNEL but road_class == SECONDARY", "url": "https://github.com/graphhopper/graphhopper/pull/2209#discussion_r553867636", "createdAt": "2021-01-08T10:36:30Z", "author": {"login": "easbar"}, "path": "docs/core/profiles.md", "diffHunk": "@@ -139,108 +141,152 @@ And there are others that take on a numeric value, like:\n - max_weight\n - max_width\n \n-*Important note: Whenever you want to use any of these categories for a custom profile you need to add them to \n+*Important note: Whenever you want to use any of these categories for a custom profile you need to add them to\n `graph.encoded_values` in `config.yml`.*\n \n ### Setting up a Custom Model\n \n As mentioned above, the custom weighting function has three parameters that you can adjust: speed, priority and\n distance_influence. You can set up rules that determine these parameters from the edge's properties. A set of such rules\n-is called a 'custom model' and it is written in a dedicated YAML format. We will now see how the cost function parameters\n-can be influenced by the different fields of such a custom model.\n+is called a 'custom model' and it is written in a dedicated YAML or JSON format. We will now see how the cost function \n+parameters can be influenced by the different fields of such a custom model.\n   \n #### Customizing `speed`\n \n-For every edge a default speed is inherited from the base vehicle, but you have multiple options to adjust it.\n-The first thing you can do is rescaling the default speeds using the `speed_factor` section. For example this is how you\n-can reduce the the speed of every edge that has the value 'motorway' for the category 'road_class' to fifty percent of \n+For every road segment a default speed is inherited from the base vehicle and you have multiple options to adjust it.\n+The first thing you can do is rescaling the default speeds using `multiply by`. For example this is how you\n+can reduce the speed of every road segment that has the value `MOTORWAY` for the category 'road_class' to fifty percent of \n the default speed that is normally used by the base vehicle for this road class:\n ```yaml\n-speed_factor:\n-  road_class: {motorway: 0.5}\n-```  \n-Note that `road_class: {motorway: 0.5}` is an alternative YAML notation that is equivalent to:\n-```yaml\n-speed_factor:\n-  road_class:\n-    motorway: 0.5\n+speed:\n+  - if: road_class == MOTORWAY\n+    multiply by: 0.5\n ```\n \n-You can also setup speed factors for multiple road classes like this\n+You can also change the speed in case of different road classes like this\n ```yaml\n-speed_factor:\n-  road_class: {motorway: 0.5, primary: 0.7, tertiary: 0.9}\n+speed:\n+  - if: road_class == MOTORWAY\n+    multiply by: 0.5\n+  - if: road_class == PRIMARY || road_class == TERTIARY\n+    multiply by: 0.7\n ```\n \n-and use multiple categories to influence the speed factor\n+The OR-operator `||` means if the left **or** right expressions is true then the value `0.7` is used.\n+You can also use multiple categories in the expressions:\n+\n ```yaml\n-speed_factor:\n-  road_class: {motorway: 0.5}\n-  road_environment: {tunnel: 0.8}\n+speed:\n+  - if: \"road_class == MOTORWAY\",     multiply by: 0.5\n+  - if: \"road_environment == TUNNEL\", multiply by: 0.8\n ```\n \n-If an edge matches multiple rules the speed factor values will be multiplied. For example, here the speed factor of \n-a road segment that has `road_class=motorway` will be `0.5`, the speed factor of a road segment that additionally has \n-`road_environment=tunnel` will be `0.4` and the speed factor of a road segment that has `road_class=secondary` and \n-`road_environment=tunnel` will be `0.8`.\n+Here also quotes around every expression and a comma is used to write one statement per YAML line. \n+Which looks more like JSON which is also possible for server-side profiles and the only way to write custom models at \n+query time:\n \n-Instead of setting the speed factors for certain values you can instead set the speed factors for all *other* values using\n-as special key (`\"*\"`), like this:\n-```yaml\n-speed_factor: \n-  road_class: {\"*\": 0.5}\n-  road_environment: {tunnel: 0.8, \"*\": 0.6}\n+```json\n+{ \"speed\": [\n+    { \"if\": \"road_class == MOTORWAY\", \"multiply by\": 0.5 },\n+    { \"if\": \"road_environment == TUNNEL\", \"multiply by\": 0.8 }\n+  ]\n+}\n ```\n \n-So in this example we set a speed factor of `0.5` regardless of the `road_class` and all `road_environment` values yield\n-a speed factor of `0.6` *except* `tunnel` which gets a speed factor of `0.8`. And as mentioned above for edges that match\n-multiple of these rules the different factors get multiplied.\n+There are other categories like `get_off_bike` that are of `boolean` type. You use them via:\n \n-For encoded values with boolean values, like `get_off_bike` you set the speed factor like this:\n ```yaml\n-speed_factor:\n-  get_off_bike: {true: 0.6, false: 1.0}\n+speed:\n+  - if: get_off_bike\n+    multiply by: 0.6\n ```\n-which means that for edges with `get_off_bike=true` the speed factor will be `0.6` and otherwise it will be `1.0`.\n-You can skip any of these values to retain the default.\n \n-For encoded values with numeric values, like `max_width` you use the `<` and `>` operators, like this:\n+which means that for edges with `get_off_bike==true` the speed factor will be `0.6`.\n+\n+For encoded values with numeric values, like `max_width` you should not use \"equality\" or \"inequality\" but the\n+comparison operators \"bigger\" `>`, \"bigger or equals\" `>=`, \"smaller\" `<` or \"smaller or equals\" `<=`, e.g.:\n ```yaml\n-speed_factor:\n-  max_width: {\"<2.5\": 0.8}\n+speed:\n+  - if: \"max_width < 2.5\", multiply by: 0.8\n ``` \n-which means that for all edges with `max_width` smaller than `2.5m` the speed factor is `0.8`.\n+which means that for all edges with `max_width` smaller than `2.5m` the speed is multiplied by `0.8`.\n \n-In any case values of `speed_factor` have to be in the range `[0,1]` and it is not possible to *increase* the speed for\n-edges of certain types. \n+Then there are categories of `string` type. You use them via:\n \n-Another way to change the speed is using the `max_speed` section, for example:\n ```yaml\n-max_speed:\n-  surface: {gravel: 60}\n+speed:\n+- if: country == \"DEU\"\n+  multiply by: 0\n ```\n \n-implies that on all road segments with `surface=gravel` the speed will be at most `60km/h`, regardless of the default \n-speed of this edge or the adjustments made by the `speed_factor` section. Just like with `speed_factor` you can setup\n-`max_speed` values for multiple category values and different categories. If multiple rules match for a given edge the\n-most restrictive rule will determine the speed (the minimum `max_speed` will be applied). \n-Values for `max_speed` must be in the range `[0,max_vehicle_speed]` where `max_vehicle_speed` is the maximum speed that\n-is set for the base vehicle (which you cannot change).\n+Another way to change the speed is using `limit to`:\n+```yaml\n+speed:\n+  - if: \"surface != GRAVEL\", limit to: 60\n+```\n+\n+This implies that on all road segments with no `GRAVEL` value for `surface` the speed will be at most `60km/h`,\n+regardless of the default speed of this road segment or the previous `multiply by` statements. Just like\n+with `multiply by` you can use multiple category values and different categories in the expressions for `limit to`. \n+If multiple statements match for a given edge the most restrictive statement will determine the speed.\n+\n+Values for `limit to` must be in the range `[0, max_vehicle_speed]` where `max_vehicle_speed` is the maximum speed that\n+is set for the base vehicle, and you cannot change it.\n+\n+An unconditional statement can be used as the last statement to limit the speed to a certain value under all conditions:\n+```yaml\n+speed:\n+  - if: \"true\", limit to: 90\n+```\n+\n+This means that the speed is at most `90km/h` for any road segments regardless of its properties.\n+\n+#### `else`\n+\n+Every `if` statement can have an `else` statement which is evaluated only when the `if`-condition is `false`.\n+\n+#### `else if`\n \n-You can also modify the speed for all edges in a certain area. To do this first add some areas to the `areas` section\n-of the custom model and then use this name to set a `speed_factor` or `max_speed` for this area. In the following\n-example we set the `speed_factor` of an area called `my_area` to `0.7`. For `max_speed` it works the same way. All area\n-names need to be prefixed with `area_`.  \n+If a road segment matches multiple expressions the speed will be multiplied. In this example:\n \n ```yaml\n-speed_factor:\n-  area_my_area: 0.7\n+speed:\n+- if: road_class == MOTORWAY\n+  multiply by: 0.5\n+- if: road_environment == TUNNEL\n+  multiply by: 0.8\n+```\n+\n+the speed of a road segment that has `road_class == MOTORWAY` will be multiplied by `0.5`, for a road segment\n+that additionally has `road_environment == TUNNEL` it will be multiplied by `0.4` and for a road segment that has\n+`road_class == SECONDARY` and `road_environment == TUNNEL` it will be multiplied by `0.8`. You can avoid the ", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a4324f5e2a621aa09930022b3bf5db353da6b0c3"}, "originalPosition": 213}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mzg5OTUyMg==", "bodyText": "Would you mind to edit the docs until you are satisfied? You suggestions make a lot of sense to me.", "url": "https://github.com/graphhopper/graphhopper/pull/2209#discussion_r553899522", "createdAt": "2021-01-08T11:47:58Z", "author": {"login": "karussell"}, "path": "docs/core/profiles.md", "diffHunk": "@@ -139,108 +141,152 @@ And there are others that take on a numeric value, like:\n - max_weight\n - max_width\n \n-*Important note: Whenever you want to use any of these categories for a custom profile you need to add them to \n+*Important note: Whenever you want to use any of these categories for a custom profile you need to add them to\n `graph.encoded_values` in `config.yml`.*\n \n ### Setting up a Custom Model\n \n As mentioned above, the custom weighting function has three parameters that you can adjust: speed, priority and\n distance_influence. You can set up rules that determine these parameters from the edge's properties. A set of such rules\n-is called a 'custom model' and it is written in a dedicated YAML format. We will now see how the cost function parameters\n-can be influenced by the different fields of such a custom model.\n+is called a 'custom model' and it is written in a dedicated YAML or JSON format. We will now see how the cost function \n+parameters can be influenced by the different fields of such a custom model.\n   \n #### Customizing `speed`\n \n-For every edge a default speed is inherited from the base vehicle, but you have multiple options to adjust it.\n-The first thing you can do is rescaling the default speeds using the `speed_factor` section. For example this is how you\n-can reduce the the speed of every edge that has the value 'motorway' for the category 'road_class' to fifty percent of \n+For every road segment a default speed is inherited from the base vehicle and you have multiple options to adjust it.\n+The first thing you can do is rescaling the default speeds using `multiply by`. For example this is how you\n+can reduce the speed of every road segment that has the value `MOTORWAY` for the category 'road_class' to fifty percent of \n the default speed that is normally used by the base vehicle for this road class:\n ```yaml\n-speed_factor:\n-  road_class: {motorway: 0.5}\n-```  \n-Note that `road_class: {motorway: 0.5}` is an alternative YAML notation that is equivalent to:\n-```yaml\n-speed_factor:\n-  road_class:\n-    motorway: 0.5\n+speed:\n+  - if: road_class == MOTORWAY\n+    multiply by: 0.5\n ```\n \n-You can also setup speed factors for multiple road classes like this\n+You can also change the speed in case of different road classes like this\n ```yaml\n-speed_factor:\n-  road_class: {motorway: 0.5, primary: 0.7, tertiary: 0.9}\n+speed:\n+  - if: road_class == MOTORWAY\n+    multiply by: 0.5\n+  - if: road_class == PRIMARY || road_class == TERTIARY\n+    multiply by: 0.7\n ```\n \n-and use multiple categories to influence the speed factor\n+The OR-operator `||` means if the left **or** right expressions is true then the value `0.7` is used.\n+You can also use multiple categories in the expressions:\n+\n ```yaml\n-speed_factor:\n-  road_class: {motorway: 0.5}\n-  road_environment: {tunnel: 0.8}\n+speed:\n+  - if: \"road_class == MOTORWAY\",     multiply by: 0.5\n+  - if: \"road_environment == TUNNEL\", multiply by: 0.8\n ```\n \n-If an edge matches multiple rules the speed factor values will be multiplied. For example, here the speed factor of \n-a road segment that has `road_class=motorway` will be `0.5`, the speed factor of a road segment that additionally has \n-`road_environment=tunnel` will be `0.4` and the speed factor of a road segment that has `road_class=secondary` and \n-`road_environment=tunnel` will be `0.8`.\n+Here also quotes around every expression and a comma is used to write one statement per YAML line. \n+Which looks more like JSON which is also possible for server-side profiles and the only way to write custom models at \n+query time:\n \n-Instead of setting the speed factors for certain values you can instead set the speed factors for all *other* values using\n-as special key (`\"*\"`), like this:\n-```yaml\n-speed_factor: \n-  road_class: {\"*\": 0.5}\n-  road_environment: {tunnel: 0.8, \"*\": 0.6}\n+```json\n+{ \"speed\": [\n+    { \"if\": \"road_class == MOTORWAY\", \"multiply by\": 0.5 },\n+    { \"if\": \"road_environment == TUNNEL\", \"multiply by\": 0.8 }\n+  ]\n+}\n ```\n \n-So in this example we set a speed factor of `0.5` regardless of the `road_class` and all `road_environment` values yield\n-a speed factor of `0.6` *except* `tunnel` which gets a speed factor of `0.8`. And as mentioned above for edges that match\n-multiple of these rules the different factors get multiplied.\n+There are other categories like `get_off_bike` that are of `boolean` type. You use them via:\n \n-For encoded values with boolean values, like `get_off_bike` you set the speed factor like this:\n ```yaml\n-speed_factor:\n-  get_off_bike: {true: 0.6, false: 1.0}\n+speed:\n+  - if: get_off_bike\n+    multiply by: 0.6\n ```\n-which means that for edges with `get_off_bike=true` the speed factor will be `0.6` and otherwise it will be `1.0`.\n-You can skip any of these values to retain the default.\n \n-For encoded values with numeric values, like `max_width` you use the `<` and `>` operators, like this:\n+which means that for edges with `get_off_bike==true` the speed factor will be `0.6`.\n+\n+For encoded values with numeric values, like `max_width` you should not use \"equality\" or \"inequality\" but the\n+comparison operators \"bigger\" `>`, \"bigger or equals\" `>=`, \"smaller\" `<` or \"smaller or equals\" `<=`, e.g.:\n ```yaml\n-speed_factor:\n-  max_width: {\"<2.5\": 0.8}\n+speed:\n+  - if: \"max_width < 2.5\", multiply by: 0.8\n ``` \n-which means that for all edges with `max_width` smaller than `2.5m` the speed factor is `0.8`.\n+which means that for all edges with `max_width` smaller than `2.5m` the speed is multiplied by `0.8`.\n \n-In any case values of `speed_factor` have to be in the range `[0,1]` and it is not possible to *increase* the speed for\n-edges of certain types. \n+Then there are categories of `string` type. You use them via:\n \n-Another way to change the speed is using the `max_speed` section, for example:\n ```yaml\n-max_speed:\n-  surface: {gravel: 60}\n+speed:\n+- if: country == \"DEU\"\n+  multiply by: 0\n ```\n \n-implies that on all road segments with `surface=gravel` the speed will be at most `60km/h`, regardless of the default \n-speed of this edge or the adjustments made by the `speed_factor` section. Just like with `speed_factor` you can setup\n-`max_speed` values for multiple category values and different categories. If multiple rules match for a given edge the\n-most restrictive rule will determine the speed (the minimum `max_speed` will be applied). \n-Values for `max_speed` must be in the range `[0,max_vehicle_speed]` where `max_vehicle_speed` is the maximum speed that\n-is set for the base vehicle (which you cannot change).\n+Another way to change the speed is using `limit to`:\n+```yaml\n+speed:\n+  - if: \"surface != GRAVEL\", limit to: 60\n+```\n+\n+This implies that on all road segments with no `GRAVEL` value for `surface` the speed will be at most `60km/h`,\n+regardless of the default speed of this road segment or the previous `multiply by` statements. Just like\n+with `multiply by` you can use multiple category values and different categories in the expressions for `limit to`. \n+If multiple statements match for a given edge the most restrictive statement will determine the speed.\n+\n+Values for `limit to` must be in the range `[0, max_vehicle_speed]` where `max_vehicle_speed` is the maximum speed that\n+is set for the base vehicle, and you cannot change it.\n+\n+An unconditional statement can be used as the last statement to limit the speed to a certain value under all conditions:\n+```yaml\n+speed:\n+  - if: \"true\", limit to: 90\n+```\n+\n+This means that the speed is at most `90km/h` for any road segments regardless of its properties.\n+\n+#### `else`\n+\n+Every `if` statement can have an `else` statement which is evaluated only when the `if`-condition is `false`.\n+\n+#### `else if`\n \n-You can also modify the speed for all edges in a certain area. To do this first add some areas to the `areas` section\n-of the custom model and then use this name to set a `speed_factor` or `max_speed` for this area. In the following\n-example we set the `speed_factor` of an area called `my_area` to `0.7`. For `max_speed` it works the same way. All area\n-names need to be prefixed with `area_`.  \n+If a road segment matches multiple expressions the speed will be multiplied. In this example:\n \n ```yaml\n-speed_factor:\n-  area_my_area: 0.7\n+speed:\n+- if: road_class == MOTORWAY\n+  multiply by: 0.5\n+- if: road_environment == TUNNEL\n+  multiply by: 0.8\n+```\n+\n+the speed of a road segment that has `road_class == MOTORWAY` will be multiplied by `0.5`, for a road segment\n+that additionally has `road_environment == TUNNEL` it will be multiplied by `0.4` and for a road segment that has\n+`road_class == SECONDARY` and `road_environment == TUNNEL` it will be multiplied by `0.8`. You can avoid the ", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mzg2NzYzNg=="}, "originalCommit": {"oid": "a4324f5e2a621aa09930022b3bf5db353da6b0c3"}, "originalPosition": 213}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzkwNDUyMQ==", "bodyText": "ok will do", "url": "https://github.com/graphhopper/graphhopper/pull/2209#discussion_r553904521", "createdAt": "2021-01-08T12:00:11Z", "author": {"login": "easbar"}, "path": "docs/core/profiles.md", "diffHunk": "@@ -139,108 +141,152 @@ And there are others that take on a numeric value, like:\n - max_weight\n - max_width\n \n-*Important note: Whenever you want to use any of these categories for a custom profile you need to add them to \n+*Important note: Whenever you want to use any of these categories for a custom profile you need to add them to\n `graph.encoded_values` in `config.yml`.*\n \n ### Setting up a Custom Model\n \n As mentioned above, the custom weighting function has three parameters that you can adjust: speed, priority and\n distance_influence. You can set up rules that determine these parameters from the edge's properties. A set of such rules\n-is called a 'custom model' and it is written in a dedicated YAML format. We will now see how the cost function parameters\n-can be influenced by the different fields of such a custom model.\n+is called a 'custom model' and it is written in a dedicated YAML or JSON format. We will now see how the cost function \n+parameters can be influenced by the different fields of such a custom model.\n   \n #### Customizing `speed`\n \n-For every edge a default speed is inherited from the base vehicle, but you have multiple options to adjust it.\n-The first thing you can do is rescaling the default speeds using the `speed_factor` section. For example this is how you\n-can reduce the the speed of every edge that has the value 'motorway' for the category 'road_class' to fifty percent of \n+For every road segment a default speed is inherited from the base vehicle and you have multiple options to adjust it.\n+The first thing you can do is rescaling the default speeds using `multiply by`. For example this is how you\n+can reduce the speed of every road segment that has the value `MOTORWAY` for the category 'road_class' to fifty percent of \n the default speed that is normally used by the base vehicle for this road class:\n ```yaml\n-speed_factor:\n-  road_class: {motorway: 0.5}\n-```  \n-Note that `road_class: {motorway: 0.5}` is an alternative YAML notation that is equivalent to:\n-```yaml\n-speed_factor:\n-  road_class:\n-    motorway: 0.5\n+speed:\n+  - if: road_class == MOTORWAY\n+    multiply by: 0.5\n ```\n \n-You can also setup speed factors for multiple road classes like this\n+You can also change the speed in case of different road classes like this\n ```yaml\n-speed_factor:\n-  road_class: {motorway: 0.5, primary: 0.7, tertiary: 0.9}\n+speed:\n+  - if: road_class == MOTORWAY\n+    multiply by: 0.5\n+  - if: road_class == PRIMARY || road_class == TERTIARY\n+    multiply by: 0.7\n ```\n \n-and use multiple categories to influence the speed factor\n+The OR-operator `||` means if the left **or** right expressions is true then the value `0.7` is used.\n+You can also use multiple categories in the expressions:\n+\n ```yaml\n-speed_factor:\n-  road_class: {motorway: 0.5}\n-  road_environment: {tunnel: 0.8}\n+speed:\n+  - if: \"road_class == MOTORWAY\",     multiply by: 0.5\n+  - if: \"road_environment == TUNNEL\", multiply by: 0.8\n ```\n \n-If an edge matches multiple rules the speed factor values will be multiplied. For example, here the speed factor of \n-a road segment that has `road_class=motorway` will be `0.5`, the speed factor of a road segment that additionally has \n-`road_environment=tunnel` will be `0.4` and the speed factor of a road segment that has `road_class=secondary` and \n-`road_environment=tunnel` will be `0.8`.\n+Here also quotes around every expression and a comma is used to write one statement per YAML line. \n+Which looks more like JSON which is also possible for server-side profiles and the only way to write custom models at \n+query time:\n \n-Instead of setting the speed factors for certain values you can instead set the speed factors for all *other* values using\n-as special key (`\"*\"`), like this:\n-```yaml\n-speed_factor: \n-  road_class: {\"*\": 0.5}\n-  road_environment: {tunnel: 0.8, \"*\": 0.6}\n+```json\n+{ \"speed\": [\n+    { \"if\": \"road_class == MOTORWAY\", \"multiply by\": 0.5 },\n+    { \"if\": \"road_environment == TUNNEL\", \"multiply by\": 0.8 }\n+  ]\n+}\n ```\n \n-So in this example we set a speed factor of `0.5` regardless of the `road_class` and all `road_environment` values yield\n-a speed factor of `0.6` *except* `tunnel` which gets a speed factor of `0.8`. And as mentioned above for edges that match\n-multiple of these rules the different factors get multiplied.\n+There are other categories like `get_off_bike` that are of `boolean` type. You use them via:\n \n-For encoded values with boolean values, like `get_off_bike` you set the speed factor like this:\n ```yaml\n-speed_factor:\n-  get_off_bike: {true: 0.6, false: 1.0}\n+speed:\n+  - if: get_off_bike\n+    multiply by: 0.6\n ```\n-which means that for edges with `get_off_bike=true` the speed factor will be `0.6` and otherwise it will be `1.0`.\n-You can skip any of these values to retain the default.\n \n-For encoded values with numeric values, like `max_width` you use the `<` and `>` operators, like this:\n+which means that for edges with `get_off_bike==true` the speed factor will be `0.6`.\n+\n+For encoded values with numeric values, like `max_width` you should not use \"equality\" or \"inequality\" but the\n+comparison operators \"bigger\" `>`, \"bigger or equals\" `>=`, \"smaller\" `<` or \"smaller or equals\" `<=`, e.g.:\n ```yaml\n-speed_factor:\n-  max_width: {\"<2.5\": 0.8}\n+speed:\n+  - if: \"max_width < 2.5\", multiply by: 0.8\n ``` \n-which means that for all edges with `max_width` smaller than `2.5m` the speed factor is `0.8`.\n+which means that for all edges with `max_width` smaller than `2.5m` the speed is multiplied by `0.8`.\n \n-In any case values of `speed_factor` have to be in the range `[0,1]` and it is not possible to *increase* the speed for\n-edges of certain types. \n+Then there are categories of `string` type. You use them via:\n \n-Another way to change the speed is using the `max_speed` section, for example:\n ```yaml\n-max_speed:\n-  surface: {gravel: 60}\n+speed:\n+- if: country == \"DEU\"\n+  multiply by: 0\n ```\n \n-implies that on all road segments with `surface=gravel` the speed will be at most `60km/h`, regardless of the default \n-speed of this edge or the adjustments made by the `speed_factor` section. Just like with `speed_factor` you can setup\n-`max_speed` values for multiple category values and different categories. If multiple rules match for a given edge the\n-most restrictive rule will determine the speed (the minimum `max_speed` will be applied). \n-Values for `max_speed` must be in the range `[0,max_vehicle_speed]` where `max_vehicle_speed` is the maximum speed that\n-is set for the base vehicle (which you cannot change).\n+Another way to change the speed is using `limit to`:\n+```yaml\n+speed:\n+  - if: \"surface != GRAVEL\", limit to: 60\n+```\n+\n+This implies that on all road segments with no `GRAVEL` value for `surface` the speed will be at most `60km/h`,\n+regardless of the default speed of this road segment or the previous `multiply by` statements. Just like\n+with `multiply by` you can use multiple category values and different categories in the expressions for `limit to`. \n+If multiple statements match for a given edge the most restrictive statement will determine the speed.\n+\n+Values for `limit to` must be in the range `[0, max_vehicle_speed]` where `max_vehicle_speed` is the maximum speed that\n+is set for the base vehicle, and you cannot change it.\n+\n+An unconditional statement can be used as the last statement to limit the speed to a certain value under all conditions:\n+```yaml\n+speed:\n+  - if: \"true\", limit to: 90\n+```\n+\n+This means that the speed is at most `90km/h` for any road segments regardless of its properties.\n+\n+#### `else`\n+\n+Every `if` statement can have an `else` statement which is evaluated only when the `if`-condition is `false`.\n+\n+#### `else if`\n \n-You can also modify the speed for all edges in a certain area. To do this first add some areas to the `areas` section\n-of the custom model and then use this name to set a `speed_factor` or `max_speed` for this area. In the following\n-example we set the `speed_factor` of an area called `my_area` to `0.7`. For `max_speed` it works the same way. All area\n-names need to be prefixed with `area_`.  \n+If a road segment matches multiple expressions the speed will be multiplied. In this example:\n \n ```yaml\n-speed_factor:\n-  area_my_area: 0.7\n+speed:\n+- if: road_class == MOTORWAY\n+  multiply by: 0.5\n+- if: road_environment == TUNNEL\n+  multiply by: 0.8\n+```\n+\n+the speed of a road segment that has `road_class == MOTORWAY` will be multiplied by `0.5`, for a road segment\n+that additionally has `road_environment == TUNNEL` it will be multiplied by `0.4` and for a road segment that has\n+`road_class == SECONDARY` and `road_environment == TUNNEL` it will be multiplied by `0.8`. You can avoid the ", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mzg2NzYzNg=="}, "originalCommit": {"oid": "a4324f5e2a621aa09930022b3bf5db353da6b0c3"}, "originalPosition": 213}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDExMDI1Nw==", "bodyText": "-> 5cd2762 I went through the whole thing top to bottom, I hope its better than before. Feel free to revert/edit/complain :)", "url": "https://github.com/graphhopper/graphhopper/pull/2209#discussion_r554110257", "createdAt": "2021-01-08T18:13:16Z", "author": {"login": "easbar"}, "path": "docs/core/profiles.md", "diffHunk": "@@ -139,108 +141,152 @@ And there are others that take on a numeric value, like:\n - max_weight\n - max_width\n \n-*Important note: Whenever you want to use any of these categories for a custom profile you need to add them to \n+*Important note: Whenever you want to use any of these categories for a custom profile you need to add them to\n `graph.encoded_values` in `config.yml`.*\n \n ### Setting up a Custom Model\n \n As mentioned above, the custom weighting function has three parameters that you can adjust: speed, priority and\n distance_influence. You can set up rules that determine these parameters from the edge's properties. A set of such rules\n-is called a 'custom model' and it is written in a dedicated YAML format. We will now see how the cost function parameters\n-can be influenced by the different fields of such a custom model.\n+is called a 'custom model' and it is written in a dedicated YAML or JSON format. We will now see how the cost function \n+parameters can be influenced by the different fields of such a custom model.\n   \n #### Customizing `speed`\n \n-For every edge a default speed is inherited from the base vehicle, but you have multiple options to adjust it.\n-The first thing you can do is rescaling the default speeds using the `speed_factor` section. For example this is how you\n-can reduce the the speed of every edge that has the value 'motorway' for the category 'road_class' to fifty percent of \n+For every road segment a default speed is inherited from the base vehicle and you have multiple options to adjust it.\n+The first thing you can do is rescaling the default speeds using `multiply by`. For example this is how you\n+can reduce the speed of every road segment that has the value `MOTORWAY` for the category 'road_class' to fifty percent of \n the default speed that is normally used by the base vehicle for this road class:\n ```yaml\n-speed_factor:\n-  road_class: {motorway: 0.5}\n-```  \n-Note that `road_class: {motorway: 0.5}` is an alternative YAML notation that is equivalent to:\n-```yaml\n-speed_factor:\n-  road_class:\n-    motorway: 0.5\n+speed:\n+  - if: road_class == MOTORWAY\n+    multiply by: 0.5\n ```\n \n-You can also setup speed factors for multiple road classes like this\n+You can also change the speed in case of different road classes like this\n ```yaml\n-speed_factor:\n-  road_class: {motorway: 0.5, primary: 0.7, tertiary: 0.9}\n+speed:\n+  - if: road_class == MOTORWAY\n+    multiply by: 0.5\n+  - if: road_class == PRIMARY || road_class == TERTIARY\n+    multiply by: 0.7\n ```\n \n-and use multiple categories to influence the speed factor\n+The OR-operator `||` means if the left **or** right expressions is true then the value `0.7` is used.\n+You can also use multiple categories in the expressions:\n+\n ```yaml\n-speed_factor:\n-  road_class: {motorway: 0.5}\n-  road_environment: {tunnel: 0.8}\n+speed:\n+  - if: \"road_class == MOTORWAY\",     multiply by: 0.5\n+  - if: \"road_environment == TUNNEL\", multiply by: 0.8\n ```\n \n-If an edge matches multiple rules the speed factor values will be multiplied. For example, here the speed factor of \n-a road segment that has `road_class=motorway` will be `0.5`, the speed factor of a road segment that additionally has \n-`road_environment=tunnel` will be `0.4` and the speed factor of a road segment that has `road_class=secondary` and \n-`road_environment=tunnel` will be `0.8`.\n+Here also quotes around every expression and a comma is used to write one statement per YAML line. \n+Which looks more like JSON which is also possible for server-side profiles and the only way to write custom models at \n+query time:\n \n-Instead of setting the speed factors for certain values you can instead set the speed factors for all *other* values using\n-as special key (`\"*\"`), like this:\n-```yaml\n-speed_factor: \n-  road_class: {\"*\": 0.5}\n-  road_environment: {tunnel: 0.8, \"*\": 0.6}\n+```json\n+{ \"speed\": [\n+    { \"if\": \"road_class == MOTORWAY\", \"multiply by\": 0.5 },\n+    { \"if\": \"road_environment == TUNNEL\", \"multiply by\": 0.8 }\n+  ]\n+}\n ```\n \n-So in this example we set a speed factor of `0.5` regardless of the `road_class` and all `road_environment` values yield\n-a speed factor of `0.6` *except* `tunnel` which gets a speed factor of `0.8`. And as mentioned above for edges that match\n-multiple of these rules the different factors get multiplied.\n+There are other categories like `get_off_bike` that are of `boolean` type. You use them via:\n \n-For encoded values with boolean values, like `get_off_bike` you set the speed factor like this:\n ```yaml\n-speed_factor:\n-  get_off_bike: {true: 0.6, false: 1.0}\n+speed:\n+  - if: get_off_bike\n+    multiply by: 0.6\n ```\n-which means that for edges with `get_off_bike=true` the speed factor will be `0.6` and otherwise it will be `1.0`.\n-You can skip any of these values to retain the default.\n \n-For encoded values with numeric values, like `max_width` you use the `<` and `>` operators, like this:\n+which means that for edges with `get_off_bike==true` the speed factor will be `0.6`.\n+\n+For encoded values with numeric values, like `max_width` you should not use \"equality\" or \"inequality\" but the\n+comparison operators \"bigger\" `>`, \"bigger or equals\" `>=`, \"smaller\" `<` or \"smaller or equals\" `<=`, e.g.:\n ```yaml\n-speed_factor:\n-  max_width: {\"<2.5\": 0.8}\n+speed:\n+  - if: \"max_width < 2.5\", multiply by: 0.8\n ``` \n-which means that for all edges with `max_width` smaller than `2.5m` the speed factor is `0.8`.\n+which means that for all edges with `max_width` smaller than `2.5m` the speed is multiplied by `0.8`.\n \n-In any case values of `speed_factor` have to be in the range `[0,1]` and it is not possible to *increase* the speed for\n-edges of certain types. \n+Then there are categories of `string` type. You use them via:\n \n-Another way to change the speed is using the `max_speed` section, for example:\n ```yaml\n-max_speed:\n-  surface: {gravel: 60}\n+speed:\n+- if: country == \"DEU\"\n+  multiply by: 0\n ```\n \n-implies that on all road segments with `surface=gravel` the speed will be at most `60km/h`, regardless of the default \n-speed of this edge or the adjustments made by the `speed_factor` section. Just like with `speed_factor` you can setup\n-`max_speed` values for multiple category values and different categories. If multiple rules match for a given edge the\n-most restrictive rule will determine the speed (the minimum `max_speed` will be applied). \n-Values for `max_speed` must be in the range `[0,max_vehicle_speed]` where `max_vehicle_speed` is the maximum speed that\n-is set for the base vehicle (which you cannot change).\n+Another way to change the speed is using `limit to`:\n+```yaml\n+speed:\n+  - if: \"surface != GRAVEL\", limit to: 60\n+```\n+\n+This implies that on all road segments with no `GRAVEL` value for `surface` the speed will be at most `60km/h`,\n+regardless of the default speed of this road segment or the previous `multiply by` statements. Just like\n+with `multiply by` you can use multiple category values and different categories in the expressions for `limit to`. \n+If multiple statements match for a given edge the most restrictive statement will determine the speed.\n+\n+Values for `limit to` must be in the range `[0, max_vehicle_speed]` where `max_vehicle_speed` is the maximum speed that\n+is set for the base vehicle, and you cannot change it.\n+\n+An unconditional statement can be used as the last statement to limit the speed to a certain value under all conditions:\n+```yaml\n+speed:\n+  - if: \"true\", limit to: 90\n+```\n+\n+This means that the speed is at most `90km/h` for any road segments regardless of its properties.\n+\n+#### `else`\n+\n+Every `if` statement can have an `else` statement which is evaluated only when the `if`-condition is `false`.\n+\n+#### `else if`\n \n-You can also modify the speed for all edges in a certain area. To do this first add some areas to the `areas` section\n-of the custom model and then use this name to set a `speed_factor` or `max_speed` for this area. In the following\n-example we set the `speed_factor` of an area called `my_area` to `0.7`. For `max_speed` it works the same way. All area\n-names need to be prefixed with `area_`.  \n+If a road segment matches multiple expressions the speed will be multiplied. In this example:\n \n ```yaml\n-speed_factor:\n-  area_my_area: 0.7\n+speed:\n+- if: road_class == MOTORWAY\n+  multiply by: 0.5\n+- if: road_environment == TUNNEL\n+  multiply by: 0.8\n+```\n+\n+the speed of a road segment that has `road_class == MOTORWAY` will be multiplied by `0.5`, for a road segment\n+that additionally has `road_environment == TUNNEL` it will be multiplied by `0.4` and for a road segment that has\n+`road_class == SECONDARY` and `road_environment == TUNNEL` it will be multiplied by `0.8`. You can avoid the ", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mzg2NzYzNg=="}, "originalCommit": {"oid": "a4324f5e2a621aa09930022b3bf5db353da6b0c3"}, "originalPosition": 213}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ4Nzc3Nzc0OnYy", "diffSide": "RIGHT", "path": "api/src/main/java/com/graphhopper/util/CustomModel.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wOFQxODoxNzoxOVrOIQcU-A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xMVQxODo1NTo0OFrOIRi6XQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDExMjI0OA==", "bodyText": "But what if we set distance_influence to some value on the server side (say 50) and we want to set it to DEFAULT_D_I in a query? And can we rename DEFAULT_D_I to DEFAULT_DISTANCE_INFLUENCE? _D_I looks so cryptic.", "url": "https://github.com/graphhopper/graphhopper/pull/2209#discussion_r554112248", "createdAt": "2021-01-08T18:17:19Z", "author": {"login": "easbar"}, "path": "api/src/main/java/com/graphhopper/util/CustomModel.java", "diffHunk": "@@ -126,43 +136,38 @@ public String toString() {\n \n     private String createContentString() {\n         // used to check against stored custom models, see #2026\n-        return \"distanceInfluence=\" + distanceInfluence + \"|speedFactor=\" + speedFactorMap + \"|maxSpeed=\" + maxSpeedMap +\n-                \"|maxSpeedFallback=\" + maxSpeedFallback + \"|priorityMap=\" + priorityMap + \"|areas=\" + areas;\n+        return \"distanceInfluence=\" + distanceInfluence + \"|headingPenalty=\" + headingPenalty\n+                + \"|speedStatements=\" + speedStatements + \"|priorityStatements=\" + priorityStatements + \"|areas=\" + areas;\n     }\n \n     /**\n      * A new CustomModel is created from the baseModel merged with the specified queryModel.\n      */\n     public static CustomModel merge(CustomModel baseModel, CustomModel queryModel) {\n-        // avoid changing the specified CustomModel via deep copy otherwise the server-side CustomModel would be modified (same problem if queryModel would be used as target)\n+        if (queryModel.isInternal())\n+            throw new IllegalArgumentException(\"CustomModel in query cannot be internal\");\n+\n+        // avoid changing the specified CustomModel via deep copy otherwise the server-side CustomModel would be\n+        // modified (same problem if queryModel would be used as target)\n         CustomModel mergedCM = new CustomModel(baseModel);\n-        if (queryModel.maxSpeedFallback != null) {\n-            if (mergedCM.maxSpeedFallback != null && mergedCM.maxSpeedFallback > queryModel.maxSpeedFallback)\n-                throw new IllegalArgumentException(\"CustomModel in query can only use max_speed_fallback bigger or equal to \" + mergedCM.maxSpeedFallback);\n-            mergedCM.maxSpeedFallback = queryModel.maxSpeedFallback;\n-        }\n+        // we only overwrite the distance influence if a non-default value was used\n         if (Math.abs(queryModel.distanceInfluence - CustomModel.DEFAULT_D_I) > 0.01) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5cd2762c32ef2d93de16a38b61fb624588893ff3"}, "originalPosition": 124}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTIxMjc5Nw==", "bodyText": "Renamed it.\n\nBut what if we set distance_influence to some value on the server side (say 50) and we want to set it to DEFAULT_D_I in a query?\n\nAh, we probably need a Double instead of double that is null if not set in the query?", "url": "https://github.com/graphhopper/graphhopper/pull/2209#discussion_r555212797", "createdAt": "2021-01-11T17:21:03Z", "author": {"login": "karussell"}, "path": "api/src/main/java/com/graphhopper/util/CustomModel.java", "diffHunk": "@@ -126,43 +136,38 @@ public String toString() {\n \n     private String createContentString() {\n         // used to check against stored custom models, see #2026\n-        return \"distanceInfluence=\" + distanceInfluence + \"|speedFactor=\" + speedFactorMap + \"|maxSpeed=\" + maxSpeedMap +\n-                \"|maxSpeedFallback=\" + maxSpeedFallback + \"|priorityMap=\" + priorityMap + \"|areas=\" + areas;\n+        return \"distanceInfluence=\" + distanceInfluence + \"|headingPenalty=\" + headingPenalty\n+                + \"|speedStatements=\" + speedStatements + \"|priorityStatements=\" + priorityStatements + \"|areas=\" + areas;\n     }\n \n     /**\n      * A new CustomModel is created from the baseModel merged with the specified queryModel.\n      */\n     public static CustomModel merge(CustomModel baseModel, CustomModel queryModel) {\n-        // avoid changing the specified CustomModel via deep copy otherwise the server-side CustomModel would be modified (same problem if queryModel would be used as target)\n+        if (queryModel.isInternal())\n+            throw new IllegalArgumentException(\"CustomModel in query cannot be internal\");\n+\n+        // avoid changing the specified CustomModel via deep copy otherwise the server-side CustomModel would be\n+        // modified (same problem if queryModel would be used as target)\n         CustomModel mergedCM = new CustomModel(baseModel);\n-        if (queryModel.maxSpeedFallback != null) {\n-            if (mergedCM.maxSpeedFallback != null && mergedCM.maxSpeedFallback > queryModel.maxSpeedFallback)\n-                throw new IllegalArgumentException(\"CustomModel in query can only use max_speed_fallback bigger or equal to \" + mergedCM.maxSpeedFallback);\n-            mergedCM.maxSpeedFallback = queryModel.maxSpeedFallback;\n-        }\n+        // we only overwrite the distance influence if a non-default value was used\n         if (Math.abs(queryModel.distanceInfluence - CustomModel.DEFAULT_D_I) > 0.01) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDExMjI0OA=="}, "originalCommit": {"oid": "5cd2762c32ef2d93de16a38b61fb624588893ff3"}, "originalPosition": 124}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTI2ODcwMQ==", "bodyText": "Yes with a Double we can better recognize the value was 'not given'.", "url": "https://github.com/graphhopper/graphhopper/pull/2209#discussion_r555268701", "createdAt": "2021-01-11T18:55:48Z", "author": {"login": "easbar"}, "path": "api/src/main/java/com/graphhopper/util/CustomModel.java", "diffHunk": "@@ -126,43 +136,38 @@ public String toString() {\n \n     private String createContentString() {\n         // used to check against stored custom models, see #2026\n-        return \"distanceInfluence=\" + distanceInfluence + \"|speedFactor=\" + speedFactorMap + \"|maxSpeed=\" + maxSpeedMap +\n-                \"|maxSpeedFallback=\" + maxSpeedFallback + \"|priorityMap=\" + priorityMap + \"|areas=\" + areas;\n+        return \"distanceInfluence=\" + distanceInfluence + \"|headingPenalty=\" + headingPenalty\n+                + \"|speedStatements=\" + speedStatements + \"|priorityStatements=\" + priorityStatements + \"|areas=\" + areas;\n     }\n \n     /**\n      * A new CustomModel is created from the baseModel merged with the specified queryModel.\n      */\n     public static CustomModel merge(CustomModel baseModel, CustomModel queryModel) {\n-        // avoid changing the specified CustomModel via deep copy otherwise the server-side CustomModel would be modified (same problem if queryModel would be used as target)\n+        if (queryModel.isInternal())\n+            throw new IllegalArgumentException(\"CustomModel in query cannot be internal\");\n+\n+        // avoid changing the specified CustomModel via deep copy otherwise the server-side CustomModel would be\n+        // modified (same problem if queryModel would be used as target)\n         CustomModel mergedCM = new CustomModel(baseModel);\n-        if (queryModel.maxSpeedFallback != null) {\n-            if (mergedCM.maxSpeedFallback != null && mergedCM.maxSpeedFallback > queryModel.maxSpeedFallback)\n-                throw new IllegalArgumentException(\"CustomModel in query can only use max_speed_fallback bigger or equal to \" + mergedCM.maxSpeedFallback);\n-            mergedCM.maxSpeedFallback = queryModel.maxSpeedFallback;\n-        }\n+        // we only overwrite the distance influence if a non-default value was used\n         if (Math.abs(queryModel.distanceInfluence - CustomModel.DEFAULT_D_I) > 0.01) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDExMjI0OA=="}, "originalCommit": {"oid": "5cd2762c32ef2d93de16a38b61fb624588893ff3"}, "originalPosition": 124}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ4Nzk4MTI4OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/com/graphhopper/routing/weighting/custom/ExpressionVisitor.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wOFQxOToyMzoyMlrOIQeSvA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xNVQxNTozNzowNFrOIUhQbQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDE0NDQ0NA==", "bodyText": "I got this error when I used the 'Example' of the flex box in GH maps because I was missing the max_weight encoded value. The error read:\nCannot compile expression , priority_user_statements invalid simple condition: max_weight > 3\n\nCan we provide a more meaningful error message, e.g. state that the max_weight encoded value is missing, and maybe which ones are available? Debugging custom models is probably very frustrating without detailed error messages.", "url": "https://github.com/graphhopper/graphhopper/pull/2209#discussion_r554144444", "createdAt": "2021-01-08T19:23:22Z", "author": {"login": "easbar"}, "path": "core/src/main/java/com/graphhopper/routing/weighting/custom/ExpressionVisitor.java", "diffHunk": "@@ -0,0 +1,223 @@\n+/*\n+ *  Licensed to GraphHopper GmbH under one or more contributor\n+ *  license agreements. See the NOTICE file distributed with this work for\n+ *  additional information regarding copyright ownership.\n+ *\n+ *  GraphHopper GmbH licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except in\n+ *  compliance with the License. You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package com.graphhopper.routing.weighting.custom;\n+\n+import com.graphhopper.json.Statement;\n+import com.graphhopper.routing.ev.EncodedValueLookup;\n+import com.graphhopper.routing.ev.RouteNetwork;\n+import com.graphhopper.routing.ev.StringEncodedValue;\n+import com.graphhopper.util.Helper;\n+import org.codehaus.janino.Scanner;\n+import org.codehaus.janino.*;\n+\n+import java.io.StringReader;\n+import java.util.*;\n+\n+import static com.graphhopper.routing.weighting.custom.CustomModelParser.IN_AREA_PREFIX;\n+\n+class ExpressionVisitor implements Visitor.AtomVisitor<Boolean, Exception> {\n+\n+    private final ParseResult result;\n+    private final EncodedValueLookup lookup;\n+    private final TreeMap<Integer, Replacement> replacements = new TreeMap<>();\n+    private final NameValidator nameValidator;\n+    private final Set<String> allowedMethods = new HashSet<>(Arrays.asList(\"ordinal\", \"getDistance\", \"getName\",\n+            \"contains\", \"sqrt\", \"abs\"));\n+\n+    public ExpressionVisitor(ParseResult result, NameValidator nameValidator, EncodedValueLookup lookup) {\n+        this.result = result;\n+        this.nameValidator = nameValidator;\n+        this.lookup = lookup;\n+    }\n+\n+    // allow only methods and other identifiers (constants and encoded values)\n+    boolean isValidIdentifier(String identifier) {\n+        if (nameValidator.isValid(identifier)) {\n+            if (!Character.isUpperCase(identifier.charAt(0)))\n+                result.guessedVariables.add(identifier);\n+            return true;\n+        }\n+        return false;\n+    }\n+\n+    @Override\n+    public Boolean visitRvalue(Java.Rvalue rv) throws Exception {\n+        if (rv instanceof Java.AmbiguousName) {\n+            Java.AmbiguousName n = (Java.AmbiguousName) rv;\n+            if (n.identifiers.length == 1) {\n+                String arg = n.identifiers[0];\n+                if (arg.startsWith(IN_AREA_PREFIX)) {\n+                    int start = rv.getLocation().getColumnNumber() - 1;\n+                    replacements.put(start, new Replacement(start, arg.length(),\n+                            CustomWeightingHelper.class.getSimpleName() + \".in(this.\" + arg + \", edge)\"));\n+                    result.guessedVariables.add(arg);\n+                    return true;\n+                } else {\n+                    // e.g. like road_class\n+                    return isValidIdentifier(arg);\n+                }\n+            }\n+            return false;\n+        }\n+        if (rv instanceof Java.Literal)\n+            return true;\n+        if (rv instanceof Java.MethodInvocation) {\n+            Java.MethodInvocation mi = (Java.MethodInvocation) rv;\n+            if (allowedMethods.contains(mi.methodName)) {\n+                // skip methods like this.in() for now\n+                if (mi.target == null)\n+                    return false;\n+                // edge.getDistance, Math.sqrt => check target name (edge or Math)\n+                Java.AmbiguousName n = (Java.AmbiguousName) mi.target.toRvalue();\n+                return n.identifiers.length == 2 && isValidIdentifier(n.identifiers[0]);\n+            }\n+            return false;\n+        }\n+        if (rv instanceof Java.BinaryOperation) {\n+            Java.BinaryOperation binOp = (Java.BinaryOperation) rv;\n+            int startRH = binOp.rhs.getLocation().getColumnNumber() - 1;\n+            if (binOp.lhs instanceof Java.AmbiguousName && ((Java.AmbiguousName) binOp.lhs).identifiers.length == 1) {\n+                String lhVarAsString = ((Java.AmbiguousName) binOp.lhs).identifiers[0];\n+                boolean eqOps = binOp.operator.equals(\"==\") || binOp.operator.equals(\"!=\");\n+                if (binOp.rhs instanceof Java.StringLiteral) {\n+                    // replace String with its index for faster comparison (?) and skipping the Map<String, Integer> lookup at runtime\n+                    if (lookup.hasEncodedValue(lhVarAsString)) {\n+                        if (!eqOps)\n+                            throw new IllegalArgumentException(\"Operator \" + binOp.operator + \" not allowed for String\");\n+                        StringEncodedValue ev = lookup.getStringEncodedValue(lhVarAsString);\n+                        String str = ((Java.StringLiteral) binOp.rhs).value;\n+                        int integ = ev.indexOf(str.substring(1, str.length() - 1));\n+                        if (integ == 0) integ = -1; // 0 means not found and this should always trigger inequality\n+                        replacements.put(startRH, new Replacement(startRH, str.length(), \"\" + integ));\n+                    }\n+                } else if (binOp.rhs instanceof Java.AmbiguousName && ((Java.AmbiguousName) binOp.rhs).identifiers.length == 1) {\n+                    // Make enum explicit as NO or OTHER can occur in other enums so convert \"toll == NO\" to \"toll == Toll.NO\"\n+                    String rhValue = ((Java.AmbiguousName) binOp.rhs).identifiers[0];\n+                    if (nameValidator.isValid(lhVarAsString) && rhValue.toUpperCase(Locale.ROOT).equals(rhValue)) {\n+                        if (!eqOps)\n+                            throw new IllegalArgumentException(\"Operator \" + binOp.operator + \" not allowed for enum\");\n+                        String value = toEncodedValueClassName(binOp.lhs.toString());\n+                        replacements.put(startRH, new Replacement(startRH, rhValue.length(), value + \".\" + rhValue));\n+                    }\n+                }\n+            }\n+            return binOp.lhs.accept(this) && binOp.rhs.accept(this);\n+        }\n+        return false;\n+    }\n+\n+    @Override\n+    public Boolean visitPackage(Java.Package p) {\n+        return false;\n+    }\n+\n+    @Override\n+    public Boolean visitType(Java.Type t) {\n+        return false;\n+    }\n+\n+    @Override\n+    public Boolean visitConstructorInvocation(Java.ConstructorInvocation ci) {\n+        return false;\n+    }\n+\n+    static void parseExpressions(StringBuilder expressions, NameValidator nameInConditionValidator, String exceptionInfo,\n+                                 Set<String> createObjects, List<Statement> list, EncodedValueLookup lookup, String lastStmt) {\n+\n+        for (Statement statement : list) {\n+            if (statement.getKeyword() == Statement.Keyword.ELSE) {\n+                if (!Helper.isEmpty(statement.getExpression()))\n+                    throw new IllegalArgumentException(\"expression must be empty but was \" + statement.getExpression());\n+\n+                expressions.append(\"else {\" + statement.getOperation().build(statement.getValue()) + \"; }\\n\");\n+            } else if (statement.getKeyword() == Statement.Keyword.ELSEIF || statement.getKeyword() == Statement.Keyword.IF) {\n+                ExpressionVisitor.ParseResult parseResult = parseExpression(statement.getExpression(), nameInConditionValidator, lookup);\n+                if (!parseResult.ok)\n+                    throw new IllegalArgumentException(exceptionInfo + \" invalid simple condition: \" + statement.getExpression());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a6853d08b41aeac14b244e7b9c50da99557dd33a"}, "originalPosition": 151}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTc5NDU4Nw==", "bodyText": "Can you check if the improved error messages would have been helpful in your case?\nd6552b2#diff-dafd159caf8461d50b0bda954bc5d78540d453751585e81682e22cc3ae09bce9R132", "url": "https://github.com/graphhopper/graphhopper/pull/2209#discussion_r555794587", "createdAt": "2021-01-12T14:08:11Z", "author": {"login": "karussell"}, "path": "core/src/main/java/com/graphhopper/routing/weighting/custom/ExpressionVisitor.java", "diffHunk": "@@ -0,0 +1,223 @@\n+/*\n+ *  Licensed to GraphHopper GmbH under one or more contributor\n+ *  license agreements. See the NOTICE file distributed with this work for\n+ *  additional information regarding copyright ownership.\n+ *\n+ *  GraphHopper GmbH licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except in\n+ *  compliance with the License. You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package com.graphhopper.routing.weighting.custom;\n+\n+import com.graphhopper.json.Statement;\n+import com.graphhopper.routing.ev.EncodedValueLookup;\n+import com.graphhopper.routing.ev.RouteNetwork;\n+import com.graphhopper.routing.ev.StringEncodedValue;\n+import com.graphhopper.util.Helper;\n+import org.codehaus.janino.Scanner;\n+import org.codehaus.janino.*;\n+\n+import java.io.StringReader;\n+import java.util.*;\n+\n+import static com.graphhopper.routing.weighting.custom.CustomModelParser.IN_AREA_PREFIX;\n+\n+class ExpressionVisitor implements Visitor.AtomVisitor<Boolean, Exception> {\n+\n+    private final ParseResult result;\n+    private final EncodedValueLookup lookup;\n+    private final TreeMap<Integer, Replacement> replacements = new TreeMap<>();\n+    private final NameValidator nameValidator;\n+    private final Set<String> allowedMethods = new HashSet<>(Arrays.asList(\"ordinal\", \"getDistance\", \"getName\",\n+            \"contains\", \"sqrt\", \"abs\"));\n+\n+    public ExpressionVisitor(ParseResult result, NameValidator nameValidator, EncodedValueLookup lookup) {\n+        this.result = result;\n+        this.nameValidator = nameValidator;\n+        this.lookup = lookup;\n+    }\n+\n+    // allow only methods and other identifiers (constants and encoded values)\n+    boolean isValidIdentifier(String identifier) {\n+        if (nameValidator.isValid(identifier)) {\n+            if (!Character.isUpperCase(identifier.charAt(0)))\n+                result.guessedVariables.add(identifier);\n+            return true;\n+        }\n+        return false;\n+    }\n+\n+    @Override\n+    public Boolean visitRvalue(Java.Rvalue rv) throws Exception {\n+        if (rv instanceof Java.AmbiguousName) {\n+            Java.AmbiguousName n = (Java.AmbiguousName) rv;\n+            if (n.identifiers.length == 1) {\n+                String arg = n.identifiers[0];\n+                if (arg.startsWith(IN_AREA_PREFIX)) {\n+                    int start = rv.getLocation().getColumnNumber() - 1;\n+                    replacements.put(start, new Replacement(start, arg.length(),\n+                            CustomWeightingHelper.class.getSimpleName() + \".in(this.\" + arg + \", edge)\"));\n+                    result.guessedVariables.add(arg);\n+                    return true;\n+                } else {\n+                    // e.g. like road_class\n+                    return isValidIdentifier(arg);\n+                }\n+            }\n+            return false;\n+        }\n+        if (rv instanceof Java.Literal)\n+            return true;\n+        if (rv instanceof Java.MethodInvocation) {\n+            Java.MethodInvocation mi = (Java.MethodInvocation) rv;\n+            if (allowedMethods.contains(mi.methodName)) {\n+                // skip methods like this.in() for now\n+                if (mi.target == null)\n+                    return false;\n+                // edge.getDistance, Math.sqrt => check target name (edge or Math)\n+                Java.AmbiguousName n = (Java.AmbiguousName) mi.target.toRvalue();\n+                return n.identifiers.length == 2 && isValidIdentifier(n.identifiers[0]);\n+            }\n+            return false;\n+        }\n+        if (rv instanceof Java.BinaryOperation) {\n+            Java.BinaryOperation binOp = (Java.BinaryOperation) rv;\n+            int startRH = binOp.rhs.getLocation().getColumnNumber() - 1;\n+            if (binOp.lhs instanceof Java.AmbiguousName && ((Java.AmbiguousName) binOp.lhs).identifiers.length == 1) {\n+                String lhVarAsString = ((Java.AmbiguousName) binOp.lhs).identifiers[0];\n+                boolean eqOps = binOp.operator.equals(\"==\") || binOp.operator.equals(\"!=\");\n+                if (binOp.rhs instanceof Java.StringLiteral) {\n+                    // replace String with its index for faster comparison (?) and skipping the Map<String, Integer> lookup at runtime\n+                    if (lookup.hasEncodedValue(lhVarAsString)) {\n+                        if (!eqOps)\n+                            throw new IllegalArgumentException(\"Operator \" + binOp.operator + \" not allowed for String\");\n+                        StringEncodedValue ev = lookup.getStringEncodedValue(lhVarAsString);\n+                        String str = ((Java.StringLiteral) binOp.rhs).value;\n+                        int integ = ev.indexOf(str.substring(1, str.length() - 1));\n+                        if (integ == 0) integ = -1; // 0 means not found and this should always trigger inequality\n+                        replacements.put(startRH, new Replacement(startRH, str.length(), \"\" + integ));\n+                    }\n+                } else if (binOp.rhs instanceof Java.AmbiguousName && ((Java.AmbiguousName) binOp.rhs).identifiers.length == 1) {\n+                    // Make enum explicit as NO or OTHER can occur in other enums so convert \"toll == NO\" to \"toll == Toll.NO\"\n+                    String rhValue = ((Java.AmbiguousName) binOp.rhs).identifiers[0];\n+                    if (nameValidator.isValid(lhVarAsString) && rhValue.toUpperCase(Locale.ROOT).equals(rhValue)) {\n+                        if (!eqOps)\n+                            throw new IllegalArgumentException(\"Operator \" + binOp.operator + \" not allowed for enum\");\n+                        String value = toEncodedValueClassName(binOp.lhs.toString());\n+                        replacements.put(startRH, new Replacement(startRH, rhValue.length(), value + \".\" + rhValue));\n+                    }\n+                }\n+            }\n+            return binOp.lhs.accept(this) && binOp.rhs.accept(this);\n+        }\n+        return false;\n+    }\n+\n+    @Override\n+    public Boolean visitPackage(Java.Package p) {\n+        return false;\n+    }\n+\n+    @Override\n+    public Boolean visitType(Java.Type t) {\n+        return false;\n+    }\n+\n+    @Override\n+    public Boolean visitConstructorInvocation(Java.ConstructorInvocation ci) {\n+        return false;\n+    }\n+\n+    static void parseExpressions(StringBuilder expressions, NameValidator nameInConditionValidator, String exceptionInfo,\n+                                 Set<String> createObjects, List<Statement> list, EncodedValueLookup lookup, String lastStmt) {\n+\n+        for (Statement statement : list) {\n+            if (statement.getKeyword() == Statement.Keyword.ELSE) {\n+                if (!Helper.isEmpty(statement.getExpression()))\n+                    throw new IllegalArgumentException(\"expression must be empty but was \" + statement.getExpression());\n+\n+                expressions.append(\"else {\" + statement.getOperation().build(statement.getValue()) + \"; }\\n\");\n+            } else if (statement.getKeyword() == Statement.Keyword.ELSEIF || statement.getKeyword() == Statement.Keyword.IF) {\n+                ExpressionVisitor.ParseResult parseResult = parseExpression(statement.getExpression(), nameInConditionValidator, lookup);\n+                if (!parseResult.ok)\n+                    throw new IllegalArgumentException(exceptionInfo + \" invalid simple condition: \" + statement.getExpression());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDE0NDQ0NA=="}, "originalCommit": {"oid": "a6853d08b41aeac14b244e7b9c50da99557dd33a"}, "originalPosition": 151}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NzcyMDE4Ng==", "bodyText": "Now I get\nCannot compile expression , priority_user_statements invalid expression \"max_weight < 3\": encoded value 'max_weight' not available\n\nYes that's better. The first part still looks a bit cryptic, but at least now we are told max_weight is missing.", "url": "https://github.com/graphhopper/graphhopper/pull/2209#discussion_r557720186", "createdAt": "2021-01-14T21:48:38Z", "author": {"login": "easbar"}, "path": "core/src/main/java/com/graphhopper/routing/weighting/custom/ExpressionVisitor.java", "diffHunk": "@@ -0,0 +1,223 @@\n+/*\n+ *  Licensed to GraphHopper GmbH under one or more contributor\n+ *  license agreements. See the NOTICE file distributed with this work for\n+ *  additional information regarding copyright ownership.\n+ *\n+ *  GraphHopper GmbH licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except in\n+ *  compliance with the License. You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package com.graphhopper.routing.weighting.custom;\n+\n+import com.graphhopper.json.Statement;\n+import com.graphhopper.routing.ev.EncodedValueLookup;\n+import com.graphhopper.routing.ev.RouteNetwork;\n+import com.graphhopper.routing.ev.StringEncodedValue;\n+import com.graphhopper.util.Helper;\n+import org.codehaus.janino.Scanner;\n+import org.codehaus.janino.*;\n+\n+import java.io.StringReader;\n+import java.util.*;\n+\n+import static com.graphhopper.routing.weighting.custom.CustomModelParser.IN_AREA_PREFIX;\n+\n+class ExpressionVisitor implements Visitor.AtomVisitor<Boolean, Exception> {\n+\n+    private final ParseResult result;\n+    private final EncodedValueLookup lookup;\n+    private final TreeMap<Integer, Replacement> replacements = new TreeMap<>();\n+    private final NameValidator nameValidator;\n+    private final Set<String> allowedMethods = new HashSet<>(Arrays.asList(\"ordinal\", \"getDistance\", \"getName\",\n+            \"contains\", \"sqrt\", \"abs\"));\n+\n+    public ExpressionVisitor(ParseResult result, NameValidator nameValidator, EncodedValueLookup lookup) {\n+        this.result = result;\n+        this.nameValidator = nameValidator;\n+        this.lookup = lookup;\n+    }\n+\n+    // allow only methods and other identifiers (constants and encoded values)\n+    boolean isValidIdentifier(String identifier) {\n+        if (nameValidator.isValid(identifier)) {\n+            if (!Character.isUpperCase(identifier.charAt(0)))\n+                result.guessedVariables.add(identifier);\n+            return true;\n+        }\n+        return false;\n+    }\n+\n+    @Override\n+    public Boolean visitRvalue(Java.Rvalue rv) throws Exception {\n+        if (rv instanceof Java.AmbiguousName) {\n+            Java.AmbiguousName n = (Java.AmbiguousName) rv;\n+            if (n.identifiers.length == 1) {\n+                String arg = n.identifiers[0];\n+                if (arg.startsWith(IN_AREA_PREFIX)) {\n+                    int start = rv.getLocation().getColumnNumber() - 1;\n+                    replacements.put(start, new Replacement(start, arg.length(),\n+                            CustomWeightingHelper.class.getSimpleName() + \".in(this.\" + arg + \", edge)\"));\n+                    result.guessedVariables.add(arg);\n+                    return true;\n+                } else {\n+                    // e.g. like road_class\n+                    return isValidIdentifier(arg);\n+                }\n+            }\n+            return false;\n+        }\n+        if (rv instanceof Java.Literal)\n+            return true;\n+        if (rv instanceof Java.MethodInvocation) {\n+            Java.MethodInvocation mi = (Java.MethodInvocation) rv;\n+            if (allowedMethods.contains(mi.methodName)) {\n+                // skip methods like this.in() for now\n+                if (mi.target == null)\n+                    return false;\n+                // edge.getDistance, Math.sqrt => check target name (edge or Math)\n+                Java.AmbiguousName n = (Java.AmbiguousName) mi.target.toRvalue();\n+                return n.identifiers.length == 2 && isValidIdentifier(n.identifiers[0]);\n+            }\n+            return false;\n+        }\n+        if (rv instanceof Java.BinaryOperation) {\n+            Java.BinaryOperation binOp = (Java.BinaryOperation) rv;\n+            int startRH = binOp.rhs.getLocation().getColumnNumber() - 1;\n+            if (binOp.lhs instanceof Java.AmbiguousName && ((Java.AmbiguousName) binOp.lhs).identifiers.length == 1) {\n+                String lhVarAsString = ((Java.AmbiguousName) binOp.lhs).identifiers[0];\n+                boolean eqOps = binOp.operator.equals(\"==\") || binOp.operator.equals(\"!=\");\n+                if (binOp.rhs instanceof Java.StringLiteral) {\n+                    // replace String with its index for faster comparison (?) and skipping the Map<String, Integer> lookup at runtime\n+                    if (lookup.hasEncodedValue(lhVarAsString)) {\n+                        if (!eqOps)\n+                            throw new IllegalArgumentException(\"Operator \" + binOp.operator + \" not allowed for String\");\n+                        StringEncodedValue ev = lookup.getStringEncodedValue(lhVarAsString);\n+                        String str = ((Java.StringLiteral) binOp.rhs).value;\n+                        int integ = ev.indexOf(str.substring(1, str.length() - 1));\n+                        if (integ == 0) integ = -1; // 0 means not found and this should always trigger inequality\n+                        replacements.put(startRH, new Replacement(startRH, str.length(), \"\" + integ));\n+                    }\n+                } else if (binOp.rhs instanceof Java.AmbiguousName && ((Java.AmbiguousName) binOp.rhs).identifiers.length == 1) {\n+                    // Make enum explicit as NO or OTHER can occur in other enums so convert \"toll == NO\" to \"toll == Toll.NO\"\n+                    String rhValue = ((Java.AmbiguousName) binOp.rhs).identifiers[0];\n+                    if (nameValidator.isValid(lhVarAsString) && rhValue.toUpperCase(Locale.ROOT).equals(rhValue)) {\n+                        if (!eqOps)\n+                            throw new IllegalArgumentException(\"Operator \" + binOp.operator + \" not allowed for enum\");\n+                        String value = toEncodedValueClassName(binOp.lhs.toString());\n+                        replacements.put(startRH, new Replacement(startRH, rhValue.length(), value + \".\" + rhValue));\n+                    }\n+                }\n+            }\n+            return binOp.lhs.accept(this) && binOp.rhs.accept(this);\n+        }\n+        return false;\n+    }\n+\n+    @Override\n+    public Boolean visitPackage(Java.Package p) {\n+        return false;\n+    }\n+\n+    @Override\n+    public Boolean visitType(Java.Type t) {\n+        return false;\n+    }\n+\n+    @Override\n+    public Boolean visitConstructorInvocation(Java.ConstructorInvocation ci) {\n+        return false;\n+    }\n+\n+    static void parseExpressions(StringBuilder expressions, NameValidator nameInConditionValidator, String exceptionInfo,\n+                                 Set<String> createObjects, List<Statement> list, EncodedValueLookup lookup, String lastStmt) {\n+\n+        for (Statement statement : list) {\n+            if (statement.getKeyword() == Statement.Keyword.ELSE) {\n+                if (!Helper.isEmpty(statement.getExpression()))\n+                    throw new IllegalArgumentException(\"expression must be empty but was \" + statement.getExpression());\n+\n+                expressions.append(\"else {\" + statement.getOperation().build(statement.getValue()) + \"; }\\n\");\n+            } else if (statement.getKeyword() == Statement.Keyword.ELSEIF || statement.getKeyword() == Statement.Keyword.IF) {\n+                ExpressionVisitor.ParseResult parseResult = parseExpression(statement.getExpression(), nameInConditionValidator, lookup);\n+                if (!parseResult.ok)\n+                    throw new IllegalArgumentException(exceptionInfo + \" invalid simple condition: \" + statement.getExpression());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDE0NDQ0NA=="}, "originalCommit": {"oid": "a6853d08b41aeac14b244e7b9c50da99557dd33a"}, "originalPosition": 151}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODM4NzMwOQ==", "bodyText": "Ok. Now it should be:\nCannot compile expression in 'priority' entry, invalid expression \"max_weight < 3\": encoded value 'max_weight' not available", "url": "https://github.com/graphhopper/graphhopper/pull/2209#discussion_r558387309", "createdAt": "2021-01-15T15:37:04Z", "author": {"login": "karussell"}, "path": "core/src/main/java/com/graphhopper/routing/weighting/custom/ExpressionVisitor.java", "diffHunk": "@@ -0,0 +1,223 @@\n+/*\n+ *  Licensed to GraphHopper GmbH under one or more contributor\n+ *  license agreements. See the NOTICE file distributed with this work for\n+ *  additional information regarding copyright ownership.\n+ *\n+ *  GraphHopper GmbH licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except in\n+ *  compliance with the License. You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package com.graphhopper.routing.weighting.custom;\n+\n+import com.graphhopper.json.Statement;\n+import com.graphhopper.routing.ev.EncodedValueLookup;\n+import com.graphhopper.routing.ev.RouteNetwork;\n+import com.graphhopper.routing.ev.StringEncodedValue;\n+import com.graphhopper.util.Helper;\n+import org.codehaus.janino.Scanner;\n+import org.codehaus.janino.*;\n+\n+import java.io.StringReader;\n+import java.util.*;\n+\n+import static com.graphhopper.routing.weighting.custom.CustomModelParser.IN_AREA_PREFIX;\n+\n+class ExpressionVisitor implements Visitor.AtomVisitor<Boolean, Exception> {\n+\n+    private final ParseResult result;\n+    private final EncodedValueLookup lookup;\n+    private final TreeMap<Integer, Replacement> replacements = new TreeMap<>();\n+    private final NameValidator nameValidator;\n+    private final Set<String> allowedMethods = new HashSet<>(Arrays.asList(\"ordinal\", \"getDistance\", \"getName\",\n+            \"contains\", \"sqrt\", \"abs\"));\n+\n+    public ExpressionVisitor(ParseResult result, NameValidator nameValidator, EncodedValueLookup lookup) {\n+        this.result = result;\n+        this.nameValidator = nameValidator;\n+        this.lookup = lookup;\n+    }\n+\n+    // allow only methods and other identifiers (constants and encoded values)\n+    boolean isValidIdentifier(String identifier) {\n+        if (nameValidator.isValid(identifier)) {\n+            if (!Character.isUpperCase(identifier.charAt(0)))\n+                result.guessedVariables.add(identifier);\n+            return true;\n+        }\n+        return false;\n+    }\n+\n+    @Override\n+    public Boolean visitRvalue(Java.Rvalue rv) throws Exception {\n+        if (rv instanceof Java.AmbiguousName) {\n+            Java.AmbiguousName n = (Java.AmbiguousName) rv;\n+            if (n.identifiers.length == 1) {\n+                String arg = n.identifiers[0];\n+                if (arg.startsWith(IN_AREA_PREFIX)) {\n+                    int start = rv.getLocation().getColumnNumber() - 1;\n+                    replacements.put(start, new Replacement(start, arg.length(),\n+                            CustomWeightingHelper.class.getSimpleName() + \".in(this.\" + arg + \", edge)\"));\n+                    result.guessedVariables.add(arg);\n+                    return true;\n+                } else {\n+                    // e.g. like road_class\n+                    return isValidIdentifier(arg);\n+                }\n+            }\n+            return false;\n+        }\n+        if (rv instanceof Java.Literal)\n+            return true;\n+        if (rv instanceof Java.MethodInvocation) {\n+            Java.MethodInvocation mi = (Java.MethodInvocation) rv;\n+            if (allowedMethods.contains(mi.methodName)) {\n+                // skip methods like this.in() for now\n+                if (mi.target == null)\n+                    return false;\n+                // edge.getDistance, Math.sqrt => check target name (edge or Math)\n+                Java.AmbiguousName n = (Java.AmbiguousName) mi.target.toRvalue();\n+                return n.identifiers.length == 2 && isValidIdentifier(n.identifiers[0]);\n+            }\n+            return false;\n+        }\n+        if (rv instanceof Java.BinaryOperation) {\n+            Java.BinaryOperation binOp = (Java.BinaryOperation) rv;\n+            int startRH = binOp.rhs.getLocation().getColumnNumber() - 1;\n+            if (binOp.lhs instanceof Java.AmbiguousName && ((Java.AmbiguousName) binOp.lhs).identifiers.length == 1) {\n+                String lhVarAsString = ((Java.AmbiguousName) binOp.lhs).identifiers[0];\n+                boolean eqOps = binOp.operator.equals(\"==\") || binOp.operator.equals(\"!=\");\n+                if (binOp.rhs instanceof Java.StringLiteral) {\n+                    // replace String with its index for faster comparison (?) and skipping the Map<String, Integer> lookup at runtime\n+                    if (lookup.hasEncodedValue(lhVarAsString)) {\n+                        if (!eqOps)\n+                            throw new IllegalArgumentException(\"Operator \" + binOp.operator + \" not allowed for String\");\n+                        StringEncodedValue ev = lookup.getStringEncodedValue(lhVarAsString);\n+                        String str = ((Java.StringLiteral) binOp.rhs).value;\n+                        int integ = ev.indexOf(str.substring(1, str.length() - 1));\n+                        if (integ == 0) integ = -1; // 0 means not found and this should always trigger inequality\n+                        replacements.put(startRH, new Replacement(startRH, str.length(), \"\" + integ));\n+                    }\n+                } else if (binOp.rhs instanceof Java.AmbiguousName && ((Java.AmbiguousName) binOp.rhs).identifiers.length == 1) {\n+                    // Make enum explicit as NO or OTHER can occur in other enums so convert \"toll == NO\" to \"toll == Toll.NO\"\n+                    String rhValue = ((Java.AmbiguousName) binOp.rhs).identifiers[0];\n+                    if (nameValidator.isValid(lhVarAsString) && rhValue.toUpperCase(Locale.ROOT).equals(rhValue)) {\n+                        if (!eqOps)\n+                            throw new IllegalArgumentException(\"Operator \" + binOp.operator + \" not allowed for enum\");\n+                        String value = toEncodedValueClassName(binOp.lhs.toString());\n+                        replacements.put(startRH, new Replacement(startRH, rhValue.length(), value + \".\" + rhValue));\n+                    }\n+                }\n+            }\n+            return binOp.lhs.accept(this) && binOp.rhs.accept(this);\n+        }\n+        return false;\n+    }\n+\n+    @Override\n+    public Boolean visitPackage(Java.Package p) {\n+        return false;\n+    }\n+\n+    @Override\n+    public Boolean visitType(Java.Type t) {\n+        return false;\n+    }\n+\n+    @Override\n+    public Boolean visitConstructorInvocation(Java.ConstructorInvocation ci) {\n+        return false;\n+    }\n+\n+    static void parseExpressions(StringBuilder expressions, NameValidator nameInConditionValidator, String exceptionInfo,\n+                                 Set<String> createObjects, List<Statement> list, EncodedValueLookup lookup, String lastStmt) {\n+\n+        for (Statement statement : list) {\n+            if (statement.getKeyword() == Statement.Keyword.ELSE) {\n+                if (!Helper.isEmpty(statement.getExpression()))\n+                    throw new IllegalArgumentException(\"expression must be empty but was \" + statement.getExpression());\n+\n+                expressions.append(\"else {\" + statement.getOperation().build(statement.getValue()) + \"; }\\n\");\n+            } else if (statement.getKeyword() == Statement.Keyword.ELSEIF || statement.getKeyword() == Statement.Keyword.IF) {\n+                ExpressionVisitor.ParseResult parseResult = parseExpression(statement.getExpression(), nameInConditionValidator, lookup);\n+                if (!parseResult.ok)\n+                    throw new IllegalArgumentException(exceptionInfo + \" invalid simple condition: \" + statement.getExpression());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDE0NDQ0NA=="}, "originalCommit": {"oid": "a6853d08b41aeac14b244e7b9c50da99557dd33a"}, "originalPosition": 151}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ4ODAwNTk4OnYy", "diffSide": "RIGHT", "path": "web/src/main/resources/assets/js/main-template.js", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wOFQxOTozMTo0NlrOIQeiFg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wOFQxOTozMTo0NlrOIQeiFg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDE0ODM3NA==", "bodyText": "With max_weight > 3 I always got 'point not found' error, because this blocks all edges where the max_weight is larger than three tons (almost all edges except a few that allow, e.g. 1.8t max).", "url": "https://github.com/graphhopper/graphhopper/pull/2209#discussion_r554148374", "createdAt": "2021-01-08T19:31:46Z", "author": {"login": "easbar"}, "path": "web/src/main/resources/assets/js/main-template.js", "diffHunk": "@@ -81,8 +81,8 @@ $(document).ready(function (e) {\n         mapLayer.adjustMapSize();\n     });\n     $(\"#flex-example\").click(function() {\n-         $(\"#flex-input-text\").val(\"speed:\\n- if: road_class: == MOTORWAY\\n  multiply by: 0.8\\n\"\n-          + \"priority:\\n- if: road_environment == TUNNEL\\n  multiply by: 0.0\\n- if: road_class == RESIDENTIAL\\n  multiply by: 0.7\\n- if: max_weight > 3\\n  multiply by: 0.0\");\n+         $(\"#flex-input-text\").val(\"speed:\\n- if: road_class == MOTORWAY\\n  multiply by: 0.8\\n\"\n+          + \"priority:\\n- if: road_environment == TUNNEL\\n  multiply by: 0.0\\n- if: road_class == RESIDENTIAL\\n  multiply by: 0.7\\n- if: max_weight < 3\\n  multiply by: 0.0\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b81b1cfb6e7b3c5bc1f559f4f673adfe95927d85"}, "originalPosition": 7}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ4ODAyMzkwOnYy", "diffSide": "RIGHT", "path": "web/src/main/resources/assets/js/main-template.js", "isResolved": true, "comments": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wOFQxOTozNzo1N1rOIQetPQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xNlQxNjo1NjoyMFrOIVETtg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDE1MTIyOQ==", "bodyText": "Hm, the autocomplete feature does not work very well currently. For example we get no hint to type if/else/else if and after we do we do not get a hint to type an encoded value name. This could probably be improved without too much effort (but great help for the user), but we should optimize for one format only? Not sure if that should be yaml or json and if yaml it could be the 'one-line-per-statement' format or the more verbose one...", "url": "https://github.com/graphhopper/graphhopper/pull/2209#discussion_r554151229", "createdAt": "2021-01-08T19:37:57Z", "author": {"login": "easbar"}, "path": "web/src/main/resources/assets/js/main-template.js", "diffHunk": "@@ -276,8 +277,8 @@ $(document).ready(function (e) {\n                         endIndex = endIndex < 0 ? cleanedText.length : endIndex;\n                         var wordUnderCursor = cleanedText.substring(startIndex, endIndex);\n                         if(this.selectionStart == 0 || this.value.substr(this.selectionStart - 1, 1) === \"\\n\") {\n-                           document.getElementById(\"ev_value\").innerHTML = \"<b>root:</b> speed_factor, priority, max_speed, max_speed_fallback, distance_influence, areas\";\n-                        } else if(wordUnderCursor === \"priority\" || wordUnderCursor === \"speed_factor\" || wordUnderCursor === \"max_speed\") {\n+                           document.getElementById(\"ev_value\").innerHTML = \"<b>root:</b> priority, speed, distance_influence, areas\";\n+                        } else if(wordUnderCursor === \"priority\" || wordUnderCursor === \"speed\") {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b81b1cfb6e7b3c5bc1f559f4f673adfe95927d85"}, "originalPosition": 17}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDE1NjUxMQ==", "bodyText": "And by the way: Should we rename the 'flex' button or otherwise make it more visible?", "url": "https://github.com/graphhopper/graphhopper/pull/2209#discussion_r554156511", "createdAt": "2021-01-08T19:49:18Z", "author": {"login": "easbar"}, "path": "web/src/main/resources/assets/js/main-template.js", "diffHunk": "@@ -276,8 +277,8 @@ $(document).ready(function (e) {\n                         endIndex = endIndex < 0 ? cleanedText.length : endIndex;\n                         var wordUnderCursor = cleanedText.substring(startIndex, endIndex);\n                         if(this.selectionStart == 0 || this.value.substr(this.selectionStart - 1, 1) === \"\\n\") {\n-                           document.getElementById(\"ev_value\").innerHTML = \"<b>root:</b> speed_factor, priority, max_speed, max_speed_fallback, distance_influence, areas\";\n-                        } else if(wordUnderCursor === \"priority\" || wordUnderCursor === \"speed_factor\" || wordUnderCursor === \"max_speed\") {\n+                           document.getElementById(\"ev_value\").innerHTML = \"<b>root:</b> priority, speed, distance_influence, areas\";\n+                        } else if(wordUnderCursor === \"priority\" || wordUnderCursor === \"speed\") {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDE1MTIyOQ=="}, "originalCommit": {"oid": "b81b1cfb6e7b3c5bc1f559f4f673adfe95927d85"}, "originalPosition": 17}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDkwMTE3Nw==", "bodyText": "For now I would postpone the improvement of the auto complete feature (except this can be solved quickly :) ? )", "url": "https://github.com/graphhopper/graphhopper/pull/2209#discussion_r554901177", "createdAt": "2021-01-11T09:03:04Z", "author": {"login": "karussell"}, "path": "web/src/main/resources/assets/js/main-template.js", "diffHunk": "@@ -276,8 +277,8 @@ $(document).ready(function (e) {\n                         endIndex = endIndex < 0 ? cleanedText.length : endIndex;\n                         var wordUnderCursor = cleanedText.substring(startIndex, endIndex);\n                         if(this.selectionStart == 0 || this.value.substr(this.selectionStart - 1, 1) === \"\\n\") {\n-                           document.getElementById(\"ev_value\").innerHTML = \"<b>root:</b> speed_factor, priority, max_speed, max_speed_fallback, distance_influence, areas\";\n-                        } else if(wordUnderCursor === \"priority\" || wordUnderCursor === \"speed_factor\" || wordUnderCursor === \"max_speed\") {\n+                           document.getElementById(\"ev_value\").innerHTML = \"<b>root:</b> priority, speed, distance_influence, areas\";\n+                        } else if(wordUnderCursor === \"priority\" || wordUnderCursor === \"speed\") {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDE1MTIyOQ=="}, "originalCommit": {"oid": "b81b1cfb6e7b3c5bc1f559f4f673adfe95927d85"}, "originalPosition": 17}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTI2Nzg5OQ==", "bodyText": "I think it can be improved with a few simple rules if we e.g. assume the explicit yaml format, but its hard to make it work for all formats at the same time probably. But also we can postpone this. I just thought if there are users who are willing to start experimenting with the new custom model language we should probably do our best they have a good experience and the autocomplete makes it much more comfortable to use IMO. Same with proper syntax checking and detailed error messages, but this is another story maybe.", "url": "https://github.com/graphhopper/graphhopper/pull/2209#discussion_r555267899", "createdAt": "2021-01-11T18:54:23Z", "author": {"login": "easbar"}, "path": "web/src/main/resources/assets/js/main-template.js", "diffHunk": "@@ -276,8 +277,8 @@ $(document).ready(function (e) {\n                         endIndex = endIndex < 0 ? cleanedText.length : endIndex;\n                         var wordUnderCursor = cleanedText.substring(startIndex, endIndex);\n                         if(this.selectionStart == 0 || this.value.substr(this.selectionStart - 1, 1) === \"\\n\") {\n-                           document.getElementById(\"ev_value\").innerHTML = \"<b>root:</b> speed_factor, priority, max_speed, max_speed_fallback, distance_influence, areas\";\n-                        } else if(wordUnderCursor === \"priority\" || wordUnderCursor === \"speed_factor\" || wordUnderCursor === \"max_speed\") {\n+                           document.getElementById(\"ev_value\").innerHTML = \"<b>root:</b> priority, speed, distance_influence, areas\";\n+                        } else if(wordUnderCursor === \"priority\" || wordUnderCursor === \"speed\") {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDE1MTIyOQ=="}, "originalCommit": {"oid": "b81b1cfb6e7b3c5bc1f559f4f673adfe95927d85"}, "originalPosition": 17}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODM4NjY1Ng==", "bodyText": "assume the explicit yaml format, but its hard to make it work for all formats at the same time probably.\n\nYes, I would assume YAML for the UI. And if JSON is copy pasted into the box it could be converted to YAML and we can also provide a \"convert to YAML\" feature. So that working with the JSON endpoint is easy enough.", "url": "https://github.com/graphhopper/graphhopper/pull/2209#discussion_r558386656", "createdAt": "2021-01-15T15:36:05Z", "author": {"login": "karussell"}, "path": "web/src/main/resources/assets/js/main-template.js", "diffHunk": "@@ -276,8 +277,8 @@ $(document).ready(function (e) {\n                         endIndex = endIndex < 0 ? cleanedText.length : endIndex;\n                         var wordUnderCursor = cleanedText.substring(startIndex, endIndex);\n                         if(this.selectionStart == 0 || this.value.substr(this.selectionStart - 1, 1) === \"\\n\") {\n-                           document.getElementById(\"ev_value\").innerHTML = \"<b>root:</b> speed_factor, priority, max_speed, max_speed_fallback, distance_influence, areas\";\n-                        } else if(wordUnderCursor === \"priority\" || wordUnderCursor === \"speed_factor\" || wordUnderCursor === \"max_speed\") {\n+                           document.getElementById(\"ev_value\").innerHTML = \"<b>root:</b> priority, speed, distance_influence, areas\";\n+                        } else if(wordUnderCursor === \"priority\" || wordUnderCursor === \"speed\") {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDE1MTIyOQ=="}, "originalCommit": {"oid": "b81b1cfb6e7b3c5bc1f559f4f673adfe95927d85"}, "originalPosition": 17}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODQ5MzMyNw==", "bodyText": "Ok yes. And do you want to change the docs to json?", "url": "https://github.com/graphhopper/graphhopper/pull/2209#discussion_r558493327", "createdAt": "2021-01-15T18:29:56Z", "author": {"login": "easbar"}, "path": "web/src/main/resources/assets/js/main-template.js", "diffHunk": "@@ -276,8 +277,8 @@ $(document).ready(function (e) {\n                         endIndex = endIndex < 0 ? cleanedText.length : endIndex;\n                         var wordUnderCursor = cleanedText.substring(startIndex, endIndex);\n                         if(this.selectionStart == 0 || this.value.substr(this.selectionStart - 1, 1) === \"\\n\") {\n-                           document.getElementById(\"ev_value\").innerHTML = \"<b>root:</b> speed_factor, priority, max_speed, max_speed_fallback, distance_influence, areas\";\n-                        } else if(wordUnderCursor === \"priority\" || wordUnderCursor === \"speed_factor\" || wordUnderCursor === \"max_speed\") {\n+                           document.getElementById(\"ev_value\").innerHTML = \"<b>root:</b> priority, speed, distance_influence, areas\";\n+                        } else if(wordUnderCursor === \"priority\" || wordUnderCursor === \"speed\") {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDE1MTIyOQ=="}, "originalCommit": {"oid": "b81b1cfb6e7b3c5bc1f559f4f673adfe95927d85"}, "originalPosition": 17}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODk2MTU5MA==", "bodyText": "At the moment I slightly favor JSON over YAML for the documentation as we can assume more knowledge from users that do server-side profiles. But maybe we decide this in #2232?", "url": "https://github.com/graphhopper/graphhopper/pull/2209#discussion_r558961590", "createdAt": "2021-01-16T16:56:20Z", "author": {"login": "karussell"}, "path": "web/src/main/resources/assets/js/main-template.js", "diffHunk": "@@ -276,8 +277,8 @@ $(document).ready(function (e) {\n                         endIndex = endIndex < 0 ? cleanedText.length : endIndex;\n                         var wordUnderCursor = cleanedText.substring(startIndex, endIndex);\n                         if(this.selectionStart == 0 || this.value.substr(this.selectionStart - 1, 1) === \"\\n\") {\n-                           document.getElementById(\"ev_value\").innerHTML = \"<b>root:</b> speed_factor, priority, max_speed, max_speed_fallback, distance_influence, areas\";\n-                        } else if(wordUnderCursor === \"priority\" || wordUnderCursor === \"speed_factor\" || wordUnderCursor === \"max_speed\") {\n+                           document.getElementById(\"ev_value\").innerHTML = \"<b>root:</b> priority, speed, distance_influence, areas\";\n+                        } else if(wordUnderCursor === \"priority\" || wordUnderCursor === \"speed\") {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDE1MTIyOQ=="}, "originalCommit": {"oid": "b81b1cfb6e7b3c5bc1f559f4f673adfe95927d85"}, "originalPosition": 17}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4690, "cost": 1, "resetAt": "2021-11-12T20:28:25Z"}}}