{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzg3Njk0Mzk5", "number": 1953, "reviewThreads": {"totalCount": 10, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xM1QxMDoyODoxNFrODnyJVA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMFQyMDoxMTo1N1rOEEcdwA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQzMDQyNjQ0OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/com/graphhopper/reader/dem/EdgeSampling.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xM1QxMDoyODoxNFrOF1-pew==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNVQxMzowNjowN1rOGQoblg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjE0NTI3NQ==", "bodyText": "Do we think that this assumption and approximation are fine? Or should we use a more exact calculation to interpolate between points.", "url": "https://github.com/graphhopper/graphhopper/pull/1953#discussion_r392145275", "createdAt": "2020-03-13T10:28:14Z", "author": {"login": "msbarry"}, "path": "core/src/main/java/com/graphhopper/reader/dem/EdgeSampling.java", "diffHunk": "@@ -0,0 +1,72 @@\n+/*\n+ *  Licensed to GraphHopper GmbH under one or more contributor\n+ *  license agreements. See the NOTICE file distributed with this work for\n+ *  additional information regarding copyright ownership.\n+ *\n+ *  GraphHopper GmbH licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except in\n+ *  compliance with the License. You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package com.graphhopper.reader.dem;\n+\n+import com.graphhopper.util.DistanceCalc;\n+import com.graphhopper.util.DistanceCalcEarth;\n+import com.graphhopper.util.PointList;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Ensures that elevation is sampled along a point list with no more than maxDistance between samples. Works by adding\n+ * points along long edges and fetching elevation at each inserted point.\n+ *\n+ * This uses a simple linear approximation to interpolate between points which should be fine for short distances, but\n+ * if support for longer distances is needed or to handle segments crossing the international date line, should use a\n+ * more robust algorithm that interpolates along the great circle path between points.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f53e5275bb7ef1fb148a99dc3664f83b740a9e5a"}, "originalPosition": 32}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Mjk2NDM2MQ==", "bodyText": "For now I think this is fine.", "url": "https://github.com/graphhopper/graphhopper/pull/1953#discussion_r392964361", "createdAt": "2020-03-16T11:55:47Z", "author": {"login": "karussell"}, "path": "core/src/main/java/com/graphhopper/reader/dem/EdgeSampling.java", "diffHunk": "@@ -0,0 +1,72 @@\n+/*\n+ *  Licensed to GraphHopper GmbH under one or more contributor\n+ *  license agreements. See the NOTICE file distributed with this work for\n+ *  additional information regarding copyright ownership.\n+ *\n+ *  GraphHopper GmbH licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except in\n+ *  compliance with the License. You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package com.graphhopper.reader.dem;\n+\n+import com.graphhopper.util.DistanceCalc;\n+import com.graphhopper.util.DistanceCalcEarth;\n+import com.graphhopper.util.PointList;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Ensures that elevation is sampled along a point list with no more than maxDistance between samples. Works by adding\n+ * points along long edges and fetching elevation at each inserted point.\n+ *\n+ * This uses a simple linear approximation to interpolate between points which should be fine for short distances, but\n+ * if support for longer distances is needed or to handle segments crossing the international date line, should use a\n+ * more robust algorithm that interpolates along the great circle path between points.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjE0NTI3NQ=="}, "originalCommit": {"oid": "f53e5275bb7ef1fb148a99dc3664f83b740a9e5a"}, "originalPosition": 32}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDA5MjgyMg==", "bodyText": "Yes I think this is a good decision. I did something like this using the great circle. This is quite computation heavy and probably not necessary in most cases.", "url": "https://github.com/graphhopper/graphhopper/pull/1953#discussion_r420092822", "createdAt": "2020-05-05T13:06:07Z", "author": {"login": "boldtrn"}, "path": "core/src/main/java/com/graphhopper/reader/dem/EdgeSampling.java", "diffHunk": "@@ -0,0 +1,72 @@\n+/*\n+ *  Licensed to GraphHopper GmbH under one or more contributor\n+ *  license agreements. See the NOTICE file distributed with this work for\n+ *  additional information regarding copyright ownership.\n+ *\n+ *  GraphHopper GmbH licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except in\n+ *  compliance with the License. You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package com.graphhopper.reader.dem;\n+\n+import com.graphhopper.util.DistanceCalc;\n+import com.graphhopper.util.DistanceCalcEarth;\n+import com.graphhopper.util.PointList;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Ensures that elevation is sampled along a point list with no more than maxDistance between samples. Works by adding\n+ * points along long edges and fetching elevation at each inserted point.\n+ *\n+ * This uses a simple linear approximation to interpolate between points which should be fine for short distances, but\n+ * if support for longer distances is needed or to handle segments crossing the international date line, should use a\n+ * more robust algorithm that interpolates along the great circle path between points.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjE0NTI3NQ=="}, "originalCommit": {"oid": "f53e5275bb7ef1fb148a99dc3664f83b740a9e5a"}, "originalPosition": 32}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQzMDQzMTIzOnYy", "diffSide": "RIGHT", "path": "core/src/main/java/com/graphhopper/util/DouglasPeucker.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xM1QxMDoyOTo1M1rOF1-smA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xN1QwOTozMjo1MlrOF3UN6g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjE0NjA3Mg==", "bodyText": "Do we want to stay with this unit and name for the elevation factor param? I had thought about making it either elevation max dist (with unit meters) or just inverse of what this is now.", "url": "https://github.com/graphhopper/graphhopper/pull/1953#discussion_r392146072", "createdAt": "2020-03-13T10:29:53Z", "author": {"login": "msbarry"}, "path": "core/src/main/java/com/graphhopper/util/DouglasPeucker.java", "diffHunk": "@@ -53,6 +56,17 @@ public DouglasPeucker setMaxDistance(double dist) {\n         return this;\n     }\n \n+    /**\n+     * Weight to give elevation changes during simplification:\n+     * 0 means elevation is ignored during simplification\n+     * 0.2 means that 5 meters of elevation change is treated like\n+     * 1m of lat/lon change\n+     */\n+    public DouglasPeucker setElevationFactor(double factor) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f53e5275bb7ef1fb148a99dc3664f83b740a9e5a"}, "originalPosition": 27}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Mjk2NjY1MA==", "bodyText": "The absolute value (elevation max dist in meters) makes sense and would be preferred (I initially did not understand the factor ... see above ;) ). But I guess there is a reason why you chose the factor over the absolute max ele?", "url": "https://github.com/graphhopper/graphhopper/pull/1953#discussion_r392966650", "createdAt": "2020-03-16T12:00:38Z", "author": {"login": "karussell"}, "path": "core/src/main/java/com/graphhopper/util/DouglasPeucker.java", "diffHunk": "@@ -53,6 +56,17 @@ public DouglasPeucker setMaxDistance(double dist) {\n         return this;\n     }\n \n+    /**\n+     * Weight to give elevation changes during simplification:\n+     * 0 means elevation is ignored during simplification\n+     * 0.2 means that 5 meters of elevation change is treated like\n+     * 1m of lat/lon change\n+     */\n+    public DouglasPeucker setElevationFactor(double factor) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjE0NjA3Mg=="}, "originalCommit": {"oid": "f53e5275bb7ef1fb148a99dc3664f83b740a9e5a"}, "originalPosition": 27}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzU0NzI0Mg==", "bodyText": "That makes sense, I switched everything over to \"elevation max dist\" - elevation factor was an attempt to pass through directly what the calculation needed, but max distance makes more sense for users.", "url": "https://github.com/graphhopper/graphhopper/pull/1953#discussion_r393547242", "createdAt": "2020-03-17T09:32:52Z", "author": {"login": "msbarry"}, "path": "core/src/main/java/com/graphhopper/util/DouglasPeucker.java", "diffHunk": "@@ -53,6 +56,17 @@ public DouglasPeucker setMaxDistance(double dist) {\n         return this;\n     }\n \n+    /**\n+     * Weight to give elevation changes during simplification:\n+     * 0 means elevation is ignored during simplification\n+     * 0.2 means that 5 meters of elevation change is treated like\n+     * 1m of lat/lon change\n+     */\n+    public DouglasPeucker setElevationFactor(double factor) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjE0NjA3Mg=="}, "originalCommit": {"oid": "f53e5275bb7ef1fb148a99dc3664f83b740a9e5a"}, "originalPosition": 27}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQzMDQ0MjUyOnYy", "diffSide": "RIGHT", "path": "core/src/main/java/com/graphhopper/GraphHopper.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xM1QxMDozMzoyOVrOF1-ziA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xNlQxMTo1NDo0MFrOF2wm1A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjE0Nzg0OA==", "bodyText": "Without bilinear interpolation, the output can look pretty bad because it enhances the resolution on blockiness. Do we want to warn when long edge sampling is used without bilinear interpolation?\nFor example with SRTM and no bilinear interpolation:", "url": "https://github.com/graphhopper/graphhopper/pull/1953#discussion_r392147848", "createdAt": "2020-03-13T10:33:29Z", "author": {"login": "msbarry"}, "path": "core/src/main/java/com/graphhopper/GraphHopper.java", "diffHunk": "@@ -542,6 +560,8 @@ public GraphHopper init(GraphHopperConfig ghConfig) {\n \n         // elevation\n         this.smoothElevation = ghConfig.getBool(\"graph.elevation.smoothing\", false);\n+        this.longEdgeSamplingDistance = ghConfig.getDouble(\"graph.elevation.long_edge_sampling_distance\", 0);\n+        this.elevationSimplifyFactor = ghConfig.getDouble(\"graph.elevation.simplify_factor\", 0);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f53e5275bb7ef1fb148a99dc3664f83b740a9e5a"}, "originalPosition": 37}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Mjk2Mzc5Ng==", "bodyText": "Do we want to warn when long edge sampling is used without bilinear interpolation?\n\nYes, sounds good.\nWhat does the elevation simplify factor do?", "url": "https://github.com/graphhopper/graphhopper/pull/1953#discussion_r392963796", "createdAt": "2020-03-16T11:54:40Z", "author": {"login": "karussell"}, "path": "core/src/main/java/com/graphhopper/GraphHopper.java", "diffHunk": "@@ -542,6 +560,8 @@ public GraphHopper init(GraphHopperConfig ghConfig) {\n \n         // elevation\n         this.smoothElevation = ghConfig.getBool(\"graph.elevation.smoothing\", false);\n+        this.longEdgeSamplingDistance = ghConfig.getDouble(\"graph.elevation.long_edge_sampling_distance\", 0);\n+        this.elevationSimplifyFactor = ghConfig.getDouble(\"graph.elevation.simplify_factor\", 0);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjE0Nzg0OA=="}, "originalCommit": {"oid": "f53e5275bb7ef1fb148a99dc3664f83b740a9e5a"}, "originalPosition": 37}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQzMDQ0NDU4OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/com/graphhopper/GraphHopper.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xM1QxMDozNDowNlrOF1-00A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xN1QxMDo0Mzo0OVrOF3WsYA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjE0ODE3Ng==", "bodyText": "Also, should these be enabled by default? If so, what values should we use?", "url": "https://github.com/graphhopper/graphhopper/pull/1953#discussion_r392148176", "createdAt": "2020-03-13T10:34:06Z", "author": {"login": "msbarry"}, "path": "core/src/main/java/com/graphhopper/GraphHopper.java", "diffHunk": "@@ -542,6 +560,8 @@ public GraphHopper init(GraphHopperConfig ghConfig) {\n \n         // elevation\n         this.smoothElevation = ghConfig.getBool(\"graph.elevation.smoothing\", false);\n+        this.longEdgeSamplingDistance = ghConfig.getDouble(\"graph.elevation.long_edge_sampling_distance\", 0);\n+        this.elevationSimplifyFactor = ghConfig.getDouble(\"graph.elevation.simplify_factor\", 0);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f53e5275bb7ef1fb148a99dc3664f83b740a9e5a"}, "originalPosition": 37}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Mjk2NzYyOA==", "bodyText": "Yes, for now I would keep the current settings as default (i.e. disabling 'long edge sampling'). But if we learn that it is worth the extra costs we can change it to like 60m (and 1m for max ele simplify)?\n\ngraph.elevation.long_edge_sampling_distance\n\nShouldn't the default for this be Double.MAX_VALUE?", "url": "https://github.com/graphhopper/graphhopper/pull/1953#discussion_r392967628", "createdAt": "2020-03-16T12:02:34Z", "author": {"login": "karussell"}, "path": "core/src/main/java/com/graphhopper/GraphHopper.java", "diffHunk": "@@ -542,6 +560,8 @@ public GraphHopper init(GraphHopperConfig ghConfig) {\n \n         // elevation\n         this.smoothElevation = ghConfig.getBool(\"graph.elevation.smoothing\", false);\n+        this.longEdgeSamplingDistance = ghConfig.getDouble(\"graph.elevation.long_edge_sampling_distance\", 0);\n+        this.elevationSimplifyFactor = ghConfig.getDouble(\"graph.elevation.simplify_factor\", 0);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjE0ODE3Ng=="}, "originalCommit": {"oid": "f53e5275bb7ef1fb148a99dc3664f83b740a9e5a"}, "originalPosition": 37}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzU0ODg0MQ==", "bodyText": "OK sounds good, and I changed both of them to default to Double.MAX_VALUE.\nDo you think that I should add sections to config-example.yml explaining how to use these 2 new parameters (and bilinear interpolation)?", "url": "https://github.com/graphhopper/graphhopper/pull/1953#discussion_r393548841", "createdAt": "2020-03-17T09:35:46Z", "author": {"login": "msbarry"}, "path": "core/src/main/java/com/graphhopper/GraphHopper.java", "diffHunk": "@@ -542,6 +560,8 @@ public GraphHopper init(GraphHopperConfig ghConfig) {\n \n         // elevation\n         this.smoothElevation = ghConfig.getBool(\"graph.elevation.smoothing\", false);\n+        this.longEdgeSamplingDistance = ghConfig.getDouble(\"graph.elevation.long_edge_sampling_distance\", 0);\n+        this.elevationSimplifyFactor = ghConfig.getDouble(\"graph.elevation.simplify_factor\", 0);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjE0ODE3Ng=="}, "originalCommit": {"oid": "f53e5275bb7ef1fb148a99dc3664f83b740a9e5a"}, "originalPosition": 37}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzU4NzgwOA==", "bodyText": "Ah, yes. Adding this to config-example.yml is a good idea", "url": "https://github.com/graphhopper/graphhopper/pull/1953#discussion_r393587808", "createdAt": "2020-03-17T10:43:49Z", "author": {"login": "karussell"}, "path": "core/src/main/java/com/graphhopper/GraphHopper.java", "diffHunk": "@@ -542,6 +560,8 @@ public GraphHopper init(GraphHopperConfig ghConfig) {\n \n         // elevation\n         this.smoothElevation = ghConfig.getBool(\"graph.elevation.smoothing\", false);\n+        this.longEdgeSamplingDistance = ghConfig.getDouble(\"graph.elevation.long_edge_sampling_distance\", 0);\n+        this.elevationSimplifyFactor = ghConfig.getDouble(\"graph.elevation.simplify_factor\", 0);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjE0ODE3Ng=="}, "originalCommit": {"oid": "f53e5275bb7ef1fb148a99dc3664f83b740a9e5a"}, "originalPosition": 37}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYxNTA3NDA4OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/com/graphhopper/reader/dem/EdgeSampling.java", "isResolved": false, "comments": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNVQxMzowNDo0OFrOGQoYDg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wN1QxMDo1MjoyMVrOGR5H1g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDA5MTkxOA==", "bodyText": "I am wondering if we should make this warning a bit more explicit / self-explaining or maybe add a note what the user can do about it?\nCrossing the date line should not happen, since we check isCrossBoundary a few lines above.\nWhat are other cases where this could happen? For ferries, this might be an issue. For regular roads, not having a node every few kms could indicate a mapping error. For OSM this could mean to double check the roads at the given coordinates and maybe align the roads.\nI haven't tested the PR yet, are there many of these logs? I could imagine that for example in Canada or Australia, this could be an issue.", "url": "https://github.com/graphhopper/graphhopper/pull/1953#discussion_r420091918", "createdAt": "2020-05-05T13:04:48Z", "author": {"login": "boldtrn"}, "path": "core/src/main/java/com/graphhopper/reader/dem/EdgeSampling.java", "diffHunk": "@@ -0,0 +1,72 @@\n+/*\n+ *  Licensed to GraphHopper GmbH under one or more contributor\n+ *  license agreements. See the NOTICE file distributed with this work for\n+ *  additional information regarding copyright ownership.\n+ *\n+ *  GraphHopper GmbH licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except in\n+ *  compliance with the License. You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package com.graphhopper.reader.dem;\n+\n+import com.graphhopper.util.DistanceCalc;\n+import com.graphhopper.util.DistanceCalcEarth;\n+import com.graphhopper.util.PointList;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Ensures that elevation is sampled along a point list with no more than maxDistance between samples. Works by adding\n+ * points along long edges and fetching elevation at each inserted point.\n+ *\n+ * This uses a simple linear approximation to interpolate between points which should be fine for short distances, but\n+ * if support for longer distances is needed or to handle segments crossing the international date line, should use a\n+ * more robust algorithm that interpolates along the great circle path between points.\n+ */\n+public class EdgeSampling {\n+    private static final Logger logger = LoggerFactory.getLogger(EdgeSampling.class);\n+    private static final double WARN_ON_SEGMENT_LENGTH = DistanceCalcEarth.METERS_PER_DEGREE / 4;\n+\n+    private EdgeSampling() {}\n+\n+    public static PointList sample(PointList input, double maxDistance, DistanceCalc distCalc, ElevationProvider elevation) {\n+        PointList output = new PointList(input.getSize() * 2, input.is3D());\n+        if (input.isEmpty()) return output;\n+        int nodes = input.getSize();\n+        double lastLat = input.getLat(0), lastLon = input.getLon(0), thisLat, thisLon, thisEle;\n+        for (int i = 0; i < nodes; i++) {\n+            thisLat = input.getLat(i);\n+            thisLon = input.getLon(i);\n+            thisEle = input.getEle(i);\n+            if (i > 0 && !distCalc.isCrossBoundary(lastLon, thisLon)) {\n+                double segmentLength = distCalc.calcDist(lastLat, lastLon, thisLat, thisLon);\n+                if (segmentLength > WARN_ON_SEGMENT_LENGTH) {\n+                    logger.warn(\"Edge from \" + lastLat + \",\" + lastLon + \" to \" + thisLat + \",\" + thisLon + \" is \" +\n+                            (int)segmentLength + \"m long, might cause issues with edge sampling.\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "47b1f3e13f592806482e303b59ad12e427f99d7e"}, "originalPosition": 53}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDQ5MDkzNQ==", "bodyText": "I haven't run this on the entire world so I don't know if it actually comes up. I did not see it running in the US or Germany.  A few options I could see are:\n\nhandle this more gracefully by falling back to great circle interpolation in this case (or when crossing the international date line)\nnot interpolating at all if the edge is too long\nor telling the user to add intermediate points to fix data in OpenStreetMap\n\nIf we can find an example, it would be good to see what it looks like on a few map providers - routes returned by GraphHopper should align with maps they might be displayed on.", "url": "https://github.com/graphhopper/graphhopper/pull/1953#discussion_r420490935", "createdAt": "2020-05-06T00:52:37Z", "author": {"login": "msbarry"}, "path": "core/src/main/java/com/graphhopper/reader/dem/EdgeSampling.java", "diffHunk": "@@ -0,0 +1,72 @@\n+/*\n+ *  Licensed to GraphHopper GmbH under one or more contributor\n+ *  license agreements. See the NOTICE file distributed with this work for\n+ *  additional information regarding copyright ownership.\n+ *\n+ *  GraphHopper GmbH licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except in\n+ *  compliance with the License. You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package com.graphhopper.reader.dem;\n+\n+import com.graphhopper.util.DistanceCalc;\n+import com.graphhopper.util.DistanceCalcEarth;\n+import com.graphhopper.util.PointList;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Ensures that elevation is sampled along a point list with no more than maxDistance between samples. Works by adding\n+ * points along long edges and fetching elevation at each inserted point.\n+ *\n+ * This uses a simple linear approximation to interpolate between points which should be fine for short distances, but\n+ * if support for longer distances is needed or to handle segments crossing the international date line, should use a\n+ * more robust algorithm that interpolates along the great circle path between points.\n+ */\n+public class EdgeSampling {\n+    private static final Logger logger = LoggerFactory.getLogger(EdgeSampling.class);\n+    private static final double WARN_ON_SEGMENT_LENGTH = DistanceCalcEarth.METERS_PER_DEGREE / 4;\n+\n+    private EdgeSampling() {}\n+\n+    public static PointList sample(PointList input, double maxDistance, DistanceCalc distCalc, ElevationProvider elevation) {\n+        PointList output = new PointList(input.getSize() * 2, input.is3D());\n+        if (input.isEmpty()) return output;\n+        int nodes = input.getSize();\n+        double lastLat = input.getLat(0), lastLon = input.getLon(0), thisLat, thisLon, thisEle;\n+        for (int i = 0; i < nodes; i++) {\n+            thisLat = input.getLat(i);\n+            thisLon = input.getLon(i);\n+            thisEle = input.getEle(i);\n+            if (i > 0 && !distCalc.isCrossBoundary(lastLon, thisLon)) {\n+                double segmentLength = distCalc.calcDist(lastLat, lastLon, thisLat, thisLon);\n+                if (segmentLength > WARN_ON_SEGMENT_LENGTH) {\n+                    logger.warn(\"Edge from \" + lastLat + \",\" + lastLon + \" to \" + thisLat + \",\" + thisLon + \" is \" +\n+                            (int)segmentLength + \"m long, might cause issues with edge sampling.\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDA5MTkxOA=="}, "originalCommit": {"oid": "47b1f3e13f592806482e303b59ad12e427f99d7e"}, "originalPosition": 53}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDU2ODE4Ng==", "bodyText": "Yes I agree, having an example or two would be great. Ok so I think we should keep this in mind and see if any issues pop up when importing a planet file. I will run a test on Australia to see if there are any such warnings popping up.", "url": "https://github.com/graphhopper/graphhopper/pull/1953#discussion_r420568186", "createdAt": "2020-05-06T06:23:44Z", "author": {"login": "boldtrn"}, "path": "core/src/main/java/com/graphhopper/reader/dem/EdgeSampling.java", "diffHunk": "@@ -0,0 +1,72 @@\n+/*\n+ *  Licensed to GraphHopper GmbH under one or more contributor\n+ *  license agreements. See the NOTICE file distributed with this work for\n+ *  additional information regarding copyright ownership.\n+ *\n+ *  GraphHopper GmbH licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except in\n+ *  compliance with the License. You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package com.graphhopper.reader.dem;\n+\n+import com.graphhopper.util.DistanceCalc;\n+import com.graphhopper.util.DistanceCalcEarth;\n+import com.graphhopper.util.PointList;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Ensures that elevation is sampled along a point list with no more than maxDistance between samples. Works by adding\n+ * points along long edges and fetching elevation at each inserted point.\n+ *\n+ * This uses a simple linear approximation to interpolate between points which should be fine for short distances, but\n+ * if support for longer distances is needed or to handle segments crossing the international date line, should use a\n+ * more robust algorithm that interpolates along the great circle path between points.\n+ */\n+public class EdgeSampling {\n+    private static final Logger logger = LoggerFactory.getLogger(EdgeSampling.class);\n+    private static final double WARN_ON_SEGMENT_LENGTH = DistanceCalcEarth.METERS_PER_DEGREE / 4;\n+\n+    private EdgeSampling() {}\n+\n+    public static PointList sample(PointList input, double maxDistance, DistanceCalc distCalc, ElevationProvider elevation) {\n+        PointList output = new PointList(input.getSize() * 2, input.is3D());\n+        if (input.isEmpty()) return output;\n+        int nodes = input.getSize();\n+        double lastLat = input.getLat(0), lastLon = input.getLon(0), thisLat, thisLon, thisEle;\n+        for (int i = 0; i < nodes; i++) {\n+            thisLat = input.getLat(i);\n+            thisLon = input.getLon(i);\n+            thisEle = input.getEle(i);\n+            if (i > 0 && !distCalc.isCrossBoundary(lastLon, thisLon)) {\n+                double segmentLength = distCalc.calcDist(lastLat, lastLon, thisLat, thisLon);\n+                if (segmentLength > WARN_ON_SEGMENT_LENGTH) {\n+                    logger.warn(\"Edge from \" + lastLat + \",\" + lastLon + \" to \" + thisLat + \",\" + thisLon + \" is \" +\n+                            (int)segmentLength + \"m long, might cause issues with edge sampling.\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDA5MTkxOA=="}, "originalCommit": {"oid": "47b1f3e13f592806482e303b59ad12e427f99d7e"}, "originalPosition": 53}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDc0MjE0Nw==", "bodyText": "Ok, I cound find some instances of this warning in Australia :).\n2020-05-06 13:58:47.635 [main] WARN  c.g.reader.dem.EdgeSampling - Edge from -32.68276041782112,120.69303365110682 to -32.87841862913412,120.4256310036547 is 33140m long, might cause issues with edge sampling.\n2020-05-06 14:00:00.221 [main] WARN  c.g.reader.dem.EdgeSampling - Edge from -32.99502934504366,120.25418606223582 to -32.99459069210121,119.94914326703123 is 28448m long, might cause issues with edge sampling.\n2020-05-06 14:01:07.068 [main] WARN  c.g.reader.dem.EdgeSampling - Edge from -33.58228318949677,139.9640097833576 to -33.297097123349396,140.12294594473272 is 34972m long, might cause issues with edge sampling.\n2020-05-06 14:01:21.906 [main] WARN  c.g.reader.dem.EdgeSampling - Edge from -28.882821363571765,130.60277563935762 to -28.853342581987587,130.90639108955244 is 29746m long, might cause issues with edge sampling.\n2020-05-06 14:01:27.928 [main] WARN  c.g.reader.dem.EdgeSampling - Edge from -27.22052787737238,153.12535546255162 to -27.079826267357756,153.36294665998847 is 28238m long, might cause issues with edge sampling.\n2020-05-06 14:01:55.286 [main] WARN  c.g.reader.dem.EdgeSampling - Edge from -14.098557027397089,136.0286709523649 to -13.853749011168235,136.18335264585954 is 31930m long, might cause issues with edge sampling.\n\nHere are some of the ways where this applies:\n\nhttps://www.openstreetmap.org/way/29477902\nhttps://www.openstreetmap.org/way/731710835\nhttps://www.openstreetmap.org/way/544311447\n\nMy feeling would be, since there are not many of these edges it would be valid to simply ignore these cases and not interpolating there. I could no add a point for these ways and slightly improve the following of the original track, using satellite imagery, where I can see it, but it's probably not worth it. WDYT?", "url": "https://github.com/graphhopper/graphhopper/pull/1953#discussion_r420742147", "createdAt": "2020-05-06T12:13:24Z", "author": {"login": "boldtrn"}, "path": "core/src/main/java/com/graphhopper/reader/dem/EdgeSampling.java", "diffHunk": "@@ -0,0 +1,72 @@\n+/*\n+ *  Licensed to GraphHopper GmbH under one or more contributor\n+ *  license agreements. See the NOTICE file distributed with this work for\n+ *  additional information regarding copyright ownership.\n+ *\n+ *  GraphHopper GmbH licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except in\n+ *  compliance with the License. You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package com.graphhopper.reader.dem;\n+\n+import com.graphhopper.util.DistanceCalc;\n+import com.graphhopper.util.DistanceCalcEarth;\n+import com.graphhopper.util.PointList;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Ensures that elevation is sampled along a point list with no more than maxDistance between samples. Works by adding\n+ * points along long edges and fetching elevation at each inserted point.\n+ *\n+ * This uses a simple linear approximation to interpolate between points which should be fine for short distances, but\n+ * if support for longer distances is needed or to handle segments crossing the international date line, should use a\n+ * more robust algorithm that interpolates along the great circle path between points.\n+ */\n+public class EdgeSampling {\n+    private static final Logger logger = LoggerFactory.getLogger(EdgeSampling.class);\n+    private static final double WARN_ON_SEGMENT_LENGTH = DistanceCalcEarth.METERS_PER_DEGREE / 4;\n+\n+    private EdgeSampling() {}\n+\n+    public static PointList sample(PointList input, double maxDistance, DistanceCalc distCalc, ElevationProvider elevation) {\n+        PointList output = new PointList(input.getSize() * 2, input.is3D());\n+        if (input.isEmpty()) return output;\n+        int nodes = input.getSize();\n+        double lastLat = input.getLat(0), lastLon = input.getLon(0), thisLat, thisLon, thisEle;\n+        for (int i = 0; i < nodes; i++) {\n+            thisLat = input.getLat(i);\n+            thisLon = input.getLon(i);\n+            thisEle = input.getEle(i);\n+            if (i > 0 && !distCalc.isCrossBoundary(lastLon, thisLon)) {\n+                double segmentLength = distCalc.calcDist(lastLat, lastLon, thisLat, thisLon);\n+                if (segmentLength > WARN_ON_SEGMENT_LENGTH) {\n+                    logger.warn(\"Edge from \" + lastLat + \",\" + lastLon + \" to \" + thisLat + \",\" + thisLon + \" is \" +\n+                            (int)segmentLength + \"m long, might cause issues with edge sampling.\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDA5MTkxOA=="}, "originalCommit": {"oid": "47b1f3e13f592806482e303b59ad12e427f99d7e"}, "originalPosition": 53}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTE4NzcxOA==", "bodyText": "Looking into those, the difference between the road that graphhopper shows with edge sampling the difference appears to be negligible.  I'll bump the threshold out to 1 degree instead of 1/4 degree, improve the error message,  and fall back to not interpolating in this case", "url": "https://github.com/graphhopper/graphhopper/pull/1953#discussion_r421187718", "createdAt": "2020-05-07T01:33:35Z", "author": {"login": "msbarry"}, "path": "core/src/main/java/com/graphhopper/reader/dem/EdgeSampling.java", "diffHunk": "@@ -0,0 +1,72 @@\n+/*\n+ *  Licensed to GraphHopper GmbH under one or more contributor\n+ *  license agreements. See the NOTICE file distributed with this work for\n+ *  additional information regarding copyright ownership.\n+ *\n+ *  GraphHopper GmbH licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except in\n+ *  compliance with the License. You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package com.graphhopper.reader.dem;\n+\n+import com.graphhopper.util.DistanceCalc;\n+import com.graphhopper.util.DistanceCalcEarth;\n+import com.graphhopper.util.PointList;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Ensures that elevation is sampled along a point list with no more than maxDistance between samples. Works by adding\n+ * points along long edges and fetching elevation at each inserted point.\n+ *\n+ * This uses a simple linear approximation to interpolate between points which should be fine for short distances, but\n+ * if support for longer distances is needed or to handle segments crossing the international date line, should use a\n+ * more robust algorithm that interpolates along the great circle path between points.\n+ */\n+public class EdgeSampling {\n+    private static final Logger logger = LoggerFactory.getLogger(EdgeSampling.class);\n+    private static final double WARN_ON_SEGMENT_LENGTH = DistanceCalcEarth.METERS_PER_DEGREE / 4;\n+\n+    private EdgeSampling() {}\n+\n+    public static PointList sample(PointList input, double maxDistance, DistanceCalc distCalc, ElevationProvider elevation) {\n+        PointList output = new PointList(input.getSize() * 2, input.is3D());\n+        if (input.isEmpty()) return output;\n+        int nodes = input.getSize();\n+        double lastLat = input.getLat(0), lastLon = input.getLon(0), thisLat, thisLon, thisEle;\n+        for (int i = 0; i < nodes; i++) {\n+            thisLat = input.getLat(i);\n+            thisLon = input.getLon(i);\n+            thisEle = input.getEle(i);\n+            if (i > 0 && !distCalc.isCrossBoundary(lastLon, thisLon)) {\n+                double segmentLength = distCalc.calcDist(lastLat, lastLon, thisLat, thisLon);\n+                if (segmentLength > WARN_ON_SEGMENT_LENGTH) {\n+                    logger.warn(\"Edge from \" + lastLat + \",\" + lastLon + \" to \" + thisLat + \",\" + thisLon + \" is \" +\n+                            (int)segmentLength + \"m long, might cause issues with edge sampling.\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDA5MTkxOA=="}, "originalCommit": {"oid": "47b1f3e13f592806482e303b59ad12e427f99d7e"}, "originalPosition": 53}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTI4MTQ1MA==", "bodyText": "Ok, sounds good to me, thanks!\n\nLooking into those, the difference between the road that graphhopper shows with edge sampling the difference appears to be negligible.\n\nHow did you compare those? Visually using Leaflet? Leaflet by default uses a linear approach as well. There is a plugin for Leaflet: https://github.com/henrythasler/Leaflet.Geodesic\nOr you could also use the GPX files and import them on Google MyMaps, they also use the great circle to connect two points.", "url": "https://github.com/graphhopper/graphhopper/pull/1953#discussion_r421281450", "createdAt": "2020-05-07T07:01:13Z", "author": {"login": "boldtrn"}, "path": "core/src/main/java/com/graphhopper/reader/dem/EdgeSampling.java", "diffHunk": "@@ -0,0 +1,72 @@\n+/*\n+ *  Licensed to GraphHopper GmbH under one or more contributor\n+ *  license agreements. See the NOTICE file distributed with this work for\n+ *  additional information regarding copyright ownership.\n+ *\n+ *  GraphHopper GmbH licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except in\n+ *  compliance with the License. You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package com.graphhopper.reader.dem;\n+\n+import com.graphhopper.util.DistanceCalc;\n+import com.graphhopper.util.DistanceCalcEarth;\n+import com.graphhopper.util.PointList;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Ensures that elevation is sampled along a point list with no more than maxDistance between samples. Works by adding\n+ * points along long edges and fetching elevation at each inserted point.\n+ *\n+ * This uses a simple linear approximation to interpolate between points which should be fine for short distances, but\n+ * if support for longer distances is needed or to handle segments crossing the international date line, should use a\n+ * more robust algorithm that interpolates along the great circle path between points.\n+ */\n+public class EdgeSampling {\n+    private static final Logger logger = LoggerFactory.getLogger(EdgeSampling.class);\n+    private static final double WARN_ON_SEGMENT_LENGTH = DistanceCalcEarth.METERS_PER_DEGREE / 4;\n+\n+    private EdgeSampling() {}\n+\n+    public static PointList sample(PointList input, double maxDistance, DistanceCalc distCalc, ElevationProvider elevation) {\n+        PointList output = new PointList(input.getSize() * 2, input.is3D());\n+        if (input.isEmpty()) return output;\n+        int nodes = input.getSize();\n+        double lastLat = input.getLat(0), lastLon = input.getLon(0), thisLat, thisLon, thisEle;\n+        for (int i = 0; i < nodes; i++) {\n+            thisLat = input.getLat(i);\n+            thisLon = input.getLon(i);\n+            thisEle = input.getEle(i);\n+            if (i > 0 && !distCalc.isCrossBoundary(lastLon, thisLon)) {\n+                double segmentLength = distCalc.calcDist(lastLat, lastLon, thisLat, thisLon);\n+                if (segmentLength > WARN_ON_SEGMENT_LENGTH) {\n+                    logger.warn(\"Edge from \" + lastLat + \",\" + lastLon + \" to \" + thisLat + \",\" + thisLon + \" is \" +\n+                            (int)segmentLength + \"m long, might cause issues with edge sampling.\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDA5MTkxOA=="}, "originalCommit": {"oid": "47b1f3e13f592806482e303b59ad12e427f99d7e"}, "originalPosition": 53}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTQxNDg3MA==", "bodyText": "I switched to satellite view on local graphhopper web, the path was off by a couple of road widths in the middle.  I dug into the great circle approach, it wasn't too complex so I just implemented that for segments longer than 1/4 degree. Let me know what you think, it is based on the same source as projectCoordinate and seems to hold up pretty well in unit tests.", "url": "https://github.com/graphhopper/graphhopper/pull/1953#discussion_r421414870", "createdAt": "2020-05-07T10:52:21Z", "author": {"login": "msbarry"}, "path": "core/src/main/java/com/graphhopper/reader/dem/EdgeSampling.java", "diffHunk": "@@ -0,0 +1,72 @@\n+/*\n+ *  Licensed to GraphHopper GmbH under one or more contributor\n+ *  license agreements. See the NOTICE file distributed with this work for\n+ *  additional information regarding copyright ownership.\n+ *\n+ *  GraphHopper GmbH licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except in\n+ *  compliance with the License. You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package com.graphhopper.reader.dem;\n+\n+import com.graphhopper.util.DistanceCalc;\n+import com.graphhopper.util.DistanceCalcEarth;\n+import com.graphhopper.util.PointList;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Ensures that elevation is sampled along a point list with no more than maxDistance between samples. Works by adding\n+ * points along long edges and fetching elevation at each inserted point.\n+ *\n+ * This uses a simple linear approximation to interpolate between points which should be fine for short distances, but\n+ * if support for longer distances is needed or to handle segments crossing the international date line, should use a\n+ * more robust algorithm that interpolates along the great circle path between points.\n+ */\n+public class EdgeSampling {\n+    private static final Logger logger = LoggerFactory.getLogger(EdgeSampling.class);\n+    private static final double WARN_ON_SEGMENT_LENGTH = DistanceCalcEarth.METERS_PER_DEGREE / 4;\n+\n+    private EdgeSampling() {}\n+\n+    public static PointList sample(PointList input, double maxDistance, DistanceCalc distCalc, ElevationProvider elevation) {\n+        PointList output = new PointList(input.getSize() * 2, input.is3D());\n+        if (input.isEmpty()) return output;\n+        int nodes = input.getSize();\n+        double lastLat = input.getLat(0), lastLon = input.getLon(0), thisLat, thisLon, thisEle;\n+        for (int i = 0; i < nodes; i++) {\n+            thisLat = input.getLat(i);\n+            thisLon = input.getLon(i);\n+            thisEle = input.getEle(i);\n+            if (i > 0 && !distCalc.isCrossBoundary(lastLon, thisLon)) {\n+                double segmentLength = distCalc.calcDist(lastLat, lastLon, thisLat, thisLon);\n+                if (segmentLength > WARN_ON_SEGMENT_LENGTH) {\n+                    logger.warn(\"Edge from \" + lastLat + \",\" + lastLon + \" to \" + thisLat + \",\" + thisLon + \" is \" +\n+                            (int)segmentLength + \"m long, might cause issues with edge sampling.\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDA5MTkxOA=="}, "originalCommit": {"oid": "47b1f3e13f592806482e303b59ad12e427f99d7e"}, "originalPosition": 53}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYxNTA5MzEwOnYy", "diffSide": "RIGHT", "path": "core/src/main/java/com/graphhopper/reader/dem/EdgeSampling.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNVQxMzowOToxOVrOGQoj0Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNVQxMzowOToxOVrOGQoj0Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDA5NDkyOQ==", "bodyText": "Shouldn't this use the 3D distance?", "url": "https://github.com/graphhopper/graphhopper/pull/1953#discussion_r420094929", "createdAt": "2020-05-05T13:09:19Z", "author": {"login": "boldtrn"}, "path": "core/src/main/java/com/graphhopper/reader/dem/EdgeSampling.java", "diffHunk": "@@ -0,0 +1,72 @@\n+/*\n+ *  Licensed to GraphHopper GmbH under one or more contributor\n+ *  license agreements. See the NOTICE file distributed with this work for\n+ *  additional information regarding copyright ownership.\n+ *\n+ *  GraphHopper GmbH licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except in\n+ *  compliance with the License. You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package com.graphhopper.reader.dem;\n+\n+import com.graphhopper.util.DistanceCalc;\n+import com.graphhopper.util.DistanceCalcEarth;\n+import com.graphhopper.util.PointList;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Ensures that elevation is sampled along a point list with no more than maxDistance between samples. Works by adding\n+ * points along long edges and fetching elevation at each inserted point.\n+ *\n+ * This uses a simple linear approximation to interpolate between points which should be fine for short distances, but\n+ * if support for longer distances is needed or to handle segments crossing the international date line, should use a\n+ * more robust algorithm that interpolates along the great circle path between points.\n+ */\n+public class EdgeSampling {\n+    private static final Logger logger = LoggerFactory.getLogger(EdgeSampling.class);\n+    private static final double WARN_ON_SEGMENT_LENGTH = DistanceCalcEarth.METERS_PER_DEGREE / 4;\n+\n+    private EdgeSampling() {}\n+\n+    public static PointList sample(PointList input, double maxDistance, DistanceCalc distCalc, ElevationProvider elevation) {\n+        PointList output = new PointList(input.getSize() * 2, input.is3D());\n+        if (input.isEmpty()) return output;\n+        int nodes = input.getSize();\n+        double lastLat = input.getLat(0), lastLon = input.getLon(0), thisLat, thisLon, thisEle;\n+        for (int i = 0; i < nodes; i++) {\n+            thisLat = input.getLat(i);\n+            thisLon = input.getLon(i);\n+            thisEle = input.getEle(i);\n+            if (i > 0 && !distCalc.isCrossBoundary(lastLon, thisLon)) {\n+                double segmentLength = distCalc.calcDist(lastLat, lastLon, thisLat, thisLon);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "47b1f3e13f592806482e303b59ad12e427f99d7e"}, "originalPosition": 50}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYxOTEwNDQ1OnYy", "diffSide": "RIGHT", "path": "api/src/main/java/com/graphhopper/util/DistanceCalcEarth.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNlQxMTo0MTo1MVrOGRPD0w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNlQxMzo1MTo1MVrOGRUDMg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDcyNTcxNQ==", "bodyText": "@boldtrn this fixed the Australia issue and fixed some unit tests I added, I saw that other code was not trimming segments (calcNormalizedEdgeDistance sets reduceToSegment to false) - is there a reason to retain that behavior here and only handle the NaN case?", "url": "https://github.com/graphhopper/graphhopper/pull/1953#discussion_r420725715", "createdAt": "2020-05-06T11:41:51Z", "author": {"login": "msbarry"}, "path": "api/src/main/java/com/graphhopper/util/DistanceCalcEarth.java", "diffHunk": "@@ -149,6 +149,8 @@ public double calcNormalizedEdgeDistance3D(double r_lat_deg, double r_lon_deg, d\n \n         double norm = delta_lon * delta_lon + delta_lat * delta_lat + delta_ele * delta_ele;\n         double factor = ((r_lon - a_lon) * delta_lon + (r_lat - a_lat) * delta_lat + (r_ele - a_ele) * delta_ele) / norm;\n+        if (factor < 0 || Double.isNaN(factor)) factor = 0;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "91267315ecee0dc9707d32c1aaf9a8fe8daddac2"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDc0NTcyMw==", "bodyText": "Thanks for finding this. I am not sure if we still need this. If I understand this right, the option was used to remain backward compatibility. WDYT @karussell?", "url": "https://github.com/graphhopper/graphhopper/pull/1953#discussion_r420745723", "createdAt": "2020-05-06T12:19:35Z", "author": {"login": "boldtrn"}, "path": "api/src/main/java/com/graphhopper/util/DistanceCalcEarth.java", "diffHunk": "@@ -149,6 +149,8 @@ public double calcNormalizedEdgeDistance3D(double r_lat_deg, double r_lon_deg, d\n \n         double norm = delta_lon * delta_lon + delta_lat * delta_lat + delta_ele * delta_ele;\n         double factor = ((r_lon - a_lon) * delta_lon + (r_lat - a_lat) * delta_lat + (r_ele - a_ele) * delta_ele) / norm;\n+        if (factor < 0 || Double.isNaN(factor)) factor = 0;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDcyNTcxNQ=="}, "originalCommit": {"oid": "91267315ecee0dc9707d32c1aaf9a8fe8daddac2"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDgwNzQ3NA==", "bodyText": "IMO we can remove the reduceToSegment parameter as it seems that only reduceToSegment==false is used.\nThe option was introduced several years ago in this commit: 98e22f4#diff-381813cce27dac5fde2afa44aec5bb13L164\nbut wasn't used it seems. Ugly.", "url": "https://github.com/graphhopper/graphhopper/pull/1953#discussion_r420807474", "createdAt": "2020-05-06T13:51:51Z", "author": {"login": "karussell"}, "path": "api/src/main/java/com/graphhopper/util/DistanceCalcEarth.java", "diffHunk": "@@ -149,6 +149,8 @@ public double calcNormalizedEdgeDistance3D(double r_lat_deg, double r_lon_deg, d\n \n         double norm = delta_lon * delta_lon + delta_lat * delta_lat + delta_ele * delta_ele;\n         double factor = ((r_lon - a_lon) * delta_lon + (r_lat - a_lat) * delta_lat + (r_ele - a_ele) * delta_ele) / norm;\n+        if (factor < 0 || Double.isNaN(factor)) factor = 0;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDcyNTcxNQ=="}, "originalCommit": {"oid": "91267315ecee0dc9707d32c1aaf9a8fe8daddac2"}, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYyODA0NDQ5OnYy", "diffSide": "RIGHT", "path": "api/src/main/java/com/graphhopper/util/DistanceCalcEarth.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wOFQxMjo1MzozN1rOGSkgmw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wOFQxMjo1MzozN1rOGSkgmw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjEyNTcyMw==", "bodyText": "We should probably avoid to recompute stuff like Math.cos(lat1radians).", "url": "https://github.com/graphhopper/graphhopper/pull/1953#discussion_r422125723", "createdAt": "2020-05-08T12:53:37Z", "author": {"login": "otbutz"}, "path": "api/src/main/java/com/graphhopper/util/DistanceCalcEarth.java", "diffHunk": "@@ -300,6 +280,35 @@ public GHPoint projectCoordinate(double latInDeg, double lonInDeg, double distan\n         return new GHPoint(projectedLat, projectedLon);\n     }\n \n+    @Override\n+    public GHPoint intermediatePoint(double f, double lat1, double lon1, double lat2, double lon2) {\n+        double lat1radians = Math.toRadians(lat1);\n+        double lon1radians = Math.toRadians(lon1);\n+        double lat2radians = Math.toRadians(lat2);\n+        double lon2radians = Math.toRadians(lon2);\n+\n+        // This formula is taken from: (http://www.movable-type.co.uk/scripts/latlong.html -> https://github.com/chrisveness/geodesy MIT)\n+\n+        double deltaLat = lat2radians - lat1radians;\n+        double deltaLon = lon2radians - lon1radians;\n+        double a = Math.sin(deltaLat/2) * Math.sin(deltaLat/2)\n+                + Math.cos(lat1radians) * Math.cos(lat2radians) * Math.sin(deltaLon/2) * Math.sin(deltaLon/2);\n+        double angularDistance =  2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));\n+        if (angularDistance == 0) return new GHPoint(lat1, lon1);\n+\n+        double A = Math.sin((1-f)*angularDistance) / Math.sin(angularDistance);\n+        double B = Math.sin(f*angularDistance) / Math.sin(angularDistance);\n+\n+        double x = A * Math.cos(lat1radians) * Math.cos(lon1radians) + B * Math.cos(lat2radians) * Math.cos(lon2radians);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7f2449245fa86890030fe43cc509d387cb62e486"}, "originalPosition": 144}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcyNTM4MTgyOnYy", "diffSide": "RIGHT", "path": "web/src/main/resources/assets/js/main.js", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOVQxNDo0MDowM1rOGhNaRg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOVQxNDo0MDowM1rOGhNaRg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzQ3NTkxMA==", "bodyText": "This file needs to be removed as it is now auto-created.", "url": "https://github.com/graphhopper/graphhopper/pull/1953#discussion_r437475910", "createdAt": "2020-06-09T14:40:03Z", "author": {"login": "karussell"}, "path": "web/src/main/resources/assets/js/main.js", "diffHunk": "@@ -0,0 +1,284 @@\n+(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c=\"function\"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error(\"Cannot find module '\"+i+\"'\");throw a.code=\"MODULE_NOT_FOUND\",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u=\"function\"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "27343aee24345faec25aefc670da96247f14c1fe"}, "originalPosition": 1}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjczMDk2MTI4OnYy", "diffSide": "LEFT", "path": "core/src/main/java/com/graphhopper/GraphHopper.java", "isResolved": false, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMFQyMDoxMTo1N1rOGiEqQQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMVQwOTo1NDoyMlrOGiWewA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODM4MTEyMQ==", "bodyText": "@easbar probably a matter of taste but ... there are properties that are used while import and for the routing and they could be different which would motivate two variables, but likely not here. Should we still keep the two variables?", "url": "https://github.com/graphhopper/graphhopper/pull/1953#discussion_r438381121", "createdAt": "2020-06-10T20:11:57Z", "author": {"login": "karussell"}, "path": "core/src/main/java/com/graphhopper/GraphHopper.java", "diffHunk": "@@ -711,7 +709,7 @@ protected DataReader initDataReader(DataReader reader) {\n                 setElevationProvider(eleProvider).\n                 setWorkerThreads(dataReaderWorkerThreads).\n                 setWayPointMaxDistance(dataReaderWayPointMaxDistance).\n-                setWayPointElevationMaxDistance(elevationWayPointMaxDistance).", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8d8d7fd7611779be657e61dcacc7d4aee5302f0d"}, "originalPosition": 20}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODQ3NzE3Ng==", "bodyText": "We could also make elevation way point max distance controllable through a request parameter for routing?", "url": "https://github.com/graphhopper/graphhopper/pull/1953#discussion_r438477176", "createdAt": "2020-06-11T00:24:26Z", "author": {"login": "msbarry"}, "path": "core/src/main/java/com/graphhopper/GraphHopper.java", "diffHunk": "@@ -711,7 +709,7 @@ protected DataReader initDataReader(DataReader reader) {\n                 setElevationProvider(eleProvider).\n                 setWorkerThreads(dataReaderWorkerThreads).\n                 setWayPointMaxDistance(dataReaderWayPointMaxDistance).\n-                setWayPointElevationMaxDistance(elevationWayPointMaxDistance).", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODM4MTEyMQ=="}, "originalCommit": {"oid": "8d8d7fd7611779be657e61dcacc7d4aee5302f0d"}, "originalPosition": 20}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODU2OTAyNw==", "bodyText": "Thanks a lot for this very nice PR @msbarry!\nAs far as I can tell the elevationWayPointMaxDistance is used to control how many extra pillar nodes get created during import (to preserve elevation changes within the geometries) and it is also used during path simplification when running routing requests (to not throw away way points reflecting elevation changes). These two usages are different in that the first only can have an effect during import (after the first import it becomes meaningless unless we rebuild the graph) while the other could (at least in theory) be changed for every single request. Is that correct? For this reason I think it would be cleaner to use two parameters, e.g. one would go into the (not yet existing) ImporterConfig and the other would go to RouterConfig and the latter could also be changed via the routing hints in Router#createPathMerger. I just wonder if this is overkill and I do not think its urgent to separate this into two parameters already. In any case the parameter used for the import is a good default value for the one used during routing?\n\nShould we still keep the two variables?\n\nWhich two variables do you mean? I thought so far there is only one (only one that has to do with import and routing).\n\nWe could also make elevation way point max distance controllable through a request parameter for routing?\n\nYes, exactly, in Router#createPathMerger.", "url": "https://github.com/graphhopper/graphhopper/pull/1953#discussion_r438569027", "createdAt": "2020-06-11T06:29:02Z", "author": {"login": "easbar"}, "path": "core/src/main/java/com/graphhopper/GraphHopper.java", "diffHunk": "@@ -711,7 +709,7 @@ protected DataReader initDataReader(DataReader reader) {\n                 setElevationProvider(eleProvider).\n                 setWorkerThreads(dataReaderWorkerThreads).\n                 setWayPointMaxDistance(dataReaderWayPointMaxDistance).\n-                setWayPointElevationMaxDistance(elevationWayPointMaxDistance).", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODM4MTEyMQ=="}, "originalCommit": {"oid": "8d8d7fd7611779be657e61dcacc7d4aee5302f0d"}, "originalPosition": 20}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODY2OTk0Ng==", "bodyText": "Thanks @easbar, longEdgeSamplingDistance controls how many extra pillar nodes are added and elevationWayPointMaxDistance prevents them from getting removed during simplification (on import, and during routing).  I added a new elevation_way_point_max_distance request parameter in 9edbfbf to let you change elevationWayPointMaxDistance on each request or omit to default to what was used during import.  I agree it's probably overkill to split out separate config parameters for data reader import and router default. Let me know if that change looks sufficient.", "url": "https://github.com/graphhopper/graphhopper/pull/1953#discussion_r438669946", "createdAt": "2020-06-11T09:48:17Z", "author": {"login": "msbarry"}, "path": "core/src/main/java/com/graphhopper/GraphHopper.java", "diffHunk": "@@ -711,7 +709,7 @@ protected DataReader initDataReader(DataReader reader) {\n                 setElevationProvider(eleProvider).\n                 setWorkerThreads(dataReaderWorkerThreads).\n                 setWayPointMaxDistance(dataReaderWayPointMaxDistance).\n-                setWayPointElevationMaxDistance(elevationWayPointMaxDistance).", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODM4MTEyMQ=="}, "originalCommit": {"oid": "8d8d7fd7611779be657e61dcacc7d4aee5302f0d"}, "originalPosition": 20}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODY3MzA4OA==", "bodyText": "Yes thanks I like it.", "url": "https://github.com/graphhopper/graphhopper/pull/1953#discussion_r438673088", "createdAt": "2020-06-11T09:54:22Z", "author": {"login": "easbar"}, "path": "core/src/main/java/com/graphhopper/GraphHopper.java", "diffHunk": "@@ -711,7 +709,7 @@ protected DataReader initDataReader(DataReader reader) {\n                 setElevationProvider(eleProvider).\n                 setWorkerThreads(dataReaderWorkerThreads).\n                 setWayPointMaxDistance(dataReaderWayPointMaxDistance).\n-                setWayPointElevationMaxDistance(elevationWayPointMaxDistance).", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODM4MTEyMQ=="}, "originalCommit": {"oid": "8d8d7fd7611779be657e61dcacc7d4aee5302f0d"}, "originalPosition": 20}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4754, "cost": 1, "resetAt": "2021-11-12T20:28:25Z"}}}