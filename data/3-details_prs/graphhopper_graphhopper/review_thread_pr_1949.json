{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzg1MzI0Mzcw", "number": 1949, "reviewThreads": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMFQwODo0NTo1M1rODmloMA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMFQxMDo0NzozNFrODmoNsA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQxNzg4OTc2OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/com/graphhopper/GraphHopper.java", "isResolved": false, "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMFQwODo0NTo1M1rOF0Fqkg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMFQxMTo0MzozOVrOF0LZlw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDE2MzA5MA==", "bodyText": "Any opinion here? createWeighting normally uses a DefaultTurnCostProvider if profile.isTurnCosts()==true. But for LM we always want to enforce not using turn costs for the preparation, but to me it seemed like this does not justify adding an extra parameter, so I am using the pmap workaround here...", "url": "https://github.com/graphhopper/graphhopper/pull/1949#discussion_r390163090", "createdAt": "2020-03-10T08:45:53Z", "author": {"login": "easbar"}, "path": "core/src/main/java/com/graphhopper/GraphHopper.java", "diffHunk": "@@ -913,9 +922,11 @@ private void initLMPreparationHandler() {\n \n         for (LMProfileConfig lmConfig : lmPreparationHandler.getLMProfileConfigs()) {\n             ProfileConfig profile = profilesByName.get(lmConfig.getProfile());\n-            FlagEncoder encoder = encodingManager.getEncoder(profile.getVehicle());\n-            // note that we do not consider turn costs during LM preparation?\n-            Weighting weighting = createWeighting(new HintsMap(profile.getWeighting()), encoder, NO_TURN_COST_PROVIDER);\n+            // note that we do not consider turn costs during LM preparation. this is important if we want\n+            // to allow e.g. changing the u_turn_costs per request (we have to use the minimum weight settings (\n+            // = no turn costs) for the preparation)\n+            // todonow: is it too ugly this way?\n+            Weighting weighting = createWeighting(profile, new PMap().put(\"__disable_turn_costs\", true));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8a9f090b2fb8e05691043fa428077a046251557e"}, "originalPosition": 140}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDI1MTAwNQ==", "bodyText": "I would not do this here and just force the usage of no turn cost provider in LM. IMO this is something implementation specific?", "url": "https://github.com/graphhopper/graphhopper/pull/1949#discussion_r390251005", "createdAt": "2020-03-10T11:30:48Z", "author": {"login": "karussell"}, "path": "core/src/main/java/com/graphhopper/GraphHopper.java", "diffHunk": "@@ -913,9 +922,11 @@ private void initLMPreparationHandler() {\n \n         for (LMProfileConfig lmConfig : lmPreparationHandler.getLMProfileConfigs()) {\n             ProfileConfig profile = profilesByName.get(lmConfig.getProfile());\n-            FlagEncoder encoder = encodingManager.getEncoder(profile.getVehicle());\n-            // note that we do not consider turn costs during LM preparation?\n-            Weighting weighting = createWeighting(new HintsMap(profile.getWeighting()), encoder, NO_TURN_COST_PROVIDER);\n+            // note that we do not consider turn costs during LM preparation. this is important if we want\n+            // to allow e.g. changing the u_turn_costs per request (we have to use the minimum weight settings (\n+            // = no turn costs) for the preparation)\n+            // todonow: is it too ugly this way?\n+            Weighting weighting = createWeighting(profile, new PMap().put(\"__disable_turn_costs\", true));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDE2MzA5MA=="}, "originalCommit": {"oid": "8a9f090b2fb8e05691043fa428077a046251557e"}, "originalPosition": 140}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDI1MTU2OA==", "bodyText": "What do you mean? You mean we should always set turn_costs: false for all profiles with LM? But then we cannot use turn costs with LM...", "url": "https://github.com/graphhopper/graphhopper/pull/1949#discussion_r390251568", "createdAt": "2020-03-10T11:32:04Z", "author": {"login": "easbar"}, "path": "core/src/main/java/com/graphhopper/GraphHopper.java", "diffHunk": "@@ -913,9 +922,11 @@ private void initLMPreparationHandler() {\n \n         for (LMProfileConfig lmConfig : lmPreparationHandler.getLMProfileConfigs()) {\n             ProfileConfig profile = profilesByName.get(lmConfig.getProfile());\n-            FlagEncoder encoder = encodingManager.getEncoder(profile.getVehicle());\n-            // note that we do not consider turn costs during LM preparation?\n-            Weighting weighting = createWeighting(new HintsMap(profile.getWeighting()), encoder, NO_TURN_COST_PROVIDER);\n+            // note that we do not consider turn costs during LM preparation. this is important if we want\n+            // to allow e.g. changing the u_turn_costs per request (we have to use the minimum weight settings (\n+            // = no turn costs) for the preparation)\n+            // todonow: is it too ugly this way?\n+            Weighting weighting = createWeighting(profile, new PMap().put(\"__disable_turn_costs\", true));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDE2MzA5MA=="}, "originalCommit": {"oid": "8a9f090b2fb8e05691043fa428077a046251557e"}, "originalPosition": 140}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDI1MjIwMg==", "bodyText": "Ah you mean somehow disabling the turn costs in PrepareLandmarks? Yes that would be the right thing to do, but how? PrepareLandmarks just gets a Weighting, but how would it disable the turn costs then?", "url": "https://github.com/graphhopper/graphhopper/pull/1949#discussion_r390252202", "createdAt": "2020-03-10T11:33:22Z", "author": {"login": "easbar"}, "path": "core/src/main/java/com/graphhopper/GraphHopper.java", "diffHunk": "@@ -913,9 +922,11 @@ private void initLMPreparationHandler() {\n \n         for (LMProfileConfig lmConfig : lmPreparationHandler.getLMProfileConfigs()) {\n             ProfileConfig profile = profilesByName.get(lmConfig.getProfile());\n-            FlagEncoder encoder = encodingManager.getEncoder(profile.getVehicle());\n-            // note that we do not consider turn costs during LM preparation?\n-            Weighting weighting = createWeighting(new HintsMap(profile.getWeighting()), encoder, NO_TURN_COST_PROVIDER);\n+            // note that we do not consider turn costs during LM preparation. this is important if we want\n+            // to allow e.g. changing the u_turn_costs per request (we have to use the minimum weight settings (\n+            // = no turn costs) for the preparation)\n+            // todonow: is it too ugly this way?\n+            Weighting weighting = createWeighting(profile, new PMap().put(\"__disable_turn_costs\", true));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDE2MzA5MA=="}, "originalCommit": {"oid": "8a9f090b2fb8e05691043fa428077a046251557e"}, "originalPosition": 140}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDI1NTEwOQ==", "bodyText": "Ah you mean somehow disabling the turn costs in PrepareLandmarks?\n\nYes. Isn't it already ignored when we do traversalMode = TraversalMode.NODE_BASED in LandmarkStorage?", "url": "https://github.com/graphhopper/graphhopper/pull/1949#discussion_r390255109", "createdAt": "2020-03-10T11:39:32Z", "author": {"login": "karussell"}, "path": "core/src/main/java/com/graphhopper/GraphHopper.java", "diffHunk": "@@ -913,9 +922,11 @@ private void initLMPreparationHandler() {\n \n         for (LMProfileConfig lmConfig : lmPreparationHandler.getLMProfileConfigs()) {\n             ProfileConfig profile = profilesByName.get(lmConfig.getProfile());\n-            FlagEncoder encoder = encodingManager.getEncoder(profile.getVehicle());\n-            // note that we do not consider turn costs during LM preparation?\n-            Weighting weighting = createWeighting(new HintsMap(profile.getWeighting()), encoder, NO_TURN_COST_PROVIDER);\n+            // note that we do not consider turn costs during LM preparation. this is important if we want\n+            // to allow e.g. changing the u_turn_costs per request (we have to use the minimum weight settings (\n+            // = no turn costs) for the preparation)\n+            // todonow: is it too ugly this way?\n+            Weighting weighting = createWeighting(profile, new PMap().put(\"__disable_turn_costs\", true));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDE2MzA5MA=="}, "originalCommit": {"oid": "8a9f090b2fb8e05691043fa428077a046251557e"}, "originalPosition": 140}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDI1NzA0Nw==", "bodyText": "Ah yes thats a good point. Yes that should fix it \ud83d\udc4d -> done", "url": "https://github.com/graphhopper/graphhopper/pull/1949#discussion_r390257047", "createdAt": "2020-03-10T11:43:39Z", "author": {"login": "easbar"}, "path": "core/src/main/java/com/graphhopper/GraphHopper.java", "diffHunk": "@@ -913,9 +922,11 @@ private void initLMPreparationHandler() {\n \n         for (LMProfileConfig lmConfig : lmPreparationHandler.getLMProfileConfigs()) {\n             ProfileConfig profile = profilesByName.get(lmConfig.getProfile());\n-            FlagEncoder encoder = encodingManager.getEncoder(profile.getVehicle());\n-            // note that we do not consider turn costs during LM preparation?\n-            Weighting weighting = createWeighting(new HintsMap(profile.getWeighting()), encoder, NO_TURN_COST_PROVIDER);\n+            // note that we do not consider turn costs during LM preparation. this is important if we want\n+            // to allow e.g. changing the u_turn_costs per request (we have to use the minimum weight settings (\n+            // = no turn costs) for the preparation)\n+            // todonow: is it too ugly this way?\n+            Weighting weighting = createWeighting(profile, new PMap().put(\"__disable_turn_costs\", true));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDE2MzA5MA=="}, "originalCommit": {"oid": "8a9f090b2fb8e05691043fa428077a046251557e"}, "originalPosition": 140}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQxNzkwMDA0OnYy", "diffSide": "RIGHT", "path": "web-bundle/src/main/java/com/graphhopper/resources/SPTResource.java", "isResolved": false, "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMFQwODo0OTowNlrOF0Fw1A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMVQxNjozMToxOVrOF0-_0g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDE2NDY5Mg==", "bodyText": "Is it fine to overwrite ch/lm.disable here or should we throw an error?", "url": "https://github.com/graphhopper/graphhopper/pull/1949#discussion_r390164692", "createdAt": "2020-03-10T08:49:06Z", "author": {"login": "easbar"}, "path": "web-bundle/src/main/java/com/graphhopper/resources/SPTResource.java", "diffHunk": "@@ -62,11 +60,15 @@ public Response doGet(\n             throw new IllegalArgumentException(\"point parameter cannot be null\");\n \n         StopWatch sw = new StopWatch().start();\n-\n-        if (!encodingManager.hasEncoder(vehicle))\n-            throw new IllegalArgumentException(\"vehicle not supported:\" + vehicle);\n-\n-        FlagEncoder encoder = encodingManager.getEncoder(vehicle);\n+        HintsMap hintsMap = new HintsMap();\n+        RouteResource.initHints(hintsMap, uriInfo.getQueryParameters());\n+        hintsMap.put(Parameters.CH.DISABLE, true);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8a9f090b2fb8e05691043fa428077a046251557e"}, "originalPosition": 36}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDI1MTk2OQ==", "bodyText": "Isn't the none-CH case the default now? But yeah, I think I had to do this for the /custom endpoint too.", "url": "https://github.com/graphhopper/graphhopper/pull/1949#discussion_r390251969", "createdAt": "2020-03-10T11:32:55Z", "author": {"login": "karussell"}, "path": "web-bundle/src/main/java/com/graphhopper/resources/SPTResource.java", "diffHunk": "@@ -62,11 +60,15 @@ public Response doGet(\n             throw new IllegalArgumentException(\"point parameter cannot be null\");\n \n         StopWatch sw = new StopWatch().start();\n-\n-        if (!encodingManager.hasEncoder(vehicle))\n-            throw new IllegalArgumentException(\"vehicle not supported:\" + vehicle);\n-\n-        FlagEncoder encoder = encodingManager.getEncoder(vehicle);\n+        HintsMap hintsMap = new HintsMap();\n+        RouteResource.initHints(hintsMap, uriInfo.getQueryParameters());\n+        hintsMap.put(Parameters.CH.DISABLE, true);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDE2NDY5Mg=="}, "originalCommit": {"oid": "8a9f090b2fb8e05691043fa428077a046251557e"}, "originalPosition": 36}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDI1MzY3MQ==", "bodyText": "Hm, no graphHopper.resolveProfile(hintsMap) will give us a CH profile or error if it does not exist, so we have to explicitly disable CH/LM to obtain the profile no matter whether a CH/LM profile for these hints exists or not.", "url": "https://github.com/graphhopper/graphhopper/pull/1949#discussion_r390253671", "createdAt": "2020-03-10T11:36:27Z", "author": {"login": "easbar"}, "path": "web-bundle/src/main/java/com/graphhopper/resources/SPTResource.java", "diffHunk": "@@ -62,11 +60,15 @@ public Response doGet(\n             throw new IllegalArgumentException(\"point parameter cannot be null\");\n \n         StopWatch sw = new StopWatch().start();\n-\n-        if (!encodingManager.hasEncoder(vehicle))\n-            throw new IllegalArgumentException(\"vehicle not supported:\" + vehicle);\n-\n-        FlagEncoder encoder = encodingManager.getEncoder(vehicle);\n+        HintsMap hintsMap = new HintsMap();\n+        RouteResource.initHints(hintsMap, uriInfo.getQueryParameters());\n+        hintsMap.put(Parameters.CH.DISABLE, true);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDE2NDY5Mg=="}, "originalCommit": {"oid": "8a9f090b2fb8e05691043fa428077a046251557e"}, "originalPosition": 36}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDI3NTAxNQ==", "bodyText": "So, if there is a profile without CH, then this will work without the parameter, but if the profile is listed in profiles_ch then we need the disabling parameter?\nThe problem is, what if we add a new algorithm xy? Then in theory I would expect that the profile selection remains unchanged and we only specify profiles_xy: [car_xy], i.e. an existing profile car will still work without the algorithm xy. Not sure if this is good as it increases the profile count further.", "url": "https://github.com/graphhopper/graphhopper/pull/1949#discussion_r390275015", "createdAt": "2020-03-10T12:21:49Z", "author": {"login": "karussell"}, "path": "web-bundle/src/main/java/com/graphhopper/resources/SPTResource.java", "diffHunk": "@@ -62,11 +60,15 @@ public Response doGet(\n             throw new IllegalArgumentException(\"point parameter cannot be null\");\n \n         StopWatch sw = new StopWatch().start();\n-\n-        if (!encodingManager.hasEncoder(vehicle))\n-            throw new IllegalArgumentException(\"vehicle not supported:\" + vehicle);\n-\n-        FlagEncoder encoder = encodingManager.getEncoder(vehicle);\n+        HintsMap hintsMap = new HintsMap();\n+        RouteResource.initHints(hintsMap, uriInfo.getQueryParameters());\n+        hintsMap.put(Parameters.CH.DISABLE, true);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDE2NDY5Mg=="}, "originalCommit": {"oid": "8a9f090b2fb8e05691043fa428077a046251557e"}, "originalPosition": 36}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDMxNzg2Mw==", "bodyText": "So, if there is a profile without CH, then this will work without the parameter, but if the profile is listed in profiles_ch then we need the disabling parameter?\n\nYes, or to put it differently if we put ch.disable=true as we do here we get the profile matching our hints no matter what LM/CH preparations there are (and for isochrones we are not even using them). But you are right the profile selection depends on the available LM/CH preparations (it always did).\n\nThe problem is, what if we add a new algorithm xy? Then in theory I would expect that the profile selection remains unchanged\n\nBut why? If there is a new algorithm we likely want to use it? If the selection remained unchanged what would the new algorithm be good for? In this sense I think its better not to expose the algorithm selection such that it can always be changed internally. As a user of the API I am generally not interested which algorithm is used to solve my problem. What I think is problematic though, that sometimes it can be hard to figure out which algorithm needs to be used, because for certain parameters only certain algorithms work (for example blocked areas etc.).", "url": "https://github.com/graphhopper/graphhopper/pull/1949#discussion_r390317863", "createdAt": "2020-03-10T13:38:37Z", "author": {"login": "easbar"}, "path": "web-bundle/src/main/java/com/graphhopper/resources/SPTResource.java", "diffHunk": "@@ -62,11 +60,15 @@ public Response doGet(\n             throw new IllegalArgumentException(\"point parameter cannot be null\");\n \n         StopWatch sw = new StopWatch().start();\n-\n-        if (!encodingManager.hasEncoder(vehicle))\n-            throw new IllegalArgumentException(\"vehicle not supported:\" + vehicle);\n-\n-        FlagEncoder encoder = encodingManager.getEncoder(vehicle);\n+        HintsMap hintsMap = new HintsMap();\n+        RouteResource.initHints(hintsMap, uriInfo.getQueryParameters());\n+        hintsMap.put(Parameters.CH.DISABLE, true);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDE2NDY5Mg=="}, "originalCommit": {"oid": "8a9f090b2fb8e05691043fa428077a046251557e"}, "originalPosition": 36}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTEwMjQxOA==", "bodyText": "Ok, regarding the parameter setting and I think I better understand this now: we have to do it here to avoid a failure if LM or CH is configured.", "url": "https://github.com/graphhopper/graphhopper/pull/1949#discussion_r391102418", "createdAt": "2020-03-11T16:31:19Z", "author": {"login": "karussell"}, "path": "web-bundle/src/main/java/com/graphhopper/resources/SPTResource.java", "diffHunk": "@@ -62,11 +60,15 @@ public Response doGet(\n             throw new IllegalArgumentException(\"point parameter cannot be null\");\n \n         StopWatch sw = new StopWatch().start();\n-\n-        if (!encodingManager.hasEncoder(vehicle))\n-            throw new IllegalArgumentException(\"vehicle not supported:\" + vehicle);\n-\n-        FlagEncoder encoder = encodingManager.getEncoder(vehicle);\n+        HintsMap hintsMap = new HintsMap();\n+        RouteResource.initHints(hintsMap, uriInfo.getQueryParameters());\n+        hintsMap.put(Parameters.CH.DISABLE, true);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDE2NDY5Mg=="}, "originalCommit": {"oid": "8a9f090b2fb8e05691043fa428077a046251557e"}, "originalPosition": 36}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQxNzkyMTg3OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/com/graphhopper/routing/ProfileResolver.java", "isResolved": false, "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMFQwODo1NTozMFrOF0F97Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMFQxMzo0NTo1OVrOF0Pbhw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDE2ODA0NQ==", "bodyText": "I do not like how we rely on the turn cost provider name to contain the u-turn costs here, but so far I do not have a better idea to do this. Also this is only needed to cover a (probably exotic) case: Multiple edge-based profiles with different u-turn costs. Once we have the profile request parameter we 'only' need to support this u-turn costs comparison here for legacy reasons, so this makes me even more want to get rid of it.", "url": "https://github.com/graphhopper/graphhopper/pull/1949#discussion_r390168045", "createdAt": "2020-03-10T08:55:30Z", "author": {"login": "easbar"}, "path": "core/src/main/java/com/graphhopper/routing/ProfileResolver.java", "diffHunk": "@@ -0,0 +1,195 @@\n+/*\n+ *  Licensed to GraphHopper GmbH under one or more contributor\n+ *  license agreements. See the NOTICE file distributed with this work for\n+ *  additional information regarding copyright ownership.\n+ *\n+ *  GraphHopper GmbH licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except in\n+ *  compliance with the License. You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+\n+package com.graphhopper.routing;\n+\n+import com.graphhopper.config.ProfileConfig;\n+import com.graphhopper.routing.lm.LMProfile;\n+import com.graphhopper.routing.util.EncodingManager;\n+import com.graphhopper.routing.util.FlagEncoder;\n+import com.graphhopper.routing.util.HintsMap;\n+import com.graphhopper.storage.CHProfile;\n+import com.graphhopper.util.Parameters;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import static com.graphhopper.routing.weighting.Weighting.INFINITE_U_TURN_COSTS;\n+\n+public class ProfileResolver {\n+\n+    public ProfileConfig resolveProfile(EncodingManager encodingManager, List<CHProfile> chProfiles, List<LMProfile> lmProfiles, HintsMap hints) {\n+        // default handling\n+        String vehicle = hints.getVehicle();\n+        if (vehicle.isEmpty()) {\n+            vehicle = getDefaultVehicle(encodingManager).toString();\n+        }\n+        String weighting = hints.getWeighting();\n+        if (weighting.isEmpty()) {\n+            weighting = \"fastest\";\n+        }\n+        if (!encodingManager.hasEncoder(vehicle))\n+            throw new IllegalArgumentException(\"Vehicle not supported: \" + vehicle + \". Supported are: \" + encodingManager.toString());\n+\n+        FlagEncoder encoder = encodingManager.getEncoder(vehicle);\n+        // we use turn costs if the encoder supports it *unless* the edge_based parameter is set explicitly\n+        boolean turnCosts = encoder.supportsTurnCosts();\n+        if (hints.has(Parameters.Routing.EDGE_BASED))\n+            turnCosts = hints.getBool(Parameters.Routing.EDGE_BASED, false);\n+        if (turnCosts && !encoder.supportsTurnCosts())\n+            throw new IllegalArgumentException(\"You need to set up a turn cost storage to make use of edge_based=true, e.g. use car|turn_costs=true\");\n+\n+        String profileName = resolveProfileName(chProfiles, lmProfiles, hints);\n+\n+        return new ProfileConfig(profileName)\n+                .setVehicle(vehicle)\n+                .setWeighting(weighting)\n+                .setTurnCosts(turnCosts);\n+    }\n+\n+    private String resolveProfileName(List<CHProfile> chProfiles, List<LMProfile> lmProfiles, HintsMap hints) {\n+        boolean disableCH = hints.getBool(Parameters.CH.DISABLE, false);\n+        boolean disableLM = hints.getBool(Parameters.Landmark.DISABLE, false);\n+\n+        String profileName;\n+        if (!chProfiles.isEmpty() && !disableCH) {\n+            profileName = selectCHProfile(chProfiles, hints).getName();\n+        } else if (!lmProfiles.isEmpty() && !disableLM) {\n+            profileName = selectLMProfile(lmProfiles, hints).getName();\n+        } else {\n+            // todonow: here we will instead select one of the existing profiles\n+            profileName = \"unprepared_profile\";\n+        }\n+        return profileName;\n+    }\n+\n+    /**\n+     * @param chProfiles the CH profiles to choose from\n+     * @param hintsMap   a map used to describe the CH profile that shall be selected\n+     * @throws IllegalArgumentException if no CH profile could be selected for the given parameters\n+     */\n+    public CHProfile selectCHProfile(List<CHProfile> chProfiles, HintsMap hintsMap) {\n+        List<CHProfile> matchingProfiles = new ArrayList<>();\n+        for (CHProfile p : chProfiles) {\n+            if (!chProfileMatchesHints(p, hintsMap))\n+                continue;\n+            matchingProfiles.add(p);\n+        }\n+\n+        Boolean edgeBased = getEdgeBased(hintsMap);\n+        Integer uTurnCosts = getUTurnCosts(hintsMap);\n+        if (matchingProfiles.isEmpty()) {\n+            throw new IllegalArgumentException(\"Cannot find matching CH profile for your request. Please check your parameters.\" +\n+                    \"\\nYou can try disabling CH using \" + Parameters.CH.DISABLE + \"=true\" +\n+                    \"\\nrequested:  \" + getCHRequestAsString(hintsMap, edgeBased, uTurnCosts) + \"\\navailable: \" + chProfiles);\n+        } else if (matchingProfiles.size() == 1) {\n+            return matchingProfiles.get(0);\n+        } else {\n+            // special case: prefer edge-based over node-based if these are the only two options\n+            CHProfile match1 = matchingProfiles.get(0);\n+            CHProfile match2 = matchingProfiles.get(1);\n+            if (edgeBased == null && matchingProfiles.size() == 2 &&\n+                    match1.getWeighting().getName().equals(match2.getWeighting().getName()) &&\n+                    match1.getWeighting().getFlagEncoder().toString().equals(match2.getWeighting().getFlagEncoder().toString()) &&\n+                    match1.isEdgeBased() != match2.isEdgeBased()) {\n+                return match1.isEdgeBased() ? match1 : match2;\n+            }\n+            throw new IllegalArgumentException(\"There are multiple CH profiles matching your request. Use the `weighting`,`vehicle`,`edge_based` and/or `u_turn_costs` parameters to be more specific.\" +\n+                    \"\\nYou can also try disabling CH altogether using \" + Parameters.CH.DISABLE + \"=true\" +\n+                    \"\\nrequested:  \" + getCHRequestAsString(hintsMap, edgeBased, uTurnCosts) + \"\\nmatched:   \" + matchingProfiles + \"\\navailable: \" + chProfiles);\n+        }\n+    }\n+\n+    public LMProfile selectLMProfile(List<LMProfile> lmProfiles, HintsMap hintsMap) {\n+        List<LMProfile> matchingProfiles = new ArrayList<>();\n+        for (LMProfile p : lmProfiles) {\n+            if (!lmProfileMatchesHints(p, hintsMap))\n+                continue;\n+            matchingProfiles.add(p);\n+        }\n+        // Note:\n+        // There are situations where we can use the requested encoder/weighting with an existing LM preparation, even\n+        // though the preparation was done with a different weighting. For example this works when the new weighting\n+        // only yields higher (but never lower) weights than the one that was used for the preparation. However, its not\n+        // trivial to check whether or not this is the case so we do not allow this for now.\n+        if (matchingProfiles.isEmpty()) {\n+            throw new IllegalArgumentException(\"Cannot find matching LM profile for your request. Please check your parameters.\" +\n+                    \"\\nYou can try disabling LM by setting \" + Parameters.Landmark.DISABLE + \"=true\" +\n+                    \"\\nrequested: \" + getLMRequestAsString(hintsMap) + \"\\navailable: \" + lmProfilesAsStrings(lmProfiles));\n+        } else if (matchingProfiles.size() == 1) {\n+            return matchingProfiles.get(0);\n+        } else {\n+            throw new IllegalArgumentException(\"There are multiple LM profiles matching your request. Use the `weighting` and `vehicle` parameters to be more specific.\" +\n+                    \"\\nYou can also try disabling LM altogether using \" + Parameters.CH.DISABLE + \"=true\" +\n+                    \"\\nrequested:  \" + getLMRequestAsString(hintsMap) + \"\\nmatched:   \" + lmProfilesAsStrings(matchingProfiles) + \"\\navailable: \" + lmProfilesAsStrings(lmProfiles));\n+        }\n+    }\n+\n+    protected boolean chProfileMatchesHints(CHProfile p, HintsMap hintsMap) {\n+        Boolean edgeBased = getEdgeBased(hintsMap);\n+        Integer uTurnCosts = getUTurnCosts(hintsMap);\n+        return (edgeBased == null || p.isEdgeBased() == edgeBased) &&\n+                (uTurnCosts == null || p.getWeighting().getTurnCostProvider().getName().equals(uTurnCosts.toString())) &&", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8a9f090b2fb8e05691043fa428077a046251557e"}, "originalPosition": 147}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDI1MzAxMA==", "bodyText": "Yes, probably we have to accept that ProfileResolver is mainly for backward compatibility? The bigger problem is the new getTurnCostProvider method, which I would prefer to be private. But I also do not see how.", "url": "https://github.com/graphhopper/graphhopper/pull/1949#discussion_r390253010", "createdAt": "2020-03-10T11:35:08Z", "author": {"login": "karussell"}, "path": "core/src/main/java/com/graphhopper/routing/ProfileResolver.java", "diffHunk": "@@ -0,0 +1,195 @@\n+/*\n+ *  Licensed to GraphHopper GmbH under one or more contributor\n+ *  license agreements. See the NOTICE file distributed with this work for\n+ *  additional information regarding copyright ownership.\n+ *\n+ *  GraphHopper GmbH licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except in\n+ *  compliance with the License. You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+\n+package com.graphhopper.routing;\n+\n+import com.graphhopper.config.ProfileConfig;\n+import com.graphhopper.routing.lm.LMProfile;\n+import com.graphhopper.routing.util.EncodingManager;\n+import com.graphhopper.routing.util.FlagEncoder;\n+import com.graphhopper.routing.util.HintsMap;\n+import com.graphhopper.storage.CHProfile;\n+import com.graphhopper.util.Parameters;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import static com.graphhopper.routing.weighting.Weighting.INFINITE_U_TURN_COSTS;\n+\n+public class ProfileResolver {\n+\n+    public ProfileConfig resolveProfile(EncodingManager encodingManager, List<CHProfile> chProfiles, List<LMProfile> lmProfiles, HintsMap hints) {\n+        // default handling\n+        String vehicle = hints.getVehicle();\n+        if (vehicle.isEmpty()) {\n+            vehicle = getDefaultVehicle(encodingManager).toString();\n+        }\n+        String weighting = hints.getWeighting();\n+        if (weighting.isEmpty()) {\n+            weighting = \"fastest\";\n+        }\n+        if (!encodingManager.hasEncoder(vehicle))\n+            throw new IllegalArgumentException(\"Vehicle not supported: \" + vehicle + \". Supported are: \" + encodingManager.toString());\n+\n+        FlagEncoder encoder = encodingManager.getEncoder(vehicle);\n+        // we use turn costs if the encoder supports it *unless* the edge_based parameter is set explicitly\n+        boolean turnCosts = encoder.supportsTurnCosts();\n+        if (hints.has(Parameters.Routing.EDGE_BASED))\n+            turnCosts = hints.getBool(Parameters.Routing.EDGE_BASED, false);\n+        if (turnCosts && !encoder.supportsTurnCosts())\n+            throw new IllegalArgumentException(\"You need to set up a turn cost storage to make use of edge_based=true, e.g. use car|turn_costs=true\");\n+\n+        String profileName = resolveProfileName(chProfiles, lmProfiles, hints);\n+\n+        return new ProfileConfig(profileName)\n+                .setVehicle(vehicle)\n+                .setWeighting(weighting)\n+                .setTurnCosts(turnCosts);\n+    }\n+\n+    private String resolveProfileName(List<CHProfile> chProfiles, List<LMProfile> lmProfiles, HintsMap hints) {\n+        boolean disableCH = hints.getBool(Parameters.CH.DISABLE, false);\n+        boolean disableLM = hints.getBool(Parameters.Landmark.DISABLE, false);\n+\n+        String profileName;\n+        if (!chProfiles.isEmpty() && !disableCH) {\n+            profileName = selectCHProfile(chProfiles, hints).getName();\n+        } else if (!lmProfiles.isEmpty() && !disableLM) {\n+            profileName = selectLMProfile(lmProfiles, hints).getName();\n+        } else {\n+            // todonow: here we will instead select one of the existing profiles\n+            profileName = \"unprepared_profile\";\n+        }\n+        return profileName;\n+    }\n+\n+    /**\n+     * @param chProfiles the CH profiles to choose from\n+     * @param hintsMap   a map used to describe the CH profile that shall be selected\n+     * @throws IllegalArgumentException if no CH profile could be selected for the given parameters\n+     */\n+    public CHProfile selectCHProfile(List<CHProfile> chProfiles, HintsMap hintsMap) {\n+        List<CHProfile> matchingProfiles = new ArrayList<>();\n+        for (CHProfile p : chProfiles) {\n+            if (!chProfileMatchesHints(p, hintsMap))\n+                continue;\n+            matchingProfiles.add(p);\n+        }\n+\n+        Boolean edgeBased = getEdgeBased(hintsMap);\n+        Integer uTurnCosts = getUTurnCosts(hintsMap);\n+        if (matchingProfiles.isEmpty()) {\n+            throw new IllegalArgumentException(\"Cannot find matching CH profile for your request. Please check your parameters.\" +\n+                    \"\\nYou can try disabling CH using \" + Parameters.CH.DISABLE + \"=true\" +\n+                    \"\\nrequested:  \" + getCHRequestAsString(hintsMap, edgeBased, uTurnCosts) + \"\\navailable: \" + chProfiles);\n+        } else if (matchingProfiles.size() == 1) {\n+            return matchingProfiles.get(0);\n+        } else {\n+            // special case: prefer edge-based over node-based if these are the only two options\n+            CHProfile match1 = matchingProfiles.get(0);\n+            CHProfile match2 = matchingProfiles.get(1);\n+            if (edgeBased == null && matchingProfiles.size() == 2 &&\n+                    match1.getWeighting().getName().equals(match2.getWeighting().getName()) &&\n+                    match1.getWeighting().getFlagEncoder().toString().equals(match2.getWeighting().getFlagEncoder().toString()) &&\n+                    match1.isEdgeBased() != match2.isEdgeBased()) {\n+                return match1.isEdgeBased() ? match1 : match2;\n+            }\n+            throw new IllegalArgumentException(\"There are multiple CH profiles matching your request. Use the `weighting`,`vehicle`,`edge_based` and/or `u_turn_costs` parameters to be more specific.\" +\n+                    \"\\nYou can also try disabling CH altogether using \" + Parameters.CH.DISABLE + \"=true\" +\n+                    \"\\nrequested:  \" + getCHRequestAsString(hintsMap, edgeBased, uTurnCosts) + \"\\nmatched:   \" + matchingProfiles + \"\\navailable: \" + chProfiles);\n+        }\n+    }\n+\n+    public LMProfile selectLMProfile(List<LMProfile> lmProfiles, HintsMap hintsMap) {\n+        List<LMProfile> matchingProfiles = new ArrayList<>();\n+        for (LMProfile p : lmProfiles) {\n+            if (!lmProfileMatchesHints(p, hintsMap))\n+                continue;\n+            matchingProfiles.add(p);\n+        }\n+        // Note:\n+        // There are situations where we can use the requested encoder/weighting with an existing LM preparation, even\n+        // though the preparation was done with a different weighting. For example this works when the new weighting\n+        // only yields higher (but never lower) weights than the one that was used for the preparation. However, its not\n+        // trivial to check whether or not this is the case so we do not allow this for now.\n+        if (matchingProfiles.isEmpty()) {\n+            throw new IllegalArgumentException(\"Cannot find matching LM profile for your request. Please check your parameters.\" +\n+                    \"\\nYou can try disabling LM by setting \" + Parameters.Landmark.DISABLE + \"=true\" +\n+                    \"\\nrequested: \" + getLMRequestAsString(hintsMap) + \"\\navailable: \" + lmProfilesAsStrings(lmProfiles));\n+        } else if (matchingProfiles.size() == 1) {\n+            return matchingProfiles.get(0);\n+        } else {\n+            throw new IllegalArgumentException(\"There are multiple LM profiles matching your request. Use the `weighting` and `vehicle` parameters to be more specific.\" +\n+                    \"\\nYou can also try disabling LM altogether using \" + Parameters.CH.DISABLE + \"=true\" +\n+                    \"\\nrequested:  \" + getLMRequestAsString(hintsMap) + \"\\nmatched:   \" + lmProfilesAsStrings(matchingProfiles) + \"\\navailable: \" + lmProfilesAsStrings(lmProfiles));\n+        }\n+    }\n+\n+    protected boolean chProfileMatchesHints(CHProfile p, HintsMap hintsMap) {\n+        Boolean edgeBased = getEdgeBased(hintsMap);\n+        Integer uTurnCosts = getUTurnCosts(hintsMap);\n+        return (edgeBased == null || p.isEdgeBased() == edgeBased) &&\n+                (uTurnCosts == null || p.getWeighting().getTurnCostProvider().getName().equals(uTurnCosts.toString())) &&", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDE2ODA0NQ=="}, "originalCommit": {"oid": "8a9f090b2fb8e05691043fa428077a046251557e"}, "originalPosition": 147}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDI1NDkwOA==", "bodyText": "Yes, I would like to remove/not add getTurnCostProvider as well. But how else can we check what u-turn costs a weighting is using? Maybe we can skip this selection rule and throw an error if there are multiple edge-based weightings for the given weighting and vehicle. In this case one would have to use the profile parameter when using multiple edge-based CH preparations with different u-turn costs.", "url": "https://github.com/graphhopper/graphhopper/pull/1949#discussion_r390254908", "createdAt": "2020-03-10T11:39:07Z", "author": {"login": "easbar"}, "path": "core/src/main/java/com/graphhopper/routing/ProfileResolver.java", "diffHunk": "@@ -0,0 +1,195 @@\n+/*\n+ *  Licensed to GraphHopper GmbH under one or more contributor\n+ *  license agreements. See the NOTICE file distributed with this work for\n+ *  additional information regarding copyright ownership.\n+ *\n+ *  GraphHopper GmbH licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except in\n+ *  compliance with the License. You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+\n+package com.graphhopper.routing;\n+\n+import com.graphhopper.config.ProfileConfig;\n+import com.graphhopper.routing.lm.LMProfile;\n+import com.graphhopper.routing.util.EncodingManager;\n+import com.graphhopper.routing.util.FlagEncoder;\n+import com.graphhopper.routing.util.HintsMap;\n+import com.graphhopper.storage.CHProfile;\n+import com.graphhopper.util.Parameters;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import static com.graphhopper.routing.weighting.Weighting.INFINITE_U_TURN_COSTS;\n+\n+public class ProfileResolver {\n+\n+    public ProfileConfig resolveProfile(EncodingManager encodingManager, List<CHProfile> chProfiles, List<LMProfile> lmProfiles, HintsMap hints) {\n+        // default handling\n+        String vehicle = hints.getVehicle();\n+        if (vehicle.isEmpty()) {\n+            vehicle = getDefaultVehicle(encodingManager).toString();\n+        }\n+        String weighting = hints.getWeighting();\n+        if (weighting.isEmpty()) {\n+            weighting = \"fastest\";\n+        }\n+        if (!encodingManager.hasEncoder(vehicle))\n+            throw new IllegalArgumentException(\"Vehicle not supported: \" + vehicle + \". Supported are: \" + encodingManager.toString());\n+\n+        FlagEncoder encoder = encodingManager.getEncoder(vehicle);\n+        // we use turn costs if the encoder supports it *unless* the edge_based parameter is set explicitly\n+        boolean turnCosts = encoder.supportsTurnCosts();\n+        if (hints.has(Parameters.Routing.EDGE_BASED))\n+            turnCosts = hints.getBool(Parameters.Routing.EDGE_BASED, false);\n+        if (turnCosts && !encoder.supportsTurnCosts())\n+            throw new IllegalArgumentException(\"You need to set up a turn cost storage to make use of edge_based=true, e.g. use car|turn_costs=true\");\n+\n+        String profileName = resolveProfileName(chProfiles, lmProfiles, hints);\n+\n+        return new ProfileConfig(profileName)\n+                .setVehicle(vehicle)\n+                .setWeighting(weighting)\n+                .setTurnCosts(turnCosts);\n+    }\n+\n+    private String resolveProfileName(List<CHProfile> chProfiles, List<LMProfile> lmProfiles, HintsMap hints) {\n+        boolean disableCH = hints.getBool(Parameters.CH.DISABLE, false);\n+        boolean disableLM = hints.getBool(Parameters.Landmark.DISABLE, false);\n+\n+        String profileName;\n+        if (!chProfiles.isEmpty() && !disableCH) {\n+            profileName = selectCHProfile(chProfiles, hints).getName();\n+        } else if (!lmProfiles.isEmpty() && !disableLM) {\n+            profileName = selectLMProfile(lmProfiles, hints).getName();\n+        } else {\n+            // todonow: here we will instead select one of the existing profiles\n+            profileName = \"unprepared_profile\";\n+        }\n+        return profileName;\n+    }\n+\n+    /**\n+     * @param chProfiles the CH profiles to choose from\n+     * @param hintsMap   a map used to describe the CH profile that shall be selected\n+     * @throws IllegalArgumentException if no CH profile could be selected for the given parameters\n+     */\n+    public CHProfile selectCHProfile(List<CHProfile> chProfiles, HintsMap hintsMap) {\n+        List<CHProfile> matchingProfiles = new ArrayList<>();\n+        for (CHProfile p : chProfiles) {\n+            if (!chProfileMatchesHints(p, hintsMap))\n+                continue;\n+            matchingProfiles.add(p);\n+        }\n+\n+        Boolean edgeBased = getEdgeBased(hintsMap);\n+        Integer uTurnCosts = getUTurnCosts(hintsMap);\n+        if (matchingProfiles.isEmpty()) {\n+            throw new IllegalArgumentException(\"Cannot find matching CH profile for your request. Please check your parameters.\" +\n+                    \"\\nYou can try disabling CH using \" + Parameters.CH.DISABLE + \"=true\" +\n+                    \"\\nrequested:  \" + getCHRequestAsString(hintsMap, edgeBased, uTurnCosts) + \"\\navailable: \" + chProfiles);\n+        } else if (matchingProfiles.size() == 1) {\n+            return matchingProfiles.get(0);\n+        } else {\n+            // special case: prefer edge-based over node-based if these are the only two options\n+            CHProfile match1 = matchingProfiles.get(0);\n+            CHProfile match2 = matchingProfiles.get(1);\n+            if (edgeBased == null && matchingProfiles.size() == 2 &&\n+                    match1.getWeighting().getName().equals(match2.getWeighting().getName()) &&\n+                    match1.getWeighting().getFlagEncoder().toString().equals(match2.getWeighting().getFlagEncoder().toString()) &&\n+                    match1.isEdgeBased() != match2.isEdgeBased()) {\n+                return match1.isEdgeBased() ? match1 : match2;\n+            }\n+            throw new IllegalArgumentException(\"There are multiple CH profiles matching your request. Use the `weighting`,`vehicle`,`edge_based` and/or `u_turn_costs` parameters to be more specific.\" +\n+                    \"\\nYou can also try disabling CH altogether using \" + Parameters.CH.DISABLE + \"=true\" +\n+                    \"\\nrequested:  \" + getCHRequestAsString(hintsMap, edgeBased, uTurnCosts) + \"\\nmatched:   \" + matchingProfiles + \"\\navailable: \" + chProfiles);\n+        }\n+    }\n+\n+    public LMProfile selectLMProfile(List<LMProfile> lmProfiles, HintsMap hintsMap) {\n+        List<LMProfile> matchingProfiles = new ArrayList<>();\n+        for (LMProfile p : lmProfiles) {\n+            if (!lmProfileMatchesHints(p, hintsMap))\n+                continue;\n+            matchingProfiles.add(p);\n+        }\n+        // Note:\n+        // There are situations where we can use the requested encoder/weighting with an existing LM preparation, even\n+        // though the preparation was done with a different weighting. For example this works when the new weighting\n+        // only yields higher (but never lower) weights than the one that was used for the preparation. However, its not\n+        // trivial to check whether or not this is the case so we do not allow this for now.\n+        if (matchingProfiles.isEmpty()) {\n+            throw new IllegalArgumentException(\"Cannot find matching LM profile for your request. Please check your parameters.\" +\n+                    \"\\nYou can try disabling LM by setting \" + Parameters.Landmark.DISABLE + \"=true\" +\n+                    \"\\nrequested: \" + getLMRequestAsString(hintsMap) + \"\\navailable: \" + lmProfilesAsStrings(lmProfiles));\n+        } else if (matchingProfiles.size() == 1) {\n+            return matchingProfiles.get(0);\n+        } else {\n+            throw new IllegalArgumentException(\"There are multiple LM profiles matching your request. Use the `weighting` and `vehicle` parameters to be more specific.\" +\n+                    \"\\nYou can also try disabling LM altogether using \" + Parameters.CH.DISABLE + \"=true\" +\n+                    \"\\nrequested:  \" + getLMRequestAsString(hintsMap) + \"\\nmatched:   \" + lmProfilesAsStrings(matchingProfiles) + \"\\navailable: \" + lmProfilesAsStrings(lmProfiles));\n+        }\n+    }\n+\n+    protected boolean chProfileMatchesHints(CHProfile p, HintsMap hintsMap) {\n+        Boolean edgeBased = getEdgeBased(hintsMap);\n+        Integer uTurnCosts = getUTurnCosts(hintsMap);\n+        return (edgeBased == null || p.isEdgeBased() == edgeBased) &&\n+                (uTurnCosts == null || p.getWeighting().getTurnCostProvider().getName().equals(uTurnCosts.toString())) &&", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDE2ODA0NQ=="}, "originalCommit": {"oid": "8a9f090b2fb8e05691043fa428077a046251557e"}, "originalPosition": 147}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDI1NTMwOQ==", "bodyText": "Yes, probably we have to accept that ProfileResolver is mainly for backward compatibility?\n\nYes absolutely, maybe not yet in this PR but ProfileResolver only exists for backward-compatibility.", "url": "https://github.com/graphhopper/graphhopper/pull/1949#discussion_r390255309", "createdAt": "2020-03-10T11:39:57Z", "author": {"login": "easbar"}, "path": "core/src/main/java/com/graphhopper/routing/ProfileResolver.java", "diffHunk": "@@ -0,0 +1,195 @@\n+/*\n+ *  Licensed to GraphHopper GmbH under one or more contributor\n+ *  license agreements. See the NOTICE file distributed with this work for\n+ *  additional information regarding copyright ownership.\n+ *\n+ *  GraphHopper GmbH licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except in\n+ *  compliance with the License. You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+\n+package com.graphhopper.routing;\n+\n+import com.graphhopper.config.ProfileConfig;\n+import com.graphhopper.routing.lm.LMProfile;\n+import com.graphhopper.routing.util.EncodingManager;\n+import com.graphhopper.routing.util.FlagEncoder;\n+import com.graphhopper.routing.util.HintsMap;\n+import com.graphhopper.storage.CHProfile;\n+import com.graphhopper.util.Parameters;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import static com.graphhopper.routing.weighting.Weighting.INFINITE_U_TURN_COSTS;\n+\n+public class ProfileResolver {\n+\n+    public ProfileConfig resolveProfile(EncodingManager encodingManager, List<CHProfile> chProfiles, List<LMProfile> lmProfiles, HintsMap hints) {\n+        // default handling\n+        String vehicle = hints.getVehicle();\n+        if (vehicle.isEmpty()) {\n+            vehicle = getDefaultVehicle(encodingManager).toString();\n+        }\n+        String weighting = hints.getWeighting();\n+        if (weighting.isEmpty()) {\n+            weighting = \"fastest\";\n+        }\n+        if (!encodingManager.hasEncoder(vehicle))\n+            throw new IllegalArgumentException(\"Vehicle not supported: \" + vehicle + \". Supported are: \" + encodingManager.toString());\n+\n+        FlagEncoder encoder = encodingManager.getEncoder(vehicle);\n+        // we use turn costs if the encoder supports it *unless* the edge_based parameter is set explicitly\n+        boolean turnCosts = encoder.supportsTurnCosts();\n+        if (hints.has(Parameters.Routing.EDGE_BASED))\n+            turnCosts = hints.getBool(Parameters.Routing.EDGE_BASED, false);\n+        if (turnCosts && !encoder.supportsTurnCosts())\n+            throw new IllegalArgumentException(\"You need to set up a turn cost storage to make use of edge_based=true, e.g. use car|turn_costs=true\");\n+\n+        String profileName = resolveProfileName(chProfiles, lmProfiles, hints);\n+\n+        return new ProfileConfig(profileName)\n+                .setVehicle(vehicle)\n+                .setWeighting(weighting)\n+                .setTurnCosts(turnCosts);\n+    }\n+\n+    private String resolveProfileName(List<CHProfile> chProfiles, List<LMProfile> lmProfiles, HintsMap hints) {\n+        boolean disableCH = hints.getBool(Parameters.CH.DISABLE, false);\n+        boolean disableLM = hints.getBool(Parameters.Landmark.DISABLE, false);\n+\n+        String profileName;\n+        if (!chProfiles.isEmpty() && !disableCH) {\n+            profileName = selectCHProfile(chProfiles, hints).getName();\n+        } else if (!lmProfiles.isEmpty() && !disableLM) {\n+            profileName = selectLMProfile(lmProfiles, hints).getName();\n+        } else {\n+            // todonow: here we will instead select one of the existing profiles\n+            profileName = \"unprepared_profile\";\n+        }\n+        return profileName;\n+    }\n+\n+    /**\n+     * @param chProfiles the CH profiles to choose from\n+     * @param hintsMap   a map used to describe the CH profile that shall be selected\n+     * @throws IllegalArgumentException if no CH profile could be selected for the given parameters\n+     */\n+    public CHProfile selectCHProfile(List<CHProfile> chProfiles, HintsMap hintsMap) {\n+        List<CHProfile> matchingProfiles = new ArrayList<>();\n+        for (CHProfile p : chProfiles) {\n+            if (!chProfileMatchesHints(p, hintsMap))\n+                continue;\n+            matchingProfiles.add(p);\n+        }\n+\n+        Boolean edgeBased = getEdgeBased(hintsMap);\n+        Integer uTurnCosts = getUTurnCosts(hintsMap);\n+        if (matchingProfiles.isEmpty()) {\n+            throw new IllegalArgumentException(\"Cannot find matching CH profile for your request. Please check your parameters.\" +\n+                    \"\\nYou can try disabling CH using \" + Parameters.CH.DISABLE + \"=true\" +\n+                    \"\\nrequested:  \" + getCHRequestAsString(hintsMap, edgeBased, uTurnCosts) + \"\\navailable: \" + chProfiles);\n+        } else if (matchingProfiles.size() == 1) {\n+            return matchingProfiles.get(0);\n+        } else {\n+            // special case: prefer edge-based over node-based if these are the only two options\n+            CHProfile match1 = matchingProfiles.get(0);\n+            CHProfile match2 = matchingProfiles.get(1);\n+            if (edgeBased == null && matchingProfiles.size() == 2 &&\n+                    match1.getWeighting().getName().equals(match2.getWeighting().getName()) &&\n+                    match1.getWeighting().getFlagEncoder().toString().equals(match2.getWeighting().getFlagEncoder().toString()) &&\n+                    match1.isEdgeBased() != match2.isEdgeBased()) {\n+                return match1.isEdgeBased() ? match1 : match2;\n+            }\n+            throw new IllegalArgumentException(\"There are multiple CH profiles matching your request. Use the `weighting`,`vehicle`,`edge_based` and/or `u_turn_costs` parameters to be more specific.\" +\n+                    \"\\nYou can also try disabling CH altogether using \" + Parameters.CH.DISABLE + \"=true\" +\n+                    \"\\nrequested:  \" + getCHRequestAsString(hintsMap, edgeBased, uTurnCosts) + \"\\nmatched:   \" + matchingProfiles + \"\\navailable: \" + chProfiles);\n+        }\n+    }\n+\n+    public LMProfile selectLMProfile(List<LMProfile> lmProfiles, HintsMap hintsMap) {\n+        List<LMProfile> matchingProfiles = new ArrayList<>();\n+        for (LMProfile p : lmProfiles) {\n+            if (!lmProfileMatchesHints(p, hintsMap))\n+                continue;\n+            matchingProfiles.add(p);\n+        }\n+        // Note:\n+        // There are situations where we can use the requested encoder/weighting with an existing LM preparation, even\n+        // though the preparation was done with a different weighting. For example this works when the new weighting\n+        // only yields higher (but never lower) weights than the one that was used for the preparation. However, its not\n+        // trivial to check whether or not this is the case so we do not allow this for now.\n+        if (matchingProfiles.isEmpty()) {\n+            throw new IllegalArgumentException(\"Cannot find matching LM profile for your request. Please check your parameters.\" +\n+                    \"\\nYou can try disabling LM by setting \" + Parameters.Landmark.DISABLE + \"=true\" +\n+                    \"\\nrequested: \" + getLMRequestAsString(hintsMap) + \"\\navailable: \" + lmProfilesAsStrings(lmProfiles));\n+        } else if (matchingProfiles.size() == 1) {\n+            return matchingProfiles.get(0);\n+        } else {\n+            throw new IllegalArgumentException(\"There are multiple LM profiles matching your request. Use the `weighting` and `vehicle` parameters to be more specific.\" +\n+                    \"\\nYou can also try disabling LM altogether using \" + Parameters.CH.DISABLE + \"=true\" +\n+                    \"\\nrequested:  \" + getLMRequestAsString(hintsMap) + \"\\nmatched:   \" + lmProfilesAsStrings(matchingProfiles) + \"\\navailable: \" + lmProfilesAsStrings(lmProfiles));\n+        }\n+    }\n+\n+    protected boolean chProfileMatchesHints(CHProfile p, HintsMap hintsMap) {\n+        Boolean edgeBased = getEdgeBased(hintsMap);\n+        Integer uTurnCosts = getUTurnCosts(hintsMap);\n+        return (edgeBased == null || p.isEdgeBased() == edgeBased) &&\n+                (uTurnCosts == null || p.getWeighting().getTurnCostProvider().getName().equals(uTurnCosts.toString())) &&", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDE2ODA0NQ=="}, "originalCommit": {"oid": "8a9f090b2fb8e05691043fa428077a046251557e"}, "originalPosition": 147}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDI1Njk2Mw==", "bodyText": "In this case one would have to use the profile parameter when using multiple edge-based CH preparations with different u-turn costs.\n\nThis sounds not too bad.", "url": "https://github.com/graphhopper/graphhopper/pull/1949#discussion_r390256963", "createdAt": "2020-03-10T11:43:29Z", "author": {"login": "karussell"}, "path": "core/src/main/java/com/graphhopper/routing/ProfileResolver.java", "diffHunk": "@@ -0,0 +1,195 @@\n+/*\n+ *  Licensed to GraphHopper GmbH under one or more contributor\n+ *  license agreements. See the NOTICE file distributed with this work for\n+ *  additional information regarding copyright ownership.\n+ *\n+ *  GraphHopper GmbH licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except in\n+ *  compliance with the License. You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+\n+package com.graphhopper.routing;\n+\n+import com.graphhopper.config.ProfileConfig;\n+import com.graphhopper.routing.lm.LMProfile;\n+import com.graphhopper.routing.util.EncodingManager;\n+import com.graphhopper.routing.util.FlagEncoder;\n+import com.graphhopper.routing.util.HintsMap;\n+import com.graphhopper.storage.CHProfile;\n+import com.graphhopper.util.Parameters;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import static com.graphhopper.routing.weighting.Weighting.INFINITE_U_TURN_COSTS;\n+\n+public class ProfileResolver {\n+\n+    public ProfileConfig resolveProfile(EncodingManager encodingManager, List<CHProfile> chProfiles, List<LMProfile> lmProfiles, HintsMap hints) {\n+        // default handling\n+        String vehicle = hints.getVehicle();\n+        if (vehicle.isEmpty()) {\n+            vehicle = getDefaultVehicle(encodingManager).toString();\n+        }\n+        String weighting = hints.getWeighting();\n+        if (weighting.isEmpty()) {\n+            weighting = \"fastest\";\n+        }\n+        if (!encodingManager.hasEncoder(vehicle))\n+            throw new IllegalArgumentException(\"Vehicle not supported: \" + vehicle + \". Supported are: \" + encodingManager.toString());\n+\n+        FlagEncoder encoder = encodingManager.getEncoder(vehicle);\n+        // we use turn costs if the encoder supports it *unless* the edge_based parameter is set explicitly\n+        boolean turnCosts = encoder.supportsTurnCosts();\n+        if (hints.has(Parameters.Routing.EDGE_BASED))\n+            turnCosts = hints.getBool(Parameters.Routing.EDGE_BASED, false);\n+        if (turnCosts && !encoder.supportsTurnCosts())\n+            throw new IllegalArgumentException(\"You need to set up a turn cost storage to make use of edge_based=true, e.g. use car|turn_costs=true\");\n+\n+        String profileName = resolveProfileName(chProfiles, lmProfiles, hints);\n+\n+        return new ProfileConfig(profileName)\n+                .setVehicle(vehicle)\n+                .setWeighting(weighting)\n+                .setTurnCosts(turnCosts);\n+    }\n+\n+    private String resolveProfileName(List<CHProfile> chProfiles, List<LMProfile> lmProfiles, HintsMap hints) {\n+        boolean disableCH = hints.getBool(Parameters.CH.DISABLE, false);\n+        boolean disableLM = hints.getBool(Parameters.Landmark.DISABLE, false);\n+\n+        String profileName;\n+        if (!chProfiles.isEmpty() && !disableCH) {\n+            profileName = selectCHProfile(chProfiles, hints).getName();\n+        } else if (!lmProfiles.isEmpty() && !disableLM) {\n+            profileName = selectLMProfile(lmProfiles, hints).getName();\n+        } else {\n+            // todonow: here we will instead select one of the existing profiles\n+            profileName = \"unprepared_profile\";\n+        }\n+        return profileName;\n+    }\n+\n+    /**\n+     * @param chProfiles the CH profiles to choose from\n+     * @param hintsMap   a map used to describe the CH profile that shall be selected\n+     * @throws IllegalArgumentException if no CH profile could be selected for the given parameters\n+     */\n+    public CHProfile selectCHProfile(List<CHProfile> chProfiles, HintsMap hintsMap) {\n+        List<CHProfile> matchingProfiles = new ArrayList<>();\n+        for (CHProfile p : chProfiles) {\n+            if (!chProfileMatchesHints(p, hintsMap))\n+                continue;\n+            matchingProfiles.add(p);\n+        }\n+\n+        Boolean edgeBased = getEdgeBased(hintsMap);\n+        Integer uTurnCosts = getUTurnCosts(hintsMap);\n+        if (matchingProfiles.isEmpty()) {\n+            throw new IllegalArgumentException(\"Cannot find matching CH profile for your request. Please check your parameters.\" +\n+                    \"\\nYou can try disabling CH using \" + Parameters.CH.DISABLE + \"=true\" +\n+                    \"\\nrequested:  \" + getCHRequestAsString(hintsMap, edgeBased, uTurnCosts) + \"\\navailable: \" + chProfiles);\n+        } else if (matchingProfiles.size() == 1) {\n+            return matchingProfiles.get(0);\n+        } else {\n+            // special case: prefer edge-based over node-based if these are the only two options\n+            CHProfile match1 = matchingProfiles.get(0);\n+            CHProfile match2 = matchingProfiles.get(1);\n+            if (edgeBased == null && matchingProfiles.size() == 2 &&\n+                    match1.getWeighting().getName().equals(match2.getWeighting().getName()) &&\n+                    match1.getWeighting().getFlagEncoder().toString().equals(match2.getWeighting().getFlagEncoder().toString()) &&\n+                    match1.isEdgeBased() != match2.isEdgeBased()) {\n+                return match1.isEdgeBased() ? match1 : match2;\n+            }\n+            throw new IllegalArgumentException(\"There are multiple CH profiles matching your request. Use the `weighting`,`vehicle`,`edge_based` and/or `u_turn_costs` parameters to be more specific.\" +\n+                    \"\\nYou can also try disabling CH altogether using \" + Parameters.CH.DISABLE + \"=true\" +\n+                    \"\\nrequested:  \" + getCHRequestAsString(hintsMap, edgeBased, uTurnCosts) + \"\\nmatched:   \" + matchingProfiles + \"\\navailable: \" + chProfiles);\n+        }\n+    }\n+\n+    public LMProfile selectLMProfile(List<LMProfile> lmProfiles, HintsMap hintsMap) {\n+        List<LMProfile> matchingProfiles = new ArrayList<>();\n+        for (LMProfile p : lmProfiles) {\n+            if (!lmProfileMatchesHints(p, hintsMap))\n+                continue;\n+            matchingProfiles.add(p);\n+        }\n+        // Note:\n+        // There are situations where we can use the requested encoder/weighting with an existing LM preparation, even\n+        // though the preparation was done with a different weighting. For example this works when the new weighting\n+        // only yields higher (but never lower) weights than the one that was used for the preparation. However, its not\n+        // trivial to check whether or not this is the case so we do not allow this for now.\n+        if (matchingProfiles.isEmpty()) {\n+            throw new IllegalArgumentException(\"Cannot find matching LM profile for your request. Please check your parameters.\" +\n+                    \"\\nYou can try disabling LM by setting \" + Parameters.Landmark.DISABLE + \"=true\" +\n+                    \"\\nrequested: \" + getLMRequestAsString(hintsMap) + \"\\navailable: \" + lmProfilesAsStrings(lmProfiles));\n+        } else if (matchingProfiles.size() == 1) {\n+            return matchingProfiles.get(0);\n+        } else {\n+            throw new IllegalArgumentException(\"There are multiple LM profiles matching your request. Use the `weighting` and `vehicle` parameters to be more specific.\" +\n+                    \"\\nYou can also try disabling LM altogether using \" + Parameters.CH.DISABLE + \"=true\" +\n+                    \"\\nrequested:  \" + getLMRequestAsString(hintsMap) + \"\\nmatched:   \" + lmProfilesAsStrings(matchingProfiles) + \"\\navailable: \" + lmProfilesAsStrings(lmProfiles));\n+        }\n+    }\n+\n+    protected boolean chProfileMatchesHints(CHProfile p, HintsMap hintsMap) {\n+        Boolean edgeBased = getEdgeBased(hintsMap);\n+        Integer uTurnCosts = getUTurnCosts(hintsMap);\n+        return (edgeBased == null || p.isEdgeBased() == edgeBased) &&\n+                (uTurnCosts == null || p.getWeighting().getTurnCostProvider().getName().equals(uTurnCosts.toString())) &&", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDE2ODA0NQ=="}, "originalCommit": {"oid": "8a9f090b2fb8e05691043fa428077a046251557e"}, "originalPosition": 147}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDMyMzA3OQ==", "bodyText": "Done", "url": "https://github.com/graphhopper/graphhopper/pull/1949#discussion_r390323079", "createdAt": "2020-03-10T13:45:59Z", "author": {"login": "easbar"}, "path": "core/src/main/java/com/graphhopper/routing/ProfileResolver.java", "diffHunk": "@@ -0,0 +1,195 @@\n+/*\n+ *  Licensed to GraphHopper GmbH under one or more contributor\n+ *  license agreements. See the NOTICE file distributed with this work for\n+ *  additional information regarding copyright ownership.\n+ *\n+ *  GraphHopper GmbH licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except in\n+ *  compliance with the License. You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+\n+package com.graphhopper.routing;\n+\n+import com.graphhopper.config.ProfileConfig;\n+import com.graphhopper.routing.lm.LMProfile;\n+import com.graphhopper.routing.util.EncodingManager;\n+import com.graphhopper.routing.util.FlagEncoder;\n+import com.graphhopper.routing.util.HintsMap;\n+import com.graphhopper.storage.CHProfile;\n+import com.graphhopper.util.Parameters;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import static com.graphhopper.routing.weighting.Weighting.INFINITE_U_TURN_COSTS;\n+\n+public class ProfileResolver {\n+\n+    public ProfileConfig resolveProfile(EncodingManager encodingManager, List<CHProfile> chProfiles, List<LMProfile> lmProfiles, HintsMap hints) {\n+        // default handling\n+        String vehicle = hints.getVehicle();\n+        if (vehicle.isEmpty()) {\n+            vehicle = getDefaultVehicle(encodingManager).toString();\n+        }\n+        String weighting = hints.getWeighting();\n+        if (weighting.isEmpty()) {\n+            weighting = \"fastest\";\n+        }\n+        if (!encodingManager.hasEncoder(vehicle))\n+            throw new IllegalArgumentException(\"Vehicle not supported: \" + vehicle + \". Supported are: \" + encodingManager.toString());\n+\n+        FlagEncoder encoder = encodingManager.getEncoder(vehicle);\n+        // we use turn costs if the encoder supports it *unless* the edge_based parameter is set explicitly\n+        boolean turnCosts = encoder.supportsTurnCosts();\n+        if (hints.has(Parameters.Routing.EDGE_BASED))\n+            turnCosts = hints.getBool(Parameters.Routing.EDGE_BASED, false);\n+        if (turnCosts && !encoder.supportsTurnCosts())\n+            throw new IllegalArgumentException(\"You need to set up a turn cost storage to make use of edge_based=true, e.g. use car|turn_costs=true\");\n+\n+        String profileName = resolveProfileName(chProfiles, lmProfiles, hints);\n+\n+        return new ProfileConfig(profileName)\n+                .setVehicle(vehicle)\n+                .setWeighting(weighting)\n+                .setTurnCosts(turnCosts);\n+    }\n+\n+    private String resolveProfileName(List<CHProfile> chProfiles, List<LMProfile> lmProfiles, HintsMap hints) {\n+        boolean disableCH = hints.getBool(Parameters.CH.DISABLE, false);\n+        boolean disableLM = hints.getBool(Parameters.Landmark.DISABLE, false);\n+\n+        String profileName;\n+        if (!chProfiles.isEmpty() && !disableCH) {\n+            profileName = selectCHProfile(chProfiles, hints).getName();\n+        } else if (!lmProfiles.isEmpty() && !disableLM) {\n+            profileName = selectLMProfile(lmProfiles, hints).getName();\n+        } else {\n+            // todonow: here we will instead select one of the existing profiles\n+            profileName = \"unprepared_profile\";\n+        }\n+        return profileName;\n+    }\n+\n+    /**\n+     * @param chProfiles the CH profiles to choose from\n+     * @param hintsMap   a map used to describe the CH profile that shall be selected\n+     * @throws IllegalArgumentException if no CH profile could be selected for the given parameters\n+     */\n+    public CHProfile selectCHProfile(List<CHProfile> chProfiles, HintsMap hintsMap) {\n+        List<CHProfile> matchingProfiles = new ArrayList<>();\n+        for (CHProfile p : chProfiles) {\n+            if (!chProfileMatchesHints(p, hintsMap))\n+                continue;\n+            matchingProfiles.add(p);\n+        }\n+\n+        Boolean edgeBased = getEdgeBased(hintsMap);\n+        Integer uTurnCosts = getUTurnCosts(hintsMap);\n+        if (matchingProfiles.isEmpty()) {\n+            throw new IllegalArgumentException(\"Cannot find matching CH profile for your request. Please check your parameters.\" +\n+                    \"\\nYou can try disabling CH using \" + Parameters.CH.DISABLE + \"=true\" +\n+                    \"\\nrequested:  \" + getCHRequestAsString(hintsMap, edgeBased, uTurnCosts) + \"\\navailable: \" + chProfiles);\n+        } else if (matchingProfiles.size() == 1) {\n+            return matchingProfiles.get(0);\n+        } else {\n+            // special case: prefer edge-based over node-based if these are the only two options\n+            CHProfile match1 = matchingProfiles.get(0);\n+            CHProfile match2 = matchingProfiles.get(1);\n+            if (edgeBased == null && matchingProfiles.size() == 2 &&\n+                    match1.getWeighting().getName().equals(match2.getWeighting().getName()) &&\n+                    match1.getWeighting().getFlagEncoder().toString().equals(match2.getWeighting().getFlagEncoder().toString()) &&\n+                    match1.isEdgeBased() != match2.isEdgeBased()) {\n+                return match1.isEdgeBased() ? match1 : match2;\n+            }\n+            throw new IllegalArgumentException(\"There are multiple CH profiles matching your request. Use the `weighting`,`vehicle`,`edge_based` and/or `u_turn_costs` parameters to be more specific.\" +\n+                    \"\\nYou can also try disabling CH altogether using \" + Parameters.CH.DISABLE + \"=true\" +\n+                    \"\\nrequested:  \" + getCHRequestAsString(hintsMap, edgeBased, uTurnCosts) + \"\\nmatched:   \" + matchingProfiles + \"\\navailable: \" + chProfiles);\n+        }\n+    }\n+\n+    public LMProfile selectLMProfile(List<LMProfile> lmProfiles, HintsMap hintsMap) {\n+        List<LMProfile> matchingProfiles = new ArrayList<>();\n+        for (LMProfile p : lmProfiles) {\n+            if (!lmProfileMatchesHints(p, hintsMap))\n+                continue;\n+            matchingProfiles.add(p);\n+        }\n+        // Note:\n+        // There are situations where we can use the requested encoder/weighting with an existing LM preparation, even\n+        // though the preparation was done with a different weighting. For example this works when the new weighting\n+        // only yields higher (but never lower) weights than the one that was used for the preparation. However, its not\n+        // trivial to check whether or not this is the case so we do not allow this for now.\n+        if (matchingProfiles.isEmpty()) {\n+            throw new IllegalArgumentException(\"Cannot find matching LM profile for your request. Please check your parameters.\" +\n+                    \"\\nYou can try disabling LM by setting \" + Parameters.Landmark.DISABLE + \"=true\" +\n+                    \"\\nrequested: \" + getLMRequestAsString(hintsMap) + \"\\navailable: \" + lmProfilesAsStrings(lmProfiles));\n+        } else if (matchingProfiles.size() == 1) {\n+            return matchingProfiles.get(0);\n+        } else {\n+            throw new IllegalArgumentException(\"There are multiple LM profiles matching your request. Use the `weighting` and `vehicle` parameters to be more specific.\" +\n+                    \"\\nYou can also try disabling LM altogether using \" + Parameters.CH.DISABLE + \"=true\" +\n+                    \"\\nrequested:  \" + getLMRequestAsString(hintsMap) + \"\\nmatched:   \" + lmProfilesAsStrings(matchingProfiles) + \"\\navailable: \" + lmProfilesAsStrings(lmProfiles));\n+        }\n+    }\n+\n+    protected boolean chProfileMatchesHints(CHProfile p, HintsMap hintsMap) {\n+        Boolean edgeBased = getEdgeBased(hintsMap);\n+        Integer uTurnCosts = getUTurnCosts(hintsMap);\n+        return (edgeBased == null || p.isEdgeBased() == edgeBased) &&\n+                (uTurnCosts == null || p.getWeighting().getTurnCostProvider().getName().equals(uTurnCosts.toString())) &&", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDE2ODA0NQ=="}, "originalCommit": {"oid": "8a9f090b2fb8e05691043fa428077a046251557e"}, "originalPosition": 147}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQxODMxMzQ0OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/com/graphhopper/GraphHopper.java", "isResolved": false, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMFQxMDo0NzozNFrOF0JwBw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMFQxMToyOToyMVrOF0K_Uw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDIzMDAyMw==", "bodyText": "In #1776 I stumbled over this check as I wanted to inject the graph into the Weighting but at this time graph is null.\nBut with #1950 I found a good solution so that I kept this method here :)", "url": "https://github.com/graphhopper/graphhopper/pull/1949#discussion_r390230023", "createdAt": "2020-03-10T10:47:34Z", "author": {"login": "karussell"}, "path": "core/src/main/java/com/graphhopper/GraphHopper.java", "diffHunk": "@@ -833,8 +840,9 @@ private void checkProfilesConsistency() {\n                         \"\\nYou need to add `|turn_costs=true` to the vehicle in `graph.flag_encoders`\");\n             }\n             try {\n-                createWeighting(new HintsMap(profile.getWeighting()), encoder, NO_TURN_COST_PROVIDER);\n+                createWeighting(profile, new PMap());\n             } catch (IllegalArgumentException e) {\n+                // todonow: update, what are we really checking here?\n                 throw new IllegalArgumentException(\"The profile '\" + profile.getName() + \"' was configured with an unknown weighting '\" + profile.getWeighting() + \"'\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8a9f090b2fb8e05691043fa428077a046251557e"}, "originalPosition": 79}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDIzMTcxNg==", "bodyText": "Ah ok. The graph being null problem when running this check should also be already fixed with this: 639bd9a", "url": "https://github.com/graphhopper/graphhopper/pull/1949#discussion_r390231716", "createdAt": "2020-03-10T10:50:44Z", "author": {"login": "easbar"}, "path": "core/src/main/java/com/graphhopper/GraphHopper.java", "diffHunk": "@@ -833,8 +840,9 @@ private void checkProfilesConsistency() {\n                         \"\\nYou need to add `|turn_costs=true` to the vehicle in `graph.flag_encoders`\");\n             }\n             try {\n-                createWeighting(new HintsMap(profile.getWeighting()), encoder, NO_TURN_COST_PROVIDER);\n+                createWeighting(profile, new PMap());\n             } catch (IllegalArgumentException e) {\n+                // todonow: update, what are we really checking here?\n                 throw new IllegalArgumentException(\"The profile '\" + profile.getName() + \"' was configured with an unknown weighting '\" + profile.getWeighting() + \"'\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDIzMDAyMw=="}, "originalCommit": {"oid": "8a9f090b2fb8e05691043fa428077a046251557e"}, "originalPosition": 79}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDI0MjM3MA==", "bodyText": "Aha, where did you stumble over this?", "url": "https://github.com/graphhopper/graphhopper/pull/1949#discussion_r390242370", "createdAt": "2020-03-10T11:11:39Z", "author": {"login": "karussell"}, "path": "core/src/main/java/com/graphhopper/GraphHopper.java", "diffHunk": "@@ -833,8 +840,9 @@ private void checkProfilesConsistency() {\n                         \"\\nYou need to add `|turn_costs=true` to the vehicle in `graph.flag_encoders`\");\n             }\n             try {\n-                createWeighting(new HintsMap(profile.getWeighting()), encoder, NO_TURN_COST_PROVIDER);\n+                createWeighting(profile, new PMap());\n             } catch (IllegalArgumentException e) {\n+                // todonow: update, what are we really checking here?\n                 throw new IllegalArgumentException(\"The profile '\" + profile.getName() + \"' was configured with an unknown weighting '\" + profile.getWeighting() + \"'\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDIzMDAyMw=="}, "originalCommit": {"oid": "8a9f090b2fb8e05691043fa428077a046251557e"}, "originalPosition": 79}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDI1MDMyMw==", "bodyText": "Well its required for this branch because the turn cost provider is created in createWeighting now (and thus there is a call to ghStorage.getTurnCostStorage()).", "url": "https://github.com/graphhopper/graphhopper/pull/1949#discussion_r390250323", "createdAt": "2020-03-10T11:29:21Z", "author": {"login": "easbar"}, "path": "core/src/main/java/com/graphhopper/GraphHopper.java", "diffHunk": "@@ -833,8 +840,9 @@ private void checkProfilesConsistency() {\n                         \"\\nYou need to add `|turn_costs=true` to the vehicle in `graph.flag_encoders`\");\n             }\n             try {\n-                createWeighting(new HintsMap(profile.getWeighting()), encoder, NO_TURN_COST_PROVIDER);\n+                createWeighting(profile, new PMap());\n             } catch (IllegalArgumentException e) {\n+                // todonow: update, what are we really checking here?\n                 throw new IllegalArgumentException(\"The profile '\" + profile.getName() + \"' was configured with an unknown weighting '\" + profile.getWeighting() + \"'\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDIzMDAyMw=="}, "originalCommit": {"oid": "8a9f090b2fb8e05691043fa428077a046251557e"}, "originalPosition": 79}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4751, "cost": 1, "resetAt": "2021-11-12T20:28:25Z"}}}