{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDMzMzcxMDY5", "number": 5611, "title": "docs: KLIP-28 introduce CREATE OR REPLACE", "bodyText": "https://github.com/agavra/ksql/blob/aed31a2478e49956e469d11e11bccf74ef5c472c/design-proposals/klip-28-create-or-replace", "createdAt": "2020-06-11T22:50:34Z", "url": "https://github.com/confluentinc/ksql/pull/5611", "merged": true, "mergeCommit": {"oid": "19f277d05ec51a086ece4016c23990ca1fda5135"}, "closed": true, "closedAt": "2020-06-23T17:42:26Z", "author": {"login": "agavra"}, "timelineItems": {"totalCount": 12, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcqWKxrgH2gAyNDMzMzcxMDY5OmFlZDMxYTI0NzhlNDk5NTZlNDY5ZDExZTExYmNjZjc0ZWY1YzQ3MmM=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcubmeyAFqTQzNjc0OTc3OQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "aed31a2478e49956e469d11e11bccf74ef5c472c", "author": {"user": {"login": "agavra", "name": "Almog Gavra"}}, "url": "https://github.com/confluentinc/ksql/commit/aed31a2478e49956e469d11e11bccf74ef5c472c", "committedDate": "2020-06-11T22:40:35Z", "message": "docs: KLIP-28 introduce CREATE OR REPLACE"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMxNDYxNzM5", "url": "https://github.com/confluentinc/ksql/pull/5611#pullrequestreview-431461739", "createdAt": "2020-06-16T12:42:50Z", "commit": {"oid": "aed31a2478e49956e469d11e11bccf74ef5c472c"}, "state": "COMMENTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNlQxMjo0Mjo1MVrOGkZc_g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNlQxMjo0NjoyMVrOGkZljQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDgxODk0Mg==", "bodyText": "Does this include removing columns from the output schema, as well as adding columns?\nWhat about changing the type of a column?\nRemoving and changing the type of existing columns has implications for downstream queries. The simplest solution would be to not allow either of these in this first pass, but not sure of the intent of the KLIP from this statement.  Can we make sure the doc is clearer on this please?\nIMHO it's crucial that we ensure dumping the full database schema and running it on a fresh instance would succeed and result in all the same output schemas and data.", "url": "https://github.com/confluentinc/ksql/pull/5611#discussion_r440818942", "createdAt": "2020-06-16T12:42:51Z", "author": {"login": "big-andy-coates"}, "path": "design-proposals/klip-28-create-or-replace", "diffHunk": "@@ -0,0 +1,156 @@\n+# KLIP 28 - Introduce CREATE OR REPLACE\n+\n+**Author**: agavra | \n+**Release Target**: 0.11 | \n+**Status**: _In Discussion_ | \n+**Discussion**: _link to the design discussion PR_\n+\n+**tl;dr:** _CREATE OR REPLACE is a mechanism geared toward enabling in-place ksqlDB query evolution._\n+           \n+## Motivation and background\n+\n+Production deployments of databases are never static; they evolve as application and business \n+requirements change. To that end, all popular data stores have ways of managing and manipulating \n+existing data. For stream processing applications, a user may want to modify their application as \n+a result of:\n+\n+- Business Requirements: requirements simply change over time\n+- Schema Evolution: the incoming data or required output has been modified\n+- Optimizations: the same application can be executed more efficiently (either by user or engine)\n+\n+At time of writing, ksqlDB provides a crude mechanism for altering its application behavior: dropping \n+a query and restarting it at the earliest or latest offset. While this often works well in development \n+environments, there are limitations to its applicability in production:\n+\n+- Data Retention: the earliest available offset may not correspond with the beginning of time\n+- Downtime: the delta between terminating and catch-up may be out of the application\u2019s SLO\n+- Output Routing: populating to the old output topic will produce duplicates while using a new output topic will require cascading migrations\n+- Compute: recomputing the complete history for a query may not be feasible\n+\n+Kafka Streams provides more granular mechanisms (e.g. restarting queries with different behaviors \n+but identical consumer groups), but these methods burden users with extra complexity and lack guardrails.\n+\n+## Scope\n+\n+To better understand the scope of this KLIP and any future improvements, we define a taxonomy on \n+query upgrades as any combination of three types of characteristics: **source query, upgrade** and\n+**environment**:\n+\n+| **Category** | **Characteristic** | **Description** |\n+|----------|----------------|-------------|\n+| Query | Stateful | Stateful queries maintain local storage |\n+| | Windowed | Windowed queries maintain a limited amount of state specified by a window in time\n+| | Joined | Joined queries read from multiple sources\n+| | Multistage | Multistage queries contain intermediate, non-user visible topics in Kafka\n+| | Nondeterministic | Nondeterministic queries may produce different results when executing identical input\n+| | Simple | Queries with none of the above characteristics\n+| Upgrade | Transparent | Transparent upgrades change the way something is computer (e.g. improving a UDF performance)\n+| | Data Selection | Data selecting query upgrades change which/how many events are emitted\n+| | Schema Evolution | Schema evolving query upgrades change the output type of the data |\n+| | Source Modifying | These upgrades change the source data, whether by means of modifying a JOIN or swapping out a source |\n+| | Topology | These upgrades are invisible to the user, but change the topology, such as the number of sub-topologies or the ordering of operations (e.g. filter push down) |\n+| | Scaling | Scaling upgrades change the physical properties of the query in order to enable better performance characteristics. |\n+| | Unsupported | Unsupported upgrades are ones that will semantically change the query in an unsupported way. There are no plans to implement these migrations. |\n+| Environment | Backfill | Backfill requires the output data to be accurate not just from a point in time, but from the earliest point of retained history |\n+| | Cascading | Cascading environments contain queries that are not terminal, but rather feed into downstream stream processing tasks |\n+| | Exactly Once | Exactly Once environments do not allow for data duplication or missed events |\n+| | Ordered | Ordered environments require that a single offset delineates pre- and post-migration (no events are interleaved) |\n+| | Live | Live environments describe queries that cannot afford downtime, either by means of acting as live storage (e.g. responding to pull queries) or feeding into high availability systems (powering important functionality) |\n+\n+### What is in scope\n+\n+- Specify a syntax that can support arbitrary upgrades\n+- Design a validator to fail unsupported upgrades\n+- Design a mechanism for upgrading queries under limited scope\n+\n+### What is not in scope\n+\n+The Design section below enumerates which upgrades are out of scope\n+\n+## Value/Return\n+\n+This KLIP will represent a significant step forward in the operability of ksqlDB in production, as\n+noted in the background and motivation section.\n+\n+## Public APIS\n+\n+The syntax `CREATE OR REPLACE (STREAM | TABLE) source_name WITH (key=value, ...) AS query;` will be\n+introduced to allow users to specify an existing stream or table to replace with a new query that\n+will resume from the same processing point as any previously existing query.\n+\n+## Design\n+\n+If the `source_name` does not yet exist, a `CREATE OR REPLACE` statement functions identically to\n+a normal `CREATE` statement. Otherwise, ksqlDB executes the following:\n+\n+1. Identify the original `queryID` that populates the source (`INSERT INTO` discussed later)\n+2. Ensure the upgrade is valid\n+3. Terminate `queryID`\n+4. Start the new query under the same `queryID`\n+\n+A few changes need to happen in order to make this work. For 1, we need to maintain a mapping from\n+source to queryID(s). If the source has multiple associated ids (in the case of `INSERT INTO`) then\n+the upgrade will fail and not terminate any queries.\n+\n+For step 2, there will be a component to determine whether two topologies are \"upgrade\n+compatible\"; the first iterations, which will be delivered as part of this KLIP, will only allow\n+for the most basic upgrades: \n+\n+- Any _transparent_ upgrade will be supported\n+- Any _data selection_ upgrade will be supported\n+- _Schema evolution_ upgrades will be supported on simple and stateful queries, but it will be", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aed31a2478e49956e469d11e11bccf74ef5c472c"}, "originalPosition": 101}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDgyMDIwOA==", "bodyText": "Missing details...", "url": "https://github.com/confluentinc/ksql/pull/5611#discussion_r440820208", "createdAt": "2020-06-16T12:44:50Z", "author": {"login": "big-andy-coates"}, "path": "design-proposals/klip-28-create-or-replace", "diffHunk": "@@ -0,0 +1,156 @@\n+# KLIP 28 - Introduce CREATE OR REPLACE\n+\n+**Author**: agavra | \n+**Release Target**: 0.11 | \n+**Status**: _In Discussion_ | \n+**Discussion**: _link to the design discussion PR_\n+\n+**tl;dr:** _CREATE OR REPLACE is a mechanism geared toward enabling in-place ksqlDB query evolution._\n+           \n+## Motivation and background\n+\n+Production deployments of databases are never static; they evolve as application and business \n+requirements change. To that end, all popular data stores have ways of managing and manipulating \n+existing data. For stream processing applications, a user may want to modify their application as \n+a result of:\n+\n+- Business Requirements: requirements simply change over time\n+- Schema Evolution: the incoming data or required output has been modified\n+- Optimizations: the same application can be executed more efficiently (either by user or engine)\n+\n+At time of writing, ksqlDB provides a crude mechanism for altering its application behavior: dropping \n+a query and restarting it at the earliest or latest offset. While this often works well in development \n+environments, there are limitations to its applicability in production:\n+\n+- Data Retention: the earliest available offset may not correspond with the beginning of time\n+- Downtime: the delta between terminating and catch-up may be out of the application\u2019s SLO\n+- Output Routing: populating to the old output topic will produce duplicates while using a new output topic will require cascading migrations\n+- Compute: recomputing the complete history for a query may not be feasible\n+\n+Kafka Streams provides more granular mechanisms (e.g. restarting queries with different behaviors \n+but identical consumer groups), but these methods burden users with extra complexity and lack guardrails.\n+\n+## Scope\n+\n+To better understand the scope of this KLIP and any future improvements, we define a taxonomy on \n+query upgrades as any combination of three types of characteristics: **source query, upgrade** and\n+**environment**:\n+\n+| **Category** | **Characteristic** | **Description** |\n+|----------|----------------|-------------|\n+| Query | Stateful | Stateful queries maintain local storage |\n+| | Windowed | Windowed queries maintain a limited amount of state specified by a window in time\n+| | Joined | Joined queries read from multiple sources\n+| | Multistage | Multistage queries contain intermediate, non-user visible topics in Kafka\n+| | Nondeterministic | Nondeterministic queries may produce different results when executing identical input\n+| | Simple | Queries with none of the above characteristics\n+| Upgrade | Transparent | Transparent upgrades change the way something is computer (e.g. improving a UDF performance)\n+| | Data Selection | Data selecting query upgrades change which/how many events are emitted\n+| | Schema Evolution | Schema evolving query upgrades change the output type of the data |\n+| | Source Modifying | These upgrades change the source data, whether by means of modifying a JOIN or swapping out a source |\n+| | Topology | These upgrades are invisible to the user, but change the topology, such as the number of sub-topologies or the ordering of operations (e.g. filter push down) |\n+| | Scaling | Scaling upgrades change the physical properties of the query in order to enable better performance characteristics. |\n+| | Unsupported | Unsupported upgrades are ones that will semantically change the query in an unsupported way. There are no plans to implement these migrations. |\n+| Environment | Backfill | Backfill requires the output data to be accurate not just from a point in time, but from the earliest point of retained history |\n+| | Cascading | Cascading environments contain queries that are not terminal, but rather feed into downstream stream processing tasks |\n+| | Exactly Once | Exactly Once environments do not allow for data duplication or missed events |\n+| | Ordered | Ordered environments require that a single offset delineates pre- and post-migration (no events are interleaved) |\n+| | Live | Live environments describe queries that cannot afford downtime, either by means of acting as live storage (e.g. responding to pull queries) or feeding into high availability systems (powering important functionality) |\n+\n+### What is in scope\n+\n+- Specify a syntax that can support arbitrary upgrades\n+- Design a validator to fail unsupported upgrades\n+- Design a mechanism for upgrading queries under limited scope\n+\n+### What is not in scope\n+\n+The Design section below enumerates which upgrades are out of scope\n+\n+## Value/Return\n+\n+This KLIP will represent a significant step forward in the operability of ksqlDB in production, as\n+noted in the background and motivation section.\n+\n+## Public APIS\n+\n+The syntax `CREATE OR REPLACE (STREAM | TABLE) source_name WITH (key=value, ...) AS query;` will be\n+introduced to allow users to specify an existing stream or table to replace with a new query that\n+will resume from the same processing point as any previously existing query.\n+\n+## Design\n+\n+If the `source_name` does not yet exist, a `CREATE OR REPLACE` statement functions identically to\n+a normal `CREATE` statement. Otherwise, ksqlDB executes the following:\n+\n+1. Identify the original `queryID` that populates the source (`INSERT INTO` discussed later)\n+2. Ensure the upgrade is valid\n+3. Terminate `queryID`\n+4. Start the new query under the same `queryID`\n+\n+A few changes need to happen in order to make this work. For 1, we need to maintain a mapping from\n+source to queryID(s). If the source has multiple associated ids (in the case of `INSERT INTO`) then\n+the upgrade will fail and not terminate any queries.\n+\n+For step 2, there will be a component to determine whether two topologies are \"upgrade\n+compatible\"; the first iterations, which will be delivered as part of this KLIP, will only allow\n+for the most basic upgrades: \n+\n+- Any _transparent_ upgrade will be supported\n+- Any _data selection_ upgrade will be supported\n+- _Schema evolution_ upgrades will be supported on simple and stateful queries, but it will be\n+    communicated that the users will not get `backfill` or `ordered` properties for stateful.\n+- _Source modifying_ upgrades will not be supported\n+- _Topology changes_ will not be supported\n+\n+There are currently discussions that discuss how to expand the support of some of these upgrades,\n+but we believe there is value in supporting the limitted set described above.\n+\n+For step 4, we need to be able to generate queryIDs differently for `CREATE OR REPLACE` statements\n+than for others (i.e. it shouldn't just be the offset of the command, but rather the same queryID \n+as the original query.) One simple way to implement this is to allow the queryID to be specified\n+in the command topic. Since the engine receiving the request has a complete view of the engine\n+metadata, it can determine the queryID to enqueue onto the command topic.\n+\n+### On \"INSERT INTO\"\n+\n+Insert into can eventually be replaced with `UNION` as proposed in [KLIP-17](https://github.com/confluentinc/ksql/pull/4125),\n+but that must happen in lock-step with this proposal. At first, we will support `CREATE OR REPLACE`\n+and `INSERT INTO`. Then, we will add support for `UNION`, allowing us to model consecutive `INSERT INTO`\n+statements as replacing unions with larger unions (essentially adding an extra source to the union).\n+The approach for that will require a slight modification to the four steps outlined in the design\n+section above.\n+\n+## Test plan\n+\n+_What are the failure scenarios you are going to cover in your testing? What scale testing do you plan to run? What about peformance and load testing? It goes ", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aed31a2478e49956e469d11e11bccf74ef5c472c"}, "originalPosition": 126}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDgyMTEzMw==", "bodyText": "Rather than add a new file, can we not just add the OR REPLACE bit to the current CREATE TABLE AS and CREATE STREAM AS documentation?", "url": "https://github.com/confluentinc/ksql/pull/5611#discussion_r440821133", "createdAt": "2020-06-16T12:46:21Z", "author": {"login": "big-andy-coates"}, "path": "design-proposals/klip-28-create-or-replace", "diffHunk": "@@ -0,0 +1,156 @@\n+# KLIP 28 - Introduce CREATE OR REPLACE\n+\n+**Author**: agavra | \n+**Release Target**: 0.11 | \n+**Status**: _In Discussion_ | \n+**Discussion**: _link to the design discussion PR_\n+\n+**tl;dr:** _CREATE OR REPLACE is a mechanism geared toward enabling in-place ksqlDB query evolution._\n+           \n+## Motivation and background\n+\n+Production deployments of databases are never static; they evolve as application and business \n+requirements change. To that end, all popular data stores have ways of managing and manipulating \n+existing data. For stream processing applications, a user may want to modify their application as \n+a result of:\n+\n+- Business Requirements: requirements simply change over time\n+- Schema Evolution: the incoming data or required output has been modified\n+- Optimizations: the same application can be executed more efficiently (either by user or engine)\n+\n+At time of writing, ksqlDB provides a crude mechanism for altering its application behavior: dropping \n+a query and restarting it at the earliest or latest offset. While this often works well in development \n+environments, there are limitations to its applicability in production:\n+\n+- Data Retention: the earliest available offset may not correspond with the beginning of time\n+- Downtime: the delta between terminating and catch-up may be out of the application\u2019s SLO\n+- Output Routing: populating to the old output topic will produce duplicates while using a new output topic will require cascading migrations\n+- Compute: recomputing the complete history for a query may not be feasible\n+\n+Kafka Streams provides more granular mechanisms (e.g. restarting queries with different behaviors \n+but identical consumer groups), but these methods burden users with extra complexity and lack guardrails.\n+\n+## Scope\n+\n+To better understand the scope of this KLIP and any future improvements, we define a taxonomy on \n+query upgrades as any combination of three types of characteristics: **source query, upgrade** and\n+**environment**:\n+\n+| **Category** | **Characteristic** | **Description** |\n+|----------|----------------|-------------|\n+| Query | Stateful | Stateful queries maintain local storage |\n+| | Windowed | Windowed queries maintain a limited amount of state specified by a window in time\n+| | Joined | Joined queries read from multiple sources\n+| | Multistage | Multistage queries contain intermediate, non-user visible topics in Kafka\n+| | Nondeterministic | Nondeterministic queries may produce different results when executing identical input\n+| | Simple | Queries with none of the above characteristics\n+| Upgrade | Transparent | Transparent upgrades change the way something is computer (e.g. improving a UDF performance)\n+| | Data Selection | Data selecting query upgrades change which/how many events are emitted\n+| | Schema Evolution | Schema evolving query upgrades change the output type of the data |\n+| | Source Modifying | These upgrades change the source data, whether by means of modifying a JOIN or swapping out a source |\n+| | Topology | These upgrades are invisible to the user, but change the topology, such as the number of sub-topologies or the ordering of operations (e.g. filter push down) |\n+| | Scaling | Scaling upgrades change the physical properties of the query in order to enable better performance characteristics. |\n+| | Unsupported | Unsupported upgrades are ones that will semantically change the query in an unsupported way. There are no plans to implement these migrations. |\n+| Environment | Backfill | Backfill requires the output data to be accurate not just from a point in time, but from the earliest point of retained history |\n+| | Cascading | Cascading environments contain queries that are not terminal, but rather feed into downstream stream processing tasks |\n+| | Exactly Once | Exactly Once environments do not allow for data duplication or missed events |\n+| | Ordered | Ordered environments require that a single offset delineates pre- and post-migration (no events are interleaved) |\n+| | Live | Live environments describe queries that cannot afford downtime, either by means of acting as live storage (e.g. responding to pull queries) or feeding into high availability systems (powering important functionality) |\n+\n+### What is in scope\n+\n+- Specify a syntax that can support arbitrary upgrades\n+- Design a validator to fail unsupported upgrades\n+- Design a mechanism for upgrading queries under limited scope\n+\n+### What is not in scope\n+\n+The Design section below enumerates which upgrades are out of scope\n+\n+## Value/Return\n+\n+This KLIP will represent a significant step forward in the operability of ksqlDB in production, as\n+noted in the background and motivation section.\n+\n+## Public APIS\n+\n+The syntax `CREATE OR REPLACE (STREAM | TABLE) source_name WITH (key=value, ...) AS query;` will be\n+introduced to allow users to specify an existing stream or table to replace with a new query that\n+will resume from the same processing point as any previously existing query.\n+\n+## Design\n+\n+If the `source_name` does not yet exist, a `CREATE OR REPLACE` statement functions identically to\n+a normal `CREATE` statement. Otherwise, ksqlDB executes the following:\n+\n+1. Identify the original `queryID` that populates the source (`INSERT INTO` discussed later)\n+2. Ensure the upgrade is valid\n+3. Terminate `queryID`\n+4. Start the new query under the same `queryID`\n+\n+A few changes need to happen in order to make this work. For 1, we need to maintain a mapping from\n+source to queryID(s). If the source has multiple associated ids (in the case of `INSERT INTO`) then\n+the upgrade will fail and not terminate any queries.\n+\n+For step 2, there will be a component to determine whether two topologies are \"upgrade\n+compatible\"; the first iterations, which will be delivered as part of this KLIP, will only allow\n+for the most basic upgrades: \n+\n+- Any _transparent_ upgrade will be supported\n+- Any _data selection_ upgrade will be supported\n+- _Schema evolution_ upgrades will be supported on simple and stateful queries, but it will be\n+    communicated that the users will not get `backfill` or `ordered` properties for stateful.\n+- _Source modifying_ upgrades will not be supported\n+- _Topology changes_ will not be supported\n+\n+There are currently discussions that discuss how to expand the support of some of these upgrades,\n+but we believe there is value in supporting the limitted set described above.\n+\n+For step 4, we need to be able to generate queryIDs differently for `CREATE OR REPLACE` statements\n+than for others (i.e. it shouldn't just be the offset of the command, but rather the same queryID \n+as the original query.) One simple way to implement this is to allow the queryID to be specified\n+in the command topic. Since the engine receiving the request has a complete view of the engine\n+metadata, it can determine the queryID to enqueue onto the command topic.\n+\n+### On \"INSERT INTO\"\n+\n+Insert into can eventually be replaced with `UNION` as proposed in [KLIP-17](https://github.com/confluentinc/ksql/pull/4125),\n+but that must happen in lock-step with this proposal. At first, we will support `CREATE OR REPLACE`\n+and `INSERT INTO`. Then, we will add support for `UNION`, allowing us to model consecutive `INSERT INTO`\n+statements as replacing unions with larger unions (essentially adding an extra source to the union).\n+The approach for that will require a slight modification to the four steps outlined in the design\n+section above.\n+\n+## Test plan\n+\n+_What are the failure scenarios you are going to cover in your testing? What scale testing do you plan to run? What about peformance and load testing? It goes \n+without saying that most classes should have unit tests._\n+\n+## Documentation Updates\n+\n+We will add the following `md` file:\n+\n+### Synopsis:\n+\n+```sql\n+CREATE OR REPLACE (STREAM | TABLE) source_name \n+    [WITH ( property_name = expression [, ...] )]\n+    AS query;\n+```", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aed31a2478e49956e469d11e11bccf74ef5c472c"}, "originalPosition": 139}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMxNDcxMjQ3", "url": "https://github.com/confluentinc/ksql/pull/5611#pullrequestreview-431471247", "createdAt": "2020-06-16T12:54:33Z", "commit": {"oid": "aed31a2478e49956e469d11e11bccf74ef5c472c"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNlQxMjo1NDozM1rOGkZ5fg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNlQxMjo1NDozM1rOGkZ5fg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDgyNjIzOA==", "bodyText": "One simple way to implement this is to allow the queryID to be specified in the command topic.\n\nFYI, the query plan already includes the query id.", "url": "https://github.com/confluentinc/ksql/pull/5611#discussion_r440826238", "createdAt": "2020-06-16T12:54:33Z", "author": {"login": "big-andy-coates"}, "path": "design-proposals/klip-28-create-or-replace", "diffHunk": "@@ -0,0 +1,156 @@\n+# KLIP 28 - Introduce CREATE OR REPLACE\n+\n+**Author**: agavra | \n+**Release Target**: 0.11 | \n+**Status**: _In Discussion_ | \n+**Discussion**: _link to the design discussion PR_\n+\n+**tl;dr:** _CREATE OR REPLACE is a mechanism geared toward enabling in-place ksqlDB query evolution._\n+           \n+## Motivation and background\n+\n+Production deployments of databases are never static; they evolve as application and business \n+requirements change. To that end, all popular data stores have ways of managing and manipulating \n+existing data. For stream processing applications, a user may want to modify their application as \n+a result of:\n+\n+- Business Requirements: requirements simply change over time\n+- Schema Evolution: the incoming data or required output has been modified\n+- Optimizations: the same application can be executed more efficiently (either by user or engine)\n+\n+At time of writing, ksqlDB provides a crude mechanism for altering its application behavior: dropping \n+a query and restarting it at the earliest or latest offset. While this often works well in development \n+environments, there are limitations to its applicability in production:\n+\n+- Data Retention: the earliest available offset may not correspond with the beginning of time\n+- Downtime: the delta between terminating and catch-up may be out of the application\u2019s SLO\n+- Output Routing: populating to the old output topic will produce duplicates while using a new output topic will require cascading migrations\n+- Compute: recomputing the complete history for a query may not be feasible\n+\n+Kafka Streams provides more granular mechanisms (e.g. restarting queries with different behaviors \n+but identical consumer groups), but these methods burden users with extra complexity and lack guardrails.\n+\n+## Scope\n+\n+To better understand the scope of this KLIP and any future improvements, we define a taxonomy on \n+query upgrades as any combination of three types of characteristics: **source query, upgrade** and\n+**environment**:\n+\n+| **Category** | **Characteristic** | **Description** |\n+|----------|----------------|-------------|\n+| Query | Stateful | Stateful queries maintain local storage |\n+| | Windowed | Windowed queries maintain a limited amount of state specified by a window in time\n+| | Joined | Joined queries read from multiple sources\n+| | Multistage | Multistage queries contain intermediate, non-user visible topics in Kafka\n+| | Nondeterministic | Nondeterministic queries may produce different results when executing identical input\n+| | Simple | Queries with none of the above characteristics\n+| Upgrade | Transparent | Transparent upgrades change the way something is computer (e.g. improving a UDF performance)\n+| | Data Selection | Data selecting query upgrades change which/how many events are emitted\n+| | Schema Evolution | Schema evolving query upgrades change the output type of the data |\n+| | Source Modifying | These upgrades change the source data, whether by means of modifying a JOIN or swapping out a source |\n+| | Topology | These upgrades are invisible to the user, but change the topology, such as the number of sub-topologies or the ordering of operations (e.g. filter push down) |\n+| | Scaling | Scaling upgrades change the physical properties of the query in order to enable better performance characteristics. |\n+| | Unsupported | Unsupported upgrades are ones that will semantically change the query in an unsupported way. There are no plans to implement these migrations. |\n+| Environment | Backfill | Backfill requires the output data to be accurate not just from a point in time, but from the earliest point of retained history |\n+| | Cascading | Cascading environments contain queries that are not terminal, but rather feed into downstream stream processing tasks |\n+| | Exactly Once | Exactly Once environments do not allow for data duplication or missed events |\n+| | Ordered | Ordered environments require that a single offset delineates pre- and post-migration (no events are interleaved) |\n+| | Live | Live environments describe queries that cannot afford downtime, either by means of acting as live storage (e.g. responding to pull queries) or feeding into high availability systems (powering important functionality) |\n+\n+### What is in scope\n+\n+- Specify a syntax that can support arbitrary upgrades\n+- Design a validator to fail unsupported upgrades\n+- Design a mechanism for upgrading queries under limited scope\n+\n+### What is not in scope\n+\n+The Design section below enumerates which upgrades are out of scope\n+\n+## Value/Return\n+\n+This KLIP will represent a significant step forward in the operability of ksqlDB in production, as\n+noted in the background and motivation section.\n+\n+## Public APIS\n+\n+The syntax `CREATE OR REPLACE (STREAM | TABLE) source_name WITH (key=value, ...) AS query;` will be\n+introduced to allow users to specify an existing stream or table to replace with a new query that\n+will resume from the same processing point as any previously existing query.\n+\n+## Design\n+\n+If the `source_name` does not yet exist, a `CREATE OR REPLACE` statement functions identically to\n+a normal `CREATE` statement. Otherwise, ksqlDB executes the following:\n+\n+1. Identify the original `queryID` that populates the source (`INSERT INTO` discussed later)\n+2. Ensure the upgrade is valid\n+3. Terminate `queryID`\n+4. Start the new query under the same `queryID`\n+\n+A few changes need to happen in order to make this work. For 1, we need to maintain a mapping from\n+source to queryID(s). If the source has multiple associated ids (in the case of `INSERT INTO`) then\n+the upgrade will fail and not terminate any queries.\n+\n+For step 2, there will be a component to determine whether two topologies are \"upgrade\n+compatible\"; the first iterations, which will be delivered as part of this KLIP, will only allow\n+for the most basic upgrades: \n+\n+- Any _transparent_ upgrade will be supported\n+- Any _data selection_ upgrade will be supported\n+- _Schema evolution_ upgrades will be supported on simple and stateful queries, but it will be\n+    communicated that the users will not get `backfill` or `ordered` properties for stateful.\n+- _Source modifying_ upgrades will not be supported\n+- _Topology changes_ will not be supported\n+\n+There are currently discussions that discuss how to expand the support of some of these upgrades,\n+but we believe there is value in supporting the limitted set described above.\n+\n+For step 4, we need to be able to generate queryIDs differently for `CREATE OR REPLACE` statements\n+than for others (i.e. it shouldn't just be the offset of the command, but rather the same queryID \n+as the original query.) One simple way to implement this is to allow the queryID to be specified", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aed31a2478e49956e469d11e11bccf74ef5c472c"}, "originalPosition": 111}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMxNjEwMDMz", "url": "https://github.com/confluentinc/ksql/pull/5611#pullrequestreview-431610033", "createdAt": "2020-06-16T15:11:48Z", "commit": {"oid": "aed31a2478e49956e469d11e11bccf74ef5c472c"}, "state": "APPROVED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNlQxNToxMTo0OFrOGkgJfg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNlQxNToxODoxOFrOGkgdnA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDkyODYzOA==", "bodyText": "Instead of\n\nbut these methods burden users with extra complexity and lack guardrails\n\nhow about\n\nbut to directly expose these methods to users through ksqlDB would burden them with extra complexity and lack guardrails\n\nOr, perhaps I'm misunderstanding the intention here?", "url": "https://github.com/confluentinc/ksql/pull/5611#discussion_r440928638", "createdAt": "2020-06-16T15:11:48Z", "author": {"login": "rmoff"}, "path": "design-proposals/klip-28-create-or-replace", "diffHunk": "@@ -0,0 +1,156 @@\n+# KLIP 28 - Introduce CREATE OR REPLACE\n+\n+**Author**: agavra | \n+**Release Target**: 0.11 | \n+**Status**: _In Discussion_ | \n+**Discussion**: _link to the design discussion PR_\n+\n+**tl;dr:** _CREATE OR REPLACE is a mechanism geared toward enabling in-place ksqlDB query evolution._\n+           \n+## Motivation and background\n+\n+Production deployments of databases are never static; they evolve as application and business \n+requirements change. To that end, all popular data stores have ways of managing and manipulating \n+existing data. For stream processing applications, a user may want to modify their application as \n+a result of:\n+\n+- Business Requirements: requirements simply change over time\n+- Schema Evolution: the incoming data or required output has been modified\n+- Optimizations: the same application can be executed more efficiently (either by user or engine)\n+\n+At time of writing, ksqlDB provides a crude mechanism for altering its application behavior: dropping \n+a query and restarting it at the earliest or latest offset. While this often works well in development \n+environments, there are limitations to its applicability in production:\n+\n+- Data Retention: the earliest available offset may not correspond with the beginning of time\n+- Downtime: the delta between terminating and catch-up may be out of the application\u2019s SLO\n+- Output Routing: populating to the old output topic will produce duplicates while using a new output topic will require cascading migrations\n+- Compute: recomputing the complete history for a query may not be feasible\n+\n+Kafka Streams provides more granular mechanisms (e.g. restarting queries with different behaviors \n+but identical consumer groups), but these methods burden users with extra complexity and lack guardrails.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aed31a2478e49956e469d11e11bccf74ef5c472c"}, "originalPosition": 31}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDkzMzc4OA==", "bodyText": "Which Environment would be for a Simple query that didn't require backfill? For example, a query with a predicate that needed to be changed but only future-processed records needed to reflect it (an example would be changing the alert threshold for a monitor)", "url": "https://github.com/confluentinc/ksql/pull/5611#discussion_r440933788", "createdAt": "2020-06-16T15:18:18Z", "author": {"login": "rmoff"}, "path": "design-proposals/klip-28-create-or-replace", "diffHunk": "@@ -0,0 +1,156 @@\n+# KLIP 28 - Introduce CREATE OR REPLACE\n+\n+**Author**: agavra | \n+**Release Target**: 0.11 | \n+**Status**: _In Discussion_ | \n+**Discussion**: _link to the design discussion PR_\n+\n+**tl;dr:** _CREATE OR REPLACE is a mechanism geared toward enabling in-place ksqlDB query evolution._\n+           \n+## Motivation and background\n+\n+Production deployments of databases are never static; they evolve as application and business \n+requirements change. To that end, all popular data stores have ways of managing and manipulating \n+existing data. For stream processing applications, a user may want to modify their application as \n+a result of:\n+\n+- Business Requirements: requirements simply change over time\n+- Schema Evolution: the incoming data or required output has been modified\n+- Optimizations: the same application can be executed more efficiently (either by user or engine)\n+\n+At time of writing, ksqlDB provides a crude mechanism for altering its application behavior: dropping \n+a query and restarting it at the earliest or latest offset. While this often works well in development \n+environments, there are limitations to its applicability in production:\n+\n+- Data Retention: the earliest available offset may not correspond with the beginning of time\n+- Downtime: the delta between terminating and catch-up may be out of the application\u2019s SLO\n+- Output Routing: populating to the old output topic will produce duplicates while using a new output topic will require cascading migrations\n+- Compute: recomputing the complete history for a query may not be feasible\n+\n+Kafka Streams provides more granular mechanisms (e.g. restarting queries with different behaviors \n+but identical consumer groups), but these methods burden users with extra complexity and lack guardrails.\n+\n+## Scope\n+\n+To better understand the scope of this KLIP and any future improvements, we define a taxonomy on \n+query upgrades as any combination of three types of characteristics: **source query, upgrade** and\n+**environment**:\n+\n+| **Category** | **Characteristic** | **Description** |\n+|----------|----------------|-------------|\n+| Query | Stateful | Stateful queries maintain local storage |\n+| | Windowed | Windowed queries maintain a limited amount of state specified by a window in time\n+| | Joined | Joined queries read from multiple sources\n+| | Multistage | Multistage queries contain intermediate, non-user visible topics in Kafka\n+| | Nondeterministic | Nondeterministic queries may produce different results when executing identical input\n+| | Simple | Queries with none of the above characteristics\n+| Upgrade | Transparent | Transparent upgrades change the way something is computer (e.g. improving a UDF performance)\n+| | Data Selection | Data selecting query upgrades change which/how many events are emitted\n+| | Schema Evolution | Schema evolving query upgrades change the output type of the data |\n+| | Source Modifying | These upgrades change the source data, whether by means of modifying a JOIN or swapping out a source |\n+| | Topology | These upgrades are invisible to the user, but change the topology, such as the number of sub-topologies or the ordering of operations (e.g. filter push down) |\n+| | Scaling | Scaling upgrades change the physical properties of the query in order to enable better performance characteristics. |\n+| | Unsupported | Unsupported upgrades are ones that will semantically change the query in an unsupported way. There are no plans to implement these migrations. |\n+| Environment | Backfill | Backfill requires the output data to be accurate not just from a point in time, but from the earliest point of retained history |", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aed31a2478e49956e469d11e11bccf74ef5c472c"}, "originalPosition": 54}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "aed31a2478e49956e469d11e11bccf74ef5c472c", "author": {"user": {"login": "agavra", "name": "Almog Gavra"}}, "url": "https://github.com/confluentinc/ksql/commit/aed31a2478e49956e469d11e11bccf74ef5c472c", "committedDate": "2020-06-11T22:40:35Z", "message": "docs: KLIP-28 introduce CREATE OR REPLACE"}, "afterCommit": {"oid": "7291b890e53e2bbd7c90cf79f0a18b6a54a5e13b", "author": {"user": {"login": "agavra", "name": "Almog Gavra"}}, "url": "https://github.com/confluentinc/ksql/commit/7291b890e53e2bbd7c90cf79f0a18b6a54a5e13b", "committedDate": "2020-06-16T17:29:22Z", "message": "docs: KLIP-28 introduce CREATE OR REPLACE"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "99494da8845c64262edd974d1032f86dc7bb7e6e", "author": {"user": {"login": "agavra", "name": "Almog Gavra"}}, "url": "https://github.com/confluentinc/ksql/commit/99494da8845c64262edd974d1032f86dc7bb7e6e", "committedDate": "2020-06-16T17:30:31Z", "message": "docs: address comments"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "7291b890e53e2bbd7c90cf79f0a18b6a54a5e13b", "author": {"user": {"login": "agavra", "name": "Almog Gavra"}}, "url": "https://github.com/confluentinc/ksql/commit/7291b890e53e2bbd7c90cf79f0a18b6a54a5e13b", "committedDate": "2020-06-16T17:29:22Z", "message": "docs: KLIP-28 introduce CREATE OR REPLACE"}, "afterCommit": {"oid": "99494da8845c64262edd974d1032f86dc7bb7e6e", "author": {"user": {"login": "agavra", "name": "Almog Gavra"}}, "url": "https://github.com/confluentinc/ksql/commit/99494da8845c64262edd974d1032f86dc7bb7e6e", "committedDate": "2020-06-16T17:30:31Z", "message": "docs: address comments"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM1OTgzMTQx", "url": "https://github.com/confluentinc/ksql/pull/5611#pullrequestreview-435983141", "createdAt": "2020-06-23T17:06:07Z", "commit": {"oid": "99494da8845c64262edd974d1032f86dc7bb7e6e"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM1OTg2ODcz", "url": "https://github.com/confluentinc/ksql/pull/5611#pullrequestreview-435986873", "createdAt": "2020-06-23T17:10:56Z", "commit": {"oid": "99494da8845c64262edd974d1032f86dc7bb7e6e"}, "state": "APPROVED", "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yM1QxNzoxMDo1NlrOGnywwQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yM1QxNzoxMjo0MlrOGny0sA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDM3OTMyOQ==", "bodyText": "What's an example of this? Changing the number of streams threads, and other streams properties?\nWhat about changing parameters such as the number of output partitions -- and other properties from the \"WITH\" clause, such as output format? Will that be supported?", "url": "https://github.com/confluentinc/ksql/pull/5611#discussion_r444379329", "createdAt": "2020-06-23T17:10:56Z", "author": {"login": "vcrfxia"}, "path": "design-proposals/klip-28-create-or-replace.md", "diffHunk": "@@ -0,0 +1,200 @@\n+# KLIP 28 - Introduce CREATE OR REPLACE\n+\n+**Author**: agavra | \n+**Release Target**: 0.11 | \n+**Status**: _In Discussion_ | \n+**Discussion**: _link to the design discussion PR_\n+\n+**tl;dr:** _CREATE OR REPLACE is a mechanism geared toward enabling in-place ksqlDB query evolution._\n+           \n+## Motivation and background\n+\n+Production deployments of databases are never static; they evolve as application and business \n+requirements change. To that end, all popular data stores have ways of managing and manipulating \n+existing data. For stream processing applications, a user may want to modify their application as \n+a result of:\n+\n+- Business Requirements: requirements simply change over time\n+- Schema Evolution: the incoming data or required output has been modified\n+- Optimizations: the same application can be executed more efficiently (either by user or engine)\n+\n+At time of writing, ksqlDB provides a crude mechanism for altering its application behavior: dropping \n+a query and restarting it at the earliest or latest offset. While this often works well in development \n+environments, there are limitations to its applicability in production:\n+\n+- Data Retention: the earliest available offset may not correspond with the beginning of time\n+- Downtime: the delta between terminating and catch-up may be out of the application\u2019s SLO\n+- Output Routing: populating to the old output topic will produce duplicates while using a new output topic will require cascading migrations\n+- Compute: recomputing the complete history for a query may not be feasible\n+\n+Kafka Streams provides more granular mechanisms (e.g. restarting queries with different behaviors \n+but identical consumer groups), but these methods burden users with extra complexity and lack guardrails.\n+\n+## Scope\n+\n+To better understand the scope of this KLIP and any future improvements, we define a taxonomy on \n+query upgrades as any combination of three types of characteristics: **source query, upgrade** and\n+(optionally) **environment**:\n+\n+| **Category** | **Characteristic** | **Description** |\n+|----------|----------------|-------------|\n+| Query | Stateful | Stateful queries maintain local storage |\n+| | Windowed | Windowed queries maintain a limited amount of state specified by a window in time\n+| | Joined | Joined queries read from multiple sources\n+| | Multistage | Multistage queries contain intermediate, non-user visible topics in Kafka\n+| | Nondeterministic | Nondeterministic queries may produce different results when executing identical input\n+| | Simple | Queries with none of the above characteristics\n+| Upgrade | Transparent | Transparent upgrades change the way something is computer (e.g. improving a UDF performance)\n+| | Data Selection | Data selecting query upgrades change which/how many events are emitted\n+| | Schema Evolution | Schema evolving query upgrades change the output type of the data |\n+| | Source Modifying | These upgrades change the source data, whether by means of modifying a JOIN or swapping out a source |\n+| | Topology | These upgrades are invisible to the user, but change the topology, such as the number of sub-topologies or the ordering of operations (e.g. filter push down) |\n+| | Scaling | Scaling upgrades change the physical properties of the query in order to enable better performance characteristics. |", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "99494da8845c64262edd974d1032f86dc7bb7e6e"}, "originalPosition": 52}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDM3OTUxOQ==", "bodyText": "\"No plans to implement these migrations\" at this time, or ever?", "url": "https://github.com/confluentinc/ksql/pull/5611#discussion_r444379519", "createdAt": "2020-06-23T17:11:16Z", "author": {"login": "vcrfxia"}, "path": "design-proposals/klip-28-create-or-replace.md", "diffHunk": "@@ -0,0 +1,200 @@\n+# KLIP 28 - Introduce CREATE OR REPLACE\n+\n+**Author**: agavra | \n+**Release Target**: 0.11 | \n+**Status**: _In Discussion_ | \n+**Discussion**: _link to the design discussion PR_\n+\n+**tl;dr:** _CREATE OR REPLACE is a mechanism geared toward enabling in-place ksqlDB query evolution._\n+           \n+## Motivation and background\n+\n+Production deployments of databases are never static; they evolve as application and business \n+requirements change. To that end, all popular data stores have ways of managing and manipulating \n+existing data. For stream processing applications, a user may want to modify their application as \n+a result of:\n+\n+- Business Requirements: requirements simply change over time\n+- Schema Evolution: the incoming data or required output has been modified\n+- Optimizations: the same application can be executed more efficiently (either by user or engine)\n+\n+At time of writing, ksqlDB provides a crude mechanism for altering its application behavior: dropping \n+a query and restarting it at the earliest or latest offset. While this often works well in development \n+environments, there are limitations to its applicability in production:\n+\n+- Data Retention: the earliest available offset may not correspond with the beginning of time\n+- Downtime: the delta between terminating and catch-up may be out of the application\u2019s SLO\n+- Output Routing: populating to the old output topic will produce duplicates while using a new output topic will require cascading migrations\n+- Compute: recomputing the complete history for a query may not be feasible\n+\n+Kafka Streams provides more granular mechanisms (e.g. restarting queries with different behaviors \n+but identical consumer groups), but these methods burden users with extra complexity and lack guardrails.\n+\n+## Scope\n+\n+To better understand the scope of this KLIP and any future improvements, we define a taxonomy on \n+query upgrades as any combination of three types of characteristics: **source query, upgrade** and\n+(optionally) **environment**:\n+\n+| **Category** | **Characteristic** | **Description** |\n+|----------|----------------|-------------|\n+| Query | Stateful | Stateful queries maintain local storage |\n+| | Windowed | Windowed queries maintain a limited amount of state specified by a window in time\n+| | Joined | Joined queries read from multiple sources\n+| | Multistage | Multistage queries contain intermediate, non-user visible topics in Kafka\n+| | Nondeterministic | Nondeterministic queries may produce different results when executing identical input\n+| | Simple | Queries with none of the above characteristics\n+| Upgrade | Transparent | Transparent upgrades change the way something is computer (e.g. improving a UDF performance)\n+| | Data Selection | Data selecting query upgrades change which/how many events are emitted\n+| | Schema Evolution | Schema evolving query upgrades change the output type of the data |\n+| | Source Modifying | These upgrades change the source data, whether by means of modifying a JOIN or swapping out a source |\n+| | Topology | These upgrades are invisible to the user, but change the topology, such as the number of sub-topologies or the ordering of operations (e.g. filter push down) |\n+| | Scaling | Scaling upgrades change the physical properties of the query in order to enable better performance characteristics. |\n+| | Unsupported | Unsupported upgrades are ones that will semantically change the query in an unsupported way. There are no plans to implement these migrations. |", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "99494da8845c64262edd974d1032f86dc7bb7e6e"}, "originalPosition": 53}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDM3OTgyOA==", "bodyText": "Does this mean the only thing that's supported is adding fields? What about reordering fields? Reordering fields would be breaking in the case of DELIMITED.", "url": "https://github.com/confluentinc/ksql/pull/5611#discussion_r444379828", "createdAt": "2020-06-23T17:11:49Z", "author": {"login": "vcrfxia"}, "path": "design-proposals/klip-28-create-or-replace.md", "diffHunk": "@@ -0,0 +1,200 @@\n+# KLIP 28 - Introduce CREATE OR REPLACE\n+\n+**Author**: agavra | \n+**Release Target**: 0.11 | \n+**Status**: _In Discussion_ | \n+**Discussion**: _link to the design discussion PR_\n+\n+**tl;dr:** _CREATE OR REPLACE is a mechanism geared toward enabling in-place ksqlDB query evolution._\n+           \n+## Motivation and background\n+\n+Production deployments of databases are never static; they evolve as application and business \n+requirements change. To that end, all popular data stores have ways of managing and manipulating \n+existing data. For stream processing applications, a user may want to modify their application as \n+a result of:\n+\n+- Business Requirements: requirements simply change over time\n+- Schema Evolution: the incoming data or required output has been modified\n+- Optimizations: the same application can be executed more efficiently (either by user or engine)\n+\n+At time of writing, ksqlDB provides a crude mechanism for altering its application behavior: dropping \n+a query and restarting it at the earliest or latest offset. While this often works well in development \n+environments, there are limitations to its applicability in production:\n+\n+- Data Retention: the earliest available offset may not correspond with the beginning of time\n+- Downtime: the delta between terminating and catch-up may be out of the application\u2019s SLO\n+- Output Routing: populating to the old output topic will produce duplicates while using a new output topic will require cascading migrations\n+- Compute: recomputing the complete history for a query may not be feasible\n+\n+Kafka Streams provides more granular mechanisms (e.g. restarting queries with different behaviors \n+but identical consumer groups), but these methods burden users with extra complexity and lack guardrails.\n+\n+## Scope\n+\n+To better understand the scope of this KLIP and any future improvements, we define a taxonomy on \n+query upgrades as any combination of three types of characteristics: **source query, upgrade** and\n+(optionally) **environment**:\n+\n+| **Category** | **Characteristic** | **Description** |\n+|----------|----------------|-------------|\n+| Query | Stateful | Stateful queries maintain local storage |\n+| | Windowed | Windowed queries maintain a limited amount of state specified by a window in time\n+| | Joined | Joined queries read from multiple sources\n+| | Multistage | Multistage queries contain intermediate, non-user visible topics in Kafka\n+| | Nondeterministic | Nondeterministic queries may produce different results when executing identical input\n+| | Simple | Queries with none of the above characteristics\n+| Upgrade | Transparent | Transparent upgrades change the way something is computer (e.g. improving a UDF performance)\n+| | Data Selection | Data selecting query upgrades change which/how many events are emitted\n+| | Schema Evolution | Schema evolving query upgrades change the output type of the data |\n+| | Source Modifying | These upgrades change the source data, whether by means of modifying a JOIN or swapping out a source |\n+| | Topology | These upgrades are invisible to the user, but change the topology, such as the number of sub-topologies or the ordering of operations (e.g. filter push down) |\n+| | Scaling | Scaling upgrades change the physical properties of the query in order to enable better performance characteristics. |\n+| | Unsupported | Unsupported upgrades are ones that will semantically change the query in an unsupported way. There are no plans to implement these migrations. |\n+| Environment | Backfill | Backfill requires the output data to be accurate not just from a point in time, but from the earliest point of retained history |\n+| | Cascading | Cascading environments contain queries that are not terminal, but rather feed into downstream stream processing tasks |\n+| | Exactly Once | Exactly Once environments do not allow for data duplication or missed events |\n+| | Ordered | Ordered environments require that a single offset delineates pre- and post-migration (no events are interleaved) |\n+| | Live | Live environments describe queries that cannot afford downtime, either by means of acting as live storage (e.g. responding to pull queries) or feeding into high availability systems (powering important functionality) |\n+\n+### What is in scope\n+\n+- Specify a syntax that can support arbitrary upgrades\n+- Design a validator to fail unsupported upgrades\n+- Design a mechanism for upgrading queries under limited scope\n+\n+### What is not in scope\n+\n+The Design section below enumerates which upgrades are out of scope\n+\n+## Value/Return\n+\n+This KLIP will represent a significant step forward in the operability of ksqlDB in production, as\n+noted in the background and motivation section.\n+\n+## Public APIS\n+\n+The syntax `CREATE OR REPLACE (STREAM | TABLE) source_name WITH (key=value, ...) AS query;` will be\n+introduced to allow users to specify an existing stream or table to replace with a new query that\n+will resume from the same processing point as any previously existing query.\n+\n+## Design\n+\n+If the `source_name` does not yet exist, a `CREATE OR REPLACE` statement functions identically to\n+a normal `CREATE` statement. Otherwise, ksqlDB executes the following:\n+\n+1. Identify the original `queryID` that populates the source (`INSERT INTO` discussed later)\n+2. Ensure the upgrade is valid\n+3. Terminate `queryID`\n+4. Start the new query under the same `queryID`\n+\n+A few changes need to happen in order to make this work. For 1, we need to maintain a mapping from\n+source to queryID(s). If the source has multiple associated ids (in the case of `INSERT INTO`) then\n+the upgrade will fail and not terminate any queries.\n+\n+For step 2, there will be a component to determine whether two topologies are \"upgrade\n+compatible\"; the first iterations, which will be delivered as part of this KLIP, will only allow\n+for the most basic upgrades: \n+\n+- Any _transparent_ upgrade will be supported\n+- Any _data selection_ upgrade will be supported\n+- _Schema evolution_ upgrades will be supported on simple and stateful queries, but it will be\n+    communicated that the users will not get `backfill` or `ordered` properties for stateful.\n+- _Source modifying_ upgrades will not be supported\n+- _Topology changes_ will not be supported\n+\n+Note that _Schema Evolution_ compatibility is defined by the limitations of the serialization\n+format that is used with the added restrictions against removing fields and changing types to ensure", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "99494da8845c64262edd974d1032f86dc7bb7e6e"}, "originalPosition": 107}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDM4MDExNA==", "bodyText": "Is this true? Wouldn't adding a field would break downstream queries in the case of DELIMITED?", "url": "https://github.com/confluentinc/ksql/pull/5611#discussion_r444380114", "createdAt": "2020-06-23T17:12:21Z", "author": {"login": "vcrfxia"}, "path": "design-proposals/klip-28-create-or-replace.md", "diffHunk": "@@ -0,0 +1,200 @@\n+# KLIP 28 - Introduce CREATE OR REPLACE\n+\n+**Author**: agavra | \n+**Release Target**: 0.11 | \n+**Status**: _In Discussion_ | \n+**Discussion**: _link to the design discussion PR_\n+\n+**tl;dr:** _CREATE OR REPLACE is a mechanism geared toward enabling in-place ksqlDB query evolution._\n+           \n+## Motivation and background\n+\n+Production deployments of databases are never static; they evolve as application and business \n+requirements change. To that end, all popular data stores have ways of managing and manipulating \n+existing data. For stream processing applications, a user may want to modify their application as \n+a result of:\n+\n+- Business Requirements: requirements simply change over time\n+- Schema Evolution: the incoming data or required output has been modified\n+- Optimizations: the same application can be executed more efficiently (either by user or engine)\n+\n+At time of writing, ksqlDB provides a crude mechanism for altering its application behavior: dropping \n+a query and restarting it at the earliest or latest offset. While this often works well in development \n+environments, there are limitations to its applicability in production:\n+\n+- Data Retention: the earliest available offset may not correspond with the beginning of time\n+- Downtime: the delta between terminating and catch-up may be out of the application\u2019s SLO\n+- Output Routing: populating to the old output topic will produce duplicates while using a new output topic will require cascading migrations\n+- Compute: recomputing the complete history for a query may not be feasible\n+\n+Kafka Streams provides more granular mechanisms (e.g. restarting queries with different behaviors \n+but identical consumer groups), but these methods burden users with extra complexity and lack guardrails.\n+\n+## Scope\n+\n+To better understand the scope of this KLIP and any future improvements, we define a taxonomy on \n+query upgrades as any combination of three types of characteristics: **source query, upgrade** and\n+(optionally) **environment**:\n+\n+| **Category** | **Characteristic** | **Description** |\n+|----------|----------------|-------------|\n+| Query | Stateful | Stateful queries maintain local storage |\n+| | Windowed | Windowed queries maintain a limited amount of state specified by a window in time\n+| | Joined | Joined queries read from multiple sources\n+| | Multistage | Multistage queries contain intermediate, non-user visible topics in Kafka\n+| | Nondeterministic | Nondeterministic queries may produce different results when executing identical input\n+| | Simple | Queries with none of the above characteristics\n+| Upgrade | Transparent | Transparent upgrades change the way something is computer (e.g. improving a UDF performance)\n+| | Data Selection | Data selecting query upgrades change which/how many events are emitted\n+| | Schema Evolution | Schema evolving query upgrades change the output type of the data |\n+| | Source Modifying | These upgrades change the source data, whether by means of modifying a JOIN or swapping out a source |\n+| | Topology | These upgrades are invisible to the user, but change the topology, such as the number of sub-topologies or the ordering of operations (e.g. filter push down) |\n+| | Scaling | Scaling upgrades change the physical properties of the query in order to enable better performance characteristics. |\n+| | Unsupported | Unsupported upgrades are ones that will semantically change the query in an unsupported way. There are no plans to implement these migrations. |\n+| Environment | Backfill | Backfill requires the output data to be accurate not just from a point in time, but from the earliest point of retained history |\n+| | Cascading | Cascading environments contain queries that are not terminal, but rather feed into downstream stream processing tasks |\n+| | Exactly Once | Exactly Once environments do not allow for data duplication or missed events |\n+| | Ordered | Ordered environments require that a single offset delineates pre- and post-migration (no events are interleaved) |\n+| | Live | Live environments describe queries that cannot afford downtime, either by means of acting as live storage (e.g. responding to pull queries) or feeding into high availability systems (powering important functionality) |\n+\n+### What is in scope\n+\n+- Specify a syntax that can support arbitrary upgrades\n+- Design a validator to fail unsupported upgrades\n+- Design a mechanism for upgrading queries under limited scope\n+\n+### What is not in scope\n+\n+The Design section below enumerates which upgrades are out of scope\n+\n+## Value/Return\n+\n+This KLIP will represent a significant step forward in the operability of ksqlDB in production, as\n+noted in the background and motivation section.\n+\n+## Public APIS\n+\n+The syntax `CREATE OR REPLACE (STREAM | TABLE) source_name WITH (key=value, ...) AS query;` will be\n+introduced to allow users to specify an existing stream or table to replace with a new query that\n+will resume from the same processing point as any previously existing query.\n+\n+## Design\n+\n+If the `source_name` does not yet exist, a `CREATE OR REPLACE` statement functions identically to\n+a normal `CREATE` statement. Otherwise, ksqlDB executes the following:\n+\n+1. Identify the original `queryID` that populates the source (`INSERT INTO` discussed later)\n+2. Ensure the upgrade is valid\n+3. Terminate `queryID`\n+4. Start the new query under the same `queryID`\n+\n+A few changes need to happen in order to make this work. For 1, we need to maintain a mapping from\n+source to queryID(s). If the source has multiple associated ids (in the case of `INSERT INTO`) then\n+the upgrade will fail and not terminate any queries.\n+\n+For step 2, there will be a component to determine whether two topologies are \"upgrade\n+compatible\"; the first iterations, which will be delivered as part of this KLIP, will only allow\n+for the most basic upgrades: \n+\n+- Any _transparent_ upgrade will be supported\n+- Any _data selection_ upgrade will be supported\n+- _Schema evolution_ upgrades will be supported on simple and stateful queries, but it will be\n+    communicated that the users will not get `backfill` or `ordered` properties for stateful.\n+- _Source modifying_ upgrades will not be supported\n+- _Topology changes_ will not be supported\n+\n+Note that _Schema Evolution_ compatibility is defined by the limitations of the serialization\n+format that is used with the added restrictions against removing fields and changing types to ensure\n+referential integrity of ksqlDB tables. This way, downstream query output schemas willn not be affected", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "99494da8845c64262edd974d1032f86dc7bb7e6e"}, "originalPosition": 108}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDM4MDE1Nw==", "bodyText": "Cool!", "url": "https://github.com/confluentinc/ksql/pull/5611#discussion_r444380157", "createdAt": "2020-06-23T17:12:25Z", "author": {"login": "vcrfxia"}, "path": "design-proposals/klip-28-create-or-replace.md", "diffHunk": "@@ -0,0 +1,200 @@\n+# KLIP 28 - Introduce CREATE OR REPLACE\n+\n+**Author**: agavra | \n+**Release Target**: 0.11 | \n+**Status**: _In Discussion_ | \n+**Discussion**: _link to the design discussion PR_\n+\n+**tl;dr:** _CREATE OR REPLACE is a mechanism geared toward enabling in-place ksqlDB query evolution._\n+           \n+## Motivation and background\n+\n+Production deployments of databases are never static; they evolve as application and business \n+requirements change. To that end, all popular data stores have ways of managing and manipulating \n+existing data. For stream processing applications, a user may want to modify their application as \n+a result of:\n+\n+- Business Requirements: requirements simply change over time\n+- Schema Evolution: the incoming data or required output has been modified\n+- Optimizations: the same application can be executed more efficiently (either by user or engine)\n+\n+At time of writing, ksqlDB provides a crude mechanism for altering its application behavior: dropping \n+a query and restarting it at the earliest or latest offset. While this often works well in development \n+environments, there are limitations to its applicability in production:\n+\n+- Data Retention: the earliest available offset may not correspond with the beginning of time\n+- Downtime: the delta between terminating and catch-up may be out of the application\u2019s SLO\n+- Output Routing: populating to the old output topic will produce duplicates while using a new output topic will require cascading migrations\n+- Compute: recomputing the complete history for a query may not be feasible\n+\n+Kafka Streams provides more granular mechanisms (e.g. restarting queries with different behaviors \n+but identical consumer groups), but these methods burden users with extra complexity and lack guardrails.\n+\n+## Scope\n+\n+To better understand the scope of this KLIP and any future improvements, we define a taxonomy on \n+query upgrades as any combination of three types of characteristics: **source query, upgrade** and\n+(optionally) **environment**:\n+\n+| **Category** | **Characteristic** | **Description** |\n+|----------|----------------|-------------|\n+| Query | Stateful | Stateful queries maintain local storage |\n+| | Windowed | Windowed queries maintain a limited amount of state specified by a window in time\n+| | Joined | Joined queries read from multiple sources\n+| | Multistage | Multistage queries contain intermediate, non-user visible topics in Kafka\n+| | Nondeterministic | Nondeterministic queries may produce different results when executing identical input\n+| | Simple | Queries with none of the above characteristics\n+| Upgrade | Transparent | Transparent upgrades change the way something is computer (e.g. improving a UDF performance)\n+| | Data Selection | Data selecting query upgrades change which/how many events are emitted\n+| | Schema Evolution | Schema evolving query upgrades change the output type of the data |\n+| | Source Modifying | These upgrades change the source data, whether by means of modifying a JOIN or swapping out a source |\n+| | Topology | These upgrades are invisible to the user, but change the topology, such as the number of sub-topologies or the ordering of operations (e.g. filter push down) |\n+| | Scaling | Scaling upgrades change the physical properties of the query in order to enable better performance characteristics. |\n+| | Unsupported | Unsupported upgrades are ones that will semantically change the query in an unsupported way. There are no plans to implement these migrations. |\n+| Environment | Backfill | Backfill requires the output data to be accurate not just from a point in time, but from the earliest point of retained history |\n+| | Cascading | Cascading environments contain queries that are not terminal, but rather feed into downstream stream processing tasks |\n+| | Exactly Once | Exactly Once environments do not allow for data duplication or missed events |\n+| | Ordered | Ordered environments require that a single offset delineates pre- and post-migration (no events are interleaved) |\n+| | Live | Live environments describe queries that cannot afford downtime, either by means of acting as live storage (e.g. responding to pull queries) or feeding into high availability systems (powering important functionality) |\n+\n+### What is in scope\n+\n+- Specify a syntax that can support arbitrary upgrades\n+- Design a validator to fail unsupported upgrades\n+- Design a mechanism for upgrading queries under limited scope\n+\n+### What is not in scope\n+\n+The Design section below enumerates which upgrades are out of scope\n+\n+## Value/Return\n+\n+This KLIP will represent a significant step forward in the operability of ksqlDB in production, as\n+noted in the background and motivation section.\n+\n+## Public APIS\n+\n+The syntax `CREATE OR REPLACE (STREAM | TABLE) source_name WITH (key=value, ...) AS query;` will be\n+introduced to allow users to specify an existing stream or table to replace with a new query that\n+will resume from the same processing point as any previously existing query.\n+\n+## Design\n+\n+If the `source_name` does not yet exist, a `CREATE OR REPLACE` statement functions identically to\n+a normal `CREATE` statement. Otherwise, ksqlDB executes the following:\n+\n+1. Identify the original `queryID` that populates the source (`INSERT INTO` discussed later)\n+2. Ensure the upgrade is valid\n+3. Terminate `queryID`\n+4. Start the new query under the same `queryID`\n+\n+A few changes need to happen in order to make this work. For 1, we need to maintain a mapping from\n+source to queryID(s). If the source has multiple associated ids (in the case of `INSERT INTO`) then\n+the upgrade will fail and not terminate any queries.\n+\n+For step 2, there will be a component to determine whether two topologies are \"upgrade\n+compatible\"; the first iterations, which will be delivered as part of this KLIP, will only allow\n+for the most basic upgrades: \n+\n+- Any _transparent_ upgrade will be supported\n+- Any _data selection_ upgrade will be supported\n+- _Schema evolution_ upgrades will be supported on simple and stateful queries, but it will be\n+    communicated that the users will not get `backfill` or `ordered` properties for stateful.\n+- _Source modifying_ upgrades will not be supported\n+- _Topology changes_ will not be supported\n+\n+Note that _Schema Evolution_ compatibility is defined by the limitations of the serialization\n+format that is used with the added restrictions against removing fields and changing types to ensure\n+referential integrity of ksqlDB tables. This way, downstream query output schemas willn not be affected\n+by upstream schema evolution.\n+\n+There are currently discussions that discuss how to expand the support of some of these upgrades,\n+but we believe there is value in supporting the limitted set described above.\n+\n+For step 4, we need to be able to generate queryIDs differently for `CREATE OR REPLACE` statements\n+than for others (i.e. it shouldn't just be the offset of the command, but rather the same queryID \n+as the original query.) One simple way to implement this is to allow the queryID to be specified\n+in the command topic. Since the engine receiving the request has a complete view of the engine\n+metadata, it can determine the queryID to enqueue onto the command topic.\n+\n+### On \"INSERT INTO\"\n+\n+Insert into can eventually be replaced with `UNION` as proposed in [KLIP-17](https://github.com/confluentinc/ksql/pull/4125),\n+but that must happen in lock-step with this proposal. At first, we will support `CREATE OR REPLACE`\n+and `INSERT INTO`. Then, we will add support for `UNION`, allowing us to model consecutive `INSERT INTO`\n+statements as replacing unions with larger unions (essentially adding an extra source to the union).", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "99494da8845c64262edd974d1032f86dc7bb7e6e"}, "originalPosition": 125}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDM4MDMzNg==", "bodyText": "super nit:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            | Upgrade | Transparent | Transparent upgrades change the way something is computer (e.g. improving a UDF performance)\n          \n          \n            \n            | Upgrade | Transparent | Transparent upgrades change the way something is computed (e.g. improving a UDF performance)", "url": "https://github.com/confluentinc/ksql/pull/5611#discussion_r444380336", "createdAt": "2020-06-23T17:12:42Z", "author": {"login": "vcrfxia"}, "path": "design-proposals/klip-28-create-or-replace.md", "diffHunk": "@@ -0,0 +1,200 @@\n+# KLIP 28 - Introduce CREATE OR REPLACE\n+\n+**Author**: agavra | \n+**Release Target**: 0.11 | \n+**Status**: _In Discussion_ | \n+**Discussion**: _link to the design discussion PR_\n+\n+**tl;dr:** _CREATE OR REPLACE is a mechanism geared toward enabling in-place ksqlDB query evolution._\n+           \n+## Motivation and background\n+\n+Production deployments of databases are never static; they evolve as application and business \n+requirements change. To that end, all popular data stores have ways of managing and manipulating \n+existing data. For stream processing applications, a user may want to modify their application as \n+a result of:\n+\n+- Business Requirements: requirements simply change over time\n+- Schema Evolution: the incoming data or required output has been modified\n+- Optimizations: the same application can be executed more efficiently (either by user or engine)\n+\n+At time of writing, ksqlDB provides a crude mechanism for altering its application behavior: dropping \n+a query and restarting it at the earliest or latest offset. While this often works well in development \n+environments, there are limitations to its applicability in production:\n+\n+- Data Retention: the earliest available offset may not correspond with the beginning of time\n+- Downtime: the delta between terminating and catch-up may be out of the application\u2019s SLO\n+- Output Routing: populating to the old output topic will produce duplicates while using a new output topic will require cascading migrations\n+- Compute: recomputing the complete history for a query may not be feasible\n+\n+Kafka Streams provides more granular mechanisms (e.g. restarting queries with different behaviors \n+but identical consumer groups), but these methods burden users with extra complexity and lack guardrails.\n+\n+## Scope\n+\n+To better understand the scope of this KLIP and any future improvements, we define a taxonomy on \n+query upgrades as any combination of three types of characteristics: **source query, upgrade** and\n+(optionally) **environment**:\n+\n+| **Category** | **Characteristic** | **Description** |\n+|----------|----------------|-------------|\n+| Query | Stateful | Stateful queries maintain local storage |\n+| | Windowed | Windowed queries maintain a limited amount of state specified by a window in time\n+| | Joined | Joined queries read from multiple sources\n+| | Multistage | Multistage queries contain intermediate, non-user visible topics in Kafka\n+| | Nondeterministic | Nondeterministic queries may produce different results when executing identical input\n+| | Simple | Queries with none of the above characteristics\n+| Upgrade | Transparent | Transparent upgrades change the way something is computer (e.g. improving a UDF performance)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "99494da8845c64262edd974d1032f86dc7bb7e6e"}, "originalPosition": 47}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "fb67282746a8dacfc0128bc4b838eb427fa307aa", "author": {"user": {"login": "agavra", "name": "Almog Gavra"}}, "url": "https://github.com/confluentinc/ksql/commit/fb67282746a8dacfc0128bc4b838eb427fa307aa", "committedDate": "2020-06-23T17:39:51Z", "message": "Update design-proposals/klip-28-create-or-replace.md\n\nCo-authored-by: Victoria Xia <victoria.f.xia281@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e1816f3333083c41e8c7146118a4ae26e06bd4ac", "author": {"user": {"login": "agavra", "name": "Almog Gavra"}}, "url": "https://github.com/confluentinc/ksql/commit/e1816f3333083c41e8c7146118a4ae26e06bd4ac", "committedDate": "2020-06-23T17:42:01Z", "message": "Update klip-28-create-or-replace.md"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM2NzQ5Nzc5", "url": "https://github.com/confluentinc/ksql/pull/5611#pullrequestreview-436749779", "createdAt": "2020-06-24T15:15:55Z", "commit": {"oid": "e1816f3333083c41e8c7146118a4ae26e06bd4ac"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNFQxNToxNTo1NVrOGoW7qQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNFQxNToxNTo1NVrOGoW7qQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDk3MTk0NQ==", "bodyText": "Not just removing fields, but also renaming fields.", "url": "https://github.com/confluentinc/ksql/pull/5611#discussion_r444971945", "createdAt": "2020-06-24T15:15:55Z", "author": {"login": "big-andy-coates"}, "path": "design-proposals/klip-28-create-or-replace.md", "diffHunk": "@@ -0,0 +1,200 @@\n+# KLIP 28 - Introduce CREATE OR REPLACE\n+\n+**Author**: agavra | \n+**Release Target**: 0.11 | \n+**Status**: _Approved_ | \n+**Discussion**: _https://github.com/confluentinc/ksql/pull/5611_\n+\n+**tl;dr:** _CREATE OR REPLACE is a mechanism geared toward enabling in-place ksqlDB query evolution._\n+           \n+## Motivation and background\n+\n+Production deployments of databases are never static; they evolve as application and business \n+requirements change. To that end, all popular data stores have ways of managing and manipulating \n+existing data. For stream processing applications, a user may want to modify their application as \n+a result of:\n+\n+- Business Requirements: requirements simply change over time\n+- Schema Evolution: the incoming data or required output has been modified\n+- Optimizations: the same application can be executed more efficiently (either by user or engine)\n+\n+At time of writing, ksqlDB provides a crude mechanism for altering its application behavior: dropping \n+a query and restarting it at the earliest or latest offset. While this often works well in development \n+environments, there are limitations to its applicability in production:\n+\n+- Data Retention: the earliest available offset may not correspond with the beginning of time\n+- Downtime: the delta between terminating and catch-up may be out of the application\u2019s SLO\n+- Output Routing: populating to the old output topic will produce duplicates while using a new output topic will require cascading migrations\n+- Compute: recomputing the complete history for a query may not be feasible\n+\n+Kafka Streams provides more granular mechanisms (e.g. restarting queries with different behaviors \n+but identical consumer groups), but these methods burden users with extra complexity and lack guardrails.\n+\n+## Scope\n+\n+To better understand the scope of this KLIP and any future improvements, we define a taxonomy on \n+query upgrades as any combination of three types of characteristics: **source query, upgrade** and\n+(optionally) **environment**:\n+\n+| **Category** | **Characteristic** | **Description** |\n+|----------|----------------|-------------|\n+| Query | Stateful | Stateful queries maintain local storage |\n+| | Windowed | Windowed queries maintain a limited amount of state specified by a window in time\n+| | Joined | Joined queries read from multiple sources\n+| | Multistage | Multistage queries contain intermediate, non-user visible topics in Kafka\n+| | Nondeterministic | Nondeterministic queries may produce different results when executing identical input\n+| | Simple | Queries with none of the above characteristics\n+| Upgrade | Transparent | Transparent upgrades change the way something is computed (e.g. improving a UDF performance)\n+| | Data Selection | Data selecting query upgrades change which/how many events are emitted\n+| | Schema Evolution | Schema evolving query upgrades change the output type of the data |\n+| | Source Modifying | These upgrades change the source data, whether by means of modifying a JOIN or swapping out a source |\n+| | Topology | These upgrades are invisible to the user, but change the topology, such as the number of sub-topologies or the ordering of operations (e.g. filter push down) |\n+| | Scaling | Scaling upgrades change the physical properties of the query in order to enable better performance characteristics. |\n+| | Unsupported | Unsupported upgrades are ones that will semantically change the query in an unsupported way. There are no plans to implement these migrations. |\n+| Environment | Backfill | Backfill requires the output data to be accurate not just from a point in time, but from the earliest point of retained history |\n+| | Cascading | Cascading environments contain queries that are not terminal, but rather feed into downstream stream processing tasks |\n+| | Exactly Once | Exactly Once environments do not allow for data duplication or missed events |\n+| | Ordered | Ordered environments require that a single offset delineates pre- and post-migration (no events are interleaved) |\n+| | Live | Live environments describe queries that cannot afford downtime, either by means of acting as live storage (e.g. responding to pull queries) or feeding into high availability systems (powering important functionality) |\n+\n+### What is in scope\n+\n+- Specify a syntax that can support arbitrary upgrades\n+- Design a validator to fail unsupported upgrades\n+- Design a mechanism for upgrading queries under limited scope\n+\n+### What is not in scope\n+\n+The Design section below enumerates which upgrades are out of scope\n+\n+## Value/Return\n+\n+This KLIP will represent a significant step forward in the operability of ksqlDB in production, as\n+noted in the background and motivation section.\n+\n+## Public APIS\n+\n+The syntax `CREATE OR REPLACE (STREAM | TABLE) source_name WITH (key=value, ...) AS query;` will be\n+introduced to allow users to specify an existing stream or table to replace with a new query that\n+will resume from the same processing point as any previously existing query.\n+\n+## Design\n+\n+If the `source_name` does not yet exist, a `CREATE OR REPLACE` statement functions identically to\n+a normal `CREATE` statement. Otherwise, ksqlDB executes the following:\n+\n+1. Identify the original `queryID` that populates the source (`INSERT INTO` discussed later)\n+2. Ensure the upgrade is valid\n+3. Terminate `queryID`\n+4. Start the new query under the same `queryID`\n+\n+A few changes need to happen in order to make this work. For 1, we need to maintain a mapping from\n+source to queryID(s). If the source has multiple associated ids (in the case of `INSERT INTO`) then\n+the upgrade will fail and not terminate any queries.\n+\n+For step 2, there will be a component to determine whether two topologies are \"upgrade\n+compatible\"; the first iterations, which will be delivered as part of this KLIP, will only allow\n+for the most basic upgrades: \n+\n+- Any _transparent_ upgrade will be supported\n+- Any _data selection_ upgrade will be supported\n+- _Schema evolution_ upgrades will be supported on simple and stateful queries, but it will be\n+    communicated that the users will not get `backfill` or `ordered` properties for stateful.\n+- _Source modifying_ upgrades will not be supported\n+- _Topology changes_ will not be supported\n+\n+Note that _Schema Evolution_ compatibility is defined by the limitations of the serialization\n+format that is used with the added restrictions against removing fields and changing types to ensure", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e1816f3333083c41e8c7146118a4ae26e06bd4ac"}, "originalPosition": 107}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 197, "cost": 1, "resetAt": "2021-11-01T13:07:16Z"}}}