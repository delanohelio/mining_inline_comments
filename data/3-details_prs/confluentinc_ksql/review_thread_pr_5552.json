{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDI3ODk1ODU3", "number": 5552, "reviewThreads": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNFQyMDowOTo0M1rOECtzwg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNFQyMDoxMTo0MVrOECt2Qg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcxMjgzMTM4OnYy", "diffSide": "RIGHT", "path": "ksqldb-rest-app/src/main/java/io/confluent/ksql/rest/server/resources/streaming/RecordFormatter.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNFQyMDowOTo0M1rOGfWDhA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQwOTozNDo1MlrOGfndpA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTUyMDM4OA==", "bodyText": "Why do call formatRecords here again when you already formatted them at line 110?", "url": "https://github.com/confluentinc/ksql/pull/5552#discussion_r435520388", "createdAt": "2020-06-04T20:09:43Z", "author": {"login": "vpapavas"}, "path": "ksqldb-rest-app/src/main/java/io/confluent/ksql/rest/server/resources/streaming/RecordFormatter.java", "diffHunk": "@@ -103,10 +103,25 @@ public RecordFormatter(\n     this.valueDeserializers = requireNonNull(valueDeserializers, \"valueDeserializers\");\n   }\n \n-  public List<Supplier<String>> format(final Iterable<ConsumerRecord<Bytes, Bytes>> records) {\n-    return StreamSupport.stream(records.spliterator(), false)\n-        .map(this::delayedFormat)\n-        .collect(Collectors.toList());\n+  public List<String> format(final Iterable<ConsumerRecord<Bytes, Bytes>> records) {\n+    final String activeKeyFormat = keyDeserializers.getPossibleFormats().get(0);\n+    final String activeValueFormat = valueDeserializers.getPossibleFormats().get(0);\n+\n+    final List<String> formatted = formatRecords(records);\n+\n+    final boolean sameKeyFormatChanged = activeKeyFormat\n+        .equals(keyDeserializers.getPossibleFormats().get(0));\n+\n+    final boolean sameValueFormatChanged = activeValueFormat\n+        .equals(valueDeserializers.getPossibleFormats().get(0));\n+\n+    if (sameKeyFormatChanged && sameValueFormatChanged) {\n+      return formatted;\n+    }\n+\n+    // The active key/value format has been eliminated as a possibility while processing this batch.\n+    // Reformat with the new active format:\n+    return formatRecords(records);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e323c15c0d7d9b449514abace642f9f10e38f46f"}, "originalPosition": 26}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTgwNTYwNA==", "bodyText": "As the comment says: because the active key or value format has changed during the processing of the batch.\nFor example, if processing the second record in the batch eliminates the KAFKA_BIGINT key format, then the first row, which will have been formatted using KAFKA_BIGINT needs to be processed again, otherwise it will be printed out wrong.\nThis is the whole point of the PR!", "url": "https://github.com/confluentinc/ksql/pull/5552#discussion_r435805604", "createdAt": "2020-06-05T09:34:52Z", "author": {"login": "big-andy-coates"}, "path": "ksqldb-rest-app/src/main/java/io/confluent/ksql/rest/server/resources/streaming/RecordFormatter.java", "diffHunk": "@@ -103,10 +103,25 @@ public RecordFormatter(\n     this.valueDeserializers = requireNonNull(valueDeserializers, \"valueDeserializers\");\n   }\n \n-  public List<Supplier<String>> format(final Iterable<ConsumerRecord<Bytes, Bytes>> records) {\n-    return StreamSupport.stream(records.spliterator(), false)\n-        .map(this::delayedFormat)\n-        .collect(Collectors.toList());\n+  public List<String> format(final Iterable<ConsumerRecord<Bytes, Bytes>> records) {\n+    final String activeKeyFormat = keyDeserializers.getPossibleFormats().get(0);\n+    final String activeValueFormat = valueDeserializers.getPossibleFormats().get(0);\n+\n+    final List<String> formatted = formatRecords(records);\n+\n+    final boolean sameKeyFormatChanged = activeKeyFormat\n+        .equals(keyDeserializers.getPossibleFormats().get(0));\n+\n+    final boolean sameValueFormatChanged = activeValueFormat\n+        .equals(valueDeserializers.getPossibleFormats().get(0));\n+\n+    if (sameKeyFormatChanged && sameValueFormatChanged) {\n+      return formatted;\n+    }\n+\n+    // The active key/value format has been eliminated as a possibility while processing this batch.\n+    // Reformat with the new active format:\n+    return formatRecords(records);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTUyMDM4OA=="}, "originalCommit": {"oid": "e323c15c0d7d9b449514abace642f9f10e38f46f"}, "originalPosition": 26}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcxMjgzNzc4OnYy", "diffSide": "RIGHT", "path": "ksqldb-rest-app/src/main/java/io/confluent/ksql/rest/server/resources/streaming/PrintPublisher.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNFQyMDoxMTo0MVrOGfWHnw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQwOTozNzoxOFrOGfni5w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTUyMTQzOQ==", "bodyText": "This is that sets the batch size? So if it is not set then it is (Integer.MAX_VALUE) - numWritten  where numWritten is what has been processed up to this point?", "url": "https://github.com/confluentinc/ksql/pull/5552#discussion_r435521439", "createdAt": "2020-06-04T20:11:41Z", "author": {"login": "vpapavas"}, "path": "ksqldb-rest-app/src/main/java/io/confluent/ksql/rest/server/resources/streaming/PrintPublisher.java", "diffHunk": "@@ -112,8 +110,8 @@ public void subscribe(final Flow.Subscriber<Collection<String>> subscriber) {\n           return null;\n         }\n \n-        final Collection<Supplier<String>> formatted = formatter.format(records);\n-        final Collection<Supplier<String>> limited = new LimitIntervalCollection<>(\n+        final Collection<String> formatted = formatter.format(records);\n+        final Collection<String> limited = new LimitIntervalCollection<>(\n             formatted,\n             printTopic.getLimit().orElse(Integer.MAX_VALUE) - numWritten,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e323c15c0d7d9b449514abace642f9f10e38f46f"}, "originalPosition": 18}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTgwNjk1MQ==", "bodyText": "If by batch size you're talking about the size of the batch of records pull from Kafka, then no.  That's controlled by the consumer config.\nThis code is only handling any LIMIT statement.", "url": "https://github.com/confluentinc/ksql/pull/5552#discussion_r435806951", "createdAt": "2020-06-05T09:37:18Z", "author": {"login": "big-andy-coates"}, "path": "ksqldb-rest-app/src/main/java/io/confluent/ksql/rest/server/resources/streaming/PrintPublisher.java", "diffHunk": "@@ -112,8 +110,8 @@ public void subscribe(final Flow.Subscriber<Collection<String>> subscriber) {\n           return null;\n         }\n \n-        final Collection<Supplier<String>> formatted = formatter.format(records);\n-        final Collection<Supplier<String>> limited = new LimitIntervalCollection<>(\n+        final Collection<String> formatted = formatter.format(records);\n+        final Collection<String> limited = new LimitIntervalCollection<>(\n             formatted,\n             printTopic.getLimit().orElse(Integer.MAX_VALUE) - numWritten,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTUyMTQzOQ=="}, "originalCommit": {"oid": "e323c15c0d7d9b449514abace642f9f10e38f46f"}, "originalPosition": 18}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3359, "cost": 1, "resetAt": "2021-11-12T19:05:54Z"}}}