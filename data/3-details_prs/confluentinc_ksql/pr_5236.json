{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDExMjY0NTk0", "number": 5236, "title": "docs: add KLIP-26: Java client interfaces", "bodyText": "Description\nAdd KLIP-26: Java client interfaces.\nTesting done\nDocs-only change.\nReviewer checklist\n\n Ensure docs are updated if necessary. (eg. if a user visible feature is being added or changed).\n Ensure relevant issues are linked (description should include text like \"Fixes #\")", "createdAt": "2020-04-30T08:52:09Z", "url": "https://github.com/confluentinc/ksql/pull/5236", "merged": true, "mergeCommit": {"oid": "1dcf1aa9ac9aa31eb8a96821976576062e256395"}, "closed": true, "closedAt": "2020-05-11T16:26:34Z", "author": {"login": "vcrfxia"}, "timelineItems": {"totalCount": 29, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABccpId1gH2gAyNDExMjY0NTk0OmFlZDM4ZDU4MzY1NTA4MjlmN2ZkNDU5ZGYzMWI0N2FhZjdlNWFkNDU=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcgHZQjgH2gAyNDExMjY0NTk0OjZhZmEzY2Q1MDUyNzAwNWM3NjQwZTNjYzg5ZTAyMGIwMzBiNmNkYTQ=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "aed38d5836550829f7fd459df31b47aaf7e5ad45", "author": {"user": {"login": "vcrfxia", "name": "Victoria Xia"}}, "url": "https://github.com/confluentinc/ksql/commit/aed38d5836550829f7fd459df31b47aaf7e5ad45", "committedDate": "2020-04-30T08:51:19Z", "message": "docs: klip-26: Java client interfaces"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDAzNDIyNjIz", "url": "https://github.com/confluentinc/ksql/pull/5236#pullrequestreview-403422623", "createdAt": "2020-04-30T11:12:55Z", "commit": {"oid": "aed38d5836550829f7fd459df31b47aaf7e5ad45"}, "state": "APPROVED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0zMFQxMToxMjo1NVrOGOkrEg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0zMFQxMToxODozOFrOGOk1jQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzkzNDA5OA==", "bodyText": "I think this would need to be:\nCompletableFuture<Publisher<InsertResponse>> streamInserts(String streamName, Publisher<Map<String, Object>> insertsPublisher);\n\nAs, for inserting, a row is represented as a map.", "url": "https://github.com/confluentinc/ksql/pull/5236#discussion_r417934098", "createdAt": "2020-04-30T11:12:55Z", "author": {"login": "purplefox"}, "path": "design-proposals/klip-26-java-client-interfaces.md", "diffHunk": "@@ -0,0 +1,715 @@\n+# KLIP 26 - Java client interfaces\n+\n+**Author**: Victoria Xia (@vcrfxia) | \n+**Release Target**: ksqlDB 0.10.0 | \n+**Status**: _In development_ | \n+**Discussion**: TBD\n+\n+**tl;dr:** _[KLIP 15](./klip-15-new-api-and-client.md) already made the case for why it makes sense\n+           to introduce a Java client for ksqlDB. This KLIP proposes interfaces for the client._\n+\n+## Motivation and background\n+\n+See [KLIP 15](./klip-15-new-api-and-client.md).\n+\n+## What is in scope\n+\n+The Java client will support the following operations:\n+* Push query\n+* Pull query\n+* Select DDL/DML operations:\n+    * `CREATE STREAM`\n+    * `CREATE TABLE`\n+    * `CREATE STREAM ... AS SELECT`\n+    * `CREATE TABLE ... AS SELECT`\n+    * `DROP STREAM`\n+    * `DROP TABLE`\n+    * `INSERT INTO`\n+    * `TERMINATE <queryId>`\n+    * `CREATE CONNECTOR`\n+    * `DROP CONNECTOR`\n+* Select admin operations:\n+    * `SHOW TOPICS` (non-extended)\n+    * `SHOW STREAMS` (non-extended)\n+    * `SHOW TABLES` (non-extended)\n+    * `SHOW QUERIES` (non-extended)\n+    * `SHOW CONNECTORS`\n+* Insert values, i.e., insert rows into an existing stream/table\n+* Terminate push query (via the `/close-query` endpoint)\n+\n+The purpose of this KLIP is to reach agreement on the interfaces / public APIs.\n+Implementation details will not be covered.\n+\n+## What is not in scope\n+\n+This KLIP does not cover Java client support for the following:\n+* `DESCRIBE <stream/table>`, `DESCRIBE CONNECTOR`, `DESCRIBE FUNCTION`\n+* `EXPLAIN <queryId>`\n+* `PRINT <topic>`\n+* `SHOW TOPICS EXTENDED`, `SHOW <STREAMS/TABLES> EXTENDED`, `SHOW QUERIES EXTENDED`\n+* `CREATE TYPE`, `DROP TYPE`, `SHOW TYPES`\n+* `SHOW FUNCTIONS`, `SHOW PROPERTIES`\n+* `RUN SCRIPT`\n+* Use of other endpoints (info, healthcheck, terminate cluster, status, etc.)\n+\n+We can always add support for these operations in the future if desired.\n+\n+As above, implementation details are out of scope as the purpose of this KLIP is to reach agreement\n+on the interfaces / public APIs.\n+\n+## Value/Return\n+\n+See [KLIP 15](./klip-15-new-api-and-client.md).\n+\n+## Public APIS\n+\n+The following subsections describe the methods of the `Client` interface:\n+```\n+public interface Client {\n+    ...\n+}\n+```\n+\n+### Constructors\n+```\n+  static Client create(ClientOptions clientOptions) {\n+    return new ClientImpl(clientOptions);\n+  }\n+\n+  static Client create(ClientOptions clientOptions, Vertx vertx) {\n+    return new ClientImpl(clientOptions, vertx);\n+  }\n+```\n+\n+The Java client will be implemented as a Vert.x HttpClient. We expose a constructor that allows users to provide their own `Vertx` instance\n+in order to take advantage of a shared connection pool and other properties if desired.\n+\n+`ClientOptions` will initially be as follows:\n+```\n+public interface ClientOptions {\n+\n+  ClientOptions setHost(String host);\n+\n+  ClientOptions setPort(int port);\n+\n+  ClientOptions setUseTls(boolean useTls);\n+\n+  ClientOptions setUseClientAuth(boolean useClientAuth);\n+\n+  ClientOptions setTrustStore(String trustStorePath);\n+\n+  ClientOptions setTrustStorePassword(String trustStorePassword);\n+\n+  ClientOptions setKeyStore(String keyStorePath);\n+\n+  ClientOptions setKeyStorePassword(String keyStorePassword);\n+\n+  ClientOptions setBasicAuthCredentials(String username, String password);\n+\n+  String getHost();\n+\n+  int getPort();\n+\n+  boolean isUseTls();\n+\n+  boolean isUseClientAuth();\n+\n+  boolean isUseBasicAuth();\n+\n+  String getTrustStore();\n+\n+  String getTrustStorePassword();\n+\n+  String getKeyStore();\n+\n+  String getKeyStorePassword();\n+\n+  String getBasicAuthUsername();\n+\n+  String getBasicAuthPassword();\n+\n+  ClientOptions copy();\n+\n+  static ClientOptions create() {\n+    return new ClientOptionsImpl();\n+  }\n+}\n+```\n+\n+We can always add additional configuration options later. We may also wish to expose the Vert.x `HttpClientOptions` for\n+advanced users that wish to provide custom configs.\n+\n+### Transient queries -- Streaming\n+\n+The `Client` interface will provide the following methods for streaming the results of a transient (push or pull) query:\n+```\n+  /**\n+   * Execute a query (push or pull) and receive the results one row at a time.\n+   *\n+   * @param sql statement of query to execute.\n+   * @return query result.\n+   */\n+  CompletableFuture<QueryResult> streamQuery(String sql);\n+\n+  /**\n+   * Execute a query (push or pull) and receive the results one row at a time.\n+   *\n+   * @param sql statement of query to execute.\n+   * @param properties query properties.\n+   * @return query result.\n+   */\n+  CompletableFuture<QueryResult> streamQuery(String sql, Map<String, Object> properties);\n+```\n+where `QueryResult` is as follows:\n+```\n+/**\n+ * The result of a query (push or pull), streamed one row at time. Records may be consumed by either\n+ * subscribing to the publisher or polling (blocking) for one record at a time. These two methods of\n+ * consumption are mutually exclusive; only one method may be used (per QueryResult).\n+ */\n+public interface QueryResult extends Publisher<Row> {\n+\n+  List<String> columnNames();\n+\n+  List<String> columnTypes();\n+\n+  String queryID();\n+\n+  /**\n+   * Block until a row becomes available.\n+   *\n+   * @return the row.\n+   */\n+  Row poll();\n+\n+  /**\n+   * Block until a row becomes available or the timeout has elapsed.\n+   *\n+   * @param timeout amount of to wait for a row. Non-positive values are interpreted as no timeout.\n+   * @param timeUnit unit for timeout param.\n+   * @return the row, if available; else, null.\n+   */\n+  Row poll(long timeout, TimeUnit timeUnit);\n+\n+  boolean isComplete();\n+\n+  void close();\n+}\n+```\n+Note that `QueryResult` is a Reactive Streams `Publisher` so users can stream results. Users can also call `poll()` to receive\n+results in a synchronous fashion instead. Only one of the two methods will be allowed per `QueryResult` instance.\n+\n+The `Row` interface is as follows:\n+```\n+/**\n+ * A single record, returned as part of a query result.\n+ */\n+public interface Row {\n+\n+  List<String> columnNames();\n+\n+  List<String> columnTypes();\n+\n+  List<Object> values();\n+\n+  /**\n+   * Get the value for a particular column of the Row as an Object.\n+   *\n+   * @param columnIndex index of column (1-indexed).\n+   * @return column value.\n+   */\n+  Object getObject(int columnIndex);\n+\n+  /**\n+   * Get the value for a particular column of the Row as an Object.\n+   *\n+   * @param columnName name of column.\n+   * @return column value.\n+   */\n+  Object getObject(String columnName);\n+\n+  /**\n+   * Get the value for a particular column of the Row as a string.\n+   *\n+   * @param columnIndex index of column (1-indexed).\n+   * @return column value.\n+   */\n+  String getString(int columnIndex);\n+\n+  /**\n+   * Get the value for a particular column of the Row as a string.\n+   *\n+   * @param columnName name of column.\n+   * @return column value.\n+   */\n+  String getString(String columnName);\n+\n+  /**\n+   * Get the value for a particular column of the Row as an integer.\n+   *\n+   * @param columnIndex index of column (1-indexed).\n+   * @return column value.\n+   */\n+  Integer getInt(int columnIndex);\n+\n+  /**\n+   * Get the value for a particular column of the Row as an integer.\n+   *\n+   * @param columnName name of column.\n+   * @return column value.\n+   */\n+  Integer getInt(String columnName);\n+\n+  /**\n+   * Get the value for a particular column of the Row as a long.\n+   *\n+   * @param columnIndex index of column (1-indexed).\n+   * @return column value.\n+   */\n+  Long getLong(int columnIndex);\n+\n+  /**\n+   * Get the value for a particular column of the Row as a long.\n+   *\n+   * @param columnName name of column.\n+   * @return column value.\n+   */\n+  Long getLong(String columnName);\n+\n+  /**\n+   * Get the value for a particular column of the Row as a double.\n+   *\n+   * @param columnIndex index of column (1-indexed).\n+   * @return column value.\n+   */\n+  Double getDouble(int columnIndex);\n+\n+  /**\n+   * Get the value for a particular column of the Row as a double.\n+   *\n+   * @param columnName name of column.\n+   * @return column value.\n+   */\n+  Double getDouble(String columnName);\n+\n+  /**\n+   * Get the value for a particular column of the Row as a boolean.\n+   *\n+   * @param columnIndex index of column (1-indexed).\n+   * @return column value.\n+   */\n+  Boolean getBoolean(int columnIndex);\n+\n+  /**\n+   * Get the value for a particular column of the Row as a boolean.\n+   *\n+   * @param columnName name of column.\n+   * @return column value.\n+   */\n+  Boolean getBoolean(String columnName);\n+\n+  /**\n+   * Get the value for a particular column of the Row as a decimal.\n+   *\n+   * @param columnIndex index of column (1-indexed).\n+   * @return column value.\n+   */\n+  BigDecimal getDecimal(int columnIndex);\n+\n+  /**\n+   * Get the value for a particular column of the Row as a decimal.\n+   *\n+   * @param columnName name of column.\n+   * @return column value.\n+   */\n+  BigDecimal getDecimal(String columnName);\n+}\n+```\n+\n+We considered representing column types in a more structured form (rather than plain strings) to accomodate complex/nested data types but felt this added complexity would not be helpful for most use cases. (This would also require a server-side change, so it's a fair bit of additional work.)\n+\n+For `getDecimal(...)` in the `Row` interface, rather than trying to parse the column type to extract the precision and scale, we will simply convert the value to a BigDecimal without explicitly specifying the precision and scale. We could also add an option for users to specify the scale and precision in the getter, if we think that would be useful.\n+\n+We could also add `getList(...)` and `getMap(...)` methods to the `Row` interface, but it's not clear to me how valuable this would be given that the nested data types would not be known.\n+\n+Tim also proposed switching from generic Java types (`Map<String, Object>`, `List<Object>`) to Vert.x types (`JsonObject`, `JsonArray`) as the latter is more type-safe and the client already has a dependency on Vert.x anyway. The downside, though, is that then apps that use the client would be required to depend on Vert.x as well.\n+\n+### Transient queries -- Non-streaming\n+\n+The `Client` interface will also provide the following methods for receiving the results of a transient query (push or pull) in a single batch (non-streaming),\n+once the query has completed:\n+```\n+  /**\n+   * Execute a query (push or pull) and receive all result rows together, once the query has\n+   * completed.\n+   *\n+   * @param sql statement of query to execute.\n+   * @return query result.\n+   */\n+  CompletableFuture<List<Row>> executeQuery(String sql);\n+\n+  /**\n+   * Execute a query (push or pull) and receive all result rows together, once the query has\n+   * completed.\n+   *\n+   * @param sql statement of query to execute.\n+   * @param properties query properties.\n+   * @return query result.\n+   */\n+  CompletableFuture<List<Row>> executeQuery(String sql, Map<String, Object> properties);\n+```\n+\n+For a query to \"complete\" could mean:\n+* The query is a pull query\n+* The query is a push query with a limit clause, and the limit has been reached\n+* The query is a push query that has been terminated\n+\n+We may want to introduce a limit to the number of rows that may be returned from these `executeQuery()` methods,\n+in order to decrease the likelihood of running out of memory.\n+\n+### Insert values\n+\n+A method to insert one row at a time:\n+```\n+  /**\n+   * Insert a single row into the relevant stream/table.\n+   *\n+   * @param streamName name of stream/table.\n+   * @param row the row to insert.\n+   * @return a future that completes once the request has been processed.\n+   */\n+  CompletableFuture<Void> insertInto(String streamName, Map<String, Object> row);\n+```\n+\n+A method to stream inserts (via the `/inserts-stream` endpoint):\n+```\n+  CompletableFuture<Publisher<InsertResponse>> streamInserts(String streamName, Publisher<List<Object>> insertsPublisher);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aed38d5836550829f7fd459df31b47aaf7e5ad45"}, "originalPosition": 386}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzkzNTIxOA==", "bodyText": "I wouldn't consider things like CTAS and CSAS as DML. DML in the relational DB world refers to operations which directly manipulate data, such as INSERT, DELETE and UPDATE. DDL refers to creating tables, indexes etc. I'd consider CTAS/CSAS as DDL.", "url": "https://github.com/confluentinc/ksql/pull/5236#discussion_r417935218", "createdAt": "2020-04-30T11:15:22Z", "author": {"login": "purplefox"}, "path": "design-proposals/klip-26-java-client-interfaces.md", "diffHunk": "@@ -0,0 +1,715 @@\n+# KLIP 26 - Java client interfaces\n+\n+**Author**: Victoria Xia (@vcrfxia) | \n+**Release Target**: ksqlDB 0.10.0 | \n+**Status**: _In development_ | \n+**Discussion**: TBD\n+\n+**tl;dr:** _[KLIP 15](./klip-15-new-api-and-client.md) already made the case for why it makes sense\n+           to introduce a Java client for ksqlDB. This KLIP proposes interfaces for the client._\n+\n+## Motivation and background\n+\n+See [KLIP 15](./klip-15-new-api-and-client.md).\n+\n+## What is in scope\n+\n+The Java client will support the following operations:\n+* Push query\n+* Pull query\n+* Select DDL/DML operations:\n+    * `CREATE STREAM`\n+    * `CREATE TABLE`\n+    * `CREATE STREAM ... AS SELECT`\n+    * `CREATE TABLE ... AS SELECT`\n+    * `DROP STREAM`\n+    * `DROP TABLE`\n+    * `INSERT INTO`\n+    * `TERMINATE <queryId>`\n+    * `CREATE CONNECTOR`\n+    * `DROP CONNECTOR`\n+* Select admin operations:\n+    * `SHOW TOPICS` (non-extended)\n+    * `SHOW STREAMS` (non-extended)\n+    * `SHOW TABLES` (non-extended)\n+    * `SHOW QUERIES` (non-extended)\n+    * `SHOW CONNECTORS`\n+* Insert values, i.e., insert rows into an existing stream/table\n+* Terminate push query (via the `/close-query` endpoint)\n+\n+The purpose of this KLIP is to reach agreement on the interfaces / public APIs.\n+Implementation details will not be covered.\n+\n+## What is not in scope\n+\n+This KLIP does not cover Java client support for the following:\n+* `DESCRIBE <stream/table>`, `DESCRIBE CONNECTOR`, `DESCRIBE FUNCTION`\n+* `EXPLAIN <queryId>`\n+* `PRINT <topic>`\n+* `SHOW TOPICS EXTENDED`, `SHOW <STREAMS/TABLES> EXTENDED`, `SHOW QUERIES EXTENDED`\n+* `CREATE TYPE`, `DROP TYPE`, `SHOW TYPES`\n+* `SHOW FUNCTIONS`, `SHOW PROPERTIES`\n+* `RUN SCRIPT`\n+* Use of other endpoints (info, healthcheck, terminate cluster, status, etc.)\n+\n+We can always add support for these operations in the future if desired.\n+\n+As above, implementation details are out of scope as the purpose of this KLIP is to reach agreement\n+on the interfaces / public APIs.\n+\n+## Value/Return\n+\n+See [KLIP 15](./klip-15-new-api-and-client.md).\n+\n+## Public APIS\n+\n+The following subsections describe the methods of the `Client` interface:\n+```\n+public interface Client {\n+    ...\n+}\n+```\n+\n+### Constructors\n+```\n+  static Client create(ClientOptions clientOptions) {\n+    return new ClientImpl(clientOptions);\n+  }\n+\n+  static Client create(ClientOptions clientOptions, Vertx vertx) {\n+    return new ClientImpl(clientOptions, vertx);\n+  }\n+```\n+\n+The Java client will be implemented as a Vert.x HttpClient. We expose a constructor that allows users to provide their own `Vertx` instance\n+in order to take advantage of a shared connection pool and other properties if desired.\n+\n+`ClientOptions` will initially be as follows:\n+```\n+public interface ClientOptions {\n+\n+  ClientOptions setHost(String host);\n+\n+  ClientOptions setPort(int port);\n+\n+  ClientOptions setUseTls(boolean useTls);\n+\n+  ClientOptions setUseClientAuth(boolean useClientAuth);\n+\n+  ClientOptions setTrustStore(String trustStorePath);\n+\n+  ClientOptions setTrustStorePassword(String trustStorePassword);\n+\n+  ClientOptions setKeyStore(String keyStorePath);\n+\n+  ClientOptions setKeyStorePassword(String keyStorePassword);\n+\n+  ClientOptions setBasicAuthCredentials(String username, String password);\n+\n+  String getHost();\n+\n+  int getPort();\n+\n+  boolean isUseTls();\n+\n+  boolean isUseClientAuth();\n+\n+  boolean isUseBasicAuth();\n+\n+  String getTrustStore();\n+\n+  String getTrustStorePassword();\n+\n+  String getKeyStore();\n+\n+  String getKeyStorePassword();\n+\n+  String getBasicAuthUsername();\n+\n+  String getBasicAuthPassword();\n+\n+  ClientOptions copy();\n+\n+  static ClientOptions create() {\n+    return new ClientOptionsImpl();\n+  }\n+}\n+```\n+\n+We can always add additional configuration options later. We may also wish to expose the Vert.x `HttpClientOptions` for\n+advanced users that wish to provide custom configs.\n+\n+### Transient queries -- Streaming\n+\n+The `Client` interface will provide the following methods for streaming the results of a transient (push or pull) query:\n+```\n+  /**\n+   * Execute a query (push or pull) and receive the results one row at a time.\n+   *\n+   * @param sql statement of query to execute.\n+   * @return query result.\n+   */\n+  CompletableFuture<QueryResult> streamQuery(String sql);\n+\n+  /**\n+   * Execute a query (push or pull) and receive the results one row at a time.\n+   *\n+   * @param sql statement of query to execute.\n+   * @param properties query properties.\n+   * @return query result.\n+   */\n+  CompletableFuture<QueryResult> streamQuery(String sql, Map<String, Object> properties);\n+```\n+where `QueryResult` is as follows:\n+```\n+/**\n+ * The result of a query (push or pull), streamed one row at time. Records may be consumed by either\n+ * subscribing to the publisher or polling (blocking) for one record at a time. These two methods of\n+ * consumption are mutually exclusive; only one method may be used (per QueryResult).\n+ */\n+public interface QueryResult extends Publisher<Row> {\n+\n+  List<String> columnNames();\n+\n+  List<String> columnTypes();\n+\n+  String queryID();\n+\n+  /**\n+   * Block until a row becomes available.\n+   *\n+   * @return the row.\n+   */\n+  Row poll();\n+\n+  /**\n+   * Block until a row becomes available or the timeout has elapsed.\n+   *\n+   * @param timeout amount of to wait for a row. Non-positive values are interpreted as no timeout.\n+   * @param timeUnit unit for timeout param.\n+   * @return the row, if available; else, null.\n+   */\n+  Row poll(long timeout, TimeUnit timeUnit);\n+\n+  boolean isComplete();\n+\n+  void close();\n+}\n+```\n+Note that `QueryResult` is a Reactive Streams `Publisher` so users can stream results. Users can also call `poll()` to receive\n+results in a synchronous fashion instead. Only one of the two methods will be allowed per `QueryResult` instance.\n+\n+The `Row` interface is as follows:\n+```\n+/**\n+ * A single record, returned as part of a query result.\n+ */\n+public interface Row {\n+\n+  List<String> columnNames();\n+\n+  List<String> columnTypes();\n+\n+  List<Object> values();\n+\n+  /**\n+   * Get the value for a particular column of the Row as an Object.\n+   *\n+   * @param columnIndex index of column (1-indexed).\n+   * @return column value.\n+   */\n+  Object getObject(int columnIndex);\n+\n+  /**\n+   * Get the value for a particular column of the Row as an Object.\n+   *\n+   * @param columnName name of column.\n+   * @return column value.\n+   */\n+  Object getObject(String columnName);\n+\n+  /**\n+   * Get the value for a particular column of the Row as a string.\n+   *\n+   * @param columnIndex index of column (1-indexed).\n+   * @return column value.\n+   */\n+  String getString(int columnIndex);\n+\n+  /**\n+   * Get the value for a particular column of the Row as a string.\n+   *\n+   * @param columnName name of column.\n+   * @return column value.\n+   */\n+  String getString(String columnName);\n+\n+  /**\n+   * Get the value for a particular column of the Row as an integer.\n+   *\n+   * @param columnIndex index of column (1-indexed).\n+   * @return column value.\n+   */\n+  Integer getInt(int columnIndex);\n+\n+  /**\n+   * Get the value for a particular column of the Row as an integer.\n+   *\n+   * @param columnName name of column.\n+   * @return column value.\n+   */\n+  Integer getInt(String columnName);\n+\n+  /**\n+   * Get the value for a particular column of the Row as a long.\n+   *\n+   * @param columnIndex index of column (1-indexed).\n+   * @return column value.\n+   */\n+  Long getLong(int columnIndex);\n+\n+  /**\n+   * Get the value for a particular column of the Row as a long.\n+   *\n+   * @param columnName name of column.\n+   * @return column value.\n+   */\n+  Long getLong(String columnName);\n+\n+  /**\n+   * Get the value for a particular column of the Row as a double.\n+   *\n+   * @param columnIndex index of column (1-indexed).\n+   * @return column value.\n+   */\n+  Double getDouble(int columnIndex);\n+\n+  /**\n+   * Get the value for a particular column of the Row as a double.\n+   *\n+   * @param columnName name of column.\n+   * @return column value.\n+   */\n+  Double getDouble(String columnName);\n+\n+  /**\n+   * Get the value for a particular column of the Row as a boolean.\n+   *\n+   * @param columnIndex index of column (1-indexed).\n+   * @return column value.\n+   */\n+  Boolean getBoolean(int columnIndex);\n+\n+  /**\n+   * Get the value for a particular column of the Row as a boolean.\n+   *\n+   * @param columnName name of column.\n+   * @return column value.\n+   */\n+  Boolean getBoolean(String columnName);\n+\n+  /**\n+   * Get the value for a particular column of the Row as a decimal.\n+   *\n+   * @param columnIndex index of column (1-indexed).\n+   * @return column value.\n+   */\n+  BigDecimal getDecimal(int columnIndex);\n+\n+  /**\n+   * Get the value for a particular column of the Row as a decimal.\n+   *\n+   * @param columnName name of column.\n+   * @return column value.\n+   */\n+  BigDecimal getDecimal(String columnName);\n+}\n+```\n+\n+We considered representing column types in a more structured form (rather than plain strings) to accomodate complex/nested data types but felt this added complexity would not be helpful for most use cases. (This would also require a server-side change, so it's a fair bit of additional work.)\n+\n+For `getDecimal(...)` in the `Row` interface, rather than trying to parse the column type to extract the precision and scale, we will simply convert the value to a BigDecimal without explicitly specifying the precision and scale. We could also add an option for users to specify the scale and precision in the getter, if we think that would be useful.\n+\n+We could also add `getList(...)` and `getMap(...)` methods to the `Row` interface, but it's not clear to me how valuable this would be given that the nested data types would not be known.\n+\n+Tim also proposed switching from generic Java types (`Map<String, Object>`, `List<Object>`) to Vert.x types (`JsonObject`, `JsonArray`) as the latter is more type-safe and the client already has a dependency on Vert.x anyway. The downside, though, is that then apps that use the client would be required to depend on Vert.x as well.\n+\n+### Transient queries -- Non-streaming\n+\n+The `Client` interface will also provide the following methods for receiving the results of a transient query (push or pull) in a single batch (non-streaming),\n+once the query has completed:\n+```\n+  /**\n+   * Execute a query (push or pull) and receive all result rows together, once the query has\n+   * completed.\n+   *\n+   * @param sql statement of query to execute.\n+   * @return query result.\n+   */\n+  CompletableFuture<List<Row>> executeQuery(String sql);\n+\n+  /**\n+   * Execute a query (push or pull) and receive all result rows together, once the query has\n+   * completed.\n+   *\n+   * @param sql statement of query to execute.\n+   * @param properties query properties.\n+   * @return query result.\n+   */\n+  CompletableFuture<List<Row>> executeQuery(String sql, Map<String, Object> properties);\n+```\n+\n+For a query to \"complete\" could mean:\n+* The query is a pull query\n+* The query is a push query with a limit clause, and the limit has been reached\n+* The query is a push query that has been terminated\n+\n+We may want to introduce a limit to the number of rows that may be returned from these `executeQuery()` methods,\n+in order to decrease the likelihood of running out of memory.\n+\n+### Insert values\n+\n+A method to insert one row at a time:\n+```\n+  /**\n+   * Insert a single row into the relevant stream/table.\n+   *\n+   * @param streamName name of stream/table.\n+   * @param row the row to insert.\n+   * @return a future that completes once the request has been processed.\n+   */\n+  CompletableFuture<Void> insertInto(String streamName, Map<String, Object> row);\n+```\n+\n+A method to stream inserts (via the `/inserts-stream` endpoint):\n+```\n+  CompletableFuture<Publisher<InsertResponse>> streamInserts(String streamName, Publisher<List<Object>> insertsPublisher);\n+}\n+```\n+where `InsertResponse` is as follows:\n+```\n+public interface InsertResponse {\n+\n+  /**\n+   * Whether the row was successfully inserted or not.\n+   */\n+  boolean isSuccessful();\n+\n+  /**\n+   * Unique sequence number for the row in the stream of inserts.\n+   */\n+  int getSequenceNum();\n+\n+  /**\n+   * If unsuccessful, the error message.\n+   */\n+  String getErrorMessage();\n+\n+  /**\n+   * If unsuccessful, the error code.\n+   */\n+  int getErrorCode();\n+\n+}\n+```\n+\n+### DDL/DML operations\n+\n+#### `CREATE <STREAM/TABLE>`, `CREATE <STREAM/TABLE> ... AS SELECT`, `INSERT INTO`\n+\n+`Client` methods:\n+```\n+  /**\n+   * Execute DDL statement: `CREATE STREAM`, `CREATE TABLE`\n+   */\n+  CompletableFuture<DdlResponse> executeDdl(String sql);\n+\n+  /**\n+   * Execute DML statement: `CREATE STREAM ... AS SELECT`, `CREATE TABLE ... AS SELECT`, `INSERT INTO`\n+   */\n+  CompletableFuture<DmlResponse> executeDml(String sql);\n+\n+  /**\n+   * Execute DML statement: `CREATE STREAM ... AS SELECT`, `CREATE TABLE ... AS SELECT`, `INSERT INTO`\n+   */\n+  CompletableFuture<DmlResponse> executeDml(String sql, Map<String, Object> properties);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aed38d5836550829f7fd459df31b47aaf7e5ad45"}, "originalPosition": 435}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzkzNTgwMg==", "bodyText": "Why do we need command sequence number, command ID, etc? Are they used elsewhere in the API?", "url": "https://github.com/confluentinc/ksql/pull/5236#discussion_r417935802", "createdAt": "2020-04-30T11:16:36Z", "author": {"login": "purplefox"}, "path": "design-proposals/klip-26-java-client-interfaces.md", "diffHunk": "@@ -0,0 +1,715 @@\n+# KLIP 26 - Java client interfaces\n+\n+**Author**: Victoria Xia (@vcrfxia) | \n+**Release Target**: ksqlDB 0.10.0 | \n+**Status**: _In development_ | \n+**Discussion**: TBD\n+\n+**tl;dr:** _[KLIP 15](./klip-15-new-api-and-client.md) already made the case for why it makes sense\n+           to introduce a Java client for ksqlDB. This KLIP proposes interfaces for the client._\n+\n+## Motivation and background\n+\n+See [KLIP 15](./klip-15-new-api-and-client.md).\n+\n+## What is in scope\n+\n+The Java client will support the following operations:\n+* Push query\n+* Pull query\n+* Select DDL/DML operations:\n+    * `CREATE STREAM`\n+    * `CREATE TABLE`\n+    * `CREATE STREAM ... AS SELECT`\n+    * `CREATE TABLE ... AS SELECT`\n+    * `DROP STREAM`\n+    * `DROP TABLE`\n+    * `INSERT INTO`\n+    * `TERMINATE <queryId>`\n+    * `CREATE CONNECTOR`\n+    * `DROP CONNECTOR`\n+* Select admin operations:\n+    * `SHOW TOPICS` (non-extended)\n+    * `SHOW STREAMS` (non-extended)\n+    * `SHOW TABLES` (non-extended)\n+    * `SHOW QUERIES` (non-extended)\n+    * `SHOW CONNECTORS`\n+* Insert values, i.e., insert rows into an existing stream/table\n+* Terminate push query (via the `/close-query` endpoint)\n+\n+The purpose of this KLIP is to reach agreement on the interfaces / public APIs.\n+Implementation details will not be covered.\n+\n+## What is not in scope\n+\n+This KLIP does not cover Java client support for the following:\n+* `DESCRIBE <stream/table>`, `DESCRIBE CONNECTOR`, `DESCRIBE FUNCTION`\n+* `EXPLAIN <queryId>`\n+* `PRINT <topic>`\n+* `SHOW TOPICS EXTENDED`, `SHOW <STREAMS/TABLES> EXTENDED`, `SHOW QUERIES EXTENDED`\n+* `CREATE TYPE`, `DROP TYPE`, `SHOW TYPES`\n+* `SHOW FUNCTIONS`, `SHOW PROPERTIES`\n+* `RUN SCRIPT`\n+* Use of other endpoints (info, healthcheck, terminate cluster, status, etc.)\n+\n+We can always add support for these operations in the future if desired.\n+\n+As above, implementation details are out of scope as the purpose of this KLIP is to reach agreement\n+on the interfaces / public APIs.\n+\n+## Value/Return\n+\n+See [KLIP 15](./klip-15-new-api-and-client.md).\n+\n+## Public APIS\n+\n+The following subsections describe the methods of the `Client` interface:\n+```\n+public interface Client {\n+    ...\n+}\n+```\n+\n+### Constructors\n+```\n+  static Client create(ClientOptions clientOptions) {\n+    return new ClientImpl(clientOptions);\n+  }\n+\n+  static Client create(ClientOptions clientOptions, Vertx vertx) {\n+    return new ClientImpl(clientOptions, vertx);\n+  }\n+```\n+\n+The Java client will be implemented as a Vert.x HttpClient. We expose a constructor that allows users to provide their own `Vertx` instance\n+in order to take advantage of a shared connection pool and other properties if desired.\n+\n+`ClientOptions` will initially be as follows:\n+```\n+public interface ClientOptions {\n+\n+  ClientOptions setHost(String host);\n+\n+  ClientOptions setPort(int port);\n+\n+  ClientOptions setUseTls(boolean useTls);\n+\n+  ClientOptions setUseClientAuth(boolean useClientAuth);\n+\n+  ClientOptions setTrustStore(String trustStorePath);\n+\n+  ClientOptions setTrustStorePassword(String trustStorePassword);\n+\n+  ClientOptions setKeyStore(String keyStorePath);\n+\n+  ClientOptions setKeyStorePassword(String keyStorePassword);\n+\n+  ClientOptions setBasicAuthCredentials(String username, String password);\n+\n+  String getHost();\n+\n+  int getPort();\n+\n+  boolean isUseTls();\n+\n+  boolean isUseClientAuth();\n+\n+  boolean isUseBasicAuth();\n+\n+  String getTrustStore();\n+\n+  String getTrustStorePassword();\n+\n+  String getKeyStore();\n+\n+  String getKeyStorePassword();\n+\n+  String getBasicAuthUsername();\n+\n+  String getBasicAuthPassword();\n+\n+  ClientOptions copy();\n+\n+  static ClientOptions create() {\n+    return new ClientOptionsImpl();\n+  }\n+}\n+```\n+\n+We can always add additional configuration options later. We may also wish to expose the Vert.x `HttpClientOptions` for\n+advanced users that wish to provide custom configs.\n+\n+### Transient queries -- Streaming\n+\n+The `Client` interface will provide the following methods for streaming the results of a transient (push or pull) query:\n+```\n+  /**\n+   * Execute a query (push or pull) and receive the results one row at a time.\n+   *\n+   * @param sql statement of query to execute.\n+   * @return query result.\n+   */\n+  CompletableFuture<QueryResult> streamQuery(String sql);\n+\n+  /**\n+   * Execute a query (push or pull) and receive the results one row at a time.\n+   *\n+   * @param sql statement of query to execute.\n+   * @param properties query properties.\n+   * @return query result.\n+   */\n+  CompletableFuture<QueryResult> streamQuery(String sql, Map<String, Object> properties);\n+```\n+where `QueryResult` is as follows:\n+```\n+/**\n+ * The result of a query (push or pull), streamed one row at time. Records may be consumed by either\n+ * subscribing to the publisher or polling (blocking) for one record at a time. These two methods of\n+ * consumption are mutually exclusive; only one method may be used (per QueryResult).\n+ */\n+public interface QueryResult extends Publisher<Row> {\n+\n+  List<String> columnNames();\n+\n+  List<String> columnTypes();\n+\n+  String queryID();\n+\n+  /**\n+   * Block until a row becomes available.\n+   *\n+   * @return the row.\n+   */\n+  Row poll();\n+\n+  /**\n+   * Block until a row becomes available or the timeout has elapsed.\n+   *\n+   * @param timeout amount of to wait for a row. Non-positive values are interpreted as no timeout.\n+   * @param timeUnit unit for timeout param.\n+   * @return the row, if available; else, null.\n+   */\n+  Row poll(long timeout, TimeUnit timeUnit);\n+\n+  boolean isComplete();\n+\n+  void close();\n+}\n+```\n+Note that `QueryResult` is a Reactive Streams `Publisher` so users can stream results. Users can also call `poll()` to receive\n+results in a synchronous fashion instead. Only one of the two methods will be allowed per `QueryResult` instance.\n+\n+The `Row` interface is as follows:\n+```\n+/**\n+ * A single record, returned as part of a query result.\n+ */\n+public interface Row {\n+\n+  List<String> columnNames();\n+\n+  List<String> columnTypes();\n+\n+  List<Object> values();\n+\n+  /**\n+   * Get the value for a particular column of the Row as an Object.\n+   *\n+   * @param columnIndex index of column (1-indexed).\n+   * @return column value.\n+   */\n+  Object getObject(int columnIndex);\n+\n+  /**\n+   * Get the value for a particular column of the Row as an Object.\n+   *\n+   * @param columnName name of column.\n+   * @return column value.\n+   */\n+  Object getObject(String columnName);\n+\n+  /**\n+   * Get the value for a particular column of the Row as a string.\n+   *\n+   * @param columnIndex index of column (1-indexed).\n+   * @return column value.\n+   */\n+  String getString(int columnIndex);\n+\n+  /**\n+   * Get the value for a particular column of the Row as a string.\n+   *\n+   * @param columnName name of column.\n+   * @return column value.\n+   */\n+  String getString(String columnName);\n+\n+  /**\n+   * Get the value for a particular column of the Row as an integer.\n+   *\n+   * @param columnIndex index of column (1-indexed).\n+   * @return column value.\n+   */\n+  Integer getInt(int columnIndex);\n+\n+  /**\n+   * Get the value for a particular column of the Row as an integer.\n+   *\n+   * @param columnName name of column.\n+   * @return column value.\n+   */\n+  Integer getInt(String columnName);\n+\n+  /**\n+   * Get the value for a particular column of the Row as a long.\n+   *\n+   * @param columnIndex index of column (1-indexed).\n+   * @return column value.\n+   */\n+  Long getLong(int columnIndex);\n+\n+  /**\n+   * Get the value for a particular column of the Row as a long.\n+   *\n+   * @param columnName name of column.\n+   * @return column value.\n+   */\n+  Long getLong(String columnName);\n+\n+  /**\n+   * Get the value for a particular column of the Row as a double.\n+   *\n+   * @param columnIndex index of column (1-indexed).\n+   * @return column value.\n+   */\n+  Double getDouble(int columnIndex);\n+\n+  /**\n+   * Get the value for a particular column of the Row as a double.\n+   *\n+   * @param columnName name of column.\n+   * @return column value.\n+   */\n+  Double getDouble(String columnName);\n+\n+  /**\n+   * Get the value for a particular column of the Row as a boolean.\n+   *\n+   * @param columnIndex index of column (1-indexed).\n+   * @return column value.\n+   */\n+  Boolean getBoolean(int columnIndex);\n+\n+  /**\n+   * Get the value for a particular column of the Row as a boolean.\n+   *\n+   * @param columnName name of column.\n+   * @return column value.\n+   */\n+  Boolean getBoolean(String columnName);\n+\n+  /**\n+   * Get the value for a particular column of the Row as a decimal.\n+   *\n+   * @param columnIndex index of column (1-indexed).\n+   * @return column value.\n+   */\n+  BigDecimal getDecimal(int columnIndex);\n+\n+  /**\n+   * Get the value for a particular column of the Row as a decimal.\n+   *\n+   * @param columnName name of column.\n+   * @return column value.\n+   */\n+  BigDecimal getDecimal(String columnName);\n+}\n+```\n+\n+We considered representing column types in a more structured form (rather than plain strings) to accomodate complex/nested data types but felt this added complexity would not be helpful for most use cases. (This would also require a server-side change, so it's a fair bit of additional work.)\n+\n+For `getDecimal(...)` in the `Row` interface, rather than trying to parse the column type to extract the precision and scale, we will simply convert the value to a BigDecimal without explicitly specifying the precision and scale. We could also add an option for users to specify the scale and precision in the getter, if we think that would be useful.\n+\n+We could also add `getList(...)` and `getMap(...)` methods to the `Row` interface, but it's not clear to me how valuable this would be given that the nested data types would not be known.\n+\n+Tim also proposed switching from generic Java types (`Map<String, Object>`, `List<Object>`) to Vert.x types (`JsonObject`, `JsonArray`) as the latter is more type-safe and the client already has a dependency on Vert.x anyway. The downside, though, is that then apps that use the client would be required to depend on Vert.x as well.\n+\n+### Transient queries -- Non-streaming\n+\n+The `Client` interface will also provide the following methods for receiving the results of a transient query (push or pull) in a single batch (non-streaming),\n+once the query has completed:\n+```\n+  /**\n+   * Execute a query (push or pull) and receive all result rows together, once the query has\n+   * completed.\n+   *\n+   * @param sql statement of query to execute.\n+   * @return query result.\n+   */\n+  CompletableFuture<List<Row>> executeQuery(String sql);\n+\n+  /**\n+   * Execute a query (push or pull) and receive all result rows together, once the query has\n+   * completed.\n+   *\n+   * @param sql statement of query to execute.\n+   * @param properties query properties.\n+   * @return query result.\n+   */\n+  CompletableFuture<List<Row>> executeQuery(String sql, Map<String, Object> properties);\n+```\n+\n+For a query to \"complete\" could mean:\n+* The query is a pull query\n+* The query is a push query with a limit clause, and the limit has been reached\n+* The query is a push query that has been terminated\n+\n+We may want to introduce a limit to the number of rows that may be returned from these `executeQuery()` methods,\n+in order to decrease the likelihood of running out of memory.\n+\n+### Insert values\n+\n+A method to insert one row at a time:\n+```\n+  /**\n+   * Insert a single row into the relevant stream/table.\n+   *\n+   * @param streamName name of stream/table.\n+   * @param row the row to insert.\n+   * @return a future that completes once the request has been processed.\n+   */\n+  CompletableFuture<Void> insertInto(String streamName, Map<String, Object> row);\n+```\n+\n+A method to stream inserts (via the `/inserts-stream` endpoint):\n+```\n+  CompletableFuture<Publisher<InsertResponse>> streamInserts(String streamName, Publisher<List<Object>> insertsPublisher);\n+}\n+```\n+where `InsertResponse` is as follows:\n+```\n+public interface InsertResponse {\n+\n+  /**\n+   * Whether the row was successfully inserted or not.\n+   */\n+  boolean isSuccessful();\n+\n+  /**\n+   * Unique sequence number for the row in the stream of inserts.\n+   */\n+  int getSequenceNum();\n+\n+  /**\n+   * If unsuccessful, the error message.\n+   */\n+  String getErrorMessage();\n+\n+  /**\n+   * If unsuccessful, the error code.\n+   */\n+  int getErrorCode();\n+\n+}\n+```\n+\n+### DDL/DML operations\n+\n+#### `CREATE <STREAM/TABLE>`, `CREATE <STREAM/TABLE> ... AS SELECT`, `INSERT INTO`\n+\n+`Client` methods:\n+```\n+  /**\n+   * Execute DDL statement: `CREATE STREAM`, `CREATE TABLE`\n+   */\n+  CompletableFuture<DdlResponse> executeDdl(String sql);\n+\n+  /**\n+   * Execute DML statement: `CREATE STREAM ... AS SELECT`, `CREATE TABLE ... AS SELECT`, `INSERT INTO`\n+   */\n+  CompletableFuture<DmlResponse> executeDml(String sql);\n+\n+  /**\n+   * Execute DML statement: `CREATE STREAM ... AS SELECT`, `CREATE TABLE ... AS SELECT`, `INSERT INTO`\n+   */\n+  CompletableFuture<DmlResponse> executeDml(String sql, Map<String, Object> properties);\n+\n+```\n+with\n+```\n+public interface DdlResponse {\n+\n+  enum Status { QUEUED, PARSING, EXECUTING, RUNNING, TERMINATED, SUCCESS, ERROR }\n+  \n+  Status getStatus();\n+  \n+  String getStatusMessage();\n+  \n+  long getCommandSequenceNumber();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aed38d5836550829f7fd459df31b47aaf7e5ad45"}, "originalPosition": 448}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzkzNjc4MQ==", "bodyText": "Imho, I'm not a fan of trying to design APIs \"up-front\" in design docs. I'd suggest trying a few things out in actual code and then you'll get a much better picture of what works, and what doesn't.", "url": "https://github.com/confluentinc/ksql/pull/5236#discussion_r417936781", "createdAt": "2020-04-30T11:18:38Z", "author": {"login": "purplefox"}, "path": "design-proposals/klip-26-java-client-interfaces.md", "diffHunk": "@@ -0,0 +1,715 @@\n+# KLIP 26 - Java client interfaces\n+\n+**Author**: Victoria Xia (@vcrfxia) | \n+**Release Target**: ksqlDB 0.10.0 | \n+**Status**: _In development_ | \n+**Discussion**: TBD\n+\n+**tl;dr:** _[KLIP 15](./klip-15-new-api-and-client.md) already made the case for why it makes sense\n+           to introduce a Java client for ksqlDB. This KLIP proposes interfaces for the client._\n+\n+## Motivation and background\n+\n+See [KLIP 15](./klip-15-new-api-and-client.md).\n+\n+## What is in scope\n+\n+The Java client will support the following operations:\n+* Push query\n+* Pull query\n+* Select DDL/DML operations:\n+    * `CREATE STREAM`\n+    * `CREATE TABLE`\n+    * `CREATE STREAM ... AS SELECT`\n+    * `CREATE TABLE ... AS SELECT`\n+    * `DROP STREAM`\n+    * `DROP TABLE`\n+    * `INSERT INTO`\n+    * `TERMINATE <queryId>`\n+    * `CREATE CONNECTOR`\n+    * `DROP CONNECTOR`\n+* Select admin operations:\n+    * `SHOW TOPICS` (non-extended)\n+    * `SHOW STREAMS` (non-extended)\n+    * `SHOW TABLES` (non-extended)\n+    * `SHOW QUERIES` (non-extended)\n+    * `SHOW CONNECTORS`\n+* Insert values, i.e., insert rows into an existing stream/table\n+* Terminate push query (via the `/close-query` endpoint)\n+\n+The purpose of this KLIP is to reach agreement on the interfaces / public APIs.\n+Implementation details will not be covered.\n+\n+## What is not in scope\n+\n+This KLIP does not cover Java client support for the following:\n+* `DESCRIBE <stream/table>`, `DESCRIBE CONNECTOR`, `DESCRIBE FUNCTION`\n+* `EXPLAIN <queryId>`\n+* `PRINT <topic>`\n+* `SHOW TOPICS EXTENDED`, `SHOW <STREAMS/TABLES> EXTENDED`, `SHOW QUERIES EXTENDED`\n+* `CREATE TYPE`, `DROP TYPE`, `SHOW TYPES`\n+* `SHOW FUNCTIONS`, `SHOW PROPERTIES`\n+* `RUN SCRIPT`\n+* Use of other endpoints (info, healthcheck, terminate cluster, status, etc.)\n+\n+We can always add support for these operations in the future if desired.\n+\n+As above, implementation details are out of scope as the purpose of this KLIP is to reach agreement\n+on the interfaces / public APIs.\n+\n+## Value/Return\n+\n+See [KLIP 15](./klip-15-new-api-and-client.md).\n+\n+## Public APIS\n+\n+The following subsections describe the methods of the `Client` interface:\n+```\n+public interface Client {\n+    ...\n+}\n+```\n+\n+### Constructors\n+```\n+  static Client create(ClientOptions clientOptions) {\n+    return new ClientImpl(clientOptions);\n+  }\n+\n+  static Client create(ClientOptions clientOptions, Vertx vertx) {\n+    return new ClientImpl(clientOptions, vertx);\n+  }\n+```\n+\n+The Java client will be implemented as a Vert.x HttpClient. We expose a constructor that allows users to provide their own `Vertx` instance\n+in order to take advantage of a shared connection pool and other properties if desired.\n+\n+`ClientOptions` will initially be as follows:\n+```\n+public interface ClientOptions {\n+\n+  ClientOptions setHost(String host);\n+\n+  ClientOptions setPort(int port);\n+\n+  ClientOptions setUseTls(boolean useTls);\n+\n+  ClientOptions setUseClientAuth(boolean useClientAuth);\n+\n+  ClientOptions setTrustStore(String trustStorePath);\n+\n+  ClientOptions setTrustStorePassword(String trustStorePassword);\n+\n+  ClientOptions setKeyStore(String keyStorePath);\n+\n+  ClientOptions setKeyStorePassword(String keyStorePassword);\n+\n+  ClientOptions setBasicAuthCredentials(String username, String password);\n+\n+  String getHost();\n+\n+  int getPort();\n+\n+  boolean isUseTls();\n+\n+  boolean isUseClientAuth();\n+\n+  boolean isUseBasicAuth();\n+\n+  String getTrustStore();\n+\n+  String getTrustStorePassword();\n+\n+  String getKeyStore();\n+\n+  String getKeyStorePassword();\n+\n+  String getBasicAuthUsername();\n+\n+  String getBasicAuthPassword();\n+\n+  ClientOptions copy();\n+\n+  static ClientOptions create() {\n+    return new ClientOptionsImpl();\n+  }\n+}\n+```\n+\n+We can always add additional configuration options later. We may also wish to expose the Vert.x `HttpClientOptions` for\n+advanced users that wish to provide custom configs.\n+\n+### Transient queries -- Streaming\n+\n+The `Client` interface will provide the following methods for streaming the results of a transient (push or pull) query:\n+```\n+  /**\n+   * Execute a query (push or pull) and receive the results one row at a time.\n+   *\n+   * @param sql statement of query to execute.\n+   * @return query result.\n+   */\n+  CompletableFuture<QueryResult> streamQuery(String sql);\n+\n+  /**\n+   * Execute a query (push or pull) and receive the results one row at a time.\n+   *\n+   * @param sql statement of query to execute.\n+   * @param properties query properties.\n+   * @return query result.\n+   */\n+  CompletableFuture<QueryResult> streamQuery(String sql, Map<String, Object> properties);\n+```\n+where `QueryResult` is as follows:\n+```\n+/**\n+ * The result of a query (push or pull), streamed one row at time. Records may be consumed by either\n+ * subscribing to the publisher or polling (blocking) for one record at a time. These two methods of\n+ * consumption are mutually exclusive; only one method may be used (per QueryResult).\n+ */\n+public interface QueryResult extends Publisher<Row> {\n+\n+  List<String> columnNames();\n+\n+  List<String> columnTypes();\n+\n+  String queryID();\n+\n+  /**\n+   * Block until a row becomes available.\n+   *\n+   * @return the row.\n+   */\n+  Row poll();\n+\n+  /**\n+   * Block until a row becomes available or the timeout has elapsed.\n+   *\n+   * @param timeout amount of to wait for a row. Non-positive values are interpreted as no timeout.\n+   * @param timeUnit unit for timeout param.\n+   * @return the row, if available; else, null.\n+   */\n+  Row poll(long timeout, TimeUnit timeUnit);\n+\n+  boolean isComplete();\n+\n+  void close();\n+}\n+```\n+Note that `QueryResult` is a Reactive Streams `Publisher` so users can stream results. Users can also call `poll()` to receive\n+results in a synchronous fashion instead. Only one of the two methods will be allowed per `QueryResult` instance.\n+\n+The `Row` interface is as follows:\n+```\n+/**\n+ * A single record, returned as part of a query result.\n+ */\n+public interface Row {\n+\n+  List<String> columnNames();\n+\n+  List<String> columnTypes();\n+\n+  List<Object> values();\n+\n+  /**\n+   * Get the value for a particular column of the Row as an Object.\n+   *\n+   * @param columnIndex index of column (1-indexed).\n+   * @return column value.\n+   */\n+  Object getObject(int columnIndex);\n+\n+  /**\n+   * Get the value for a particular column of the Row as an Object.\n+   *\n+   * @param columnName name of column.\n+   * @return column value.\n+   */\n+  Object getObject(String columnName);\n+\n+  /**\n+   * Get the value for a particular column of the Row as a string.\n+   *\n+   * @param columnIndex index of column (1-indexed).\n+   * @return column value.\n+   */\n+  String getString(int columnIndex);\n+\n+  /**\n+   * Get the value for a particular column of the Row as a string.\n+   *\n+   * @param columnName name of column.\n+   * @return column value.\n+   */\n+  String getString(String columnName);\n+\n+  /**\n+   * Get the value for a particular column of the Row as an integer.\n+   *\n+   * @param columnIndex index of column (1-indexed).\n+   * @return column value.\n+   */\n+  Integer getInt(int columnIndex);\n+\n+  /**\n+   * Get the value for a particular column of the Row as an integer.\n+   *\n+   * @param columnName name of column.\n+   * @return column value.\n+   */\n+  Integer getInt(String columnName);\n+\n+  /**\n+   * Get the value for a particular column of the Row as a long.\n+   *\n+   * @param columnIndex index of column (1-indexed).\n+   * @return column value.\n+   */\n+  Long getLong(int columnIndex);\n+\n+  /**\n+   * Get the value for a particular column of the Row as a long.\n+   *\n+   * @param columnName name of column.\n+   * @return column value.\n+   */\n+  Long getLong(String columnName);\n+\n+  /**\n+   * Get the value for a particular column of the Row as a double.\n+   *\n+   * @param columnIndex index of column (1-indexed).\n+   * @return column value.\n+   */\n+  Double getDouble(int columnIndex);\n+\n+  /**\n+   * Get the value for a particular column of the Row as a double.\n+   *\n+   * @param columnName name of column.\n+   * @return column value.\n+   */\n+  Double getDouble(String columnName);\n+\n+  /**\n+   * Get the value for a particular column of the Row as a boolean.\n+   *\n+   * @param columnIndex index of column (1-indexed).\n+   * @return column value.\n+   */\n+  Boolean getBoolean(int columnIndex);\n+\n+  /**\n+   * Get the value for a particular column of the Row as a boolean.\n+   *\n+   * @param columnName name of column.\n+   * @return column value.\n+   */\n+  Boolean getBoolean(String columnName);\n+\n+  /**\n+   * Get the value for a particular column of the Row as a decimal.\n+   *\n+   * @param columnIndex index of column (1-indexed).\n+   * @return column value.\n+   */\n+  BigDecimal getDecimal(int columnIndex);\n+\n+  /**\n+   * Get the value for a particular column of the Row as a decimal.\n+   *\n+   * @param columnName name of column.\n+   * @return column value.\n+   */\n+  BigDecimal getDecimal(String columnName);\n+}\n+```\n+\n+We considered representing column types in a more structured form (rather than plain strings) to accomodate complex/nested data types but felt this added complexity would not be helpful for most use cases. (This would also require a server-side change, so it's a fair bit of additional work.)\n+\n+For `getDecimal(...)` in the `Row` interface, rather than trying to parse the column type to extract the precision and scale, we will simply convert the value to a BigDecimal without explicitly specifying the precision and scale. We could also add an option for users to specify the scale and precision in the getter, if we think that would be useful.\n+\n+We could also add `getList(...)` and `getMap(...)` methods to the `Row` interface, but it's not clear to me how valuable this would be given that the nested data types would not be known.\n+\n+Tim also proposed switching from generic Java types (`Map<String, Object>`, `List<Object>`) to Vert.x types (`JsonObject`, `JsonArray`) as the latter is more type-safe and the client already has a dependency on Vert.x anyway. The downside, though, is that then apps that use the client would be required to depend on Vert.x as well.\n+\n+### Transient queries -- Non-streaming\n+\n+The `Client` interface will also provide the following methods for receiving the results of a transient query (push or pull) in a single batch (non-streaming),\n+once the query has completed:\n+```\n+  /**\n+   * Execute a query (push or pull) and receive all result rows together, once the query has\n+   * completed.\n+   *\n+   * @param sql statement of query to execute.\n+   * @return query result.\n+   */\n+  CompletableFuture<List<Row>> executeQuery(String sql);\n+\n+  /**\n+   * Execute a query (push or pull) and receive all result rows together, once the query has\n+   * completed.\n+   *\n+   * @param sql statement of query to execute.\n+   * @param properties query properties.\n+   * @return query result.\n+   */\n+  CompletableFuture<List<Row>> executeQuery(String sql, Map<String, Object> properties);\n+```\n+\n+For a query to \"complete\" could mean:\n+* The query is a pull query\n+* The query is a push query with a limit clause, and the limit has been reached\n+* The query is a push query that has been terminated\n+\n+We may want to introduce a limit to the number of rows that may be returned from these `executeQuery()` methods,\n+in order to decrease the likelihood of running out of memory.\n+\n+### Insert values\n+\n+A method to insert one row at a time:\n+```\n+  /**\n+   * Insert a single row into the relevant stream/table.\n+   *\n+   * @param streamName name of stream/table.\n+   * @param row the row to insert.\n+   * @return a future that completes once the request has been processed.\n+   */\n+  CompletableFuture<Void> insertInto(String streamName, Map<String, Object> row);\n+```\n+\n+A method to stream inserts (via the `/inserts-stream` endpoint):\n+```\n+  CompletableFuture<Publisher<InsertResponse>> streamInserts(String streamName, Publisher<List<Object>> insertsPublisher);\n+}\n+```\n+where `InsertResponse` is as follows:\n+```\n+public interface InsertResponse {\n+\n+  /**\n+   * Whether the row was successfully inserted or not.\n+   */\n+  boolean isSuccessful();\n+\n+  /**\n+   * Unique sequence number for the row in the stream of inserts.\n+   */\n+  int getSequenceNum();\n+\n+  /**\n+   * If unsuccessful, the error message.\n+   */\n+  String getErrorMessage();\n+\n+  /**\n+   * If unsuccessful, the error code.\n+   */\n+  int getErrorCode();\n+\n+}\n+```\n+\n+### DDL/DML operations\n+\n+#### `CREATE <STREAM/TABLE>`, `CREATE <STREAM/TABLE> ... AS SELECT`, `INSERT INTO`\n+\n+`Client` methods:\n+```\n+  /**\n+   * Execute DDL statement: `CREATE STREAM`, `CREATE TABLE`\n+   */\n+  CompletableFuture<DdlResponse> executeDdl(String sql);\n+\n+  /**\n+   * Execute DML statement: `CREATE STREAM ... AS SELECT`, `CREATE TABLE ... AS SELECT`, `INSERT INTO`\n+   */\n+  CompletableFuture<DmlResponse> executeDml(String sql);\n+\n+  /**\n+   * Execute DML statement: `CREATE STREAM ... AS SELECT`, `CREATE TABLE ... AS SELECT`, `INSERT INTO`\n+   */\n+  CompletableFuture<DmlResponse> executeDml(String sql, Map<String, Object> properties);\n+\n+```\n+with\n+```\n+public interface DdlResponse {\n+\n+  enum Status { QUEUED, PARSING, EXECUTING, RUNNING, TERMINATED, SUCCESS, ERROR }\n+  \n+  Status getStatus();\n+  \n+  String getStatusMessage();\n+  \n+  long getCommandSequenceNumber();\n+\n+  String getCommandId();\n+}\n+```\n+and `DmlResponse` is identical.\n+\n+I don't love this proposal since `DDL` and `DML` aren't used throughout our docs but I'm not a huge fan of the alternatives I considered either, such as\n+```\n+  CompletableFuture<CreateSourceResponse> createStream(String sql);\n+\n+  CompletableFuture<CreateSourceResponse> createStream(String sql, Map<String, Object> properties);\n+\n+  CompletableFuture<CreateSourceResponse> createTable(String sql);\n+\n+  CompletableFuture<CreateSourceResponse> createTable(String sql, Map<String, Object> properties);\n+\n+  CompletableFuture<InsertIntoResponse> insertIntoSource(String sql);\n+\n+  CompletableFuture<InsertIntoResponse> insertIntoSource(String sql, Map<String, Object> properties);\n+```\n+\n+In this version, the implementations of `createStream(...)` and `createTable(...)` would be identical and could be replaced with a single `createSource(...)`\n+but the name of this method feels confusing. As with the previous proposal, `CreateSourceResponse` and `InsertIntoResponse` are identical.\n+\n+Other alternatives include separating `CREATE <STREAM/TABLE>` and `CREATE <STREAM/TABLE> ... AS SELECT` into separate methods, but that feels unnecessarily complex.\n+\n+#### `DROP <STREAM/TABLE>`\n+\n+`Client` methods:\n+```\n+  /**\n+   * Drop stream. The underlying Kafka topic will not be deleted.\n+   */\n+  CompletableFuture<DropSourceResponse> dropStream(String streamName);\n+\n+  /**\n+   * Drop stream. The underlying Kafka topic may optionally be deleted.\n+   */\n+  CompletableFuture<DropSourceResponse> dropStream(String streamName, boolean deleteTopic);\n+\n+  /**\n+   * Drop table. The underlying Kafka topic will not be deleted.\n+   */\n+  CompletableFuture<DropSourceResponse> dropTable(String tableName);\n+\n+  /**\n+   * Drop table. The underlying Kafka topic may optionally be deleted.\n+   */\n+  CompletableFuture<DropSourceResponse> dropTable(String tableName, boolean deleteTopic);\n+```\n+where `DropSourceResponse` is actually the same as `DdlResponse`/`DmlResponse`/`CreateSourceResponse`/`InsertIntoResponse` above.\n+\n+Again, the implementations of `dropStream(...)` and `dropTable(...)` would be the same so we could instead have a single `dropSource(...)`, but the naming might be confusing.\n+\n+If we choose to keep them separate, there's an open question of whether the client should validate that `dropStream(...)` is not used to drop a table, and vice versa.\n+IMO such validation would be introducing complexity without much benefit, though this point of ambiguity makes me prefer a single `dropSource(...)` if we can agree on a method name that's not confusing.\n+\n+Note that users can also execute `DROP <STREAM/TABLE>` requests via `executeDdl(...)` or `executDml(...)` above.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aed38d5836550829f7fd459df31b47aaf7e5ad45"}, "originalPosition": 506}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDAzNjU2NjYz", "url": "https://github.com/confluentinc/ksql/pull/5236#pullrequestreview-403656663", "createdAt": "2020-04-30T15:55:24Z", "commit": {"oid": "aed38d5836550829f7fd459df31b47aaf7e5ad45"}, "state": "COMMENTED", "comments": {"totalCount": 14, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0zMFQxNTo1NToyNFrOGOvuug==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0zMFQxNjozMzowNVrOGOxOGw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODExNTI1OA==", "bodyText": "to me, this sounds like it should be two different APIs and not the same class", "url": "https://github.com/confluentinc/ksql/pull/5236#discussion_r418115258", "createdAt": "2020-04-30T15:55:24Z", "author": {"login": "agavra"}, "path": "design-proposals/klip-26-java-client-interfaces.md", "diffHunk": "@@ -0,0 +1,715 @@\n+# KLIP 26 - Java client interfaces\n+\n+**Author**: Victoria Xia (@vcrfxia) | \n+**Release Target**: ksqlDB 0.10.0 | \n+**Status**: _In development_ | \n+**Discussion**: TBD\n+\n+**tl;dr:** _[KLIP 15](./klip-15-new-api-and-client.md) already made the case for why it makes sense\n+           to introduce a Java client for ksqlDB. This KLIP proposes interfaces for the client._\n+\n+## Motivation and background\n+\n+See [KLIP 15](./klip-15-new-api-and-client.md).\n+\n+## What is in scope\n+\n+The Java client will support the following operations:\n+* Push query\n+* Pull query\n+* Select DDL/DML operations:\n+    * `CREATE STREAM`\n+    * `CREATE TABLE`\n+    * `CREATE STREAM ... AS SELECT`\n+    * `CREATE TABLE ... AS SELECT`\n+    * `DROP STREAM`\n+    * `DROP TABLE`\n+    * `INSERT INTO`\n+    * `TERMINATE <queryId>`\n+    * `CREATE CONNECTOR`\n+    * `DROP CONNECTOR`\n+* Select admin operations:\n+    * `SHOW TOPICS` (non-extended)\n+    * `SHOW STREAMS` (non-extended)\n+    * `SHOW TABLES` (non-extended)\n+    * `SHOW QUERIES` (non-extended)\n+    * `SHOW CONNECTORS`\n+* Insert values, i.e., insert rows into an existing stream/table\n+* Terminate push query (via the `/close-query` endpoint)\n+\n+The purpose of this KLIP is to reach agreement on the interfaces / public APIs.\n+Implementation details will not be covered.\n+\n+## What is not in scope\n+\n+This KLIP does not cover Java client support for the following:\n+* `DESCRIBE <stream/table>`, `DESCRIBE CONNECTOR`, `DESCRIBE FUNCTION`\n+* `EXPLAIN <queryId>`\n+* `PRINT <topic>`\n+* `SHOW TOPICS EXTENDED`, `SHOW <STREAMS/TABLES> EXTENDED`, `SHOW QUERIES EXTENDED`\n+* `CREATE TYPE`, `DROP TYPE`, `SHOW TYPES`\n+* `SHOW FUNCTIONS`, `SHOW PROPERTIES`\n+* `RUN SCRIPT`\n+* Use of other endpoints (info, healthcheck, terminate cluster, status, etc.)\n+\n+We can always add support for these operations in the future if desired.\n+\n+As above, implementation details are out of scope as the purpose of this KLIP is to reach agreement\n+on the interfaces / public APIs.\n+\n+## Value/Return\n+\n+See [KLIP 15](./klip-15-new-api-and-client.md).\n+\n+## Public APIS\n+\n+The following subsections describe the methods of the `Client` interface:\n+```\n+public interface Client {\n+    ...\n+}\n+```\n+\n+### Constructors\n+```\n+  static Client create(ClientOptions clientOptions) {\n+    return new ClientImpl(clientOptions);\n+  }\n+\n+  static Client create(ClientOptions clientOptions, Vertx vertx) {\n+    return new ClientImpl(clientOptions, vertx);\n+  }\n+```\n+\n+The Java client will be implemented as a Vert.x HttpClient. We expose a constructor that allows users to provide their own `Vertx` instance\n+in order to take advantage of a shared connection pool and other properties if desired.\n+\n+`ClientOptions` will initially be as follows:\n+```\n+public interface ClientOptions {\n+\n+  ClientOptions setHost(String host);\n+\n+  ClientOptions setPort(int port);\n+\n+  ClientOptions setUseTls(boolean useTls);\n+\n+  ClientOptions setUseClientAuth(boolean useClientAuth);\n+\n+  ClientOptions setTrustStore(String trustStorePath);\n+\n+  ClientOptions setTrustStorePassword(String trustStorePassword);\n+\n+  ClientOptions setKeyStore(String keyStorePath);\n+\n+  ClientOptions setKeyStorePassword(String keyStorePassword);\n+\n+  ClientOptions setBasicAuthCredentials(String username, String password);\n+\n+  String getHost();\n+\n+  int getPort();\n+\n+  boolean isUseTls();\n+\n+  boolean isUseClientAuth();\n+\n+  boolean isUseBasicAuth();\n+\n+  String getTrustStore();\n+\n+  String getTrustStorePassword();\n+\n+  String getKeyStore();\n+\n+  String getKeyStorePassword();\n+\n+  String getBasicAuthUsername();\n+\n+  String getBasicAuthPassword();\n+\n+  ClientOptions copy();\n+\n+  static ClientOptions create() {\n+    return new ClientOptionsImpl();\n+  }\n+}\n+```\n+\n+We can always add additional configuration options later. We may also wish to expose the Vert.x `HttpClientOptions` for\n+advanced users that wish to provide custom configs.\n+\n+### Transient queries -- Streaming\n+\n+The `Client` interface will provide the following methods for streaming the results of a transient (push or pull) query:\n+```\n+  /**\n+   * Execute a query (push or pull) and receive the results one row at a time.\n+   *\n+   * @param sql statement of query to execute.\n+   * @return query result.\n+   */\n+  CompletableFuture<QueryResult> streamQuery(String sql);\n+\n+  /**\n+   * Execute a query (push or pull) and receive the results one row at a time.\n+   *\n+   * @param sql statement of query to execute.\n+   * @param properties query properties.\n+   * @return query result.\n+   */\n+  CompletableFuture<QueryResult> streamQuery(String sql, Map<String, Object> properties);\n+```\n+where `QueryResult` is as follows:\n+```\n+/**\n+ * The result of a query (push or pull), streamed one row at time. Records may be consumed by either\n+ * subscribing to the publisher or polling (blocking) for one record at a time. These two methods of\n+ * consumption are mutually exclusive; only one method may be used (per QueryResult).", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aed38d5836550829f7fd459df31b47aaf7e5ad45"}, "originalPosition": 168}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODExOTI5NQ==", "bodyText": "what happens if you call any of these methods on a column that isn't of the specified type?", "url": "https://github.com/confluentinc/ksql/pull/5236#discussion_r418119295", "createdAt": "2020-04-30T16:01:27Z", "author": {"login": "agavra"}, "path": "design-proposals/klip-26-java-client-interfaces.md", "diffHunk": "@@ -0,0 +1,715 @@\n+# KLIP 26 - Java client interfaces\n+\n+**Author**: Victoria Xia (@vcrfxia) | \n+**Release Target**: ksqlDB 0.10.0 | \n+**Status**: _In development_ | \n+**Discussion**: TBD\n+\n+**tl;dr:** _[KLIP 15](./klip-15-new-api-and-client.md) already made the case for why it makes sense\n+           to introduce a Java client for ksqlDB. This KLIP proposes interfaces for the client._\n+\n+## Motivation and background\n+\n+See [KLIP 15](./klip-15-new-api-and-client.md).\n+\n+## What is in scope\n+\n+The Java client will support the following operations:\n+* Push query\n+* Pull query\n+* Select DDL/DML operations:\n+    * `CREATE STREAM`\n+    * `CREATE TABLE`\n+    * `CREATE STREAM ... AS SELECT`\n+    * `CREATE TABLE ... AS SELECT`\n+    * `DROP STREAM`\n+    * `DROP TABLE`\n+    * `INSERT INTO`\n+    * `TERMINATE <queryId>`\n+    * `CREATE CONNECTOR`\n+    * `DROP CONNECTOR`\n+* Select admin operations:\n+    * `SHOW TOPICS` (non-extended)\n+    * `SHOW STREAMS` (non-extended)\n+    * `SHOW TABLES` (non-extended)\n+    * `SHOW QUERIES` (non-extended)\n+    * `SHOW CONNECTORS`\n+* Insert values, i.e., insert rows into an existing stream/table\n+* Terminate push query (via the `/close-query` endpoint)\n+\n+The purpose of this KLIP is to reach agreement on the interfaces / public APIs.\n+Implementation details will not be covered.\n+\n+## What is not in scope\n+\n+This KLIP does not cover Java client support for the following:\n+* `DESCRIBE <stream/table>`, `DESCRIBE CONNECTOR`, `DESCRIBE FUNCTION`\n+* `EXPLAIN <queryId>`\n+* `PRINT <topic>`\n+* `SHOW TOPICS EXTENDED`, `SHOW <STREAMS/TABLES> EXTENDED`, `SHOW QUERIES EXTENDED`\n+* `CREATE TYPE`, `DROP TYPE`, `SHOW TYPES`\n+* `SHOW FUNCTIONS`, `SHOW PROPERTIES`\n+* `RUN SCRIPT`\n+* Use of other endpoints (info, healthcheck, terminate cluster, status, etc.)\n+\n+We can always add support for these operations in the future if desired.\n+\n+As above, implementation details are out of scope as the purpose of this KLIP is to reach agreement\n+on the interfaces / public APIs.\n+\n+## Value/Return\n+\n+See [KLIP 15](./klip-15-new-api-and-client.md).\n+\n+## Public APIS\n+\n+The following subsections describe the methods of the `Client` interface:\n+```\n+public interface Client {\n+    ...\n+}\n+```\n+\n+### Constructors\n+```\n+  static Client create(ClientOptions clientOptions) {\n+    return new ClientImpl(clientOptions);\n+  }\n+\n+  static Client create(ClientOptions clientOptions, Vertx vertx) {\n+    return new ClientImpl(clientOptions, vertx);\n+  }\n+```\n+\n+The Java client will be implemented as a Vert.x HttpClient. We expose a constructor that allows users to provide their own `Vertx` instance\n+in order to take advantage of a shared connection pool and other properties if desired.\n+\n+`ClientOptions` will initially be as follows:\n+```\n+public interface ClientOptions {\n+\n+  ClientOptions setHost(String host);\n+\n+  ClientOptions setPort(int port);\n+\n+  ClientOptions setUseTls(boolean useTls);\n+\n+  ClientOptions setUseClientAuth(boolean useClientAuth);\n+\n+  ClientOptions setTrustStore(String trustStorePath);\n+\n+  ClientOptions setTrustStorePassword(String trustStorePassword);\n+\n+  ClientOptions setKeyStore(String keyStorePath);\n+\n+  ClientOptions setKeyStorePassword(String keyStorePassword);\n+\n+  ClientOptions setBasicAuthCredentials(String username, String password);\n+\n+  String getHost();\n+\n+  int getPort();\n+\n+  boolean isUseTls();\n+\n+  boolean isUseClientAuth();\n+\n+  boolean isUseBasicAuth();\n+\n+  String getTrustStore();\n+\n+  String getTrustStorePassword();\n+\n+  String getKeyStore();\n+\n+  String getKeyStorePassword();\n+\n+  String getBasicAuthUsername();\n+\n+  String getBasicAuthPassword();\n+\n+  ClientOptions copy();\n+\n+  static ClientOptions create() {\n+    return new ClientOptionsImpl();\n+  }\n+}\n+```\n+\n+We can always add additional configuration options later. We may also wish to expose the Vert.x `HttpClientOptions` for\n+advanced users that wish to provide custom configs.\n+\n+### Transient queries -- Streaming\n+\n+The `Client` interface will provide the following methods for streaming the results of a transient (push or pull) query:\n+```\n+  /**\n+   * Execute a query (push or pull) and receive the results one row at a time.\n+   *\n+   * @param sql statement of query to execute.\n+   * @return query result.\n+   */\n+  CompletableFuture<QueryResult> streamQuery(String sql);\n+\n+  /**\n+   * Execute a query (push or pull) and receive the results one row at a time.\n+   *\n+   * @param sql statement of query to execute.\n+   * @param properties query properties.\n+   * @return query result.\n+   */\n+  CompletableFuture<QueryResult> streamQuery(String sql, Map<String, Object> properties);\n+```\n+where `QueryResult` is as follows:\n+```\n+/**\n+ * The result of a query (push or pull), streamed one row at time. Records may be consumed by either\n+ * subscribing to the publisher or polling (blocking) for one record at a time. These two methods of\n+ * consumption are mutually exclusive; only one method may be used (per QueryResult).\n+ */\n+public interface QueryResult extends Publisher<Row> {\n+\n+  List<String> columnNames();\n+\n+  List<String> columnTypes();\n+\n+  String queryID();\n+\n+  /**\n+   * Block until a row becomes available.\n+   *\n+   * @return the row.\n+   */\n+  Row poll();\n+\n+  /**\n+   * Block until a row becomes available or the timeout has elapsed.\n+   *\n+   * @param timeout amount of to wait for a row. Non-positive values are interpreted as no timeout.\n+   * @param timeUnit unit for timeout param.\n+   * @return the row, if available; else, null.\n+   */\n+  Row poll(long timeout, TimeUnit timeUnit);\n+\n+  boolean isComplete();\n+\n+  void close();\n+}\n+```\n+Note that `QueryResult` is a Reactive Streams `Publisher` so users can stream results. Users can also call `poll()` to receive\n+results in a synchronous fashion instead. Only one of the two methods will be allowed per `QueryResult` instance.\n+\n+The `Row` interface is as follows:\n+```\n+/**\n+ * A single record, returned as part of a query result.\n+ */\n+public interface Row {\n+\n+  List<String> columnNames();\n+\n+  List<String> columnTypes();\n+\n+  List<Object> values();\n+\n+  /**\n+   * Get the value for a particular column of the Row as an Object.\n+   *\n+   * @param columnIndex index of column (1-indexed).\n+   * @return column value.\n+   */\n+  Object getObject(int columnIndex);\n+\n+  /**\n+   * Get the value for a particular column of the Row as an Object.\n+   *\n+   * @param columnName name of column.\n+   * @return column value.\n+   */\n+  Object getObject(String columnName);\n+\n+  /**\n+   * Get the value for a particular column of the Row as a string.\n+   *\n+   * @param columnIndex index of column (1-indexed).\n+   * @return column value.\n+   */\n+  String getString(int columnIndex);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aed38d5836550829f7fd459df31b47aaf7e5ad45"}, "originalPosition": 237}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODEyMjk3Ng==", "bodyText": "I originally commented this above, but I see that you've thought this through. I tend to disagree here - having strings as column types seems somewhat annoying. Every time I want to programatically get a field I'll need to parse the type and that's not something that's easy (especially for Structs). It will also make it so that each location that is using types will need to re-parse it, instead of having the parsing done once when we construct the type and pass it around alongside the Row object. This will also make it harder for us to adjust our type system because we could accidentally break third-party parsers when maintaining backwards compatibility.\nIn general, exposing \"String\" for data types is always super error prone - I'd urge against it if possible. At a minimum, we should wrap the string in a ColumnType class so that later we can add methods that will do the parsing for the user.", "url": "https://github.com/confluentinc/ksql/pull/5236#discussion_r418122976", "createdAt": "2020-04-30T16:06:59Z", "author": {"login": "agavra"}, "path": "design-proposals/klip-26-java-client-interfaces.md", "diffHunk": "@@ -0,0 +1,715 @@\n+# KLIP 26 - Java client interfaces\n+\n+**Author**: Victoria Xia (@vcrfxia) | \n+**Release Target**: ksqlDB 0.10.0 | \n+**Status**: _In development_ | \n+**Discussion**: TBD\n+\n+**tl;dr:** _[KLIP 15](./klip-15-new-api-and-client.md) already made the case for why it makes sense\n+           to introduce a Java client for ksqlDB. This KLIP proposes interfaces for the client._\n+\n+## Motivation and background\n+\n+See [KLIP 15](./klip-15-new-api-and-client.md).\n+\n+## What is in scope\n+\n+The Java client will support the following operations:\n+* Push query\n+* Pull query\n+* Select DDL/DML operations:\n+    * `CREATE STREAM`\n+    * `CREATE TABLE`\n+    * `CREATE STREAM ... AS SELECT`\n+    * `CREATE TABLE ... AS SELECT`\n+    * `DROP STREAM`\n+    * `DROP TABLE`\n+    * `INSERT INTO`\n+    * `TERMINATE <queryId>`\n+    * `CREATE CONNECTOR`\n+    * `DROP CONNECTOR`\n+* Select admin operations:\n+    * `SHOW TOPICS` (non-extended)\n+    * `SHOW STREAMS` (non-extended)\n+    * `SHOW TABLES` (non-extended)\n+    * `SHOW QUERIES` (non-extended)\n+    * `SHOW CONNECTORS`\n+* Insert values, i.e., insert rows into an existing stream/table\n+* Terminate push query (via the `/close-query` endpoint)\n+\n+The purpose of this KLIP is to reach agreement on the interfaces / public APIs.\n+Implementation details will not be covered.\n+\n+## What is not in scope\n+\n+This KLIP does not cover Java client support for the following:\n+* `DESCRIBE <stream/table>`, `DESCRIBE CONNECTOR`, `DESCRIBE FUNCTION`\n+* `EXPLAIN <queryId>`\n+* `PRINT <topic>`\n+* `SHOW TOPICS EXTENDED`, `SHOW <STREAMS/TABLES> EXTENDED`, `SHOW QUERIES EXTENDED`\n+* `CREATE TYPE`, `DROP TYPE`, `SHOW TYPES`\n+* `SHOW FUNCTIONS`, `SHOW PROPERTIES`\n+* `RUN SCRIPT`\n+* Use of other endpoints (info, healthcheck, terminate cluster, status, etc.)\n+\n+We can always add support for these operations in the future if desired.\n+\n+As above, implementation details are out of scope as the purpose of this KLIP is to reach agreement\n+on the interfaces / public APIs.\n+\n+## Value/Return\n+\n+See [KLIP 15](./klip-15-new-api-and-client.md).\n+\n+## Public APIS\n+\n+The following subsections describe the methods of the `Client` interface:\n+```\n+public interface Client {\n+    ...\n+}\n+```\n+\n+### Constructors\n+```\n+  static Client create(ClientOptions clientOptions) {\n+    return new ClientImpl(clientOptions);\n+  }\n+\n+  static Client create(ClientOptions clientOptions, Vertx vertx) {\n+    return new ClientImpl(clientOptions, vertx);\n+  }\n+```\n+\n+The Java client will be implemented as a Vert.x HttpClient. We expose a constructor that allows users to provide their own `Vertx` instance\n+in order to take advantage of a shared connection pool and other properties if desired.\n+\n+`ClientOptions` will initially be as follows:\n+```\n+public interface ClientOptions {\n+\n+  ClientOptions setHost(String host);\n+\n+  ClientOptions setPort(int port);\n+\n+  ClientOptions setUseTls(boolean useTls);\n+\n+  ClientOptions setUseClientAuth(boolean useClientAuth);\n+\n+  ClientOptions setTrustStore(String trustStorePath);\n+\n+  ClientOptions setTrustStorePassword(String trustStorePassword);\n+\n+  ClientOptions setKeyStore(String keyStorePath);\n+\n+  ClientOptions setKeyStorePassword(String keyStorePassword);\n+\n+  ClientOptions setBasicAuthCredentials(String username, String password);\n+\n+  String getHost();\n+\n+  int getPort();\n+\n+  boolean isUseTls();\n+\n+  boolean isUseClientAuth();\n+\n+  boolean isUseBasicAuth();\n+\n+  String getTrustStore();\n+\n+  String getTrustStorePassword();\n+\n+  String getKeyStore();\n+\n+  String getKeyStorePassword();\n+\n+  String getBasicAuthUsername();\n+\n+  String getBasicAuthPassword();\n+\n+  ClientOptions copy();\n+\n+  static ClientOptions create() {\n+    return new ClientOptionsImpl();\n+  }\n+}\n+```\n+\n+We can always add additional configuration options later. We may also wish to expose the Vert.x `HttpClientOptions` for\n+advanced users that wish to provide custom configs.\n+\n+### Transient queries -- Streaming\n+\n+The `Client` interface will provide the following methods for streaming the results of a transient (push or pull) query:\n+```\n+  /**\n+   * Execute a query (push or pull) and receive the results one row at a time.\n+   *\n+   * @param sql statement of query to execute.\n+   * @return query result.\n+   */\n+  CompletableFuture<QueryResult> streamQuery(String sql);\n+\n+  /**\n+   * Execute a query (push or pull) and receive the results one row at a time.\n+   *\n+   * @param sql statement of query to execute.\n+   * @param properties query properties.\n+   * @return query result.\n+   */\n+  CompletableFuture<QueryResult> streamQuery(String sql, Map<String, Object> properties);\n+```\n+where `QueryResult` is as follows:\n+```\n+/**\n+ * The result of a query (push or pull), streamed one row at time. Records may be consumed by either\n+ * subscribing to the publisher or polling (blocking) for one record at a time. These two methods of\n+ * consumption are mutually exclusive; only one method may be used (per QueryResult).\n+ */\n+public interface QueryResult extends Publisher<Row> {\n+\n+  List<String> columnNames();\n+\n+  List<String> columnTypes();\n+\n+  String queryID();\n+\n+  /**\n+   * Block until a row becomes available.\n+   *\n+   * @return the row.\n+   */\n+  Row poll();\n+\n+  /**\n+   * Block until a row becomes available or the timeout has elapsed.\n+   *\n+   * @param timeout amount of to wait for a row. Non-positive values are interpreted as no timeout.\n+   * @param timeUnit unit for timeout param.\n+   * @return the row, if available; else, null.\n+   */\n+  Row poll(long timeout, TimeUnit timeUnit);\n+\n+  boolean isComplete();\n+\n+  void close();\n+}\n+```\n+Note that `QueryResult` is a Reactive Streams `Publisher` so users can stream results. Users can also call `poll()` to receive\n+results in a synchronous fashion instead. Only one of the two methods will be allowed per `QueryResult` instance.\n+\n+The `Row` interface is as follows:\n+```\n+/**\n+ * A single record, returned as part of a query result.\n+ */\n+public interface Row {\n+\n+  List<String> columnNames();\n+\n+  List<String> columnTypes();\n+\n+  List<Object> values();\n+\n+  /**\n+   * Get the value for a particular column of the Row as an Object.\n+   *\n+   * @param columnIndex index of column (1-indexed).\n+   * @return column value.\n+   */\n+  Object getObject(int columnIndex);\n+\n+  /**\n+   * Get the value for a particular column of the Row as an Object.\n+   *\n+   * @param columnName name of column.\n+   * @return column value.\n+   */\n+  Object getObject(String columnName);\n+\n+  /**\n+   * Get the value for a particular column of the Row as a string.\n+   *\n+   * @param columnIndex index of column (1-indexed).\n+   * @return column value.\n+   */\n+  String getString(int columnIndex);\n+\n+  /**\n+   * Get the value for a particular column of the Row as a string.\n+   *\n+   * @param columnName name of column.\n+   * @return column value.\n+   */\n+  String getString(String columnName);\n+\n+  /**\n+   * Get the value for a particular column of the Row as an integer.\n+   *\n+   * @param columnIndex index of column (1-indexed).\n+   * @return column value.\n+   */\n+  Integer getInt(int columnIndex);\n+\n+  /**\n+   * Get the value for a particular column of the Row as an integer.\n+   *\n+   * @param columnName name of column.\n+   * @return column value.\n+   */\n+  Integer getInt(String columnName);\n+\n+  /**\n+   * Get the value for a particular column of the Row as a long.\n+   *\n+   * @param columnIndex index of column (1-indexed).\n+   * @return column value.\n+   */\n+  Long getLong(int columnIndex);\n+\n+  /**\n+   * Get the value for a particular column of the Row as a long.\n+   *\n+   * @param columnName name of column.\n+   * @return column value.\n+   */\n+  Long getLong(String columnName);\n+\n+  /**\n+   * Get the value for a particular column of the Row as a double.\n+   *\n+   * @param columnIndex index of column (1-indexed).\n+   * @return column value.\n+   */\n+  Double getDouble(int columnIndex);\n+\n+  /**\n+   * Get the value for a particular column of the Row as a double.\n+   *\n+   * @param columnName name of column.\n+   * @return column value.\n+   */\n+  Double getDouble(String columnName);\n+\n+  /**\n+   * Get the value for a particular column of the Row as a boolean.\n+   *\n+   * @param columnIndex index of column (1-indexed).\n+   * @return column value.\n+   */\n+  Boolean getBoolean(int columnIndex);\n+\n+  /**\n+   * Get the value for a particular column of the Row as a boolean.\n+   *\n+   * @param columnName name of column.\n+   * @return column value.\n+   */\n+  Boolean getBoolean(String columnName);\n+\n+  /**\n+   * Get the value for a particular column of the Row as a decimal.\n+   *\n+   * @param columnIndex index of column (1-indexed).\n+   * @return column value.\n+   */\n+  BigDecimal getDecimal(int columnIndex);\n+\n+  /**\n+   * Get the value for a particular column of the Row as a decimal.\n+   *\n+   * @param columnName name of column.\n+   * @return column value.\n+   */\n+  BigDecimal getDecimal(String columnName);\n+}\n+```\n+\n+We considered representing column types in a more structured form (rather than plain strings) to accomodate complex/nested data types but felt this added complexity would not be helpful for most use cases. (This would also require a server-side change, so it's a fair bit of additional work.)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aed38d5836550829f7fd459df31b47aaf7e5ad45"}, "originalPosition": 329}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODEyNDk5NA==", "bodyText": "+1 to exposing Map not Json* I also prefer exposing interfaces, not classes, so that we have freedom about how we want to implement it underneath the hood. In other systems I've worked on we've done lots of optimizations around the clients in completely backwards compatible ways because we could play around with the return type (e.g. lazily parsing nested fields)", "url": "https://github.com/confluentinc/ksql/pull/5236#discussion_r418124994", "createdAt": "2020-04-30T16:10:04Z", "author": {"login": "agavra"}, "path": "design-proposals/klip-26-java-client-interfaces.md", "diffHunk": "@@ -0,0 +1,715 @@\n+# KLIP 26 - Java client interfaces\n+\n+**Author**: Victoria Xia (@vcrfxia) | \n+**Release Target**: ksqlDB 0.10.0 | \n+**Status**: _In development_ | \n+**Discussion**: TBD\n+\n+**tl;dr:** _[KLIP 15](./klip-15-new-api-and-client.md) already made the case for why it makes sense\n+           to introduce a Java client for ksqlDB. This KLIP proposes interfaces for the client._\n+\n+## Motivation and background\n+\n+See [KLIP 15](./klip-15-new-api-and-client.md).\n+\n+## What is in scope\n+\n+The Java client will support the following operations:\n+* Push query\n+* Pull query\n+* Select DDL/DML operations:\n+    * `CREATE STREAM`\n+    * `CREATE TABLE`\n+    * `CREATE STREAM ... AS SELECT`\n+    * `CREATE TABLE ... AS SELECT`\n+    * `DROP STREAM`\n+    * `DROP TABLE`\n+    * `INSERT INTO`\n+    * `TERMINATE <queryId>`\n+    * `CREATE CONNECTOR`\n+    * `DROP CONNECTOR`\n+* Select admin operations:\n+    * `SHOW TOPICS` (non-extended)\n+    * `SHOW STREAMS` (non-extended)\n+    * `SHOW TABLES` (non-extended)\n+    * `SHOW QUERIES` (non-extended)\n+    * `SHOW CONNECTORS`\n+* Insert values, i.e., insert rows into an existing stream/table\n+* Terminate push query (via the `/close-query` endpoint)\n+\n+The purpose of this KLIP is to reach agreement on the interfaces / public APIs.\n+Implementation details will not be covered.\n+\n+## What is not in scope\n+\n+This KLIP does not cover Java client support for the following:\n+* `DESCRIBE <stream/table>`, `DESCRIBE CONNECTOR`, `DESCRIBE FUNCTION`\n+* `EXPLAIN <queryId>`\n+* `PRINT <topic>`\n+* `SHOW TOPICS EXTENDED`, `SHOW <STREAMS/TABLES> EXTENDED`, `SHOW QUERIES EXTENDED`\n+* `CREATE TYPE`, `DROP TYPE`, `SHOW TYPES`\n+* `SHOW FUNCTIONS`, `SHOW PROPERTIES`\n+* `RUN SCRIPT`\n+* Use of other endpoints (info, healthcheck, terminate cluster, status, etc.)\n+\n+We can always add support for these operations in the future if desired.\n+\n+As above, implementation details are out of scope as the purpose of this KLIP is to reach agreement\n+on the interfaces / public APIs.\n+\n+## Value/Return\n+\n+See [KLIP 15](./klip-15-new-api-and-client.md).\n+\n+## Public APIS\n+\n+The following subsections describe the methods of the `Client` interface:\n+```\n+public interface Client {\n+    ...\n+}\n+```\n+\n+### Constructors\n+```\n+  static Client create(ClientOptions clientOptions) {\n+    return new ClientImpl(clientOptions);\n+  }\n+\n+  static Client create(ClientOptions clientOptions, Vertx vertx) {\n+    return new ClientImpl(clientOptions, vertx);\n+  }\n+```\n+\n+The Java client will be implemented as a Vert.x HttpClient. We expose a constructor that allows users to provide their own `Vertx` instance\n+in order to take advantage of a shared connection pool and other properties if desired.\n+\n+`ClientOptions` will initially be as follows:\n+```\n+public interface ClientOptions {\n+\n+  ClientOptions setHost(String host);\n+\n+  ClientOptions setPort(int port);\n+\n+  ClientOptions setUseTls(boolean useTls);\n+\n+  ClientOptions setUseClientAuth(boolean useClientAuth);\n+\n+  ClientOptions setTrustStore(String trustStorePath);\n+\n+  ClientOptions setTrustStorePassword(String trustStorePassword);\n+\n+  ClientOptions setKeyStore(String keyStorePath);\n+\n+  ClientOptions setKeyStorePassword(String keyStorePassword);\n+\n+  ClientOptions setBasicAuthCredentials(String username, String password);\n+\n+  String getHost();\n+\n+  int getPort();\n+\n+  boolean isUseTls();\n+\n+  boolean isUseClientAuth();\n+\n+  boolean isUseBasicAuth();\n+\n+  String getTrustStore();\n+\n+  String getTrustStorePassword();\n+\n+  String getKeyStore();\n+\n+  String getKeyStorePassword();\n+\n+  String getBasicAuthUsername();\n+\n+  String getBasicAuthPassword();\n+\n+  ClientOptions copy();\n+\n+  static ClientOptions create() {\n+    return new ClientOptionsImpl();\n+  }\n+}\n+```\n+\n+We can always add additional configuration options later. We may also wish to expose the Vert.x `HttpClientOptions` for\n+advanced users that wish to provide custom configs.\n+\n+### Transient queries -- Streaming\n+\n+The `Client` interface will provide the following methods for streaming the results of a transient (push or pull) query:\n+```\n+  /**\n+   * Execute a query (push or pull) and receive the results one row at a time.\n+   *\n+   * @param sql statement of query to execute.\n+   * @return query result.\n+   */\n+  CompletableFuture<QueryResult> streamQuery(String sql);\n+\n+  /**\n+   * Execute a query (push or pull) and receive the results one row at a time.\n+   *\n+   * @param sql statement of query to execute.\n+   * @param properties query properties.\n+   * @return query result.\n+   */\n+  CompletableFuture<QueryResult> streamQuery(String sql, Map<String, Object> properties);\n+```\n+where `QueryResult` is as follows:\n+```\n+/**\n+ * The result of a query (push or pull), streamed one row at time. Records may be consumed by either\n+ * subscribing to the publisher or polling (blocking) for one record at a time. These two methods of\n+ * consumption are mutually exclusive; only one method may be used (per QueryResult).\n+ */\n+public interface QueryResult extends Publisher<Row> {\n+\n+  List<String> columnNames();\n+\n+  List<String> columnTypes();\n+\n+  String queryID();\n+\n+  /**\n+   * Block until a row becomes available.\n+   *\n+   * @return the row.\n+   */\n+  Row poll();\n+\n+  /**\n+   * Block until a row becomes available or the timeout has elapsed.\n+   *\n+   * @param timeout amount of to wait for a row. Non-positive values are interpreted as no timeout.\n+   * @param timeUnit unit for timeout param.\n+   * @return the row, if available; else, null.\n+   */\n+  Row poll(long timeout, TimeUnit timeUnit);\n+\n+  boolean isComplete();\n+\n+  void close();\n+}\n+```\n+Note that `QueryResult` is a Reactive Streams `Publisher` so users can stream results. Users can also call `poll()` to receive\n+results in a synchronous fashion instead. Only one of the two methods will be allowed per `QueryResult` instance.\n+\n+The `Row` interface is as follows:\n+```\n+/**\n+ * A single record, returned as part of a query result.\n+ */\n+public interface Row {\n+\n+  List<String> columnNames();\n+\n+  List<String> columnTypes();\n+\n+  List<Object> values();\n+\n+  /**\n+   * Get the value for a particular column of the Row as an Object.\n+   *\n+   * @param columnIndex index of column (1-indexed).\n+   * @return column value.\n+   */\n+  Object getObject(int columnIndex);\n+\n+  /**\n+   * Get the value for a particular column of the Row as an Object.\n+   *\n+   * @param columnName name of column.\n+   * @return column value.\n+   */\n+  Object getObject(String columnName);\n+\n+  /**\n+   * Get the value for a particular column of the Row as a string.\n+   *\n+   * @param columnIndex index of column (1-indexed).\n+   * @return column value.\n+   */\n+  String getString(int columnIndex);\n+\n+  /**\n+   * Get the value for a particular column of the Row as a string.\n+   *\n+   * @param columnName name of column.\n+   * @return column value.\n+   */\n+  String getString(String columnName);\n+\n+  /**\n+   * Get the value for a particular column of the Row as an integer.\n+   *\n+   * @param columnIndex index of column (1-indexed).\n+   * @return column value.\n+   */\n+  Integer getInt(int columnIndex);\n+\n+  /**\n+   * Get the value for a particular column of the Row as an integer.\n+   *\n+   * @param columnName name of column.\n+   * @return column value.\n+   */\n+  Integer getInt(String columnName);\n+\n+  /**\n+   * Get the value for a particular column of the Row as a long.\n+   *\n+   * @param columnIndex index of column (1-indexed).\n+   * @return column value.\n+   */\n+  Long getLong(int columnIndex);\n+\n+  /**\n+   * Get the value for a particular column of the Row as a long.\n+   *\n+   * @param columnName name of column.\n+   * @return column value.\n+   */\n+  Long getLong(String columnName);\n+\n+  /**\n+   * Get the value for a particular column of the Row as a double.\n+   *\n+   * @param columnIndex index of column (1-indexed).\n+   * @return column value.\n+   */\n+  Double getDouble(int columnIndex);\n+\n+  /**\n+   * Get the value for a particular column of the Row as a double.\n+   *\n+   * @param columnName name of column.\n+   * @return column value.\n+   */\n+  Double getDouble(String columnName);\n+\n+  /**\n+   * Get the value for a particular column of the Row as a boolean.\n+   *\n+   * @param columnIndex index of column (1-indexed).\n+   * @return column value.\n+   */\n+  Boolean getBoolean(int columnIndex);\n+\n+  /**\n+   * Get the value for a particular column of the Row as a boolean.\n+   *\n+   * @param columnName name of column.\n+   * @return column value.\n+   */\n+  Boolean getBoolean(String columnName);\n+\n+  /**\n+   * Get the value for a particular column of the Row as a decimal.\n+   *\n+   * @param columnIndex index of column (1-indexed).\n+   * @return column value.\n+   */\n+  BigDecimal getDecimal(int columnIndex);\n+\n+  /**\n+   * Get the value for a particular column of the Row as a decimal.\n+   *\n+   * @param columnName name of column.\n+   * @return column value.\n+   */\n+  BigDecimal getDecimal(String columnName);\n+}\n+```\n+\n+We considered representing column types in a more structured form (rather than plain strings) to accomodate complex/nested data types but felt this added complexity would not be helpful for most use cases. (This would also require a server-side change, so it's a fair bit of additional work.)\n+\n+For `getDecimal(...)` in the `Row` interface, rather than trying to parse the column type to extract the precision and scale, we will simply convert the value to a BigDecimal without explicitly specifying the precision and scale. We could also add an option for users to specify the scale and precision in the getter, if we think that would be useful.\n+\n+We could also add `getList(...)` and `getMap(...)` methods to the `Row` interface, but it's not clear to me how valuable this would be given that the nested data types would not be known.\n+\n+Tim also proposed switching from generic Java types (`Map<String, Object>`, `List<Object>`) to Vert.x types (`JsonObject`, `JsonArray`) as the latter is more type-safe and the client already has a dependency on Vert.x anyway. The downside, though, is that then apps that use the client would be required to depend on Vert.x as well.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aed38d5836550829f7fd459df31b47aaf7e5ad45"}, "originalPosition": 335}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODEzMDQzNQ==", "bodyText": "maybe i'm missing something, but how do you terminate a push query using the client if you're waiting on it?", "url": "https://github.com/confluentinc/ksql/pull/5236#discussion_r418130435", "createdAt": "2020-04-30T16:18:27Z", "author": {"login": "agavra"}, "path": "design-proposals/klip-26-java-client-interfaces.md", "diffHunk": "@@ -0,0 +1,715 @@\n+# KLIP 26 - Java client interfaces\n+\n+**Author**: Victoria Xia (@vcrfxia) | \n+**Release Target**: ksqlDB 0.10.0 | \n+**Status**: _In development_ | \n+**Discussion**: TBD\n+\n+**tl;dr:** _[KLIP 15](./klip-15-new-api-and-client.md) already made the case for why it makes sense\n+           to introduce a Java client for ksqlDB. This KLIP proposes interfaces for the client._\n+\n+## Motivation and background\n+\n+See [KLIP 15](./klip-15-new-api-and-client.md).\n+\n+## What is in scope\n+\n+The Java client will support the following operations:\n+* Push query\n+* Pull query\n+* Select DDL/DML operations:\n+    * `CREATE STREAM`\n+    * `CREATE TABLE`\n+    * `CREATE STREAM ... AS SELECT`\n+    * `CREATE TABLE ... AS SELECT`\n+    * `DROP STREAM`\n+    * `DROP TABLE`\n+    * `INSERT INTO`\n+    * `TERMINATE <queryId>`\n+    * `CREATE CONNECTOR`\n+    * `DROP CONNECTOR`\n+* Select admin operations:\n+    * `SHOW TOPICS` (non-extended)\n+    * `SHOW STREAMS` (non-extended)\n+    * `SHOW TABLES` (non-extended)\n+    * `SHOW QUERIES` (non-extended)\n+    * `SHOW CONNECTORS`\n+* Insert values, i.e., insert rows into an existing stream/table\n+* Terminate push query (via the `/close-query` endpoint)\n+\n+The purpose of this KLIP is to reach agreement on the interfaces / public APIs.\n+Implementation details will not be covered.\n+\n+## What is not in scope\n+\n+This KLIP does not cover Java client support for the following:\n+* `DESCRIBE <stream/table>`, `DESCRIBE CONNECTOR`, `DESCRIBE FUNCTION`\n+* `EXPLAIN <queryId>`\n+* `PRINT <topic>`\n+* `SHOW TOPICS EXTENDED`, `SHOW <STREAMS/TABLES> EXTENDED`, `SHOW QUERIES EXTENDED`\n+* `CREATE TYPE`, `DROP TYPE`, `SHOW TYPES`\n+* `SHOW FUNCTIONS`, `SHOW PROPERTIES`\n+* `RUN SCRIPT`\n+* Use of other endpoints (info, healthcheck, terminate cluster, status, etc.)\n+\n+We can always add support for these operations in the future if desired.\n+\n+As above, implementation details are out of scope as the purpose of this KLIP is to reach agreement\n+on the interfaces / public APIs.\n+\n+## Value/Return\n+\n+See [KLIP 15](./klip-15-new-api-and-client.md).\n+\n+## Public APIS\n+\n+The following subsections describe the methods of the `Client` interface:\n+```\n+public interface Client {\n+    ...\n+}\n+```\n+\n+### Constructors\n+```\n+  static Client create(ClientOptions clientOptions) {\n+    return new ClientImpl(clientOptions);\n+  }\n+\n+  static Client create(ClientOptions clientOptions, Vertx vertx) {\n+    return new ClientImpl(clientOptions, vertx);\n+  }\n+```\n+\n+The Java client will be implemented as a Vert.x HttpClient. We expose a constructor that allows users to provide their own `Vertx` instance\n+in order to take advantage of a shared connection pool and other properties if desired.\n+\n+`ClientOptions` will initially be as follows:\n+```\n+public interface ClientOptions {\n+\n+  ClientOptions setHost(String host);\n+\n+  ClientOptions setPort(int port);\n+\n+  ClientOptions setUseTls(boolean useTls);\n+\n+  ClientOptions setUseClientAuth(boolean useClientAuth);\n+\n+  ClientOptions setTrustStore(String trustStorePath);\n+\n+  ClientOptions setTrustStorePassword(String trustStorePassword);\n+\n+  ClientOptions setKeyStore(String keyStorePath);\n+\n+  ClientOptions setKeyStorePassword(String keyStorePassword);\n+\n+  ClientOptions setBasicAuthCredentials(String username, String password);\n+\n+  String getHost();\n+\n+  int getPort();\n+\n+  boolean isUseTls();\n+\n+  boolean isUseClientAuth();\n+\n+  boolean isUseBasicAuth();\n+\n+  String getTrustStore();\n+\n+  String getTrustStorePassword();\n+\n+  String getKeyStore();\n+\n+  String getKeyStorePassword();\n+\n+  String getBasicAuthUsername();\n+\n+  String getBasicAuthPassword();\n+\n+  ClientOptions copy();\n+\n+  static ClientOptions create() {\n+    return new ClientOptionsImpl();\n+  }\n+}\n+```\n+\n+We can always add additional configuration options later. We may also wish to expose the Vert.x `HttpClientOptions` for\n+advanced users that wish to provide custom configs.\n+\n+### Transient queries -- Streaming\n+\n+The `Client` interface will provide the following methods for streaming the results of a transient (push or pull) query:\n+```\n+  /**\n+   * Execute a query (push or pull) and receive the results one row at a time.\n+   *\n+   * @param sql statement of query to execute.\n+   * @return query result.\n+   */\n+  CompletableFuture<QueryResult> streamQuery(String sql);\n+\n+  /**\n+   * Execute a query (push or pull) and receive the results one row at a time.\n+   *\n+   * @param sql statement of query to execute.\n+   * @param properties query properties.\n+   * @return query result.\n+   */\n+  CompletableFuture<QueryResult> streamQuery(String sql, Map<String, Object> properties);\n+```\n+where `QueryResult` is as follows:\n+```\n+/**\n+ * The result of a query (push or pull), streamed one row at time. Records may be consumed by either\n+ * subscribing to the publisher or polling (blocking) for one record at a time. These two methods of\n+ * consumption are mutually exclusive; only one method may be used (per QueryResult).\n+ */\n+public interface QueryResult extends Publisher<Row> {\n+\n+  List<String> columnNames();\n+\n+  List<String> columnTypes();\n+\n+  String queryID();\n+\n+  /**\n+   * Block until a row becomes available.\n+   *\n+   * @return the row.\n+   */\n+  Row poll();\n+\n+  /**\n+   * Block until a row becomes available or the timeout has elapsed.\n+   *\n+   * @param timeout amount of to wait for a row. Non-positive values are interpreted as no timeout.\n+   * @param timeUnit unit for timeout param.\n+   * @return the row, if available; else, null.\n+   */\n+  Row poll(long timeout, TimeUnit timeUnit);\n+\n+  boolean isComplete();\n+\n+  void close();\n+}\n+```\n+Note that `QueryResult` is a Reactive Streams `Publisher` so users can stream results. Users can also call `poll()` to receive\n+results in a synchronous fashion instead. Only one of the two methods will be allowed per `QueryResult` instance.\n+\n+The `Row` interface is as follows:\n+```\n+/**\n+ * A single record, returned as part of a query result.\n+ */\n+public interface Row {\n+\n+  List<String> columnNames();\n+\n+  List<String> columnTypes();\n+\n+  List<Object> values();\n+\n+  /**\n+   * Get the value for a particular column of the Row as an Object.\n+   *\n+   * @param columnIndex index of column (1-indexed).\n+   * @return column value.\n+   */\n+  Object getObject(int columnIndex);\n+\n+  /**\n+   * Get the value for a particular column of the Row as an Object.\n+   *\n+   * @param columnName name of column.\n+   * @return column value.\n+   */\n+  Object getObject(String columnName);\n+\n+  /**\n+   * Get the value for a particular column of the Row as a string.\n+   *\n+   * @param columnIndex index of column (1-indexed).\n+   * @return column value.\n+   */\n+  String getString(int columnIndex);\n+\n+  /**\n+   * Get the value for a particular column of the Row as a string.\n+   *\n+   * @param columnName name of column.\n+   * @return column value.\n+   */\n+  String getString(String columnName);\n+\n+  /**\n+   * Get the value for a particular column of the Row as an integer.\n+   *\n+   * @param columnIndex index of column (1-indexed).\n+   * @return column value.\n+   */\n+  Integer getInt(int columnIndex);\n+\n+  /**\n+   * Get the value for a particular column of the Row as an integer.\n+   *\n+   * @param columnName name of column.\n+   * @return column value.\n+   */\n+  Integer getInt(String columnName);\n+\n+  /**\n+   * Get the value for a particular column of the Row as a long.\n+   *\n+   * @param columnIndex index of column (1-indexed).\n+   * @return column value.\n+   */\n+  Long getLong(int columnIndex);\n+\n+  /**\n+   * Get the value for a particular column of the Row as a long.\n+   *\n+   * @param columnName name of column.\n+   * @return column value.\n+   */\n+  Long getLong(String columnName);\n+\n+  /**\n+   * Get the value for a particular column of the Row as a double.\n+   *\n+   * @param columnIndex index of column (1-indexed).\n+   * @return column value.\n+   */\n+  Double getDouble(int columnIndex);\n+\n+  /**\n+   * Get the value for a particular column of the Row as a double.\n+   *\n+   * @param columnName name of column.\n+   * @return column value.\n+   */\n+  Double getDouble(String columnName);\n+\n+  /**\n+   * Get the value for a particular column of the Row as a boolean.\n+   *\n+   * @param columnIndex index of column (1-indexed).\n+   * @return column value.\n+   */\n+  Boolean getBoolean(int columnIndex);\n+\n+  /**\n+   * Get the value for a particular column of the Row as a boolean.\n+   *\n+   * @param columnName name of column.\n+   * @return column value.\n+   */\n+  Boolean getBoolean(String columnName);\n+\n+  /**\n+   * Get the value for a particular column of the Row as a decimal.\n+   *\n+   * @param columnIndex index of column (1-indexed).\n+   * @return column value.\n+   */\n+  BigDecimal getDecimal(int columnIndex);\n+\n+  /**\n+   * Get the value for a particular column of the Row as a decimal.\n+   *\n+   * @param columnName name of column.\n+   * @return column value.\n+   */\n+  BigDecimal getDecimal(String columnName);\n+}\n+```\n+\n+We considered representing column types in a more structured form (rather than plain strings) to accomodate complex/nested data types but felt this added complexity would not be helpful for most use cases. (This would also require a server-side change, so it's a fair bit of additional work.)\n+\n+For `getDecimal(...)` in the `Row` interface, rather than trying to parse the column type to extract the precision and scale, we will simply convert the value to a BigDecimal without explicitly specifying the precision and scale. We could also add an option for users to specify the scale and precision in the getter, if we think that would be useful.\n+\n+We could also add `getList(...)` and `getMap(...)` methods to the `Row` interface, but it's not clear to me how valuable this would be given that the nested data types would not be known.\n+\n+Tim also proposed switching from generic Java types (`Map<String, Object>`, `List<Object>`) to Vert.x types (`JsonObject`, `JsonArray`) as the latter is more type-safe and the client already has a dependency on Vert.x anyway. The downside, though, is that then apps that use the client would be required to depend on Vert.x as well.\n+\n+### Transient queries -- Non-streaming\n+\n+The `Client` interface will also provide the following methods for receiving the results of a transient query (push or pull) in a single batch (non-streaming),\n+once the query has completed:\n+```\n+  /**\n+   * Execute a query (push or pull) and receive all result rows together, once the query has\n+   * completed.\n+   *\n+   * @param sql statement of query to execute.\n+   * @return query result.\n+   */\n+  CompletableFuture<List<Row>> executeQuery(String sql);\n+\n+  /**\n+   * Execute a query (push or pull) and receive all result rows together, once the query has\n+   * completed.\n+   *\n+   * @param sql statement of query to execute.\n+   * @param properties query properties.\n+   * @return query result.\n+   */\n+  CompletableFuture<List<Row>> executeQuery(String sql, Map<String, Object> properties);\n+```\n+\n+For a query to \"complete\" could mean:\n+* The query is a pull query\n+* The query is a push query with a limit clause, and the limit has been reached\n+* The query is a push query that has been terminated", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aed38d5836550829f7fd459df31b47aaf7e5ad45"}, "originalPosition": 365}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODEzMTM1NQ==", "bodyText": "why do we need two different apis for DDL and DML? why not just executeStatement(String sql) - the response object can have different types if we need to disambiguate the responses", "url": "https://github.com/confluentinc/ksql/pull/5236#discussion_r418131355", "createdAt": "2020-04-30T16:19:53Z", "author": {"login": "agavra"}, "path": "design-proposals/klip-26-java-client-interfaces.md", "diffHunk": "@@ -0,0 +1,715 @@\n+# KLIP 26 - Java client interfaces\n+\n+**Author**: Victoria Xia (@vcrfxia) | \n+**Release Target**: ksqlDB 0.10.0 | \n+**Status**: _In development_ | \n+**Discussion**: TBD\n+\n+**tl;dr:** _[KLIP 15](./klip-15-new-api-and-client.md) already made the case for why it makes sense\n+           to introduce a Java client for ksqlDB. This KLIP proposes interfaces for the client._\n+\n+## Motivation and background\n+\n+See [KLIP 15](./klip-15-new-api-and-client.md).\n+\n+## What is in scope\n+\n+The Java client will support the following operations:\n+* Push query\n+* Pull query\n+* Select DDL/DML operations:\n+    * `CREATE STREAM`\n+    * `CREATE TABLE`\n+    * `CREATE STREAM ... AS SELECT`\n+    * `CREATE TABLE ... AS SELECT`\n+    * `DROP STREAM`\n+    * `DROP TABLE`\n+    * `INSERT INTO`\n+    * `TERMINATE <queryId>`\n+    * `CREATE CONNECTOR`\n+    * `DROP CONNECTOR`\n+* Select admin operations:\n+    * `SHOW TOPICS` (non-extended)\n+    * `SHOW STREAMS` (non-extended)\n+    * `SHOW TABLES` (non-extended)\n+    * `SHOW QUERIES` (non-extended)\n+    * `SHOW CONNECTORS`\n+* Insert values, i.e., insert rows into an existing stream/table\n+* Terminate push query (via the `/close-query` endpoint)\n+\n+The purpose of this KLIP is to reach agreement on the interfaces / public APIs.\n+Implementation details will not be covered.\n+\n+## What is not in scope\n+\n+This KLIP does not cover Java client support for the following:\n+* `DESCRIBE <stream/table>`, `DESCRIBE CONNECTOR`, `DESCRIBE FUNCTION`\n+* `EXPLAIN <queryId>`\n+* `PRINT <topic>`\n+* `SHOW TOPICS EXTENDED`, `SHOW <STREAMS/TABLES> EXTENDED`, `SHOW QUERIES EXTENDED`\n+* `CREATE TYPE`, `DROP TYPE`, `SHOW TYPES`\n+* `SHOW FUNCTIONS`, `SHOW PROPERTIES`\n+* `RUN SCRIPT`\n+* Use of other endpoints (info, healthcheck, terminate cluster, status, etc.)\n+\n+We can always add support for these operations in the future if desired.\n+\n+As above, implementation details are out of scope as the purpose of this KLIP is to reach agreement\n+on the interfaces / public APIs.\n+\n+## Value/Return\n+\n+See [KLIP 15](./klip-15-new-api-and-client.md).\n+\n+## Public APIS\n+\n+The following subsections describe the methods of the `Client` interface:\n+```\n+public interface Client {\n+    ...\n+}\n+```\n+\n+### Constructors\n+```\n+  static Client create(ClientOptions clientOptions) {\n+    return new ClientImpl(clientOptions);\n+  }\n+\n+  static Client create(ClientOptions clientOptions, Vertx vertx) {\n+    return new ClientImpl(clientOptions, vertx);\n+  }\n+```\n+\n+The Java client will be implemented as a Vert.x HttpClient. We expose a constructor that allows users to provide their own `Vertx` instance\n+in order to take advantage of a shared connection pool and other properties if desired.\n+\n+`ClientOptions` will initially be as follows:\n+```\n+public interface ClientOptions {\n+\n+  ClientOptions setHost(String host);\n+\n+  ClientOptions setPort(int port);\n+\n+  ClientOptions setUseTls(boolean useTls);\n+\n+  ClientOptions setUseClientAuth(boolean useClientAuth);\n+\n+  ClientOptions setTrustStore(String trustStorePath);\n+\n+  ClientOptions setTrustStorePassword(String trustStorePassword);\n+\n+  ClientOptions setKeyStore(String keyStorePath);\n+\n+  ClientOptions setKeyStorePassword(String keyStorePassword);\n+\n+  ClientOptions setBasicAuthCredentials(String username, String password);\n+\n+  String getHost();\n+\n+  int getPort();\n+\n+  boolean isUseTls();\n+\n+  boolean isUseClientAuth();\n+\n+  boolean isUseBasicAuth();\n+\n+  String getTrustStore();\n+\n+  String getTrustStorePassword();\n+\n+  String getKeyStore();\n+\n+  String getKeyStorePassword();\n+\n+  String getBasicAuthUsername();\n+\n+  String getBasicAuthPassword();\n+\n+  ClientOptions copy();\n+\n+  static ClientOptions create() {\n+    return new ClientOptionsImpl();\n+  }\n+}\n+```\n+\n+We can always add additional configuration options later. We may also wish to expose the Vert.x `HttpClientOptions` for\n+advanced users that wish to provide custom configs.\n+\n+### Transient queries -- Streaming\n+\n+The `Client` interface will provide the following methods for streaming the results of a transient (push or pull) query:\n+```\n+  /**\n+   * Execute a query (push or pull) and receive the results one row at a time.\n+   *\n+   * @param sql statement of query to execute.\n+   * @return query result.\n+   */\n+  CompletableFuture<QueryResult> streamQuery(String sql);\n+\n+  /**\n+   * Execute a query (push or pull) and receive the results one row at a time.\n+   *\n+   * @param sql statement of query to execute.\n+   * @param properties query properties.\n+   * @return query result.\n+   */\n+  CompletableFuture<QueryResult> streamQuery(String sql, Map<String, Object> properties);\n+```\n+where `QueryResult` is as follows:\n+```\n+/**\n+ * The result of a query (push or pull), streamed one row at time. Records may be consumed by either\n+ * subscribing to the publisher or polling (blocking) for one record at a time. These two methods of\n+ * consumption are mutually exclusive; only one method may be used (per QueryResult).\n+ */\n+public interface QueryResult extends Publisher<Row> {\n+\n+  List<String> columnNames();\n+\n+  List<String> columnTypes();\n+\n+  String queryID();\n+\n+  /**\n+   * Block until a row becomes available.\n+   *\n+   * @return the row.\n+   */\n+  Row poll();\n+\n+  /**\n+   * Block until a row becomes available or the timeout has elapsed.\n+   *\n+   * @param timeout amount of to wait for a row. Non-positive values are interpreted as no timeout.\n+   * @param timeUnit unit for timeout param.\n+   * @return the row, if available; else, null.\n+   */\n+  Row poll(long timeout, TimeUnit timeUnit);\n+\n+  boolean isComplete();\n+\n+  void close();\n+}\n+```\n+Note that `QueryResult` is a Reactive Streams `Publisher` so users can stream results. Users can also call `poll()` to receive\n+results in a synchronous fashion instead. Only one of the two methods will be allowed per `QueryResult` instance.\n+\n+The `Row` interface is as follows:\n+```\n+/**\n+ * A single record, returned as part of a query result.\n+ */\n+public interface Row {\n+\n+  List<String> columnNames();\n+\n+  List<String> columnTypes();\n+\n+  List<Object> values();\n+\n+  /**\n+   * Get the value for a particular column of the Row as an Object.\n+   *\n+   * @param columnIndex index of column (1-indexed).\n+   * @return column value.\n+   */\n+  Object getObject(int columnIndex);\n+\n+  /**\n+   * Get the value for a particular column of the Row as an Object.\n+   *\n+   * @param columnName name of column.\n+   * @return column value.\n+   */\n+  Object getObject(String columnName);\n+\n+  /**\n+   * Get the value for a particular column of the Row as a string.\n+   *\n+   * @param columnIndex index of column (1-indexed).\n+   * @return column value.\n+   */\n+  String getString(int columnIndex);\n+\n+  /**\n+   * Get the value for a particular column of the Row as a string.\n+   *\n+   * @param columnName name of column.\n+   * @return column value.\n+   */\n+  String getString(String columnName);\n+\n+  /**\n+   * Get the value for a particular column of the Row as an integer.\n+   *\n+   * @param columnIndex index of column (1-indexed).\n+   * @return column value.\n+   */\n+  Integer getInt(int columnIndex);\n+\n+  /**\n+   * Get the value for a particular column of the Row as an integer.\n+   *\n+   * @param columnName name of column.\n+   * @return column value.\n+   */\n+  Integer getInt(String columnName);\n+\n+  /**\n+   * Get the value for a particular column of the Row as a long.\n+   *\n+   * @param columnIndex index of column (1-indexed).\n+   * @return column value.\n+   */\n+  Long getLong(int columnIndex);\n+\n+  /**\n+   * Get the value for a particular column of the Row as a long.\n+   *\n+   * @param columnName name of column.\n+   * @return column value.\n+   */\n+  Long getLong(String columnName);\n+\n+  /**\n+   * Get the value for a particular column of the Row as a double.\n+   *\n+   * @param columnIndex index of column (1-indexed).\n+   * @return column value.\n+   */\n+  Double getDouble(int columnIndex);\n+\n+  /**\n+   * Get the value for a particular column of the Row as a double.\n+   *\n+   * @param columnName name of column.\n+   * @return column value.\n+   */\n+  Double getDouble(String columnName);\n+\n+  /**\n+   * Get the value for a particular column of the Row as a boolean.\n+   *\n+   * @param columnIndex index of column (1-indexed).\n+   * @return column value.\n+   */\n+  Boolean getBoolean(int columnIndex);\n+\n+  /**\n+   * Get the value for a particular column of the Row as a boolean.\n+   *\n+   * @param columnName name of column.\n+   * @return column value.\n+   */\n+  Boolean getBoolean(String columnName);\n+\n+  /**\n+   * Get the value for a particular column of the Row as a decimal.\n+   *\n+   * @param columnIndex index of column (1-indexed).\n+   * @return column value.\n+   */\n+  BigDecimal getDecimal(int columnIndex);\n+\n+  /**\n+   * Get the value for a particular column of the Row as a decimal.\n+   *\n+   * @param columnName name of column.\n+   * @return column value.\n+   */\n+  BigDecimal getDecimal(String columnName);\n+}\n+```\n+\n+We considered representing column types in a more structured form (rather than plain strings) to accomodate complex/nested data types but felt this added complexity would not be helpful for most use cases. (This would also require a server-side change, so it's a fair bit of additional work.)\n+\n+For `getDecimal(...)` in the `Row` interface, rather than trying to parse the column type to extract the precision and scale, we will simply convert the value to a BigDecimal without explicitly specifying the precision and scale. We could also add an option for users to specify the scale and precision in the getter, if we think that would be useful.\n+\n+We could also add `getList(...)` and `getMap(...)` methods to the `Row` interface, but it's not clear to me how valuable this would be given that the nested data types would not be known.\n+\n+Tim also proposed switching from generic Java types (`Map<String, Object>`, `List<Object>`) to Vert.x types (`JsonObject`, `JsonArray`) as the latter is more type-safe and the client already has a dependency on Vert.x anyway. The downside, though, is that then apps that use the client would be required to depend on Vert.x as well.\n+\n+### Transient queries -- Non-streaming\n+\n+The `Client` interface will also provide the following methods for receiving the results of a transient query (push or pull) in a single batch (non-streaming),\n+once the query has completed:\n+```\n+  /**\n+   * Execute a query (push or pull) and receive all result rows together, once the query has\n+   * completed.\n+   *\n+   * @param sql statement of query to execute.\n+   * @return query result.\n+   */\n+  CompletableFuture<List<Row>> executeQuery(String sql);\n+\n+  /**\n+   * Execute a query (push or pull) and receive all result rows together, once the query has\n+   * completed.\n+   *\n+   * @param sql statement of query to execute.\n+   * @param properties query properties.\n+   * @return query result.\n+   */\n+  CompletableFuture<List<Row>> executeQuery(String sql, Map<String, Object> properties);\n+```\n+\n+For a query to \"complete\" could mean:\n+* The query is a pull query\n+* The query is a push query with a limit clause, and the limit has been reached\n+* The query is a push query that has been terminated\n+\n+We may want to introduce a limit to the number of rows that may be returned from these `executeQuery()` methods,\n+in order to decrease the likelihood of running out of memory.\n+\n+### Insert values\n+\n+A method to insert one row at a time:\n+```\n+  /**\n+   * Insert a single row into the relevant stream/table.\n+   *\n+   * @param streamName name of stream/table.\n+   * @param row the row to insert.\n+   * @return a future that completes once the request has been processed.\n+   */\n+  CompletableFuture<Void> insertInto(String streamName, Map<String, Object> row);\n+```\n+\n+A method to stream inserts (via the `/inserts-stream` endpoint):\n+```\n+  CompletableFuture<Publisher<InsertResponse>> streamInserts(String streamName, Publisher<List<Object>> insertsPublisher);\n+}\n+```\n+where `InsertResponse` is as follows:\n+```\n+public interface InsertResponse {\n+\n+  /**\n+   * Whether the row was successfully inserted or not.\n+   */\n+  boolean isSuccessful();\n+\n+  /**\n+   * Unique sequence number for the row in the stream of inserts.\n+   */\n+  int getSequenceNum();\n+\n+  /**\n+   * If unsuccessful, the error message.\n+   */\n+  String getErrorMessage();\n+\n+  /**\n+   * If unsuccessful, the error code.\n+   */\n+  int getErrorCode();\n+\n+}\n+```\n+\n+### DDL/DML operations\n+\n+#### `CREATE <STREAM/TABLE>`, `CREATE <STREAM/TABLE> ... AS SELECT`, `INSERT INTO`\n+\n+`Client` methods:\n+```\n+  /**\n+   * Execute DDL statement: `CREATE STREAM`, `CREATE TABLE`\n+   */\n+  CompletableFuture<DdlResponse> executeDdl(String sql);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aed38d5836550829f7fd459df31b47aaf7e5ad45"}, "originalPosition": 425}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODEzNDk1NA==", "bodyText": "again, not sure why we can't just group this into executeStatement instead of separating all these methods - seems straightforward to me and even more user friendly if I'm programatically constructing statements", "url": "https://github.com/confluentinc/ksql/pull/5236#discussion_r418134954", "createdAt": "2020-04-30T16:25:39Z", "author": {"login": "agavra"}, "path": "design-proposals/klip-26-java-client-interfaces.md", "diffHunk": "@@ -0,0 +1,715 @@\n+# KLIP 26 - Java client interfaces\n+\n+**Author**: Victoria Xia (@vcrfxia) | \n+**Release Target**: ksqlDB 0.10.0 | \n+**Status**: _In development_ | \n+**Discussion**: TBD\n+\n+**tl;dr:** _[KLIP 15](./klip-15-new-api-and-client.md) already made the case for why it makes sense\n+           to introduce a Java client for ksqlDB. This KLIP proposes interfaces for the client._\n+\n+## Motivation and background\n+\n+See [KLIP 15](./klip-15-new-api-and-client.md).\n+\n+## What is in scope\n+\n+The Java client will support the following operations:\n+* Push query\n+* Pull query\n+* Select DDL/DML operations:\n+    * `CREATE STREAM`\n+    * `CREATE TABLE`\n+    * `CREATE STREAM ... AS SELECT`\n+    * `CREATE TABLE ... AS SELECT`\n+    * `DROP STREAM`\n+    * `DROP TABLE`\n+    * `INSERT INTO`\n+    * `TERMINATE <queryId>`\n+    * `CREATE CONNECTOR`\n+    * `DROP CONNECTOR`\n+* Select admin operations:\n+    * `SHOW TOPICS` (non-extended)\n+    * `SHOW STREAMS` (non-extended)\n+    * `SHOW TABLES` (non-extended)\n+    * `SHOW QUERIES` (non-extended)\n+    * `SHOW CONNECTORS`\n+* Insert values, i.e., insert rows into an existing stream/table\n+* Terminate push query (via the `/close-query` endpoint)\n+\n+The purpose of this KLIP is to reach agreement on the interfaces / public APIs.\n+Implementation details will not be covered.\n+\n+## What is not in scope\n+\n+This KLIP does not cover Java client support for the following:\n+* `DESCRIBE <stream/table>`, `DESCRIBE CONNECTOR`, `DESCRIBE FUNCTION`\n+* `EXPLAIN <queryId>`\n+* `PRINT <topic>`\n+* `SHOW TOPICS EXTENDED`, `SHOW <STREAMS/TABLES> EXTENDED`, `SHOW QUERIES EXTENDED`\n+* `CREATE TYPE`, `DROP TYPE`, `SHOW TYPES`\n+* `SHOW FUNCTIONS`, `SHOW PROPERTIES`\n+* `RUN SCRIPT`\n+* Use of other endpoints (info, healthcheck, terminate cluster, status, etc.)\n+\n+We can always add support for these operations in the future if desired.\n+\n+As above, implementation details are out of scope as the purpose of this KLIP is to reach agreement\n+on the interfaces / public APIs.\n+\n+## Value/Return\n+\n+See [KLIP 15](./klip-15-new-api-and-client.md).\n+\n+## Public APIS\n+\n+The following subsections describe the methods of the `Client` interface:\n+```\n+public interface Client {\n+    ...\n+}\n+```\n+\n+### Constructors\n+```\n+  static Client create(ClientOptions clientOptions) {\n+    return new ClientImpl(clientOptions);\n+  }\n+\n+  static Client create(ClientOptions clientOptions, Vertx vertx) {\n+    return new ClientImpl(clientOptions, vertx);\n+  }\n+```\n+\n+The Java client will be implemented as a Vert.x HttpClient. We expose a constructor that allows users to provide their own `Vertx` instance\n+in order to take advantage of a shared connection pool and other properties if desired.\n+\n+`ClientOptions` will initially be as follows:\n+```\n+public interface ClientOptions {\n+\n+  ClientOptions setHost(String host);\n+\n+  ClientOptions setPort(int port);\n+\n+  ClientOptions setUseTls(boolean useTls);\n+\n+  ClientOptions setUseClientAuth(boolean useClientAuth);\n+\n+  ClientOptions setTrustStore(String trustStorePath);\n+\n+  ClientOptions setTrustStorePassword(String trustStorePassword);\n+\n+  ClientOptions setKeyStore(String keyStorePath);\n+\n+  ClientOptions setKeyStorePassword(String keyStorePassword);\n+\n+  ClientOptions setBasicAuthCredentials(String username, String password);\n+\n+  String getHost();\n+\n+  int getPort();\n+\n+  boolean isUseTls();\n+\n+  boolean isUseClientAuth();\n+\n+  boolean isUseBasicAuth();\n+\n+  String getTrustStore();\n+\n+  String getTrustStorePassword();\n+\n+  String getKeyStore();\n+\n+  String getKeyStorePassword();\n+\n+  String getBasicAuthUsername();\n+\n+  String getBasicAuthPassword();\n+\n+  ClientOptions copy();\n+\n+  static ClientOptions create() {\n+    return new ClientOptionsImpl();\n+  }\n+}\n+```\n+\n+We can always add additional configuration options later. We may also wish to expose the Vert.x `HttpClientOptions` for\n+advanced users that wish to provide custom configs.\n+\n+### Transient queries -- Streaming\n+\n+The `Client` interface will provide the following methods for streaming the results of a transient (push or pull) query:\n+```\n+  /**\n+   * Execute a query (push or pull) and receive the results one row at a time.\n+   *\n+   * @param sql statement of query to execute.\n+   * @return query result.\n+   */\n+  CompletableFuture<QueryResult> streamQuery(String sql);\n+\n+  /**\n+   * Execute a query (push or pull) and receive the results one row at a time.\n+   *\n+   * @param sql statement of query to execute.\n+   * @param properties query properties.\n+   * @return query result.\n+   */\n+  CompletableFuture<QueryResult> streamQuery(String sql, Map<String, Object> properties);\n+```\n+where `QueryResult` is as follows:\n+```\n+/**\n+ * The result of a query (push or pull), streamed one row at time. Records may be consumed by either\n+ * subscribing to the publisher or polling (blocking) for one record at a time. These two methods of\n+ * consumption are mutually exclusive; only one method may be used (per QueryResult).\n+ */\n+public interface QueryResult extends Publisher<Row> {\n+\n+  List<String> columnNames();\n+\n+  List<String> columnTypes();\n+\n+  String queryID();\n+\n+  /**\n+   * Block until a row becomes available.\n+   *\n+   * @return the row.\n+   */\n+  Row poll();\n+\n+  /**\n+   * Block until a row becomes available or the timeout has elapsed.\n+   *\n+   * @param timeout amount of to wait for a row. Non-positive values are interpreted as no timeout.\n+   * @param timeUnit unit for timeout param.\n+   * @return the row, if available; else, null.\n+   */\n+  Row poll(long timeout, TimeUnit timeUnit);\n+\n+  boolean isComplete();\n+\n+  void close();\n+}\n+```\n+Note that `QueryResult` is a Reactive Streams `Publisher` so users can stream results. Users can also call `poll()` to receive\n+results in a synchronous fashion instead. Only one of the two methods will be allowed per `QueryResult` instance.\n+\n+The `Row` interface is as follows:\n+```\n+/**\n+ * A single record, returned as part of a query result.\n+ */\n+public interface Row {\n+\n+  List<String> columnNames();\n+\n+  List<String> columnTypes();\n+\n+  List<Object> values();\n+\n+  /**\n+   * Get the value for a particular column of the Row as an Object.\n+   *\n+   * @param columnIndex index of column (1-indexed).\n+   * @return column value.\n+   */\n+  Object getObject(int columnIndex);\n+\n+  /**\n+   * Get the value for a particular column of the Row as an Object.\n+   *\n+   * @param columnName name of column.\n+   * @return column value.\n+   */\n+  Object getObject(String columnName);\n+\n+  /**\n+   * Get the value for a particular column of the Row as a string.\n+   *\n+   * @param columnIndex index of column (1-indexed).\n+   * @return column value.\n+   */\n+  String getString(int columnIndex);\n+\n+  /**\n+   * Get the value for a particular column of the Row as a string.\n+   *\n+   * @param columnName name of column.\n+   * @return column value.\n+   */\n+  String getString(String columnName);\n+\n+  /**\n+   * Get the value for a particular column of the Row as an integer.\n+   *\n+   * @param columnIndex index of column (1-indexed).\n+   * @return column value.\n+   */\n+  Integer getInt(int columnIndex);\n+\n+  /**\n+   * Get the value for a particular column of the Row as an integer.\n+   *\n+   * @param columnName name of column.\n+   * @return column value.\n+   */\n+  Integer getInt(String columnName);\n+\n+  /**\n+   * Get the value for a particular column of the Row as a long.\n+   *\n+   * @param columnIndex index of column (1-indexed).\n+   * @return column value.\n+   */\n+  Long getLong(int columnIndex);\n+\n+  /**\n+   * Get the value for a particular column of the Row as a long.\n+   *\n+   * @param columnName name of column.\n+   * @return column value.\n+   */\n+  Long getLong(String columnName);\n+\n+  /**\n+   * Get the value for a particular column of the Row as a double.\n+   *\n+   * @param columnIndex index of column (1-indexed).\n+   * @return column value.\n+   */\n+  Double getDouble(int columnIndex);\n+\n+  /**\n+   * Get the value for a particular column of the Row as a double.\n+   *\n+   * @param columnName name of column.\n+   * @return column value.\n+   */\n+  Double getDouble(String columnName);\n+\n+  /**\n+   * Get the value for a particular column of the Row as a boolean.\n+   *\n+   * @param columnIndex index of column (1-indexed).\n+   * @return column value.\n+   */\n+  Boolean getBoolean(int columnIndex);\n+\n+  /**\n+   * Get the value for a particular column of the Row as a boolean.\n+   *\n+   * @param columnName name of column.\n+   * @return column value.\n+   */\n+  Boolean getBoolean(String columnName);\n+\n+  /**\n+   * Get the value for a particular column of the Row as a decimal.\n+   *\n+   * @param columnIndex index of column (1-indexed).\n+   * @return column value.\n+   */\n+  BigDecimal getDecimal(int columnIndex);\n+\n+  /**\n+   * Get the value for a particular column of the Row as a decimal.\n+   *\n+   * @param columnName name of column.\n+   * @return column value.\n+   */\n+  BigDecimal getDecimal(String columnName);\n+}\n+```\n+\n+We considered representing column types in a more structured form (rather than plain strings) to accomodate complex/nested data types but felt this added complexity would not be helpful for most use cases. (This would also require a server-side change, so it's a fair bit of additional work.)\n+\n+For `getDecimal(...)` in the `Row` interface, rather than trying to parse the column type to extract the precision and scale, we will simply convert the value to a BigDecimal without explicitly specifying the precision and scale. We could also add an option for users to specify the scale and precision in the getter, if we think that would be useful.\n+\n+We could also add `getList(...)` and `getMap(...)` methods to the `Row` interface, but it's not clear to me how valuable this would be given that the nested data types would not be known.\n+\n+Tim also proposed switching from generic Java types (`Map<String, Object>`, `List<Object>`) to Vert.x types (`JsonObject`, `JsonArray`) as the latter is more type-safe and the client already has a dependency on Vert.x anyway. The downside, though, is that then apps that use the client would be required to depend on Vert.x as well.\n+\n+### Transient queries -- Non-streaming\n+\n+The `Client` interface will also provide the following methods for receiving the results of a transient query (push or pull) in a single batch (non-streaming),\n+once the query has completed:\n+```\n+  /**\n+   * Execute a query (push or pull) and receive all result rows together, once the query has\n+   * completed.\n+   *\n+   * @param sql statement of query to execute.\n+   * @return query result.\n+   */\n+  CompletableFuture<List<Row>> executeQuery(String sql);\n+\n+  /**\n+   * Execute a query (push or pull) and receive all result rows together, once the query has\n+   * completed.\n+   *\n+   * @param sql statement of query to execute.\n+   * @param properties query properties.\n+   * @return query result.\n+   */\n+  CompletableFuture<List<Row>> executeQuery(String sql, Map<String, Object> properties);\n+```\n+\n+For a query to \"complete\" could mean:\n+* The query is a pull query\n+* The query is a push query with a limit clause, and the limit has been reached\n+* The query is a push query that has been terminated\n+\n+We may want to introduce a limit to the number of rows that may be returned from these `executeQuery()` methods,\n+in order to decrease the likelihood of running out of memory.\n+\n+### Insert values\n+\n+A method to insert one row at a time:\n+```\n+  /**\n+   * Insert a single row into the relevant stream/table.\n+   *\n+   * @param streamName name of stream/table.\n+   * @param row the row to insert.\n+   * @return a future that completes once the request has been processed.\n+   */\n+  CompletableFuture<Void> insertInto(String streamName, Map<String, Object> row);\n+```\n+\n+A method to stream inserts (via the `/inserts-stream` endpoint):\n+```\n+  CompletableFuture<Publisher<InsertResponse>> streamInserts(String streamName, Publisher<List<Object>> insertsPublisher);\n+}\n+```\n+where `InsertResponse` is as follows:\n+```\n+public interface InsertResponse {\n+\n+  /**\n+   * Whether the row was successfully inserted or not.\n+   */\n+  boolean isSuccessful();\n+\n+  /**\n+   * Unique sequence number for the row in the stream of inserts.\n+   */\n+  int getSequenceNum();\n+\n+  /**\n+   * If unsuccessful, the error message.\n+   */\n+  String getErrorMessage();\n+\n+  /**\n+   * If unsuccessful, the error code.\n+   */\n+  int getErrorCode();\n+\n+}\n+```\n+\n+### DDL/DML operations\n+\n+#### `CREATE <STREAM/TABLE>`, `CREATE <STREAM/TABLE> ... AS SELECT`, `INSERT INTO`\n+\n+`Client` methods:\n+```\n+  /**\n+   * Execute DDL statement: `CREATE STREAM`, `CREATE TABLE`\n+   */\n+  CompletableFuture<DdlResponse> executeDdl(String sql);\n+\n+  /**\n+   * Execute DML statement: `CREATE STREAM ... AS SELECT`, `CREATE TABLE ... AS SELECT`, `INSERT INTO`\n+   */\n+  CompletableFuture<DmlResponse> executeDml(String sql);\n+\n+  /**\n+   * Execute DML statement: `CREATE STREAM ... AS SELECT`, `CREATE TABLE ... AS SELECT`, `INSERT INTO`\n+   */\n+  CompletableFuture<DmlResponse> executeDml(String sql, Map<String, Object> properties);\n+\n+```\n+with\n+```\n+public interface DdlResponse {\n+\n+  enum Status { QUEUED, PARSING, EXECUTING, RUNNING, TERMINATED, SUCCESS, ERROR }\n+  \n+  Status getStatus();\n+  \n+  String getStatusMessage();\n+  \n+  long getCommandSequenceNumber();\n+\n+  String getCommandId();\n+}\n+```\n+and `DmlResponse` is identical.\n+\n+I don't love this proposal since `DDL` and `DML` aren't used throughout our docs but I'm not a huge fan of the alternatives I considered either, such as\n+```\n+  CompletableFuture<CreateSourceResponse> createStream(String sql);\n+\n+  CompletableFuture<CreateSourceResponse> createStream(String sql, Map<String, Object> properties);\n+\n+  CompletableFuture<CreateSourceResponse> createTable(String sql);\n+\n+  CompletableFuture<CreateSourceResponse> createTable(String sql, Map<String, Object> properties);\n+\n+  CompletableFuture<InsertIntoResponse> insertIntoSource(String sql);\n+\n+  CompletableFuture<InsertIntoResponse> insertIntoSource(String sql, Map<String, Object> properties);\n+```\n+\n+In this version, the implementations of `createStream(...)` and `createTable(...)` would be identical and could be replaced with a single `createSource(...)`\n+but the name of this method feels confusing. As with the previous proposal, `CreateSourceResponse` and `InsertIntoResponse` are identical.\n+\n+Other alternatives include separating `CREATE <STREAM/TABLE>` and `CREATE <STREAM/TABLE> ... AS SELECT` into separate methods, but that feels unnecessarily complex.\n+\n+#### `DROP <STREAM/TABLE>`\n+\n+`Client` methods:\n+```\n+  /**\n+   * Drop stream. The underlying Kafka topic will not be deleted.\n+   */\n+  CompletableFuture<DropSourceResponse> dropStream(String streamName);\n+\n+  /**\n+   * Drop stream. The underlying Kafka topic may optionally be deleted.\n+   */\n+  CompletableFuture<DropSourceResponse> dropStream(String streamName, boolean deleteTopic);\n+\n+  /**\n+   * Drop table. The underlying Kafka topic will not be deleted.\n+   */\n+  CompletableFuture<DropSourceResponse> dropTable(String tableName);\n+\n+  /**\n+   * Drop table. The underlying Kafka topic may optionally be deleted.\n+   */\n+  CompletableFuture<DropSourceResponse> dropTable(String tableName, boolean deleteTopic);\n+```\n+where `DropSourceResponse` is actually the same as `DdlResponse`/`DmlResponse`/`CreateSourceResponse`/`InsertIntoResponse` above.\n+\n+Again, the implementations of `dropStream(...)` and `dropTable(...)` would be the same so we could instead have a single `dropSource(...)`, but the naming might be confusing.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aed38d5836550829f7fd459df31b47aaf7e5ad45"}, "originalPosition": 501}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODEzNjM1MA==", "bodyText": "+1 I don't think we need connector management as part of the ksqlDB client interface (at least for v1). This seems like something that the connect product should solve and then if the user wants connector management in java they can pull in a dedicated first-class connect client", "url": "https://github.com/confluentinc/ksql/pull/5236#discussion_r418136350", "createdAt": "2020-04-30T16:27:47Z", "author": {"login": "agavra"}, "path": "design-proposals/klip-26-java-client-interfaces.md", "diffHunk": "@@ -0,0 +1,715 @@\n+# KLIP 26 - Java client interfaces\n+\n+**Author**: Victoria Xia (@vcrfxia) | \n+**Release Target**: ksqlDB 0.10.0 | \n+**Status**: _In development_ | \n+**Discussion**: TBD\n+\n+**tl;dr:** _[KLIP 15](./klip-15-new-api-and-client.md) already made the case for why it makes sense\n+           to introduce a Java client for ksqlDB. This KLIP proposes interfaces for the client._\n+\n+## Motivation and background\n+\n+See [KLIP 15](./klip-15-new-api-and-client.md).\n+\n+## What is in scope\n+\n+The Java client will support the following operations:\n+* Push query\n+* Pull query\n+* Select DDL/DML operations:\n+    * `CREATE STREAM`\n+    * `CREATE TABLE`\n+    * `CREATE STREAM ... AS SELECT`\n+    * `CREATE TABLE ... AS SELECT`\n+    * `DROP STREAM`\n+    * `DROP TABLE`\n+    * `INSERT INTO`\n+    * `TERMINATE <queryId>`\n+    * `CREATE CONNECTOR`\n+    * `DROP CONNECTOR`\n+* Select admin operations:\n+    * `SHOW TOPICS` (non-extended)\n+    * `SHOW STREAMS` (non-extended)\n+    * `SHOW TABLES` (non-extended)\n+    * `SHOW QUERIES` (non-extended)\n+    * `SHOW CONNECTORS`\n+* Insert values, i.e., insert rows into an existing stream/table\n+* Terminate push query (via the `/close-query` endpoint)\n+\n+The purpose of this KLIP is to reach agreement on the interfaces / public APIs.\n+Implementation details will not be covered.\n+\n+## What is not in scope\n+\n+This KLIP does not cover Java client support for the following:\n+* `DESCRIBE <stream/table>`, `DESCRIBE CONNECTOR`, `DESCRIBE FUNCTION`\n+* `EXPLAIN <queryId>`\n+* `PRINT <topic>`\n+* `SHOW TOPICS EXTENDED`, `SHOW <STREAMS/TABLES> EXTENDED`, `SHOW QUERIES EXTENDED`\n+* `CREATE TYPE`, `DROP TYPE`, `SHOW TYPES`\n+* `SHOW FUNCTIONS`, `SHOW PROPERTIES`\n+* `RUN SCRIPT`\n+* Use of other endpoints (info, healthcheck, terminate cluster, status, etc.)\n+\n+We can always add support for these operations in the future if desired.\n+\n+As above, implementation details are out of scope as the purpose of this KLIP is to reach agreement\n+on the interfaces / public APIs.\n+\n+## Value/Return\n+\n+See [KLIP 15](./klip-15-new-api-and-client.md).\n+\n+## Public APIS\n+\n+The following subsections describe the methods of the `Client` interface:\n+```\n+public interface Client {\n+    ...\n+}\n+```\n+\n+### Constructors\n+```\n+  static Client create(ClientOptions clientOptions) {\n+    return new ClientImpl(clientOptions);\n+  }\n+\n+  static Client create(ClientOptions clientOptions, Vertx vertx) {\n+    return new ClientImpl(clientOptions, vertx);\n+  }\n+```\n+\n+The Java client will be implemented as a Vert.x HttpClient. We expose a constructor that allows users to provide their own `Vertx` instance\n+in order to take advantage of a shared connection pool and other properties if desired.\n+\n+`ClientOptions` will initially be as follows:\n+```\n+public interface ClientOptions {\n+\n+  ClientOptions setHost(String host);\n+\n+  ClientOptions setPort(int port);\n+\n+  ClientOptions setUseTls(boolean useTls);\n+\n+  ClientOptions setUseClientAuth(boolean useClientAuth);\n+\n+  ClientOptions setTrustStore(String trustStorePath);\n+\n+  ClientOptions setTrustStorePassword(String trustStorePassword);\n+\n+  ClientOptions setKeyStore(String keyStorePath);\n+\n+  ClientOptions setKeyStorePassword(String keyStorePassword);\n+\n+  ClientOptions setBasicAuthCredentials(String username, String password);\n+\n+  String getHost();\n+\n+  int getPort();\n+\n+  boolean isUseTls();\n+\n+  boolean isUseClientAuth();\n+\n+  boolean isUseBasicAuth();\n+\n+  String getTrustStore();\n+\n+  String getTrustStorePassword();\n+\n+  String getKeyStore();\n+\n+  String getKeyStorePassword();\n+\n+  String getBasicAuthUsername();\n+\n+  String getBasicAuthPassword();\n+\n+  ClientOptions copy();\n+\n+  static ClientOptions create() {\n+    return new ClientOptionsImpl();\n+  }\n+}\n+```\n+\n+We can always add additional configuration options later. We may also wish to expose the Vert.x `HttpClientOptions` for\n+advanced users that wish to provide custom configs.\n+\n+### Transient queries -- Streaming\n+\n+The `Client` interface will provide the following methods for streaming the results of a transient (push or pull) query:\n+```\n+  /**\n+   * Execute a query (push or pull) and receive the results one row at a time.\n+   *\n+   * @param sql statement of query to execute.\n+   * @return query result.\n+   */\n+  CompletableFuture<QueryResult> streamQuery(String sql);\n+\n+  /**\n+   * Execute a query (push or pull) and receive the results one row at a time.\n+   *\n+   * @param sql statement of query to execute.\n+   * @param properties query properties.\n+   * @return query result.\n+   */\n+  CompletableFuture<QueryResult> streamQuery(String sql, Map<String, Object> properties);\n+```\n+where `QueryResult` is as follows:\n+```\n+/**\n+ * The result of a query (push or pull), streamed one row at time. Records may be consumed by either\n+ * subscribing to the publisher or polling (blocking) for one record at a time. These two methods of\n+ * consumption are mutually exclusive; only one method may be used (per QueryResult).\n+ */\n+public interface QueryResult extends Publisher<Row> {\n+\n+  List<String> columnNames();\n+\n+  List<String> columnTypes();\n+\n+  String queryID();\n+\n+  /**\n+   * Block until a row becomes available.\n+   *\n+   * @return the row.\n+   */\n+  Row poll();\n+\n+  /**\n+   * Block until a row becomes available or the timeout has elapsed.\n+   *\n+   * @param timeout amount of to wait for a row. Non-positive values are interpreted as no timeout.\n+   * @param timeUnit unit for timeout param.\n+   * @return the row, if available; else, null.\n+   */\n+  Row poll(long timeout, TimeUnit timeUnit);\n+\n+  boolean isComplete();\n+\n+  void close();\n+}\n+```\n+Note that `QueryResult` is a Reactive Streams `Publisher` so users can stream results. Users can also call `poll()` to receive\n+results in a synchronous fashion instead. Only one of the two methods will be allowed per `QueryResult` instance.\n+\n+The `Row` interface is as follows:\n+```\n+/**\n+ * A single record, returned as part of a query result.\n+ */\n+public interface Row {\n+\n+  List<String> columnNames();\n+\n+  List<String> columnTypes();\n+\n+  List<Object> values();\n+\n+  /**\n+   * Get the value for a particular column of the Row as an Object.\n+   *\n+   * @param columnIndex index of column (1-indexed).\n+   * @return column value.\n+   */\n+  Object getObject(int columnIndex);\n+\n+  /**\n+   * Get the value for a particular column of the Row as an Object.\n+   *\n+   * @param columnName name of column.\n+   * @return column value.\n+   */\n+  Object getObject(String columnName);\n+\n+  /**\n+   * Get the value for a particular column of the Row as a string.\n+   *\n+   * @param columnIndex index of column (1-indexed).\n+   * @return column value.\n+   */\n+  String getString(int columnIndex);\n+\n+  /**\n+   * Get the value for a particular column of the Row as a string.\n+   *\n+   * @param columnName name of column.\n+   * @return column value.\n+   */\n+  String getString(String columnName);\n+\n+  /**\n+   * Get the value for a particular column of the Row as an integer.\n+   *\n+   * @param columnIndex index of column (1-indexed).\n+   * @return column value.\n+   */\n+  Integer getInt(int columnIndex);\n+\n+  /**\n+   * Get the value for a particular column of the Row as an integer.\n+   *\n+   * @param columnName name of column.\n+   * @return column value.\n+   */\n+  Integer getInt(String columnName);\n+\n+  /**\n+   * Get the value for a particular column of the Row as a long.\n+   *\n+   * @param columnIndex index of column (1-indexed).\n+   * @return column value.\n+   */\n+  Long getLong(int columnIndex);\n+\n+  /**\n+   * Get the value for a particular column of the Row as a long.\n+   *\n+   * @param columnName name of column.\n+   * @return column value.\n+   */\n+  Long getLong(String columnName);\n+\n+  /**\n+   * Get the value for a particular column of the Row as a double.\n+   *\n+   * @param columnIndex index of column (1-indexed).\n+   * @return column value.\n+   */\n+  Double getDouble(int columnIndex);\n+\n+  /**\n+   * Get the value for a particular column of the Row as a double.\n+   *\n+   * @param columnName name of column.\n+   * @return column value.\n+   */\n+  Double getDouble(String columnName);\n+\n+  /**\n+   * Get the value for a particular column of the Row as a boolean.\n+   *\n+   * @param columnIndex index of column (1-indexed).\n+   * @return column value.\n+   */\n+  Boolean getBoolean(int columnIndex);\n+\n+  /**\n+   * Get the value for a particular column of the Row as a boolean.\n+   *\n+   * @param columnName name of column.\n+   * @return column value.\n+   */\n+  Boolean getBoolean(String columnName);\n+\n+  /**\n+   * Get the value for a particular column of the Row as a decimal.\n+   *\n+   * @param columnIndex index of column (1-indexed).\n+   * @return column value.\n+   */\n+  BigDecimal getDecimal(int columnIndex);\n+\n+  /**\n+   * Get the value for a particular column of the Row as a decimal.\n+   *\n+   * @param columnName name of column.\n+   * @return column value.\n+   */\n+  BigDecimal getDecimal(String columnName);\n+}\n+```\n+\n+We considered representing column types in a more structured form (rather than plain strings) to accomodate complex/nested data types but felt this added complexity would not be helpful for most use cases. (This would also require a server-side change, so it's a fair bit of additional work.)\n+\n+For `getDecimal(...)` in the `Row` interface, rather than trying to parse the column type to extract the precision and scale, we will simply convert the value to a BigDecimal without explicitly specifying the precision and scale. We could also add an option for users to specify the scale and precision in the getter, if we think that would be useful.\n+\n+We could also add `getList(...)` and `getMap(...)` methods to the `Row` interface, but it's not clear to me how valuable this would be given that the nested data types would not be known.\n+\n+Tim also proposed switching from generic Java types (`Map<String, Object>`, `List<Object>`) to Vert.x types (`JsonObject`, `JsonArray`) as the latter is more type-safe and the client already has a dependency on Vert.x anyway. The downside, though, is that then apps that use the client would be required to depend on Vert.x as well.\n+\n+### Transient queries -- Non-streaming\n+\n+The `Client` interface will also provide the following methods for receiving the results of a transient query (push or pull) in a single batch (non-streaming),\n+once the query has completed:\n+```\n+  /**\n+   * Execute a query (push or pull) and receive all result rows together, once the query has\n+   * completed.\n+   *\n+   * @param sql statement of query to execute.\n+   * @return query result.\n+   */\n+  CompletableFuture<List<Row>> executeQuery(String sql);\n+\n+  /**\n+   * Execute a query (push or pull) and receive all result rows together, once the query has\n+   * completed.\n+   *\n+   * @param sql statement of query to execute.\n+   * @param properties query properties.\n+   * @return query result.\n+   */\n+  CompletableFuture<List<Row>> executeQuery(String sql, Map<String, Object> properties);\n+```\n+\n+For a query to \"complete\" could mean:\n+* The query is a pull query\n+* The query is a push query with a limit clause, and the limit has been reached\n+* The query is a push query that has been terminated\n+\n+We may want to introduce a limit to the number of rows that may be returned from these `executeQuery()` methods,\n+in order to decrease the likelihood of running out of memory.\n+\n+### Insert values\n+\n+A method to insert one row at a time:\n+```\n+  /**\n+   * Insert a single row into the relevant stream/table.\n+   *\n+   * @param streamName name of stream/table.\n+   * @param row the row to insert.\n+   * @return a future that completes once the request has been processed.\n+   */\n+  CompletableFuture<Void> insertInto(String streamName, Map<String, Object> row);\n+```\n+\n+A method to stream inserts (via the `/inserts-stream` endpoint):\n+```\n+  CompletableFuture<Publisher<InsertResponse>> streamInserts(String streamName, Publisher<List<Object>> insertsPublisher);\n+}\n+```\n+where `InsertResponse` is as follows:\n+```\n+public interface InsertResponse {\n+\n+  /**\n+   * Whether the row was successfully inserted or not.\n+   */\n+  boolean isSuccessful();\n+\n+  /**\n+   * Unique sequence number for the row in the stream of inserts.\n+   */\n+  int getSequenceNum();\n+\n+  /**\n+   * If unsuccessful, the error message.\n+   */\n+  String getErrorMessage();\n+\n+  /**\n+   * If unsuccessful, the error code.\n+   */\n+  int getErrorCode();\n+\n+}\n+```\n+\n+### DDL/DML operations\n+\n+#### `CREATE <STREAM/TABLE>`, `CREATE <STREAM/TABLE> ... AS SELECT`, `INSERT INTO`\n+\n+`Client` methods:\n+```\n+  /**\n+   * Execute DDL statement: `CREATE STREAM`, `CREATE TABLE`\n+   */\n+  CompletableFuture<DdlResponse> executeDdl(String sql);\n+\n+  /**\n+   * Execute DML statement: `CREATE STREAM ... AS SELECT`, `CREATE TABLE ... AS SELECT`, `INSERT INTO`\n+   */\n+  CompletableFuture<DmlResponse> executeDml(String sql);\n+\n+  /**\n+   * Execute DML statement: `CREATE STREAM ... AS SELECT`, `CREATE TABLE ... AS SELECT`, `INSERT INTO`\n+   */\n+  CompletableFuture<DmlResponse> executeDml(String sql, Map<String, Object> properties);\n+\n+```\n+with\n+```\n+public interface DdlResponse {\n+\n+  enum Status { QUEUED, PARSING, EXECUTING, RUNNING, TERMINATED, SUCCESS, ERROR }\n+  \n+  Status getStatus();\n+  \n+  String getStatusMessage();\n+  \n+  long getCommandSequenceNumber();\n+\n+  String getCommandId();\n+}\n+```\n+and `DmlResponse` is identical.\n+\n+I don't love this proposal since `DDL` and `DML` aren't used throughout our docs but I'm not a huge fan of the alternatives I considered either, such as\n+```\n+  CompletableFuture<CreateSourceResponse> createStream(String sql);\n+\n+  CompletableFuture<CreateSourceResponse> createStream(String sql, Map<String, Object> properties);\n+\n+  CompletableFuture<CreateSourceResponse> createTable(String sql);\n+\n+  CompletableFuture<CreateSourceResponse> createTable(String sql, Map<String, Object> properties);\n+\n+  CompletableFuture<InsertIntoResponse> insertIntoSource(String sql);\n+\n+  CompletableFuture<InsertIntoResponse> insertIntoSource(String sql, Map<String, Object> properties);\n+```\n+\n+In this version, the implementations of `createStream(...)` and `createTable(...)` would be identical and could be replaced with a single `createSource(...)`\n+but the name of this method feels confusing. As with the previous proposal, `CreateSourceResponse` and `InsertIntoResponse` are identical.\n+\n+Other alternatives include separating `CREATE <STREAM/TABLE>` and `CREATE <STREAM/TABLE> ... AS SELECT` into separate methods, but that feels unnecessarily complex.\n+\n+#### `DROP <STREAM/TABLE>`\n+\n+`Client` methods:\n+```\n+  /**\n+   * Drop stream. The underlying Kafka topic will not be deleted.\n+   */\n+  CompletableFuture<DropSourceResponse> dropStream(String streamName);\n+\n+  /**\n+   * Drop stream. The underlying Kafka topic may optionally be deleted.\n+   */\n+  CompletableFuture<DropSourceResponse> dropStream(String streamName, boolean deleteTopic);\n+\n+  /**\n+   * Drop table. The underlying Kafka topic will not be deleted.\n+   */\n+  CompletableFuture<DropSourceResponse> dropTable(String tableName);\n+\n+  /**\n+   * Drop table. The underlying Kafka topic may optionally be deleted.\n+   */\n+  CompletableFuture<DropSourceResponse> dropTable(String tableName, boolean deleteTopic);\n+```\n+where `DropSourceResponse` is actually the same as `DdlResponse`/`DmlResponse`/`CreateSourceResponse`/`InsertIntoResponse` above.\n+\n+Again, the implementations of `dropStream(...)` and `dropTable(...)` would be the same so we could instead have a single `dropSource(...)`, but the naming might be confusing.\n+\n+If we choose to keep them separate, there's an open question of whether the client should validate that `dropStream(...)` is not used to drop a table, and vice versa.\n+IMO such validation would be introducing complexity without much benefit, though this point of ambiguity makes me prefer a single `dropSource(...)` if we can agree on a method name that's not confusing.\n+\n+Note that users can also execute `DROP <STREAM/TABLE>` requests via `executeDdl(...)` or `executDml(...)` above.\n+\n+#### `TERMINATE <queryId>`\n+\n+```\n+  CompletableFuture<TerminateQueryResponse> terminatePersistentQuery(String queryId);\n+```\n+where `TerminateQueryResponse` is again the same as `DdlResponse`/`DmlResponse`/`CreateSourceResponse`/`InsertIntoResponse`/`DropSourceResponse` above.\n+\n+The method name `terminatePersistenQuery(...)` is to distinguish from `terminatePushQuery(...)` below.\n+\n+#### Connectors\n+\n+```\n+  CompletableFuture<ConnectorInfo> createSourceConnector(String name, Map<String, String> properties);\n+\n+  CompletableFuture<ConnectorInfo> createSinkConnector(String name, Map<String, String> properties);\n+\n+  CompletableFuture<Void> dropConnector(String name);\n+```\n+where `ConnectorInfo` is from an Apache Kafka module ([link](https://github.com/apache/kafka/blob/trunk/connect/runtime/src/main/java/org/apache/kafka/connect/runtime/rest/entities/ConnectorInfo.java)).\n+\n+Or would we rather not have a dependency on Apache Kafka in the ksqlDB client interfaces?", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aed38d5836550829f7fd459df31b47aaf7e5ad45"}, "originalPosition": 528}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODEzNzA4OQ==", "bodyText": "For this case, I think a String makes sense - especially if we ever want to support pluggable schemas (which is what schema registry has moved toward and they standardized on strings as the names for formats)", "url": "https://github.com/confluentinc/ksql/pull/5236#discussion_r418137089", "createdAt": "2020-04-30T16:28:59Z", "author": {"login": "agavra"}, "path": "design-proposals/klip-26-java-client-interfaces.md", "diffHunk": "@@ -0,0 +1,715 @@\n+# KLIP 26 - Java client interfaces\n+\n+**Author**: Victoria Xia (@vcrfxia) | \n+**Release Target**: ksqlDB 0.10.0 | \n+**Status**: _In development_ | \n+**Discussion**: TBD\n+\n+**tl;dr:** _[KLIP 15](./klip-15-new-api-and-client.md) already made the case for why it makes sense\n+           to introduce a Java client for ksqlDB. This KLIP proposes interfaces for the client._\n+\n+## Motivation and background\n+\n+See [KLIP 15](./klip-15-new-api-and-client.md).\n+\n+## What is in scope\n+\n+The Java client will support the following operations:\n+* Push query\n+* Pull query\n+* Select DDL/DML operations:\n+    * `CREATE STREAM`\n+    * `CREATE TABLE`\n+    * `CREATE STREAM ... AS SELECT`\n+    * `CREATE TABLE ... AS SELECT`\n+    * `DROP STREAM`\n+    * `DROP TABLE`\n+    * `INSERT INTO`\n+    * `TERMINATE <queryId>`\n+    * `CREATE CONNECTOR`\n+    * `DROP CONNECTOR`\n+* Select admin operations:\n+    * `SHOW TOPICS` (non-extended)\n+    * `SHOW STREAMS` (non-extended)\n+    * `SHOW TABLES` (non-extended)\n+    * `SHOW QUERIES` (non-extended)\n+    * `SHOW CONNECTORS`\n+* Insert values, i.e., insert rows into an existing stream/table\n+* Terminate push query (via the `/close-query` endpoint)\n+\n+The purpose of this KLIP is to reach agreement on the interfaces / public APIs.\n+Implementation details will not be covered.\n+\n+## What is not in scope\n+\n+This KLIP does not cover Java client support for the following:\n+* `DESCRIBE <stream/table>`, `DESCRIBE CONNECTOR`, `DESCRIBE FUNCTION`\n+* `EXPLAIN <queryId>`\n+* `PRINT <topic>`\n+* `SHOW TOPICS EXTENDED`, `SHOW <STREAMS/TABLES> EXTENDED`, `SHOW QUERIES EXTENDED`\n+* `CREATE TYPE`, `DROP TYPE`, `SHOW TYPES`\n+* `SHOW FUNCTIONS`, `SHOW PROPERTIES`\n+* `RUN SCRIPT`\n+* Use of other endpoints (info, healthcheck, terminate cluster, status, etc.)\n+\n+We can always add support for these operations in the future if desired.\n+\n+As above, implementation details are out of scope as the purpose of this KLIP is to reach agreement\n+on the interfaces / public APIs.\n+\n+## Value/Return\n+\n+See [KLIP 15](./klip-15-new-api-and-client.md).\n+\n+## Public APIS\n+\n+The following subsections describe the methods of the `Client` interface:\n+```\n+public interface Client {\n+    ...\n+}\n+```\n+\n+### Constructors\n+```\n+  static Client create(ClientOptions clientOptions) {\n+    return new ClientImpl(clientOptions);\n+  }\n+\n+  static Client create(ClientOptions clientOptions, Vertx vertx) {\n+    return new ClientImpl(clientOptions, vertx);\n+  }\n+```\n+\n+The Java client will be implemented as a Vert.x HttpClient. We expose a constructor that allows users to provide their own `Vertx` instance\n+in order to take advantage of a shared connection pool and other properties if desired.\n+\n+`ClientOptions` will initially be as follows:\n+```\n+public interface ClientOptions {\n+\n+  ClientOptions setHost(String host);\n+\n+  ClientOptions setPort(int port);\n+\n+  ClientOptions setUseTls(boolean useTls);\n+\n+  ClientOptions setUseClientAuth(boolean useClientAuth);\n+\n+  ClientOptions setTrustStore(String trustStorePath);\n+\n+  ClientOptions setTrustStorePassword(String trustStorePassword);\n+\n+  ClientOptions setKeyStore(String keyStorePath);\n+\n+  ClientOptions setKeyStorePassword(String keyStorePassword);\n+\n+  ClientOptions setBasicAuthCredentials(String username, String password);\n+\n+  String getHost();\n+\n+  int getPort();\n+\n+  boolean isUseTls();\n+\n+  boolean isUseClientAuth();\n+\n+  boolean isUseBasicAuth();\n+\n+  String getTrustStore();\n+\n+  String getTrustStorePassword();\n+\n+  String getKeyStore();\n+\n+  String getKeyStorePassword();\n+\n+  String getBasicAuthUsername();\n+\n+  String getBasicAuthPassword();\n+\n+  ClientOptions copy();\n+\n+  static ClientOptions create() {\n+    return new ClientOptionsImpl();\n+  }\n+}\n+```\n+\n+We can always add additional configuration options later. We may also wish to expose the Vert.x `HttpClientOptions` for\n+advanced users that wish to provide custom configs.\n+\n+### Transient queries -- Streaming\n+\n+The `Client` interface will provide the following methods for streaming the results of a transient (push or pull) query:\n+```\n+  /**\n+   * Execute a query (push or pull) and receive the results one row at a time.\n+   *\n+   * @param sql statement of query to execute.\n+   * @return query result.\n+   */\n+  CompletableFuture<QueryResult> streamQuery(String sql);\n+\n+  /**\n+   * Execute a query (push or pull) and receive the results one row at a time.\n+   *\n+   * @param sql statement of query to execute.\n+   * @param properties query properties.\n+   * @return query result.\n+   */\n+  CompletableFuture<QueryResult> streamQuery(String sql, Map<String, Object> properties);\n+```\n+where `QueryResult` is as follows:\n+```\n+/**\n+ * The result of a query (push or pull), streamed one row at time. Records may be consumed by either\n+ * subscribing to the publisher or polling (blocking) for one record at a time. These two methods of\n+ * consumption are mutually exclusive; only one method may be used (per QueryResult).\n+ */\n+public interface QueryResult extends Publisher<Row> {\n+\n+  List<String> columnNames();\n+\n+  List<String> columnTypes();\n+\n+  String queryID();\n+\n+  /**\n+   * Block until a row becomes available.\n+   *\n+   * @return the row.\n+   */\n+  Row poll();\n+\n+  /**\n+   * Block until a row becomes available or the timeout has elapsed.\n+   *\n+   * @param timeout amount of to wait for a row. Non-positive values are interpreted as no timeout.\n+   * @param timeUnit unit for timeout param.\n+   * @return the row, if available; else, null.\n+   */\n+  Row poll(long timeout, TimeUnit timeUnit);\n+\n+  boolean isComplete();\n+\n+  void close();\n+}\n+```\n+Note that `QueryResult` is a Reactive Streams `Publisher` so users can stream results. Users can also call `poll()` to receive\n+results in a synchronous fashion instead. Only one of the two methods will be allowed per `QueryResult` instance.\n+\n+The `Row` interface is as follows:\n+```\n+/**\n+ * A single record, returned as part of a query result.\n+ */\n+public interface Row {\n+\n+  List<String> columnNames();\n+\n+  List<String> columnTypes();\n+\n+  List<Object> values();\n+\n+  /**\n+   * Get the value for a particular column of the Row as an Object.\n+   *\n+   * @param columnIndex index of column (1-indexed).\n+   * @return column value.\n+   */\n+  Object getObject(int columnIndex);\n+\n+  /**\n+   * Get the value for a particular column of the Row as an Object.\n+   *\n+   * @param columnName name of column.\n+   * @return column value.\n+   */\n+  Object getObject(String columnName);\n+\n+  /**\n+   * Get the value for a particular column of the Row as a string.\n+   *\n+   * @param columnIndex index of column (1-indexed).\n+   * @return column value.\n+   */\n+  String getString(int columnIndex);\n+\n+  /**\n+   * Get the value for a particular column of the Row as a string.\n+   *\n+   * @param columnName name of column.\n+   * @return column value.\n+   */\n+  String getString(String columnName);\n+\n+  /**\n+   * Get the value for a particular column of the Row as an integer.\n+   *\n+   * @param columnIndex index of column (1-indexed).\n+   * @return column value.\n+   */\n+  Integer getInt(int columnIndex);\n+\n+  /**\n+   * Get the value for a particular column of the Row as an integer.\n+   *\n+   * @param columnName name of column.\n+   * @return column value.\n+   */\n+  Integer getInt(String columnName);\n+\n+  /**\n+   * Get the value for a particular column of the Row as a long.\n+   *\n+   * @param columnIndex index of column (1-indexed).\n+   * @return column value.\n+   */\n+  Long getLong(int columnIndex);\n+\n+  /**\n+   * Get the value for a particular column of the Row as a long.\n+   *\n+   * @param columnName name of column.\n+   * @return column value.\n+   */\n+  Long getLong(String columnName);\n+\n+  /**\n+   * Get the value for a particular column of the Row as a double.\n+   *\n+   * @param columnIndex index of column (1-indexed).\n+   * @return column value.\n+   */\n+  Double getDouble(int columnIndex);\n+\n+  /**\n+   * Get the value for a particular column of the Row as a double.\n+   *\n+   * @param columnName name of column.\n+   * @return column value.\n+   */\n+  Double getDouble(String columnName);\n+\n+  /**\n+   * Get the value for a particular column of the Row as a boolean.\n+   *\n+   * @param columnIndex index of column (1-indexed).\n+   * @return column value.\n+   */\n+  Boolean getBoolean(int columnIndex);\n+\n+  /**\n+   * Get the value for a particular column of the Row as a boolean.\n+   *\n+   * @param columnName name of column.\n+   * @return column value.\n+   */\n+  Boolean getBoolean(String columnName);\n+\n+  /**\n+   * Get the value for a particular column of the Row as a decimal.\n+   *\n+   * @param columnIndex index of column (1-indexed).\n+   * @return column value.\n+   */\n+  BigDecimal getDecimal(int columnIndex);\n+\n+  /**\n+   * Get the value for a particular column of the Row as a decimal.\n+   *\n+   * @param columnName name of column.\n+   * @return column value.\n+   */\n+  BigDecimal getDecimal(String columnName);\n+}\n+```\n+\n+We considered representing column types in a more structured form (rather than plain strings) to accomodate complex/nested data types but felt this added complexity would not be helpful for most use cases. (This would also require a server-side change, so it's a fair bit of additional work.)\n+\n+For `getDecimal(...)` in the `Row` interface, rather than trying to parse the column type to extract the precision and scale, we will simply convert the value to a BigDecimal without explicitly specifying the precision and scale. We could also add an option for users to specify the scale and precision in the getter, if we think that would be useful.\n+\n+We could also add `getList(...)` and `getMap(...)` methods to the `Row` interface, but it's not clear to me how valuable this would be given that the nested data types would not be known.\n+\n+Tim also proposed switching from generic Java types (`Map<String, Object>`, `List<Object>`) to Vert.x types (`JsonObject`, `JsonArray`) as the latter is more type-safe and the client already has a dependency on Vert.x anyway. The downside, though, is that then apps that use the client would be required to depend on Vert.x as well.\n+\n+### Transient queries -- Non-streaming\n+\n+The `Client` interface will also provide the following methods for receiving the results of a transient query (push or pull) in a single batch (non-streaming),\n+once the query has completed:\n+```\n+  /**\n+   * Execute a query (push or pull) and receive all result rows together, once the query has\n+   * completed.\n+   *\n+   * @param sql statement of query to execute.\n+   * @return query result.\n+   */\n+  CompletableFuture<List<Row>> executeQuery(String sql);\n+\n+  /**\n+   * Execute a query (push or pull) and receive all result rows together, once the query has\n+   * completed.\n+   *\n+   * @param sql statement of query to execute.\n+   * @param properties query properties.\n+   * @return query result.\n+   */\n+  CompletableFuture<List<Row>> executeQuery(String sql, Map<String, Object> properties);\n+```\n+\n+For a query to \"complete\" could mean:\n+* The query is a pull query\n+* The query is a push query with a limit clause, and the limit has been reached\n+* The query is a push query that has been terminated\n+\n+We may want to introduce a limit to the number of rows that may be returned from these `executeQuery()` methods,\n+in order to decrease the likelihood of running out of memory.\n+\n+### Insert values\n+\n+A method to insert one row at a time:\n+```\n+  /**\n+   * Insert a single row into the relevant stream/table.\n+   *\n+   * @param streamName name of stream/table.\n+   * @param row the row to insert.\n+   * @return a future that completes once the request has been processed.\n+   */\n+  CompletableFuture<Void> insertInto(String streamName, Map<String, Object> row);\n+```\n+\n+A method to stream inserts (via the `/inserts-stream` endpoint):\n+```\n+  CompletableFuture<Publisher<InsertResponse>> streamInserts(String streamName, Publisher<List<Object>> insertsPublisher);\n+}\n+```\n+where `InsertResponse` is as follows:\n+```\n+public interface InsertResponse {\n+\n+  /**\n+   * Whether the row was successfully inserted or not.\n+   */\n+  boolean isSuccessful();\n+\n+  /**\n+   * Unique sequence number for the row in the stream of inserts.\n+   */\n+  int getSequenceNum();\n+\n+  /**\n+   * If unsuccessful, the error message.\n+   */\n+  String getErrorMessage();\n+\n+  /**\n+   * If unsuccessful, the error code.\n+   */\n+  int getErrorCode();\n+\n+}\n+```\n+\n+### DDL/DML operations\n+\n+#### `CREATE <STREAM/TABLE>`, `CREATE <STREAM/TABLE> ... AS SELECT`, `INSERT INTO`\n+\n+`Client` methods:\n+```\n+  /**\n+   * Execute DDL statement: `CREATE STREAM`, `CREATE TABLE`\n+   */\n+  CompletableFuture<DdlResponse> executeDdl(String sql);\n+\n+  /**\n+   * Execute DML statement: `CREATE STREAM ... AS SELECT`, `CREATE TABLE ... AS SELECT`, `INSERT INTO`\n+   */\n+  CompletableFuture<DmlResponse> executeDml(String sql);\n+\n+  /**\n+   * Execute DML statement: `CREATE STREAM ... AS SELECT`, `CREATE TABLE ... AS SELECT`, `INSERT INTO`\n+   */\n+  CompletableFuture<DmlResponse> executeDml(String sql, Map<String, Object> properties);\n+\n+```\n+with\n+```\n+public interface DdlResponse {\n+\n+  enum Status { QUEUED, PARSING, EXECUTING, RUNNING, TERMINATED, SUCCESS, ERROR }\n+  \n+  Status getStatus();\n+  \n+  String getStatusMessage();\n+  \n+  long getCommandSequenceNumber();\n+\n+  String getCommandId();\n+}\n+```\n+and `DmlResponse` is identical.\n+\n+I don't love this proposal since `DDL` and `DML` aren't used throughout our docs but I'm not a huge fan of the alternatives I considered either, such as\n+```\n+  CompletableFuture<CreateSourceResponse> createStream(String sql);\n+\n+  CompletableFuture<CreateSourceResponse> createStream(String sql, Map<String, Object> properties);\n+\n+  CompletableFuture<CreateSourceResponse> createTable(String sql);\n+\n+  CompletableFuture<CreateSourceResponse> createTable(String sql, Map<String, Object> properties);\n+\n+  CompletableFuture<InsertIntoResponse> insertIntoSource(String sql);\n+\n+  CompletableFuture<InsertIntoResponse> insertIntoSource(String sql, Map<String, Object> properties);\n+```\n+\n+In this version, the implementations of `createStream(...)` and `createTable(...)` would be identical and could be replaced with a single `createSource(...)`\n+but the name of this method feels confusing. As with the previous proposal, `CreateSourceResponse` and `InsertIntoResponse` are identical.\n+\n+Other alternatives include separating `CREATE <STREAM/TABLE>` and `CREATE <STREAM/TABLE> ... AS SELECT` into separate methods, but that feels unnecessarily complex.\n+\n+#### `DROP <STREAM/TABLE>`\n+\n+`Client` methods:\n+```\n+  /**\n+   * Drop stream. The underlying Kafka topic will not be deleted.\n+   */\n+  CompletableFuture<DropSourceResponse> dropStream(String streamName);\n+\n+  /**\n+   * Drop stream. The underlying Kafka topic may optionally be deleted.\n+   */\n+  CompletableFuture<DropSourceResponse> dropStream(String streamName, boolean deleteTopic);\n+\n+  /**\n+   * Drop table. The underlying Kafka topic will not be deleted.\n+   */\n+  CompletableFuture<DropSourceResponse> dropTable(String tableName);\n+\n+  /**\n+   * Drop table. The underlying Kafka topic may optionally be deleted.\n+   */\n+  CompletableFuture<DropSourceResponse> dropTable(String tableName, boolean deleteTopic);\n+```\n+where `DropSourceResponse` is actually the same as `DdlResponse`/`DmlResponse`/`CreateSourceResponse`/`InsertIntoResponse` above.\n+\n+Again, the implementations of `dropStream(...)` and `dropTable(...)` would be the same so we could instead have a single `dropSource(...)`, but the naming might be confusing.\n+\n+If we choose to keep them separate, there's an open question of whether the client should validate that `dropStream(...)` is not used to drop a table, and vice versa.\n+IMO such validation would be introducing complexity without much benefit, though this point of ambiguity makes me prefer a single `dropSource(...)` if we can agree on a method name that's not confusing.\n+\n+Note that users can also execute `DROP <STREAM/TABLE>` requests via `executeDdl(...)` or `executDml(...)` above.\n+\n+#### `TERMINATE <queryId>`\n+\n+```\n+  CompletableFuture<TerminateQueryResponse> terminatePersistentQuery(String queryId);\n+```\n+where `TerminateQueryResponse` is again the same as `DdlResponse`/`DmlResponse`/`CreateSourceResponse`/`InsertIntoResponse`/`DropSourceResponse` above.\n+\n+The method name `terminatePersistenQuery(...)` is to distinguish from `terminatePushQuery(...)` below.\n+\n+#### Connectors\n+\n+```\n+  CompletableFuture<ConnectorInfo> createSourceConnector(String name, Map<String, String> properties);\n+\n+  CompletableFuture<ConnectorInfo> createSinkConnector(String name, Map<String, String> properties);\n+\n+  CompletableFuture<Void> dropConnector(String name);\n+```\n+where `ConnectorInfo` is from an Apache Kafka module ([link](https://github.com/apache/kafka/blob/trunk/connect/runtime/src/main/java/org/apache/kafka/connect/runtime/rest/entities/ConnectorInfo.java)).\n+\n+Or would we rather not have a dependency on Apache Kafka in the ksqlDB client interfaces?\n+\n+### Admin operations\n+\n+#### `SHOW TOPICS`\n+\n+```\n+  CompletableFuture<List<TopicInfo>> listTopics();\n+```\n+with\n+```\n+public interface TopicInfo {\n+\n+  String getName();\n+\n+  int getPartitions();\n+  \n+  List<Integer> getReplicasPerPartition();\n+\n+}\n+```\n+\n+#### `SHOW <STREAMS/TABLES>`\n+\n+```\n+  CompletableFuture<List<StreamInfo>> listStreams();\n+\n+  CompletableFuture<List<TableInfo>> listTables();\n+```\n+with\n+```\n+public interface StreamInfo {\n+\n+  String getName();\n+\n+  String getTopic();\n+\n+  String getFormat();\n+  \n+}\n+```\n+and\n+```\n+public interface TableInfo {\n+\n+  String getName();\n+\n+  String getTopic();\n+\n+  String getFormat();\n+\n+  boolean isWindowed();\n+  \n+}\n+```\n+\n+I'm not sure whether it makes more sense for `StreamInfo#getFormat()` and `TableInfo#getFormat()` to return a string or an enum value.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aed38d5836550829f7fd459df31b47aaf7e5ad45"}, "originalPosition": 584}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODEzODI1MA==", "bodyText": "optional? seems like the exact intended use case \ud83d\ude02", "url": "https://github.com/confluentinc/ksql/pull/5236#discussion_r418138250", "createdAt": "2020-04-30T16:30:48Z", "author": {"login": "agavra"}, "path": "design-proposals/klip-26-java-client-interfaces.md", "diffHunk": "@@ -0,0 +1,715 @@\n+# KLIP 26 - Java client interfaces\n+\n+**Author**: Victoria Xia (@vcrfxia) | \n+**Release Target**: ksqlDB 0.10.0 | \n+**Status**: _In development_ | \n+**Discussion**: TBD\n+\n+**tl;dr:** _[KLIP 15](./klip-15-new-api-and-client.md) already made the case for why it makes sense\n+           to introduce a Java client for ksqlDB. This KLIP proposes interfaces for the client._\n+\n+## Motivation and background\n+\n+See [KLIP 15](./klip-15-new-api-and-client.md).\n+\n+## What is in scope\n+\n+The Java client will support the following operations:\n+* Push query\n+* Pull query\n+* Select DDL/DML operations:\n+    * `CREATE STREAM`\n+    * `CREATE TABLE`\n+    * `CREATE STREAM ... AS SELECT`\n+    * `CREATE TABLE ... AS SELECT`\n+    * `DROP STREAM`\n+    * `DROP TABLE`\n+    * `INSERT INTO`\n+    * `TERMINATE <queryId>`\n+    * `CREATE CONNECTOR`\n+    * `DROP CONNECTOR`\n+* Select admin operations:\n+    * `SHOW TOPICS` (non-extended)\n+    * `SHOW STREAMS` (non-extended)\n+    * `SHOW TABLES` (non-extended)\n+    * `SHOW QUERIES` (non-extended)\n+    * `SHOW CONNECTORS`\n+* Insert values, i.e., insert rows into an existing stream/table\n+* Terminate push query (via the `/close-query` endpoint)\n+\n+The purpose of this KLIP is to reach agreement on the interfaces / public APIs.\n+Implementation details will not be covered.\n+\n+## What is not in scope\n+\n+This KLIP does not cover Java client support for the following:\n+* `DESCRIBE <stream/table>`, `DESCRIBE CONNECTOR`, `DESCRIBE FUNCTION`\n+* `EXPLAIN <queryId>`\n+* `PRINT <topic>`\n+* `SHOW TOPICS EXTENDED`, `SHOW <STREAMS/TABLES> EXTENDED`, `SHOW QUERIES EXTENDED`\n+* `CREATE TYPE`, `DROP TYPE`, `SHOW TYPES`\n+* `SHOW FUNCTIONS`, `SHOW PROPERTIES`\n+* `RUN SCRIPT`\n+* Use of other endpoints (info, healthcheck, terminate cluster, status, etc.)\n+\n+We can always add support for these operations in the future if desired.\n+\n+As above, implementation details are out of scope as the purpose of this KLIP is to reach agreement\n+on the interfaces / public APIs.\n+\n+## Value/Return\n+\n+See [KLIP 15](./klip-15-new-api-and-client.md).\n+\n+## Public APIS\n+\n+The following subsections describe the methods of the `Client` interface:\n+```\n+public interface Client {\n+    ...\n+}\n+```\n+\n+### Constructors\n+```\n+  static Client create(ClientOptions clientOptions) {\n+    return new ClientImpl(clientOptions);\n+  }\n+\n+  static Client create(ClientOptions clientOptions, Vertx vertx) {\n+    return new ClientImpl(clientOptions, vertx);\n+  }\n+```\n+\n+The Java client will be implemented as a Vert.x HttpClient. We expose a constructor that allows users to provide their own `Vertx` instance\n+in order to take advantage of a shared connection pool and other properties if desired.\n+\n+`ClientOptions` will initially be as follows:\n+```\n+public interface ClientOptions {\n+\n+  ClientOptions setHost(String host);\n+\n+  ClientOptions setPort(int port);\n+\n+  ClientOptions setUseTls(boolean useTls);\n+\n+  ClientOptions setUseClientAuth(boolean useClientAuth);\n+\n+  ClientOptions setTrustStore(String trustStorePath);\n+\n+  ClientOptions setTrustStorePassword(String trustStorePassword);\n+\n+  ClientOptions setKeyStore(String keyStorePath);\n+\n+  ClientOptions setKeyStorePassword(String keyStorePassword);\n+\n+  ClientOptions setBasicAuthCredentials(String username, String password);\n+\n+  String getHost();\n+\n+  int getPort();\n+\n+  boolean isUseTls();\n+\n+  boolean isUseClientAuth();\n+\n+  boolean isUseBasicAuth();\n+\n+  String getTrustStore();\n+\n+  String getTrustStorePassword();\n+\n+  String getKeyStore();\n+\n+  String getKeyStorePassword();\n+\n+  String getBasicAuthUsername();\n+\n+  String getBasicAuthPassword();\n+\n+  ClientOptions copy();\n+\n+  static ClientOptions create() {\n+    return new ClientOptionsImpl();\n+  }\n+}\n+```\n+\n+We can always add additional configuration options later. We may also wish to expose the Vert.x `HttpClientOptions` for\n+advanced users that wish to provide custom configs.\n+\n+### Transient queries -- Streaming\n+\n+The `Client` interface will provide the following methods for streaming the results of a transient (push or pull) query:\n+```\n+  /**\n+   * Execute a query (push or pull) and receive the results one row at a time.\n+   *\n+   * @param sql statement of query to execute.\n+   * @return query result.\n+   */\n+  CompletableFuture<QueryResult> streamQuery(String sql);\n+\n+  /**\n+   * Execute a query (push or pull) and receive the results one row at a time.\n+   *\n+   * @param sql statement of query to execute.\n+   * @param properties query properties.\n+   * @return query result.\n+   */\n+  CompletableFuture<QueryResult> streamQuery(String sql, Map<String, Object> properties);\n+```\n+where `QueryResult` is as follows:\n+```\n+/**\n+ * The result of a query (push or pull), streamed one row at time. Records may be consumed by either\n+ * subscribing to the publisher or polling (blocking) for one record at a time. These two methods of\n+ * consumption are mutually exclusive; only one method may be used (per QueryResult).\n+ */\n+public interface QueryResult extends Publisher<Row> {\n+\n+  List<String> columnNames();\n+\n+  List<String> columnTypes();\n+\n+  String queryID();\n+\n+  /**\n+   * Block until a row becomes available.\n+   *\n+   * @return the row.\n+   */\n+  Row poll();\n+\n+  /**\n+   * Block until a row becomes available or the timeout has elapsed.\n+   *\n+   * @param timeout amount of to wait for a row. Non-positive values are interpreted as no timeout.\n+   * @param timeUnit unit for timeout param.\n+   * @return the row, if available; else, null.\n+   */\n+  Row poll(long timeout, TimeUnit timeUnit);\n+\n+  boolean isComplete();\n+\n+  void close();\n+}\n+```\n+Note that `QueryResult` is a Reactive Streams `Publisher` so users can stream results. Users can also call `poll()` to receive\n+results in a synchronous fashion instead. Only one of the two methods will be allowed per `QueryResult` instance.\n+\n+The `Row` interface is as follows:\n+```\n+/**\n+ * A single record, returned as part of a query result.\n+ */\n+public interface Row {\n+\n+  List<String> columnNames();\n+\n+  List<String> columnTypes();\n+\n+  List<Object> values();\n+\n+  /**\n+   * Get the value for a particular column of the Row as an Object.\n+   *\n+   * @param columnIndex index of column (1-indexed).\n+   * @return column value.\n+   */\n+  Object getObject(int columnIndex);\n+\n+  /**\n+   * Get the value for a particular column of the Row as an Object.\n+   *\n+   * @param columnName name of column.\n+   * @return column value.\n+   */\n+  Object getObject(String columnName);\n+\n+  /**\n+   * Get the value for a particular column of the Row as a string.\n+   *\n+   * @param columnIndex index of column (1-indexed).\n+   * @return column value.\n+   */\n+  String getString(int columnIndex);\n+\n+  /**\n+   * Get the value for a particular column of the Row as a string.\n+   *\n+   * @param columnName name of column.\n+   * @return column value.\n+   */\n+  String getString(String columnName);\n+\n+  /**\n+   * Get the value for a particular column of the Row as an integer.\n+   *\n+   * @param columnIndex index of column (1-indexed).\n+   * @return column value.\n+   */\n+  Integer getInt(int columnIndex);\n+\n+  /**\n+   * Get the value for a particular column of the Row as an integer.\n+   *\n+   * @param columnName name of column.\n+   * @return column value.\n+   */\n+  Integer getInt(String columnName);\n+\n+  /**\n+   * Get the value for a particular column of the Row as a long.\n+   *\n+   * @param columnIndex index of column (1-indexed).\n+   * @return column value.\n+   */\n+  Long getLong(int columnIndex);\n+\n+  /**\n+   * Get the value for a particular column of the Row as a long.\n+   *\n+   * @param columnName name of column.\n+   * @return column value.\n+   */\n+  Long getLong(String columnName);\n+\n+  /**\n+   * Get the value for a particular column of the Row as a double.\n+   *\n+   * @param columnIndex index of column (1-indexed).\n+   * @return column value.\n+   */\n+  Double getDouble(int columnIndex);\n+\n+  /**\n+   * Get the value for a particular column of the Row as a double.\n+   *\n+   * @param columnName name of column.\n+   * @return column value.\n+   */\n+  Double getDouble(String columnName);\n+\n+  /**\n+   * Get the value for a particular column of the Row as a boolean.\n+   *\n+   * @param columnIndex index of column (1-indexed).\n+   * @return column value.\n+   */\n+  Boolean getBoolean(int columnIndex);\n+\n+  /**\n+   * Get the value for a particular column of the Row as a boolean.\n+   *\n+   * @param columnName name of column.\n+   * @return column value.\n+   */\n+  Boolean getBoolean(String columnName);\n+\n+  /**\n+   * Get the value for a particular column of the Row as a decimal.\n+   *\n+   * @param columnIndex index of column (1-indexed).\n+   * @return column value.\n+   */\n+  BigDecimal getDecimal(int columnIndex);\n+\n+  /**\n+   * Get the value for a particular column of the Row as a decimal.\n+   *\n+   * @param columnName name of column.\n+   * @return column value.\n+   */\n+  BigDecimal getDecimal(String columnName);\n+}\n+```\n+\n+We considered representing column types in a more structured form (rather than plain strings) to accomodate complex/nested data types but felt this added complexity would not be helpful for most use cases. (This would also require a server-side change, so it's a fair bit of additional work.)\n+\n+For `getDecimal(...)` in the `Row` interface, rather than trying to parse the column type to extract the precision and scale, we will simply convert the value to a BigDecimal without explicitly specifying the precision and scale. We could also add an option for users to specify the scale and precision in the getter, if we think that would be useful.\n+\n+We could also add `getList(...)` and `getMap(...)` methods to the `Row` interface, but it's not clear to me how valuable this would be given that the nested data types would not be known.\n+\n+Tim also proposed switching from generic Java types (`Map<String, Object>`, `List<Object>`) to Vert.x types (`JsonObject`, `JsonArray`) as the latter is more type-safe and the client already has a dependency on Vert.x anyway. The downside, though, is that then apps that use the client would be required to depend on Vert.x as well.\n+\n+### Transient queries -- Non-streaming\n+\n+The `Client` interface will also provide the following methods for receiving the results of a transient query (push or pull) in a single batch (non-streaming),\n+once the query has completed:\n+```\n+  /**\n+   * Execute a query (push or pull) and receive all result rows together, once the query has\n+   * completed.\n+   *\n+   * @param sql statement of query to execute.\n+   * @return query result.\n+   */\n+  CompletableFuture<List<Row>> executeQuery(String sql);\n+\n+  /**\n+   * Execute a query (push or pull) and receive all result rows together, once the query has\n+   * completed.\n+   *\n+   * @param sql statement of query to execute.\n+   * @param properties query properties.\n+   * @return query result.\n+   */\n+  CompletableFuture<List<Row>> executeQuery(String sql, Map<String, Object> properties);\n+```\n+\n+For a query to \"complete\" could mean:\n+* The query is a pull query\n+* The query is a push query with a limit clause, and the limit has been reached\n+* The query is a push query that has been terminated\n+\n+We may want to introduce a limit to the number of rows that may be returned from these `executeQuery()` methods,\n+in order to decrease the likelihood of running out of memory.\n+\n+### Insert values\n+\n+A method to insert one row at a time:\n+```\n+  /**\n+   * Insert a single row into the relevant stream/table.\n+   *\n+   * @param streamName name of stream/table.\n+   * @param row the row to insert.\n+   * @return a future that completes once the request has been processed.\n+   */\n+  CompletableFuture<Void> insertInto(String streamName, Map<String, Object> row);\n+```\n+\n+A method to stream inserts (via the `/inserts-stream` endpoint):\n+```\n+  CompletableFuture<Publisher<InsertResponse>> streamInserts(String streamName, Publisher<List<Object>> insertsPublisher);\n+}\n+```\n+where `InsertResponse` is as follows:\n+```\n+public interface InsertResponse {\n+\n+  /**\n+   * Whether the row was successfully inserted or not.\n+   */\n+  boolean isSuccessful();\n+\n+  /**\n+   * Unique sequence number for the row in the stream of inserts.\n+   */\n+  int getSequenceNum();\n+\n+  /**\n+   * If unsuccessful, the error message.\n+   */\n+  String getErrorMessage();\n+\n+  /**\n+   * If unsuccessful, the error code.\n+   */\n+  int getErrorCode();\n+\n+}\n+```\n+\n+### DDL/DML operations\n+\n+#### `CREATE <STREAM/TABLE>`, `CREATE <STREAM/TABLE> ... AS SELECT`, `INSERT INTO`\n+\n+`Client` methods:\n+```\n+  /**\n+   * Execute DDL statement: `CREATE STREAM`, `CREATE TABLE`\n+   */\n+  CompletableFuture<DdlResponse> executeDdl(String sql);\n+\n+  /**\n+   * Execute DML statement: `CREATE STREAM ... AS SELECT`, `CREATE TABLE ... AS SELECT`, `INSERT INTO`\n+   */\n+  CompletableFuture<DmlResponse> executeDml(String sql);\n+\n+  /**\n+   * Execute DML statement: `CREATE STREAM ... AS SELECT`, `CREATE TABLE ... AS SELECT`, `INSERT INTO`\n+   */\n+  CompletableFuture<DmlResponse> executeDml(String sql, Map<String, Object> properties);\n+\n+```\n+with\n+```\n+public interface DdlResponse {\n+\n+  enum Status { QUEUED, PARSING, EXECUTING, RUNNING, TERMINATED, SUCCESS, ERROR }\n+  \n+  Status getStatus();\n+  \n+  String getStatusMessage();\n+  \n+  long getCommandSequenceNumber();\n+\n+  String getCommandId();\n+}\n+```\n+and `DmlResponse` is identical.\n+\n+I don't love this proposal since `DDL` and `DML` aren't used throughout our docs but I'm not a huge fan of the alternatives I considered either, such as\n+```\n+  CompletableFuture<CreateSourceResponse> createStream(String sql);\n+\n+  CompletableFuture<CreateSourceResponse> createStream(String sql, Map<String, Object> properties);\n+\n+  CompletableFuture<CreateSourceResponse> createTable(String sql);\n+\n+  CompletableFuture<CreateSourceResponse> createTable(String sql, Map<String, Object> properties);\n+\n+  CompletableFuture<InsertIntoResponse> insertIntoSource(String sql);\n+\n+  CompletableFuture<InsertIntoResponse> insertIntoSource(String sql, Map<String, Object> properties);\n+```\n+\n+In this version, the implementations of `createStream(...)` and `createTable(...)` would be identical and could be replaced with a single `createSource(...)`\n+but the name of this method feels confusing. As with the previous proposal, `CreateSourceResponse` and `InsertIntoResponse` are identical.\n+\n+Other alternatives include separating `CREATE <STREAM/TABLE>` and `CREATE <STREAM/TABLE> ... AS SELECT` into separate methods, but that feels unnecessarily complex.\n+\n+#### `DROP <STREAM/TABLE>`\n+\n+`Client` methods:\n+```\n+  /**\n+   * Drop stream. The underlying Kafka topic will not be deleted.\n+   */\n+  CompletableFuture<DropSourceResponse> dropStream(String streamName);\n+\n+  /**\n+   * Drop stream. The underlying Kafka topic may optionally be deleted.\n+   */\n+  CompletableFuture<DropSourceResponse> dropStream(String streamName, boolean deleteTopic);\n+\n+  /**\n+   * Drop table. The underlying Kafka topic will not be deleted.\n+   */\n+  CompletableFuture<DropSourceResponse> dropTable(String tableName);\n+\n+  /**\n+   * Drop table. The underlying Kafka topic may optionally be deleted.\n+   */\n+  CompletableFuture<DropSourceResponse> dropTable(String tableName, boolean deleteTopic);\n+```\n+where `DropSourceResponse` is actually the same as `DdlResponse`/`DmlResponse`/`CreateSourceResponse`/`InsertIntoResponse` above.\n+\n+Again, the implementations of `dropStream(...)` and `dropTable(...)` would be the same so we could instead have a single `dropSource(...)`, but the naming might be confusing.\n+\n+If we choose to keep them separate, there's an open question of whether the client should validate that `dropStream(...)` is not used to drop a table, and vice versa.\n+IMO such validation would be introducing complexity without much benefit, though this point of ambiguity makes me prefer a single `dropSource(...)` if we can agree on a method name that's not confusing.\n+\n+Note that users can also execute `DROP <STREAM/TABLE>` requests via `executeDdl(...)` or `executDml(...)` above.\n+\n+#### `TERMINATE <queryId>`\n+\n+```\n+  CompletableFuture<TerminateQueryResponse> terminatePersistentQuery(String queryId);\n+```\n+where `TerminateQueryResponse` is again the same as `DdlResponse`/`DmlResponse`/`CreateSourceResponse`/`InsertIntoResponse`/`DropSourceResponse` above.\n+\n+The method name `terminatePersistenQuery(...)` is to distinguish from `terminatePushQuery(...)` below.\n+\n+#### Connectors\n+\n+```\n+  CompletableFuture<ConnectorInfo> createSourceConnector(String name, Map<String, String> properties);\n+\n+  CompletableFuture<ConnectorInfo> createSinkConnector(String name, Map<String, String> properties);\n+\n+  CompletableFuture<Void> dropConnector(String name);\n+```\n+where `ConnectorInfo` is from an Apache Kafka module ([link](https://github.com/apache/kafka/blob/trunk/connect/runtime/src/main/java/org/apache/kafka/connect/runtime/rest/entities/ConnectorInfo.java)).\n+\n+Or would we rather not have a dependency on Apache Kafka in the ksqlDB client interfaces?\n+\n+### Admin operations\n+\n+#### `SHOW TOPICS`\n+\n+```\n+  CompletableFuture<List<TopicInfo>> listTopics();\n+```\n+with\n+```\n+public interface TopicInfo {\n+\n+  String getName();\n+\n+  int getPartitions();\n+  \n+  List<Integer> getReplicasPerPartition();\n+\n+}\n+```\n+\n+#### `SHOW <STREAMS/TABLES>`\n+\n+```\n+  CompletableFuture<List<StreamInfo>> listStreams();\n+\n+  CompletableFuture<List<TableInfo>> listTables();\n+```\n+with\n+```\n+public interface StreamInfo {\n+\n+  String getName();\n+\n+  String getTopic();\n+\n+  String getFormat();\n+  \n+}\n+```\n+and\n+```\n+public interface TableInfo {\n+\n+  String getName();\n+\n+  String getTopic();\n+\n+  String getFormat();\n+\n+  boolean isWindowed();\n+  \n+}\n+```\n+\n+I'm not sure whether it makes more sense for `StreamInfo#getFormat()` and `TableInfo#getFormat()` to return a string or an enum value.\n+The latter would make it easier for the user to know the possible values, but we'd have to keep the list up to date and would also sacrifice forward compatibility.\n+\n+#### `SHOW QUERIES`\n+\n+```\n+  CompletableFuture<List<QueryInfo>> listQueries();\n+```\n+with\n+```\n+public interface QueryInfo {\n+\n+  boolean isPersistentQuery();\n+\n+  boolean isPushQuery();\n+\n+  /**\n+   * Query ID, used for control operations such as terminating the query\n+   */\n+  String getId();\n+\n+  String getSql();\n+\n+  /**\n+   * Name of sink, for a persistent query. Else, null.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aed38d5836550829f7fd459df31b47aaf7e5ad45"}, "originalPosition": 608}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODEzODU4NA==", "bodyText": "not sure I see how this can be used programatically from a client... can we punt on introducing this method at all?", "url": "https://github.com/confluentinc/ksql/pull/5236#discussion_r418138584", "createdAt": "2020-04-30T16:31:22Z", "author": {"login": "agavra"}, "path": "design-proposals/klip-26-java-client-interfaces.md", "diffHunk": "@@ -0,0 +1,715 @@\n+# KLIP 26 - Java client interfaces\n+\n+**Author**: Victoria Xia (@vcrfxia) | \n+**Release Target**: ksqlDB 0.10.0 | \n+**Status**: _In development_ | \n+**Discussion**: TBD\n+\n+**tl;dr:** _[KLIP 15](./klip-15-new-api-and-client.md) already made the case for why it makes sense\n+           to introduce a Java client for ksqlDB. This KLIP proposes interfaces for the client._\n+\n+## Motivation and background\n+\n+See [KLIP 15](./klip-15-new-api-and-client.md).\n+\n+## What is in scope\n+\n+The Java client will support the following operations:\n+* Push query\n+* Pull query\n+* Select DDL/DML operations:\n+    * `CREATE STREAM`\n+    * `CREATE TABLE`\n+    * `CREATE STREAM ... AS SELECT`\n+    * `CREATE TABLE ... AS SELECT`\n+    * `DROP STREAM`\n+    * `DROP TABLE`\n+    * `INSERT INTO`\n+    * `TERMINATE <queryId>`\n+    * `CREATE CONNECTOR`\n+    * `DROP CONNECTOR`\n+* Select admin operations:\n+    * `SHOW TOPICS` (non-extended)\n+    * `SHOW STREAMS` (non-extended)\n+    * `SHOW TABLES` (non-extended)\n+    * `SHOW QUERIES` (non-extended)\n+    * `SHOW CONNECTORS`\n+* Insert values, i.e., insert rows into an existing stream/table\n+* Terminate push query (via the `/close-query` endpoint)\n+\n+The purpose of this KLIP is to reach agreement on the interfaces / public APIs.\n+Implementation details will not be covered.\n+\n+## What is not in scope\n+\n+This KLIP does not cover Java client support for the following:\n+* `DESCRIBE <stream/table>`, `DESCRIBE CONNECTOR`, `DESCRIBE FUNCTION`\n+* `EXPLAIN <queryId>`\n+* `PRINT <topic>`\n+* `SHOW TOPICS EXTENDED`, `SHOW <STREAMS/TABLES> EXTENDED`, `SHOW QUERIES EXTENDED`\n+* `CREATE TYPE`, `DROP TYPE`, `SHOW TYPES`\n+* `SHOW FUNCTIONS`, `SHOW PROPERTIES`\n+* `RUN SCRIPT`\n+* Use of other endpoints (info, healthcheck, terminate cluster, status, etc.)\n+\n+We can always add support for these operations in the future if desired.\n+\n+As above, implementation details are out of scope as the purpose of this KLIP is to reach agreement\n+on the interfaces / public APIs.\n+\n+## Value/Return\n+\n+See [KLIP 15](./klip-15-new-api-and-client.md).\n+\n+## Public APIS\n+\n+The following subsections describe the methods of the `Client` interface:\n+```\n+public interface Client {\n+    ...\n+}\n+```\n+\n+### Constructors\n+```\n+  static Client create(ClientOptions clientOptions) {\n+    return new ClientImpl(clientOptions);\n+  }\n+\n+  static Client create(ClientOptions clientOptions, Vertx vertx) {\n+    return new ClientImpl(clientOptions, vertx);\n+  }\n+```\n+\n+The Java client will be implemented as a Vert.x HttpClient. We expose a constructor that allows users to provide their own `Vertx` instance\n+in order to take advantage of a shared connection pool and other properties if desired.\n+\n+`ClientOptions` will initially be as follows:\n+```\n+public interface ClientOptions {\n+\n+  ClientOptions setHost(String host);\n+\n+  ClientOptions setPort(int port);\n+\n+  ClientOptions setUseTls(boolean useTls);\n+\n+  ClientOptions setUseClientAuth(boolean useClientAuth);\n+\n+  ClientOptions setTrustStore(String trustStorePath);\n+\n+  ClientOptions setTrustStorePassword(String trustStorePassword);\n+\n+  ClientOptions setKeyStore(String keyStorePath);\n+\n+  ClientOptions setKeyStorePassword(String keyStorePassword);\n+\n+  ClientOptions setBasicAuthCredentials(String username, String password);\n+\n+  String getHost();\n+\n+  int getPort();\n+\n+  boolean isUseTls();\n+\n+  boolean isUseClientAuth();\n+\n+  boolean isUseBasicAuth();\n+\n+  String getTrustStore();\n+\n+  String getTrustStorePassword();\n+\n+  String getKeyStore();\n+\n+  String getKeyStorePassword();\n+\n+  String getBasicAuthUsername();\n+\n+  String getBasicAuthPassword();\n+\n+  ClientOptions copy();\n+\n+  static ClientOptions create() {\n+    return new ClientOptionsImpl();\n+  }\n+}\n+```\n+\n+We can always add additional configuration options later. We may also wish to expose the Vert.x `HttpClientOptions` for\n+advanced users that wish to provide custom configs.\n+\n+### Transient queries -- Streaming\n+\n+The `Client` interface will provide the following methods for streaming the results of a transient (push or pull) query:\n+```\n+  /**\n+   * Execute a query (push or pull) and receive the results one row at a time.\n+   *\n+   * @param sql statement of query to execute.\n+   * @return query result.\n+   */\n+  CompletableFuture<QueryResult> streamQuery(String sql);\n+\n+  /**\n+   * Execute a query (push or pull) and receive the results one row at a time.\n+   *\n+   * @param sql statement of query to execute.\n+   * @param properties query properties.\n+   * @return query result.\n+   */\n+  CompletableFuture<QueryResult> streamQuery(String sql, Map<String, Object> properties);\n+```\n+where `QueryResult` is as follows:\n+```\n+/**\n+ * The result of a query (push or pull), streamed one row at time. Records may be consumed by either\n+ * subscribing to the publisher or polling (blocking) for one record at a time. These two methods of\n+ * consumption are mutually exclusive; only one method may be used (per QueryResult).\n+ */\n+public interface QueryResult extends Publisher<Row> {\n+\n+  List<String> columnNames();\n+\n+  List<String> columnTypes();\n+\n+  String queryID();\n+\n+  /**\n+   * Block until a row becomes available.\n+   *\n+   * @return the row.\n+   */\n+  Row poll();\n+\n+  /**\n+   * Block until a row becomes available or the timeout has elapsed.\n+   *\n+   * @param timeout amount of to wait for a row. Non-positive values are interpreted as no timeout.\n+   * @param timeUnit unit for timeout param.\n+   * @return the row, if available; else, null.\n+   */\n+  Row poll(long timeout, TimeUnit timeUnit);\n+\n+  boolean isComplete();\n+\n+  void close();\n+}\n+```\n+Note that `QueryResult` is a Reactive Streams `Publisher` so users can stream results. Users can also call `poll()` to receive\n+results in a synchronous fashion instead. Only one of the two methods will be allowed per `QueryResult` instance.\n+\n+The `Row` interface is as follows:\n+```\n+/**\n+ * A single record, returned as part of a query result.\n+ */\n+public interface Row {\n+\n+  List<String> columnNames();\n+\n+  List<String> columnTypes();\n+\n+  List<Object> values();\n+\n+  /**\n+   * Get the value for a particular column of the Row as an Object.\n+   *\n+   * @param columnIndex index of column (1-indexed).\n+   * @return column value.\n+   */\n+  Object getObject(int columnIndex);\n+\n+  /**\n+   * Get the value for a particular column of the Row as an Object.\n+   *\n+   * @param columnName name of column.\n+   * @return column value.\n+   */\n+  Object getObject(String columnName);\n+\n+  /**\n+   * Get the value for a particular column of the Row as a string.\n+   *\n+   * @param columnIndex index of column (1-indexed).\n+   * @return column value.\n+   */\n+  String getString(int columnIndex);\n+\n+  /**\n+   * Get the value for a particular column of the Row as a string.\n+   *\n+   * @param columnName name of column.\n+   * @return column value.\n+   */\n+  String getString(String columnName);\n+\n+  /**\n+   * Get the value for a particular column of the Row as an integer.\n+   *\n+   * @param columnIndex index of column (1-indexed).\n+   * @return column value.\n+   */\n+  Integer getInt(int columnIndex);\n+\n+  /**\n+   * Get the value for a particular column of the Row as an integer.\n+   *\n+   * @param columnName name of column.\n+   * @return column value.\n+   */\n+  Integer getInt(String columnName);\n+\n+  /**\n+   * Get the value for a particular column of the Row as a long.\n+   *\n+   * @param columnIndex index of column (1-indexed).\n+   * @return column value.\n+   */\n+  Long getLong(int columnIndex);\n+\n+  /**\n+   * Get the value for a particular column of the Row as a long.\n+   *\n+   * @param columnName name of column.\n+   * @return column value.\n+   */\n+  Long getLong(String columnName);\n+\n+  /**\n+   * Get the value for a particular column of the Row as a double.\n+   *\n+   * @param columnIndex index of column (1-indexed).\n+   * @return column value.\n+   */\n+  Double getDouble(int columnIndex);\n+\n+  /**\n+   * Get the value for a particular column of the Row as a double.\n+   *\n+   * @param columnName name of column.\n+   * @return column value.\n+   */\n+  Double getDouble(String columnName);\n+\n+  /**\n+   * Get the value for a particular column of the Row as a boolean.\n+   *\n+   * @param columnIndex index of column (1-indexed).\n+   * @return column value.\n+   */\n+  Boolean getBoolean(int columnIndex);\n+\n+  /**\n+   * Get the value for a particular column of the Row as a boolean.\n+   *\n+   * @param columnName name of column.\n+   * @return column value.\n+   */\n+  Boolean getBoolean(String columnName);\n+\n+  /**\n+   * Get the value for a particular column of the Row as a decimal.\n+   *\n+   * @param columnIndex index of column (1-indexed).\n+   * @return column value.\n+   */\n+  BigDecimal getDecimal(int columnIndex);\n+\n+  /**\n+   * Get the value for a particular column of the Row as a decimal.\n+   *\n+   * @param columnName name of column.\n+   * @return column value.\n+   */\n+  BigDecimal getDecimal(String columnName);\n+}\n+```\n+\n+We considered representing column types in a more structured form (rather than plain strings) to accomodate complex/nested data types but felt this added complexity would not be helpful for most use cases. (This would also require a server-side change, so it's a fair bit of additional work.)\n+\n+For `getDecimal(...)` in the `Row` interface, rather than trying to parse the column type to extract the precision and scale, we will simply convert the value to a BigDecimal without explicitly specifying the precision and scale. We could also add an option for users to specify the scale and precision in the getter, if we think that would be useful.\n+\n+We could also add `getList(...)` and `getMap(...)` methods to the `Row` interface, but it's not clear to me how valuable this would be given that the nested data types would not be known.\n+\n+Tim also proposed switching from generic Java types (`Map<String, Object>`, `List<Object>`) to Vert.x types (`JsonObject`, `JsonArray`) as the latter is more type-safe and the client already has a dependency on Vert.x anyway. The downside, though, is that then apps that use the client would be required to depend on Vert.x as well.\n+\n+### Transient queries -- Non-streaming\n+\n+The `Client` interface will also provide the following methods for receiving the results of a transient query (push or pull) in a single batch (non-streaming),\n+once the query has completed:\n+```\n+  /**\n+   * Execute a query (push or pull) and receive all result rows together, once the query has\n+   * completed.\n+   *\n+   * @param sql statement of query to execute.\n+   * @return query result.\n+   */\n+  CompletableFuture<List<Row>> executeQuery(String sql);\n+\n+  /**\n+   * Execute a query (push or pull) and receive all result rows together, once the query has\n+   * completed.\n+   *\n+   * @param sql statement of query to execute.\n+   * @param properties query properties.\n+   * @return query result.\n+   */\n+  CompletableFuture<List<Row>> executeQuery(String sql, Map<String, Object> properties);\n+```\n+\n+For a query to \"complete\" could mean:\n+* The query is a pull query\n+* The query is a push query with a limit clause, and the limit has been reached\n+* The query is a push query that has been terminated\n+\n+We may want to introduce a limit to the number of rows that may be returned from these `executeQuery()` methods,\n+in order to decrease the likelihood of running out of memory.\n+\n+### Insert values\n+\n+A method to insert one row at a time:\n+```\n+  /**\n+   * Insert a single row into the relevant stream/table.\n+   *\n+   * @param streamName name of stream/table.\n+   * @param row the row to insert.\n+   * @return a future that completes once the request has been processed.\n+   */\n+  CompletableFuture<Void> insertInto(String streamName, Map<String, Object> row);\n+```\n+\n+A method to stream inserts (via the `/inserts-stream` endpoint):\n+```\n+  CompletableFuture<Publisher<InsertResponse>> streamInserts(String streamName, Publisher<List<Object>> insertsPublisher);\n+}\n+```\n+where `InsertResponse` is as follows:\n+```\n+public interface InsertResponse {\n+\n+  /**\n+   * Whether the row was successfully inserted or not.\n+   */\n+  boolean isSuccessful();\n+\n+  /**\n+   * Unique sequence number for the row in the stream of inserts.\n+   */\n+  int getSequenceNum();\n+\n+  /**\n+   * If unsuccessful, the error message.\n+   */\n+  String getErrorMessage();\n+\n+  /**\n+   * If unsuccessful, the error code.\n+   */\n+  int getErrorCode();\n+\n+}\n+```\n+\n+### DDL/DML operations\n+\n+#### `CREATE <STREAM/TABLE>`, `CREATE <STREAM/TABLE> ... AS SELECT`, `INSERT INTO`\n+\n+`Client` methods:\n+```\n+  /**\n+   * Execute DDL statement: `CREATE STREAM`, `CREATE TABLE`\n+   */\n+  CompletableFuture<DdlResponse> executeDdl(String sql);\n+\n+  /**\n+   * Execute DML statement: `CREATE STREAM ... AS SELECT`, `CREATE TABLE ... AS SELECT`, `INSERT INTO`\n+   */\n+  CompletableFuture<DmlResponse> executeDml(String sql);\n+\n+  /**\n+   * Execute DML statement: `CREATE STREAM ... AS SELECT`, `CREATE TABLE ... AS SELECT`, `INSERT INTO`\n+   */\n+  CompletableFuture<DmlResponse> executeDml(String sql, Map<String, Object> properties);\n+\n+```\n+with\n+```\n+public interface DdlResponse {\n+\n+  enum Status { QUEUED, PARSING, EXECUTING, RUNNING, TERMINATED, SUCCESS, ERROR }\n+  \n+  Status getStatus();\n+  \n+  String getStatusMessage();\n+  \n+  long getCommandSequenceNumber();\n+\n+  String getCommandId();\n+}\n+```\n+and `DmlResponse` is identical.\n+\n+I don't love this proposal since `DDL` and `DML` aren't used throughout our docs but I'm not a huge fan of the alternatives I considered either, such as\n+```\n+  CompletableFuture<CreateSourceResponse> createStream(String sql);\n+\n+  CompletableFuture<CreateSourceResponse> createStream(String sql, Map<String, Object> properties);\n+\n+  CompletableFuture<CreateSourceResponse> createTable(String sql);\n+\n+  CompletableFuture<CreateSourceResponse> createTable(String sql, Map<String, Object> properties);\n+\n+  CompletableFuture<InsertIntoResponse> insertIntoSource(String sql);\n+\n+  CompletableFuture<InsertIntoResponse> insertIntoSource(String sql, Map<String, Object> properties);\n+```\n+\n+In this version, the implementations of `createStream(...)` and `createTable(...)` would be identical and could be replaced with a single `createSource(...)`\n+but the name of this method feels confusing. As with the previous proposal, `CreateSourceResponse` and `InsertIntoResponse` are identical.\n+\n+Other alternatives include separating `CREATE <STREAM/TABLE>` and `CREATE <STREAM/TABLE> ... AS SELECT` into separate methods, but that feels unnecessarily complex.\n+\n+#### `DROP <STREAM/TABLE>`\n+\n+`Client` methods:\n+```\n+  /**\n+   * Drop stream. The underlying Kafka topic will not be deleted.\n+   */\n+  CompletableFuture<DropSourceResponse> dropStream(String streamName);\n+\n+  /**\n+   * Drop stream. The underlying Kafka topic may optionally be deleted.\n+   */\n+  CompletableFuture<DropSourceResponse> dropStream(String streamName, boolean deleteTopic);\n+\n+  /**\n+   * Drop table. The underlying Kafka topic will not be deleted.\n+   */\n+  CompletableFuture<DropSourceResponse> dropTable(String tableName);\n+\n+  /**\n+   * Drop table. The underlying Kafka topic may optionally be deleted.\n+   */\n+  CompletableFuture<DropSourceResponse> dropTable(String tableName, boolean deleteTopic);\n+```\n+where `DropSourceResponse` is actually the same as `DdlResponse`/`DmlResponse`/`CreateSourceResponse`/`InsertIntoResponse` above.\n+\n+Again, the implementations of `dropStream(...)` and `dropTable(...)` would be the same so we could instead have a single `dropSource(...)`, but the naming might be confusing.\n+\n+If we choose to keep them separate, there's an open question of whether the client should validate that `dropStream(...)` is not used to drop a table, and vice versa.\n+IMO such validation would be introducing complexity without much benefit, though this point of ambiguity makes me prefer a single `dropSource(...)` if we can agree on a method name that's not confusing.\n+\n+Note that users can also execute `DROP <STREAM/TABLE>` requests via `executeDdl(...)` or `executDml(...)` above.\n+\n+#### `TERMINATE <queryId>`\n+\n+```\n+  CompletableFuture<TerminateQueryResponse> terminatePersistentQuery(String queryId);\n+```\n+where `TerminateQueryResponse` is again the same as `DdlResponse`/`DmlResponse`/`CreateSourceResponse`/`InsertIntoResponse`/`DropSourceResponse` above.\n+\n+The method name `terminatePersistenQuery(...)` is to distinguish from `terminatePushQuery(...)` below.\n+\n+#### Connectors\n+\n+```\n+  CompletableFuture<ConnectorInfo> createSourceConnector(String name, Map<String, String> properties);\n+\n+  CompletableFuture<ConnectorInfo> createSinkConnector(String name, Map<String, String> properties);\n+\n+  CompletableFuture<Void> dropConnector(String name);\n+```\n+where `ConnectorInfo` is from an Apache Kafka module ([link](https://github.com/apache/kafka/blob/trunk/connect/runtime/src/main/java/org/apache/kafka/connect/runtime/rest/entities/ConnectorInfo.java)).\n+\n+Or would we rather not have a dependency on Apache Kafka in the ksqlDB client interfaces?\n+\n+### Admin operations\n+\n+#### `SHOW TOPICS`\n+\n+```\n+  CompletableFuture<List<TopicInfo>> listTopics();\n+```\n+with\n+```\n+public interface TopicInfo {\n+\n+  String getName();\n+\n+  int getPartitions();\n+  \n+  List<Integer> getReplicasPerPartition();\n+\n+}\n+```\n+\n+#### `SHOW <STREAMS/TABLES>`\n+\n+```\n+  CompletableFuture<List<StreamInfo>> listStreams();\n+\n+  CompletableFuture<List<TableInfo>> listTables();\n+```\n+with\n+```\n+public interface StreamInfo {\n+\n+  String getName();\n+\n+  String getTopic();\n+\n+  String getFormat();\n+  \n+}\n+```\n+and\n+```\n+public interface TableInfo {\n+\n+  String getName();\n+\n+  String getTopic();\n+\n+  String getFormat();\n+\n+  boolean isWindowed();\n+  \n+}\n+```\n+\n+I'm not sure whether it makes more sense for `StreamInfo#getFormat()` and `TableInfo#getFormat()` to return a string or an enum value.\n+The latter would make it easier for the user to know the possible values, but we'd have to keep the list up to date and would also sacrifice forward compatibility.\n+\n+#### `SHOW QUERIES`\n+\n+```\n+  CompletableFuture<List<QueryInfo>> listQueries();\n+```\n+with\n+```\n+public interface QueryInfo {\n+\n+  boolean isPersistentQuery();\n+\n+  boolean isPushQuery();\n+\n+  /**\n+   * Query ID, used for control operations such as terminating the query\n+   */\n+  String getId();\n+\n+  String getSql();\n+\n+  /**\n+   * Name of sink, for a persistent query. Else, null.\n+   */\n+  String getSink();\n+\n+  /**\n+   * Name of sink topic, for a persistent query. Else, null.\n+   */\n+  String getSinkTopic();\n+  \n+  /**\n+   * Map of query state (\"RUNNING\", \"ERROR\", or \"UNRESPONSIVE\") to the number of ksqlDB servers\n+   * on which this query is in each state.\n+   */\n+  Map<String, Integer> getServerStatusCounts();\n+\n+}\n+```\n+\n+Again, not sure whether it makes more sense to represent query states as strings, or to introduce an Enum and have `getServerStatusCounts()` return an EnumMap instead.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aed38d5836550829f7fd459df31b47aaf7e5ad45"}, "originalPosition": 626}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODEzOTAzOQ==", "bodyText": "again, let's punt on connect support - I think we should let connect build a java client if that's what we want to do. Seems weird to have a client that talks to ksql, which just delegates to a connect cluster", "url": "https://github.com/confluentinc/ksql/pull/5236#discussion_r418139039", "createdAt": "2020-04-30T16:32:03Z", "author": {"login": "agavra"}, "path": "design-proposals/klip-26-java-client-interfaces.md", "diffHunk": "@@ -0,0 +1,715 @@\n+# KLIP 26 - Java client interfaces\n+\n+**Author**: Victoria Xia (@vcrfxia) | \n+**Release Target**: ksqlDB 0.10.0 | \n+**Status**: _In development_ | \n+**Discussion**: TBD\n+\n+**tl;dr:** _[KLIP 15](./klip-15-new-api-and-client.md) already made the case for why it makes sense\n+           to introduce a Java client for ksqlDB. This KLIP proposes interfaces for the client._\n+\n+## Motivation and background\n+\n+See [KLIP 15](./klip-15-new-api-and-client.md).\n+\n+## What is in scope\n+\n+The Java client will support the following operations:\n+* Push query\n+* Pull query\n+* Select DDL/DML operations:\n+    * `CREATE STREAM`\n+    * `CREATE TABLE`\n+    * `CREATE STREAM ... AS SELECT`\n+    * `CREATE TABLE ... AS SELECT`\n+    * `DROP STREAM`\n+    * `DROP TABLE`\n+    * `INSERT INTO`\n+    * `TERMINATE <queryId>`\n+    * `CREATE CONNECTOR`\n+    * `DROP CONNECTOR`\n+* Select admin operations:\n+    * `SHOW TOPICS` (non-extended)\n+    * `SHOW STREAMS` (non-extended)\n+    * `SHOW TABLES` (non-extended)\n+    * `SHOW QUERIES` (non-extended)\n+    * `SHOW CONNECTORS`\n+* Insert values, i.e., insert rows into an existing stream/table\n+* Terminate push query (via the `/close-query` endpoint)\n+\n+The purpose of this KLIP is to reach agreement on the interfaces / public APIs.\n+Implementation details will not be covered.\n+\n+## What is not in scope\n+\n+This KLIP does not cover Java client support for the following:\n+* `DESCRIBE <stream/table>`, `DESCRIBE CONNECTOR`, `DESCRIBE FUNCTION`\n+* `EXPLAIN <queryId>`\n+* `PRINT <topic>`\n+* `SHOW TOPICS EXTENDED`, `SHOW <STREAMS/TABLES> EXTENDED`, `SHOW QUERIES EXTENDED`\n+* `CREATE TYPE`, `DROP TYPE`, `SHOW TYPES`\n+* `SHOW FUNCTIONS`, `SHOW PROPERTIES`\n+* `RUN SCRIPT`\n+* Use of other endpoints (info, healthcheck, terminate cluster, status, etc.)\n+\n+We can always add support for these operations in the future if desired.\n+\n+As above, implementation details are out of scope as the purpose of this KLIP is to reach agreement\n+on the interfaces / public APIs.\n+\n+## Value/Return\n+\n+See [KLIP 15](./klip-15-new-api-and-client.md).\n+\n+## Public APIS\n+\n+The following subsections describe the methods of the `Client` interface:\n+```\n+public interface Client {\n+    ...\n+}\n+```\n+\n+### Constructors\n+```\n+  static Client create(ClientOptions clientOptions) {\n+    return new ClientImpl(clientOptions);\n+  }\n+\n+  static Client create(ClientOptions clientOptions, Vertx vertx) {\n+    return new ClientImpl(clientOptions, vertx);\n+  }\n+```\n+\n+The Java client will be implemented as a Vert.x HttpClient. We expose a constructor that allows users to provide their own `Vertx` instance\n+in order to take advantage of a shared connection pool and other properties if desired.\n+\n+`ClientOptions` will initially be as follows:\n+```\n+public interface ClientOptions {\n+\n+  ClientOptions setHost(String host);\n+\n+  ClientOptions setPort(int port);\n+\n+  ClientOptions setUseTls(boolean useTls);\n+\n+  ClientOptions setUseClientAuth(boolean useClientAuth);\n+\n+  ClientOptions setTrustStore(String trustStorePath);\n+\n+  ClientOptions setTrustStorePassword(String trustStorePassword);\n+\n+  ClientOptions setKeyStore(String keyStorePath);\n+\n+  ClientOptions setKeyStorePassword(String keyStorePassword);\n+\n+  ClientOptions setBasicAuthCredentials(String username, String password);\n+\n+  String getHost();\n+\n+  int getPort();\n+\n+  boolean isUseTls();\n+\n+  boolean isUseClientAuth();\n+\n+  boolean isUseBasicAuth();\n+\n+  String getTrustStore();\n+\n+  String getTrustStorePassword();\n+\n+  String getKeyStore();\n+\n+  String getKeyStorePassword();\n+\n+  String getBasicAuthUsername();\n+\n+  String getBasicAuthPassword();\n+\n+  ClientOptions copy();\n+\n+  static ClientOptions create() {\n+    return new ClientOptionsImpl();\n+  }\n+}\n+```\n+\n+We can always add additional configuration options later. We may also wish to expose the Vert.x `HttpClientOptions` for\n+advanced users that wish to provide custom configs.\n+\n+### Transient queries -- Streaming\n+\n+The `Client` interface will provide the following methods for streaming the results of a transient (push or pull) query:\n+```\n+  /**\n+   * Execute a query (push or pull) and receive the results one row at a time.\n+   *\n+   * @param sql statement of query to execute.\n+   * @return query result.\n+   */\n+  CompletableFuture<QueryResult> streamQuery(String sql);\n+\n+  /**\n+   * Execute a query (push or pull) and receive the results one row at a time.\n+   *\n+   * @param sql statement of query to execute.\n+   * @param properties query properties.\n+   * @return query result.\n+   */\n+  CompletableFuture<QueryResult> streamQuery(String sql, Map<String, Object> properties);\n+```\n+where `QueryResult` is as follows:\n+```\n+/**\n+ * The result of a query (push or pull), streamed one row at time. Records may be consumed by either\n+ * subscribing to the publisher or polling (blocking) for one record at a time. These two methods of\n+ * consumption are mutually exclusive; only one method may be used (per QueryResult).\n+ */\n+public interface QueryResult extends Publisher<Row> {\n+\n+  List<String> columnNames();\n+\n+  List<String> columnTypes();\n+\n+  String queryID();\n+\n+  /**\n+   * Block until a row becomes available.\n+   *\n+   * @return the row.\n+   */\n+  Row poll();\n+\n+  /**\n+   * Block until a row becomes available or the timeout has elapsed.\n+   *\n+   * @param timeout amount of to wait for a row. Non-positive values are interpreted as no timeout.\n+   * @param timeUnit unit for timeout param.\n+   * @return the row, if available; else, null.\n+   */\n+  Row poll(long timeout, TimeUnit timeUnit);\n+\n+  boolean isComplete();\n+\n+  void close();\n+}\n+```\n+Note that `QueryResult` is a Reactive Streams `Publisher` so users can stream results. Users can also call `poll()` to receive\n+results in a synchronous fashion instead. Only one of the two methods will be allowed per `QueryResult` instance.\n+\n+The `Row` interface is as follows:\n+```\n+/**\n+ * A single record, returned as part of a query result.\n+ */\n+public interface Row {\n+\n+  List<String> columnNames();\n+\n+  List<String> columnTypes();\n+\n+  List<Object> values();\n+\n+  /**\n+   * Get the value for a particular column of the Row as an Object.\n+   *\n+   * @param columnIndex index of column (1-indexed).\n+   * @return column value.\n+   */\n+  Object getObject(int columnIndex);\n+\n+  /**\n+   * Get the value for a particular column of the Row as an Object.\n+   *\n+   * @param columnName name of column.\n+   * @return column value.\n+   */\n+  Object getObject(String columnName);\n+\n+  /**\n+   * Get the value for a particular column of the Row as a string.\n+   *\n+   * @param columnIndex index of column (1-indexed).\n+   * @return column value.\n+   */\n+  String getString(int columnIndex);\n+\n+  /**\n+   * Get the value for a particular column of the Row as a string.\n+   *\n+   * @param columnName name of column.\n+   * @return column value.\n+   */\n+  String getString(String columnName);\n+\n+  /**\n+   * Get the value for a particular column of the Row as an integer.\n+   *\n+   * @param columnIndex index of column (1-indexed).\n+   * @return column value.\n+   */\n+  Integer getInt(int columnIndex);\n+\n+  /**\n+   * Get the value for a particular column of the Row as an integer.\n+   *\n+   * @param columnName name of column.\n+   * @return column value.\n+   */\n+  Integer getInt(String columnName);\n+\n+  /**\n+   * Get the value for a particular column of the Row as a long.\n+   *\n+   * @param columnIndex index of column (1-indexed).\n+   * @return column value.\n+   */\n+  Long getLong(int columnIndex);\n+\n+  /**\n+   * Get the value for a particular column of the Row as a long.\n+   *\n+   * @param columnName name of column.\n+   * @return column value.\n+   */\n+  Long getLong(String columnName);\n+\n+  /**\n+   * Get the value for a particular column of the Row as a double.\n+   *\n+   * @param columnIndex index of column (1-indexed).\n+   * @return column value.\n+   */\n+  Double getDouble(int columnIndex);\n+\n+  /**\n+   * Get the value for a particular column of the Row as a double.\n+   *\n+   * @param columnName name of column.\n+   * @return column value.\n+   */\n+  Double getDouble(String columnName);\n+\n+  /**\n+   * Get the value for a particular column of the Row as a boolean.\n+   *\n+   * @param columnIndex index of column (1-indexed).\n+   * @return column value.\n+   */\n+  Boolean getBoolean(int columnIndex);\n+\n+  /**\n+   * Get the value for a particular column of the Row as a boolean.\n+   *\n+   * @param columnName name of column.\n+   * @return column value.\n+   */\n+  Boolean getBoolean(String columnName);\n+\n+  /**\n+   * Get the value for a particular column of the Row as a decimal.\n+   *\n+   * @param columnIndex index of column (1-indexed).\n+   * @return column value.\n+   */\n+  BigDecimal getDecimal(int columnIndex);\n+\n+  /**\n+   * Get the value for a particular column of the Row as a decimal.\n+   *\n+   * @param columnName name of column.\n+   * @return column value.\n+   */\n+  BigDecimal getDecimal(String columnName);\n+}\n+```\n+\n+We considered representing column types in a more structured form (rather than plain strings) to accomodate complex/nested data types but felt this added complexity would not be helpful for most use cases. (This would also require a server-side change, so it's a fair bit of additional work.)\n+\n+For `getDecimal(...)` in the `Row` interface, rather than trying to parse the column type to extract the precision and scale, we will simply convert the value to a BigDecimal without explicitly specifying the precision and scale. We could also add an option for users to specify the scale and precision in the getter, if we think that would be useful.\n+\n+We could also add `getList(...)` and `getMap(...)` methods to the `Row` interface, but it's not clear to me how valuable this would be given that the nested data types would not be known.\n+\n+Tim also proposed switching from generic Java types (`Map<String, Object>`, `List<Object>`) to Vert.x types (`JsonObject`, `JsonArray`) as the latter is more type-safe and the client already has a dependency on Vert.x anyway. The downside, though, is that then apps that use the client would be required to depend on Vert.x as well.\n+\n+### Transient queries -- Non-streaming\n+\n+The `Client` interface will also provide the following methods for receiving the results of a transient query (push or pull) in a single batch (non-streaming),\n+once the query has completed:\n+```\n+  /**\n+   * Execute a query (push or pull) and receive all result rows together, once the query has\n+   * completed.\n+   *\n+   * @param sql statement of query to execute.\n+   * @return query result.\n+   */\n+  CompletableFuture<List<Row>> executeQuery(String sql);\n+\n+  /**\n+   * Execute a query (push or pull) and receive all result rows together, once the query has\n+   * completed.\n+   *\n+   * @param sql statement of query to execute.\n+   * @param properties query properties.\n+   * @return query result.\n+   */\n+  CompletableFuture<List<Row>> executeQuery(String sql, Map<String, Object> properties);\n+```\n+\n+For a query to \"complete\" could mean:\n+* The query is a pull query\n+* The query is a push query with a limit clause, and the limit has been reached\n+* The query is a push query that has been terminated\n+\n+We may want to introduce a limit to the number of rows that may be returned from these `executeQuery()` methods,\n+in order to decrease the likelihood of running out of memory.\n+\n+### Insert values\n+\n+A method to insert one row at a time:\n+```\n+  /**\n+   * Insert a single row into the relevant stream/table.\n+   *\n+   * @param streamName name of stream/table.\n+   * @param row the row to insert.\n+   * @return a future that completes once the request has been processed.\n+   */\n+  CompletableFuture<Void> insertInto(String streamName, Map<String, Object> row);\n+```\n+\n+A method to stream inserts (via the `/inserts-stream` endpoint):\n+```\n+  CompletableFuture<Publisher<InsertResponse>> streamInserts(String streamName, Publisher<List<Object>> insertsPublisher);\n+}\n+```\n+where `InsertResponse` is as follows:\n+```\n+public interface InsertResponse {\n+\n+  /**\n+   * Whether the row was successfully inserted or not.\n+   */\n+  boolean isSuccessful();\n+\n+  /**\n+   * Unique sequence number for the row in the stream of inserts.\n+   */\n+  int getSequenceNum();\n+\n+  /**\n+   * If unsuccessful, the error message.\n+   */\n+  String getErrorMessage();\n+\n+  /**\n+   * If unsuccessful, the error code.\n+   */\n+  int getErrorCode();\n+\n+}\n+```\n+\n+### DDL/DML operations\n+\n+#### `CREATE <STREAM/TABLE>`, `CREATE <STREAM/TABLE> ... AS SELECT`, `INSERT INTO`\n+\n+`Client` methods:\n+```\n+  /**\n+   * Execute DDL statement: `CREATE STREAM`, `CREATE TABLE`\n+   */\n+  CompletableFuture<DdlResponse> executeDdl(String sql);\n+\n+  /**\n+   * Execute DML statement: `CREATE STREAM ... AS SELECT`, `CREATE TABLE ... AS SELECT`, `INSERT INTO`\n+   */\n+  CompletableFuture<DmlResponse> executeDml(String sql);\n+\n+  /**\n+   * Execute DML statement: `CREATE STREAM ... AS SELECT`, `CREATE TABLE ... AS SELECT`, `INSERT INTO`\n+   */\n+  CompletableFuture<DmlResponse> executeDml(String sql, Map<String, Object> properties);\n+\n+```\n+with\n+```\n+public interface DdlResponse {\n+\n+  enum Status { QUEUED, PARSING, EXECUTING, RUNNING, TERMINATED, SUCCESS, ERROR }\n+  \n+  Status getStatus();\n+  \n+  String getStatusMessage();\n+  \n+  long getCommandSequenceNumber();\n+\n+  String getCommandId();\n+}\n+```\n+and `DmlResponse` is identical.\n+\n+I don't love this proposal since `DDL` and `DML` aren't used throughout our docs but I'm not a huge fan of the alternatives I considered either, such as\n+```\n+  CompletableFuture<CreateSourceResponse> createStream(String sql);\n+\n+  CompletableFuture<CreateSourceResponse> createStream(String sql, Map<String, Object> properties);\n+\n+  CompletableFuture<CreateSourceResponse> createTable(String sql);\n+\n+  CompletableFuture<CreateSourceResponse> createTable(String sql, Map<String, Object> properties);\n+\n+  CompletableFuture<InsertIntoResponse> insertIntoSource(String sql);\n+\n+  CompletableFuture<InsertIntoResponse> insertIntoSource(String sql, Map<String, Object> properties);\n+```\n+\n+In this version, the implementations of `createStream(...)` and `createTable(...)` would be identical and could be replaced with a single `createSource(...)`\n+but the name of this method feels confusing. As with the previous proposal, `CreateSourceResponse` and `InsertIntoResponse` are identical.\n+\n+Other alternatives include separating `CREATE <STREAM/TABLE>` and `CREATE <STREAM/TABLE> ... AS SELECT` into separate methods, but that feels unnecessarily complex.\n+\n+#### `DROP <STREAM/TABLE>`\n+\n+`Client` methods:\n+```\n+  /**\n+   * Drop stream. The underlying Kafka topic will not be deleted.\n+   */\n+  CompletableFuture<DropSourceResponse> dropStream(String streamName);\n+\n+  /**\n+   * Drop stream. The underlying Kafka topic may optionally be deleted.\n+   */\n+  CompletableFuture<DropSourceResponse> dropStream(String streamName, boolean deleteTopic);\n+\n+  /**\n+   * Drop table. The underlying Kafka topic will not be deleted.\n+   */\n+  CompletableFuture<DropSourceResponse> dropTable(String tableName);\n+\n+  /**\n+   * Drop table. The underlying Kafka topic may optionally be deleted.\n+   */\n+  CompletableFuture<DropSourceResponse> dropTable(String tableName, boolean deleteTopic);\n+```\n+where `DropSourceResponse` is actually the same as `DdlResponse`/`DmlResponse`/`CreateSourceResponse`/`InsertIntoResponse` above.\n+\n+Again, the implementations of `dropStream(...)` and `dropTable(...)` would be the same so we could instead have a single `dropSource(...)`, but the naming might be confusing.\n+\n+If we choose to keep them separate, there's an open question of whether the client should validate that `dropStream(...)` is not used to drop a table, and vice versa.\n+IMO such validation would be introducing complexity without much benefit, though this point of ambiguity makes me prefer a single `dropSource(...)` if we can agree on a method name that's not confusing.\n+\n+Note that users can also execute `DROP <STREAM/TABLE>` requests via `executeDdl(...)` or `executDml(...)` above.\n+\n+#### `TERMINATE <queryId>`\n+\n+```\n+  CompletableFuture<TerminateQueryResponse> terminatePersistentQuery(String queryId);\n+```\n+where `TerminateQueryResponse` is again the same as `DdlResponse`/`DmlResponse`/`CreateSourceResponse`/`InsertIntoResponse`/`DropSourceResponse` above.\n+\n+The method name `terminatePersistenQuery(...)` is to distinguish from `terminatePushQuery(...)` below.\n+\n+#### Connectors\n+\n+```\n+  CompletableFuture<ConnectorInfo> createSourceConnector(String name, Map<String, String> properties);\n+\n+  CompletableFuture<ConnectorInfo> createSinkConnector(String name, Map<String, String> properties);\n+\n+  CompletableFuture<Void> dropConnector(String name);\n+```\n+where `ConnectorInfo` is from an Apache Kafka module ([link](https://github.com/apache/kafka/blob/trunk/connect/runtime/src/main/java/org/apache/kafka/connect/runtime/rest/entities/ConnectorInfo.java)).\n+\n+Or would we rather not have a dependency on Apache Kafka in the ksqlDB client interfaces?\n+\n+### Admin operations\n+\n+#### `SHOW TOPICS`\n+\n+```\n+  CompletableFuture<List<TopicInfo>> listTopics();\n+```\n+with\n+```\n+public interface TopicInfo {\n+\n+  String getName();\n+\n+  int getPartitions();\n+  \n+  List<Integer> getReplicasPerPartition();\n+\n+}\n+```\n+\n+#### `SHOW <STREAMS/TABLES>`\n+\n+```\n+  CompletableFuture<List<StreamInfo>> listStreams();\n+\n+  CompletableFuture<List<TableInfo>> listTables();\n+```\n+with\n+```\n+public interface StreamInfo {\n+\n+  String getName();\n+\n+  String getTopic();\n+\n+  String getFormat();\n+  \n+}\n+```\n+and\n+```\n+public interface TableInfo {\n+\n+  String getName();\n+\n+  String getTopic();\n+\n+  String getFormat();\n+\n+  boolean isWindowed();\n+  \n+}\n+```\n+\n+I'm not sure whether it makes more sense for `StreamInfo#getFormat()` and `TableInfo#getFormat()` to return a string or an enum value.\n+The latter would make it easier for the user to know the possible values, but we'd have to keep the list up to date and would also sacrifice forward compatibility.\n+\n+#### `SHOW QUERIES`\n+\n+```\n+  CompletableFuture<List<QueryInfo>> listQueries();\n+```\n+with\n+```\n+public interface QueryInfo {\n+\n+  boolean isPersistentQuery();\n+\n+  boolean isPushQuery();\n+\n+  /**\n+   * Query ID, used for control operations such as terminating the query\n+   */\n+  String getId();\n+\n+  String getSql();\n+\n+  /**\n+   * Name of sink, for a persistent query. Else, null.\n+   */\n+  String getSink();\n+\n+  /**\n+   * Name of sink topic, for a persistent query. Else, null.\n+   */\n+  String getSinkTopic();\n+  \n+  /**\n+   * Map of query state (\"RUNNING\", \"ERROR\", or \"UNRESPONSIVE\") to the number of ksqlDB servers\n+   * on which this query is in each state.\n+   */\n+  Map<String, Integer> getServerStatusCounts();\n+\n+}\n+```\n+\n+Again, not sure whether it makes more sense to represent query states as strings, or to introduce an Enum and have `getServerStatusCounts()` return an EnumMap instead.\n+\n+Does having `getSink()` and `getSinkTopic()` return null in the case of push queries make sense, or would we prefer an empty string or an Optional instead?\n+\n+#### `SHOW CONNECTORS`", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aed38d5836550829f7fd459df31b47aaf7e5ad45"}, "originalPosition": 630}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODEzOTQzOQ==", "bodyText": "how do you get the queryId for a push query? (related to my comment above about how do you terminate push queries)", "url": "https://github.com/confluentinc/ksql/pull/5236#discussion_r418139439", "createdAt": "2020-04-30T16:32:42Z", "author": {"login": "agavra"}, "path": "design-proposals/klip-26-java-client-interfaces.md", "diffHunk": "@@ -0,0 +1,715 @@\n+# KLIP 26 - Java client interfaces\n+\n+**Author**: Victoria Xia (@vcrfxia) | \n+**Release Target**: ksqlDB 0.10.0 | \n+**Status**: _In development_ | \n+**Discussion**: TBD\n+\n+**tl;dr:** _[KLIP 15](./klip-15-new-api-and-client.md) already made the case for why it makes sense\n+           to introduce a Java client for ksqlDB. This KLIP proposes interfaces for the client._\n+\n+## Motivation and background\n+\n+See [KLIP 15](./klip-15-new-api-and-client.md).\n+\n+## What is in scope\n+\n+The Java client will support the following operations:\n+* Push query\n+* Pull query\n+* Select DDL/DML operations:\n+    * `CREATE STREAM`\n+    * `CREATE TABLE`\n+    * `CREATE STREAM ... AS SELECT`\n+    * `CREATE TABLE ... AS SELECT`\n+    * `DROP STREAM`\n+    * `DROP TABLE`\n+    * `INSERT INTO`\n+    * `TERMINATE <queryId>`\n+    * `CREATE CONNECTOR`\n+    * `DROP CONNECTOR`\n+* Select admin operations:\n+    * `SHOW TOPICS` (non-extended)\n+    * `SHOW STREAMS` (non-extended)\n+    * `SHOW TABLES` (non-extended)\n+    * `SHOW QUERIES` (non-extended)\n+    * `SHOW CONNECTORS`\n+* Insert values, i.e., insert rows into an existing stream/table\n+* Terminate push query (via the `/close-query` endpoint)\n+\n+The purpose of this KLIP is to reach agreement on the interfaces / public APIs.\n+Implementation details will not be covered.\n+\n+## What is not in scope\n+\n+This KLIP does not cover Java client support for the following:\n+* `DESCRIBE <stream/table>`, `DESCRIBE CONNECTOR`, `DESCRIBE FUNCTION`\n+* `EXPLAIN <queryId>`\n+* `PRINT <topic>`\n+* `SHOW TOPICS EXTENDED`, `SHOW <STREAMS/TABLES> EXTENDED`, `SHOW QUERIES EXTENDED`\n+* `CREATE TYPE`, `DROP TYPE`, `SHOW TYPES`\n+* `SHOW FUNCTIONS`, `SHOW PROPERTIES`\n+* `RUN SCRIPT`\n+* Use of other endpoints (info, healthcheck, terminate cluster, status, etc.)\n+\n+We can always add support for these operations in the future if desired.\n+\n+As above, implementation details are out of scope as the purpose of this KLIP is to reach agreement\n+on the interfaces / public APIs.\n+\n+## Value/Return\n+\n+See [KLIP 15](./klip-15-new-api-and-client.md).\n+\n+## Public APIS\n+\n+The following subsections describe the methods of the `Client` interface:\n+```\n+public interface Client {\n+    ...\n+}\n+```\n+\n+### Constructors\n+```\n+  static Client create(ClientOptions clientOptions) {\n+    return new ClientImpl(clientOptions);\n+  }\n+\n+  static Client create(ClientOptions clientOptions, Vertx vertx) {\n+    return new ClientImpl(clientOptions, vertx);\n+  }\n+```\n+\n+The Java client will be implemented as a Vert.x HttpClient. We expose a constructor that allows users to provide their own `Vertx` instance\n+in order to take advantage of a shared connection pool and other properties if desired.\n+\n+`ClientOptions` will initially be as follows:\n+```\n+public interface ClientOptions {\n+\n+  ClientOptions setHost(String host);\n+\n+  ClientOptions setPort(int port);\n+\n+  ClientOptions setUseTls(boolean useTls);\n+\n+  ClientOptions setUseClientAuth(boolean useClientAuth);\n+\n+  ClientOptions setTrustStore(String trustStorePath);\n+\n+  ClientOptions setTrustStorePassword(String trustStorePassword);\n+\n+  ClientOptions setKeyStore(String keyStorePath);\n+\n+  ClientOptions setKeyStorePassword(String keyStorePassword);\n+\n+  ClientOptions setBasicAuthCredentials(String username, String password);\n+\n+  String getHost();\n+\n+  int getPort();\n+\n+  boolean isUseTls();\n+\n+  boolean isUseClientAuth();\n+\n+  boolean isUseBasicAuth();\n+\n+  String getTrustStore();\n+\n+  String getTrustStorePassword();\n+\n+  String getKeyStore();\n+\n+  String getKeyStorePassword();\n+\n+  String getBasicAuthUsername();\n+\n+  String getBasicAuthPassword();\n+\n+  ClientOptions copy();\n+\n+  static ClientOptions create() {\n+    return new ClientOptionsImpl();\n+  }\n+}\n+```\n+\n+We can always add additional configuration options later. We may also wish to expose the Vert.x `HttpClientOptions` for\n+advanced users that wish to provide custom configs.\n+\n+### Transient queries -- Streaming\n+\n+The `Client` interface will provide the following methods for streaming the results of a transient (push or pull) query:\n+```\n+  /**\n+   * Execute a query (push or pull) and receive the results one row at a time.\n+   *\n+   * @param sql statement of query to execute.\n+   * @return query result.\n+   */\n+  CompletableFuture<QueryResult> streamQuery(String sql);\n+\n+  /**\n+   * Execute a query (push or pull) and receive the results one row at a time.\n+   *\n+   * @param sql statement of query to execute.\n+   * @param properties query properties.\n+   * @return query result.\n+   */\n+  CompletableFuture<QueryResult> streamQuery(String sql, Map<String, Object> properties);\n+```\n+where `QueryResult` is as follows:\n+```\n+/**\n+ * The result of a query (push or pull), streamed one row at time. Records may be consumed by either\n+ * subscribing to the publisher or polling (blocking) for one record at a time. These two methods of\n+ * consumption are mutually exclusive; only one method may be used (per QueryResult).\n+ */\n+public interface QueryResult extends Publisher<Row> {\n+\n+  List<String> columnNames();\n+\n+  List<String> columnTypes();\n+\n+  String queryID();\n+\n+  /**\n+   * Block until a row becomes available.\n+   *\n+   * @return the row.\n+   */\n+  Row poll();\n+\n+  /**\n+   * Block until a row becomes available or the timeout has elapsed.\n+   *\n+   * @param timeout amount of to wait for a row. Non-positive values are interpreted as no timeout.\n+   * @param timeUnit unit for timeout param.\n+   * @return the row, if available; else, null.\n+   */\n+  Row poll(long timeout, TimeUnit timeUnit);\n+\n+  boolean isComplete();\n+\n+  void close();\n+}\n+```\n+Note that `QueryResult` is a Reactive Streams `Publisher` so users can stream results. Users can also call `poll()` to receive\n+results in a synchronous fashion instead. Only one of the two methods will be allowed per `QueryResult` instance.\n+\n+The `Row` interface is as follows:\n+```\n+/**\n+ * A single record, returned as part of a query result.\n+ */\n+public interface Row {\n+\n+  List<String> columnNames();\n+\n+  List<String> columnTypes();\n+\n+  List<Object> values();\n+\n+  /**\n+   * Get the value for a particular column of the Row as an Object.\n+   *\n+   * @param columnIndex index of column (1-indexed).\n+   * @return column value.\n+   */\n+  Object getObject(int columnIndex);\n+\n+  /**\n+   * Get the value for a particular column of the Row as an Object.\n+   *\n+   * @param columnName name of column.\n+   * @return column value.\n+   */\n+  Object getObject(String columnName);\n+\n+  /**\n+   * Get the value for a particular column of the Row as a string.\n+   *\n+   * @param columnIndex index of column (1-indexed).\n+   * @return column value.\n+   */\n+  String getString(int columnIndex);\n+\n+  /**\n+   * Get the value for a particular column of the Row as a string.\n+   *\n+   * @param columnName name of column.\n+   * @return column value.\n+   */\n+  String getString(String columnName);\n+\n+  /**\n+   * Get the value for a particular column of the Row as an integer.\n+   *\n+   * @param columnIndex index of column (1-indexed).\n+   * @return column value.\n+   */\n+  Integer getInt(int columnIndex);\n+\n+  /**\n+   * Get the value for a particular column of the Row as an integer.\n+   *\n+   * @param columnName name of column.\n+   * @return column value.\n+   */\n+  Integer getInt(String columnName);\n+\n+  /**\n+   * Get the value for a particular column of the Row as a long.\n+   *\n+   * @param columnIndex index of column (1-indexed).\n+   * @return column value.\n+   */\n+  Long getLong(int columnIndex);\n+\n+  /**\n+   * Get the value for a particular column of the Row as a long.\n+   *\n+   * @param columnName name of column.\n+   * @return column value.\n+   */\n+  Long getLong(String columnName);\n+\n+  /**\n+   * Get the value for a particular column of the Row as a double.\n+   *\n+   * @param columnIndex index of column (1-indexed).\n+   * @return column value.\n+   */\n+  Double getDouble(int columnIndex);\n+\n+  /**\n+   * Get the value for a particular column of the Row as a double.\n+   *\n+   * @param columnName name of column.\n+   * @return column value.\n+   */\n+  Double getDouble(String columnName);\n+\n+  /**\n+   * Get the value for a particular column of the Row as a boolean.\n+   *\n+   * @param columnIndex index of column (1-indexed).\n+   * @return column value.\n+   */\n+  Boolean getBoolean(int columnIndex);\n+\n+  /**\n+   * Get the value for a particular column of the Row as a boolean.\n+   *\n+   * @param columnName name of column.\n+   * @return column value.\n+   */\n+  Boolean getBoolean(String columnName);\n+\n+  /**\n+   * Get the value for a particular column of the Row as a decimal.\n+   *\n+   * @param columnIndex index of column (1-indexed).\n+   * @return column value.\n+   */\n+  BigDecimal getDecimal(int columnIndex);\n+\n+  /**\n+   * Get the value for a particular column of the Row as a decimal.\n+   *\n+   * @param columnName name of column.\n+   * @return column value.\n+   */\n+  BigDecimal getDecimal(String columnName);\n+}\n+```\n+\n+We considered representing column types in a more structured form (rather than plain strings) to accomodate complex/nested data types but felt this added complexity would not be helpful for most use cases. (This would also require a server-side change, so it's a fair bit of additional work.)\n+\n+For `getDecimal(...)` in the `Row` interface, rather than trying to parse the column type to extract the precision and scale, we will simply convert the value to a BigDecimal without explicitly specifying the precision and scale. We could also add an option for users to specify the scale and precision in the getter, if we think that would be useful.\n+\n+We could also add `getList(...)` and `getMap(...)` methods to the `Row` interface, but it's not clear to me how valuable this would be given that the nested data types would not be known.\n+\n+Tim also proposed switching from generic Java types (`Map<String, Object>`, `List<Object>`) to Vert.x types (`JsonObject`, `JsonArray`) as the latter is more type-safe and the client already has a dependency on Vert.x anyway. The downside, though, is that then apps that use the client would be required to depend on Vert.x as well.\n+\n+### Transient queries -- Non-streaming\n+\n+The `Client` interface will also provide the following methods for receiving the results of a transient query (push or pull) in a single batch (non-streaming),\n+once the query has completed:\n+```\n+  /**\n+   * Execute a query (push or pull) and receive all result rows together, once the query has\n+   * completed.\n+   *\n+   * @param sql statement of query to execute.\n+   * @return query result.\n+   */\n+  CompletableFuture<List<Row>> executeQuery(String sql);\n+\n+  /**\n+   * Execute a query (push or pull) and receive all result rows together, once the query has\n+   * completed.\n+   *\n+   * @param sql statement of query to execute.\n+   * @param properties query properties.\n+   * @return query result.\n+   */\n+  CompletableFuture<List<Row>> executeQuery(String sql, Map<String, Object> properties);\n+```\n+\n+For a query to \"complete\" could mean:\n+* The query is a pull query\n+* The query is a push query with a limit clause, and the limit has been reached\n+* The query is a push query that has been terminated\n+\n+We may want to introduce a limit to the number of rows that may be returned from these `executeQuery()` methods,\n+in order to decrease the likelihood of running out of memory.\n+\n+### Insert values\n+\n+A method to insert one row at a time:\n+```\n+  /**\n+   * Insert a single row into the relevant stream/table.\n+   *\n+   * @param streamName name of stream/table.\n+   * @param row the row to insert.\n+   * @return a future that completes once the request has been processed.\n+   */\n+  CompletableFuture<Void> insertInto(String streamName, Map<String, Object> row);\n+```\n+\n+A method to stream inserts (via the `/inserts-stream` endpoint):\n+```\n+  CompletableFuture<Publisher<InsertResponse>> streamInserts(String streamName, Publisher<List<Object>> insertsPublisher);\n+}\n+```\n+where `InsertResponse` is as follows:\n+```\n+public interface InsertResponse {\n+\n+  /**\n+   * Whether the row was successfully inserted or not.\n+   */\n+  boolean isSuccessful();\n+\n+  /**\n+   * Unique sequence number for the row in the stream of inserts.\n+   */\n+  int getSequenceNum();\n+\n+  /**\n+   * If unsuccessful, the error message.\n+   */\n+  String getErrorMessage();\n+\n+  /**\n+   * If unsuccessful, the error code.\n+   */\n+  int getErrorCode();\n+\n+}\n+```\n+\n+### DDL/DML operations\n+\n+#### `CREATE <STREAM/TABLE>`, `CREATE <STREAM/TABLE> ... AS SELECT`, `INSERT INTO`\n+\n+`Client` methods:\n+```\n+  /**\n+   * Execute DDL statement: `CREATE STREAM`, `CREATE TABLE`\n+   */\n+  CompletableFuture<DdlResponse> executeDdl(String sql);\n+\n+  /**\n+   * Execute DML statement: `CREATE STREAM ... AS SELECT`, `CREATE TABLE ... AS SELECT`, `INSERT INTO`\n+   */\n+  CompletableFuture<DmlResponse> executeDml(String sql);\n+\n+  /**\n+   * Execute DML statement: `CREATE STREAM ... AS SELECT`, `CREATE TABLE ... AS SELECT`, `INSERT INTO`\n+   */\n+  CompletableFuture<DmlResponse> executeDml(String sql, Map<String, Object> properties);\n+\n+```\n+with\n+```\n+public interface DdlResponse {\n+\n+  enum Status { QUEUED, PARSING, EXECUTING, RUNNING, TERMINATED, SUCCESS, ERROR }\n+  \n+  Status getStatus();\n+  \n+  String getStatusMessage();\n+  \n+  long getCommandSequenceNumber();\n+\n+  String getCommandId();\n+}\n+```\n+and `DmlResponse` is identical.\n+\n+I don't love this proposal since `DDL` and `DML` aren't used throughout our docs but I'm not a huge fan of the alternatives I considered either, such as\n+```\n+  CompletableFuture<CreateSourceResponse> createStream(String sql);\n+\n+  CompletableFuture<CreateSourceResponse> createStream(String sql, Map<String, Object> properties);\n+\n+  CompletableFuture<CreateSourceResponse> createTable(String sql);\n+\n+  CompletableFuture<CreateSourceResponse> createTable(String sql, Map<String, Object> properties);\n+\n+  CompletableFuture<InsertIntoResponse> insertIntoSource(String sql);\n+\n+  CompletableFuture<InsertIntoResponse> insertIntoSource(String sql, Map<String, Object> properties);\n+```\n+\n+In this version, the implementations of `createStream(...)` and `createTable(...)` would be identical and could be replaced with a single `createSource(...)`\n+but the name of this method feels confusing. As with the previous proposal, `CreateSourceResponse` and `InsertIntoResponse` are identical.\n+\n+Other alternatives include separating `CREATE <STREAM/TABLE>` and `CREATE <STREAM/TABLE> ... AS SELECT` into separate methods, but that feels unnecessarily complex.\n+\n+#### `DROP <STREAM/TABLE>`\n+\n+`Client` methods:\n+```\n+  /**\n+   * Drop stream. The underlying Kafka topic will not be deleted.\n+   */\n+  CompletableFuture<DropSourceResponse> dropStream(String streamName);\n+\n+  /**\n+   * Drop stream. The underlying Kafka topic may optionally be deleted.\n+   */\n+  CompletableFuture<DropSourceResponse> dropStream(String streamName, boolean deleteTopic);\n+\n+  /**\n+   * Drop table. The underlying Kafka topic will not be deleted.\n+   */\n+  CompletableFuture<DropSourceResponse> dropTable(String tableName);\n+\n+  /**\n+   * Drop table. The underlying Kafka topic may optionally be deleted.\n+   */\n+  CompletableFuture<DropSourceResponse> dropTable(String tableName, boolean deleteTopic);\n+```\n+where `DropSourceResponse` is actually the same as `DdlResponse`/`DmlResponse`/`CreateSourceResponse`/`InsertIntoResponse` above.\n+\n+Again, the implementations of `dropStream(...)` and `dropTable(...)` would be the same so we could instead have a single `dropSource(...)`, but the naming might be confusing.\n+\n+If we choose to keep them separate, there's an open question of whether the client should validate that `dropStream(...)` is not used to drop a table, and vice versa.\n+IMO such validation would be introducing complexity without much benefit, though this point of ambiguity makes me prefer a single `dropSource(...)` if we can agree on a method name that's not confusing.\n+\n+Note that users can also execute `DROP <STREAM/TABLE>` requests via `executeDdl(...)` or `executDml(...)` above.\n+\n+#### `TERMINATE <queryId>`\n+\n+```\n+  CompletableFuture<TerminateQueryResponse> terminatePersistentQuery(String queryId);\n+```\n+where `TerminateQueryResponse` is again the same as `DdlResponse`/`DmlResponse`/`CreateSourceResponse`/`InsertIntoResponse`/`DropSourceResponse` above.\n+\n+The method name `terminatePersistenQuery(...)` is to distinguish from `terminatePushQuery(...)` below.\n+\n+#### Connectors\n+\n+```\n+  CompletableFuture<ConnectorInfo> createSourceConnector(String name, Map<String, String> properties);\n+\n+  CompletableFuture<ConnectorInfo> createSinkConnector(String name, Map<String, String> properties);\n+\n+  CompletableFuture<Void> dropConnector(String name);\n+```\n+where `ConnectorInfo` is from an Apache Kafka module ([link](https://github.com/apache/kafka/blob/trunk/connect/runtime/src/main/java/org/apache/kafka/connect/runtime/rest/entities/ConnectorInfo.java)).\n+\n+Or would we rather not have a dependency on Apache Kafka in the ksqlDB client interfaces?\n+\n+### Admin operations\n+\n+#### `SHOW TOPICS`\n+\n+```\n+  CompletableFuture<List<TopicInfo>> listTopics();\n+```\n+with\n+```\n+public interface TopicInfo {\n+\n+  String getName();\n+\n+  int getPartitions();\n+  \n+  List<Integer> getReplicasPerPartition();\n+\n+}\n+```\n+\n+#### `SHOW <STREAMS/TABLES>`\n+\n+```\n+  CompletableFuture<List<StreamInfo>> listStreams();\n+\n+  CompletableFuture<List<TableInfo>> listTables();\n+```\n+with\n+```\n+public interface StreamInfo {\n+\n+  String getName();\n+\n+  String getTopic();\n+\n+  String getFormat();\n+  \n+}\n+```\n+and\n+```\n+public interface TableInfo {\n+\n+  String getName();\n+\n+  String getTopic();\n+\n+  String getFormat();\n+\n+  boolean isWindowed();\n+  \n+}\n+```\n+\n+I'm not sure whether it makes more sense for `StreamInfo#getFormat()` and `TableInfo#getFormat()` to return a string or an enum value.\n+The latter would make it easier for the user to know the possible values, but we'd have to keep the list up to date and would also sacrifice forward compatibility.\n+\n+#### `SHOW QUERIES`\n+\n+```\n+  CompletableFuture<List<QueryInfo>> listQueries();\n+```\n+with\n+```\n+public interface QueryInfo {\n+\n+  boolean isPersistentQuery();\n+\n+  boolean isPushQuery();\n+\n+  /**\n+   * Query ID, used for control operations such as terminating the query\n+   */\n+  String getId();\n+\n+  String getSql();\n+\n+  /**\n+   * Name of sink, for a persistent query. Else, null.\n+   */\n+  String getSink();\n+\n+  /**\n+   * Name of sink topic, for a persistent query. Else, null.\n+   */\n+  String getSinkTopic();\n+  \n+  /**\n+   * Map of query state (\"RUNNING\", \"ERROR\", or \"UNRESPONSIVE\") to the number of ksqlDB servers\n+   * on which this query is in each state.\n+   */\n+  Map<String, Integer> getServerStatusCounts();\n+\n+}\n+```\n+\n+Again, not sure whether it makes more sense to represent query states as strings, or to introduce an Enum and have `getServerStatusCounts()` return an EnumMap instead.\n+\n+Does having `getSink()` and `getSinkTopic()` return null in the case of push queries make sense, or would we prefer an empty string or an Optional instead?\n+\n+#### `SHOW CONNECTORS`\n+\n+```\n+  CompletableFuture<ConnectorList> listConnectors();\n+```\n+with\n+```\n+public interface ConnectorList {\n+  \n+  List<ConnectorInfo> getConnectors();\n+  \n+  /**\n+   * Any warnings returned by the server as a result of listing connectors.\n+   */\n+  List<String> getWarnings();\n+\n+}\n+```\n+and\n+```\n+public interface ConnectorInfo {\n+\n+  enum ConnectorType {\n+    SOURCE,\n+    SINK,\n+    UNKNOWN;\n+  }\n+\n+  String getName();\n+\n+  ConnectorType getType();\n+\n+  String getClassName();\n+\n+  String getState();\n+\n+}\n+```\n+\n+I don't love that the introduction of `ConnectorList` wrapped around `List<ConnectorInfo>` breaks the pattern established by `SHOW TOPICS`/`SHOW <STREAMS/TABLES>`/`SHOW QUERIES` but it seems important to propagate any server warnings to the user so the trade-off is worth it IMO.\n+\n+### Terminate push query\n+\n+```\n+  CompletableFuture<Void> terminatePushQuery(String queryId);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aed38d5836550829f7fd459df31b47aaf7e5ad45"}, "originalPosition": 674}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODEzOTY3NQ==", "bodyText": "why is the return of the CompleteableFuture void? seems like we'd want to know if our terminate succeeded", "url": "https://github.com/confluentinc/ksql/pull/5236#discussion_r418139675", "createdAt": "2020-04-30T16:33:05Z", "author": {"login": "agavra"}, "path": "design-proposals/klip-26-java-client-interfaces.md", "diffHunk": "@@ -0,0 +1,715 @@\n+# KLIP 26 - Java client interfaces\n+\n+**Author**: Victoria Xia (@vcrfxia) | \n+**Release Target**: ksqlDB 0.10.0 | \n+**Status**: _In development_ | \n+**Discussion**: TBD\n+\n+**tl;dr:** _[KLIP 15](./klip-15-new-api-and-client.md) already made the case for why it makes sense\n+           to introduce a Java client for ksqlDB. This KLIP proposes interfaces for the client._\n+\n+## Motivation and background\n+\n+See [KLIP 15](./klip-15-new-api-and-client.md).\n+\n+## What is in scope\n+\n+The Java client will support the following operations:\n+* Push query\n+* Pull query\n+* Select DDL/DML operations:\n+    * `CREATE STREAM`\n+    * `CREATE TABLE`\n+    * `CREATE STREAM ... AS SELECT`\n+    * `CREATE TABLE ... AS SELECT`\n+    * `DROP STREAM`\n+    * `DROP TABLE`\n+    * `INSERT INTO`\n+    * `TERMINATE <queryId>`\n+    * `CREATE CONNECTOR`\n+    * `DROP CONNECTOR`\n+* Select admin operations:\n+    * `SHOW TOPICS` (non-extended)\n+    * `SHOW STREAMS` (non-extended)\n+    * `SHOW TABLES` (non-extended)\n+    * `SHOW QUERIES` (non-extended)\n+    * `SHOW CONNECTORS`\n+* Insert values, i.e., insert rows into an existing stream/table\n+* Terminate push query (via the `/close-query` endpoint)\n+\n+The purpose of this KLIP is to reach agreement on the interfaces / public APIs.\n+Implementation details will not be covered.\n+\n+## What is not in scope\n+\n+This KLIP does not cover Java client support for the following:\n+* `DESCRIBE <stream/table>`, `DESCRIBE CONNECTOR`, `DESCRIBE FUNCTION`\n+* `EXPLAIN <queryId>`\n+* `PRINT <topic>`\n+* `SHOW TOPICS EXTENDED`, `SHOW <STREAMS/TABLES> EXTENDED`, `SHOW QUERIES EXTENDED`\n+* `CREATE TYPE`, `DROP TYPE`, `SHOW TYPES`\n+* `SHOW FUNCTIONS`, `SHOW PROPERTIES`\n+* `RUN SCRIPT`\n+* Use of other endpoints (info, healthcheck, terminate cluster, status, etc.)\n+\n+We can always add support for these operations in the future if desired.\n+\n+As above, implementation details are out of scope as the purpose of this KLIP is to reach agreement\n+on the interfaces / public APIs.\n+\n+## Value/Return\n+\n+See [KLIP 15](./klip-15-new-api-and-client.md).\n+\n+## Public APIS\n+\n+The following subsections describe the methods of the `Client` interface:\n+```\n+public interface Client {\n+    ...\n+}\n+```\n+\n+### Constructors\n+```\n+  static Client create(ClientOptions clientOptions) {\n+    return new ClientImpl(clientOptions);\n+  }\n+\n+  static Client create(ClientOptions clientOptions, Vertx vertx) {\n+    return new ClientImpl(clientOptions, vertx);\n+  }\n+```\n+\n+The Java client will be implemented as a Vert.x HttpClient. We expose a constructor that allows users to provide their own `Vertx` instance\n+in order to take advantage of a shared connection pool and other properties if desired.\n+\n+`ClientOptions` will initially be as follows:\n+```\n+public interface ClientOptions {\n+\n+  ClientOptions setHost(String host);\n+\n+  ClientOptions setPort(int port);\n+\n+  ClientOptions setUseTls(boolean useTls);\n+\n+  ClientOptions setUseClientAuth(boolean useClientAuth);\n+\n+  ClientOptions setTrustStore(String trustStorePath);\n+\n+  ClientOptions setTrustStorePassword(String trustStorePassword);\n+\n+  ClientOptions setKeyStore(String keyStorePath);\n+\n+  ClientOptions setKeyStorePassword(String keyStorePassword);\n+\n+  ClientOptions setBasicAuthCredentials(String username, String password);\n+\n+  String getHost();\n+\n+  int getPort();\n+\n+  boolean isUseTls();\n+\n+  boolean isUseClientAuth();\n+\n+  boolean isUseBasicAuth();\n+\n+  String getTrustStore();\n+\n+  String getTrustStorePassword();\n+\n+  String getKeyStore();\n+\n+  String getKeyStorePassword();\n+\n+  String getBasicAuthUsername();\n+\n+  String getBasicAuthPassword();\n+\n+  ClientOptions copy();\n+\n+  static ClientOptions create() {\n+    return new ClientOptionsImpl();\n+  }\n+}\n+```\n+\n+We can always add additional configuration options later. We may also wish to expose the Vert.x `HttpClientOptions` for\n+advanced users that wish to provide custom configs.\n+\n+### Transient queries -- Streaming\n+\n+The `Client` interface will provide the following methods for streaming the results of a transient (push or pull) query:\n+```\n+  /**\n+   * Execute a query (push or pull) and receive the results one row at a time.\n+   *\n+   * @param sql statement of query to execute.\n+   * @return query result.\n+   */\n+  CompletableFuture<QueryResult> streamQuery(String sql);\n+\n+  /**\n+   * Execute a query (push or pull) and receive the results one row at a time.\n+   *\n+   * @param sql statement of query to execute.\n+   * @param properties query properties.\n+   * @return query result.\n+   */\n+  CompletableFuture<QueryResult> streamQuery(String sql, Map<String, Object> properties);\n+```\n+where `QueryResult` is as follows:\n+```\n+/**\n+ * The result of a query (push or pull), streamed one row at time. Records may be consumed by either\n+ * subscribing to the publisher or polling (blocking) for one record at a time. These two methods of\n+ * consumption are mutually exclusive; only one method may be used (per QueryResult).\n+ */\n+public interface QueryResult extends Publisher<Row> {\n+\n+  List<String> columnNames();\n+\n+  List<String> columnTypes();\n+\n+  String queryID();\n+\n+  /**\n+   * Block until a row becomes available.\n+   *\n+   * @return the row.\n+   */\n+  Row poll();\n+\n+  /**\n+   * Block until a row becomes available or the timeout has elapsed.\n+   *\n+   * @param timeout amount of to wait for a row. Non-positive values are interpreted as no timeout.\n+   * @param timeUnit unit for timeout param.\n+   * @return the row, if available; else, null.\n+   */\n+  Row poll(long timeout, TimeUnit timeUnit);\n+\n+  boolean isComplete();\n+\n+  void close();\n+}\n+```\n+Note that `QueryResult` is a Reactive Streams `Publisher` so users can stream results. Users can also call `poll()` to receive\n+results in a synchronous fashion instead. Only one of the two methods will be allowed per `QueryResult` instance.\n+\n+The `Row` interface is as follows:\n+```\n+/**\n+ * A single record, returned as part of a query result.\n+ */\n+public interface Row {\n+\n+  List<String> columnNames();\n+\n+  List<String> columnTypes();\n+\n+  List<Object> values();\n+\n+  /**\n+   * Get the value for a particular column of the Row as an Object.\n+   *\n+   * @param columnIndex index of column (1-indexed).\n+   * @return column value.\n+   */\n+  Object getObject(int columnIndex);\n+\n+  /**\n+   * Get the value for a particular column of the Row as an Object.\n+   *\n+   * @param columnName name of column.\n+   * @return column value.\n+   */\n+  Object getObject(String columnName);\n+\n+  /**\n+   * Get the value for a particular column of the Row as a string.\n+   *\n+   * @param columnIndex index of column (1-indexed).\n+   * @return column value.\n+   */\n+  String getString(int columnIndex);\n+\n+  /**\n+   * Get the value for a particular column of the Row as a string.\n+   *\n+   * @param columnName name of column.\n+   * @return column value.\n+   */\n+  String getString(String columnName);\n+\n+  /**\n+   * Get the value for a particular column of the Row as an integer.\n+   *\n+   * @param columnIndex index of column (1-indexed).\n+   * @return column value.\n+   */\n+  Integer getInt(int columnIndex);\n+\n+  /**\n+   * Get the value for a particular column of the Row as an integer.\n+   *\n+   * @param columnName name of column.\n+   * @return column value.\n+   */\n+  Integer getInt(String columnName);\n+\n+  /**\n+   * Get the value for a particular column of the Row as a long.\n+   *\n+   * @param columnIndex index of column (1-indexed).\n+   * @return column value.\n+   */\n+  Long getLong(int columnIndex);\n+\n+  /**\n+   * Get the value for a particular column of the Row as a long.\n+   *\n+   * @param columnName name of column.\n+   * @return column value.\n+   */\n+  Long getLong(String columnName);\n+\n+  /**\n+   * Get the value for a particular column of the Row as a double.\n+   *\n+   * @param columnIndex index of column (1-indexed).\n+   * @return column value.\n+   */\n+  Double getDouble(int columnIndex);\n+\n+  /**\n+   * Get the value for a particular column of the Row as a double.\n+   *\n+   * @param columnName name of column.\n+   * @return column value.\n+   */\n+  Double getDouble(String columnName);\n+\n+  /**\n+   * Get the value for a particular column of the Row as a boolean.\n+   *\n+   * @param columnIndex index of column (1-indexed).\n+   * @return column value.\n+   */\n+  Boolean getBoolean(int columnIndex);\n+\n+  /**\n+   * Get the value for a particular column of the Row as a boolean.\n+   *\n+   * @param columnName name of column.\n+   * @return column value.\n+   */\n+  Boolean getBoolean(String columnName);\n+\n+  /**\n+   * Get the value for a particular column of the Row as a decimal.\n+   *\n+   * @param columnIndex index of column (1-indexed).\n+   * @return column value.\n+   */\n+  BigDecimal getDecimal(int columnIndex);\n+\n+  /**\n+   * Get the value for a particular column of the Row as a decimal.\n+   *\n+   * @param columnName name of column.\n+   * @return column value.\n+   */\n+  BigDecimal getDecimal(String columnName);\n+}\n+```\n+\n+We considered representing column types in a more structured form (rather than plain strings) to accomodate complex/nested data types but felt this added complexity would not be helpful for most use cases. (This would also require a server-side change, so it's a fair bit of additional work.)\n+\n+For `getDecimal(...)` in the `Row` interface, rather than trying to parse the column type to extract the precision and scale, we will simply convert the value to a BigDecimal without explicitly specifying the precision and scale. We could also add an option for users to specify the scale and precision in the getter, if we think that would be useful.\n+\n+We could also add `getList(...)` and `getMap(...)` methods to the `Row` interface, but it's not clear to me how valuable this would be given that the nested data types would not be known.\n+\n+Tim also proposed switching from generic Java types (`Map<String, Object>`, `List<Object>`) to Vert.x types (`JsonObject`, `JsonArray`) as the latter is more type-safe and the client already has a dependency on Vert.x anyway. The downside, though, is that then apps that use the client would be required to depend on Vert.x as well.\n+\n+### Transient queries -- Non-streaming\n+\n+The `Client` interface will also provide the following methods for receiving the results of a transient query (push or pull) in a single batch (non-streaming),\n+once the query has completed:\n+```\n+  /**\n+   * Execute a query (push or pull) and receive all result rows together, once the query has\n+   * completed.\n+   *\n+   * @param sql statement of query to execute.\n+   * @return query result.\n+   */\n+  CompletableFuture<List<Row>> executeQuery(String sql);\n+\n+  /**\n+   * Execute a query (push or pull) and receive all result rows together, once the query has\n+   * completed.\n+   *\n+   * @param sql statement of query to execute.\n+   * @param properties query properties.\n+   * @return query result.\n+   */\n+  CompletableFuture<List<Row>> executeQuery(String sql, Map<String, Object> properties);\n+```\n+\n+For a query to \"complete\" could mean:\n+* The query is a pull query\n+* The query is a push query with a limit clause, and the limit has been reached\n+* The query is a push query that has been terminated\n+\n+We may want to introduce a limit to the number of rows that may be returned from these `executeQuery()` methods,\n+in order to decrease the likelihood of running out of memory.\n+\n+### Insert values\n+\n+A method to insert one row at a time:\n+```\n+  /**\n+   * Insert a single row into the relevant stream/table.\n+   *\n+   * @param streamName name of stream/table.\n+   * @param row the row to insert.\n+   * @return a future that completes once the request has been processed.\n+   */\n+  CompletableFuture<Void> insertInto(String streamName, Map<String, Object> row);\n+```\n+\n+A method to stream inserts (via the `/inserts-stream` endpoint):\n+```\n+  CompletableFuture<Publisher<InsertResponse>> streamInserts(String streamName, Publisher<List<Object>> insertsPublisher);\n+}\n+```\n+where `InsertResponse` is as follows:\n+```\n+public interface InsertResponse {\n+\n+  /**\n+   * Whether the row was successfully inserted or not.\n+   */\n+  boolean isSuccessful();\n+\n+  /**\n+   * Unique sequence number for the row in the stream of inserts.\n+   */\n+  int getSequenceNum();\n+\n+  /**\n+   * If unsuccessful, the error message.\n+   */\n+  String getErrorMessage();\n+\n+  /**\n+   * If unsuccessful, the error code.\n+   */\n+  int getErrorCode();\n+\n+}\n+```\n+\n+### DDL/DML operations\n+\n+#### `CREATE <STREAM/TABLE>`, `CREATE <STREAM/TABLE> ... AS SELECT`, `INSERT INTO`\n+\n+`Client` methods:\n+```\n+  /**\n+   * Execute DDL statement: `CREATE STREAM`, `CREATE TABLE`\n+   */\n+  CompletableFuture<DdlResponse> executeDdl(String sql);\n+\n+  /**\n+   * Execute DML statement: `CREATE STREAM ... AS SELECT`, `CREATE TABLE ... AS SELECT`, `INSERT INTO`\n+   */\n+  CompletableFuture<DmlResponse> executeDml(String sql);\n+\n+  /**\n+   * Execute DML statement: `CREATE STREAM ... AS SELECT`, `CREATE TABLE ... AS SELECT`, `INSERT INTO`\n+   */\n+  CompletableFuture<DmlResponse> executeDml(String sql, Map<String, Object> properties);\n+\n+```\n+with\n+```\n+public interface DdlResponse {\n+\n+  enum Status { QUEUED, PARSING, EXECUTING, RUNNING, TERMINATED, SUCCESS, ERROR }\n+  \n+  Status getStatus();\n+  \n+  String getStatusMessage();\n+  \n+  long getCommandSequenceNumber();\n+\n+  String getCommandId();\n+}\n+```\n+and `DmlResponse` is identical.\n+\n+I don't love this proposal since `DDL` and `DML` aren't used throughout our docs but I'm not a huge fan of the alternatives I considered either, such as\n+```\n+  CompletableFuture<CreateSourceResponse> createStream(String sql);\n+\n+  CompletableFuture<CreateSourceResponse> createStream(String sql, Map<String, Object> properties);\n+\n+  CompletableFuture<CreateSourceResponse> createTable(String sql);\n+\n+  CompletableFuture<CreateSourceResponse> createTable(String sql, Map<String, Object> properties);\n+\n+  CompletableFuture<InsertIntoResponse> insertIntoSource(String sql);\n+\n+  CompletableFuture<InsertIntoResponse> insertIntoSource(String sql, Map<String, Object> properties);\n+```\n+\n+In this version, the implementations of `createStream(...)` and `createTable(...)` would be identical and could be replaced with a single `createSource(...)`\n+but the name of this method feels confusing. As with the previous proposal, `CreateSourceResponse` and `InsertIntoResponse` are identical.\n+\n+Other alternatives include separating `CREATE <STREAM/TABLE>` and `CREATE <STREAM/TABLE> ... AS SELECT` into separate methods, but that feels unnecessarily complex.\n+\n+#### `DROP <STREAM/TABLE>`\n+\n+`Client` methods:\n+```\n+  /**\n+   * Drop stream. The underlying Kafka topic will not be deleted.\n+   */\n+  CompletableFuture<DropSourceResponse> dropStream(String streamName);\n+\n+  /**\n+   * Drop stream. The underlying Kafka topic may optionally be deleted.\n+   */\n+  CompletableFuture<DropSourceResponse> dropStream(String streamName, boolean deleteTopic);\n+\n+  /**\n+   * Drop table. The underlying Kafka topic will not be deleted.\n+   */\n+  CompletableFuture<DropSourceResponse> dropTable(String tableName);\n+\n+  /**\n+   * Drop table. The underlying Kafka topic may optionally be deleted.\n+   */\n+  CompletableFuture<DropSourceResponse> dropTable(String tableName, boolean deleteTopic);\n+```\n+where `DropSourceResponse` is actually the same as `DdlResponse`/`DmlResponse`/`CreateSourceResponse`/`InsertIntoResponse` above.\n+\n+Again, the implementations of `dropStream(...)` and `dropTable(...)` would be the same so we could instead have a single `dropSource(...)`, but the naming might be confusing.\n+\n+If we choose to keep them separate, there's an open question of whether the client should validate that `dropStream(...)` is not used to drop a table, and vice versa.\n+IMO such validation would be introducing complexity without much benefit, though this point of ambiguity makes me prefer a single `dropSource(...)` if we can agree on a method name that's not confusing.\n+\n+Note that users can also execute `DROP <STREAM/TABLE>` requests via `executeDdl(...)` or `executDml(...)` above.\n+\n+#### `TERMINATE <queryId>`\n+\n+```\n+  CompletableFuture<TerminateQueryResponse> terminatePersistentQuery(String queryId);\n+```\n+where `TerminateQueryResponse` is again the same as `DdlResponse`/`DmlResponse`/`CreateSourceResponse`/`InsertIntoResponse`/`DropSourceResponse` above.\n+\n+The method name `terminatePersistenQuery(...)` is to distinguish from `terminatePushQuery(...)` below.\n+\n+#### Connectors\n+\n+```\n+  CompletableFuture<ConnectorInfo> createSourceConnector(String name, Map<String, String> properties);\n+\n+  CompletableFuture<ConnectorInfo> createSinkConnector(String name, Map<String, String> properties);\n+\n+  CompletableFuture<Void> dropConnector(String name);\n+```\n+where `ConnectorInfo` is from an Apache Kafka module ([link](https://github.com/apache/kafka/blob/trunk/connect/runtime/src/main/java/org/apache/kafka/connect/runtime/rest/entities/ConnectorInfo.java)).\n+\n+Or would we rather not have a dependency on Apache Kafka in the ksqlDB client interfaces?\n+\n+### Admin operations\n+\n+#### `SHOW TOPICS`\n+\n+```\n+  CompletableFuture<List<TopicInfo>> listTopics();\n+```\n+with\n+```\n+public interface TopicInfo {\n+\n+  String getName();\n+\n+  int getPartitions();\n+  \n+  List<Integer> getReplicasPerPartition();\n+\n+}\n+```\n+\n+#### `SHOW <STREAMS/TABLES>`\n+\n+```\n+  CompletableFuture<List<StreamInfo>> listStreams();\n+\n+  CompletableFuture<List<TableInfo>> listTables();\n+```\n+with\n+```\n+public interface StreamInfo {\n+\n+  String getName();\n+\n+  String getTopic();\n+\n+  String getFormat();\n+  \n+}\n+```\n+and\n+```\n+public interface TableInfo {\n+\n+  String getName();\n+\n+  String getTopic();\n+\n+  String getFormat();\n+\n+  boolean isWindowed();\n+  \n+}\n+```\n+\n+I'm not sure whether it makes more sense for `StreamInfo#getFormat()` and `TableInfo#getFormat()` to return a string or an enum value.\n+The latter would make it easier for the user to know the possible values, but we'd have to keep the list up to date and would also sacrifice forward compatibility.\n+\n+#### `SHOW QUERIES`\n+\n+```\n+  CompletableFuture<List<QueryInfo>> listQueries();\n+```\n+with\n+```\n+public interface QueryInfo {\n+\n+  boolean isPersistentQuery();\n+\n+  boolean isPushQuery();\n+\n+  /**\n+   * Query ID, used for control operations such as terminating the query\n+   */\n+  String getId();\n+\n+  String getSql();\n+\n+  /**\n+   * Name of sink, for a persistent query. Else, null.\n+   */\n+  String getSink();\n+\n+  /**\n+   * Name of sink topic, for a persistent query. Else, null.\n+   */\n+  String getSinkTopic();\n+  \n+  /**\n+   * Map of query state (\"RUNNING\", \"ERROR\", or \"UNRESPONSIVE\") to the number of ksqlDB servers\n+   * on which this query is in each state.\n+   */\n+  Map<String, Integer> getServerStatusCounts();\n+\n+}\n+```\n+\n+Again, not sure whether it makes more sense to represent query states as strings, or to introduce an Enum and have `getServerStatusCounts()` return an EnumMap instead.\n+\n+Does having `getSink()` and `getSinkTopic()` return null in the case of push queries make sense, or would we prefer an empty string or an Optional instead?\n+\n+#### `SHOW CONNECTORS`\n+\n+```\n+  CompletableFuture<ConnectorList> listConnectors();\n+```\n+with\n+```\n+public interface ConnectorList {\n+  \n+  List<ConnectorInfo> getConnectors();\n+  \n+  /**\n+   * Any warnings returned by the server as a result of listing connectors.\n+   */\n+  List<String> getWarnings();\n+\n+}\n+```\n+and\n+```\n+public interface ConnectorInfo {\n+\n+  enum ConnectorType {\n+    SOURCE,\n+    SINK,\n+    UNKNOWN;\n+  }\n+\n+  String getName();\n+\n+  ConnectorType getType();\n+\n+  String getClassName();\n+\n+  String getState();\n+\n+}\n+```\n+\n+I don't love that the introduction of `ConnectorList` wrapped around `List<ConnectorInfo>` breaks the pattern established by `SHOW TOPICS`/`SHOW <STREAMS/TABLES>`/`SHOW QUERIES` but it seems important to propagate any server warnings to the user so the trade-off is worth it IMO.\n+\n+### Terminate push query\n+\n+```\n+  CompletableFuture<Void> terminatePushQuery(String queryId);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aed38d5836550829f7fd459df31b47aaf7e5ad45"}, "originalPosition": 674}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDAzNzg1Nzcw", "url": "https://github.com/confluentinc/ksql/pull/5236#pullrequestreview-403785770", "createdAt": "2020-04-30T18:46:02Z", "commit": {"oid": "aed38d5836550829f7fd459df31b47aaf7e5ad45"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0zMFQxODo0NjowMlrOGO16VQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0zMFQxODo0NjowMlrOGO16VQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODIxNjUzMw==", "bodyText": "What do you mean by \"streaming the result of a pull query\" ? Only push queries return a data stream?\nHaving said that, would it make sense to have two different methods for both query types, as both should return a different \"object\"?", "url": "https://github.com/confluentinc/ksql/pull/5236#discussion_r418216533", "createdAt": "2020-04-30T18:46:02Z", "author": {"login": "mjsax"}, "path": "design-proposals/klip-26-java-client-interfaces.md", "diffHunk": "@@ -0,0 +1,715 @@\n+# KLIP 26 - Java client interfaces\n+\n+**Author**: Victoria Xia (@vcrfxia) | \n+**Release Target**: ksqlDB 0.10.0 | \n+**Status**: _In development_ | \n+**Discussion**: TBD\n+\n+**tl;dr:** _[KLIP 15](./klip-15-new-api-and-client.md) already made the case for why it makes sense\n+           to introduce a Java client for ksqlDB. This KLIP proposes interfaces for the client._\n+\n+## Motivation and background\n+\n+See [KLIP 15](./klip-15-new-api-and-client.md).\n+\n+## What is in scope\n+\n+The Java client will support the following operations:\n+* Push query\n+* Pull query\n+* Select DDL/DML operations:\n+    * `CREATE STREAM`\n+    * `CREATE TABLE`\n+    * `CREATE STREAM ... AS SELECT`\n+    * `CREATE TABLE ... AS SELECT`\n+    * `DROP STREAM`\n+    * `DROP TABLE`\n+    * `INSERT INTO`\n+    * `TERMINATE <queryId>`\n+    * `CREATE CONNECTOR`\n+    * `DROP CONNECTOR`\n+* Select admin operations:\n+    * `SHOW TOPICS` (non-extended)\n+    * `SHOW STREAMS` (non-extended)\n+    * `SHOW TABLES` (non-extended)\n+    * `SHOW QUERIES` (non-extended)\n+    * `SHOW CONNECTORS`\n+* Insert values, i.e., insert rows into an existing stream/table\n+* Terminate push query (via the `/close-query` endpoint)\n+\n+The purpose of this KLIP is to reach agreement on the interfaces / public APIs.\n+Implementation details will not be covered.\n+\n+## What is not in scope\n+\n+This KLIP does not cover Java client support for the following:\n+* `DESCRIBE <stream/table>`, `DESCRIBE CONNECTOR`, `DESCRIBE FUNCTION`\n+* `EXPLAIN <queryId>`\n+* `PRINT <topic>`\n+* `SHOW TOPICS EXTENDED`, `SHOW <STREAMS/TABLES> EXTENDED`, `SHOW QUERIES EXTENDED`\n+* `CREATE TYPE`, `DROP TYPE`, `SHOW TYPES`\n+* `SHOW FUNCTIONS`, `SHOW PROPERTIES`\n+* `RUN SCRIPT`\n+* Use of other endpoints (info, healthcheck, terminate cluster, status, etc.)\n+\n+We can always add support for these operations in the future if desired.\n+\n+As above, implementation details are out of scope as the purpose of this KLIP is to reach agreement\n+on the interfaces / public APIs.\n+\n+## Value/Return\n+\n+See [KLIP 15](./klip-15-new-api-and-client.md).\n+\n+## Public APIS\n+\n+The following subsections describe the methods of the `Client` interface:\n+```\n+public interface Client {\n+    ...\n+}\n+```\n+\n+### Constructors\n+```\n+  static Client create(ClientOptions clientOptions) {\n+    return new ClientImpl(clientOptions);\n+  }\n+\n+  static Client create(ClientOptions clientOptions, Vertx vertx) {\n+    return new ClientImpl(clientOptions, vertx);\n+  }\n+```\n+\n+The Java client will be implemented as a Vert.x HttpClient. We expose a constructor that allows users to provide their own `Vertx` instance\n+in order to take advantage of a shared connection pool and other properties if desired.\n+\n+`ClientOptions` will initially be as follows:\n+```\n+public interface ClientOptions {\n+\n+  ClientOptions setHost(String host);\n+\n+  ClientOptions setPort(int port);\n+\n+  ClientOptions setUseTls(boolean useTls);\n+\n+  ClientOptions setUseClientAuth(boolean useClientAuth);\n+\n+  ClientOptions setTrustStore(String trustStorePath);\n+\n+  ClientOptions setTrustStorePassword(String trustStorePassword);\n+\n+  ClientOptions setKeyStore(String keyStorePath);\n+\n+  ClientOptions setKeyStorePassword(String keyStorePassword);\n+\n+  ClientOptions setBasicAuthCredentials(String username, String password);\n+\n+  String getHost();\n+\n+  int getPort();\n+\n+  boolean isUseTls();\n+\n+  boolean isUseClientAuth();\n+\n+  boolean isUseBasicAuth();\n+\n+  String getTrustStore();\n+\n+  String getTrustStorePassword();\n+\n+  String getKeyStore();\n+\n+  String getKeyStorePassword();\n+\n+  String getBasicAuthUsername();\n+\n+  String getBasicAuthPassword();\n+\n+  ClientOptions copy();\n+\n+  static ClientOptions create() {\n+    return new ClientOptionsImpl();\n+  }\n+}\n+```\n+\n+We can always add additional configuration options later. We may also wish to expose the Vert.x `HttpClientOptions` for\n+advanced users that wish to provide custom configs.\n+\n+### Transient queries -- Streaming\n+\n+The `Client` interface will provide the following methods for streaming the results of a transient (push or pull) query:", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aed38d5836550829f7fd459df31b47aaf7e5ad45"}, "originalPosition": 144}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDAzNzg4MTIy", "url": "https://github.com/confluentinc/ksql/pull/5236#pullrequestreview-403788122", "createdAt": "2020-04-30T18:49:29Z", "commit": {"oid": "aed38d5836550829f7fd459df31b47aaf7e5ad45"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0zMFQxODo0OTozMFrOGO2BpA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0zMFQxODo0OTozMFrOGO2BpA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODIxODQwNA==", "bodyText": "For pull queries, this would block forever if the end of the result is reached? That might be a bad user experience. We could of course throw an exception, but that seems equally bad?\nHow does the JDBC interface handle this case (the also return a finite ResetSet one can iterate through)", "url": "https://github.com/confluentinc/ksql/pull/5236#discussion_r418218404", "createdAt": "2020-04-30T18:49:30Z", "author": {"login": "mjsax"}, "path": "design-proposals/klip-26-java-client-interfaces.md", "diffHunk": "@@ -0,0 +1,715 @@\n+# KLIP 26 - Java client interfaces\n+\n+**Author**: Victoria Xia (@vcrfxia) | \n+**Release Target**: ksqlDB 0.10.0 | \n+**Status**: _In development_ | \n+**Discussion**: TBD\n+\n+**tl;dr:** _[KLIP 15](./klip-15-new-api-and-client.md) already made the case for why it makes sense\n+           to introduce a Java client for ksqlDB. This KLIP proposes interfaces for the client._\n+\n+## Motivation and background\n+\n+See [KLIP 15](./klip-15-new-api-and-client.md).\n+\n+## What is in scope\n+\n+The Java client will support the following operations:\n+* Push query\n+* Pull query\n+* Select DDL/DML operations:\n+    * `CREATE STREAM`\n+    * `CREATE TABLE`\n+    * `CREATE STREAM ... AS SELECT`\n+    * `CREATE TABLE ... AS SELECT`\n+    * `DROP STREAM`\n+    * `DROP TABLE`\n+    * `INSERT INTO`\n+    * `TERMINATE <queryId>`\n+    * `CREATE CONNECTOR`\n+    * `DROP CONNECTOR`\n+* Select admin operations:\n+    * `SHOW TOPICS` (non-extended)\n+    * `SHOW STREAMS` (non-extended)\n+    * `SHOW TABLES` (non-extended)\n+    * `SHOW QUERIES` (non-extended)\n+    * `SHOW CONNECTORS`\n+* Insert values, i.e., insert rows into an existing stream/table\n+* Terminate push query (via the `/close-query` endpoint)\n+\n+The purpose of this KLIP is to reach agreement on the interfaces / public APIs.\n+Implementation details will not be covered.\n+\n+## What is not in scope\n+\n+This KLIP does not cover Java client support for the following:\n+* `DESCRIBE <stream/table>`, `DESCRIBE CONNECTOR`, `DESCRIBE FUNCTION`\n+* `EXPLAIN <queryId>`\n+* `PRINT <topic>`\n+* `SHOW TOPICS EXTENDED`, `SHOW <STREAMS/TABLES> EXTENDED`, `SHOW QUERIES EXTENDED`\n+* `CREATE TYPE`, `DROP TYPE`, `SHOW TYPES`\n+* `SHOW FUNCTIONS`, `SHOW PROPERTIES`\n+* `RUN SCRIPT`\n+* Use of other endpoints (info, healthcheck, terminate cluster, status, etc.)\n+\n+We can always add support for these operations in the future if desired.\n+\n+As above, implementation details are out of scope as the purpose of this KLIP is to reach agreement\n+on the interfaces / public APIs.\n+\n+## Value/Return\n+\n+See [KLIP 15](./klip-15-new-api-and-client.md).\n+\n+## Public APIS\n+\n+The following subsections describe the methods of the `Client` interface:\n+```\n+public interface Client {\n+    ...\n+}\n+```\n+\n+### Constructors\n+```\n+  static Client create(ClientOptions clientOptions) {\n+    return new ClientImpl(clientOptions);\n+  }\n+\n+  static Client create(ClientOptions clientOptions, Vertx vertx) {\n+    return new ClientImpl(clientOptions, vertx);\n+  }\n+```\n+\n+The Java client will be implemented as a Vert.x HttpClient. We expose a constructor that allows users to provide their own `Vertx` instance\n+in order to take advantage of a shared connection pool and other properties if desired.\n+\n+`ClientOptions` will initially be as follows:\n+```\n+public interface ClientOptions {\n+\n+  ClientOptions setHost(String host);\n+\n+  ClientOptions setPort(int port);\n+\n+  ClientOptions setUseTls(boolean useTls);\n+\n+  ClientOptions setUseClientAuth(boolean useClientAuth);\n+\n+  ClientOptions setTrustStore(String trustStorePath);\n+\n+  ClientOptions setTrustStorePassword(String trustStorePassword);\n+\n+  ClientOptions setKeyStore(String keyStorePath);\n+\n+  ClientOptions setKeyStorePassword(String keyStorePassword);\n+\n+  ClientOptions setBasicAuthCredentials(String username, String password);\n+\n+  String getHost();\n+\n+  int getPort();\n+\n+  boolean isUseTls();\n+\n+  boolean isUseClientAuth();\n+\n+  boolean isUseBasicAuth();\n+\n+  String getTrustStore();\n+\n+  String getTrustStorePassword();\n+\n+  String getKeyStore();\n+\n+  String getKeyStorePassword();\n+\n+  String getBasicAuthUsername();\n+\n+  String getBasicAuthPassword();\n+\n+  ClientOptions copy();\n+\n+  static ClientOptions create() {\n+    return new ClientOptionsImpl();\n+  }\n+}\n+```\n+\n+We can always add additional configuration options later. We may also wish to expose the Vert.x `HttpClientOptions` for\n+advanced users that wish to provide custom configs.\n+\n+### Transient queries -- Streaming\n+\n+The `Client` interface will provide the following methods for streaming the results of a transient (push or pull) query:\n+```\n+  /**\n+   * Execute a query (push or pull) and receive the results one row at a time.\n+   *\n+   * @param sql statement of query to execute.\n+   * @return query result.\n+   */\n+  CompletableFuture<QueryResult> streamQuery(String sql);\n+\n+  /**\n+   * Execute a query (push or pull) and receive the results one row at a time.\n+   *\n+   * @param sql statement of query to execute.\n+   * @param properties query properties.\n+   * @return query result.\n+   */\n+  CompletableFuture<QueryResult> streamQuery(String sql, Map<String, Object> properties);\n+```\n+where `QueryResult` is as follows:\n+```\n+/**\n+ * The result of a query (push or pull), streamed one row at time. Records may be consumed by either\n+ * subscribing to the publisher or polling (blocking) for one record at a time. These two methods of\n+ * consumption are mutually exclusive; only one method may be used (per QueryResult).\n+ */\n+public interface QueryResult extends Publisher<Row> {\n+\n+  List<String> columnNames();\n+\n+  List<String> columnTypes();\n+\n+  String queryID();\n+\n+  /**\n+   * Block until a row becomes available.\n+   *\n+   * @return the row.\n+   */\n+  Row poll();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aed38d5836550829f7fd459df31b47aaf7e5ad45"}, "originalPosition": 183}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDAzNzkwNzcx", "url": "https://github.com/confluentinc/ksql/pull/5236#pullrequestreview-403790771", "createdAt": "2020-04-30T18:53:09Z", "commit": {"oid": "aed38d5836550829f7fd459df31b47aaf7e5ad45"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0zMFQxODo1MzowOVrOGO2JhQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0zMFQxODo1MzowOVrOGO2JhQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODIyMDQyMQ==", "bodyText": "What is Publisher exactly (ie, from which library -- or is it from the Java standard library?)", "url": "https://github.com/confluentinc/ksql/pull/5236#discussion_r418220421", "createdAt": "2020-04-30T18:53:09Z", "author": {"login": "mjsax"}, "path": "design-proposals/klip-26-java-client-interfaces.md", "diffHunk": "@@ -0,0 +1,715 @@\n+# KLIP 26 - Java client interfaces\n+\n+**Author**: Victoria Xia (@vcrfxia) | \n+**Release Target**: ksqlDB 0.10.0 | \n+**Status**: _In development_ | \n+**Discussion**: TBD\n+\n+**tl;dr:** _[KLIP 15](./klip-15-new-api-and-client.md) already made the case for why it makes sense\n+           to introduce a Java client for ksqlDB. This KLIP proposes interfaces for the client._\n+\n+## Motivation and background\n+\n+See [KLIP 15](./klip-15-new-api-and-client.md).\n+\n+## What is in scope\n+\n+The Java client will support the following operations:\n+* Push query\n+* Pull query\n+* Select DDL/DML operations:\n+    * `CREATE STREAM`\n+    * `CREATE TABLE`\n+    * `CREATE STREAM ... AS SELECT`\n+    * `CREATE TABLE ... AS SELECT`\n+    * `DROP STREAM`\n+    * `DROP TABLE`\n+    * `INSERT INTO`\n+    * `TERMINATE <queryId>`\n+    * `CREATE CONNECTOR`\n+    * `DROP CONNECTOR`\n+* Select admin operations:\n+    * `SHOW TOPICS` (non-extended)\n+    * `SHOW STREAMS` (non-extended)\n+    * `SHOW TABLES` (non-extended)\n+    * `SHOW QUERIES` (non-extended)\n+    * `SHOW CONNECTORS`\n+* Insert values, i.e., insert rows into an existing stream/table\n+* Terminate push query (via the `/close-query` endpoint)\n+\n+The purpose of this KLIP is to reach agreement on the interfaces / public APIs.\n+Implementation details will not be covered.\n+\n+## What is not in scope\n+\n+This KLIP does not cover Java client support for the following:\n+* `DESCRIBE <stream/table>`, `DESCRIBE CONNECTOR`, `DESCRIBE FUNCTION`\n+* `EXPLAIN <queryId>`\n+* `PRINT <topic>`\n+* `SHOW TOPICS EXTENDED`, `SHOW <STREAMS/TABLES> EXTENDED`, `SHOW QUERIES EXTENDED`\n+* `CREATE TYPE`, `DROP TYPE`, `SHOW TYPES`\n+* `SHOW FUNCTIONS`, `SHOW PROPERTIES`\n+* `RUN SCRIPT`\n+* Use of other endpoints (info, healthcheck, terminate cluster, status, etc.)\n+\n+We can always add support for these operations in the future if desired.\n+\n+As above, implementation details are out of scope as the purpose of this KLIP is to reach agreement\n+on the interfaces / public APIs.\n+\n+## Value/Return\n+\n+See [KLIP 15](./klip-15-new-api-and-client.md).\n+\n+## Public APIS\n+\n+The following subsections describe the methods of the `Client` interface:\n+```\n+public interface Client {\n+    ...\n+}\n+```\n+\n+### Constructors\n+```\n+  static Client create(ClientOptions clientOptions) {\n+    return new ClientImpl(clientOptions);\n+  }\n+\n+  static Client create(ClientOptions clientOptions, Vertx vertx) {\n+    return new ClientImpl(clientOptions, vertx);\n+  }\n+```\n+\n+The Java client will be implemented as a Vert.x HttpClient. We expose a constructor that allows users to provide their own `Vertx` instance\n+in order to take advantage of a shared connection pool and other properties if desired.\n+\n+`ClientOptions` will initially be as follows:\n+```\n+public interface ClientOptions {\n+\n+  ClientOptions setHost(String host);\n+\n+  ClientOptions setPort(int port);\n+\n+  ClientOptions setUseTls(boolean useTls);\n+\n+  ClientOptions setUseClientAuth(boolean useClientAuth);\n+\n+  ClientOptions setTrustStore(String trustStorePath);\n+\n+  ClientOptions setTrustStorePassword(String trustStorePassword);\n+\n+  ClientOptions setKeyStore(String keyStorePath);\n+\n+  ClientOptions setKeyStorePassword(String keyStorePassword);\n+\n+  ClientOptions setBasicAuthCredentials(String username, String password);\n+\n+  String getHost();\n+\n+  int getPort();\n+\n+  boolean isUseTls();\n+\n+  boolean isUseClientAuth();\n+\n+  boolean isUseBasicAuth();\n+\n+  String getTrustStore();\n+\n+  String getTrustStorePassword();\n+\n+  String getKeyStore();\n+\n+  String getKeyStorePassword();\n+\n+  String getBasicAuthUsername();\n+\n+  String getBasicAuthPassword();\n+\n+  ClientOptions copy();\n+\n+  static ClientOptions create() {\n+    return new ClientOptionsImpl();\n+  }\n+}\n+```\n+\n+We can always add additional configuration options later. We may also wish to expose the Vert.x `HttpClientOptions` for\n+advanced users that wish to provide custom configs.\n+\n+### Transient queries -- Streaming\n+\n+The `Client` interface will provide the following methods for streaming the results of a transient (push or pull) query:\n+```\n+  /**\n+   * Execute a query (push or pull) and receive the results one row at a time.\n+   *\n+   * @param sql statement of query to execute.\n+   * @return query result.\n+   */\n+  CompletableFuture<QueryResult> streamQuery(String sql);\n+\n+  /**\n+   * Execute a query (push or pull) and receive the results one row at a time.\n+   *\n+   * @param sql statement of query to execute.\n+   * @param properties query properties.\n+   * @return query result.\n+   */\n+  CompletableFuture<QueryResult> streamQuery(String sql, Map<String, Object> properties);\n+```\n+where `QueryResult` is as follows:\n+```\n+/**\n+ * The result of a query (push or pull), streamed one row at time. Records may be consumed by either\n+ * subscribing to the publisher or polling (blocking) for one record at a time. These two methods of\n+ * consumption are mutually exclusive; only one method may be used (per QueryResult).\n+ */\n+public interface QueryResult extends Publisher<Row> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aed38d5836550829f7fd459df31b47aaf7e5ad45"}, "originalPosition": 170}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDAzNzkxMTE4", "url": "https://github.com/confluentinc/ksql/pull/5236#pullrequestreview-403791118", "createdAt": "2020-04-30T18:53:40Z", "commit": {"oid": "aed38d5836550829f7fd459df31b47aaf7e5ad45"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0zMFQxODo1Mzo0MFrOGO2Kkw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0zMFQxODo1Mzo0MFrOGO2Kkw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODIyMDY5MQ==", "bodyText": "Only one of the two methods will be allowed\n\nCan you elaborate?", "url": "https://github.com/confluentinc/ksql/pull/5236#discussion_r418220691", "createdAt": "2020-04-30T18:53:40Z", "author": {"login": "mjsax"}, "path": "design-proposals/klip-26-java-client-interfaces.md", "diffHunk": "@@ -0,0 +1,715 @@\n+# KLIP 26 - Java client interfaces\n+\n+**Author**: Victoria Xia (@vcrfxia) | \n+**Release Target**: ksqlDB 0.10.0 | \n+**Status**: _In development_ | \n+**Discussion**: TBD\n+\n+**tl;dr:** _[KLIP 15](./klip-15-new-api-and-client.md) already made the case for why it makes sense\n+           to introduce a Java client for ksqlDB. This KLIP proposes interfaces for the client._\n+\n+## Motivation and background\n+\n+See [KLIP 15](./klip-15-new-api-and-client.md).\n+\n+## What is in scope\n+\n+The Java client will support the following operations:\n+* Push query\n+* Pull query\n+* Select DDL/DML operations:\n+    * `CREATE STREAM`\n+    * `CREATE TABLE`\n+    * `CREATE STREAM ... AS SELECT`\n+    * `CREATE TABLE ... AS SELECT`\n+    * `DROP STREAM`\n+    * `DROP TABLE`\n+    * `INSERT INTO`\n+    * `TERMINATE <queryId>`\n+    * `CREATE CONNECTOR`\n+    * `DROP CONNECTOR`\n+* Select admin operations:\n+    * `SHOW TOPICS` (non-extended)\n+    * `SHOW STREAMS` (non-extended)\n+    * `SHOW TABLES` (non-extended)\n+    * `SHOW QUERIES` (non-extended)\n+    * `SHOW CONNECTORS`\n+* Insert values, i.e., insert rows into an existing stream/table\n+* Terminate push query (via the `/close-query` endpoint)\n+\n+The purpose of this KLIP is to reach agreement on the interfaces / public APIs.\n+Implementation details will not be covered.\n+\n+## What is not in scope\n+\n+This KLIP does not cover Java client support for the following:\n+* `DESCRIBE <stream/table>`, `DESCRIBE CONNECTOR`, `DESCRIBE FUNCTION`\n+* `EXPLAIN <queryId>`\n+* `PRINT <topic>`\n+* `SHOW TOPICS EXTENDED`, `SHOW <STREAMS/TABLES> EXTENDED`, `SHOW QUERIES EXTENDED`\n+* `CREATE TYPE`, `DROP TYPE`, `SHOW TYPES`\n+* `SHOW FUNCTIONS`, `SHOW PROPERTIES`\n+* `RUN SCRIPT`\n+* Use of other endpoints (info, healthcheck, terminate cluster, status, etc.)\n+\n+We can always add support for these operations in the future if desired.\n+\n+As above, implementation details are out of scope as the purpose of this KLIP is to reach agreement\n+on the interfaces / public APIs.\n+\n+## Value/Return\n+\n+See [KLIP 15](./klip-15-new-api-and-client.md).\n+\n+## Public APIS\n+\n+The following subsections describe the methods of the `Client` interface:\n+```\n+public interface Client {\n+    ...\n+}\n+```\n+\n+### Constructors\n+```\n+  static Client create(ClientOptions clientOptions) {\n+    return new ClientImpl(clientOptions);\n+  }\n+\n+  static Client create(ClientOptions clientOptions, Vertx vertx) {\n+    return new ClientImpl(clientOptions, vertx);\n+  }\n+```\n+\n+The Java client will be implemented as a Vert.x HttpClient. We expose a constructor that allows users to provide their own `Vertx` instance\n+in order to take advantage of a shared connection pool and other properties if desired.\n+\n+`ClientOptions` will initially be as follows:\n+```\n+public interface ClientOptions {\n+\n+  ClientOptions setHost(String host);\n+\n+  ClientOptions setPort(int port);\n+\n+  ClientOptions setUseTls(boolean useTls);\n+\n+  ClientOptions setUseClientAuth(boolean useClientAuth);\n+\n+  ClientOptions setTrustStore(String trustStorePath);\n+\n+  ClientOptions setTrustStorePassword(String trustStorePassword);\n+\n+  ClientOptions setKeyStore(String keyStorePath);\n+\n+  ClientOptions setKeyStorePassword(String keyStorePassword);\n+\n+  ClientOptions setBasicAuthCredentials(String username, String password);\n+\n+  String getHost();\n+\n+  int getPort();\n+\n+  boolean isUseTls();\n+\n+  boolean isUseClientAuth();\n+\n+  boolean isUseBasicAuth();\n+\n+  String getTrustStore();\n+\n+  String getTrustStorePassword();\n+\n+  String getKeyStore();\n+\n+  String getKeyStorePassword();\n+\n+  String getBasicAuthUsername();\n+\n+  String getBasicAuthPassword();\n+\n+  ClientOptions copy();\n+\n+  static ClientOptions create() {\n+    return new ClientOptionsImpl();\n+  }\n+}\n+```\n+\n+We can always add additional configuration options later. We may also wish to expose the Vert.x `HttpClientOptions` for\n+advanced users that wish to provide custom configs.\n+\n+### Transient queries -- Streaming\n+\n+The `Client` interface will provide the following methods for streaming the results of a transient (push or pull) query:\n+```\n+  /**\n+   * Execute a query (push or pull) and receive the results one row at a time.\n+   *\n+   * @param sql statement of query to execute.\n+   * @return query result.\n+   */\n+  CompletableFuture<QueryResult> streamQuery(String sql);\n+\n+  /**\n+   * Execute a query (push or pull) and receive the results one row at a time.\n+   *\n+   * @param sql statement of query to execute.\n+   * @param properties query properties.\n+   * @return query result.\n+   */\n+  CompletableFuture<QueryResult> streamQuery(String sql, Map<String, Object> properties);\n+```\n+where `QueryResult` is as follows:\n+```\n+/**\n+ * The result of a query (push or pull), streamed one row at time. Records may be consumed by either\n+ * subscribing to the publisher or polling (blocking) for one record at a time. These two methods of\n+ * consumption are mutually exclusive; only one method may be used (per QueryResult).\n+ */\n+public interface QueryResult extends Publisher<Row> {\n+\n+  List<String> columnNames();\n+\n+  List<String> columnTypes();\n+\n+  String queryID();\n+\n+  /**\n+   * Block until a row becomes available.\n+   *\n+   * @return the row.\n+   */\n+  Row poll();\n+\n+  /**\n+   * Block until a row becomes available or the timeout has elapsed.\n+   *\n+   * @param timeout amount of to wait for a row. Non-positive values are interpreted as no timeout.\n+   * @param timeUnit unit for timeout param.\n+   * @return the row, if available; else, null.\n+   */\n+  Row poll(long timeout, TimeUnit timeUnit);\n+\n+  boolean isComplete();\n+\n+  void close();\n+}\n+```\n+Note that `QueryResult` is a Reactive Streams `Publisher` so users can stream results. Users can also call `poll()` to receive\n+results in a synchronous fashion instead. Only one of the two methods will be allowed per `QueryResult` instance.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aed38d5836550829f7fd459df31b47aaf7e5ad45"}, "originalPosition": 200}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDAzODIyMDE1", "url": "https://github.com/confluentinc/ksql/pull/5236#pullrequestreview-403822015", "createdAt": "2020-04-30T19:39:35Z", "commit": {"oid": "aed38d5836550829f7fd459df31b47aaf7e5ad45"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0zMFQxOTozOTozNVrOGO3o5g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0zMFQxOTozOTozNVrOGO3o5g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODI0NDgzOA==", "bodyText": "Should we introduce a proper type class (or enum) instead of String?", "url": "https://github.com/confluentinc/ksql/pull/5236#discussion_r418244838", "createdAt": "2020-04-30T19:39:35Z", "author": {"login": "mjsax"}, "path": "design-proposals/klip-26-java-client-interfaces.md", "diffHunk": "@@ -0,0 +1,715 @@\n+# KLIP 26 - Java client interfaces\n+\n+**Author**: Victoria Xia (@vcrfxia) | \n+**Release Target**: ksqlDB 0.10.0 | \n+**Status**: _In development_ | \n+**Discussion**: TBD\n+\n+**tl;dr:** _[KLIP 15](./klip-15-new-api-and-client.md) already made the case for why it makes sense\n+           to introduce a Java client for ksqlDB. This KLIP proposes interfaces for the client._\n+\n+## Motivation and background\n+\n+See [KLIP 15](./klip-15-new-api-and-client.md).\n+\n+## What is in scope\n+\n+The Java client will support the following operations:\n+* Push query\n+* Pull query\n+* Select DDL/DML operations:\n+    * `CREATE STREAM`\n+    * `CREATE TABLE`\n+    * `CREATE STREAM ... AS SELECT`\n+    * `CREATE TABLE ... AS SELECT`\n+    * `DROP STREAM`\n+    * `DROP TABLE`\n+    * `INSERT INTO`\n+    * `TERMINATE <queryId>`\n+    * `CREATE CONNECTOR`\n+    * `DROP CONNECTOR`\n+* Select admin operations:\n+    * `SHOW TOPICS` (non-extended)\n+    * `SHOW STREAMS` (non-extended)\n+    * `SHOW TABLES` (non-extended)\n+    * `SHOW QUERIES` (non-extended)\n+    * `SHOW CONNECTORS`\n+* Insert values, i.e., insert rows into an existing stream/table\n+* Terminate push query (via the `/close-query` endpoint)\n+\n+The purpose of this KLIP is to reach agreement on the interfaces / public APIs.\n+Implementation details will not be covered.\n+\n+## What is not in scope\n+\n+This KLIP does not cover Java client support for the following:\n+* `DESCRIBE <stream/table>`, `DESCRIBE CONNECTOR`, `DESCRIBE FUNCTION`\n+* `EXPLAIN <queryId>`\n+* `PRINT <topic>`\n+* `SHOW TOPICS EXTENDED`, `SHOW <STREAMS/TABLES> EXTENDED`, `SHOW QUERIES EXTENDED`\n+* `CREATE TYPE`, `DROP TYPE`, `SHOW TYPES`\n+* `SHOW FUNCTIONS`, `SHOW PROPERTIES`\n+* `RUN SCRIPT`\n+* Use of other endpoints (info, healthcheck, terminate cluster, status, etc.)\n+\n+We can always add support for these operations in the future if desired.\n+\n+As above, implementation details are out of scope as the purpose of this KLIP is to reach agreement\n+on the interfaces / public APIs.\n+\n+## Value/Return\n+\n+See [KLIP 15](./klip-15-new-api-and-client.md).\n+\n+## Public APIS\n+\n+The following subsections describe the methods of the `Client` interface:\n+```\n+public interface Client {\n+    ...\n+}\n+```\n+\n+### Constructors\n+```\n+  static Client create(ClientOptions clientOptions) {\n+    return new ClientImpl(clientOptions);\n+  }\n+\n+  static Client create(ClientOptions clientOptions, Vertx vertx) {\n+    return new ClientImpl(clientOptions, vertx);\n+  }\n+```\n+\n+The Java client will be implemented as a Vert.x HttpClient. We expose a constructor that allows users to provide their own `Vertx` instance\n+in order to take advantage of a shared connection pool and other properties if desired.\n+\n+`ClientOptions` will initially be as follows:\n+```\n+public interface ClientOptions {\n+\n+  ClientOptions setHost(String host);\n+\n+  ClientOptions setPort(int port);\n+\n+  ClientOptions setUseTls(boolean useTls);\n+\n+  ClientOptions setUseClientAuth(boolean useClientAuth);\n+\n+  ClientOptions setTrustStore(String trustStorePath);\n+\n+  ClientOptions setTrustStorePassword(String trustStorePassword);\n+\n+  ClientOptions setKeyStore(String keyStorePath);\n+\n+  ClientOptions setKeyStorePassword(String keyStorePassword);\n+\n+  ClientOptions setBasicAuthCredentials(String username, String password);\n+\n+  String getHost();\n+\n+  int getPort();\n+\n+  boolean isUseTls();\n+\n+  boolean isUseClientAuth();\n+\n+  boolean isUseBasicAuth();\n+\n+  String getTrustStore();\n+\n+  String getTrustStorePassword();\n+\n+  String getKeyStore();\n+\n+  String getKeyStorePassword();\n+\n+  String getBasicAuthUsername();\n+\n+  String getBasicAuthPassword();\n+\n+  ClientOptions copy();\n+\n+  static ClientOptions create() {\n+    return new ClientOptionsImpl();\n+  }\n+}\n+```\n+\n+We can always add additional configuration options later. We may also wish to expose the Vert.x `HttpClientOptions` for\n+advanced users that wish to provide custom configs.\n+\n+### Transient queries -- Streaming\n+\n+The `Client` interface will provide the following methods for streaming the results of a transient (push or pull) query:\n+```\n+  /**\n+   * Execute a query (push or pull) and receive the results one row at a time.\n+   *\n+   * @param sql statement of query to execute.\n+   * @return query result.\n+   */\n+  CompletableFuture<QueryResult> streamQuery(String sql);\n+\n+  /**\n+   * Execute a query (push or pull) and receive the results one row at a time.\n+   *\n+   * @param sql statement of query to execute.\n+   * @param properties query properties.\n+   * @return query result.\n+   */\n+  CompletableFuture<QueryResult> streamQuery(String sql, Map<String, Object> properties);\n+```\n+where `QueryResult` is as follows:\n+```\n+/**\n+ * The result of a query (push or pull), streamed one row at time. Records may be consumed by either\n+ * subscribing to the publisher or polling (blocking) for one record at a time. These two methods of\n+ * consumption are mutually exclusive; only one method may be used (per QueryResult).\n+ */\n+public interface QueryResult extends Publisher<Row> {\n+\n+  List<String> columnNames();\n+\n+  List<String> columnTypes();\n+\n+  String queryID();\n+\n+  /**\n+   * Block until a row becomes available.\n+   *\n+   * @return the row.\n+   */\n+  Row poll();\n+\n+  /**\n+   * Block until a row becomes available or the timeout has elapsed.\n+   *\n+   * @param timeout amount of to wait for a row. Non-positive values are interpreted as no timeout.\n+   * @param timeUnit unit for timeout param.\n+   * @return the row, if available; else, null.\n+   */\n+  Row poll(long timeout, TimeUnit timeUnit);\n+\n+  boolean isComplete();\n+\n+  void close();\n+}\n+```\n+Note that `QueryResult` is a Reactive Streams `Publisher` so users can stream results. Users can also call `poll()` to receive\n+results in a synchronous fashion instead. Only one of the two methods will be allowed per `QueryResult` instance.\n+\n+The `Row` interface is as follows:\n+```\n+/**\n+ * A single record, returned as part of a query result.\n+ */\n+public interface Row {\n+\n+  List<String> columnNames();\n+\n+  List<String> columnTypes();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aed38d5836550829f7fd459df31b47aaf7e5ad45"}, "originalPosition": 211}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDAzODIzNTE4", "url": "https://github.com/confluentinc/ksql/pull/5236#pullrequestreview-403823518", "createdAt": "2020-04-30T19:41:55Z", "commit": {"oid": "aed38d5836550829f7fd459df31b47aaf7e5ad45"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0zMFQxOTo0MTo1NVrOGO3toQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0zMFQxOTo0MTo1NVrOGO3toQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODI0NjA0OQ==", "bodyText": "I assume we return Integer instead if int to handle NULL ?\nWould it make sense to add isNull(int columnIndex) and isNotNull(int columnIndex), too? (also for columnName)", "url": "https://github.com/confluentinc/ksql/pull/5236#discussion_r418246049", "createdAt": "2020-04-30T19:41:55Z", "author": {"login": "mjsax"}, "path": "design-proposals/klip-26-java-client-interfaces.md", "diffHunk": "@@ -0,0 +1,715 @@\n+# KLIP 26 - Java client interfaces\n+\n+**Author**: Victoria Xia (@vcrfxia) | \n+**Release Target**: ksqlDB 0.10.0 | \n+**Status**: _In development_ | \n+**Discussion**: TBD\n+\n+**tl;dr:** _[KLIP 15](./klip-15-new-api-and-client.md) already made the case for why it makes sense\n+           to introduce a Java client for ksqlDB. This KLIP proposes interfaces for the client._\n+\n+## Motivation and background\n+\n+See [KLIP 15](./klip-15-new-api-and-client.md).\n+\n+## What is in scope\n+\n+The Java client will support the following operations:\n+* Push query\n+* Pull query\n+* Select DDL/DML operations:\n+    * `CREATE STREAM`\n+    * `CREATE TABLE`\n+    * `CREATE STREAM ... AS SELECT`\n+    * `CREATE TABLE ... AS SELECT`\n+    * `DROP STREAM`\n+    * `DROP TABLE`\n+    * `INSERT INTO`\n+    * `TERMINATE <queryId>`\n+    * `CREATE CONNECTOR`\n+    * `DROP CONNECTOR`\n+* Select admin operations:\n+    * `SHOW TOPICS` (non-extended)\n+    * `SHOW STREAMS` (non-extended)\n+    * `SHOW TABLES` (non-extended)\n+    * `SHOW QUERIES` (non-extended)\n+    * `SHOW CONNECTORS`\n+* Insert values, i.e., insert rows into an existing stream/table\n+* Terminate push query (via the `/close-query` endpoint)\n+\n+The purpose of this KLIP is to reach agreement on the interfaces / public APIs.\n+Implementation details will not be covered.\n+\n+## What is not in scope\n+\n+This KLIP does not cover Java client support for the following:\n+* `DESCRIBE <stream/table>`, `DESCRIBE CONNECTOR`, `DESCRIBE FUNCTION`\n+* `EXPLAIN <queryId>`\n+* `PRINT <topic>`\n+* `SHOW TOPICS EXTENDED`, `SHOW <STREAMS/TABLES> EXTENDED`, `SHOW QUERIES EXTENDED`\n+* `CREATE TYPE`, `DROP TYPE`, `SHOW TYPES`\n+* `SHOW FUNCTIONS`, `SHOW PROPERTIES`\n+* `RUN SCRIPT`\n+* Use of other endpoints (info, healthcheck, terminate cluster, status, etc.)\n+\n+We can always add support for these operations in the future if desired.\n+\n+As above, implementation details are out of scope as the purpose of this KLIP is to reach agreement\n+on the interfaces / public APIs.\n+\n+## Value/Return\n+\n+See [KLIP 15](./klip-15-new-api-and-client.md).\n+\n+## Public APIS\n+\n+The following subsections describe the methods of the `Client` interface:\n+```\n+public interface Client {\n+    ...\n+}\n+```\n+\n+### Constructors\n+```\n+  static Client create(ClientOptions clientOptions) {\n+    return new ClientImpl(clientOptions);\n+  }\n+\n+  static Client create(ClientOptions clientOptions, Vertx vertx) {\n+    return new ClientImpl(clientOptions, vertx);\n+  }\n+```\n+\n+The Java client will be implemented as a Vert.x HttpClient. We expose a constructor that allows users to provide their own `Vertx` instance\n+in order to take advantage of a shared connection pool and other properties if desired.\n+\n+`ClientOptions` will initially be as follows:\n+```\n+public interface ClientOptions {\n+\n+  ClientOptions setHost(String host);\n+\n+  ClientOptions setPort(int port);\n+\n+  ClientOptions setUseTls(boolean useTls);\n+\n+  ClientOptions setUseClientAuth(boolean useClientAuth);\n+\n+  ClientOptions setTrustStore(String trustStorePath);\n+\n+  ClientOptions setTrustStorePassword(String trustStorePassword);\n+\n+  ClientOptions setKeyStore(String keyStorePath);\n+\n+  ClientOptions setKeyStorePassword(String keyStorePassword);\n+\n+  ClientOptions setBasicAuthCredentials(String username, String password);\n+\n+  String getHost();\n+\n+  int getPort();\n+\n+  boolean isUseTls();\n+\n+  boolean isUseClientAuth();\n+\n+  boolean isUseBasicAuth();\n+\n+  String getTrustStore();\n+\n+  String getTrustStorePassword();\n+\n+  String getKeyStore();\n+\n+  String getKeyStorePassword();\n+\n+  String getBasicAuthUsername();\n+\n+  String getBasicAuthPassword();\n+\n+  ClientOptions copy();\n+\n+  static ClientOptions create() {\n+    return new ClientOptionsImpl();\n+  }\n+}\n+```\n+\n+We can always add additional configuration options later. We may also wish to expose the Vert.x `HttpClientOptions` for\n+advanced users that wish to provide custom configs.\n+\n+### Transient queries -- Streaming\n+\n+The `Client` interface will provide the following methods for streaming the results of a transient (push or pull) query:\n+```\n+  /**\n+   * Execute a query (push or pull) and receive the results one row at a time.\n+   *\n+   * @param sql statement of query to execute.\n+   * @return query result.\n+   */\n+  CompletableFuture<QueryResult> streamQuery(String sql);\n+\n+  /**\n+   * Execute a query (push or pull) and receive the results one row at a time.\n+   *\n+   * @param sql statement of query to execute.\n+   * @param properties query properties.\n+   * @return query result.\n+   */\n+  CompletableFuture<QueryResult> streamQuery(String sql, Map<String, Object> properties);\n+```\n+where `QueryResult` is as follows:\n+```\n+/**\n+ * The result of a query (push or pull), streamed one row at time. Records may be consumed by either\n+ * subscribing to the publisher or polling (blocking) for one record at a time. These two methods of\n+ * consumption are mutually exclusive; only one method may be used (per QueryResult).\n+ */\n+public interface QueryResult extends Publisher<Row> {\n+\n+  List<String> columnNames();\n+\n+  List<String> columnTypes();\n+\n+  String queryID();\n+\n+  /**\n+   * Block until a row becomes available.\n+   *\n+   * @return the row.\n+   */\n+  Row poll();\n+\n+  /**\n+   * Block until a row becomes available or the timeout has elapsed.\n+   *\n+   * @param timeout amount of to wait for a row. Non-positive values are interpreted as no timeout.\n+   * @param timeUnit unit for timeout param.\n+   * @return the row, if available; else, null.\n+   */\n+  Row poll(long timeout, TimeUnit timeUnit);\n+\n+  boolean isComplete();\n+\n+  void close();\n+}\n+```\n+Note that `QueryResult` is a Reactive Streams `Publisher` so users can stream results. Users can also call `poll()` to receive\n+results in a synchronous fashion instead. Only one of the two methods will be allowed per `QueryResult` instance.\n+\n+The `Row` interface is as follows:\n+```\n+/**\n+ * A single record, returned as part of a query result.\n+ */\n+public interface Row {\n+\n+  List<String> columnNames();\n+\n+  List<String> columnTypes();\n+\n+  List<Object> values();\n+\n+  /**\n+   * Get the value for a particular column of the Row as an Object.\n+   *\n+   * @param columnIndex index of column (1-indexed).\n+   * @return column value.\n+   */\n+  Object getObject(int columnIndex);\n+\n+  /**\n+   * Get the value for a particular column of the Row as an Object.\n+   *\n+   * @param columnName name of column.\n+   * @return column value.\n+   */\n+  Object getObject(String columnName);\n+\n+  /**\n+   * Get the value for a particular column of the Row as a string.\n+   *\n+   * @param columnIndex index of column (1-indexed).\n+   * @return column value.\n+   */\n+  String getString(int columnIndex);\n+\n+  /**\n+   * Get the value for a particular column of the Row as a string.\n+   *\n+   * @param columnName name of column.\n+   * @return column value.\n+   */\n+  String getString(String columnName);\n+\n+  /**\n+   * Get the value for a particular column of the Row as an integer.\n+   *\n+   * @param columnIndex index of column (1-indexed).\n+   * @return column value.\n+   */\n+  Integer getInt(int columnIndex);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aed38d5836550829f7fd459df31b47aaf7e5ad45"}, "originalPosition": 253}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDAzODI1MTEx", "url": "https://github.com/confluentinc/ksql/pull/5236#pullrequestreview-403825111", "createdAt": "2020-04-30T19:44:23Z", "commit": {"oid": "aed38d5836550829f7fd459df31b47aaf7e5ad45"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0zMFQxOTo0NDoyNFrOGO3ygw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0zMFQxOTo0NDoyNFrOGO3ygw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODI0NzI5OQ==", "bodyText": "Should there be helpers for nested types, too? Or is getObject() plus casting the intended way to handle them?", "url": "https://github.com/confluentinc/ksql/pull/5236#discussion_r418247299", "createdAt": "2020-04-30T19:44:24Z", "author": {"login": "mjsax"}, "path": "design-proposals/klip-26-java-client-interfaces.md", "diffHunk": "@@ -0,0 +1,715 @@\n+# KLIP 26 - Java client interfaces\n+\n+**Author**: Victoria Xia (@vcrfxia) | \n+**Release Target**: ksqlDB 0.10.0 | \n+**Status**: _In development_ | \n+**Discussion**: TBD\n+\n+**tl;dr:** _[KLIP 15](./klip-15-new-api-and-client.md) already made the case for why it makes sense\n+           to introduce a Java client for ksqlDB. This KLIP proposes interfaces for the client._\n+\n+## Motivation and background\n+\n+See [KLIP 15](./klip-15-new-api-and-client.md).\n+\n+## What is in scope\n+\n+The Java client will support the following operations:\n+* Push query\n+* Pull query\n+* Select DDL/DML operations:\n+    * `CREATE STREAM`\n+    * `CREATE TABLE`\n+    * `CREATE STREAM ... AS SELECT`\n+    * `CREATE TABLE ... AS SELECT`\n+    * `DROP STREAM`\n+    * `DROP TABLE`\n+    * `INSERT INTO`\n+    * `TERMINATE <queryId>`\n+    * `CREATE CONNECTOR`\n+    * `DROP CONNECTOR`\n+* Select admin operations:\n+    * `SHOW TOPICS` (non-extended)\n+    * `SHOW STREAMS` (non-extended)\n+    * `SHOW TABLES` (non-extended)\n+    * `SHOW QUERIES` (non-extended)\n+    * `SHOW CONNECTORS`\n+* Insert values, i.e., insert rows into an existing stream/table\n+* Terminate push query (via the `/close-query` endpoint)\n+\n+The purpose of this KLIP is to reach agreement on the interfaces / public APIs.\n+Implementation details will not be covered.\n+\n+## What is not in scope\n+\n+This KLIP does not cover Java client support for the following:\n+* `DESCRIBE <stream/table>`, `DESCRIBE CONNECTOR`, `DESCRIBE FUNCTION`\n+* `EXPLAIN <queryId>`\n+* `PRINT <topic>`\n+* `SHOW TOPICS EXTENDED`, `SHOW <STREAMS/TABLES> EXTENDED`, `SHOW QUERIES EXTENDED`\n+* `CREATE TYPE`, `DROP TYPE`, `SHOW TYPES`\n+* `SHOW FUNCTIONS`, `SHOW PROPERTIES`\n+* `RUN SCRIPT`\n+* Use of other endpoints (info, healthcheck, terminate cluster, status, etc.)\n+\n+We can always add support for these operations in the future if desired.\n+\n+As above, implementation details are out of scope as the purpose of this KLIP is to reach agreement\n+on the interfaces / public APIs.\n+\n+## Value/Return\n+\n+See [KLIP 15](./klip-15-new-api-and-client.md).\n+\n+## Public APIS\n+\n+The following subsections describe the methods of the `Client` interface:\n+```\n+public interface Client {\n+    ...\n+}\n+```\n+\n+### Constructors\n+```\n+  static Client create(ClientOptions clientOptions) {\n+    return new ClientImpl(clientOptions);\n+  }\n+\n+  static Client create(ClientOptions clientOptions, Vertx vertx) {\n+    return new ClientImpl(clientOptions, vertx);\n+  }\n+```\n+\n+The Java client will be implemented as a Vert.x HttpClient. We expose a constructor that allows users to provide their own `Vertx` instance\n+in order to take advantage of a shared connection pool and other properties if desired.\n+\n+`ClientOptions` will initially be as follows:\n+```\n+public interface ClientOptions {\n+\n+  ClientOptions setHost(String host);\n+\n+  ClientOptions setPort(int port);\n+\n+  ClientOptions setUseTls(boolean useTls);\n+\n+  ClientOptions setUseClientAuth(boolean useClientAuth);\n+\n+  ClientOptions setTrustStore(String trustStorePath);\n+\n+  ClientOptions setTrustStorePassword(String trustStorePassword);\n+\n+  ClientOptions setKeyStore(String keyStorePath);\n+\n+  ClientOptions setKeyStorePassword(String keyStorePassword);\n+\n+  ClientOptions setBasicAuthCredentials(String username, String password);\n+\n+  String getHost();\n+\n+  int getPort();\n+\n+  boolean isUseTls();\n+\n+  boolean isUseClientAuth();\n+\n+  boolean isUseBasicAuth();\n+\n+  String getTrustStore();\n+\n+  String getTrustStorePassword();\n+\n+  String getKeyStore();\n+\n+  String getKeyStorePassword();\n+\n+  String getBasicAuthUsername();\n+\n+  String getBasicAuthPassword();\n+\n+  ClientOptions copy();\n+\n+  static ClientOptions create() {\n+    return new ClientOptionsImpl();\n+  }\n+}\n+```\n+\n+We can always add additional configuration options later. We may also wish to expose the Vert.x `HttpClientOptions` for\n+advanced users that wish to provide custom configs.\n+\n+### Transient queries -- Streaming\n+\n+The `Client` interface will provide the following methods for streaming the results of a transient (push or pull) query:\n+```\n+  /**\n+   * Execute a query (push or pull) and receive the results one row at a time.\n+   *\n+   * @param sql statement of query to execute.\n+   * @return query result.\n+   */\n+  CompletableFuture<QueryResult> streamQuery(String sql);\n+\n+  /**\n+   * Execute a query (push or pull) and receive the results one row at a time.\n+   *\n+   * @param sql statement of query to execute.\n+   * @param properties query properties.\n+   * @return query result.\n+   */\n+  CompletableFuture<QueryResult> streamQuery(String sql, Map<String, Object> properties);\n+```\n+where `QueryResult` is as follows:\n+```\n+/**\n+ * The result of a query (push or pull), streamed one row at time. Records may be consumed by either\n+ * subscribing to the publisher or polling (blocking) for one record at a time. These two methods of\n+ * consumption are mutually exclusive; only one method may be used (per QueryResult).\n+ */\n+public interface QueryResult extends Publisher<Row> {\n+\n+  List<String> columnNames();\n+\n+  List<String> columnTypes();\n+\n+  String queryID();\n+\n+  /**\n+   * Block until a row becomes available.\n+   *\n+   * @return the row.\n+   */\n+  Row poll();\n+\n+  /**\n+   * Block until a row becomes available or the timeout has elapsed.\n+   *\n+   * @param timeout amount of to wait for a row. Non-positive values are interpreted as no timeout.\n+   * @param timeUnit unit for timeout param.\n+   * @return the row, if available; else, null.\n+   */\n+  Row poll(long timeout, TimeUnit timeUnit);\n+\n+  boolean isComplete();\n+\n+  void close();\n+}\n+```\n+Note that `QueryResult` is a Reactive Streams `Publisher` so users can stream results. Users can also call `poll()` to receive\n+results in a synchronous fashion instead. Only one of the two methods will be allowed per `QueryResult` instance.\n+\n+The `Row` interface is as follows:\n+```\n+/**\n+ * A single record, returned as part of a query result.\n+ */\n+public interface Row {\n+\n+  List<String> columnNames();\n+\n+  List<String> columnTypes();\n+\n+  List<Object> values();\n+\n+  /**\n+   * Get the value for a particular column of the Row as an Object.\n+   *\n+   * @param columnIndex index of column (1-indexed).\n+   * @return column value.\n+   */\n+  Object getObject(int columnIndex);\n+\n+  /**\n+   * Get the value for a particular column of the Row as an Object.\n+   *\n+   * @param columnName name of column.\n+   * @return column value.\n+   */\n+  Object getObject(String columnName);\n+\n+  /**\n+   * Get the value for a particular column of the Row as a string.\n+   *\n+   * @param columnIndex index of column (1-indexed).\n+   * @return column value.\n+   */\n+  String getString(int columnIndex);\n+\n+  /**\n+   * Get the value for a particular column of the Row as a string.\n+   *\n+   * @param columnName name of column.\n+   * @return column value.\n+   */\n+  String getString(String columnName);\n+\n+  /**\n+   * Get the value for a particular column of the Row as an integer.\n+   *\n+   * @param columnIndex index of column (1-indexed).\n+   * @return column value.\n+   */\n+  Integer getInt(int columnIndex);\n+\n+  /**\n+   * Get the value for a particular column of the Row as an integer.\n+   *\n+   * @param columnName name of column.\n+   * @return column value.\n+   */\n+  Integer getInt(String columnName);\n+\n+  /**\n+   * Get the value for a particular column of the Row as a long.\n+   *\n+   * @param columnIndex index of column (1-indexed).\n+   * @return column value.\n+   */\n+  Long getLong(int columnIndex);\n+\n+  /**\n+   * Get the value for a particular column of the Row as a long.\n+   *\n+   * @param columnName name of column.\n+   * @return column value.\n+   */\n+  Long getLong(String columnName);\n+\n+  /**\n+   * Get the value for a particular column of the Row as a double.\n+   *\n+   * @param columnIndex index of column (1-indexed).\n+   * @return column value.\n+   */\n+  Double getDouble(int columnIndex);\n+\n+  /**\n+   * Get the value for a particular column of the Row as a double.\n+   *\n+   * @param columnName name of column.\n+   * @return column value.\n+   */\n+  Double getDouble(String columnName);\n+\n+  /**\n+   * Get the value for a particular column of the Row as a boolean.\n+   *\n+   * @param columnIndex index of column (1-indexed).\n+   * @return column value.\n+   */\n+  Boolean getBoolean(int columnIndex);\n+\n+  /**\n+   * Get the value for a particular column of the Row as a boolean.\n+   *\n+   * @param columnName name of column.\n+   * @return column value.\n+   */\n+  Boolean getBoolean(String columnName);\n+\n+  /**\n+   * Get the value for a particular column of the Row as a decimal.\n+   *\n+   * @param columnIndex index of column (1-indexed).\n+   * @return column value.\n+   */\n+  BigDecimal getDecimal(int columnIndex);\n+\n+  /**\n+   * Get the value for a particular column of the Row as a decimal.\n+   *\n+   * @param columnName name of column.\n+   * @return column value.\n+   */\n+  BigDecimal getDecimal(String columnName);\n+}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aed38d5836550829f7fd459df31b47aaf7e5ad45"}, "originalPosition": 326}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDAzODI1NDY2", "url": "https://github.com/confluentinc/ksql/pull/5236#pullrequestreview-403825466", "createdAt": "2020-04-30T19:44:57Z", "commit": {"oid": "aed38d5836550829f7fd459df31b47aaf7e5ad45"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0zMFQxOTo0NDo1N1rOGO3zrQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0zMFQxOTo0NDo1N1rOGO3zrQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODI0NzU5Nw==", "bodyText": "What is the use case for this method? Should we not always return proper types?", "url": "https://github.com/confluentinc/ksql/pull/5236#discussion_r418247597", "createdAt": "2020-04-30T19:44:57Z", "author": {"login": "mjsax"}, "path": "design-proposals/klip-26-java-client-interfaces.md", "diffHunk": "@@ -0,0 +1,715 @@\n+# KLIP 26 - Java client interfaces\n+\n+**Author**: Victoria Xia (@vcrfxia) | \n+**Release Target**: ksqlDB 0.10.0 | \n+**Status**: _In development_ | \n+**Discussion**: TBD\n+\n+**tl;dr:** _[KLIP 15](./klip-15-new-api-and-client.md) already made the case for why it makes sense\n+           to introduce a Java client for ksqlDB. This KLIP proposes interfaces for the client._\n+\n+## Motivation and background\n+\n+See [KLIP 15](./klip-15-new-api-and-client.md).\n+\n+## What is in scope\n+\n+The Java client will support the following operations:\n+* Push query\n+* Pull query\n+* Select DDL/DML operations:\n+    * `CREATE STREAM`\n+    * `CREATE TABLE`\n+    * `CREATE STREAM ... AS SELECT`\n+    * `CREATE TABLE ... AS SELECT`\n+    * `DROP STREAM`\n+    * `DROP TABLE`\n+    * `INSERT INTO`\n+    * `TERMINATE <queryId>`\n+    * `CREATE CONNECTOR`\n+    * `DROP CONNECTOR`\n+* Select admin operations:\n+    * `SHOW TOPICS` (non-extended)\n+    * `SHOW STREAMS` (non-extended)\n+    * `SHOW TABLES` (non-extended)\n+    * `SHOW QUERIES` (non-extended)\n+    * `SHOW CONNECTORS`\n+* Insert values, i.e., insert rows into an existing stream/table\n+* Terminate push query (via the `/close-query` endpoint)\n+\n+The purpose of this KLIP is to reach agreement on the interfaces / public APIs.\n+Implementation details will not be covered.\n+\n+## What is not in scope\n+\n+This KLIP does not cover Java client support for the following:\n+* `DESCRIBE <stream/table>`, `DESCRIBE CONNECTOR`, `DESCRIBE FUNCTION`\n+* `EXPLAIN <queryId>`\n+* `PRINT <topic>`\n+* `SHOW TOPICS EXTENDED`, `SHOW <STREAMS/TABLES> EXTENDED`, `SHOW QUERIES EXTENDED`\n+* `CREATE TYPE`, `DROP TYPE`, `SHOW TYPES`\n+* `SHOW FUNCTIONS`, `SHOW PROPERTIES`\n+* `RUN SCRIPT`\n+* Use of other endpoints (info, healthcheck, terminate cluster, status, etc.)\n+\n+We can always add support for these operations in the future if desired.\n+\n+As above, implementation details are out of scope as the purpose of this KLIP is to reach agreement\n+on the interfaces / public APIs.\n+\n+## Value/Return\n+\n+See [KLIP 15](./klip-15-new-api-and-client.md).\n+\n+## Public APIS\n+\n+The following subsections describe the methods of the `Client` interface:\n+```\n+public interface Client {\n+    ...\n+}\n+```\n+\n+### Constructors\n+```\n+  static Client create(ClientOptions clientOptions) {\n+    return new ClientImpl(clientOptions);\n+  }\n+\n+  static Client create(ClientOptions clientOptions, Vertx vertx) {\n+    return new ClientImpl(clientOptions, vertx);\n+  }\n+```\n+\n+The Java client will be implemented as a Vert.x HttpClient. We expose a constructor that allows users to provide their own `Vertx` instance\n+in order to take advantage of a shared connection pool and other properties if desired.\n+\n+`ClientOptions` will initially be as follows:\n+```\n+public interface ClientOptions {\n+\n+  ClientOptions setHost(String host);\n+\n+  ClientOptions setPort(int port);\n+\n+  ClientOptions setUseTls(boolean useTls);\n+\n+  ClientOptions setUseClientAuth(boolean useClientAuth);\n+\n+  ClientOptions setTrustStore(String trustStorePath);\n+\n+  ClientOptions setTrustStorePassword(String trustStorePassword);\n+\n+  ClientOptions setKeyStore(String keyStorePath);\n+\n+  ClientOptions setKeyStorePassword(String keyStorePassword);\n+\n+  ClientOptions setBasicAuthCredentials(String username, String password);\n+\n+  String getHost();\n+\n+  int getPort();\n+\n+  boolean isUseTls();\n+\n+  boolean isUseClientAuth();\n+\n+  boolean isUseBasicAuth();\n+\n+  String getTrustStore();\n+\n+  String getTrustStorePassword();\n+\n+  String getKeyStore();\n+\n+  String getKeyStorePassword();\n+\n+  String getBasicAuthUsername();\n+\n+  String getBasicAuthPassword();\n+\n+  ClientOptions copy();\n+\n+  static ClientOptions create() {\n+    return new ClientOptionsImpl();\n+  }\n+}\n+```\n+\n+We can always add additional configuration options later. We may also wish to expose the Vert.x `HttpClientOptions` for\n+advanced users that wish to provide custom configs.\n+\n+### Transient queries -- Streaming\n+\n+The `Client` interface will provide the following methods for streaming the results of a transient (push or pull) query:\n+```\n+  /**\n+   * Execute a query (push or pull) and receive the results one row at a time.\n+   *\n+   * @param sql statement of query to execute.\n+   * @return query result.\n+   */\n+  CompletableFuture<QueryResult> streamQuery(String sql);\n+\n+  /**\n+   * Execute a query (push or pull) and receive the results one row at a time.\n+   *\n+   * @param sql statement of query to execute.\n+   * @param properties query properties.\n+   * @return query result.\n+   */\n+  CompletableFuture<QueryResult> streamQuery(String sql, Map<String, Object> properties);\n+```\n+where `QueryResult` is as follows:\n+```\n+/**\n+ * The result of a query (push or pull), streamed one row at time. Records may be consumed by either\n+ * subscribing to the publisher or polling (blocking) for one record at a time. These two methods of\n+ * consumption are mutually exclusive; only one method may be used (per QueryResult).\n+ */\n+public interface QueryResult extends Publisher<Row> {\n+\n+  List<String> columnNames();\n+\n+  List<String> columnTypes();\n+\n+  String queryID();\n+\n+  /**\n+   * Block until a row becomes available.\n+   *\n+   * @return the row.\n+   */\n+  Row poll();\n+\n+  /**\n+   * Block until a row becomes available or the timeout has elapsed.\n+   *\n+   * @param timeout amount of to wait for a row. Non-positive values are interpreted as no timeout.\n+   * @param timeUnit unit for timeout param.\n+   * @return the row, if available; else, null.\n+   */\n+  Row poll(long timeout, TimeUnit timeUnit);\n+\n+  boolean isComplete();\n+\n+  void close();\n+}\n+```\n+Note that `QueryResult` is a Reactive Streams `Publisher` so users can stream results. Users can also call `poll()` to receive\n+results in a synchronous fashion instead. Only one of the two methods will be allowed per `QueryResult` instance.\n+\n+The `Row` interface is as follows:\n+```\n+/**\n+ * A single record, returned as part of a query result.\n+ */\n+public interface Row {\n+\n+  List<String> columnNames();\n+\n+  List<String> columnTypes();\n+\n+  List<Object> values();\n+\n+  /**\n+   * Get the value for a particular column of the Row as an Object.\n+   *\n+   * @param columnIndex index of column (1-indexed).\n+   * @return column value.\n+   */\n+  Object getObject(int columnIndex);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aed38d5836550829f7fd459df31b47aaf7e5ad45"}, "originalPosition": 221}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDAzODI3MDY2", "url": "https://github.com/confluentinc/ksql/pull/5236#pullrequestreview-403827066", "createdAt": "2020-04-30T19:47:21Z", "commit": {"oid": "aed38d5836550829f7fd459df31b47aaf7e5ad45"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0zMFQxOTo0NzoyMVrOGO34kA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0zMFQxOTo0NzoyMVrOGO34kA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODI0ODg0OA==", "bodyText": "Why can't we expose the nested data types?", "url": "https://github.com/confluentinc/ksql/pull/5236#discussion_r418248848", "createdAt": "2020-04-30T19:47:21Z", "author": {"login": "mjsax"}, "path": "design-proposals/klip-26-java-client-interfaces.md", "diffHunk": "@@ -0,0 +1,715 @@\n+# KLIP 26 - Java client interfaces\n+\n+**Author**: Victoria Xia (@vcrfxia) | \n+**Release Target**: ksqlDB 0.10.0 | \n+**Status**: _In development_ | \n+**Discussion**: TBD\n+\n+**tl;dr:** _[KLIP 15](./klip-15-new-api-and-client.md) already made the case for why it makes sense\n+           to introduce a Java client for ksqlDB. This KLIP proposes interfaces for the client._\n+\n+## Motivation and background\n+\n+See [KLIP 15](./klip-15-new-api-and-client.md).\n+\n+## What is in scope\n+\n+The Java client will support the following operations:\n+* Push query\n+* Pull query\n+* Select DDL/DML operations:\n+    * `CREATE STREAM`\n+    * `CREATE TABLE`\n+    * `CREATE STREAM ... AS SELECT`\n+    * `CREATE TABLE ... AS SELECT`\n+    * `DROP STREAM`\n+    * `DROP TABLE`\n+    * `INSERT INTO`\n+    * `TERMINATE <queryId>`\n+    * `CREATE CONNECTOR`\n+    * `DROP CONNECTOR`\n+* Select admin operations:\n+    * `SHOW TOPICS` (non-extended)\n+    * `SHOW STREAMS` (non-extended)\n+    * `SHOW TABLES` (non-extended)\n+    * `SHOW QUERIES` (non-extended)\n+    * `SHOW CONNECTORS`\n+* Insert values, i.e., insert rows into an existing stream/table\n+* Terminate push query (via the `/close-query` endpoint)\n+\n+The purpose of this KLIP is to reach agreement on the interfaces / public APIs.\n+Implementation details will not be covered.\n+\n+## What is not in scope\n+\n+This KLIP does not cover Java client support for the following:\n+* `DESCRIBE <stream/table>`, `DESCRIBE CONNECTOR`, `DESCRIBE FUNCTION`\n+* `EXPLAIN <queryId>`\n+* `PRINT <topic>`\n+* `SHOW TOPICS EXTENDED`, `SHOW <STREAMS/TABLES> EXTENDED`, `SHOW QUERIES EXTENDED`\n+* `CREATE TYPE`, `DROP TYPE`, `SHOW TYPES`\n+* `SHOW FUNCTIONS`, `SHOW PROPERTIES`\n+* `RUN SCRIPT`\n+* Use of other endpoints (info, healthcheck, terminate cluster, status, etc.)\n+\n+We can always add support for these operations in the future if desired.\n+\n+As above, implementation details are out of scope as the purpose of this KLIP is to reach agreement\n+on the interfaces / public APIs.\n+\n+## Value/Return\n+\n+See [KLIP 15](./klip-15-new-api-and-client.md).\n+\n+## Public APIS\n+\n+The following subsections describe the methods of the `Client` interface:\n+```\n+public interface Client {\n+    ...\n+}\n+```\n+\n+### Constructors\n+```\n+  static Client create(ClientOptions clientOptions) {\n+    return new ClientImpl(clientOptions);\n+  }\n+\n+  static Client create(ClientOptions clientOptions, Vertx vertx) {\n+    return new ClientImpl(clientOptions, vertx);\n+  }\n+```\n+\n+The Java client will be implemented as a Vert.x HttpClient. We expose a constructor that allows users to provide their own `Vertx` instance\n+in order to take advantage of a shared connection pool and other properties if desired.\n+\n+`ClientOptions` will initially be as follows:\n+```\n+public interface ClientOptions {\n+\n+  ClientOptions setHost(String host);\n+\n+  ClientOptions setPort(int port);\n+\n+  ClientOptions setUseTls(boolean useTls);\n+\n+  ClientOptions setUseClientAuth(boolean useClientAuth);\n+\n+  ClientOptions setTrustStore(String trustStorePath);\n+\n+  ClientOptions setTrustStorePassword(String trustStorePassword);\n+\n+  ClientOptions setKeyStore(String keyStorePath);\n+\n+  ClientOptions setKeyStorePassword(String keyStorePassword);\n+\n+  ClientOptions setBasicAuthCredentials(String username, String password);\n+\n+  String getHost();\n+\n+  int getPort();\n+\n+  boolean isUseTls();\n+\n+  boolean isUseClientAuth();\n+\n+  boolean isUseBasicAuth();\n+\n+  String getTrustStore();\n+\n+  String getTrustStorePassword();\n+\n+  String getKeyStore();\n+\n+  String getKeyStorePassword();\n+\n+  String getBasicAuthUsername();\n+\n+  String getBasicAuthPassword();\n+\n+  ClientOptions copy();\n+\n+  static ClientOptions create() {\n+    return new ClientOptionsImpl();\n+  }\n+}\n+```\n+\n+We can always add additional configuration options later. We may also wish to expose the Vert.x `HttpClientOptions` for\n+advanced users that wish to provide custom configs.\n+\n+### Transient queries -- Streaming\n+\n+The `Client` interface will provide the following methods for streaming the results of a transient (push or pull) query:\n+```\n+  /**\n+   * Execute a query (push or pull) and receive the results one row at a time.\n+   *\n+   * @param sql statement of query to execute.\n+   * @return query result.\n+   */\n+  CompletableFuture<QueryResult> streamQuery(String sql);\n+\n+  /**\n+   * Execute a query (push or pull) and receive the results one row at a time.\n+   *\n+   * @param sql statement of query to execute.\n+   * @param properties query properties.\n+   * @return query result.\n+   */\n+  CompletableFuture<QueryResult> streamQuery(String sql, Map<String, Object> properties);\n+```\n+where `QueryResult` is as follows:\n+```\n+/**\n+ * The result of a query (push or pull), streamed one row at time. Records may be consumed by either\n+ * subscribing to the publisher or polling (blocking) for one record at a time. These two methods of\n+ * consumption are mutually exclusive; only one method may be used (per QueryResult).\n+ */\n+public interface QueryResult extends Publisher<Row> {\n+\n+  List<String> columnNames();\n+\n+  List<String> columnTypes();\n+\n+  String queryID();\n+\n+  /**\n+   * Block until a row becomes available.\n+   *\n+   * @return the row.\n+   */\n+  Row poll();\n+\n+  /**\n+   * Block until a row becomes available or the timeout has elapsed.\n+   *\n+   * @param timeout amount of to wait for a row. Non-positive values are interpreted as no timeout.\n+   * @param timeUnit unit for timeout param.\n+   * @return the row, if available; else, null.\n+   */\n+  Row poll(long timeout, TimeUnit timeUnit);\n+\n+  boolean isComplete();\n+\n+  void close();\n+}\n+```\n+Note that `QueryResult` is a Reactive Streams `Publisher` so users can stream results. Users can also call `poll()` to receive\n+results in a synchronous fashion instead. Only one of the two methods will be allowed per `QueryResult` instance.\n+\n+The `Row` interface is as follows:\n+```\n+/**\n+ * A single record, returned as part of a query result.\n+ */\n+public interface Row {\n+\n+  List<String> columnNames();\n+\n+  List<String> columnTypes();\n+\n+  List<Object> values();\n+\n+  /**\n+   * Get the value for a particular column of the Row as an Object.\n+   *\n+   * @param columnIndex index of column (1-indexed).\n+   * @return column value.\n+   */\n+  Object getObject(int columnIndex);\n+\n+  /**\n+   * Get the value for a particular column of the Row as an Object.\n+   *\n+   * @param columnName name of column.\n+   * @return column value.\n+   */\n+  Object getObject(String columnName);\n+\n+  /**\n+   * Get the value for a particular column of the Row as a string.\n+   *\n+   * @param columnIndex index of column (1-indexed).\n+   * @return column value.\n+   */\n+  String getString(int columnIndex);\n+\n+  /**\n+   * Get the value for a particular column of the Row as a string.\n+   *\n+   * @param columnName name of column.\n+   * @return column value.\n+   */\n+  String getString(String columnName);\n+\n+  /**\n+   * Get the value for a particular column of the Row as an integer.\n+   *\n+   * @param columnIndex index of column (1-indexed).\n+   * @return column value.\n+   */\n+  Integer getInt(int columnIndex);\n+\n+  /**\n+   * Get the value for a particular column of the Row as an integer.\n+   *\n+   * @param columnName name of column.\n+   * @return column value.\n+   */\n+  Integer getInt(String columnName);\n+\n+  /**\n+   * Get the value for a particular column of the Row as a long.\n+   *\n+   * @param columnIndex index of column (1-indexed).\n+   * @return column value.\n+   */\n+  Long getLong(int columnIndex);\n+\n+  /**\n+   * Get the value for a particular column of the Row as a long.\n+   *\n+   * @param columnName name of column.\n+   * @return column value.\n+   */\n+  Long getLong(String columnName);\n+\n+  /**\n+   * Get the value for a particular column of the Row as a double.\n+   *\n+   * @param columnIndex index of column (1-indexed).\n+   * @return column value.\n+   */\n+  Double getDouble(int columnIndex);\n+\n+  /**\n+   * Get the value for a particular column of the Row as a double.\n+   *\n+   * @param columnName name of column.\n+   * @return column value.\n+   */\n+  Double getDouble(String columnName);\n+\n+  /**\n+   * Get the value for a particular column of the Row as a boolean.\n+   *\n+   * @param columnIndex index of column (1-indexed).\n+   * @return column value.\n+   */\n+  Boolean getBoolean(int columnIndex);\n+\n+  /**\n+   * Get the value for a particular column of the Row as a boolean.\n+   *\n+   * @param columnName name of column.\n+   * @return column value.\n+   */\n+  Boolean getBoolean(String columnName);\n+\n+  /**\n+   * Get the value for a particular column of the Row as a decimal.\n+   *\n+   * @param columnIndex index of column (1-indexed).\n+   * @return column value.\n+   */\n+  BigDecimal getDecimal(int columnIndex);\n+\n+  /**\n+   * Get the value for a particular column of the Row as a decimal.\n+   *\n+   * @param columnName name of column.\n+   * @return column value.\n+   */\n+  BigDecimal getDecimal(String columnName);\n+}\n+```\n+\n+We considered representing column types in a more structured form (rather than plain strings) to accomodate complex/nested data types but felt this added complexity would not be helpful for most use cases. (This would also require a server-side change, so it's a fair bit of additional work.)\n+\n+For `getDecimal(...)` in the `Row` interface, rather than trying to parse the column type to extract the precision and scale, we will simply convert the value to a BigDecimal without explicitly specifying the precision and scale. We could also add an option for users to specify the scale and precision in the getter, if we think that would be useful.\n+\n+We could also add `getList(...)` and `getMap(...)` methods to the `Row` interface, but it's not clear to me how valuable this would be given that the nested data types would not be known.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aed38d5836550829f7fd459df31b47aaf7e5ad45"}, "originalPosition": 333}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDAzODI4Mzg1", "url": "https://github.com/confluentinc/ksql/pull/5236#pullrequestreview-403828385", "createdAt": "2020-04-30T19:49:22Z", "commit": {"oid": "aed38d5836550829f7fd459df31b47aaf7e5ad45"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0zMFQxOTo0OToyMlrOGO38yA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0zMFQxOTo0OToyMlrOGO38yA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODI0OTkyOA==", "bodyText": "\"push query\" and \"single batch (non-streaming)\" contradicts each other. Also the headline is \"Non-streaming\"", "url": "https://github.com/confluentinc/ksql/pull/5236#discussion_r418249928", "createdAt": "2020-04-30T19:49:22Z", "author": {"login": "mjsax"}, "path": "design-proposals/klip-26-java-client-interfaces.md", "diffHunk": "@@ -0,0 +1,715 @@\n+# KLIP 26 - Java client interfaces\n+\n+**Author**: Victoria Xia (@vcrfxia) | \n+**Release Target**: ksqlDB 0.10.0 | \n+**Status**: _In development_ | \n+**Discussion**: TBD\n+\n+**tl;dr:** _[KLIP 15](./klip-15-new-api-and-client.md) already made the case for why it makes sense\n+           to introduce a Java client for ksqlDB. This KLIP proposes interfaces for the client._\n+\n+## Motivation and background\n+\n+See [KLIP 15](./klip-15-new-api-and-client.md).\n+\n+## What is in scope\n+\n+The Java client will support the following operations:\n+* Push query\n+* Pull query\n+* Select DDL/DML operations:\n+    * `CREATE STREAM`\n+    * `CREATE TABLE`\n+    * `CREATE STREAM ... AS SELECT`\n+    * `CREATE TABLE ... AS SELECT`\n+    * `DROP STREAM`\n+    * `DROP TABLE`\n+    * `INSERT INTO`\n+    * `TERMINATE <queryId>`\n+    * `CREATE CONNECTOR`\n+    * `DROP CONNECTOR`\n+* Select admin operations:\n+    * `SHOW TOPICS` (non-extended)\n+    * `SHOW STREAMS` (non-extended)\n+    * `SHOW TABLES` (non-extended)\n+    * `SHOW QUERIES` (non-extended)\n+    * `SHOW CONNECTORS`\n+* Insert values, i.e., insert rows into an existing stream/table\n+* Terminate push query (via the `/close-query` endpoint)\n+\n+The purpose of this KLIP is to reach agreement on the interfaces / public APIs.\n+Implementation details will not be covered.\n+\n+## What is not in scope\n+\n+This KLIP does not cover Java client support for the following:\n+* `DESCRIBE <stream/table>`, `DESCRIBE CONNECTOR`, `DESCRIBE FUNCTION`\n+* `EXPLAIN <queryId>`\n+* `PRINT <topic>`\n+* `SHOW TOPICS EXTENDED`, `SHOW <STREAMS/TABLES> EXTENDED`, `SHOW QUERIES EXTENDED`\n+* `CREATE TYPE`, `DROP TYPE`, `SHOW TYPES`\n+* `SHOW FUNCTIONS`, `SHOW PROPERTIES`\n+* `RUN SCRIPT`\n+* Use of other endpoints (info, healthcheck, terminate cluster, status, etc.)\n+\n+We can always add support for these operations in the future if desired.\n+\n+As above, implementation details are out of scope as the purpose of this KLIP is to reach agreement\n+on the interfaces / public APIs.\n+\n+## Value/Return\n+\n+See [KLIP 15](./klip-15-new-api-and-client.md).\n+\n+## Public APIS\n+\n+The following subsections describe the methods of the `Client` interface:\n+```\n+public interface Client {\n+    ...\n+}\n+```\n+\n+### Constructors\n+```\n+  static Client create(ClientOptions clientOptions) {\n+    return new ClientImpl(clientOptions);\n+  }\n+\n+  static Client create(ClientOptions clientOptions, Vertx vertx) {\n+    return new ClientImpl(clientOptions, vertx);\n+  }\n+```\n+\n+The Java client will be implemented as a Vert.x HttpClient. We expose a constructor that allows users to provide their own `Vertx` instance\n+in order to take advantage of a shared connection pool and other properties if desired.\n+\n+`ClientOptions` will initially be as follows:\n+```\n+public interface ClientOptions {\n+\n+  ClientOptions setHost(String host);\n+\n+  ClientOptions setPort(int port);\n+\n+  ClientOptions setUseTls(boolean useTls);\n+\n+  ClientOptions setUseClientAuth(boolean useClientAuth);\n+\n+  ClientOptions setTrustStore(String trustStorePath);\n+\n+  ClientOptions setTrustStorePassword(String trustStorePassword);\n+\n+  ClientOptions setKeyStore(String keyStorePath);\n+\n+  ClientOptions setKeyStorePassword(String keyStorePassword);\n+\n+  ClientOptions setBasicAuthCredentials(String username, String password);\n+\n+  String getHost();\n+\n+  int getPort();\n+\n+  boolean isUseTls();\n+\n+  boolean isUseClientAuth();\n+\n+  boolean isUseBasicAuth();\n+\n+  String getTrustStore();\n+\n+  String getTrustStorePassword();\n+\n+  String getKeyStore();\n+\n+  String getKeyStorePassword();\n+\n+  String getBasicAuthUsername();\n+\n+  String getBasicAuthPassword();\n+\n+  ClientOptions copy();\n+\n+  static ClientOptions create() {\n+    return new ClientOptionsImpl();\n+  }\n+}\n+```\n+\n+We can always add additional configuration options later. We may also wish to expose the Vert.x `HttpClientOptions` for\n+advanced users that wish to provide custom configs.\n+\n+### Transient queries -- Streaming\n+\n+The `Client` interface will provide the following methods for streaming the results of a transient (push or pull) query:\n+```\n+  /**\n+   * Execute a query (push or pull) and receive the results one row at a time.\n+   *\n+   * @param sql statement of query to execute.\n+   * @return query result.\n+   */\n+  CompletableFuture<QueryResult> streamQuery(String sql);\n+\n+  /**\n+   * Execute a query (push or pull) and receive the results one row at a time.\n+   *\n+   * @param sql statement of query to execute.\n+   * @param properties query properties.\n+   * @return query result.\n+   */\n+  CompletableFuture<QueryResult> streamQuery(String sql, Map<String, Object> properties);\n+```\n+where `QueryResult` is as follows:\n+```\n+/**\n+ * The result of a query (push or pull), streamed one row at time. Records may be consumed by either\n+ * subscribing to the publisher or polling (blocking) for one record at a time. These two methods of\n+ * consumption are mutually exclusive; only one method may be used (per QueryResult).\n+ */\n+public interface QueryResult extends Publisher<Row> {\n+\n+  List<String> columnNames();\n+\n+  List<String> columnTypes();\n+\n+  String queryID();\n+\n+  /**\n+   * Block until a row becomes available.\n+   *\n+   * @return the row.\n+   */\n+  Row poll();\n+\n+  /**\n+   * Block until a row becomes available or the timeout has elapsed.\n+   *\n+   * @param timeout amount of to wait for a row. Non-positive values are interpreted as no timeout.\n+   * @param timeUnit unit for timeout param.\n+   * @return the row, if available; else, null.\n+   */\n+  Row poll(long timeout, TimeUnit timeUnit);\n+\n+  boolean isComplete();\n+\n+  void close();\n+}\n+```\n+Note that `QueryResult` is a Reactive Streams `Publisher` so users can stream results. Users can also call `poll()` to receive\n+results in a synchronous fashion instead. Only one of the two methods will be allowed per `QueryResult` instance.\n+\n+The `Row` interface is as follows:\n+```\n+/**\n+ * A single record, returned as part of a query result.\n+ */\n+public interface Row {\n+\n+  List<String> columnNames();\n+\n+  List<String> columnTypes();\n+\n+  List<Object> values();\n+\n+  /**\n+   * Get the value for a particular column of the Row as an Object.\n+   *\n+   * @param columnIndex index of column (1-indexed).\n+   * @return column value.\n+   */\n+  Object getObject(int columnIndex);\n+\n+  /**\n+   * Get the value for a particular column of the Row as an Object.\n+   *\n+   * @param columnName name of column.\n+   * @return column value.\n+   */\n+  Object getObject(String columnName);\n+\n+  /**\n+   * Get the value for a particular column of the Row as a string.\n+   *\n+   * @param columnIndex index of column (1-indexed).\n+   * @return column value.\n+   */\n+  String getString(int columnIndex);\n+\n+  /**\n+   * Get the value for a particular column of the Row as a string.\n+   *\n+   * @param columnName name of column.\n+   * @return column value.\n+   */\n+  String getString(String columnName);\n+\n+  /**\n+   * Get the value for a particular column of the Row as an integer.\n+   *\n+   * @param columnIndex index of column (1-indexed).\n+   * @return column value.\n+   */\n+  Integer getInt(int columnIndex);\n+\n+  /**\n+   * Get the value for a particular column of the Row as an integer.\n+   *\n+   * @param columnName name of column.\n+   * @return column value.\n+   */\n+  Integer getInt(String columnName);\n+\n+  /**\n+   * Get the value for a particular column of the Row as a long.\n+   *\n+   * @param columnIndex index of column (1-indexed).\n+   * @return column value.\n+   */\n+  Long getLong(int columnIndex);\n+\n+  /**\n+   * Get the value for a particular column of the Row as a long.\n+   *\n+   * @param columnName name of column.\n+   * @return column value.\n+   */\n+  Long getLong(String columnName);\n+\n+  /**\n+   * Get the value for a particular column of the Row as a double.\n+   *\n+   * @param columnIndex index of column (1-indexed).\n+   * @return column value.\n+   */\n+  Double getDouble(int columnIndex);\n+\n+  /**\n+   * Get the value for a particular column of the Row as a double.\n+   *\n+   * @param columnName name of column.\n+   * @return column value.\n+   */\n+  Double getDouble(String columnName);\n+\n+  /**\n+   * Get the value for a particular column of the Row as a boolean.\n+   *\n+   * @param columnIndex index of column (1-indexed).\n+   * @return column value.\n+   */\n+  Boolean getBoolean(int columnIndex);\n+\n+  /**\n+   * Get the value for a particular column of the Row as a boolean.\n+   *\n+   * @param columnName name of column.\n+   * @return column value.\n+   */\n+  Boolean getBoolean(String columnName);\n+\n+  /**\n+   * Get the value for a particular column of the Row as a decimal.\n+   *\n+   * @param columnIndex index of column (1-indexed).\n+   * @return column value.\n+   */\n+  BigDecimal getDecimal(int columnIndex);\n+\n+  /**\n+   * Get the value for a particular column of the Row as a decimal.\n+   *\n+   * @param columnName name of column.\n+   * @return column value.\n+   */\n+  BigDecimal getDecimal(String columnName);\n+}\n+```\n+\n+We considered representing column types in a more structured form (rather than plain strings) to accomodate complex/nested data types but felt this added complexity would not be helpful for most use cases. (This would also require a server-side change, so it's a fair bit of additional work.)\n+\n+For `getDecimal(...)` in the `Row` interface, rather than trying to parse the column type to extract the precision and scale, we will simply convert the value to a BigDecimal without explicitly specifying the precision and scale. We could also add an option for users to specify the scale and precision in the getter, if we think that would be useful.\n+\n+We could also add `getList(...)` and `getMap(...)` methods to the `Row` interface, but it's not clear to me how valuable this would be given that the nested data types would not be known.\n+\n+Tim also proposed switching from generic Java types (`Map<String, Object>`, `List<Object>`) to Vert.x types (`JsonObject`, `JsonArray`) as the latter is more type-safe and the client already has a dependency on Vert.x anyway. The downside, though, is that then apps that use the client would be required to depend on Vert.x as well.\n+\n+### Transient queries -- Non-streaming\n+\n+The `Client` interface will also provide the following methods for receiving the results of a transient query (push or pull) in a single batch (non-streaming),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aed38d5836550829f7fd459df31b47aaf7e5ad45"}, "originalPosition": 339}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDAzODMxNzMz", "url": "https://github.com/confluentinc/ksql/pull/5236#pullrequestreview-403831733", "createdAt": "2020-04-30T19:54:31Z", "commit": {"oid": "aed38d5836550829f7fd459df31b47aaf7e5ad45"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0zMFQxOTo1NDozMVrOGO4G5A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0zMFQxOTo1NDozMVrOGO4G5A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODI1MjUxNg==", "bodyText": "Why List? Seems Set would be more appropriate for pull queries.", "url": "https://github.com/confluentinc/ksql/pull/5236#discussion_r418252516", "createdAt": "2020-04-30T19:54:31Z", "author": {"login": "mjsax"}, "path": "design-proposals/klip-26-java-client-interfaces.md", "diffHunk": "@@ -0,0 +1,715 @@\n+# KLIP 26 - Java client interfaces\n+\n+**Author**: Victoria Xia (@vcrfxia) | \n+**Release Target**: ksqlDB 0.10.0 | \n+**Status**: _In development_ | \n+**Discussion**: TBD\n+\n+**tl;dr:** _[KLIP 15](./klip-15-new-api-and-client.md) already made the case for why it makes sense\n+           to introduce a Java client for ksqlDB. This KLIP proposes interfaces for the client._\n+\n+## Motivation and background\n+\n+See [KLIP 15](./klip-15-new-api-and-client.md).\n+\n+## What is in scope\n+\n+The Java client will support the following operations:\n+* Push query\n+* Pull query\n+* Select DDL/DML operations:\n+    * `CREATE STREAM`\n+    * `CREATE TABLE`\n+    * `CREATE STREAM ... AS SELECT`\n+    * `CREATE TABLE ... AS SELECT`\n+    * `DROP STREAM`\n+    * `DROP TABLE`\n+    * `INSERT INTO`\n+    * `TERMINATE <queryId>`\n+    * `CREATE CONNECTOR`\n+    * `DROP CONNECTOR`\n+* Select admin operations:\n+    * `SHOW TOPICS` (non-extended)\n+    * `SHOW STREAMS` (non-extended)\n+    * `SHOW TABLES` (non-extended)\n+    * `SHOW QUERIES` (non-extended)\n+    * `SHOW CONNECTORS`\n+* Insert values, i.e., insert rows into an existing stream/table\n+* Terminate push query (via the `/close-query` endpoint)\n+\n+The purpose of this KLIP is to reach agreement on the interfaces / public APIs.\n+Implementation details will not be covered.\n+\n+## What is not in scope\n+\n+This KLIP does not cover Java client support for the following:\n+* `DESCRIBE <stream/table>`, `DESCRIBE CONNECTOR`, `DESCRIBE FUNCTION`\n+* `EXPLAIN <queryId>`\n+* `PRINT <topic>`\n+* `SHOW TOPICS EXTENDED`, `SHOW <STREAMS/TABLES> EXTENDED`, `SHOW QUERIES EXTENDED`\n+* `CREATE TYPE`, `DROP TYPE`, `SHOW TYPES`\n+* `SHOW FUNCTIONS`, `SHOW PROPERTIES`\n+* `RUN SCRIPT`\n+* Use of other endpoints (info, healthcheck, terminate cluster, status, etc.)\n+\n+We can always add support for these operations in the future if desired.\n+\n+As above, implementation details are out of scope as the purpose of this KLIP is to reach agreement\n+on the interfaces / public APIs.\n+\n+## Value/Return\n+\n+See [KLIP 15](./klip-15-new-api-and-client.md).\n+\n+## Public APIS\n+\n+The following subsections describe the methods of the `Client` interface:\n+```\n+public interface Client {\n+    ...\n+}\n+```\n+\n+### Constructors\n+```\n+  static Client create(ClientOptions clientOptions) {\n+    return new ClientImpl(clientOptions);\n+  }\n+\n+  static Client create(ClientOptions clientOptions, Vertx vertx) {\n+    return new ClientImpl(clientOptions, vertx);\n+  }\n+```\n+\n+The Java client will be implemented as a Vert.x HttpClient. We expose a constructor that allows users to provide their own `Vertx` instance\n+in order to take advantage of a shared connection pool and other properties if desired.\n+\n+`ClientOptions` will initially be as follows:\n+```\n+public interface ClientOptions {\n+\n+  ClientOptions setHost(String host);\n+\n+  ClientOptions setPort(int port);\n+\n+  ClientOptions setUseTls(boolean useTls);\n+\n+  ClientOptions setUseClientAuth(boolean useClientAuth);\n+\n+  ClientOptions setTrustStore(String trustStorePath);\n+\n+  ClientOptions setTrustStorePassword(String trustStorePassword);\n+\n+  ClientOptions setKeyStore(String keyStorePath);\n+\n+  ClientOptions setKeyStorePassword(String keyStorePassword);\n+\n+  ClientOptions setBasicAuthCredentials(String username, String password);\n+\n+  String getHost();\n+\n+  int getPort();\n+\n+  boolean isUseTls();\n+\n+  boolean isUseClientAuth();\n+\n+  boolean isUseBasicAuth();\n+\n+  String getTrustStore();\n+\n+  String getTrustStorePassword();\n+\n+  String getKeyStore();\n+\n+  String getKeyStorePassword();\n+\n+  String getBasicAuthUsername();\n+\n+  String getBasicAuthPassword();\n+\n+  ClientOptions copy();\n+\n+  static ClientOptions create() {\n+    return new ClientOptionsImpl();\n+  }\n+}\n+```\n+\n+We can always add additional configuration options later. We may also wish to expose the Vert.x `HttpClientOptions` for\n+advanced users that wish to provide custom configs.\n+\n+### Transient queries -- Streaming\n+\n+The `Client` interface will provide the following methods for streaming the results of a transient (push or pull) query:\n+```\n+  /**\n+   * Execute a query (push or pull) and receive the results one row at a time.\n+   *\n+   * @param sql statement of query to execute.\n+   * @return query result.\n+   */\n+  CompletableFuture<QueryResult> streamQuery(String sql);\n+\n+  /**\n+   * Execute a query (push or pull) and receive the results one row at a time.\n+   *\n+   * @param sql statement of query to execute.\n+   * @param properties query properties.\n+   * @return query result.\n+   */\n+  CompletableFuture<QueryResult> streamQuery(String sql, Map<String, Object> properties);\n+```\n+where `QueryResult` is as follows:\n+```\n+/**\n+ * The result of a query (push or pull), streamed one row at time. Records may be consumed by either\n+ * subscribing to the publisher or polling (blocking) for one record at a time. These two methods of\n+ * consumption are mutually exclusive; only one method may be used (per QueryResult).\n+ */\n+public interface QueryResult extends Publisher<Row> {\n+\n+  List<String> columnNames();\n+\n+  List<String> columnTypes();\n+\n+  String queryID();\n+\n+  /**\n+   * Block until a row becomes available.\n+   *\n+   * @return the row.\n+   */\n+  Row poll();\n+\n+  /**\n+   * Block until a row becomes available or the timeout has elapsed.\n+   *\n+   * @param timeout amount of to wait for a row. Non-positive values are interpreted as no timeout.\n+   * @param timeUnit unit for timeout param.\n+   * @return the row, if available; else, null.\n+   */\n+  Row poll(long timeout, TimeUnit timeUnit);\n+\n+  boolean isComplete();\n+\n+  void close();\n+}\n+```\n+Note that `QueryResult` is a Reactive Streams `Publisher` so users can stream results. Users can also call `poll()` to receive\n+results in a synchronous fashion instead. Only one of the two methods will be allowed per `QueryResult` instance.\n+\n+The `Row` interface is as follows:\n+```\n+/**\n+ * A single record, returned as part of a query result.\n+ */\n+public interface Row {\n+\n+  List<String> columnNames();\n+\n+  List<String> columnTypes();\n+\n+  List<Object> values();\n+\n+  /**\n+   * Get the value for a particular column of the Row as an Object.\n+   *\n+   * @param columnIndex index of column (1-indexed).\n+   * @return column value.\n+   */\n+  Object getObject(int columnIndex);\n+\n+  /**\n+   * Get the value for a particular column of the Row as an Object.\n+   *\n+   * @param columnName name of column.\n+   * @return column value.\n+   */\n+  Object getObject(String columnName);\n+\n+  /**\n+   * Get the value for a particular column of the Row as a string.\n+   *\n+   * @param columnIndex index of column (1-indexed).\n+   * @return column value.\n+   */\n+  String getString(int columnIndex);\n+\n+  /**\n+   * Get the value for a particular column of the Row as a string.\n+   *\n+   * @param columnName name of column.\n+   * @return column value.\n+   */\n+  String getString(String columnName);\n+\n+  /**\n+   * Get the value for a particular column of the Row as an integer.\n+   *\n+   * @param columnIndex index of column (1-indexed).\n+   * @return column value.\n+   */\n+  Integer getInt(int columnIndex);\n+\n+  /**\n+   * Get the value for a particular column of the Row as an integer.\n+   *\n+   * @param columnName name of column.\n+   * @return column value.\n+   */\n+  Integer getInt(String columnName);\n+\n+  /**\n+   * Get the value for a particular column of the Row as a long.\n+   *\n+   * @param columnIndex index of column (1-indexed).\n+   * @return column value.\n+   */\n+  Long getLong(int columnIndex);\n+\n+  /**\n+   * Get the value for a particular column of the Row as a long.\n+   *\n+   * @param columnName name of column.\n+   * @return column value.\n+   */\n+  Long getLong(String columnName);\n+\n+  /**\n+   * Get the value for a particular column of the Row as a double.\n+   *\n+   * @param columnIndex index of column (1-indexed).\n+   * @return column value.\n+   */\n+  Double getDouble(int columnIndex);\n+\n+  /**\n+   * Get the value for a particular column of the Row as a double.\n+   *\n+   * @param columnName name of column.\n+   * @return column value.\n+   */\n+  Double getDouble(String columnName);\n+\n+  /**\n+   * Get the value for a particular column of the Row as a boolean.\n+   *\n+   * @param columnIndex index of column (1-indexed).\n+   * @return column value.\n+   */\n+  Boolean getBoolean(int columnIndex);\n+\n+  /**\n+   * Get the value for a particular column of the Row as a boolean.\n+   *\n+   * @param columnName name of column.\n+   * @return column value.\n+   */\n+  Boolean getBoolean(String columnName);\n+\n+  /**\n+   * Get the value for a particular column of the Row as a decimal.\n+   *\n+   * @param columnIndex index of column (1-indexed).\n+   * @return column value.\n+   */\n+  BigDecimal getDecimal(int columnIndex);\n+\n+  /**\n+   * Get the value for a particular column of the Row as a decimal.\n+   *\n+   * @param columnName name of column.\n+   * @return column value.\n+   */\n+  BigDecimal getDecimal(String columnName);\n+}\n+```\n+\n+We considered representing column types in a more structured form (rather than plain strings) to accomodate complex/nested data types but felt this added complexity would not be helpful for most use cases. (This would also require a server-side change, so it's a fair bit of additional work.)\n+\n+For `getDecimal(...)` in the `Row` interface, rather than trying to parse the column type to extract the precision and scale, we will simply convert the value to a BigDecimal without explicitly specifying the precision and scale. We could also add an option for users to specify the scale and precision in the getter, if we think that would be useful.\n+\n+We could also add `getList(...)` and `getMap(...)` methods to the `Row` interface, but it's not clear to me how valuable this would be given that the nested data types would not be known.\n+\n+Tim also proposed switching from generic Java types (`Map<String, Object>`, `List<Object>`) to Vert.x types (`JsonObject`, `JsonArray`) as the latter is more type-safe and the client already has a dependency on Vert.x anyway. The downside, though, is that then apps that use the client would be required to depend on Vert.x as well.\n+\n+### Transient queries -- Non-streaming\n+\n+The `Client` interface will also provide the following methods for receiving the results of a transient query (push or pull) in a single batch (non-streaming),\n+once the query has completed:\n+```\n+  /**\n+   * Execute a query (push or pull) and receive all result rows together, once the query has\n+   * completed.\n+   *\n+   * @param sql statement of query to execute.\n+   * @return query result.\n+   */\n+  CompletableFuture<List<Row>> executeQuery(String sql);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aed38d5836550829f7fd459df31b47aaf7e5ad45"}, "originalPosition": 349}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDAzODMyOTM4", "url": "https://github.com/confluentinc/ksql/pull/5236#pullrequestreview-403832938", "createdAt": "2020-04-30T19:56:21Z", "commit": {"oid": "aed38d5836550829f7fd459df31b47aaf7e5ad45"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0zMFQxOTo1NjoyMlrOGO4Kaw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0zMFQxOTo1NjoyMlrOGO4Kaw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODI1MzQxOQ==", "bodyText": "So basically the offset? This would not be unique. Do we think we need to expose the partition number, too?", "url": "https://github.com/confluentinc/ksql/pull/5236#discussion_r418253419", "createdAt": "2020-04-30T19:56:22Z", "author": {"login": "mjsax"}, "path": "design-proposals/klip-26-java-client-interfaces.md", "diffHunk": "@@ -0,0 +1,715 @@\n+# KLIP 26 - Java client interfaces\n+\n+**Author**: Victoria Xia (@vcrfxia) | \n+**Release Target**: ksqlDB 0.10.0 | \n+**Status**: _In development_ | \n+**Discussion**: TBD\n+\n+**tl;dr:** _[KLIP 15](./klip-15-new-api-and-client.md) already made the case for why it makes sense\n+           to introduce a Java client for ksqlDB. This KLIP proposes interfaces for the client._\n+\n+## Motivation and background\n+\n+See [KLIP 15](./klip-15-new-api-and-client.md).\n+\n+## What is in scope\n+\n+The Java client will support the following operations:\n+* Push query\n+* Pull query\n+* Select DDL/DML operations:\n+    * `CREATE STREAM`\n+    * `CREATE TABLE`\n+    * `CREATE STREAM ... AS SELECT`\n+    * `CREATE TABLE ... AS SELECT`\n+    * `DROP STREAM`\n+    * `DROP TABLE`\n+    * `INSERT INTO`\n+    * `TERMINATE <queryId>`\n+    * `CREATE CONNECTOR`\n+    * `DROP CONNECTOR`\n+* Select admin operations:\n+    * `SHOW TOPICS` (non-extended)\n+    * `SHOW STREAMS` (non-extended)\n+    * `SHOW TABLES` (non-extended)\n+    * `SHOW QUERIES` (non-extended)\n+    * `SHOW CONNECTORS`\n+* Insert values, i.e., insert rows into an existing stream/table\n+* Terminate push query (via the `/close-query` endpoint)\n+\n+The purpose of this KLIP is to reach agreement on the interfaces / public APIs.\n+Implementation details will not be covered.\n+\n+## What is not in scope\n+\n+This KLIP does not cover Java client support for the following:\n+* `DESCRIBE <stream/table>`, `DESCRIBE CONNECTOR`, `DESCRIBE FUNCTION`\n+* `EXPLAIN <queryId>`\n+* `PRINT <topic>`\n+* `SHOW TOPICS EXTENDED`, `SHOW <STREAMS/TABLES> EXTENDED`, `SHOW QUERIES EXTENDED`\n+* `CREATE TYPE`, `DROP TYPE`, `SHOW TYPES`\n+* `SHOW FUNCTIONS`, `SHOW PROPERTIES`\n+* `RUN SCRIPT`\n+* Use of other endpoints (info, healthcheck, terminate cluster, status, etc.)\n+\n+We can always add support for these operations in the future if desired.\n+\n+As above, implementation details are out of scope as the purpose of this KLIP is to reach agreement\n+on the interfaces / public APIs.\n+\n+## Value/Return\n+\n+See [KLIP 15](./klip-15-new-api-and-client.md).\n+\n+## Public APIS\n+\n+The following subsections describe the methods of the `Client` interface:\n+```\n+public interface Client {\n+    ...\n+}\n+```\n+\n+### Constructors\n+```\n+  static Client create(ClientOptions clientOptions) {\n+    return new ClientImpl(clientOptions);\n+  }\n+\n+  static Client create(ClientOptions clientOptions, Vertx vertx) {\n+    return new ClientImpl(clientOptions, vertx);\n+  }\n+```\n+\n+The Java client will be implemented as a Vert.x HttpClient. We expose a constructor that allows users to provide their own `Vertx` instance\n+in order to take advantage of a shared connection pool and other properties if desired.\n+\n+`ClientOptions` will initially be as follows:\n+```\n+public interface ClientOptions {\n+\n+  ClientOptions setHost(String host);\n+\n+  ClientOptions setPort(int port);\n+\n+  ClientOptions setUseTls(boolean useTls);\n+\n+  ClientOptions setUseClientAuth(boolean useClientAuth);\n+\n+  ClientOptions setTrustStore(String trustStorePath);\n+\n+  ClientOptions setTrustStorePassword(String trustStorePassword);\n+\n+  ClientOptions setKeyStore(String keyStorePath);\n+\n+  ClientOptions setKeyStorePassword(String keyStorePassword);\n+\n+  ClientOptions setBasicAuthCredentials(String username, String password);\n+\n+  String getHost();\n+\n+  int getPort();\n+\n+  boolean isUseTls();\n+\n+  boolean isUseClientAuth();\n+\n+  boolean isUseBasicAuth();\n+\n+  String getTrustStore();\n+\n+  String getTrustStorePassword();\n+\n+  String getKeyStore();\n+\n+  String getKeyStorePassword();\n+\n+  String getBasicAuthUsername();\n+\n+  String getBasicAuthPassword();\n+\n+  ClientOptions copy();\n+\n+  static ClientOptions create() {\n+    return new ClientOptionsImpl();\n+  }\n+}\n+```\n+\n+We can always add additional configuration options later. We may also wish to expose the Vert.x `HttpClientOptions` for\n+advanced users that wish to provide custom configs.\n+\n+### Transient queries -- Streaming\n+\n+The `Client` interface will provide the following methods for streaming the results of a transient (push or pull) query:\n+```\n+  /**\n+   * Execute a query (push or pull) and receive the results one row at a time.\n+   *\n+   * @param sql statement of query to execute.\n+   * @return query result.\n+   */\n+  CompletableFuture<QueryResult> streamQuery(String sql);\n+\n+  /**\n+   * Execute a query (push or pull) and receive the results one row at a time.\n+   *\n+   * @param sql statement of query to execute.\n+   * @param properties query properties.\n+   * @return query result.\n+   */\n+  CompletableFuture<QueryResult> streamQuery(String sql, Map<String, Object> properties);\n+```\n+where `QueryResult` is as follows:\n+```\n+/**\n+ * The result of a query (push or pull), streamed one row at time. Records may be consumed by either\n+ * subscribing to the publisher or polling (blocking) for one record at a time. These two methods of\n+ * consumption are mutually exclusive; only one method may be used (per QueryResult).\n+ */\n+public interface QueryResult extends Publisher<Row> {\n+\n+  List<String> columnNames();\n+\n+  List<String> columnTypes();\n+\n+  String queryID();\n+\n+  /**\n+   * Block until a row becomes available.\n+   *\n+   * @return the row.\n+   */\n+  Row poll();\n+\n+  /**\n+   * Block until a row becomes available or the timeout has elapsed.\n+   *\n+   * @param timeout amount of to wait for a row. Non-positive values are interpreted as no timeout.\n+   * @param timeUnit unit for timeout param.\n+   * @return the row, if available; else, null.\n+   */\n+  Row poll(long timeout, TimeUnit timeUnit);\n+\n+  boolean isComplete();\n+\n+  void close();\n+}\n+```\n+Note that `QueryResult` is a Reactive Streams `Publisher` so users can stream results. Users can also call `poll()` to receive\n+results in a synchronous fashion instead. Only one of the two methods will be allowed per `QueryResult` instance.\n+\n+The `Row` interface is as follows:\n+```\n+/**\n+ * A single record, returned as part of a query result.\n+ */\n+public interface Row {\n+\n+  List<String> columnNames();\n+\n+  List<String> columnTypes();\n+\n+  List<Object> values();\n+\n+  /**\n+   * Get the value for a particular column of the Row as an Object.\n+   *\n+   * @param columnIndex index of column (1-indexed).\n+   * @return column value.\n+   */\n+  Object getObject(int columnIndex);\n+\n+  /**\n+   * Get the value for a particular column of the Row as an Object.\n+   *\n+   * @param columnName name of column.\n+   * @return column value.\n+   */\n+  Object getObject(String columnName);\n+\n+  /**\n+   * Get the value for a particular column of the Row as a string.\n+   *\n+   * @param columnIndex index of column (1-indexed).\n+   * @return column value.\n+   */\n+  String getString(int columnIndex);\n+\n+  /**\n+   * Get the value for a particular column of the Row as a string.\n+   *\n+   * @param columnName name of column.\n+   * @return column value.\n+   */\n+  String getString(String columnName);\n+\n+  /**\n+   * Get the value for a particular column of the Row as an integer.\n+   *\n+   * @param columnIndex index of column (1-indexed).\n+   * @return column value.\n+   */\n+  Integer getInt(int columnIndex);\n+\n+  /**\n+   * Get the value for a particular column of the Row as an integer.\n+   *\n+   * @param columnName name of column.\n+   * @return column value.\n+   */\n+  Integer getInt(String columnName);\n+\n+  /**\n+   * Get the value for a particular column of the Row as a long.\n+   *\n+   * @param columnIndex index of column (1-indexed).\n+   * @return column value.\n+   */\n+  Long getLong(int columnIndex);\n+\n+  /**\n+   * Get the value for a particular column of the Row as a long.\n+   *\n+   * @param columnName name of column.\n+   * @return column value.\n+   */\n+  Long getLong(String columnName);\n+\n+  /**\n+   * Get the value for a particular column of the Row as a double.\n+   *\n+   * @param columnIndex index of column (1-indexed).\n+   * @return column value.\n+   */\n+  Double getDouble(int columnIndex);\n+\n+  /**\n+   * Get the value for a particular column of the Row as a double.\n+   *\n+   * @param columnName name of column.\n+   * @return column value.\n+   */\n+  Double getDouble(String columnName);\n+\n+  /**\n+   * Get the value for a particular column of the Row as a boolean.\n+   *\n+   * @param columnIndex index of column (1-indexed).\n+   * @return column value.\n+   */\n+  Boolean getBoolean(int columnIndex);\n+\n+  /**\n+   * Get the value for a particular column of the Row as a boolean.\n+   *\n+   * @param columnName name of column.\n+   * @return column value.\n+   */\n+  Boolean getBoolean(String columnName);\n+\n+  /**\n+   * Get the value for a particular column of the Row as a decimal.\n+   *\n+   * @param columnIndex index of column (1-indexed).\n+   * @return column value.\n+   */\n+  BigDecimal getDecimal(int columnIndex);\n+\n+  /**\n+   * Get the value for a particular column of the Row as a decimal.\n+   *\n+   * @param columnName name of column.\n+   * @return column value.\n+   */\n+  BigDecimal getDecimal(String columnName);\n+}\n+```\n+\n+We considered representing column types in a more structured form (rather than plain strings) to accomodate complex/nested data types but felt this added complexity would not be helpful for most use cases. (This would also require a server-side change, so it's a fair bit of additional work.)\n+\n+For `getDecimal(...)` in the `Row` interface, rather than trying to parse the column type to extract the precision and scale, we will simply convert the value to a BigDecimal without explicitly specifying the precision and scale. We could also add an option for users to specify the scale and precision in the getter, if we think that would be useful.\n+\n+We could also add `getList(...)` and `getMap(...)` methods to the `Row` interface, but it's not clear to me how valuable this would be given that the nested data types would not be known.\n+\n+Tim also proposed switching from generic Java types (`Map<String, Object>`, `List<Object>`) to Vert.x types (`JsonObject`, `JsonArray`) as the latter is more type-safe and the client already has a dependency on Vert.x anyway. The downside, though, is that then apps that use the client would be required to depend on Vert.x as well.\n+\n+### Transient queries -- Non-streaming\n+\n+The `Client` interface will also provide the following methods for receiving the results of a transient query (push or pull) in a single batch (non-streaming),\n+once the query has completed:\n+```\n+  /**\n+   * Execute a query (push or pull) and receive all result rows together, once the query has\n+   * completed.\n+   *\n+   * @param sql statement of query to execute.\n+   * @return query result.\n+   */\n+  CompletableFuture<List<Row>> executeQuery(String sql);\n+\n+  /**\n+   * Execute a query (push or pull) and receive all result rows together, once the query has\n+   * completed.\n+   *\n+   * @param sql statement of query to execute.\n+   * @param properties query properties.\n+   * @return query result.\n+   */\n+  CompletableFuture<List<Row>> executeQuery(String sql, Map<String, Object> properties);\n+```\n+\n+For a query to \"complete\" could mean:\n+* The query is a pull query\n+* The query is a push query with a limit clause, and the limit has been reached\n+* The query is a push query that has been terminated\n+\n+We may want to introduce a limit to the number of rows that may be returned from these `executeQuery()` methods,\n+in order to decrease the likelihood of running out of memory.\n+\n+### Insert values\n+\n+A method to insert one row at a time:\n+```\n+  /**\n+   * Insert a single row into the relevant stream/table.\n+   *\n+   * @param streamName name of stream/table.\n+   * @param row the row to insert.\n+   * @return a future that completes once the request has been processed.\n+   */\n+  CompletableFuture<Void> insertInto(String streamName, Map<String, Object> row);\n+```\n+\n+A method to stream inserts (via the `/inserts-stream` endpoint):\n+```\n+  CompletableFuture<Publisher<InsertResponse>> streamInserts(String streamName, Publisher<List<Object>> insertsPublisher);\n+}\n+```\n+where `InsertResponse` is as follows:\n+```\n+public interface InsertResponse {\n+\n+  /**\n+   * Whether the row was successfully inserted or not.\n+   */\n+  boolean isSuccessful();\n+\n+  /**\n+   * Unique sequence number for the row in the stream of inserts.\n+   */\n+  int getSequenceNum();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aed38d5836550829f7fd459df31b47aaf7e5ad45"}, "originalPosition": 401}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDAzODM3MTk2", "url": "https://github.com/confluentinc/ksql/pull/5236#pullrequestreview-403837196", "createdAt": "2020-04-30T20:02:54Z", "commit": {"oid": "aed38d5836550829f7fd459df31b47aaf7e5ad45"}, "state": "COMMENTED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDAzNzEyOTM3", "url": "https://github.com/confluentinc/ksql/pull/5236#pullrequestreview-403712937", "createdAt": "2020-04-30T17:05:37Z", "commit": {"oid": "aed38d5836550829f7fd459df31b47aaf7e5ad45"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0zMFQxNzowNTozN1rOGOyZWQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0zMFQxODowMTowOVrOGO0Z-w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODE1ODkzNw==", "bodyText": "It's been a bit since I've dealt with keystores and truststores, so maybe I'm missing something, but for a client, do you need a keystore?  In this case, it would be for authenticating the client to the server, which we currently do with basic auth.", "url": "https://github.com/confluentinc/ksql/pull/5236#discussion_r418158937", "createdAt": "2020-04-30T17:05:37Z", "author": {"login": "AlanConfluent"}, "path": "design-proposals/klip-26-java-client-interfaces.md", "diffHunk": "@@ -0,0 +1,715 @@\n+# KLIP 26 - Java client interfaces\n+\n+**Author**: Victoria Xia (@vcrfxia) | \n+**Release Target**: ksqlDB 0.10.0 | \n+**Status**: _In development_ | \n+**Discussion**: TBD\n+\n+**tl;dr:** _[KLIP 15](./klip-15-new-api-and-client.md) already made the case for why it makes sense\n+           to introduce a Java client for ksqlDB. This KLIP proposes interfaces for the client._\n+\n+## Motivation and background\n+\n+See [KLIP 15](./klip-15-new-api-and-client.md).\n+\n+## What is in scope\n+\n+The Java client will support the following operations:\n+* Push query\n+* Pull query\n+* Select DDL/DML operations:\n+    * `CREATE STREAM`\n+    * `CREATE TABLE`\n+    * `CREATE STREAM ... AS SELECT`\n+    * `CREATE TABLE ... AS SELECT`\n+    * `DROP STREAM`\n+    * `DROP TABLE`\n+    * `INSERT INTO`\n+    * `TERMINATE <queryId>`\n+    * `CREATE CONNECTOR`\n+    * `DROP CONNECTOR`\n+* Select admin operations:\n+    * `SHOW TOPICS` (non-extended)\n+    * `SHOW STREAMS` (non-extended)\n+    * `SHOW TABLES` (non-extended)\n+    * `SHOW QUERIES` (non-extended)\n+    * `SHOW CONNECTORS`\n+* Insert values, i.e., insert rows into an existing stream/table\n+* Terminate push query (via the `/close-query` endpoint)\n+\n+The purpose of this KLIP is to reach agreement on the interfaces / public APIs.\n+Implementation details will not be covered.\n+\n+## What is not in scope\n+\n+This KLIP does not cover Java client support for the following:\n+* `DESCRIBE <stream/table>`, `DESCRIBE CONNECTOR`, `DESCRIBE FUNCTION`\n+* `EXPLAIN <queryId>`\n+* `PRINT <topic>`\n+* `SHOW TOPICS EXTENDED`, `SHOW <STREAMS/TABLES> EXTENDED`, `SHOW QUERIES EXTENDED`\n+* `CREATE TYPE`, `DROP TYPE`, `SHOW TYPES`\n+* `SHOW FUNCTIONS`, `SHOW PROPERTIES`\n+* `RUN SCRIPT`\n+* Use of other endpoints (info, healthcheck, terminate cluster, status, etc.)\n+\n+We can always add support for these operations in the future if desired.\n+\n+As above, implementation details are out of scope as the purpose of this KLIP is to reach agreement\n+on the interfaces / public APIs.\n+\n+## Value/Return\n+\n+See [KLIP 15](./klip-15-new-api-and-client.md).\n+\n+## Public APIS\n+\n+The following subsections describe the methods of the `Client` interface:\n+```\n+public interface Client {\n+    ...\n+}\n+```\n+\n+### Constructors\n+```\n+  static Client create(ClientOptions clientOptions) {\n+    return new ClientImpl(clientOptions);\n+  }\n+\n+  static Client create(ClientOptions clientOptions, Vertx vertx) {\n+    return new ClientImpl(clientOptions, vertx);\n+  }\n+```\n+\n+The Java client will be implemented as a Vert.x HttpClient. We expose a constructor that allows users to provide their own `Vertx` instance\n+in order to take advantage of a shared connection pool and other properties if desired.\n+\n+`ClientOptions` will initially be as follows:\n+```\n+public interface ClientOptions {\n+\n+  ClientOptions setHost(String host);\n+\n+  ClientOptions setPort(int port);\n+\n+  ClientOptions setUseTls(boolean useTls);\n+\n+  ClientOptions setUseClientAuth(boolean useClientAuth);\n+\n+  ClientOptions setTrustStore(String trustStorePath);\n+\n+  ClientOptions setTrustStorePassword(String trustStorePassword);\n+\n+  ClientOptions setKeyStore(String keyStorePath);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aed38d5836550829f7fd459df31b47aaf7e5ad45"}, "originalPosition": 103}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODE5MTg2Nw==", "bodyText": "Will this return null both if the stream is complete or if a timeout has occurred?  Wondering if it would be a bit cleaner in the common case to throw a TimeoutException?\nhttps://docs.oracle.com/javase/7/docs/api/java/util/concurrent/Future.html#get(long,%20java.util.concurrent.TimeUnit)", "url": "https://github.com/confluentinc/ksql/pull/5236#discussion_r418191867", "createdAt": "2020-04-30T18:01:09Z", "author": {"login": "AlanConfluent"}, "path": "design-proposals/klip-26-java-client-interfaces.md", "diffHunk": "@@ -0,0 +1,715 @@\n+# KLIP 26 - Java client interfaces\n+\n+**Author**: Victoria Xia (@vcrfxia) | \n+**Release Target**: ksqlDB 0.10.0 | \n+**Status**: _In development_ | \n+**Discussion**: TBD\n+\n+**tl;dr:** _[KLIP 15](./klip-15-new-api-and-client.md) already made the case for why it makes sense\n+           to introduce a Java client for ksqlDB. This KLIP proposes interfaces for the client._\n+\n+## Motivation and background\n+\n+See [KLIP 15](./klip-15-new-api-and-client.md).\n+\n+## What is in scope\n+\n+The Java client will support the following operations:\n+* Push query\n+* Pull query\n+* Select DDL/DML operations:\n+    * `CREATE STREAM`\n+    * `CREATE TABLE`\n+    * `CREATE STREAM ... AS SELECT`\n+    * `CREATE TABLE ... AS SELECT`\n+    * `DROP STREAM`\n+    * `DROP TABLE`\n+    * `INSERT INTO`\n+    * `TERMINATE <queryId>`\n+    * `CREATE CONNECTOR`\n+    * `DROP CONNECTOR`\n+* Select admin operations:\n+    * `SHOW TOPICS` (non-extended)\n+    * `SHOW STREAMS` (non-extended)\n+    * `SHOW TABLES` (non-extended)\n+    * `SHOW QUERIES` (non-extended)\n+    * `SHOW CONNECTORS`\n+* Insert values, i.e., insert rows into an existing stream/table\n+* Terminate push query (via the `/close-query` endpoint)\n+\n+The purpose of this KLIP is to reach agreement on the interfaces / public APIs.\n+Implementation details will not be covered.\n+\n+## What is not in scope\n+\n+This KLIP does not cover Java client support for the following:\n+* `DESCRIBE <stream/table>`, `DESCRIBE CONNECTOR`, `DESCRIBE FUNCTION`\n+* `EXPLAIN <queryId>`\n+* `PRINT <topic>`\n+* `SHOW TOPICS EXTENDED`, `SHOW <STREAMS/TABLES> EXTENDED`, `SHOW QUERIES EXTENDED`\n+* `CREATE TYPE`, `DROP TYPE`, `SHOW TYPES`\n+* `SHOW FUNCTIONS`, `SHOW PROPERTIES`\n+* `RUN SCRIPT`\n+* Use of other endpoints (info, healthcheck, terminate cluster, status, etc.)\n+\n+We can always add support for these operations in the future if desired.\n+\n+As above, implementation details are out of scope as the purpose of this KLIP is to reach agreement\n+on the interfaces / public APIs.\n+\n+## Value/Return\n+\n+See [KLIP 15](./klip-15-new-api-and-client.md).\n+\n+## Public APIS\n+\n+The following subsections describe the methods of the `Client` interface:\n+```\n+public interface Client {\n+    ...\n+}\n+```\n+\n+### Constructors\n+```\n+  static Client create(ClientOptions clientOptions) {\n+    return new ClientImpl(clientOptions);\n+  }\n+\n+  static Client create(ClientOptions clientOptions, Vertx vertx) {\n+    return new ClientImpl(clientOptions, vertx);\n+  }\n+```\n+\n+The Java client will be implemented as a Vert.x HttpClient. We expose a constructor that allows users to provide their own `Vertx` instance\n+in order to take advantage of a shared connection pool and other properties if desired.\n+\n+`ClientOptions` will initially be as follows:\n+```\n+public interface ClientOptions {\n+\n+  ClientOptions setHost(String host);\n+\n+  ClientOptions setPort(int port);\n+\n+  ClientOptions setUseTls(boolean useTls);\n+\n+  ClientOptions setUseClientAuth(boolean useClientAuth);\n+\n+  ClientOptions setTrustStore(String trustStorePath);\n+\n+  ClientOptions setTrustStorePassword(String trustStorePassword);\n+\n+  ClientOptions setKeyStore(String keyStorePath);\n+\n+  ClientOptions setKeyStorePassword(String keyStorePassword);\n+\n+  ClientOptions setBasicAuthCredentials(String username, String password);\n+\n+  String getHost();\n+\n+  int getPort();\n+\n+  boolean isUseTls();\n+\n+  boolean isUseClientAuth();\n+\n+  boolean isUseBasicAuth();\n+\n+  String getTrustStore();\n+\n+  String getTrustStorePassword();\n+\n+  String getKeyStore();\n+\n+  String getKeyStorePassword();\n+\n+  String getBasicAuthUsername();\n+\n+  String getBasicAuthPassword();\n+\n+  ClientOptions copy();\n+\n+  static ClientOptions create() {\n+    return new ClientOptionsImpl();\n+  }\n+}\n+```\n+\n+We can always add additional configuration options later. We may also wish to expose the Vert.x `HttpClientOptions` for\n+advanced users that wish to provide custom configs.\n+\n+### Transient queries -- Streaming\n+\n+The `Client` interface will provide the following methods for streaming the results of a transient (push or pull) query:\n+```\n+  /**\n+   * Execute a query (push or pull) and receive the results one row at a time.\n+   *\n+   * @param sql statement of query to execute.\n+   * @return query result.\n+   */\n+  CompletableFuture<QueryResult> streamQuery(String sql);\n+\n+  /**\n+   * Execute a query (push or pull) and receive the results one row at a time.\n+   *\n+   * @param sql statement of query to execute.\n+   * @param properties query properties.\n+   * @return query result.\n+   */\n+  CompletableFuture<QueryResult> streamQuery(String sql, Map<String, Object> properties);\n+```\n+where `QueryResult` is as follows:\n+```\n+/**\n+ * The result of a query (push or pull), streamed one row at time. Records may be consumed by either\n+ * subscribing to the publisher or polling (blocking) for one record at a time. These two methods of\n+ * consumption are mutually exclusive; only one method may be used (per QueryResult).\n+ */\n+public interface QueryResult extends Publisher<Row> {\n+\n+  List<String> columnNames();\n+\n+  List<String> columnTypes();\n+\n+  String queryID();\n+\n+  /**\n+   * Block until a row becomes available.\n+   *\n+   * @return the row.\n+   */\n+  Row poll();\n+\n+  /**\n+   * Block until a row becomes available or the timeout has elapsed.\n+   *\n+   * @param timeout amount of to wait for a row. Non-positive values are interpreted as no timeout.\n+   * @param timeUnit unit for timeout param.\n+   * @return the row, if available; else, null.\n+   */\n+  Row poll(long timeout, TimeUnit timeUnit);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aed38d5836550829f7fd459df31b47aaf7e5ad45"}, "originalPosition": 192}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA1NDYwNzk4", "url": "https://github.com/confluentinc/ksql/pull/5236#pullrequestreview-405460798", "createdAt": "2020-05-05T02:23:59Z", "commit": {"oid": "aed38d5836550829f7fd459df31b47aaf7e5ad45"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "efc58b7c30c8fe0bf1d11150260b0518ec0b45d6", "author": {"user": {"login": "vcrfxia", "name": "Victoria Xia"}}, "url": "https://github.com/confluentinc/ksql/commit/efc58b7c30c8fe0bf1d11150260b0518ec0b45d6", "committedDate": "2020-05-06T01:41:56Z", "message": "chore: clear up DDL/DML confusion. remove unneeded fields. add commandSeqNum"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "bf95f3b7c0d142581c475bc3acd107a3c1f0761c", "author": {"user": {"login": "vcrfxia", "name": "Victoria Xia"}}, "url": "https://github.com/confluentinc/ksql/commit/bf95f3b7c0d142581c475bc3acd107a3c1f0761c", "committedDate": "2020-05-06T01:48:59Z", "message": "chore: return queryId from executeQuery()"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8069dbf256e9ff29b57871998260c93b428d636d", "author": {"user": {"login": "vcrfxia", "name": "Victoria Xia"}}, "url": "https://github.com/confluentinc/ksql/commit/8069dbf256e9ff29b57871998260c93b428d636d", "committedDate": "2020-05-06T07:14:00Z", "message": "chore: add ColumnType"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "cf93bc3def69770ec3d3de22a6c0d7dfc7d5bb8b", "author": {"user": {"login": "vcrfxia", "name": "Victoria Xia"}}, "url": "https://github.com/confluentinc/ksql/commit/cf93bc3def69770ec3d3de22a6c0d7dfc7d5bb8b", "committedDate": "2020-05-06T08:04:13Z", "message": "chore: add wrapper around raw types"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "71202cf4efa35be303209e71da23ce363f9dce39", "author": {"user": {"login": "vcrfxia", "name": "Victoria Xia"}}, "url": "https://github.com/confluentinc/ksql/commit/71202cf4efa35be303209e71da23ce363f9dce39", "committedDate": "2020-05-06T08:25:17Z", "message": "chore: more feedback"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f447ce9002ada1f992080685f3262cbda4faf1b1", "author": {"user": {"login": "vcrfxia", "name": "Victoria Xia"}}, "url": "https://github.com/confluentinc/ksql/commit/f447ce9002ada1f992080685f3262cbda4faf1b1", "committedDate": "2020-05-06T08:26:11Z", "message": "Merge branch 'master' into klip-26"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA2NDA0Mzkz", "url": "https://github.com/confluentinc/ksql/pull/5236#pullrequestreview-406404393", "createdAt": "2020-05-06T08:34:04Z", "commit": {"oid": "aed38d5836550829f7fd459df31b47aaf7e5ad45"}, "state": "COMMENTED", "comments": {"totalCount": 12, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNlQwODozNDowNFrOGRJEFQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNlQwODo1MzoyM1rOGRJucw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDYyNzQ3Nw==", "bodyText": "Can you (@agavra , @mjsax , or @derekjn ) elaborate on this? Is the proposal to switch from having two options:\nstreamQuery(); -- can either subscribe to result or poll\nexecuteQuery(); -- wait and receive results in a single batch\n\nto having three options\nstreamQuery(); -- subscribe to result\nsubmitQueryAndPoll(); -- poll from results, potentially as they arrive\nexecuteQueryAndWait(); -- wait and receive results in a single batch\n\n? (Having trouble with naming here -- am curious to know what others think is intuitive.)\nWhy is this preferable/more intuitive?", "url": "https://github.com/confluentinc/ksql/pull/5236#discussion_r420627477", "createdAt": "2020-05-06T08:34:04Z", "author": {"login": "vcrfxia"}, "path": "design-proposals/klip-26-java-client-interfaces.md", "diffHunk": "@@ -0,0 +1,715 @@\n+# KLIP 26 - Java client interfaces\n+\n+**Author**: Victoria Xia (@vcrfxia) | \n+**Release Target**: ksqlDB 0.10.0 | \n+**Status**: _In development_ | \n+**Discussion**: TBD\n+\n+**tl;dr:** _[KLIP 15](./klip-15-new-api-and-client.md) already made the case for why it makes sense\n+           to introduce a Java client for ksqlDB. This KLIP proposes interfaces for the client._\n+\n+## Motivation and background\n+\n+See [KLIP 15](./klip-15-new-api-and-client.md).\n+\n+## What is in scope\n+\n+The Java client will support the following operations:\n+* Push query\n+* Pull query\n+* Select DDL/DML operations:\n+    * `CREATE STREAM`\n+    * `CREATE TABLE`\n+    * `CREATE STREAM ... AS SELECT`\n+    * `CREATE TABLE ... AS SELECT`\n+    * `DROP STREAM`\n+    * `DROP TABLE`\n+    * `INSERT INTO`\n+    * `TERMINATE <queryId>`\n+    * `CREATE CONNECTOR`\n+    * `DROP CONNECTOR`\n+* Select admin operations:\n+    * `SHOW TOPICS` (non-extended)\n+    * `SHOW STREAMS` (non-extended)\n+    * `SHOW TABLES` (non-extended)\n+    * `SHOW QUERIES` (non-extended)\n+    * `SHOW CONNECTORS`\n+* Insert values, i.e., insert rows into an existing stream/table\n+* Terminate push query (via the `/close-query` endpoint)\n+\n+The purpose of this KLIP is to reach agreement on the interfaces / public APIs.\n+Implementation details will not be covered.\n+\n+## What is not in scope\n+\n+This KLIP does not cover Java client support for the following:\n+* `DESCRIBE <stream/table>`, `DESCRIBE CONNECTOR`, `DESCRIBE FUNCTION`\n+* `EXPLAIN <queryId>`\n+* `PRINT <topic>`\n+* `SHOW TOPICS EXTENDED`, `SHOW <STREAMS/TABLES> EXTENDED`, `SHOW QUERIES EXTENDED`\n+* `CREATE TYPE`, `DROP TYPE`, `SHOW TYPES`\n+* `SHOW FUNCTIONS`, `SHOW PROPERTIES`\n+* `RUN SCRIPT`\n+* Use of other endpoints (info, healthcheck, terminate cluster, status, etc.)\n+\n+We can always add support for these operations in the future if desired.\n+\n+As above, implementation details are out of scope as the purpose of this KLIP is to reach agreement\n+on the interfaces / public APIs.\n+\n+## Value/Return\n+\n+See [KLIP 15](./klip-15-new-api-and-client.md).\n+\n+## Public APIS\n+\n+The following subsections describe the methods of the `Client` interface:\n+```\n+public interface Client {\n+    ...\n+}\n+```\n+\n+### Constructors\n+```\n+  static Client create(ClientOptions clientOptions) {\n+    return new ClientImpl(clientOptions);\n+  }\n+\n+  static Client create(ClientOptions clientOptions, Vertx vertx) {\n+    return new ClientImpl(clientOptions, vertx);\n+  }\n+```\n+\n+The Java client will be implemented as a Vert.x HttpClient. We expose a constructor that allows users to provide their own `Vertx` instance\n+in order to take advantage of a shared connection pool and other properties if desired.\n+\n+`ClientOptions` will initially be as follows:\n+```\n+public interface ClientOptions {\n+\n+  ClientOptions setHost(String host);\n+\n+  ClientOptions setPort(int port);\n+\n+  ClientOptions setUseTls(boolean useTls);\n+\n+  ClientOptions setUseClientAuth(boolean useClientAuth);\n+\n+  ClientOptions setTrustStore(String trustStorePath);\n+\n+  ClientOptions setTrustStorePassword(String trustStorePassword);\n+\n+  ClientOptions setKeyStore(String keyStorePath);\n+\n+  ClientOptions setKeyStorePassword(String keyStorePassword);\n+\n+  ClientOptions setBasicAuthCredentials(String username, String password);\n+\n+  String getHost();\n+\n+  int getPort();\n+\n+  boolean isUseTls();\n+\n+  boolean isUseClientAuth();\n+\n+  boolean isUseBasicAuth();\n+\n+  String getTrustStore();\n+\n+  String getTrustStorePassword();\n+\n+  String getKeyStore();\n+\n+  String getKeyStorePassword();\n+\n+  String getBasicAuthUsername();\n+\n+  String getBasicAuthPassword();\n+\n+  ClientOptions copy();\n+\n+  static ClientOptions create() {\n+    return new ClientOptionsImpl();\n+  }\n+}\n+```\n+\n+We can always add additional configuration options later. We may also wish to expose the Vert.x `HttpClientOptions` for\n+advanced users that wish to provide custom configs.\n+\n+### Transient queries -- Streaming\n+\n+The `Client` interface will provide the following methods for streaming the results of a transient (push or pull) query:\n+```\n+  /**\n+   * Execute a query (push or pull) and receive the results one row at a time.\n+   *\n+   * @param sql statement of query to execute.\n+   * @return query result.\n+   */\n+  CompletableFuture<QueryResult> streamQuery(String sql);\n+\n+  /**\n+   * Execute a query (push or pull) and receive the results one row at a time.\n+   *\n+   * @param sql statement of query to execute.\n+   * @param properties query properties.\n+   * @return query result.\n+   */\n+  CompletableFuture<QueryResult> streamQuery(String sql, Map<String, Object> properties);\n+```\n+where `QueryResult` is as follows:\n+```\n+/**\n+ * The result of a query (push or pull), streamed one row at time. Records may be consumed by either\n+ * subscribing to the publisher or polling (blocking) for one record at a time. These two methods of\n+ * consumption are mutually exclusive; only one method may be used (per QueryResult).", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODExNTI1OA=="}, "originalCommit": {"oid": "aed38d5836550829f7fd459df31b47aaf7e5ad45"}, "originalPosition": 168}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDYyODQ4Mg==", "bodyText": "Yup, see the discussion in #5236 (comment).", "url": "https://github.com/confluentinc/ksql/pull/5236#discussion_r420628482", "createdAt": "2020-05-06T08:35:47Z", "author": {"login": "vcrfxia"}, "path": "design-proposals/klip-26-java-client-interfaces.md", "diffHunk": "@@ -0,0 +1,715 @@\n+# KLIP 26 - Java client interfaces\n+\n+**Author**: Victoria Xia (@vcrfxia) | \n+**Release Target**: ksqlDB 0.10.0 | \n+**Status**: _In development_ | \n+**Discussion**: TBD\n+\n+**tl;dr:** _[KLIP 15](./klip-15-new-api-and-client.md) already made the case for why it makes sense\n+           to introduce a Java client for ksqlDB. This KLIP proposes interfaces for the client._\n+\n+## Motivation and background\n+\n+See [KLIP 15](./klip-15-new-api-and-client.md).\n+\n+## What is in scope\n+\n+The Java client will support the following operations:\n+* Push query\n+* Pull query\n+* Select DDL/DML operations:\n+    * `CREATE STREAM`\n+    * `CREATE TABLE`\n+    * `CREATE STREAM ... AS SELECT`\n+    * `CREATE TABLE ... AS SELECT`\n+    * `DROP STREAM`\n+    * `DROP TABLE`\n+    * `INSERT INTO`\n+    * `TERMINATE <queryId>`\n+    * `CREATE CONNECTOR`\n+    * `DROP CONNECTOR`\n+* Select admin operations:\n+    * `SHOW TOPICS` (non-extended)\n+    * `SHOW STREAMS` (non-extended)\n+    * `SHOW TABLES` (non-extended)\n+    * `SHOW QUERIES` (non-extended)\n+    * `SHOW CONNECTORS`\n+* Insert values, i.e., insert rows into an existing stream/table\n+* Terminate push query (via the `/close-query` endpoint)\n+\n+The purpose of this KLIP is to reach agreement on the interfaces / public APIs.\n+Implementation details will not be covered.\n+\n+## What is not in scope\n+\n+This KLIP does not cover Java client support for the following:\n+* `DESCRIBE <stream/table>`, `DESCRIBE CONNECTOR`, `DESCRIBE FUNCTION`\n+* `EXPLAIN <queryId>`\n+* `PRINT <topic>`\n+* `SHOW TOPICS EXTENDED`, `SHOW <STREAMS/TABLES> EXTENDED`, `SHOW QUERIES EXTENDED`\n+* `CREATE TYPE`, `DROP TYPE`, `SHOW TYPES`\n+* `SHOW FUNCTIONS`, `SHOW PROPERTIES`\n+* `RUN SCRIPT`\n+* Use of other endpoints (info, healthcheck, terminate cluster, status, etc.)\n+\n+We can always add support for these operations in the future if desired.\n+\n+As above, implementation details are out of scope as the purpose of this KLIP is to reach agreement\n+on the interfaces / public APIs.\n+\n+## Value/Return\n+\n+See [KLIP 15](./klip-15-new-api-and-client.md).\n+\n+## Public APIS\n+\n+The following subsections describe the methods of the `Client` interface:\n+```\n+public interface Client {\n+    ...\n+}\n+```\n+\n+### Constructors\n+```\n+  static Client create(ClientOptions clientOptions) {\n+    return new ClientImpl(clientOptions);\n+  }\n+\n+  static Client create(ClientOptions clientOptions, Vertx vertx) {\n+    return new ClientImpl(clientOptions, vertx);\n+  }\n+```\n+\n+The Java client will be implemented as a Vert.x HttpClient. We expose a constructor that allows users to provide their own `Vertx` instance\n+in order to take advantage of a shared connection pool and other properties if desired.\n+\n+`ClientOptions` will initially be as follows:\n+```\n+public interface ClientOptions {\n+\n+  ClientOptions setHost(String host);\n+\n+  ClientOptions setPort(int port);\n+\n+  ClientOptions setUseTls(boolean useTls);\n+\n+  ClientOptions setUseClientAuth(boolean useClientAuth);\n+\n+  ClientOptions setTrustStore(String trustStorePath);\n+\n+  ClientOptions setTrustStorePassword(String trustStorePassword);\n+\n+  ClientOptions setKeyStore(String keyStorePath);\n+\n+  ClientOptions setKeyStorePassword(String keyStorePassword);\n+\n+  ClientOptions setBasicAuthCredentials(String username, String password);\n+\n+  String getHost();\n+\n+  int getPort();\n+\n+  boolean isUseTls();\n+\n+  boolean isUseClientAuth();\n+\n+  boolean isUseBasicAuth();\n+\n+  String getTrustStore();\n+\n+  String getTrustStorePassword();\n+\n+  String getKeyStore();\n+\n+  String getKeyStorePassword();\n+\n+  String getBasicAuthUsername();\n+\n+  String getBasicAuthPassword();\n+\n+  ClientOptions copy();\n+\n+  static ClientOptions create() {\n+    return new ClientOptionsImpl();\n+  }\n+}\n+```\n+\n+We can always add additional configuration options later. We may also wish to expose the Vert.x `HttpClientOptions` for\n+advanced users that wish to provide custom configs.\n+\n+### Transient queries -- Streaming\n+\n+The `Client` interface will provide the following methods for streaming the results of a transient (push or pull) query:\n+```\n+  /**\n+   * Execute a query (push or pull) and receive the results one row at a time.\n+   *\n+   * @param sql statement of query to execute.\n+   * @return query result.\n+   */\n+  CompletableFuture<QueryResult> streamQuery(String sql);\n+\n+  /**\n+   * Execute a query (push or pull) and receive the results one row at a time.\n+   *\n+   * @param sql statement of query to execute.\n+   * @param properties query properties.\n+   * @return query result.\n+   */\n+  CompletableFuture<QueryResult> streamQuery(String sql, Map<String, Object> properties);\n+```\n+where `QueryResult` is as follows:\n+```\n+/**\n+ * The result of a query (push or pull), streamed one row at time. Records may be consumed by either\n+ * subscribing to the publisher or polling (blocking) for one record at a time. These two methods of\n+ * consumption are mutually exclusive; only one method may be used (per QueryResult).\n+ */\n+public interface QueryResult extends Publisher<Row> {\n+\n+  List<String> columnNames();\n+\n+  List<String> columnTypes();\n+\n+  String queryID();\n+\n+  /**\n+   * Block until a row becomes available.\n+   *\n+   * @return the row.\n+   */\n+  Row poll();\n+\n+  /**\n+   * Block until a row becomes available or the timeout has elapsed.\n+   *\n+   * @param timeout amount of to wait for a row. Non-positive values are interpreted as no timeout.\n+   * @param timeUnit unit for timeout param.\n+   * @return the row, if available; else, null.\n+   */\n+  Row poll(long timeout, TimeUnit timeUnit);\n+\n+  boolean isComplete();\n+\n+  void close();\n+}\n+```\n+Note that `QueryResult` is a Reactive Streams `Publisher` so users can stream results. Users can also call `poll()` to receive\n+results in a synchronous fashion instead. Only one of the two methods will be allowed per `QueryResult` instance.\n+\n+The `Row` interface is as follows:\n+```\n+/**\n+ * A single record, returned as part of a query result.\n+ */\n+public interface Row {\n+\n+  List<String> columnNames();\n+\n+  List<String> columnTypes();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODI0NDgzOA=="}, "originalCommit": {"oid": "aed38d5836550829f7fd459df31b47aaf7e5ad45"}, "originalPosition": 211}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDYyOTcxNA==", "bodyText": "This was important to have before we introduced getKsqlObject() (for returning map and struct types) and getKsqlArray() (for returning array types). Now that we've added those methods the need for a plain getObject() is less pressing, though it still seems useful to have a generic getter that works for any column type.\nMaybe we should rename this getValue() to avoid confusion with getKsqlObject().", "url": "https://github.com/confluentinc/ksql/pull/5236#discussion_r420629714", "createdAt": "2020-05-06T08:38:02Z", "author": {"login": "vcrfxia"}, "path": "design-proposals/klip-26-java-client-interfaces.md", "diffHunk": "@@ -0,0 +1,715 @@\n+# KLIP 26 - Java client interfaces\n+\n+**Author**: Victoria Xia (@vcrfxia) | \n+**Release Target**: ksqlDB 0.10.0 | \n+**Status**: _In development_ | \n+**Discussion**: TBD\n+\n+**tl;dr:** _[KLIP 15](./klip-15-new-api-and-client.md) already made the case for why it makes sense\n+           to introduce a Java client for ksqlDB. This KLIP proposes interfaces for the client._\n+\n+## Motivation and background\n+\n+See [KLIP 15](./klip-15-new-api-and-client.md).\n+\n+## What is in scope\n+\n+The Java client will support the following operations:\n+* Push query\n+* Pull query\n+* Select DDL/DML operations:\n+    * `CREATE STREAM`\n+    * `CREATE TABLE`\n+    * `CREATE STREAM ... AS SELECT`\n+    * `CREATE TABLE ... AS SELECT`\n+    * `DROP STREAM`\n+    * `DROP TABLE`\n+    * `INSERT INTO`\n+    * `TERMINATE <queryId>`\n+    * `CREATE CONNECTOR`\n+    * `DROP CONNECTOR`\n+* Select admin operations:\n+    * `SHOW TOPICS` (non-extended)\n+    * `SHOW STREAMS` (non-extended)\n+    * `SHOW TABLES` (non-extended)\n+    * `SHOW QUERIES` (non-extended)\n+    * `SHOW CONNECTORS`\n+* Insert values, i.e., insert rows into an existing stream/table\n+* Terminate push query (via the `/close-query` endpoint)\n+\n+The purpose of this KLIP is to reach agreement on the interfaces / public APIs.\n+Implementation details will not be covered.\n+\n+## What is not in scope\n+\n+This KLIP does not cover Java client support for the following:\n+* `DESCRIBE <stream/table>`, `DESCRIBE CONNECTOR`, `DESCRIBE FUNCTION`\n+* `EXPLAIN <queryId>`\n+* `PRINT <topic>`\n+* `SHOW TOPICS EXTENDED`, `SHOW <STREAMS/TABLES> EXTENDED`, `SHOW QUERIES EXTENDED`\n+* `CREATE TYPE`, `DROP TYPE`, `SHOW TYPES`\n+* `SHOW FUNCTIONS`, `SHOW PROPERTIES`\n+* `RUN SCRIPT`\n+* Use of other endpoints (info, healthcheck, terminate cluster, status, etc.)\n+\n+We can always add support for these operations in the future if desired.\n+\n+As above, implementation details are out of scope as the purpose of this KLIP is to reach agreement\n+on the interfaces / public APIs.\n+\n+## Value/Return\n+\n+See [KLIP 15](./klip-15-new-api-and-client.md).\n+\n+## Public APIS\n+\n+The following subsections describe the methods of the `Client` interface:\n+```\n+public interface Client {\n+    ...\n+}\n+```\n+\n+### Constructors\n+```\n+  static Client create(ClientOptions clientOptions) {\n+    return new ClientImpl(clientOptions);\n+  }\n+\n+  static Client create(ClientOptions clientOptions, Vertx vertx) {\n+    return new ClientImpl(clientOptions, vertx);\n+  }\n+```\n+\n+The Java client will be implemented as a Vert.x HttpClient. We expose a constructor that allows users to provide their own `Vertx` instance\n+in order to take advantage of a shared connection pool and other properties if desired.\n+\n+`ClientOptions` will initially be as follows:\n+```\n+public interface ClientOptions {\n+\n+  ClientOptions setHost(String host);\n+\n+  ClientOptions setPort(int port);\n+\n+  ClientOptions setUseTls(boolean useTls);\n+\n+  ClientOptions setUseClientAuth(boolean useClientAuth);\n+\n+  ClientOptions setTrustStore(String trustStorePath);\n+\n+  ClientOptions setTrustStorePassword(String trustStorePassword);\n+\n+  ClientOptions setKeyStore(String keyStorePath);\n+\n+  ClientOptions setKeyStorePassword(String keyStorePassword);\n+\n+  ClientOptions setBasicAuthCredentials(String username, String password);\n+\n+  String getHost();\n+\n+  int getPort();\n+\n+  boolean isUseTls();\n+\n+  boolean isUseClientAuth();\n+\n+  boolean isUseBasicAuth();\n+\n+  String getTrustStore();\n+\n+  String getTrustStorePassword();\n+\n+  String getKeyStore();\n+\n+  String getKeyStorePassword();\n+\n+  String getBasicAuthUsername();\n+\n+  String getBasicAuthPassword();\n+\n+  ClientOptions copy();\n+\n+  static ClientOptions create() {\n+    return new ClientOptionsImpl();\n+  }\n+}\n+```\n+\n+We can always add additional configuration options later. We may also wish to expose the Vert.x `HttpClientOptions` for\n+advanced users that wish to provide custom configs.\n+\n+### Transient queries -- Streaming\n+\n+The `Client` interface will provide the following methods for streaming the results of a transient (push or pull) query:\n+```\n+  /**\n+   * Execute a query (push or pull) and receive the results one row at a time.\n+   *\n+   * @param sql statement of query to execute.\n+   * @return query result.\n+   */\n+  CompletableFuture<QueryResult> streamQuery(String sql);\n+\n+  /**\n+   * Execute a query (push or pull) and receive the results one row at a time.\n+   *\n+   * @param sql statement of query to execute.\n+   * @param properties query properties.\n+   * @return query result.\n+   */\n+  CompletableFuture<QueryResult> streamQuery(String sql, Map<String, Object> properties);\n+```\n+where `QueryResult` is as follows:\n+```\n+/**\n+ * The result of a query (push or pull), streamed one row at time. Records may be consumed by either\n+ * subscribing to the publisher or polling (blocking) for one record at a time. These two methods of\n+ * consumption are mutually exclusive; only one method may be used (per QueryResult).\n+ */\n+public interface QueryResult extends Publisher<Row> {\n+\n+  List<String> columnNames();\n+\n+  List<String> columnTypes();\n+\n+  String queryID();\n+\n+  /**\n+   * Block until a row becomes available.\n+   *\n+   * @return the row.\n+   */\n+  Row poll();\n+\n+  /**\n+   * Block until a row becomes available or the timeout has elapsed.\n+   *\n+   * @param timeout amount of to wait for a row. Non-positive values are interpreted as no timeout.\n+   * @param timeUnit unit for timeout param.\n+   * @return the row, if available; else, null.\n+   */\n+  Row poll(long timeout, TimeUnit timeUnit);\n+\n+  boolean isComplete();\n+\n+  void close();\n+}\n+```\n+Note that `QueryResult` is a Reactive Streams `Publisher` so users can stream results. Users can also call `poll()` to receive\n+results in a synchronous fashion instead. Only one of the two methods will be allowed per `QueryResult` instance.\n+\n+The `Row` interface is as follows:\n+```\n+/**\n+ * A single record, returned as part of a query result.\n+ */\n+public interface Row {\n+\n+  List<String> columnNames();\n+\n+  List<String> columnTypes();\n+\n+  List<Object> values();\n+\n+  /**\n+   * Get the value for a particular column of the Row as an Object.\n+   *\n+   * @param columnIndex index of column (1-indexed).\n+   * @return column value.\n+   */\n+  Object getObject(int columnIndex);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODI0NzU5Nw=="}, "originalCommit": {"oid": "aed38d5836550829f7fd459df31b47aaf7e5ad45"}, "originalPosition": 221}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDYzMTEzNw==", "bodyText": "Added isNull(...) but held off on adding isNotNull(...) since it seems redundant. Is it standard practice to include both even though one is simply the negation of the other?", "url": "https://github.com/confluentinc/ksql/pull/5236#discussion_r420631137", "createdAt": "2020-05-06T08:40:30Z", "author": {"login": "vcrfxia"}, "path": "design-proposals/klip-26-java-client-interfaces.md", "diffHunk": "@@ -0,0 +1,715 @@\n+# KLIP 26 - Java client interfaces\n+\n+**Author**: Victoria Xia (@vcrfxia) | \n+**Release Target**: ksqlDB 0.10.0 | \n+**Status**: _In development_ | \n+**Discussion**: TBD\n+\n+**tl;dr:** _[KLIP 15](./klip-15-new-api-and-client.md) already made the case for why it makes sense\n+           to introduce a Java client for ksqlDB. This KLIP proposes interfaces for the client._\n+\n+## Motivation and background\n+\n+See [KLIP 15](./klip-15-new-api-and-client.md).\n+\n+## What is in scope\n+\n+The Java client will support the following operations:\n+* Push query\n+* Pull query\n+* Select DDL/DML operations:\n+    * `CREATE STREAM`\n+    * `CREATE TABLE`\n+    * `CREATE STREAM ... AS SELECT`\n+    * `CREATE TABLE ... AS SELECT`\n+    * `DROP STREAM`\n+    * `DROP TABLE`\n+    * `INSERT INTO`\n+    * `TERMINATE <queryId>`\n+    * `CREATE CONNECTOR`\n+    * `DROP CONNECTOR`\n+* Select admin operations:\n+    * `SHOW TOPICS` (non-extended)\n+    * `SHOW STREAMS` (non-extended)\n+    * `SHOW TABLES` (non-extended)\n+    * `SHOW QUERIES` (non-extended)\n+    * `SHOW CONNECTORS`\n+* Insert values, i.e., insert rows into an existing stream/table\n+* Terminate push query (via the `/close-query` endpoint)\n+\n+The purpose of this KLIP is to reach agreement on the interfaces / public APIs.\n+Implementation details will not be covered.\n+\n+## What is not in scope\n+\n+This KLIP does not cover Java client support for the following:\n+* `DESCRIBE <stream/table>`, `DESCRIBE CONNECTOR`, `DESCRIBE FUNCTION`\n+* `EXPLAIN <queryId>`\n+* `PRINT <topic>`\n+* `SHOW TOPICS EXTENDED`, `SHOW <STREAMS/TABLES> EXTENDED`, `SHOW QUERIES EXTENDED`\n+* `CREATE TYPE`, `DROP TYPE`, `SHOW TYPES`\n+* `SHOW FUNCTIONS`, `SHOW PROPERTIES`\n+* `RUN SCRIPT`\n+* Use of other endpoints (info, healthcheck, terminate cluster, status, etc.)\n+\n+We can always add support for these operations in the future if desired.\n+\n+As above, implementation details are out of scope as the purpose of this KLIP is to reach agreement\n+on the interfaces / public APIs.\n+\n+## Value/Return\n+\n+See [KLIP 15](./klip-15-new-api-and-client.md).\n+\n+## Public APIS\n+\n+The following subsections describe the methods of the `Client` interface:\n+```\n+public interface Client {\n+    ...\n+}\n+```\n+\n+### Constructors\n+```\n+  static Client create(ClientOptions clientOptions) {\n+    return new ClientImpl(clientOptions);\n+  }\n+\n+  static Client create(ClientOptions clientOptions, Vertx vertx) {\n+    return new ClientImpl(clientOptions, vertx);\n+  }\n+```\n+\n+The Java client will be implemented as a Vert.x HttpClient. We expose a constructor that allows users to provide their own `Vertx` instance\n+in order to take advantage of a shared connection pool and other properties if desired.\n+\n+`ClientOptions` will initially be as follows:\n+```\n+public interface ClientOptions {\n+\n+  ClientOptions setHost(String host);\n+\n+  ClientOptions setPort(int port);\n+\n+  ClientOptions setUseTls(boolean useTls);\n+\n+  ClientOptions setUseClientAuth(boolean useClientAuth);\n+\n+  ClientOptions setTrustStore(String trustStorePath);\n+\n+  ClientOptions setTrustStorePassword(String trustStorePassword);\n+\n+  ClientOptions setKeyStore(String keyStorePath);\n+\n+  ClientOptions setKeyStorePassword(String keyStorePassword);\n+\n+  ClientOptions setBasicAuthCredentials(String username, String password);\n+\n+  String getHost();\n+\n+  int getPort();\n+\n+  boolean isUseTls();\n+\n+  boolean isUseClientAuth();\n+\n+  boolean isUseBasicAuth();\n+\n+  String getTrustStore();\n+\n+  String getTrustStorePassword();\n+\n+  String getKeyStore();\n+\n+  String getKeyStorePassword();\n+\n+  String getBasicAuthUsername();\n+\n+  String getBasicAuthPassword();\n+\n+  ClientOptions copy();\n+\n+  static ClientOptions create() {\n+    return new ClientOptionsImpl();\n+  }\n+}\n+```\n+\n+We can always add additional configuration options later. We may also wish to expose the Vert.x `HttpClientOptions` for\n+advanced users that wish to provide custom configs.\n+\n+### Transient queries -- Streaming\n+\n+The `Client` interface will provide the following methods for streaming the results of a transient (push or pull) query:\n+```\n+  /**\n+   * Execute a query (push or pull) and receive the results one row at a time.\n+   *\n+   * @param sql statement of query to execute.\n+   * @return query result.\n+   */\n+  CompletableFuture<QueryResult> streamQuery(String sql);\n+\n+  /**\n+   * Execute a query (push or pull) and receive the results one row at a time.\n+   *\n+   * @param sql statement of query to execute.\n+   * @param properties query properties.\n+   * @return query result.\n+   */\n+  CompletableFuture<QueryResult> streamQuery(String sql, Map<String, Object> properties);\n+```\n+where `QueryResult` is as follows:\n+```\n+/**\n+ * The result of a query (push or pull), streamed one row at time. Records may be consumed by either\n+ * subscribing to the publisher or polling (blocking) for one record at a time. These two methods of\n+ * consumption are mutually exclusive; only one method may be used (per QueryResult).\n+ */\n+public interface QueryResult extends Publisher<Row> {\n+\n+  List<String> columnNames();\n+\n+  List<String> columnTypes();\n+\n+  String queryID();\n+\n+  /**\n+   * Block until a row becomes available.\n+   *\n+   * @return the row.\n+   */\n+  Row poll();\n+\n+  /**\n+   * Block until a row becomes available or the timeout has elapsed.\n+   *\n+   * @param timeout amount of to wait for a row. Non-positive values are interpreted as no timeout.\n+   * @param timeUnit unit for timeout param.\n+   * @return the row, if available; else, null.\n+   */\n+  Row poll(long timeout, TimeUnit timeUnit);\n+\n+  boolean isComplete();\n+\n+  void close();\n+}\n+```\n+Note that `QueryResult` is a Reactive Streams `Publisher` so users can stream results. Users can also call `poll()` to receive\n+results in a synchronous fashion instead. Only one of the two methods will be allowed per `QueryResult` instance.\n+\n+The `Row` interface is as follows:\n+```\n+/**\n+ * A single record, returned as part of a query result.\n+ */\n+public interface Row {\n+\n+  List<String> columnNames();\n+\n+  List<String> columnTypes();\n+\n+  List<Object> values();\n+\n+  /**\n+   * Get the value for a particular column of the Row as an Object.\n+   *\n+   * @param columnIndex index of column (1-indexed).\n+   * @return column value.\n+   */\n+  Object getObject(int columnIndex);\n+\n+  /**\n+   * Get the value for a particular column of the Row as an Object.\n+   *\n+   * @param columnName name of column.\n+   * @return column value.\n+   */\n+  Object getObject(String columnName);\n+\n+  /**\n+   * Get the value for a particular column of the Row as a string.\n+   *\n+   * @param columnIndex index of column (1-indexed).\n+   * @return column value.\n+   */\n+  String getString(int columnIndex);\n+\n+  /**\n+   * Get the value for a particular column of the Row as a string.\n+   *\n+   * @param columnName name of column.\n+   * @return column value.\n+   */\n+  String getString(String columnName);\n+\n+  /**\n+   * Get the value for a particular column of the Row as an integer.\n+   *\n+   * @param columnIndex index of column (1-indexed).\n+   * @return column value.\n+   */\n+  Integer getInt(int columnIndex);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODI0NjA0OQ=="}, "originalCommit": {"oid": "aed38d5836550829f7fd459df31b47aaf7e5ad45"}, "originalPosition": 253}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDYzMTY4Mw==", "bodyText": "Added getKsqlObject() and getKsqlArray() per discussion (here and in #5236 (comment)).", "url": "https://github.com/confluentinc/ksql/pull/5236#discussion_r420631683", "createdAt": "2020-05-06T08:41:32Z", "author": {"login": "vcrfxia"}, "path": "design-proposals/klip-26-java-client-interfaces.md", "diffHunk": "@@ -0,0 +1,715 @@\n+# KLIP 26 - Java client interfaces\n+\n+**Author**: Victoria Xia (@vcrfxia) | \n+**Release Target**: ksqlDB 0.10.0 | \n+**Status**: _In development_ | \n+**Discussion**: TBD\n+\n+**tl;dr:** _[KLIP 15](./klip-15-new-api-and-client.md) already made the case for why it makes sense\n+           to introduce a Java client for ksqlDB. This KLIP proposes interfaces for the client._\n+\n+## Motivation and background\n+\n+See [KLIP 15](./klip-15-new-api-and-client.md).\n+\n+## What is in scope\n+\n+The Java client will support the following operations:\n+* Push query\n+* Pull query\n+* Select DDL/DML operations:\n+    * `CREATE STREAM`\n+    * `CREATE TABLE`\n+    * `CREATE STREAM ... AS SELECT`\n+    * `CREATE TABLE ... AS SELECT`\n+    * `DROP STREAM`\n+    * `DROP TABLE`\n+    * `INSERT INTO`\n+    * `TERMINATE <queryId>`\n+    * `CREATE CONNECTOR`\n+    * `DROP CONNECTOR`\n+* Select admin operations:\n+    * `SHOW TOPICS` (non-extended)\n+    * `SHOW STREAMS` (non-extended)\n+    * `SHOW TABLES` (non-extended)\n+    * `SHOW QUERIES` (non-extended)\n+    * `SHOW CONNECTORS`\n+* Insert values, i.e., insert rows into an existing stream/table\n+* Terminate push query (via the `/close-query` endpoint)\n+\n+The purpose of this KLIP is to reach agreement on the interfaces / public APIs.\n+Implementation details will not be covered.\n+\n+## What is not in scope\n+\n+This KLIP does not cover Java client support for the following:\n+* `DESCRIBE <stream/table>`, `DESCRIBE CONNECTOR`, `DESCRIBE FUNCTION`\n+* `EXPLAIN <queryId>`\n+* `PRINT <topic>`\n+* `SHOW TOPICS EXTENDED`, `SHOW <STREAMS/TABLES> EXTENDED`, `SHOW QUERIES EXTENDED`\n+* `CREATE TYPE`, `DROP TYPE`, `SHOW TYPES`\n+* `SHOW FUNCTIONS`, `SHOW PROPERTIES`\n+* `RUN SCRIPT`\n+* Use of other endpoints (info, healthcheck, terminate cluster, status, etc.)\n+\n+We can always add support for these operations in the future if desired.\n+\n+As above, implementation details are out of scope as the purpose of this KLIP is to reach agreement\n+on the interfaces / public APIs.\n+\n+## Value/Return\n+\n+See [KLIP 15](./klip-15-new-api-and-client.md).\n+\n+## Public APIS\n+\n+The following subsections describe the methods of the `Client` interface:\n+```\n+public interface Client {\n+    ...\n+}\n+```\n+\n+### Constructors\n+```\n+  static Client create(ClientOptions clientOptions) {\n+    return new ClientImpl(clientOptions);\n+  }\n+\n+  static Client create(ClientOptions clientOptions, Vertx vertx) {\n+    return new ClientImpl(clientOptions, vertx);\n+  }\n+```\n+\n+The Java client will be implemented as a Vert.x HttpClient. We expose a constructor that allows users to provide their own `Vertx` instance\n+in order to take advantage of a shared connection pool and other properties if desired.\n+\n+`ClientOptions` will initially be as follows:\n+```\n+public interface ClientOptions {\n+\n+  ClientOptions setHost(String host);\n+\n+  ClientOptions setPort(int port);\n+\n+  ClientOptions setUseTls(boolean useTls);\n+\n+  ClientOptions setUseClientAuth(boolean useClientAuth);\n+\n+  ClientOptions setTrustStore(String trustStorePath);\n+\n+  ClientOptions setTrustStorePassword(String trustStorePassword);\n+\n+  ClientOptions setKeyStore(String keyStorePath);\n+\n+  ClientOptions setKeyStorePassword(String keyStorePassword);\n+\n+  ClientOptions setBasicAuthCredentials(String username, String password);\n+\n+  String getHost();\n+\n+  int getPort();\n+\n+  boolean isUseTls();\n+\n+  boolean isUseClientAuth();\n+\n+  boolean isUseBasicAuth();\n+\n+  String getTrustStore();\n+\n+  String getTrustStorePassword();\n+\n+  String getKeyStore();\n+\n+  String getKeyStorePassword();\n+\n+  String getBasicAuthUsername();\n+\n+  String getBasicAuthPassword();\n+\n+  ClientOptions copy();\n+\n+  static ClientOptions create() {\n+    return new ClientOptionsImpl();\n+  }\n+}\n+```\n+\n+We can always add additional configuration options later. We may also wish to expose the Vert.x `HttpClientOptions` for\n+advanced users that wish to provide custom configs.\n+\n+### Transient queries -- Streaming\n+\n+The `Client` interface will provide the following methods for streaming the results of a transient (push or pull) query:\n+```\n+  /**\n+   * Execute a query (push or pull) and receive the results one row at a time.\n+   *\n+   * @param sql statement of query to execute.\n+   * @return query result.\n+   */\n+  CompletableFuture<QueryResult> streamQuery(String sql);\n+\n+  /**\n+   * Execute a query (push or pull) and receive the results one row at a time.\n+   *\n+   * @param sql statement of query to execute.\n+   * @param properties query properties.\n+   * @return query result.\n+   */\n+  CompletableFuture<QueryResult> streamQuery(String sql, Map<String, Object> properties);\n+```\n+where `QueryResult` is as follows:\n+```\n+/**\n+ * The result of a query (push or pull), streamed one row at time. Records may be consumed by either\n+ * subscribing to the publisher or polling (blocking) for one record at a time. These two methods of\n+ * consumption are mutually exclusive; only one method may be used (per QueryResult).\n+ */\n+public interface QueryResult extends Publisher<Row> {\n+\n+  List<String> columnNames();\n+\n+  List<String> columnTypes();\n+\n+  String queryID();\n+\n+  /**\n+   * Block until a row becomes available.\n+   *\n+   * @return the row.\n+   */\n+  Row poll();\n+\n+  /**\n+   * Block until a row becomes available or the timeout has elapsed.\n+   *\n+   * @param timeout amount of to wait for a row. Non-positive values are interpreted as no timeout.\n+   * @param timeUnit unit for timeout param.\n+   * @return the row, if available; else, null.\n+   */\n+  Row poll(long timeout, TimeUnit timeUnit);\n+\n+  boolean isComplete();\n+\n+  void close();\n+}\n+```\n+Note that `QueryResult` is a Reactive Streams `Publisher` so users can stream results. Users can also call `poll()` to receive\n+results in a synchronous fashion instead. Only one of the two methods will be allowed per `QueryResult` instance.\n+\n+The `Row` interface is as follows:\n+```\n+/**\n+ * A single record, returned as part of a query result.\n+ */\n+public interface Row {\n+\n+  List<String> columnNames();\n+\n+  List<String> columnTypes();\n+\n+  List<Object> values();\n+\n+  /**\n+   * Get the value for a particular column of the Row as an Object.\n+   *\n+   * @param columnIndex index of column (1-indexed).\n+   * @return column value.\n+   */\n+  Object getObject(int columnIndex);\n+\n+  /**\n+   * Get the value for a particular column of the Row as an Object.\n+   *\n+   * @param columnName name of column.\n+   * @return column value.\n+   */\n+  Object getObject(String columnName);\n+\n+  /**\n+   * Get the value for a particular column of the Row as a string.\n+   *\n+   * @param columnIndex index of column (1-indexed).\n+   * @return column value.\n+   */\n+  String getString(int columnIndex);\n+\n+  /**\n+   * Get the value for a particular column of the Row as a string.\n+   *\n+   * @param columnName name of column.\n+   * @return column value.\n+   */\n+  String getString(String columnName);\n+\n+  /**\n+   * Get the value for a particular column of the Row as an integer.\n+   *\n+   * @param columnIndex index of column (1-indexed).\n+   * @return column value.\n+   */\n+  Integer getInt(int columnIndex);\n+\n+  /**\n+   * Get the value for a particular column of the Row as an integer.\n+   *\n+   * @param columnName name of column.\n+   * @return column value.\n+   */\n+  Integer getInt(String columnName);\n+\n+  /**\n+   * Get the value for a particular column of the Row as a long.\n+   *\n+   * @param columnIndex index of column (1-indexed).\n+   * @return column value.\n+   */\n+  Long getLong(int columnIndex);\n+\n+  /**\n+   * Get the value for a particular column of the Row as a long.\n+   *\n+   * @param columnName name of column.\n+   * @return column value.\n+   */\n+  Long getLong(String columnName);\n+\n+  /**\n+   * Get the value for a particular column of the Row as a double.\n+   *\n+   * @param columnIndex index of column (1-indexed).\n+   * @return column value.\n+   */\n+  Double getDouble(int columnIndex);\n+\n+  /**\n+   * Get the value for a particular column of the Row as a double.\n+   *\n+   * @param columnName name of column.\n+   * @return column value.\n+   */\n+  Double getDouble(String columnName);\n+\n+  /**\n+   * Get the value for a particular column of the Row as a boolean.\n+   *\n+   * @param columnIndex index of column (1-indexed).\n+   * @return column value.\n+   */\n+  Boolean getBoolean(int columnIndex);\n+\n+  /**\n+   * Get the value for a particular column of the Row as a boolean.\n+   *\n+   * @param columnName name of column.\n+   * @return column value.\n+   */\n+  Boolean getBoolean(String columnName);\n+\n+  /**\n+   * Get the value for a particular column of the Row as a decimal.\n+   *\n+   * @param columnIndex index of column (1-indexed).\n+   * @return column value.\n+   */\n+  BigDecimal getDecimal(int columnIndex);\n+\n+  /**\n+   * Get the value for a particular column of the Row as a decimal.\n+   *\n+   * @param columnName name of column.\n+   * @return column value.\n+   */\n+  BigDecimal getDecimal(String columnName);\n+}", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODI0NzI5OQ=="}, "originalCommit": {"oid": "aed38d5836550829f7fd459df31b47aaf7e5ad45"}, "originalPosition": 326}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDYzMjIyOQ==", "bodyText": "Introduced a ColumnType interface that currently wraps an enum type. We can add more methods to expose richer type information (e.g., inner types for nested/complex types) later on.", "url": "https://github.com/confluentinc/ksql/pull/5236#discussion_r420632229", "createdAt": "2020-05-06T08:42:29Z", "author": {"login": "vcrfxia"}, "path": "design-proposals/klip-26-java-client-interfaces.md", "diffHunk": "@@ -0,0 +1,715 @@\n+# KLIP 26 - Java client interfaces\n+\n+**Author**: Victoria Xia (@vcrfxia) | \n+**Release Target**: ksqlDB 0.10.0 | \n+**Status**: _In development_ | \n+**Discussion**: TBD\n+\n+**tl;dr:** _[KLIP 15](./klip-15-new-api-and-client.md) already made the case for why it makes sense\n+           to introduce a Java client for ksqlDB. This KLIP proposes interfaces for the client._\n+\n+## Motivation and background\n+\n+See [KLIP 15](./klip-15-new-api-and-client.md).\n+\n+## What is in scope\n+\n+The Java client will support the following operations:\n+* Push query\n+* Pull query\n+* Select DDL/DML operations:\n+    * `CREATE STREAM`\n+    * `CREATE TABLE`\n+    * `CREATE STREAM ... AS SELECT`\n+    * `CREATE TABLE ... AS SELECT`\n+    * `DROP STREAM`\n+    * `DROP TABLE`\n+    * `INSERT INTO`\n+    * `TERMINATE <queryId>`\n+    * `CREATE CONNECTOR`\n+    * `DROP CONNECTOR`\n+* Select admin operations:\n+    * `SHOW TOPICS` (non-extended)\n+    * `SHOW STREAMS` (non-extended)\n+    * `SHOW TABLES` (non-extended)\n+    * `SHOW QUERIES` (non-extended)\n+    * `SHOW CONNECTORS`\n+* Insert values, i.e., insert rows into an existing stream/table\n+* Terminate push query (via the `/close-query` endpoint)\n+\n+The purpose of this KLIP is to reach agreement on the interfaces / public APIs.\n+Implementation details will not be covered.\n+\n+## What is not in scope\n+\n+This KLIP does not cover Java client support for the following:\n+* `DESCRIBE <stream/table>`, `DESCRIBE CONNECTOR`, `DESCRIBE FUNCTION`\n+* `EXPLAIN <queryId>`\n+* `PRINT <topic>`\n+* `SHOW TOPICS EXTENDED`, `SHOW <STREAMS/TABLES> EXTENDED`, `SHOW QUERIES EXTENDED`\n+* `CREATE TYPE`, `DROP TYPE`, `SHOW TYPES`\n+* `SHOW FUNCTIONS`, `SHOW PROPERTIES`\n+* `RUN SCRIPT`\n+* Use of other endpoints (info, healthcheck, terminate cluster, status, etc.)\n+\n+We can always add support for these operations in the future if desired.\n+\n+As above, implementation details are out of scope as the purpose of this KLIP is to reach agreement\n+on the interfaces / public APIs.\n+\n+## Value/Return\n+\n+See [KLIP 15](./klip-15-new-api-and-client.md).\n+\n+## Public APIS\n+\n+The following subsections describe the methods of the `Client` interface:\n+```\n+public interface Client {\n+    ...\n+}\n+```\n+\n+### Constructors\n+```\n+  static Client create(ClientOptions clientOptions) {\n+    return new ClientImpl(clientOptions);\n+  }\n+\n+  static Client create(ClientOptions clientOptions, Vertx vertx) {\n+    return new ClientImpl(clientOptions, vertx);\n+  }\n+```\n+\n+The Java client will be implemented as a Vert.x HttpClient. We expose a constructor that allows users to provide their own `Vertx` instance\n+in order to take advantage of a shared connection pool and other properties if desired.\n+\n+`ClientOptions` will initially be as follows:\n+```\n+public interface ClientOptions {\n+\n+  ClientOptions setHost(String host);\n+\n+  ClientOptions setPort(int port);\n+\n+  ClientOptions setUseTls(boolean useTls);\n+\n+  ClientOptions setUseClientAuth(boolean useClientAuth);\n+\n+  ClientOptions setTrustStore(String trustStorePath);\n+\n+  ClientOptions setTrustStorePassword(String trustStorePassword);\n+\n+  ClientOptions setKeyStore(String keyStorePath);\n+\n+  ClientOptions setKeyStorePassword(String keyStorePassword);\n+\n+  ClientOptions setBasicAuthCredentials(String username, String password);\n+\n+  String getHost();\n+\n+  int getPort();\n+\n+  boolean isUseTls();\n+\n+  boolean isUseClientAuth();\n+\n+  boolean isUseBasicAuth();\n+\n+  String getTrustStore();\n+\n+  String getTrustStorePassword();\n+\n+  String getKeyStore();\n+\n+  String getKeyStorePassword();\n+\n+  String getBasicAuthUsername();\n+\n+  String getBasicAuthPassword();\n+\n+  ClientOptions copy();\n+\n+  static ClientOptions create() {\n+    return new ClientOptionsImpl();\n+  }\n+}\n+```\n+\n+We can always add additional configuration options later. We may also wish to expose the Vert.x `HttpClientOptions` for\n+advanced users that wish to provide custom configs.\n+\n+### Transient queries -- Streaming\n+\n+The `Client` interface will provide the following methods for streaming the results of a transient (push or pull) query:\n+```\n+  /**\n+   * Execute a query (push or pull) and receive the results one row at a time.\n+   *\n+   * @param sql statement of query to execute.\n+   * @return query result.\n+   */\n+  CompletableFuture<QueryResult> streamQuery(String sql);\n+\n+  /**\n+   * Execute a query (push or pull) and receive the results one row at a time.\n+   *\n+   * @param sql statement of query to execute.\n+   * @param properties query properties.\n+   * @return query result.\n+   */\n+  CompletableFuture<QueryResult> streamQuery(String sql, Map<String, Object> properties);\n+```\n+where `QueryResult` is as follows:\n+```\n+/**\n+ * The result of a query (push or pull), streamed one row at time. Records may be consumed by either\n+ * subscribing to the publisher or polling (blocking) for one record at a time. These two methods of\n+ * consumption are mutually exclusive; only one method may be used (per QueryResult).\n+ */\n+public interface QueryResult extends Publisher<Row> {\n+\n+  List<String> columnNames();\n+\n+  List<String> columnTypes();\n+\n+  String queryID();\n+\n+  /**\n+   * Block until a row becomes available.\n+   *\n+   * @return the row.\n+   */\n+  Row poll();\n+\n+  /**\n+   * Block until a row becomes available or the timeout has elapsed.\n+   *\n+   * @param timeout amount of to wait for a row. Non-positive values are interpreted as no timeout.\n+   * @param timeUnit unit for timeout param.\n+   * @return the row, if available; else, null.\n+   */\n+  Row poll(long timeout, TimeUnit timeUnit);\n+\n+  boolean isComplete();\n+\n+  void close();\n+}\n+```\n+Note that `QueryResult` is a Reactive Streams `Publisher` so users can stream results. Users can also call `poll()` to receive\n+results in a synchronous fashion instead. Only one of the two methods will be allowed per `QueryResult` instance.\n+\n+The `Row` interface is as follows:\n+```\n+/**\n+ * A single record, returned as part of a query result.\n+ */\n+public interface Row {\n+\n+  List<String> columnNames();\n+\n+  List<String> columnTypes();\n+\n+  List<Object> values();\n+\n+  /**\n+   * Get the value for a particular column of the Row as an Object.\n+   *\n+   * @param columnIndex index of column (1-indexed).\n+   * @return column value.\n+   */\n+  Object getObject(int columnIndex);\n+\n+  /**\n+   * Get the value for a particular column of the Row as an Object.\n+   *\n+   * @param columnName name of column.\n+   * @return column value.\n+   */\n+  Object getObject(String columnName);\n+\n+  /**\n+   * Get the value for a particular column of the Row as a string.\n+   *\n+   * @param columnIndex index of column (1-indexed).\n+   * @return column value.\n+   */\n+  String getString(int columnIndex);\n+\n+  /**\n+   * Get the value for a particular column of the Row as a string.\n+   *\n+   * @param columnName name of column.\n+   * @return column value.\n+   */\n+  String getString(String columnName);\n+\n+  /**\n+   * Get the value for a particular column of the Row as an integer.\n+   *\n+   * @param columnIndex index of column (1-indexed).\n+   * @return column value.\n+   */\n+  Integer getInt(int columnIndex);\n+\n+  /**\n+   * Get the value for a particular column of the Row as an integer.\n+   *\n+   * @param columnName name of column.\n+   * @return column value.\n+   */\n+  Integer getInt(String columnName);\n+\n+  /**\n+   * Get the value for a particular column of the Row as a long.\n+   *\n+   * @param columnIndex index of column (1-indexed).\n+   * @return column value.\n+   */\n+  Long getLong(int columnIndex);\n+\n+  /**\n+   * Get the value for a particular column of the Row as a long.\n+   *\n+   * @param columnName name of column.\n+   * @return column value.\n+   */\n+  Long getLong(String columnName);\n+\n+  /**\n+   * Get the value for a particular column of the Row as a double.\n+   *\n+   * @param columnIndex index of column (1-indexed).\n+   * @return column value.\n+   */\n+  Double getDouble(int columnIndex);\n+\n+  /**\n+   * Get the value for a particular column of the Row as a double.\n+   *\n+   * @param columnName name of column.\n+   * @return column value.\n+   */\n+  Double getDouble(String columnName);\n+\n+  /**\n+   * Get the value for a particular column of the Row as a boolean.\n+   *\n+   * @param columnIndex index of column (1-indexed).\n+   * @return column value.\n+   */\n+  Boolean getBoolean(int columnIndex);\n+\n+  /**\n+   * Get the value for a particular column of the Row as a boolean.\n+   *\n+   * @param columnName name of column.\n+   * @return column value.\n+   */\n+  Boolean getBoolean(String columnName);\n+\n+  /**\n+   * Get the value for a particular column of the Row as a decimal.\n+   *\n+   * @param columnIndex index of column (1-indexed).\n+   * @return column value.\n+   */\n+  BigDecimal getDecimal(int columnIndex);\n+\n+  /**\n+   * Get the value for a particular column of the Row as a decimal.\n+   *\n+   * @param columnName name of column.\n+   * @return column value.\n+   */\n+  BigDecimal getDecimal(String columnName);\n+}\n+```\n+\n+We considered representing column types in a more structured form (rather than plain strings) to accomodate complex/nested data types but felt this added complexity would not be helpful for most use cases. (This would also require a server-side change, so it's a fair bit of additional work.)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODEyMjk3Ng=="}, "originalCommit": {"oid": "aed38d5836550829f7fd459df31b47aaf7e5ad45"}, "originalPosition": 329}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDYzMjc0Ng==", "bodyText": "Resolved in https://github.com/confluentinc/ksql/pull/5236/files#r418247299", "url": "https://github.com/confluentinc/ksql/pull/5236#discussion_r420632746", "createdAt": "2020-05-06T08:43:22Z", "author": {"login": "vcrfxia"}, "path": "design-proposals/klip-26-java-client-interfaces.md", "diffHunk": "@@ -0,0 +1,715 @@\n+# KLIP 26 - Java client interfaces\n+\n+**Author**: Victoria Xia (@vcrfxia) | \n+**Release Target**: ksqlDB 0.10.0 | \n+**Status**: _In development_ | \n+**Discussion**: TBD\n+\n+**tl;dr:** _[KLIP 15](./klip-15-new-api-and-client.md) already made the case for why it makes sense\n+           to introduce a Java client for ksqlDB. This KLIP proposes interfaces for the client._\n+\n+## Motivation and background\n+\n+See [KLIP 15](./klip-15-new-api-and-client.md).\n+\n+## What is in scope\n+\n+The Java client will support the following operations:\n+* Push query\n+* Pull query\n+* Select DDL/DML operations:\n+    * `CREATE STREAM`\n+    * `CREATE TABLE`\n+    * `CREATE STREAM ... AS SELECT`\n+    * `CREATE TABLE ... AS SELECT`\n+    * `DROP STREAM`\n+    * `DROP TABLE`\n+    * `INSERT INTO`\n+    * `TERMINATE <queryId>`\n+    * `CREATE CONNECTOR`\n+    * `DROP CONNECTOR`\n+* Select admin operations:\n+    * `SHOW TOPICS` (non-extended)\n+    * `SHOW STREAMS` (non-extended)\n+    * `SHOW TABLES` (non-extended)\n+    * `SHOW QUERIES` (non-extended)\n+    * `SHOW CONNECTORS`\n+* Insert values, i.e., insert rows into an existing stream/table\n+* Terminate push query (via the `/close-query` endpoint)\n+\n+The purpose of this KLIP is to reach agreement on the interfaces / public APIs.\n+Implementation details will not be covered.\n+\n+## What is not in scope\n+\n+This KLIP does not cover Java client support for the following:\n+* `DESCRIBE <stream/table>`, `DESCRIBE CONNECTOR`, `DESCRIBE FUNCTION`\n+* `EXPLAIN <queryId>`\n+* `PRINT <topic>`\n+* `SHOW TOPICS EXTENDED`, `SHOW <STREAMS/TABLES> EXTENDED`, `SHOW QUERIES EXTENDED`\n+* `CREATE TYPE`, `DROP TYPE`, `SHOW TYPES`\n+* `SHOW FUNCTIONS`, `SHOW PROPERTIES`\n+* `RUN SCRIPT`\n+* Use of other endpoints (info, healthcheck, terminate cluster, status, etc.)\n+\n+We can always add support for these operations in the future if desired.\n+\n+As above, implementation details are out of scope as the purpose of this KLIP is to reach agreement\n+on the interfaces / public APIs.\n+\n+## Value/Return\n+\n+See [KLIP 15](./klip-15-new-api-and-client.md).\n+\n+## Public APIS\n+\n+The following subsections describe the methods of the `Client` interface:\n+```\n+public interface Client {\n+    ...\n+}\n+```\n+\n+### Constructors\n+```\n+  static Client create(ClientOptions clientOptions) {\n+    return new ClientImpl(clientOptions);\n+  }\n+\n+  static Client create(ClientOptions clientOptions, Vertx vertx) {\n+    return new ClientImpl(clientOptions, vertx);\n+  }\n+```\n+\n+The Java client will be implemented as a Vert.x HttpClient. We expose a constructor that allows users to provide their own `Vertx` instance\n+in order to take advantage of a shared connection pool and other properties if desired.\n+\n+`ClientOptions` will initially be as follows:\n+```\n+public interface ClientOptions {\n+\n+  ClientOptions setHost(String host);\n+\n+  ClientOptions setPort(int port);\n+\n+  ClientOptions setUseTls(boolean useTls);\n+\n+  ClientOptions setUseClientAuth(boolean useClientAuth);\n+\n+  ClientOptions setTrustStore(String trustStorePath);\n+\n+  ClientOptions setTrustStorePassword(String trustStorePassword);\n+\n+  ClientOptions setKeyStore(String keyStorePath);\n+\n+  ClientOptions setKeyStorePassword(String keyStorePassword);\n+\n+  ClientOptions setBasicAuthCredentials(String username, String password);\n+\n+  String getHost();\n+\n+  int getPort();\n+\n+  boolean isUseTls();\n+\n+  boolean isUseClientAuth();\n+\n+  boolean isUseBasicAuth();\n+\n+  String getTrustStore();\n+\n+  String getTrustStorePassword();\n+\n+  String getKeyStore();\n+\n+  String getKeyStorePassword();\n+\n+  String getBasicAuthUsername();\n+\n+  String getBasicAuthPassword();\n+\n+  ClientOptions copy();\n+\n+  static ClientOptions create() {\n+    return new ClientOptionsImpl();\n+  }\n+}\n+```\n+\n+We can always add additional configuration options later. We may also wish to expose the Vert.x `HttpClientOptions` for\n+advanced users that wish to provide custom configs.\n+\n+### Transient queries -- Streaming\n+\n+The `Client` interface will provide the following methods for streaming the results of a transient (push or pull) query:\n+```\n+  /**\n+   * Execute a query (push or pull) and receive the results one row at a time.\n+   *\n+   * @param sql statement of query to execute.\n+   * @return query result.\n+   */\n+  CompletableFuture<QueryResult> streamQuery(String sql);\n+\n+  /**\n+   * Execute a query (push or pull) and receive the results one row at a time.\n+   *\n+   * @param sql statement of query to execute.\n+   * @param properties query properties.\n+   * @return query result.\n+   */\n+  CompletableFuture<QueryResult> streamQuery(String sql, Map<String, Object> properties);\n+```\n+where `QueryResult` is as follows:\n+```\n+/**\n+ * The result of a query (push or pull), streamed one row at time. Records may be consumed by either\n+ * subscribing to the publisher or polling (blocking) for one record at a time. These two methods of\n+ * consumption are mutually exclusive; only one method may be used (per QueryResult).\n+ */\n+public interface QueryResult extends Publisher<Row> {\n+\n+  List<String> columnNames();\n+\n+  List<String> columnTypes();\n+\n+  String queryID();\n+\n+  /**\n+   * Block until a row becomes available.\n+   *\n+   * @return the row.\n+   */\n+  Row poll();\n+\n+  /**\n+   * Block until a row becomes available or the timeout has elapsed.\n+   *\n+   * @param timeout amount of to wait for a row. Non-positive values are interpreted as no timeout.\n+   * @param timeUnit unit for timeout param.\n+   * @return the row, if available; else, null.\n+   */\n+  Row poll(long timeout, TimeUnit timeUnit);\n+\n+  boolean isComplete();\n+\n+  void close();\n+}\n+```\n+Note that `QueryResult` is a Reactive Streams `Publisher` so users can stream results. Users can also call `poll()` to receive\n+results in a synchronous fashion instead. Only one of the two methods will be allowed per `QueryResult` instance.\n+\n+The `Row` interface is as follows:\n+```\n+/**\n+ * A single record, returned as part of a query result.\n+ */\n+public interface Row {\n+\n+  List<String> columnNames();\n+\n+  List<String> columnTypes();\n+\n+  List<Object> values();\n+\n+  /**\n+   * Get the value for a particular column of the Row as an Object.\n+   *\n+   * @param columnIndex index of column (1-indexed).\n+   * @return column value.\n+   */\n+  Object getObject(int columnIndex);\n+\n+  /**\n+   * Get the value for a particular column of the Row as an Object.\n+   *\n+   * @param columnName name of column.\n+   * @return column value.\n+   */\n+  Object getObject(String columnName);\n+\n+  /**\n+   * Get the value for a particular column of the Row as a string.\n+   *\n+   * @param columnIndex index of column (1-indexed).\n+   * @return column value.\n+   */\n+  String getString(int columnIndex);\n+\n+  /**\n+   * Get the value for a particular column of the Row as a string.\n+   *\n+   * @param columnName name of column.\n+   * @return column value.\n+   */\n+  String getString(String columnName);\n+\n+  /**\n+   * Get the value for a particular column of the Row as an integer.\n+   *\n+   * @param columnIndex index of column (1-indexed).\n+   * @return column value.\n+   */\n+  Integer getInt(int columnIndex);\n+\n+  /**\n+   * Get the value for a particular column of the Row as an integer.\n+   *\n+   * @param columnName name of column.\n+   * @return column value.\n+   */\n+  Integer getInt(String columnName);\n+\n+  /**\n+   * Get the value for a particular column of the Row as a long.\n+   *\n+   * @param columnIndex index of column (1-indexed).\n+   * @return column value.\n+   */\n+  Long getLong(int columnIndex);\n+\n+  /**\n+   * Get the value for a particular column of the Row as a long.\n+   *\n+   * @param columnName name of column.\n+   * @return column value.\n+   */\n+  Long getLong(String columnName);\n+\n+  /**\n+   * Get the value for a particular column of the Row as a double.\n+   *\n+   * @param columnIndex index of column (1-indexed).\n+   * @return column value.\n+   */\n+  Double getDouble(int columnIndex);\n+\n+  /**\n+   * Get the value for a particular column of the Row as a double.\n+   *\n+   * @param columnName name of column.\n+   * @return column value.\n+   */\n+  Double getDouble(String columnName);\n+\n+  /**\n+   * Get the value for a particular column of the Row as a boolean.\n+   *\n+   * @param columnIndex index of column (1-indexed).\n+   * @return column value.\n+   */\n+  Boolean getBoolean(int columnIndex);\n+\n+  /**\n+   * Get the value for a particular column of the Row as a boolean.\n+   *\n+   * @param columnName name of column.\n+   * @return column value.\n+   */\n+  Boolean getBoolean(String columnName);\n+\n+  /**\n+   * Get the value for a particular column of the Row as a decimal.\n+   *\n+   * @param columnIndex index of column (1-indexed).\n+   * @return column value.\n+   */\n+  BigDecimal getDecimal(int columnIndex);\n+\n+  /**\n+   * Get the value for a particular column of the Row as a decimal.\n+   *\n+   * @param columnName name of column.\n+   * @return column value.\n+   */\n+  BigDecimal getDecimal(String columnName);\n+}\n+```\n+\n+We considered representing column types in a more structured form (rather than plain strings) to accomodate complex/nested data types but felt this added complexity would not be helpful for most use cases. (This would also require a server-side change, so it's a fair bit of additional work.)\n+\n+For `getDecimal(...)` in the `Row` interface, rather than trying to parse the column type to extract the precision and scale, we will simply convert the value to a BigDecimal without explicitly specifying the precision and scale. We could also add an option for users to specify the scale and precision in the getter, if we think that would be useful.\n+\n+We could also add `getList(...)` and `getMap(...)` methods to the `Row` interface, but it's not clear to me how valuable this would be given that the nested data types would not be known.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODI0ODg0OA=="}, "originalCommit": {"oid": "aed38d5836550829f7fd459df31b47aaf7e5ad45"}, "originalPosition": 333}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDYzMzcyMw==", "bodyText": "Introduced KsqlObject and KsqlArray to wrap the Vert.x types JsonObject and JsonArray. (Not a fan of the new names but couldn't think of anything better.) Thanks for the input, all!", "url": "https://github.com/confluentinc/ksql/pull/5236#discussion_r420633723", "createdAt": "2020-05-06T08:45:03Z", "author": {"login": "vcrfxia"}, "path": "design-proposals/klip-26-java-client-interfaces.md", "diffHunk": "@@ -0,0 +1,715 @@\n+# KLIP 26 - Java client interfaces\n+\n+**Author**: Victoria Xia (@vcrfxia) | \n+**Release Target**: ksqlDB 0.10.0 | \n+**Status**: _In development_ | \n+**Discussion**: TBD\n+\n+**tl;dr:** _[KLIP 15](./klip-15-new-api-and-client.md) already made the case for why it makes sense\n+           to introduce a Java client for ksqlDB. This KLIP proposes interfaces for the client._\n+\n+## Motivation and background\n+\n+See [KLIP 15](./klip-15-new-api-and-client.md).\n+\n+## What is in scope\n+\n+The Java client will support the following operations:\n+* Push query\n+* Pull query\n+* Select DDL/DML operations:\n+    * `CREATE STREAM`\n+    * `CREATE TABLE`\n+    * `CREATE STREAM ... AS SELECT`\n+    * `CREATE TABLE ... AS SELECT`\n+    * `DROP STREAM`\n+    * `DROP TABLE`\n+    * `INSERT INTO`\n+    * `TERMINATE <queryId>`\n+    * `CREATE CONNECTOR`\n+    * `DROP CONNECTOR`\n+* Select admin operations:\n+    * `SHOW TOPICS` (non-extended)\n+    * `SHOW STREAMS` (non-extended)\n+    * `SHOW TABLES` (non-extended)\n+    * `SHOW QUERIES` (non-extended)\n+    * `SHOW CONNECTORS`\n+* Insert values, i.e., insert rows into an existing stream/table\n+* Terminate push query (via the `/close-query` endpoint)\n+\n+The purpose of this KLIP is to reach agreement on the interfaces / public APIs.\n+Implementation details will not be covered.\n+\n+## What is not in scope\n+\n+This KLIP does not cover Java client support for the following:\n+* `DESCRIBE <stream/table>`, `DESCRIBE CONNECTOR`, `DESCRIBE FUNCTION`\n+* `EXPLAIN <queryId>`\n+* `PRINT <topic>`\n+* `SHOW TOPICS EXTENDED`, `SHOW <STREAMS/TABLES> EXTENDED`, `SHOW QUERIES EXTENDED`\n+* `CREATE TYPE`, `DROP TYPE`, `SHOW TYPES`\n+* `SHOW FUNCTIONS`, `SHOW PROPERTIES`\n+* `RUN SCRIPT`\n+* Use of other endpoints (info, healthcheck, terminate cluster, status, etc.)\n+\n+We can always add support for these operations in the future if desired.\n+\n+As above, implementation details are out of scope as the purpose of this KLIP is to reach agreement\n+on the interfaces / public APIs.\n+\n+## Value/Return\n+\n+See [KLIP 15](./klip-15-new-api-and-client.md).\n+\n+## Public APIS\n+\n+The following subsections describe the methods of the `Client` interface:\n+```\n+public interface Client {\n+    ...\n+}\n+```\n+\n+### Constructors\n+```\n+  static Client create(ClientOptions clientOptions) {\n+    return new ClientImpl(clientOptions);\n+  }\n+\n+  static Client create(ClientOptions clientOptions, Vertx vertx) {\n+    return new ClientImpl(clientOptions, vertx);\n+  }\n+```\n+\n+The Java client will be implemented as a Vert.x HttpClient. We expose a constructor that allows users to provide their own `Vertx` instance\n+in order to take advantage of a shared connection pool and other properties if desired.\n+\n+`ClientOptions` will initially be as follows:\n+```\n+public interface ClientOptions {\n+\n+  ClientOptions setHost(String host);\n+\n+  ClientOptions setPort(int port);\n+\n+  ClientOptions setUseTls(boolean useTls);\n+\n+  ClientOptions setUseClientAuth(boolean useClientAuth);\n+\n+  ClientOptions setTrustStore(String trustStorePath);\n+\n+  ClientOptions setTrustStorePassword(String trustStorePassword);\n+\n+  ClientOptions setKeyStore(String keyStorePath);\n+\n+  ClientOptions setKeyStorePassword(String keyStorePassword);\n+\n+  ClientOptions setBasicAuthCredentials(String username, String password);\n+\n+  String getHost();\n+\n+  int getPort();\n+\n+  boolean isUseTls();\n+\n+  boolean isUseClientAuth();\n+\n+  boolean isUseBasicAuth();\n+\n+  String getTrustStore();\n+\n+  String getTrustStorePassword();\n+\n+  String getKeyStore();\n+\n+  String getKeyStorePassword();\n+\n+  String getBasicAuthUsername();\n+\n+  String getBasicAuthPassword();\n+\n+  ClientOptions copy();\n+\n+  static ClientOptions create() {\n+    return new ClientOptionsImpl();\n+  }\n+}\n+```\n+\n+We can always add additional configuration options later. We may also wish to expose the Vert.x `HttpClientOptions` for\n+advanced users that wish to provide custom configs.\n+\n+### Transient queries -- Streaming\n+\n+The `Client` interface will provide the following methods for streaming the results of a transient (push or pull) query:\n+```\n+  /**\n+   * Execute a query (push or pull) and receive the results one row at a time.\n+   *\n+   * @param sql statement of query to execute.\n+   * @return query result.\n+   */\n+  CompletableFuture<QueryResult> streamQuery(String sql);\n+\n+  /**\n+   * Execute a query (push or pull) and receive the results one row at a time.\n+   *\n+   * @param sql statement of query to execute.\n+   * @param properties query properties.\n+   * @return query result.\n+   */\n+  CompletableFuture<QueryResult> streamQuery(String sql, Map<String, Object> properties);\n+```\n+where `QueryResult` is as follows:\n+```\n+/**\n+ * The result of a query (push or pull), streamed one row at time. Records may be consumed by either\n+ * subscribing to the publisher or polling (blocking) for one record at a time. These two methods of\n+ * consumption are mutually exclusive; only one method may be used (per QueryResult).\n+ */\n+public interface QueryResult extends Publisher<Row> {\n+\n+  List<String> columnNames();\n+\n+  List<String> columnTypes();\n+\n+  String queryID();\n+\n+  /**\n+   * Block until a row becomes available.\n+   *\n+   * @return the row.\n+   */\n+  Row poll();\n+\n+  /**\n+   * Block until a row becomes available or the timeout has elapsed.\n+   *\n+   * @param timeout amount of to wait for a row. Non-positive values are interpreted as no timeout.\n+   * @param timeUnit unit for timeout param.\n+   * @return the row, if available; else, null.\n+   */\n+  Row poll(long timeout, TimeUnit timeUnit);\n+\n+  boolean isComplete();\n+\n+  void close();\n+}\n+```\n+Note that `QueryResult` is a Reactive Streams `Publisher` so users can stream results. Users can also call `poll()` to receive\n+results in a synchronous fashion instead. Only one of the two methods will be allowed per `QueryResult` instance.\n+\n+The `Row` interface is as follows:\n+```\n+/**\n+ * A single record, returned as part of a query result.\n+ */\n+public interface Row {\n+\n+  List<String> columnNames();\n+\n+  List<String> columnTypes();\n+\n+  List<Object> values();\n+\n+  /**\n+   * Get the value for a particular column of the Row as an Object.\n+   *\n+   * @param columnIndex index of column (1-indexed).\n+   * @return column value.\n+   */\n+  Object getObject(int columnIndex);\n+\n+  /**\n+   * Get the value for a particular column of the Row as an Object.\n+   *\n+   * @param columnName name of column.\n+   * @return column value.\n+   */\n+  Object getObject(String columnName);\n+\n+  /**\n+   * Get the value for a particular column of the Row as a string.\n+   *\n+   * @param columnIndex index of column (1-indexed).\n+   * @return column value.\n+   */\n+  String getString(int columnIndex);\n+\n+  /**\n+   * Get the value for a particular column of the Row as a string.\n+   *\n+   * @param columnName name of column.\n+   * @return column value.\n+   */\n+  String getString(String columnName);\n+\n+  /**\n+   * Get the value for a particular column of the Row as an integer.\n+   *\n+   * @param columnIndex index of column (1-indexed).\n+   * @return column value.\n+   */\n+  Integer getInt(int columnIndex);\n+\n+  /**\n+   * Get the value for a particular column of the Row as an integer.\n+   *\n+   * @param columnName name of column.\n+   * @return column value.\n+   */\n+  Integer getInt(String columnName);\n+\n+  /**\n+   * Get the value for a particular column of the Row as a long.\n+   *\n+   * @param columnIndex index of column (1-indexed).\n+   * @return column value.\n+   */\n+  Long getLong(int columnIndex);\n+\n+  /**\n+   * Get the value for a particular column of the Row as a long.\n+   *\n+   * @param columnName name of column.\n+   * @return column value.\n+   */\n+  Long getLong(String columnName);\n+\n+  /**\n+   * Get the value for a particular column of the Row as a double.\n+   *\n+   * @param columnIndex index of column (1-indexed).\n+   * @return column value.\n+   */\n+  Double getDouble(int columnIndex);\n+\n+  /**\n+   * Get the value for a particular column of the Row as a double.\n+   *\n+   * @param columnName name of column.\n+   * @return column value.\n+   */\n+  Double getDouble(String columnName);\n+\n+  /**\n+   * Get the value for a particular column of the Row as a boolean.\n+   *\n+   * @param columnIndex index of column (1-indexed).\n+   * @return column value.\n+   */\n+  Boolean getBoolean(int columnIndex);\n+\n+  /**\n+   * Get the value for a particular column of the Row as a boolean.\n+   *\n+   * @param columnName name of column.\n+   * @return column value.\n+   */\n+  Boolean getBoolean(String columnName);\n+\n+  /**\n+   * Get the value for a particular column of the Row as a decimal.\n+   *\n+   * @param columnIndex index of column (1-indexed).\n+   * @return column value.\n+   */\n+  BigDecimal getDecimal(int columnIndex);\n+\n+  /**\n+   * Get the value for a particular column of the Row as a decimal.\n+   *\n+   * @param columnName name of column.\n+   * @return column value.\n+   */\n+  BigDecimal getDecimal(String columnName);\n+}\n+```\n+\n+We considered representing column types in a more structured form (rather than plain strings) to accomodate complex/nested data types but felt this added complexity would not be helpful for most use cases. (This would also require a server-side change, so it's a fair bit of additional work.)\n+\n+For `getDecimal(...)` in the `Row` interface, rather than trying to parse the column type to extract the precision and scale, we will simply convert the value to a BigDecimal without explicitly specifying the precision and scale. We could also add an option for users to specify the scale and precision in the getter, if we think that would be useful.\n+\n+We could also add `getList(...)` and `getMap(...)` methods to the `Row` interface, but it's not clear to me how valuable this would be given that the nested data types would not be known.\n+\n+Tim also proposed switching from generic Java types (`Map<String, Object>`, `List<Object>`) to Vert.x types (`JsonObject`, `JsonArray`) as the latter is more type-safe and the client already has a dependency on Vert.x anyway. The downside, though, is that then apps that use the client would be required to depend on Vert.x as well.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODEyNDk5NA=="}, "originalCommit": {"oid": "aed38d5836550829f7fd459df31b47aaf7e5ad45"}, "originalPosition": 335}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDYzNDMxMw==", "bodyText": "@mjsax do you have thoughts on what might be better/clearer names?", "url": "https://github.com/confluentinc/ksql/pull/5236#discussion_r420634313", "createdAt": "2020-05-06T08:45:58Z", "author": {"login": "vcrfxia"}, "path": "design-proposals/klip-26-java-client-interfaces.md", "diffHunk": "@@ -0,0 +1,715 @@\n+# KLIP 26 - Java client interfaces\n+\n+**Author**: Victoria Xia (@vcrfxia) | \n+**Release Target**: ksqlDB 0.10.0 | \n+**Status**: _In development_ | \n+**Discussion**: TBD\n+\n+**tl;dr:** _[KLIP 15](./klip-15-new-api-and-client.md) already made the case for why it makes sense\n+           to introduce a Java client for ksqlDB. This KLIP proposes interfaces for the client._\n+\n+## Motivation and background\n+\n+See [KLIP 15](./klip-15-new-api-and-client.md).\n+\n+## What is in scope\n+\n+The Java client will support the following operations:\n+* Push query\n+* Pull query\n+* Select DDL/DML operations:\n+    * `CREATE STREAM`\n+    * `CREATE TABLE`\n+    * `CREATE STREAM ... AS SELECT`\n+    * `CREATE TABLE ... AS SELECT`\n+    * `DROP STREAM`\n+    * `DROP TABLE`\n+    * `INSERT INTO`\n+    * `TERMINATE <queryId>`\n+    * `CREATE CONNECTOR`\n+    * `DROP CONNECTOR`\n+* Select admin operations:\n+    * `SHOW TOPICS` (non-extended)\n+    * `SHOW STREAMS` (non-extended)\n+    * `SHOW TABLES` (non-extended)\n+    * `SHOW QUERIES` (non-extended)\n+    * `SHOW CONNECTORS`\n+* Insert values, i.e., insert rows into an existing stream/table\n+* Terminate push query (via the `/close-query` endpoint)\n+\n+The purpose of this KLIP is to reach agreement on the interfaces / public APIs.\n+Implementation details will not be covered.\n+\n+## What is not in scope\n+\n+This KLIP does not cover Java client support for the following:\n+* `DESCRIBE <stream/table>`, `DESCRIBE CONNECTOR`, `DESCRIBE FUNCTION`\n+* `EXPLAIN <queryId>`\n+* `PRINT <topic>`\n+* `SHOW TOPICS EXTENDED`, `SHOW <STREAMS/TABLES> EXTENDED`, `SHOW QUERIES EXTENDED`\n+* `CREATE TYPE`, `DROP TYPE`, `SHOW TYPES`\n+* `SHOW FUNCTIONS`, `SHOW PROPERTIES`\n+* `RUN SCRIPT`\n+* Use of other endpoints (info, healthcheck, terminate cluster, status, etc.)\n+\n+We can always add support for these operations in the future if desired.\n+\n+As above, implementation details are out of scope as the purpose of this KLIP is to reach agreement\n+on the interfaces / public APIs.\n+\n+## Value/Return\n+\n+See [KLIP 15](./klip-15-new-api-and-client.md).\n+\n+## Public APIS\n+\n+The following subsections describe the methods of the `Client` interface:\n+```\n+public interface Client {\n+    ...\n+}\n+```\n+\n+### Constructors\n+```\n+  static Client create(ClientOptions clientOptions) {\n+    return new ClientImpl(clientOptions);\n+  }\n+\n+  static Client create(ClientOptions clientOptions, Vertx vertx) {\n+    return new ClientImpl(clientOptions, vertx);\n+  }\n+```\n+\n+The Java client will be implemented as a Vert.x HttpClient. We expose a constructor that allows users to provide their own `Vertx` instance\n+in order to take advantage of a shared connection pool and other properties if desired.\n+\n+`ClientOptions` will initially be as follows:\n+```\n+public interface ClientOptions {\n+\n+  ClientOptions setHost(String host);\n+\n+  ClientOptions setPort(int port);\n+\n+  ClientOptions setUseTls(boolean useTls);\n+\n+  ClientOptions setUseClientAuth(boolean useClientAuth);\n+\n+  ClientOptions setTrustStore(String trustStorePath);\n+\n+  ClientOptions setTrustStorePassword(String trustStorePassword);\n+\n+  ClientOptions setKeyStore(String keyStorePath);\n+\n+  ClientOptions setKeyStorePassword(String keyStorePassword);\n+\n+  ClientOptions setBasicAuthCredentials(String username, String password);\n+\n+  String getHost();\n+\n+  int getPort();\n+\n+  boolean isUseTls();\n+\n+  boolean isUseClientAuth();\n+\n+  boolean isUseBasicAuth();\n+\n+  String getTrustStore();\n+\n+  String getTrustStorePassword();\n+\n+  String getKeyStore();\n+\n+  String getKeyStorePassword();\n+\n+  String getBasicAuthUsername();\n+\n+  String getBasicAuthPassword();\n+\n+  ClientOptions copy();\n+\n+  static ClientOptions create() {\n+    return new ClientOptionsImpl();\n+  }\n+}\n+```\n+\n+We can always add additional configuration options later. We may also wish to expose the Vert.x `HttpClientOptions` for\n+advanced users that wish to provide custom configs.\n+\n+### Transient queries -- Streaming\n+\n+The `Client` interface will provide the following methods for streaming the results of a transient (push or pull) query:\n+```\n+  /**\n+   * Execute a query (push or pull) and receive the results one row at a time.\n+   *\n+   * @param sql statement of query to execute.\n+   * @return query result.\n+   */\n+  CompletableFuture<QueryResult> streamQuery(String sql);\n+\n+  /**\n+   * Execute a query (push or pull) and receive the results one row at a time.\n+   *\n+   * @param sql statement of query to execute.\n+   * @param properties query properties.\n+   * @return query result.\n+   */\n+  CompletableFuture<QueryResult> streamQuery(String sql, Map<String, Object> properties);\n+```\n+where `QueryResult` is as follows:\n+```\n+/**\n+ * The result of a query (push or pull), streamed one row at time. Records may be consumed by either\n+ * subscribing to the publisher or polling (blocking) for one record at a time. These two methods of\n+ * consumption are mutually exclusive; only one method may be used (per QueryResult).\n+ */\n+public interface QueryResult extends Publisher<Row> {\n+\n+  List<String> columnNames();\n+\n+  List<String> columnTypes();\n+\n+  String queryID();\n+\n+  /**\n+   * Block until a row becomes available.\n+   *\n+   * @return the row.\n+   */\n+  Row poll();\n+\n+  /**\n+   * Block until a row becomes available or the timeout has elapsed.\n+   *\n+   * @param timeout amount of to wait for a row. Non-positive values are interpreted as no timeout.\n+   * @param timeUnit unit for timeout param.\n+   * @return the row, if available; else, null.\n+   */\n+  Row poll(long timeout, TimeUnit timeUnit);\n+\n+  boolean isComplete();\n+\n+  void close();\n+}\n+```\n+Note that `QueryResult` is a Reactive Streams `Publisher` so users can stream results. Users can also call `poll()` to receive\n+results in a synchronous fashion instead. Only one of the two methods will be allowed per `QueryResult` instance.\n+\n+The `Row` interface is as follows:\n+```\n+/**\n+ * A single record, returned as part of a query result.\n+ */\n+public interface Row {\n+\n+  List<String> columnNames();\n+\n+  List<String> columnTypes();\n+\n+  List<Object> values();\n+\n+  /**\n+   * Get the value for a particular column of the Row as an Object.\n+   *\n+   * @param columnIndex index of column (1-indexed).\n+   * @return column value.\n+   */\n+  Object getObject(int columnIndex);\n+\n+  /**\n+   * Get the value for a particular column of the Row as an Object.\n+   *\n+   * @param columnName name of column.\n+   * @return column value.\n+   */\n+  Object getObject(String columnName);\n+\n+  /**\n+   * Get the value for a particular column of the Row as a string.\n+   *\n+   * @param columnIndex index of column (1-indexed).\n+   * @return column value.\n+   */\n+  String getString(int columnIndex);\n+\n+  /**\n+   * Get the value for a particular column of the Row as a string.\n+   *\n+   * @param columnName name of column.\n+   * @return column value.\n+   */\n+  String getString(String columnName);\n+\n+  /**\n+   * Get the value for a particular column of the Row as an integer.\n+   *\n+   * @param columnIndex index of column (1-indexed).\n+   * @return column value.\n+   */\n+  Integer getInt(int columnIndex);\n+\n+  /**\n+   * Get the value for a particular column of the Row as an integer.\n+   *\n+   * @param columnName name of column.\n+   * @return column value.\n+   */\n+  Integer getInt(String columnName);\n+\n+  /**\n+   * Get the value for a particular column of the Row as a long.\n+   *\n+   * @param columnIndex index of column (1-indexed).\n+   * @return column value.\n+   */\n+  Long getLong(int columnIndex);\n+\n+  /**\n+   * Get the value for a particular column of the Row as a long.\n+   *\n+   * @param columnName name of column.\n+   * @return column value.\n+   */\n+  Long getLong(String columnName);\n+\n+  /**\n+   * Get the value for a particular column of the Row as a double.\n+   *\n+   * @param columnIndex index of column (1-indexed).\n+   * @return column value.\n+   */\n+  Double getDouble(int columnIndex);\n+\n+  /**\n+   * Get the value for a particular column of the Row as a double.\n+   *\n+   * @param columnName name of column.\n+   * @return column value.\n+   */\n+  Double getDouble(String columnName);\n+\n+  /**\n+   * Get the value for a particular column of the Row as a boolean.\n+   *\n+   * @param columnIndex index of column (1-indexed).\n+   * @return column value.\n+   */\n+  Boolean getBoolean(int columnIndex);\n+\n+  /**\n+   * Get the value for a particular column of the Row as a boolean.\n+   *\n+   * @param columnName name of column.\n+   * @return column value.\n+   */\n+  Boolean getBoolean(String columnName);\n+\n+  /**\n+   * Get the value for a particular column of the Row as a decimal.\n+   *\n+   * @param columnIndex index of column (1-indexed).\n+   * @return column value.\n+   */\n+  BigDecimal getDecimal(int columnIndex);\n+\n+  /**\n+   * Get the value for a particular column of the Row as a decimal.\n+   *\n+   * @param columnName name of column.\n+   * @return column value.\n+   */\n+  BigDecimal getDecimal(String columnName);\n+}\n+```\n+\n+We considered representing column types in a more structured form (rather than plain strings) to accomodate complex/nested data types but felt this added complexity would not be helpful for most use cases. (This would also require a server-side change, so it's a fair bit of additional work.)\n+\n+For `getDecimal(...)` in the `Row` interface, rather than trying to parse the column type to extract the precision and scale, we will simply convert the value to a BigDecimal without explicitly specifying the precision and scale. We could also add an option for users to specify the scale and precision in the getter, if we think that would be useful.\n+\n+We could also add `getList(...)` and `getMap(...)` methods to the `Row` interface, but it's not clear to me how valuable this would be given that the nested data types would not be known.\n+\n+Tim also proposed switching from generic Java types (`Map<String, Object>`, `List<Object>`) to Vert.x types (`JsonObject`, `JsonArray`) as the latter is more type-safe and the client already has a dependency on Vert.x anyway. The downside, though, is that then apps that use the client would be required to depend on Vert.x as well.\n+\n+### Transient queries -- Non-streaming\n+\n+The `Client` interface will also provide the following methods for receiving the results of a transient query (push or pull) in a single batch (non-streaming),", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODI0OTkyOA=="}, "originalCommit": {"oid": "aed38d5836550829f7fd459df31b47aaf7e5ad45"}, "originalPosition": 339}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDYzNjM3Mw==", "bodyText": "Updated this to just have executeStatement() (as you suggested) rather than separate executeDdl() and executeDml() methods to avoid this confusion.\nMy instinct says the client shouldn't be in the business of parsing statements if we can avoid it as it seems cumbersome to have to worry about parsing logic in two places, though I'm curious what the arguments in favor of client parsing are.", "url": "https://github.com/confluentinc/ksql/pull/5236#discussion_r420636373", "createdAt": "2020-05-06T08:49:54Z", "author": {"login": "vcrfxia"}, "path": "design-proposals/klip-26-java-client-interfaces.md", "diffHunk": "@@ -0,0 +1,715 @@\n+# KLIP 26 - Java client interfaces\n+\n+**Author**: Victoria Xia (@vcrfxia) | \n+**Release Target**: ksqlDB 0.10.0 | \n+**Status**: _In development_ | \n+**Discussion**: TBD\n+\n+**tl;dr:** _[KLIP 15](./klip-15-new-api-and-client.md) already made the case for why it makes sense\n+           to introduce a Java client for ksqlDB. This KLIP proposes interfaces for the client._\n+\n+## Motivation and background\n+\n+See [KLIP 15](./klip-15-new-api-and-client.md).\n+\n+## What is in scope\n+\n+The Java client will support the following operations:\n+* Push query\n+* Pull query\n+* Select DDL/DML operations:\n+    * `CREATE STREAM`\n+    * `CREATE TABLE`\n+    * `CREATE STREAM ... AS SELECT`\n+    * `CREATE TABLE ... AS SELECT`\n+    * `DROP STREAM`\n+    * `DROP TABLE`\n+    * `INSERT INTO`\n+    * `TERMINATE <queryId>`\n+    * `CREATE CONNECTOR`\n+    * `DROP CONNECTOR`\n+* Select admin operations:\n+    * `SHOW TOPICS` (non-extended)\n+    * `SHOW STREAMS` (non-extended)\n+    * `SHOW TABLES` (non-extended)\n+    * `SHOW QUERIES` (non-extended)\n+    * `SHOW CONNECTORS`\n+* Insert values, i.e., insert rows into an existing stream/table\n+* Terminate push query (via the `/close-query` endpoint)\n+\n+The purpose of this KLIP is to reach agreement on the interfaces / public APIs.\n+Implementation details will not be covered.\n+\n+## What is not in scope\n+\n+This KLIP does not cover Java client support for the following:\n+* `DESCRIBE <stream/table>`, `DESCRIBE CONNECTOR`, `DESCRIBE FUNCTION`\n+* `EXPLAIN <queryId>`\n+* `PRINT <topic>`\n+* `SHOW TOPICS EXTENDED`, `SHOW <STREAMS/TABLES> EXTENDED`, `SHOW QUERIES EXTENDED`\n+* `CREATE TYPE`, `DROP TYPE`, `SHOW TYPES`\n+* `SHOW FUNCTIONS`, `SHOW PROPERTIES`\n+* `RUN SCRIPT`\n+* Use of other endpoints (info, healthcheck, terminate cluster, status, etc.)\n+\n+We can always add support for these operations in the future if desired.\n+\n+As above, implementation details are out of scope as the purpose of this KLIP is to reach agreement\n+on the interfaces / public APIs.\n+\n+## Value/Return\n+\n+See [KLIP 15](./klip-15-new-api-and-client.md).\n+\n+## Public APIS\n+\n+The following subsections describe the methods of the `Client` interface:\n+```\n+public interface Client {\n+    ...\n+}\n+```\n+\n+### Constructors\n+```\n+  static Client create(ClientOptions clientOptions) {\n+    return new ClientImpl(clientOptions);\n+  }\n+\n+  static Client create(ClientOptions clientOptions, Vertx vertx) {\n+    return new ClientImpl(clientOptions, vertx);\n+  }\n+```\n+\n+The Java client will be implemented as a Vert.x HttpClient. We expose a constructor that allows users to provide their own `Vertx` instance\n+in order to take advantage of a shared connection pool and other properties if desired.\n+\n+`ClientOptions` will initially be as follows:\n+```\n+public interface ClientOptions {\n+\n+  ClientOptions setHost(String host);\n+\n+  ClientOptions setPort(int port);\n+\n+  ClientOptions setUseTls(boolean useTls);\n+\n+  ClientOptions setUseClientAuth(boolean useClientAuth);\n+\n+  ClientOptions setTrustStore(String trustStorePath);\n+\n+  ClientOptions setTrustStorePassword(String trustStorePassword);\n+\n+  ClientOptions setKeyStore(String keyStorePath);\n+\n+  ClientOptions setKeyStorePassword(String keyStorePassword);\n+\n+  ClientOptions setBasicAuthCredentials(String username, String password);\n+\n+  String getHost();\n+\n+  int getPort();\n+\n+  boolean isUseTls();\n+\n+  boolean isUseClientAuth();\n+\n+  boolean isUseBasicAuth();\n+\n+  String getTrustStore();\n+\n+  String getTrustStorePassword();\n+\n+  String getKeyStore();\n+\n+  String getKeyStorePassword();\n+\n+  String getBasicAuthUsername();\n+\n+  String getBasicAuthPassword();\n+\n+  ClientOptions copy();\n+\n+  static ClientOptions create() {\n+    return new ClientOptionsImpl();\n+  }\n+}\n+```\n+\n+We can always add additional configuration options later. We may also wish to expose the Vert.x `HttpClientOptions` for\n+advanced users that wish to provide custom configs.\n+\n+### Transient queries -- Streaming\n+\n+The `Client` interface will provide the following methods for streaming the results of a transient (push or pull) query:\n+```\n+  /**\n+   * Execute a query (push or pull) and receive the results one row at a time.\n+   *\n+   * @param sql statement of query to execute.\n+   * @return query result.\n+   */\n+  CompletableFuture<QueryResult> streamQuery(String sql);\n+\n+  /**\n+   * Execute a query (push or pull) and receive the results one row at a time.\n+   *\n+   * @param sql statement of query to execute.\n+   * @param properties query properties.\n+   * @return query result.\n+   */\n+  CompletableFuture<QueryResult> streamQuery(String sql, Map<String, Object> properties);\n+```\n+where `QueryResult` is as follows:\n+```\n+/**\n+ * The result of a query (push or pull), streamed one row at time. Records may be consumed by either\n+ * subscribing to the publisher or polling (blocking) for one record at a time. These two methods of\n+ * consumption are mutually exclusive; only one method may be used (per QueryResult).\n+ */\n+public interface QueryResult extends Publisher<Row> {\n+\n+  List<String> columnNames();\n+\n+  List<String> columnTypes();\n+\n+  String queryID();\n+\n+  /**\n+   * Block until a row becomes available.\n+   *\n+   * @return the row.\n+   */\n+  Row poll();\n+\n+  /**\n+   * Block until a row becomes available or the timeout has elapsed.\n+   *\n+   * @param timeout amount of to wait for a row. Non-positive values are interpreted as no timeout.\n+   * @param timeUnit unit for timeout param.\n+   * @return the row, if available; else, null.\n+   */\n+  Row poll(long timeout, TimeUnit timeUnit);\n+\n+  boolean isComplete();\n+\n+  void close();\n+}\n+```\n+Note that `QueryResult` is a Reactive Streams `Publisher` so users can stream results. Users can also call `poll()` to receive\n+results in a synchronous fashion instead. Only one of the two methods will be allowed per `QueryResult` instance.\n+\n+The `Row` interface is as follows:\n+```\n+/**\n+ * A single record, returned as part of a query result.\n+ */\n+public interface Row {\n+\n+  List<String> columnNames();\n+\n+  List<String> columnTypes();\n+\n+  List<Object> values();\n+\n+  /**\n+   * Get the value for a particular column of the Row as an Object.\n+   *\n+   * @param columnIndex index of column (1-indexed).\n+   * @return column value.\n+   */\n+  Object getObject(int columnIndex);\n+\n+  /**\n+   * Get the value for a particular column of the Row as an Object.\n+   *\n+   * @param columnName name of column.\n+   * @return column value.\n+   */\n+  Object getObject(String columnName);\n+\n+  /**\n+   * Get the value for a particular column of the Row as a string.\n+   *\n+   * @param columnIndex index of column (1-indexed).\n+   * @return column value.\n+   */\n+  String getString(int columnIndex);\n+\n+  /**\n+   * Get the value for a particular column of the Row as a string.\n+   *\n+   * @param columnName name of column.\n+   * @return column value.\n+   */\n+  String getString(String columnName);\n+\n+  /**\n+   * Get the value for a particular column of the Row as an integer.\n+   *\n+   * @param columnIndex index of column (1-indexed).\n+   * @return column value.\n+   */\n+  Integer getInt(int columnIndex);\n+\n+  /**\n+   * Get the value for a particular column of the Row as an integer.\n+   *\n+   * @param columnName name of column.\n+   * @return column value.\n+   */\n+  Integer getInt(String columnName);\n+\n+  /**\n+   * Get the value for a particular column of the Row as a long.\n+   *\n+   * @param columnIndex index of column (1-indexed).\n+   * @return column value.\n+   */\n+  Long getLong(int columnIndex);\n+\n+  /**\n+   * Get the value for a particular column of the Row as a long.\n+   *\n+   * @param columnName name of column.\n+   * @return column value.\n+   */\n+  Long getLong(String columnName);\n+\n+  /**\n+   * Get the value for a particular column of the Row as a double.\n+   *\n+   * @param columnIndex index of column (1-indexed).\n+   * @return column value.\n+   */\n+  Double getDouble(int columnIndex);\n+\n+  /**\n+   * Get the value for a particular column of the Row as a double.\n+   *\n+   * @param columnName name of column.\n+   * @return column value.\n+   */\n+  Double getDouble(String columnName);\n+\n+  /**\n+   * Get the value for a particular column of the Row as a boolean.\n+   *\n+   * @param columnIndex index of column (1-indexed).\n+   * @return column value.\n+   */\n+  Boolean getBoolean(int columnIndex);\n+\n+  /**\n+   * Get the value for a particular column of the Row as a boolean.\n+   *\n+   * @param columnName name of column.\n+   * @return column value.\n+   */\n+  Boolean getBoolean(String columnName);\n+\n+  /**\n+   * Get the value for a particular column of the Row as a decimal.\n+   *\n+   * @param columnIndex index of column (1-indexed).\n+   * @return column value.\n+   */\n+  BigDecimal getDecimal(int columnIndex);\n+\n+  /**\n+   * Get the value for a particular column of the Row as a decimal.\n+   *\n+   * @param columnName name of column.\n+   * @return column value.\n+   */\n+  BigDecimal getDecimal(String columnName);\n+}\n+```\n+\n+We considered representing column types in a more structured form (rather than plain strings) to accomodate complex/nested data types but felt this added complexity would not be helpful for most use cases. (This would also require a server-side change, so it's a fair bit of additional work.)\n+\n+For `getDecimal(...)` in the `Row` interface, rather than trying to parse the column type to extract the precision and scale, we will simply convert the value to a BigDecimal without explicitly specifying the precision and scale. We could also add an option for users to specify the scale and precision in the getter, if we think that would be useful.\n+\n+We could also add `getList(...)` and `getMap(...)` methods to the `Row` interface, but it's not clear to me how valuable this would be given that the nested data types would not be known.\n+\n+Tim also proposed switching from generic Java types (`Map<String, Object>`, `List<Object>`) to Vert.x types (`JsonObject`, `JsonArray`) as the latter is more type-safe and the client already has a dependency on Vert.x anyway. The downside, though, is that then apps that use the client would be required to depend on Vert.x as well.\n+\n+### Transient queries -- Non-streaming\n+\n+The `Client` interface will also provide the following methods for receiving the results of a transient query (push or pull) in a single batch (non-streaming),\n+once the query has completed:\n+```\n+  /**\n+   * Execute a query (push or pull) and receive all result rows together, once the query has\n+   * completed.\n+   *\n+   * @param sql statement of query to execute.\n+   * @return query result.\n+   */\n+  CompletableFuture<List<Row>> executeQuery(String sql);\n+\n+  /**\n+   * Execute a query (push or pull) and receive all result rows together, once the query has\n+   * completed.\n+   *\n+   * @param sql statement of query to execute.\n+   * @param properties query properties.\n+   * @return query result.\n+   */\n+  CompletableFuture<List<Row>> executeQuery(String sql, Map<String, Object> properties);\n+```\n+\n+For a query to \"complete\" could mean:\n+* The query is a pull query\n+* The query is a push query with a limit clause, and the limit has been reached\n+* The query is a push query that has been terminated\n+\n+We may want to introduce a limit to the number of rows that may be returned from these `executeQuery()` methods,\n+in order to decrease the likelihood of running out of memory.\n+\n+### Insert values\n+\n+A method to insert one row at a time:\n+```\n+  /**\n+   * Insert a single row into the relevant stream/table.\n+   *\n+   * @param streamName name of stream/table.\n+   * @param row the row to insert.\n+   * @return a future that completes once the request has been processed.\n+   */\n+  CompletableFuture<Void> insertInto(String streamName, Map<String, Object> row);\n+```\n+\n+A method to stream inserts (via the `/inserts-stream` endpoint):\n+```\n+  CompletableFuture<Publisher<InsertResponse>> streamInserts(String streamName, Publisher<List<Object>> insertsPublisher);\n+}\n+```\n+where `InsertResponse` is as follows:\n+```\n+public interface InsertResponse {\n+\n+  /**\n+   * Whether the row was successfully inserted or not.\n+   */\n+  boolean isSuccessful();\n+\n+  /**\n+   * Unique sequence number for the row in the stream of inserts.\n+   */\n+  int getSequenceNum();\n+\n+  /**\n+   * If unsuccessful, the error message.\n+   */\n+  String getErrorMessage();\n+\n+  /**\n+   * If unsuccessful, the error code.\n+   */\n+  int getErrorCode();\n+\n+}\n+```\n+\n+### DDL/DML operations\n+\n+#### `CREATE <STREAM/TABLE>`, `CREATE <STREAM/TABLE> ... AS SELECT`, `INSERT INTO`\n+\n+`Client` methods:\n+```\n+  /**\n+   * Execute DDL statement: `CREATE STREAM`, `CREATE TABLE`\n+   */\n+  CompletableFuture<DdlResponse> executeDdl(String sql);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODEzMTM1NQ=="}, "originalCommit": {"oid": "aed38d5836550829f7fd459df31b47aaf7e5ad45"}, "originalPosition": 425}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDYzNzE3Ng==", "bodyText": "As mentioned above, I've updated this to just have executeStatement() (as Almog suggested) rather than separate executeDdl() and executeDml() methods to avoid this confusion.", "url": "https://github.com/confluentinc/ksql/pull/5236#discussion_r420637176", "createdAt": "2020-05-06T08:51:21Z", "author": {"login": "vcrfxia"}, "path": "design-proposals/klip-26-java-client-interfaces.md", "diffHunk": "@@ -0,0 +1,715 @@\n+# KLIP 26 - Java client interfaces\n+\n+**Author**: Victoria Xia (@vcrfxia) | \n+**Release Target**: ksqlDB 0.10.0 | \n+**Status**: _In development_ | \n+**Discussion**: TBD\n+\n+**tl;dr:** _[KLIP 15](./klip-15-new-api-and-client.md) already made the case for why it makes sense\n+           to introduce a Java client for ksqlDB. This KLIP proposes interfaces for the client._\n+\n+## Motivation and background\n+\n+See [KLIP 15](./klip-15-new-api-and-client.md).\n+\n+## What is in scope\n+\n+The Java client will support the following operations:\n+* Push query\n+* Pull query\n+* Select DDL/DML operations:\n+    * `CREATE STREAM`\n+    * `CREATE TABLE`\n+    * `CREATE STREAM ... AS SELECT`\n+    * `CREATE TABLE ... AS SELECT`\n+    * `DROP STREAM`\n+    * `DROP TABLE`\n+    * `INSERT INTO`\n+    * `TERMINATE <queryId>`\n+    * `CREATE CONNECTOR`\n+    * `DROP CONNECTOR`\n+* Select admin operations:\n+    * `SHOW TOPICS` (non-extended)\n+    * `SHOW STREAMS` (non-extended)\n+    * `SHOW TABLES` (non-extended)\n+    * `SHOW QUERIES` (non-extended)\n+    * `SHOW CONNECTORS`\n+* Insert values, i.e., insert rows into an existing stream/table\n+* Terminate push query (via the `/close-query` endpoint)\n+\n+The purpose of this KLIP is to reach agreement on the interfaces / public APIs.\n+Implementation details will not be covered.\n+\n+## What is not in scope\n+\n+This KLIP does not cover Java client support for the following:\n+* `DESCRIBE <stream/table>`, `DESCRIBE CONNECTOR`, `DESCRIBE FUNCTION`\n+* `EXPLAIN <queryId>`\n+* `PRINT <topic>`\n+* `SHOW TOPICS EXTENDED`, `SHOW <STREAMS/TABLES> EXTENDED`, `SHOW QUERIES EXTENDED`\n+* `CREATE TYPE`, `DROP TYPE`, `SHOW TYPES`\n+* `SHOW FUNCTIONS`, `SHOW PROPERTIES`\n+* `RUN SCRIPT`\n+* Use of other endpoints (info, healthcheck, terminate cluster, status, etc.)\n+\n+We can always add support for these operations in the future if desired.\n+\n+As above, implementation details are out of scope as the purpose of this KLIP is to reach agreement\n+on the interfaces / public APIs.\n+\n+## Value/Return\n+\n+See [KLIP 15](./klip-15-new-api-and-client.md).\n+\n+## Public APIS\n+\n+The following subsections describe the methods of the `Client` interface:\n+```\n+public interface Client {\n+    ...\n+}\n+```\n+\n+### Constructors\n+```\n+  static Client create(ClientOptions clientOptions) {\n+    return new ClientImpl(clientOptions);\n+  }\n+\n+  static Client create(ClientOptions clientOptions, Vertx vertx) {\n+    return new ClientImpl(clientOptions, vertx);\n+  }\n+```\n+\n+The Java client will be implemented as a Vert.x HttpClient. We expose a constructor that allows users to provide their own `Vertx` instance\n+in order to take advantage of a shared connection pool and other properties if desired.\n+\n+`ClientOptions` will initially be as follows:\n+```\n+public interface ClientOptions {\n+\n+  ClientOptions setHost(String host);\n+\n+  ClientOptions setPort(int port);\n+\n+  ClientOptions setUseTls(boolean useTls);\n+\n+  ClientOptions setUseClientAuth(boolean useClientAuth);\n+\n+  ClientOptions setTrustStore(String trustStorePath);\n+\n+  ClientOptions setTrustStorePassword(String trustStorePassword);\n+\n+  ClientOptions setKeyStore(String keyStorePath);\n+\n+  ClientOptions setKeyStorePassword(String keyStorePassword);\n+\n+  ClientOptions setBasicAuthCredentials(String username, String password);\n+\n+  String getHost();\n+\n+  int getPort();\n+\n+  boolean isUseTls();\n+\n+  boolean isUseClientAuth();\n+\n+  boolean isUseBasicAuth();\n+\n+  String getTrustStore();\n+\n+  String getTrustStorePassword();\n+\n+  String getKeyStore();\n+\n+  String getKeyStorePassword();\n+\n+  String getBasicAuthUsername();\n+\n+  String getBasicAuthPassword();\n+\n+  ClientOptions copy();\n+\n+  static ClientOptions create() {\n+    return new ClientOptionsImpl();\n+  }\n+}\n+```\n+\n+We can always add additional configuration options later. We may also wish to expose the Vert.x `HttpClientOptions` for\n+advanced users that wish to provide custom configs.\n+\n+### Transient queries -- Streaming\n+\n+The `Client` interface will provide the following methods for streaming the results of a transient (push or pull) query:\n+```\n+  /**\n+   * Execute a query (push or pull) and receive the results one row at a time.\n+   *\n+   * @param sql statement of query to execute.\n+   * @return query result.\n+   */\n+  CompletableFuture<QueryResult> streamQuery(String sql);\n+\n+  /**\n+   * Execute a query (push or pull) and receive the results one row at a time.\n+   *\n+   * @param sql statement of query to execute.\n+   * @param properties query properties.\n+   * @return query result.\n+   */\n+  CompletableFuture<QueryResult> streamQuery(String sql, Map<String, Object> properties);\n+```\n+where `QueryResult` is as follows:\n+```\n+/**\n+ * The result of a query (push or pull), streamed one row at time. Records may be consumed by either\n+ * subscribing to the publisher or polling (blocking) for one record at a time. These two methods of\n+ * consumption are mutually exclusive; only one method may be used (per QueryResult).\n+ */\n+public interface QueryResult extends Publisher<Row> {\n+\n+  List<String> columnNames();\n+\n+  List<String> columnTypes();\n+\n+  String queryID();\n+\n+  /**\n+   * Block until a row becomes available.\n+   *\n+   * @return the row.\n+   */\n+  Row poll();\n+\n+  /**\n+   * Block until a row becomes available or the timeout has elapsed.\n+   *\n+   * @param timeout amount of to wait for a row. Non-positive values are interpreted as no timeout.\n+   * @param timeUnit unit for timeout param.\n+   * @return the row, if available; else, null.\n+   */\n+  Row poll(long timeout, TimeUnit timeUnit);\n+\n+  boolean isComplete();\n+\n+  void close();\n+}\n+```\n+Note that `QueryResult` is a Reactive Streams `Publisher` so users can stream results. Users can also call `poll()` to receive\n+results in a synchronous fashion instead. Only one of the two methods will be allowed per `QueryResult` instance.\n+\n+The `Row` interface is as follows:\n+```\n+/**\n+ * A single record, returned as part of a query result.\n+ */\n+public interface Row {\n+\n+  List<String> columnNames();\n+\n+  List<String> columnTypes();\n+\n+  List<Object> values();\n+\n+  /**\n+   * Get the value for a particular column of the Row as an Object.\n+   *\n+   * @param columnIndex index of column (1-indexed).\n+   * @return column value.\n+   */\n+  Object getObject(int columnIndex);\n+\n+  /**\n+   * Get the value for a particular column of the Row as an Object.\n+   *\n+   * @param columnName name of column.\n+   * @return column value.\n+   */\n+  Object getObject(String columnName);\n+\n+  /**\n+   * Get the value for a particular column of the Row as a string.\n+   *\n+   * @param columnIndex index of column (1-indexed).\n+   * @return column value.\n+   */\n+  String getString(int columnIndex);\n+\n+  /**\n+   * Get the value for a particular column of the Row as a string.\n+   *\n+   * @param columnName name of column.\n+   * @return column value.\n+   */\n+  String getString(String columnName);\n+\n+  /**\n+   * Get the value for a particular column of the Row as an integer.\n+   *\n+   * @param columnIndex index of column (1-indexed).\n+   * @return column value.\n+   */\n+  Integer getInt(int columnIndex);\n+\n+  /**\n+   * Get the value for a particular column of the Row as an integer.\n+   *\n+   * @param columnName name of column.\n+   * @return column value.\n+   */\n+  Integer getInt(String columnName);\n+\n+  /**\n+   * Get the value for a particular column of the Row as a long.\n+   *\n+   * @param columnIndex index of column (1-indexed).\n+   * @return column value.\n+   */\n+  Long getLong(int columnIndex);\n+\n+  /**\n+   * Get the value for a particular column of the Row as a long.\n+   *\n+   * @param columnName name of column.\n+   * @return column value.\n+   */\n+  Long getLong(String columnName);\n+\n+  /**\n+   * Get the value for a particular column of the Row as a double.\n+   *\n+   * @param columnIndex index of column (1-indexed).\n+   * @return column value.\n+   */\n+  Double getDouble(int columnIndex);\n+\n+  /**\n+   * Get the value for a particular column of the Row as a double.\n+   *\n+   * @param columnName name of column.\n+   * @return column value.\n+   */\n+  Double getDouble(String columnName);\n+\n+  /**\n+   * Get the value for a particular column of the Row as a boolean.\n+   *\n+   * @param columnIndex index of column (1-indexed).\n+   * @return column value.\n+   */\n+  Boolean getBoolean(int columnIndex);\n+\n+  /**\n+   * Get the value for a particular column of the Row as a boolean.\n+   *\n+   * @param columnName name of column.\n+   * @return column value.\n+   */\n+  Boolean getBoolean(String columnName);\n+\n+  /**\n+   * Get the value for a particular column of the Row as a decimal.\n+   *\n+   * @param columnIndex index of column (1-indexed).\n+   * @return column value.\n+   */\n+  BigDecimal getDecimal(int columnIndex);\n+\n+  /**\n+   * Get the value for a particular column of the Row as a decimal.\n+   *\n+   * @param columnName name of column.\n+   * @return column value.\n+   */\n+  BigDecimal getDecimal(String columnName);\n+}\n+```\n+\n+We considered representing column types in a more structured form (rather than plain strings) to accomodate complex/nested data types but felt this added complexity would not be helpful for most use cases. (This would also require a server-side change, so it's a fair bit of additional work.)\n+\n+For `getDecimal(...)` in the `Row` interface, rather than trying to parse the column type to extract the precision and scale, we will simply convert the value to a BigDecimal without explicitly specifying the precision and scale. We could also add an option for users to specify the scale and precision in the getter, if we think that would be useful.\n+\n+We could also add `getList(...)` and `getMap(...)` methods to the `Row` interface, but it's not clear to me how valuable this would be given that the nested data types would not be known.\n+\n+Tim also proposed switching from generic Java types (`Map<String, Object>`, `List<Object>`) to Vert.x types (`JsonObject`, `JsonArray`) as the latter is more type-safe and the client already has a dependency on Vert.x anyway. The downside, though, is that then apps that use the client would be required to depend on Vert.x as well.\n+\n+### Transient queries -- Non-streaming\n+\n+The `Client` interface will also provide the following methods for receiving the results of a transient query (push or pull) in a single batch (non-streaming),\n+once the query has completed:\n+```\n+  /**\n+   * Execute a query (push or pull) and receive all result rows together, once the query has\n+   * completed.\n+   *\n+   * @param sql statement of query to execute.\n+   * @return query result.\n+   */\n+  CompletableFuture<List<Row>> executeQuery(String sql);\n+\n+  /**\n+   * Execute a query (push or pull) and receive all result rows together, once the query has\n+   * completed.\n+   *\n+   * @param sql statement of query to execute.\n+   * @param properties query properties.\n+   * @return query result.\n+   */\n+  CompletableFuture<List<Row>> executeQuery(String sql, Map<String, Object> properties);\n+```\n+\n+For a query to \"complete\" could mean:\n+* The query is a pull query\n+* The query is a push query with a limit clause, and the limit has been reached\n+* The query is a push query that has been terminated\n+\n+We may want to introduce a limit to the number of rows that may be returned from these `executeQuery()` methods,\n+in order to decrease the likelihood of running out of memory.\n+\n+### Insert values\n+\n+A method to insert one row at a time:\n+```\n+  /**\n+   * Insert a single row into the relevant stream/table.\n+   *\n+   * @param streamName name of stream/table.\n+   * @param row the row to insert.\n+   * @return a future that completes once the request has been processed.\n+   */\n+  CompletableFuture<Void> insertInto(String streamName, Map<String, Object> row);\n+```\n+\n+A method to stream inserts (via the `/inserts-stream` endpoint):\n+```\n+  CompletableFuture<Publisher<InsertResponse>> streamInserts(String streamName, Publisher<List<Object>> insertsPublisher);\n+}\n+```\n+where `InsertResponse` is as follows:\n+```\n+public interface InsertResponse {\n+\n+  /**\n+   * Whether the row was successfully inserted or not.\n+   */\n+  boolean isSuccessful();\n+\n+  /**\n+   * Unique sequence number for the row in the stream of inserts.\n+   */\n+  int getSequenceNum();\n+\n+  /**\n+   * If unsuccessful, the error message.\n+   */\n+  String getErrorMessage();\n+\n+  /**\n+   * If unsuccessful, the error code.\n+   */\n+  int getErrorCode();\n+\n+}\n+```\n+\n+### DDL/DML operations\n+\n+#### `CREATE <STREAM/TABLE>`, `CREATE <STREAM/TABLE> ... AS SELECT`, `INSERT INTO`\n+\n+`Client` methods:\n+```\n+  /**\n+   * Execute DDL statement: `CREATE STREAM`, `CREATE TABLE`\n+   */\n+  CompletableFuture<DdlResponse> executeDdl(String sql);\n+\n+  /**\n+   * Execute DML statement: `CREATE STREAM ... AS SELECT`, `CREATE TABLE ... AS SELECT`, `INSERT INTO`\n+   */\n+  CompletableFuture<DmlResponse> executeDml(String sql);\n+\n+  /**\n+   * Execute DML statement: `CREATE STREAM ... AS SELECT`, `CREATE TABLE ... AS SELECT`, `INSERT INTO`\n+   */\n+  CompletableFuture<DmlResponse> executeDml(String sql, Map<String, Object> properties);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzkzNTIxOA=="}, "originalCommit": {"oid": "aed38d5836550829f7fd459df31b47aaf7e5ad45"}, "originalPosition": 435}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDYzODMyMw==", "bodyText": "Makes sense, I've removed this.", "url": "https://github.com/confluentinc/ksql/pull/5236#discussion_r420638323", "createdAt": "2020-05-06T08:53:23Z", "author": {"login": "vcrfxia"}, "path": "design-proposals/klip-26-java-client-interfaces.md", "diffHunk": "@@ -0,0 +1,715 @@\n+# KLIP 26 - Java client interfaces\n+\n+**Author**: Victoria Xia (@vcrfxia) | \n+**Release Target**: ksqlDB 0.10.0 | \n+**Status**: _In development_ | \n+**Discussion**: TBD\n+\n+**tl;dr:** _[KLIP 15](./klip-15-new-api-and-client.md) already made the case for why it makes sense\n+           to introduce a Java client for ksqlDB. This KLIP proposes interfaces for the client._\n+\n+## Motivation and background\n+\n+See [KLIP 15](./klip-15-new-api-and-client.md).\n+\n+## What is in scope\n+\n+The Java client will support the following operations:\n+* Push query\n+* Pull query\n+* Select DDL/DML operations:\n+    * `CREATE STREAM`\n+    * `CREATE TABLE`\n+    * `CREATE STREAM ... AS SELECT`\n+    * `CREATE TABLE ... AS SELECT`\n+    * `DROP STREAM`\n+    * `DROP TABLE`\n+    * `INSERT INTO`\n+    * `TERMINATE <queryId>`\n+    * `CREATE CONNECTOR`\n+    * `DROP CONNECTOR`\n+* Select admin operations:\n+    * `SHOW TOPICS` (non-extended)\n+    * `SHOW STREAMS` (non-extended)\n+    * `SHOW TABLES` (non-extended)\n+    * `SHOW QUERIES` (non-extended)\n+    * `SHOW CONNECTORS`\n+* Insert values, i.e., insert rows into an existing stream/table\n+* Terminate push query (via the `/close-query` endpoint)\n+\n+The purpose of this KLIP is to reach agreement on the interfaces / public APIs.\n+Implementation details will not be covered.\n+\n+## What is not in scope\n+\n+This KLIP does not cover Java client support for the following:\n+* `DESCRIBE <stream/table>`, `DESCRIBE CONNECTOR`, `DESCRIBE FUNCTION`\n+* `EXPLAIN <queryId>`\n+* `PRINT <topic>`\n+* `SHOW TOPICS EXTENDED`, `SHOW <STREAMS/TABLES> EXTENDED`, `SHOW QUERIES EXTENDED`\n+* `CREATE TYPE`, `DROP TYPE`, `SHOW TYPES`\n+* `SHOW FUNCTIONS`, `SHOW PROPERTIES`\n+* `RUN SCRIPT`\n+* Use of other endpoints (info, healthcheck, terminate cluster, status, etc.)\n+\n+We can always add support for these operations in the future if desired.\n+\n+As above, implementation details are out of scope as the purpose of this KLIP is to reach agreement\n+on the interfaces / public APIs.\n+\n+## Value/Return\n+\n+See [KLIP 15](./klip-15-new-api-and-client.md).\n+\n+## Public APIS\n+\n+The following subsections describe the methods of the `Client` interface:\n+```\n+public interface Client {\n+    ...\n+}\n+```\n+\n+### Constructors\n+```\n+  static Client create(ClientOptions clientOptions) {\n+    return new ClientImpl(clientOptions);\n+  }\n+\n+  static Client create(ClientOptions clientOptions, Vertx vertx) {\n+    return new ClientImpl(clientOptions, vertx);\n+  }\n+```\n+\n+The Java client will be implemented as a Vert.x HttpClient. We expose a constructor that allows users to provide their own `Vertx` instance\n+in order to take advantage of a shared connection pool and other properties if desired.\n+\n+`ClientOptions` will initially be as follows:\n+```\n+public interface ClientOptions {\n+\n+  ClientOptions setHost(String host);\n+\n+  ClientOptions setPort(int port);\n+\n+  ClientOptions setUseTls(boolean useTls);\n+\n+  ClientOptions setUseClientAuth(boolean useClientAuth);\n+\n+  ClientOptions setTrustStore(String trustStorePath);\n+\n+  ClientOptions setTrustStorePassword(String trustStorePassword);\n+\n+  ClientOptions setKeyStore(String keyStorePath);\n+\n+  ClientOptions setKeyStorePassword(String keyStorePassword);\n+\n+  ClientOptions setBasicAuthCredentials(String username, String password);\n+\n+  String getHost();\n+\n+  int getPort();\n+\n+  boolean isUseTls();\n+\n+  boolean isUseClientAuth();\n+\n+  boolean isUseBasicAuth();\n+\n+  String getTrustStore();\n+\n+  String getTrustStorePassword();\n+\n+  String getKeyStore();\n+\n+  String getKeyStorePassword();\n+\n+  String getBasicAuthUsername();\n+\n+  String getBasicAuthPassword();\n+\n+  ClientOptions copy();\n+\n+  static ClientOptions create() {\n+    return new ClientOptionsImpl();\n+  }\n+}\n+```\n+\n+We can always add additional configuration options later. We may also wish to expose the Vert.x `HttpClientOptions` for\n+advanced users that wish to provide custom configs.\n+\n+### Transient queries -- Streaming\n+\n+The `Client` interface will provide the following methods for streaming the results of a transient (push or pull) query:\n+```\n+  /**\n+   * Execute a query (push or pull) and receive the results one row at a time.\n+   *\n+   * @param sql statement of query to execute.\n+   * @return query result.\n+   */\n+  CompletableFuture<QueryResult> streamQuery(String sql);\n+\n+  /**\n+   * Execute a query (push or pull) and receive the results one row at a time.\n+   *\n+   * @param sql statement of query to execute.\n+   * @param properties query properties.\n+   * @return query result.\n+   */\n+  CompletableFuture<QueryResult> streamQuery(String sql, Map<String, Object> properties);\n+```\n+where `QueryResult` is as follows:\n+```\n+/**\n+ * The result of a query (push or pull), streamed one row at time. Records may be consumed by either\n+ * subscribing to the publisher or polling (blocking) for one record at a time. These two methods of\n+ * consumption are mutually exclusive; only one method may be used (per QueryResult).\n+ */\n+public interface QueryResult extends Publisher<Row> {\n+\n+  List<String> columnNames();\n+\n+  List<String> columnTypes();\n+\n+  String queryID();\n+\n+  /**\n+   * Block until a row becomes available.\n+   *\n+   * @return the row.\n+   */\n+  Row poll();\n+\n+  /**\n+   * Block until a row becomes available or the timeout has elapsed.\n+   *\n+   * @param timeout amount of to wait for a row. Non-positive values are interpreted as no timeout.\n+   * @param timeUnit unit for timeout param.\n+   * @return the row, if available; else, null.\n+   */\n+  Row poll(long timeout, TimeUnit timeUnit);\n+\n+  boolean isComplete();\n+\n+  void close();\n+}\n+```\n+Note that `QueryResult` is a Reactive Streams `Publisher` so users can stream results. Users can also call `poll()` to receive\n+results in a synchronous fashion instead. Only one of the two methods will be allowed per `QueryResult` instance.\n+\n+The `Row` interface is as follows:\n+```\n+/**\n+ * A single record, returned as part of a query result.\n+ */\n+public interface Row {\n+\n+  List<String> columnNames();\n+\n+  List<String> columnTypes();\n+\n+  List<Object> values();\n+\n+  /**\n+   * Get the value for a particular column of the Row as an Object.\n+   *\n+   * @param columnIndex index of column (1-indexed).\n+   * @return column value.\n+   */\n+  Object getObject(int columnIndex);\n+\n+  /**\n+   * Get the value for a particular column of the Row as an Object.\n+   *\n+   * @param columnName name of column.\n+   * @return column value.\n+   */\n+  Object getObject(String columnName);\n+\n+  /**\n+   * Get the value for a particular column of the Row as a string.\n+   *\n+   * @param columnIndex index of column (1-indexed).\n+   * @return column value.\n+   */\n+  String getString(int columnIndex);\n+\n+  /**\n+   * Get the value for a particular column of the Row as a string.\n+   *\n+   * @param columnName name of column.\n+   * @return column value.\n+   */\n+  String getString(String columnName);\n+\n+  /**\n+   * Get the value for a particular column of the Row as an integer.\n+   *\n+   * @param columnIndex index of column (1-indexed).\n+   * @return column value.\n+   */\n+  Integer getInt(int columnIndex);\n+\n+  /**\n+   * Get the value for a particular column of the Row as an integer.\n+   *\n+   * @param columnName name of column.\n+   * @return column value.\n+   */\n+  Integer getInt(String columnName);\n+\n+  /**\n+   * Get the value for a particular column of the Row as a long.\n+   *\n+   * @param columnIndex index of column (1-indexed).\n+   * @return column value.\n+   */\n+  Long getLong(int columnIndex);\n+\n+  /**\n+   * Get the value for a particular column of the Row as a long.\n+   *\n+   * @param columnName name of column.\n+   * @return column value.\n+   */\n+  Long getLong(String columnName);\n+\n+  /**\n+   * Get the value for a particular column of the Row as a double.\n+   *\n+   * @param columnIndex index of column (1-indexed).\n+   * @return column value.\n+   */\n+  Double getDouble(int columnIndex);\n+\n+  /**\n+   * Get the value for a particular column of the Row as a double.\n+   *\n+   * @param columnName name of column.\n+   * @return column value.\n+   */\n+  Double getDouble(String columnName);\n+\n+  /**\n+   * Get the value for a particular column of the Row as a boolean.\n+   *\n+   * @param columnIndex index of column (1-indexed).\n+   * @return column value.\n+   */\n+  Boolean getBoolean(int columnIndex);\n+\n+  /**\n+   * Get the value for a particular column of the Row as a boolean.\n+   *\n+   * @param columnName name of column.\n+   * @return column value.\n+   */\n+  Boolean getBoolean(String columnName);\n+\n+  /**\n+   * Get the value for a particular column of the Row as a decimal.\n+   *\n+   * @param columnIndex index of column (1-indexed).\n+   * @return column value.\n+   */\n+  BigDecimal getDecimal(int columnIndex);\n+\n+  /**\n+   * Get the value for a particular column of the Row as a decimal.\n+   *\n+   * @param columnName name of column.\n+   * @return column value.\n+   */\n+  BigDecimal getDecimal(String columnName);\n+}\n+```\n+\n+We considered representing column types in a more structured form (rather than plain strings) to accomodate complex/nested data types but felt this added complexity would not be helpful for most use cases. (This would also require a server-side change, so it's a fair bit of additional work.)\n+\n+For `getDecimal(...)` in the `Row` interface, rather than trying to parse the column type to extract the precision and scale, we will simply convert the value to a BigDecimal without explicitly specifying the precision and scale. We could also add an option for users to specify the scale and precision in the getter, if we think that would be useful.\n+\n+We could also add `getList(...)` and `getMap(...)` methods to the `Row` interface, but it's not clear to me how valuable this would be given that the nested data types would not be known.\n+\n+Tim also proposed switching from generic Java types (`Map<String, Object>`, `List<Object>`) to Vert.x types (`JsonObject`, `JsonArray`) as the latter is more type-safe and the client already has a dependency on Vert.x anyway. The downside, though, is that then apps that use the client would be required to depend on Vert.x as well.\n+\n+### Transient queries -- Non-streaming\n+\n+The `Client` interface will also provide the following methods for receiving the results of a transient query (push or pull) in a single batch (non-streaming),\n+once the query has completed:\n+```\n+  /**\n+   * Execute a query (push or pull) and receive all result rows together, once the query has\n+   * completed.\n+   *\n+   * @param sql statement of query to execute.\n+   * @return query result.\n+   */\n+  CompletableFuture<List<Row>> executeQuery(String sql);\n+\n+  /**\n+   * Execute a query (push or pull) and receive all result rows together, once the query has\n+   * completed.\n+   *\n+   * @param sql statement of query to execute.\n+   * @param properties query properties.\n+   * @return query result.\n+   */\n+  CompletableFuture<List<Row>> executeQuery(String sql, Map<String, Object> properties);\n+```\n+\n+For a query to \"complete\" could mean:\n+* The query is a pull query\n+* The query is a push query with a limit clause, and the limit has been reached\n+* The query is a push query that has been terminated\n+\n+We may want to introduce a limit to the number of rows that may be returned from these `executeQuery()` methods,\n+in order to decrease the likelihood of running out of memory.\n+\n+### Insert values\n+\n+A method to insert one row at a time:\n+```\n+  /**\n+   * Insert a single row into the relevant stream/table.\n+   *\n+   * @param streamName name of stream/table.\n+   * @param row the row to insert.\n+   * @return a future that completes once the request has been processed.\n+   */\n+  CompletableFuture<Void> insertInto(String streamName, Map<String, Object> row);\n+```\n+\n+A method to stream inserts (via the `/inserts-stream` endpoint):\n+```\n+  CompletableFuture<Publisher<InsertResponse>> streamInserts(String streamName, Publisher<List<Object>> insertsPublisher);\n+}\n+```\n+where `InsertResponse` is as follows:\n+```\n+public interface InsertResponse {\n+\n+  /**\n+   * Whether the row was successfully inserted or not.\n+   */\n+  boolean isSuccessful();\n+\n+  /**\n+   * Unique sequence number for the row in the stream of inserts.\n+   */\n+  int getSequenceNum();\n+\n+  /**\n+   * If unsuccessful, the error message.\n+   */\n+  String getErrorMessage();\n+\n+  /**\n+   * If unsuccessful, the error code.\n+   */\n+  int getErrorCode();\n+\n+}\n+```\n+\n+### DDL/DML operations\n+\n+#### `CREATE <STREAM/TABLE>`, `CREATE <STREAM/TABLE> ... AS SELECT`, `INSERT INTO`\n+\n+`Client` methods:\n+```\n+  /**\n+   * Execute DDL statement: `CREATE STREAM`, `CREATE TABLE`\n+   */\n+  CompletableFuture<DdlResponse> executeDdl(String sql);\n+\n+  /**\n+   * Execute DML statement: `CREATE STREAM ... AS SELECT`, `CREATE TABLE ... AS SELECT`, `INSERT INTO`\n+   */\n+  CompletableFuture<DmlResponse> executeDml(String sql);\n+\n+  /**\n+   * Execute DML statement: `CREATE STREAM ... AS SELECT`, `CREATE TABLE ... AS SELECT`, `INSERT INTO`\n+   */\n+  CompletableFuture<DmlResponse> executeDml(String sql, Map<String, Object> properties);\n+\n+```\n+with\n+```\n+public interface DdlResponse {\n+\n+  enum Status { QUEUED, PARSING, EXECUTING, RUNNING, TERMINATED, SUCCESS, ERROR }\n+  \n+  Status getStatus();\n+  \n+  String getStatusMessage();\n+  \n+  long getCommandSequenceNumber();\n+\n+  String getCommandId();\n+}\n+```\n+and `DmlResponse` is identical.\n+\n+I don't love this proposal since `DDL` and `DML` aren't used throughout our docs but I'm not a huge fan of the alternatives I considered either, such as\n+```\n+  CompletableFuture<CreateSourceResponse> createStream(String sql);\n+\n+  CompletableFuture<CreateSourceResponse> createStream(String sql, Map<String, Object> properties);\n+\n+  CompletableFuture<CreateSourceResponse> createTable(String sql);\n+\n+  CompletableFuture<CreateSourceResponse> createTable(String sql, Map<String, Object> properties);\n+\n+  CompletableFuture<InsertIntoResponse> insertIntoSource(String sql);\n+\n+  CompletableFuture<InsertIntoResponse> insertIntoSource(String sql, Map<String, Object> properties);\n+```\n+\n+In this version, the implementations of `createStream(...)` and `createTable(...)` would be identical and could be replaced with a single `createSource(...)`\n+but the name of this method feels confusing. As with the previous proposal, `CreateSourceResponse` and `InsertIntoResponse` are identical.\n+\n+Other alternatives include separating `CREATE <STREAM/TABLE>` and `CREATE <STREAM/TABLE> ... AS SELECT` into separate methods, but that feels unnecessarily complex.\n+\n+#### `DROP <STREAM/TABLE>`\n+\n+`Client` methods:\n+```\n+  /**\n+   * Drop stream. The underlying Kafka topic will not be deleted.\n+   */\n+  CompletableFuture<DropSourceResponse> dropStream(String streamName);\n+\n+  /**\n+   * Drop stream. The underlying Kafka topic may optionally be deleted.\n+   */\n+  CompletableFuture<DropSourceResponse> dropStream(String streamName, boolean deleteTopic);\n+\n+  /**\n+   * Drop table. The underlying Kafka topic will not be deleted.\n+   */\n+  CompletableFuture<DropSourceResponse> dropTable(String tableName);\n+\n+  /**\n+   * Drop table. The underlying Kafka topic may optionally be deleted.\n+   */\n+  CompletableFuture<DropSourceResponse> dropTable(String tableName, boolean deleteTopic);\n+```\n+where `DropSourceResponse` is actually the same as `DdlResponse`/`DmlResponse`/`CreateSourceResponse`/`InsertIntoResponse` above.\n+\n+Again, the implementations of `dropStream(...)` and `dropTable(...)` would be the same so we could instead have a single `dropSource(...)`, but the naming might be confusing.\n+\n+If we choose to keep them separate, there's an open question of whether the client should validate that `dropStream(...)` is not used to drop a table, and vice versa.\n+IMO such validation would be introducing complexity without much benefit, though this point of ambiguity makes me prefer a single `dropSource(...)` if we can agree on a method name that's not confusing.\n+\n+Note that users can also execute `DROP <STREAM/TABLE>` requests via `executeDdl(...)` or `executDml(...)` above.\n+\n+#### `TERMINATE <queryId>`\n+\n+```\n+  CompletableFuture<TerminateQueryResponse> terminatePersistentQuery(String queryId);\n+```\n+where `TerminateQueryResponse` is again the same as `DdlResponse`/`DmlResponse`/`CreateSourceResponse`/`InsertIntoResponse`/`DropSourceResponse` above.\n+\n+The method name `terminatePersistenQuery(...)` is to distinguish from `terminatePushQuery(...)` below.\n+\n+#### Connectors\n+\n+```\n+  CompletableFuture<ConnectorInfo> createSourceConnector(String name, Map<String, String> properties);\n+\n+  CompletableFuture<ConnectorInfo> createSinkConnector(String name, Map<String, String> properties);\n+\n+  CompletableFuture<Void> dropConnector(String name);\n+```\n+where `ConnectorInfo` is from an Apache Kafka module ([link](https://github.com/apache/kafka/blob/trunk/connect/runtime/src/main/java/org/apache/kafka/connect/runtime/rest/entities/ConnectorInfo.java)).\n+\n+Or would we rather not have a dependency on Apache Kafka in the ksqlDB client interfaces?\n+\n+### Admin operations\n+\n+#### `SHOW TOPICS`\n+\n+```\n+  CompletableFuture<List<TopicInfo>> listTopics();\n+```\n+with\n+```\n+public interface TopicInfo {\n+\n+  String getName();\n+\n+  int getPartitions();\n+  \n+  List<Integer> getReplicasPerPartition();\n+\n+}\n+```\n+\n+#### `SHOW <STREAMS/TABLES>`\n+\n+```\n+  CompletableFuture<List<StreamInfo>> listStreams();\n+\n+  CompletableFuture<List<TableInfo>> listTables();\n+```\n+with\n+```\n+public interface StreamInfo {\n+\n+  String getName();\n+\n+  String getTopic();\n+\n+  String getFormat();\n+  \n+}\n+```\n+and\n+```\n+public interface TableInfo {\n+\n+  String getName();\n+\n+  String getTopic();\n+\n+  String getFormat();\n+\n+  boolean isWindowed();\n+  \n+}\n+```\n+\n+I'm not sure whether it makes more sense for `StreamInfo#getFormat()` and `TableInfo#getFormat()` to return a string or an enum value.\n+The latter would make it easier for the user to know the possible values, but we'd have to keep the list up to date and would also sacrifice forward compatibility.\n+\n+#### `SHOW QUERIES`\n+\n+```\n+  CompletableFuture<List<QueryInfo>> listQueries();\n+```\n+with\n+```\n+public interface QueryInfo {\n+\n+  boolean isPersistentQuery();\n+\n+  boolean isPushQuery();\n+\n+  /**\n+   * Query ID, used for control operations such as terminating the query\n+   */\n+  String getId();\n+\n+  String getSql();\n+\n+  /**\n+   * Name of sink, for a persistent query. Else, null.\n+   */\n+  String getSink();\n+\n+  /**\n+   * Name of sink topic, for a persistent query. Else, null.\n+   */\n+  String getSinkTopic();\n+  \n+  /**\n+   * Map of query state (\"RUNNING\", \"ERROR\", or \"UNRESPONSIVE\") to the number of ksqlDB servers\n+   * on which this query is in each state.\n+   */\n+  Map<String, Integer> getServerStatusCounts();\n+\n+}\n+```\n+\n+Again, not sure whether it makes more sense to represent query states as strings, or to introduce an Enum and have `getServerStatusCounts()` return an EnumMap instead.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODEzODU4NA=="}, "originalCommit": {"oid": "aed38d5836550829f7fd459df31b47aaf7e5ad45"}, "originalPosition": 626}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA2ODcyMzEx", "url": "https://github.com/confluentinc/ksql/pull/5236#pullrequestreview-406872311", "createdAt": "2020-05-06T18:20:00Z", "commit": {"oid": "f447ce9002ada1f992080685f3262cbda4faf1b1"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "34f0b20ab5aaed577a799290c6c96541266a4a4f", "author": {"user": {"login": "vcrfxia", "name": "Victoria Xia"}}, "url": "https://github.com/confluentinc/ksql/commit/34f0b20ab5aaed577a799290c6c96541266a4a4f", "committedDate": "2020-05-07T07:37:45Z", "message": "chore: rename Row interface getter"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0e94d765ec60d016aa71d32cbe26e1e58c9abbda", "author": {"user": {"login": "vcrfxia", "name": "Victoria Xia"}}, "url": "https://github.com/confluentinc/ksql/commit/0e94d765ec60d016aa71d32cbe26e1e58c9abbda", "committedDate": "2020-05-07T07:50:18Z", "message": "chore: managing connectors is now out of scope"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6afa3cd50527005c7640e3cc89e020b030b6cda4", "author": {"user": {"login": "vcrfxia", "name": "Victoria Xia"}}, "url": "https://github.com/confluentinc/ksql/commit/6afa3cd50527005c7640e3cc89e020b030b6cda4", "committedDate": "2020-05-11T03:48:35Z", "message": "chore: switch timeout to Duration, rename to BatchedQueryResult"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4808, "cost": 1, "resetAt": "2021-11-01T13:51:04Z"}}}