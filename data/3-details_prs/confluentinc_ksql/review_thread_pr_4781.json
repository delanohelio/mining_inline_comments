{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzg5NDA4Mjk3", "number": 4781, "reviewThreads": {"totalCount": 12, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xNlQxNzo1NzozMFrODocWDA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xN1QyMjo0NjoxMFrODo6gZQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQzNzM0MDI4OnYy", "diffSide": "RIGHT", "path": "ksqldb-engine/src/main/java/io/confluent/ksql/analyzer/AggregateAnalyzer.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xNlQxNzo1NzozMFrOF2_rVg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xNlQxNzo1NzozMFrOF2_rVg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzIxMDcxMA==", "bodyText": "Basically moved from QueryAnalyzer.", "url": "https://github.com/confluentinc/ksql/pull/4781#discussion_r393210710", "createdAt": "2020-03-16T17:57:30Z", "author": {"login": "big-andy-coates"}, "path": "ksqldb-engine/src/main/java/io/confluent/ksql/analyzer/AggregateAnalyzer.java", "diffHunk": "@@ -15,47 +15,74 @@\n \n package io.confluent.ksql.analyzer;\n \n+import static java.util.Objects.requireNonNull;\n+\n import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.collect.Sets;\n+import com.google.common.collect.Sets.SetView;\n import io.confluent.ksql.execution.expression.tree.ColumnReferenceExp;\n import io.confluent.ksql.execution.expression.tree.Expression;\n import io.confluent.ksql.execution.expression.tree.FunctionCall;\n import io.confluent.ksql.execution.expression.tree.QualifiedColumnReferenceExp;\n import io.confluent.ksql.execution.expression.tree.TraversalExpressionVisitor;\n import io.confluent.ksql.execution.expression.tree.UnqualifiedColumnReferenceExp;\n+import io.confluent.ksql.execution.plan.SelectExpression;\n import io.confluent.ksql.function.FunctionRegistry;\n import io.confluent.ksql.name.FunctionName;\n import io.confluent.ksql.util.KsqlException;\n import io.confluent.ksql.util.SchemaUtil;\n import java.util.HashSet;\n-import java.util.Objects;\n+import java.util.List;\n+import java.util.Map;\n import java.util.Optional;\n import java.util.Set;\n import java.util.function.BiConsumer;\n+import java.util.stream.Collectors;\n \n-class AggregateAnalyzer {\n+public class AggregateAnalyzer {\n \n-  private final MutableAggregateAnalysis aggregateAnalysis;\n-  private final QualifiedColumnReferenceExp defaultArgument;\n   private final FunctionRegistry functionRegistry;\n-  private final boolean hasWindowExpression;\n \n-  AggregateAnalyzer(\n-      final MutableAggregateAnalysis aggregateAnalysis,\n-      final QualifiedColumnReferenceExp defaultArgument,\n-      final boolean hasWindowExpression,\n+  public AggregateAnalyzer(\n       final FunctionRegistry functionRegistry\n   ) {\n-    this.aggregateAnalysis = Objects.requireNonNull(aggregateAnalysis, \"aggregateAnalysis\");\n-    this.defaultArgument = Objects.requireNonNull(defaultArgument, \"defaultArgument\");\n-    this.functionRegistry = Objects.requireNonNull(functionRegistry, \"functionRegistry\");\n-    this.hasWindowExpression = hasWindowExpression;\n+    this.functionRegistry = requireNonNull(functionRegistry, \"functionRegistry\");\n   }\n \n-  void processSelect(final Expression expression) {\n+  public AggregateAnalysisResult analyze(\n+      final ImmutableAnalysis analysis,\n+      final List<SelectExpression> finalProjection\n+  ) {\n+    if (analysis.getGroupByExpressions().isEmpty()) {\n+      throw new IllegalArgumentException(\"Not an aggregate query\");\n+    }\n+\n+    final Context context = new Context(analysis);\n+\n+    finalProjection.stream()\n+        .map(SelectExpression::getExpression)\n+        .forEach(exp -> processSelect(exp, context));\n+\n+    analysis.getWhereExpression()\n+        .ifPresent(exp -> processWhere(exp, context));\n+\n+    analysis.getGroupByExpressions()\n+        .forEach(exp -> processGroupBy(exp, context));\n+\n+    analysis.getHavingExpression()\n+        .ifPresent(exp -> processHaving(exp, context));\n+\n+    enforceAggregateRules(context);\n+\n+    return context.aggregateAnalysis;\n+  }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b53fba882cbbb226a66081cbf258c1813fad81bb"}, "originalPosition": 86}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQzNzM0MjA2OnYy", "diffSide": "RIGHT", "path": "ksqldb-engine/src/main/java/io/confluent/ksql/analyzer/AggregateAnalyzer.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xNlQxNzo1ODowMVrOF2_sdg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xNlQxNzo1ODowMVrOF2_sdg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzIxMDk5OA==", "bodyText": "Moved from QueryAnalyzer", "url": "https://github.com/confluentinc/ksql/pull/4781#discussion_r393210998", "createdAt": "2020-03-16T17:58:01Z", "author": {"login": "big-andy-coates"}, "path": "ksqldb-engine/src/main/java/io/confluent/ksql/analyzer/AggregateAnalyzer.java", "diffHunk": "@@ -117,18 +150,91 @@ private void throwOnWindowBoundColumnIfWindowedAggregate(final ColumnReferenceEx\n     }\n   }\n \n+  private static void enforceAggregateRules(\n+      final Context context\n+  ) {\n+    if (context.aggregateAnalysis.getAggregateFunctions().isEmpty()) {\n+      throw new KsqlException(\n+          \"GROUP BY requires columns using aggregate functions in SELECT clause.\");\n+    }\n+\n+    final Set<Expression> groupByExprs = getGroupByExpressions(context.analysis);\n+\n+    final List<String> unmatchedSelects = context.aggregateAnalysis\n+        .getNonAggregateSelectExpressions()\n+        .entrySet()\n+        .stream()\n+        // Remove any that exactly match a group by expression:\n+        .filter(e -> !groupByExprs.contains(e.getKey()))\n+        // Remove any that are constants,\n+        // or expressions where all params exactly match a group by expression:\n+        .filter(e -> !Sets.difference(e.getValue(), groupByExprs).isEmpty())\n+        .map(Map.Entry::getKey)\n+        .map(Expression::toString)\n+        .sorted()\n+        .collect(Collectors.toList());\n+\n+    if (!unmatchedSelects.isEmpty()) {\n+      throw new KsqlException(\n+          \"Non-aggregate SELECT expression(s) not part of GROUP BY: \" + unmatchedSelects);\n+    }\n+\n+    final SetView<ColumnReferenceExp> unmatchedSelectsAgg = Sets\n+        .difference(context.aggregateAnalysis.getAggregateSelectFields(), groupByExprs);\n+    if (!unmatchedSelectsAgg.isEmpty()) {\n+      throw new KsqlException(\n+          \"Column used in aggregate SELECT expression(s) \"\n+              + \"outside of aggregate functions not part of GROUP BY: \" + unmatchedSelectsAgg);\n+    }\n+\n+    final Set<ColumnReferenceExp> havingColumns = context.aggregateAnalysis\n+        .getNonAggregateHavingFields().stream()\n+        .map(ref -> new UnqualifiedColumnReferenceExp(ref.getColumnName()))\n+        .collect(Collectors.toSet());\n+\n+    final Set<ColumnReferenceExp> havingOnly = Sets.difference(havingColumns, groupByExprs);\n+    if (!havingOnly.isEmpty()) {\n+      throw new KsqlException(\n+          \"Non-aggregate HAVING expression not part of GROUP BY: \" + havingOnly);\n+    }\n+  }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b53fba882cbbb226a66081cbf258c1813fad81bb"}, "originalPosition": 216}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQzNzM0MjQzOnYy", "diffSide": "RIGHT", "path": "ksqldb-engine/src/main/java/io/confluent/ksql/analyzer/AggregateAnalyzer.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xNlQxNzo1ODowN1rOF2_ssg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xNlQxNzo1ODowN1rOF2_ssg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzIxMTA1OA==", "bodyText": "Moved from QueryAnalyzer", "url": "https://github.com/confluentinc/ksql/pull/4781#discussion_r393211058", "createdAt": "2020-03-16T17:58:07Z", "author": {"login": "big-andy-coates"}, "path": "ksqldb-engine/src/main/java/io/confluent/ksql/analyzer/AggregateAnalyzer.java", "diffHunk": "@@ -117,18 +150,91 @@ private void throwOnWindowBoundColumnIfWindowedAggregate(final ColumnReferenceEx\n     }\n   }\n \n+  private static void enforceAggregateRules(\n+      final Context context\n+  ) {\n+    if (context.aggregateAnalysis.getAggregateFunctions().isEmpty()) {\n+      throw new KsqlException(\n+          \"GROUP BY requires columns using aggregate functions in SELECT clause.\");\n+    }\n+\n+    final Set<Expression> groupByExprs = getGroupByExpressions(context.analysis);\n+\n+    final List<String> unmatchedSelects = context.aggregateAnalysis\n+        .getNonAggregateSelectExpressions()\n+        .entrySet()\n+        .stream()\n+        // Remove any that exactly match a group by expression:\n+        .filter(e -> !groupByExprs.contains(e.getKey()))\n+        // Remove any that are constants,\n+        // or expressions where all params exactly match a group by expression:\n+        .filter(e -> !Sets.difference(e.getValue(), groupByExprs).isEmpty())\n+        .map(Map.Entry::getKey)\n+        .map(Expression::toString)\n+        .sorted()\n+        .collect(Collectors.toList());\n+\n+    if (!unmatchedSelects.isEmpty()) {\n+      throw new KsqlException(\n+          \"Non-aggregate SELECT expression(s) not part of GROUP BY: \" + unmatchedSelects);\n+    }\n+\n+    final SetView<ColumnReferenceExp> unmatchedSelectsAgg = Sets\n+        .difference(context.aggregateAnalysis.getAggregateSelectFields(), groupByExprs);\n+    if (!unmatchedSelectsAgg.isEmpty()) {\n+      throw new KsqlException(\n+          \"Column used in aggregate SELECT expression(s) \"\n+              + \"outside of aggregate functions not part of GROUP BY: \" + unmatchedSelectsAgg);\n+    }\n+\n+    final Set<ColumnReferenceExp> havingColumns = context.aggregateAnalysis\n+        .getNonAggregateHavingFields().stream()\n+        .map(ref -> new UnqualifiedColumnReferenceExp(ref.getColumnName()))\n+        .collect(Collectors.toSet());\n+\n+    final Set<ColumnReferenceExp> havingOnly = Sets.difference(havingColumns, groupByExprs);\n+    if (!havingOnly.isEmpty()) {\n+      throw new KsqlException(\n+          \"Non-aggregate HAVING expression not part of GROUP BY: \" + havingOnly);\n+    }\n+  }\n+\n+  private static Set<Expression> getGroupByExpressions(\n+      final ImmutableAnalysis analysis\n+  ) {\n+    if (!analysis.getWindowExpression().isPresent()) {\n+      return ImmutableSet.copyOf(analysis.getGroupByExpressions());\n+    }\n+\n+    // Add in window bounds columns as implicit group by columns:\n+    final Set<UnqualifiedColumnReferenceExp> windowBoundColumnRefs =\n+        SchemaUtil.windowBoundsColumnNames().stream()\n+            .map(UnqualifiedColumnReferenceExp::new)\n+            .collect(Collectors.toSet());\n+\n+    return ImmutableSet.<Expression>builder()\n+        .addAll(analysis.getGroupByExpressions())\n+        .addAll(windowBoundColumnRefs)\n+        .build();\n+  }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b53fba882cbbb226a66081cbf258c1813fad81bb"}, "originalPosition": 235}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQzNzM0NjIyOnYy", "diffSide": "RIGHT", "path": "ksqldb-engine/src/main/java/io/confluent/ksql/analyzer/Analysis.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xNlQxNzo1OToxMVrOF2_vHg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xNlQxNzo1OToxMVrOF2_vHg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzIxMTY3OA==", "bodyText": "Previously, we captured the resolved select items - now we just capture the unresolved SelectItem", "url": "https://github.com/confluentinc/ksql/pull/4781#discussion_r393211678", "createdAt": "2020-03-16T17:59:11Z", "author": {"login": "big-andy-coates"}, "path": "ksqldb-engine/src/main/java/io/confluent/ksql/analyzer/Analysis.java", "diffHunk": "@@ -89,8 +88,8 @@ ResultMaterialization getResultMaterialization() {\n     return resultMaterialization;\n   }\n \n-  void addSelectItem(final Expression expression, final ColumnName alias) {\n-    selectExpressions.add(SelectExpression.of(alias, expression));\n+  void addSelectItem(final SelectItem selectItem) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b53fba882cbbb226a66081cbf258c1813fad81bb"}, "originalPosition": 36}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQzNzM1MTUzOnYy", "diffSide": "LEFT", "path": "ksqldb-engine/src/main/java/io/confluent/ksql/analyzer/Analyzer.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xNlQxODowMDo0N1rOF2_yuQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xNlQxODowMDo0N1rOF2_yuQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzIxMjYwMQ==", "bodyText": "To set the serde options we need to know the number of columns, which requires any * to be resolved. Hence this code has now moved to later LogicalPlanner once any * has been resolved.", "url": "https://github.com/confluentinc/ksql/pull/4781#discussion_r393212601", "createdAt": "2020-03-16T18:00:47Z", "author": {"login": "big-andy-coates"}, "path": "ksqldb-engine/src/main/java/io/confluent/ksql/analyzer/Analyzer.java", "diffHunk": "@@ -243,27 +218,6 @@ private KeyFormat buildKeyFormat() {\n               .getKeyFormat());\n     }\n \n-    private void setSerdeOptions(final Sink sink) {\n-      final List<ColumnName> columnNames = getColumnNames();\n-\n-      final Format valueFormat = getValueFormat(sink);\n-\n-      final Set<SerdeOption> serdeOptions = serdeOptionsSupplier.build(\n-          columnNames,\n-          valueFormat,\n-          sink.getProperties().getWrapSingleValues(),\n-          defaultSerdeOptions\n-      );\n-\n-      analysis.setSerdeOptions(serdeOptions);\n-    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b53fba882cbbb226a66081cbf258c1813fad81bb"}, "originalPosition": 141}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQzNzM2Nzk3OnYy", "diffSide": "LEFT", "path": "ksqldb-engine/src/main/java/io/confluent/ksql/analyzer/QueryAnalyzer.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xNlQxODowNDoxMFrOF2_9HA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOFQwOTo1ODo1MlrOF39s1g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzIxNTI2MA==", "bodyText": "Analysis of aggregates is now delayed until the creation of an AggregateNode in the LogicalPlanner.  This is necessary as this code needs any *s to have been resolved.", "url": "https://github.com/confluentinc/ksql/pull/4781#discussion_r393215260", "createdAt": "2020-03-16T18:04:10Z", "author": {"login": "big-andy-coates"}, "path": "ksqldb-engine/src/main/java/io/confluent/ksql/analyzer/QueryAnalyzer.java", "diffHunk": "@@ -97,177 +78,4 @@ public Analysis analyze(\n \n     return analysis;\n   }\n-\n-  public AggregateAnalysis analyzeAggregate(final Query query, final Analysis analysis) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b53fba882cbbb226a66081cbf258c1813fad81bb"}, "originalPosition": 62}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDAwMTQ3MQ==", "bodyText": "Moving the analysis out of the analyzer seems less than ideal... I'm trying to wrap my head around what * means in the context of an aggregation. other than COUNT(*) and other aggregate functions that have the * as the argument - how can you even use * in an aggregate? If it doesn't make sense outside of function calls, can we leverage that to keep the analysis in the analyzer?", "url": "https://github.com/confluentinc/ksql/pull/4781#discussion_r394001471", "createdAt": "2020-03-17T22:15:12Z", "author": {"login": "agavra"}, "path": "ksqldb-engine/src/main/java/io/confluent/ksql/analyzer/QueryAnalyzer.java", "diffHunk": "@@ -97,177 +78,4 @@ public Analysis analyze(\n \n     return analysis;\n   }\n-\n-  public AggregateAnalysis analyzeAggregate(final Query query, final Analysis analysis) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzIxNTI2MA=="}, "originalCommit": {"oid": "b53fba882cbbb226a66081cbf258c1813fad81bb"}, "originalPosition": 62}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDIyNjkwMg==", "bodyText": "I think this is just a continuation of a trend Tim started with UDTFs.  Trying to extract everything up front in the analyzer, and then using this to build the logical plan, is probably not the best approach.  It often involves duplicating logic between the analyser and plan, and if we just delay the analysis till we're building the plan we can take advantage of being able to ask parent nodes for things, i.e. we can build something more object oriented and take advantage of polymorphism, rather than if statements.\nWith regards to the resolution of * for GROUP BY:  It's valid to have SELECT * FROM X GROUP BY ?,?,? just so long as the GROUP BY contains all the columns in the source.  There's a QTT test covering this somewhere.  But we don't know what columns exist in the source until we've built the plan: the source could be a join for example. Hence we now delay this analysis till later.", "url": "https://github.com/confluentinc/ksql/pull/4781#discussion_r394226902", "createdAt": "2020-03-18T09:58:52Z", "author": {"login": "big-andy-coates"}, "path": "ksqldb-engine/src/main/java/io/confluent/ksql/analyzer/QueryAnalyzer.java", "diffHunk": "@@ -97,177 +78,4 @@ public Analysis analyze(\n \n     return analysis;\n   }\n-\n-  public AggregateAnalysis analyzeAggregate(final Query query, final Analysis analysis) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzIxNTI2MA=="}, "originalCommit": {"oid": "b53fba882cbbb226a66081cbf258c1813fad81bb"}, "originalPosition": 62}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQzNzM3MzY4OnYy", "diffSide": "RIGHT", "path": "ksqldb-engine/src/main/java/io/confluent/ksql/planner/plan/DataSourceNode.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xNlQxODowNToyMFrOF3AAtQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xNlQxODowNToyMFrOF3AAtQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzIxNjE4MQ==", "bodyText": "Moved from Analyzer", "url": "https://github.com/confluentinc/ksql/pull/4781#discussion_r393216181", "createdAt": "2020-03-16T18:05:20Z", "author": {"login": "big-andy-coates"}, "path": "ksqldb-engine/src/main/java/io/confluent/ksql/planner/plan/DataSourceNode.java", "diffHunk": "@@ -124,6 +140,21 @@ private static LogicalSchema buildSchema(final DataSource dataSource) {\n         .withMetaAndKeyColsInValue(dataSource.getKsqlTopic().getKeyFormat().isWindowed());\n   }\n \n+  private static Stream<ColumnName> orderColumns(\n+      final List<Column> columns,\n+      final LogicalSchema schema\n+  ) {\n+    // When doing a `select *` system and key columns should be at the front of the column list\n+    // but are added at the back during processing for performance reasons.\n+    // Switch them around here:\n+    final Map<Boolean, List<Column>> partitioned = columns.stream().collect(Collectors\n+        .groupingBy(c -> SchemaUtil.isSystemColumn(c.name()) || schema.isKeyColumn(c.name())));\n+\n+    final List<Column> all = partitioned.get(true);\n+    all.addAll(partitioned.get(false));\n+    return all.stream().map(Column::name);\n+  }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b53fba882cbbb226a66081cbf258c1813fad81bb"}, "originalPosition": 104}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQzNzQwNDQzOnYy", "diffSide": "RIGHT", "path": "ksqldb-execution/src/main/java/io/confluent/ksql/execution/util/ComparisonUtil.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xNlQxODoxMToyOVrOF3ATww==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xNlQxODoxMToyOVrOF3ATww==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzIyMTA1OQ==", "bodyText": "Found a bug in here when moving tests to QTT:  Comparisons to the NULL type result in SqlType of null, which caused an NPE in this method!\nUnfortunately, fixing it caused the complexity of this method to go over the checkstyle rule, so had to refactor.", "url": "https://github.com/confluentinc/ksql/pull/4781#discussion_r393221059", "createdAt": "2020-03-16T18:11:29Z", "author": {"login": "big-andy-coates"}, "path": "ksqldb-execution/src/main/java/io/confluent/ksql/execution/util/ComparisonUtil.java", "diffHunk": "@@ -15,38 +15,104 @@\n \n package io.confluent.ksql.execution.util;\n \n+import static java.util.Objects.requireNonNull;\n+\n+import com.google.common.collect.ImmutableList;\n import io.confluent.ksql.execution.expression.tree.ComparisonExpression;\n+import io.confluent.ksql.execution.expression.tree.ComparisonExpression.Type;\n import io.confluent.ksql.schema.ksql.SqlBaseType;\n import io.confluent.ksql.schema.ksql.types.SqlType;\n import io.confluent.ksql.util.KsqlException;\n+import java.util.List;\n+import java.util.function.BiPredicate;\n+import java.util.function.Predicate;\n \n final class ComparisonUtil {\n \n-  private ComparisonUtil() {\n+  private static final List<Handler> HANDLERS = ImmutableList.<Handler>builder()\n+      .add(handler(SqlBaseType::isNumber, ComparisonUtil::handleNumber))\n+      .add(handler(SqlBaseType.STRING, ComparisonUtil::handleString))\n+      .add(handler(SqlBaseType.BOOLEAN, ComparisonUtil::handleBoolean))\n+      .build();\n \n+  private ComparisonUtil() {\n   }\n \n-  static boolean isValidComparison(\n+  static void isValidComparison(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b53fba882cbbb226a66081cbf258c1813fad81bb"}, "originalPosition": 29}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQzNzQxNjA5OnYy", "diffSide": "RIGHT", "path": "ksqldb-rest-app/src/main/java/io/confluent/ksql/rest/server/execution/PullQueryExecutor.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xNlQxODoxNDo0OVrOF3AbGw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xNlQxODoxNDo0OVrOF3AbGw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzIyMjkzOQ==", "bodyText": "This actually means KSQL rejects any pull query that uses a mix of * and explicit column names in a pull query. Previously, depending on the order, the explicit columns were ignored or a weird error was returned.  At least now a meaningful error is returned.", "url": "https://github.com/confluentinc/ksql/pull/4781#discussion_r393222939", "createdAt": "2020-03-16T18:14:49Z", "author": {"login": "big-andy-coates"}, "path": "ksqldb-rest-app/src/main/java/io/confluent/ksql/rest/server/execution/PullQueryExecutor.java", "diffHunk": "@@ -757,8 +763,15 @@ private static ComparisonTarget extractWhereClauseTarget(\n   }\n \n   private static boolean isSelectStar(final Select select) {\n-    final List<SelectItem> selects = select.getSelectItems();\n-    return selects.size() == 1 && selects.get(0) instanceof AllColumns;\n+    final boolean someStars = select.getSelectItems().stream()\n+        .anyMatch(s -> s instanceof AllColumns);\n+\n+    if (someStars && select.getSelectItems().size() != 1) {\n+      throw new KsqlException(\"Pull queries only support wildcards in the projects \"\n+          + \"if they are the only expression\");\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b53fba882cbbb226a66081cbf258c1813fad81bb"}, "originalPosition": 72}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ0MjI2ODY1OnYy", "diffSide": "RIGHT", "path": "ksqldb-engine/src/main/java/io/confluent/ksql/planner/plan/JoinNode.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xN1QyMjo0MDowN1rOF3wljw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOFQxMDowMToyNVrOF39zTA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDAxMjA0Nw==", "bodyText": "at what point do we change the names of the columns to prepend <SOURCE>_ and does it make sense to do it here instead? e.g.\nksql> CREATE STREAM s (id VARCHAR, val VARCHAR) WITH (kafka_topic='s', value_format='json', partitions=1);\nksql> CREATE TABLE t (id VARCHAR, val VARCHAR) with (kafka_topic='t', value_format='json', partitions=1, key='id');\nksql> CREATE STREAM j AS SELECT * FROM s LEFT JOIN t ON s.id = t.id;\nksql> SELECT * FROM J EMIT CHANGES;\n+-------+-------+-------+-------+-------+-------+-------+-------+-------+-------+\n|ROWTIME|ROWKEY |S_ROWTI|S_ROWKE|S_ID   |S_VAL  |T_ROWTI|T_ROWKE|T_ID   |T_VAL  |\n|       |       |ME     |Y      |       |       |ME     |Y      |       |       |\n+-------+-------+-------+-------+-------+-------+-------+-------+-------+-------+", "url": "https://github.com/confluentinc/ksql/pull/4781#discussion_r394012047", "createdAt": "2020-03-17T22:40:07Z", "author": {"login": "agavra"}, "path": "ksqldb-engine/src/main/java/io/confluent/ksql/planner/plan/JoinNode.java", "diffHunk": "@@ -111,6 +112,15 @@ protected int getPartitions(final KafkaTopicClient kafkaTopicClient) {\n     return right.getPartitions(kafkaTopicClient);\n   }\n \n+  @Override\n+  public Stream<ColumnName> resolveSelectStar(\n+      final Optional<SourceName> sourceName, final boolean valueOnly\n+  ) {\n+    return getSources().stream()\n+        .filter(s -> !sourceName.isPresent() || sourceName.equals(s.getSourceName()))\n+        .flatMap(s -> s.resolveSelectStar(sourceName, false));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8d17dde25147b08474fc662252b957f82d007cb5"}, "originalPosition": 46}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDIyODU1Ng==", "bodyText": "@rodesai made a change to the LogicalPlanner to alias the join columns in a projection node, prior to the join node.  There's probably scope for cleaning some of that work up a little once the dust has settled from recent changes. However:\n1). I actually probably makes sense to handle the aliases in the rewriter the engine runs post-parse/pre-execute, rather than in this method.\n2) It's out of scope for this PR.", "url": "https://github.com/confluentinc/ksql/pull/4781#discussion_r394228556", "createdAt": "2020-03-18T10:01:25Z", "author": {"login": "big-andy-coates"}, "path": "ksqldb-engine/src/main/java/io/confluent/ksql/planner/plan/JoinNode.java", "diffHunk": "@@ -111,6 +112,15 @@ protected int getPartitions(final KafkaTopicClient kafkaTopicClient) {\n     return right.getPartitions(kafkaTopicClient);\n   }\n \n+  @Override\n+  public Stream<ColumnName> resolveSelectStar(\n+      final Optional<SourceName> sourceName, final boolean valueOnly\n+  ) {\n+    return getSources().stream()\n+        .filter(s -> !sourceName.isPresent() || sourceName.equals(s.getSourceName()))\n+        .flatMap(s -> s.resolveSelectStar(sourceName, false));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDAxMjA0Nw=="}, "originalCommit": {"oid": "8d17dde25147b08474fc662252b957f82d007cb5"}, "originalPosition": 46}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ0MjI3MTMwOnYy", "diffSide": "RIGHT", "path": "ksqldb-engine/src/main/java/io/confluent/ksql/planner/plan/FlatMapNode.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xN1QyMjo0MToyMlrOF3wnUQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOFQxMDoxNzozOFrOF3-Zcg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDAxMjQ5Nw==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              public Expression resolveSelect(final int idx, final Expression expression) {\n          \n          \n            \n              @Override\n          \n          \n            \n              public Expression resolveSelect(final int idx, final Expression expression) {", "url": "https://github.com/confluentinc/ksql/pull/4781#discussion_r394012497", "createdAt": "2020-03-17T22:41:22Z", "author": {"login": "agavra"}, "path": "ksqldb-engine/src/main/java/io/confluent/ksql/planner/plan/FlatMapNode.java", "diffHunk": "@@ -90,6 +94,10 @@ protected int getPartitions(final KafkaTopicClient kafkaTopicClient) {\n     return source.getPartitions(kafkaTopicClient);\n   }\n \n+  public Expression resolveSelect(final int idx, final Expression expression) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8d17dde25147b08474fc662252b957f82d007cb5"}, "originalPosition": 48}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDIzODMyMg==", "bodyText": "done.", "url": "https://github.com/confluentinc/ksql/pull/4781#discussion_r394238322", "createdAt": "2020-03-18T10:17:38Z", "author": {"login": "big-andy-coates"}, "path": "ksqldb-engine/src/main/java/io/confluent/ksql/planner/plan/FlatMapNode.java", "diffHunk": "@@ -90,6 +94,10 @@ protected int getPartitions(final KafkaTopicClient kafkaTopicClient) {\n     return source.getPartitions(kafkaTopicClient);\n   }\n \n+  public Expression resolveSelect(final int idx, final Expression expression) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDAxMjQ5Nw=="}, "originalCommit": {"oid": "8d17dde25147b08474fc662252b957f82d007cb5"}, "originalPosition": 48}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ0MjI4MTk3OnYy", "diffSide": "RIGHT", "path": "ksqldb-engine/src/main/java/io/confluent/ksql/planner/LogicalPlanner.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xN1QyMjo0NjoxMFrOF3wt5g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOFQxMDoxOToxOVrOF3-dWg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDAxNDE4Mg==", "bodyText": "this comment is a little confusing to me - where are we taking only the value columns?", "url": "https://github.com/confluentinc/ksql/pull/4781#discussion_r394014182", "createdAt": "2020-03-17T22:46:10Z", "author": {"login": "agavra"}, "path": "ksqldb-engine/src/main/java/io/confluent/ksql/planner/LogicalPlanner.java", "diffHunk": "@@ -223,6 +262,46 @@ private ProjectNode buildProjectNode(\n     );\n   }\n \n+  private List<SelectExpression> buildSelectExpressions(final PlanNode parentNode) {\n+    return IntStream.range(0, analysis.getSelectItems().size())\n+        .boxed()\n+        .flatMap(idx -> resolveSelectItem(idx, parentNode))\n+        .collect(Collectors.toList());\n+  }\n+\n+  private Stream<SelectExpression> resolveSelectItem(\n+      final int idx,\n+      final PlanNode parentNode\n+  ) {\n+    final SelectItem selectItem = analysis.getSelectItems().get(idx);\n+\n+    if (selectItem instanceof SingleColumn) {\n+      final SingleColumn column = (SingleColumn) selectItem;\n+      final Expression expression = parentNode.resolveSelect(idx, column.getExpression());\n+      final ColumnName alias = column.getAlias()\n+          .orElseThrow(() -> new IllegalStateException(\"Alias should be present by this point\"));\n+\n+      return Stream.of(SelectExpression.of(alias, expression));\n+    }\n+\n+    if (selectItem instanceof AllColumns) {\n+      final AllColumns allColumns = (AllColumns) selectItem;\n+\n+      final Stream<ColumnName> columns = parentNode\n+          .resolveSelectStar(allColumns.getSource(), analysis.getInto().isPresent());\n+\n+      // Only need to take value columns as value schema includes key schema by this point", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8d17dde25147b08474fc662252b957f82d007cb5"}, "originalPosition": 218}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDIzOTMyMg==", "bodyText": "outdated comment - remove.", "url": "https://github.com/confluentinc/ksql/pull/4781#discussion_r394239322", "createdAt": "2020-03-18T10:19:19Z", "author": {"login": "big-andy-coates"}, "path": "ksqldb-engine/src/main/java/io/confluent/ksql/planner/LogicalPlanner.java", "diffHunk": "@@ -223,6 +262,46 @@ private ProjectNode buildProjectNode(\n     );\n   }\n \n+  private List<SelectExpression> buildSelectExpressions(final PlanNode parentNode) {\n+    return IntStream.range(0, analysis.getSelectItems().size())\n+        .boxed()\n+        .flatMap(idx -> resolveSelectItem(idx, parentNode))\n+        .collect(Collectors.toList());\n+  }\n+\n+  private Stream<SelectExpression> resolveSelectItem(\n+      final int idx,\n+      final PlanNode parentNode\n+  ) {\n+    final SelectItem selectItem = analysis.getSelectItems().get(idx);\n+\n+    if (selectItem instanceof SingleColumn) {\n+      final SingleColumn column = (SingleColumn) selectItem;\n+      final Expression expression = parentNode.resolveSelect(idx, column.getExpression());\n+      final ColumnName alias = column.getAlias()\n+          .orElseThrow(() -> new IllegalStateException(\"Alias should be present by this point\"));\n+\n+      return Stream.of(SelectExpression.of(alias, expression));\n+    }\n+\n+    if (selectItem instanceof AllColumns) {\n+      final AllColumns allColumns = (AllColumns) selectItem;\n+\n+      final Stream<ColumnName> columns = parentNode\n+          .resolveSelectStar(allColumns.getSource(), analysis.getInto().isPresent());\n+\n+      // Only need to take value columns as value schema includes key schema by this point", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDAxNDE4Mg=="}, "originalCommit": {"oid": "8d17dde25147b08474fc662252b957f82d007cb5"}, "originalPosition": 218}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3772, "cost": 1, "resetAt": "2021-11-12T19:05:54Z"}}}