{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDY3NTU5MTk3", "number": 6018, "title": "fix: set restarted query as healthy during a time threshold", "bodyText": "Description\nFixes #6009\nUse the config ksql.query.status.running.threshold.seconds to specify a threshold when stop tracking query error retries and set the query as healthy and running. All past query errors will be cleared after the threshold time expires.\nI also took the time to make some minor improvements to the query monitor code.\nTesting done\nAdd unit tests\nReviewer checklist\n\n Ensure docs are updated if necessary. (eg. if a user visible feature is being added or changed).\n Ensure relevant issues are linked (description should include text like \"Fixes #\")", "createdAt": "2020-08-13T18:22:40Z", "url": "https://github.com/confluentinc/ksql/pull/6018", "merged": true, "mergeCommit": {"oid": "ae5c2153c73e3307528b1434e593dbd6d20826c7"}, "closed": true, "closedAt": "2020-08-17T21:33:32Z", "author": {"login": "spena"}, "timelineItems": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABc-kpjCgFqTQ2NzAzMjEyOA==", "endCursor": "Y3Vyc29yOnYyOpPPAAABc_1NkZAFqTQ2ODYyNjY0MQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY3MDMyMTI4", "url": "https://github.com/confluentinc/ksql/pull/6018#pullrequestreview-467032128", "createdAt": "2020-08-13T18:36:57Z", "commit": {"oid": "625ff195e441d52081188b9c15d8cf394d5b9a0f"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xM1QxODozNjo1N1rOHAYofQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xM1QxODo1MDozOVrOHAZHNg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDE2NTYyOQ==", "bodyText": "yay! I hate .forEach with a large nested lambda \ud83d\ude02", "url": "https://github.com/confluentinc/ksql/pull/6018#discussion_r470165629", "createdAt": "2020-08-13T18:36:57Z", "author": {"login": "agavra"}, "path": "ksqldb-engine/src/main/java/io/confluent/ksql/engine/QueryMonitor.java", "diffHunk": "@@ -120,32 +123,52 @@ private void maybeRestartQueries() {\n     final long now = ticker.read();\n \n     // Restart queries that has passed the waiting timeout\n-    final List<QueryId> deleteRetryEvents = new ArrayList<>();\n-    queriesRetries.entrySet().stream()\n-        .forEach(mapEntry -> {\n-          final QueryId queryId = mapEntry.getKey();\n-          final RetryEvent retryEvent = mapEntry.getValue();\n-          final Optional<PersistentQueryMetadata> query = ksqlEngine.getPersistentQuery(queryId);\n-\n-          // Query was terminated manually if no present\n-          if (!query.isPresent()) {\n-            deleteRetryEvents.add(queryId);\n-          } else if (query.get().isError() && now > retryEvent.nextRestartTimeMs()) {\n-            // Retry again if it's still in ERROR state\n-            retryEvent.restart();\n-          } else if (now > retryEvent.queryHealthyTime()) {\n-            // Clean the errors queue & delete the query from future retries now the query is\n-            // healthy\n-            query.ifPresent(QueryMetadata::clearErrors);\n-            deleteRetryEvents.add(queryId);\n-          }\n-        });\n-\n-    deleteRetryEvents.stream().forEach(queriesRetries::remove);\n+    final Iterator<Map.Entry<QueryId, RetryEvent>> it = queriesRetries.entrySet().iterator();\n+    while (it.hasNext()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "625ff195e441d52081188b9c15d8cf394d5b9a0f"}, "originalPosition": 67}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDE2NzY0Nw==", "bodyText": "I don't think we should include CREATED in this - to make sure that the backoff loop doesn't get reset if the state is in CREATED as it'll probably soon transfer to RUNNING", "url": "https://github.com/confluentinc/ksql/pull/6018#discussion_r470167647", "createdAt": "2020-08-13T18:40:28Z", "author": {"login": "agavra"}, "path": "ksqldb-engine/src/main/java/io/confluent/ksql/engine/QueryMonitor.java", "diffHunk": "@@ -120,32 +123,52 @@ private void maybeRestartQueries() {\n     final long now = ticker.read();\n \n     // Restart queries that has passed the waiting timeout\n-    final List<QueryId> deleteRetryEvents = new ArrayList<>();\n-    queriesRetries.entrySet().stream()\n-        .forEach(mapEntry -> {\n-          final QueryId queryId = mapEntry.getKey();\n-          final RetryEvent retryEvent = mapEntry.getValue();\n-          final Optional<PersistentQueryMetadata> query = ksqlEngine.getPersistentQuery(queryId);\n-\n-          // Query was terminated manually if no present\n-          if (!query.isPresent()) {\n-            deleteRetryEvents.add(queryId);\n-          } else if (query.get().isError() && now > retryEvent.nextRestartTimeMs()) {\n-            // Retry again if it's still in ERROR state\n-            retryEvent.restart();\n-          } else if (now > retryEvent.queryHealthyTime()) {\n-            // Clean the errors queue & delete the query from future retries now the query is\n-            // healthy\n-            query.ifPresent(QueryMetadata::clearErrors);\n-            deleteRetryEvents.add(queryId);\n-          }\n-        });\n-\n-    deleteRetryEvents.stream().forEach(queriesRetries::remove);\n+    final Iterator<Map.Entry<QueryId, RetryEvent>> it = queriesRetries.entrySet().iterator();\n+    while (it.hasNext()) {\n+      final Map.Entry<QueryId, RetryEvent> mapEntry = it.next();\n+\n+      final QueryId queryId = mapEntry.getKey();\n+      final RetryEvent retryEvent = mapEntry.getValue();\n+      final Optional<PersistentQueryMetadata> query = ksqlEngine.getPersistentQuery(queryId);\n+\n+      // Query was terminated manually if no present\n+      if (!query.isPresent()) {\n+        it.remove();\n+      } else {\n+        final PersistentQueryMetadata queryMetadata = query.get();\n+        switch (queryMetadata.getState()) {\n+          case ERROR:\n+            if (now >= retryEvent.nextRestartTimeMs()) {\n+              retryEvent.restart(queryMetadata);\n+            }\n+            break;\n+          case RUNNING:\n+          case REBALANCING:\n+            if (now >= retryEvent.queryHealthyTime()) {\n+              // Clean the errors queue & delete the query from future retries now the query is\n+              // healthy and has been running after some threshold time\n+              query.ifPresent(QueryMetadata::clearErrors);\n+              it.remove();\n+            }\n+            break;\n+          default:\n+            // Stop attempting restarts for any other status. Either the query is pending\n+            // a shutdown or other status that do not track.\n+            it.remove();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "625ff195e441d52081188b9c15d8cf394d5b9a0f"}, "originalPosition": 97}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDE2ODYyMg==", "bodyText": "nit: we know it's present, can we just queryMetadata.clearErrors()?", "url": "https://github.com/confluentinc/ksql/pull/6018#discussion_r470168622", "createdAt": "2020-08-13T18:41:58Z", "author": {"login": "agavra"}, "path": "ksqldb-engine/src/main/java/io/confluent/ksql/engine/QueryMonitor.java", "diffHunk": "@@ -120,32 +123,52 @@ private void maybeRestartQueries() {\n     final long now = ticker.read();\n \n     // Restart queries that has passed the waiting timeout\n-    final List<QueryId> deleteRetryEvents = new ArrayList<>();\n-    queriesRetries.entrySet().stream()\n-        .forEach(mapEntry -> {\n-          final QueryId queryId = mapEntry.getKey();\n-          final RetryEvent retryEvent = mapEntry.getValue();\n-          final Optional<PersistentQueryMetadata> query = ksqlEngine.getPersistentQuery(queryId);\n-\n-          // Query was terminated manually if no present\n-          if (!query.isPresent()) {\n-            deleteRetryEvents.add(queryId);\n-          } else if (query.get().isError() && now > retryEvent.nextRestartTimeMs()) {\n-            // Retry again if it's still in ERROR state\n-            retryEvent.restart();\n-          } else if (now > retryEvent.queryHealthyTime()) {\n-            // Clean the errors queue & delete the query from future retries now the query is\n-            // healthy\n-            query.ifPresent(QueryMetadata::clearErrors);\n-            deleteRetryEvents.add(queryId);\n-          }\n-        });\n-\n-    deleteRetryEvents.stream().forEach(queriesRetries::remove);\n+    final Iterator<Map.Entry<QueryId, RetryEvent>> it = queriesRetries.entrySet().iterator();\n+    while (it.hasNext()) {\n+      final Map.Entry<QueryId, RetryEvent> mapEntry = it.next();\n+\n+      final QueryId queryId = mapEntry.getKey();\n+      final RetryEvent retryEvent = mapEntry.getValue();\n+      final Optional<PersistentQueryMetadata> query = ksqlEngine.getPersistentQuery(queryId);\n+\n+      // Query was terminated manually if no present\n+      if (!query.isPresent()) {\n+        it.remove();\n+      } else {\n+        final PersistentQueryMetadata queryMetadata = query.get();\n+        switch (queryMetadata.getState()) {\n+          case ERROR:\n+            if (now >= retryEvent.nextRestartTimeMs()) {\n+              retryEvent.restart(queryMetadata);\n+            }\n+            break;\n+          case RUNNING:\n+          case REBALANCING:\n+            if (now >= retryEvent.queryHealthyTime()) {\n+              // Clean the errors queue & delete the query from future retries now the query is\n+              // healthy and has been running after some threshold time\n+              query.ifPresent(QueryMetadata::clearErrors);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "625ff195e441d52081188b9c15d8cf394d5b9a0f"}, "originalPosition": 90}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDE3MDcwOA==", "bodyText": "this seems a little high - can we set it to 2700 instead? (3x the max query backoff)", "url": "https://github.com/confluentinc/ksql/pull/6018#discussion_r470170708", "createdAt": "2020-08-13T18:45:35Z", "author": {"login": "agavra"}, "path": "ksqldb-common/src/main/java/io/confluent/ksql/util/KsqlConfig.java", "diffHunk": "@@ -340,6 +340,12 @@\n       + \"error messages (per query) to hold in the internal query errors queue and display\"\n       + \"in the query description when executing the `EXPLAIN <query>` command.\";\n \n+  public static final String KSQL_QUERY_STATUS_RUNNING_THRESHOLD_SECS =\n+      \"ksql.query.status.running.threshold.seconds\";\n+  private static final Integer KSQL_QUERY_STATUS_RUNNING_THRESHOLD_SECS_DEFAULT = 18000;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "625ff195e441d52081188b9c15d8cf394d5b9a0f"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDE3MzQ5NA==", "bodyText": "tracking this way is OK, but I think it would be better if we exposed how long the query was actually running from the query metadata. That way, we can know that what we're measuring is exactly query uptime, and not just time since the last attempted restart.\nWe can implement this using a KafkaStreams.StateListener to start the timer when transitioning to RUNNING for the first time.", "url": "https://github.com/confluentinc/ksql/pull/6018#discussion_r470173494", "createdAt": "2020-08-13T18:50:39Z", "author": {"login": "agavra"}, "path": "ksqldb-engine/src/main/java/io/confluent/ksql/engine/QueryMonitor.java", "diffHunk": "@@ -168,31 +191,35 @@ public void run() {\n   }\n \n   static class RetryEvent {\n-    private final KsqlEngine ksqlEngine;\n     private final QueryId queryId;\n     private final Ticker ticker;\n+    private final long statusRunningThresholdMs;\n \n     private int numRetries = 0;\n     private long waitingTimeMs;\n     private long expiryTimeMs;\n     private long retryBackoffMaxMs;\n     private long baseWaitingTimeMs;\n+    private long healthyTimeMs;\n \n     RetryEvent(\n-        final KsqlEngine ksqlEngine,\n         final QueryId queryId,\n         final long baseWaitingTimeMs,\n         final long retryBackoffMaxMs,\n+        final long statusRunningThresholdMs,\n         final Ticker ticker\n     ) {\n-      this.ksqlEngine = ksqlEngine;\n       this.queryId = queryId;\n       this.ticker = ticker;\n+      this.statusRunningThresholdMs = statusRunningThresholdMs;\n+\n+      final long now = ticker.read();\n \n       this.baseWaitingTimeMs = baseWaitingTimeMs;\n       this.waitingTimeMs = baseWaitingTimeMs;\n-      this.expiryTimeMs = ticker.read() + baseWaitingTimeMs;\n       this.retryBackoffMaxMs = retryBackoffMaxMs;\n+      this.expiryTimeMs = now + baseWaitingTimeMs;\n+      this.healthyTimeMs = now + statusRunningThresholdMs;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "625ff195e441d52081188b9c15d8cf394d5b9a0f"}, "originalPosition": 152}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3c97bdca81b525f99e6fd230602f17300dd13c72", "author": {"user": {"login": "spena", "name": "Sergio Pe\u00f1a"}}, "url": "https://github.com/confluentinc/ksql/commit/3c97bdca81b525f99e6fd230602f17300dd13c72", "committedDate": "2020-08-16T11:15:52Z", "message": "fix: set restarted query as healthy during a time threshold"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "86e4cf60183e01e4c80f043421fc972842b85aaf", "author": {"user": {"login": "spena", "name": "Sergio Pe\u00f1a"}}, "url": "https://github.com/confluentinc/ksql/commit/86e4cf60183e01e4c80f043421fc972842b85aaf", "committedDate": "2020-08-16T11:15:52Z", "message": "fix: address Almog'ts feedback"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f4d44185d6cca5af04b95b5b6cda31e9c4e99468", "author": {"user": {"login": "spena", "name": "Sergio Pe\u00f1a"}}, "url": "https://github.com/confluentinc/ksql/commit/f4d44185d6cca5af04b95b5b6cda31e9c4e99468", "committedDate": "2020-08-16T11:15:52Z", "message": "fix: set uptime on QueryMetadata using QueryStateListener"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "625ff195e441d52081188b9c15d8cf394d5b9a0f", "author": {"user": {"login": "spena", "name": "Sergio Pe\u00f1a"}}, "url": "https://github.com/confluentinc/ksql/commit/625ff195e441d52081188b9c15d8cf394d5b9a0f", "committedDate": "2020-08-13T18:17:38Z", "message": "fix: set restarted query as healthy during a time threshold"}, "afterCommit": {"oid": "f4d44185d6cca5af04b95b5b6cda31e9c4e99468", "author": {"user": {"login": "spena", "name": "Sergio Pe\u00f1a"}}, "url": "https://github.com/confluentinc/ksql/commit/f4d44185d6cca5af04b95b5b6cda31e9c4e99468", "committedDate": "2020-08-16T11:15:52Z", "message": "fix: set uptime on QueryMetadata using QueryStateListener"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY4NjI2NjQx", "url": "https://github.com/confluentinc/ksql/pull/6018#pullrequestreview-468626641", "createdAt": "2020-08-17T16:43:06Z", "commit": {"oid": "f4d44185d6cca5af04b95b5b6cda31e9c4e99468"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4694, "cost": 1, "resetAt": "2021-11-01T13:51:04Z"}}}