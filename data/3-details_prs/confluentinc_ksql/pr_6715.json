{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTMxNDc2MDUy", "number": 6715, "title": "chore: avoid extra state store when repartitioning tables for joins", "bodyText": "Description\nFixes #6650 by taking the second of the two proposed solutions.\nThis PR introduces a PlanInfoExtractor which traverses the execution step plan to collect needed information to be passed to the PlanBuilder, for use when translating the execution step plan into an actual Kafka Streams topology. The PlanInfoExtractor collects information about whether sources are repartitioned downstream (prior to any joins). The SourceBuilder uses this information to decide whether or not to force materialization on source tables -- if the table is repartitioned downstream, it is not necessary to force materialization at the table source.\nTesting done\nUnit + QTT.\nReviewer checklist\n\n Ensure docs are updated if necessary. (eg. if a user visible feature is being added or changed).\n Ensure relevant issues are linked (description should include text like \"Fixes #\")", "createdAt": "2020-12-03T04:50:58Z", "url": "https://github.com/confluentinc/ksql/pull/6715", "merged": true, "mergeCommit": {"oid": "2576feeb5a2a8b0067c460ea26eb57fbf43ca2c5"}, "closed": true, "closedAt": "2020-12-04T03:21:45Z", "author": {"login": "vcrfxia"}, "timelineItems": {"totalCount": 9, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdibRSngH2gAyNTMxNDc2MDUyOjYzNTJjYWUyMGQzOWU5MmFiYmRiMDdlNDVkNDEwNDQ1MjhmMDk2ODI=", "endCursor": "Y3Vyc29yOnYyOpPPAAABditl6eAH2gAyNTMxNDc2MDUyOjQ3NjMyNmY1MmY0Nzc2MTkwMTRmOGJlZDVlYTA0ZWEyMzQ5MDA5ZTI=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "6352cae20d39e92abbdb07e45d41044528f09682", "author": {"user": {"login": "vcrfxia", "name": "Victoria Xia"}}, "url": "https://github.com/confluentinc/ksql/commit/6352cae20d39e92abbdb07e45d41044528f09682", "committedDate": "2020-12-03T04:16:59Z", "message": "chore: avoid extra state store when repartitioning tables for joins"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQzNDU4OTA4", "url": "https://github.com/confluentinc/ksql/pull/6715#pullrequestreview-543458908", "createdAt": "2020-12-03T04:51:38Z", "commit": {"oid": "6352cae20d39e92abbdb07e45d41044528f09682"}, "state": "COMMENTED", "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wM1QwNDo1MTozOVrOH95eCA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wM1QwNDo1Mzo1M1rOH95g1g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDY2Njc2MA==", "bodyText": "The current expectation is that this variant is only called by QueryExecutor, on output nodes, and not from any intermediate nodes. Is it worth enforcing this assumption by throwing an exception if the method is called a non-output-node execution step?", "url": "https://github.com/confluentinc/ksql/pull/6715#discussion_r534666760", "createdAt": "2020-12-03T04:51:39Z", "author": {"login": "vcrfxia"}, "path": "ksqldb-execution/src/main/java/io/confluent/ksql/execution/plan/ExecutionStep.java", "diffHunk": "@@ -60,7 +60,13 @@\n   @JsonIgnore\n   List<ExecutionStep<?>> getSources();\n \n-  S build(PlanBuilder planBuilder);\n+  default S build(PlanBuilder planBuilder) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6352cae20d39e92abbdb07e45d41044528f09682"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDY2NjkzOQ==", "bodyText": "Today, we only ever repartition tables to enable joins, and it is not possible to repartition a table after a table operation that requires materialization (e.g., joining on a table that is the result of grouping by another table, in the same query) so it is correct to only track repartitions when deciding whether to force materialization at the table source or not. However, if in the future we allow table repartitions after table operations that require materialization, then this logic will have to be updated to account for that. Does it make sense to future-proof this and add in the more complicated logic now, or would that be overcomplicating things?", "url": "https://github.com/confluentinc/ksql/pull/6715#discussion_r534666939", "createdAt": "2020-12-03T04:52:08Z", "author": {"login": "vcrfxia"}, "path": "ksqldb-streams/src/main/java/io/confluent/ksql/execution/streams/KSPlanInfoExtractor.java", "diffHunk": "@@ -0,0 +1,191 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (final the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.execution.streams;\n+\n+import io.confluent.ksql.execution.plan.ExecutionStep;\n+import io.confluent.ksql.execution.plan.PlanInfoExtractor;\n+import io.confluent.ksql.execution.plan.StreamAggregate;\n+import io.confluent.ksql.execution.plan.StreamFilter;\n+import io.confluent.ksql.execution.plan.StreamFlatMap;\n+import io.confluent.ksql.execution.plan.StreamGroupBy;\n+import io.confluent.ksql.execution.plan.StreamGroupByKey;\n+import io.confluent.ksql.execution.plan.StreamSelect;\n+import io.confluent.ksql.execution.plan.StreamSelectKey;\n+import io.confluent.ksql.execution.plan.StreamSelectKeyV1;\n+import io.confluent.ksql.execution.plan.StreamSink;\n+import io.confluent.ksql.execution.plan.StreamSource;\n+import io.confluent.ksql.execution.plan.StreamStreamJoin;\n+import io.confluent.ksql.execution.plan.StreamTableJoin;\n+import io.confluent.ksql.execution.plan.StreamWindowedAggregate;\n+import io.confluent.ksql.execution.plan.TableAggregate;\n+import io.confluent.ksql.execution.plan.TableFilter;\n+import io.confluent.ksql.execution.plan.TableGroupBy;\n+import io.confluent.ksql.execution.plan.TableSelect;\n+import io.confluent.ksql.execution.plan.TableSelectKey;\n+import io.confluent.ksql.execution.plan.TableSink;\n+import io.confluent.ksql.execution.plan.TableSource;\n+import io.confluent.ksql.execution.plan.TableSuppress;\n+import io.confluent.ksql.execution.plan.TableTableJoin;\n+import io.confluent.ksql.execution.plan.WindowedStreamSource;\n+import io.confluent.ksql.execution.plan.WindowedTableSource;\n+\n+/**\n+ * Visitor for extracting {@link KSPlanInfo} from an execution step plan.\n+ * See {@link KSPlanInfo} description for more.\n+ */\n+public class KSPlanInfoExtractor implements PlanInfoExtractor {\n+  \n+  @Override\n+  public <K> KSPlanInfo visitStreamFilter(final StreamFilter<K> streamFilter) {\n+    return visitSingleSourceStep(streamFilter);\n+  }\n+\n+  @Override\n+  public <K> KSPlanInfo visitStreamGroupBy(final StreamGroupBy<K> streamGroupBy) {\n+    return visitSingleSourceStep(streamGroupBy);\n+  }\n+\n+  @Override\n+  public KSPlanInfo visitStreamGroupByKey(final StreamGroupByKey streamGroupByKey) {\n+    return visitSingleSourceStep(streamGroupByKey);\n+  }\n+\n+  @Override\n+  public KSPlanInfo visitStreamAggregate(final StreamAggregate streamAggregate) {\n+    return visitSingleSourceStep(streamAggregate);\n+  }\n+\n+  @Override\n+  public <K> KSPlanInfo visitStreamSelect(final StreamSelect<K> streamSelect) {\n+    return visitSingleSourceStep(streamSelect);\n+  }\n+\n+  @Override\n+  public <K> KSPlanInfo visitFlatMap(final StreamFlatMap<K> streamFlatMap) {\n+    return visitSingleSourceStep(streamFlatMap);\n+  }\n+\n+  @Override\n+  public KSPlanInfo visitStreamSelectKey(final StreamSelectKeyV1 streamSelectKey) {\n+    return visitRepartitionStep(streamSelectKey);\n+  }\n+\n+  @Override\n+  public <K> KSPlanInfo visitStreamSelectKey(final StreamSelectKey<K> streamSelectKey) {\n+    return visitRepartitionStep(streamSelectKey);\n+  }\n+\n+  @Override\n+  public <K> KSPlanInfo visitStreamSink(final StreamSink<K> streamSink) {\n+    return visitSingleSourceStep(streamSink);\n+  }\n+\n+  @Override\n+  public KSPlanInfo visitStreamSource(final StreamSource streamSource) {\n+    return visitSourceStep(streamSource);\n+  }\n+\n+  @Override\n+  public KSPlanInfo visitWindowedStreamSource(final WindowedStreamSource windowedStreamSource) {\n+    return visitSourceStep(windowedStreamSource);\n+  }\n+\n+  @Override\n+  public <K> KSPlanInfo visitStreamStreamJoin(final StreamStreamJoin<K> streamStreamJoin) {\n+    return visitJoinStep(streamStreamJoin);\n+  }\n+\n+  @Override\n+  public <K> KSPlanInfo visitStreamTableJoin(final StreamTableJoin<K> streamTableJoin) {\n+    return visitJoinStep(streamTableJoin);\n+  }\n+\n+  @Override\n+  public KSPlanInfo visitTableSource(final TableSource tableSource) {\n+    return visitSourceStep(tableSource);\n+  }\n+\n+  @Override\n+  public KSPlanInfo visitWindowedTableSource(final WindowedTableSource windowedTableSource) {\n+    return visitSourceStep(windowedTableSource);\n+  }\n+\n+  @Override\n+  public KSPlanInfo visitStreamWindowedAggregate(\n+      final StreamWindowedAggregate streamWindowedAggregate\n+  ) {\n+    return visitSingleSourceStep(streamWindowedAggregate);\n+  }\n+\n+  @Override\n+  public KSPlanInfo visitTableAggregate(final TableAggregate tableAggregate) {\n+    return visitSingleSourceStep(tableAggregate);\n+  }\n+\n+  @Override\n+  public <K> KSPlanInfo visitTableFilter(final TableFilter<K> tableFilter) {\n+    return visitSingleSourceStep(tableFilter);\n+  }\n+\n+  @Override\n+  public <K> KSPlanInfo visitTableGroupBy(final TableGroupBy<K> tableGroupBy) {\n+    return visitSingleSourceStep(tableGroupBy);\n+  }\n+\n+  @Override\n+  public <K> KSPlanInfo visitTableSelect(final TableSelect<K> tableSelect) {\n+    return visitSingleSourceStep(tableSelect);\n+  }\n+\n+  @Override\n+  public <K> KSPlanInfo visitTableSelectKey(final TableSelectKey<K> tableSelectKey) {\n+    return visitRepartitionStep(tableSelectKey);\n+  }\n+\n+  @Override\n+  public <K> KSPlanInfo visitTableSink(final TableSink<K> tableSink) {\n+    return visitSingleSourceStep(tableSink);\n+  }\n+\n+  @Override\n+  public <K> KSPlanInfo visitTableSuppress(final TableSuppress<K> tableSuppress) {\n+    return visitSingleSourceStep(tableSuppress);\n+  }\n+\n+  @Override\n+  public <K> KSPlanInfo visitTableTableJoin(final TableTableJoin<K> tableTableJoin) {\n+    return visitJoinStep(tableTableJoin);\n+  }\n+\n+  private KSPlanInfo visitSourceStep(final ExecutionStep<?> step) {\n+    return new KSPlanInfo(step);\n+  }\n+\n+  private KSPlanInfo visitRepartitionStep(final ExecutionStep<?> step) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6352cae20d39e92abbdb07e45d41044528f09682"}, "originalPosition": 177}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDY2NzA3NA==", "bodyText": "Is it weird that this interface is empty? It's unclear to me which (if any) parts of the KSPlanInfo implementation are generic enough to warrant being moved into the interface.", "url": "https://github.com/confluentinc/ksql/pull/6715#discussion_r534667074", "createdAt": "2020-12-03T04:52:30Z", "author": {"login": "vcrfxia"}, "path": "ksqldb-execution/src/main/java/io/confluent/ksql/execution/plan/PlanInfo.java", "diffHunk": "@@ -0,0 +1,23 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.execution.plan;\n+\n+/**\n+ * Information about an execution step plan to be passed to a {@link PlanBuilder}\n+ * for use when converting an execution step plan into a physical plan.\n+ */\n+public interface PlanInfo {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6352cae20d39e92abbdb07e45d41044528f09682"}, "originalPosition": 22}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDY2NzI1MA==", "bodyText": "Deleting and regenerating historic plans in this way is normally a major no-no but it was a conscious decision in this case as we have not released SR-enabled joins yet. This PR will be merged before 0.15 is cut, so these topology changes will not appear as a breaking change between releases.", "url": "https://github.com/confluentinc/ksql/pull/6715#discussion_r534667250", "createdAt": "2020-12-03T04:53:03Z", "author": {"login": "vcrfxia"}, "path": "ksqldb-functional-tests/src/test/resources/historical_plans/joins_-_stream-table_key-to-key_-_SR-enabled_key_format/6.2.0_1606950106050/topology", "diffHunk": "@@ -3,20 +3,17 @@ Topologies:\n     Source: KSTREAM-SOURCE-0000000001 (topics: [t])\n       --> KTABLE-SOURCE-0000000002\n     Processor: KTABLE-SOURCE-0000000002 (stores: [])\n-      --> KTABLE-MAPVALUES-0000000003", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6352cae20d39e92abbdb07e45d41044528f09682"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDY2NzQ3OA==", "bodyText": "Not sure why we had both easymock and mockito in this test file but easymock is gone now \ud83d\udc80", "url": "https://github.com/confluentinc/ksql/pull/6715#discussion_r534667478", "createdAt": "2020-12-03T04:53:53Z", "author": {"login": "vcrfxia"}, "path": "ksqldb-engine/src/test/java/io/confluent/ksql/structured/SchemaKTableTest.java", "diffHunk": "@@ -15,24 +15,22 @@\n \n package io.confluent.ksql.structured;\n \n-import static org.easymock.EasyMock.anyObject;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6352cae20d39e92abbdb07e45d41044528f09682"}, "originalPosition": 4}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQzNDY2MzI3", "url": "https://github.com/confluentinc/ksql/pull/6715#pullrequestreview-543466327", "createdAt": "2020-12-03T04:56:39Z", "commit": {"oid": "6352cae20d39e92abbdb07e45d41044528f09682"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wM1QwNDo1Njo0MFrOH95kXg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wM1QwNDo1Njo0MFrOH95kXg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDY2ODM4Mg==", "bodyText": "I assumed if we're removing the Materialized we might as well remove the dummy mapValues step too. This change is backwards compatible (between releases) since this pathway is only hit in the case of forcing table repartitions to enable joins, which are new as of master (not currently released). However, if we think it's confusing that sometimes there is a dummy mapValues step on table sources and sometimes there isn't, I can put the dummy mapValues step back in with no materialization.", "url": "https://github.com/confluentinc/ksql/pull/6715#discussion_r534668382", "createdAt": "2020-12-03T04:56:40Z", "author": {"login": "vcrfxia"}, "path": "ksqldb-streams/src/main/java/io/confluent/ksql/execution/streams/SourceBuilder.java", "diffHunk": "@@ -330,12 +335,23 @@ private static PhysicalSchema getPhysicalSchema(final SourceStep<?> streamSource\n       final KTable<K, GenericRow> source = queryBuilder\n           .getStreamsBuilder()\n           .table(streamSource.getTopicName(), consumed);\n-      // add this identity mapValues call to prevent the source-changelog\n-      // optimization in kafka streams - we don't want this optimization to\n-      // be enabled because we cannot require symmetric serialization between\n-      // producer and KSQL (see https://issues.apache.org/jira/browse/KAFKA-10179\n-      // and https://github.com/confluentinc/ksql/issues/5673 for more details)\n-      table = source.mapValues(row -> row, materialized);\n+\n+      final boolean forceMaterialization = !planInfo.isRepartitionedInPlan(streamSource);\n+      if (forceMaterialization) {\n+        // add this identity mapValues call to prevent the source-changelog\n+        // optimization in kafka streams - we don't want this optimization to\n+        // be enabled because we cannot require symmetric serialization between\n+        // producer and KSQL (see https://issues.apache.org/jira/browse/KAFKA-10179\n+        // and https://github.com/confluentinc/ksql/issues/5673 for more details)\n+        table = source.mapValues(row -> row, materialized);\n+      } else {\n+        // if we know this table source is repartitioned later in the topology,\n+        // we do not need to force a materialization at this source step since the\n+        // re-partitioned topic will be used for any subsequent state stores, in lieu\n+        // of the original source topic, thus avoiding the issues above.\n+        // See https://github.com/confluentinc/ksql/issues/6650\n+        table = source;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6352cae20d39e92abbdb07e45d41044528f09682"}, "originalPosition": 75}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ0MTk0NjEz", "url": "https://github.com/confluentinc/ksql/pull/6715#pullrequestreview-544194613", "createdAt": "2020-12-03T17:17:16Z", "commit": {"oid": "6352cae20d39e92abbdb07e45d41044528f09682"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wM1QxNzoxNzoxN1rOH-n_jQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wM1QxODoxMDozOFrOH-qONA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTQyOTAwNQ==", "bodyText": "I think it makes sense to remove it", "url": "https://github.com/confluentinc/ksql/pull/6715#discussion_r535429005", "createdAt": "2020-12-03T17:17:17Z", "author": {"login": "agavra"}, "path": "ksqldb-streams/src/main/java/io/confluent/ksql/execution/streams/SourceBuilder.java", "diffHunk": "@@ -330,12 +335,23 @@ private static PhysicalSchema getPhysicalSchema(final SourceStep<?> streamSource\n       final KTable<K, GenericRow> source = queryBuilder\n           .getStreamsBuilder()\n           .table(streamSource.getTopicName(), consumed);\n-      // add this identity mapValues call to prevent the source-changelog\n-      // optimization in kafka streams - we don't want this optimization to\n-      // be enabled because we cannot require symmetric serialization between\n-      // producer and KSQL (see https://issues.apache.org/jira/browse/KAFKA-10179\n-      // and https://github.com/confluentinc/ksql/issues/5673 for more details)\n-      table = source.mapValues(row -> row, materialized);\n+\n+      final boolean forceMaterialization = !planInfo.isRepartitionedInPlan(streamSource);\n+      if (forceMaterialization) {\n+        // add this identity mapValues call to prevent the source-changelog\n+        // optimization in kafka streams - we don't want this optimization to\n+        // be enabled because we cannot require symmetric serialization between\n+        // producer and KSQL (see https://issues.apache.org/jira/browse/KAFKA-10179\n+        // and https://github.com/confluentinc/ksql/issues/5673 for more details)\n+        table = source.mapValues(row -> row, materialized);\n+      } else {\n+        // if we know this table source is repartitioned later in the topology,\n+        // we do not need to force a materialization at this source step since the\n+        // re-partitioned topic will be used for any subsequent state stores, in lieu\n+        // of the original source topic, thus avoiding the issues above.\n+        // See https://github.com/confluentinc/ksql/issues/6650\n+        table = source;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDY2ODM4Mg=="}, "originalCommit": {"oid": "6352cae20d39e92abbdb07e45d41044528f09682"}, "originalPosition": 75}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTQ2NTUyNA==", "bodyText": "I think the abstract builder pattern makes sense for PlanBuilder, but less so for PlanInfoExtractor because we may want different PlanBuilders if we decide to implement a non-KS physical plan (ignoring for a sec that KStreamHolder isn't actually generic enough to support non-KS implementations yet). The PlanInfo, however, should make sense to any corresponding physical plan we decide to build (it's an analysis of the steps and has nothing to do with Kafka Streams specifically). All we have to do is rename \"repartition\" to \"keyChange\" and this change becomes entirely generic.\nthe tl;dr is that I don't think we need to have this be an interface (and I don't think we need an interface for PlanInfoExtractor either (though see my general comment about a different approach to this)", "url": "https://github.com/confluentinc/ksql/pull/6715#discussion_r535465524", "createdAt": "2020-12-03T18:10:38Z", "author": {"login": "agavra"}, "path": "ksqldb-execution/src/main/java/io/confluent/ksql/execution/plan/PlanInfo.java", "diffHunk": "@@ -0,0 +1,23 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.execution.plan;\n+\n+/**\n+ * Information about an execution step plan to be passed to a {@link PlanBuilder}\n+ * for use when converting an execution step plan into a physical plan.\n+ */\n+public interface PlanInfo {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDY2NzA3NA=="}, "originalCommit": {"oid": "6352cae20d39e92abbdb07e45d41044528f09682"}, "originalPosition": 22}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ0NTY0Mzkz", "url": "https://github.com/confluentinc/ksql/pull/6715#pullrequestreview-544564393", "createdAt": "2020-12-04T00:11:42Z", "commit": {"oid": "6352cae20d39e92abbdb07e45d41044528f09682"}, "state": "APPROVED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNFQwMDoxMTo0MlrOH-69MA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNFQwMDoxMTo0MlrOH-69MA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTczOTY5Ng==", "bodyText": "I'd rather nix the interface \ud83d\ude02 fewer lines of code to refactor when we inevitably do", "url": "https://github.com/confluentinc/ksql/pull/6715#discussion_r535739696", "createdAt": "2020-12-04T00:11:42Z", "author": {"login": "agavra"}, "path": "ksqldb-execution/src/main/java/io/confluent/ksql/execution/plan/PlanInfo.java", "diffHunk": "@@ -0,0 +1,23 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.execution.plan;\n+\n+/**\n+ * Information about an execution step plan to be passed to a {@link PlanBuilder}\n+ * for use when converting an execution step plan into a physical plan.\n+ */\n+public interface PlanInfo {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDY2NzA3NA=="}, "originalCommit": {"oid": "6352cae20d39e92abbdb07e45d41044528f09682"}, "originalPosition": 22}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d9bf50372b3d9e69ca7f43e0ffae3dd25d42b471", "author": {"user": {"login": "vcrfxia", "name": "Victoria Xia"}}, "url": "https://github.com/confluentinc/ksql/commit/d9bf50372b3d9e69ca7f43e0ffae3dd25d42b471", "committedDate": "2020-12-04T01:16:02Z", "message": "chore: remove PlanInfo interface"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "bf170086e6b6f8e0317c54181869dd8eea897267", "author": {"user": {"login": "vcrfxia", "name": "Victoria Xia"}}, "url": "https://github.com/confluentinc/ksql/commit/bf170086e6b6f8e0317c54181869dd8eea897267", "committedDate": "2020-12-04T01:26:40Z", "message": "chore: rename PlanInfoExtractor"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "37ec0b8de4943e6a3816b0bf9611ae185a685c9f", "author": {"user": {"login": "vcrfxia", "name": "Victoria Xia"}}, "url": "https://github.com/confluentinc/ksql/commit/37ec0b8de4943e6a3816b0bf9611ae185a685c9f", "committedDate": "2020-12-04T01:37:38Z", "message": "chore: cleanup"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "476326f52f477619014f8bed5ea04ea2349009e2", "author": {"user": {"login": "vcrfxia", "name": "Victoria Xia"}}, "url": "https://github.com/confluentinc/ksql/commit/476326f52f477619014f8bed5ea04ea2349009e2", "committedDate": "2020-12-04T01:37:48Z", "message": "chore: remove ExecutionStepVisitor"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4568, "cost": 1, "resetAt": "2021-11-01T13:51:04Z"}}}