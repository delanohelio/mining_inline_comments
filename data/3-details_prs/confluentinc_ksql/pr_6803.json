{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTQyMzU1NDkz", "number": 6803, "title": "feat: support PARTITION BY on multiple expressions", "bodyText": "Description\nFixes #5754\nThis PR adds support for PARTITION BY with multiple expressions, resulting in multiple key columns. There are no backwards compatibility concerns as the ksqlDB syntax did not support this prior to this PR.\nDocs will come in a separate PR.\nTesting done\nQTT.\nReviewer checklist\n\n Ensure docs are updated if necessary. (eg. if a user visible feature is being added or changed).\n Ensure relevant issues are linked (description should include text like \"Fixes #\")", "createdAt": "2020-12-18T07:27:15Z", "url": "https://github.com/confluentinc/ksql/pull/6803", "merged": true, "mergeCommit": {"oid": "5a6b48efa63f0a0f007021c8cd73c71165b483fa"}, "closed": true, "closedAt": "2020-12-18T21:59:15Z", "author": {"login": "vcrfxia"}, "timelineItems": {"totalCount": 12, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdnNeD-gH2gAyNTQyMzU1NDkzOjA5ZGIzNDRlMGE3ODQwYzk1YjdlZjVmODVjZmIwYWQyM2U3NTViMzY=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdndg5wAH2gAyNTQyMzU1NDkzOjVlODE2NjIxNzQxYzY5NzI0MmI3NjAyNjI0ZTdjZDFkNTY5MjEwM2Y=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "09db344e0a7840c95b7ef5f85cfb0ad23e755b36", "author": {"user": {"login": "vcrfxia", "name": "Victoria Xia"}}, "url": "https://github.com/confluentinc/ksql/commit/09db344e0a7840c95b7ef5f85cfb0ad23e755b36", "committedDate": "2020-12-18T01:01:53Z", "message": "chore: syntax changes"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "27844a82ef43ea083000058e16c62ac7be3cd846", "author": {"user": {"login": "vcrfxia", "name": "Victoria Xia"}}, "url": "https://github.com/confluentinc/ksql/commit/27844a82ef43ea083000058e16c62ac7be3cd846", "committedDate": "2020-12-18T03:36:58Z", "message": "chore: null handling"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7af9b8e6d3f9450695124b7c61b68a2aae1c7adb", "author": {"user": {"login": "vcrfxia", "name": "Victoria Xia"}}, "url": "https://github.com/confluentinc/ksql/commit/7af9b8e6d3f9450695124b7c61b68a2aae1c7adb", "committedDate": "2020-12-18T07:22:37Z", "message": "chore: cleanup"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "aa4ce584257966cbce8b57f4cfe373f8f2d30a06", "author": {"user": {"login": "vcrfxia", "name": "Victoria Xia"}}, "url": "https://github.com/confluentinc/ksql/commit/aa4ce584257966cbce8b57f4cfe373f8f2d30a06", "committedDate": "2020-12-18T07:26:48Z", "message": "chore: historic plans"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "52533b65c56d1a8aad15e0cf83ad26dd14616251", "author": {"user": {"login": "vcrfxia", "name": "Victoria Xia"}}, "url": "https://github.com/confluentinc/ksql/commit/52533b65c56d1a8aad15e0cf83ad26dd14616251", "committedDate": "2020-12-18T08:20:08Z", "message": "test: fix test"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "73bc73ed761e4391bcd4a8452ed49e2e0f8a06c0", "author": {"user": {"login": "vcrfxia", "name": "Victoria Xia"}}, "url": "https://github.com/confluentinc/ksql/commit/73bc73ed761e4391bcd4a8452ed49e2e0f8a06c0", "committedDate": "2020-12-18T14:24:27Z", "message": "chore: switch List to ImmutableList"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b8030febe31fd17efd1d9b20e18ac3d604e27704", "author": {"user": {"login": "vcrfxia", "name": "Victoria Xia"}}, "url": "https://github.com/confluentinc/ksql/commit/b8030febe31fd17efd1d9b20e18ac3d604e27704", "committedDate": "2020-12-18T15:30:08Z", "message": "test: fix tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "bf93e158f221f42371c77ded6f0b07ba53d2de54", "author": {"user": {"login": "vcrfxia", "name": "Victoria Xia"}}, "url": "https://github.com/confluentinc/ksql/commit/bf93e158f221f42371c77ded6f0b07ba53d2de54", "committedDate": "2020-12-18T17:02:10Z", "message": "chore: fix required fields"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6d4302daba861a0f1ef8283c011272338a423cf7", "author": {"user": {"login": "vcrfxia", "name": "Victoria Xia"}}, "url": "https://github.com/confluentinc/ksql/commit/6d4302daba861a0f1ef8283c011272338a423cf7", "committedDate": "2020-12-18T18:36:05Z", "message": "test: remove obsolete test"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "043f12d5094715b64875a987e637bbff3ec52976", "author": {"user": {"login": "vcrfxia", "name": "Victoria Xia"}}, "url": "https://github.com/confluentinc/ksql/commit/043f12d5094715b64875a987e637bbff3ec52976", "committedDate": "2020-12-18T18:36:41Z", "message": "Merge branch 'master' into partition-by-multi"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTU1NzA4MzI5", "url": "https://github.com/confluentinc/ksql/pull/6803#pullrequestreview-555708329", "createdAt": "2020-12-18T18:15:12Z", "commit": {"oid": "09db344e0a7840c95b7ef5f85cfb0ad23e755b36"}, "state": "APPROVED", "comments": {"totalCount": 11, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xOFQxODoxNToxMlrOIItfSA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xOFQxODo1NDozNVrOIIu11w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjAwNDgwOA==", "bodyText": "i think this is OK", "url": "https://github.com/confluentinc/ksql/pull/6803#discussion_r546004808", "createdAt": "2020-12-18T18:15:12Z", "author": {"login": "agavra"}, "path": "ksqldb-engine/src/main/java/io/confluent/ksql/planner/LogicalPlanner.java", "diffHunk": "@@ -663,7 +665,7 @@ private LogicalSchema buildAggregateSchema(\n \n   private LogicalSchema buildRepartitionedSchema(\n       final PlanNode sourceNode,\n-      final Expression partitionBy\n+      final List<Expression> partitionBy // TODO: rename?", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "09db344e0a7840c95b7ef5f85cfb0ad23e755b36"}, "originalPosition": 47}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjAwNzE3Mg==", "bodyText": "nit: since we already import ImmutableList let's just use ImmutableList.of here", "url": "https://github.com/confluentinc/ksql/pull/6803#discussion_r546007172", "createdAt": "2020-12-18T18:18:16Z", "author": {"login": "agavra"}, "path": "ksqldb-engine/src/main/java/io/confluent/ksql/planner/LogicalPlanner.java", "diffHunk": "@@ -405,7 +407,7 @@ private PreJoinRepartitionNode buildInternalRepartitionNode(\n         ExpressionTreeRewriter.rewriteWith(plugin, joinExpression);\n \n     final LogicalSchema schema =\n-        buildRepartitionedSchema(source, rewrittenPartitionBy);\n+        buildRepartitionedSchema(source, Collections.singletonList(rewrittenPartitionBy));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "09db344e0a7840c95b7ef5f85cfb0ad23e755b36"}, "originalPosition": 38}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjAwNzQ4NQ==", "bodyText": "nit: same thing about ImmutableList", "url": "https://github.com/confluentinc/ksql/pull/6803#discussion_r546007485", "createdAt": "2020-12-18T18:18:38Z", "author": {"login": "agavra"}, "path": "ksqldb-engine/src/main/java/io/confluent/ksql/planner/plan/PreJoinRepartitionNode.java", "diffHunk": "@@ -111,7 +112,7 @@ public void setKeyFormat(final KeyFormat format) {\n     return getSource().buildStream(builder)\n         .selectKey(\n             valueFormat.getFormatInfo(),\n-            partitionBy,\n+            Collections.singletonList(partitionBy),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "09db344e0a7840c95b7ef5f85cfb0ad23e755b36"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjAwODc0MA==", "bodyText": "do we still need to make a copy of the original partition by now that it's a list?", "url": "https://github.com/confluentinc/ksql/pull/6803#discussion_r546008740", "createdAt": "2020-12-18T18:20:57Z", "author": {"login": "agavra"}, "path": "ksqldb-engine/src/main/java/io/confluent/ksql/planner/plan/UserRepartitionNode.java", "diffHunk": "@@ -103,9 +107,19 @@ public Expression resolveSelect(final int idx, final Expression expression) {\n \n   @Override\n   void validateKeyPresent(final SourceName sinkName, final Projection projection) {\n-    if (!(partitionBy instanceof NullLiteral) && !projection.containsExpression(partitionBy)) {\n-      final ImmutableList<Expression> keys = ImmutableList.of(originalPartitionBy);\n+    if (!PartitionByParamsFactory.isPartitionByNull(partitionBy)\n+        && !containsExpressions(projection, partitionBy)) {\n+      final ImmutableList<Expression> keys = ImmutableList.copyOf(originalPartitionBy);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "09db344e0a7840c95b7ef5f85cfb0ad23e755b36"}, "originalPosition": 69}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjAwODk3MQ==", "bodyText": "ditto: no need for the copy", "url": "https://github.com/confluentinc/ksql/pull/6803#discussion_r546008971", "createdAt": "2020-12-18T18:21:27Z", "author": {"login": "agavra"}, "path": "ksqldb-engine/src/main/java/io/confluent/ksql/structured/SchemaKStream.java", "diffHunk": "@@ -314,15 +314,15 @@ static Expression rewriteTimeComparisonForFilter(final Expression expression) {\n    */\n   public SchemaKStream<K> selectKey(\n       final FormatInfo valueFormat,\n-      final Expression keyExpression,\n+      final List<Expression> keyExpression,\n       final Optional<KeyFormat> forceInternalKeyFormat,\n       final Stacker contextStacker,\n       final boolean forceRepartition\n   ) {\n     final boolean keyFormatChange = forceInternalKeyFormat.isPresent()\n         && !forceInternalKeyFormat.get().equals(keyFormat);\n \n-    final boolean repartitionNeeded = repartitionNeeded(ImmutableList.of(keyExpression));\n+    final boolean repartitionNeeded = repartitionNeeded(ImmutableList.copyOf(keyExpression));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "09db344e0a7840c95b7ef5f85cfb0ad23e755b36"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjAxMTcxOA==", "bodyText": "might be interesting to do this with DELIMITED so that we can assert that the key order actually changes", "url": "https://github.com/confluentinc/ksql/pull/6803#discussion_r546011718", "createdAt": "2020-12-18T18:26:35Z", "author": {"login": "agavra"}, "path": "ksqldb-functional-tests/src/test/resources/query-validation-tests/partition-by.json", "diffHunk": "@@ -1025,6 +1025,140 @@\n         \"type\": \"io.confluent.ksql.util.KsqlStatementException\",\n         \"message\": \"Map keys, including types that contain maps, are not supported as they may lead to unexpected behavior due to inconsistent serialization. Key column name: `VAL`. Column type: STRUCT<`F1` MAP<STRING, INTEGER>>. See https://github.com/confluentinc/ksql/issues/6621 for more.\"\n       }\n+    },\n+    {\n+      \"name\": \"multiple columns - select star\",\n+      \"statements\": [\n+        \"CREATE STREAM INPUT (NAME STRING, ID INT, AGE INT) with (kafka_topic='input', format='JSON');\",\n+        \"CREATE STREAM OUTPUT AS select * from INPUT partition by ID, AGE;\"\n+      ],\n+      \"inputs\": [{\"topic\": \"input\", \"value\": {\"NAME\": \"bob\", \"ID\": 10, \"AGE\": 30}}],\n+      \"outputs\": [{\"topic\": \"OUTPUT\", \"key\": {\"ID\": 10, \"AGE\": 30}, \"value\": {\"NAME\": \"bob\"}}],\n+      \"post\": {\n+        \"sources\": [\n+          {\"name\": \"OUTPUT\", \"type\": \"stream\", \"schema\": \"ID INT KEY, AGE INT KEY, NAME STRING\"}\n+        ]\n+      }\n+    },\n+    {\n+      \"name\": \"multiple columns - select explicit\",\n+      \"statements\": [\n+        \"CREATE STREAM INPUT (NAME STRING, ID INT, AGE INT) with (kafka_topic='input', format='JSON');\",\n+        \"CREATE STREAM OUTPUT AS select ID, AGE, NAME from INPUT partition by ID, AGE;\"\n+      ],\n+      \"inputs\": [{\"topic\": \"input\", \"value\": {\"NAME\": \"bob\", \"ID\": 10, \"AGE\": 30}}],\n+      \"outputs\": [{\"topic\": \"OUTPUT\", \"key\": {\"ID\": 10, \"AGE\": 30}, \"value\": {\"NAME\": \"bob\"}}],\n+      \"post\": {\n+        \"sources\": [\n+          {\"name\": \"OUTPUT\", \"type\": \"stream\", \"schema\": \"ID INT KEY, AGE INT KEY, NAME STRING\"}\n+        ]\n+      }\n+    },\n+    {\n+      \"name\": \"multiple columns - some key some value\",\n+      \"statements\": [\n+        \"CREATE STREAM INPUT (NAME STRING KEY, ID INT, AGE INT) with (kafka_topic='input', format='JSON');\",\n+        \"CREATE STREAM OUTPUT AS select ID, AGE, NAME from INPUT partition by ID, NAME;\"\n+      ],\n+      \"inputs\": [{\"topic\": \"input\", \"key\": \"bob\", \"value\": {\"ID\": 10, \"AGE\": 30}}],\n+      \"outputs\": [{\"topic\": \"OUTPUT\", \"key\": {\"ID\": 10, \"NAME\": \"bob\"}, \"value\": {\"AGE\": 30}}],\n+      \"post\": {\n+        \"sources\": [\n+          {\"name\": \"OUTPUT\", \"type\": \"stream\", \"schema\": \"ID INT KEY, NAME STRING KEY, AGE INT\"}\n+        ]\n+      }\n+    },\n+    {\n+      \"name\": \"multiple key columns\",\n+      \"statements\": [\n+        \"CREATE STREAM INPUT (NAME STRING KEY, ID INT KEY, AGE INT) with (kafka_topic='input', format='JSON');\",", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "09db344e0a7840c95b7ef5f85cfb0ad23e755b36"}, "originalPosition": 50}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjAxMjEwOQ==", "bodyText": "can we name one of the expressions in the projection to make sure that the key name is properly propagated to the schema?", "url": "https://github.com/confluentinc/ksql/pull/6803#discussion_r546012109", "createdAt": "2020-12-18T18:27:18Z", "author": {"login": "agavra"}, "path": "ksqldb-functional-tests/src/test/resources/query-validation-tests/partition-by.json", "diffHunk": "@@ -1025,6 +1025,140 @@\n         \"type\": \"io.confluent.ksql.util.KsqlStatementException\",\n         \"message\": \"Map keys, including types that contain maps, are not supported as they may lead to unexpected behavior due to inconsistent serialization. Key column name: `VAL`. Column type: STRUCT<`F1` MAP<STRING, INTEGER>>. See https://github.com/confluentinc/ksql/issues/6621 for more.\"\n       }\n+    },\n+    {\n+      \"name\": \"multiple columns - select star\",\n+      \"statements\": [\n+        \"CREATE STREAM INPUT (NAME STRING, ID INT, AGE INT) with (kafka_topic='input', format='JSON');\",\n+        \"CREATE STREAM OUTPUT AS select * from INPUT partition by ID, AGE;\"\n+      ],\n+      \"inputs\": [{\"topic\": \"input\", \"value\": {\"NAME\": \"bob\", \"ID\": 10, \"AGE\": 30}}],\n+      \"outputs\": [{\"topic\": \"OUTPUT\", \"key\": {\"ID\": 10, \"AGE\": 30}, \"value\": {\"NAME\": \"bob\"}}],\n+      \"post\": {\n+        \"sources\": [\n+          {\"name\": \"OUTPUT\", \"type\": \"stream\", \"schema\": \"ID INT KEY, AGE INT KEY, NAME STRING\"}\n+        ]\n+      }\n+    },\n+    {\n+      \"name\": \"multiple columns - select explicit\",\n+      \"statements\": [\n+        \"CREATE STREAM INPUT (NAME STRING, ID INT, AGE INT) with (kafka_topic='input', format='JSON');\",\n+        \"CREATE STREAM OUTPUT AS select ID, AGE, NAME from INPUT partition by ID, AGE;\"\n+      ],\n+      \"inputs\": [{\"topic\": \"input\", \"value\": {\"NAME\": \"bob\", \"ID\": 10, \"AGE\": 30}}],\n+      \"outputs\": [{\"topic\": \"OUTPUT\", \"key\": {\"ID\": 10, \"AGE\": 30}, \"value\": {\"NAME\": \"bob\"}}],\n+      \"post\": {\n+        \"sources\": [\n+          {\"name\": \"OUTPUT\", \"type\": \"stream\", \"schema\": \"ID INT KEY, AGE INT KEY, NAME STRING\"}\n+        ]\n+      }\n+    },\n+    {\n+      \"name\": \"multiple columns - some key some value\",\n+      \"statements\": [\n+        \"CREATE STREAM INPUT (NAME STRING KEY, ID INT, AGE INT) with (kafka_topic='input', format='JSON');\",\n+        \"CREATE STREAM OUTPUT AS select ID, AGE, NAME from INPUT partition by ID, NAME;\"\n+      ],\n+      \"inputs\": [{\"topic\": \"input\", \"key\": \"bob\", \"value\": {\"ID\": 10, \"AGE\": 30}}],\n+      \"outputs\": [{\"topic\": \"OUTPUT\", \"key\": {\"ID\": 10, \"NAME\": \"bob\"}, \"value\": {\"AGE\": 30}}],\n+      \"post\": {\n+        \"sources\": [\n+          {\"name\": \"OUTPUT\", \"type\": \"stream\", \"schema\": \"ID INT KEY, NAME STRING KEY, AGE INT\"}\n+        ]\n+      }\n+    },\n+    {\n+      \"name\": \"multiple key columns\",\n+      \"statements\": [\n+        \"CREATE STREAM INPUT (NAME STRING KEY, ID INT KEY, AGE INT) with (kafka_topic='input', format='JSON');\",\n+        \"CREATE STREAM OUTPUT AS select ID, AGE, NAME from INPUT partition by ID, NAME;\"\n+      ],\n+      \"inputs\": [{\"topic\": \"input\", \"key\": {\"NAME\": \"bob\", \"ID\": 10}, \"value\": {\"AGE\": 30}}],\n+      \"outputs\": [{\"topic\": \"OUTPUT\", \"key\": {\"ID\": 10, \"NAME\": \"bob\"}, \"value\": {\"AGE\": 30}}],\n+      \"post\": {\n+        \"sources\": [\n+          {\"name\": \"OUTPUT\", \"type\": \"stream\", \"schema\": \"ID INT KEY, NAME STRING KEY, AGE INT\"}\n+        ]\n+      }\n+    },\n+    {\n+      \"name\": \"multiple columns with expressions\",", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "09db344e0a7840c95b7ef5f85cfb0ad23e755b36"}, "originalPosition": 62}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjAxNDY3Nw==", "bodyText": "what's wrong with a duplicate partition by expression? I don't see any reason why a user might want it, but I don't see why not either (e.g. maybe their output data expects userId, userSpecialId in the key and this stream always has the same value for both)\nI get that the key name conflicts might be a little weird, so we can do this in a follow-up PR, but I don't think we should prohibit it", "url": "https://github.com/confluentinc/ksql/pull/6803#discussion_r546014677", "createdAt": "2020-12-18T18:32:22Z", "author": {"login": "agavra"}, "path": "ksqldb-parser/src/main/java/io/confluent/ksql/parser/tree/PartitionBy.java", "diffHunk": "@@ -17,27 +17,43 @@\n \n import static java.util.Objects.requireNonNull;\n \n+import com.google.common.collect.ImmutableList;\n import com.google.errorprone.annotations.Immutable;\n import io.confluent.ksql.execution.expression.tree.Expression;\n import io.confluent.ksql.parser.NodeLocation;\n+import io.confluent.ksql.util.KsqlException;\n+import java.util.HashSet;\n+import java.util.List;\n import java.util.Objects;\n import java.util.Optional;\n \n @Immutable\n public class PartitionBy extends AstNode {\n \n-  private final Expression expression;\n+  private final List<Expression> partitionByExpressions;\n \n   public PartitionBy(\n       final Optional<NodeLocation> location,\n-      final Expression partitionBy\n+      final List<Expression> partitionByExpressions\n   ) {\n     super(location);\n-    this.expression = requireNonNull(partitionBy, \"partitionBy\");\n+    this.partitionByExpressions = ImmutableList\n+        .copyOf(requireNonNull(partitionByExpressions, \"partitionByExpressions\"));\n+\n+    if (partitionByExpressions.isEmpty()) {\n+      throw new KsqlException(\"PARTITION BY requires at least one expression\");\n+    }\n+\n+    final HashSet<Object> partitionBys = new HashSet<>(partitionByExpressions.size());\n+    partitionByExpressions.forEach(exp -> {\n+      if (!partitionBys.add(exp)) {\n+        throw new KsqlException(\"Duplicate PARTITION BY expression: \" + exp);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "09db344e0a7840c95b7ef5f85cfb0ad23e755b36"}, "originalPosition": 37}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjAxNTI3Nw==", "bodyText": "not your code, but can we rename this partitionBy?", "url": "https://github.com/confluentinc/ksql/pull/6803#discussion_r546015277", "createdAt": "2020-12-18T18:33:35Z", "author": {"login": "agavra"}, "path": "ksqldb-parser/src/main/java/io/confluent/ksql/parser/tree/PartitionBy.java", "diffHunk": "@@ -54,18 +70,18 @@ public boolean equals(final Object o) {\n       return false;\n     }\n     final PartitionBy groupBy = (PartitionBy) o;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "09db344e0a7840c95b7ef5f85cfb0ad23e755b36"}, "originalPosition": 52}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjAyNDc0MA==", "bodyText": "instead of relying on the implicit ordering of the partition by, it might make sense to lookup the partitionByCol.name in the resultSchema at the cost of a bit of performance. thoughts?", "url": "https://github.com/confluentinc/ksql/pull/6803#discussion_r546024740", "createdAt": "2020-12-18T18:51:45Z", "author": {"login": "agavra"}, "path": "ksqldb-streams/src/main/java/io/confluent/ksql/execution/streams/PartitionByParamsFactory.java", "diffHunk": "@@ -76,118 +79,168 @@ private PartitionByParamsFactory() {\n   public static <K> PartitionByParams<K> build(\n       final LogicalSchema sourceSchema,\n       final ExecutionKeyFactory<K> serdeFactory,\n-      final Expression partitionBy,\n+      final List<Expression> partitionBy, // TODO: rename?\n       final KsqlConfig ksqlConfig,\n       final FunctionRegistry functionRegistry,\n       final ProcessingLogger logger\n   ) {\n-    final Optional<ColumnName> partitionByCol = getPartitionByColumnName(sourceSchema, partitionBy);\n+    final List<PartitionByColumn> partitionByCols =\n+        getPartitionByColumnName(sourceSchema, partitionBy);\n \n     final LogicalSchema resultSchema =\n-        buildSchema(sourceSchema, partitionBy, functionRegistry, partitionByCol);\n+        buildSchema(sourceSchema, partitionBy, functionRegistry, partitionByCols);\n \n     final Mapper<K> mapper;\n-    if (partitionBy instanceof NullLiteral) {\n+    if (isPartitionByNull(partitionBy)) {\n       // In case of PARTITION BY NULL, it is sufficient to set the new key to null as the old key\n       // is already present in the current value\n       mapper = (k, v) -> new KeyValue<>(null, v);\n     } else {\n-      final Set<? extends ColumnReferenceExp> partitionByCols =\n-          ColumnExtractor.extractColumns(partitionBy);\n-      final boolean partitionByInvolvesKeyColsOnly = partitionByCols.stream()\n+      final Set<? extends ColumnReferenceExp> sourceColsInPartitionBy = partitionBy.stream()\n+          .flatMap(pby -> ColumnExtractor.extractColumns(pby).stream())\n+          .collect(Collectors.toSet());\n+      final boolean partitionByInvolvesKeyColsOnly = sourceColsInPartitionBy.stream()\n           .map(ColumnReferenceExp::getColumnName)\n           .allMatch(sourceSchema::isKeyColumn);\n \n-      final PartitionByExpressionEvaluator evaluator = buildExpressionEvaluator(\n-          sourceSchema,\n-          partitionBy,\n-          ksqlConfig,\n-          functionRegistry,\n-          logger,\n-          partitionByInvolvesKeyColsOnly\n-      );\n-      mapper = buildMapper(resultSchema, partitionByCol, evaluator, serdeFactory);\n+      // TODO: what should be the behavior if some partition by expressions involve value columns but others don't, and a tombstone is received? should we drop the entire record? that's what's currently happening in this implementation. I think -- check\n+      final List<PartitionByExpressionEvaluator> evaluators = partitionBy.stream()\n+          .map(pby -> buildExpressionEvaluator(\n+              sourceSchema,\n+              pby,\n+              ksqlConfig,\n+              functionRegistry,\n+              logger,\n+              partitionByInvolvesKeyColsOnly\n+          )).collect(Collectors.toList());\n+      mapper = buildMapper(resultSchema, partitionByCols, evaluators, serdeFactory);\n     }\n \n-    return new PartitionByParams<K>(resultSchema, mapper);\n+    return new PartitionByParams<K>(resultSchema, mapper); // TODO: remove K\n   }\n \n   public static LogicalSchema buildSchema(\n       final LogicalSchema sourceSchema,\n-      final Expression partitionBy,\n+      final List<Expression> partitionBy, // TODO: rename?\n       final FunctionRegistry functionRegistry\n   ) {\n-    final Optional<ColumnName> partitionByCol =\n+    final List<PartitionByColumn> partitionByCols =\n         getPartitionByColumnName(sourceSchema, partitionBy);\n \n-    return buildSchema(sourceSchema, partitionBy, functionRegistry, partitionByCol);\n+    return buildSchema(sourceSchema, partitionBy, functionRegistry, partitionByCols);\n+  }\n+\n+  // TODO: move\n+  public static boolean isPartitionByNull(final List<Expression> partitionBys) {\n+    final boolean nullExpressionPresent = partitionBys.stream()\n+        .anyMatch(pb -> pb instanceof NullLiteral);\n+\n+    if (!nullExpressionPresent) {\n+      return false;\n+    }\n+\n+    if (partitionBys.size() > 1) {\n+      throw new KsqlException(\"Cannot PARTITION BY multiple columns including NULL\");\n+    }\n+\n+    return true;\n   }\n \n   private static LogicalSchema buildSchema(\n       final LogicalSchema sourceSchema,\n-      final Expression partitionBy,\n+      final List<Expression> partitionBy, // TODO: rename?\n       final FunctionRegistry functionRegistry,\n-      final Optional<ColumnName> partitionByCol\n+      final List<PartitionByColumn> partitionByCols\n   ) {\n     final ExpressionTypeManager expressionTypeManager =\n         new ExpressionTypeManager(sourceSchema, functionRegistry);\n \n-    final SqlType keyType = expressionTypeManager\n-        .getExpressionSqlType(partitionBy);\n+    final List<SqlType> keyTypes = partitionBy.stream()\n+        .map(expressionTypeManager::getExpressionSqlType)\n+        .collect(Collectors.toList());\n \n-    final ColumnName newKeyName = partitionByCol\n-        .orElseGet(() -> ColumnNames.uniqueAliasFor(partitionBy, sourceSchema));\n+    if (isPartitionByNull(partitionBy)) {\n+      final Builder builder = LogicalSchema.builder();\n+      builder.valueColumns(sourceSchema.value());\n+      return builder.build();\n+    } else {\n+      final Builder builder = LogicalSchema.builder();\n+      for (int i = 0; i < partitionBy.size(); i++) {\n+        builder.keyColumn(partitionByCols.get(i).name, keyTypes.get(i));\n+      }\n \n-    final Builder builder = LogicalSchema.builder();\n-    if (keyType != null) {\n-      builder.keyColumn(newKeyName, keyType);\n-    }\n-    builder.valueColumns(sourceSchema.value());\n+      builder.valueColumns(sourceSchema.value());\n+      for (int i = 0; i < partitionBy.size(); i++) {\n+        if (partitionByCols.get(i).shouldAppend) {\n+          // New key column added, copy in to value schema:\n+          builder.valueColumn(partitionByCols.get(i).name, keyTypes.get(i));\n+        }\n+      }\n \n-    if (keyType != null && !partitionByCol.isPresent()) {\n-      // New key column added, copy in to value schema:\n-      builder.valueColumn(newKeyName, keyType);\n+      return builder.build();\n     }\n-\n-    return builder.build();\n   }\n \n-  private static Optional<ColumnName> getPartitionByColumnName(\n-      final LogicalSchema sourceSchema,\n-      final Expression partitionBy\n-  ) {\n-    if (partitionBy instanceof ColumnReferenceExp) {\n-      // PARTITION BY column:\n-      final ColumnName columnName = ((ColumnReferenceExp) partitionBy).getColumnName();\n-\n-      final Column column = sourceSchema\n-          .findValueColumn(columnName)\n-          .orElseThrow(() ->\n-              new IllegalStateException(\"Unknown partition by column: \" + columnName));\n+  // TODO: move, add accessors?\n+  private static class PartitionByColumn {\n+    final ColumnName name;\n+    final boolean shouldAppend;\n \n-      return Optional.of(column.name());\n+    PartitionByColumn(final ColumnName name, final boolean shouldAppend) {\n+      this.name = Objects.requireNonNull(name, \"name\");\n+      this.shouldAppend = shouldAppend;\n     }\n+  }\n \n-    return Optional.empty();\n+  private static List<PartitionByColumn> getPartitionByColumnName(\n+      final LogicalSchema sourceSchema,\n+      final List<Expression> partitionByExpressions\n+  ) {\n+    final ColumnAliasGenerator columnAliasGenerator =\n+        ColumnNames.columnAliasGenerator(Stream.of(sourceSchema));\n+    return partitionByExpressions.stream()\n+        .map(partitionBy -> {\n+          if (partitionBy instanceof ColumnReferenceExp) {\n+            // PARTITION BY column:\n+            final ColumnName columnName = ((ColumnReferenceExp) partitionBy).getColumnName();\n+\n+            final Column column = sourceSchema\n+                .findValueColumn(columnName)\n+                .orElseThrow(() ->\n+                    new IllegalStateException(\"Unknown partition by column: \" + columnName));\n+\n+            return new PartitionByColumn(column.name(), false);\n+          } else {\n+            return new PartitionByColumn(columnAliasGenerator.uniqueAliasFor(partitionBy), true);\n+          }\n+        })\n+        .collect(Collectors.toList());\n   }\n \n   private static <K> Mapper<K> buildMapper(\n-      final LogicalSchema resultSchema,\n-      final Optional<ColumnName> partitionByCol,\n-      final PartitionByExpressionEvaluator evaluator,\n+      final LogicalSchema resultSchema, // TODO: remove dead param (and simplify build())\n+      final List<PartitionByColumn> partitionByCol,\n+      final List<PartitionByExpressionEvaluator> evaluators,\n       final ExecutionKeyFactory<K> executionKeyFactory\n   ) {\n-    // If partitioning by something other than an existing column, then a new key will have\n-    // been synthesized. This new key must be appended to the value to make it available for\n-    // stream processing, in the same way SourceBuilder appends the key and rowtime to the value:\n-    final boolean appendNewKey = !partitionByCol.isPresent();\n-\n     return (oldK, row) -> {\n-      final Object newKey = evaluator.evaluate(oldK, row);\n-      final K key = executionKeyFactory.constructNewKey(oldK, genericKey(newKey));\n-\n-      if (row != null && appendNewKey) {\n-        row.append(newKey);\n+      final List<Object> newKeyComponents = evaluators.stream()\n+          .map(evaluator -> evaluator.evaluate(oldK, row))\n+          .collect(Collectors.toList());\n+\n+      final K key =\n+          executionKeyFactory.constructNewKey(oldK, GenericKey.fromList(newKeyComponents));\n+\n+      if (row != null) {\n+        for (int i = 0; i < partitionByCol.size(); i++) {\n+          if (partitionByCol.get(i).shouldAppend) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "09db344e0a7840c95b7ef5f85cfb0ad23e755b36"}, "originalPosition": 252}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjAyNjk2Nw==", "bodyText": "or... we can finally swap over to using PAPI :)", "url": "https://github.com/confluentinc/ksql/pull/6803#discussion_r546026967", "createdAt": "2020-12-18T18:54:35Z", "author": {"login": "agavra"}, "path": "ksqldb-functional-tests/src/test/resources/query-validation-tests/partition-by.json", "diffHunk": "@@ -1098,12 +1150,27 @@\n     },\n     {\n       \"name\": \"multiple columns including ROWTIME\",\n+      \"comments\": [\n+        \"Ideally the third row of output would contain ROWTIME populated as 12 in the output key.\",\n+        \"This doesn't happen today because ROWTIME is evaluated from the value, which is null in this\",\n+        \"example. To fix this, we'd have to add special handling to detect when a key expression\",\n+        \"depends only on ROWTIME, similar to how today we have special handling to detect when a key\",\n+        \"expression depends only on key columns.\"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "27844a82ef43ea083000058e16c62ac7be3cd846"}, "originalPosition": 116}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5e816621741c697242b7602624e7cd1d5692103f", "author": {"user": {"login": "vcrfxia", "name": "Victoria Xia"}}, "url": "https://github.com/confluentinc/ksql/commit/5e816621741c697242b7602624e7cd1d5692103f", "committedDate": "2020-12-18T19:43:28Z", "message": "chore: feedback"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4533, "cost": 1, "resetAt": "2021-11-01T13:51:04Z"}}}