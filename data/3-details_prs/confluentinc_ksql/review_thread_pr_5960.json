{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDY0MjA5Mjgx", "number": 5960, "reviewThreads": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNlQxOTo1NTozOFrOEV-MtA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNlQxOTo1ODowN1rOEV-PpA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkxNDc0NjEyOnYy", "diffSide": "RIGHT", "path": "ksqldb-engine/src/main/java/io/confluent/ksql/function/FunctionMetrics.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNlQxOTo1NTozOFrOG9CKIg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wN1QxNToyMDo0NFrOG9d98g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjY1MTY4Mg==", "bodyText": "there's a race here that is possible here where two calls for the same metrics.getSensor(sensorName) don't find the sensor and they both end up registering the extra metrics. I don't know of a good way around it...", "url": "https://github.com/confluentinc/ksql/pull/5960#discussion_r466651682", "createdAt": "2020-08-06T19:55:38Z", "author": {"login": "agavra"}, "path": "ksqldb-engine/src/main/java/io/confluent/ksql/function/FunctionMetrics.java", "diffHunk": "@@ -0,0 +1,108 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.function;\n+\n+import java.util.Optional;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.BiFunction;\n+import org.apache.kafka.common.MetricName;\n+import org.apache.kafka.common.metrics.Metrics;\n+import org.apache.kafka.common.metrics.Sensor;\n+import org.apache.kafka.common.metrics.stats.Avg;\n+import org.apache.kafka.common.metrics.stats.Max;\n+import org.apache.kafka.common.metrics.stats.Rate;\n+import org.apache.kafka.common.metrics.stats.WindowedCount;\n+\n+public final class FunctionMetrics {\n+\n+  static final String AVG_DESC = \"Average time for invocations of the %s\";\n+  static final String MAX_DESC = \"Max time for invocations of the %s\";\n+  static final String COUNT_DESC = \"Total number of invocations of the %s\";\n+  static final String RATE_DESC = \"The rate of invocations (invocations per second) of the %s\";\n+\n+  private FunctionMetrics() {\n+  }\n+\n+  /**\n+   * Gets an existing invocation sensor, or creates one if needed.\n+   *\n+   * <p>Sensor created with avg, max, count and rate metrics.\n+   *\n+   * @param metrics the metrics service.\n+   * @param sensorName the name of the sensor\n+   * @param groupName the name of the group\n+   * @param functionDescription the description of the function.\n+   */\n+  public static void initInvocationSensor(\n+      final Optional<Metrics> metrics,\n+      final String sensorName,\n+      final String groupName,\n+      final String functionDescription\n+  ) {\n+    metrics.ifPresent(m -> getInvocationSensor(m, sensorName, groupName, functionDescription));\n+  }\n+\n+  /**\n+   * Gets an existing invocation sensor, or creates one if needed.\n+   *\n+   * <p>Sensor created with avg, max, count and rate metrics.\n+   *\n+   * @param metrics the metrics service.\n+   * @param sensorName the name of the sensor\n+   * @param groupName the name of the group\n+   * @param functionDescription the description of the function.\n+   */\n+  public static Sensor getInvocationSensor(\n+      final Metrics metrics,\n+      final String sensorName,\n+      final String groupName,\n+      final String functionDescription\n+  ) {\n+    final Sensor existing = metrics.getSensor(sensorName);\n+    if (existing != null) {\n+      return existing;\n+    }\n+\n+    final Sensor newSensor = metrics.sensor(sensorName);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c2081bfe6dbd3ea38258833e0ae71bf6ee664e60"}, "originalPosition": 79}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzEwNzMxNA==", "bodyText": "Yeah I know, but I was just fixing the NPE and being lazy ;). Fixed it.", "url": "https://github.com/confluentinc/ksql/pull/5960#discussion_r467107314", "createdAt": "2020-08-07T15:20:44Z", "author": {"login": "big-andy-coates"}, "path": "ksqldb-engine/src/main/java/io/confluent/ksql/function/FunctionMetrics.java", "diffHunk": "@@ -0,0 +1,108 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.function;\n+\n+import java.util.Optional;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.BiFunction;\n+import org.apache.kafka.common.MetricName;\n+import org.apache.kafka.common.metrics.Metrics;\n+import org.apache.kafka.common.metrics.Sensor;\n+import org.apache.kafka.common.metrics.stats.Avg;\n+import org.apache.kafka.common.metrics.stats.Max;\n+import org.apache.kafka.common.metrics.stats.Rate;\n+import org.apache.kafka.common.metrics.stats.WindowedCount;\n+\n+public final class FunctionMetrics {\n+\n+  static final String AVG_DESC = \"Average time for invocations of the %s\";\n+  static final String MAX_DESC = \"Max time for invocations of the %s\";\n+  static final String COUNT_DESC = \"Total number of invocations of the %s\";\n+  static final String RATE_DESC = \"The rate of invocations (invocations per second) of the %s\";\n+\n+  private FunctionMetrics() {\n+  }\n+\n+  /**\n+   * Gets an existing invocation sensor, or creates one if needed.\n+   *\n+   * <p>Sensor created with avg, max, count and rate metrics.\n+   *\n+   * @param metrics the metrics service.\n+   * @param sensorName the name of the sensor\n+   * @param groupName the name of the group\n+   * @param functionDescription the description of the function.\n+   */\n+  public static void initInvocationSensor(\n+      final Optional<Metrics> metrics,\n+      final String sensorName,\n+      final String groupName,\n+      final String functionDescription\n+  ) {\n+    metrics.ifPresent(m -> getInvocationSensor(m, sensorName, groupName, functionDescription));\n+  }\n+\n+  /**\n+   * Gets an existing invocation sensor, or creates one if needed.\n+   *\n+   * <p>Sensor created with avg, max, count and rate metrics.\n+   *\n+   * @param metrics the metrics service.\n+   * @param sensorName the name of the sensor\n+   * @param groupName the name of the group\n+   * @param functionDescription the description of the function.\n+   */\n+  public static Sensor getInvocationSensor(\n+      final Metrics metrics,\n+      final String sensorName,\n+      final String groupName,\n+      final String functionDescription\n+  ) {\n+    final Sensor existing = metrics.getSensor(sensorName);\n+    if (existing != null) {\n+      return existing;\n+    }\n+\n+    final Sensor newSensor = metrics.sensor(sensorName);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjY1MTY4Mg=="}, "originalCommit": {"oid": "c2081bfe6dbd3ea38258833e0ae71bf6ee664e60"}, "originalPosition": 79}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkxNDc1MzY0OnYy", "diffSide": "RIGHT", "path": "ksqldb-engine/src/main/java/io/confluent/ksql/function/UdtfLoader.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNlQxOTo1ODowN1rOG9COwg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wN1QxNToxMDowNlrOG9dl_Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjY1Mjg2Ng==", "bodyText": "if anyone was relying on the old metrics, their alerts for udtfs will break with this change. probably ok as I'd be shocked if anyone was actually writing their own UDTFs and using metrics on them at this point but something to call out \ud83d\ude09", "url": "https://github.com/confluentinc/ksql/pull/5960#discussion_r466652866", "createdAt": "2020-08-06T19:58:07Z", "author": {"login": "agavra"}, "path": "ksqldb-engine/src/main/java/io/confluent/ksql/function/UdtfLoader.java", "diffHunk": "@@ -67,7 +68,8 @@ public void loadUdtfFromClass(\n     }\n     final String functionName = udtfDescriptionAnnotation.name();\n     final String sensorName = \"ksql-udtf-\" + functionName;\n-    FunctionLoaderUtils.addSensor(sensorName, functionName, metrics);\n+\n+    FunctionMetrics.initInvocationSensor(metrics, sensorName, \"ksql-udtf\", functionName + \" udtf\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c2081bfe6dbd3ea38258833e0ae71bf6ee664e60"}, "originalPosition": 27}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzEwMDk5NQ==", "bodyText": "Yeah, I'm aware, but ... meh.  turning metrics on caused an NPE, so likely no one is using them, and better to change it now.", "url": "https://github.com/confluentinc/ksql/pull/5960#discussion_r467100995", "createdAt": "2020-08-07T15:09:47Z", "author": {"login": "big-andy-coates"}, "path": "ksqldb-engine/src/main/java/io/confluent/ksql/function/UdtfLoader.java", "diffHunk": "@@ -67,7 +68,8 @@ public void loadUdtfFromClass(\n     }\n     final String functionName = udtfDescriptionAnnotation.name();\n     final String sensorName = \"ksql-udtf-\" + functionName;\n-    FunctionLoaderUtils.addSensor(sensorName, functionName, metrics);\n+\n+    FunctionMetrics.initInvocationSensor(metrics, sensorName, \"ksql-udtf\", functionName + \" udtf\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjY1Mjg2Ng=="}, "originalCommit": {"oid": "c2081bfe6dbd3ea38258833e0ae71bf6ee664e60"}, "originalPosition": 27}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzEwMTE4MQ==", "bodyText": "As mentioned in the description, I see this as a bug fix.", "url": "https://github.com/confluentinc/ksql/pull/5960#discussion_r467101181", "createdAt": "2020-08-07T15:10:06Z", "author": {"login": "big-andy-coates"}, "path": "ksqldb-engine/src/main/java/io/confluent/ksql/function/UdtfLoader.java", "diffHunk": "@@ -67,7 +68,8 @@ public void loadUdtfFromClass(\n     }\n     final String functionName = udtfDescriptionAnnotation.name();\n     final String sensorName = \"ksql-udtf-\" + functionName;\n-    FunctionLoaderUtils.addSensor(sensorName, functionName, metrics);\n+\n+    FunctionMetrics.initInvocationSensor(metrics, sensorName, \"ksql-udtf\", functionName + \" udtf\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjY1Mjg2Ng=="}, "originalCommit": {"oid": "c2081bfe6dbd3ea38258833e0ae71bf6ee664e60"}, "originalPosition": 27}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3044, "cost": 1, "resetAt": "2021-11-12T19:05:54Z"}}}