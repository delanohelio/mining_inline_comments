{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzYzODUyMTYx", "number": 4335, "reviewThreads": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yMVQyMjoyNjoyMlrODZqC7w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yMVQyMjoyNjoyMlrODZqC7w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI4MjI5ODcxOnYy", "diffSide": "RIGHT", "path": "ksql-parser/src/main/java/io/confluent/ksql/schema/ksql/DefaultSqlValueCoercer.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yMVQyMjoyNjoyMlrOFgK3qQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yMlQxODowMToxMlrOFglovA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTI3Njg0MQ==", "bodyText": "nit: the error contract for this method seems a bit weird now. If the value cannot be coerced return empty, but if the value can't be coerced due to being a decimal that doesn't fit we return an error. Consider changing this to just throw if coercing fails.", "url": "https://github.com/confluentinc/ksql/pull/4335#discussion_r369276841", "createdAt": "2020-01-21T22:26:22Z", "author": {"login": "rodesai"}, "path": "ksql-parser/src/main/java/io/confluent/ksql/schema/ksql/DefaultSqlValueCoercer.java", "diffHunk": "@@ -23,28 +23,28 @@\n import io.confluent.ksql.schema.ksql.types.SqlStruct;\n import io.confluent.ksql.schema.ksql.types.SqlType;\n import io.confluent.ksql.schema.ksql.types.SqlTypes;\n-import io.confluent.ksql.util.KsqlException;\n+import io.confluent.ksql.util.DecimalUtil;\n import java.math.BigDecimal;\n-import java.math.MathContext;\n-import java.math.RoundingMode;\n import java.util.HashMap;\n import java.util.List;\n import java.util.Map;\n import java.util.Optional;\n-import java.util.function.Function;\n+import java.util.function.BiFunction;\n import org.apache.kafka.connect.data.Field;\n import org.apache.kafka.connect.data.Struct;\n \n public enum DefaultSqlValueCoercer implements SqlValueCoercer {\n \n   INSTANCE;\n \n-  private static final Map<SqlBaseType, Function<Number, Number>> UPCASTER =\n-      ImmutableMap.<SqlBaseType, Function<Number, Number>>builder()\n-          .put(SqlBaseType.INTEGER, Number::intValue)\n-          .put(SqlBaseType.BIGINT, Number::longValue)\n-          .put(SqlBaseType.DOUBLE, Number::doubleValue)\n-          .build();\n+  private static final Map<SqlBaseType, BiFunction<Number, SqlType, Number>> UPCASTER =\n+      ImmutableMap.<SqlBaseType, BiFunction<Number, SqlType, Number>>builder()\n+          .put(SqlBaseType.INTEGER, (num, type) -> num.intValue())\n+          .put(SqlBaseType.BIGINT, (num, type) -> num.longValue())\n+          .put(SqlBaseType.DOUBLE, (num, type) -> num.doubleValue())\n+          .put(SqlBaseType.DECIMAL, (num, type) ->\n+              DecimalUtil.ensureFit(new BigDecimal(String.format(\"%s\", num)), (SqlDecimal) type)\n+          ).build();\n \n   @Override\n   public Optional<?> coerce(final Object value, final SqlType targetType) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c38e4249c167fe360de11c3e3391ec901942825f"}, "originalPosition": 38}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTcxNTM4OA==", "bodyText": "I will return empty - callers of this class map the optionals to specific, actionable errors. Good catch!", "url": "https://github.com/confluentinc/ksql/pull/4335#discussion_r369715388", "createdAt": "2020-01-22T18:01:12Z", "author": {"login": "agavra"}, "path": "ksql-parser/src/main/java/io/confluent/ksql/schema/ksql/DefaultSqlValueCoercer.java", "diffHunk": "@@ -23,28 +23,28 @@\n import io.confluent.ksql.schema.ksql.types.SqlStruct;\n import io.confluent.ksql.schema.ksql.types.SqlType;\n import io.confluent.ksql.schema.ksql.types.SqlTypes;\n-import io.confluent.ksql.util.KsqlException;\n+import io.confluent.ksql.util.DecimalUtil;\n import java.math.BigDecimal;\n-import java.math.MathContext;\n-import java.math.RoundingMode;\n import java.util.HashMap;\n import java.util.List;\n import java.util.Map;\n import java.util.Optional;\n-import java.util.function.Function;\n+import java.util.function.BiFunction;\n import org.apache.kafka.connect.data.Field;\n import org.apache.kafka.connect.data.Struct;\n \n public enum DefaultSqlValueCoercer implements SqlValueCoercer {\n \n   INSTANCE;\n \n-  private static final Map<SqlBaseType, Function<Number, Number>> UPCASTER =\n-      ImmutableMap.<SqlBaseType, Function<Number, Number>>builder()\n-          .put(SqlBaseType.INTEGER, Number::intValue)\n-          .put(SqlBaseType.BIGINT, Number::longValue)\n-          .put(SqlBaseType.DOUBLE, Number::doubleValue)\n-          .build();\n+  private static final Map<SqlBaseType, BiFunction<Number, SqlType, Number>> UPCASTER =\n+      ImmutableMap.<SqlBaseType, BiFunction<Number, SqlType, Number>>builder()\n+          .put(SqlBaseType.INTEGER, (num, type) -> num.intValue())\n+          .put(SqlBaseType.BIGINT, (num, type) -> num.longValue())\n+          .put(SqlBaseType.DOUBLE, (num, type) -> num.doubleValue())\n+          .put(SqlBaseType.DECIMAL, (num, type) ->\n+              DecimalUtil.ensureFit(new BigDecimal(String.format(\"%s\", num)), (SqlDecimal) type)\n+          ).build();\n \n   @Override\n   public Optional<?> coerce(final Object value, final SqlType targetType) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTI3Njg0MQ=="}, "originalCommit": {"oid": "c38e4249c167fe360de11c3e3391ec901942825f"}, "originalPosition": 38}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2243, "cost": 1, "resetAt": "2021-11-12T19:05:54Z"}}}