{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTEyNjU2MTE0", "number": 6548, "title": "fix: Bypass window store cache when doing windowed pull queries", "bodyText": "Description\nWindowed pull queries have very mediocre performance.  After lots of investigation, it was clear that this was due to the use of the streams cache.  We experimented with disabling the cache, and performance is good for pull queries.  The issue is that if we did this, then other areas such as persistent queries suffer in their performance.\nThis PR aims to disable the use of the streams cache for only windowed pull queries. There was a lot of discussion over whether a public API should be exposed in Streams to bypass the cache during a state store lookup.  At the moment they don't want to do this with the existing API. Next public API will expose bypassing the cache.\nIn order to give ksqlDB good performance for all pull query types, it was decided to use some reflection to bypass the lack of proper public APIs and skip the caching layers.\nTesting done\nRan local unit tests.  Ran RestQueryTranslationTests.  Ran pull query benchmarks for windowed queries.\nReviewer checklist\n\n Ensure docs are updated if necessary. (eg. if a user visible feature is being added or changed).\n Ensure relevant issues are linked (description should include text like \"Fixes #\")", "createdAt": "2020-10-29T23:58:39Z", "url": "https://github.com/confluentinc/ksql/pull/6548", "merged": true, "mergeCommit": {"oid": "8f84e417654fa1ee19ee2407587452405c447c21"}, "closed": true, "closedAt": "2020-11-02T23:58:06Z", "author": {"login": "AlanConfluent"}, "timelineItems": {"totalCount": 12, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdWxldbAH2gAyNTEyNjU2MTE0OjdlZmQ0NTQ0MWNlOGVkYWY1ZmEwYTI0ZmRiOTA1YTZlMDYwMjI3YmM=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdYbbeiAFqTUyMTMwMzk4NA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "7efd45441ce8edaf5fa0a24fdb905a6e060227bc", "author": {"user": {"login": "AlanConfluent", "name": "Alan Sheinberg"}}, "url": "https://github.com/confluentinc/ksql/commit/7efd45441ce8edaf5fa0a24fdb905a6e060227bc", "committedDate": "2020-10-27T23:29:50Z", "message": "fix: Removes the streams cache for window stores since this hurts pull query performance"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a95014a096bc6024e38309ef4a6f38f9a31203fb", "author": {"user": {"login": "AlanConfluent", "name": "Alan Sheinberg"}}, "url": "https://github.com/confluentinc/ksql/commit/a95014a096bc6024e38309ef4a6f38f9a31203fb", "committedDate": "2020-10-29T20:12:22Z", "message": "Checkpoint that kina works, added session too"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "38fc46423dc06ff693c3b0f1d70564a8ca4ca34d", "author": {"user": {"login": "AlanConfluent", "name": "Alan Sheinberg"}}, "url": "https://github.com/confluentinc/ksql/commit/38fc46423dc06ff693c3b0f1d70564a8ca4ca34d", "committedDate": "2020-10-29T22:12:09Z", "message": "Changes to new methodology"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1fce993ed8dd1ab928a09f320471e777bf70d218", "author": {"user": {"login": "AlanConfluent", "name": "Alan Sheinberg"}}, "url": "https://github.com/confluentinc/ksql/commit/1fce993ed8dd1ab928a09f320471e777bf70d218", "committedDate": "2020-10-29T23:22:30Z", "message": "Removes old code and gets style validated"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5062bba83ad4f7fabba134430872bb7517258369", "author": {"user": {"login": "AlanConfluent", "name": "Alan Sheinberg"}}, "url": "https://github.com/confluentinc/ksql/commit/5062bba83ad4f7fabba134430872bb7517258369", "committedDate": "2020-10-29T23:50:33Z", "message": "Adds more tests"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIwMzgxMjgy", "url": "https://github.com/confluentinc/ksql/pull/6548#pullrequestreview-520381282", "createdAt": "2020-10-30T05:14:15Z", "commit": {"oid": "5062bba83ad4f7fabba134430872bb7517258369"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIwNzE3NzY2", "url": "https://github.com/confluentinc/ksql/pull/6548#pullrequestreview-520717766", "createdAt": "2020-10-30T14:24:36Z", "commit": {"oid": "5062bba83ad4f7fabba134430872bb7517258369"}, "state": "APPROVED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0zMFQxNDoyNDozN1rOHrRX6Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0zMFQxNDozNDo1M1rOHrRy2g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTEzNTQ2NQ==", "bodyText": "This is interesting; why does it happen?\n...Ah, I see. It's because the RocksDBSessionStore wraps a SegmentedBytesStore.\nThe rest seems fairly obvious, but this one might be subtle enough to warrant  a comment.", "url": "https://github.com/confluentinc/ksql/pull/6548#discussion_r515135465", "createdAt": "2020-10-30T14:24:37Z", "author": {"login": "vvcephei"}, "path": "ksqldb-streams/src/main/java/io/confluent/ksql/execution/streams/materialization/ks/SessionStoreCacheBypass.java", "diffHunk": "@@ -0,0 +1,199 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.execution.streams.materialization.ks;\n+\n+import io.confluent.ksql.GenericRow;\n+import java.lang.reflect.Field;\n+import java.util.List;\n+import java.util.NoSuchElementException;\n+import java.util.Objects;\n+import org.apache.kafka.common.utils.Bytes;\n+import org.apache.kafka.connect.data.Struct;\n+import org.apache.kafka.streams.KeyValue;\n+import org.apache.kafka.streams.errors.InvalidStateStoreException;\n+import org.apache.kafka.streams.kstream.Windowed;\n+import org.apache.kafka.streams.processor.StateStore;\n+import org.apache.kafka.streams.state.KeyValueIterator;\n+import org.apache.kafka.streams.state.QueryableStoreType;\n+import org.apache.kafka.streams.state.ReadOnlySessionStore;\n+import org.apache.kafka.streams.state.SessionStore;\n+import org.apache.kafka.streams.state.StateSerdes;\n+import org.apache.kafka.streams.state.internals.CompositeReadOnlySessionStore;\n+import org.apache.kafka.streams.state.internals.MeteredSessionStore;\n+import org.apache.kafka.streams.state.internals.StateStoreProvider;\n+import org.apache.kafka.streams.state.internals.WrappedStateStore;\n+\n+public final class SessionStoreCacheBypass {\n+\n+  private static final Field PROVIDER_FIELD;\n+  private static final Field STORE_NAME_FIELD;\n+  private static final Field STORE_TYPE_FIELD;\n+  static final Field SERDES_FIELD;\n+\n+  static {\n+    try {\n+      PROVIDER_FIELD = CompositeReadOnlySessionStore.class.getDeclaredField(\"storeProvider\");\n+      PROVIDER_FIELD.setAccessible(true);\n+      STORE_NAME_FIELD = CompositeReadOnlySessionStore.class.getDeclaredField(\"storeName\");\n+      STORE_NAME_FIELD.setAccessible(true);\n+      STORE_TYPE_FIELD\n+          = CompositeReadOnlySessionStore.class.getDeclaredField(\"queryableStoreType\");\n+      STORE_TYPE_FIELD.setAccessible(true);\n+      SERDES_FIELD = MeteredSessionStore.class.getDeclaredField(\"serdes\");\n+      SERDES_FIELD.setAccessible(true);\n+    } catch (final NoSuchFieldException e) {\n+      throw new RuntimeException(\"Stream internals changed unexpectedly!\", e);\n+    }\n+  }\n+\n+  private SessionStoreCacheBypass() {}\n+\n+  interface SessionStoreCacheBypassFetcher {\n+\n+    KeyValueIterator<Windowed<Struct>, GenericRow> fetch(\n+        ReadOnlySessionStore<Struct, GenericRow> store,\n+        Struct key\n+    );\n+  }\n+\n+  @SuppressWarnings(\"unchecked\")\n+  public static KeyValueIterator<Windowed<Struct>, GenericRow> fetch(\n+      final ReadOnlySessionStore<Struct, GenericRow> store,\n+      final Struct key\n+  ) {\n+    Objects.requireNonNull(key, \"key can't be null\");\n+\n+    final StateStoreProvider provider;\n+    final String storeName;\n+    final QueryableStoreType<ReadOnlySessionStore<Struct, GenericRow>> storeType;\n+    try {\n+      provider = (StateStoreProvider) PROVIDER_FIELD.get(store);\n+      storeName = (String) STORE_NAME_FIELD.get(store);\n+      storeType = (QueryableStoreType<ReadOnlySessionStore<Struct, GenericRow>>)\n+          STORE_TYPE_FIELD.get(store);\n+    } catch (final IllegalAccessException e) {\n+      throw new RuntimeException(\"Stream internals changed unexpectedly!\", e);\n+    }\n+    final List<ReadOnlySessionStore<Struct, GenericRow>> stores\n+        = provider.stores(storeName, storeType);\n+    for (final ReadOnlySessionStore<Struct, GenericRow> sessionStore : stores) {\n+      try {\n+        final KeyValueIterator<Windowed<Struct>, GenericRow> result\n+            = fetchUncached(sessionStore, key);\n+        // returns the first non-empty iterator\n+        if (!result.hasNext()) {\n+          result.close();\n+        } else {\n+          return result;\n+        }\n+      } catch (final InvalidStateStoreException e) {\n+        throw new InvalidStateStoreException(\n+            \"State store is not available anymore and may have been migrated to another instance; \"\n+                + \"please re-discover its location from the state metadata.\", e);\n+      }\n+    }\n+    return new EmptyKeyValueIterator();\n+  }\n+\n+  @SuppressWarnings(\"unchecked\")\n+  private static KeyValueIterator<Windowed<Struct>, GenericRow> fetchUncached(\n+      final ReadOnlySessionStore<Struct, GenericRow> sessionStore,\n+      final Struct key\n+  ) {\n+    if (sessionStore instanceof MeteredSessionStore) {\n+      final StateSerdes<Struct, GenericRow> serdes;\n+      try {\n+        serdes = (StateSerdes<Struct, GenericRow>) SERDES_FIELD.get(sessionStore);\n+      } catch (final IllegalAccessException e) {\n+        throw new RuntimeException(\"Stream internals changed unexpectedly!\", e);\n+      }\n+\n+      final Bytes rawKey = Bytes.wrap(serdes.rawKey(key));\n+      SessionStore<Bytes, byte[]> wrapped\n+          = ((MeteredSessionStore<Struct, GenericRow>) sessionStore).wrapped();\n+      while (wrapped instanceof WrappedStateStore) {\n+        final StateStore store = ((WrappedStateStore<?, ?, ?>) wrapped).wrapped();\n+        if (!(store instanceof SessionStore)) {\n+          break;\n+        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5062bba83ad4f7fabba134430872bb7517258369"}, "originalPosition": 131}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTE0MjM2Mg==", "bodyText": "It looks like this test verifies that we bottom out at a wrapped store when it doesn't wrap a WindowStore, right?\nIt seems like a similar test could positively verify that we actually do skip the caching layer, or any other wrapped layer, but I didn't see that test. Did I miss it?", "url": "https://github.com/confluentinc/ksql/pull/6548#discussion_r515142362", "createdAt": "2020-10-30T14:34:53Z", "author": {"login": "vvcephei"}, "path": "ksqldb-streams/src/test/java/io/confluent/ksql/execution/streams/materialization/ks/WindowStoreCacheBypassTest.java", "diffHunk": "@@ -0,0 +1,152 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.execution.streams.materialization.ks;\n+\n+import static io.confluent.ksql.execution.streams.materialization.ks.WindowStoreCacheBypass.SERDES_FIELD;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.containsString;\n+import static org.junit.Assert.assertThrows;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+\n+import com.google.common.collect.ImmutableList;\n+import io.confluent.ksql.GenericRow;\n+import java.time.Instant;\n+import org.apache.kafka.common.utils.Bytes;\n+import org.apache.kafka.connect.data.Schema;\n+import org.apache.kafka.connect.data.SchemaBuilder;\n+import org.apache.kafka.connect.data.Struct;\n+import org.apache.kafka.streams.errors.InvalidStateStoreException;\n+import org.apache.kafka.streams.processor.StateStore;\n+import org.apache.kafka.streams.state.QueryableStoreType;\n+import org.apache.kafka.streams.state.ReadOnlyWindowStore;\n+import org.apache.kafka.streams.state.StateSerdes;\n+import org.apache.kafka.streams.state.ValueAndTimestamp;\n+import org.apache.kafka.streams.state.WindowStore;\n+import org.apache.kafka.streams.state.WindowStoreIterator;\n+import org.apache.kafka.streams.state.internals.CompositeReadOnlyWindowStore;\n+import org.apache.kafka.streams.state.internals.MeteredWindowStore;\n+import org.apache.kafka.streams.state.internals.StateStoreProvider;\n+import org.apache.kafka.streams.state.internals.WrappedStateStore;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.mockito.Mock;\n+import org.mockito.junit.MockitoJUnitRunner;\n+\n+@RunWith(MockitoJUnitRunner.class)\n+public class WindowStoreCacheBypassTest {\n+\n+  private static final Schema SCHEMA = SchemaBuilder.struct().field(\"a\", SchemaBuilder.int32());\n+  private static final Struct SOME_KEY = new Struct(SCHEMA).put(\"a\", 1);\n+  private static final byte[] BYTES = new byte[] {'a', 'b'};\n+\n+  @Mock\n+  private QueryableStoreType<ReadOnlyWindowStore<Struct, ValueAndTimestamp<GenericRow>>>\n+      queryableStoreType;\n+  @Mock\n+  private StateStoreProvider provider;\n+  @Mock\n+  private MeteredWindowStore<Struct, ValueAndTimestamp<GenericRow>> meteredWindowStore;\n+  @Mock\n+  private WindowStore<Bytes, byte[]> windowStore;\n+  @Mock\n+  private WrappedWindowStore<Bytes, byte[]> wrappedWindowStore;\n+  @Mock\n+  private StateStore stateStore;\n+  @Mock\n+  private WindowStoreIterator<byte[]> windowStoreIterator;\n+  @Mock\n+  private StateSerdes<Struct, ValueAndTimestamp<GenericRow>> serdes;\n+\n+  private CompositeReadOnlyWindowStore<Struct, ValueAndTimestamp<GenericRow>> store;\n+  private WrappedStateStore<StateStore, Struct, ValueAndTimestamp<GenericRow>> wrappedStateStore;\n+\n+  @Before\n+  public void setUp() {\n+    store = new CompositeReadOnlyWindowStore<>(provider, queryableStoreType, \"foo\");\n+  }\n+\n+  @Test\n+  public void shouldCallUnderlyingStore() throws IllegalAccessException {\n+    when(provider.stores(any(), any())).thenReturn(ImmutableList.of(meteredWindowStore));\n+    SERDES_FIELD.set(meteredWindowStore, serdes);\n+    when(serdes.rawKey(any())).thenReturn(BYTES);\n+    when(meteredWindowStore.wrapped()).thenReturn(wrappedWindowStore);\n+    when(wrappedWindowStore.wrapped()).thenReturn(windowStore);\n+    when(windowStore.fetch(any(), any(), any())).thenReturn(windowStoreIterator);\n+    when(windowStoreIterator.hasNext()).thenReturn(false);\n+\n+    WindowStoreCacheBypass.fetch(store, SOME_KEY, Instant.ofEpochMilli(100), Instant.ofEpochMilli(200));\n+    verify(windowStore).fetch(new Bytes(BYTES), Instant.ofEpochMilli(100L), Instant.ofEpochMilli(200L));\n+  }\n+\n+  @Test\n+  public void shouldAvoidNonWindowStore() throws IllegalAccessException {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5062bba83ad4f7fabba134430872bb7517258369"}, "originalPosition": 99}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "81089d81c2bef1f39dc87f8f9ee00b6b0bc9197e", "author": {"user": {"login": "AlanConfluent", "name": "Alan Sheinberg"}}, "url": "https://github.com/confluentinc/ksql/commit/81089d81c2bef1f39dc87f8f9ee00b6b0bc9197e", "committedDate": "2020-10-30T18:20:02Z", "message": "Remove unused field in test"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7cfe7deb0909a8519fc61884e05f7693f13450bc", "author": {"user": {"login": "AlanConfluent", "name": "Alan Sheinberg"}}, "url": "https://github.com/confluentinc/ksql/commit/7cfe7deb0909a8519fc61884e05f7693f13450bc", "committedDate": "2020-10-30T23:44:43Z", "message": "Feedback again"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "0aa734640b1b11bfc08ce2e77592afe7e06e6d3d", "author": {"user": {"login": "AlanConfluent", "name": "Alan Sheinberg"}}, "url": "https://github.com/confluentinc/ksql/commit/0aa734640b1b11bfc08ce2e77592afe7e06e6d3d", "committedDate": "2020-10-30T23:24:13Z", "message": "Feedback"}, "afterCommit": {"oid": "7cfe7deb0909a8519fc61884e05f7693f13450bc", "author": {"user": {"login": "AlanConfluent", "name": "Alan Sheinberg"}}, "url": "https://github.com/confluentinc/ksql/commit/7cfe7deb0909a8519fc61884e05f7693f13450bc", "committedDate": "2020-10-30T23:44:43Z", "message": "Feedback again"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIxMzAzOTAy", "url": "https://github.com/confluentinc/ksql/pull/6548#pullrequestreview-521303902", "createdAt": "2020-11-02T02:48:32Z", "commit": {"oid": "7cfe7deb0909a8519fc61884e05f7693f13450bc"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMlQwMjo0ODozMlrOHr00UQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMlQwMjo0ODozMlrOHr00UQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTcxNjE3Nw==", "bodyText": "Why did you add these?", "url": "https://github.com/confluentinc/ksql/pull/6548#discussion_r515716177", "createdAt": "2020-11-02T02:48:32Z", "author": {"login": "vpapavas"}, "path": "ksqldb-rest-app/src/test/java/io/confluent/ksql/rest/integration/PullQueryFunctionalTest.java", "diffHunk": "@@ -129,6 +129,7 @@\n       .withProperty(KsqlRestConfig.ADVERTISED_LISTENER_CONFIG, \"http://localhost:8188\")\n       .withProperty(KsqlConfig.KSQL_QUERY_PULL_ENABLE_STANDBY_READS, true)\n       .withProperty(KsqlConfig.KSQL_STREAMS_PREFIX + \"num.standby.replicas\", 1)\n+      .withProperty(KsqlConfig.KSQL_STREAMS_PREFIX + \"cache.max.bytes.buffering\", 10000)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7cfe7deb0909a8519fc61884e05f7693f13450bc"}, "originalPosition": 4}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIxMzAzOTg0", "url": "https://github.com/confluentinc/ksql/pull/6548#pullrequestreview-521303984", "createdAt": "2020-11-02T02:48:52Z", "commit": {"oid": "7cfe7deb0909a8519fc61884e05f7693f13450bc"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4598, "cost": 1, "resetAt": "2021-11-01T13:51:04Z"}}}