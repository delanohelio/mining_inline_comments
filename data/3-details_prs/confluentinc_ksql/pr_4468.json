{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzcyMTQzNzM5", "number": 4468, "title": "feat: Adds a new RoutingFilter, MaximumLagFilter that looks at offset lags", "bodyText": "Description\nAdds a new RoutingFilter, MaximumLagFilter, which filters hosts based on their changelog lag.  It takes the maximum reported end offset, and calculates the lag from that and the reported current offset.\nTesting done\nRan mvn package\nReviewer checklist\n\n Ensure docs are updated if necessary. (eg. if a user visible feature is being added or changed).\n Ensure relevant issues are linked (description should include text like \"Fixes #\")", "createdAt": "2020-02-06T22:29:10Z", "url": "https://github.com/confluentinc/ksql/pull/4468", "merged": true, "mergeCommit": {"oid": "fd7c1a5924a7e8408c2313ae7f8e383daf56a56f"}, "closed": true, "closedAt": "2020-02-08T01:06:29Z", "author": {"login": "AlanConfluent"}, "timelineItems": {"totalCount": 12, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcBzyYuAFqTM1NDg0MTU3MQ==", "endCursor": "Y3Vyc29yOnYyOpPPAAABcCItPPgH2gAyMzcyMTQzNzM5OmQ1MjIyYTZmZDI5MGQ4NmZlMjQ4YTczNjY1YWMxZDJlZjM1ZmE0ZTU=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU0ODQxNTcx", "url": "https://github.com/confluentinc/ksql/pull/4468#pullrequestreview-354841571", "createdAt": "2020-02-06T23:19:56Z", "commit": {"oid": "3f29c37b083521f11ec3896b0df116f171b6e847"}, "state": "COMMENTED", "comments": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNlQyMzoxOTo1N1rOFmtl-g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wN1QwMDowMDowMFrOFmuVeg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjEzNzIxMA==", "bodyText": "since this is applied to both active and standbys, should we name this differently?  ksql.query.pull.max.tolerable.offset.lag ?", "url": "https://github.com/confluentinc/ksql/pull/4468#discussion_r376137210", "createdAt": "2020-02-06T23:19:57Z", "author": {"login": "vinothchandar"}, "path": "ksql-common/src/main/java/io/confluent/ksql/util/KsqlConfig.java", "diffHunk": "@@ -182,6 +182,13 @@\n           + \"to ksql.streams.num.standby.replicas >= 1\";\n   public static final boolean KSQL_QUERY_PULL_ENABLE_STANDBY_READS_DEFAULT = false;\n \n+  public static final String KSQL_QUERY_PULL_STANDBY_READS_MAX_OFFSET_LAG_CONFIG =", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3f29c37b083521f11ec3896b0df116f171b6e847"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjE0MDc2NQ==", "bodyText": "at some point, to handle some corner cases with network partitions, we probably need to expire lag information reported. (we discussed this a while ago if you recall).. Can we file a follow up to explore that?>", "url": "https://github.com/confluentinc/ksql/pull/4468#discussion_r376140765", "createdAt": "2020-02-06T23:31:24Z", "author": {"login": "vinothchandar"}, "path": "ksql-rest-app/src/main/java/io/confluent/ksql/rest/server/MaximumLagFilter.java", "diffHunk": "@@ -0,0 +1,103 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.rest.server;\n+\n+import static java.util.Objects.requireNonNull;\n+\n+import com.google.common.collect.ImmutableMap;\n+import io.confluent.ksql.execution.streams.RoutingFilter;\n+import io.confluent.ksql.execution.streams.RoutingOptions;\n+import io.confluent.ksql.rest.entity.LagInfoEntity;\n+import io.confluent.ksql.rest.entity.QueryStateStoreId;\n+import io.confluent.ksql.util.KsqlHostInfo;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.OptionalLong;\n+import java.util.function.Function;\n+\n+/**\n+ * A RoutingFilter that filters hosts based upon changelog processing lag.\n+ */\n+public final class MaximumLagFilter implements RoutingFilter {\n+\n+  private final ImmutableMap<KsqlHostInfo, Optional<LagInfoEntity>> lagByHost;\n+  private final RoutingOptions routingOptions;\n+  private final OptionalLong maxEndOffset;\n+\n+  private MaximumLagFilter(\n+      final RoutingOptions routingOptions,\n+      final ImmutableMap<KsqlHostInfo, Optional<LagInfoEntity>> lagByHost,\n+      final OptionalLong maxEndOffset\n+  ) {\n+    this.lagByHost = requireNonNull(lagByHost, \"lagByHost\");\n+    this.routingOptions = requireNonNull(routingOptions, \"requireNonNull\");\n+    this.maxEndOffset = requireNonNull(maxEndOffset, \"maxEndOffset\");\n+  }\n+\n+  @Override\n+  public boolean filter(final KsqlHostInfo hostInfo) {\n+    final long allowedOffsetLag = routingOptions.getOffsetLagAllowed();\n+    if (allowedOffsetLag >= 0) {\n+      return lagByHost.getOrDefault(hostInfo, Optional.empty())", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3f29c37b083521f11ec3896b0df116f171b6e847"}, "originalPosition": 54}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjE0MTI0Mw==", "bodyText": "optional: this is the queryId of the persistent query that materialized the table right? can we name/doc this more clearly?", "url": "https://github.com/confluentinc/ksql/pull/4468#discussion_r376141243", "createdAt": "2020-02-06T23:32:54Z", "author": {"login": "vinothchandar"}, "path": "ksql-rest-app/src/main/java/io/confluent/ksql/rest/server/MaximumLagFilter.java", "diffHunk": "@@ -0,0 +1,103 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.rest.server;\n+\n+import static java.util.Objects.requireNonNull;\n+\n+import com.google.common.collect.ImmutableMap;\n+import io.confluent.ksql.execution.streams.RoutingFilter;\n+import io.confluent.ksql.execution.streams.RoutingOptions;\n+import io.confluent.ksql.rest.entity.LagInfoEntity;\n+import io.confluent.ksql.rest.entity.QueryStateStoreId;\n+import io.confluent.ksql.util.KsqlHostInfo;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.OptionalLong;\n+import java.util.function.Function;\n+\n+/**\n+ * A RoutingFilter that filters hosts based upon changelog processing lag.\n+ */\n+public final class MaximumLagFilter implements RoutingFilter {\n+\n+  private final ImmutableMap<KsqlHostInfo, Optional<LagInfoEntity>> lagByHost;\n+  private final RoutingOptions routingOptions;\n+  private final OptionalLong maxEndOffset;\n+\n+  private MaximumLagFilter(\n+      final RoutingOptions routingOptions,\n+      final ImmutableMap<KsqlHostInfo, Optional<LagInfoEntity>> lagByHost,\n+      final OptionalLong maxEndOffset\n+  ) {\n+    this.lagByHost = requireNonNull(lagByHost, \"lagByHost\");\n+    this.routingOptions = requireNonNull(routingOptions, \"requireNonNull\");\n+    this.maxEndOffset = requireNonNull(maxEndOffset, \"maxEndOffset\");\n+  }\n+\n+  @Override\n+  public boolean filter(final KsqlHostInfo hostInfo) {\n+    final long allowedOffsetLag = routingOptions.getOffsetLagAllowed();\n+    if (allowedOffsetLag >= 0) {\n+      return lagByHost.getOrDefault(hostInfo, Optional.empty())\n+          .map(hostLag -> {\n+            // Compute the lag from the maximum end offset we've seen\n+            final long endOffset = maxEndOffset.orElse(hostLag.getEndOffsetPosition());\n+            final long offsetLag = Math.max(endOffset - hostLag.getCurrentOffsetPosition(), 0);\n+            return offsetLag <= allowedOffsetLag;\n+          })\n+          // If we don't have lag info, we'll be conservative and include the host\n+          .orElse(true);\n+    }\n+    return true;\n+  }\n+\n+  /**\n+   * Creates a FreshnessFilter\n+   * @param lagReportingAgent The optional lag reporting agent.\n+   * @param routingOptions The routing options\n+   * @param hosts The set of all hosts that have the store, including actives and standbys\n+   * @param applicationQueryId The application query id", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3f29c37b083521f11ec3896b0df116f171b6e847"}, "originalPosition": 72}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjE0NzkzNQ==", "bodyText": "Confirming my understanding: I see that LagInfoEntity just holds data for a given store partition and this lagByHost map is a filtered version of the data we track in the lag agent, getHostsPartitionLagInfo() effectively filter the data for the store/partition we are interested in?\nnit: rename to lagInfoByHost ?", "url": "https://github.com/confluentinc/ksql/pull/4468#discussion_r376147935", "createdAt": "2020-02-06T23:55:00Z", "author": {"login": "vinothchandar"}, "path": "ksql-rest-app/src/main/java/io/confluent/ksql/rest/server/MaximumLagFilter.java", "diffHunk": "@@ -0,0 +1,103 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.rest.server;\n+\n+import static java.util.Objects.requireNonNull;\n+\n+import com.google.common.collect.ImmutableMap;\n+import io.confluent.ksql.execution.streams.RoutingFilter;\n+import io.confluent.ksql.execution.streams.RoutingOptions;\n+import io.confluent.ksql.rest.entity.LagInfoEntity;\n+import io.confluent.ksql.rest.entity.QueryStateStoreId;\n+import io.confluent.ksql.util.KsqlHostInfo;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.OptionalLong;\n+import java.util.function.Function;\n+\n+/**\n+ * A RoutingFilter that filters hosts based upon changelog processing lag.\n+ */\n+public final class MaximumLagFilter implements RoutingFilter {\n+\n+  private final ImmutableMap<KsqlHostInfo, Optional<LagInfoEntity>> lagByHost;\n+  private final RoutingOptions routingOptions;\n+  private final OptionalLong maxEndOffset;\n+\n+  private MaximumLagFilter(\n+      final RoutingOptions routingOptions,\n+      final ImmutableMap<KsqlHostInfo, Optional<LagInfoEntity>> lagByHost,\n+      final OptionalLong maxEndOffset\n+  ) {\n+    this.lagByHost = requireNonNull(lagByHost, \"lagByHost\");\n+    this.routingOptions = requireNonNull(routingOptions, \"requireNonNull\");\n+    this.maxEndOffset = requireNonNull(maxEndOffset, \"maxEndOffset\");\n+  }\n+\n+  @Override\n+  public boolean filter(final KsqlHostInfo hostInfo) {\n+    final long allowedOffsetLag = routingOptions.getOffsetLagAllowed();\n+    if (allowedOffsetLag >= 0) {\n+      return lagByHost.getOrDefault(hostInfo, Optional.empty())\n+          .map(hostLag -> {\n+            // Compute the lag from the maximum end offset we've seen\n+            final long endOffset = maxEndOffset.orElse(hostLag.getEndOffsetPosition());\n+            final long offsetLag = Math.max(endOffset - hostLag.getCurrentOffsetPosition(), 0);\n+            return offsetLag <= allowedOffsetLag;\n+          })\n+          // If we don't have lag info, we'll be conservative and include the host\n+          .orElse(true);\n+    }\n+    return true;\n+  }\n+\n+  /**\n+   * Creates a FreshnessFilter\n+   * @param lagReportingAgent The optional lag reporting agent.\n+   * @param routingOptions The routing options\n+   * @param hosts The set of all hosts that have the store, including actives and standbys\n+   * @param applicationQueryId The application query id\n+   * @param storeName The state store name\n+   * @param partition The partition of the topic\n+   * @return a new FreshnessFilter, unless lag reporting is disabled.\n+   */\n+  public static Optional<MaximumLagFilter> create(\n+      final Optional<LagReportingAgent> lagReportingAgent,\n+      final RoutingOptions routingOptions,\n+      final List<KsqlHostInfo> hosts,\n+      final String applicationQueryId,\n+      final String storeName,\n+      final int partition\n+  ) {\n+    if (!lagReportingAgent.isPresent()) {\n+      return Optional.empty();\n+    }\n+    final QueryStateStoreId queryStateStoreId = QueryStateStoreId.of(applicationQueryId, storeName);\n+    final ImmutableMap<KsqlHostInfo, Optional<LagInfoEntity>> lagByHost = hosts.stream()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3f29c37b083521f11ec3896b0df116f171b6e847"}, "originalPosition": 89}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjE0ODQ0NQ==", "bodyText": "getHostsPartitionLagInfo() also checks for live hosts. given how we are wiring the filters now, do we still need to special handling  below\nif (!aliveHosts.contains(host)) {\n      return Optional.empty();\n    }", "url": "https://github.com/confluentinc/ksql/pull/4468#discussion_r376148445", "createdAt": "2020-02-06T23:56:44Z", "author": {"login": "vinothchandar"}, "path": "ksql-rest-app/src/main/java/io/confluent/ksql/rest/server/MaximumLagFilter.java", "diffHunk": "@@ -0,0 +1,103 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.rest.server;\n+\n+import static java.util.Objects.requireNonNull;\n+\n+import com.google.common.collect.ImmutableMap;\n+import io.confluent.ksql.execution.streams.RoutingFilter;\n+import io.confluent.ksql.execution.streams.RoutingOptions;\n+import io.confluent.ksql.rest.entity.LagInfoEntity;\n+import io.confluent.ksql.rest.entity.QueryStateStoreId;\n+import io.confluent.ksql.util.KsqlHostInfo;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.OptionalLong;\n+import java.util.function.Function;\n+\n+/**\n+ * A RoutingFilter that filters hosts based upon changelog processing lag.\n+ */\n+public final class MaximumLagFilter implements RoutingFilter {\n+\n+  private final ImmutableMap<KsqlHostInfo, Optional<LagInfoEntity>> lagByHost;\n+  private final RoutingOptions routingOptions;\n+  private final OptionalLong maxEndOffset;\n+\n+  private MaximumLagFilter(\n+      final RoutingOptions routingOptions,\n+      final ImmutableMap<KsqlHostInfo, Optional<LagInfoEntity>> lagByHost,\n+      final OptionalLong maxEndOffset\n+  ) {\n+    this.lagByHost = requireNonNull(lagByHost, \"lagByHost\");\n+    this.routingOptions = requireNonNull(routingOptions, \"requireNonNull\");\n+    this.maxEndOffset = requireNonNull(maxEndOffset, \"maxEndOffset\");\n+  }\n+\n+  @Override\n+  public boolean filter(final KsqlHostInfo hostInfo) {\n+    final long allowedOffsetLag = routingOptions.getOffsetLagAllowed();\n+    if (allowedOffsetLag >= 0) {\n+      return lagByHost.getOrDefault(hostInfo, Optional.empty())\n+          .map(hostLag -> {\n+            // Compute the lag from the maximum end offset we've seen\n+            final long endOffset = maxEndOffset.orElse(hostLag.getEndOffsetPosition());\n+            final long offsetLag = Math.max(endOffset - hostLag.getCurrentOffsetPosition(), 0);\n+            return offsetLag <= allowedOffsetLag;\n+          })\n+          // If we don't have lag info, we'll be conservative and include the host\n+          .orElse(true);\n+    }\n+    return true;\n+  }\n+\n+  /**\n+   * Creates a FreshnessFilter\n+   * @param lagReportingAgent The optional lag reporting agent.\n+   * @param routingOptions The routing options\n+   * @param hosts The set of all hosts that have the store, including actives and standbys\n+   * @param applicationQueryId The application query id\n+   * @param storeName The state store name\n+   * @param partition The partition of the topic\n+   * @return a new FreshnessFilter, unless lag reporting is disabled.\n+   */\n+  public static Optional<MaximumLagFilter> create(\n+      final Optional<LagReportingAgent> lagReportingAgent,\n+      final RoutingOptions routingOptions,\n+      final List<KsqlHostInfo> hosts,\n+      final String applicationQueryId,\n+      final String storeName,\n+      final int partition\n+  ) {\n+    if (!lagReportingAgent.isPresent()) {\n+      return Optional.empty();\n+    }\n+    final QueryStateStoreId queryStateStoreId = QueryStateStoreId.of(applicationQueryId, storeName);\n+    final ImmutableMap<KsqlHostInfo, Optional<LagInfoEntity>> lagByHost = hosts.stream()\n+        .collect(ImmutableMap.toImmutableMap(\n+            Function.identity(),\n+            host -> lagReportingAgent.get().getHostsPartitionLagInfo(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3f29c37b083521f11ec3896b0df116f171b6e847"}, "originalPosition": 92}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjE0OTE2MA==", "bodyText": "I am concerned about this cloning done on every call. does this create a new copy of the config map each call? Should we better way to build a composite objects out of these two configs?", "url": "https://github.com/confluentinc/ksql/pull/4468#discussion_r376149160", "createdAt": "2020-02-06T23:59:21Z", "author": {"login": "vinothchandar"}, "path": "ksql-rest-app/src/main/java/io/confluent/ksql/rest/server/execution/PullQueryExecutor.java", "diffHunk": "@@ -213,11 +215,16 @@ private TableRowsEntity handlePullQuery(\n       final ServiceContext serviceContext,\n       final PullQueryContext pullQueryContext\n   ) {\n+    final KsqlConfig ksqlConfigWithOverrides = statement.getConfig()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3f29c37b083521f11ec3896b0df116f171b6e847"}, "originalPosition": 35}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjE0OTM3MA==", "bodyText": "add a note in the configs doc, that this can be overridden per query?", "url": "https://github.com/confluentinc/ksql/pull/4468#discussion_r376149370", "createdAt": "2020-02-07T00:00:00Z", "author": {"login": "vinothchandar"}, "path": "ksql-rest-app/src/main/java/io/confluent/ksql/rest/server/execution/PullQueryExecutor.java", "diffHunk": "@@ -957,4 +967,19 @@ private ColumnReferenceRewriter() {\n       return Optional.of(new UnqualifiedColumnReferenceExp(node.getReference()));\n     }\n   }\n+\n+  private static final class ConfigRoutingOptions implements RoutingOptions {\n+\n+    private final KsqlConfig ksqlConfig;\n+\n+    ConfigRoutingOptions(final KsqlConfig ksqlConfig) {\n+      this.ksqlConfig = ksqlConfig;\n+    }\n+\n+    @Override\n+    public long getOffsetLagAllowed() {\n+      return ksqlConfig.getLong(\n+          KsqlConfig.KSQL_QUERY_PULL_STANDBY_READS_MAX_OFFSET_LAG_CONFIG);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3f29c37b083521f11ec3896b0df116f171b6e847"}, "originalPosition": 149}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU0ODU2MDg2", "url": "https://github.com/confluentinc/ksql/pull/4468#pullrequestreview-354856086", "createdAt": "2020-02-07T00:00:17Z", "commit": {"oid": "3f29c37b083521f11ec3896b0df116f171b6e847"}, "state": "COMMENTED", "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wN1QwMDowMDoxOFrOFmuVxg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wN1QwMDoxNDowN1rOFmulIg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjE0OTQ0Ng==", "bodyText": "for my understanding, if standby reads are disabled why do we bother adding the other filters?", "url": "https://github.com/confluentinc/ksql/pull/4468#discussion_r376149446", "createdAt": "2020-02-07T00:00:18Z", "author": {"login": "agavra"}, "path": "ksql-rest-app/src/main/java/io/confluent/ksql/rest/server/KsqlRestApplication.java", "diffHunk": "@@ -740,16 +742,21 @@ static KsqlRestApplication buildApplication(\n     return Optional.empty();\n   }\n \n-  private static RoutingFilters initializeRoutingFilters(\n+  private static RoutingFilterFactory initializeRoutingFilterFactory(\n       final KsqlConfig ksqlConfig,\n-      final Optional<HeartbeatAgent> heartbeatAgent) {\n-    final ImmutableList.Builder<RoutingFilter> filterBuilder = ImmutableList.builder();\n-    if (!ksqlConfig.getBoolean(KsqlConfig.KSQL_QUERY_PULL_ENABLE_STANDBY_READS)) {\n-      filterBuilder.add(new ActiveHostFilter());\n-    }\n-    filterBuilder.add(new LivenessFilter(heartbeatAgent));\n-    final RoutingFilters routingFilters = new RoutingFilters(filterBuilder.build());\n-    return routingFilters;\n+      final Optional<HeartbeatAgent> heartbeatAgent,\n+      final Optional<LagReportingAgent> lagReportingAgent) {\n+    return (routingOptions, hosts, active, applicationQueryId, storeName, partition) -> {\n+      final ImmutableList.Builder<RoutingFilter> filterBuilder = ImmutableList.builder();\n+      if (!ksqlConfig.getBoolean(KsqlConfig.KSQL_QUERY_PULL_ENABLE_STANDBY_READS)) {\n+        filterBuilder.add(new ActiveHostFilter(active));\n+      }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3f29c37b083521f11ec3896b0df116f171b6e847"}, "originalPosition": 57}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjE1MDMyNg==", "bodyText": "should we allow values less than 0? feels like a misconfiguration", "url": "https://github.com/confluentinc/ksql/pull/4468#discussion_r376150326", "createdAt": "2020-02-07T00:03:12Z", "author": {"login": "agavra"}, "path": "ksql-rest-app/src/main/java/io/confluent/ksql/rest/server/MaximumLagFilter.java", "diffHunk": "@@ -0,0 +1,103 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.rest.server;\n+\n+import static java.util.Objects.requireNonNull;\n+\n+import com.google.common.collect.ImmutableMap;\n+import io.confluent.ksql.execution.streams.RoutingFilter;\n+import io.confluent.ksql.execution.streams.RoutingOptions;\n+import io.confluent.ksql.rest.entity.LagInfoEntity;\n+import io.confluent.ksql.rest.entity.QueryStateStoreId;\n+import io.confluent.ksql.util.KsqlHostInfo;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.OptionalLong;\n+import java.util.function.Function;\n+\n+/**\n+ * A RoutingFilter that filters hosts based upon changelog processing lag.\n+ */\n+public final class MaximumLagFilter implements RoutingFilter {\n+\n+  private final ImmutableMap<KsqlHostInfo, Optional<LagInfoEntity>> lagByHost;\n+  private final RoutingOptions routingOptions;\n+  private final OptionalLong maxEndOffset;\n+\n+  private MaximumLagFilter(\n+      final RoutingOptions routingOptions,\n+      final ImmutableMap<KsqlHostInfo, Optional<LagInfoEntity>> lagByHost,\n+      final OptionalLong maxEndOffset\n+  ) {\n+    this.lagByHost = requireNonNull(lagByHost, \"lagByHost\");\n+    this.routingOptions = requireNonNull(routingOptions, \"requireNonNull\");\n+    this.maxEndOffset = requireNonNull(maxEndOffset, \"maxEndOffset\");\n+  }\n+\n+  @Override\n+  public boolean filter(final KsqlHostInfo hostInfo) {\n+    final long allowedOffsetLag = routingOptions.getOffsetLagAllowed();\n+    if (allowedOffsetLag >= 0) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3f29c37b083521f11ec3896b0df116f171b6e847"}, "originalPosition": 53}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjE1MDYzNg==", "bodyText": "wouldn't the conservative thing be to exclude the host? if I asked for an offset lag of 0 and I get a host that just came online (so I don't have lag info yet) I'd be surprised by this!", "url": "https://github.com/confluentinc/ksql/pull/4468#discussion_r376150636", "createdAt": "2020-02-07T00:04:18Z", "author": {"login": "agavra"}, "path": "ksql-rest-app/src/main/java/io/confluent/ksql/rest/server/MaximumLagFilter.java", "diffHunk": "@@ -0,0 +1,103 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.rest.server;\n+\n+import static java.util.Objects.requireNonNull;\n+\n+import com.google.common.collect.ImmutableMap;\n+import io.confluent.ksql.execution.streams.RoutingFilter;\n+import io.confluent.ksql.execution.streams.RoutingOptions;\n+import io.confluent.ksql.rest.entity.LagInfoEntity;\n+import io.confluent.ksql.rest.entity.QueryStateStoreId;\n+import io.confluent.ksql.util.KsqlHostInfo;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.OptionalLong;\n+import java.util.function.Function;\n+\n+/**\n+ * A RoutingFilter that filters hosts based upon changelog processing lag.\n+ */\n+public final class MaximumLagFilter implements RoutingFilter {\n+\n+  private final ImmutableMap<KsqlHostInfo, Optional<LagInfoEntity>> lagByHost;\n+  private final RoutingOptions routingOptions;\n+  private final OptionalLong maxEndOffset;\n+\n+  private MaximumLagFilter(\n+      final RoutingOptions routingOptions,\n+      final ImmutableMap<KsqlHostInfo, Optional<LagInfoEntity>> lagByHost,\n+      final OptionalLong maxEndOffset\n+  ) {\n+    this.lagByHost = requireNonNull(lagByHost, \"lagByHost\");\n+    this.routingOptions = requireNonNull(routingOptions, \"requireNonNull\");\n+    this.maxEndOffset = requireNonNull(maxEndOffset, \"maxEndOffset\");\n+  }\n+\n+  @Override\n+  public boolean filter(final KsqlHostInfo hostInfo) {\n+    final long allowedOffsetLag = routingOptions.getOffsetLagAllowed();\n+    if (allowedOffsetLag >= 0) {\n+      return lagByHost.getOrDefault(hostInfo, Optional.empty())\n+          .map(hostLag -> {\n+            // Compute the lag from the maximum end offset we've seen\n+            final long endOffset = maxEndOffset.orElse(hostLag.getEndOffsetPosition());\n+            final long offsetLag = Math.max(endOffset - hostLag.getCurrentOffsetPosition(), 0);\n+            return offsetLag <= allowedOffsetLag;\n+          })\n+          // If we don't have lag info, we'll be conservative and include the host\n+          .orElse(true);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3f29c37b083521f11ec3896b0df116f171b6e847"}, "originalPosition": 62}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjE1MDgyNg==", "bodyText": "can we document this parameter? it's a little unclear what it means to me (i.e. why would I prefer this over whats in the map - maxEndOffset.orElse(hostLag.getEndOffsetPosition()))\nEDIT: after reading more of the code this makes sense to me - it's the latest end offset that any of the replicas has seen (so it's independent of how caught up any of them actually are).", "url": "https://github.com/confluentinc/ksql/pull/4468#discussion_r376150826", "createdAt": "2020-02-07T00:05:03Z", "author": {"login": "agavra"}, "path": "ksql-rest-app/src/main/java/io/confluent/ksql/rest/server/MaximumLagFilter.java", "diffHunk": "@@ -0,0 +1,103 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.rest.server;\n+\n+import static java.util.Objects.requireNonNull;\n+\n+import com.google.common.collect.ImmutableMap;\n+import io.confluent.ksql.execution.streams.RoutingFilter;\n+import io.confluent.ksql.execution.streams.RoutingOptions;\n+import io.confluent.ksql.rest.entity.LagInfoEntity;\n+import io.confluent.ksql.rest.entity.QueryStateStoreId;\n+import io.confluent.ksql.util.KsqlHostInfo;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.OptionalLong;\n+import java.util.function.Function;\n+\n+/**\n+ * A RoutingFilter that filters hosts based upon changelog processing lag.\n+ */\n+public final class MaximumLagFilter implements RoutingFilter {\n+\n+  private final ImmutableMap<KsqlHostInfo, Optional<LagInfoEntity>> lagByHost;\n+  private final RoutingOptions routingOptions;\n+  private final OptionalLong maxEndOffset;\n+\n+  private MaximumLagFilter(\n+      final RoutingOptions routingOptions,\n+      final ImmutableMap<KsqlHostInfo, Optional<LagInfoEntity>> lagByHost,\n+      final OptionalLong maxEndOffset", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3f29c37b083521f11ec3896b0df116f171b6e847"}, "originalPosition": 43}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjE1MzM3OA==", "bodyText": "if the maxEndOffset is not present it seems like something bad happened (nobody knows where the real end of the kafka topic is)... is it safe to ignore that?", "url": "https://github.com/confluentinc/ksql/pull/4468#discussion_r376153378", "createdAt": "2020-02-07T00:14:07Z", "author": {"login": "agavra"}, "path": "ksql-rest-app/src/main/java/io/confluent/ksql/rest/server/MaximumLagFilter.java", "diffHunk": "@@ -0,0 +1,103 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.rest.server;\n+\n+import static java.util.Objects.requireNonNull;\n+\n+import com.google.common.collect.ImmutableMap;\n+import io.confluent.ksql.execution.streams.RoutingFilter;\n+import io.confluent.ksql.execution.streams.RoutingOptions;\n+import io.confluent.ksql.rest.entity.LagInfoEntity;\n+import io.confluent.ksql.rest.entity.QueryStateStoreId;\n+import io.confluent.ksql.util.KsqlHostInfo;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.OptionalLong;\n+import java.util.function.Function;\n+\n+/**\n+ * A RoutingFilter that filters hosts based upon changelog processing lag.\n+ */\n+public final class MaximumLagFilter implements RoutingFilter {\n+\n+  private final ImmutableMap<KsqlHostInfo, Optional<LagInfoEntity>> lagByHost;\n+  private final RoutingOptions routingOptions;\n+  private final OptionalLong maxEndOffset;\n+\n+  private MaximumLagFilter(\n+      final RoutingOptions routingOptions,\n+      final ImmutableMap<KsqlHostInfo, Optional<LagInfoEntity>> lagByHost,\n+      final OptionalLong maxEndOffset\n+  ) {\n+    this.lagByHost = requireNonNull(lagByHost, \"lagByHost\");\n+    this.routingOptions = requireNonNull(routingOptions, \"requireNonNull\");\n+    this.maxEndOffset = requireNonNull(maxEndOffset, \"maxEndOffset\");\n+  }\n+\n+  @Override\n+  public boolean filter(final KsqlHostInfo hostInfo) {\n+    final long allowedOffsetLag = routingOptions.getOffsetLagAllowed();\n+    if (allowedOffsetLag >= 0) {\n+      return lagByHost.getOrDefault(hostInfo, Optional.empty())\n+          .map(hostLag -> {\n+            // Compute the lag from the maximum end offset we've seen\n+            final long endOffset = maxEndOffset.orElse(hostLag.getEndOffsetPosition());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3f29c37b083521f11ec3896b0df116f171b6e847"}, "originalPosition": 57}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU0ODcwNDI2", "url": "https://github.com/confluentinc/ksql/pull/4468#pullrequestreview-354870426", "createdAt": "2020-02-07T00:44:52Z", "commit": {"oid": "3f29c37b083521f11ec3896b0df116f171b6e847"}, "state": "APPROVED", "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wN1QwMDo0NDo1MlrOFmvFMA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wN1QwMDo1NToyMVrOFmvQiQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjE2MTU4NA==", "bodyText": "13?", "url": "https://github.com/confluentinc/ksql/pull/4468#discussion_r376161584", "createdAt": "2020-02-07T00:44:52Z", "author": {"login": "vinothchandar"}, "path": "ksql-rest-app/src/test/java/io/confluent/ksql/rest/server/MaximumLagFilterTest.java", "diffHunk": "@@ -0,0 +1,109 @@\n+package io.confluent.ksql.rest.server;\n+\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertTrue;\n+import static org.mockito.Mockito.eq;\n+import static org.mockito.Mockito.when;\n+\n+import com.google.common.collect.ImmutableList;\n+import io.confluent.ksql.execution.streams.RoutingOptions;\n+import io.confluent.ksql.rest.entity.LagInfoEntity;\n+import io.confluent.ksql.rest.entity.QueryStateStoreId;\n+import io.confluent.ksql.util.KsqlHostInfo;\n+import java.util.List;\n+import java.util.Optional;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.mockito.Mock;\n+import org.mockito.junit.MockitoJUnitRunner;\n+\n+@RunWith(MockitoJUnitRunner.class)\n+public class MaximumLagFilterTest {\n+\n+  private static KsqlHostInfo HOST = new KsqlHostInfo(\"host\", 8088);\n+  private static KsqlHostInfo HOST2 = new KsqlHostInfo(\"host2\", 8088);\n+  private static List<KsqlHostInfo> HOSTS = ImmutableList.of(HOST, HOST2);\n+  private static String APPLICATION_ID = \"app_id\";\n+  private static String STATE_STORE = \"state_store\";\n+  private static int PARTITION = 3;\n+  private static LagInfoEntity LAG = new LagInfoEntity(3, 12, 9);\n+  private static LagInfoEntity LAG2 = new LagInfoEntity(7, 15, 8);\n+\n+  @Mock\n+  private LagReportingAgent lagReportingAgent;\n+  @Mock\n+  private RoutingOptions routingOptions;\n+\n+  private MaximumLagFilter filter;\n+\n+  @Before\n+  public void setUp() {\n+    when(lagReportingAgent.getHostsPartitionLagInfo(eq(HOST),\n+        eq(QueryStateStoreId.of(APPLICATION_ID, STATE_STORE)), eq(PARTITION)))\n+        .thenReturn(Optional.of(LAG));\n+    when(lagReportingAgent.getHostsPartitionLagInfo(eq(HOST2),\n+        eq(QueryStateStoreId.of(APPLICATION_ID, STATE_STORE)), eq(PARTITION)))\n+        .thenReturn(Optional.of(LAG2));\n+  }\n+\n+\n+  @Test\n+  public void filter_shouldIncludeBelowThreshold() {\n+    // The max end offset is 15, so the lag for HOST is 12", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3f29c37b083521f11ec3896b0df116f171b6e847"}, "originalPosition": 53}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjE2MTY0OQ==", "bodyText": "nit: HOST1?", "url": "https://github.com/confluentinc/ksql/pull/4468#discussion_r376161649", "createdAt": "2020-02-07T00:45:08Z", "author": {"login": "vinothchandar"}, "path": "ksql-rest-app/src/test/java/io/confluent/ksql/rest/server/MaximumLagFilterTest.java", "diffHunk": "@@ -0,0 +1,109 @@\n+package io.confluent.ksql.rest.server;\n+\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertTrue;\n+import static org.mockito.Mockito.eq;\n+import static org.mockito.Mockito.when;\n+\n+import com.google.common.collect.ImmutableList;\n+import io.confluent.ksql.execution.streams.RoutingOptions;\n+import io.confluent.ksql.rest.entity.LagInfoEntity;\n+import io.confluent.ksql.rest.entity.QueryStateStoreId;\n+import io.confluent.ksql.util.KsqlHostInfo;\n+import java.util.List;\n+import java.util.Optional;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.mockito.Mock;\n+import org.mockito.junit.MockitoJUnitRunner;\n+\n+@RunWith(MockitoJUnitRunner.class)\n+public class MaximumLagFilterTest {\n+\n+  private static KsqlHostInfo HOST = new KsqlHostInfo(\"host\", 8088);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3f29c37b083521f11ec3896b0df116f171b6e847"}, "originalPosition": 24}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjE2MTczNQ==", "bodyText": "lol :) .. bear with me. LAG1?", "url": "https://github.com/confluentinc/ksql/pull/4468#discussion_r376161735", "createdAt": "2020-02-07T00:45:28Z", "author": {"login": "vinothchandar"}, "path": "ksql-rest-app/src/test/java/io/confluent/ksql/rest/server/MaximumLagFilterTest.java", "diffHunk": "@@ -0,0 +1,109 @@\n+package io.confluent.ksql.rest.server;\n+\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertTrue;\n+import static org.mockito.Mockito.eq;\n+import static org.mockito.Mockito.when;\n+\n+import com.google.common.collect.ImmutableList;\n+import io.confluent.ksql.execution.streams.RoutingOptions;\n+import io.confluent.ksql.rest.entity.LagInfoEntity;\n+import io.confluent.ksql.rest.entity.QueryStateStoreId;\n+import io.confluent.ksql.util.KsqlHostInfo;\n+import java.util.List;\n+import java.util.Optional;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.mockito.Mock;\n+import org.mockito.junit.MockitoJUnitRunner;\n+\n+@RunWith(MockitoJUnitRunner.class)\n+public class MaximumLagFilterTest {\n+\n+  private static KsqlHostInfo HOST = new KsqlHostInfo(\"host\", 8088);\n+  private static KsqlHostInfo HOST2 = new KsqlHostInfo(\"host2\", 8088);\n+  private static List<KsqlHostInfo> HOSTS = ImmutableList.of(HOST, HOST2);\n+  private static String APPLICATION_ID = \"app_id\";\n+  private static String STATE_STORE = \"state_store\";\n+  private static int PARTITION = 3;\n+  private static LagInfoEntity LAG = new LagInfoEntity(3, 12, 9);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3f29c37b083521f11ec3896b0df116f171b6e847"}, "originalPosition": 30}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjE2MzA0Nw==", "bodyText": "This object is useful for query time options more than server options. Maybe I can change the name?\n\nresponding here.. Good with this for now. API looks much cleaner with an interface", "url": "https://github.com/confluentinc/ksql/pull/4468#discussion_r376163047", "createdAt": "2020-02-07T00:50:17Z", "author": {"login": "vinothchandar"}, "path": "ksql-streams/src/main/java/io/confluent/ksql/execution/streams/RoutingOptions.java", "diffHunk": "@@ -0,0 +1,24 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.execution.streams;\n+\n+/**\n+ * These are options used for locating the host to retrieve data from.\n+ */\n+public interface RoutingOptions {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3f29c37b083521f11ec3896b0df116f171b6e847"}, "originalPosition": 21}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjE2NDQ4OQ==", "bodyText": "Even without a ranking interface.. given we place the activeHost first.. I think we are guaranteed to send to active if its alive and not restoring (i.e laggy)", "url": "https://github.com/confluentinc/ksql/pull/4468#discussion_r376164489", "createdAt": "2020-02-07T00:55:21Z", "author": {"login": "vinothchandar"}, "path": "ksql-streams/src/main/java/io/confluent/ksql/execution/streams/materialization/ks/KsLocator.java", "diffHunk": "@@ -81,18 +87,17 @@\n     final Set<HostInfo> standByHosts = metadata.getStandbyHosts();\n     LOG.debug(\"Before filtering: Active host {} , standby hosts {}\", activeHost, standByHosts);\n \n-    final Stream<KsqlHostInfo> active = Stream.of(asKsqlHost(activeHost));\n-    final Stream<KsqlHostInfo> standby = standByHosts\n-        .stream()\n-        .map(this::asKsqlHost);\n-    final Stream<KsqlHostInfo> hostStream = Stream.concat(active, standby);\n+    final List<KsqlHostInfo> allHosts = Stream.concat(Stream.of(activeHost), standByHosts.stream())", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3f29c37b083521f11ec3896b0df116f171b6e847"}, "originalPosition": 48}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU1MzAwOTUy", "url": "https://github.com/confluentinc/ksql/pull/4468#pullrequestreview-355300952", "createdAt": "2020-02-07T17:02:04Z", "commit": {"oid": "93d745dbbcd08e0028e53fc2ab2170ed488cd633"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c5477a4a9899201fbbfc2b6b89d092dea3e448c4", "author": {"user": {"login": "AlanConfluent", "name": "Alan Sheinberg"}}, "url": "https://github.com/confluentinc/ksql/commit/c5477a4a9899201fbbfc2b6b89d092dea3e448c4", "committedDate": "2020-02-07T20:30:44Z", "message": "feat: Adds a new RoutingFilter, MaxAllowedLagFilter that looks at offset lags"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "906306eceed6694b3012b218c50ed2830f70af3a", "author": {"user": {"login": "AlanConfluent", "name": "Alan Sheinberg"}}, "url": "https://github.com/confluentinc/ksql/commit/906306eceed6694b3012b218c50ed2830f70af3a", "committedDate": "2020-02-07T20:30:45Z", "message": "Change config name"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "44234f92d7b56812460598601fe1b6a739db02b1", "author": {"user": {"login": "AlanConfluent", "name": "Alan Sheinberg"}}, "url": "https://github.com/confluentinc/ksql/commit/44234f92d7b56812460598601fe1b6a739db02b1", "committedDate": "2020-02-07T20:30:45Z", "message": "Changes name to MaximimLagFilter"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0c33e57f3c2d265906207606011d711b300a31d4", "author": {"user": {"login": "AlanConfluent", "name": "Alan Sheinberg"}}, "url": "https://github.com/confluentinc/ksql/commit/0c33e57f3c2d265906207606011d711b300a31d4", "committedDate": "2020-02-07T20:30:45Z", "message": "Feedback"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c31cd20dc40c0fc9149967bb00f7d11e15d472cc", "author": {"user": {"login": "AlanConfluent", "name": "Alan Sheinberg"}}, "url": "https://github.com/confluentinc/ksql/commit/c31cd20dc40c0fc9149967bb00f7d11e15d472cc", "committedDate": "2020-02-07T20:30:45Z", "message": "More feedback"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "4c647f80bcc394f45d7bbc749057fea5ae28f114", "author": {"user": {"login": "AlanConfluent", "name": "Alan Sheinberg"}}, "url": "https://github.com/confluentinc/ksql/commit/4c647f80bcc394f45d7bbc749057fea5ae28f114", "committedDate": "2020-02-07T19:29:39Z", "message": "More feedback"}, "afterCommit": {"oid": "c31cd20dc40c0fc9149967bb00f7d11e15d472cc", "author": {"user": {"login": "AlanConfluent", "name": "Alan Sheinberg"}}, "url": "https://github.com/confluentinc/ksql/commit/c31cd20dc40c0fc9149967bb00f7d11e15d472cc", "committedDate": "2020-02-07T20:30:45Z", "message": "More feedback"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU1NDI0OTQz", "url": "https://github.com/confluentinc/ksql/pull/4468#pullrequestreview-355424943", "createdAt": "2020-02-07T20:42:51Z", "commit": {"oid": "c31cd20dc40c0fc9149967bb00f7d11e15d472cc"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wN1QyMDo0Mjo1MlrOFnJuDA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wN1QyMDo0NToyN1rOFnJx8Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjU5ODAyOA==", "bodyText": "Should this be LONG.MAX_VALUE?", "url": "https://github.com/confluentinc/ksql/pull/4468#discussion_r376598028", "createdAt": "2020-02-07T20:42:52Z", "author": {"login": "vinothchandar"}, "path": "ksql-common/src/main/java/io/confluent/ksql/util/KsqlConfig.java", "diffHunk": "@@ -182,6 +184,14 @@\n           + \"to ksql.streams.num.standby.replicas >= 1\";\n   public static final boolean KSQL_QUERY_PULL_ENABLE_STANDBY_READS_DEFAULT = false;\n \n+  public static final String KSQL_QUERY_PULL_MAX_ALLOWED_OFFSET_LAG_CONFIG =\n+      \"ksql.query.pull.max.allowed.offset.lag\";\n+  public static final Long KSQL_QUERY_PULL_MAX_ALLOWED_OFFSET_LAG_DEFAULT = 0L;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c31cd20dc40c0fc9149967bb00f7d11e15d472cc"}, "originalPosition": 15}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjU5OTAyNQ==", "bodyText": "0 means, we don't query standbys at all (they will always have non-zero lag right).. So someone enabling standby.reads will be forced to also set this, to issue those queries.. I can imagine a lot of tickets we get where users complain standby routing is not working etc..\nmight be better to err on the other side? and as users become concerned about stale values, they will reach out and we point at this config.. wdyt", "url": "https://github.com/confluentinc/ksql/pull/4468#discussion_r376599025", "createdAt": "2020-02-07T20:45:27Z", "author": {"login": "vinothchandar"}, "path": "ksql-common/src/main/java/io/confluent/ksql/util/KsqlConfig.java", "diffHunk": "@@ -182,6 +184,14 @@\n           + \"to ksql.streams.num.standby.replicas >= 1\";\n   public static final boolean KSQL_QUERY_PULL_ENABLE_STANDBY_READS_DEFAULT = false;\n \n+  public static final String KSQL_QUERY_PULL_MAX_ALLOWED_OFFSET_LAG_CONFIG =\n+      \"ksql.query.pull.max.allowed.offset.lag\";\n+  public static final Long KSQL_QUERY_PULL_MAX_ALLOWED_OFFSET_LAG_DEFAULT = 0L;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjU5ODAyOA=="}, "originalCommit": {"oid": "c31cd20dc40c0fc9149967bb00f7d11e15d472cc"}, "originalPosition": 15}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d5222a6fd290d86fe248a73665ac1d2ef35fa4e5", "author": {"user": {"login": "AlanConfluent", "name": "Alan Sheinberg"}}, "url": "https://github.com/confluentinc/ksql/commit/d5222a6fd290d86fe248a73665ac1d2ef35fa4e5", "committedDate": "2020-02-08T00:22:35Z", "message": "Fixes tests"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4952, "cost": 1, "resetAt": "2021-11-01T13:51:04Z"}}}